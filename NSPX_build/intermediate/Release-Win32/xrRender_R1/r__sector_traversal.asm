; Listing generated by Microsoft (R) Optimizing Compiler Version 19.29.30146.0 

	TITLE	i:\vitalya\mine\nsprojectx\nspx_build\intermediate\release-win32\xrrender_r1\r__sector_traversal.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	??_C@_06JAELEMPN@portal@			; `string'
EXTRN	__imp_?Render@CBackend@@QAEXW4_D3DPRIMITIVETYPE@@II@Z:PROC
EXTRN	__imp_?stride@resptrcode_geom@@QBEIXZ:PROC
;	COMDAT ??_C@_06JAELEMPN@portal@
CONST	SEGMENT
??_C@_06JAELEMPN@portal@ DB 'portal', 00H		; `string'
?_Fake_alloc@std@@3U_Fake_allocator@1@B	ORG $+1		; std::_Fake_alloc
PUBLIC	?color_rgba_f@@YAIMMMM@Z			; color_rgba_f
PUBLIC	?color_argb_f@@YAIMMMM@Z			; color_argb_f
PUBLIC	?subst_alpha@@YAIII@Z				; subst_alpha
PUBLIC	?set@L@FVF@@QAEXABU?$_vector3@M@@I@Z		; FVF::L::set
PUBLIC	??$swap@PAVCPortal@@$0A@@std@@YAXAAPAVCPortal@@0@Z ; std::swap<CPortal *,0>
PUBLIC	??$_Swap_adl@PAVCPortal@@@std@@YAXAAPAVCPortal@@0@Z ; std::_Swap_adl<CPortal *>
PUBLIC	??$addressof@U?$pair@PAVCPortal@@M@std@@@std@@YAPAU?$pair@PAVCPortal@@M@0@AAU10@@Z ; std::addressof<std::pair<CPortal *,float> >
PUBLIC	?swap@?$pair@PAVCPortal@@M@std@@QAEXAAU12@@Z	; std::pair<CPortal *,float>::swap
PUBLIC	??$forward@AAPAU?$pair@PAVCPortal@@M@std@@@std@@YAAAPAU?$pair@PAVCPortal@@M@0@AAPAU10@@Z ; std::forward<std::pair<CPortal *,float> * &>
PUBLIC	??$swap@PAVCPortal@@M$0A@@std@@YAXAAU?$pair@PAVCPortal@@M@0@0@Z ; std::swap<CPortal *,float,0>
PUBLIC	??$_Med3_unchecked@PAU?$pair@PAVCPortal@@M@std@@P6A_NABU12@0@Z@std@@YAXPAU?$pair@PAVCPortal@@M@0@00P6A_NABU10@1@Z@Z ; std::_Med3_unchecked<std::pair<CPortal *,float> *,bool (__cdecl*)(std::pair<CPortal *,float> const &,std::pair<CPortal *,float> const &)>
PUBLIC	??$_Pop_heap_hole_unchecked@PAU?$pair@PAVCPortal@@M@std@@U12@P6A_NABU12@0@Z@std@@YAXPAU?$pair@PAVCPortal@@M@0@00$$QAU10@P6A_NABU10@2@Z@Z ; std::_Pop_heap_hole_unchecked<std::pair<CPortal *,float> *,std::pair<CPortal *,float>,bool (__cdecl*)(std::pair<CPortal *,float> const &,std::pair<CPortal *,float> const &)>
PUBLIC	??$_Push_heap_by_index@PAU?$pair@PAVCPortal@@M@std@@U12@P6A_NABU12@0@Z@std@@YAXPAU?$pair@PAVCPortal@@M@0@HH$$QAU10@P6A_NABU10@2@Z@Z ; std::_Push_heap_by_index<std::pair<CPortal *,float> *,std::pair<CPortal *,float>,bool (__cdecl*)(std::pair<CPortal *,float> const &,std::pair<CPortal *,float> const &)>
PUBLIC	??$?0AAPAU?$pair@PAVCPortal@@M@std@@AAPAU01@$0A@@?$pair@PAU?$pair@PAVCPortal@@M@std@@PAU12@@std@@QAE@AAPAU?$pair@PAVCPortal@@M@1@0@Z ; std::pair<std::pair<CPortal *,float> *,std::pair<CPortal *,float> *>::pair<std::pair<CPortal *,float> *,std::pair<CPortal *,float> *><std::pair<CPortal *,float> * &,std::pair<CPortal *,float> * &,0>
PUBLIC	??$iter_swap@PAU?$pair@PAVCPortal@@M@std@@PAU12@@std@@YAXPAU?$pair@PAVCPortal@@M@0@0@Z ; std::iter_swap<std::pair<CPortal *,float> *,std::pair<CPortal *,float> *>
PUBLIC	??$_Next_iter@PAU?$pair@PAVCPortal@@M@std@@@std@@YAPAU?$pair@PAVCPortal@@M@0@PAU10@@Z ; std::_Next_iter<std::pair<CPortal *,float> *>
PUBLIC	??$_Guess_median_unchecked@PAU?$pair@PAVCPortal@@M@std@@P6A_NABU12@0@Z@std@@YAXPAU?$pair@PAVCPortal@@M@0@00P6A_NABU10@1@Z@Z ; std::_Guess_median_unchecked<std::pair<CPortal *,float> *,bool (__cdecl*)(std::pair<CPortal *,float> const &,std::pair<CPortal *,float> const &)>
PUBLIC	??$_Prev_iter@PAU?$pair@PAVCPortal@@M@std@@@std@@YAPAU?$pair@PAVCPortal@@M@0@PAU10@@Z ; std::_Prev_iter<std::pair<CPortal *,float> *>
PUBLIC	??$_Pop_heap_unchecked@PAU?$pair@PAVCPortal@@M@std@@P6A_NABU12@0@Z@std@@YAXPAU?$pair@PAVCPortal@@M@0@0P6A_NABU10@1@Z@Z ; std::_Pop_heap_unchecked<std::pair<CPortal *,float> *,bool (__cdecl*)(std::pair<CPortal *,float> const &,std::pair<CPortal *,float> const &)>
PUBLIC	??$_Pop_heap_hole_by_index@PAU?$pair@PAVCPortal@@M@std@@U12@P6A_NABU12@0@Z@std@@YAXPAU?$pair@PAVCPortal@@M@0@HH$$QAU10@P6A_NABU10@2@Z@Z ; std::_Pop_heap_hole_by_index<std::pair<CPortal *,float> *,std::pair<CPortal *,float>,bool (__cdecl*)(std::pair<CPortal *,float> const &,std::pair<CPortal *,float> const &)>
PUBLIC	??$_Move_backward_unchecked@PAU?$pair@PAVCPortal@@M@std@@PAU12@@std@@YAPAU?$pair@PAVCPortal@@M@0@PAU10@00@Z ; std::_Move_backward_unchecked<std::pair<CPortal *,float> *,std::pair<CPortal *,float> *>
PUBLIC	??$?4U?$pair@PAVCPortal@@M@std@@$0A@@?$pair@PAVCPortal@@M@std@@QAEAAU01@$$QAU01@@Z ; std::pair<CPortal *,float>::operator=<std::pair<CPortal *,float>,0>
PUBLIC	??$_Destroy_in_place@PAU?$pair@PAVCPortal@@M@std@@@std@@YAXAAPAU?$pair@PAVCPortal@@M@0@@Z ; std::_Destroy_in_place<std::pair<CPortal *,float> *>
PUBLIC	??$_Partition_by_median_guess_unchecked@PAU?$pair@PAVCPortal@@M@std@@P6A_NABU12@0@Z@std@@YA?AU?$pair@PAU?$pair@PAVCPortal@@M@std@@PAU12@@0@PAU?$pair@PAVCPortal@@M@0@0P6A_NABU20@1@Z@Z ; std::_Partition_by_median_guess_unchecked<std::pair<CPortal *,float> *,bool (__cdecl*)(std::pair<CPortal *,float> const &,std::pair<CPortal *,float> const &)>
PUBLIC	??$_Sort_heap_unchecked@PAU?$pair@PAVCPortal@@M@std@@P6A_NABU12@0@Z@std@@YAXPAU?$pair@PAVCPortal@@M@0@0P6A_NABU10@1@Z@Z ; std::_Sort_heap_unchecked<std::pair<CPortal *,float> *,bool (__cdecl*)(std::pair<CPortal *,float> const &,std::pair<CPortal *,float> const &)>
PUBLIC	??$_Make_heap_unchecked@PAU?$pair@PAVCPortal@@M@std@@P6A_NABU12@0@Z@std@@YAXPAU?$pair@PAVCPortal@@M@0@0P6A_NABU10@1@Z@Z ; std::_Make_heap_unchecked<std::pair<CPortal *,float> *,bool (__cdecl*)(std::pair<CPortal *,float> const &,std::pair<CPortal *,float> const &)>
PUBLIC	??$_Insertion_sort_unchecked@PAU?$pair@PAVCPortal@@M@std@@P6A_NABU12@0@Z@std@@YAPAU?$pair@PAVCPortal@@M@0@QAU10@0P6A_NABU10@1@Z@Z ; std::_Insertion_sort_unchecked<std::pair<CPortal *,float> *,bool (__cdecl*)(std::pair<CPortal *,float> const &,std::pair<CPortal *,float> const &)>
PUBLIC	??$forward@AAPAVCPortal@@@std@@YAAAPAVCPortal@@AAPAV1@@Z ; std::forward<CPortal * &>
PUBLIC	?destroy@?$xalloc@U?$pair@PAVCPortal@@M@std@@@@QAEXPAU?$pair@PAVCPortal@@M@std@@@Z ; xalloc<std::pair<CPortal *,float> >::destroy
PUBLIC	??$_Emplace_back@U?$pair@PAVCPortal@@M@std@@@?$_Uninitialized_backout_al@V?$xalloc@U?$pair@PAVCPortal@@M@std@@@@@std@@QAEX$$QAU?$pair@PAVCPortal@@M@1@@Z ; std::_Uninitialized_backout_al<xalloc<std::pair<CPortal *,float> > >::_Emplace_back<std::pair<CPortal *,float> >
PUBLIC	??$destroy@U?$pair@PAVCPortal@@M@std@@@?$_Normal_allocator_traits@V?$xalloc@U?$pair@PAVCPortal@@M@std@@@@@std@@SAXAAV?$xalloc@U?$pair@PAVCPortal@@M@std@@@@PAU?$pair@PAVCPortal@@M@1@@Z ; std::_Normal_allocator_traits<xalloc<std::pair<CPortal *,float> > >::destroy<std::pair<CPortal *,float> >
PUBLIC	??$_Sort_unchecked@PAU?$pair@PAVCPortal@@M@std@@P6A_NABU12@0@Z@std@@YAXPAU?$pair@PAVCPortal@@M@0@0HP6A_NABU10@1@Z@Z ; std::_Sort_unchecked<std::pair<CPortal *,float> *,bool (__cdecl*)(std::pair<CPortal *,float> const &,std::pair<CPortal *,float> const &)>
PUBLIC	??$_Pass_fn@P6A_NABU?$pair@PAVCPortal@@M@std@@0@Z$0A@@std@@YAP6A_NABU?$pair@PAVCPortal@@M@0@0@ZP6A_N00@Z@Z ; std::_Pass_fn<bool (__cdecl*)(std::pair<CPortal *,float> const &,std::pair<CPortal *,float> const &),0>
PUBLIC	??$_Adl_verify_range@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@PAVCPortal@@M@std@@@std@@@std@@@std@@V12@@std@@YAXABV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@PAVCPortal@@M@std@@@std@@@std@@@0@0@Z ; std::_Adl_verify_range<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::pair<CPortal *,float> > > >,std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::pair<CPortal *,float> > > > >
PUBLIC	??$?0AAPAVCPortal@@AAM$0A@@?$pair@PAVCPortal@@M@std@@QAE@AAPAVCPortal@@AAM@Z ; std::pair<CPortal *,float>::pair<CPortal *,float><CPortal * &,float &,0>
PUBLIC	??0?$xalloc@PAVIRender_Sector@@@@QAE@XZ		; xalloc<IRender_Sector *>::xalloc<IRender_Sector *>
PUBLIC	??0?$_Vector_val@U?$_Simple_types@PAVIRender_Sector@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<IRender_Sector *> >::_Vector_val<std::_Simple_types<IRender_Sector *> >
PUBLIC	??0?$xalloc@U?$pair@PAVCPortal@@M@std@@@@QAE@XZ	; xalloc<std::pair<CPortal *,float> >::xalloc<std::pair<CPortal *,float> >
PUBLIC	?construct@?$xalloc@U?$pair@PAVCPortal@@M@std@@@@QAEXPAU?$pair@PAVCPortal@@M@std@@ABU23@@Z ; xalloc<std::pair<CPortal *,float> >::construct
PUBLIC	?_Umove@?$vector@U?$pair@PAVCPortal@@M@std@@V?$xalloc@U?$pair@PAVCPortal@@M@std@@@@@std@@AAEPAU?$pair@PAVCPortal@@M@2@PAU32@00@Z ; std::vector<std::pair<CPortal *,float>,xalloc<std::pair<CPortal *,float> > >::_Umove
PUBLIC	?_Calculate_growth@?$vector@U?$pair@PAVCPortal@@M@std@@V?$xalloc@U?$pair@PAVCPortal@@M@std@@@@@std@@ABEII@Z ; std::vector<std::pair<CPortal *,float>,xalloc<std::pair<CPortal *,float> > >::_Calculate_growth
PUBLIC	??0?$_Vector_val@U?$_Simple_types@U?$pair@PAVCPortal@@M@std@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<std::pair<CPortal *,float> > >::_Vector_val<std::_Simple_types<std::pair<CPortal *,float> > >
PUBLIC	?_Unwrapped@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@PAVCPortal@@M@std@@@std@@@std@@@std@@QBEPAU?$pair@PAVCPortal@@M@2@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::pair<CPortal *,float> > > >::_Unwrapped
PUBLIC	??0?$_Uninitialized_backout_al@V?$xalloc@U?$pair@PAVCPortal@@M@std@@@@@std@@QAE@PAU?$pair@PAVCPortal@@M@1@AAV?$xalloc@U?$pair@PAVCPortal@@M@std@@@@@Z ; std::_Uninitialized_backout_al<xalloc<std::pair<CPortal *,float> > >::_Uninitialized_backout_al<xalloc<std::pair<CPortal *,float> > >
PUBLIC	??1?$_Uninitialized_backout_al@V?$xalloc@U?$pair@PAVCPortal@@M@std@@@@@std@@QAE@XZ ; std::_Uninitialized_backout_al<xalloc<std::pair<CPortal *,float> > >::~_Uninitialized_backout_al<xalloc<std::pair<CPortal *,float> > >
PUBLIC	?_Release@?$_Uninitialized_backout_al@V?$xalloc@U?$pair@PAVCPortal@@M@std@@@@@std@@QAEPAU?$pair@PAVCPortal@@M@2@XZ ; std::_Uninitialized_backout_al<xalloc<std::pair<CPortal *,float> > >::_Release
PUBLIC	??$_Get_unwrapped@ABQAU?$pair@PAVCPortal@@M@std@@@std@@YA?A_TABQAU?$pair@PAVCPortal@@M@0@@Z ; std::_Get_unwrapped<std::pair<CPortal *,float> * const &>
PUBLIC	??$_Uninitialized_move@PAU?$pair@PAVCPortal@@M@std@@V?$xalloc@U?$pair@PAVCPortal@@M@std@@@@@std@@YAPAU?$pair@PAVCPortal@@M@0@QAU10@0PAU10@AAV?$xalloc@U?$pair@PAVCPortal@@M@std@@@@@Z ; std::_Uninitialized_move<std::pair<CPortal *,float> *,xalloc<std::pair<CPortal *,float> > >
PUBLIC	??$xr_alloc@U?$pair@PAVCPortal@@M@std@@@@YAPAU?$pair@PAVCPortal@@M@std@@I@Z ; xr_alloc<std::pair<CPortal *,float> >
PUBLIC	??$xr_free@U?$pair@PAVCPortal@@M@std@@@@YAXAAPAU?$pair@PAVCPortal@@M@std@@@Z ; xr_free<std::pair<CPortal *,float> >
PUBLIC	??$_Destroy_range@V?$xalloc@U?$pair@PAVCPortal@@M@std@@@@@std@@YAXPAU?$pair@PAVCPortal@@M@0@QAU10@AAV?$xalloc@U?$pair@PAVCPortal@@M@std@@@@@Z ; std::_Destroy_range<xalloc<std::pair<CPortal *,float> > >
PUBLIC	??$addressof@V?$_Vector_val@U?$_Simple_types@U_scissor@@@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@U_scissor@@@std@@@0@AAV10@@Z ; std::addressof<std::_Vector_val<std::_Simple_types<_scissor> > >
PUBLIC	??$?0$$V@?$_Compressed_pair@V?$xalloc@PAVIRender_Sector@@@@V?$_Vector_val@U?$_Simple_types@PAVIRender_Sector@@@std@@@std@@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<xalloc<IRender_Sector *>,std::_Vector_val<std::_Simple_types<IRender_Sector *> >,1>::_Compressed_pair<xalloc<IRender_Sector *>,std::_Vector_val<std::_Simple_types<IRender_Sector *> >,1><>
PUBLIC	??$?0$$V@?$_Compressed_pair@V?$xalloc@U?$pair@PAVCPortal@@M@std@@@@V?$_Vector_val@U?$_Simple_types@U?$pair@PAVCPortal@@M@std@@@std@@@std@@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<xalloc<std::pair<CPortal *,float> >,std::_Vector_val<std::_Simple_types<std::pair<CPortal *,float> > >,1>::_Compressed_pair<xalloc<std::pair<CPortal *,float> >,std::_Vector_val<std::_Simple_types<std::pair<CPortal *,float> > >,1><>
PUBLIC	??$_Emplace_reallocate@U?$pair@PAVCPortal@@M@std@@@?$vector@U?$pair@PAVCPortal@@M@std@@V?$xalloc@U?$pair@PAVCPortal@@M@std@@@@@std@@QAEPAU?$pair@PAVCPortal@@M@1@QAU21@$$QAU21@@Z ; std::vector<std::pair<CPortal *,float>,xalloc<std::pair<CPortal *,float> > >::_Emplace_reallocate<std::pair<CPortal *,float> >
PUBLIC	??$construct@U?$pair@PAVCPortal@@M@std@@U12@@?$_Normal_allocator_traits@V?$xalloc@U?$pair@PAVCPortal@@M@std@@@@@std@@SAXAAV?$xalloc@U?$pair@PAVCPortal@@M@std@@@@PAU?$pair@PAVCPortal@@M@1@$$QAU31@@Z ; std::_Normal_allocator_traits<xalloc<std::pair<CPortal *,float> > >::construct<std::pair<CPortal *,float>,std::pair<CPortal *,float> >
PUBLIC	??$_Unfancy@U?$pair@PAVCPortal@@M@std@@@std@@YAPAU?$pair@PAVCPortal@@M@0@PAU10@@Z ; std::_Unfancy<std::pair<CPortal *,float> >
PUBLIC	??$forward@U?$pair@PAVCPortal@@M@std@@@std@@YA$$QAU?$pair@PAVCPortal@@M@0@AAU10@@Z ; std::forward<std::pair<CPortal *,float> >
PUBLIC	??$move@AAU?$pair@PAVCPortal@@M@std@@@std@@YA$$QAU?$pair@PAVCPortal@@M@0@AAU10@@Z ; std::move<std::pair<CPortal *,float> &>
PUBLIC	??$addressof@V?$_Vector_val@U?$_Simple_types@U?$pair@PAVCPortal@@M@std@@@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@U?$pair@PAVCPortal@@M@std@@@std@@@0@AAV10@@Z ; std::addressof<std::_Vector_val<std::_Simple_types<std::pair<CPortal *,float> > > >
PUBLIC	??$_Get_unwrapped@ABV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@PAVCPortal@@M@std@@@std@@@std@@@std@@@std@@YA?A_TABV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@PAVCPortal@@M@std@@@std@@@std@@@0@@Z ; std::_Get_unwrapped<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::pair<CPortal *,float> > > > const &>
PUBLIC	??$sort@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@PAVCPortal@@M@std@@@std@@@std@@@std@@P6A_NABU?$pair@PAVCPortal@@M@2@0@Z@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@PAVCPortal@@M@std@@@std@@@std@@@0@0P6A_NABU?$pair@PAVCPortal@@M@0@1@Z@Z ; std::sort<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::pair<CPortal *,float> > > >,bool (__cdecl*)(std::pair<CPortal *,float> const &,std::pair<CPortal *,float> const &)>
PUBLIC	??$mk_pair@PAVCPortal@@M@@YA?AU?$pair@PAVCPortal@@M@std@@PAVCPortal@@M@Z ; mk_pair<CPortal *,float>
PUBLIC	?_Verify_offset@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@PAVCPortal@@M@std@@@std@@@std@@@std@@QBEXH@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::pair<CPortal *,float> > > >::_Verify_offset
PUBLIC	?_Verify_offset@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U_scissor@@@std@@@std@@@std@@QBEXH@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<_scissor> > >::_Verify_offset
PUBLIC	?max_size@?$xalloc@U?$pair@PAVCPortal@@M@std@@@@QBEIXZ ; xalloc<std::pair<CPortal *,float> >::max_size
PUBLIC	?_Umove_if_noexcept1@?$vector@U?$pair@PAVCPortal@@M@std@@V?$xalloc@U?$pair@PAVCPortal@@M@std@@@@@std@@AAEXPAU?$pair@PAVCPortal@@M@2@00U?$integral_constant@_N$00@2@@Z ; std::vector<std::pair<CPortal *,float>,xalloc<std::pair<CPortal *,float> > >::_Umove_if_noexcept1
PUBLIC	?_Get_first@?$_Compressed_pair@V?$xalloc@U?$pair@PAVCPortal@@M@std@@@@V?$_Vector_val@U?$_Simple_types@U?$pair@PAVCPortal@@M@std@@@std@@@std@@$00@std@@QBEABV?$xalloc@U?$pair@PAVCPortal@@M@std@@@@XZ ; std::_Compressed_pair<xalloc<std::pair<CPortal *,float> >,std::_Vector_val<std::_Simple_types<std::pair<CPortal *,float> > >,1>::_Get_first
PUBLIC	??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@PAVCPortal@@M@std@@@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::pair<CPortal *,float> > > >::operator+=
PUBLIC	??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U_scissor@@@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<_scissor> > >::operator+=
PUBLIC	?min@?$_vector2@M@@QAEAAU1@ABU1@@Z		; _vector2<float>::min
PUBLIC	?max@?$_vector2@M@@QAEAAU1@ABU1@@Z		; _vector2<float>::max
PUBLIC	?clear@?$vector@PAVIRender_Sector@@V?$xalloc@PAVIRender_Sector@@@@@std@@QAEXXZ ; std::vector<IRender_Sector *,xalloc<IRender_Sector *> >::clear
PUBLIC	?allocate@?$xalloc@U?$pair@PAVCPortal@@M@std@@@@QBEPAU?$pair@PAVCPortal@@M@std@@IPBX@Z ; xalloc<std::pair<CPortal *,float> >::allocate
PUBLIC	?deallocate@?$xalloc@U?$pair@PAVCPortal@@M@std@@@@QBEXPAU?$pair@PAVCPortal@@M@std@@I@Z ; xalloc<std::pair<CPortal *,float> >::deallocate
PUBLIC	?max_size@?$_Normal_allocator_traits@V?$xalloc@U?$pair@PAVCPortal@@M@std@@@@@std@@SAIABV?$xalloc@U?$pair@PAVCPortal@@M@std@@@@@Z ; std::_Normal_allocator_traits<xalloc<std::pair<CPortal *,float> > >::max_size
PUBLIC	?clear@?$vector@U?$pair@PAVCPortal@@M@std@@V?$xalloc@U?$pair@PAVCPortal@@M@std@@@@@std@@QAEXXZ ; std::vector<std::pair<CPortal *,float>,xalloc<std::pair<CPortal *,float> > >::clear
PUBLIC	?_Umove_if_noexcept@?$vector@U?$pair@PAVCPortal@@M@std@@V?$xalloc@U?$pair@PAVCPortal@@M@std@@@@@std@@AAEXPAU?$pair@PAVCPortal@@M@2@00@Z ; std::vector<std::pair<CPortal *,float>,xalloc<std::pair<CPortal *,float> > >::_Umove_if_noexcept
PUBLIC	?_Destroy@?$vector@U?$pair@PAVCPortal@@M@std@@V?$xalloc@U?$pair@PAVCPortal@@M@std@@@@@std@@AAEXPAU?$pair@PAVCPortal@@M@2@0@Z ; std::vector<std::pair<CPortal *,float>,xalloc<std::pair<CPortal *,float> > >::_Destroy
PUBLIC	?_Change_array@?$vector@U?$pair@PAVCPortal@@M@std@@V?$xalloc@U?$pair@PAVCPortal@@M@std@@@@@std@@AAEXQAU?$pair@PAVCPortal@@M@2@II@Z ; std::vector<std::pair<CPortal *,float>,xalloc<std::pair<CPortal *,float> > >::_Change_array
PUBLIC	?_Getal@?$vector@U?$pair@PAVCPortal@@M@std@@V?$xalloc@U?$pair@PAVCPortal@@M@std@@@@@std@@ABEABV?$xalloc@U?$pair@PAVCPortal@@M@std@@@@XZ ; std::vector<std::pair<CPortal *,float>,xalloc<std::pair<CPortal *,float> > >::_Getal
PUBLIC	?_Get_first@?$_Compressed_pair@V?$xalloc@U?$pair@PAVCPortal@@M@std@@@@V?$_Vector_val@U?$_Simple_types@U?$pair@PAVCPortal@@M@std@@@std@@@std@@$00@std@@QAEAAV?$xalloc@U?$pair@PAVCPortal@@M@std@@@@XZ ; std::_Compressed_pair<xalloc<std::pair<CPortal *,float> >,std::_Vector_val<std::_Simple_types<std::pair<CPortal *,float> > >,1>::_Get_first
PUBLIC	??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@PAVCPortal@@M@std@@@std@@@std@@@std@@QBEABU?$pair@PAVCPortal@@M@1@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::pair<CPortal *,float> > > >::operator*
PUBLIC	??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@PAVCPortal@@M@std@@@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::pair<CPortal *,float> > > >::operator+=
PUBLIC	??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U_scissor@@@std@@@std@@@std@@QAE@PAU_scissor@@PBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<_scissor> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<_scissor> > >
PUBLIC	??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U_scissor@@@std@@@std@@@std@@QBEABU_scissor@@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<_scissor> > >::operator*
PUBLIC	??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U_scissor@@@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<_scissor> > >::operator+=
PUBLIC	??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U_scissor@@@std@@@std@@@std@@QAE@PAU_scissor@@PBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<_scissor> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<_scissor> > >
PUBLIC	?modify@?$_box2@M@@QAEAAV1@ABU?$_vector2@M@@@Z	; _box2<float>::modify
PUBLIC	?begin@?$vector@U_scissor@@V?$xalloc@U_scissor@@@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U_scissor@@@std@@@std@@@2@XZ ; std::vector<_scissor,xalloc<_scissor> >::begin
PUBLIC	?size@?$vector@U_scissor@@V?$xalloc@U_scissor@@@@@std@@QBEIXZ ; std::vector<_scissor,xalloc<_scissor> >::size
PUBLIC	??0?$vector@PAVIRender_Sector@@V?$xalloc@PAVIRender_Sector@@@@@std@@QAE@XZ ; std::vector<IRender_Sector *,xalloc<IRender_Sector *> >::vector<IRender_Sector *,xalloc<IRender_Sector *> >
PUBLIC	?_Tidy@?$vector@PAVIRender_Sector@@V?$xalloc@PAVIRender_Sector@@@@@std@@AAEXXZ ; std::vector<IRender_Sector *,xalloc<IRender_Sector *> >::_Tidy
PUBLIC	?clear_and_free@?$xr_vector@PAVIRender_Sector@@V?$xalloc@PAVIRender_Sector@@@@@@QAEXXZ ; xr_vector<IRender_Sector *,xalloc<IRender_Sector *> >::clear_and_free
PUBLIC	??0?$vector@U?$pair@PAVCPortal@@M@std@@V?$xalloc@U?$pair@PAVCPortal@@M@std@@@@@std@@QAE@XZ ; std::vector<std::pair<CPortal *,float>,xalloc<std::pair<CPortal *,float> > >::vector<std::pair<CPortal *,float>,xalloc<std::pair<CPortal *,float> > >
PUBLIC	?_Reallocate_exactly@?$vector@U?$pair@PAVCPortal@@M@std@@V?$xalloc@U?$pair@PAVCPortal@@M@std@@@@@std@@AAEXI@Z ; std::vector<std::pair<CPortal *,float>,xalloc<std::pair<CPortal *,float> > >::_Reallocate_exactly
PUBLIC	?size@?$vector@U?$pair@PAVCPortal@@M@std@@V?$xalloc@U?$pair@PAVCPortal@@M@std@@@@@std@@QBEIXZ ; std::vector<std::pair<CPortal *,float>,xalloc<std::pair<CPortal *,float> > >::size
PUBLIC	?max_size@?$vector@U?$pair@PAVCPortal@@M@std@@V?$xalloc@U?$pair@PAVCPortal@@M@std@@@@@std@@QBEIXZ ; std::vector<std::pair<CPortal *,float>,xalloc<std::pair<CPortal *,float> > >::max_size
PUBLIC	?capacity@?$vector@U?$pair@PAVCPortal@@M@std@@V?$xalloc@U?$pair@PAVCPortal@@M@std@@@@@std@@QBEIXZ ; std::vector<std::pair<CPortal *,float>,xalloc<std::pair<CPortal *,float> > >::capacity
PUBLIC	?_Tidy@?$vector@U?$pair@PAVCPortal@@M@std@@V?$xalloc@U?$pair@PAVCPortal@@M@std@@@@@std@@AAEXXZ ; std::vector<std::pair<CPortal *,float>,xalloc<std::pair<CPortal *,float> > >::_Tidy
PUBLIC	?_Xlength@?$vector@U?$pair@PAVCPortal@@M@std@@V?$xalloc@U?$pair@PAVCPortal@@M@std@@@@@std@@CAXXZ ; std::vector<std::pair<CPortal *,float>,xalloc<std::pair<CPortal *,float> > >::_Xlength
PUBLIC	?_Orphan_range@?$vector@U?$pair@PAVCPortal@@M@std@@V?$xalloc@U?$pair@PAVCPortal@@M@std@@@@@std@@ABEXPAU?$pair@PAVCPortal@@M@2@0@Z ; std::vector<std::pair<CPortal *,float>,xalloc<std::pair<CPortal *,float> > >::_Orphan_range
PUBLIC	?_Getal@?$vector@U?$pair@PAVCPortal@@M@std@@V?$xalloc@U?$pair@PAVCPortal@@M@std@@@@@std@@AAEAAV?$xalloc@U?$pair@PAVCPortal@@M@std@@@@XZ ; std::vector<std::pair<CPortal *,float>,xalloc<std::pair<CPortal *,float> > >::_Getal
PUBLIC	?clear_and_free@?$xr_vector@U?$pair@PAVCPortal@@M@std@@V?$xalloc@U?$pair@PAVCPortal@@M@std@@@@@@QAEXXZ ; xr_vector<std::pair<CPortal *,float>,xalloc<std::pair<CPortal *,float> > >::clear_and_free
PUBLIC	??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@PAVCPortal@@M@std@@@std@@@std@@@std@@QAE@PAU?$pair@PAVCPortal@@M@1@PBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::pair<CPortal *,float> > > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::pair<CPortal *,float> > > >
PUBLIC	??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@PAVCPortal@@M@std@@@std@@@std@@@std@@QBEAAU?$pair@PAVCPortal@@M@1@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::pair<CPortal *,float> > > >::operator*
PUBLIC	??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@PAVCPortal@@M@std@@@std@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::pair<CPortal *,float> > > >::operator+
PUBLIC	??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U_scissor@@@std@@@std@@@std@@QBEAAU_scissor@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<_scissor> > >::operator*
PUBLIC	??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U_scissor@@@std@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<_scissor> > >::operator+
PUBLIC	??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@PAVCPortal@@M@std@@@std@@@std@@@std@@QAE@PAU?$pair@PAVCPortal@@M@1@PBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::pair<CPortal *,float> > > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::pair<CPortal *,float> > > >
PUBLIC	?set@?$_box2@M@@QAEAAV1@MMMM@Z			; _box2<float>::set
PUBLIC	?merge@?$_box2@M@@QAEAAV1@ABV1@@Z		; _box2<float>::merge
PUBLIC	?size@?$xr_vector@U_scissor@@V?$xalloc@U_scissor@@@@@@QBEIXZ ; xr_vector<_scissor,xalloc<_scissor> >::size
PUBLIC	??A?$xr_vector@U_scissor@@V?$xalloc@U_scissor@@@@@@QAEAAU_scissor@@I@Z ; xr_vector<_scissor,xalloc<_scissor> >::operator[]
PUBLIC	??1?$vector@PAVIRender_Sector@@V?$xalloc@PAVIRender_Sector@@@@@std@@QAE@XZ ; std::vector<IRender_Sector *,xalloc<IRender_Sector *> >::~vector<IRender_Sector *,xalloc<IRender_Sector *> >
PUBLIC	??0?$xr_vector@PAVIRender_Sector@@V?$xalloc@PAVIRender_Sector@@@@@@QAE@XZ ; xr_vector<IRender_Sector *,xalloc<IRender_Sector *> >::xr_vector<IRender_Sector *,xalloc<IRender_Sector *> >
PUBLIC	?clear@?$xr_vector@PAVIRender_Sector@@V?$xalloc@PAVIRender_Sector@@@@@@QAEXXZ ; xr_vector<IRender_Sector *,xalloc<IRender_Sector *> >::clear
PUBLIC	??1?$vector@U?$pair@PAVCPortal@@M@std@@V?$xalloc@U?$pair@PAVCPortal@@M@std@@@@@std@@QAE@XZ ; std::vector<std::pair<CPortal *,float>,xalloc<std::pair<CPortal *,float> > >::~vector<std::pair<CPortal *,float>,xalloc<std::pair<CPortal *,float> > >
PUBLIC	??$_Emplace_back_with_unused_capacity@U?$pair@PAVCPortal@@M@std@@@?$vector@U?$pair@PAVCPortal@@M@std@@V?$xalloc@U?$pair@PAVCPortal@@M@std@@@@@std@@AAE?A_T$$QAU?$pair@PAVCPortal@@M@1@@Z ; std::vector<std::pair<CPortal *,float>,xalloc<std::pair<CPortal *,float> > >::_Emplace_back_with_unused_capacity<std::pair<CPortal *,float> >
PUBLIC	??$emplace_back@U?$pair@PAVCPortal@@M@std@@@?$vector@U?$pair@PAVCPortal@@M@std@@V?$xalloc@U?$pair@PAVCPortal@@M@std@@@@@std@@QAE?A_T$$QAU?$pair@PAVCPortal@@M@1@@Z ; std::vector<std::pair<CPortal *,float>,xalloc<std::pair<CPortal *,float> > >::emplace_back<std::pair<CPortal *,float> >
PUBLIC	?push_back@?$vector@U?$pair@PAVCPortal@@M@std@@V?$xalloc@U?$pair@PAVCPortal@@M@std@@@@@std@@QAEX$$QAU?$pair@PAVCPortal@@M@2@@Z ; std::vector<std::pair<CPortal *,float>,xalloc<std::pair<CPortal *,float> > >::push_back
PUBLIC	?reserve@?$vector@U?$pair@PAVCPortal@@M@std@@V?$xalloc@U?$pair@PAVCPortal@@M@std@@@@@std@@QAEXI@Z ; std::vector<std::pair<CPortal *,float>,xalloc<std::pair<CPortal *,float> > >::reserve
PUBLIC	?begin@?$vector@U?$pair@PAVCPortal@@M@std@@V?$xalloc@U?$pair@PAVCPortal@@M@std@@@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@PAVCPortal@@M@std@@@std@@@std@@@2@XZ ; std::vector<std::pair<CPortal *,float>,xalloc<std::pair<CPortal *,float> > >::begin
PUBLIC	?end@?$vector@U?$pair@PAVCPortal@@M@std@@V?$xalloc@U?$pair@PAVCPortal@@M@std@@@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@PAVCPortal@@M@std@@@std@@@std@@@2@XZ ; std::vector<std::pair<CPortal *,float>,xalloc<std::pair<CPortal *,float> > >::end
PUBLIC	?empty@?$vector@U?$pair@PAVCPortal@@M@std@@V?$xalloc@U?$pair@PAVCPortal@@M@std@@@@@std@@QBE_NXZ ; std::vector<std::pair<CPortal *,float>,xalloc<std::pair<CPortal *,float> > >::empty
PUBLIC	??0?$xr_vector@U?$pair@PAVCPortal@@M@std@@V?$xalloc@U?$pair@PAVCPortal@@M@std@@@@@@QAE@XZ ; xr_vector<std::pair<CPortal *,float>,xalloc<std::pair<CPortal *,float> > >::xr_vector<std::pair<CPortal *,float>,xalloc<std::pair<CPortal *,float> > >
PUBLIC	?size@?$xr_vector@U?$pair@PAVCPortal@@M@std@@V?$xalloc@U?$pair@PAVCPortal@@M@std@@@@@@QBEIXZ ; xr_vector<std::pair<CPortal *,float>,xalloc<std::pair<CPortal *,float> > >::size
PUBLIC	?clear@?$xr_vector@U?$pair@PAVCPortal@@M@std@@V?$xalloc@U?$pair@PAVCPortal@@M@std@@@@@@QAEXXZ ; xr_vector<std::pair<CPortal *,float>,xalloc<std::pair<CPortal *,float> > >::clear
PUBLIC	??A?$xr_vector@U?$pair@PAVCPortal@@M@std@@V?$xalloc@U?$pair@PAVCPortal@@M@std@@@@@@QAEAAU?$pair@PAVCPortal@@M@std@@I@Z ; xr_vector<std::pair<CPortal *,float>,xalloc<std::pair<CPortal *,float> > >::operator[]
PUBLIC	?fade_render@CPortalTraverser@@QAEXXZ		; CPortalTraverser::fade_render
PUBLIC	?psort_pred@@YA_NABU?$pair@PAVCPortal@@M@std@@0@Z ; psort_pred
PUBLIC	?destroy@CPortalTraverser@@QAEXXZ		; CPortalTraverser::destroy
PUBLIC	?initialize@CPortalTraverser@@QAEXXZ		; CPortalTraverser::initialize
PUBLIC	??0CPortalTraverser@@QAE@XZ			; CPortalTraverser::CPortalTraverser
PUBLIC	??1?$xr_vector@U?$pair@PAVCPortal@@M@std@@V?$xalloc@U?$pair@PAVCPortal@@M@std@@@@@@QAE@XZ ; xr_vector<std::pair<CPortal *,float>,xalloc<std::pair<CPortal *,float> > >::~xr_vector<std::pair<CPortal *,float>,xalloc<std::pair<CPortal *,float> > >
PUBLIC	??1?$xr_vector@PAVIRender_Sector@@V?$xalloc@PAVIRender_Sector@@@@@@QAE@XZ ; xr_vector<IRender_Sector *,xalloc<IRender_Sector *> >::~xr_vector<IRender_Sector *,xalloc<IRender_Sector *> >
PUBLIC	??1CPortalTraverser@@QAE@XZ			; CPortalTraverser::~CPortalTraverser
PUBLIC	?fade_portal@CPortalTraverser@@QAEXPAVCPortal@@M@Z ; CPortalTraverser::fade_portal
PUBLIC	?traverse@CPortalTraverser@@QAEXPAVIRender_Sector@@AAVCFrustum@@AAU?$_vector3@M@@AAU?$_matrix@M@@I@Z ; CPortalTraverser::traverse
PUBLIC	?PortalTraverser@@3VCPortalTraverser@@A		; PortalTraverser
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?_Reallocate_exactly@?$vector@U?$pair@PAVCPortal@@M@std@@V?$xalloc@U?$pair@PAVCPortal@@M@std@@@@@std@@AAEXI@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Reallocate_exactly@?$vector@U?$pair@PAVCPortal@@M@std@@V?$xalloc@U?$pair@PAVCPortal@@M@std@@@@@std@@AAEXI@Z
	DD	01H
	DD	FLAT:__tryblocktable$?_Reallocate_exactly@?$vector@U?$pair@PAVCPortal@@M@std@@V?$xalloc@U?$pair@PAVCPortal@@M@std@@@@@std@@AAEXI@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
__unwindtable$?_Reallocate_exactly@?$vector@U?$pair@PAVCPortal@@M@std@@V?$xalloc@U?$pair@PAVCPortal@@M@std@@@@@std@@AAEXI@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?_Reallocate_exactly@?$vector@U?$pair@PAVCPortal@@M@std@@V?$xalloc@U?$pair@PAVCPortal@@M@std@@@@@std@@AAEXI@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Reallocate_exactly@?$vector@U?$pair@PAVCPortal@@M@std@@V?$xalloc@U?$pair@PAVCPortal@@M@std@@@@@std@@AAEXI@Z$2
__catchsym$?_Reallocate_exactly@?$vector@U?$pair@PAVCPortal@@M@std@@V?$xalloc@U?$pair@PAVCPortal@@M@std@@@@@std@@AAEXI@Z$2 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Reallocate_exactly@?$vector@U?$pair@PAVCPortal@@M@std@@V?$xalloc@U?$pair@PAVCPortal@@M@std@@@@@std@@AAEXI@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$_Emplace_reallocate@U?$pair@PAVCPortal@@M@std@@@?$vector@U?$pair@PAVCPortal@@M@std@@V?$xalloc@U?$pair@PAVCPortal@@M@std@@@@@std@@QAEPAU?$pair@PAVCPortal@@M@1@QAU21@$$QAU21@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Emplace_reallocate@U?$pair@PAVCPortal@@M@std@@@?$vector@U?$pair@PAVCPortal@@M@std@@V?$xalloc@U?$pair@PAVCPortal@@M@std@@@@@std@@QAEPAU?$pair@PAVCPortal@@M@1@QAU21@$$QAU21@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Emplace_reallocate@U?$pair@PAVCPortal@@M@std@@@?$vector@U?$pair@PAVCPortal@@M@std@@V?$xalloc@U?$pair@PAVCPortal@@M@std@@@@@std@@QAEPAU?$pair@PAVCPortal@@M@1@QAU21@$$QAU21@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
__unwindtable$??$_Emplace_reallocate@U?$pair@PAVCPortal@@M@std@@@?$vector@U?$pair@PAVCPortal@@M@std@@V?$xalloc@U?$pair@PAVCPortal@@M@std@@@@@std@@QAEPAU?$pair@PAVCPortal@@M@1@QAU21@$$QAU21@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Emplace_reallocate@U?$pair@PAVCPortal@@M@std@@@?$vector@U?$pair@PAVCPortal@@M@std@@V?$xalloc@U?$pair@PAVCPortal@@M@std@@@@@std@@QAEPAU?$pair@PAVCPortal@@M@1@QAU21@$$QAU21@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Emplace_reallocate@U?$pair@PAVCPortal@@M@std@@@?$vector@U?$pair@PAVCPortal@@M@std@@V?$xalloc@U?$pair@PAVCPortal@@M@std@@@@@std@@QAEPAU?$pair@PAVCPortal@@M@1@QAU21@$$QAU21@@Z$2
__catchsym$??$_Emplace_reallocate@U?$pair@PAVCPortal@@M@std@@@?$vector@U?$pair@PAVCPortal@@M@std@@V?$xalloc@U?$pair@PAVCPortal@@M@std@@@@@std@@QAEPAU?$pair@PAVCPortal@@M@1@QAU21@$$QAU21@@Z$2 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Emplace_reallocate@U?$pair@PAVCPortal@@M@std@@@?$vector@U?$pair@PAVCPortal@@M@std@@V?$xalloc@U?$pair@PAVCPortal@@M@std@@@@@std@@QAEPAU?$pair@PAVCPortal@@M@1@QAU21@$$QAU21@@Z$0
	ORG $+8
?PortalTraverser@@3VCPortalTraverser@@A DD 0ffffffffH	; PortalTraverser
?PortalTraverser$initializer$@@3P6AXXZA DD FLAT:??__EPortalTraverser@@YAXXZ ; PortalTraverser$initializer$
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__sector_traversal.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__sector_traversal.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector2.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__sector_traversal.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__sector_traversal.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector2.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__sector_traversal.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__sector_traversal.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__sector_traversal.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__sector_traversal.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__sector_traversal.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector2.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__sector_traversal.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__sector_traversal.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector2.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_std_extensions.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector2.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_std_extensions.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector2.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_std_extensions.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector2.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_std_extensions.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector2.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_std_extensions.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector2.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_std_extensions.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector2.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_std_extensions.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector2.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_std_extensions.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__sector_traversal.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector2.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__sector_traversal.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__sector_traversal.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__sector_traversal.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__sector_traversal.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__sector_traversal.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__sector_traversal.cpp
_TEXT	SEGMENT
_scissor$ = -20						; size = 20
_start$ = 8						; size = 4
_F$ = 12						; size = 4
_vBase$ = 16						; size = 4
_mXFORM$ = 20						; size = 4
_options$ = 24						; size = 4
?traverse@CPortalTraverser@@QAEXPAVIRender_Sector@@AAVCFrustum@@AAU?$_vector3@M@@AAU?$_matrix@M@@I@Z PROC ; CPortalTraverser::traverse
; _this$ = ecx

; 18   : {

	sub	esp, 24					; 00000018H
	push	ebx

; 19   : 	Fmatrix			m_viewport_01	= {
; 20   : 		1.f/2.f,			0.0f,				0.0f,		0.0f,
; 21   : 		0.0f,				-1.f/2.f,			0.0f,		0.0f,
; 22   : 		0.0f,				0.0f,				1.0f,		0.0f,
; 23   : 		1.f/2.f + 0 + 0,	1.f/2.f + 0 + 0,	0.0f,		1.0f
; 24   : 	};
; 25   : 
; 26   : 	if (options & VQ_FADE)			{

	mov	ebx, DWORD PTR _options$[esp+24]
	push	ebp
	mov	ebp, ecx
	push	esi
	push	edi
	test	bl, 8
	je	SHORT $LN4@traverse

; 27   : 		f_portals.clear		();

	mov	edx, DWORD PTR [ebp+164]
	lea	ecx, DWORD PTR [ebp+164]
	mov	DWORD PTR [ecx+4], edx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1546 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	eax, DWORD PTR [ecx+8]
	sub	eax, edx
	sar	eax, 3

; 1358 :         if (_Newcapacity > capacity()) { // something to do (reserve() never shrinks)

	cmp	eax, 16					; 00000010H
	jae	SHORT $LN4@traverse

; 1359 :             if (_Newcapacity > max_size()) {
; 1360 :                 _Xlength();
; 1361 :             }
; 1362 : 
; 1363 :             _Reallocate_exactly(_Newcapacity);

	push	ecx
	call	?_Reallocate_exactly@?$vector@U?$pair@PAVCPortal@@M@std@@V?$xalloc@U?$pair@PAVCPortal@@M@std@@@@@std@@AAEXI@Z ; std::vector<std::pair<CPortal *,float>,xalloc<std::pair<CPortal *,float> > >::_Reallocate_exactly
$LN4@traverse:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__sector_traversal.cpp

; 32   : 	i_marker			++;

	inc	DWORD PTR [ebp]

; 35   : 	i_mXFORM			= mXFORM;

	lea	edi, DWORD PTR [ebp+20]
	mov	DWORD PTR [ebp+4], ebx
	mov	ecx, DWORD PTR _vBase$[esp+36]
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 85   : 		m[0][0] = A.m[0][0] * B.m[0][0] + A.m[1][0] * B.m[0][1] + A.m[2][0] * B.m[0][2] + A.m[3][0] * B.m[0][3];

	movss	xmm2, DWORD PTR __real@3f000000
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector2.h

; 15   : 	IC SelfRef set(float _u, float _v)				{ x=T(_u); y=T(_v);				return *this;	}

	mov	DWORD PTR _scissor$[esp+40], 0
	mov	DWORD PTR _scissor$[esp+44], 0
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__sector_traversal.cpp

; 34   : 	i_vBase				= vBase;

	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [ebp+8], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [ebp+12], eax
	mov	eax, DWORD PTR [ecx+8]

; 35   : 	i_mXFORM			= mXFORM;

	mov	ecx, 16					; 00000010H
	mov	DWORD PTR [ebp+16], eax
	mov	eax, DWORD PTR _mXFORM$[esp+36]
	mov	esi, eax
	rep movsd
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 85   : 		m[0][0] = A.m[0][0] * B.m[0][0] + A.m[1][0] * B.m[0][1] + A.m[2][0] * B.m[0][2] + A.m[3][0] * B.m[0][3];

	movss	xmm0, DWORD PTR [eax+12]
	addss	xmm0, DWORD PTR [eax]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__sector_traversal.cpp

; 37   : 	i_start				= (CSector*)start;

	mov	ecx, DWORD PTR _start$[esp+36]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector2.h

; 15   : 	IC SelfRef set(float _u, float _v)				{ x=T(_u); y=T(_v);				return *this;	}

	mov	DWORD PTR _scissor$[esp+48], 1065353216	; 3f800000H
	mov	DWORD PTR _scissor$[esp+52], 1065353216	; 3f800000H
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__sector_traversal.cpp

; 41   : 	scissor.depth		= 0;

	mov	DWORD PTR _scissor$[esp+56], 0
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 85   : 		m[0][0] = A.m[0][0] * B.m[0][0] + A.m[1][0] * B.m[0][1] + A.m[2][0] * B.m[0][2] + A.m[3][0] * B.m[0][3];

	mulss	xmm0, xmm2
	movss	DWORD PTR [ebp+84], xmm0

; 86   : 		m[0][1] = A.m[0][1] * B.m[0][0] + A.m[1][1] * B.m[0][1] + A.m[2][1] * B.m[0][2] + A.m[3][1] * B.m[0][3];

	movss	xmm1, DWORD PTR [eax+12]
	movss	xmm0, DWORD PTR [eax+4]
	mulss	xmm0, xmm2
	mulss	xmm1, xmm2
	subss	xmm1, xmm0
	movss	DWORD PTR [ebp+88], xmm1

; 87   : 		m[0][2] = A.m[0][2] * B.m[0][0] + A.m[1][2] * B.m[0][1] + A.m[2][2] * B.m[0][2] + A.m[3][2] * B.m[0][3];

	fld	DWORD PTR [eax+8]
	fstp	DWORD PTR [ebp+92]

; 88   : 		m[0][3] = A.m[0][3] * B.m[0][0] + A.m[1][3] * B.m[0][1] + A.m[2][3] * B.m[0][2] + A.m[3][3] * B.m[0][3];

	fld	DWORD PTR [eax+12]
	fstp	DWORD PTR [ebp+96]

; 89   : 
; 90   : 		m[1][0] = A.m[0][0] * B.m[1][0] + A.m[1][0] * B.m[1][1] + A.m[2][0] * B.m[1][2] + A.m[3][0] * B.m[1][3];

	movss	xmm0, DWORD PTR [eax+16]
	addss	xmm0, DWORD PTR [eax+28]
	mulss	xmm0, xmm2
	movss	DWORD PTR [ebp+100], xmm0

; 91   : 		m[1][1] = A.m[0][1] * B.m[1][0] + A.m[1][1] * B.m[1][1] + A.m[2][1] * B.m[1][2] + A.m[3][1] * B.m[1][3];

	movss	xmm1, DWORD PTR [eax+28]
	movss	xmm0, DWORD PTR [eax+20]
	mulss	xmm0, xmm2
	mulss	xmm1, xmm2
	subss	xmm1, xmm0
	movss	DWORD PTR [ebp+104], xmm1

; 92   : 		m[1][2] = A.m[0][2] * B.m[1][0] + A.m[1][2] * B.m[1][1] + A.m[2][2] * B.m[1][2] + A.m[3][2] * B.m[1][3];

	fld	DWORD PTR [eax+24]
	fstp	DWORD PTR [ebp+108]

; 93   : 		m[1][3] = A.m[0][3] * B.m[1][0] + A.m[1][3] * B.m[1][1] + A.m[2][3] * B.m[1][2] + A.m[3][3] * B.m[1][3];

	fld	DWORD PTR [eax+28]
	fstp	DWORD PTR [ebp+112]

; 94   : 
; 95   : 		m[2][0] = A.m[0][0] * B.m[2][0] + A.m[1][0] * B.m[2][1] + A.m[2][0] * B.m[2][2] + A.m[3][0] * B.m[2][3];

	movss	xmm0, DWORD PTR [eax+32]
	addss	xmm0, DWORD PTR [eax+44]
	mulss	xmm0, xmm2
	movss	DWORD PTR [ebp+116], xmm0

; 96   : 		m[2][1] = A.m[0][1] * B.m[2][0] + A.m[1][1] * B.m[2][1] + A.m[2][1] * B.m[2][2] + A.m[3][1] * B.m[2][3];

	movss	xmm1, DWORD PTR [eax+44]
	movss	xmm0, DWORD PTR [eax+36]
	mulss	xmm0, xmm2
	mulss	xmm1, xmm2
	subss	xmm1, xmm0
	movss	DWORD PTR [ebp+120], xmm1

; 97   : 		m[2][2] = A.m[0][2] * B.m[2][0] + A.m[1][2] * B.m[2][1] + A.m[2][2] * B.m[2][2] + A.m[3][2] * B.m[2][3];

	fld	DWORD PTR [eax+40]
	fstp	DWORD PTR [ebp+124]

; 98   : 		m[2][3] = A.m[0][3] * B.m[2][0] + A.m[1][3] * B.m[2][1] + A.m[2][3] * B.m[2][2] + A.m[3][3] * B.m[2][3];

	fld	DWORD PTR [eax+44]
	fstp	DWORD PTR [ebp+128]

; 99   : 
; 100  : 		m[3][0] = A.m[0][0] * B.m[3][0] + A.m[1][0] * B.m[3][1] + A.m[2][0] * B.m[3][2] + A.m[3][0] * B.m[3][3];

	movss	xmm0, DWORD PTR [eax+48]
	addss	xmm0, DWORD PTR [eax+60]
	mulss	xmm0, xmm2
	movss	DWORD PTR [ebp+132], xmm0

; 101  : 		m[3][1] = A.m[0][1] * B.m[3][0] + A.m[1][1] * B.m[3][1] + A.m[2][1] * B.m[3][2] + A.m[3][1] * B.m[3][3];

	movss	xmm1, DWORD PTR [eax+60]
	movss	xmm0, DWORD PTR [eax+52]
	mulss	xmm1, xmm2
	mulss	xmm0, xmm2
	subss	xmm1, xmm0
	movss	DWORD PTR [ebp+136], xmm1

; 102  : 		m[3][2] = A.m[0][2] * B.m[3][0] + A.m[1][2] * B.m[3][1] + A.m[2][2] * B.m[3][2] + A.m[3][2] * B.m[3][3];

	fld	DWORD PTR [eax+56]
	fstp	DWORD PTR [ebp+140]

; 103  : 		m[3][3] = A.m[0][3] * B.m[3][0] + A.m[1][3] * B.m[3][1] + A.m[2][3] * B.m[3][2] + A.m[3][3] * B.m[3][3];

	fld	DWORD PTR [eax+60]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__sector_traversal.cpp

; 38   : 	r_sectors.clear		();

	mov	eax, DWORD PTR [ebp+152]
	mov	DWORD PTR [ebp+156], eax

; 42   : 	i_start->traverse	(F,scissor);

	lea	eax, DWORD PTR _scissor$[esp+40]
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 103  : 		m[3][3] = A.m[0][3] * B.m[3][0] + A.m[1][3] * B.m[3][1] + A.m[2][3] * B.m[3][2] + A.m[3][3] * B.m[3][3];

	fstp	DWORD PTR [ebp+144]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__sector_traversal.cpp

; 37   : 	i_start				= (CSector*)start;

	mov	DWORD PTR [ebp+148], ecx

; 42   : 	i_start->traverse	(F,scissor);

	push	eax
	push	DWORD PTR _F$[esp+40]
	call	?traverse@CSector@@QAEXAAVCFrustum@@AAU_scissor@@@Z ; CSector::traverse

; 43   : 
; 44   : 	if (options & VQ_SCISSOR)		{

	test	bl, 4
	je	$LN6@traverse
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	eax, DWORD PTR [ebp+156]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__sector_traversal.cpp

; 47   : 		for (u32 s=0; s<r_sectors.size(); s++)

	xor	ebx, ebx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	ecx, DWORD PTR [ebp+152]
	sub	eax, ecx
	sar	eax, 2
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__sector_traversal.cpp

; 47   : 		for (u32 s=0; s<r_sectors.size(); s++)

	test	eax, eax
	je	$LN6@traverse
	npad	3
$LL7@traverse:

; 48   : 		{
; 49   : 			CSector*	S		= (CSector*)r_sectors[s];

	mov	ecx, DWORD PTR [ecx+ebx*4]

; 52   : 			for (u32 it=0; it<S->r_scissors.size(); it++)

	xor	edi, edi
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector2.h

; 15   : 	IC SelfRef set(float _u, float _v)				{ x=T(_u); y=T(_v);				return *this;	}

	mov	DWORD PTR [ecx+44], 2139095039		; 7f7fffffH
	mov	DWORD PTR [ecx+48], 2139095039		; 7f7fffffH
	mov	DWORD PTR [ecx+52], -8388609		; ff7fffffH
	mov	DWORD PTR [ecx+56], -8388609		; ff7fffffH
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__sector_traversal.cpp

; 51   : 			S->r_scissor_merged.depth		= flt_max;

	mov	DWORD PTR [ecx+60], 2139095039		; 7f7fffffH
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	eax, DWORD PTR [ecx+36]
	mov	edx, DWORD PTR [ecx+32]
	sub	eax, edx
	sar	eax, 2
	imul	eax, eax, -858993459
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__sector_traversal.cpp

; 52   : 			for (u32 it=0; it<S->r_scissors.size(); it++)

	test	eax, eax
	je	$LN5@traverse

; 53   : 			{
; 54   : 				S->r_scissor_merged.merge(S->r_scissors[it]);

	xor	esi, esi
$LL10@traverse:
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector2.h

; 20   : 	IC SelfRef min(const Self &p)					{ x=_min(x,p.x); y=_min(y,p.y);	return *this;	}

	movss	xmm0, DWORD PTR [ecx+44]
	movss	xmm1, DWORD PTR [edx+esi]
; File I:\Vitalya\mine\NSProjectX\xrCore\_std_extensions.h

; 93   : template <class T>	IC T		_min	(T a, T b)	{ return a<b?a:b;	}

	comiss	xmm1, xmm0
	ja	SHORT $LN100@traverse
	movaps	xmm0, xmm1
$LN100@traverse:
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector2.h

; 20   : 	IC SelfRef min(const Self &p)					{ x=_min(x,p.x); y=_min(y,p.y);	return *this;	}

	movss	DWORD PTR [ecx+44], xmm0
	movss	xmm0, DWORD PTR [ecx+48]
	movss	xmm1, DWORD PTR [edx+esi+4]
; File I:\Vitalya\mine\NSProjectX\xrCore\_std_extensions.h

; 93   : template <class T>	IC T		_min	(T a, T b)	{ return a<b?a:b;	}

	comiss	xmm1, xmm0
	ja	SHORT $LN104@traverse
	movaps	xmm0, xmm1
$LN104@traverse:
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector2.h

; 20   : 	IC SelfRef min(const Self &p)					{ x=_min(x,p.x); y=_min(y,p.y);	return *this;	}

	movss	DWORD PTR [ecx+48], xmm0

; 22   : 	IC SelfRef max(const Self &p)					{ x=_max(x,p.x); y=_max(y,p.y);	return *this;	}

	movss	xmm0, DWORD PTR [ecx+52]
	movss	xmm1, DWORD PTR [edx+esi]
; File I:\Vitalya\mine\NSProjectX\xrCore\_std_extensions.h

; 94   : template <class T>	IC T		_max	(T a, T b)	{ return a>b?a:b;	}

	comiss	xmm0, xmm1
	ja	SHORT $LN110@traverse
	movaps	xmm0, xmm1
$LN110@traverse:
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector2.h

; 22   : 	IC SelfRef max(const Self &p)					{ x=_max(x,p.x); y=_max(y,p.y);	return *this;	}

	movss	DWORD PTR [ecx+52], xmm0
	movss	xmm0, DWORD PTR [ecx+56]
	movss	xmm1, DWORD PTR [edx+esi+4]
; File I:\Vitalya\mine\NSProjectX\xrCore\_std_extensions.h

; 94   : template <class T>	IC T		_max	(T a, T b)	{ return a>b?a:b;	}

	comiss	xmm0, xmm1
	ja	SHORT $LN114@traverse
	movaps	xmm0, xmm1
$LN114@traverse:
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector2.h

; 22   : 	IC SelfRef max(const Self &p)					{ x=_max(x,p.x); y=_max(y,p.y);	return *this;	}

	movss	DWORD PTR [ecx+56], xmm0

; 20   : 	IC SelfRef min(const Self &p)					{ x=_min(x,p.x); y=_min(y,p.y);	return *this;	}

	movss	xmm0, DWORD PTR [ecx+44]
	movss	xmm1, DWORD PTR [edx+esi+8]
; File I:\Vitalya\mine\NSProjectX\xrCore\_std_extensions.h

; 93   : template <class T>	IC T		_min	(T a, T b)	{ return a<b?a:b;	}

	comiss	xmm1, xmm0
	ja	SHORT $LN122@traverse
	movaps	xmm0, xmm1
$LN122@traverse:
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector2.h

; 20   : 	IC SelfRef min(const Self &p)					{ x=_min(x,p.x); y=_min(y,p.y);	return *this;	}

	movss	DWORD PTR [ecx+44], xmm0
	movss	xmm0, DWORD PTR [ecx+48]
	movss	xmm1, DWORD PTR [edx+esi+12]
; File I:\Vitalya\mine\NSProjectX\xrCore\_std_extensions.h

; 93   : template <class T>	IC T		_min	(T a, T b)	{ return a<b?a:b;	}

	comiss	xmm1, xmm0
	ja	SHORT $LN126@traverse
	movaps	xmm0, xmm1
$LN126@traverse:
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector2.h

; 20   : 	IC SelfRef min(const Self &p)					{ x=_min(x,p.x); y=_min(y,p.y);	return *this;	}

	movss	DWORD PTR [ecx+48], xmm0

; 22   : 	IC SelfRef max(const Self &p)					{ x=_max(x,p.x); y=_max(y,p.y);	return *this;	}

	movss	xmm0, DWORD PTR [ecx+52]
	movss	xmm1, DWORD PTR [edx+esi+8]
; File I:\Vitalya\mine\NSProjectX\xrCore\_std_extensions.h

; 94   : template <class T>	IC T		_max	(T a, T b)	{ return a>b?a:b;	}

	comiss	xmm0, xmm1
	ja	SHORT $LN132@traverse
	movaps	xmm0, xmm1
$LN132@traverse:
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector2.h

; 22   : 	IC SelfRef max(const Self &p)					{ x=_max(x,p.x); y=_max(y,p.y);	return *this;	}

	movss	DWORD PTR [ecx+52], xmm0
	movss	xmm0, DWORD PTR [ecx+56]
	movss	xmm1, DWORD PTR [edx+esi+12]
; File I:\Vitalya\mine\NSProjectX\xrCore\_std_extensions.h

; 94   : template <class T>	IC T		_max	(T a, T b)	{ return a>b?a:b;	}

	comiss	xmm0, xmm1
	ja	SHORT $LN136@traverse
	movaps	xmm0, xmm1
$LN136@traverse:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__sector_traversal.cpp

; 55   : 				if (S->r_scissors[it].depth < S->r_scissor_merged.depth)

	mov	edx, DWORD PTR [ecx+32]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector2.h

; 22   : 	IC SelfRef max(const Self &p)					{ x=_max(x,p.x); y=_max(y,p.y);	return *this;	}

	movss	DWORD PTR [ecx+56], xmm0
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__sector_traversal.cpp

; 55   : 				if (S->r_scissors[it].depth < S->r_scissor_merged.depth)

	movss	xmm0, DWORD PTR [ecx+60]
	movss	xmm1, DWORD PTR [edx+esi+16]
	comiss	xmm0, xmm1
	jbe	SHORT $LN8@traverse

; 56   : 					S->r_scissor_merged.depth = S->r_scissors[it].depth;

	movss	DWORD PTR [ecx+60], xmm1
$LN8@traverse:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	eax, DWORD PTR [ecx+36]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__sector_traversal.cpp

; 52   : 			for (u32 it=0; it<S->r_scissors.size(); it++)

	inc	edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	sub	eax, edx
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__sector_traversal.cpp

; 52   : 			for (u32 it=0; it<S->r_scissors.size(); it++)

	add	esi, 20					; 00000014H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	sar	eax, 2
	imul	eax, eax, -858993459
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__sector_traversal.cpp

; 52   : 			for (u32 it=0; it<S->r_scissors.size(); it++)

	cmp	edi, eax
	jb	$LL10@traverse
$LN5@traverse:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	eax, DWORD PTR [ebp+156]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__sector_traversal.cpp

; 47   : 		for (u32 s=0; s<r_sectors.size(); s++)

	inc	ebx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	ecx, DWORD PTR [ebp+152]
	sub	eax, ecx
	sar	eax, 2
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__sector_traversal.cpp

; 47   : 		for (u32 s=0; s<r_sectors.size(); s++)

	cmp	ebx, eax
	jb	$LL7@traverse
$LN6@traverse:

; 57   : 			}
; 58   : 		}
; 59   : 	}
; 60   : }

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 24					; 00000018H
	ret	20					; 00000014H
?traverse@CPortalTraverser@@QAEXPAVIRender_Sector@@AAVCFrustum@@AAU?$_vector3@M@@AAU?$_matrix@M@@I@Z ENDP ; CPortalTraverser::traverse
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__sector_traversal.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__sector_traversal.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__sector_traversal.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__sector_traversal.cpp
_TEXT	SEGMENT
$T1 = -12						; size = 8
__p$ = 8						; size = 4
_ssa$ = 12						; size = 4
?fade_portal@CPortalTraverser@@QAEXPAVCPortal@@M@Z PROC	; CPortalTraverser::fade_portal
; _this$ = ecx

; 63   : {

	sub	esp, 16					; 00000010H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 186  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

	movss	xmm0, DWORD PTR _ssa$[esp+12]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__sector_traversal.cpp

; 64   : 	f_portals.push_back				(mk_pair(_p,ssa));

	add	ecx, 164				; 000000a4H
	push	esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 186  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

	mov	esi, DWORD PTR __p$[esp+16]
	mov	DWORD PTR $T1[esp+20], esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 730  :         if (_Mylast != _My_data._Myend) {

	mov	edx, DWORD PTR [ecx+4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 186  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

	movss	DWORD PTR $T1[esp+24], xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 730  :         if (_Mylast != _My_data._Myend) {

	cmp	edx, DWORD PTR [ecx+8]
	je	SHORT $LN10@fade_porta

; 713  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

	mov	eax, DWORD PTR $T1[esp+24]
	mov	DWORD PTR [edx], esi
	mov	DWORD PTR [edx+4], eax

; 714  :         _Orphan_range(_Mylast, _Mylast);
; 715  :         _Ty& _Result = *_Mylast;
; 716  :         ++_Mylast;

	add	DWORD PTR [ecx+4], 8
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__sector_traversal.cpp

; 65   : }

	pop	esi
	add	esp, 16					; 00000010H
	ret	8
$LN10@fade_porta:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 734  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	lea	eax, DWORD PTR $T1[esp+20]
	push	eax
	push	edx
	call	??$_Emplace_reallocate@U?$pair@PAVCPortal@@M@std@@@?$vector@U?$pair@PAVCPortal@@M@std@@V?$xalloc@U?$pair@PAVCPortal@@M@std@@@@@std@@QAEPAU?$pair@PAVCPortal@@M@1@QAU21@$$QAU21@@Z ; std::vector<std::pair<CPortal *,float>,xalloc<std::pair<CPortal *,float> > >::_Emplace_reallocate<std::pair<CPortal *,float> >
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__sector_traversal.cpp

; 65   : }

	pop	esi
	add	esp, 16					; 00000010H
	ret	8
?fade_portal@CPortalTraverser@@QAEXPAVCPortal@@M@Z ENDP	; CPortalTraverser::fade_portal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__sector_traversal.cpp
;	COMDAT ??__EPortalTraverser@@YAXXZ
text$di	SEGMENT
??__EPortalTraverser@@YAXXZ PROC			; `dynamic initializer for 'PortalTraverser'', COMDAT

; 6    : CPortalTraverser	PortalTraverser;

	push	OFFSET ??__FPortalTraverser@@YAXXZ	; `dynamic atexit destructor for 'PortalTraverser''
	call	_atexit
	pop	ecx
	ret	0
??__EPortalTraverser@@YAXXZ ENDP			; `dynamic initializer for 'PortalTraverser''
text$di	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??__FPortalTraverser@@YAXXZ
text$yd	SEGMENT
??__FPortalTraverser@@YAXXZ PROC			; `dynamic atexit destructor for 'PortalTraverser'', COMDAT
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 64   : 						~resptr_core	()												{	_dec();						}

	mov	ecx, OFFSET ?PortalTraverser@@3VCPortalTraverser@@A+180
	call	DWORD PTR __imp_?_dec@?$resptr_base@USGeometry@@@@IAEXXZ
	mov	ecx, OFFSET ?PortalTraverser@@3VCPortalTraverser@@A+176
	call	DWORD PTR __imp_?_dec@?$resptr_base@UShader@@@@IAEXXZ
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR ?PortalTraverser@@3VCPortalTraverser@@A+164
	test	eax, eax
	je	SHORT $LN14@dynamic
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR ?PortalTraverser@@3VCPortalTraverser@@A+164, 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR ?PortalTraverser@@3VCPortalTraverser@@A+168, 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR ?PortalTraverser@@3VCPortalTraverser@@A+172, 0
$LN14@dynamic:

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR ?PortalTraverser@@3VCPortalTraverser@@A+152
	test	eax, eax
	je	SHORT $LN26@dynamic
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR ?PortalTraverser@@3VCPortalTraverser@@A+152, 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR ?PortalTraverser@@3VCPortalTraverser@@A+156, 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR ?PortalTraverser@@3VCPortalTraverser@@A+160, 0
$LN26@dynamic:
	ret	0
??__FPortalTraverser@@YAXXZ ENDP			; `dynamic atexit destructor for 'PortalTraverser''
text$yd	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??1CPortalTraverser@@QAE@XZ
_TEXT	SEGMENT
??1CPortalTraverser@@QAE@XZ PROC			; CPortalTraverser::~CPortalTraverser, COMDAT
; _this$ = ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 64   : 						~resptr_core	()												{	_dec();						}

	push	esi
	mov	esi, ecx
	lea	ecx, DWORD PTR [esi+180]
	call	DWORD PTR __imp_?_dec@?$resptr_base@USGeometry@@@@IAEXXZ
	lea	ecx, DWORD PTR [esi+176]
	call	DWORD PTR __imp_?_dec@?$resptr_base@UShader@@@@IAEXXZ
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [esi+164]
	test	eax, eax
	je	SHORT $LN12@CPortalTra
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi+164], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+168], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+172], 0
$LN12@CPortalTra:

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [esi+152]
	test	eax, eax
	je	SHORT $LN24@CPortalTra
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi+152], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+156], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+160], 0
$LN24@CPortalTra:
	pop	esi
	ret	0
??1CPortalTraverser@@QAE@XZ ENDP			; CPortalTraverser::~CPortalTraverser
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??1?$xr_vector@PAVIRender_Sector@@V?$xalloc@PAVIRender_Sector@@@@@@QAE@XZ
_TEXT	SEGMENT
??1?$xr_vector@PAVIRender_Sector@@V?$xalloc@PAVIRender_Sector@@@@@@QAE@XZ PROC ; xr_vector<IRender_Sector *,xalloc<IRender_Sector *> >::~xr_vector<IRender_Sector *,xalloc<IRender_Sector *> >, COMDAT
; _this$ = ecx

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	push	esi
	mov	esi, ecx
	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN6@xr_vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+4], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+8], 0
$LN6@xr_vector:
	pop	esi
	ret	0
??1?$xr_vector@PAVIRender_Sector@@V?$xalloc@PAVIRender_Sector@@@@@@QAE@XZ ENDP ; xr_vector<IRender_Sector *,xalloc<IRender_Sector *> >::~xr_vector<IRender_Sector *,xalloc<IRender_Sector *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??1?$xr_vector@U?$pair@PAVCPortal@@M@std@@V?$xalloc@U?$pair@PAVCPortal@@M@std@@@@@@QAE@XZ
_TEXT	SEGMENT
??1?$xr_vector@U?$pair@PAVCPortal@@M@std@@V?$xalloc@U?$pair@PAVCPortal@@M@std@@@@@@QAE@XZ PROC ; xr_vector<std::pair<CPortal *,float>,xalloc<std::pair<CPortal *,float> > >::~xr_vector<std::pair<CPortal *,float>,xalloc<std::pair<CPortal *,float> > >, COMDAT
; _this$ = ecx

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	push	esi
	mov	esi, ecx
	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN6@xr_vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+4], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+8], 0
$LN6@xr_vector:
	pop	esi
	ret	0
??1?$xr_vector@U?$pair@PAVCPortal@@M@std@@V?$xalloc@U?$pair@PAVCPortal@@M@std@@@@@@QAE@XZ ENDP ; xr_vector<std::pair<CPortal *,float>,xalloc<std::pair<CPortal *,float> > >::~xr_vector<std::pair<CPortal *,float>,xalloc<std::pair<CPortal *,float> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__sector_traversal.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__sector_traversal.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__sector_traversal.cpp
_TEXT	SEGMENT
??0CPortalTraverser@@QAE@XZ PROC			; CPortalTraverser::CPortalTraverser
; _this$dead$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR ?PortalTraverser@@3VCPortalTraverser@@A+152, 0
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__sector_traversal.cpp

; 11   : }

	mov	eax, OFFSET ?PortalTraverser@@3VCPortalTraverser@@A ; PortalTraverser
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR ?PortalTraverser@@3VCPortalTraverser@@A+156, 0
	mov	DWORD PTR ?PortalTraverser@@3VCPortalTraverser@@A+160, 0
	mov	DWORD PTR ?PortalTraverser@@3VCPortalTraverser@@A+164, 0
	mov	DWORD PTR ?PortalTraverser@@3VCPortalTraverser@@A+168, 0
	mov	DWORD PTR ?PortalTraverser@@3VCPortalTraverser@@A+172, 0
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 61   : 						resptr_core		()												{	p_ = 0;						}

	mov	DWORD PTR ?PortalTraverser@@3VCPortalTraverser@@A+176, 0
	mov	DWORD PTR ?PortalTraverser@@3VCPortalTraverser@@A+180, 0
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__sector_traversal.cpp

; 10   : 	i_marker			=	0xffffffff;

	mov	DWORD PTR ?PortalTraverser@@3VCPortalTraverser@@A, -1

; 11   : }

	ret	0
??0CPortalTraverser@@QAE@XZ ENDP			; CPortalTraverser::CPortalTraverser
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__sector_traversal.cpp
_TEXT	SEGMENT
?initialize@CPortalTraverser@@QAEXXZ PROC		; CPortalTraverser::initialize
; _this$dead$ = ecx

; 68   : 	f_shader.create					("portal");

	push	0
	push	0
	push	0
	push	OFFSET ??_C@_06JAELEMPN@portal@
	mov	ecx, OFFSET ?PortalTraverser@@3VCPortalTraverser@@A+176
	call	DWORD PTR __imp_?create@resptrcode_shader@@QAEXPBD000@Z

; 69   : 	f_geom.create					(FVF::F_L, RCache.Vertex.Buffer(), 0);

	mov	eax, DWORD PTR __imp_?RCache@@3VCBackend@@A
	mov	ecx, OFFSET ?PortalTraverser@@3VCPortalTraverser@@A+180
	push	0
	push	DWORD PTR [eax]
	push	66					; 00000042H
	call	DWORD PTR __imp_?create@resptrcode_geom@@QAEXIPAUIDirect3DVertexBuffer9@@PAUIDirect3DIndexBuffer9@@@Z

; 70   : }

	ret	0
?initialize@CPortalTraverser@@QAEXXZ ENDP		; CPortalTraverser::initialize
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__sector_traversal.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__sector_traversal.cpp
_TEXT	SEGMENT
?destroy@CPortalTraverser@@QAEXXZ PROC			; CPortalTraverser::destroy
; _this$dead$ = ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 46   : 	ICF		void		_set	(T * rhs) 							{	if (0!=rhs) rhs->dwReference++;	_dec(); p_ = rhs;											}

	mov	ecx, OFFSET ?PortalTraverser@@3VCPortalTraverser@@A+180
	call	DWORD PTR __imp_?_dec@?$resptr_base@USGeometry@@@@IAEXXZ
	mov	ecx, OFFSET ?PortalTraverser@@3VCPortalTraverser@@A+176
	mov	DWORD PTR ?PortalTraverser@@3VCPortalTraverser@@A+180, 0
	call	DWORD PTR __imp_?_dec@?$resptr_base@UShader@@@@IAEXXZ
	mov	DWORD PTR ?PortalTraverser@@3VCPortalTraverser@@A+176, 0
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__sector_traversal.cpp

; 75   : }

	ret	0
?destroy@CPortalTraverser@@QAEXXZ ENDP			; CPortalTraverser::destroy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__sector_traversal.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__sector_traversal.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__sector_traversal.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__sector_traversal.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__sector_traversal.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__sector_traversal.cpp
;	COMDAT ?psort_pred@@YA_NABU?$pair@PAVCPortal@@M@std@@0@Z
_TEXT	SEGMENT
__1$ = 8						; size = 4
__2$ = 12						; size = 4
?psort_pred@@YA_NABU?$pair@PAVCPortal@@M@std@@0@Z PROC	; psort_pred, COMDAT

; 78   : 	float		d1		= PortalTraverser.i_vBase.distance_to_sqr(_1.first->S.P);

	mov	eax, DWORD PTR __1$[esp-4]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 287  : 	{	return (x-v.x)*(x-v.x) + (y-v.y)*(y-v.y) + (z-v.z)*(z-v.z);	}

	movss	xmm4, DWORD PTR ?PortalTraverser@@3VCPortalTraverser@@A+12
	movss	xmm5, DWORD PTR ?PortalTraverser@@3VCPortalTraverser@@A+8
	movaps	xmm1, xmm4
	movss	xmm2, DWORD PTR ?PortalTraverser@@3VCPortalTraverser@@A+16
	movaps	xmm3, xmm5
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__sector_traversal.cpp

; 78   : 	float		d1		= PortalTraverser.i_vBase.distance_to_sqr(_1.first->S.P);

	mov	ecx, DWORD PTR [eax]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 287  : 	{	return (x-v.x)*(x-v.x) + (y-v.y)*(y-v.y) + (z-v.z)*(z-v.z);	}

	movaps	xmm0, xmm2
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__sector_traversal.cpp

; 79   : 	float		d2		= PortalTraverser.i_vBase.distance_to_sqr(_2.first->S.P);

	mov	eax, DWORD PTR __2$[esp-4]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 287  : 	{	return (x-v.x)*(x-v.x) + (y-v.y)*(y-v.y) + (z-v.z)*(z-v.z);	}

	subss	xmm5, DWORD PTR [ecx+128]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__sector_traversal.cpp

; 79   : 	float		d2		= PortalTraverser.i_vBase.distance_to_sqr(_2.first->S.P);

	mov	eax, DWORD PTR [eax]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 287  : 	{	return (x-v.x)*(x-v.x) + (y-v.y)*(y-v.y) + (z-v.z)*(z-v.z);	}

	subss	xmm4, DWORD PTR [ecx+132]
	subss	xmm2, DWORD PTR [ecx+136]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__sector_traversal.cpp

; 79   : 	float		d2		= PortalTraverser.i_vBase.distance_to_sqr(_2.first->S.P);

	sub	eax, -128				; ffffff80H
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 287  : 	{	return (x-v.x)*(x-v.x) + (y-v.y)*(y-v.y) + (z-v.z)*(z-v.z);	}

	mulss	xmm5, xmm5
	mulss	xmm4, xmm4
	subss	xmm3, DWORD PTR [eax]
	subss	xmm1, DWORD PTR [eax+4]
	subss	xmm0, DWORD PTR [eax+8]
	addss	xmm5, xmm4
	mulss	xmm2, xmm2
	mulss	xmm3, xmm3
	mulss	xmm1, xmm1
	mulss	xmm0, xmm0
	addss	xmm5, xmm2
	addss	xmm3, xmm1
	addss	xmm3, xmm0
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__sector_traversal.cpp

; 80   : 	return		d2>d1;	// descending, back to front

	comiss	xmm3, xmm5
	jbe	SHORT $LN3@psort_pred
	mov	al, 1

; 81   : }

	ret	0
$LN3@psort_pred:

; 80   : 	return		d2>d1;	// descending, back to front

	xor	al, al

; 81   : }

	ret	0
?psort_pred@@YA_NABU?$pair@PAVCPortal@@M@std@@0@Z ENDP	; psort_pred
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__sector_traversal.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__sector_traversal.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__sector_traversal.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__sector_traversal.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__sector_traversal.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__sector_traversal.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__sector_traversal.cpp
; File I:\Vitalya\mine\NSProjectX\xrEngine\shader.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__sector_traversal.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_color.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__sector_traversal.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_color.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__sector_traversal.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__sector_traversal.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_color.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h
; File I:\Vitalya\mine\NSProjectX\xrCore\vector.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h
; File I:\Vitalya\mine\NSProjectX\xrCore\vector.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_color.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_color.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h
; File I:\Vitalya\mine\NSProjectX\xrCore\vector.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_color.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_color.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h
; File I:\Vitalya\mine\NSProjectX\xrCore\vector.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_color.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__sector_traversal.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_color.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__sector_traversal.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_color.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_color.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__sector_traversal.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__sector_traversal.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h
; File I:\Vitalya\mine\NSProjectX\xrCore\vector.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__sector_traversal.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_color.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__sector_traversal.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_color.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrEngine\fvf.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrEngine\fvf.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrEngine\fvf.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__sector_traversal.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__sector_traversal.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__sector_traversal.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__sector_traversal.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__sector_traversal.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__sector_traversal.cpp
; File I:\Vitalya\mine\NSProjectX\xrEngine\R_Backend_Runtime.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__sector_traversal.cpp
; File I:\Vitalya\mine\NSProjectX\xrEngine\R_Backend_Runtime.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__sector_traversal.cpp
; File I:\Vitalya\mine\NSProjectX\xrEngine\R_Backend_Runtime.h
; File I:\Vitalya\mine\NSProjectX\xrEngine\r_constants_cache.h
; File I:\Vitalya\mine\NSProjectX\xrEngine\R_Backend_Runtime.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__sector_traversal.cpp
; File I:\Vitalya\mine\NSProjectX\xrEngine\R_Backend_Runtime.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__sector_traversal.cpp
_TEXT	SEGMENT
__b$1$ = -40						; size = 4
_a$1 = -40						; size = 4
_a$2 = -40						; size = 4
_a$3 = -40						; size = 4
__r$1$ = -36						; size = 4
__it$1$ = -36						; size = 4
_a$4 = -36						; size = 4
__offset$ = -32						; size = 4
tv1595 = -28						; size = 4
__pcount$1$ = -24					; size = 4
__ambient$1$ = -20					; size = 4
__P$1$ = -16						; size = 4
__ambient_f$ = -12					; size = 12
?fade_render@CPortalTraverser@@QAEXXZ PROC		; CPortalTraverser::fade_render
; _this$dead$ = ecx

; 85   : {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1531 :         return _My_data._Myfirst == _My_data._Mylast;

	mov	ecx, DWORD PTR ?PortalTraverser@@3VCPortalTraverser@@A+164
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__sector_traversal.cpp

; 85   : {

	sub	esp, 44					; 0000002cH
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1531 :         return _My_data._Myfirst == _My_data._Mylast;

	mov	edx, DWORD PTR ?PortalTraverser@@3VCPortalTraverser@@A+168
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__sector_traversal.cpp

; 85   : {

	push	ebx
	push	esi
	push	edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1531 :         return _My_data._Myfirst == _My_data._Mylast;

	cmp	ecx, edx
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__sector_traversal.cpp

; 86   : 	if (f_portals.empty())			return;

	je	$LN1@fade_rende
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 7080 :     _Sort_unchecked(_UFirst, _ULast, _ULast - _UFirst, _Pass_fn(_Pred));

	mov	eax, edx
	sub	eax, ecx
	sar	eax, 3
	push	OFFSET ?psort_pred@@YA_NABU?$pair@PAVCPortal@@M@std@@0@Z ; psort_pred
	push	eax
	call	??$_Sort_unchecked@PAU?$pair@PAVCPortal@@M@std@@P6A_NABU12@0@Z@std@@YAXPAU?$pair@PAVCPortal@@M@0@0HP6A_NABU10@1@Z@Z ; std::_Sort_unchecked<std::pair<CPortal *,float> *,bool (__cdecl*)(std::pair<CPortal *,float> const &,std::pair<CPortal *,float> const &)>
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	edx, DWORD PTR ?PortalTraverser@@3VCPortalTraverser@@A+168
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__sector_traversal.cpp

; 92   : 	u32		_pcount					= 0;

	xor	ebx, ebx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	esi, DWORD PTR ?PortalTraverser@@3VCPortalTraverser@@A+164
	mov	eax, edx
	sub	eax, esi
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__sector_traversal.cpp

; 92   : 	u32		_pcount					= 0;

	mov	DWORD PTR __pcount$1$[esp+64], ebx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	sar	eax, 3
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 7080 :     _Sort_unchecked(_UFirst, _ULast, _ULast - _UFirst, _Pass_fn(_Pred));

	add	esp, 8
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__sector_traversal.cpp

; 93   : 	for		(u32 _it = 0; _it<f_portals.size(); _it++)	_pcount	+= f_portals[_it].first->getPoly().size()-2;

	xor	ecx, ecx
	test	eax, eax
	je	SHORT $LN3@fade_rende
	sub	edx, esi
	sar	edx, 3
	npad	7
$LL4@fade_rende:
	mov	eax, DWORD PTR [esi+ecx*8]
	add	ebx, -2					; fffffffeH
	inc	ecx
	mov	eax, DWORD PTR [eax+100]
	add	ebx, eax
	cmp	ecx, edx
	jb	SHORT $LL4@fade_rende
	mov	DWORD PTR __pcount$1$[esp+56], ebx
$LN3@fade_rende:
; File I:\Vitalya\mine\NSProjectX\xrEngine\shader.h

; 67   : 	u32					stride()	const { return _get()->vb_stride; }

	mov	eax, DWORD PTR ?PortalTraverser@@3VCPortalTraverser@@A+180
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__sector_traversal.cpp

; 97   : 	FVF::L*		_v					= (FVF::L*)RCache.Vertex.Lock(_pcount*3,f_geom.stride(),_offset);

	lea	edx, DWORD PTR __offset$[esp+56]
	push	edx
	mov	DWORD PTR __offset$[esp+60], 0
	lea	ecx, DWORD PTR [ebx+ebx*2]
	mov	DWORD PTR tv1595[esp+60], ecx
	push	DWORD PTR [eax+20]
	push	ecx
	mov	ecx, DWORD PTR __imp_?RCache@@3VCBackend@@A
	call	DWORD PTR __imp_?Lock@_VertexStream@@QAEPAXIIAAI@Z

; 99   : 	Fvector		_ambient_f			= g_pGamePersistent->Environment().CurrentEnv->ambient;

	mov	ecx, DWORD PTR __imp_?g_pGamePersistent@@3PAVIGame_Persistent@@A
	mov	edi, eax
; File I:\Vitalya\mine\NSProjectX\xrCore\_color.h

; 9    : 	s32	 _r = clampr(iFloor(r*255.f),0,255);

	movss	xmm1, DWORD PTR __real@437f0000
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__sector_traversal.cpp

; 98   : 	float		ssaRange			= r_ssaLOD_A - r_ssaLOD_B;

	movss	xmm2, DWORD PTR ?r_ssaLOD_A@@3MA
	movss	xmm5, DWORD PTR ?r_ssaLOD_B@@3MA

; 99   : 	Fvector		_ambient_f			= g_pGamePersistent->Environment().CurrentEnv->ambient;

	mov	ecx, DWORD PTR [ecx]
	subss	xmm2, xmm5
	mov	ecx, DWORD PTR [ecx+1116]
	mov	ecx, DWORD PTR [ecx+440]
	mov	eax, DWORD PTR [ecx+120]
	mov	DWORD PTR __ambient_f$[esp+56], eax
; File I:\Vitalya\mine\NSProjectX\xrCore\_color.h

; 9    : 	s32	 _r = clampr(iFloor(r*255.f),0,255);

	movss	xmm0, DWORD PTR __ambient_f$[esp+56]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__sector_traversal.cpp

; 99   : 	Fvector		_ambient_f			= g_pGamePersistent->Environment().CurrentEnv->ambient;

	mov	eax, DWORD PTR [ecx+124]
	mov	DWORD PTR __ambient_f$[esp+60], eax
	mov	eax, DWORD PTR [ecx+128]
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h

; 84   :     int exponent	= (127 + 31) - ((a >> 23) & 0xFF);

	mov	ecx, 158				; 0000009eH
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__sector_traversal.cpp

; 99   : 	Fvector		_ambient_f			= g_pGamePersistent->Environment().CurrentEnv->ambient;

	mov	DWORD PTR __ambient_f$[esp+64], eax
; File I:\Vitalya\mine\NSProjectX\xrCore\_color.h

; 9    : 	s32	 _r = clampr(iFloor(r*255.f),0,255);

	mulss	xmm0, xmm1
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h

; 83   :     int a			= *(const int*)(&x);

	movss	DWORD PTR _a$4[esp+56], xmm0

; 84   :     int exponent	= (127 + 31) - ((a >> 23) & 0xFF);

	mov	esi, DWORD PTR _a$4[esp+56]
	mov	eax, esi
	sar	eax, 23					; 00000017H

; 85   :     int r			= (((u32)(a) << 8) | (1U << 31)) >> exponent;

	mov	ebx, esi
	movzx	eax, al
	or	ebx, -8388608				; ff800000H
	sub	ecx, eax
	shl	ebx, 8
	shr	ebx, cl

; 86   :     exponent		+= 31-127;
; 87   :     {
; 88   :         int imask	=	(!(((( (1<<(exponent)))-1)>>8)&a));

	mov	eax, 1
	sub	ecx, 96					; 00000060H

; 89   :         exponent	-=	(31-127)+32;
; 90   :         exponent	>>=	31;
; 91   :         a			>>=	31;

	mov	edx, esi
	shl	eax, cl
	dec	eax
	sar	edx, 31					; 0000001fH
	sar	eax, 8
	and	eax, esi
	neg	eax
	sbb	eax, eax
	inc	eax
	and	eax, edx

; 92   :         r			-=	(imask&a);

	sub	ebx, eax
	lea	eax, DWORD PTR [ecx+64]
	sar	eax, 31					; 0000001fH

; 93   :         r			&=	exponent;

	and	ebx, eax
; File I:\Vitalya\mine\NSProjectX\xrCore\vector.h

; 96   : 	if		( val<_low	)	return _low; 

	mov	eax, 255				; 000000ffH
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h

; 93   :         r			&=	exponent;

	xor	ebx, edx
; File I:\Vitalya\mine\NSProjectX\xrCore\vector.h

; 96   : 	if		( val<_low	)	return _low; 

	jge	SHORT $LN65@fade_rende
	mov	DWORD PTR __r$1$[esp+56], 0
	jmp	SHORT $LN67@fade_rende
$LN65@fade_rende:

; 97   : 	else if	( val>_high )	return _high;

	cmp	ebx, eax
	cmovg	ebx, eax
	mov	DWORD PTR __r$1$[esp+56], ebx
$LN67@fade_rende:
; File I:\Vitalya\mine\NSProjectX\xrCore\_color.h

; 10   : 	s32	 _g = clampr(iFloor(g*255.f),0,255);

	movss	xmm0, DWORD PTR __ambient_f$[esp+60]
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h

; 84   :     int exponent	= (127 + 31) - ((a >> 23) & 0xFF);

	mov	ecx, 158				; 0000009eH
; File I:\Vitalya\mine\NSProjectX\xrCore\_color.h

; 10   : 	s32	 _g = clampr(iFloor(g*255.f),0,255);

	mulss	xmm0, xmm1
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h

; 83   :     int a			= *(const int*)(&x);

	movss	DWORD PTR _a$2[esp+56], xmm0

; 84   :     int exponent	= (127 + 31) - ((a >> 23) & 0xFF);

	mov	esi, DWORD PTR _a$2[esp+56]
	mov	eax, esi
	sar	eax, 23					; 00000017H

; 85   :     int r			= (((u32)(a) << 8) | (1U << 31)) >> exponent;

	mov	ebx, esi
	movzx	eax, al
	or	ebx, -8388608				; ff800000H
	sub	ecx, eax
	shl	ebx, 8
	shr	ebx, cl

; 86   :     exponent		+= 31-127;
; 87   :     {
; 88   :         int imask	=	(!(((( (1<<(exponent)))-1)>>8)&a));

	mov	eax, 1
	sub	ecx, 96					; 00000060H

; 89   :         exponent	-=	(31-127)+32;
; 90   :         exponent	>>=	31;
; 91   :         a			>>=	31;

	mov	edx, esi
	shl	eax, cl
	dec	eax
	sar	edx, 31					; 0000001fH
	sar	eax, 8
	and	eax, esi
	neg	eax
	sbb	eax, eax
	inc	eax
	and	eax, edx

; 92   :         r			-=	(imask&a);

	sub	ebx, eax
	lea	eax, DWORD PTR [ecx+64]
	sar	eax, 31					; 0000001fH

; 93   :         r			&=	exponent;

	and	ebx, eax
	xor	ebx, edx
; File I:\Vitalya\mine\NSProjectX\xrCore\vector.h

; 96   : 	if		( val<_low	)	return _low; 

	jge	SHORT $LN73@fade_rende
	xor	ebx, ebx
	jmp	SHORT $LN75@fade_rende
$LN73@fade_rende:

; 97   : 	else if	( val>_high )	return _high;

	cmp	ebx, 255				; 000000ffH
	mov	eax, 255				; 000000ffH
	cmovg	ebx, eax
$LN75@fade_rende:
; File I:\Vitalya\mine\NSProjectX\xrCore\_color.h

; 11   : 	s32	 _b = clampr(iFloor(b*255.f),0,255);

	movss	xmm0, DWORD PTR __ambient_f$[esp+64]
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h

; 84   :     int exponent	= (127 + 31) - ((a >> 23) & 0xFF);

	mov	ecx, 158				; 0000009eH
; File I:\Vitalya\mine\NSProjectX\xrCore\_color.h

; 11   : 	s32	 _b = clampr(iFloor(b*255.f),0,255);

	mulss	xmm0, xmm1
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h

; 83   :     int a			= *(const int*)(&x);

	movss	DWORD PTR _a$1[esp+56], xmm0

; 84   :     int exponent	= (127 + 31) - ((a >> 23) & 0xFF);

	mov	esi, DWORD PTR _a$1[esp+56]
	mov	eax, esi
	sar	eax, 23					; 00000017H

; 89   :         exponent	-=	(31-127)+32;
; 90   :         exponent	>>=	31;
; 91   :         a			>>=	31;

	mov	edx, esi
	movzx	eax, al
	sub	ecx, eax
	sar	edx, 31					; 0000001fH
	mov	eax, esi
	or	eax, -8388608				; ff800000H
	shl	eax, 8
	shr	eax, cl
	sub	ecx, 96					; 00000060H
	mov	DWORD PTR __b$1$[esp+56], eax
	mov	eax, 1
	shl	eax, cl
	dec	eax
	sar	eax, 8
	and	eax, esi
	neg	eax
	sbb	eax, eax
	inc	eax
	and	eax, edx

; 92   :         r			-=	(imask&a);

	sub	DWORD PTR __b$1$[esp+56], eax
	lea	eax, DWORD PTR [ecx+64]

; 93   :         r			&=	exponent;

	mov	ecx, DWORD PTR __b$1$[esp+56]
	sar	eax, 31					; 0000001fH
	and	ecx, eax
	xor	ecx, edx
; File I:\Vitalya\mine\NSProjectX\xrCore\vector.h

; 96   : 	if		( val<_low	)	return _low; 

	jge	SHORT $LN81@fade_rende
	xor	ecx, ecx
	jmp	SHORT $LN83@fade_rende
$LN81@fade_rende:

; 97   : 	else if	( val>_high )	return _high;

	cmp	ecx, 255				; 000000ffH
	mov	eax, 255				; 000000ffH
	cmovg	ecx, eax
$LN83@fade_rende:
; File I:\Vitalya\mine\NSProjectX\xrCore\_color.h

; 5    : ICF u32	color_argb	(u32 a, u32 r, u32 g, u32 b)	{	return ((a&0xff)<<24)|((r&0xff)<<16)|((g&0xff)<<8)|(b&0xff);	}

	mov	eax, DWORD PTR __r$1$[esp+56]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__sector_traversal.cpp

; 101  : 	for (u32 _it = 0; _it<f_portals.size(); _it++)

	xor	edx, edx
; File I:\Vitalya\mine\NSProjectX\xrCore\_color.h

; 5    : ICF u32	color_argb	(u32 a, u32 r, u32 g, u32 b)	{	return ((a&0xff)<<24)|((r&0xff)<<16)|((g&0xff)<<8)|(b&0xff);	}

	shl	eax, 8
	movzx	ebx, bl
	or	ebx, eax
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__sector_traversal.cpp

; 101  : 	for (u32 _it = 0; _it<f_portals.size(); _it++)

	mov	DWORD PTR __it$1$[esp+56], edx
; File I:\Vitalya\mine\NSProjectX\xrCore\_color.h

; 5    : ICF u32	color_argb	(u32 a, u32 r, u32 g, u32 b)	{	return ((a&0xff)<<24)|((r&0xff)<<16)|((g&0xff)<<8)|(b&0xff);	}

	movzx	eax, cl
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	ecx, DWORD PTR ?PortalTraverser@@3VCPortalTraverser@@A+164
; File I:\Vitalya\mine\NSProjectX\xrCore\_color.h

; 5    : ICF u32	color_argb	(u32 a, u32 r, u32 g, u32 b)	{	return ((a&0xff)<<24)|((r&0xff)<<16)|((g&0xff)<<8)|(b&0xff);	}

	shl	ebx, 8
	or	ebx, eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	eax, DWORD PTR ?PortalTraverser@@3VCPortalTraverser@@A+168
	sub	eax, ecx
	sar	eax, 3
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__sector_traversal.cpp

; 101  : 	for (u32 _it = 0; _it<f_portals.size(); _it++)

	test	eax, eax
	je	$LN6@fade_rende
	movss	xmm4, DWORD PTR __real@3f800000
	and	ebx, 16777215				; 00ffffffH
	movaps	xmm3, xmm4
	mov	DWORD PTR __ambient$1$[esp+56], ebx
	divss	xmm3, xmm2
	movss	xmm2, DWORD PTR __real@437f8000
	npad	3
$LL7@fade_rende:

; 102  : 	{
; 103  : 		std::pair<CPortal*, float>&	fp		= f_portals	[_it]	;
; 104  : 		CPortal*					_P		= fp.first	;
; 105  : 		float						_ssa	= fp.second	;
; 106  : 		float		ssaDiff					= _ssa-r_ssaLOD_B	;

	movss	xmm1, DWORD PTR [ecx+edx*8+4]

; 108  : 		int			iA						= iFloor((1-ssaScale)*255.5f);	clamp(iA,0,255);

	movaps	xmm0, xmm4
	mov	eax, DWORD PTR [ecx+edx*8]
	subss	xmm1, xmm5
	mov	DWORD PTR __P$1$[esp+56], eax
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h

; 84   :     int exponent	= (127 + 31) - ((a >> 23) & 0xFF);

	mov	ecx, 158				; 0000009eH
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__sector_traversal.cpp

; 107  : 		float		ssaScale				= ssaDiff/ssaRange	;

	mulss	xmm1, xmm3

; 108  : 		int			iA						= iFloor((1-ssaScale)*255.5f);	clamp(iA,0,255);

	subss	xmm0, xmm1
	mulss	xmm0, xmm2
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h

; 83   :     int a			= *(const int*)(&x);

	movss	DWORD PTR _a$3[esp+56], xmm0

; 84   :     int exponent	= (127 + 31) - ((a >> 23) & 0xFF);

	mov	esi, DWORD PTR _a$3[esp+56]
	mov	eax, esi
	sar	eax, 23					; 00000017H

; 85   :     int r			= (((u32)(a) << 8) | (1U << 31)) >> exponent;

	mov	ebx, esi
	movzx	eax, al
	or	ebx, -8388608				; ff800000H
	sub	ecx, eax
	shl	ebx, 8
	shr	ebx, cl

; 86   :     exponent		+= 31-127;
; 87   :     {
; 88   :         int imask	=	(!(((( (1<<(exponent)))-1)>>8)&a));

	mov	eax, 1
	sub	ecx, 96					; 00000060H

; 89   :         exponent	-=	(31-127)+32;
; 90   :         exponent	>>=	31;
; 91   :         a			>>=	31;

	mov	edx, esi
	shl	eax, cl
	dec	eax
	sar	edx, 31					; 0000001fH
	sar	eax, 8
	and	eax, esi
	neg	eax
	sbb	eax, eax
	inc	eax
	and	eax, edx

; 92   :         r			-=	(imask&a);

	sub	ebx, eax
	lea	eax, DWORD PTR [ecx+64]
	sar	eax, 31					; 0000001fH

; 93   :         r			&=	exponent;

	and	ebx, eax
	xor	ebx, edx
; File I:\Vitalya\mine\NSProjectX\xrCore\vector.h

; 92   : 	if( val<_low ) val = _low; else if( val>_high ) val = _high;

	jge	SHORT $LN120@fade_rende
	xor	ebx, ebx
	jmp	SHORT $LN122@fade_rende
$LN120@fade_rende:
	cmp	ebx, 255				; 000000ffH
	mov	eax, 255				; 000000ffH
	cmovg	ebx, eax
$LN122@fade_rende:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__sector_traversal.cpp

; 112  : 		u32			_polys					= _P->getPoly().size()-2;

	mov	ecx, DWORD PTR __P$1$[esp+56]
; File I:\Vitalya\mine\NSProjectX\xrCore\_color.h

; 5    : ICF u32	color_argb	(u32 a, u32 r, u32 g, u32 b)	{	return ((a&0xff)<<24)|((r&0xff)<<16)|((g&0xff)<<8)|(b&0xff);	}

	shl	ebx, 24					; 00000018H

; 21   : ICF u32 subst_alpha	(u32 rgba, u32 a)				{	return rgba&~color_rgba(0,0,0,0xff)|color_rgba(0,0,0,a);}

	or	ebx, DWORD PTR __ambient$1$[esp+56]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__sector_traversal.cpp

; 112  : 		u32			_polys					= _P->getPoly().size()-2;

	mov	edx, DWORD PTR [ecx+100]
	sub	edx, 2

; 113  : 		for			(u32 _pit=0; _pit<_polys; _pit++)	{

	je	SHORT $LN5@fade_rende
; File I:\Vitalya\mine\NSProjectX\xrCore\_color.h

; 21   : ICF u32 subst_alpha	(u32 rgba, u32 a)				{	return rgba&~color_rgba(0,0,0,0xff)|color_rgba(0,0,0,a);}

	lea	eax, DWORD PTR [ecx+24]
$LL10@fade_rende:
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 24   : 	ICF SelfRef	set(const _vector3<float> &v)			{ x = T(v.x);	y = T(v.y);	z = T(v.z);	return *this;	};

	fld	DWORD PTR [ecx+4]
	fstp	DWORD PTR [edi]
	fld	DWORD PTR [ecx+8]
	fstp	DWORD PTR [edi+4]
	fld	DWORD PTR [ecx+12]
	fstp	DWORD PTR [edi+8]
; File I:\Vitalya\mine\NSProjectX\xrEngine\fvf.h

; 13   : 		IC void		set(const Fvector& _p, u32 C) { p.set(_p); color = C; }

	mov	DWORD PTR [edi+12], ebx
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 24   : 	ICF SelfRef	set(const _vector3<float> &v)			{ x = T(v.x);	y = T(v.y);	z = T(v.z);	return *this;	};

	fld	DWORD PTR [eax-8]
	fstp	DWORD PTR [edi+16]
	fld	DWORD PTR [eax-4]
	fstp	DWORD PTR [edi+20]
	fld	DWORD PTR [eax]
	fstp	DWORD PTR [edi+24]
; File I:\Vitalya\mine\NSProjectX\xrEngine\fvf.h

; 13   : 		IC void		set(const Fvector& _p, u32 C) { p.set(_p); color = C; }

	mov	DWORD PTR [edi+28], ebx
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 24   : 	ICF SelfRef	set(const _vector3<float> &v)			{ x = T(v.x);	y = T(v.y);	z = T(v.z);	return *this;	};

	fld	DWORD PTR [eax+4]
	fstp	DWORD PTR [edi+32]
	fld	DWORD PTR [eax+8]
	add	eax, 12					; 0000000cH
	fstp	DWORD PTR [edi+36]
	fld	DWORD PTR [eax]
	fstp	DWORD PTR [edi+40]
; File I:\Vitalya\mine\NSProjectX\xrEngine\fvf.h

; 13   : 		IC void		set(const Fvector& _p, u32 C) { p.set(_p); color = C; }

	mov	DWORD PTR [edi+44], ebx
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__sector_traversal.cpp

; 116  : 			_v->set (_P->getPoly()[_pit+2],_clr);	_v++;

	add	edi, 48					; 00000030H
	sub	edx, 1
	jne	SHORT $LL10@fade_rende
$LN5@fade_rende:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	eax, DWORD PTR ?PortalTraverser@@3VCPortalTraverser@@A+168
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__sector_traversal.cpp

; 101  : 	for (u32 _it = 0; _it<f_portals.size(); _it++)

	mov	edx, DWORD PTR __it$1$[esp+56]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	ecx, DWORD PTR ?PortalTraverser@@3VCPortalTraverser@@A+164
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__sector_traversal.cpp

; 101  : 	for (u32 _it = 0; _it<f_portals.size(); _it++)

	inc	edx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	sub	eax, ecx
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__sector_traversal.cpp

; 101  : 	for (u32 _it = 0; _it<f_portals.size(); _it++)

	mov	DWORD PTR __it$1$[esp+56], edx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	sar	eax, 3
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__sector_traversal.cpp

; 101  : 	for (u32 _it = 0; _it<f_portals.size(); _it++)

	cmp	edx, eax
	jb	$LL7@fade_rende
$LN6@fade_rende:

; 117  : 		}
; 118  : 	}
; 119  : 	RCache.Vertex.Unlock			(_pcount*3,f_geom.stride());

	mov	eax, DWORD PTR ?PortalTraverser@@3VCPortalTraverser@@A+180
	mov	ecx, DWORD PTR __imp_?RCache@@3VCBackend@@A
	push	DWORD PTR [eax+20]
	push	DWORD PTR tv1595[esp+60]
	call	DWORD PTR __imp_?Unlock@_VertexStream@@QAEXII@Z

; 120  : 
; 121  : 	// render
; 122  : 	RCache.set_xform_world			(Fidentity);

	push	DWORD PTR __imp_?Fidentity@@3U?$_matrix@M@@A
	mov	ecx, DWORD PTR __imp_?RCache@@3VCBackend@@A
	call	DWORD PTR __imp_?set_xform_world@CBackend@@QAEXABU?$_matrix@M@@@Z

; 123  : 	RCache.set_Shader				(f_shader);

	mov	ecx, DWORD PTR __imp_?RCache@@3VCBackend@@A
	push	0
	push	OFFSET ?PortalTraverser@@3VCPortalTraverser@@A+176
	call	DWORD PTR __imp_?set_Shader@CBackend@@QAEXAAV?$resptr_core@UShader@@Uresptrcode_shader@@@@I@Z
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 70   : 	T &					operator*() const												{	return *p_;	}

	mov	edi, DWORD PTR ?PortalTraverser@@3VCPortalTraverser@@A+180
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__sector_traversal.cpp

; 124  : 	RCache.set_Geometry				(f_geom);

	mov	esi, DWORD PTR __imp_?RCache@@3VCBackend@@A
; File I:\Vitalya\mine\NSProjectX\xrEngine\R_Backend_Runtime.h

; 224  : 	set_Format(_geom->dcl._get()->dcl);

	mov	eax, DWORD PTR [edi+8]
	mov	edx, DWORD PTR [eax+8]

; 131  : 	if (decl != _decl)

	cmp	DWORD PTR [esi+592], edx
	je	SHORT $LN174@fade_rende

; 132  : 	{
; 133  : 		PGO(Msg("PGO:v_format:%x", _decl));
; 134  : #ifdef DEBUG
; 135  : 		stat.decl++;
; 136  : #endif
; 137  : 		decl = _decl;

	mov	DWORD PTR [esi+592], edx

; 138  : 		CHK_DX(HW.pDevice->SetVertexDeclaration(decl));

	mov	eax, DWORD PTR __imp_?HW@@3VCHW@@A
	push	edx
	mov	eax, DWORD PTR [eax+8]
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+348]
$LN174@fade_rende:

; 225  : 	set_Vertices(_geom->vb, _geom->vb_stride);

	mov	ebx, DWORD PTR [edi+12]
	mov	edx, DWORD PTR [edi+20]

; 172  : 	if ((vb != _vb) || (vb_stride != _vb_stride))

	cmp	DWORD PTR [esi+596], ebx
	jne	SHORT $LN178@fade_rende
	cmp	DWORD PTR [esi+604], edx
	je	SHORT $LN177@fade_rende
$LN178@fade_rende:

; 173  : 	{
; 174  : 		PGO(Msg("PGO:VB:%x,%d", _vb, _vb_stride));
; 175  : #ifdef DEBUG
; 176  : 		stat.vb++;
; 177  : #endif
; 178  : 		vb = _vb;

	mov	DWORD PTR [esi+596], ebx

; 179  : 		vb_stride = _vb_stride;

	mov	DWORD PTR [esi+604], edx

; 180  : 		CHK_DX(HW.pDevice->SetStreamSource(0, vb, 0, vb_stride));

	mov	eax, DWORD PTR __imp_?HW@@3VCHW@@A
	push	edx
	push	0
	push	ebx
	mov	eax, DWORD PTR [eax+8]
	push	0
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+400]
$LN177@fade_rende:

; 226  : 	set_Indices(_geom->ib);

	mov	edx, DWORD PTR [edi+16]

; 186  : 	if (ib != _ib)

	cmp	DWORD PTR [esi+600], edx
	je	SHORT $LN181@fade_rende

; 187  : 	{
; 188  : 		PGO(Msg("PGO:IB:%x", _ib));
; 189  : #ifdef DEBUG
; 190  : 		stat.ib++;
; 191  : #endif
; 192  : 		ib = _ib;

	mov	DWORD PTR [esi+600], edx

; 193  : 		CHK_DX(HW.pDevice->SetIndices(ib));

	mov	eax, DWORD PTR __imp_?HW@@3VCHW@@A
	push	edx
	mov	eax, DWORD PTR [eax+8]
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+416]
$LN181@fade_rende:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__sector_traversal.cpp

; 125  : 	RCache.set_CullMode				(CULL_NONE);

	mov	eax, DWORD PTR __imp_?RCache@@3VCBackend@@A
; File I:\Vitalya\mine\NSProjectX\xrEngine\R_Backend_Runtime.h

; 266  : 	if (cull_mode != _mode) { cull_mode = _mode;			CHK_DX(HW.pDevice->SetRenderState(D3DRS_CULLMODE, _mode)); }

	cmp	DWORD PTR [eax+8916], 1
	je	SHORT $LN184@fade_rende
	mov	DWORD PTR [eax+8916], 1
	mov	eax, DWORD PTR __imp_?HW@@3VCHW@@A
	push	1
	push	22					; 00000016H
	mov	eax, DWORD PTR [eax+8]
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+228]
$LN184@fade_rende:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__sector_traversal.cpp

; 126  : 	RCache.Render					(D3DPT_TRIANGLELIST,_offset,_pcount);

	mov	eax, DWORD PTR __imp_?RCache@@3VCBackend@@A
	mov	edi, DWORD PTR __offset$[esp+56]
; File I:\Vitalya\mine\NSProjectX\xrEngine\R_Backend_Runtime.h

; 210  : 	stat.verts += 3 * PC;

	mov	ecx, DWORD PTR tv1595[esp+56]

; 211  : 	stat.polys += PC;

	mov	esi, DWORD PTR __pcount$1$[esp+56]
	add	DWORD PTR [eax+9020], ecx

; 212  : 	constants.flush();

	lea	ecx, DWORD PTR [eax+608]
	inc	DWORD PTR [eax+9024]
	add	DWORD PTR [eax+9016], esi
; File I:\Vitalya\mine\NSProjectX\xrEngine\r_constants_cache.h

; 172  : 		if (a_pixel.b_dirty || a_vertex.b_dirty)	flush_cache();

	cmp	DWORD PTR [ecx+4112], 0
	jne	SHORT $LN190@fade_rende
	cmp	DWORD PTR [ecx+8240], 0
	je	SHORT $LN189@fade_rende
$LN190@fade_rende:
	call	DWORD PTR __imp_?flush_cache@R_constants@@QAEXXZ
$LN189@fade_rende:
; File I:\Vitalya\mine\NSProjectX\xrEngine\R_Backend_Runtime.h

; 213  : 	CHK_DX(HW.pDevice->DrawPrimitive(T, startV, PC));

	mov	eax, DWORD PTR __imp_?HW@@3VCHW@@A
	push	esi
	push	edi
	push	4
	mov	eax, DWORD PTR [eax+8]
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+324]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__sector_traversal.cpp

; 127  : 	RCache.set_CullMode				(CULL_CCW);

	mov	eax, DWORD PTR __imp_?RCache@@3VCBackend@@A
; File I:\Vitalya\mine\NSProjectX\xrEngine\R_Backend_Runtime.h

; 266  : 	if (cull_mode != _mode) { cull_mode = _mode;			CHK_DX(HW.pDevice->SetRenderState(D3DRS_CULLMODE, _mode)); }

	cmp	DWORD PTR [eax+8916], 3
	je	SHORT $LN193@fade_rende
	mov	DWORD PTR [eax+8916], 3
	mov	eax, DWORD PTR __imp_?HW@@3VCHW@@A
	push	3
	push	22					; 00000016H
	mov	eax, DWORD PTR [eax+8]
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+228]
$LN193@fade_rende:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__sector_traversal.cpp

; 130  : 	f_portals.clear					();

	mov	eax, DWORD PTR ?PortalTraverser@@3VCPortalTraverser@@A+164
	mov	DWORD PTR ?PortalTraverser@@3VCPortalTraverser@@A+168, eax
$LN1@fade_rende:

; 131  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?fade_render@CPortalTraverser@@QAEXXZ ENDP		; CPortalTraverser::fade_render
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ??A?$xr_vector@U?$pair@PAVCPortal@@M@std@@V?$xalloc@U?$pair@PAVCPortal@@M@std@@@@@@QAEAAU?$pair@PAVCPortal@@M@std@@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$xr_vector@U?$pair@PAVCPortal@@M@std@@V?$xalloc@U?$pair@PAVCPortal@@M@std@@@@@@QAEAAU?$pair@PAVCPortal@@M@std@@I@Z PROC ; xr_vector<std::pair<CPortal *,float>,xalloc<std::pair<CPortal *,float> > >::operator[], COMDAT
; _this$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 119  :         _Ptr += _Off;

	mov	ecx, DWORD PTR [ecx]
	mov	eax, DWORD PTR __Pos$[esp-4]
	lea	eax, DWORD PTR [ecx+eax*8]
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 138  : 	reference operator[]		(size_type _Pos)					{ {VERIFY(_Pos<size());} return (*(begin() + _Pos)); }

	ret	4
??A?$xr_vector@U?$pair@PAVCPortal@@M@std@@V?$xalloc@U?$pair@PAVCPortal@@M@std@@@@@@QAEAAU?$pair@PAVCPortal@@M@std@@I@Z ENDP ; xr_vector<std::pair<CPortal *,float>,xalloc<std::pair<CPortal *,float> > >::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?clear@?$xr_vector@U?$pair@PAVCPortal@@M@std@@V?$xalloc@U?$pair@PAVCPortal@@M@std@@@@@@QAEXXZ
_TEXT	SEGMENT
?clear@?$xr_vector@U?$pair@PAVCPortal@@M@std@@V?$xalloc@U?$pair@PAVCPortal@@M@std@@@@@@QAEXXZ PROC ; xr_vector<std::pair<CPortal *,float>,xalloc<std::pair<CPortal *,float> > >::clear, COMDAT
; _this$ = ecx

; 132  : 	void	clear				()									{ clear_and_free	();			}

	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [ecx+4], eax
	ret	0
?clear@?$xr_vector@U?$pair@PAVCPortal@@M@std@@V?$xalloc@U?$pair@PAVCPortal@@M@std@@@@@@QAEXXZ ENDP ; xr_vector<std::pair<CPortal *,float>,xalloc<std::pair<CPortal *,float> > >::clear
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?size@?$xr_vector@U?$pair@PAVCPortal@@M@std@@V?$xalloc@U?$pair@PAVCPortal@@M@std@@@@@@QBEIXZ
_TEXT	SEGMENT
?size@?$xr_vector@U?$pair@PAVCPortal@@M@std@@V?$xalloc@U?$pair@PAVCPortal@@M@std@@@@@@QBEIXZ PROC ; xr_vector<std::pair<CPortal *,float>,xalloc<std::pair<CPortal *,float> > >::size, COMDAT
; _this$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	eax, DWORD PTR [ecx+4]
	sub	eax, DWORD PTR [ecx]
	sar	eax, 3
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 125  : 	u32		size				() const							{ return (u32)inherited::size();} 

	ret	0
?size@?$xr_vector@U?$pair@PAVCPortal@@M@std@@V?$xalloc@U?$pair@PAVCPortal@@M@std@@@@@@QBEIXZ ENDP ; xr_vector<std::pair<CPortal *,float>,xalloc<std::pair<CPortal *,float> > >::size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ??0?$xr_vector@U?$pair@PAVCPortal@@M@std@@V?$xalloc@U?$pair@PAVCPortal@@M@std@@@@@@QAE@XZ
_TEXT	SEGMENT
??0?$xr_vector@U?$pair@PAVCPortal@@M@std@@V?$xalloc@U?$pair@PAVCPortal@@M@std@@@@@@QAE@XZ PROC ; xr_vector<std::pair<CPortal *,float>,xalloc<std::pair<CPortal *,float> > >::xr_vector<std::pair<CPortal *,float>,xalloc<std::pair<CPortal *,float> > >, COMDAT
; _this$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx], 0
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 122  : 			xr_vector			()									: inherited	()					{}

	mov	eax, ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 122  : 			xr_vector			()									: inherited	()					{}

	ret	0
??0?$xr_vector@U?$pair@PAVCPortal@@M@std@@V?$xalloc@U?$pair@PAVCPortal@@M@std@@@@@@QAE@XZ ENDP ; xr_vector<std::pair<CPortal *,float>,xalloc<std::pair<CPortal *,float> > >::xr_vector<std::pair<CPortal *,float>,xalloc<std::pair<CPortal *,float> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?empty@?$vector@U?$pair@PAVCPortal@@M@std@@V?$xalloc@U?$pair@PAVCPortal@@M@std@@@@@std@@QBE_NXZ
_TEXT	SEGMENT
?empty@?$vector@U?$pair@PAVCPortal@@M@std@@V?$xalloc@U?$pair@PAVCPortal@@M@std@@@@@std@@QBE_NXZ PROC ; std::vector<std::pair<CPortal *,float>,xalloc<std::pair<CPortal *,float> > >::empty, COMDAT
; _this$ = ecx

; 1530 :         auto& _My_data = _Mypair._Myval2;
; 1531 :         return _My_data._Myfirst == _My_data._Mylast;

	mov	eax, DWORD PTR [ecx]
	cmp	eax, DWORD PTR [ecx+4]
	sete	al

; 1532 :     }

	ret	0
?empty@?$vector@U?$pair@PAVCPortal@@M@std@@V?$xalloc@U?$pair@PAVCPortal@@M@std@@@@@std@@QBE_NXZ ENDP ; std::vector<std::pair<CPortal *,float>,xalloc<std::pair<CPortal *,float> > >::empty
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?end@?$vector@U?$pair@PAVCPortal@@M@std@@V?$xalloc@U?$pair@PAVCPortal@@M@std@@@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@PAVCPortal@@M@std@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@U?$pair@PAVCPortal@@M@std@@V?$xalloc@U?$pair@PAVCPortal@@M@std@@@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@PAVCPortal@@M@std@@@std@@@std@@@2@XZ PROC ; std::vector<std::pair<CPortal *,float>,xalloc<std::pair<CPortal *,float> > >::end, COMDAT
; _this$ = ecx

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	ecx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax], ecx

; 1472 :         auto& _My_data = _Mypair._Myval2;
; 1473 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));
; 1474 :     }

	ret	4
?end@?$vector@U?$pair@PAVCPortal@@M@std@@V?$xalloc@U?$pair@PAVCPortal@@M@std@@@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@PAVCPortal@@M@std@@@std@@@std@@@2@XZ ENDP ; std::vector<std::pair<CPortal *,float>,xalloc<std::pair<CPortal *,float> > >::end
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?begin@?$vector@U?$pair@PAVCPortal@@M@std@@V?$xalloc@U?$pair@PAVCPortal@@M@std@@@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@PAVCPortal@@M@std@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@U?$pair@PAVCPortal@@M@std@@V?$xalloc@U?$pair@PAVCPortal@@M@std@@@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@PAVCPortal@@M@std@@@std@@@std@@@2@XZ PROC ; std::vector<std::pair<CPortal *,float>,xalloc<std::pair<CPortal *,float> > >::begin, COMDAT
; _this$ = ecx

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	ecx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], ecx

; 1462 :         auto& _My_data = _Mypair._Myval2;
; 1463 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));
; 1464 :     }

	ret	4
?begin@?$vector@U?$pair@PAVCPortal@@M@std@@V?$xalloc@U?$pair@PAVCPortal@@M@std@@@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@PAVCPortal@@M@std@@@std@@@std@@@2@XZ ENDP ; std::vector<std::pair<CPortal *,float>,xalloc<std::pair<CPortal *,float> > >::begin
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?reserve@?$vector@U?$pair@PAVCPortal@@M@std@@V?$xalloc@U?$pair@PAVCPortal@@M@std@@@@@std@@QAEXI@Z
_TEXT	SEGMENT
__Newcapacity$dead$ = 8					; size = 4
?reserve@?$vector@U?$pair@PAVCPortal@@M@std@@V?$xalloc@U?$pair@PAVCPortal@@M@std@@@@@std@@QAEXI@Z PROC ; std::vector<std::pair<CPortal *,float>,xalloc<std::pair<CPortal *,float> > >::reserve, COMDAT
; _this$ = ecx

; 1546 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx]
	sar	eax, 3

; 1357 :         // increase capacity to _Newcapacity (without geometric growth), provide strong guarantee
; 1358 :         if (_Newcapacity > capacity()) { // something to do (reserve() never shrinks)

	cmp	eax, 16					; 00000010H
	jb	?_Reallocate_exactly@?$vector@U?$pair@PAVCPortal@@M@std@@V?$xalloc@U?$pair@PAVCPortal@@M@std@@@@@std@@AAEXI@Z ; std::vector<std::pair<CPortal *,float>,xalloc<std::pair<CPortal *,float> > >::_Reallocate_exactly

; 1359 :             if (_Newcapacity > max_size()) {
; 1360 :                 _Xlength();
; 1361 :             }
; 1362 : 
; 1363 :             _Reallocate_exactly(_Newcapacity);
; 1364 :         }
; 1365 :     }

	ret	4
?reserve@?$vector@U?$pair@PAVCPortal@@M@std@@V?$xalloc@U?$pair@PAVCPortal@@M@std@@@@@std@@QAEXI@Z ENDP ; std::vector<std::pair<CPortal *,float>,xalloc<std::pair<CPortal *,float> > >::reserve
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?push_back@?$vector@U?$pair@PAVCPortal@@M@std@@V?$xalloc@U?$pair@PAVCPortal@@M@std@@@@@std@@QAEX$$QAU?$pair@PAVCPortal@@M@2@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?push_back@?$vector@U?$pair@PAVCPortal@@M@std@@V?$xalloc@U?$pair@PAVCPortal@@M@std@@@@@std@@QAEX$$QAU?$pair@PAVCPortal@@M@2@@Z PROC ; std::vector<std::pair<CPortal *,float>,xalloc<std::pair<CPortal *,float> > >::push_back, COMDAT
; _this$ = ecx

; 746  :     _CONSTEXPR20_CONTAINER void push_back(_Ty&& _Val) {

	push	esi

; 730  :         if (_Mylast != _My_data._Myend) {

	mov	esi, DWORD PTR [ecx+4]
	cmp	esi, DWORD PTR [ecx+8]
	je	SHORT $LN4@push_back

; 713  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

	mov	eax, DWORD PTR __Val$[esp]
	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR [esi], edx
	mov	DWORD PTR [esi+4], eax

; 714  :         _Orphan_range(_Mylast, _Mylast);
; 715  :         _Ty& _Result = *_Mylast;
; 716  :         ++_Mylast;

	add	DWORD PTR [ecx+4], 8
	pop	esi

; 747  :         // insert by moving into element at end, provide strong guarantee
; 748  :         emplace_back(_STD move(_Val));
; 749  :     }

	ret	4
$LN4@push_back:

; 734  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	push	DWORD PTR __Val$[esp]
	push	esi
	call	??$_Emplace_reallocate@U?$pair@PAVCPortal@@M@std@@@?$vector@U?$pair@PAVCPortal@@M@std@@V?$xalloc@U?$pair@PAVCPortal@@M@std@@@@@std@@QAEPAU?$pair@PAVCPortal@@M@1@QAU21@$$QAU21@@Z ; std::vector<std::pair<CPortal *,float>,xalloc<std::pair<CPortal *,float> > >::_Emplace_reallocate<std::pair<CPortal *,float> >
	pop	esi

; 747  :         // insert by moving into element at end, provide strong guarantee
; 748  :         emplace_back(_STD move(_Val));
; 749  :     }

	ret	4
?push_back@?$vector@U?$pair@PAVCPortal@@M@std@@V?$xalloc@U?$pair@PAVCPortal@@M@std@@@@@std@@QAEX$$QAU?$pair@PAVCPortal@@M@2@@Z ENDP ; std::vector<std::pair<CPortal *,float>,xalloc<std::pair<CPortal *,float> > >::push_back
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??$emplace_back@U?$pair@PAVCPortal@@M@std@@@?$vector@U?$pair@PAVCPortal@@M@std@@V?$xalloc@U?$pair@PAVCPortal@@M@std@@@@@std@@QAE?A_T$$QAU?$pair@PAVCPortal@@M@1@@Z
_TEXT	SEGMENT
_<_Val_0>$ = 8						; size = 4
??$emplace_back@U?$pair@PAVCPortal@@M@std@@@?$vector@U?$pair@PAVCPortal@@M@std@@V?$xalloc@U?$pair@PAVCPortal@@M@std@@@@@std@@QAE?A_T$$QAU?$pair@PAVCPortal@@M@1@@Z PROC ; std::vector<std::pair<CPortal *,float>,xalloc<std::pair<CPortal *,float> > >::emplace_back<std::pair<CPortal *,float> >, COMDAT
; _this$ = ecx

; 726  :     _CONSTEXPR20_CONTAINER decltype(auto) emplace_back(_Valty&&... _Val) {

	push	esi

; 727  :         // insert by perfectly forwarding into element at end, provide strong guarantee
; 728  :         auto& _My_data   = _Mypair._Myval2;
; 729  :         pointer& _Mylast = _My_data._Mylast;
; 730  :         if (_Mylast != _My_data._Myend) {

	mov	esi, DWORD PTR [ecx+4]
	cmp	esi, DWORD PTR [ecx+8]
	je	SHORT $LN2@emplace_ba

; 713  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

	mov	eax, DWORD PTR _<_Val_0>$[esp]
	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR [esi], edx
	mov	DWORD PTR [esi+4], eax

; 714  :         _Orphan_range(_Mylast, _Mylast);
; 715  :         _Ty& _Result = *_Mylast;
; 716  :         ++_Mylast;

	add	DWORD PTR [ecx+4], 8
	pop	esi

; 735  : #if _HAS_CXX17
; 736  :         return _Result;
; 737  : #else // ^^^ _HAS_CXX17 ^^^ // vvv !_HAS_CXX17 vvv
; 738  :         (void) _Result;
; 739  : #endif // _HAS_CXX17
; 740  :     }

	ret	4
$LN2@emplace_ba:

; 731  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);
; 732  :         }
; 733  : 
; 734  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	push	DWORD PTR _<_Val_0>$[esp]
	push	esi
	call	??$_Emplace_reallocate@U?$pair@PAVCPortal@@M@std@@@?$vector@U?$pair@PAVCPortal@@M@std@@V?$xalloc@U?$pair@PAVCPortal@@M@std@@@@@std@@QAEPAU?$pair@PAVCPortal@@M@1@QAU21@$$QAU21@@Z ; std::vector<std::pair<CPortal *,float>,xalloc<std::pair<CPortal *,float> > >::_Emplace_reallocate<std::pair<CPortal *,float> >
	pop	esi

; 735  : #if _HAS_CXX17
; 736  :         return _Result;
; 737  : #else // ^^^ _HAS_CXX17 ^^^ // vvv !_HAS_CXX17 vvv
; 738  :         (void) _Result;
; 739  : #endif // _HAS_CXX17
; 740  :     }

	ret	4
??$emplace_back@U?$pair@PAVCPortal@@M@std@@@?$vector@U?$pair@PAVCPortal@@M@std@@V?$xalloc@U?$pair@PAVCPortal@@M@std@@@@@std@@QAE?A_T$$QAU?$pair@PAVCPortal@@M@1@@Z ENDP ; std::vector<std::pair<CPortal *,float>,xalloc<std::pair<CPortal *,float> > >::emplace_back<std::pair<CPortal *,float> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??$_Emplace_back_with_unused_capacity@U?$pair@PAVCPortal@@M@std@@@?$vector@U?$pair@PAVCPortal@@M@std@@V?$xalloc@U?$pair@PAVCPortal@@M@std@@@@@std@@AAE?A_T$$QAU?$pair@PAVCPortal@@M@1@@Z
_TEXT	SEGMENT
_<_Val_0>$ = 8						; size = 4
??$_Emplace_back_with_unused_capacity@U?$pair@PAVCPortal@@M@std@@@?$vector@U?$pair@PAVCPortal@@M@std@@V?$xalloc@U?$pair@PAVCPortal@@M@std@@@@@std@@AAE?A_T$$QAU?$pair@PAVCPortal@@M@1@@Z PROC ; std::vector<std::pair<CPortal *,float>,xalloc<std::pair<CPortal *,float> > >::_Emplace_back_with_unused_capacity<std::pair<CPortal *,float> >, COMDAT
; _this$ = ecx

; 709  :         // insert by perfectly forwarding into element at end, provide strong guarantee
; 710  :         auto& _My_data   = _Mypair._Myval2;
; 711  :         pointer& _Mylast = _My_data._Mylast;
; 712  :         _STL_INTERNAL_CHECK(_Mylast != _My_data._Myend); // check that we have unused capacity
; 713  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

	mov	eax, DWORD PTR _<_Val_0>$[esp-4]
	push	esi
	mov	esi, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax], edx
	mov	DWORD PTR [eax+4], esi

; 714  :         _Orphan_range(_Mylast, _Mylast);
; 715  :         _Ty& _Result = *_Mylast;
; 716  :         ++_Mylast;

	add	DWORD PTR [ecx+4], 8
	pop	esi

; 717  : #if _HAS_CXX17
; 718  :         return _Result;
; 719  : #else // ^^^ _HAS_CXX17 ^^^ // vvv !_HAS_CXX17 vvv
; 720  :         (void) _Result;
; 721  : #endif // _HAS_CXX17
; 722  :     }

	ret	4
??$_Emplace_back_with_unused_capacity@U?$pair@PAVCPortal@@M@std@@@?$vector@U?$pair@PAVCPortal@@M@std@@V?$xalloc@U?$pair@PAVCPortal@@M@std@@@@@std@@AAE?A_T$$QAU?$pair@PAVCPortal@@M@1@@Z ENDP ; std::vector<std::pair<CPortal *,float>,xalloc<std::pair<CPortal *,float> > >::_Emplace_back_with_unused_capacity<std::pair<CPortal *,float> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??1?$vector@U?$pair@PAVCPortal@@M@std@@V?$xalloc@U?$pair@PAVCPortal@@M@std@@@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@U?$pair@PAVCPortal@@M@std@@V?$xalloc@U?$pair@PAVCPortal@@M@std@@@@@std@@QAE@XZ PROC ; std::vector<std::pair<CPortal *,float>,xalloc<std::pair<CPortal *,float> > >::~vector<std::pair<CPortal *,float>,xalloc<std::pair<CPortal *,float> > >, COMDAT
; _this$ = ecx

; 698  :     _CONSTEXPR20_CONTAINER ~vector() noexcept {

	push	esi
	mov	esi, ecx

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN4@vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+4], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+8], 0
$LN4@vector:
	pop	esi

; 699  :         _Tidy();
; 700  : #if _ITERATOR_DEBUG_LEVEL != 0
; 701  :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 702  :         _Delete_plain_internal(_Alproxy, _STD exchange(_Mypair._Myval2._Myproxy, nullptr));
; 703  : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 704  :     }

	ret	0
??1?$vector@U?$pair@PAVCPortal@@M@std@@V?$xalloc@U?$pair@PAVCPortal@@M@std@@@@@std@@QAE@XZ ENDP ; std::vector<std::pair<CPortal *,float>,xalloc<std::pair<CPortal *,float> > >::~vector<std::pair<CPortal *,float>,xalloc<std::pair<CPortal *,float> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?clear@?$xr_vector@PAVIRender_Sector@@V?$xalloc@PAVIRender_Sector@@@@@@QAEXXZ
_TEXT	SEGMENT
?clear@?$xr_vector@PAVIRender_Sector@@V?$xalloc@PAVIRender_Sector@@@@@@QAEXXZ PROC ; xr_vector<IRender_Sector *,xalloc<IRender_Sector *> >::clear, COMDAT
; _this$ = ecx

; 132  : 	void	clear				()									{ clear_and_free	();			}

	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [ecx+4], eax
	ret	0
?clear@?$xr_vector@PAVIRender_Sector@@V?$xalloc@PAVIRender_Sector@@@@@@QAEXXZ ENDP ; xr_vector<IRender_Sector *,xalloc<IRender_Sector *> >::clear
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ??0?$xr_vector@PAVIRender_Sector@@V?$xalloc@PAVIRender_Sector@@@@@@QAE@XZ
_TEXT	SEGMENT
??0?$xr_vector@PAVIRender_Sector@@V?$xalloc@PAVIRender_Sector@@@@@@QAE@XZ PROC ; xr_vector<IRender_Sector *,xalloc<IRender_Sector *> >::xr_vector<IRender_Sector *,xalloc<IRender_Sector *> >, COMDAT
; _this$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx], 0
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 122  : 			xr_vector			()									: inherited	()					{}

	mov	eax, ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 122  : 			xr_vector			()									: inherited	()					{}

	ret	0
??0?$xr_vector@PAVIRender_Sector@@V?$xalloc@PAVIRender_Sector@@@@@@QAE@XZ ENDP ; xr_vector<IRender_Sector *,xalloc<IRender_Sector *> >::xr_vector<IRender_Sector *,xalloc<IRender_Sector *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??1?$vector@PAVIRender_Sector@@V?$xalloc@PAVIRender_Sector@@@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@PAVIRender_Sector@@V?$xalloc@PAVIRender_Sector@@@@@std@@QAE@XZ PROC ; std::vector<IRender_Sector *,xalloc<IRender_Sector *> >::~vector<IRender_Sector *,xalloc<IRender_Sector *> >, COMDAT
; _this$ = ecx

; 698  :     _CONSTEXPR20_CONTAINER ~vector() noexcept {

	push	esi
	mov	esi, ecx

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN4@vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+4], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+8], 0
$LN4@vector:
	pop	esi

; 699  :         _Tidy();
; 700  : #if _ITERATOR_DEBUG_LEVEL != 0
; 701  :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 702  :         _Delete_plain_internal(_Alproxy, _STD exchange(_Mypair._Myval2._Myproxy, nullptr));
; 703  : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 704  :     }

	ret	0
??1?$vector@PAVIRender_Sector@@V?$xalloc@PAVIRender_Sector@@@@@std@@QAE@XZ ENDP ; std::vector<IRender_Sector *,xalloc<IRender_Sector *> >::~vector<IRender_Sector *,xalloc<IRender_Sector *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ??A?$xr_vector@U_scissor@@V?$xalloc@U_scissor@@@@@@QAEAAU_scissor@@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$xr_vector@U_scissor@@V?$xalloc@U_scissor@@@@@@QAEAAU_scissor@@I@Z PROC ; xr_vector<_scissor,xalloc<_scissor> >::operator[], COMDAT
; _this$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 119  :         _Ptr += _Off;

	mov	eax, DWORD PTR __Pos$[esp-4]
	lea	edx, DWORD PTR [eax+eax*4]
	mov	eax, DWORD PTR [ecx]
	lea	eax, DWORD PTR [eax+edx*4]
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 138  : 	reference operator[]		(size_type _Pos)					{ {VERIFY(_Pos<size());} return (*(begin() + _Pos)); }

	ret	4
??A?$xr_vector@U_scissor@@V?$xalloc@U_scissor@@@@@@QAEAAU_scissor@@I@Z ENDP ; xr_vector<_scissor,xalloc<_scissor> >::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?size@?$xr_vector@U_scissor@@V?$xalloc@U_scissor@@@@@@QBEIXZ
_TEXT	SEGMENT
?size@?$xr_vector@U_scissor@@V?$xalloc@U_scissor@@@@@@QBEIXZ PROC ; xr_vector<_scissor,xalloc<_scissor> >::size, COMDAT
; _this$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	eax, DWORD PTR [ecx+4]
	sub	eax, DWORD PTR [ecx]
	sar	eax, 2
	imul	eax, eax, -858993459
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 125  : 	u32		size				() const							{ return (u32)inherited::size();} 

	ret	0
?size@?$xr_vector@U_scissor@@V?$xalloc@U_scissor@@@@@@QBEIXZ ENDP ; xr_vector<_scissor,xalloc<_scissor> >::size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox2.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector2.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_std_extensions.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector2.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_std_extensions.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector2.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_std_extensions.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector2.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_std_extensions.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector2.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_std_extensions.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector2.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_std_extensions.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector2.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_std_extensions.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector2.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_std_extensions.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector2.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox2.h
;	COMDAT ?merge@?$_box2@M@@QAEAAV1@ABV1@@Z
_TEXT	SEGMENT
_b$ = 8							; size = 4
?merge@?$_box2@M@@QAEAAV1@ABV1@@Z PROC			; _box2<float>::merge, COMDAT
; _this$ = ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector2.h

; 20   : 	IC SelfRef min(const Self &p)					{ x=_min(x,p.x); y=_min(y,p.y);	return *this;	}

	mov	eax, DWORD PTR _b$[esp-4]
	movss	xmm0, DWORD PTR [ecx]
	movss	xmm1, DWORD PTR [eax]
; File I:\Vitalya\mine\NSProjectX\xrCore\_std_extensions.h

; 93   : template <class T>	IC T		_min	(T a, T b)	{ return a<b?a:b;	}

	comiss	xmm1, xmm0
	ja	SHORT $LN10@merge
	movaps	xmm0, xmm1
$LN10@merge:
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector2.h

; 20   : 	IC SelfRef min(const Self &p)					{ x=_min(x,p.x); y=_min(y,p.y);	return *this;	}

	movss	DWORD PTR [ecx], xmm0
	movss	xmm0, DWORD PTR [ecx+4]
	movss	xmm1, DWORD PTR [eax+4]
; File I:\Vitalya\mine\NSProjectX\xrCore\_std_extensions.h

; 93   : template <class T>	IC T		_min	(T a, T b)	{ return a<b?a:b;	}

	comiss	xmm1, xmm0
	ja	SHORT $LN14@merge
	movaps	xmm0, xmm1
$LN14@merge:
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector2.h

; 20   : 	IC SelfRef min(const Self &p)					{ x=_min(x,p.x); y=_min(y,p.y);	return *this;	}

	movss	DWORD PTR [ecx+4], xmm0

; 22   : 	IC SelfRef max(const Self &p)					{ x=_max(x,p.x); y=_max(y,p.y);	return *this;	}

	movss	xmm0, DWORD PTR [ecx+8]
	movss	xmm1, DWORD PTR [eax]
; File I:\Vitalya\mine\NSProjectX\xrCore\_std_extensions.h

; 94   : template <class T>	IC T		_max	(T a, T b)	{ return a>b?a:b;	}

	comiss	xmm0, xmm1
	ja	SHORT $LN20@merge
	movaps	xmm0, xmm1
$LN20@merge:
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector2.h

; 22   : 	IC SelfRef max(const Self &p)					{ x=_max(x,p.x); y=_max(y,p.y);	return *this;	}

	movss	DWORD PTR [ecx+8], xmm0
	movss	xmm0, DWORD PTR [ecx+12]
	movss	xmm1, DWORD PTR [eax+4]
; File I:\Vitalya\mine\NSProjectX\xrCore\_std_extensions.h

; 94   : template <class T>	IC T		_max	(T a, T b)	{ return a>b?a:b;	}

	comiss	xmm0, xmm1
	ja	SHORT $LN24@merge
	movaps	xmm0, xmm1
$LN24@merge:
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector2.h

; 22   : 	IC SelfRef max(const Self &p)					{ x=_max(x,p.x); y=_max(y,p.y);	return *this;	}

	movss	DWORD PTR [ecx+12], xmm0

; 20   : 	IC SelfRef min(const Self &p)					{ x=_min(x,p.x); y=_min(y,p.y);	return *this;	}

	movss	xmm0, DWORD PTR [ecx]
	movss	xmm1, DWORD PTR [eax+8]
; File I:\Vitalya\mine\NSProjectX\xrCore\_std_extensions.h

; 93   : template <class T>	IC T		_min	(T a, T b)	{ return a<b?a:b;	}

	comiss	xmm1, xmm0
	ja	SHORT $LN32@merge
	movaps	xmm0, xmm1
$LN32@merge:
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector2.h

; 20   : 	IC SelfRef min(const Self &p)					{ x=_min(x,p.x); y=_min(y,p.y);	return *this;	}

	movss	DWORD PTR [ecx], xmm0
	movss	xmm0, DWORD PTR [ecx+4]
	movss	xmm1, DWORD PTR [eax+12]
; File I:\Vitalya\mine\NSProjectX\xrCore\_std_extensions.h

; 93   : template <class T>	IC T		_min	(T a, T b)	{ return a<b?a:b;	}

	comiss	xmm1, xmm0
	ja	SHORT $LN36@merge
	movaps	xmm0, xmm1
$LN36@merge:
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector2.h

; 20   : 	IC SelfRef min(const Self &p)					{ x=_min(x,p.x); y=_min(y,p.y);	return *this;	}

	movss	DWORD PTR [ecx+4], xmm0

; 22   : 	IC SelfRef max(const Self &p)					{ x=_max(x,p.x); y=_max(y,p.y);	return *this;	}

	movss	xmm0, DWORD PTR [ecx+8]
	movss	xmm1, DWORD PTR [eax+8]
; File I:\Vitalya\mine\NSProjectX\xrCore\_std_extensions.h

; 94   : template <class T>	IC T		_max	(T a, T b)	{ return a>b?a:b;	}

	comiss	xmm0, xmm1
	ja	SHORT $LN42@merge
	movaps	xmm0, xmm1
$LN42@merge:
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector2.h

; 22   : 	IC SelfRef max(const Self &p)					{ x=_max(x,p.x); y=_max(y,p.y);	return *this;	}

	movss	DWORD PTR [ecx+8], xmm0
	movss	xmm0, DWORD PTR [ecx+12]
	movss	xmm1, DWORD PTR [eax+12]
; File I:\Vitalya\mine\NSProjectX\xrCore\_std_extensions.h

; 94   : template <class T>	IC T		_max	(T a, T b)	{ return a>b?a:b;	}

	comiss	xmm0, xmm1
	ja	SHORT $LN46@merge
	movaps	xmm0, xmm1
$LN46@merge:
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector2.h

; 22   : 	IC SelfRef max(const Self &p)					{ x=_max(x,p.x); y=_max(y,p.y);	return *this;	}

	movss	DWORD PTR [ecx+12], xmm0
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox2.h

; 48   : 	IC	SelfRef	merge		(SelfCRef b)				{ modify(b.min); modify(b.max);			return *this;	};

	mov	eax, ecx
	ret	4
?merge@?$_box2@M@@QAEAAV1@ABV1@@Z ENDP			; _box2<float>::merge
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox2.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector2.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox2.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector2.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox2.h
;	COMDAT ?set@?$_box2@M@@QAEAAV1@MMMM@Z
_TEXT	SEGMENT
_x1$dead$ = 8						; size = 4
_y1$dead$ = 12						; size = 4
_x2$dead$ = 16						; size = 4
_y2$dead$ = 20						; size = 4
?set@?$_box2@M@@QAEAAV1@MMMM@Z PROC			; _box2<float>::set, COMDAT
; _this$ = ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector2.h

; 15   : 	IC SelfRef set(float _u, float _v)				{ x=T(_u); y=T(_v);				return *this;	}

	mov	DWORD PTR [ecx], 0
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox2.h

; 25   : 	IC	SelfRef	set			(T x1, T y1, T x2, T y2)	{ min.set(x1,y1);	max.set(x2,y2);					return *this;	};

	mov	eax, ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector2.h

; 15   : 	IC SelfRef set(float _u, float _v)				{ x=T(_u); y=T(_v);				return *this;	}

	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 1065353216		; 3f800000H
	mov	DWORD PTR [ecx+12], 1065353216		; 3f800000H
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox2.h

; 25   : 	IC	SelfRef	set			(T x1, T y1, T x2, T y2)	{ min.set(x1,y1);	max.set(x2,y2);					return *this;	};

	ret	16					; 00000010H
?set@?$_box2@M@@QAEAAV1@MMMM@Z ENDP			; _box2<float>::set
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@PAVCPortal@@M@std@@@std@@@std@@@std@@QAE@PAU?$pair@PAVCPortal@@M@1@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
___param0$ = 8						; size = 4
___param1$dead$ = 12					; size = 4
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@PAVCPortal@@M@std@@@std@@@std@@@std@@QAE@PAU?$pair@PAVCPortal@@M@1@PBU_Container_base0@1@@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::pair<CPortal *,float> > > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::pair<CPortal *,float> > > >, COMDAT
; _this$ = ecx

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	eax, DWORD PTR ___param0$[esp-4]
	mov	DWORD PTR [ecx], eax
	mov	eax, ecx
	ret	8
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@PAVCPortal@@M@std@@@std@@@std@@@std@@QAE@PAU?$pair@PAVCPortal@@M@1@PBU_Container_base0@1@@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::pair<CPortal *,float> > > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::pair<CPortal *,float> > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U_scissor@@@std@@@std@@@std@@QBE?AV01@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U_scissor@@@std@@@std@@@std@@QBE?AV01@H@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<_scissor> > >::operator+, COMDAT
; _this$ = ecx

; 119  :         _Ptr += _Off;

	mov	eax, DWORD PTR __Off$[esp-4]
	lea	edx, DWORD PTR [eax+eax*4]
	mov	eax, DWORD PTR [ecx]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 303  :         _Vector_iterator _Tmp = *this;
; 304  :         _Tmp += _Off; // TRANSITION, LLVM-49342
; 305  :         return _Tmp;
; 306  :     }

	ret	8
??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U_scissor@@@std@@@std@@@std@@QBE?AV01@H@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<_scissor> > >::operator+
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U_scissor@@@std@@@std@@@std@@QBEAAU_scissor@@XZ
_TEXT	SEGMENT
??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U_scissor@@@std@@@std@@@std@@QBEAAU_scissor@@XZ PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<_scissor> > >::operator*, COMDAT
; _this$ = ecx

; 261  :         return const_cast<reference>(_Mybase::operator*());

	mov	eax, DWORD PTR [ecx]

; 262  :     }

	ret	0
??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U_scissor@@@std@@@std@@@std@@QBEAAU_scissor@@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<_scissor> > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@PAVCPortal@@M@std@@@std@@@std@@@std@@QBE?AV01@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@PAVCPortal@@M@std@@@std@@@std@@@std@@QBE?AV01@H@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::pair<CPortal *,float> > > >::operator+, COMDAT
; _this$ = ecx

; 119  :         _Ptr += _Off;

	mov	eax, DWORD PTR __Off$[esp-4]
	mov	ecx, DWORD PTR [ecx]
	lea	ecx, DWORD PTR [ecx+eax*8]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 303  :         _Vector_iterator _Tmp = *this;
; 304  :         _Tmp += _Off; // TRANSITION, LLVM-49342
; 305  :         return _Tmp;
; 306  :     }

	ret	8
??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@PAVCPortal@@M@std@@@std@@@std@@@std@@QBE?AV01@H@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::pair<CPortal *,float> > > >::operator+
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@PAVCPortal@@M@std@@@std@@@std@@@std@@QBEAAU?$pair@PAVCPortal@@M@1@XZ
_TEXT	SEGMENT
??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@PAVCPortal@@M@std@@@std@@@std@@@std@@QBEAAU?$pair@PAVCPortal@@M@1@XZ PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::pair<CPortal *,float> > > >::operator*, COMDAT
; _this$ = ecx

; 261  :         return const_cast<reference>(_Mybase::operator*());

	mov	eax, DWORD PTR [ecx]

; 262  :     }

	ret	0
??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@PAVCPortal@@M@std@@@std@@@std@@@std@@QBEAAU?$pair@PAVCPortal@@M@1@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::pair<CPortal *,float> > > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@PAVCPortal@@M@std@@@std@@@std@@@std@@QAE@PAU?$pair@PAVCPortal@@M@1@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Pvector$dead$ = 12					; size = 4
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@PAVCPortal@@M@std@@@std@@@std@@@std@@QAE@PAU?$pair@PAVCPortal@@M@1@PBU_Container_base0@1@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::pair<CPortal *,float> > > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::pair<CPortal *,float> > > >, COMDAT
; _this$ = ecx

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	eax, DWORD PTR __Parg$[esp-4]
	mov	DWORD PTR [ecx], eax

; 42   :         this->_Adopt(_Pvector);
; 43   :     }

	mov	eax, ecx
	ret	8
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@PAVCPortal@@M@std@@@std@@@std@@@std@@QAE@PAU?$pair@PAVCPortal@@M@1@PBU_Container_base0@1@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::pair<CPortal *,float> > > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::pair<CPortal *,float> > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?clear_and_free@?$xr_vector@U?$pair@PAVCPortal@@M@std@@V?$xalloc@U?$pair@PAVCPortal@@M@std@@@@@@QAEXXZ
_TEXT	SEGMENT
?clear_and_free@?$xr_vector@U?$pair@PAVCPortal@@M@std@@V?$xalloc@U?$pair@PAVCPortal@@M@std@@@@@@QAEXXZ PROC ; xr_vector<std::pair<CPortal *,float>,xalloc<std::pair<CPortal *,float> > >::clear_and_free, COMDAT
; _this$ = ecx

; 127  : 	void	clear_and_free		()									{ inherited::clear();			}

	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [ecx+4], eax
	ret	0
?clear_and_free@?$xr_vector@U?$pair@PAVCPortal@@M@std@@V?$xalloc@U?$pair@PAVCPortal@@M@std@@@@@@QAEXXZ ENDP ; xr_vector<std::pair<CPortal *,float>,xalloc<std::pair<CPortal *,float> > >::clear_and_free
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Getal@?$vector@U?$pair@PAVCPortal@@M@std@@V?$xalloc@U?$pair@PAVCPortal@@M@std@@@@@std@@AAEAAV?$xalloc@U?$pair@PAVCPortal@@M@std@@@@XZ
_TEXT	SEGMENT
?_Getal@?$vector@U?$pair@PAVCPortal@@M@std@@V?$xalloc@U?$pair@PAVCPortal@@M@std@@@@@std@@AAEAAV?$xalloc@U?$pair@PAVCPortal@@M@std@@@@XZ PROC ; std::vector<std::pair<CPortal *,float>,xalloc<std::pair<CPortal *,float> > >::_Getal, COMDAT
; _this$ = ecx

; 1805 :         return _Mypair._Get_first();

	mov	eax, ecx

; 1806 :     }

	ret	0
?_Getal@?$vector@U?$pair@PAVCPortal@@M@std@@V?$xalloc@U?$pair@PAVCPortal@@M@std@@@@@std@@AAEAAV?$xalloc@U?$pair@PAVCPortal@@M@std@@@@XZ ENDP ; std::vector<std::pair<CPortal *,float>,xalloc<std::pair<CPortal *,float> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Orphan_range@?$vector@U?$pair@PAVCPortal@@M@std@@V?$xalloc@U?$pair@PAVCPortal@@M@std@@@@@std@@ABEXPAU?$pair@PAVCPortal@@M@2@0@Z
_TEXT	SEGMENT
___formal$dead$ = 8					; size = 4
___formal$dead$ = 12					; size = 4
?_Orphan_range@?$vector@U?$pair@PAVCPortal@@M@std@@V?$xalloc@U?$pair@PAVCPortal@@M@std@@@@@std@@ABEXPAU?$pair@PAVCPortal@@M@2@0@Z PROC ; std::vector<std::pair<CPortal *,float>,xalloc<std::pair<CPortal *,float> > >::_Orphan_range, COMDAT
; _this$dead$ = ecx

; 1801 :     _CONSTEXPR20_CONTAINER void _Orphan_range(pointer, pointer) const {}

	ret	8
?_Orphan_range@?$vector@U?$pair@PAVCPortal@@M@std@@V?$xalloc@U?$pair@PAVCPortal@@M@std@@@@@std@@ABEXPAU?$pair@PAVCPortal@@M@2@0@Z ENDP ; std::vector<std::pair<CPortal *,float>,xalloc<std::pair<CPortal *,float> > >::_Orphan_range
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Xlength@?$vector@U?$pair@PAVCPortal@@M@std@@V?$xalloc@U?$pair@PAVCPortal@@M@std@@@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@U?$pair@PAVCPortal@@M@std@@V?$xalloc@U?$pair@PAVCPortal@@M@std@@@@@std@@CAXXZ PROC ; std::vector<std::pair<CPortal *,float>,xalloc<std::pair<CPortal *,float> > >::_Xlength, COMDAT

; 1761 :         _Xlength_error("vector too long");

	push	OFFSET ??_C@_0BA@FOIKENOD@vector?5too?5long@
	call	DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN3@Xlength:
	int	3
?_Xlength@?$vector@U?$pair@PAVCPortal@@M@std@@V?$xalloc@U?$pair@PAVCPortal@@M@std@@@@@std@@CAXXZ ENDP ; std::vector<std::pair<CPortal *,float>,xalloc<std::pair<CPortal *,float> > >::_Xlength
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Tidy@?$vector@U?$pair@PAVCPortal@@M@std@@V?$xalloc@U?$pair@PAVCPortal@@M@std@@@@@std@@AAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@U?$pair@PAVCPortal@@M@std@@V?$xalloc@U?$pair@PAVCPortal@@M@std@@@@@std@@AAEXXZ PROC ; std::vector<std::pair<CPortal *,float>,xalloc<std::pair<CPortal *,float> > >::_Tidy, COMDAT
; _this$ = ecx

; 1742 :     _CONSTEXPR20_CONTAINER void _Tidy() noexcept { // free all storage

	push	esi
	mov	esi, ecx

; 1743 :         auto& _My_data    = _Mypair._Myval2;
; 1744 :         pointer& _Myfirst = _My_data._Myfirst;
; 1745 :         pointer& _Mylast  = _My_data._Mylast;
; 1746 :         pointer& _Myend   = _My_data._Myend;
; 1747 : 
; 1748 :         _My_data._Orphan_all();
; 1749 : 
; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN2@Tidy
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+4], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+8], 0
$LN2@Tidy:

; 1757 :         }
; 1758 :     }

	pop	esi
	ret	0
?_Tidy@?$vector@U?$pair@PAVCPortal@@M@std@@V?$xalloc@U?$pair@PAVCPortal@@M@std@@@@@std@@AAEXXZ ENDP ; std::vector<std::pair<CPortal *,float>,xalloc<std::pair<CPortal *,float> > >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?capacity@?$vector@U?$pair@PAVCPortal@@M@std@@V?$xalloc@U?$pair@PAVCPortal@@M@std@@@@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@U?$pair@PAVCPortal@@M@std@@V?$xalloc@U?$pair@PAVCPortal@@M@std@@@@@std@@QBEIXZ PROC ; std::vector<std::pair<CPortal *,float>,xalloc<std::pair<CPortal *,float> > >::capacity, COMDAT
; _this$ = ecx

; 1545 :         auto& _My_data = _Mypair._Myval2;
; 1546 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx]
	sar	eax, 3

; 1547 :     }

	ret	0
?capacity@?$vector@U?$pair@PAVCPortal@@M@std@@V?$xalloc@U?$pair@PAVCPortal@@M@std@@@@@std@@QBEIXZ ENDP ; std::vector<std::pair<CPortal *,float>,xalloc<std::pair<CPortal *,float> > >::capacity
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?max_size@?$vector@U?$pair@PAVCPortal@@M@std@@V?$xalloc@U?$pair@PAVCPortal@@M@std@@@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@U?$pair@PAVCPortal@@M@std@@V?$xalloc@U?$pair@PAVCPortal@@M@std@@@@@std@@QBEIXZ PROC ; std::vector<std::pair<CPortal *,float>,xalloc<std::pair<CPortal *,float> > >::max_size, COMDAT
; _this$dead$ = ecx

; 1540 :         return (_STD min)(

	mov	eax, 536870911				; 1fffffffH

; 1541 :             static_cast<size_type>((numeric_limits<difference_type>::max)()), _Alty_traits::max_size(_Getal()));
; 1542 :     }

	ret	0
?max_size@?$vector@U?$pair@PAVCPortal@@M@std@@V?$xalloc@U?$pair@PAVCPortal@@M@std@@@@@std@@QBEIXZ ENDP ; std::vector<std::pair<CPortal *,float>,xalloc<std::pair<CPortal *,float> > >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?size@?$vector@U?$pair@PAVCPortal@@M@std@@V?$xalloc@U?$pair@PAVCPortal@@M@std@@@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@U?$pair@PAVCPortal@@M@std@@V?$xalloc@U?$pair@PAVCPortal@@M@std@@@@@std@@QBEIXZ PROC ; std::vector<std::pair<CPortal *,float>,xalloc<std::pair<CPortal *,float> > >::size, COMDAT
; _this$ = ecx

; 1535 :         auto& _My_data = _Mypair._Myval2;
; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	eax, DWORD PTR [ecx+4]
	sub	eax, DWORD PTR [ecx]
	sar	eax, 3

; 1537 :     }

	ret	0
?size@?$vector@U?$pair@PAVCPortal@@M@std@@V?$xalloc@U?$pair@PAVCPortal@@M@std@@@@@std@@QBEIXZ ENDP ; std::vector<std::pair<CPortal *,float>,xalloc<std::pair<CPortal *,float> > >::size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Reallocate_exactly@?$vector@U?$pair@PAVCPortal@@M@std@@V?$xalloc@U?$pair@PAVCPortal@@M@std@@@@@std@@AAEXI@Z
_TEXT	SEGMENT
__Newvec$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Newcapacity$dead$ = 8					; size = 4
?_Reallocate_exactly@?$vector@U?$pair@PAVCPortal@@M@std@@V?$xalloc@U?$pair@PAVCPortal@@M@std@@@@@std@@AAEXI@Z PROC ; std::vector<std::pair<CPortal *,float>,xalloc<std::pair<CPortal *,float> > >::_Reallocate_exactly, COMDAT
; _this$ = ecx

; 1286 :     _CONSTEXPR20_CONTAINER void _Reallocate_exactly(const size_type _Newcapacity) {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Reallocate_exactly@?$vector@U?$pair@PAVCPortal@@M@std@@V?$xalloc@U?$pair@PAVCPortal@@M@std@@@@@std@@AAEXI@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 8
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	esi, ecx

; 1287 :         // set capacity to _Newcapacity (without geometric growth), provide strong guarantee
; 1288 :         auto& _My_data    = _Mypair._Myval2;
; 1289 :         pointer& _Myfirst = _My_data._Myfirst;
; 1290 :         pointer& _Mylast  = _My_data._Mylast;
; 1291 : 
; 1292 :         const auto _Size = static_cast<size_type>(_Mylast - _Myfirst);

	mov	ebx, DWORD PTR [esi+4]
	sub	ebx, DWORD PTR [esi]
	sar	ebx, 3
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	push	128					; 00000080H
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1294 :         const pointer _Newvec = _Getal().allocate(_Newcapacity);

	mov	edi, eax
	mov	DWORD PTR __Newvec$[ebp], edi

; 1295 : 
; 1296 :         _TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 1297 :         _Umove_if_noexcept(_Myfirst, _Mylast, _Newvec);

	push	edi
	push	DWORD PTR [esi+4]
	push	DWORD PTR [esi]
	call	?_Umove_if_noexcept@?$vector@U?$pair@PAVCPortal@@M@std@@V?$xalloc@U?$pair@PAVCPortal@@M@std@@@@@std@@AAEXPAU?$pair@PAVCPortal@@M@2@00@Z ; std::vector<std::pair<CPortal *,float>,xalloc<std::pair<CPortal *,float> > >::_Umove_if_noexcept
	mov	DWORD PTR __$EHRec$[ebp+12], -1

; 1732 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN18@Reallocate
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	push	eax
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN18@Reallocate:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1737 :         _Myfirst = _Newvec;

	mov	DWORD PTR [esi], edi

; 1738 :         _Mylast  = _Newvec + _Newsize;

	lea	eax, DWORD PTR [edi+ebx*8]
	mov	DWORD PTR [esi+4], eax

; 1739 :         _Myend   = _Newvec + _Newcapacity;

	lea	eax, DWORD PTR [edi+128]
	mov	DWORD PTR [esi+8], eax

; 1301 :         _CATCH_END
; 1302 : 
; 1303 :         _Change_array(_Newvec, _Size, _Newcapacity);
; 1304 :     }

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
__catch$?_Reallocate_exactly@?$vector@U?$pair@PAVCPortal@@M@std@@V?$xalloc@U?$pair@PAVCPortal@@M@std@@@@@std@@AAEXI@Z$0:

; 1298 :         _CATCH_ALL
; 1299 :         _Getal().deallocate(_Newvec, _Newcapacity);

	push	ecx
	push	DWORD PTR __Newvec$[ebp]
	call	?deallocate@?$xalloc@U?$pair@PAVCPortal@@M@std@@@@QBEXPAU?$pair@PAVCPortal@@M@std@@I@Z ; xalloc<std::pair<CPortal *,float> >::deallocate

; 1300 :         _RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$LN21@Reallocate:
	int	3
	int	3
	int	3
	int	3
	int	3
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Reallocate_exactly@?$vector@U?$pair@PAVCPortal@@M@std@@V?$xalloc@U?$pair@PAVCPortal@@M@std@@@@@std@@AAEXI@Z:
	npad	1
	npad	1
	mov	eax, OFFSET __ehfuncinfo$?_Reallocate_exactly@?$vector@U?$pair@PAVCPortal@@M@std@@V?$xalloc@U?$pair@PAVCPortal@@M@std@@@@@std@@AAEXI@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Reallocate_exactly@?$vector@U?$pair@PAVCPortal@@M@std@@V?$xalloc@U?$pair@PAVCPortal@@M@std@@@@@std@@AAEXI@Z ENDP ; std::vector<std::pair<CPortal *,float>,xalloc<std::pair<CPortal *,float> > >::_Reallocate_exactly
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0?$vector@U?$pair@PAVCPortal@@M@std@@V?$xalloc@U?$pair@PAVCPortal@@M@std@@@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@U?$pair@PAVCPortal@@M@std@@V?$xalloc@U?$pair@PAVCPortal@@M@std@@@@@std@@QAE@XZ PROC ; std::vector<std::pair<CPortal *,float>,xalloc<std::pair<CPortal *,float> > >::vector<std::pair<CPortal *,float>,xalloc<std::pair<CPortal *,float> > >, COMDAT
; _this$ = ecx

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx], 0

; 464  :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 465  :     }

	mov	eax, ecx

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0

; 464  :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 465  :     }

	ret	0
??0?$vector@U?$pair@PAVCPortal@@M@std@@V?$xalloc@U?$pair@PAVCPortal@@M@std@@@@@std@@QAE@XZ ENDP ; std::vector<std::pair<CPortal *,float>,xalloc<std::pair<CPortal *,float> > >::vector<std::pair<CPortal *,float>,xalloc<std::pair<CPortal *,float> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?clear_and_free@?$xr_vector@PAVIRender_Sector@@V?$xalloc@PAVIRender_Sector@@@@@@QAEXXZ
_TEXT	SEGMENT
?clear_and_free@?$xr_vector@PAVIRender_Sector@@V?$xalloc@PAVIRender_Sector@@@@@@QAEXXZ PROC ; xr_vector<IRender_Sector *,xalloc<IRender_Sector *> >::clear_and_free, COMDAT
; _this$ = ecx

; 127  : 	void	clear_and_free		()									{ inherited::clear();			}

	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [ecx+4], eax
	ret	0
?clear_and_free@?$xr_vector@PAVIRender_Sector@@V?$xalloc@PAVIRender_Sector@@@@@@QAEXXZ ENDP ; xr_vector<IRender_Sector *,xalloc<IRender_Sector *> >::clear_and_free
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Tidy@?$vector@PAVIRender_Sector@@V?$xalloc@PAVIRender_Sector@@@@@std@@AAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@PAVIRender_Sector@@V?$xalloc@PAVIRender_Sector@@@@@std@@AAEXXZ PROC ; std::vector<IRender_Sector *,xalloc<IRender_Sector *> >::_Tidy, COMDAT
; _this$ = ecx

; 1742 :     _CONSTEXPR20_CONTAINER void _Tidy() noexcept { // free all storage

	push	esi
	mov	esi, ecx

; 1743 :         auto& _My_data    = _Mypair._Myval2;
; 1744 :         pointer& _Myfirst = _My_data._Myfirst;
; 1745 :         pointer& _Mylast  = _My_data._Mylast;
; 1746 :         pointer& _Myend   = _My_data._Myend;
; 1747 : 
; 1748 :         _My_data._Orphan_all();
; 1749 : 
; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN2@Tidy
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+4], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+8], 0
$LN2@Tidy:

; 1757 :         }
; 1758 :     }

	pop	esi
	ret	0
?_Tidy@?$vector@PAVIRender_Sector@@V?$xalloc@PAVIRender_Sector@@@@@std@@AAEXXZ ENDP ; std::vector<IRender_Sector *,xalloc<IRender_Sector *> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0?$vector@PAVIRender_Sector@@V?$xalloc@PAVIRender_Sector@@@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@PAVIRender_Sector@@V?$xalloc@PAVIRender_Sector@@@@@std@@QAE@XZ PROC ; std::vector<IRender_Sector *,xalloc<IRender_Sector *> >::vector<IRender_Sector *,xalloc<IRender_Sector *> >, COMDAT
; _this$ = ecx

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx], 0

; 464  :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 465  :     }

	mov	eax, ecx

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0

; 464  :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 465  :     }

	ret	0
??0?$vector@PAVIRender_Sector@@V?$xalloc@PAVIRender_Sector@@@@@std@@QAE@XZ ENDP ; std::vector<IRender_Sector *,xalloc<IRender_Sector *> >::vector<IRender_Sector *,xalloc<IRender_Sector *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?size@?$vector@U_scissor@@V?$xalloc@U_scissor@@@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@U_scissor@@V?$xalloc@U_scissor@@@@@std@@QBEIXZ PROC ; std::vector<_scissor,xalloc<_scissor> >::size, COMDAT
; _this$ = ecx

; 1535 :         auto& _My_data = _Mypair._Myval2;
; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	eax, DWORD PTR [ecx+4]
	sub	eax, DWORD PTR [ecx]
	sar	eax, 2
	imul	eax, eax, -858993459

; 1537 :     }

	ret	0
?size@?$vector@U_scissor@@V?$xalloc@U_scissor@@@@@std@@QBEIXZ ENDP ; std::vector<_scissor,xalloc<_scissor> >::size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?begin@?$vector@U_scissor@@V?$xalloc@U_scissor@@@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U_scissor@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@U_scissor@@V?$xalloc@U_scissor@@@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U_scissor@@@std@@@std@@@2@XZ PROC ; std::vector<_scissor,xalloc<_scissor> >::begin, COMDAT
; _this$ = ecx

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	ecx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], ecx

; 1462 :         auto& _My_data = _Mypair._Myval2;
; 1463 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));
; 1464 :     }

	ret	4
?begin@?$vector@U_scissor@@V?$xalloc@U_scissor@@@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U_scissor@@@std@@@std@@@2@XZ ENDP ; std::vector<_scissor,xalloc<_scissor> >::begin
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox2.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector2.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_std_extensions.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector2.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_std_extensions.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector2.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_std_extensions.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector2.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_std_extensions.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector2.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox2.h
;	COMDAT ?modify@?$_box2@M@@QAEAAV1@ABU?$_vector2@M@@@Z
_TEXT	SEGMENT
_p$ = 8							; size = 4
?modify@?$_box2@M@@QAEAAV1@ABU?$_vector2@M@@@Z PROC	; _box2<float>::modify, COMDAT
; _this$ = ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector2.h

; 20   : 	IC SelfRef min(const Self &p)					{ x=_min(x,p.x); y=_min(y,p.y);	return *this;	}

	mov	eax, DWORD PTR _p$[esp-4]
	movss	xmm0, DWORD PTR [ecx]
	movss	xmm1, DWORD PTR [eax]
; File I:\Vitalya\mine\NSProjectX\xrCore\_std_extensions.h

; 93   : template <class T>	IC T		_min	(T a, T b)	{ return a<b?a:b;	}

	comiss	xmm1, xmm0
	ja	SHORT $LN8@modify
	movaps	xmm0, xmm1
$LN8@modify:
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector2.h

; 20   : 	IC SelfRef min(const Self &p)					{ x=_min(x,p.x); y=_min(y,p.y);	return *this;	}

	movss	DWORD PTR [ecx], xmm0
	movss	xmm0, DWORD PTR [ecx+4]
	movss	xmm1, DWORD PTR [eax+4]
; File I:\Vitalya\mine\NSProjectX\xrCore\_std_extensions.h

; 93   : template <class T>	IC T		_min	(T a, T b)	{ return a<b?a:b;	}

	comiss	xmm1, xmm0
	ja	SHORT $LN12@modify
	movaps	xmm0, xmm1
$LN12@modify:
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector2.h

; 20   : 	IC SelfRef min(const Self &p)					{ x=_min(x,p.x); y=_min(y,p.y);	return *this;	}

	movss	DWORD PTR [ecx+4], xmm0

; 22   : 	IC SelfRef max(const Self &p)					{ x=_max(x,p.x); y=_max(y,p.y);	return *this;	}

	movss	xmm0, DWORD PTR [ecx+8]
	movss	xmm1, DWORD PTR [eax]
; File I:\Vitalya\mine\NSProjectX\xrCore\_std_extensions.h

; 94   : template <class T>	IC T		_max	(T a, T b)	{ return a>b?a:b;	}

	comiss	xmm0, xmm1
	ja	SHORT $LN18@modify
	movaps	xmm0, xmm1
$LN18@modify:
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector2.h

; 22   : 	IC SelfRef max(const Self &p)					{ x=_max(x,p.x); y=_max(y,p.y);	return *this;	}

	movss	DWORD PTR [ecx+8], xmm0
	movss	xmm0, DWORD PTR [ecx+12]
	movss	xmm1, DWORD PTR [eax+4]
; File I:\Vitalya\mine\NSProjectX\xrCore\_std_extensions.h

; 94   : template <class T>	IC T		_max	(T a, T b)	{ return a>b?a:b;	}

	comiss	xmm0, xmm1
	ja	SHORT $LN22@modify
	movaps	xmm0, xmm1
$LN22@modify:
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector2.h

; 22   : 	IC SelfRef max(const Self &p)					{ x=_max(x,p.x); y=_max(y,p.y);	return *this;	}

	movss	DWORD PTR [ecx+12], xmm0
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox2.h

; 47   : 	IC	SelfRef	modify		(const Tvector &p)			{ min.min(p); max.max(p);				return *this;	}

	mov	eax, ecx
	ret	4
?modify@?$_box2@M@@QAEAAV1@ABU?$_vector2@M@@@Z ENDP	; _box2<float>::modify
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U_scissor@@@std@@@std@@@std@@QAE@PAU_scissor@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
___param0$ = 8						; size = 4
___param1$dead$ = 12					; size = 4
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U_scissor@@@std@@@std@@@std@@QAE@PAU_scissor@@PBU_Container_base0@1@@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<_scissor> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<_scissor> > >, COMDAT
; _this$ = ecx

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	eax, DWORD PTR ___param0$[esp-4]
	mov	DWORD PTR [ecx], eax
	mov	eax, ecx
	ret	8
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U_scissor@@@std@@@std@@@std@@QAE@PAU_scissor@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<_scissor> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<_scissor> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U_scissor@@@std@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U_scissor@@@std@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<_scissor> > >::operator+=, COMDAT
; _this$ = ecx

; 119  :         _Ptr += _Off;

	mov	eax, DWORD PTR __Off$[esp-4]
	lea	eax, DWORD PTR [eax+eax*4]
	shl	eax, 2
	add	DWORD PTR [ecx], eax

; 298  :         _Mybase::operator+=(_Off);
; 299  :         return *this;

	mov	eax, ecx

; 300  :     }

	ret	4
??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U_scissor@@@std@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<_scissor> > >::operator+=
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U_scissor@@@std@@@std@@@std@@QBEABU_scissor@@XZ
_TEXT	SEGMENT
??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U_scissor@@@std@@@std@@@std@@QBEABU_scissor@@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<_scissor> > >::operator*, COMDAT
; _this$ = ecx

; 46   : #if _ITERATOR_DEBUG_LEVEL != 0
; 47   :         const auto _Mycont = static_cast<const _Myvec*>(this->_Getcont());
; 48   :         _STL_VERIFY(_Ptr, "can't dereference value-initialized vector iterator");
; 49   :         _STL_VERIFY(
; 50   :             _Mycont->_Myfirst <= _Ptr && _Ptr < _Mycont->_Mylast, "can't dereference out of range vector iterator");
; 51   : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 52   : 
; 53   :         return *_Ptr;

	mov	eax, DWORD PTR [ecx]

; 54   :     }

	ret	0
??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U_scissor@@@std@@@std@@@std@@QBEABU_scissor@@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<_scissor> > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U_scissor@@@std@@@std@@@std@@QAE@PAU_scissor@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Pvector$dead$ = 12					; size = 4
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U_scissor@@@std@@@std@@@std@@QAE@PAU_scissor@@PBU_Container_base0@1@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<_scissor> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<_scissor> > >, COMDAT
; _this$ = ecx

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	eax, DWORD PTR __Parg$[esp-4]
	mov	DWORD PTR [ecx], eax

; 42   :         this->_Adopt(_Pvector);
; 43   :     }

	mov	eax, ecx
	ret	8
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U_scissor@@@std@@@std@@@std@@QAE@PAU_scissor@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<_scissor> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<_scissor> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@PAVCPortal@@M@std@@@std@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@PAVCPortal@@M@std@@@std@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::pair<CPortal *,float> > > >::operator+=, COMDAT
; _this$ = ecx

; 119  :         _Ptr += _Off;

	mov	eax, DWORD PTR __Off$[esp-4]
	shl	eax, 3
	add	DWORD PTR [ecx], eax

; 298  :         _Mybase::operator+=(_Off);
; 299  :         return *this;

	mov	eax, ecx

; 300  :     }

	ret	4
??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@PAVCPortal@@M@std@@@std@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::pair<CPortal *,float> > > >::operator+=
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@PAVCPortal@@M@std@@@std@@@std@@@std@@QBEABU?$pair@PAVCPortal@@M@1@XZ
_TEXT	SEGMENT
??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@PAVCPortal@@M@std@@@std@@@std@@@std@@QBEABU?$pair@PAVCPortal@@M@1@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::pair<CPortal *,float> > > >::operator*, COMDAT
; _this$ = ecx

; 46   : #if _ITERATOR_DEBUG_LEVEL != 0
; 47   :         const auto _Mycont = static_cast<const _Myvec*>(this->_Getcont());
; 48   :         _STL_VERIFY(_Ptr, "can't dereference value-initialized vector iterator");
; 49   :         _STL_VERIFY(
; 50   :             _Mycont->_Myfirst <= _Ptr && _Ptr < _Mycont->_Mylast, "can't dereference out of range vector iterator");
; 51   : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 52   : 
; 53   :         return *_Ptr;

	mov	eax, DWORD PTR [ecx]

; 54   :     }

	ret	0
??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@PAVCPortal@@M@std@@@std@@@std@@@std@@QBEABU?$pair@PAVCPortal@@M@1@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::pair<CPortal *,float> > > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$xalloc@U?$pair@PAVCPortal@@M@std@@@@V?$_Vector_val@U?$_Simple_types@U?$pair@PAVCPortal@@M@std@@@std@@@std@@$00@std@@QAEAAV?$xalloc@U?$pair@PAVCPortal@@M@std@@@@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@V?$xalloc@U?$pair@PAVCPortal@@M@std@@@@V?$_Vector_val@U?$_Simple_types@U?$pair@PAVCPortal@@M@std@@@std@@@std@@$00@std@@QAEAAV?$xalloc@U?$pair@PAVCPortal@@M@std@@@@XZ PROC ; std::_Compressed_pair<xalloc<std::pair<CPortal *,float> >,std::_Vector_val<std::_Simple_types<std::pair<CPortal *,float> > >,1>::_Get_first, COMDAT
; _this$ = ecx

; 1339 :         return *this;

	mov	eax, ecx

; 1340 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$xalloc@U?$pair@PAVCPortal@@M@std@@@@V?$_Vector_val@U?$_Simple_types@U?$pair@PAVCPortal@@M@std@@@std@@@std@@$00@std@@QAEAAV?$xalloc@U?$pair@PAVCPortal@@M@std@@@@XZ ENDP ; std::_Compressed_pair<xalloc<std::pair<CPortal *,float> >,std::_Vector_val<std::_Simple_types<std::pair<CPortal *,float> > >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Getal@?$vector@U?$pair@PAVCPortal@@M@std@@V?$xalloc@U?$pair@PAVCPortal@@M@std@@@@@std@@ABEABV?$xalloc@U?$pair@PAVCPortal@@M@std@@@@XZ
_TEXT	SEGMENT
?_Getal@?$vector@U?$pair@PAVCPortal@@M@std@@V?$xalloc@U?$pair@PAVCPortal@@M@std@@@@@std@@ABEABV?$xalloc@U?$pair@PAVCPortal@@M@std@@@@XZ PROC ; std::vector<std::pair<CPortal *,float>,xalloc<std::pair<CPortal *,float> > >::_Getal, COMDAT
; _this$ = ecx

; 1809 :         return _Mypair._Get_first();

	mov	eax, ecx

; 1810 :     }

	ret	0
?_Getal@?$vector@U?$pair@PAVCPortal@@M@std@@V?$xalloc@U?$pair@PAVCPortal@@M@std@@@@@std@@ABEABV?$xalloc@U?$pair@PAVCPortal@@M@std@@@@XZ ENDP ; std::vector<std::pair<CPortal *,float>,xalloc<std::pair<CPortal *,float> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Change_array@?$vector@U?$pair@PAVCPortal@@M@std@@V?$xalloc@U?$pair@PAVCPortal@@M@std@@@@@std@@AAEXQAU?$pair@PAVCPortal@@M@2@II@Z
_TEXT	SEGMENT
__Newvec$ = 8						; size = 4
__Newsize$ = 12						; size = 4
__Newcapacity$ = 16					; size = 4
?_Change_array@?$vector@U?$pair@PAVCPortal@@M@std@@V?$xalloc@U?$pair@PAVCPortal@@M@std@@@@@std@@AAEXQAU?$pair@PAVCPortal@@M@2@II@Z PROC ; std::vector<std::pair<CPortal *,float>,xalloc<std::pair<CPortal *,float> > >::_Change_array, COMDAT
; _this$ = ecx

; 1723 :         const pointer _Newvec, const size_type _Newsize, const size_type _Newcapacity) {

	push	esi
	mov	esi, ecx

; 1724 :         // orphan all iterators, discard old array, acquire new array
; 1725 :         auto& _My_data    = _Mypair._Myval2;
; 1726 :         pointer& _Myfirst = _My_data._Myfirst;
; 1727 :         pointer& _Mylast  = _My_data._Mylast;
; 1728 :         pointer& _Myend   = _My_data._Myend;
; 1729 : 
; 1730 :         _My_data._Orphan_all();
; 1731 : 
; 1732 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN7@Change_arr
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN7@Change_arr:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1737 :         _Myfirst = _Newvec;

	mov	ecx, DWORD PTR __Newvec$[esp]

; 1738 :         _Mylast  = _Newvec + _Newsize;

	mov	eax, DWORD PTR __Newsize$[esp]
	mov	DWORD PTR [esi], ecx
	lea	eax, DWORD PTR [ecx+eax*8]
	mov	DWORD PTR [esi+4], eax

; 1739 :         _Myend   = _Newvec + _Newcapacity;

	mov	eax, DWORD PTR __Newcapacity$[esp]
	lea	eax, DWORD PTR [ecx+eax*8]
	mov	DWORD PTR [esi+8], eax
	pop	esi

; 1740 :     }

	ret	12					; 0000000cH
?_Change_array@?$vector@U?$pair@PAVCPortal@@M@std@@V?$xalloc@U?$pair@PAVCPortal@@M@std@@@@@std@@AAEXQAU?$pair@PAVCPortal@@M@2@II@Z ENDP ; std::vector<std::pair<CPortal *,float>,xalloc<std::pair<CPortal *,float> > >::_Change_array
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Destroy@?$vector@U?$pair@PAVCPortal@@M@std@@V?$xalloc@U?$pair@PAVCPortal@@M@std@@@@@std@@AAEXPAU?$pair@PAVCPortal@@M@2@0@Z
_TEXT	SEGMENT
__First$dead$ = 8					; size = 4
__Last$dead$ = 12					; size = 4
?_Destroy@?$vector@U?$pair@PAVCPortal@@M@std@@V?$xalloc@U?$pair@PAVCPortal@@M@std@@@@@std@@AAEXPAU?$pair@PAVCPortal@@M@2@0@Z PROC ; std::vector<std::pair<CPortal *,float>,xalloc<std::pair<CPortal *,float> > >::_Destroy, COMDAT
; _this$dead$ = ecx

; 1666 :         // destroy [_First, _Last) using allocator
; 1667 :         _Destroy_range(_First, _Last, _Getal());
; 1668 :     }

	ret	8
?_Destroy@?$vector@U?$pair@PAVCPortal@@M@std@@V?$xalloc@U?$pair@PAVCPortal@@M@std@@@@@std@@AAEXPAU?$pair@PAVCPortal@@M@2@0@Z ENDP ; std::vector<std::pair<CPortal *,float>,xalloc<std::pair<CPortal *,float> > >::_Destroy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Umove_if_noexcept@?$vector@U?$pair@PAVCPortal@@M@std@@V?$xalloc@U?$pair@PAVCPortal@@M@std@@@@@std@@AAEXPAU?$pair@PAVCPortal@@M@2@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
?_Umove_if_noexcept@?$vector@U?$pair@PAVCPortal@@M@std@@V?$xalloc@U?$pair@PAVCPortal@@M@std@@@@@std@@AAEXPAU?$pair@PAVCPortal@@M@2@00@Z PROC ; std::vector<std::pair<CPortal *,float>,xalloc<std::pair<CPortal *,float> > >::_Umove_if_noexcept, COMDAT
; _this$dead$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1703 :     auto _UFirst      = _Get_unwrapped(_First);

	mov	eax, DWORD PTR __First$[esp-4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1659 :     _CONSTEXPR20_CONTAINER void _Umove_if_noexcept(pointer _First, pointer _Last, pointer _Dest) {

	push	edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	mov	edi, DWORD PTR __Last$[esp]
	cmp	eax, edi
	je	SHORT $LN7@Umove_if_n

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	push	esi
	mov	esi, DWORD PTR __Dest$[esp+4]
	sub	esi, eax
$LL8@Umove_if_n:

; 1620 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [esi+eax], ecx
	mov	DWORD PTR [esi+eax+4], edx

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	add	eax, 8
	cmp	eax, edi
	jne	SHORT $LL8@Umove_if_n
	pop	esi
$LN7@Umove_if_n:
	pop	edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1663 :     }

	ret	12					; 0000000cH
?_Umove_if_noexcept@?$vector@U?$pair@PAVCPortal@@M@std@@V?$xalloc@U?$pair@PAVCPortal@@M@std@@@@@std@@AAEXPAU?$pair@PAVCPortal@@M@2@00@Z ENDP ; std::vector<std::pair<CPortal *,float>,xalloc<std::pair<CPortal *,float> > >::_Umove_if_noexcept
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?clear@?$vector@U?$pair@PAVCPortal@@M@std@@V?$xalloc@U?$pair@PAVCPortal@@M@std@@@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$vector@U?$pair@PAVCPortal@@M@std@@V?$xalloc@U?$pair@PAVCPortal@@M@std@@@@@std@@QAEXXZ PROC ; std::vector<std::pair<CPortal *,float>,xalloc<std::pair<CPortal *,float> > >::clear, COMDAT
; _this$ = ecx

; 1437 :         auto& _My_data    = _Mypair._Myval2;
; 1438 :         pointer& _Myfirst = _My_data._Myfirst;
; 1439 :         pointer& _Mylast  = _My_data._Mylast;
; 1440 : 
; 1441 :         _My_data._Orphan_all();
; 1442 :         _Destroy(_Myfirst, _Mylast);
; 1443 :         _Mylast = _Myfirst;

	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [ecx+4], eax

; 1444 :     }

	ret	0
?clear@?$vector@U?$pair@PAVCPortal@@M@std@@V?$xalloc@U?$pair@PAVCPortal@@M@std@@@@@std@@QAEXXZ ENDP ; std::vector<std::pair<CPortal *,float>,xalloc<std::pair<CPortal *,float> > >::clear
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?max_size@?$_Normal_allocator_traits@V?$xalloc@U?$pair@PAVCPortal@@M@std@@@@@std@@SAIABV?$xalloc@U?$pair@PAVCPortal@@M@std@@@@@Z
_TEXT	SEGMENT
?max_size@?$_Normal_allocator_traits@V?$xalloc@U?$pair@PAVCPortal@@M@std@@@@@std@@SAIABV?$xalloc@U?$pair@PAVCPortal@@M@std@@@@@Z PROC ; std::_Normal_allocator_traits<xalloc<std::pair<CPortal *,float> > >::max_size, COMDAT
; __Al$dead$ = ecx

; 591  :         if constexpr (_Has_max_size<_Alloc>::value) {
; 592  :             return _Al.max_size();

	mov	eax, 536870911				; 1fffffffH

; 593  :         } else {
; 594  :             return (numeric_limits<size_type>::max)() / sizeof(value_type);
; 595  :         }
; 596  :     }

	ret	0
?max_size@?$_Normal_allocator_traits@V?$xalloc@U?$pair@PAVCPortal@@M@std@@@@@std@@SAIABV?$xalloc@U?$pair@PAVCPortal@@M@std@@@@@Z ENDP ; std::_Normal_allocator_traits<xalloc<std::pair<CPortal *,float> > >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?deallocate@?$xalloc@U?$pair@PAVCPortal@@M@std@@@@QBEXPAU?$pair@PAVCPortal@@M@std@@I@Z
_TEXT	SEGMENT
_p$ = 8							; size = 4
_n$dead$ = 12						; size = 4
?deallocate@?$xalloc@U?$pair@PAVCPortal@@M@std@@@@QBEXPAU?$pair@PAVCPortal@@M@std@@I@Z PROC ; xalloc<std::pair<CPortal *,float> >::deallocate, COMDAT
; _this$dead$ = ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	eax, DWORD PTR _p$[esp-4]
	test	eax, eax
	je	SHORT $LN4@deallocate
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN4@deallocate:
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 82   : 							void					deallocate		(pointer p, size_type n) const			{	xr_free	(p);				}

	ret	8
?deallocate@?$xalloc@U?$pair@PAVCPortal@@M@std@@@@QBEXPAU?$pair@PAVCPortal@@M@std@@I@Z ENDP ; xalloc<std::pair<CPortal *,float> >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?allocate@?$xalloc@U?$pair@PAVCPortal@@M@std@@@@QBEPAU?$pair@PAVCPortal@@M@std@@IPBX@Z
_TEXT	SEGMENT
_n$ = 8							; size = 4
_p$dead$ = 12						; size = 4
?allocate@?$xalloc@U?$pair@PAVCPortal@@M@std@@@@QBEPAU?$pair@PAVCPortal@@M@std@@IPBX@Z PROC ; xalloc<std::pair<CPortal *,float> >::allocate, COMDAT
; _this$dead$ = ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	mov	eax, DWORD PTR _n$[esp-4]
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	shl	eax, 3
	push	eax
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 80   : 							pointer					allocate		(size_type n, const void* p=0) const	{	return xr_alloc<T>((u32)n);	}

	ret	8
?allocate@?$xalloc@U?$pair@PAVCPortal@@M@std@@@@QBEPAU?$pair@PAVCPortal@@M@std@@IPBX@Z ENDP ; xalloc<std::pair<CPortal *,float> >::allocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?clear@?$vector@PAVIRender_Sector@@V?$xalloc@PAVIRender_Sector@@@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$vector@PAVIRender_Sector@@V?$xalloc@PAVIRender_Sector@@@@@std@@QAEXXZ PROC ; std::vector<IRender_Sector *,xalloc<IRender_Sector *> >::clear, COMDAT
; _this$ = ecx

; 1437 :         auto& _My_data    = _Mypair._Myval2;
; 1438 :         pointer& _Myfirst = _My_data._Myfirst;
; 1439 :         pointer& _Mylast  = _My_data._Mylast;
; 1440 : 
; 1441 :         _My_data._Orphan_all();
; 1442 :         _Destroy(_Myfirst, _Mylast);
; 1443 :         _Mylast = _Myfirst;

	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [ecx+4], eax

; 1444 :     }

	ret	0
?clear@?$vector@PAVIRender_Sector@@V?$xalloc@PAVIRender_Sector@@@@@std@@QAEXXZ ENDP ; std::vector<IRender_Sector *,xalloc<IRender_Sector *> >::clear
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector2.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_std_extensions.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector2.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_std_extensions.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector2.h
;	COMDAT ?max@?$_vector2@M@@QAEAAU1@ABU1@@Z
_TEXT	SEGMENT
_p$ = 8							; size = 4
?max@?$_vector2@M@@QAEAAU1@ABU1@@Z PROC			; _vector2<float>::max, COMDAT
; _this$ = ecx

; 22   : 	IC SelfRef max(const Self &p)					{ x=_max(x,p.x); y=_max(y,p.y);	return *this;	}

	mov	eax, DWORD PTR _p$[esp-4]
	movss	xmm0, DWORD PTR [ecx]
	movss	xmm1, DWORD PTR [eax]
; File I:\Vitalya\mine\NSProjectX\xrCore\_std_extensions.h

; 94   : template <class T>	IC T		_max	(T a, T b)	{ return a>b?a:b;	}

	comiss	xmm0, xmm1
	ja	SHORT $LN6@max
	movaps	xmm0, xmm1
$LN6@max:
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector2.h

; 22   : 	IC SelfRef max(const Self &p)					{ x=_max(x,p.x); y=_max(y,p.y);	return *this;	}

	movss	DWORD PTR [ecx], xmm0
	movss	xmm0, DWORD PTR [ecx+4]
	movss	xmm1, DWORD PTR [eax+4]
; File I:\Vitalya\mine\NSProjectX\xrCore\_std_extensions.h

; 94   : template <class T>	IC T		_max	(T a, T b)	{ return a>b?a:b;	}

	comiss	xmm0, xmm1
	ja	SHORT $LN10@max
	movaps	xmm0, xmm1
$LN10@max:
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector2.h

; 22   : 	IC SelfRef max(const Self &p)					{ x=_max(x,p.x); y=_max(y,p.y);	return *this;	}

	movss	DWORD PTR [ecx+4], xmm0
	mov	eax, ecx
	ret	4
?max@?$_vector2@M@@QAEAAU1@ABU1@@Z ENDP			; _vector2<float>::max
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector2.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_std_extensions.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector2.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_std_extensions.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector2.h
;	COMDAT ?min@?$_vector2@M@@QAEAAU1@ABU1@@Z
_TEXT	SEGMENT
_p$ = 8							; size = 4
?min@?$_vector2@M@@QAEAAU1@ABU1@@Z PROC			; _vector2<float>::min, COMDAT
; _this$ = ecx

; 20   : 	IC SelfRef min(const Self &p)					{ x=_min(x,p.x); y=_min(y,p.y);	return *this;	}

	mov	eax, DWORD PTR _p$[esp-4]
	movss	xmm0, DWORD PTR [ecx]
	movss	xmm1, DWORD PTR [eax]
; File I:\Vitalya\mine\NSProjectX\xrCore\_std_extensions.h

; 93   : template <class T>	IC T		_min	(T a, T b)	{ return a<b?a:b;	}

	comiss	xmm1, xmm0
	ja	SHORT $LN6@min
	movaps	xmm0, xmm1
$LN6@min:
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector2.h

; 20   : 	IC SelfRef min(const Self &p)					{ x=_min(x,p.x); y=_min(y,p.y);	return *this;	}

	movss	DWORD PTR [ecx], xmm0
	movss	xmm0, DWORD PTR [ecx+4]
	movss	xmm1, DWORD PTR [eax+4]
; File I:\Vitalya\mine\NSProjectX\xrCore\_std_extensions.h

; 93   : template <class T>	IC T		_min	(T a, T b)	{ return a<b?a:b;	}

	comiss	xmm1, xmm0
	ja	SHORT $LN10@min
	movaps	xmm0, xmm1
$LN10@min:
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector2.h

; 20   : 	IC SelfRef min(const Self &p)					{ x=_min(x,p.x); y=_min(y,p.y);	return *this;	}

	movss	DWORD PTR [ecx+4], xmm0
	mov	eax, ecx
	ret	4
?min@?$_vector2@M@@QAEAAU1@ABU1@@Z ENDP			; _vector2<float>::min
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U_scissor@@@std@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U_scissor@@@std@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<_scissor> > >::operator+=, COMDAT
; _this$ = ecx

; 118  :         _Verify_offset(_Off);
; 119  :         _Ptr += _Off;

	mov	eax, DWORD PTR __Off$[esp-4]
	lea	eax, DWORD PTR [eax+eax*4]
	shl	eax, 2
	add	DWORD PTR [ecx], eax

; 120  :         return *this;

	mov	eax, ecx

; 121  :     }

	ret	4
??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U_scissor@@@std@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<_scissor> > >::operator+=
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@PAVCPortal@@M@std@@@std@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@PAVCPortal@@M@std@@@std@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::pair<CPortal *,float> > > >::operator+=, COMDAT
; _this$ = ecx

; 118  :         _Verify_offset(_Off);
; 119  :         _Ptr += _Off;

	mov	eax, DWORD PTR __Off$[esp-4]
	shl	eax, 3
	add	DWORD PTR [ecx], eax

; 120  :         return *this;

	mov	eax, ecx

; 121  :     }

	ret	4
??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@PAVCPortal@@M@std@@@std@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::pair<CPortal *,float> > > >::operator+=
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$xalloc@U?$pair@PAVCPortal@@M@std@@@@V?$_Vector_val@U?$_Simple_types@U?$pair@PAVCPortal@@M@std@@@std@@@std@@$00@std@@QBEABV?$xalloc@U?$pair@PAVCPortal@@M@std@@@@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@V?$xalloc@U?$pair@PAVCPortal@@M@std@@@@V?$_Vector_val@U?$_Simple_types@U?$pair@PAVCPortal@@M@std@@@std@@@std@@$00@std@@QBEABV?$xalloc@U?$pair@PAVCPortal@@M@std@@@@XZ PROC ; std::_Compressed_pair<xalloc<std::pair<CPortal *,float> >,std::_Vector_val<std::_Simple_types<std::pair<CPortal *,float> > >,1>::_Get_first, COMDAT
; _this$ = ecx

; 1343 :         return *this;

	mov	eax, ecx

; 1344 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$xalloc@U?$pair@PAVCPortal@@M@std@@@@V?$_Vector_val@U?$_Simple_types@U?$pair@PAVCPortal@@M@std@@@std@@@std@@$00@std@@QBEABV?$xalloc@U?$pair@PAVCPortal@@M@std@@@@XZ ENDP ; std::_Compressed_pair<xalloc<std::pair<CPortal *,float> >,std::_Vector_val<std::_Simple_types<std::pair<CPortal *,float> > >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Umove_if_noexcept1@?$vector@U?$pair@PAVCPortal@@M@std@@V?$xalloc@U?$pair@PAVCPortal@@M@std@@@@@std@@AAEXPAU?$pair@PAVCPortal@@M@2@00U?$integral_constant@_N$00@2@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
?_Umove_if_noexcept1@?$vector@U?$pair@PAVCPortal@@M@std@@V?$xalloc@U?$pair@PAVCPortal@@M@std@@@@@std@@AAEXPAU?$pair@PAVCPortal@@M@2@00U?$integral_constant@_N$00@2@@Z PROC ; std::vector<std::pair<CPortal *,float>,xalloc<std::pair<CPortal *,float> > >::_Umove_if_noexcept1, COMDAT
; _this$dead$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1703 :     auto _UFirst      = _Get_unwrapped(_First);

	mov	eax, DWORD PTR __First$[esp-4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1649 :     _CONSTEXPR20_CONTAINER void _Umove_if_noexcept1(pointer _First, pointer _Last, pointer _Dest, true_type) {

	push	edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	mov	edi, DWORD PTR __Last$[esp]
	cmp	eax, edi
	je	SHORT $LN5@Umove_if_n

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	push	esi
	mov	esi, DWORD PTR __Dest$[esp+4]
	sub	esi, eax
$LL6@Umove_if_n:

; 1620 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [esi+eax], ecx
	mov	DWORD PTR [esi+eax+4], edx

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	add	eax, 8
	cmp	eax, edi
	jne	SHORT $LL6@Umove_if_n
	pop	esi
$LN5@Umove_if_n:
	pop	edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1652 :     }

	ret	16					; 00000010H
?_Umove_if_noexcept1@?$vector@U?$pair@PAVCPortal@@M@std@@V?$xalloc@U?$pair@PAVCPortal@@M@std@@@@@std@@AAEXPAU?$pair@PAVCPortal@@M@2@00U?$integral_constant@_N$00@2@@Z ENDP ; std::vector<std::pair<CPortal *,float>,xalloc<std::pair<CPortal *,float> > >::_Umove_if_noexcept1
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?max_size@?$xalloc@U?$pair@PAVCPortal@@M@std@@@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$xalloc@U?$pair@PAVCPortal@@M@std@@@@QBEIXZ PROC ; xalloc<std::pair<CPortal *,float> >::max_size, COMDAT
; _this$dead$ = ecx

; 86   : 							size_type				max_size		() const								{	size_type _Count = (size_type)(-1) / sizeof (T);	return (0 < _Count ? _Count : 1);	}

	mov	eax, 536870911				; 1fffffffH
	ret	0
?max_size@?$xalloc@U?$pair@PAVCPortal@@M@std@@@@QBEIXZ ENDP ; xalloc<std::pair<CPortal *,float> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Verify_offset@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U_scissor@@@std@@@std@@@std@@QBEXH@Z
_TEXT	SEGMENT
__Off$dead$ = 8						; size = 4
?_Verify_offset@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U_scissor@@@std@@@std@@@std@@QBEXH@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<_scissor> > >::_Verify_offset, COMDAT
; _this$dead$ = ecx

; 102  : #if _ITERATOR_DEBUG_LEVEL == 0
; 103  :         (void) _Off;
; 104  : #else // ^^^ _ITERATOR_DEBUG_LEVEL == 0 ^^^ // vvv _ITERATOR_DEBUG_LEVEL != 0 vvv
; 105  :         const auto _Mycont = static_cast<const _Myvec*>(this->_Getcont());
; 106  :         _STL_VERIFY(_Off == 0 || _Ptr, "cannot seek value-initialized vector iterator");
; 107  :         if (_Off < 0) {
; 108  :             _STL_VERIFY(_Off >= _Mycont->_Myfirst - _Ptr, "cannot seek vector iterator before begin");
; 109  :         }
; 110  : 
; 111  :         if (_Off > 0) {
; 112  :             _STL_VERIFY(_Off <= _Mycont->_Mylast - _Ptr, "cannot seek vector iterator after end");
; 113  :         }
; 114  : #endif // _ITERATOR_DEBUG_LEVEL == 0
; 115  :     }

	ret	4
?_Verify_offset@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U_scissor@@@std@@@std@@@std@@QBEXH@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<_scissor> > >::_Verify_offset
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Verify_offset@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@PAVCPortal@@M@std@@@std@@@std@@@std@@QBEXH@Z
_TEXT	SEGMENT
__Off$dead$ = 8						; size = 4
?_Verify_offset@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@PAVCPortal@@M@std@@@std@@@std@@@std@@QBEXH@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::pair<CPortal *,float> > > >::_Verify_offset, COMDAT
; _this$dead$ = ecx

; 102  : #if _ITERATOR_DEBUG_LEVEL == 0
; 103  :         (void) _Off;
; 104  : #else // ^^^ _ITERATOR_DEBUG_LEVEL == 0 ^^^ // vvv _ITERATOR_DEBUG_LEVEL != 0 vvv
; 105  :         const auto _Mycont = static_cast<const _Myvec*>(this->_Getcont());
; 106  :         _STL_VERIFY(_Off == 0 || _Ptr, "cannot seek value-initialized vector iterator");
; 107  :         if (_Off < 0) {
; 108  :             _STL_VERIFY(_Off >= _Mycont->_Myfirst - _Ptr, "cannot seek vector iterator before begin");
; 109  :         }
; 110  : 
; 111  :         if (_Off > 0) {
; 112  :             _STL_VERIFY(_Off <= _Mycont->_Mylast - _Ptr, "cannot seek vector iterator after end");
; 113  :         }
; 114  : #endif // _ITERATOR_DEBUG_LEVEL == 0
; 115  :     }

	ret	4
?_Verify_offset@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@PAVCPortal@@M@std@@@std@@@std@@@std@@QBEXH@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::pair<CPortal *,float> > > >::_Verify_offset
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ??$mk_pair@PAVCPortal@@M@@YA?AU?$pair@PAVCPortal@@M@std@@PAVCPortal@@M@Z
_TEXT	SEGMENT
__Val2$ = 8						; size = 4
??$mk_pair@PAVCPortal@@M@@YA?AU?$pair@PAVCPortal@@M@std@@PAVCPortal@@M@Z PROC ; mk_pair<CPortal *,float>, COMDAT
; ___$ReturnUdt$ = ecx
; __Val1$ = edx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 186  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

	movss	xmm0, DWORD PTR __Val2$[esp-4]
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 207  : template	<class _Ty1, class _Ty2> inline	std::pair<_Ty1, _Ty2>		mk_pair		(_Ty1 _Val1, _Ty2 _Val2)	{	return (std::pair<_Ty1, _Ty2>(_Val1, _Val2));	}

	mov	eax, ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 186  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

	mov	DWORD PTR [ecx], edx
	movss	DWORD PTR [ecx+4], xmm0
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 207  : template	<class _Ty1, class _Ty2> inline	std::pair<_Ty1, _Ty2>		mk_pair		(_Ty1 _Val1, _Ty2 _Val2)	{	return (std::pair<_Ty1, _Ty2>(_Val1, _Val2));	}

	ret	0
??$mk_pair@PAVCPortal@@M@@YA?AU?$pair@PAVCPortal@@M@std@@PAVCPortal@@M@Z ENDP ; mk_pair<CPortal *,float>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
;	COMDAT ??$sort@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@PAVCPortal@@M@std@@@std@@@std@@@std@@P6A_NABU?$pair@PAVCPortal@@M@2@0@Z@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@PAVCPortal@@M@std@@@std@@@std@@@0@0P6A_NABU?$pair@PAVCPortal@@M@0@1@Z@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$sort@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@PAVCPortal@@M@std@@@std@@@std@@@std@@P6A_NABU?$pair@PAVCPortal@@M@2@0@Z@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@PAVCPortal@@M@std@@@std@@@std@@@0@0P6A_NABU?$pair@PAVCPortal@@M@0@1@Z@Z PROC ; std::sort<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::pair<CPortal *,float> > > >,bool (__cdecl*)(std::pair<CPortal *,float> const &,std::pair<CPortal *,float> const &)>, COMDAT
; __Pred$dead$ = ecx

; 7076 : _CONSTEXPR20 void sort(const _RanIt _First, const _RanIt _Last, _Pr _Pred) { // order [_First, _Last)

	push	ecx

; 7077 :     _Adl_verify_range(_First, _Last);
; 7078 :     const auto _UFirst = _Get_unwrapped(_First);
; 7079 :     const auto _ULast  = _Get_unwrapped(_Last);
; 7080 :     _Sort_unchecked(_UFirst, _ULast, _ULast - _UFirst, _Pass_fn(_Pred));

	mov	edx, DWORD PTR __Last$[esp]
	mov	eax, edx
	mov	ecx, DWORD PTR __First$[esp]
	sub	eax, ecx
	sar	eax, 3
	push	OFFSET ?psort_pred@@YA_NABU?$pair@PAVCPortal@@M@std@@0@Z ; psort_pred
	push	eax
	call	??$_Sort_unchecked@PAU?$pair@PAVCPortal@@M@std@@P6A_NABU12@0@Z@std@@YAXPAU?$pair@PAVCPortal@@M@0@0HP6A_NABU10@1@Z@Z ; std::_Sort_unchecked<std::pair<CPortal *,float> *,bool (__cdecl*)(std::pair<CPortal *,float> const &,std::pair<CPortal *,float> const &)>
	add	esp, 8

; 7081 : }

	pop	ecx
	ret	0
??$sort@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@PAVCPortal@@M@std@@@std@@@std@@@std@@P6A_NABU?$pair@PAVCPortal@@M@2@0@Z@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@PAVCPortal@@M@std@@@std@@@std@@@0@0P6A_NABU?$pair@PAVCPortal@@M@0@1@Z@Z ENDP ; std::sort<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::pair<CPortal *,float> > > >,bool (__cdecl*)(std::pair<CPortal *,float> const &,std::pair<CPortal *,float> const &)>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_Get_unwrapped@ABV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@PAVCPortal@@M@std@@@std@@@std@@@std@@@std@@YA?A_TABV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@PAVCPortal@@M@std@@@std@@@std@@@0@@Z
_TEXT	SEGMENT
??$_Get_unwrapped@ABV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@PAVCPortal@@M@std@@@std@@@std@@@std@@@std@@YA?A_TABV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@PAVCPortal@@M@std@@@std@@@std@@@0@@Z PROC ; std::_Get_unwrapped<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::pair<CPortal *,float> > > > const &>, COMDAT
; __It$ = ecx

; 1275 :     // unwrap an iterator previously subjected to _Adl_verify_range or otherwise validated
; 1276 :     if constexpr (is_pointer_v<decay_t<_Iter>>) { // special-case pointers and arrays
; 1277 :         return _It + 0;
; 1278 :     } else if constexpr (_Unwrappable_v<_Iter>) {
; 1279 :         return static_cast<_Iter&&>(_It)._Unwrapped();

	mov	eax, DWORD PTR [ecx]

; 1280 :     } else {
; 1281 :         return static_cast<_Iter&&>(_It);
; 1282 :     }
; 1283 : }

	ret	0
??$_Get_unwrapped@ABV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@PAVCPortal@@M@std@@@std@@@std@@@std@@@std@@YA?A_TABV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@PAVCPortal@@M@std@@@std@@@std@@@0@@Z ENDP ; std::_Get_unwrapped<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::pair<CPortal *,float> > > > const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef
;	COMDAT ??$addressof@V?$_Vector_val@U?$_Simple_types@U?$pair@PAVCPortal@@M@std@@@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@U?$pair@PAVCPortal@@M@std@@@std@@@0@AAV10@@Z
_TEXT	SEGMENT
??$addressof@V?$_Vector_val@U?$_Simple_types@U?$pair@PAVCPortal@@M@std@@@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@U?$pair@PAVCPortal@@M@std@@@std@@@0@AAV10@@Z PROC ; std::addressof<std::_Vector_val<std::_Simple_types<std::pair<CPortal *,float> > > >, COMDAT
; __Val$ = ecx

; 253  :     return __builtin_addressof(_Val);

	mov	eax, ecx

; 254  : }

	ret	0
??$addressof@V?$_Vector_val@U?$_Simple_types@U?$pair@PAVCPortal@@M@std@@@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@U?$pair@PAVCPortal@@M@std@@@std@@@0@AAV10@@Z ENDP ; std::addressof<std::_Vector_val<std::_Simple_types<std::pair<CPortal *,float> > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\type_traits
;	COMDAT ??$move@AAU?$pair@PAVCPortal@@M@std@@@std@@YA$$QAU?$pair@PAVCPortal@@M@0@AAU10@@Z
_TEXT	SEGMENT
??$move@AAU?$pair@PAVCPortal@@M@std@@@std@@YA$$QAU?$pair@PAVCPortal@@M@0@AAU10@@Z PROC ; std::move<std::pair<CPortal *,float> &>, COMDAT
; __Arg$ = ecx

; 1397 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

	mov	eax, ecx

; 1398 : }

	ret	0
??$move@AAU?$pair@PAVCPortal@@M@std@@@std@@YA$$QAU?$pair@PAVCPortal@@M@0@AAU10@@Z ENDP ; std::move<std::pair<CPortal *,float> &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\type_traits
;	COMDAT ??$forward@U?$pair@PAVCPortal@@M@std@@@std@@YA$$QAU?$pair@PAVCPortal@@M@0@AAU10@@Z
_TEXT	SEGMENT
??$forward@U?$pair@PAVCPortal@@M@std@@@std@@YA$$QAU?$pair@PAVCPortal@@M@0@AAU10@@Z PROC ; std::forward<std::pair<CPortal *,float> >, COMDAT
; __Arg$ = ecx

; 1386 :     return static_cast<_Ty&&>(_Arg);

	mov	eax, ecx

; 1387 : }

	ret	0
??$forward@U?$pair@PAVCPortal@@M@std@@@std@@YA$$QAU?$pair@PAVCPortal@@M@0@AAU10@@Z ENDP ; std::forward<std::pair<CPortal *,float> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef
;	COMDAT ??$_Unfancy@U?$pair@PAVCPortal@@M@std@@@std@@YAPAU?$pair@PAVCPortal@@M@0@PAU10@@Z
_TEXT	SEGMENT
??$_Unfancy@U?$pair@PAVCPortal@@M@std@@@std@@YAPAU?$pair@PAVCPortal@@M@0@PAU10@@Z PROC ; std::_Unfancy<std::pair<CPortal *,float> >, COMDAT
; __Ptr$ = ecx

; 266  :     return _Ptr;

	mov	eax, ecx

; 267  : }

	ret	0
??$_Unfancy@U?$pair@PAVCPortal@@M@std@@@std@@YAPAU?$pair@PAVCPortal@@M@0@PAU10@@Z ENDP ; std::_Unfancy<std::pair<CPortal *,float> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$construct@U?$pair@PAVCPortal@@M@std@@U12@@?$_Normal_allocator_traits@V?$xalloc@U?$pair@PAVCPortal@@M@std@@@@@std@@SAXAAV?$xalloc@U?$pair@PAVCPortal@@M@std@@@@PAU?$pair@PAVCPortal@@M@1@$$QAU31@@Z
_TEXT	SEGMENT
_<_Args_0>$ = 8						; size = 4
??$construct@U?$pair@PAVCPortal@@M@std@@U12@@?$_Normal_allocator_traits@V?$xalloc@U?$pair@PAVCPortal@@M@std@@@@@std@@SAXAAV?$xalloc@U?$pair@PAVCPortal@@M@std@@@@PAU?$pair@PAVCPortal@@M@1@$$QAU31@@Z PROC ; std::_Normal_allocator_traits<xalloc<std::pair<CPortal *,float> > >::construct<std::pair<CPortal *,float>,std::pair<CPortal *,float> >, COMDAT
; __Al$dead$ = ecx
; __Ptr$ = edx

; 565  :         if constexpr (_Uses_default_construct<_Alloc, _Ty*, _Types...>::value) {
; 566  :             (void) _Al; // TRANSITION, DevCom-1004719
; 567  : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 568  :             _STD construct_at(_Ptr, _STD forward<_Types>(_Args)...);
; 569  : #else // __cpp_lib_constexpr_dynamic_alloc
; 570  :             ::new (static_cast<void*>(_Ptr)) _Ty(_STD forward<_Types>(_Args)...);
; 571  : #endif // __cpp_lib_constexpr_dynamic_alloc
; 572  :         } else {
; 573  :             _Al.construct(_Ptr, _STD forward<_Types>(_Args)...);

	mov	eax, DWORD PTR _<_Args_0>$[esp-4]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR [edx], ecx
	mov	DWORD PTR [edx+4], eax

; 574  :         }
; 575  :     }

	ret	0
??$construct@U?$pair@PAVCPortal@@M@std@@U12@@?$_Normal_allocator_traits@V?$xalloc@U?$pair@PAVCPortal@@M@std@@@@@std@@SAXAAV?$xalloc@U?$pair@PAVCPortal@@M@std@@@@PAU?$pair@PAVCPortal@@M@1@$$QAU31@@Z ENDP ; std::_Normal_allocator_traits<xalloc<std::pair<CPortal *,float> > >::construct<std::pair<CPortal *,float>,std::pair<CPortal *,float> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??$_Emplace_reallocate@U?$pair@PAVCPortal@@M@std@@@?$vector@U?$pair@PAVCPortal@@M@std@@V?$xalloc@U?$pair@PAVCPortal@@M@std@@@@@std@@QAEPAU?$pair@PAVCPortal@@M@1@QAU21@$$QAU21@@Z
_TEXT	SEGMENT
__Backout$2 = -60					; size = 12
__Backout$3 = -48					; size = 12
__UFirst$4 = -36					; size = 4
__UFirst$5 = -32					; size = 4
__Newcapacity$1$ = -28					; size = 4
__Newsize$1$ = -24					; size = 4
tv480 = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Newvec$ = 8						; size = 4
__Whereptr$ = 8						; size = 4
_<_Val_0>$ = 12						; size = 4
??$_Emplace_reallocate@U?$pair@PAVCPortal@@M@std@@@?$vector@U?$pair@PAVCPortal@@M@std@@V?$xalloc@U?$pair@PAVCPortal@@M@std@@@@@std@@QAEPAU?$pair@PAVCPortal@@M@1@QAU21@$$QAU21@@Z PROC ; std::vector<std::pair<CPortal *,float>,xalloc<std::pair<CPortal *,float> > >::_Emplace_reallocate<std::pair<CPortal *,float> >, COMDAT
; _this$ = ecx

; 752  :     _CONSTEXPR20_CONTAINER pointer _Emplace_reallocate(const pointer _Whereptr, _Valty&&... _Val) {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Emplace_reallocate@U?$pair@PAVCPortal@@M@std@@@?$vector@U?$pair@PAVCPortal@@M@std@@V?$xalloc@U?$pair@PAVCPortal@@M@std@@@@@std@@QAEPAU?$pair@PAVCPortal@@M@1@QAU21@$$QAU21@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 48					; 00000030H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	ebx, ecx

; 753  :         // reallocate and insert by perfectly forwarding _Val at _Whereptr
; 754  :         _Alty& _Al        = _Getal();
; 755  :         auto& _My_data    = _Mypair._Myval2;
; 756  :         pointer& _Myfirst = _My_data._Myfirst;
; 757  :         pointer& _Mylast  = _My_data._Mylast;
; 758  : 
; 759  :         _STL_INTERNAL_CHECK(_Mylast == _My_data._Myend); // check that we have no unused capacity
; 760  : 
; 761  :         const auto _Whereoff = static_cast<size_type>(_Whereptr - _Myfirst);

	mov	edx, DWORD PTR [ebx]
	mov	esi, DWORD PTR __Whereptr$[ebp]
	mov	edi, esi
	sub	edi, edx
	sar	edi, 3

; 762  :         const auto _Oldsize  = static_cast<size_type>(_Mylast - _Myfirst);

	mov	eax, DWORD PTR [ebx+4]
	sub	eax, edx
	sar	eax, 3

; 763  : 
; 764  :         if (_Oldsize == max_size()) {

	cmp	eax, 536870911				; 1fffffffH
	je	$LN65@Emplace_re

; 766  :         }
; 767  : 
; 768  :         const size_type _Newsize     = _Oldsize + 1;

	inc	eax
	mov	DWORD PTR __Newsize$1$[ebp], eax

; 1546 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	ecx, DWORD PTR [ebx+8]
	sub	ecx, edx
	sar	ecx, 3

; 1675 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	edx, ecx
	shr	edx, 1
	mov	eax, 536870911				; 1fffffffH
	sub	eax, edx
	cmp	ecx, eax
	jbe	SHORT $LN12@Emplace_re

; 1676 :             return _Max; // geometric growth would overflow

	mov	eax, 536870911				; 1fffffffH
	jmp	SHORT $LN63@Emplace_re
$LN12@Emplace_re:

; 1677 :         }
; 1678 : 
; 1679 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	lea	eax, DWORD PTR [edx+ecx]

; 1680 : 
; 1681 :         if (_Geometric < _Newsize) {

	cmp	eax, DWORD PTR __Newsize$1$[ebp]
	cmovb	eax, DWORD PTR __Newsize$1$[ebp]
$LN63@Emplace_re:
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	mov	DWORD PTR __Newcapacity$1$[ebp], eax
	shl	eax, 3
	push	eax
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 771  :         const pointer _Newvec           = _Al.allocate(_Newcapacity);

	mov	DWORD PTR __Newvec$[ebp], eax

; 772  :         const pointer _Constructed_last = _Newvec + _Whereoff + 1;
; 773  :         pointer _Constructed_first      = _Constructed_last;
; 774  : 
; 775  :         _TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 776  :         _Alty_traits::construct(_Al, _Unfancy(_Newvec + _Whereoff), _STD forward<_Valty>(_Val)...);

	lea	edi, DWORD PTR [eax+edi*8]
	mov	DWORD PTR tv480[ebp], edi
	mov	eax, DWORD PTR _<_Val_0>$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR [edi], ecx
	mov	DWORD PTR [edi+4], eax

; 777  :         _Constructed_first = _Newvec + _Whereoff;
; 778  : 
; 779  :         if (_Whereptr == _Mylast) { // at back, provide strong guarantee

	mov	eax, DWORD PTR [ebx+4]
	mov	edx, DWORD PTR [ebx]
	cmp	esi, eax
	jne	SHORT $LN4@Emplace_re

; 780  :             _Umove_if_noexcept(_Myfirst, _Mylast, _Newvec);

	mov	esi, DWORD PTR __Newvec$[ebp]
	push	esi
	push	eax
	push	edx
	call	?_Umove_if_noexcept@?$vector@U?$pair@PAVCPortal@@M@std@@V?$xalloc@U?$pair@PAVCPortal@@M@std@@@@@std@@AAEXPAU?$pair@PAVCPortal@@M@2@00@Z ; std::vector<std::pair<CPortal *,float>,xalloc<std::pair<CPortal *,float> > >::_Umove_if_noexcept

; 781  :         } else { // provide basic guarantee

	jmp	SHORT $LN5@Emplace_re
$LN4@Emplace_re:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1703 :     auto _UFirst      = _Get_unwrapped(_First);

	mov	DWORD PTR __UFirst$5[ebp], edx

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	edi, DWORD PTR __Newvec$[ebp]
	mov	DWORD PTR __Backout$3[ebp], edi
	mov	DWORD PTR __Backout$3[ebp+4], edi
	mov	DWORD PTR __Backout$3[ebp+8], ebx
$LL26@Emplace_re:

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	edx, esi
	je	SHORT $LN25@Emplace_re

; 1620 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [edi], eax
	mov	DWORD PTR [edi+4], ecx

; 1621 :         ++_Last;

	add	edi, 8
	mov	DWORD PTR __Backout$3[ebp+4], edi

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	add	edx, 8
	mov	DWORD PTR __UFirst$5[ebp], edx
	jmp	SHORT $LL26@Emplace_re
$LN25@Emplace_re:

; 1625 :         _First = _Last;

	mov	DWORD PTR __Backout$3[ebp], edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 784  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

	mov	edx, DWORD PTR tv480[ebp]
	add	edx, 8

; 1646 :         return _Uninitialized_move(_First, _Last, _Dest, _Getal());

	mov	edi, DWORD PTR [ebx+4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1703 :     auto _UFirst      = _Get_unwrapped(_First);

	mov	DWORD PTR __UFirst$4[ebp], esi

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	DWORD PTR __Backout$2[ebp], edx
	mov	DWORD PTR __Backout$2[ebp+4], edx
	mov	DWORD PTR __Backout$2[ebp+8], ebx
$LL39@Emplace_re:

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	esi, edi
	je	SHORT $LN38@Emplace_re

; 1620 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR [esi+4]
	mov	DWORD PTR [edx], eax
	mov	DWORD PTR [edx+4], ecx

; 1621 :         ++_Last;

	add	edx, 8
	mov	DWORD PTR __Backout$2[ebp+4], edx

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	add	esi, 8
	mov	DWORD PTR __UFirst$4[ebp], esi
	jmp	SHORT $LL39@Emplace_re
$LN38@Emplace_re:

; 1625 :         _First = _Last;

	mov	DWORD PTR __Backout$2[ebp], edx
	mov	esi, DWORD PTR __Newvec$[ebp]
	mov	edi, DWORD PTR tv480[ebp]
$LN5@Emplace_re:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
	mov	DWORD PTR __$EHRec$[ebp+12], -1

; 1732 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [ebx]
	test	eax, eax
	je	SHORT $LN53@Emplace_re
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	push	eax
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN53@Emplace_re:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1737 :         _Myfirst = _Newvec;

	mov	DWORD PTR [ebx], esi

; 1738 :         _Mylast  = _Newvec + _Newsize;

	mov	eax, DWORD PTR __Newsize$1$[ebp]
	lea	ecx, DWORD PTR [esi+eax*8]
	mov	DWORD PTR [ebx+4], ecx

; 1739 :         _Myend   = _Newvec + _Newcapacity;

	mov	ecx, DWORD PTR __Newcapacity$1$[ebp]
	lea	ecx, DWORD PTR [esi+ecx*8]
	mov	DWORD PTR [ebx+8], ecx

; 790  :         _CATCH_END
; 791  : 
; 792  :         _Change_array(_Newvec, _Newsize, _Newcapacity);
; 793  :         return _Newvec + _Whereoff;

	mov	eax, edi

; 794  :     }

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
__catch$??$_Emplace_reallocate@U?$pair@PAVCPortal@@M@std@@@?$vector@U?$pair@PAVCPortal@@M@std@@V?$xalloc@U?$pair@PAVCPortal@@M@std@@@@@std@@QAEPAU?$pair@PAVCPortal@@M@1@QAU21@$$QAU21@@Z$0:

; 785  :         }
; 786  :         _CATCH_ALL
; 787  :         _Destroy(_Constructed_first, _Constructed_last);
; 788  :         _Al.deallocate(_Newvec, _Newcapacity);

	push	ecx
	push	DWORD PTR __Newvec$[ebp]
	call	?deallocate@?$xalloc@U?$pair@PAVCPortal@@M@std@@@@QBEXPAU?$pair@PAVCPortal@@M@std@@I@Z ; xalloc<std::pair<CPortal *,float> >::deallocate

; 789  :         _RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$LN65@Emplace_re:

; 765  :             _Xlength();

	call	?_Xlength@?$vector@U?$pair@PAVCPortal@@M@std@@V?$xalloc@U?$pair@PAVCPortal@@M@std@@@@@std@@CAXXZ ; std::vector<std::pair<CPortal *,float>,xalloc<std::pair<CPortal *,float> > >::_Xlength
$LN62@Emplace_re:
	int	3
	int	3
	int	3
	int	3
	int	3
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Emplace_reallocate@U?$pair@PAVCPortal@@M@std@@@?$vector@U?$pair@PAVCPortal@@M@std@@V?$xalloc@U?$pair@PAVCPortal@@M@std@@@@@std@@QAEPAU?$pair@PAVCPortal@@M@1@QAU21@$$QAU21@@Z:
	npad	1
	npad	1
	mov	eax, OFFSET __ehfuncinfo$??$_Emplace_reallocate@U?$pair@PAVCPortal@@M@std@@@?$vector@U?$pair@PAVCPortal@@M@std@@V?$xalloc@U?$pair@PAVCPortal@@M@std@@@@@std@@QAEPAU?$pair@PAVCPortal@@M@1@QAU21@$$QAU21@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Emplace_reallocate@U?$pair@PAVCPortal@@M@std@@@?$vector@U?$pair@PAVCPortal@@M@std@@V?$xalloc@U?$pair@PAVCPortal@@M@std@@@@@std@@QAEPAU?$pair@PAVCPortal@@M@1@QAU21@$$QAU21@@Z ENDP ; std::vector<std::pair<CPortal *,float>,xalloc<std::pair<CPortal *,float> > >::_Emplace_reallocate<std::pair<CPortal *,float> >
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$?0$$V@?$_Compressed_pair@V?$xalloc@U?$pair@PAVCPortal@@M@std@@@@V?$_Vector_val@U?$_Simple_types@U?$pair@PAVCPortal@@M@std@@@std@@@std@@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$?0$$V@?$_Compressed_pair@V?$xalloc@U?$pair@PAVCPortal@@M@std@@@@V?$_Vector_val@U?$_Simple_types@U?$pair@PAVCPortal@@M@std@@@std@@@std@@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<xalloc<std::pair<CPortal *,float> >,std::_Vector_val<std::_Simple_types<std::pair<CPortal *,float> > >,1>::_Compressed_pair<xalloc<std::pair<CPortal *,float> >,std::_Vector_val<std::_Simple_types<std::pair<CPortal *,float> > >,1><>, COMDAT
; _this$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1331 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	eax, ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1331 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	ret	4
??$?0$$V@?$_Compressed_pair@V?$xalloc@U?$pair@PAVCPortal@@M@std@@@@V?$_Vector_val@U?$_Simple_types@U?$pair@PAVCPortal@@M@std@@@std@@@std@@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<xalloc<std::pair<CPortal *,float> >,std::_Vector_val<std::_Simple_types<std::pair<CPortal *,float> > >,1>::_Compressed_pair<xalloc<std::pair<CPortal *,float> >,std::_Vector_val<std::_Simple_types<std::pair<CPortal *,float> > >,1><>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$?0$$V@?$_Compressed_pair@V?$xalloc@PAVIRender_Sector@@@@V?$_Vector_val@U?$_Simple_types@PAVIRender_Sector@@@std@@@std@@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$?0$$V@?$_Compressed_pair@V?$xalloc@PAVIRender_Sector@@@@V?$_Vector_val@U?$_Simple_types@PAVIRender_Sector@@@std@@@std@@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<xalloc<IRender_Sector *>,std::_Vector_val<std::_Simple_types<IRender_Sector *> >,1>::_Compressed_pair<xalloc<IRender_Sector *>,std::_Vector_val<std::_Simple_types<IRender_Sector *> >,1><>, COMDAT
; _this$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1331 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	eax, ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1331 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	ret	4
??$?0$$V@?$_Compressed_pair@V?$xalloc@PAVIRender_Sector@@@@V?$_Vector_val@U?$_Simple_types@PAVIRender_Sector@@@std@@@std@@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<xalloc<IRender_Sector *>,std::_Vector_val<std::_Simple_types<IRender_Sector *> >,1>::_Compressed_pair<xalloc<IRender_Sector *>,std::_Vector_val<std::_Simple_types<IRender_Sector *> >,1><>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef
;	COMDAT ??$addressof@V?$_Vector_val@U?$_Simple_types@U_scissor@@@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@U_scissor@@@std@@@0@AAV10@@Z
_TEXT	SEGMENT
??$addressof@V?$_Vector_val@U?$_Simple_types@U_scissor@@@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@U_scissor@@@std@@@0@AAV10@@Z PROC ; std::addressof<std::_Vector_val<std::_Simple_types<_scissor> > >, COMDAT
; __Val$ = ecx

; 253  :     return __builtin_addressof(_Val);

	mov	eax, ecx

; 254  : }

	ret	0
??$addressof@V?$_Vector_val@U?$_Simple_types@U_scissor@@@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@U_scissor@@@std@@@0@AAV10@@Z ENDP ; std::addressof<std::_Vector_val<std::_Simple_types<_scissor> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Destroy_range@V?$xalloc@U?$pair@PAVCPortal@@M@std@@@@@std@@YAXPAU?$pair@PAVCPortal@@M@0@QAU10@AAV?$xalloc@U?$pair@PAVCPortal@@M@std@@@@@Z
_TEXT	SEGMENT
__Al$dead$ = 8						; size = 4
??$_Destroy_range@V?$xalloc@U?$pair@PAVCPortal@@M@std@@@@@std@@YAXPAU?$pair@PAVCPortal@@M@0@QAU10@AAV?$xalloc@U?$pair@PAVCPortal@@M@std@@@@@Z PROC ; std::_Destroy_range<xalloc<std::pair<CPortal *,float> > >, COMDAT
; __First$dead$ = ecx
; __Last$dead$ = edx

; 901  :     // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
; 902  :     using _Ty = typename _Alloc::value_type;
; 903  :     if constexpr (!conjunction_v<is_trivially_destructible<_Ty>, _Uses_default_destroy<_Alloc, _Ty*>>) {
; 904  :         for (; _First != _Last; ++_First) {
; 905  :             allocator_traits<_Alloc>::destroy(_Al, _Unfancy(_First));
; 906  :         }
; 907  :     }
; 908  : }

	ret	0
??$_Destroy_range@V?$xalloc@U?$pair@PAVCPortal@@M@std@@@@@std@@YAXPAU?$pair@PAVCPortal@@M@0@QAU10@AAV?$xalloc@U?$pair@PAVCPortal@@M@std@@@@@Z ENDP ; std::_Destroy_range<xalloc<std::pair<CPortal *,float> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
;	COMDAT ??$xr_free@U?$pair@PAVCPortal@@M@std@@@@YAXAAPAU?$pair@PAVCPortal@@M@std@@@Z
_TEXT	SEGMENT
??$xr_free@U?$pair@PAVCPortal@@M@std@@@@YAXAAPAU?$pair@PAVCPortal@@M@std@@@Z PROC ; xr_free<std::pair<CPortal *,float> >, COMDAT
; _P$ = ecx

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	push	esi
	mov	esi, ecx
	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN2@xr_free
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
	mov	DWORD PTR [esi], 0
$LN2@xr_free:
	pop	esi
	ret	0
??$xr_free@U?$pair@PAVCPortal@@M@std@@@@YAXAAPAU?$pair@PAVCPortal@@M@std@@@Z ENDP ; xr_free<std::pair<CPortal *,float> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
;	COMDAT ??$xr_alloc@U?$pair@PAVCPortal@@M@std@@@@YAPAU?$pair@PAVCPortal@@M@std@@I@Z
_TEXT	SEGMENT
??$xr_alloc@U?$pair@PAVCPortal@@M@std@@@@YAPAU?$pair@PAVCPortal@@M@std@@I@Z PROC ; xr_alloc<std::pair<CPortal *,float> >, COMDAT
; _count$ = ecx

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	lea	eax, DWORD PTR [ecx*8]
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
	ret	0
??$xr_alloc@U?$pair@PAVCPortal@@M@std@@@@YAPAU?$pair@PAVCPortal@@M@std@@I@Z ENDP ; xr_alloc<std::pair<CPortal *,float> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Uninitialized_move@PAU?$pair@PAVCPortal@@M@std@@V?$xalloc@U?$pair@PAVCPortal@@M@std@@@@@std@@YAPAU?$pair@PAVCPortal@@M@0@QAU10@0PAU10@AAV?$xalloc@U?$pair@PAVCPortal@@M@std@@@@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Al$dead$ = 12						; size = 4
??$_Uninitialized_move@PAU?$pair@PAVCPortal@@M@std@@V?$xalloc@U?$pair@PAVCPortal@@M@std@@@@@std@@YAPAU?$pair@PAVCPortal@@M@0@QAU10@0PAU10@AAV?$xalloc@U?$pair@PAVCPortal@@M@std@@@@@Z PROC ; std::_Uninitialized_move<std::pair<CPortal *,float> *,xalloc<std::pair<CPortal *,float> > >, COMDAT
; __First$ = ecx
; __Last$ = edx

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	eax, DWORD PTR __Dest$[esp-4]

; 1699 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

	push	edi
	mov	edi, edx

; 1700 :     // move [_First, _Last) to raw _Dest, using _Al
; 1701 :     // note: only called internally from elsewhere in the STL
; 1702 :     using _Ptrval     = typename _Alloc::value_type*;
; 1703 :     auto _UFirst      = _Get_unwrapped(_First);
; 1704 :     const auto _ULast = _Get_unwrapped(_Last);
; 1705 :     if constexpr (conjunction_v<bool_constant<_Ptr_move_cat<decltype(_UFirst), _Ptrval>::_Really_trivial>,
; 1706 :                       _Uses_default_construct<_Alloc, _Ptrval, decltype(_STD move(*_UFirst))>>) {
; 1707 : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 1708 :         if (!_STD is_constant_evaluated())
; 1709 : #endif // __cpp_lib_constexpr_dynamic_alloc
; 1710 :         {
; 1711 :             _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));
; 1712 :             return _Dest + (_ULast - _UFirst);
; 1713 :         }
; 1714 :     }
; 1715 : 
; 1716 :     _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	ecx, edi
	je	SHORT $LN3@Uninitiali
	push	esi
	npad	4
$LL4@Uninitiali:

; 1620 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

	mov	edx, DWORD PTR [ecx]
	mov	esi, DWORD PTR [ecx+4]

; 1621 :         ++_Last;

	add	ecx, 8
	mov	DWORD PTR [eax], edx
	mov	DWORD PTR [eax+4], esi
	add	eax, 8

; 1700 :     // move [_First, _Last) to raw _Dest, using _Al
; 1701 :     // note: only called internally from elsewhere in the STL
; 1702 :     using _Ptrval     = typename _Alloc::value_type*;
; 1703 :     auto _UFirst      = _Get_unwrapped(_First);
; 1704 :     const auto _ULast = _Get_unwrapped(_Last);
; 1705 :     if constexpr (conjunction_v<bool_constant<_Ptr_move_cat<decltype(_UFirst), _Ptrval>::_Really_trivial>,
; 1706 :                       _Uses_default_construct<_Alloc, _Ptrval, decltype(_STD move(*_UFirst))>>) {
; 1707 : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 1708 :         if (!_STD is_constant_evaluated())
; 1709 : #endif // __cpp_lib_constexpr_dynamic_alloc
; 1710 :         {
; 1711 :             _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));
; 1712 :             return _Dest + (_ULast - _UFirst);
; 1713 :         }
; 1714 :     }
; 1715 : 
; 1716 :     _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	ecx, edi
	jne	SHORT $LL4@Uninitiali

; 1718 :         _Backout._Emplace_back(_STD move(*_UFirst));
; 1719 :     }
; 1720 : 
; 1721 :     return _Backout._Release();

	pop	esi
$LN3@Uninitiali:
	pop	edi

; 1722 : }

	ret	0
??$_Uninitialized_move@PAU?$pair@PAVCPortal@@M@std@@V?$xalloc@U?$pair@PAVCPortal@@M@std@@@@@std@@YAPAU?$pair@PAVCPortal@@M@0@QAU10@0PAU10@AAV?$xalloc@U?$pair@PAVCPortal@@M@std@@@@@Z ENDP ; std::_Uninitialized_move<std::pair<CPortal *,float> *,xalloc<std::pair<CPortal *,float> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_Get_unwrapped@ABQAU?$pair@PAVCPortal@@M@std@@@std@@YA?A_TABQAU?$pair@PAVCPortal@@M@0@@Z
_TEXT	SEGMENT
??$_Get_unwrapped@ABQAU?$pair@PAVCPortal@@M@std@@@std@@YA?A_TABQAU?$pair@PAVCPortal@@M@0@@Z PROC ; std::_Get_unwrapped<std::pair<CPortal *,float> * const &>, COMDAT
; __It$ = ecx

; 1275 :     // unwrap an iterator previously subjected to _Adl_verify_range or otherwise validated
; 1276 :     if constexpr (is_pointer_v<decay_t<_Iter>>) { // special-case pointers and arrays
; 1277 :         return _It + 0;

	mov	eax, DWORD PTR [ecx]

; 1278 :     } else if constexpr (_Unwrappable_v<_Iter>) {
; 1279 :         return static_cast<_Iter&&>(_It)._Unwrapped();
; 1280 :     } else {
; 1281 :         return static_cast<_Iter&&>(_It);
; 1282 :     }
; 1283 : }

	ret	0
??$_Get_unwrapped@ABQAU?$pair@PAVCPortal@@M@std@@@std@@YA?A_TABQAU?$pair@PAVCPortal@@M@0@@Z ENDP ; std::_Get_unwrapped<std::pair<CPortal *,float> * const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Release@?$_Uninitialized_backout_al@V?$xalloc@U?$pair@PAVCPortal@@M@std@@@@@std@@QAEPAU?$pair@PAVCPortal@@M@2@XZ
_TEXT	SEGMENT
?_Release@?$_Uninitialized_backout_al@V?$xalloc@U?$pair@PAVCPortal@@M@std@@@@@std@@QAEPAU?$pair@PAVCPortal@@M@2@XZ PROC ; std::_Uninitialized_backout_al<xalloc<std::pair<CPortal *,float> > >::_Release, COMDAT
; _this$ = ecx

; 1625 :         _First = _Last;

	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [ecx], eax

; 1626 :         return _Last;
; 1627 :     }

	ret	0
?_Release@?$_Uninitialized_backout_al@V?$xalloc@U?$pair@PAVCPortal@@M@std@@@@@std@@QAEPAU?$pair@PAVCPortal@@M@2@XZ ENDP ; std::_Uninitialized_backout_al<xalloc<std::pair<CPortal *,float> > >::_Release
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??1?$_Uninitialized_backout_al@V?$xalloc@U?$pair@PAVCPortal@@M@std@@@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Uninitialized_backout_al@V?$xalloc@U?$pair@PAVCPortal@@M@std@@@@@std@@QAE@XZ PROC ; std::_Uninitialized_backout_al<xalloc<std::pair<CPortal *,float> > >::~_Uninitialized_backout_al<xalloc<std::pair<CPortal *,float> > >, COMDAT
; _this$ = ecx

; 1615 :         _Destroy_range(_First, _Last, _Al);
; 1616 :     }

	ret	0
??1?$_Uninitialized_backout_al@V?$xalloc@U?$pair@PAVCPortal@@M@std@@@@@std@@QAE@XZ ENDP ; std::_Uninitialized_backout_al<xalloc<std::pair<CPortal *,float> > >::~_Uninitialized_backout_al<xalloc<std::pair<CPortal *,float> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??0?$_Uninitialized_backout_al@V?$xalloc@U?$pair@PAVCPortal@@M@std@@@@@std@@QAE@PAU?$pair@PAVCPortal@@M@1@AAV?$xalloc@U?$pair@PAVCPortal@@M@std@@@@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Al_$ = 12						; size = 4
??0?$_Uninitialized_backout_al@V?$xalloc@U?$pair@PAVCPortal@@M@std@@@@@std@@QAE@PAU?$pair@PAVCPortal@@M@1@AAV?$xalloc@U?$pair@PAVCPortal@@M@std@@@@@Z PROC ; std::_Uninitialized_backout_al<xalloc<std::pair<CPortal *,float> > >::_Uninitialized_backout_al<xalloc<std::pair<CPortal *,float> > >, COMDAT
; _this$ = ecx

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	eax, DWORD PTR __Dest$[esp-4]
	mov	DWORD PTR [ecx], eax
	mov	DWORD PTR [ecx+4], eax
	mov	eax, DWORD PTR __Al_$[esp-4]
	mov	DWORD PTR [ecx+8], eax
	mov	eax, ecx
	ret	8
??0?$_Uninitialized_backout_al@V?$xalloc@U?$pair@PAVCPortal@@M@std@@@@@std@@QAE@PAU?$pair@PAVCPortal@@M@1@AAV?$xalloc@U?$pair@PAVCPortal@@M@std@@@@@Z ENDP ; std::_Uninitialized_backout_al<xalloc<std::pair<CPortal *,float> > >::_Uninitialized_backout_al<xalloc<std::pair<CPortal *,float> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Unwrapped@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@PAVCPortal@@M@std@@@std@@@std@@@std@@QBEPAU?$pair@PAVCPortal@@M@2@XZ
_TEXT	SEGMENT
?_Unwrapped@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@PAVCPortal@@M@std@@@std@@@std@@@std@@QBEPAU?$pair@PAVCPortal@@M@2@XZ PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::pair<CPortal *,float> > > >::_Unwrapped, COMDAT
; _this$ = ecx

; 328  :         return _Unfancy(this->_Ptr);

	mov	eax, DWORD PTR [ecx]

; 329  :     }

	ret	0
?_Unwrapped@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@PAVCPortal@@M@std@@@std@@@std@@@std@@QBEPAU?$pair@PAVCPortal@@M@2@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::pair<CPortal *,float> > > >::_Unwrapped
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@U?$pair@PAVCPortal@@M@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Vector_val@U?$_Simple_types@U?$pair@PAVCPortal@@M@std@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<std::_Simple_types<std::pair<CPortal *,float> > >::_Vector_val<std::_Simple_types<std::pair<CPortal *,float> > >, COMDAT
; _this$ = ecx

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx], 0
	mov	eax, ecx
	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0
	ret	0
??0?$_Vector_val@U?$_Simple_types@U?$pair@PAVCPortal@@M@std@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<std::_Simple_types<std::pair<CPortal *,float> > >::_Vector_val<std::_Simple_types<std::pair<CPortal *,float> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Calculate_growth@?$vector@U?$pair@PAVCPortal@@M@std@@V?$xalloc@U?$pair@PAVCPortal@@M@std@@@@@std@@ABEII@Z
_TEXT	SEGMENT
__Newsize$ = 8						; size = 4
?_Calculate_growth@?$vector@U?$pair@PAVCPortal@@M@std@@V?$xalloc@U?$pair@PAVCPortal@@M@std@@@@@std@@ABEII@Z PROC ; std::vector<std::pair<CPortal *,float>,xalloc<std::pair<CPortal *,float> > >::_Calculate_growth, COMDAT
; _this$ = ecx

; 1546 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	edx, DWORD PTR [ecx+8]
	sub	edx, DWORD PTR [ecx]

; 1671 :         // given _Oldcapacity and _Newsize, calculate geometric growth
; 1672 :         const size_type _Oldcapacity = capacity();
; 1673 :         const auto _Max              = max_size();
; 1674 : 
; 1675 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	ecx, 536870911				; 1fffffffH

; 1546 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	sar	edx, 3

; 1670 :     _CONSTEXPR20_CONTAINER size_type _Calculate_growth(const size_type _Newsize) const {

	push	esi

; 1671 :         // given _Oldcapacity and _Newsize, calculate geometric growth
; 1672 :         const size_type _Oldcapacity = capacity();
; 1673 :         const auto _Max              = max_size();
; 1674 : 
; 1675 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	esi, edx
	shr	esi, 1
	sub	ecx, esi
	cmp	edx, ecx
	jbe	SHORT $LN2@Calculate_

; 1676 :             return _Max; // geometric growth would overflow

	mov	eax, 536870911				; 1fffffffH
	pop	esi

; 1682 :             return _Newsize; // geometric growth would be insufficient
; 1683 :         }
; 1684 : 
; 1685 :         return _Geometric; // geometric growth is sufficient
; 1686 :     }

	ret	4
$LN2@Calculate_:

; 1677 :         }
; 1678 : 
; 1679 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	lea	eax, DWORD PTR [esi+edx]

; 1680 : 
; 1681 :         if (_Geometric < _Newsize) {

	cmp	eax, DWORD PTR __Newsize$[esp]
	pop	esi
	cmovb	eax, DWORD PTR __Newsize$[esp-4]

; 1682 :             return _Newsize; // geometric growth would be insufficient
; 1683 :         }
; 1684 : 
; 1685 :         return _Geometric; // geometric growth is sufficient
; 1686 :     }

	ret	4
?_Calculate_growth@?$vector@U?$pair@PAVCPortal@@M@std@@V?$xalloc@U?$pair@PAVCPortal@@M@std@@@@@std@@ABEII@Z ENDP ; std::vector<std::pair<CPortal *,float>,xalloc<std::pair<CPortal *,float> > >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Umove@?$vector@U?$pair@PAVCPortal@@M@std@@V?$xalloc@U?$pair@PAVCPortal@@M@std@@@@@std@@AAEPAU?$pair@PAVCPortal@@M@2@PAU32@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
?_Umove@?$vector@U?$pair@PAVCPortal@@M@std@@V?$xalloc@U?$pair@PAVCPortal@@M@std@@@@@std@@AAEPAU?$pair@PAVCPortal@@M@2@PAU32@00@Z PROC ; std::vector<std::pair<CPortal *,float>,xalloc<std::pair<CPortal *,float> > >::_Umove, COMDAT
; _this$dead$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	mov	ecx, DWORD PTR __First$[esp-4]

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	eax, DWORD PTR __Dest$[esp-4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1644 :     _CONSTEXPR20_CONTAINER pointer _Umove(pointer _First, pointer _Last, pointer _Dest) {

	push	edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	mov	edi, DWORD PTR __Last$[esp]
	cmp	ecx, edi
	je	SHORT $LN5@Umove
	push	esi
$LL6@Umove:

; 1620 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

	mov	edx, DWORD PTR [ecx]
	mov	esi, DWORD PTR [ecx+4]

; 1621 :         ++_Last;

	add	ecx, 8
	mov	DWORD PTR [eax], edx
	mov	DWORD PTR [eax+4], esi
	add	eax, 8

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	ecx, edi
	jne	SHORT $LL6@Umove
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1646 :         return _Uninitialized_move(_First, _Last, _Dest, _Getal());

	pop	esi
$LN5@Umove:
	pop	edi

; 1647 :     }

	ret	12					; 0000000cH
?_Umove@?$vector@U?$pair@PAVCPortal@@M@std@@V?$xalloc@U?$pair@PAVCPortal@@M@std@@@@@std@@AAEPAU?$pair@PAVCPortal@@M@2@PAU32@00@Z ENDP ; std::vector<std::pair<CPortal *,float>,xalloc<std::pair<CPortal *,float> > >::_Umove
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?construct@?$xalloc@U?$pair@PAVCPortal@@M@std@@@@QAEXPAU?$pair@PAVCPortal@@M@std@@ABU23@@Z
_TEXT	SEGMENT
_p$ = 8							; size = 4
__Val$ = 12						; size = 4
?construct@?$xalloc@U?$pair@PAVCPortal@@M@std@@@@QAEXPAU?$pair@PAVCPortal@@M@std@@ABU23@@Z PROC ; xalloc<std::pair<CPortal *,float> >::construct, COMDAT
; _this$dead$ = ecx

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	eax, DWORD PTR __Val$[esp-4]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR _p$[esp-4]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	ret	8
?construct@?$xalloc@U?$pair@PAVCPortal@@M@std@@@@QAEXPAU?$pair@PAVCPortal@@M@std@@ABU23@@Z ENDP ; xalloc<std::pair<CPortal *,float> >::construct
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ??0?$xalloc@U?$pair@PAVCPortal@@M@std@@@@QAE@XZ
_TEXT	SEGMENT
??0?$xalloc@U?$pair@PAVCPortal@@M@std@@@@QAE@XZ PROC	; xalloc<std::pair<CPortal *,float> >::xalloc<std::pair<CPortal *,float> >, COMDAT
; _this$ = ecx

; 76   : 													xalloc			()										{	}

	mov	eax, ecx
	ret	0
??0?$xalloc@U?$pair@PAVCPortal@@M@std@@@@QAE@XZ ENDP	; xalloc<std::pair<CPortal *,float> >::xalloc<std::pair<CPortal *,float> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@PAVIRender_Sector@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Vector_val@U?$_Simple_types@PAVIRender_Sector@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<std::_Simple_types<IRender_Sector *> >::_Vector_val<std::_Simple_types<IRender_Sector *> >, COMDAT
; _this$ = ecx

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx], 0
	mov	eax, ecx
	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0
	ret	0
??0?$_Vector_val@U?$_Simple_types@PAVIRender_Sector@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<std::_Simple_types<IRender_Sector *> >::_Vector_val<std::_Simple_types<IRender_Sector *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ??0?$xalloc@PAVIRender_Sector@@@@QAE@XZ
_TEXT	SEGMENT
??0?$xalloc@PAVIRender_Sector@@@@QAE@XZ PROC		; xalloc<IRender_Sector *>::xalloc<IRender_Sector *>, COMDAT
; _this$ = ecx

; 76   : 													xalloc			()										{	}

	mov	eax, ecx
	ret	0
??0?$xalloc@PAVIRender_Sector@@@@QAE@XZ ENDP		; xalloc<IRender_Sector *>::xalloc<IRender_Sector *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
;	COMDAT ??$?0AAPAVCPortal@@AAM$0A@@?$pair@PAVCPortal@@M@std@@QAE@AAPAVCPortal@@AAM@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??$?0AAPAVCPortal@@AAM$0A@@?$pair@PAVCPortal@@M@std@@QAE@AAPAVCPortal@@AAM@Z PROC ; std::pair<CPortal *,float>::pair<CPortal *,float><CPortal * &,float &,0>, COMDAT
; _this$ = ecx

; 186  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

	mov	eax, DWORD PTR __Val1$[esp-4]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR __Val2$[esp-4]
	fld	DWORD PTR [eax]
	mov	eax, ecx
	fstp	DWORD PTR [ecx+4]
	ret	8
??$?0AAPAVCPortal@@AAM$0A@@?$pair@PAVCPortal@@M@std@@QAE@AAPAVCPortal@@AAM@Z ENDP ; std::pair<CPortal *,float>::pair<CPortal *,float><CPortal * &,float &,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_Adl_verify_range@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@PAVCPortal@@M@std@@@std@@@std@@@std@@V12@@std@@YAXABV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@PAVCPortal@@M@std@@@std@@@std@@@0@0@Z
_TEXT	SEGMENT
??$_Adl_verify_range@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@PAVCPortal@@M@std@@@std@@@std@@@std@@V12@@std@@YAXABV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@PAVCPortal@@M@std@@@std@@@std@@@0@0@Z PROC ; std::_Adl_verify_range<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::pair<CPortal *,float> > > >,std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::pair<CPortal *,float> > > > >, COMDAT
; __First$dead$ = ecx
; __Last$dead$ = edx

; 1259 :     // check that [_First, _Last) forms an iterator range
; 1260 :     if constexpr (_Range_verifiable_v<_Iter, _Sentinel>) {
; 1261 :         _Verify_range(_First, _Last);
; 1262 :     }
; 1263 : }

	ret	0
??$_Adl_verify_range@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@PAVCPortal@@M@std@@@std@@@std@@@std@@V12@@std@@YAXABV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@PAVCPortal@@M@std@@@std@@@std@@@0@0@Z ENDP ; std::_Adl_verify_range<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::pair<CPortal *,float> > > >,std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::pair<CPortal *,float> > > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_Pass_fn@P6A_NABU?$pair@PAVCPortal@@M@std@@0@Z$0A@@std@@YAP6A_NABU?$pair@PAVCPortal@@M@0@0@ZP6A_N00@Z@Z
_TEXT	SEGMENT
??$_Pass_fn@P6A_NABU?$pair@PAVCPortal@@M@std@@0@Z$0A@@std@@YAP6A_NABU?$pair@PAVCPortal@@M@0@0@ZP6A_N00@Z@Z PROC ; std::_Pass_fn<bool (__cdecl*)(std::pair<CPortal *,float> const &,std::pair<CPortal *,float> const &),0>, COMDAT
; __Val$dead$ = ecx

; 253  :     return _Val;

	mov	eax, OFFSET ?psort_pred@@YA_NABU?$pair@PAVCPortal@@M@std@@0@Z ; psort_pred

; 254  : }

	ret	0
??$_Pass_fn@P6A_NABU?$pair@PAVCPortal@@M@std@@0@Z$0A@@std@@YAP6A_NABU?$pair@PAVCPortal@@M@0@0@ZP6A_N00@Z@Z ENDP ; std::_Pass_fn<bool (__cdecl*)(std::pair<CPortal *,float> const &,std::pair<CPortal *,float> const &),0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
;	COMDAT ??$_Sort_unchecked@PAU?$pair@PAVCPortal@@M@std@@P6A_NABU12@0@Z@std@@YAXPAU?$pair@PAVCPortal@@M@0@0HP6A_NABU10@1@Z@Z
_TEXT	SEGMENT
__Last$1$ = -36						; size = 4
tv1020 = -32						; size = 4
__Hole$1$ = -32						; size = 4
__Max_sequence_non_leaf$1$ = -28			; size = 4
tv1018 = -24						; size = 4
__Bottom$1$ = -24					; size = 4
__Mid$1$ = -24						; size = 4
tv1026 = -20						; size = 4
__Val$1 = -20						; size = 8
__Val$2 = -12						; size = 8
__Val$3 = -12						; size = 8
__Mid$4 = -12						; size = 8
__Ideal$ = 8						; size = 4
__Pred$ = 12						; size = 4
??$_Sort_unchecked@PAU?$pair@PAVCPortal@@M@std@@P6A_NABU12@0@Z@std@@YAXPAU?$pair@PAVCPortal@@M@0@0HP6A_NABU10@1@Z@Z PROC ; std::_Sort_unchecked<std::pair<CPortal *,float> *,bool (__cdecl*)(std::pair<CPortal *,float> const &,std::pair<CPortal *,float> const &)>, COMDAT
; __First$ = ecx
; __Last$ = edx

; 7046 : _CONSTEXPR20 void _Sort_unchecked(_RanIt _First, _RanIt _Last, _Iter_diff_t<_RanIt> _Ideal, _Pr _Pred) {

	sub	esp, 36					; 00000024H
	push	ebx
	push	ebp

; 7047 :     // order [_First, _Last)
; 7048 :     for (;;) {
; 7049 :         if (_Last - _First <= _ISORT_MAX) { // small

	mov	ebp, DWORD PTR __Pred$[esp+40]
	mov	ebx, edx
	push	esi
	push	edi
	mov	edi, ecx
	mov	DWORD PTR __Last$1$[esp+52], ebx
	mov	eax, ebx
	sub	eax, edi
	and	eax, -8					; fffffff8H
	cmp	eax, 256				; 00000100H
	jle	SHORT $LN214@Sort_unche
	mov	esi, DWORD PTR __Ideal$[esp+48]
$LL2@Sort_unche:

; 7050 :             _Insertion_sort_unchecked(_First, _Last, _Pred);
; 7051 :             return;
; 7052 :         }
; 7053 : 
; 7054 :         if (_Ideal <= 0) { // heap sort if too many divisions

	test	esi, esi
	jle	$LN215@Sort_unche

; 7057 :             return;
; 7058 :         }
; 7059 : 
; 7060 :         // divide and conquer by quicksort
; 7061 :         auto _Mid = _Partition_by_median_guess_unchecked(_First, _Last, _Pred);

	push	ebp
	push	ebx
	mov	edx, edi
	lea	ecx, DWORD PTR __Mid$4[esp+60]
	call	??$_Partition_by_median_guess_unchecked@PAU?$pair@PAVCPortal@@M@std@@P6A_NABU12@0@Z@std@@YA?AU?$pair@PAU?$pair@PAVCPortal@@M@std@@PAU12@@0@PAU?$pair@PAVCPortal@@M@0@0P6A_NABU20@1@Z@Z ; std::_Partition_by_median_guess_unchecked<std::pair<CPortal *,float> *,bool (__cdecl*)(std::pair<CPortal *,float> const &,std::pair<CPortal *,float> const &)>

; 7062 : 
; 7063 :         _Ideal = (_Ideal >> 1) + (_Ideal >> 2); // allow 1.5 log2(N) divisions
; 7064 : 
; 7065 :         if (_Mid.first - _First < _Last - _Mid.second) { // loop on second half

	mov	edx, DWORD PTR __Mid$4[esp+60]
	mov	eax, esi
	sar	eax, 2
	add	esp, 8
	sar	esi, 1
	mov	ecx, ebx
	mov	ebx, DWORD PTR __Mid$4[esp+56]
	add	esi, eax
	mov	eax, edx
	sub	ecx, ebx
	sub	eax, edi
	and	ecx, -8					; fffffff8H
	and	eax, -8					; fffffff8H
	push	ebp
	push	esi
	cmp	eax, ecx
	jge	SHORT $LN7@Sort_unche

; 7066 :             _Sort_unchecked(_First, _Mid.first, _Ideal, _Pred);

	mov	ecx, edi
	call	??$_Sort_unchecked@PAU?$pair@PAVCPortal@@M@std@@P6A_NABU12@0@Z@std@@YAXPAU?$pair@PAVCPortal@@M@0@0HP6A_NABU10@1@Z@Z ; std::_Sort_unchecked<std::pair<CPortal *,float> *,bool (__cdecl*)(std::pair<CPortal *,float> const &,std::pair<CPortal *,float> const &)>

; 7067 :             _First = _Mid.second;

	mov	edi, ebx

; 7068 :         } else { // loop on first half

	mov	ebx, DWORD PTR __Last$1$[esp+60]
	jmp	SHORT $LN244@Sort_unche
$LN7@Sort_unche:

; 7069 :             _Sort_unchecked(_Mid.second, _Last, _Ideal, _Pred);

	mov	edx, DWORD PTR __Last$1$[esp+60]
	mov	ecx, ebx
	call	??$_Sort_unchecked@PAU?$pair@PAVCPortal@@M@std@@P6A_NABU12@0@Z@std@@YAXPAU?$pair@PAVCPortal@@M@0@0HP6A_NABU10@1@Z@Z ; std::_Sort_unchecked<std::pair<CPortal *,float> *,bool (__cdecl*)(std::pair<CPortal *,float> const &,std::pair<CPortal *,float> const &)>

; 7070 :             _Last = _Mid.first;

	mov	ebx, DWORD PTR __Mid$4[esp+60]
	mov	DWORD PTR __Last$1$[esp+60], ebx
$LN244@Sort_unche:

; 7047 :     // order [_First, _Last)
; 7048 :     for (;;) {
; 7049 :         if (_Last - _First <= _ISORT_MAX) { // small

	mov	eax, ebx
	add	esp, 8
	sub	eax, edi
	and	eax, -8					; fffffff8H
	cmp	eax, 256				; 00000100H
	jg	SHORT $LL2@Sort_unche
$LN214@Sort_unche:

; 6921 :     if (_First != _Last) {

	cmp	edi, ebx
	je	$LN59@Sort_unche

; 6922 :         for (_BidIt _Mid = _First; ++_Mid != _Last;) { // order next element

	lea	esi, DWORD PTR [edi+8]
	mov	DWORD PTR __Mid$1$[esp+52], esi
	cmp	esi, ebx
	je	$LN59@Sort_unche
	mov	DWORD PTR tv1020[esp+52], edi
$LL11@Sort_unche:

; 6923 :             _BidIt _Hole               = _Mid;
; 6924 :             _Iter_value_t<_BidIt> _Val = _STD move(*_Mid);

	mov	eax, DWORD PTR [esi]
	mov	ebx, esi
	mov	ecx, DWORD PTR [esi+4]
	mov	DWORD PTR __Val$1[esp+52], eax

; 6925 : 
; 6926 :             if (_DEBUG_LT_PRED(_Pred, _Val, *_First)) { // found new earliest element, move to front

	lea	eax, DWORD PTR __Val$1[esp+52]
	push	edi
	push	eax
	mov	DWORD PTR __Val$1[esp+64], ecx
	call	ebp
	add	esp, 8
	test	al, al
	je	$LN18@Sort_unche
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility

; 4362 :     while (_First != _Last) {

	cmp	esi, edi
	je	SHORT $LN23@Sort_unche
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 6927 :                 _Move_backward_unchecked(_First, _Mid, ++_Hole);

	mov	ecx, DWORD PTR tv1020[esp+52]
	add	ecx, 12					; 0000000cH
	npad	3
$LL222@Sort_unche:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 288  :         first  = _STD forward<_Ty1>(_Right.first);

	mov	eax, DWORD PTR [ecx-12]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility

; 4363 :         *--_Dest = _STD move(*--_Last);

	sub	ecx, 8
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 288  :         first  = _STD forward<_Ty1>(_Right.first);

	mov	DWORD PTR [ecx+4], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility

; 4362 :     while (_First != _Last) {

	lea	eax, DWORD PTR [ecx-4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 289  :         second = _STD forward<_Ty2>(_Right.second);

	fld	DWORD PTR [ecx]
	fstp	DWORD PTR [ecx+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility

; 4362 :     while (_First != _Last) {

	cmp	eax, edi
	jne	SHORT $LL222@Sort_unche
$LN23@Sort_unche:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 289  :         second = _STD forward<_Ty2>(_Right.second);

	movss	xmm0, DWORD PTR __Val$1[esp+56]
	mov	eax, DWORD PTR __Val$1[esp+52]
	mov	DWORD PTR [edi], eax
	movss	DWORD PTR [edi+4], xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 6929 :             } else { // look for insertion point after first

	jmp	$LN19@Sort_unche
$LN215@Sort_unche:

; 5547 :     _Diff _Bottom = _Last - _First;

	mov	ecx, ebx
	sub	ecx, edi
	mov	eax, ecx
	mov	DWORD PTR tv1026[esp+52], ecx
	sar	eax, 3

; 5548 :     for (_Diff _Hole = _Bottom >> 1; _Hole > 0;) { // shift for codegen

	mov	edx, eax
	mov	DWORD PTR __Bottom$1$[esp+52], eax
	sar	edx, 1
	test	edx, edx
	jle	$LN35@Sort_unche
	dec	eax
	sar	eax, 1
	mov	DWORD PTR __Max_sequence_non_leaf$1$[esp+52], eax
	npad	1
$LL34@Sort_unche:

; 5551 :         _Iter_value_t<_RanIt> _Val = _STD move(*(_First + _Hole));

	mov	eax, DWORD PTR [edi+edx*8-8]
	dec	edx
	mov	DWORD PTR __Val$3[esp+52], eax

; 5552 :         _Pop_heap_hole_by_index(_First, _Hole, _Bottom, _STD move(_Val), _Pred);

	mov	ebx, edx

; 5386 :     while (_Idx < _Max_sequence_non_leaf) { // move _Hole down to larger child

	mov	eax, DWORD PTR __Max_sequence_non_leaf$1$[esp+52]
	mov	esi, edx

; 5550 :         --_Hole;

	mov	DWORD PTR __Hole$1$[esp+52], edx

; 5551 :         _Iter_value_t<_RanIt> _Val = _STD move(*(_First + _Hole));

	mov	ecx, DWORD PTR [edi+edx*8+4]
	mov	DWORD PTR __Val$3[esp+56], ecx

; 5386 :     while (_Idx < _Max_sequence_non_leaf) { // move _Hole down to larger child

	cmp	edx, eax
	jge	SHORT $LN40@Sort_unche
$LL39@Sort_unche:

; 5387 :         _Idx = 2 * _Idx + 2;

	lea	esi, DWORD PTR [esi*2+2]

; 5388 :         if (_DEBUG_LT_PRED(_Pred, *(_First + _Idx), *(_First + (_Idx - 1)))) {

	lea	ecx, DWORD PTR [edi+esi*8]
	lea	eax, DWORD PTR [ecx-8]
	push	eax
	push	ecx
	call	ebp
	add	esp, 8
	test	al, al
	je	SHORT $LN41@Sort_unche

; 5389 :             --_Idx;

	dec	esi
$LN41@Sort_unche:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 288  :         first  = _STD forward<_Ty1>(_Right.first);

	mov	eax, DWORD PTR [edi+esi*8]
	mov	DWORD PTR [edi+ebx*8], eax

; 289  :         second = _STD forward<_Ty2>(_Right.second);

	fld	DWORD PTR [edi+esi*8+4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 5386 :     while (_Idx < _Max_sequence_non_leaf) { // move _Hole down to larger child

	mov	eax, DWORD PTR __Max_sequence_non_leaf$1$[esp+52]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 289  :         second = _STD forward<_Ty2>(_Right.second);

	fstp	DWORD PTR [edi+ebx*8+4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 5392 :         _Hole             = _Idx;

	mov	ebx, esi
	cmp	esi, eax
	jl	SHORT $LL39@Sort_unche
	mov	edx, DWORD PTR __Hole$1$[esp+52]
$LN40@Sort_unche:

; 5393 :     }
; 5394 : 
; 5395 :     if (_Idx == _Max_sequence_non_leaf && _Bottom % 2 == 0) { // only child at bottom, move _Hole down to it

	cmp	esi, eax
	jne	SHORT $LN42@Sort_unche
	mov	ecx, DWORD PTR __Bottom$1$[esp+52]
	test	cl, 1
	jne	SHORT $LN42@Sort_unche
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 288  :         first  = _STD forward<_Ty1>(_Right.first);

	mov	eax, DWORD PTR [edi+ecx*8-8]
	mov	DWORD PTR [edi+ebx*8], eax

; 289  :         second = _STD forward<_Ty2>(_Right.second);

	fld	DWORD PTR [edi+ecx*8-4]
	fstp	DWORD PTR [edi+ebx*8+4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 5397 :         _Hole             = _Bottom - 1;

	lea	ebx, DWORD PTR [ecx-1]
$LN42@Sort_unche:

; 5268 :          _Top < _Hole && _DEBUG_LT_PRED(_Pred, *(_First + _Idx), _Val); //

	cmp	edx, ebx
	jge	SHORT $LN242@Sort_unche
	npad	7
$LL51@Sort_unche:

; 5267 :     for (_Diff _Idx = (_Hole - 1) >> 1; // shift for codegen

	lea	esi, DWORD PTR [ebx-1]
	sar	esi, 1

; 5268 :          _Top < _Hole && _DEBUG_LT_PRED(_Pred, *(_First + _Idx), _Val); //

	lea	ecx, DWORD PTR __Val$3[esp+52]
	push	ecx
	lea	eax, DWORD PTR [edi+esi*8]
	push	eax
	call	ebp
	mov	edx, DWORD PTR __Hole$1$[esp+60]
	add	esp, 8
	test	al, al
	je	SHORT $LN242@Sort_unche
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 288  :         first  = _STD forward<_Ty1>(_Right.first);

	mov	eax, DWORD PTR [edi+esi*8]
	mov	DWORD PTR [edi+ebx*8], eax

; 289  :         second = _STD forward<_Ty2>(_Right.second);

	fld	DWORD PTR [edi+esi*8+4]
	fstp	DWORD PTR [edi+ebx*8+4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 5272 :         _Hole             = _Idx;

	mov	ebx, esi
	cmp	edx, esi
	jl	SHORT $LL51@Sort_unche
$LN242@Sort_unche:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 289  :         second = _STD forward<_Ty2>(_Right.second);

	movss	xmm0, DWORD PTR __Val$3[esp+56]
	mov	eax, DWORD PTR __Val$3[esp+52]
	mov	DWORD PTR [edi+ebx*8], eax
	movss	DWORD PTR [edi+ebx*8+4], xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 5548 :     for (_Diff _Hole = _Bottom >> 1; _Hole > 0;) { // shift for codegen

	test	edx, edx
	jg	$LL34@Sort_unche
	mov	ebx, DWORD PTR __Last$1$[esp+52]
	mov	eax, DWORD PTR __Bottom$1$[esp+52]
	mov	ecx, DWORD PTR tv1026[esp+52]
$LN35@Sort_unche:

; 5774 :     for (; _Last - _First >= 2; --_Last) {

	cmp	eax, 2
	jl	$LN59@Sort_unche

; 7055 :             _Make_heap_unchecked(_First, _Last, _Pred);
; 7056 :             _Sort_heap_unchecked(_First, _Last, _Pred);

	lea	edx, DWORD PTR [ecx-8]
	add	ebx, -8					; fffffff8H
	mov	DWORD PTR tv1018[esp+52], edx
	npad	7
$LL60@Sort_unche:

; 5419 :         _Iter_value_t<_RanIt> _Val = _STD move(*_Last);

	mov	eax, DWORD PTR [ebx]

; 5410 :     _Pop_heap_hole_by_index(

	mov	esi, edx

; 5419 :         _Iter_value_t<_RanIt> _Val = _STD move(*_Last);

	mov	ecx, DWORD PTR [ebx+4]
	mov	DWORD PTR __Val$2[esp+52], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 288  :         first  = _STD forward<_Ty1>(_Right.first);

	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR [ebx], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 5410 :     _Pop_heap_hole_by_index(

	lea	eax, DWORD PTR __Val$2[esp+52]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 289  :         second = _STD forward<_Ty2>(_Right.second);

	fld	DWORD PTR [edi+4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 5410 :     _Pop_heap_hole_by_index(

	push	ebp
	push	eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 289  :         second = _STD forward<_Ty2>(_Right.second);

	fstp	DWORD PTR [edi+edx+4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 5419 :         _Iter_value_t<_RanIt> _Val = _STD move(*_Last);

	mov	DWORD PTR __Val$2[esp+64], ecx

; 5410 :     _Pop_heap_hole_by_index(

	xor	edx, edx
	sar	esi, 3
	mov	ecx, edi
	push	esi
	call	??$_Pop_heap_hole_by_index@PAU?$pair@PAVCPortal@@M@std@@U12@P6A_NABU12@0@Z@std@@YAXPAU?$pair@PAVCPortal@@M@0@HH$$QAU10@P6A_NABU10@2@Z@Z ; std::_Pop_heap_hole_by_index<std::pair<CPortal *,float> *,std::pair<CPortal *,float>,bool (__cdecl*)(std::pair<CPortal *,float> const &,std::pair<CPortal *,float> const &)>

; 5774 :     for (; _Last - _First >= 2; --_Last) {

	mov	edx, DWORD PTR tv1018[esp+64]
	lea	ebx, DWORD PTR [ebx-8]
	sub	edx, 8

; 5410 :     _Pop_heap_hole_by_index(

	add	esp, 12					; 0000000cH

; 5774 :     for (; _Last - _First >= 2; --_Last) {

	mov	DWORD PTR tv1018[esp+52], edx
	cmp	esi, 2
	jge	SHORT $LL60@Sort_unche

; 7071 :         }
; 7072 :     }
; 7073 : }

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 36					; 00000024H
	ret	0
$LN18@Sort_unche:

; 6930 :                 for (_BidIt _Prev = _Hole; _DEBUG_LT_PRED(_Pred, _Val, *--_Prev); _Hole = _Prev) {

	mov	eax, DWORD PTR tv1020[esp+52]
	mov	esi, eax
	push	eax
	lea	eax, DWORD PTR __Val$1[esp+56]
	push	eax
	call	ebp
	add	esp, 8
	test	al, al
	je	SHORT $LN15@Sort_unche
$LL16@Sort_unche:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 288  :         first  = _STD forward<_Ty1>(_Right.first);

	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [ebx], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 6930 :                 for (_BidIt _Prev = _Hole; _DEBUG_LT_PRED(_Pred, _Val, *--_Prev); _Hole = _Prev) {

	lea	eax, DWORD PTR __Val$1[esp+52]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 289  :         second = _STD forward<_Ty2>(_Right.second);

	fld	DWORD PTR [esi+4]
	fstp	DWORD PTR [ebx+4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 6930 :                 for (_BidIt _Prev = _Hole; _DEBUG_LT_PRED(_Pred, _Val, *--_Prev); _Hole = _Prev) {

	mov	ebx, esi
	sub	esi, 8
	push	esi
	push	eax
	call	ebp
	add	esp, 8
	test	al, al
	jne	SHORT $LL16@Sort_unche
$LN15@Sort_unche:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 289  :         second = _STD forward<_Ty2>(_Right.second);

	movss	xmm0, DWORD PTR __Val$1[esp+56]
	mov	eax, DWORD PTR __Val$1[esp+52]
	mov	esi, DWORD PTR __Mid$1$[esp+52]

; 288  :         first  = _STD forward<_Ty1>(_Right.first);

	mov	DWORD PTR [ebx], eax

; 289  :         second = _STD forward<_Ty2>(_Right.second);

	movss	DWORD PTR [ebx+4], xmm0
$LN19@Sort_unche:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 6922 :         for (_BidIt _Mid = _First; ++_Mid != _Last;) { // order next element

	add	DWORD PTR tv1020[esp+52], 8
	add	esi, 8
	mov	DWORD PTR __Mid$1$[esp+52], esi
	cmp	esi, DWORD PTR __Last$1$[esp+52]
	jne	$LL11@Sort_unche
$LN59@Sort_unche:

; 7071 :         }
; 7072 :     }
; 7073 : }

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 36					; 00000024H
	ret	0
??$_Sort_unchecked@PAU?$pair@PAVCPortal@@M@std@@P6A_NABU12@0@Z@std@@YAXPAU?$pair@PAVCPortal@@M@0@0HP6A_NABU10@1@Z@Z ENDP ; std::_Sort_unchecked<std::pair<CPortal *,float> *,bool (__cdecl*)(std::pair<CPortal *,float> const &,std::pair<CPortal *,float> const &)>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$destroy@U?$pair@PAVCPortal@@M@std@@@?$_Normal_allocator_traits@V?$xalloc@U?$pair@PAVCPortal@@M@std@@@@@std@@SAXAAV?$xalloc@U?$pair@PAVCPortal@@M@std@@@@PAU?$pair@PAVCPortal@@M@1@@Z
_TEXT	SEGMENT
??$destroy@U?$pair@PAVCPortal@@M@std@@@?$_Normal_allocator_traits@V?$xalloc@U?$pair@PAVCPortal@@M@std@@@@@std@@SAXAAV?$xalloc@U?$pair@PAVCPortal@@M@std@@@@PAU?$pair@PAVCPortal@@M@1@@Z PROC ; std::_Normal_allocator_traits<xalloc<std::pair<CPortal *,float> > >::destroy<std::pair<CPortal *,float> >, COMDAT
; __Al$dead$ = ecx
; __Ptr$dead$ = edx

; 579  :         if constexpr (_Uses_default_destroy<_Alloc, _Ty*>::value) {
; 580  : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 581  :             _STD destroy_at(_Ptr);
; 582  : #else // __cpp_lib_constexpr_dynamic_alloc
; 583  :             _Ptr->~_Ty();
; 584  : #endif // __cpp_lib_constexpr_dynamic_alloc
; 585  :         } else {
; 586  :             _Al.destroy(_Ptr);
; 587  :         }
; 588  :     }

	ret	0
??$destroy@U?$pair@PAVCPortal@@M@std@@@?$_Normal_allocator_traits@V?$xalloc@U?$pair@PAVCPortal@@M@std@@@@@std@@SAXAAV?$xalloc@U?$pair@PAVCPortal@@M@std@@@@PAU?$pair@PAVCPortal@@M@1@@Z ENDP ; std::_Normal_allocator_traits<xalloc<std::pair<CPortal *,float> > >::destroy<std::pair<CPortal *,float> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Emplace_back@U?$pair@PAVCPortal@@M@std@@@?$_Uninitialized_backout_al@V?$xalloc@U?$pair@PAVCPortal@@M@std@@@@@std@@QAEX$$QAU?$pair@PAVCPortal@@M@1@@Z
_TEXT	SEGMENT
_<_Vals_0>$ = 8						; size = 4
??$_Emplace_back@U?$pair@PAVCPortal@@M@std@@@?$_Uninitialized_backout_al@V?$xalloc@U?$pair@PAVCPortal@@M@std@@@@@std@@QAEX$$QAU?$pair@PAVCPortal@@M@1@@Z PROC ; std::_Uninitialized_backout_al<xalloc<std::pair<CPortal *,float> > >::_Emplace_back<std::pair<CPortal *,float> >, COMDAT
; _this$ = ecx

; 1620 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

	mov	eax, DWORD PTR _<_Vals_0>$[esp-4]
	push	esi
	mov	esi, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax], edx
	mov	DWORD PTR [eax+4], esi

; 1621 :         ++_Last;

	add	DWORD PTR [ecx+4], 8
	pop	esi

; 1622 :     }

	ret	4
??$_Emplace_back@U?$pair@PAVCPortal@@M@std@@@?$_Uninitialized_backout_al@V?$xalloc@U?$pair@PAVCPortal@@M@std@@@@@std@@QAEX$$QAU?$pair@PAVCPortal@@M@1@@Z ENDP ; std::_Uninitialized_backout_al<xalloc<std::pair<CPortal *,float> > >::_Emplace_back<std::pair<CPortal *,float> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?destroy@?$xalloc@U?$pair@PAVCPortal@@M@std@@@@QAEXPAU?$pair@PAVCPortal@@M@std@@@Z
_TEXT	SEGMENT
_p$dead$ = 8						; size = 4
?destroy@?$xalloc@U?$pair@PAVCPortal@@M@std@@@@QAEXPAU?$pair@PAVCPortal@@M@std@@@Z PROC ; xalloc<std::pair<CPortal *,float> >::destroy, COMDAT
; _this$dead$ = ecx

; 85   : 							void					destroy			(pointer p)								{	std::_Destroy_in_place(p);			}

	ret	4
?destroy@?$xalloc@U?$pair@PAVCPortal@@M@std@@@@QAEXPAU?$pair@PAVCPortal@@M@std@@@Z ENDP ; xalloc<std::pair<CPortal *,float> >::destroy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\type_traits
;	COMDAT ??$forward@AAPAVCPortal@@@std@@YAAAPAVCPortal@@AAPAV1@@Z
_TEXT	SEGMENT
??$forward@AAPAVCPortal@@@std@@YAAAPAVCPortal@@AAPAV1@@Z PROC ; std::forward<CPortal * &>, COMDAT
; __Arg$ = ecx

; 1386 :     return static_cast<_Ty&&>(_Arg);

	mov	eax, ecx

; 1387 : }

	ret	0
??$forward@AAPAVCPortal@@@std@@YAAAPAVCPortal@@AAPAV1@@Z ENDP ; std::forward<CPortal * &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
;	COMDAT ??$_Insertion_sort_unchecked@PAU?$pair@PAVCPortal@@M@std@@P6A_NABU12@0@Z@std@@YAPAU?$pair@PAVCPortal@@M@0@QAU10@0P6A_NABU10@1@Z@Z
_TEXT	SEGMENT
tv398 = -16						; size = 4
__Last$1$ = -12						; size = 4
__Val$1 = -8						; size = 8
__Pred$ = 8						; size = 4
??$_Insertion_sort_unchecked@PAU?$pair@PAVCPortal@@M@std@@P6A_NABU12@0@Z@std@@YAPAU?$pair@PAVCPortal@@M@0@QAU10@0P6A_NABU10@1@Z@Z PROC ; std::_Insertion_sort_unchecked<std::pair<CPortal *,float> *,bool (__cdecl*)(std::pair<CPortal *,float> const &,std::pair<CPortal *,float> const &)>, COMDAT
; __First$ = ecx
; __Last$ = edx

; 6919 : _CONSTEXPR20 _BidIt _Insertion_sort_unchecked(const _BidIt _First, const _BidIt _Last, _Pr _Pred) {

	sub	esp, 16					; 00000010H
	push	ebx
	push	ebp
	mov	eax, edx
	mov	ebx, ecx
	mov	DWORD PTR __Last$1$[esp+24], eax
	push	esi
	push	edi

; 6920 :     // insertion sort [_First, _Last)
; 6921 :     if (_First != _Last) {

	cmp	ebx, eax
	je	$LN3@Insertion_

; 6922 :         for (_BidIt _Mid = _First; ++_Mid != _Last;) { // order next element

	lea	ebp, DWORD PTR [ebx+8]
	cmp	ebp, eax
	je	$LN3@Insertion_
	mov	esi, ebx
	mov	DWORD PTR tv398[esp+32], ebx
$LL2@Insertion_:

; 6923 :             _BidIt _Hole               = _Mid;
; 6924 :             _Iter_value_t<_BidIt> _Val = _STD move(*_Mid);

	mov	eax, DWORD PTR [ebp]
	mov	edi, ebp
	mov	ecx, DWORD PTR [ebp+4]
	mov	DWORD PTR __Val$1[esp+32], eax

; 6925 : 
; 6926 :             if (_DEBUG_LT_PRED(_Pred, _Val, *_First)) { // found new earliest element, move to front

	lea	eax, DWORD PTR __Val$1[esp+32]
	push	ebx
	push	eax
	mov	DWORD PTR __Val$1[esp+44], ecx
	call	DWORD PTR __Pred$[esp+36]
	add	esp, 8
	test	al, al
	je	SHORT $LN9@Insertion_
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility

; 4362 :     while (_First != _Last) {

	cmp	ebp, ebx
	je	SHORT $LN14@Insertion_
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 6927 :                 _Move_backward_unchecked(_First, _Mid, ++_Hole);

	lea	ecx, DWORD PTR [esi+12]
$LL29@Insertion_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 288  :         first  = _STD forward<_Ty1>(_Right.first);

	mov	eax, DWORD PTR [ecx-12]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility

; 4363 :         *--_Dest = _STD move(*--_Last);

	sub	ecx, 8
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 288  :         first  = _STD forward<_Ty1>(_Right.first);

	mov	DWORD PTR [ecx+4], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility

; 4362 :     while (_First != _Last) {

	lea	eax, DWORD PTR [ecx-4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 289  :         second = _STD forward<_Ty2>(_Right.second);

	fld	DWORD PTR [ecx]
	fstp	DWORD PTR [ecx+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility

; 4362 :     while (_First != _Last) {

	cmp	eax, ebx
	jne	SHORT $LL29@Insertion_
$LN14@Insertion_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 289  :         second = _STD forward<_Ty2>(_Right.second);

	movss	xmm0, DWORD PTR __Val$1[esp+36]
	mov	eax, DWORD PTR __Val$1[esp+32]
	mov	DWORD PTR [ebx], eax
	movss	DWORD PTR [ebx+4], xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 6929 :             } else { // look for insertion point after first

	jmp	SHORT $LN10@Insertion_
$LN9@Insertion_:

; 6930 :                 for (_BidIt _Prev = _Hole; _DEBUG_LT_PRED(_Pred, _Val, *--_Prev); _Hole = _Prev) {

	push	DWORD PTR tv398[esp+32]
	lea	eax, DWORD PTR __Val$1[esp+36]
	push	eax
	call	DWORD PTR __Pred$[esp+36]
	add	esp, 8
	test	al, al
	je	SHORT $LN6@Insertion_
	npad	4
$LL7@Insertion_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 288  :         first  = _STD forward<_Ty1>(_Right.first);

	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [edi], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 6930 :                 for (_BidIt _Prev = _Hole; _DEBUG_LT_PRED(_Pred, _Val, *--_Prev); _Hole = _Prev) {

	lea	eax, DWORD PTR __Val$1[esp+32]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 289  :         second = _STD forward<_Ty2>(_Right.second);

	fld	DWORD PTR [esi+4]
	fstp	DWORD PTR [edi+4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 6930 :                 for (_BidIt _Prev = _Hole; _DEBUG_LT_PRED(_Pred, _Val, *--_Prev); _Hole = _Prev) {

	mov	edi, esi
	sub	esi, 8
	push	esi
	push	eax
	call	DWORD PTR __Pred$[esp+36]
	add	esp, 8
	test	al, al
	jne	SHORT $LL7@Insertion_
$LN6@Insertion_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 289  :         second = _STD forward<_Ty2>(_Right.second);

	movss	xmm0, DWORD PTR __Val$1[esp+36]
	mov	eax, DWORD PTR __Val$1[esp+32]
	mov	esi, DWORD PTR tv398[esp+32]

; 288  :         first  = _STD forward<_Ty1>(_Right.first);

	mov	DWORD PTR [edi], eax

; 289  :         second = _STD forward<_Ty2>(_Right.second);

	movss	DWORD PTR [edi+4], xmm0
$LN10@Insertion_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 6922 :         for (_BidIt _Mid = _First; ++_Mid != _Last;) { // order next element

	mov	eax, DWORD PTR __Last$1$[esp+32]
	add	ebp, 8
	add	esi, 8
	mov	DWORD PTR tv398[esp+32], esi
	cmp	ebp, eax
	jne	$LL2@Insertion_
$LN3@Insertion_:

; 6931 :                     *_Hole = _STD move(*_Prev); // move hole down
; 6932 :                 }
; 6933 : 
; 6934 :                 *_Hole = _STD move(_Val); // insert element in hole
; 6935 :             }
; 6936 :         }
; 6937 :     }
; 6938 : 
; 6939 :     return _Last;
; 6940 : }

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 16					; 00000010H
	ret	0
??$_Insertion_sort_unchecked@PAU?$pair@PAVCPortal@@M@std@@P6A_NABU12@0@Z@std@@YAPAU?$pair@PAVCPortal@@M@0@QAU10@0P6A_NABU10@1@Z@Z ENDP ; std::_Insertion_sort_unchecked<std::pair<CPortal *,float> *,bool (__cdecl*)(std::pair<CPortal *,float> const &,std::pair<CPortal *,float> const &)>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
;	COMDAT ??$_Make_heap_unchecked@PAU?$pair@PAVCPortal@@M@std@@P6A_NABU12@0@Z@std@@YAXPAU?$pair@PAVCPortal@@M@0@0P6A_NABU10@1@Z@Z
_TEXT	SEGMENT
__Hole$1$ = -20						; size = 4
__Max_sequence_non_leaf$1$ = -16			; size = 4
__Bottom$1$ = -12					; size = 4
__Val$1 = -8						; size = 8
__Pred$ = 8						; size = 4
??$_Make_heap_unchecked@PAU?$pair@PAVCPortal@@M@std@@P6A_NABU12@0@Z@std@@YAXPAU?$pair@PAVCPortal@@M@0@0P6A_NABU10@1@Z@Z PROC ; std::_Make_heap_unchecked<std::pair<CPortal *,float> *,bool (__cdecl*)(std::pair<CPortal *,float> const &,std::pair<CPortal *,float> const &)>, COMDAT
; __First$ = ecx
; __Last$ = edx

; 5544 : _CONSTEXPR20 void _Make_heap_unchecked(_RanIt _First, _RanIt _Last, _Pr _Pred) {

	sub	esp, 24					; 00000018H
	push	ebx
	push	ebp
	push	esi
	mov	eax, edx
	push	edi
	mov	edi, ecx

; 5545 :     // make [_First, _Last) into a heap
; 5546 :     using _Diff   = _Iter_diff_t<_RanIt>;
; 5547 :     _Diff _Bottom = _Last - _First;

	sub	eax, edi
	sar	eax, 3

; 5548 :     for (_Diff _Hole = _Bottom >> 1; _Hole > 0;) { // shift for codegen

	mov	edx, eax
	mov	DWORD PTR __Bottom$1$[esp+40], eax
	sar	edx, 1
	test	edx, edx
	jle	$LN3@Make_heap_

; 5385 :     const _Diff _Max_sequence_non_leaf = (_Bottom - 1) >> 1; // shift for codegen

	mov	ebp, DWORD PTR __Pred$[esp+36]
	dec	eax
	sar	eax, 1
	mov	DWORD PTR __Max_sequence_non_leaf$1$[esp+40], eax
	npad	5
$LL2@Make_heap_:

; 5551 :         _Iter_value_t<_RanIt> _Val = _STD move(*(_First + _Hole));

	mov	eax, DWORD PTR [edi+edx*8-8]
	dec	edx
	mov	DWORD PTR __Val$1[esp+40], eax

; 5552 :         _Pop_heap_hole_by_index(_First, _Hole, _Bottom, _STD move(_Val), _Pred);

	mov	ebx, edx

; 5386 :     while (_Idx < _Max_sequence_non_leaf) { // move _Hole down to larger child

	mov	eax, DWORD PTR __Max_sequence_non_leaf$1$[esp+40]
	mov	esi, edx

; 5549 :         // reheap top half, bottom to top
; 5550 :         --_Hole;

	mov	DWORD PTR __Hole$1$[esp+40], edx

; 5551 :         _Iter_value_t<_RanIt> _Val = _STD move(*(_First + _Hole));

	mov	ecx, DWORD PTR [edi+edx*8+4]
	mov	DWORD PTR __Val$1[esp+44], ecx

; 5386 :     while (_Idx < _Max_sequence_non_leaf) { // move _Hole down to larger child

	cmp	edx, eax
	jge	SHORT $LN8@Make_heap_
$LL7@Make_heap_:

; 5387 :         _Idx = 2 * _Idx + 2;

	lea	esi, DWORD PTR [esi*2+2]

; 5388 :         if (_DEBUG_LT_PRED(_Pred, *(_First + _Idx), *(_First + (_Idx - 1)))) {

	lea	ecx, DWORD PTR [edi+esi*8]
	lea	eax, DWORD PTR [ecx-8]
	push	eax
	push	ecx
	call	ebp
	add	esp, 8
	test	al, al
	je	SHORT $LN9@Make_heap_

; 5389 :             --_Idx;

	dec	esi
$LN9@Make_heap_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 288  :         first  = _STD forward<_Ty1>(_Right.first);

	mov	eax, DWORD PTR [edi+esi*8]
	mov	DWORD PTR [edi+ebx*8], eax

; 289  :         second = _STD forward<_Ty2>(_Right.second);

	fld	DWORD PTR [edi+esi*8+4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 5386 :     while (_Idx < _Max_sequence_non_leaf) { // move _Hole down to larger child

	mov	eax, DWORD PTR __Max_sequence_non_leaf$1$[esp+40]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 289  :         second = _STD forward<_Ty2>(_Right.second);

	fstp	DWORD PTR [edi+ebx*8+4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 5392 :         _Hole             = _Idx;

	mov	ebx, esi
	cmp	esi, eax
	jl	SHORT $LL7@Make_heap_
	mov	edx, DWORD PTR __Hole$1$[esp+40]
$LN8@Make_heap_:

; 5393 :     }
; 5394 : 
; 5395 :     if (_Idx == _Max_sequence_non_leaf && _Bottom % 2 == 0) { // only child at bottom, move _Hole down to it

	cmp	esi, eax
	jne	SHORT $LN10@Make_heap_
	mov	ecx, DWORD PTR __Bottom$1$[esp+40]
	test	cl, 1
	jne	SHORT $LN10@Make_heap_
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 288  :         first  = _STD forward<_Ty1>(_Right.first);

	mov	eax, DWORD PTR [edi+ecx*8-8]
	mov	DWORD PTR [edi+ebx*8], eax

; 289  :         second = _STD forward<_Ty2>(_Right.second);

	fld	DWORD PTR [edi+ecx*8-4]
	fstp	DWORD PTR [edi+ebx*8+4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 5397 :         _Hole             = _Bottom - 1;

	lea	ebx, DWORD PTR [ecx-1]
$LN10@Make_heap_:

; 5268 :          _Top < _Hole && _DEBUG_LT_PRED(_Pred, *(_First + _Idx), _Val); //

	cmp	edx, ebx
	jge	SHORT $LN37@Make_heap_
	npad	7
$LL19@Make_heap_:

; 5267 :     for (_Diff _Idx = (_Hole - 1) >> 1; // shift for codegen

	lea	esi, DWORD PTR [ebx-1]
	sar	esi, 1

; 5268 :          _Top < _Hole && _DEBUG_LT_PRED(_Pred, *(_First + _Idx), _Val); //

	lea	eax, DWORD PTR __Val$1[esp+40]
	push	eax
	lea	ebp, DWORD PTR [edi+esi*8]
	push	ebp
	call	DWORD PTR __Pred$[esp+44]
	mov	edx, DWORD PTR __Hole$1$[esp+48]
	add	esp, 8
	test	al, al
	je	SHORT $LN38@Make_heap_
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 288  :         first  = _STD forward<_Ty1>(_Right.first);

	mov	eax, DWORD PTR [ebp]
	mov	DWORD PTR [edi+ebx*8], eax

; 289  :         second = _STD forward<_Ty2>(_Right.second);

	fld	DWORD PTR [ebp+4]
	fstp	DWORD PTR [edi+ebx*8+4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 5272 :         _Hole             = _Idx;

	mov	ebx, esi
	cmp	edx, esi
	jl	SHORT $LL19@Make_heap_
$LN38@Make_heap_:
	mov	ebp, DWORD PTR __Pred$[esp+36]
$LN37@Make_heap_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 289  :         second = _STD forward<_Ty2>(_Right.second);

	movss	xmm0, DWORD PTR __Val$1[esp+44]
	mov	eax, DWORD PTR __Val$1[esp+40]
	mov	DWORD PTR [edi+ebx*8], eax
	movss	DWORD PTR [edi+ebx*8+4], xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 5548 :     for (_Diff _Hole = _Bottom >> 1; _Hole > 0;) { // shift for codegen

	test	edx, edx
	jg	$LL2@Make_heap_
$LN3@Make_heap_:

; 5553 :     }
; 5554 : }

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 24					; 00000018H
	ret	0
??$_Make_heap_unchecked@PAU?$pair@PAVCPortal@@M@std@@P6A_NABU12@0@Z@std@@YAXPAU?$pair@PAVCPortal@@M@0@0P6A_NABU10@1@Z@Z ENDP ; std::_Make_heap_unchecked<std::pair<CPortal *,float> *,bool (__cdecl*)(std::pair<CPortal *,float> const &,std::pair<CPortal *,float> const &)>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
;	COMDAT ??$_Sort_heap_unchecked@PAU?$pair@PAVCPortal@@M@std@@P6A_NABU12@0@Z@std@@YAXPAU?$pair@PAVCPortal@@M@0@0P6A_NABU10@1@Z@Z
_TEXT	SEGMENT
__Val$1 = -8						; size = 8
__Pred$ = 8						; size = 4
??$_Sort_heap_unchecked@PAU?$pair@PAVCPortal@@M@std@@P6A_NABU12@0@Z@std@@YAXPAU?$pair@PAVCPortal@@M@0@0P6A_NABU10@1@Z@Z PROC ; std::_Sort_heap_unchecked<std::pair<CPortal *,float> *,bool (__cdecl*)(std::pair<CPortal *,float> const &,std::pair<CPortal *,float> const &)>, COMDAT
; __First$ = ecx
; __Last$ = edx

; 5772 : _CONSTEXPR20 void _Sort_heap_unchecked(_RanIt _First, _RanIt _Last, _Pr _Pred) {

	sub	esp, 8
	push	ebx
	push	ebp
	mov	ebx, ecx

; 5773 :     // order heap by repeatedly popping
; 5774 :     for (; _Last - _First >= 2; --_Last) {

	mov	ebp, edx
	sub	ebp, ebx
	mov	eax, ebp
	and	eax, -8					; fffffff8H
	push	esi
	push	edi
	cmp	eax, 16					; 00000010H
	jl	SHORT $LN3@Sort_heap_
	lea	edi, DWORD PTR [edx-8]
	add	ebp, -8					; fffffff8H
	npad	3
$LL4@Sort_heap_:

; 5419 :         _Iter_value_t<_RanIt> _Val = _STD move(*_Last);

	mov	eax, DWORD PTR [edi]

; 5410 :     _Pop_heap_hole_by_index(

	mov	esi, ebp
	push	DWORD PTR __Pred$[esp+20]

; 5419 :         _Iter_value_t<_RanIt> _Val = _STD move(*_Last);

	mov	ecx, DWORD PTR [edi+4]

; 5410 :     _Pop_heap_hole_by_index(

	xor	edx, edx

; 5419 :         _Iter_value_t<_RanIt> _Val = _STD move(*_Last);

	mov	DWORD PTR __Val$1[esp+28], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 288  :         first  = _STD forward<_Ty1>(_Right.first);

	mov	eax, DWORD PTR [ebx]
	mov	DWORD PTR [edi], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 5410 :     _Pop_heap_hole_by_index(

	lea	eax, DWORD PTR __Val$1[esp+28]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 289  :         second = _STD forward<_Ty2>(_Right.second);

	fld	DWORD PTR [ebx+4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 5410 :     _Pop_heap_hole_by_index(

	push	eax

; 5419 :         _Iter_value_t<_RanIt> _Val = _STD move(*_Last);

	mov	DWORD PTR __Val$1[esp+36], ecx

; 5410 :     _Pop_heap_hole_by_index(

	mov	ecx, ebx
	sar	esi, 3
	push	esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 289  :         second = _STD forward<_Ty2>(_Right.second);

	fstp	DWORD PTR [ebx+ebp+4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 5410 :     _Pop_heap_hole_by_index(

	call	??$_Pop_heap_hole_by_index@PAU?$pair@PAVCPortal@@M@std@@U12@P6A_NABU12@0@Z@std@@YAXPAU?$pair@PAVCPortal@@M@0@HH$$QAU10@P6A_NABU10@2@Z@Z ; std::_Pop_heap_hole_by_index<std::pair<CPortal *,float> *,std::pair<CPortal *,float>,bool (__cdecl*)(std::pair<CPortal *,float> const &,std::pair<CPortal *,float> const &)>
	add	esp, 12					; 0000000cH

; 5773 :     // order heap by repeatedly popping
; 5774 :     for (; _Last - _First >= 2; --_Last) {

	lea	edi, DWORD PTR [edi-8]
	sub	ebp, 8
	cmp	esi, 2
	jge	SHORT $LL4@Sort_heap_
$LN3@Sort_heap_:

; 5775 :         _Pop_heap_unchecked(_First, _Last, _Pred);
; 5776 :     }
; 5777 : }

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 8
	ret	0
??$_Sort_heap_unchecked@PAU?$pair@PAVCPortal@@M@std@@P6A_NABU12@0@Z@std@@YAXPAU?$pair@PAVCPortal@@M@0@0P6A_NABU10@1@Z@Z ENDP ; std::_Sort_heap_unchecked<std::pair<CPortal *,float> *,bool (__cdecl*)(std::pair<CPortal *,float> const &,std::pair<CPortal *,float> const &)>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
;	COMDAT ??$_Partition_by_median_guess_unchecked@PAU?$pair@PAVCPortal@@M@std@@P6A_NABU12@0@Z@std@@YA?AU?$pair@PAU?$pair@PAVCPortal@@M@std@@PAU12@@0@PAU?$pair@PAVCPortal@@M@0@0P6A_NABU20@1@Z@Z
_TEXT	SEGMENT
__First$1$ = -20					; size = 4
__Plast$1$ = -16					; size = 4
$T1 = -12						; size = 4
__Glast$1$ = -12					; size = 4
$T2 = -8						; size = 4
tv887 = -8						; size = 4
__Last$1$ = -8						; size = 4
__Gfirst$1$ = -8					; size = 4
___$ReturnUdt$1$ = -4					; size = 4
__Last$ = 8						; size = 4
__Pred$ = 12						; size = 4
??$_Partition_by_median_guess_unchecked@PAU?$pair@PAVCPortal@@M@std@@P6A_NABU12@0@Z@std@@YA?AU?$pair@PAU?$pair@PAVCPortal@@M@std@@PAU12@@0@PAU?$pair@PAVCPortal@@M@0@0P6A_NABU20@1@Z@Z PROC ; std::_Partition_by_median_guess_unchecked<std::pair<CPortal *,float> *,bool (__cdecl*)(std::pair<CPortal *,float> const &,std::pair<CPortal *,float> const &)>, COMDAT
; ___$ReturnUdt$ = ecx
; __First$ = edx

; 6976 : _CONSTEXPR20 pair<_RanIt, _RanIt> _Partition_by_median_guess_unchecked(_RanIt _First, _RanIt _Last, _Pr _Pred) {

	sub	esp, 20					; 00000014H
	push	ebx
	push	ebp

; 6963 :     if (40 < _Count) { // Tukey's ninther

	mov	ebp, DWORD PTR __Pred$[esp+24]

; 6976 : _CONSTEXPR20 pair<_RanIt, _RanIt> _Partition_by_median_guess_unchecked(_RanIt _First, _RanIt _Last, _Pr _Pred) {

	push	esi

; 6977 :     // partition [_First, _Last)
; 6978 :     _RanIt _Mid = _First + ((_Last - _First) >> 1); // shift for codegen

	mov	esi, DWORD PTR __Last$[esp+28]
	mov	eax, esi
	sub	eax, edx
	mov	DWORD PTR ___$ReturnUdt$1$[esp+32], ecx
	sar	eax, 4
	push	edi

; 6979 :     _Guess_median_unchecked(_First, _Mid, _Prev_iter(_Last), _Pred);

	lea	ecx, DWORD PTR [esi-8]
	mov	DWORD PTR __First$1$[esp+36], edx
	mov	DWORD PTR __Last$1$[esp+36], ecx
	lea	ebx, DWORD PTR [edx+eax*8]

; 6962 :     const _Diff _Count = _Last - _First;

	mov	eax, ecx
	sub	eax, edx
	sar	eax, 3

; 6963 :     if (40 < _Count) { // Tukey's ninther

	cmp	eax, 40					; 00000028H
	jle	SHORT $LN35@Partition_

; 6964 :         const _Diff _Step     = (_Count + 1) >> 3; // +1 can't overflow because range was made inclusive in caller

	inc	eax
	sar	eax, 3

; 6965 :         const _Diff _Two_step = _Step << 1; // note: intentionally discards low-order bit
; 6966 :         _Med3_unchecked(_First, _First + _Step, _First + _Two_step, _Pred);

	mov	edi, eax
	shl	edi, 4
	push	ebp
	lea	esi, DWORD PTR [eax*8]
	lea	ecx, DWORD PTR [esi+edx]
	lea	eax, DWORD PTR [edi+edx]
	mov	DWORD PTR $T1[esp+40], ecx
	mov	edx, ecx
	mov	ecx, DWORD PTR __First$1$[esp+40]
	push	eax
	call	??$_Med3_unchecked@PAU?$pair@PAVCPortal@@M@std@@P6A_NABU12@0@Z@std@@YAXPAU?$pair@PAVCPortal@@M@0@00P6A_NABU10@1@Z@Z ; std::_Med3_unchecked<std::pair<CPortal *,float> *,bool (__cdecl*)(std::pair<CPortal *,float> const &,std::pair<CPortal *,float> const &)>

; 6967 :         _Med3_unchecked(_Mid - _Step, _Mid, _Mid + _Step, _Pred);

	lea	eax, DWORD PTR [esi+ebx]
	mov	ecx, ebx
	push	ebp
	push	eax
	sub	ecx, esi
	mov	edx, ebx
	call	??$_Med3_unchecked@PAU?$pair@PAVCPortal@@M@std@@P6A_NABU12@0@Z@std@@YAXPAU?$pair@PAVCPortal@@M@0@00P6A_NABU10@1@Z@Z ; std::_Med3_unchecked<std::pair<CPortal *,float> *,bool (__cdecl*)(std::pair<CPortal *,float> const &,std::pair<CPortal *,float> const &)>

; 6968 :         _Med3_unchecked(_Last - _Two_step, _Last - _Step, _Last, _Pred);

	mov	eax, DWORD PTR __Last$1$[esp+52]
	mov	ecx, eax
	sub	ecx, esi
	push	ebp
	push	eax
	sub	eax, edi
	mov	DWORD PTR $T2[esp+60], ecx
	mov	edx, ecx
	mov	ecx, eax
	call	??$_Med3_unchecked@PAU?$pair@PAVCPortal@@M@std@@P6A_NABU12@0@Z@std@@YAXPAU?$pair@PAVCPortal@@M@0@00P6A_NABU10@1@Z@Z ; std::_Med3_unchecked<std::pair<CPortal *,float> *,bool (__cdecl*)(std::pair<CPortal *,float> const &,std::pair<CPortal *,float> const &)>

; 6969 :         _Med3_unchecked(_First + _Step, _Mid, _Last - _Step, _Pred);
; 6970 :     } else {

	mov	esi, DWORD PTR __Last$[esp+56]
	add	esp, 24					; 00000018H
	mov	ecx, DWORD PTR $T2[esp+36]
	mov	eax, DWORD PTR $T1[esp+36]
	jmp	SHORT $LN36@Partition_
$LN35@Partition_:

; 6971 :         _Med3_unchecked(_First, _Mid, _Last, _Pred);

	mov	eax, edx
$LN36@Partition_:

; 6980 :     _RanIt _Pfirst = _Mid;

	push	ebp
	push	ecx
	mov	edx, ebx
	mov	ecx, eax
	call	??$_Med3_unchecked@PAU?$pair@PAVCPortal@@M@std@@P6A_NABU12@0@Z@std@@YAXPAU?$pair@PAVCPortal@@M@0@00P6A_NABU10@1@Z@Z ; std::_Med3_unchecked<std::pair<CPortal *,float> *,bool (__cdecl*)(std::pair<CPortal *,float> const &,std::pair<CPortal *,float> const &)>
	add	esp, 8

; 6981 :     _RanIt _Plast  = _Next_iter(_Pfirst);

	lea	edi, DWORD PTR [ebx+8]
	mov	DWORD PTR __Plast$1$[esp+36], edi

; 6982 : 
; 6983 :     while (_First < _Pfirst && !_DEBUG_LT_PRED(_Pred, *_Prev_iter(_Pfirst), *_Pfirst)
; 6984 :            && !_Pred(*_Pfirst, *_Prev_iter(_Pfirst))) {

	cmp	DWORD PTR __First$1$[esp+36], ebx
	jae	SHORT $LN147@Partition_
	mov	esi, DWORD PTR __First$1$[esp+36]
$LL2@Partition_:
	lea	eax, DWORD PTR [ebx-8]
	push	ebx
	push	eax
	mov	DWORD PTR tv887[esp+44], eax
	call	ebp
	add	esp, 8
	test	al, al
	jne	SHORT $LN172@Partition_
	push	DWORD PTR tv887[esp+36]
	push	ebx
	call	ebp
	add	esp, 8
	test	al, al
	jne	SHORT $LN172@Partition_

; 6985 :         --_Pfirst;

	mov	ebx, DWORD PTR tv887[esp+36]
	cmp	esi, ebx
	jb	SHORT $LL2@Partition_
$LN172@Partition_:
	mov	esi, DWORD PTR __Last$[esp+32]
$LN147@Partition_:

; 6986 :     }
; 6987 : 
; 6988 :     while (_Plast < _Last && !_DEBUG_LT_PRED(_Pred, *_Plast, *_Pfirst) && !_Pred(*_Pfirst, *_Plast)) {

	cmp	edi, esi
	jae	SHORT $LN5@Partition_
$LL4@Partition_:
	push	ebx
	push	edi
	call	ebp
	add	esp, 8
	test	al, al
	jne	SHORT $LN173@Partition_
	push	edi
	push	ebx
	call	ebp
	add	esp, 8
	test	al, al
	jne	SHORT $LN173@Partition_

; 6989 :         ++_Plast;

	add	edi, 8
	cmp	edi, esi
	jb	SHORT $LL4@Partition_
$LN173@Partition_:
	mov	DWORD PTR __Plast$1$[esp+36], edi
$LN5@Partition_:

; 6990 :     }
; 6991 : 
; 6992 :     _RanIt _Gfirst = _Plast;
; 6993 :     _RanIt _Glast  = _Pfirst;

	mov	ebp, ebx
	mov	esi, edi
	mov	DWORD PTR __Glast$1$[esp+36], ebp
$LN177@Partition_:

; 6996 :         for (; _Gfirst < _Last; ++_Gfirst) {

	mov	DWORD PTR __Gfirst$1$[esp+36], esi
$LN178@Partition_:
	mov	eax, DWORD PTR __Last$[esp+32]
$LL6@Partition_:
	cmp	esi, eax
	jae	SHORT $LN151@Partition_
	mov	ebp, DWORD PTR __Last$[esp+32]
	npad	1
$LL11@Partition_:

; 6997 :             if (_DEBUG_LT_PRED(_Pred, *_Pfirst, *_Gfirst)) {

	push	esi
	push	ebx
	call	DWORD PTR __Pred$[esp+40]
	add	esp, 8
	test	al, al
	jne	SHORT $LN9@Partition_

; 6998 :                 continue;
; 6999 :             } else if (_Pred(*_Gfirst, *_Pfirst)) {

	push	ebx
	push	esi
	call	DWORD PTR __Pred$[esp+40]
	add	esp, 8
	test	al, al
	jne	SHORT $LN174@Partition_

; 7000 :                 break;
; 7001 :             } else if (_Plast != _Gfirst) {

	cmp	edi, esi
	je	SHORT $LN19@Partition_
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 101  :     _Left    = _STD move(_Right);

	fld	DWORD PTR [esi+4]

; 100  :     _Ty _Tmp = _STD move(_Left);

	mov	ecx, DWORD PTR [edi]

; 101  :     _Left    = _STD move(_Right);

	mov	eax, DWORD PTR [esi]

; 100  :     _Ty _Tmp = _STD move(_Left);

	movss	xmm0, DWORD PTR [edi+4]

; 101  :     _Left    = _STD move(_Right);

	fstp	DWORD PTR [edi+4]
	mov	DWORD PTR [edi], eax

; 102  :     _Right   = _STD move(_Tmp);

	mov	DWORD PTR [esi], ecx
	movss	DWORD PTR [esi+4], xmm0
$LN19@Partition_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 6996 :         for (; _Gfirst < _Last; ++_Gfirst) {

	add	edi, 8
$LN9@Partition_:
	add	esi, 8
	cmp	esi, ebp
	jb	SHORT $LL11@Partition_
$LN174@Partition_:
	mov	ebp, DWORD PTR __Glast$1$[esp+36]
	mov	DWORD PTR __Plast$1$[esp+36], edi
	mov	DWORD PTR __Gfirst$1$[esp+36], esi
$LN151@Partition_:

; 7009 :         for (; _First < _Glast; --_Glast) {

	mov	eax, DWORD PTR __First$1$[esp+36]
	cmp	ebp, eax
	jbe	SHORT $LN176@Partition_
	mov	esi, DWORD PTR __Glast$1$[esp+36]
	mov	edi, eax
	lea	ebp, DWORD PTR [esi-8]
	npad	3
$LL14@Partition_:

; 7010 :             if (_DEBUG_LT_PRED(_Pred, *_Prev_iter(_Glast), *_Pfirst)) {

	push	ebx
	push	ebp
	call	DWORD PTR __Pred$[esp+40]
	add	esp, 8
	test	al, al
	jne	SHORT $LN12@Partition_

; 7011 :                 continue;
; 7012 :             } else if (_Pred(*_Pfirst, *_Prev_iter(_Glast))) {

	push	ebp
	push	ebx
	call	DWORD PTR __Pred$[esp+40]
	add	esp, 8
	test	al, al
	jne	SHORT $LN175@Partition_

; 7013 :                 break;
; 7014 :             } else if (--_Pfirst != _Prev_iter(_Glast)) {

	sub	ebx, 8
	cmp	ebx, ebp
	je	SHORT $LN12@Partition_
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 101  :     _Left    = _STD move(_Right);

	fld	DWORD PTR [ebp+4]

; 100  :     _Ty _Tmp = _STD move(_Left);

	mov	ecx, DWORD PTR [ebx]

; 101  :     _Left    = _STD move(_Right);

	mov	eax, DWORD PTR [ebp]

; 100  :     _Ty _Tmp = _STD move(_Left);

	movss	xmm0, DWORD PTR [ebx+4]

; 101  :     _Left    = _STD move(_Right);

	fstp	DWORD PTR [ebx+4]
	mov	DWORD PTR [ebx], eax

; 102  :     _Right   = _STD move(_Tmp);

	mov	DWORD PTR [ebp], ecx
	movss	DWORD PTR [ebp+4], xmm0
$LN12@Partition_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 7009 :         for (; _First < _Glast; --_Glast) {

	sub	esi, 8
	sub	ebp, 8
	cmp	edi, esi
	jb	SHORT $LL14@Partition_
$LN175@Partition_:
	mov	eax, DWORD PTR __First$1$[esp+36]
	mov	edi, DWORD PTR __Plast$1$[esp+36]
	mov	DWORD PTR __Glast$1$[esp+36], esi
	mov	ebp, DWORD PTR __Glast$1$[esp+36]

; 7015 :                 _STD iter_swap(_Pfirst, _Prev_iter(_Glast));
; 7016 :             }
; 7017 :         }
; 7018 : 
; 7019 :         if (_Glast == _First && _Gfirst == _Last) {

	cmp	ebp, eax
	mov	esi, DWORD PTR __Gfirst$1$[esp+36]
$LN176@Partition_:
	jne	SHORT $LN27@Partition_
	cmp	esi, DWORD PTR __Last$[esp+32]
	je	$LN153@Partition_

; 7021 :         }
; 7022 : 
; 7023 :         if (_Glast == _First) { // no room at bottom, rotate pivot upward
; 7024 :             if (_Plast != _Gfirst) {

	cmp	edi, esi
	je	SHORT $LN75@Partition_
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 318  :         if (this != _STD addressof(_Right)) {

	cmp	ebx, edi
	je	SHORT $LN75@Partition_

; 101  :     _Left    = _STD move(_Right);

	fld	DWORD PTR [edi+4]

; 100  :     _Ty _Tmp = _STD move(_Left);

	mov	ecx, DWORD PTR [ebx]

; 101  :     _Left    = _STD move(_Right);

	mov	eax, DWORD PTR [edi]

; 100  :     _Ty _Tmp = _STD move(_Left);

	movss	xmm0, DWORD PTR [ebx+4]

; 101  :     _Left    = _STD move(_Right);

	fstp	DWORD PTR [ebx+4]
	mov	DWORD PTR [ebx], eax

; 102  :     _Right   = _STD move(_Tmp);

	mov	DWORD PTR [edi], ecx
	movss	DWORD PTR [edi+4], xmm0
$LN75@Partition_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 7028 :             ++_Plast;

	add	edi, 8
	mov	DWORD PTR __Plast$1$[esp+36], edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 318  :         if (this != _STD addressof(_Right)) {

	cmp	ebx, esi
	je	SHORT $LN90@Partition_

; 101  :     _Left    = _STD move(_Right);

	fld	DWORD PTR [esi+4]

; 100  :     _Ty _Tmp = _STD move(_Left);

	mov	ecx, DWORD PTR [ebx]

; 101  :     _Left    = _STD move(_Right);

	mov	eax, DWORD PTR [esi]

; 100  :     _Ty _Tmp = _STD move(_Left);

	movss	xmm0, DWORD PTR [ebx+4]

; 101  :     _Left    = _STD move(_Right);

	fstp	DWORD PTR [ebx+4]
	mov	DWORD PTR [ebx], eax

; 102  :     _Right   = _STD move(_Tmp);

	mov	DWORD PTR [esi], ecx
	movss	DWORD PTR [esi+4], xmm0
$LN90@Partition_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 7030 :             ++_Pfirst;

	add	ebx, 8

; 7031 :             ++_Gfirst;

	add	esi, 8
	jmp	$LN177@Partition_
$LN27@Partition_:

; 7032 :         } else if (_Gfirst == _Last) { // no room at top, rotate pivot downward

	mov	eax, DWORD PTR __Last$[esp+32]
	add	ebp, -8					; fffffff8H
	mov	DWORD PTR __Glast$1$[esp+36], ebp
	cmp	esi, eax
	jne	SHORT $LN30@Partition_

; 7033 :             if (--_Glast != --_Pfirst) {

	sub	ebx, 8
	cmp	ebp, ebx
	je	SHORT $LN168@Partition_
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 101  :     _Left    = _STD move(_Right);

	mov	eax, DWORD PTR [ebx]
	fld	DWORD PTR [ebx+4]

; 100  :     _Ty _Tmp = _STD move(_Left);

	mov	ecx, DWORD PTR [ebp]
	movss	xmm0, DWORD PTR [ebp+4]

; 101  :     _Left    = _STD move(_Right);

	mov	DWORD PTR [ebp], eax
	mov	eax, DWORD PTR __Last$[esp+32]
	fstp	DWORD PTR [ebp+4]

; 102  :     _Right   = _STD move(_Tmp);

	mov	DWORD PTR [ebx], ecx
	movss	DWORD PTR [ebx+4], xmm0
$LN168@Partition_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 7037 :             _STD iter_swap(_Pfirst, --_Plast);

	sub	edi, 8
	mov	DWORD PTR __Plast$1$[esp+36], edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 318  :         if (this != _STD addressof(_Right)) {

	cmp	ebx, edi
	je	$LL6@Partition_

; 101  :     _Left    = _STD move(_Right);

	fld	DWORD PTR [edi+4]

; 100  :     _Ty _Tmp = _STD move(_Left);

	mov	ecx, DWORD PTR [ebx]

; 101  :     _Left    = _STD move(_Right);

	mov	eax, DWORD PTR [edi]

; 100  :     _Ty _Tmp = _STD move(_Left);

	movss	xmm0, DWORD PTR [ebx+4]

; 101  :     _Left    = _STD move(_Right);

	fstp	DWORD PTR [ebx+4]
	mov	DWORD PTR [ebx], eax

; 102  :     _Right   = _STD move(_Tmp);

	mov	DWORD PTR [edi], ecx
	movss	DWORD PTR [edi+4], xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 7038 :         } else {

	jmp	$LN178@Partition_
$LN30@Partition_:

; 7039 :             _STD iter_swap(_Gfirst, --_Glast);

	mov	DWORD PTR __Glast$1$[esp+36], ebp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 318  :         if (this != _STD addressof(_Right)) {

	cmp	esi, ebp
	je	SHORT $LN135@Partition_

; 101  :     _Left    = _STD move(_Right);

	mov	eax, DWORD PTR [ebp]
	fld	DWORD PTR [ebp+4]

; 100  :     _Ty _Tmp = _STD move(_Left);

	mov	ecx, DWORD PTR [esi]
	movss	xmm0, DWORD PTR [esi+4]

; 101  :     _Left    = _STD move(_Right);

	mov	DWORD PTR [esi], eax
	mov	eax, DWORD PTR __Last$[esp+32]
	fstp	DWORD PTR [esi+4]

; 102  :     _Right   = _STD move(_Tmp);

	mov	DWORD PTR [ebp], ecx
	movss	DWORD PTR [ebp+4], xmm0
$LN135@Partition_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 7040 :             ++_Gfirst;

	add	esi, 8
	mov	DWORD PTR __Gfirst$1$[esp+36], esi

; 7041 :         }
; 7042 :     }

	jmp	$LL6@Partition_
$LN153@Partition_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 186  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

	mov	eax, DWORD PTR ___$ReturnUdt$1$[esp+36]
	mov	DWORD PTR [eax+4], edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 7020 :             return pair<_RanIt, _RanIt>(_Pfirst, _Plast);

	pop	edi
	pop	esi
	pop	ebp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 186  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

	mov	DWORD PTR [eax], ebx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 7020 :             return pair<_RanIt, _RanIt>(_Pfirst, _Plast);

	pop	ebx

; 7043 : }

	add	esp, 20					; 00000014H
	ret	0
??$_Partition_by_median_guess_unchecked@PAU?$pair@PAVCPortal@@M@std@@P6A_NABU12@0@Z@std@@YA?AU?$pair@PAU?$pair@PAVCPortal@@M@std@@PAU12@@0@PAU?$pair@PAVCPortal@@M@0@0P6A_NABU20@1@Z@Z ENDP ; std::_Partition_by_median_guess_unchecked<std::pair<CPortal *,float> *,bool (__cdecl*)(std::pair<CPortal *,float> const &,std::pair<CPortal *,float> const &)>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Destroy_in_place@PAU?$pair@PAVCPortal@@M@std@@@std@@YAXAAPAU?$pair@PAVCPortal@@M@0@@Z
_TEXT	SEGMENT
??$_Destroy_in_place@PAU?$pair@PAVCPortal@@M@std@@@std@@YAXAAPAU?$pair@PAVCPortal@@M@0@@Z PROC ; std::_Destroy_in_place<std::pair<CPortal *,float> *>, COMDAT
; __Obj$dead$ = ecx

; 295  :     if constexpr (is_array_v<_Ty>) {
; 296  :         _Destroy_range(_Obj, _Obj + extent_v<_Ty>);
; 297  :     } else {
; 298  :         _Obj.~_Ty();
; 299  :     }
; 300  : }

	ret	0
??$_Destroy_in_place@PAU?$pair@PAVCPortal@@M@std@@@std@@YAXAAPAU?$pair@PAVCPortal@@M@0@@Z ENDP ; std::_Destroy_in_place<std::pair<CPortal *,float> *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
;	COMDAT ??$?4U?$pair@PAVCPortal@@M@std@@$0A@@?$pair@PAVCPortal@@M@std@@QAEAAU01@$$QAU01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??$?4U?$pair@PAVCPortal@@M@std@@$0A@@?$pair@PAVCPortal@@M@std@@QAEAAU01@$$QAU01@@Z PROC ; std::pair<CPortal *,float>::operator=<std::pair<CPortal *,float>,0>, COMDAT
; _this$ = ecx

; 288  :         first  = _STD forward<_Ty1>(_Right.first);

	mov	edx, DWORD PTR __Right$[esp-4]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax

; 289  :         second = _STD forward<_Ty2>(_Right.second);
; 290  :         return *this;

	mov	eax, ecx
	fld	DWORD PTR [edx+4]
	fstp	DWORD PTR [ecx+4]

; 291  :     }

	ret	4
??$?4U?$pair@PAVCPortal@@M@std@@$0A@@?$pair@PAVCPortal@@M@std@@QAEAAU01@$$QAU01@@Z ENDP ; std::pair<CPortal *,float>::operator=<std::pair<CPortal *,float>,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_Move_backward_unchecked@PAU?$pair@PAVCPortal@@M@std@@PAU12@@std@@YAPAU?$pair@PAVCPortal@@M@0@PAU10@00@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
??$_Move_backward_unchecked@PAU?$pair@PAVCPortal@@M@std@@PAU12@@std@@YAPAU?$pair@PAVCPortal@@M@0@PAU10@00@Z PROC ; std::_Move_backward_unchecked<std::pair<CPortal *,float> *,std::pair<CPortal *,float> *>, COMDAT
; __First$ = ecx
; __Last$ = edx

; 4362 :     while (_First != _Last) {

	mov	eax, DWORD PTR __Dest$[esp-4]
	push	esi
	mov	esi, ecx
	cmp	edx, esi
	je	SHORT $LN3@Move_backw
	npad	5
$LL9@Move_backw:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 288  :         first  = _STD forward<_Ty1>(_Right.first);

	mov	ecx, DWORD PTR [edx-8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility

; 4363 :         *--_Dest = _STD move(*--_Last);

	sub	edx, 8
	sub	eax, 8
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 288  :         first  = _STD forward<_Ty1>(_Right.first);

	mov	DWORD PTR [eax], ecx

; 289  :         second = _STD forward<_Ty2>(_Right.second);

	fld	DWORD PTR [edx+4]
	fstp	DWORD PTR [eax+4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility

; 4362 :     while (_First != _Last) {

	cmp	edx, esi
	jne	SHORT $LL9@Move_backw
$LN3@Move_backw:
	pop	esi

; 4364 :     }
; 4365 : 
; 4366 :     return _Dest;
; 4367 : }

	ret	0
??$_Move_backward_unchecked@PAU?$pair@PAVCPortal@@M@std@@PAU12@@std@@YAPAU?$pair@PAVCPortal@@M@0@PAU10@00@Z ENDP ; std::_Move_backward_unchecked<std::pair<CPortal *,float> *,std::pair<CPortal *,float> *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
;	COMDAT ??$_Pop_heap_hole_by_index@PAU?$pair@PAVCPortal@@M@std@@U12@P6A_NABU12@0@Z@std@@YAXPAU?$pair@PAVCPortal@@M@0@HH$$QAU10@P6A_NABU10@2@Z@Z
_TEXT	SEGMENT
__Top$1$ = -4						; size = 4
__Bottom$ = 8						; size = 4
__Val$ = 12						; size = 4
__Pred$ = 16						; size = 4
??$_Pop_heap_hole_by_index@PAU?$pair@PAVCPortal@@M@std@@U12@P6A_NABU12@0@Z@std@@YAXPAU?$pair@PAVCPortal@@M@0@HH$$QAU10@P6A_NABU10@2@Z@Z PROC ; std::_Pop_heap_hole_by_index<std::pair<CPortal *,float> *,std::pair<CPortal *,float>,bool (__cdecl*)(std::pair<CPortal *,float> const &,std::pair<CPortal *,float> const &)>, COMDAT
; __First$ = ecx
; __Hole$ = edx

; 5375 :     _RanIt _First, _Iter_diff_t<_RanIt> _Hole, _Iter_diff_t<_RanIt> _Bottom, _Ty&& _Val, _Pr _Pred) {

	push	ecx
	push	ebx
	push	ebp
	mov	ebx, ecx

; 5376 :     // percolate _Hole to _Bottom, then push _Val
; 5377 :     _STL_INTERNAL_CHECK(_Bottom > 0);
; 5378 : 
; 5379 :     using _Diff      = _Iter_diff_t<_RanIt>;
; 5380 :     const _Diff _Top = _Hole;
; 5381 :     _Diff _Idx       = _Hole;
; 5382 : 
; 5383 :     // Check whether _Idx can have a child before calculating that child's index, since
; 5384 :     // calculating the child's index can trigger integer overflows
; 5385 :     const _Diff _Max_sequence_non_leaf = (_Bottom - 1) >> 1; // shift for codegen

	mov	ecx, DWORD PTR __Bottom$[esp+8]
	push	esi
	push	edi
	mov	edi, edx

; 5386 :     while (_Idx < _Max_sequence_non_leaf) { // move _Hole down to larger child

	mov	edx, DWORD PTR __Pred$[esp+16]
	lea	ebp, DWORD PTR [ecx-1]
	mov	DWORD PTR __Top$1$[esp+20], edi
	sar	ebp, 1
	mov	esi, edi
	cmp	edi, ebp
	jge	SHORT $LN3@Pop_heap_h
$LL2@Pop_heap_h:

; 5387 :         _Idx = 2 * _Idx + 2;

	lea	esi, DWORD PTR [esi*2+2]

; 5388 :         if (_DEBUG_LT_PRED(_Pred, *(_First + _Idx), *(_First + (_Idx - 1)))) {

	lea	ecx, DWORD PTR [ebx+esi*8]
	lea	eax, DWORD PTR [ecx-8]
	push	eax
	push	ecx
	call	edx
	add	esp, 8
	test	al, al
	je	SHORT $LN4@Pop_heap_h

; 5389 :             --_Idx;

	dec	esi
$LN4@Pop_heap_h:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 288  :         first  = _STD forward<_Ty1>(_Right.first);

	mov	eax, DWORD PTR [ebx+esi*8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 5386 :     while (_Idx < _Max_sequence_non_leaf) { // move _Hole down to larger child

	mov	edx, DWORD PTR __Pred$[esp+16]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 288  :         first  = _STD forward<_Ty1>(_Right.first);

	mov	DWORD PTR [ebx+edi*8], eax

; 289  :         second = _STD forward<_Ty2>(_Right.second);

	fld	DWORD PTR [ebx+esi*8+4]
	fstp	DWORD PTR [ebx+edi*8+4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 5392 :         _Hole             = _Idx;

	mov	edi, esi
	cmp	esi, ebp
	jl	SHORT $LL2@Pop_heap_h
	mov	ecx, DWORD PTR __Bottom$[esp+16]
$LN3@Pop_heap_h:

; 5393 :     }
; 5394 : 
; 5395 :     if (_Idx == _Max_sequence_non_leaf && _Bottom % 2 == 0) { // only child at bottom, move _Hole down to it

	cmp	esi, ebp
	jne	SHORT $LN5@Pop_heap_h
	test	cl, 1
	jne	SHORT $LN5@Pop_heap_h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 288  :         first  = _STD forward<_Ty1>(_Right.first);

	mov	eax, DWORD PTR [ebx+ecx*8-8]
	mov	DWORD PTR [ebx+edi*8], eax

; 289  :         second = _STD forward<_Ty2>(_Right.second);

	fld	DWORD PTR [ebx+ecx*8-4]
	fstp	DWORD PTR [ebx+edi*8+4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 5397 :         _Hole             = _Bottom - 1;

	lea	edi, DWORD PTR [ecx-1]
$LN5@Pop_heap_h:

; 5268 :          _Top < _Hole && _DEBUG_LT_PRED(_Pred, *(_First + _Idx), _Val); //

	cmp	DWORD PTR __Top$1$[esp+20], edi
	jge	SHORT $LN28@Pop_heap_h
$LL14@Pop_heap_h:
	push	DWORD PTR __Val$[esp+16]
	lea	esi, DWORD PTR [edi-1]
	sar	esi, 1
	lea	ebp, DWORD PTR [ebx+esi*8]
	push	ebp
	call	edx
	add	esp, 8
	test	al, al
	je	SHORT $LN28@Pop_heap_h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 288  :         first  = _STD forward<_Ty1>(_Right.first);

	mov	eax, DWORD PTR [ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 5268 :          _Top < _Hole && _DEBUG_LT_PRED(_Pred, *(_First + _Idx), _Val); //

	mov	edx, DWORD PTR __Pred$[esp+16]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 288  :         first  = _STD forward<_Ty1>(_Right.first);

	mov	DWORD PTR [ebx+edi*8], eax

; 289  :         second = _STD forward<_Ty2>(_Right.second);

	fld	DWORD PTR [ebp+4]
	fstp	DWORD PTR [ebx+edi*8+4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 5272 :         _Hole             = _Idx;

	mov	edi, esi
	cmp	DWORD PTR __Top$1$[esp+20], esi
	jl	SHORT $LL14@Pop_heap_h
$LN28@Pop_heap_h:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 288  :         first  = _STD forward<_Ty1>(_Right.first);

	mov	ecx, DWORD PTR __Val$[esp+16]
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [ebx+edi*8], eax

; 289  :         second = _STD forward<_Ty2>(_Right.second);

	fld	DWORD PTR [ecx+4]
	fstp	DWORD PTR [ebx+edi*8+4]
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 5401 : }

	pop	ecx
	ret	0
??$_Pop_heap_hole_by_index@PAU?$pair@PAVCPortal@@M@std@@U12@P6A_NABU12@0@Z@std@@YAXPAU?$pair@PAVCPortal@@M@0@HH$$QAU10@P6A_NABU10@2@Z@Z ENDP ; std::_Pop_heap_hole_by_index<std::pair<CPortal *,float> *,std::pair<CPortal *,float>,bool (__cdecl*)(std::pair<CPortal *,float> const &,std::pair<CPortal *,float> const &)>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
;	COMDAT ??$_Pop_heap_unchecked@PAU?$pair@PAVCPortal@@M@std@@P6A_NABU12@0@Z@std@@YAXPAU?$pair@PAVCPortal@@M@0@0P6A_NABU10@1@Z@Z
_TEXT	SEGMENT
__Val$1 = -8						; size = 8
__Pred$ = 8						; size = 4
??$_Pop_heap_unchecked@PAU?$pair@PAVCPortal@@M@std@@P6A_NABU12@0@Z@std@@YAXPAU?$pair@PAVCPortal@@M@0@0P6A_NABU10@1@Z@Z PROC ; std::_Pop_heap_unchecked<std::pair<CPortal *,float> *,bool (__cdecl*)(std::pair<CPortal *,float> const &,std::pair<CPortal *,float> const &)>, COMDAT
; __First$ = ecx
; __Last$ = edx

; 5415 : _CONSTEXPR20 void _Pop_heap_unchecked(_RanIt _First, _RanIt _Last, _Pr _Pred) {

	sub	esp, 12					; 0000000cH

; 5416 :     // pop *_First to *(_Last - 1) and reheap
; 5417 :     if (2 <= _Last - _First) {

	mov	eax, edx
	push	esi
	mov	esi, ecx
	sub	eax, esi
	and	eax, -8					; fffffff8H
	cmp	eax, 16					; 00000010H
	jl	SHORT $LN2@Pop_heap_u

; 5419 :         _Iter_value_t<_RanIt> _Val = _STD move(*_Last);

	mov	eax, DWORD PTR [edx-8]
	sub	edx, 8

; 5410 :     _Pop_heap_hole_by_index(

	push	DWORD PTR __Pred$[esp+12]

; 5419 :         _Iter_value_t<_RanIt> _Val = _STD move(*_Last);

	mov	DWORD PTR __Val$1[esp+20], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 288  :         first  = _STD forward<_Ty1>(_Right.first);

	mov	eax, DWORD PTR [esi]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 5419 :         _Iter_value_t<_RanIt> _Val = _STD move(*_Last);

	mov	ecx, DWORD PTR [edx+4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 288  :         first  = _STD forward<_Ty1>(_Right.first);

	mov	DWORD PTR [edx], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 5410 :     _Pop_heap_hole_by_index(

	lea	eax, DWORD PTR __Val$1[esp+20]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 289  :         second = _STD forward<_Ty2>(_Right.second);

	fld	DWORD PTR [esi+4]
	fstp	DWORD PTR [edx+4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 5410 :     _Pop_heap_hole_by_index(

	sub	edx, esi

; 5419 :         _Iter_value_t<_RanIt> _Val = _STD move(*_Last);

	mov	DWORD PTR __Val$1[esp+24], ecx

; 5410 :     _Pop_heap_hole_by_index(

	sar	edx, 3
	mov	ecx, esi
	push	eax
	push	edx
	xor	edx, edx
	call	??$_Pop_heap_hole_by_index@PAU?$pair@PAVCPortal@@M@std@@U12@P6A_NABU12@0@Z@std@@YAXPAU?$pair@PAVCPortal@@M@0@HH$$QAU10@P6A_NABU10@2@Z@Z ; std::_Pop_heap_hole_by_index<std::pair<CPortal *,float> *,std::pair<CPortal *,float>,bool (__cdecl*)(std::pair<CPortal *,float> const &,std::pair<CPortal *,float> const &)>
	add	esp, 12					; 0000000cH
$LN2@Pop_heap_u:

; 5420 :         _Pop_heap_hole_unchecked(_First, _Last, _Last, _STD move(_Val), _Pred);
; 5421 :     }
; 5422 : }

	pop	esi
	add	esp, 12					; 0000000cH
	ret	0
??$_Pop_heap_unchecked@PAU?$pair@PAVCPortal@@M@std@@P6A_NABU12@0@Z@std@@YAXPAU?$pair@PAVCPortal@@M@0@0P6A_NABU10@1@Z@Z ENDP ; std::_Pop_heap_unchecked<std::pair<CPortal *,float> *,bool (__cdecl*)(std::pair<CPortal *,float> const &,std::pair<CPortal *,float> const &)>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_Prev_iter@PAU?$pair@PAVCPortal@@M@std@@@std@@YAPAU?$pair@PAVCPortal@@M@0@PAU10@@Z
_TEXT	SEGMENT
??$_Prev_iter@PAU?$pair@PAVCPortal@@M@std@@@std@@YAPAU?$pair@PAVCPortal@@M@0@PAU10@@Z PROC ; std::_Prev_iter<std::pair<CPortal *,float> *>, COMDAT
; __First$ = ecx

; 1554 :     return --_First;

	lea	eax, DWORD PTR [ecx-8]

; 1555 : }

	ret	0
??$_Prev_iter@PAU?$pair@PAVCPortal@@M@std@@@std@@YAPAU?$pair@PAVCPortal@@M@0@PAU10@@Z ENDP ; std::_Prev_iter<std::pair<CPortal *,float> *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
;	COMDAT ??$_Guess_median_unchecked@PAU?$pair@PAVCPortal@@M@std@@P6A_NABU12@0@Z@std@@YAXPAU?$pair@PAVCPortal@@M@0@00P6A_NABU10@1@Z@Z
_TEXT	SEGMENT
__Mid$1$ = -4						; size = 4
$T1 = 8							; size = 4
__Last$ = 8						; size = 4
__Pred$ = 12						; size = 4
??$_Guess_median_unchecked@PAU?$pair@PAVCPortal@@M@std@@P6A_NABU12@0@Z@std@@YAXPAU?$pair@PAVCPortal@@M@0@00P6A_NABU10@1@Z@Z PROC ; std::_Guess_median_unchecked<std::pair<CPortal *,float> *,bool (__cdecl*)(std::pair<CPortal *,float> const &,std::pair<CPortal *,float> const &)>, COMDAT
; __First$ = ecx
; __Mid$ = edx

; 6959 : _CONSTEXPR20 void _Guess_median_unchecked(_RanIt _First, _RanIt _Mid, _RanIt _Last, _Pr _Pred) {

	push	ecx
	push	ebx

; 6960 :     // sort median element to middle
; 6961 :     using _Diff        = _Iter_diff_t<_RanIt>;
; 6962 :     const _Diff _Count = _Last - _First;

	mov	ebx, DWORD PTR __Last$[esp+4]
	mov	eax, ebx
	sub	eax, ecx
	push	ebp
	mov	ebp, edx
	sar	eax, 3

; 6963 :     if (40 < _Count) { // Tukey's ninther

	mov	edx, DWORD PTR __Pred$[esp+8]
	mov	DWORD PTR __Mid$1$[esp+12], ebp
	cmp	eax, 40					; 00000028H
	jle	SHORT $LN2@Guess_medi

; 6964 :         const _Diff _Step     = (_Count + 1) >> 3; // +1 can't overflow because range was made inclusive in caller

	inc	eax
	sar	eax, 3
	push	esi
	push	edi

; 6965 :         const _Diff _Two_step = _Step << 1; // note: intentionally discards low-order bit
; 6966 :         _Med3_unchecked(_First, _First + _Step, _First + _Two_step, _Pred);

	mov	edi, eax
	lea	esi, DWORD PTR [eax*8]
	shl	edi, 4
	lea	eax, DWORD PTR [esi+ecx]
	mov	DWORD PTR $T1[esp+16], eax
	push	edx
	lea	eax, DWORD PTR [edi+ecx]
	push	eax
	lea	edx, DWORD PTR [esi+ecx]
	call	??$_Med3_unchecked@PAU?$pair@PAVCPortal@@M@std@@P6A_NABU12@0@Z@std@@YAXPAU?$pair@PAVCPortal@@M@0@00P6A_NABU10@1@Z@Z ; std::_Med3_unchecked<std::pair<CPortal *,float> *,bool (__cdecl*)(std::pair<CPortal *,float> const &,std::pair<CPortal *,float> const &)>

; 6967 :         _Med3_unchecked(_Mid - _Step, _Mid, _Mid + _Step, _Pred);

	push	DWORD PTR __Pred$[esp+24]
	lea	eax, DWORD PTR [esi+ebp]
	mov	ecx, ebp
	push	eax
	sub	ecx, esi
	mov	edx, ebp
	call	??$_Med3_unchecked@PAU?$pair@PAVCPortal@@M@std@@P6A_NABU12@0@Z@std@@YAXPAU?$pair@PAVCPortal@@M@0@00P6A_NABU10@1@Z@Z ; std::_Med3_unchecked<std::pair<CPortal *,float> *,bool (__cdecl*)(std::pair<CPortal *,float> const &,std::pair<CPortal *,float> const &)>

; 6968 :         _Med3_unchecked(_Last - _Two_step, _Last - _Step, _Last, _Pred);

	push	DWORD PTR __Pred$[esp+32]
	mov	ebp, ebx
	push	ebx
	sub	ebp, esi
	sub	ebx, edi
	mov	edx, ebp
	mov	ecx, ebx
	call	??$_Med3_unchecked@PAU?$pair@PAVCPortal@@M@std@@P6A_NABU12@0@Z@std@@YAXPAU?$pair@PAVCPortal@@M@0@00P6A_NABU10@1@Z@Z ; std::_Med3_unchecked<std::pair<CPortal *,float> *,bool (__cdecl*)(std::pair<CPortal *,float> const &,std::pair<CPortal *,float> const &)>

; 6969 :         _Med3_unchecked(_First + _Step, _Mid, _Last - _Step, _Pred);
; 6970 :     } else {

	mov	edx, DWORD PTR __Pred$[esp+40]
	add	esp, 24					; 00000018H
	mov	eax, DWORD PTR $T1[esp+16]

; 6971 :         _Med3_unchecked(_First, _Mid, _Last, _Pred);
; 6972 :     }
; 6973 : }

	mov	ecx, eax
	pop	edi
	pop	esi
	push	edx
	mov	edx, DWORD PTR __Mid$1$[esp+16]
	push	ebp
	call	??$_Med3_unchecked@PAU?$pair@PAVCPortal@@M@std@@P6A_NABU12@0@Z@std@@YAXPAU?$pair@PAVCPortal@@M@0@00P6A_NABU10@1@Z@Z ; std::_Med3_unchecked<std::pair<CPortal *,float> *,bool (__cdecl*)(std::pair<CPortal *,float> const &,std::pair<CPortal *,float> const &)>
	add	esp, 8
	pop	ebp
	pop	ebx
	pop	ecx
	ret	0
$LN2@Guess_medi:
	push	edx
	mov	edx, DWORD PTR __Mid$1$[esp+16]
	mov	ebp, ebx
	mov	eax, ecx
	push	ebp
	call	??$_Med3_unchecked@PAU?$pair@PAVCPortal@@M@std@@P6A_NABU12@0@Z@std@@YAXPAU?$pair@PAVCPortal@@M@0@00P6A_NABU10@1@Z@Z ; std::_Med3_unchecked<std::pair<CPortal *,float> *,bool (__cdecl*)(std::pair<CPortal *,float> const &,std::pair<CPortal *,float> const &)>
	add	esp, 8
	pop	ebp
	pop	ebx
	pop	ecx
	ret	0
??$_Guess_median_unchecked@PAU?$pair@PAVCPortal@@M@std@@P6A_NABU12@0@Z@std@@YAXPAU?$pair@PAVCPortal@@M@0@00P6A_NABU10@1@Z@Z ENDP ; std::_Guess_median_unchecked<std::pair<CPortal *,float> *,bool (__cdecl*)(std::pair<CPortal *,float> const &,std::pair<CPortal *,float> const &)>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_Next_iter@PAU?$pair@PAVCPortal@@M@std@@@std@@YAPAU?$pair@PAVCPortal@@M@0@PAU10@@Z
_TEXT	SEGMENT
??$_Next_iter@PAU?$pair@PAVCPortal@@M@std@@@std@@YAPAU?$pair@PAVCPortal@@M@0@PAU10@@Z PROC ; std::_Next_iter<std::pair<CPortal *,float> *>, COMDAT
; __First$ = ecx

; 1541 :     return ++_First;

	lea	eax, DWORD PTR [ecx+8]

; 1542 : }

	ret	0
??$_Next_iter@PAU?$pair@PAVCPortal@@M@std@@@std@@YAPAU?$pair@PAVCPortal@@M@0@PAU10@@Z ENDP ; std::_Next_iter<std::pair<CPortal *,float> *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
;	COMDAT ??$iter_swap@PAU?$pair@PAVCPortal@@M@std@@PAU12@@std@@YAXPAU?$pair@PAVCPortal@@M@0@0@Z
_TEXT	SEGMENT
??$iter_swap@PAU?$pair@PAVCPortal@@M@std@@PAU12@@std@@YAXPAU?$pair@PAVCPortal@@M@0@0@Z PROC ; std::iter_swap<std::pair<CPortal *,float> *,std::pair<CPortal *,float> *>, COMDAT
; __Left$ = ecx
; __Right$ = edx

; 318  :         if (this != _STD addressof(_Right)) {

	cmp	ecx, edx
	je	SHORT $LN6@iter_swap

; 101  :     _Left    = _STD move(_Right);

	mov	eax, DWORD PTR [edx]
	fld	DWORD PTR [edx+4]
	movss	xmm0, DWORD PTR [ecx+4]

; 100  :     _Ty _Tmp = _STD move(_Left);

	push	esi
	mov	esi, DWORD PTR [ecx]

; 101  :     _Left    = _STD move(_Right);

	mov	DWORD PTR [ecx], eax
	fstp	DWORD PTR [ecx+4]

; 102  :     _Right   = _STD move(_Tmp);

	mov	DWORD PTR [edx], esi
	movss	DWORD PTR [edx+4], xmm0
	pop	esi
$LN6@iter_swap:

; 78   :     swap(*_Left, *_Right);
; 79   : }

	ret	0
??$iter_swap@PAU?$pair@PAVCPortal@@M@std@@PAU12@@std@@YAXPAU?$pair@PAVCPortal@@M@0@0@Z ENDP ; std::iter_swap<std::pair<CPortal *,float> *,std::pair<CPortal *,float> *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
;	COMDAT ??$?0AAPAU?$pair@PAVCPortal@@M@std@@AAPAU01@$0A@@?$pair@PAU?$pair@PAVCPortal@@M@std@@PAU12@@std@@QAE@AAPAU?$pair@PAVCPortal@@M@1@0@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??$?0AAPAU?$pair@PAVCPortal@@M@std@@AAPAU01@$0A@@?$pair@PAU?$pair@PAVCPortal@@M@std@@PAU12@@std@@QAE@AAPAU?$pair@PAVCPortal@@M@1@0@Z PROC ; std::pair<std::pair<CPortal *,float> *,std::pair<CPortal *,float> *>::pair<std::pair<CPortal *,float> *,std::pair<CPortal *,float> *><std::pair<CPortal *,float> * &,std::pair<CPortal *,float> * &,0>, COMDAT
; _this$ = ecx

; 186  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

	mov	eax, DWORD PTR __Val1$[esp-4]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR __Val2$[esp-4]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx+4], eax
	mov	eax, ecx
	ret	8
??$?0AAPAU?$pair@PAVCPortal@@M@std@@AAPAU01@$0A@@?$pair@PAU?$pair@PAVCPortal@@M@std@@PAU12@@std@@QAE@AAPAU?$pair@PAVCPortal@@M@1@0@Z ENDP ; std::pair<std::pair<CPortal *,float> *,std::pair<CPortal *,float> *>::pair<std::pair<CPortal *,float> *,std::pair<CPortal *,float> *><std::pair<CPortal *,float> * &,std::pair<CPortal *,float> * &,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
;	COMDAT ??$_Push_heap_by_index@PAU?$pair@PAVCPortal@@M@std@@U12@P6A_NABU12@0@Z@std@@YAXPAU?$pair@PAVCPortal@@M@0@HH$$QAU10@P6A_NABU10@2@Z@Z
_TEXT	SEGMENT
__Top$ = 8						; size = 4
__Val$ = 12						; size = 4
__Pred$ = 16						; size = 4
??$_Push_heap_by_index@PAU?$pair@PAVCPortal@@M@std@@U12@P6A_NABU12@0@Z@std@@YAXPAU?$pair@PAVCPortal@@M@0@HH$$QAU10@P6A_NABU10@2@Z@Z PROC ; std::_Push_heap_by_index<std::pair<CPortal *,float> *,std::pair<CPortal *,float>,bool (__cdecl*)(std::pair<CPortal *,float> const &,std::pair<CPortal *,float> const &)>, COMDAT
; __First$ = ecx
; __Hole$ = edx

; 5264 :     _RanIt _First, _Iter_diff_t<_RanIt> _Hole, _Iter_diff_t<_RanIt> _Top, _Ty&& _Val, _Pr _Pred) {

	push	ebp
	push	edi
	mov	edi, edx
	mov	ebp, ecx

; 5265 :     // percolate _Hole to _Top or where _Val belongs
; 5266 :     using _Diff = _Iter_diff_t<_RanIt>;
; 5267 :     for (_Diff _Idx = (_Hole - 1) >> 1; // shift for codegen
; 5268 :          _Top < _Hole && _DEBUG_LT_PRED(_Pred, *(_First + _Idx), _Val); //

	cmp	DWORD PTR __Top$[esp+4], edi
	jge	SHORT $LN14@Push_heap_
	push	ebx
	push	esi
	npad	2
$LL4@Push_heap_:
	push	DWORD PTR __Val$[esp+12]
	lea	esi, DWORD PTR [edi-1]
	sar	esi, 1
	lea	ebx, DWORD PTR [esi*8]
	add	ebx, ebp
	push	ebx
	call	DWORD PTR __Pred$[esp+20]
	add	esp, 8
	test	al, al
	je	SHORT $LN15@Push_heap_
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 288  :         first  = _STD forward<_Ty1>(_Right.first);

	mov	eax, DWORD PTR [ebx]
	mov	DWORD PTR [ebp+edi*8], eax

; 289  :         second = _STD forward<_Ty2>(_Right.second);

	fld	DWORD PTR [ebx+4]
	fstp	DWORD PTR [ebp+edi*8+4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 5272 :         _Hole             = _Idx;

	mov	edi, esi
	cmp	DWORD PTR __Top$[esp+12], esi
	jl	SHORT $LL4@Push_heap_
$LN15@Push_heap_:
	pop	esi
	pop	ebx
$LN14@Push_heap_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 288  :         first  = _STD forward<_Ty1>(_Right.first);

	mov	ecx, DWORD PTR __Val$[esp+4]
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [ebp+edi*8], eax

; 289  :         second = _STD forward<_Ty2>(_Right.second);

	fld	DWORD PTR [ecx+4]
	fstp	DWORD PTR [ebp+edi*8+4]
	pop	edi
	pop	ebp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 5276 : }

	ret	0
??$_Push_heap_by_index@PAU?$pair@PAVCPortal@@M@std@@U12@P6A_NABU12@0@Z@std@@YAXPAU?$pair@PAVCPortal@@M@0@HH$$QAU10@P6A_NABU10@2@Z@Z ENDP ; std::_Push_heap_by_index<std::pair<CPortal *,float> *,std::pair<CPortal *,float>,bool (__cdecl*)(std::pair<CPortal *,float> const &,std::pair<CPortal *,float> const &)>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
;	COMDAT ??$_Pop_heap_hole_unchecked@PAU?$pair@PAVCPortal@@M@std@@U12@P6A_NABU12@0@Z@std@@YAXPAU?$pair@PAVCPortal@@M@0@00$$QAU10@P6A_NABU10@2@Z@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Val$ = 12						; size = 4
__Pred$ = 16						; size = 4
??$_Pop_heap_hole_unchecked@PAU?$pair@PAVCPortal@@M@std@@U12@P6A_NABU12@0@Z@std@@YAXPAU?$pair@PAVCPortal@@M@0@00$$QAU10@P6A_NABU10@2@Z@Z PROC ; std::_Pop_heap_hole_unchecked<std::pair<CPortal *,float> *,std::pair<CPortal *,float>,bool (__cdecl*)(std::pair<CPortal *,float> const &,std::pair<CPortal *,float> const &)>, COMDAT
; __First$ = ecx
; __Last$ = edx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 288  :         first  = _STD forward<_Ty1>(_Right.first);

	mov	eax, DWORD PTR [ecx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 5404 : _CONSTEXPR20 void _Pop_heap_hole_unchecked(_RanIt _First, _RanIt _Last, _RanIt _Dest, _Ty&& _Val, _Pr _Pred) {

	push	esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 288  :         first  = _STD forward<_Ty1>(_Right.first);

	mov	esi, DWORD PTR __Dest$[esp]
	mov	DWORD PTR [esi], eax

; 289  :         second = _STD forward<_Ty2>(_Right.second);

	fld	DWORD PTR [ecx+4]
	fstp	DWORD PTR [esi+4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 5410 :     _Pop_heap_hole_by_index(

	pop	esi
	sub	edx, ecx
	sar	edx, 3
	mov	DWORD PTR __Dest$[esp-4], edx
	xor	edx, edx
	jmp	??$_Pop_heap_hole_by_index@PAU?$pair@PAVCPortal@@M@std@@U12@P6A_NABU12@0@Z@std@@YAXPAU?$pair@PAVCPortal@@M@0@HH$$QAU10@P6A_NABU10@2@Z@Z ; std::_Pop_heap_hole_by_index<std::pair<CPortal *,float> *,std::pair<CPortal *,float>,bool (__cdecl*)(std::pair<CPortal *,float> const &,std::pair<CPortal *,float> const &)>
??$_Pop_heap_hole_unchecked@PAU?$pair@PAVCPortal@@M@std@@U12@P6A_NABU12@0@Z@std@@YAXPAU?$pair@PAVCPortal@@M@0@00$$QAU10@P6A_NABU10@2@Z@Z ENDP ; std::_Pop_heap_hole_unchecked<std::pair<CPortal *,float> *,std::pair<CPortal *,float>,bool (__cdecl*)(std::pair<CPortal *,float> const &,std::pair<CPortal *,float> const &)>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
;	COMDAT ??$_Med3_unchecked@PAU?$pair@PAVCPortal@@M@std@@P6A_NABU12@0@Z@std@@YAXPAU?$pair@PAVCPortal@@M@0@00P6A_NABU10@1@Z@Z
_TEXT	SEGMENT
__Last$ = 8						; size = 4
__Pred$ = 12						; size = 4
??$_Med3_unchecked@PAU?$pair@PAVCPortal@@M@std@@P6A_NABU12@0@Z@std@@YAXPAU?$pair@PAVCPortal@@M@0@00P6A_NABU10@1@Z@Z PROC ; std::_Med3_unchecked<std::pair<CPortal *,float> *,bool (__cdecl*)(std::pair<CPortal *,float> const &,std::pair<CPortal *,float> const &)>, COMDAT
; __First$ = ecx
; __Mid$ = edx

; 6943 : _CONSTEXPR20 void _Med3_unchecked(_RanIt _First, _RanIt _Mid, _RanIt _Last, _Pr _Pred) {

	push	ebx
	push	ebp

; 6944 :     // sort median of three elements to middle
; 6945 :     if (_DEBUG_LT_PRED(_Pred, *_Mid, *_First)) {

	mov	ebp, DWORD PTR __Pred$[esp+4]
	push	esi
	push	edi
	mov	edi, ecx
	mov	esi, edx
	push	edi
	push	esi
	call	ebp
	add	esp, 8
	test	al, al
	je	SHORT $LN11@Med3_unche
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 318  :         if (this != _STD addressof(_Right)) {

	cmp	esi, edi
	je	SHORT $LN11@Med3_unche

; 101  :     _Left    = _STD move(_Right);

	fld	DWORD PTR [edi+4]

; 100  :     _Ty _Tmp = _STD move(_Left);

	mov	ecx, DWORD PTR [esi]

; 101  :     _Left    = _STD move(_Right);

	mov	eax, DWORD PTR [edi]

; 100  :     _Ty _Tmp = _STD move(_Left);

	movss	xmm0, DWORD PTR [esi+4]

; 101  :     _Left    = _STD move(_Right);

	fstp	DWORD PTR [esi+4]
	mov	DWORD PTR [esi], eax

; 102  :     _Right   = _STD move(_Tmp);

	mov	DWORD PTR [edi], ecx
	movss	DWORD PTR [edi+4], xmm0
$LN11@Med3_unche:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 6949 :     if (_DEBUG_LT_PRED(_Pred, *_Last, *_Mid)) { // swap middle and last, then test first again

	mov	ebx, DWORD PTR __Last$[esp+12]
	push	esi
	push	ebx
	call	ebp
	add	esp, 8
	test	al, al
	je	SHORT $LN41@Med3_unche
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 318  :         if (this != _STD addressof(_Right)) {

	cmp	ebx, esi
	je	SHORT $LN52@Med3_unche

; 101  :     _Left    = _STD move(_Right);

	fld	DWORD PTR [esi+4]

; 100  :     _Ty _Tmp = _STD move(_Left);

	mov	ecx, DWORD PTR [ebx]

; 101  :     _Left    = _STD move(_Right);

	mov	eax, DWORD PTR [esi]

; 100  :     _Ty _Tmp = _STD move(_Left);

	movss	xmm0, DWORD PTR [ebx+4]

; 101  :     _Left    = _STD move(_Right);

	fstp	DWORD PTR [ebx+4]
	mov	DWORD PTR [ebx], eax

; 102  :     _Right   = _STD move(_Tmp);

	mov	DWORD PTR [esi], ecx
	movss	DWORD PTR [esi+4], xmm0
$LN52@Med3_unche:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 6952 :         if (_DEBUG_LT_PRED(_Pred, *_Mid, *_First)) {

	push	edi
	push	esi
	call	ebp
	add	esp, 8
	test	al, al
	je	SHORT $LN41@Med3_unche
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 318  :         if (this != _STD addressof(_Right)) {

	cmp	esi, edi
	je	SHORT $LN41@Med3_unche

; 101  :     _Left    = _STD move(_Right);

	fld	DWORD PTR [edi+4]

; 100  :     _Ty _Tmp = _STD move(_Left);

	mov	ecx, DWORD PTR [esi]

; 101  :     _Left    = _STD move(_Right);

	mov	eax, DWORD PTR [edi]

; 100  :     _Ty _Tmp = _STD move(_Left);

	movss	xmm0, DWORD PTR [esi+4]

; 101  :     _Left    = _STD move(_Right);

	fstp	DWORD PTR [esi+4]
	mov	DWORD PTR [esi], eax

; 102  :     _Right   = _STD move(_Tmp);

	mov	DWORD PTR [edi], ecx
	movss	DWORD PTR [edi+4], xmm0
$LN41@Med3_unche:
	pop	edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 6956 : }

	pop	esi
	pop	ebp
	pop	ebx
	ret	0
??$_Med3_unchecked@PAU?$pair@PAVCPortal@@M@std@@P6A_NABU12@0@Z@std@@YAXPAU?$pair@PAVCPortal@@M@0@00P6A_NABU10@1@Z@Z ENDP ; std::_Med3_unchecked<std::pair<CPortal *,float> *,bool (__cdecl*)(std::pair<CPortal *,float> const &,std::pair<CPortal *,float> const &)>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
;	COMDAT ??$swap@PAVCPortal@@M$0A@@std@@YAXAAU?$pair@PAVCPortal@@M@0@0@Z
_TEXT	SEGMENT
??$swap@PAVCPortal@@M$0A@@std@@YAXAAU?$pair@PAVCPortal@@M@0@0@Z PROC ; std::swap<CPortal *,float,0>, COMDAT
; __Left$ = ecx
; __Right$ = edx

; 318  :         if (this != _STD addressof(_Right)) {

	cmp	ecx, edx
	je	SHORT $LN4@swap

; 101  :     _Left    = _STD move(_Right);

	mov	eax, DWORD PTR [edx]
	fld	DWORD PTR [edx+4]
	movss	xmm0, DWORD PTR [ecx+4]

; 100  :     _Ty _Tmp = _STD move(_Left);

	push	esi
	mov	esi, DWORD PTR [ecx]

; 101  :     _Left    = _STD move(_Right);

	mov	DWORD PTR [ecx], eax
	fstp	DWORD PTR [ecx+4]

; 102  :     _Right   = _STD move(_Tmp);

	mov	DWORD PTR [edx], esi
	movss	DWORD PTR [edx+4], xmm0
	pop	esi
$LN4@swap:

; 335  :     _Left.swap(_Right);
; 336  : }

	ret	0
??$swap@PAVCPortal@@M$0A@@std@@YAXAAU?$pair@PAVCPortal@@M@0@0@Z ENDP ; std::swap<CPortal *,float,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\type_traits
;	COMDAT ??$forward@AAPAU?$pair@PAVCPortal@@M@std@@@std@@YAAAPAU?$pair@PAVCPortal@@M@0@AAPAU10@@Z
_TEXT	SEGMENT
??$forward@AAPAU?$pair@PAVCPortal@@M@std@@@std@@YAAAPAU?$pair@PAVCPortal@@M@0@AAPAU10@@Z PROC ; std::forward<std::pair<CPortal *,float> * &>, COMDAT
; __Arg$ = ecx

; 1386 :     return static_cast<_Ty&&>(_Arg);

	mov	eax, ecx

; 1387 : }

	ret	0
??$forward@AAPAU?$pair@PAVCPortal@@M@std@@@std@@YAAAPAU?$pair@PAVCPortal@@M@0@AAPAU10@@Z ENDP ; std::forward<std::pair<CPortal *,float> * &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
;	COMDAT ?swap@?$pair@PAVCPortal@@M@std@@QAEXAAU12@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
?swap@?$pair@PAVCPortal@@M@std@@QAEXAAU12@@Z PROC	; std::pair<CPortal *,float>::swap, COMDAT
; _this$ = ecx

; 317  :         _Is_nothrow_swappable<_Ty1>::value&& _Is_nothrow_swappable<_Ty2>::value) {

	push	esi

; 318  :         if (this != _STD addressof(_Right)) {

	mov	esi, DWORD PTR __Right$[esp]
	cmp	ecx, esi
	je	SHORT $LN2@swap

; 101  :     _Left    = _STD move(_Right);

	fld	DWORD PTR [esi+4]

; 100  :     _Ty _Tmp = _STD move(_Left);

	mov	edx, DWORD PTR [ecx]

; 101  :     _Left    = _STD move(_Right);

	mov	eax, DWORD PTR [esi]

; 100  :     _Ty _Tmp = _STD move(_Left);

	movss	xmm0, DWORD PTR [ecx+4]

; 101  :     _Left    = _STD move(_Right);

	fstp	DWORD PTR [ecx+4]
	mov	DWORD PTR [ecx], eax

; 102  :     _Right   = _STD move(_Tmp);

	mov	DWORD PTR [esi], edx
	movss	DWORD PTR [esi+4], xmm0
$LN2@swap:
	pop	esi

; 319  :             _Swap_adl(first, _Right.first);
; 320  :             _Swap_adl(second, _Right.second);
; 321  :         }
; 322  :     }

	ret	4
?swap@?$pair@PAVCPortal@@M@std@@QAEXAAU12@@Z ENDP	; std::pair<CPortal *,float>::swap
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef
;	COMDAT ??$addressof@U?$pair@PAVCPortal@@M@std@@@std@@YAPAU?$pair@PAVCPortal@@M@0@AAU10@@Z
_TEXT	SEGMENT
??$addressof@U?$pair@PAVCPortal@@M@std@@@std@@YAPAU?$pair@PAVCPortal@@M@0@AAU10@@Z PROC ; std::addressof<std::pair<CPortal *,float> >, COMDAT
; __Val$ = ecx

; 253  :     return __builtin_addressof(_Val);

	mov	eax, ecx

; 254  : }

	ret	0
??$addressof@U?$pair@PAVCPortal@@M@std@@@std@@YAPAU?$pair@PAVCPortal@@M@0@AAU10@@Z ENDP ; std::addressof<std::pair<CPortal *,float> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
;	COMDAT ??$_Swap_adl@PAVCPortal@@@std@@YAXAAPAVCPortal@@0@Z
_TEXT	SEGMENT
??$_Swap_adl@PAVCPortal@@@std@@YAXAAPAVCPortal@@0@Z PROC ; std::_Swap_adl<CPortal *>, COMDAT
; __Left$ = ecx
; __Right$ = edx

; 101  :     _Left    = _STD move(_Right);

	mov	eax, DWORD PTR [edx]

; 106  : _CONSTEXPR20 void _Swap_adl(_Ty& _Left, _Ty& _Right) noexcept(_Is_nothrow_swappable<_Ty>::value) {

	push	esi

; 100  :     _Ty _Tmp = _STD move(_Left);

	mov	esi, DWORD PTR [ecx]

; 101  :     _Left    = _STD move(_Right);

	mov	DWORD PTR [ecx], eax

; 102  :     _Right   = _STD move(_Tmp);

	mov	DWORD PTR [edx], esi
	pop	esi

; 107  :     swap(_Left, _Right);
; 108  : }

	ret	0
??$_Swap_adl@PAVCPortal@@@std@@YAXAAPAVCPortal@@0@Z ENDP ; std::_Swap_adl<CPortal *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
;	COMDAT ??$swap@PAVCPortal@@$0A@@std@@YAXAAPAVCPortal@@0@Z
_TEXT	SEGMENT
??$swap@PAVCPortal@@$0A@@std@@YAXAAPAVCPortal@@0@Z PROC	; std::swap<CPortal *,0>, COMDAT
; __Left$ = ecx
; __Right$ = edx

; 100  :     _Ty _Tmp = _STD move(_Left);
; 101  :     _Left    = _STD move(_Right);

	mov	eax, DWORD PTR [edx]
	push	esi
	mov	esi, DWORD PTR [ecx]
	mov	DWORD PTR [ecx], eax

; 102  :     _Right   = _STD move(_Tmp);

	mov	DWORD PTR [edx], esi
	pop	esi

; 103  : }

	ret	0
??$swap@PAVCPortal@@$0A@@std@@YAXAAPAVCPortal@@0@Z ENDP	; std::swap<CPortal *,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrEngine\fvf.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrEngine\fvf.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrEngine\fvf.h
;	COMDAT ?set@L@FVF@@QAEXABU?$_vector3@M@@I@Z
_TEXT	SEGMENT
__p$ = 8						; size = 4
_C$ = 12						; size = 4
?set@L@FVF@@QAEXABU?$_vector3@M@@I@Z PROC		; FVF::L::set, COMDAT
; _this$ = ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 24   : 	ICF SelfRef	set(const _vector3<float> &v)			{ x = T(v.x);	y = T(v.y);	z = T(v.z);	return *this;	};

	mov	eax, DWORD PTR __p$[esp-4]
	fld	DWORD PTR [eax]
	fstp	DWORD PTR [ecx]
	fld	DWORD PTR [eax+4]
	fstp	DWORD PTR [ecx+4]
	fld	DWORD PTR [eax+8]
; File I:\Vitalya\mine\NSProjectX\xrEngine\fvf.h

; 13   : 		IC void		set(const Fvector& _p, u32 C) { p.set(_p); color = C; }

	mov	eax, DWORD PTR _C$[esp-4]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 24   : 	ICF SelfRef	set(const _vector3<float> &v)			{ x = T(v.x);	y = T(v.y);	z = T(v.z);	return *this;	};

	fstp	DWORD PTR [ecx+8]
; File I:\Vitalya\mine\NSProjectX\xrEngine\fvf.h

; 13   : 		IC void		set(const Fvector& _p, u32 C) { p.set(_p); color = C; }

	mov	DWORD PTR [ecx+12], eax
	ret	8
?set@L@FVF@@QAEXABU?$_vector3@M@@I@Z ENDP		; FVF::L::set
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_color.h
;	COMDAT ?subst_alpha@@YAIII@Z
_TEXT	SEGMENT
?subst_alpha@@YAIII@Z PROC				; subst_alpha, COMDAT
; _rgba$ = ecx
; _a$ = edx

; 21   : ICF u32 subst_alpha	(u32 rgba, u32 a)				{	return rgba&~color_rgba(0,0,0,0xff)|color_rgba(0,0,0,a);}

	and	ecx, 16777215				; 00ffffffH

; 5    : ICF u32	color_argb	(u32 a, u32 r, u32 g, u32 b)	{	return ((a&0xff)<<24)|((r&0xff)<<16)|((g&0xff)<<8)|(b&0xff);	}

	shl	edx, 24					; 00000018H

; 21   : ICF u32 subst_alpha	(u32 rgba, u32 a)				{	return rgba&~color_rgba(0,0,0,0xff)|color_rgba(0,0,0,a);}

	or	ecx, edx
	mov	eax, ecx
	ret	0
?subst_alpha@@YAIII@Z ENDP				; subst_alpha
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_color.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h
; File I:\Vitalya\mine\NSProjectX\xrCore\vector.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h
; File I:\Vitalya\mine\NSProjectX\xrCore\vector.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_color.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_color.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h
; File I:\Vitalya\mine\NSProjectX\xrCore\vector.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_color.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_color.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h
; File I:\Vitalya\mine\NSProjectX\xrCore\vector.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_color.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_color.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h
; File I:\Vitalya\mine\NSProjectX\xrCore\vector.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_color.h
;	COMDAT ?color_argb_f@@YAIMMMM@Z
_TEXT	SEGMENT
_a$ = 8							; size = 4
__g$1$ = 12						; size = 4
_a$1 = 12						; size = 4
_a$2 = 12						; size = 4
_r$ = 12						; size = 4
__b$1$ = 16						; size = 4
_a$3 = 16						; size = 4
_g$ = 16						; size = 4
_a$4 = 20						; size = 4
_b$ = 20						; size = 4
?color_argb_f@@YAIMMMM@Z PROC				; color_argb_f, COMDAT

; 9    : 	s32	 _r = clampr(iFloor(r*255.f),0,255);

	movss	xmm0, DWORD PTR _r$[esp-4]
	movss	xmm1, DWORD PTR __real@437f0000
	push	ebx
	mulss	xmm0, xmm1
	push	ebp
	push	esi
	push	edi
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h

; 83   :     int a			= *(const int*)(&x);

	movss	DWORD PTR _a$2[esp+12], xmm0

; 84   :     int exponent	= (127 + 31) - ((a >> 23) & 0xFF);

	mov	edi, 158				; 0000009eH
	mov	esi, DWORD PTR _a$2[esp+12]
	mov	ecx, edi
	mov	eax, esi

; 85   :     int r			= (((u32)(a) << 8) | (1U << 31)) >> exponent;

	mov	ebx, esi
	sar	eax, 23					; 00000017H
	or	ebx, -8388608				; ff800000H
	movzx	eax, al

; 86   :     exponent		+= 31-127;
; 87   :     {
; 88   :         int imask	=	(!(((( (1<<(exponent)))-1)>>8)&a));

	mov	ebp, 1
	sub	ecx, eax
	shl	ebx, 8
	shr	ebx, cl
	mov	eax, ebp
	sub	ecx, 96					; 00000060H

; 89   :         exponent	-=	(31-127)+32;
; 90   :         exponent	>>=	31;
; 91   :         a			>>=	31;

	mov	edx, esi
	shl	eax, cl
	dec	eax
	sar	edx, 31					; 0000001fH
	sar	eax, 8
	and	eax, esi
	neg	eax
	sbb	eax, eax
	inc	eax
	and	eax, edx

; 92   :         r			-=	(imask&a);

	sub	ebx, eax
	lea	eax, DWORD PTR [ecx+64]
	sar	eax, 31					; 0000001fH

; 93   :         r			&=	exponent;

	and	ebx, eax
; File I:\Vitalya\mine\NSProjectX\xrCore\vector.h

; 96   : 	if		( val<_low	)	return _low; 

	lea	eax, DWORD PTR [edi+97]
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h

; 93   :         r			&=	exponent;

	xor	ebx, edx
; File I:\Vitalya\mine\NSProjectX\xrCore\vector.h

; 96   : 	if		( val<_low	)	return _low; 

	jge	SHORT $LN6@color_argb
	xor	ebx, ebx
	jmp	SHORT $LN8@color_argb
$LN6@color_argb:

; 97   : 	else if	( val>_high )	return _high;

	cmp	ebx, eax
	cmovg	ebx, eax
$LN8@color_argb:
; File I:\Vitalya\mine\NSProjectX\xrCore\_color.h

; 10   : 	s32	 _g = clampr(iFloor(g*255.f),0,255);

	movss	xmm0, DWORD PTR _g$[esp+12]
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h

; 84   :     int exponent	= (127 + 31) - ((a >> 23) & 0xFF);

	mov	ecx, edi
; File I:\Vitalya\mine\NSProjectX\xrCore\_color.h

; 10   : 	s32	 _g = clampr(iFloor(g*255.f),0,255);

	mulss	xmm0, xmm1
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h

; 83   :     int a			= *(const int*)(&x);

	movss	DWORD PTR _a$1[esp+12], xmm0

; 84   :     int exponent	= (127 + 31) - ((a >> 23) & 0xFF);

	mov	esi, DWORD PTR _a$1[esp+12]
	mov	eax, esi
	sar	eax, 23					; 00000017H

; 89   :         exponent	-=	(31-127)+32;
; 90   :         exponent	>>=	31;
; 91   :         a			>>=	31;

	mov	edx, esi
	movzx	eax, al
	sub	ecx, eax
	sar	edx, 31					; 0000001fH
	mov	eax, esi
	or	eax, -8388608				; ff800000H
	shl	eax, 8
	shr	eax, cl
	sub	ecx, 96					; 00000060H
	mov	DWORD PTR __g$1$[esp+12], eax
	mov	eax, ebp
	shl	eax, cl
	dec	eax
	sar	eax, 8
	and	eax, esi
	neg	eax
	sbb	eax, eax
	inc	eax
	and	eax, edx

; 92   :         r			-=	(imask&a);

	sub	DWORD PTR __g$1$[esp+12], eax
	lea	eax, DWORD PTR [ecx+64]

; 93   :         r			&=	exponent;

	mov	ecx, DWORD PTR __g$1$[esp+12]
	sar	eax, 31					; 0000001fH
	and	ecx, eax
	xor	ecx, edx
; File I:\Vitalya\mine\NSProjectX\xrCore\vector.h

; 96   : 	if		( val<_low	)	return _low; 

	jge	SHORT $LN14@color_argb
	mov	DWORD PTR __g$1$[esp+12], 0
	jmp	SHORT $LN16@color_argb
$LN14@color_argb:

; 97   : 	else if	( val>_high )	return _high;

	cmp	ecx, 255				; 000000ffH
	mov	eax, 255				; 000000ffH
	cmovg	ecx, eax
	mov	DWORD PTR __g$1$[esp+12], ecx
$LN16@color_argb:
; File I:\Vitalya\mine\NSProjectX\xrCore\_color.h

; 11   : 	s32	 _b = clampr(iFloor(b*255.f),0,255);

	movss	xmm0, DWORD PTR _b$[esp+12]
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h

; 84   :     int exponent	= (127 + 31) - ((a >> 23) & 0xFF);

	mov	ecx, edi
; File I:\Vitalya\mine\NSProjectX\xrCore\_color.h

; 11   : 	s32	 _b = clampr(iFloor(b*255.f),0,255);

	mulss	xmm0, xmm1
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h

; 83   :     int a			= *(const int*)(&x);

	movss	DWORD PTR _a$3[esp+12], xmm0

; 84   :     int exponent	= (127 + 31) - ((a >> 23) & 0xFF);

	mov	esi, DWORD PTR _a$3[esp+12]
	mov	eax, esi
	sar	eax, 23					; 00000017H

; 89   :         exponent	-=	(31-127)+32;
; 90   :         exponent	>>=	31;
; 91   :         a			>>=	31;

	mov	edx, esi
	movzx	eax, al
	sub	ecx, eax
	sar	edx, 31					; 0000001fH
	mov	eax, esi
	or	eax, -8388608				; ff800000H
	shl	eax, 8
	shr	eax, cl
	sub	ecx, 96					; 00000060H
	mov	DWORD PTR __b$1$[esp+12], eax
	mov	eax, ebp
	shl	eax, cl
	dec	eax
	sar	eax, 8
	and	eax, esi
	neg	eax
	sbb	eax, eax
	inc	eax
	and	eax, edx

; 92   :         r			-=	(imask&a);

	sub	DWORD PTR __b$1$[esp+12], eax
	lea	eax, DWORD PTR [ecx+64]

; 93   :         r			&=	exponent;

	mov	ecx, DWORD PTR __b$1$[esp+12]
	sar	eax, 31					; 0000001fH
	and	ecx, eax
	xor	ecx, edx
; File I:\Vitalya\mine\NSProjectX\xrCore\vector.h

; 96   : 	if		( val<_low	)	return _low; 

	jge	SHORT $LN22@color_argb
	mov	DWORD PTR __b$1$[esp+12], 0
	jmp	SHORT $LN24@color_argb
$LN22@color_argb:

; 97   : 	else if	( val>_high )	return _high;

	cmp	ecx, 255				; 000000ffH
	mov	eax, 255				; 000000ffH
	cmovg	ecx, eax
	mov	DWORD PTR __b$1$[esp+12], ecx
$LN24@color_argb:
; File I:\Vitalya\mine\NSProjectX\xrCore\_color.h

; 12   : 	s32	 _a = clampr(iFloor(a*255.f),0,255);

	movss	xmm0, DWORD PTR _a$[esp+12]
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h

; 84   :     int exponent	= (127 + 31) - ((a >> 23) & 0xFF);

	mov	ecx, edi
; File I:\Vitalya\mine\NSProjectX\xrCore\_color.h

; 12   : 	s32	 _a = clampr(iFloor(a*255.f),0,255);

	mulss	xmm0, xmm1
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h

; 83   :     int a			= *(const int*)(&x);

	movss	DWORD PTR _a$4[esp+12], xmm0

; 84   :     int exponent	= (127 + 31) - ((a >> 23) & 0xFF);

	mov	esi, DWORD PTR _a$4[esp+12]
	mov	eax, esi
	sar	eax, 23					; 00000017H

; 85   :     int r			= (((u32)(a) << 8) | (1U << 31)) >> exponent;

	mov	edi, esi
	or	edi, -8388608				; ff800000H
	movzx	eax, al
	sub	ecx, eax
	shl	edi, 8
	shr	edi, cl

; 89   :         exponent	-=	(31-127)+32;
; 90   :         exponent	>>=	31;
; 91   :         a			>>=	31;

	mov	edx, esi
	sub	ecx, 96					; 00000060H
	sar	edx, 31					; 0000001fH
	shl	ebp, cl
	dec	ebp
	sar	ebp, 8
	and	ebp, esi
	lea	eax, DWORD PTR [ecx+64]
	neg	ebp
	sbb	ebp, ebp
	sar	eax, 31					; 0000001fH
	inc	ebp
	and	ebp, edx

; 92   :         r			-=	(imask&a);

	sub	edi, ebp

; 93   :         r			&=	exponent;

	and	edi, eax
	xor	edi, edx
; File I:\Vitalya\mine\NSProjectX\xrCore\vector.h

; 96   : 	if		( val<_low	)	return _low; 

	jge	SHORT $LN30@color_argb
	xor	edi, edi
	jmp	SHORT $LN32@color_argb
$LN30@color_argb:

; 97   : 	else if	( val>_high )	return _high;

	cmp	edi, 255				; 000000ffH
	mov	eax, 255				; 000000ffH
	cmovg	edi, eax
$LN32@color_argb:
; File I:\Vitalya\mine\NSProjectX\xrCore\_color.h

; 5    : ICF u32	color_argb	(u32 a, u32 r, u32 g, u32 b)	{	return ((a&0xff)<<24)|((r&0xff)<<16)|((g&0xff)<<8)|(b&0xff);	}

	mov	ecx, DWORD PTR __g$1$[esp+12]
	movzx	eax, bl
	shl	edi, 8
	or	eax, edi
	movzx	ecx, cl
	shl	eax, 8
	or	eax, ecx
	mov	ecx, DWORD PTR __b$1$[esp+12]

; 13   : 	return color_argb(_a,_r,_g,_b);

	pop	edi
	pop	esi

; 5    : ICF u32	color_argb	(u32 a, u32 r, u32 g, u32 b)	{	return ((a&0xff)<<24)|((r&0xff)<<16)|((g&0xff)<<8)|(b&0xff);	}

	shl	eax, 8
	movzx	ecx, cl

; 13   : 	return color_argb(_a,_r,_g,_b);

	pop	ebp

; 5    : ICF u32	color_argb	(u32 a, u32 r, u32 g, u32 b)	{	return ((a&0xff)<<24)|((r&0xff)<<16)|((g&0xff)<<8)|(b&0xff);	}

	or	eax, ecx

; 13   : 	return color_argb(_a,_r,_g,_b);

	pop	ebx

; 14   : }

	ret	0
?color_argb_f@@YAIMMMM@Z ENDP				; color_argb_f
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_color.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h
; File I:\Vitalya\mine\NSProjectX\xrCore\vector.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h
; File I:\Vitalya\mine\NSProjectX\xrCore\vector.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_color.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_color.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h
; File I:\Vitalya\mine\NSProjectX\xrCore\vector.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_color.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_color.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h
; File I:\Vitalya\mine\NSProjectX\xrCore\vector.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_color.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_color.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h
; File I:\Vitalya\mine\NSProjectX\xrCore\vector.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_color.h
;	COMDAT ?color_rgba_f@@YAIMMMM@Z
_TEXT	SEGMENT
__g$1$ = 8						; size = 4
_a$1 = 8						; size = 4
_a$2 = 8						; size = 4
_r$ = 8							; size = 4
__b$1$ = 12						; size = 4
_a$3 = 12						; size = 4
_g$ = 12						; size = 4
_a$4 = 16						; size = 4
_b$ = 16						; size = 4
_a$ = 20						; size = 4
?color_rgba_f@@YAIMMMM@Z PROC				; color_rgba_f, COMDAT

; 9    : 	s32	 _r = clampr(iFloor(r*255.f),0,255);

	movss	xmm0, DWORD PTR _r$[esp-4]
	movss	xmm1, DWORD PTR __real@437f0000

; 15   : ICF u32	color_rgba_f(f32 r, f32 g, f32 b, f32 a)	{	return color_argb_f(a,r,g,b);	}

	push	ebx

; 9    : 	s32	 _r = clampr(iFloor(r*255.f),0,255);

	mulss	xmm0, xmm1

; 15   : ICF u32	color_rgba_f(f32 r, f32 g, f32 b, f32 a)	{	return color_argb_f(a,r,g,b);	}

	push	ebp
	push	esi
	push	edi
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h

; 83   :     int a			= *(const int*)(&x);

	movss	DWORD PTR _a$2[esp+12], xmm0

; 84   :     int exponent	= (127 + 31) - ((a >> 23) & 0xFF);

	mov	edi, 158				; 0000009eH
	mov	esi, DWORD PTR _a$2[esp+12]
	mov	ecx, edi
	mov	eax, esi

; 85   :     int r			= (((u32)(a) << 8) | (1U << 31)) >> exponent;

	mov	ebx, esi
	sar	eax, 23					; 00000017H
	or	ebx, -8388608				; ff800000H
	movzx	eax, al

; 86   :     exponent		+= 31-127;
; 87   :     {
; 88   :         int imask	=	(!(((( (1<<(exponent)))-1)>>8)&a));

	mov	ebp, 1
	sub	ecx, eax
	shl	ebx, 8
	shr	ebx, cl
	mov	eax, ebp
	sub	ecx, 96					; 00000060H

; 89   :         exponent	-=	(31-127)+32;
; 90   :         exponent	>>=	31;
; 91   :         a			>>=	31;

	mov	edx, esi
	shl	eax, cl
	dec	eax
	sar	edx, 31					; 0000001fH
	sar	eax, 8
	and	eax, esi
	neg	eax
	sbb	eax, eax
	inc	eax
	and	eax, edx

; 92   :         r			-=	(imask&a);

	sub	ebx, eax
	lea	eax, DWORD PTR [ecx+64]
	sar	eax, 31					; 0000001fH

; 93   :         r			&=	exponent;

	and	ebx, eax
; File I:\Vitalya\mine\NSProjectX\xrCore\vector.h

; 96   : 	if		( val<_low	)	return _low; 

	lea	eax, DWORD PTR [edi+97]
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h

; 93   :         r			&=	exponent;

	xor	ebx, edx
; File I:\Vitalya\mine\NSProjectX\xrCore\vector.h

; 96   : 	if		( val<_low	)	return _low; 

	jge	SHORT $LN8@color_rgba
	xor	ebx, ebx
	jmp	SHORT $LN10@color_rgba
$LN8@color_rgba:

; 97   : 	else if	( val>_high )	return _high;

	cmp	ebx, eax
	cmovg	ebx, eax
$LN10@color_rgba:
; File I:\Vitalya\mine\NSProjectX\xrCore\_color.h

; 10   : 	s32	 _g = clampr(iFloor(g*255.f),0,255);

	movss	xmm0, DWORD PTR _g$[esp+12]
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h

; 84   :     int exponent	= (127 + 31) - ((a >> 23) & 0xFF);

	mov	ecx, edi
; File I:\Vitalya\mine\NSProjectX\xrCore\_color.h

; 10   : 	s32	 _g = clampr(iFloor(g*255.f),0,255);

	mulss	xmm0, xmm1
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h

; 83   :     int a			= *(const int*)(&x);

	movss	DWORD PTR _a$1[esp+12], xmm0

; 84   :     int exponent	= (127 + 31) - ((a >> 23) & 0xFF);

	mov	esi, DWORD PTR _a$1[esp+12]
	mov	eax, esi
	sar	eax, 23					; 00000017H

; 89   :         exponent	-=	(31-127)+32;
; 90   :         exponent	>>=	31;
; 91   :         a			>>=	31;

	mov	edx, esi
	movzx	eax, al
	sub	ecx, eax
	sar	edx, 31					; 0000001fH
	mov	eax, esi
	or	eax, -8388608				; ff800000H
	shl	eax, 8
	shr	eax, cl
	sub	ecx, 96					; 00000060H
	mov	DWORD PTR __g$1$[esp+12], eax
	mov	eax, ebp
	shl	eax, cl
	dec	eax
	sar	eax, 8
	and	eax, esi
	neg	eax
	sbb	eax, eax
	inc	eax
	and	eax, edx

; 92   :         r			-=	(imask&a);

	sub	DWORD PTR __g$1$[esp+12], eax
	lea	eax, DWORD PTR [ecx+64]

; 93   :         r			&=	exponent;

	mov	ecx, DWORD PTR __g$1$[esp+12]
	sar	eax, 31					; 0000001fH
	and	ecx, eax
	xor	ecx, edx
; File I:\Vitalya\mine\NSProjectX\xrCore\vector.h

; 96   : 	if		( val<_low	)	return _low; 

	jge	SHORT $LN16@color_rgba
	mov	DWORD PTR __g$1$[esp+12], 0
	jmp	SHORT $LN18@color_rgba
$LN16@color_rgba:

; 97   : 	else if	( val>_high )	return _high;

	cmp	ecx, 255				; 000000ffH
	mov	eax, 255				; 000000ffH
	cmovg	ecx, eax
	mov	DWORD PTR __g$1$[esp+12], ecx
$LN18@color_rgba:
; File I:\Vitalya\mine\NSProjectX\xrCore\_color.h

; 11   : 	s32	 _b = clampr(iFloor(b*255.f),0,255);

	movss	xmm0, DWORD PTR _b$[esp+12]
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h

; 84   :     int exponent	= (127 + 31) - ((a >> 23) & 0xFF);

	mov	ecx, edi
; File I:\Vitalya\mine\NSProjectX\xrCore\_color.h

; 11   : 	s32	 _b = clampr(iFloor(b*255.f),0,255);

	mulss	xmm0, xmm1
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h

; 83   :     int a			= *(const int*)(&x);

	movss	DWORD PTR _a$3[esp+12], xmm0

; 84   :     int exponent	= (127 + 31) - ((a >> 23) & 0xFF);

	mov	esi, DWORD PTR _a$3[esp+12]
	mov	eax, esi
	sar	eax, 23					; 00000017H

; 89   :         exponent	-=	(31-127)+32;
; 90   :         exponent	>>=	31;
; 91   :         a			>>=	31;

	mov	edx, esi
	movzx	eax, al
	sub	ecx, eax
	sar	edx, 31					; 0000001fH
	mov	eax, esi
	or	eax, -8388608				; ff800000H
	shl	eax, 8
	shr	eax, cl
	sub	ecx, 96					; 00000060H
	mov	DWORD PTR __b$1$[esp+12], eax
	mov	eax, ebp
	shl	eax, cl
	dec	eax
	sar	eax, 8
	and	eax, esi
	neg	eax
	sbb	eax, eax
	inc	eax
	and	eax, edx

; 92   :         r			-=	(imask&a);

	sub	DWORD PTR __b$1$[esp+12], eax
	lea	eax, DWORD PTR [ecx+64]

; 93   :         r			&=	exponent;

	mov	ecx, DWORD PTR __b$1$[esp+12]
	sar	eax, 31					; 0000001fH
	and	ecx, eax
	xor	ecx, edx
; File I:\Vitalya\mine\NSProjectX\xrCore\vector.h

; 96   : 	if		( val<_low	)	return _low; 

	jge	SHORT $LN24@color_rgba
	mov	DWORD PTR __b$1$[esp+12], 0
	jmp	SHORT $LN26@color_rgba
$LN24@color_rgba:

; 97   : 	else if	( val>_high )	return _high;

	cmp	ecx, 255				; 000000ffH
	mov	eax, 255				; 000000ffH
	cmovg	ecx, eax
	mov	DWORD PTR __b$1$[esp+12], ecx
$LN26@color_rgba:
; File I:\Vitalya\mine\NSProjectX\xrCore\_color.h

; 12   : 	s32	 _a = clampr(iFloor(a*255.f),0,255);

	movss	xmm0, DWORD PTR _a$[esp+12]
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h

; 84   :     int exponent	= (127 + 31) - ((a >> 23) & 0xFF);

	mov	ecx, edi
; File I:\Vitalya\mine\NSProjectX\xrCore\_color.h

; 12   : 	s32	 _a = clampr(iFloor(a*255.f),0,255);

	mulss	xmm0, xmm1
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h

; 83   :     int a			= *(const int*)(&x);

	movss	DWORD PTR _a$4[esp+12], xmm0

; 84   :     int exponent	= (127 + 31) - ((a >> 23) & 0xFF);

	mov	esi, DWORD PTR _a$4[esp+12]
	mov	eax, esi
	sar	eax, 23					; 00000017H

; 85   :     int r			= (((u32)(a) << 8) | (1U << 31)) >> exponent;

	mov	edi, esi
	or	edi, -8388608				; ff800000H
	movzx	eax, al
	sub	ecx, eax
	shl	edi, 8
	shr	edi, cl

; 89   :         exponent	-=	(31-127)+32;
; 90   :         exponent	>>=	31;
; 91   :         a			>>=	31;

	mov	edx, esi
	sub	ecx, 96					; 00000060H
	sar	edx, 31					; 0000001fH
	shl	ebp, cl
	dec	ebp
	sar	ebp, 8
	and	ebp, esi
	lea	eax, DWORD PTR [ecx+64]
	neg	ebp
	sbb	ebp, ebp
	sar	eax, 31					; 0000001fH
	inc	ebp
	and	ebp, edx

; 92   :         r			-=	(imask&a);

	sub	edi, ebp

; 93   :         r			&=	exponent;

	and	edi, eax
	xor	edi, edx
; File I:\Vitalya\mine\NSProjectX\xrCore\vector.h

; 96   : 	if		( val<_low	)	return _low; 

	jge	SHORT $LN32@color_rgba
	xor	edi, edi
	jmp	SHORT $LN34@color_rgba
$LN32@color_rgba:

; 97   : 	else if	( val>_high )	return _high;

	cmp	edi, 255				; 000000ffH
	mov	eax, 255				; 000000ffH
	cmovg	edi, eax
$LN34@color_rgba:
; File I:\Vitalya\mine\NSProjectX\xrCore\_color.h

; 5    : ICF u32	color_argb	(u32 a, u32 r, u32 g, u32 b)	{	return ((a&0xff)<<24)|((r&0xff)<<16)|((g&0xff)<<8)|(b&0xff);	}

	mov	ecx, DWORD PTR __g$1$[esp+12]
	movzx	eax, bl
	shl	edi, 8
	or	eax, edi
	movzx	ecx, cl
	shl	eax, 8
	or	eax, ecx
	mov	ecx, DWORD PTR __b$1$[esp+12]

; 15   : ICF u32	color_rgba_f(f32 r, f32 g, f32 b, f32 a)	{	return color_argb_f(a,r,g,b);	}

	pop	edi
	pop	esi

; 5    : ICF u32	color_argb	(u32 a, u32 r, u32 g, u32 b)	{	return ((a&0xff)<<24)|((r&0xff)<<16)|((g&0xff)<<8)|(b&0xff);	}

	shl	eax, 8
	movzx	ecx, cl

; 15   : ICF u32	color_rgba_f(f32 r, f32 g, f32 b, f32 a)	{	return color_argb_f(a,r,g,b);	}

	pop	ebp

; 5    : ICF u32	color_argb	(u32 a, u32 r, u32 g, u32 b)	{	return ((a&0xff)<<24)|((r&0xff)<<16)|((g&0xff)<<8)|(b&0xff);	}

	or	eax, ecx

; 15   : ICF u32	color_rgba_f(f32 r, f32 g, f32 b, f32 a)	{	return color_argb_f(a,r,g,b);	}

	pop	ebx
	ret	0
?color_rgba_f@@YAIMMMM@Z ENDP				; color_rgba_f
_TEXT	ENDS
END
