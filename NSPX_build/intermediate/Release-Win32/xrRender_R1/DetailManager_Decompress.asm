; Listing generated by Microsoft (R) Optimizing Compiler Version 19.29.30146.0 

	TITLE	i:\vitalya\mine\nsprojectx\nspx_build\intermediate\release-win32\xrrender_r1\detailmanager_decompress.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

EXTRN	__imp_?r_begin@COLLIDER@CDB@@QAEPAURESULT@2@XZ:PROC
EXTRN	__imp_?r_begin@xrXRC@@QAEPAURESULT@CDB@@XZ:PROC
EXTRN	__imp_?get_verts@MODEL@CDB@@QAEPAU?$_vector3@M@@XZ:PROC
EXTRN	__imp_?GetStaticVerts@CObjectSpace@@QAEPAU?$_vector3@M@@XZ:PROC
EXTRN	__imp_?get_tris@MODEL@CDB@@QAEPAVTRI@2@XZ:PROC
EXTRN	__imp_?GetStaticTris@CObjectSpace@@QAEPAVTRI@CDB@@XZ:PROC
EXTRN	__imp_?r_count@COLLIDER@CDB@@QAEHXZ:PROC
EXTRN	__imp_?r_count@xrXRC@@QAEHXZ:PROC
EXTRN	__imp_?g_pGameLevel@@3PAVIGame_Level@@A:DWORD
EXTRN	__imp_?GetStaticModel@CObjectSpace@@QAEPAVMODEL@CDB@@XZ:PROC
EXTRN	__imp_?box_query@xrXRC@@QAEXPBVMODEL@CDB@@ABU?$_vector3@M@@1@Z:PROC
EXTRN	__imp_?box_options@COLLIDER@CDB@@QAEXI@Z:PROC
EXTRN	__imp_?box_options@xrXRC@@QAEXI@Z:PROC
PUBLIC	?sub@?$_vector3@M@@QAEAAU1@ABU1@0@Z		; _vector3<float>::sub
PUBLIC	?dotproduct@?$_vector3@M@@QBEMABU1@@Z		; _vector3<float>::dotproduct
PUBLIC	?crossproduct@?$_vector3@M@@QAEAAU1@ABU1@0@Z	; _vector3<float>::crossproduct
PUBLIC	??$clamp@H@@YAXAAHABH1@Z			; clamp<int>
PUBLIC	?size@?$xr_vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@@QBEIXZ ; xr_vector<CDB::RESULT,xalloc<CDB::RESULT> >::size
PUBLIC	?size@?$vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@std@@QBEIXZ ; std::vector<CDB::RESULT,xalloc<CDB::RESULT> >::size
PUBLIC	?iCeil@@YAHM@Z					; iCeil
PUBLIC	??0CRandom@@QAE@H@Z				; CRandom::CRandom
PUBLIC	?randFs@CRandom@@QAEMM@Z			; CRandom::randFs
PUBLIC	?randF@CRandom@@QAEMMM@Z			; CRandom::randF
PUBLIC	?randF@CRandom@@QAEMM@Z				; CRandom::randF
PUBLIC	?randF@CRandom@@QAEMXZ				; CRandom::randF
PUBLIC	?maxF@CRandom@@QAEMXZ				; CRandom::maxF
PUBLIC	?begin@?$vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@URESULT@CDB@@@std@@@std@@@2@XZ ; std::vector<CDB::RESULT,xalloc<CDB::RESULT> >::begin
PUBLIC	??$addressof@V?$_Vector_val@U?$_Simple_types@URESULT@CDB@@@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@URESULT@CDB@@@std@@@0@AAV10@@Z ; std::addressof<std::_Vector_val<std::_Simple_types<CDB::RESULT> > >
PUBLIC	??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@URESULT@CDB@@@std@@@std@@@std@@QAE@PAURESULT@CDB@@PBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CDB::RESULT> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<CDB::RESULT> > >
PUBLIC	??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@URESULT@CDB@@@std@@@std@@@std@@QAE@PAURESULT@CDB@@PBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CDB::RESULT> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CDB::RESULT> > >
PUBLIC	??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@URESULT@CDB@@@std@@@std@@@std@@QBEAAURESULT@CDB@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CDB::RESULT> > >::operator*
PUBLIC	??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@URESULT@CDB@@@std@@@std@@@std@@QBEABURESULT@CDB@@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CDB::RESULT> > >::operator*
PUBLIC	?mul_43@?$_matrix@M@@QAEAAU1@ABU1@0@Z		; _matrix<float>::mul_43
PUBLIC	?r_qclr@DetailSlot@@QAEMII@Z			; DetailSlot::r_qclr
PUBLIC	?mul@?$_vector3@M@@QAEAAU1@M@Z			; _vector3<float>::mul
PUBLIC	?transform_tiny@?$_matrix@M@@QBEXAAU?$_vector3@M@@ABU2@@Z ; _matrix<float>::transform_tiny
PUBLIC	?set@?$_vector3@M@@QAEAAU1@ABU1@@Z		; _vector3<float>::set
PUBLIC	?negative@@YAHABM@Z				; negative
PUBLIC	?_cos@@YAMM@Z					; _cos
PUBLIC	_cosf
PUBLIC	?_sin@@YAMM@Z					; _sin
PUBLIC	_sinf
PUBLIC	?identity@?$_matrix@M@@QAEAAU1@XZ		; _matrix<float>::identity
PUBLIC	??$xr_alloc@USlotItem@CDetailManager@@@@YAPAUSlotItem@CDetailManager@@I@Z ; xr_alloc<CDetailManager::SlotItem>
PUBLIC	??$clamp@I@@YAXAAIABI1@Z			; clamp<unsigned int>
PUBLIC	?mul@?$_vector3@M@@QAEAAU1@ABU1@M@Z		; _vector3<float>::mul
PUBLIC	?block_create@?$poolSS@USlotItem@CDetailManager@@$0BAAA@@@AAEXXZ ; poolSS<CDetailManager::SlotItem,4096>::block_create
PUBLIC	?add@?$_vector3@M@@QAEAAU1@ABU1@0@Z		; _vector3<float>::add
PUBLIC	?translate_over@?$_matrix@M@@QAEAAU1@ABU?$_vector3@M@@@Z ; _matrix<float>::translate_over
PUBLIC	?scale@?$_matrix@M@@QAEAAU1@MMM@Z		; _matrix<float>::scale
PUBLIC	?rotateY@?$_matrix@M@@QAEAAU1@M@Z		; _matrix<float>::rotateY
PUBLIC	?set@?$_box3@M@@QAEAAV1@ABV1@@Z			; _box3<float>::set
PUBLIC	?xform@?$_box3@M@@QAEAAV1@ABV1@ABU?$_matrix@M@@@Z ; _box3<float>::xform
PUBLIC	?get_CD@?$_box3@M@@QBEABV1@AAU?$_vector3@M@@0@Z	; _box3<float>::get_CD
PUBLIC	?create@?$poolSS@USlotItem@CDetailManager@@$0BAAA@@@QAEPAUSlotItem@CDetailManager@@XZ ; poolSS<CDetailManager::SlotItem,4096>::create
PUBLIC	??0?$svector@H$03@@QAE@XZ			; svector<int,4>::svector<int,4>
PUBLIC	?size@?$svector@H$03@@QBEIXZ			; svector<int,4>::size
PUBLIC	?clear@?$svector@H$03@@QAEXXZ			; svector<int,4>::clear
PUBLIC	?push_back@?$svector@H$03@@QAEXH@Z		; svector<int,4>::push_back
PUBLIC	??A?$svector@H$03@@QAEAAHI@Z			; svector<int,4>::operator[]
PUBLIC	?empty@?$svector@H$03@@QBE_NXZ			; svector<int,4>::empty
PUBLIC	?InterpolateAndDither@@YA_NPAMIIIIIQAY0BA@H@Z	; InterpolateAndDither
PUBLIC	?Interpolate@@YAMPAMIII@Z			; Interpolate
PUBLIC	?TestRayTri@CDB@@YA_NABU?$_vector3@M@@0PAU2@AAM22_N@Z ; CDB::TestRayTri
PUBLIC	?cache_Decompress@CDetailManager@@QAEXPAUSlot@1@@Z ; CDetailManager::cache_Decompress
_DATA	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	04H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:?cache_Decompress@CDetailManager@@QAEXPAUSlot@1@@Z
	DD	03c8H
	DD	03cfH
	DD	03d3H
	DD	03daH
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_Decompress.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_Decompress.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_Decompress.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCDB\xrCDB.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_Decompress.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_Decompress.cpp
; File I:\Vitalya\mine\NSProjectX\xrEngine\xr_area.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrEngine\xr_area.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_Decompress.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCDB\xrCDB.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_Decompress.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_Decompress.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_Decompress.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h
; File I:\Vitalya\mine\NSProjectX\xrCore\FixedVector.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_Decompress.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_Decompress.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_Decompress.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_Decompress.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_Decompress.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_Decompress.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_Decompress.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_Decompress.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_random.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_Decompress.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_random.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_Decompress.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\vector.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_Decompress.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\vector.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_Decompress.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_Decompress.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h
; File I:\Vitalya\mine\NSProjectX\xrCore\vector.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_Decompress.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\FixedVector.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_Decompress.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\vector.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_Decompress.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\vector.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_Decompress.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_Decompress.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h
; File I:\Vitalya\mine\NSProjectX\xrCore\vector.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_Decompress.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\FixedVector.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_Decompress.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\vector.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_Decompress.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\vector.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_Decompress.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_Decompress.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h
; File I:\Vitalya\mine\NSProjectX\xrCore\vector.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_Decompress.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\FixedVector.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_Decompress.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\vector.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_Decompress.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\vector.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_Decompress.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_Decompress.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h
; File I:\Vitalya\mine\NSProjectX\xrCore\vector.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_Decompress.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\FixedVector.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_Decompress.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_random.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_Decompress.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\detailformat.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_Decompress.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xrPool.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_Decompress.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xrPool.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_Decompress.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xrPool.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xrPool.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrPool.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_Decompress.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xrPool.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_Decompress.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_random.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_Decompress.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_random.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_Decompress.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_random.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_Decompress.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_random.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_Decompress.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_random.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_Decompress.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xrPool.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_Decompress.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_Decompress.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_Decompress.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_Decompress.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_Decompress.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_Decompress.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_Decompress.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_Decompress.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_Decompress.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_Decompress.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\cl_intersect.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\cl_intersect.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\cl_intersect.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_Decompress.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\cl_intersect.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_Decompress.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\cl_intersect.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_Decompress.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_random.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_Decompress.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_random.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_Decompress.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_random.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_random.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_std_extensions.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_Decompress.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\detailformat.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_Decompress.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\detailformat.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_Decompress.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\detailformat.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_Decompress.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\detailformat.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_Decompress.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\detailformat.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_Decompress.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\detailmanager.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_Decompress.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_flags.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_Decompress.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_random.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_Decompress.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_Decompress.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_Decompress.cpp
_TEXT	SEGMENT
_c$2$ = -388						; size = 4
_c$2$ = -388						; size = 4
_c$2$ = -388						; size = 4
_c$2$ = -388						; size = 4
_index$1$ = -388					; size = 4
_fy$8 = -388						; size = 4
_a$9 = -388						; size = 4
_fy$10 = -388						; size = 4
_a$11 = -388						; size = 4
_fy$12 = -388						; size = 4
_a$13 = -388						; size = 4
_fy$14 = -388						; size = 4
_a$15 = -388						; size = 4
_a$16 = -388						; size = 4
_edge1$3$sroa$91$1$ = -384				; size = 4
tv4754 = -384						; size = 4
tv4482 = -384						; size = 4
_fx$17 = -384						; size = 4
_fx$18 = -384						; size = 4
_fx$19 = -384						; size = 4
_Item_P$1$sroa$187$1$ = -380				; size = 4
tv4956 = -380						; size = 4
tv4580 = -380						; size = 4
tv4535 = -380						; size = 4
tv4489 = -380						; size = 4
tv4444 = -380						; size = 4
tv1422 = -380						; size = 4
_y$1$ = -376						; size = 4
_shift_z$1$ = -376					; size = 4
_E$1$ = -372						; size = 4
tv4953 = -372						; size = 4
tv4584 = -372						; size = 4
tv4539 = -372						; size = 4
tv4493 = -372						; size = 4
tv4448 = -372						; size = 4
tv5566 = -368						; size = 4
tv5561 = -368						; size = 4
tv5558 = -368						; size = 4
tv5523 = -368						; size = 4
tv5518 = -368						; size = 4
tv5515 = -368						; size = 4
tv5480 = -368						; size = 4
tv5475 = -368						; size = 4
tv5472 = -368						; size = 4
tv5437 = -368						; size = 4
tv5432 = -368						; size = 4
tv5429 = -368						; size = 4
_ItemP$20 = -368					; size = 4
_ItemBB$1$ = -364					; size = 4
_Dobj$1$ = -364						; size = 4
tv5251 = -364						; size = 4
tv5112 = -364						; size = 4
tv5111 = -364						; size = 4
tv5110 = -364						; size = 4
tv4955 = -364						; size = 4
_cosa$21 = -364						; size = 4
_Item_P$1$sroa$174$1$ = -360				; size = 4
tv4756 = -360						; size = 4
tv2174 = -360						; size = 4
tv1414 = -360						; size = 4
_d_size$1$ = -356					; size = 4
_edge1$3$sroa$93$1$ = -352				; size = 4
tv4573 = -352						; size = 4
_fx$22 = -352						; size = 4
_DS$1$ = -348						; size = 4
_x$1$ = -344						; size = 4
_z$1$ = -340						; size = 4
_edge1$3$sroa$95$1$ = -336				; size = 4
_shift_x$1$ = -336					; size = 4
_Bounds$2$ = -332					; size = 4
_Bounds$6$ = -328					; size = 4
_edge2$4$sroa$82$1$ = -324				; size = 4
tv5388 = -324						; size = 4
tv5385 = -324						; size = 4
tv5382 = -324						; size = 4
tv4948 = -324						; size = 4
_this$1$ = -320						; size = 4
_Bounds$4$ = -316					; size = 4
_Bounds$8$ = -312					; size = 4
_Bounds$10$ = -308					; size = 4
_Bounds$12$ = -304					; size = 4
_Item_P$1$sroa$186$1$ = -300				; size = 4
tv4800 = -300						; size = 4
tv5060 = -296						; size = 4
tv4797 = -296						; size = 4
_r_jitter$ = -292					; size = 4
_pvec$5$sroa$79$1$ = -288				; size = 4
tv4950 = -288						; size = 4
_edge2$4$sroa$89$1$ = -284				; size = 4
tv4949 = -284						; size = 4
_vz$23 = -280						; size = 12
_vy$24 = -268						; size = 12
_alpha255$3$ = -256					; size = 4
_alpha255$2$ = -252					; size = 4
_alpha255$4$ = -248					; size = 4
_alpha255$5$ = -244					; size = 4
_alpha255$8$ = -240					; size = 4
_alpha255$13$ = -236					; size = 4
_alpha255$14$ = -232					; size = 4
_alpha255$16$ = -228					; size = 4
_alpha255$10$ = -224					; size = 4
_alpha255$9$ = -220					; size = 4
_alpha255$6$ = -216					; size = 4
_alpha255$12$ = -212					; size = 4
_selected$ = -208					; size = 20
_Tv$25 = -188						; size = 36
_alpha255$1$ = -152					; size = 4
_alpha255$7$ = -148					; size = 4
_alpha255$11$ = -144					; size = 4
_alpha255$15$ = -140					; size = 4
_r_selection$ = -136					; size = 4
_density$1$ = -132					; size = 4
_jitter$1$ = -128					; size = 4
_triCount$1$ = -124					; size = 4
_verts$1$ = -120					; size = 4
tv5026 = -116						; size = 4
_tris$1$ = -112						; size = 4
_r_scale$ = -108					; size = 4
_r_yaw$ = -104						; size = 4
_vx$26 = -100						; size = 12
_bD$ = -88						; size = 12
_bC$ = -76						; size = 12
_S$ = 8							; size = 4
?cache_Decompress@CDetailManager@@QAEXPAUSlot@1@@Z PROC	; CDetailManager::cache_Decompress
; _this$ = ecx

; 43   : {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	sub	esp, 392				; 00000188H
	push	esi
	mov	esi, ecx

; 44   : 	VERIFY				(S);
; 45   : 	Slot&	D			= *S;
; 46   : 	D.type				= stReady;

	mov	ecx, DWORD PTR _S$[ebp]
	push	edi
	mov	DWORD PTR _this$1$[esp+400], esi
	and	DWORD PTR [ecx], -3			; fffffffdH

; 47   : 	if (D.empty)		return;

	test	BYTE PTR [ecx], 1
	jne	$LN1@cache_Deco

; 49   : 	DetailSlot&	DS		= QueryDB(D.sx,D.sz);

	push	DWORD PTR [ecx+8]
	push	DWORD PTR [ecx+4]
	mov	ecx, esi
	call	?QueryDB@CDetailManager@@QAEAAUDetailSlot@@HH@Z ; CDetailManager::QueryDB
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	xmm6, DWORD PTR __real@3f000000
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_Decompress.cpp

; 63   : 	xrc.box_query		(g_pGameLevel->ObjectSpace.GetStaticModel(),bC,bD);

	lea	ecx, DWORD PTR [esi+1432]
	mov	edi, eax
	mov	DWORD PTR tv5026[esp+400], ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	mov	eax, DWORD PTR _S$[ebp]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_Decompress.cpp

; 49   : 	DetailSlot&	DS		= QueryDB(D.sx,D.sz);

	mov	DWORD PTR _DS$1$[esp+400], edi
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	xmm3, DWORD PTR [eax+28]
	movss	xmm4, DWORD PTR [eax+32]
	movss	xmm5, DWORD PTR [eax+36]
	movss	xmm2, DWORD PTR [eax+40]
	movss	xmm1, DWORD PTR [eax+44]
	subss	xmm2, xmm3
	movss	xmm0, DWORD PTR [eax+48]
	subss	xmm1, xmm4
	subss	xmm0, xmm5
; File I:\Vitalya\mine\NSProjectX\xrCDB\xrCDB.h

; 148  : 		ICF void		box_options		(u32 f)	{	box_mode = f;		}

	mov	DWORD PTR [esi+1436], 8
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_Decompress.cpp

; 63   : 	xrc.box_query		(g_pGameLevel->ObjectSpace.GetStaticModel(),bC,bD);

	lea	eax, DWORD PTR _bD$[esp+400]
	push	eax
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	mulss	xmm2, xmm6
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_Decompress.cpp

; 63   : 	xrc.box_query		(g_pGameLevel->ObjectSpace.GetStaticModel(),bC,bD);

	lea	eax, DWORD PTR _bC$[esp+404]
	push	eax
; File I:\Vitalya\mine\NSProjectX\xrEngine\xr_area.h

; 61   : 	CDB::MODEL* GetStaticModel() { return &Static; }

	mov	eax, DWORD PTR __imp_?g_pGameLevel@@3PAVIGame_Level@@A
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 40   : 	ICF SelfRef	mul(T s)								{ x*=s;		y*=s;		z*=s;			return *this;	};

	mulss	xmm1, xmm6
	mulss	xmm0, xmm6
	addss	xmm3, xmm2

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	addss	xmm4, xmm1

; 40   : 	ICF SelfRef	mul(T s)								{ x*=s;		y*=s;		z*=s;			return *this;	};

	movss	DWORD PTR _bD$[esp+408], xmm2
	movss	DWORD PTR _bD$[esp+412], xmm1

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	addss	xmm5, xmm0

; 40   : 	ICF SelfRef	mul(T s)								{ x*=s;		y*=s;		z*=s;			return *this;	};

	movss	DWORD PTR _bD$[esp+416], xmm0

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	movss	DWORD PTR _bC$[esp+408], xmm3
	movss	DWORD PTR _bC$[esp+412], xmm4
	movss	DWORD PTR _bC$[esp+416], xmm5
; File I:\Vitalya\mine\NSProjectX\xrEngine\xr_area.h

; 61   : 	CDB::MODEL* GetStaticModel() { return &Static; }

	mov	eax, DWORD PTR [eax]
	add	eax, 172				; 000000acH
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_Decompress.cpp

; 63   : 	xrc.box_query		(g_pGameLevel->ObjectSpace.GetStaticModel(),bC,bD);

	push	eax
	call	DWORD PTR __imp_?box_query@xrXRC@@QAEXPBVMODEL@CDB@@ABU?$_vector3@M@@1@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	eax, DWORD PTR [esi+1448]
	sub	eax, DWORD PTR [esi+1444]
	sar	eax, 3
	imul	edx, eax, -1227133513
; File I:\Vitalya\mine\NSProjectX\xrCDB\xrCDB.h

; 86   : 		IC TRI*					get_tris		()			{ return tris;		}

	mov	eax, DWORD PTR __imp_?g_pGameLevel@@3PAVIGame_Level@@A
	mov	eax, DWORD PTR [eax]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	DWORD PTR _triCount$1$[esp+400], edx
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_Decompress.cpp

; 65   : 	CDB::TRI*	tris	= g_pGameLevel->ObjectSpace.GetStaticTris();

	mov	ecx, DWORD PTR [eax+184]

; 66   : 	Fvector*	verts	= g_pGameLevel->ObjectSpace.GetStaticVerts();

	mov	eax, DWORD PTR [eax+192]
	mov	DWORD PTR _tris$1$[esp+400], ecx
	mov	DWORD PTR _verts$1$[esp+400], eax

; 67   : #endif
; 68   : 
; 69   : 	if (0==triCount)	return;

	test	edx, edx
	je	$LN1@cache_Deco

; 70   : 
; 71   : 	// Build shading table
; 72   : 	float		alpha255	[dm_obj_in_slot][4];
; 73   : 	for (int i=0; i<dm_obj_in_slot; i++)
; 74   : 	{
; 75   : 		alpha255[i][0]	= 255.f*float(DS.palette[i].a0)/15.f;

	movzx	ecx, WORD PTR [edi+8]
	movss	xmm0, DWORD PTR __real@41880000
	mov	eax, ecx
	and	eax, 15					; 0000000fH
	cvtsi2ss xmm1, eax

; 76   : 		alpha255[i][1]	= 255.f*float(DS.palette[i].a1)/15.f;

	mov	eax, ecx
	shr	eax, 4
	and	eax, 15					; 0000000fH
	mulss	xmm1, xmm0
	movss	DWORD PTR _alpha255$1$[esp+400], xmm1
	cvtsi2ss xmm1, eax

; 77   : 		alpha255[i][2]	= 255.f*float(DS.palette[i].a2)/15.f;

	mov	eax, ecx

; 78   : 		alpha255[i][3]	= 255.f*float(DS.palette[i].a3)/15.f;

	shr	cx, 12					; 0000000cH
	shr	eax, 8
	and	eax, 15					; 0000000fH
	mulss	xmm1, xmm0
	movss	DWORD PTR _alpha255$2$[esp+400], xmm1
	cvtsi2ss xmm1, eax
	movzx	eax, cx
	movzx	ecx, WORD PTR [edi+10]
	mulss	xmm1, xmm0
	movss	DWORD PTR _alpha255$3$[esp+400], xmm1
	cvtsi2ss xmm1, eax
	mov	eax, ecx
	and	eax, 15					; 0000000fH
	mulss	xmm1, xmm0
	movss	DWORD PTR _alpha255$4$[esp+400], xmm1
	cvtsi2ss xmm1, eax
	mov	eax, ecx
	shr	eax, 4
	and	eax, 15					; 0000000fH
	mulss	xmm1, xmm0
	movss	DWORD PTR _alpha255$5$[esp+400], xmm1
	cvtsi2ss xmm1, eax
	mov	eax, ecx
	shr	cx, 12					; 0000000cH
	shr	eax, 8
	and	eax, 15					; 0000000fH
	mulss	xmm1, xmm0
	movss	DWORD PTR _alpha255$6$[esp+400], xmm1
	cvtsi2ss xmm1, eax
	movzx	eax, cx
	movzx	ecx, WORD PTR [edi+12]
	mulss	xmm1, xmm0
	movss	DWORD PTR _alpha255$7$[esp+400], xmm1
	cvtsi2ss xmm1, eax
	mov	eax, ecx
	and	eax, 15					; 0000000fH
	mulss	xmm1, xmm0
	movss	DWORD PTR _alpha255$8$[esp+400], xmm1
	cvtsi2ss xmm1, eax
	mov	eax, ecx
	shr	eax, 4
	and	eax, 15					; 0000000fH
	mulss	xmm1, xmm0
	movss	DWORD PTR _alpha255$9$[esp+400], xmm1
	cvtsi2ss xmm1, eax
	mov	eax, ecx
	shr	cx, 12					; 0000000cH
	shr	eax, 8
	and	eax, 15					; 0000000fH
	mulss	xmm1, xmm0
	movss	DWORD PTR _alpha255$10$[esp+400], xmm1
	cvtsi2ss xmm1, eax
	movzx	eax, cx
	movzx	ecx, WORD PTR [edi+14]
	mulss	xmm1, xmm0
	movss	DWORD PTR _alpha255$11$[esp+400], xmm1
	cvtsi2ss xmm1, eax
	mov	eax, ecx
	and	eax, 15					; 0000000fH
	mulss	xmm1, xmm0
	movss	DWORD PTR _alpha255$12$[esp+400], xmm1
	cvtsi2ss xmm1, eax
	mov	eax, ecx
	shr	eax, 4
	and	eax, 15					; 0000000fH
	mulss	xmm1, xmm0
	movss	DWORD PTR _alpha255$13$[esp+400], xmm1
	cvtsi2ss xmm1, eax
	mulss	xmm1, xmm0

; 76   : 		alpha255[i][1]	= 255.f*float(DS.palette[i].a1)/15.f;

	mov	eax, ecx
	movss	DWORD PTR _alpha255$14$[esp+400], xmm1

; 77   : 		alpha255[i][2]	= 255.f*float(DS.palette[i].a2)/15.f;

	shr	eax, 8
	and	eax, 15					; 0000000fH

; 78   : 		alpha255[i][3]	= 255.f*float(DS.palette[i].a3)/15.f;

	shr	cx, 12					; 0000000cH
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 23   : 	ICF	SelfRef	set(T _x, T _y, T _z)					{ x = _x;		y = _y;		z = _z;		return *this;	};

	movss	xmm2, DWORD PTR __real@ff7fffff
	movss	xmm5, DWORD PTR __real@7f7fffff
	movaps	xmm6, xmm2
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_Decompress.cpp

; 98   : 	for (u32 z=0; z<=d_size; z++)

	fld1
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 23   : 	ICF	SelfRef	set(T _x, T _y, T _z)					{ x = _x;		y = _y;		z = _z;		return *this;	};

	movaps	xmm3, xmm5
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_Decompress.cpp

; 77   : 		alpha255[i][2]	= 255.f*float(DS.palette[i].a2)/15.f;

	cvtsi2ss xmm1, eax

; 78   : 		alpha255[i][3]	= 255.f*float(DS.palette[i].a3)/15.f;

	movzx	eax, cx
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h

; 105  :     int exponent	= (127 + 31) - ((a >> 23) & 0xFF);

	mov	ecx, 158				; 0000009eH
; File I:\Vitalya\mine\NSProjectX\xrCore\FixedVector.h

; 21   : 	svector() : count(0) 

	mov	DWORD PTR _selected$[esp+416], 0
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_Decompress.cpp

; 98   : 	for (u32 z=0; z<=d_size; z++)

	mov	DWORD PTR _z$1$[esp+400], 0
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 23   : 	ICF	SelfRef	set(T _x, T _y, T _z)					{ x = _x;		y = _y;		z = _z;		return *this;	};

	movaps	xmm4, xmm2
	movss	DWORD PTR _Bounds$2$[esp+400], xmm5
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_Decompress.cpp

; 77   : 		alpha255[i][2]	= 255.f*float(DS.palette[i].a2)/15.f;

	mulss	xmm1, xmm0
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 23   : 	ICF	SelfRef	set(T _x, T _y, T _z)					{ x = _x;		y = _y;		z = _z;		return *this;	};

	movss	DWORD PTR _Bounds$4$[esp+400], xmm3
	movss	DWORD PTR _Bounds$6$[esp+400], xmm3
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_Decompress.cpp

; 77   : 		alpha255[i][2]	= 255.f*float(DS.palette[i].a2)/15.f;

	movss	DWORD PTR _alpha255$15$[esp+400], xmm1

; 78   : 		alpha255[i][3]	= 255.f*float(DS.palette[i].a3)/15.f;

	cvtsi2ss xmm1, eax
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 23   : 	ICF	SelfRef	set(T _x, T _y, T _z)					{ x = _x;		y = _y;		z = _z;		return *this;	};

	movss	DWORD PTR _Bounds$8$[esp+400], xmm2
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_Decompress.cpp

; 78   : 		alpha255[i][3]	= 255.f*float(DS.palette[i].a3)/15.f;

	mulss	xmm1, xmm0
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 23   : 	ICF	SelfRef	set(T _x, T _y, T _z)					{ x = _x;		y = _y;		z = _z;		return *this;	};

	movss	DWORD PTR _Bounds$10$[esp+400], xmm6
	movss	DWORD PTR _Bounds$12$[esp+400], xmm4
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_Decompress.cpp

; 78   : 		alpha255[i][3]	= 255.f*float(DS.palette[i].a3)/15.f;

	movss	DWORD PTR _alpha255$16$[esp+400], xmm1

; 79   : 	}
; 80   : 
; 81   : 	// Prepare to selection
; 82   : 	float		density		= ps_r__Detail_density;

	movss	xmm1, DWORD PTR ?ps_r__Detail_density@@3MA

; 83   : 	float		jitter		= density/1.7f;

	movaps	xmm0, xmm1
	movss	DWORD PTR _density$1$[esp+400], xmm1
	mulss	xmm0, DWORD PTR __real@3f169696
	movss	DWORD PTR _jitter$1$[esp+400], xmm0

; 84   : 	u32			d_size		= iCeil	(dm_slot_size/density);

	movss	xmm0, DWORD PTR __real@40000000
	divss	xmm0, xmm1
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h

; 104  :     int a			= (*(const int*)(&x));

	movss	DWORD PTR _a$16[esp+400], xmm0

; 105  :     int exponent	= (127 + 31) - ((a >> 23) & 0xFF);

	mov	esi, DWORD PTR _a$16[esp+400]
	mov	eax, esi
	sar	eax, 23					; 00000017H
	movzx	eax, al
	sub	ecx, eax
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_Decompress.cpp

; 98   : 	for (u32 z=0; z<=d_size; z++)

	movss	xmm0, DWORD PTR __real@3f800000
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h

; 106  :     int r			= (((u32)(a) << 8) | (1U << 31)) >> exponent;

	mov	eax, esi
	or	eax, -8388608				; ff800000H
	shl	eax, 8
	shr	eax, cl

; 107  :     exponent		+= 31-127;

	sub	ecx, 96					; 00000060H
	mov	DWORD PTR _d_size$1$[esp+400], eax

; 108  :     {
; 109  :         int imask	=	(!(((( (1<<(exponent)))-1)>>8)&a));

	mov	eax, 1
	shl	eax, cl
	dec	eax
	sar	eax, 8

; 110  :         exponent	-=	(31-127)+32;

	lea	edx, DWORD PTR [ecx+64]
	and	eax, esi

; 111  :         exponent	>>=	31;

	sar	edx, 31					; 0000001fH

; 112  :         a			=	~((a-1)>>31);		/* change sign */

	lea	ecx, DWORD PTR [esi-1]

; 113  :         r			-=	(imask&a);

	mov	esi, DWORD PTR _d_size$1$[esp+400]
	sar	ecx, 31					; 0000001fH
	neg	eax
	not	ecx
	sbb	eax, eax
	inc	eax
	and	eax, ecx
	sub	esi, eax

; 114  :         r			&=	exponent;

	and	esi, edx
	xor	esi, ecx
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_Decompress.cpp

; 87   :     u32 p_rnd	= D.sx*D.sz; // нужно для того чтобы убрать полосы(ряды)

	mov	ecx, DWORD PTR _S$[ebp]
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h

; 116  :         r			=	-r;                 /* change sign */

	neg	esi
	mov	DWORD PTR _d_size$1$[esp+400], esi
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_Decompress.cpp

; 87   :     u32 p_rnd	= D.sx*D.sz; // нужно для того чтобы убрать полосы(ряды)

	mov	eax, DWORD PTR [ecx+4]
	imul	eax, DWORD PTR [ecx+8]

; 88   : 	CRandom				r_selection	(0x12071980^p_rnd);

	xor	eax, 302455168				; 12071980H
; File I:\Vitalya\mine\NSProjectX\xrCore\_random.h

; 27   : 	CRandom(s32 _seed)	: holdrand(_seed)			{};

	mov	DWORD PTR _r_selection$[esp+400], eax
	mov	DWORD PTR _r_jitter$[esp+400], eax
	mov	DWORD PTR _r_yaw$[esp+400], eax
	mov	DWORD PTR _r_scale$[esp+400], eax
$LN10@cache_Deco:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_Decompress.cpp

; 100  : 		for (u32 x=0; x<=d_size; x++)

	xor	edx, edx
	mov	DWORD PTR _x$1$[esp+400], edx
$LN13@cache_Deco:
; File I:\Vitalya\mine\NSProjectX\xrCore\_random.h

; 33   : 	IC 	s32		randI	(s32 max)					{ VERIFY(max);  return randI()%max; }

	lea	ecx, DWORD PTR _r_jitter$[esp+400]
	call	?randI@CRandom@@QAEHXZ			; CRandom::randI
	and	eax, -2147483633			; 8000000fH
	jns	SHORT $LN642@cache_Deco
	dec	eax
	or	eax, -16				; fffffff0H
	inc	eax
$LN642@cache_Deco:
	lea	ecx, DWORD PTR _r_jitter$[esp+400]
	mov	DWORD PTR _shift_x$1$[esp+400], eax
	call	?randI@CRandom@@QAEHXZ			; CRandom::randI
	and	eax, -2147483633			; 8000000fH
	jns	SHORT $LN643@cache_Deco
	dec	eax
	or	eax, -16				; fffffff0H
	inc	eax
$LN643@cache_Deco:
	mov	DWORD PTR _shift_z$1$[esp+400], eax
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_Decompress.cpp

; 107  : 			selected.clear();

	xor	edi, edi

; 108  : 			if ((DS.id0!=DetailSlot::ID_Empty)&& InterpolateAndDither(alpha255[0],x,z,shift_x,shift_z,d_size,dither))	selected.push_back(0);

	mov	eax, DWORD PTR _DS$1$[esp+400]
	mov	DWORD PTR _selected$[esp+416], edi
	mov	eax, DWORD PTR [eax]
	mov	ecx, eax
	and	ecx, 66060288				; 03f00000H
	mov	DWORD PTR tv4482[esp+400], eax
	cmp	ecx, 66060288				; 03f00000H
	je	$LN584@cache_Deco
	lea	eax, DWORD PTR [esi-1]

; 16   : 	float	f	= float(size);

	mov	DWORD PTR tv5566[esp+400], esi
	fild	DWORD PTR tv5566[esp+400]
; File I:\Vitalya\mine\NSProjectX\xrCore\vector.h

; 92   : 	if( val<_low ) val = _low; else if( val>_high ) val = _high;

	cmp	edx, eax
	mov	ecx, eax
	cmovbe	ecx, edx
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_Decompress.cpp

; 16   : 	float	f	= float(size);

	cmp	DWORD PTR _z$1$[esp+400], eax
; File I:\Vitalya\mine\NSProjectX\xrCore\vector.h

; 92   : 	if( val<_low ) val = _low; else if( val>_high ) val = _high;

	mov	DWORD PTR tv4444[esp+400], ecx
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_Decompress.cpp

; 16   : 	float	f	= float(size);

	cmovbe	eax, DWORD PTR _z$1$[esp+400]
	mov	DWORD PTR tv4448[esp+400], eax
	test	esi, esi
	jns	SHORT $LN644@cache_Deco
	fadd	DWORD PTR __real@4f800000
$LN644@cache_Deco:

; 17   : 	float	fx	= float(x)/f; float ifx = 1.f-fx;

	fdivr	ST(0), ST(1)
	mov	DWORD PTR tv5561[esp+400], ecx
	fild	DWORD PTR tv5561[esp+400]
	test	ecx, ecx
	jns	SHORT $LN645@cache_Deco
	fadd	DWORD PTR __real@4f800000
$LN645@cache_Deco:
	fmul	ST(0), ST(1)
	movaps	xmm7, xmm0

; 18   : 	float	fy	= float(y)/f; float ify = 1.f-fy;

	mov	DWORD PTR tv5558[esp+400], eax
	fstp	DWORD PTR _fx$22[esp+400]
	movss	xmm1, DWORD PTR _fx$22[esp+400]
	subss	xmm7, xmm1
	fild	DWORD PTR tv5558[esp+400]
	test	eax, eax
	jns	SHORT $LN646@cache_Deco
	fadd	DWORD PTR __real@4f800000
$LN646@cache_Deco:

; 20   : 	float	c01	= base[0]*ifx + base[1]*fx;

	movss	xmm3, DWORD PTR _alpha255$1$[esp+400]
	movaps	xmm4, xmm0
	movss	xmm0, DWORD PTR _alpha255$2$[esp+400]
	movaps	xmm6, xmm3

; 21   : 	float	c23	= base[2]*ifx + base[3]*fx;

	movss	xmm2, DWORD PTR _alpha255$3$[esp+400]
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h

; 84   :     int exponent	= (127 + 31) - ((a >> 23) & 0xFF);

	mov	ecx, 158				; 0000009eH
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_Decompress.cpp

; 20   : 	float	c01	= base[0]*ifx + base[1]*fx;

	mulss	xmm0, xmm1
	mulss	xmm6, xmm7
	fmulp	ST(1), ST(0)

; 21   : 	float	c23	= base[2]*ifx + base[3]*fx;

	mulss	xmm2, xmm7
	addss	xmm6, xmm0
	movss	xmm0, DWORD PTR _alpha255$4$[esp+400]
	mulss	xmm0, xmm1

; 23   : 	float	c13	= base[1]*ify + base[3]*fy;

	movss	xmm1, DWORD PTR _alpha255$2$[esp+400]
	fstp	DWORD PTR _fy$14[esp+400]
	movss	xmm5, DWORD PTR _fy$14[esp+400]
	addss	xmm2, xmm0
	movss	xmm0, DWORD PTR _alpha255$3$[esp+400]
	subss	xmm4, xmm5
	mulss	xmm0, xmm5

; 24   : 
; 25   : 	float	cx	= ify*c01 + fy*c23;

	mulss	xmm2, xmm5
	mulss	xmm3, xmm4
	mulss	xmm1, xmm4
	addss	xmm3, xmm0
	mulss	xmm6, xmm4
	movss	xmm0, DWORD PTR _alpha255$4$[esp+400]
	mulss	xmm0, xmm5

; 26   : 	float	cy	= ifx*c02 + fx*c13;

	mulss	xmm3, xmm7
	addss	xmm6, xmm2
	addss	xmm1, xmm0

; 34   : 	int		c	= iFloor(Interpolate(alpha255,x,y,size)+.5f);

	movss	xmm0, DWORD PTR __real@3f800000

; 26   : 	float	cy	= ifx*c02 + fx*c13;

	mulss	xmm1, DWORD PTR _fx$22[esp+400]
	addss	xmm3, xmm1

; 34   : 	int		c	= iFloor(Interpolate(alpha255,x,y,size)+.5f);

	movss	xmm1, DWORD PTR __real@3f000000

; 27   : 	return	(cx+cy)/2;

	addss	xmm6, xmm3

; 34   : 	int		c	= iFloor(Interpolate(alpha255,x,y,size)+.5f);

	addss	xmm6, xmm0
	mulss	xmm6, xmm1
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h

; 83   :     int a			= *(const int*)(&x);

	movss	DWORD PTR _a$15[esp+400], xmm6

; 84   :     int exponent	= (127 + 31) - ((a >> 23) & 0xFF);

	mov	esi, DWORD PTR _a$15[esp+400]
	mov	eax, esi
	sar	eax, 23					; 00000017H
	movzx	eax, al
	sub	ecx, eax

; 85   :     int r			= (((u32)(a) << 8) | (1U << 31)) >> exponent;

	mov	eax, esi
	or	eax, -8388608				; ff800000H
	shl	eax, 8
	shr	eax, cl

; 86   :     exponent		+= 31-127;

	sub	ecx, 96					; 00000060H
	mov	DWORD PTR _c$2$[esp+400], eax

; 87   :     {
; 88   :         int imask	=	(!(((( (1<<(exponent)))-1)>>8)&a));

	mov	eax, 1
	shl	eax, cl
	dec	eax
	sar	eax, 8

; 89   :         exponent	-=	(31-127)+32;

	lea	edx, DWORD PTR [ecx+64]
	and	eax, esi

; 90   :         exponent	>>=	31;

	sar	edx, 31					; 0000001fH

; 91   :         a			>>=	31;

	mov	ecx, esi

; 92   :         r			-=	(imask&a);

	mov	esi, DWORD PTR _c$2$[esp+400]
	sar	ecx, 31					; 0000001fH
	neg	eax
	sbb	eax, eax
	inc	eax
	and	eax, ecx
	sub	esi, eax

; 93   :         r			&=	exponent;

	and	esi, edx
	xor	esi, ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\vector.h

; 92   : 	if( val<_low ) val = _low; else if( val>_high ) val = _high;

	jge	SHORT $LN124@cache_Deco
	xor	esi, esi
	jmp	SHORT $LN126@cache_Deco
$LN124@cache_Deco:
	cmp	esi, 255				; 000000ffH
	mov	eax, 255				; 000000ffH
	cmovg	esi, eax
$LN126@cache_Deco:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_Decompress.cpp

; 38   : 	u32	col	= (x+sx) % 16;

	mov	eax, DWORD PTR _shift_x$1$[esp+400]
	add	eax, DWORD PTR tv4444[esp+400]
	mov	ecx, DWORD PTR tv4448[esp+400]
	and	eax, 15					; 0000000fH
	add	ecx, DWORD PTR _shift_z$1$[esp+400]

; 108  : 			if ((DS.id0!=DetailSlot::ID_Empty)&& InterpolateAndDither(alpha255[0],x,z,shift_x,shift_z,d_size,dither))	selected.push_back(0);

	mov	edx, DWORD PTR _x$1$[esp+400]

; 37   : 	u32	row	= (y+sy) % 16;

	and	ecx, 15					; 0000000fH

; 39   : 	return	c	> dither[col][row];

	shl	eax, 4
	add	eax, ecx
	mov	ecx, DWORD PTR _this$1$[esp+400]
	cmp	esi, DWORD PTR [ecx+eax*4+4]

; 108  : 			if ((DS.id0!=DetailSlot::ID_Empty)&& InterpolateAndDither(alpha255[0],x,z,shift_x,shift_z,d_size,dither))	selected.push_back(0);

	mov	eax, DWORD PTR tv4482[esp+400]
	mov	esi, DWORD PTR _d_size$1$[esp+400]
	jle	SHORT $LN19@cache_Deco
; File I:\Vitalya\mine\NSProjectX\xrCore\FixedVector.h

; 35   : 	IC void		push_back(value_type e)		{ VERIFY(count<dim); array[count++]=e;	}

	mov	DWORD PTR _selected$[esp+400], edi
	mov	edi, 1
	mov	DWORD PTR _selected$[esp+416], edi
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_Decompress.cpp

; 108  : 			if ((DS.id0!=DetailSlot::ID_Empty)&& InterpolateAndDither(alpha255[0],x,z,shift_x,shift_z,d_size,dither))	selected.push_back(0);

	jmp	SHORT $LN19@cache_Deco
$LN584@cache_Deco:
	movss	xmm1, DWORD PTR __real@3f000000
$LN19@cache_Deco:

; 109  : 			if ((DS.id1!=DetailSlot::ID_Empty)&& InterpolateAndDither(alpha255[1],x,z,shift_x,shift_z,d_size,dither))	selected.push_back(1);

	and	eax, -67108864				; fc000000H
	cmp	eax, -67108864				; fc000000H
	je	$LN20@cache_Deco
	lea	eax, DWORD PTR [esi-1]

; 16   : 	float	f	= float(size);

	mov	DWORD PTR tv5523[esp+400], esi
	fild	DWORD PTR tv5523[esp+400]
; File I:\Vitalya\mine\NSProjectX\xrCore\vector.h

; 92   : 	if( val<_low ) val = _low; else if( val>_high ) val = _high;

	cmp	edx, eax
	mov	ecx, eax
	cmovbe	ecx, edx
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_Decompress.cpp

; 16   : 	float	f	= float(size);

	cmp	DWORD PTR _z$1$[esp+400], eax
; File I:\Vitalya\mine\NSProjectX\xrCore\vector.h

; 92   : 	if( val<_low ) val = _low; else if( val>_high ) val = _high;

	mov	DWORD PTR tv4489[esp+400], ecx
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_Decompress.cpp

; 16   : 	float	f	= float(size);

	cmovbe	eax, DWORD PTR _z$1$[esp+400]
	mov	DWORD PTR tv4493[esp+400], eax
	test	esi, esi
	jns	SHORT $LN647@cache_Deco
	fadd	DWORD PTR __real@4f800000
$LN647@cache_Deco:

; 17   : 	float	fx	= float(x)/f; float ifx = 1.f-fx;

	fdivr	ST(0), ST(1)
	mov	DWORD PTR tv5518[esp+400], ecx
	fild	DWORD PTR tv5518[esp+400]
	test	ecx, ecx
	jns	SHORT $LN648@cache_Deco
	fadd	DWORD PTR __real@4f800000
$LN648@cache_Deco:
	fmul	ST(0), ST(1)
	movaps	xmm7, xmm0

; 18   : 	float	fy	= float(y)/f; float ify = 1.f-fy;

	mov	DWORD PTR tv5515[esp+400], eax
	fstp	DWORD PTR _fx$19[esp+400]
	movss	xmm1, DWORD PTR _fx$19[esp+400]
	subss	xmm7, xmm1
	fild	DWORD PTR tv5515[esp+400]
	test	eax, eax
	jns	SHORT $LN649@cache_Deco
	fadd	DWORD PTR __real@4f800000
$LN649@cache_Deco:

; 20   : 	float	c01	= base[0]*ifx + base[1]*fx;

	movss	xmm6, DWORD PTR _alpha255$5$[esp+400]
	movaps	xmm4, xmm0
	movss	xmm0, DWORD PTR _alpha255$6$[esp+400]
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h

; 84   :     int exponent	= (127 + 31) - ((a >> 23) & 0xFF);

	mov	ecx, 158				; 0000009eH
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_Decompress.cpp

; 21   : 	float	c23	= base[2]*ifx + base[3]*fx;

	movss	xmm3, DWORD PTR _alpha255$7$[esp+400]
	mulss	xmm0, xmm1
	movaps	xmm2, xmm3
	mulss	xmm6, xmm7
	fmulp	ST(1), ST(0)
	mulss	xmm2, xmm7
	addss	xmm6, xmm0
	movss	xmm0, DWORD PTR _alpha255$8$[esp+400]
	mulss	xmm0, xmm1

; 23   : 	float	c13	= base[1]*ify + base[3]*fy;

	movss	xmm1, DWORD PTR _alpha255$8$[esp+400]
	fstp	DWORD PTR _fy$12[esp+400]
	movss	xmm5, DWORD PTR _fy$12[esp+400]
	addss	xmm2, xmm0
	movss	xmm0, DWORD PTR _alpha255$5$[esp+400]
	subss	xmm4, xmm5
	mulss	xmm3, xmm5
	mulss	xmm1, xmm5
	mulss	xmm0, xmm4

; 24   : 
; 25   : 	float	cx	= ify*c01 + fy*c23;

	mulss	xmm6, xmm4
	addss	xmm3, xmm0
	mulss	xmm2, xmm5
	movss	xmm0, DWORD PTR _alpha255$6$[esp+400]
	mulss	xmm0, xmm4

; 26   : 	float	cy	= ifx*c02 + fx*c13;

	mulss	xmm3, xmm7
	addss	xmm6, xmm2
	addss	xmm1, xmm0

; 34   : 	int		c	= iFloor(Interpolate(alpha255,x,y,size)+.5f);

	movss	xmm0, DWORD PTR __real@3f800000

; 26   : 	float	cy	= ifx*c02 + fx*c13;

	mulss	xmm1, DWORD PTR _fx$19[esp+400]
	addss	xmm3, xmm1

; 34   : 	int		c	= iFloor(Interpolate(alpha255,x,y,size)+.5f);

	movss	xmm1, DWORD PTR __real@3f000000

; 27   : 	return	(cx+cy)/2;

	addss	xmm6, xmm3

; 34   : 	int		c	= iFloor(Interpolate(alpha255,x,y,size)+.5f);

	addss	xmm6, xmm0
	mulss	xmm6, xmm1
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h

; 83   :     int a			= *(const int*)(&x);

	movss	DWORD PTR _a$13[esp+400], xmm6

; 84   :     int exponent	= (127 + 31) - ((a >> 23) & 0xFF);

	mov	esi, DWORD PTR _a$13[esp+400]
	mov	eax, esi
	sar	eax, 23					; 00000017H
	movzx	eax, al
	sub	ecx, eax

; 85   :     int r			= (((u32)(a) << 8) | (1U << 31)) >> exponent;

	mov	eax, esi
	or	eax, -8388608				; ff800000H
	shl	eax, 8
	shr	eax, cl

; 86   :     exponent		+= 31-127;

	sub	ecx, 96					; 00000060H
	mov	DWORD PTR _c$2$[esp+400], eax

; 87   :     {
; 88   :         int imask	=	(!(((( (1<<(exponent)))-1)>>8)&a));

	mov	eax, 1
	shl	eax, cl
	dec	eax
	sar	eax, 8

; 89   :         exponent	-=	(31-127)+32;

	lea	edx, DWORD PTR [ecx+64]
	and	eax, esi

; 90   :         exponent	>>=	31;

	sar	edx, 31					; 0000001fH

; 91   :         a			>>=	31;

	mov	ecx, esi

; 92   :         r			-=	(imask&a);

	mov	esi, DWORD PTR _c$2$[esp+400]
	sar	ecx, 31					; 0000001fH
	neg	eax
	sbb	eax, eax
	inc	eax
	and	eax, ecx
	sub	esi, eax

; 93   :         r			&=	exponent;

	and	esi, edx
	xor	esi, ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\vector.h

; 92   : 	if( val<_low ) val = _low; else if( val>_high ) val = _high;

	jge	SHORT $LN150@cache_Deco
	xor	esi, esi
	jmp	SHORT $LN152@cache_Deco
$LN150@cache_Deco:
	cmp	esi, 255				; 000000ffH
	mov	eax, 255				; 000000ffH
	cmovg	esi, eax
$LN152@cache_Deco:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_Decompress.cpp

; 38   : 	u32	col	= (x+sx) % 16;

	mov	eax, DWORD PTR _shift_x$1$[esp+400]
	add	eax, DWORD PTR tv4489[esp+400]
	mov	ecx, DWORD PTR tv4493[esp+400]
	and	eax, 15					; 0000000fH
	add	ecx, DWORD PTR _shift_z$1$[esp+400]
	and	ecx, 15					; 0000000fH

; 39   : 	return	c	> dither[col][row];

	shl	eax, 4
	add	eax, ecx
	mov	ecx, DWORD PTR _this$1$[esp+400]
	cmp	esi, DWORD PTR [ecx+eax*4+4]

; 109  : 			if ((DS.id1!=DetailSlot::ID_Empty)&& InterpolateAndDither(alpha255[1],x,z,shift_x,shift_z,d_size,dither))	selected.push_back(1);

	jle	SHORT $LN20@cache_Deco
; File I:\Vitalya\mine\NSProjectX\xrCore\FixedVector.h

; 35   : 	IC void		push_back(value_type e)		{ VERIFY(count<dim); array[count++]=e;	}

	mov	DWORD PTR _selected$[esp+edi*4+400], 1
	mov	edi, DWORD PTR _selected$[esp+416]
	inc	edi
	mov	DWORD PTR _selected$[esp+416], edi
$LN20@cache_Deco:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_Decompress.cpp

; 110  : 			if ((DS.id2!=DetailSlot::ID_Empty)&& InterpolateAndDither(alpha255[2],x,z,shift_x,shift_z,d_size,dither))	selected.push_back(2);

	mov	eax, DWORD PTR _DS$1$[esp+400]
	mov	ecx, DWORD PTR [eax+4]
	mov	eax, ecx
	and	eax, 63					; 0000003fH
	mov	DWORD PTR tv4573[esp+400], ecx
	cmp	al, 63					; 0000003fH
	je	$LN21@cache_Deco
	mov	esi, DWORD PTR _d_size$1$[esp+400]

; 16   : 	float	f	= float(size);

	mov	DWORD PTR tv5480[esp+400], esi
	fild	DWORD PTR tv5480[esp+400]

; 110  : 			if ((DS.id2!=DetailSlot::ID_Empty)&& InterpolateAndDither(alpha255[2],x,z,shift_x,shift_z,d_size,dither))	selected.push_back(2);

	lea	eax, DWORD PTR [esi-1]
; File I:\Vitalya\mine\NSProjectX\xrCore\vector.h

; 92   : 	if( val<_low ) val = _low; else if( val>_high ) val = _high;

	cmp	DWORD PTR _x$1$[esp+400], eax
	mov	ecx, eax
	cmovbe	ecx, DWORD PTR _x$1$[esp+400]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_Decompress.cpp

; 16   : 	float	f	= float(size);

	cmp	DWORD PTR _z$1$[esp+400], eax
; File I:\Vitalya\mine\NSProjectX\xrCore\vector.h

; 92   : 	if( val<_low ) val = _low; else if( val>_high ) val = _high;

	mov	DWORD PTR tv4535[esp+400], ecx
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_Decompress.cpp

; 16   : 	float	f	= float(size);

	cmovbe	eax, DWORD PTR _z$1$[esp+400]
	mov	DWORD PTR tv4539[esp+400], eax
	test	esi, esi
	jns	SHORT $LN650@cache_Deco
	fadd	DWORD PTR __real@4f800000
$LN650@cache_Deco:

; 17   : 	float	fx	= float(x)/f; float ifx = 1.f-fx;

	fdivr	ST(0), ST(1)
	mov	DWORD PTR tv5475[esp+400], ecx
	fild	DWORD PTR tv5475[esp+400]
	test	ecx, ecx
	jns	SHORT $LN651@cache_Deco
	fadd	DWORD PTR __real@4f800000
$LN651@cache_Deco:
	fmul	ST(0), ST(1)
	movaps	xmm7, xmm0

; 18   : 	float	fy	= float(y)/f; float ify = 1.f-fy;

	mov	DWORD PTR tv5472[esp+400], eax
	fstp	DWORD PTR _fx$18[esp+400]
	movss	xmm1, DWORD PTR _fx$18[esp+400]
	subss	xmm7, xmm1
	fild	DWORD PTR tv5472[esp+400]
	test	eax, eax
	jns	SHORT $LN652@cache_Deco
	fadd	DWORD PTR __real@4f800000
$LN652@cache_Deco:
	movaps	xmm4, xmm0
	fmulp	ST(1), ST(0)

; 20   : 	float	c01	= base[0]*ifx + base[1]*fx;

	movaps	xmm6, xmm1
	movaps	xmm0, xmm7
	mulss	xmm0, DWORD PTR _alpha255$9$[esp+400]

; 21   : 	float	c23	= base[2]*ifx + base[3]*fx;

	movaps	xmm2, xmm1
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h

; 84   :     int exponent	= (127 + 31) - ((a >> 23) & 0xFF);

	mov	ecx, 158				; 0000009eH
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_Decompress.cpp

; 20   : 	float	c01	= base[0]*ifx + base[1]*fx;

	mulss	xmm6, DWORD PTR _alpha255$10$[esp+400]

; 21   : 	float	c23	= base[2]*ifx + base[3]*fx;

	mulss	xmm2, DWORD PTR _alpha255$12$[esp+400]
	addss	xmm6, xmm0
	movaps	xmm0, xmm7
	mulss	xmm0, DWORD PTR _alpha255$11$[esp+400]
	fstp	DWORD PTR _fy$10[esp+400]
	movss	xmm5, DWORD PTR _fy$10[esp+400]
	subss	xmm4, xmm5

; 22   : 	float	c02	= base[0]*ify + base[2]*fy;

	movaps	xmm3, xmm5
	mulss	xmm3, DWORD PTR _alpha255$11$[esp+400]
	addss	xmm2, xmm0

; 23   : 	float	c13	= base[1]*ify + base[3]*fy;

	movaps	xmm1, xmm5
	mulss	xmm1, DWORD PTR _alpha255$12$[esp+400]
	movaps	xmm0, xmm4

; 24   : 
; 25   : 	float	cx	= ify*c01 + fy*c23;

	mulss	xmm6, xmm4
	mulss	xmm0, DWORD PTR _alpha255$9$[esp+400]
	mulss	xmm2, xmm5
	addss	xmm3, xmm0
	movaps	xmm0, xmm4
	mulss	xmm0, DWORD PTR _alpha255$10$[esp+400]

; 26   : 	float	cy	= ifx*c02 + fx*c13;

	addss	xmm6, xmm2
	addss	xmm1, xmm0
	mulss	xmm3, xmm7

; 34   : 	int		c	= iFloor(Interpolate(alpha255,x,y,size)+.5f);

	movss	xmm0, DWORD PTR __real@3f800000

; 26   : 	float	cy	= ifx*c02 + fx*c13;

	mulss	xmm1, DWORD PTR _fx$18[esp+400]
	addss	xmm3, xmm1

; 34   : 	int		c	= iFloor(Interpolate(alpha255,x,y,size)+.5f);

	movss	xmm1, DWORD PTR __real@3f000000

; 27   : 	return	(cx+cy)/2;

	addss	xmm6, xmm3

; 34   : 	int		c	= iFloor(Interpolate(alpha255,x,y,size)+.5f);

	addss	xmm6, xmm0
	mulss	xmm6, xmm1
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h

; 83   :     int a			= *(const int*)(&x);

	movss	DWORD PTR _a$11[esp+400], xmm6

; 84   :     int exponent	= (127 + 31) - ((a >> 23) & 0xFF);

	mov	esi, DWORD PTR _a$11[esp+400]
	mov	eax, esi
	sar	eax, 23					; 00000017H
	movzx	eax, al
	sub	ecx, eax

; 85   :     int r			= (((u32)(a) << 8) | (1U << 31)) >> exponent;

	mov	eax, esi
	or	eax, -8388608				; ff800000H
	shl	eax, 8
	shr	eax, cl

; 86   :     exponent		+= 31-127;

	sub	ecx, 96					; 00000060H
	mov	DWORD PTR _c$2$[esp+400], eax

; 87   :     {
; 88   :         int imask	=	(!(((( (1<<(exponent)))-1)>>8)&a));

	mov	eax, 1
	shl	eax, cl
	dec	eax
	sar	eax, 8

; 89   :         exponent	-=	(31-127)+32;

	lea	edx, DWORD PTR [ecx+64]
	and	eax, esi

; 90   :         exponent	>>=	31;

	sar	edx, 31					; 0000001fH

; 91   :         a			>>=	31;

	mov	ecx, esi

; 92   :         r			-=	(imask&a);

	mov	esi, DWORD PTR _c$2$[esp+400]
	sar	ecx, 31					; 0000001fH
	neg	eax
	sbb	eax, eax
	inc	eax
	and	eax, ecx
	sub	esi, eax

; 93   :         r			&=	exponent;

	and	esi, edx
	xor	esi, ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\vector.h

; 92   : 	if( val<_low ) val = _low; else if( val>_high ) val = _high;

	jge	SHORT $LN176@cache_Deco
	xor	esi, esi
	jmp	SHORT $LN178@cache_Deco
$LN176@cache_Deco:
	cmp	esi, 255				; 000000ffH
	mov	eax, 255				; 000000ffH
	cmovg	esi, eax
$LN178@cache_Deco:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_Decompress.cpp

; 38   : 	u32	col	= (x+sx) % 16;

	mov	eax, DWORD PTR _shift_x$1$[esp+400]
	add	eax, DWORD PTR tv4535[esp+400]
	mov	ecx, DWORD PTR tv4539[esp+400]
	and	eax, 15					; 0000000fH
	add	ecx, DWORD PTR _shift_z$1$[esp+400]
	and	ecx, 15					; 0000000fH

; 39   : 	return	c	> dither[col][row];

	shl	eax, 4
	add	eax, ecx
	mov	ecx, DWORD PTR _this$1$[esp+400]
	cmp	esi, DWORD PTR [ecx+eax*4+4]

; 110  : 			if ((DS.id2!=DetailSlot::ID_Empty)&& InterpolateAndDither(alpha255[2],x,z,shift_x,shift_z,d_size,dither))	selected.push_back(2);

	mov	ecx, DWORD PTR tv4573[esp+400]
	jle	SHORT $LN21@cache_Deco
; File I:\Vitalya\mine\NSProjectX\xrCore\FixedVector.h

; 35   : 	IC void		push_back(value_type e)		{ VERIFY(count<dim); array[count++]=e;	}

	mov	DWORD PTR _selected$[esp+edi*4+400], 2
	mov	edi, DWORD PTR _selected$[esp+416]
	inc	edi
	mov	DWORD PTR _selected$[esp+416], edi
$LN21@cache_Deco:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_Decompress.cpp

; 111  : 			if ((DS.id3!=DetailSlot::ID_Empty)&& InterpolateAndDither(alpha255[3],x,z,shift_x,shift_z,d_size,dither))	selected.push_back(3);

	and	ecx, 4032				; 00000fc0H
	cmp	ecx, 4032				; 00000fc0H
	je	$LN22@cache_Deco
	mov	esi, DWORD PTR _d_size$1$[esp+400]

; 16   : 	float	f	= float(size);

	mov	DWORD PTR tv5437[esp+400], esi
	fild	DWORD PTR tv5437[esp+400]

; 111  : 			if ((DS.id3!=DetailSlot::ID_Empty)&& InterpolateAndDither(alpha255[3],x,z,shift_x,shift_z,d_size,dither))	selected.push_back(3);

	lea	eax, DWORD PTR [esi-1]
; File I:\Vitalya\mine\NSProjectX\xrCore\vector.h

; 92   : 	if( val<_low ) val = _low; else if( val>_high ) val = _high;

	cmp	DWORD PTR _x$1$[esp+400], eax
	mov	ecx, eax
	cmovbe	ecx, DWORD PTR _x$1$[esp+400]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_Decompress.cpp

; 16   : 	float	f	= float(size);

	cmp	DWORD PTR _z$1$[esp+400], eax
; File I:\Vitalya\mine\NSProjectX\xrCore\vector.h

; 92   : 	if( val<_low ) val = _low; else if( val>_high ) val = _high;

	mov	DWORD PTR tv4580[esp+400], ecx
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_Decompress.cpp

; 16   : 	float	f	= float(size);

	cmovbe	eax, DWORD PTR _z$1$[esp+400]
	mov	DWORD PTR tv4584[esp+400], eax
	test	esi, esi
	jns	SHORT $LN653@cache_Deco
	fadd	DWORD PTR __real@4f800000
$LN653@cache_Deco:

; 17   : 	float	fx	= float(x)/f; float ifx = 1.f-fx;

	fdivr	ST(0), ST(1)
	mov	DWORD PTR tv5432[esp+400], ecx
	fild	DWORD PTR tv5432[esp+400]
	test	ecx, ecx
	jns	SHORT $LN654@cache_Deco
	fadd	DWORD PTR __real@4f800000
$LN654@cache_Deco:
	fmul	ST(0), ST(1)
	movaps	xmm7, xmm0

; 18   : 	float	fy	= float(y)/f; float ify = 1.f-fy;

	mov	DWORD PTR tv5429[esp+400], eax
	fstp	DWORD PTR _fx$17[esp+400]
	movss	xmm1, DWORD PTR _fx$17[esp+400]
	subss	xmm7, xmm1
	fild	DWORD PTR tv5429[esp+400]
	test	eax, eax
	jns	SHORT $LN655@cache_Deco
	fadd	DWORD PTR __real@4f800000
$LN655@cache_Deco:
	movaps	xmm4, xmm0
	fmulp	ST(1), ST(0)

; 20   : 	float	c01	= base[0]*ifx + base[1]*fx;

	movaps	xmm6, xmm1
	movaps	xmm0, xmm7
	mulss	xmm0, DWORD PTR _alpha255$13$[esp+400]

; 21   : 	float	c23	= base[2]*ifx + base[3]*fx;

	movaps	xmm2, xmm1
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h

; 84   :     int exponent	= (127 + 31) - ((a >> 23) & 0xFF);

	mov	ecx, 158				; 0000009eH
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_Decompress.cpp

; 20   : 	float	c01	= base[0]*ifx + base[1]*fx;

	mulss	xmm6, DWORD PTR _alpha255$14$[esp+400]

; 21   : 	float	c23	= base[2]*ifx + base[3]*fx;

	mulss	xmm2, DWORD PTR _alpha255$16$[esp+400]
	addss	xmm6, xmm0
	movaps	xmm0, xmm7
	mulss	xmm0, DWORD PTR _alpha255$15$[esp+400]
	fstp	DWORD PTR _fy$8[esp+400]
	movss	xmm5, DWORD PTR _fy$8[esp+400]
	subss	xmm4, xmm5

; 22   : 	float	c02	= base[0]*ify + base[2]*fy;

	movaps	xmm3, xmm5
	mulss	xmm3, DWORD PTR _alpha255$15$[esp+400]
	addss	xmm2, xmm0

; 23   : 	float	c13	= base[1]*ify + base[3]*fy;

	movaps	xmm1, xmm5
	mulss	xmm1, DWORD PTR _alpha255$16$[esp+400]
	movaps	xmm0, xmm4

; 24   : 
; 25   : 	float	cx	= ify*c01 + fy*c23;

	mulss	xmm6, xmm4
	mulss	xmm0, DWORD PTR _alpha255$13$[esp+400]
	mulss	xmm2, xmm5
	addss	xmm3, xmm0
	movaps	xmm0, xmm4
	mulss	xmm0, DWORD PTR _alpha255$14$[esp+400]

; 26   : 	float	cy	= ifx*c02 + fx*c13;

	addss	xmm6, xmm2
	addss	xmm1, xmm0
	mulss	xmm3, xmm7

; 34   : 	int		c	= iFloor(Interpolate(alpha255,x,y,size)+.5f);

	movss	xmm0, DWORD PTR __real@3f800000

; 26   : 	float	cy	= ifx*c02 + fx*c13;

	mulss	xmm1, DWORD PTR _fx$17[esp+400]
	addss	xmm3, xmm1

; 34   : 	int		c	= iFloor(Interpolate(alpha255,x,y,size)+.5f);

	movss	xmm1, DWORD PTR __real@3f000000

; 27   : 	return	(cx+cy)/2;

	addss	xmm6, xmm3

; 34   : 	int		c	= iFloor(Interpolate(alpha255,x,y,size)+.5f);

	addss	xmm6, xmm0
	mulss	xmm6, xmm1
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h

; 83   :     int a			= *(const int*)(&x);

	movss	DWORD PTR _a$9[esp+400], xmm6

; 84   :     int exponent	= (127 + 31) - ((a >> 23) & 0xFF);

	mov	esi, DWORD PTR _a$9[esp+400]
	mov	eax, esi
	sar	eax, 23					; 00000017H
	movzx	eax, al
	sub	ecx, eax

; 85   :     int r			= (((u32)(a) << 8) | (1U << 31)) >> exponent;

	mov	eax, esi
	or	eax, -8388608				; ff800000H
	shl	eax, 8
	shr	eax, cl

; 86   :     exponent		+= 31-127;

	sub	ecx, 96					; 00000060H
	mov	DWORD PTR _c$2$[esp+400], eax

; 87   :     {
; 88   :         int imask	=	(!(((( (1<<(exponent)))-1)>>8)&a));

	mov	eax, 1
	shl	eax, cl
	dec	eax
	sar	eax, 8

; 89   :         exponent	-=	(31-127)+32;

	lea	edx, DWORD PTR [ecx+64]
	and	eax, esi

; 90   :         exponent	>>=	31;

	sar	edx, 31					; 0000001fH

; 91   :         a			>>=	31;

	mov	ecx, esi

; 92   :         r			-=	(imask&a);

	mov	esi, DWORD PTR _c$2$[esp+400]
	sar	ecx, 31					; 0000001fH
	neg	eax
	sbb	eax, eax
	inc	eax
	and	eax, ecx
	sub	esi, eax

; 93   :         r			&=	exponent;

	and	esi, edx
	xor	esi, ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\vector.h

; 92   : 	if( val<_low ) val = _low; else if( val>_high ) val = _high;

	jge	SHORT $LN202@cache_Deco
	xor	esi, esi
	jmp	SHORT $LN204@cache_Deco
$LN202@cache_Deco:
	cmp	esi, 255				; 000000ffH
	mov	eax, 255				; 000000ffH
	cmovg	esi, eax
$LN204@cache_Deco:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_Decompress.cpp

; 38   : 	u32	col	= (x+sx) % 16;

	mov	eax, DWORD PTR _shift_x$1$[esp+400]
	add	eax, DWORD PTR tv4580[esp+400]
	mov	ecx, DWORD PTR tv4584[esp+400]
	and	eax, 15					; 0000000fH
	add	ecx, DWORD PTR _shift_z$1$[esp+400]
	and	ecx, 15					; 0000000fH

; 39   : 	return	c	> dither[col][row];

	shl	eax, 4
	add	eax, ecx
	mov	ecx, DWORD PTR _this$1$[esp+400]
	cmp	esi, DWORD PTR [ecx+eax*4+4]

; 111  : 			if ((DS.id3!=DetailSlot::ID_Empty)&& InterpolateAndDither(alpha255[3],x,z,shift_x,shift_z,d_size,dither))	selected.push_back(3);

	jle	SHORT $LN22@cache_Deco
; File I:\Vitalya\mine\NSProjectX\xrCore\FixedVector.h

; 35   : 	IC void		push_back(value_type e)		{ VERIFY(count<dim); array[count++]=e;	}

	mov	DWORD PTR _selected$[esp+edi*4+400], 3
	mov	edi, DWORD PTR _selected$[esp+416]
	inc	edi
	mov	DWORD PTR _selected$[esp+416], edi
$LN22@cache_Deco:

; 48   : 	IC bool		empty()		const			{ return 0==count;	}

	test	edi, edi
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_Decompress.cpp

; 114  : 			if (selected.empty())	continue;

	je	$LN11@cache_Deco
	fstp	ST(0)

; 115  : 			u32 index;
; 116  : 			if (selected.size()==1)	index = selected[0];

	cmp	edi, 1
	jne	SHORT $LN24@cache_Deco
	mov	eax, DWORD PTR _selected$[esp+400]
	jmp	SHORT $LN662@cache_Deco
$LN24@cache_Deco:
; File I:\Vitalya\mine\NSProjectX\xrCore\_random.h

; 33   : 	IC 	s32		randI	(s32 max)					{ VERIFY(max);  return randI()%max; }

	lea	ecx, DWORD PTR _r_selection$[esp+400]
	call	?randI@CRandom@@QAEHXZ			; CRandom::randI
	cdq
	idiv	edi
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_Decompress.cpp

; 117  : 			else					index = selected[r_selection.randI(selected.size())];

	mov	eax, DWORD PTR _selected$[esp+edx*4+400]
$LN662@cache_Deco:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\detailformat.h

; 108  :         switch(idx)	{

	mov	DWORD PTR _index$1$[esp+400], eax
	jmp	DWORD PTR $LN574@cache_Deco[eax*4]
$LN231@cache_Deco:

; 109  :         case 0: return (u8)id0;

	mov	eax, DWORD PTR _DS$1$[esp+400]
	mov	eax, DWORD PTR [eax]
	shr	eax, 20					; 00000014H
	jmp	SHORT $LN663@cache_Deco
$LN232@cache_Deco:

; 110  :         case 1: return (u8)id1;

	mov	eax, DWORD PTR _DS$1$[esp+400]
	mov	eax, DWORD PTR [eax]
	shr	eax, 26					; 0000001aH
	jmp	SHORT $LN241@cache_Deco
$LN233@cache_Deco:

; 111  :         case 2: return (u8)id2;

	mov	eax, DWORD PTR _DS$1$[esp+400]
	mov	al, BYTE PTR [eax+4]
	jmp	SHORT $LN663@cache_Deco
$LN234@cache_Deco:

; 112  :         case 3: return (u8)id3;

	mov	eax, DWORD PTR _DS$1$[esp+400]
	mov	eax, DWORD PTR [eax+4]
	shr	eax, 6
$LN663@cache_Deco:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_Decompress.cpp

; 119  : 			CDetail*	Dobj	= objects[DS.r_id(index)];

	and	al, 63					; 0000003fH
$LN241@cache_Deco:
	mov	ecx, DWORD PTR _this$1$[esp+400]
; File I:\Vitalya\mine\NSProjectX\xrCore\xrPool.h

; 40   : 		if (0==list)	block_create();

	mov	edi, DWORD PTR [ecx+701208]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_Decompress.cpp

; 120  : 			SlotItem*	ItemP	= poolSI.create();

	lea	esi, DWORD PTR [ecx+701208]
	movzx	eax, al
; File I:\Vitalya\mine\NSProjectX\xrCore\xrPool.h

; 40   : 		if (0==list)	block_create();

	mov	DWORD PTR _E$1$[esp+400], edi
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_Decompress.cpp

; 119  : 			CDetail*	Dobj	= objects[DS.r_id(index)];

	mov	eax, DWORD PTR [ecx+eax*4+1136]
	mov	DWORD PTR _Dobj$1$[esp+400], eax
; File I:\Vitalya\mine\NSProjectX\xrCore\xrPool.h

; 40   : 		if (0==list)	block_create();

	test	edi, edi
	jne	SHORT $LN244@cache_Deco
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	393216					; 00060000H
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
; File I:\Vitalya\mine\NSProjectX\xrCore\xrPool.h

; 18   : 		blocks.push_back	(list);

	lea	ecx, DWORD PTR [esi+4]
	mov	DWORD PTR [esi], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 730  :         if (_Mylast != _My_data._Myend) {

	mov	edx, DWORD PTR [ecx+4]
	cmp	edx, DWORD PTR [ecx+8]
	je	SHORT $LN259@cache_Deco

; 713  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

	mov	DWORD PTR [edx], eax

; 714  :         _Orphan_range(_Mylast, _Mylast);
; 715  :         _Ty& _Result = *_Mylast;
; 716  :         ++_Mylast;

	add	DWORD PTR [ecx+4], 4

; 731  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

	jmp	SHORT $LN258@cache_Deco
$LN259@cache_Deco:

; 732  :         }
; 733  : 
; 734  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	push	esi
	push	edx
	call	??$_Emplace_reallocate@ABQAUSlotItem@CDetailManager@@@?$vector@PAUSlotItem@CDetailManager@@V?$xalloc@PAUSlotItem@CDetailManager@@@@@std@@QAEPAPAUSlotItem@CDetailManager@@QAPAU23@ABQAU23@@Z ; std::vector<CDetailManager::SlotItem *,xalloc<CDetailManager::SlotItem *> >::_Emplace_reallocate<CDetailManager::SlotItem * const &>
$LN258@cache_Deco:
; File I:\Vitalya\mine\NSProjectX\xrCore\xrPool.h

; 21   : 		for (int it=0; it<(granularity-1); it++)

	xor	edx, edx
$LL252@cache_Deco:

; 22   : 		{
; 23   : 			T*		E			= list+it;

	mov	ecx, DWORD PTR [esi]

; 24   : 			*access(E)			= E+1;

	lea	eax, DWORD PTR [ecx+96]
	add	eax, edx
	mov	DWORD PTR [ecx+edx], eax
	add	edx, 96					; 00000060H
	cmp	edx, 393120				; 0005ffa0H
	jl	SHORT $LL252@cache_Deco

; 25   : 		}
; 26   : 		*access(list+granularity-1)	= NULL;

	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [eax+393120], 0
	mov	edi, DWORD PTR [esi]
	mov	DWORD PTR _E$1$[esp+400], edi
$LN244@cache_Deco:

; 43   : 		list			= *access(list);

	mov	eax, DWORD PTR [edi]

; 44   : 		return			new (E) T();

	push	96					; 00000060H
	push	0
	push	edi
	mov	DWORD PTR [esi], eax
	call	_memset
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_Decompress.cpp

; 124  : 			float		rx = (float(x)/float(d_size))*dm_slot_size + D.vis.box.min.x;

	mov	eax, DWORD PTR _d_size$1$[esp+412]
; File I:\Vitalya\mine\NSProjectX\xrCore\xrPool.h

; 44   : 		return			new (E) T();

	add	esp, 12					; 0000000cH
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_Decompress.cpp

; 120  : 			SlotItem*	ItemP	= poolSI.create();

	mov	DWORD PTR _ItemP$20[esp+400], edi

; 124  : 			float		rx = (float(x)/float(d_size))*dm_slot_size + D.vis.box.min.x;

	fild	DWORD PTR _d_size$1$[esp+400]
	test	eax, eax
	jns	SHORT $LN656@cache_Deco
	fadd	DWORD PTR __real@4f800000
$LN656@cache_Deco:
	fld1
	fld	ST(0)
	mov	eax, DWORD PTR _x$1$[esp+400]
	fdivrp	ST(2), ST(0)
	fxch	ST(1)
	fstp	DWORD PTR tv1414[esp+400]
	fild	DWORD PTR _x$1$[esp+400]
	test	eax, eax
	jns	SHORT $LN657@cache_Deco
	fadd	DWORD PTR __real@4f800000
$LN657@cache_Deco:
	movss	xmm5, DWORD PTR tv1414[esp+400]
	mov	esi, DWORD PTR _S$[ebp]

; 125  : 			float		rz = (float(z)/float(d_size))*dm_slot_size + D.vis.box.min.z;

	mov	eax, DWORD PTR _z$1$[esp+400]
	fstp	DWORD PTR tv1422[esp+400]
	movss	xmm4, DWORD PTR tv1422[esp+400]
	addss	xmm4, xmm4
	fild	DWORD PTR _z$1$[esp+400]
	mulss	xmm4, xmm5
	addss	xmm4, DWORD PTR [esi+28]
	test	eax, eax
	jns	SHORT $LN658@cache_Deco
	fadd	DWORD PTR __real@4f800000
$LN658@cache_Deco:
; File I:\Vitalya\mine\NSProjectX\xrCore\_random.h

; 42   : 	IC 	float	randFs	(float range)				{ return randF(-range,range); }

	movss	xmm3, DWORD PTR _density$1$[esp+400]

; 39   : 	IC 	float	randF	()							{ return float(randI())/maxF();	}

	lea	ecx, DWORD PTR _r_jitter$[esp+400]

; 42   : 	IC 	float	randFs	(float range)				{ return randF(-range,range); }

	mulss	xmm3, DWORD PTR __real@bf169696

; 41   : 	IC 	float	randF	(float min,float max)		{ return min+randF(max-min); }

	movss	xmm0, DWORD PTR _jitter$1$[esp+400]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_Decompress.cpp

; 125  : 			float		rz = (float(z)/float(d_size))*dm_slot_size + D.vis.box.min.z;

	movss	xmm2, DWORD PTR [esi+36]
	fstp	DWORD PTR tv2174[esp+400]
; File I:\Vitalya\mine\NSProjectX\xrCore\_random.h

; 41   : 	IC 	float	randF	(float min,float max)		{ return min+randF(max-min); }

	subss	xmm0, xmm3

; 39   : 	IC 	float	randF	()							{ return float(randI())/maxF();	}

	call	?randI@CRandom@@QAEHXZ			; CRandom::randI
	movss	xmm7, DWORD PTR __real@38000100
	cvtsi2ss xmm1, eax
	mulss	xmm1, xmm7

; 40   : 	IC 	float	randF	(float max)					{ return randF()*max; }

	mulss	xmm1, xmm0

; 39   : 	IC 	float	randF	()							{ return float(randI())/maxF();	}

	call	?randI@CRandom@@QAEHXZ			; CRandom::randI
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_Decompress.cpp

; 127  : 			Item_P.set	(rx + r_jitter.randFs(jitter), D.vis.box.max.y, rz + r_jitter.randFs(jitter));

	addss	xmm1, xmm3
; File I:\Vitalya\mine\NSProjectX\xrCore\_random.h

; 39   : 	IC 	float	randF	()							{ return float(randI())/maxF();	}

	cvtsi2ss xmm6, eax
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_Decompress.cpp

; 134  : 			for (u32 tid=0; tid<triCount; tid++)

	mov	eax, DWORD PTR _triCount$1$[esp+400]
; File I:\Vitalya\mine\NSProjectX\xrCore\_random.h

; 39   : 	IC 	float	randF	()							{ return float(randI())/maxF();	}

	mulss	xmm6, xmm7

; 40   : 	IC 	float	randF	(float max)					{ return randF()*max; }

	mulss	xmm6, xmm0
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 23   : 	ICF	SelfRef	set(T _x, T _y, T _z)					{ x = _x;		y = _y;		z = _z;		return *this;	};

	movss	xmm0, DWORD PTR [esi+44]
	movss	DWORD PTR _Item_P$1$sroa$186$1$[esp+400], xmm0
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_Decompress.cpp

; 130  : 			float y		= D.vis.box.min.y-5;

	movss	xmm0, DWORD PTR [esi+32]
; File I:\Vitalya\mine\NSProjectX\xrCore\_random.h

; 41   : 	IC 	float	randF	(float min,float max)		{ return min+randF(max-min); }

	addss	xmm6, xmm3
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_Decompress.cpp

; 130  : 			float y		= D.vis.box.min.y-5;

	movaps	xmm3, xmm0
	subss	xmm3, DWORD PTR __real@40a00000
	addss	xmm6, xmm4
	movss	xmm4, DWORD PTR tv2174[esp+400]
	addss	xmm4, xmm4
	movss	DWORD PTR _y$1$[esp+400], xmm3
	movss	DWORD PTR _Item_P$1$sroa$187$1$[esp+400], xmm6
	mulss	xmm4, xmm5
	addss	xmm4, xmm2
	addss	xmm4, xmm1
	movss	DWORD PTR _Item_P$1$sroa$174$1$[esp+400], xmm4

; 134  : 			for (u32 tid=0; tid<triCount; tid++)

	test	eax, eax
	je	$LN15@cache_Deco
	mov	esi, DWORD PTR _verts$1$[esp+400]
	fstp	ST(0)
; File I:\Vitalya\mine\NSProjectX\xrCore\xrPool.h

; 42   : 		T* E			= list;

	xor	edi, edi
	mov	DWORD PTR tv5060[esp+400], eax
	npad	10
$LL16@cache_Deco:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_Decompress.cpp

; 153  : 				CDB::TRI&	T		= tris[xrc.r_begin()[tid].id];

	mov	ecx, DWORD PTR tv5026[esp+400]
	call	DWORD PTR __imp_?r_begin@xrXRC@@QAEPAURESULT@CDB@@XZ
	mov	edx, DWORD PTR [eax+edi+40]
	shl	edx, 4
	add	edx, DWORD PTR _tris$1$[esp+400]

; 154  : 				Fvector		Tv[3]	= { verts[T.verts[0]],verts[T.verts[1]],verts[T.verts[2]] };

	mov	eax, DWORD PTR [edx]
	lea	ecx, DWORD PTR [eax+eax*2]
	mov	eax, DWORD PTR [esi+ecx*4]
	mov	DWORD PTR _Tv$25[esp+400], eax
	mov	eax, DWORD PTR [esi+ecx*4+4]
	mov	DWORD PTR _Tv$25[esp+404], eax
	mov	eax, DWORD PTR [esi+ecx*4+8]
	mov	DWORD PTR _Tv$25[esp+408], eax
	mov	eax, DWORD PTR [edx+4]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	xmm4, DWORD PTR _Tv$25[esp+400]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_Decompress.cpp

; 154  : 				Fvector		Tv[3]	= { verts[T.verts[0]],verts[T.verts[1]],verts[T.verts[2]] };

	lea	ecx, DWORD PTR [eax+eax*2]
	mov	eax, DWORD PTR [esi+ecx*4]
	mov	DWORD PTR _Tv$25[esp+412], eax
	mov	eax, DWORD PTR [esi+ecx*4+4]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	xmm0, DWORD PTR _Tv$25[esp+412]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_Decompress.cpp

; 154  : 				Fvector		Tv[3]	= { verts[T.verts[0]],verts[T.verts[1]],verts[T.verts[2]] };

	mov	DWORD PTR _Tv$25[esp+416], eax
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	subss	xmm0, xmm4
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_Decompress.cpp

; 154  : 				Fvector		Tv[3]	= { verts[T.verts[0]],verts[T.verts[1]],verts[T.verts[2]] };

	mov	eax, DWORD PTR [esi+ecx*4+8]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	xmm1, DWORD PTR _Tv$25[esp+416]
	subss	xmm1, DWORD PTR _Tv$25[esp+404]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_Decompress.cpp

; 154  : 				Fvector		Tv[3]	= { verts[T.verts[0]],verts[T.verts[1]],verts[T.verts[2]] };

	mov	DWORD PTR _Tv$25[esp+420], eax
	mov	eax, DWORD PTR [edx+8]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	DWORD PTR _edge1$3$sroa$95$1$[esp+400], xmm0
	movss	DWORD PTR _edge1$3$sroa$93$1$[esp+400], xmm1
	movss	xmm1, DWORD PTR _Tv$25[esp+420]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_Decompress.cpp

; 154  : 				Fvector		Tv[3]	= { verts[T.verts[0]],verts[T.verts[1]],verts[T.verts[2]] };

	lea	ecx, DWORD PTR [eax+eax*2]
	mov	eax, DWORD PTR [esi+ecx*4]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	subss	xmm1, DWORD PTR _Tv$25[esp+408]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_Decompress.cpp

; 154  : 				Fvector		Tv[3]	= { verts[T.verts[0]],verts[T.verts[1]],verts[T.verts[2]] };

	mov	DWORD PTR _Tv$25[esp+424], eax
	mov	eax, DWORD PTR [esi+ecx*4+4]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	xmm7, DWORD PTR _Tv$25[esp+424]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_Decompress.cpp

; 154  : 				Fvector		Tv[3]	= { verts[T.verts[0]],verts[T.verts[1]],verts[T.verts[2]] };

	mov	DWORD PTR _Tv$25[esp+428], eax
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	subss	xmm7, xmm4
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_Decompress.cpp

; 154  : 				Fvector		Tv[3]	= { verts[T.verts[0]],verts[T.verts[1]],verts[T.verts[2]] };

	mov	eax, DWORD PTR [esi+ecx*4+8]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	xmm5, DWORD PTR _Tv$25[esp+428]
	subss	xmm5, DWORD PTR _Tv$25[esp+404]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_Decompress.cpp

; 154  : 				Fvector		Tv[3]	= { verts[T.verts[0]],verts[T.verts[1]],verts[T.verts[2]] };

	mov	DWORD PTR _Tv$25[esp+432], eax
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	xmm2, DWORD PTR _Tv$25[esp+432]
	subss	xmm2, DWORD PTR _Tv$25[esp+408]
	movss	DWORD PTR _edge1$3$sroa$91$1$[esp+400], xmm1
	movss	DWORD PTR _edge2$4$sroa$89$1$[esp+400], xmm5

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	movaps	xmm5, xmm0
	movaps	xmm0, xmm1
	mulss	xmm0, xmm7

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	DWORD PTR _edge2$4$sroa$82$1$[esp+400], xmm2

; 273  : 		x = v1.y  * v2.z  - v1.z  * v2.y ;

	xorps	xmm2, DWORD PTR __xmm@80000000800000008000000080000000

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	mulss	xmm5, xmm2

; 273  : 		x = v1.y  * v2.z  - v1.z  * v2.y ;

	movss	DWORD PTR _pvec$5$sroa$79$1$[esp+400], xmm2

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	addss	xmm5, xmm0
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\cl_intersect.h

; 79   : 			if (det < EPS)  return false;

	movss	xmm0, DWORD PTR __real@3727c5ac
	comiss	xmm0, xmm5
	ja	$LN581@cache_Deco
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	xmm3, DWORD PTR _Item_P$1$sroa$187$1$[esp+400]
	movss	xmm2, DWORD PTR _Item_P$1$sroa$174$1$[esp+400]
	subss	xmm3, xmm4
	subss	xmm2, DWORD PTR _Tv$25[esp+408]
	movss	xmm6, DWORD PTR _Item_P$1$sroa$186$1$[esp+400]
	subss	xmm6, DWORD PTR _Tv$25[esp+404]

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	movaps	xmm0, xmm3
	mulss	xmm0, DWORD PTR _pvec$5$sroa$79$1$[esp+400]
	movaps	xmm4, xmm2
	mulss	xmm4, xmm7
	addss	xmm4, xmm0
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\cl_intersect.h

; 82   : 			if (u < 0.0f || u > det) return false;

	xorps	xmm0, xmm0
	comiss	xmm0, xmm4
	ja	$LN581@cache_Deco
	comiss	xmm4, xmm5
	ja	$LN581@cache_Deco
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 273  : 		x = v1.y  * v2.z  - v1.z  * v2.y ;

	movaps	xmm0, xmm2
	movaps	xmm1, xmm6
	mulss	xmm0, DWORD PTR _edge1$3$sroa$93$1$[esp+400]
	mulss	xmm1, DWORD PTR _edge1$3$sroa$91$1$[esp+400]

; 274  : 		y = v1.z  * v2.x  - v1.x  * v2.z ;

	mulss	xmm2, DWORD PTR _edge1$3$sroa$95$1$[esp+400]

; 275  : 		z = v1.x  * v2.y  - v1.y  * v2.x ;

	mulss	xmm6, DWORD PTR _edge1$3$sroa$95$1$[esp+400]
	subss	xmm1, xmm0
	movaps	xmm0, xmm3
	mulss	xmm3, DWORD PTR _edge1$3$sroa$93$1$[esp+400]
	mulss	xmm0, DWORD PTR _edge1$3$sroa$91$1$[esp+400]
	subss	xmm3, xmm6
	subss	xmm2, xmm0
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\cl_intersect.h

; 85   : 			if (v < 0.0f || u + v > det) return false;

	comiss	xmm2, DWORD PTR __real@80000000
	ja	SHORT $LN581@cache_Deco
	subss	xmm4, xmm2
	comiss	xmm4, xmm5
	ja	SHORT $LN581@cache_Deco
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	mulss	xmm2, DWORD PTR _edge2$4$sroa$89$1$[esp+400]
	mulss	xmm3, DWORD PTR _edge2$4$sroa$82$1$[esp+400]
	mulss	xmm1, xmm7
	addss	xmm1, xmm2
	addss	xmm1, xmm3
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_Decompress.cpp

; 157  : 					if (r_range>=0)	{

	movss	xmm3, DWORD PTR _y$1$[esp+400]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\cl_intersect.h

; 88   : 			range *= inv_det;

	divss	xmm1, xmm5
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_Decompress.cpp

; 157  : 					if (r_range>=0)	{

	comiss	xmm1, DWORD PTR __real@00000000
	jb	SHORT $LN14@cache_Deco

; 158  : 						float y_test	= Item_P.y - r_range;

	movss	xmm0, DWORD PTR _Item_P$1$sroa$186$1$[esp+400]
	subss	xmm0, xmm1

; 159  : 						if (y_test>y)	y = y_test;

	comiss	xmm0, xmm3
	jbe	SHORT $LN14@cache_Deco
	movaps	xmm3, xmm0
	movss	DWORD PTR _y$1$[esp+400], xmm3
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\cl_intersect.h

; 79   : 			if (det < EPS)  return false;

	jmp	SHORT $LN14@cache_Deco
$LN581@cache_Deco:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_Decompress.cpp

; 134  : 			for (u32 tid=0; tid<triCount; tid++)

	movss	xmm3, DWORD PTR _y$1$[esp+400]
$LN14@cache_Deco:
	add	edi, 56					; 00000038H
	sub	DWORD PTR tv5060[esp+400], 1
	jne	$LL16@cache_Deco
	mov	esi, DWORD PTR _S$[ebp]
	movss	xmm4, DWORD PTR _Item_P$1$sroa$174$1$[esp+400]
	movss	xmm6, DWORD PTR _Item_P$1$sroa$187$1$[esp+400]
	fld1
	movss	xmm0, DWORD PTR [esi+32]
	movss	xmm7, DWORD PTR __real@38000100
	mov	edi, DWORD PTR _E$1$[esp+400]
$LN15@cache_Deco:

; 164  : 			if (y<D.vis.box.min.y)			continue;

	comiss	xmm0, xmm3
	ja	$LN583@cache_Deco

; 168  : 			Item.scale	= r_scale.randF		(Dobj->m_fMinScale*0.5f,Dobj->m_fMaxScale*0.9f);

	mov	edx, DWORD PTR _Dobj$1$[esp+400]
; File I:\Vitalya\mine\NSProjectX\xrCore\_random.h

; 39   : 	IC 	float	randF	()							{ return float(randI())/maxF();	}

	lea	ecx, DWORD PTR _r_scale$[esp+400]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_Decompress.cpp

; 164  : 			if (y<D.vis.box.min.y)			continue;

	fstp	ST(0)

; 168  : 			Item.scale	= r_scale.randF		(Dobj->m_fMinScale*0.5f,Dobj->m_fMaxScale*0.9f);

	movss	xmm2, DWORD PTR [edx+48]
	movss	xmm1, DWORD PTR [edx+52]
	mulss	xmm2, DWORD PTR __real@3f000000
	mulss	xmm1, DWORD PTR __real@3f666666
; File I:\Vitalya\mine\NSProjectX\xrCore\_random.h

; 39   : 	IC 	float	randF	()							{ return float(randI())/maxF();	}

	call	?randI@CRandom@@QAEHXZ			; CRandom::randI

; 41   : 	IC 	float	randF	(float min,float max)		{ return min+randF(max-min); }

	subss	xmm1, xmm2

; 39   : 	IC 	float	randF	()							{ return float(randI())/maxF();	}

	lea	ecx, DWORD PTR _r_yaw$[esp+400]
	cvtsi2ss xmm0, eax
	mulss	xmm0, xmm7

; 40   : 	IC 	float	randF	(float max)					{ return randF()*max; }

	mulss	xmm0, xmm1

; 41   : 	IC 	float	randF	(float min,float max)		{ return min+randF(max-min); }

	addss	xmm0, xmm2
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_Decompress.cpp

; 168  : 			Item.scale	= r_scale.randF		(Dobj->m_fMinScale*0.5f,Dobj->m_fMaxScale*0.9f);

	movss	DWORD PTR [edi], xmm0
; File I:\Vitalya\mine\NSProjectX\xrCore\_random.h

; 39   : 	IC 	float	randF	()							{ return float(randI())/maxF();	}

	call	?randI@CRandom@@QAEHXZ			; CRandom::randI
	mov	DWORD PTR tv5251[esp+400], eax
	fild	DWORD PTR tv5251[esp+400]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 23   : 	ICF	SelfRef	set(T _x, T _y, T _z)					{ x = _x;		y = _y;		z = _z;		return *this;	};

	mov	DWORD PTR [edi+12], 0
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 280  : 		i.set		(cosa,	0,	   -sina);	_14 = 0;

	mov	DWORD PTR [edi+20], 0
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 23   : 	ICF	SelfRef	set(T _x, T _y, T _z)					{ x = _x;		y = _y;		z = _z;		return *this;	};

	mov	DWORD PTR [edi+24], 0
	mov	DWORD PTR [edi+28], 1065353216		; 3f800000H
; File I:\Vitalya\mine\NSProjectX\xrCore\_random.h

; 40   : 	IC 	float	randF	(float max)					{ return randF()*max; }

	fmul	DWORD PTR __real@3949116d
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 23   : 	ICF	SelfRef	set(T _x, T _y, T _z)					{ x = _x;		y = _y;		z = _z;		return *this;	};

	mov	DWORD PTR [edi+32], 0
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 281  : 		j.set		(0,		1,		0	);	_24 = 0;

	mov	DWORD PTR [edi+36], 0
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 23   : 	ICF	SelfRef	set(T _x, T _y, T _z)					{ x = _x;		y = _y;		z = _z;		return *this;	};

	mov	DWORD PTR [edi+44], 0
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 282  : 		k.set		(sina,  0,		cosa);	_34 = 0;

	mov	DWORD PTR [edi+52], 0
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h

; 653  :             return (float)cos(_X);

	fld	ST(0)
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 23   : 	ICF	SelfRef	set(T _x, T _y, T _z)					{ x = _x;		y = _y;		z = _z;		return *this;	};

	mov	DWORD PTR [edi+56], 0
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h

; 653  :             return (float)cos(_X);

	fcos
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 23   : 	ICF	SelfRef	set(T _x, T _y, T _z)					{ x = _x;		y = _y;		z = _z;		return *this;	};

	mov	DWORD PTR [edi+60], 0
	mov	DWORD PTR [edi+64], 0
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 283  : 		c.set		(0,		0,		0	);	_44 = 1;

	mov	DWORD PTR [edi+68], 1065353216		; 3f800000H
	fst	DWORD PTR _cosa$21[esp+400]
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h

; 754  :             return (float)sin(_X);

	fxch	ST(1)
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 23   : 	ICF	SelfRef	set(T _x, T _y, T _z)					{ x = _x;		y = _y;		z = _z;		return *this;	};

	movss	xmm0, DWORD PTR _cosa$21[esp+400]
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h

; 754  :             return (float)sin(_X);

	fsin
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 23   : 	ICF	SelfRef	set(T _x, T _y, T _z)					{ x = _x;		y = _y;		z = _z;		return *this;	};

	movss	DWORD PTR [edi+48], xmm0
	fxch	ST(1)
	fstp	DWORD PTR [edi+8]
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 280  : 		i.set		(cosa,	0,	   -sina);	_14 = 0;

	fld	ST(0)
	fchs
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 23   : 	ICF	SelfRef	set(T _x, T _y, T _z)					{ x = _x;		y = _y;		z = _z;		return *this;	};

	fstp	DWORD PTR [edi+16]
	fstp	DWORD PTR [edi+40]
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 260  : 		identity(); m[0][0]=x; m[1][1]=y; m[2][2]=z; 

	movss	xmm5, DWORD PTR [edi]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 23   : 	ICF	SelfRef	set(T _x, T _y, T _z)					{ x = _x;		y = _y;		z = _z;		return *this;	};

	movss	DWORD PTR [edi+56], xmm6
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 117  : 		m[1][1] = A.m[0][1] * B.m[1][0] + A.m[1][1] * B.m[1][1] + A.m[2][1] * B.m[1][2];

	movaps	xmm0, xmm5
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 23   : 	ICF	SelfRef	set(T _x, T _y, T _z)					{ x = _x;		y = _y;		z = _z;		return *this;	};

	movss	DWORD PTR [edi+60], xmm3
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 111  : 		m[0][0] = A.m[0][0] * B.m[0][0] + A.m[1][0] * B.m[0][1] + A.m[2][0] * B.m[0][2];

	movaps	xmm6, xmm5
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 23   : 	ICF	SelfRef	set(T _x, T _y, T _z)					{ x = _x;		y = _y;		z = _z;		return *this;	};

	movss	DWORD PTR [edi+64], xmm4
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 112  : 		m[0][1] = A.m[0][1] * B.m[0][0] + A.m[1][1] * B.m[0][1] + A.m[2][1] * B.m[0][2];

	movaps	xmm1, xmm5

; 117  : 		m[1][1] = A.m[0][1] * B.m[1][0] + A.m[1][1] * B.m[1][1] + A.m[2][1] * B.m[1][2];

	mulss	xmm0, DWORD PTR [edi+32]
	movaps	xmm2, xmm5
	mulss	xmm6, DWORD PTR [edi+8]
	movaps	xmm4, xmm5
	mulss	xmm1, DWORD PTR [edi+12]
	movaps	xmm7, xmm5
	mulss	xmm2, DWORD PTR [edi+16]

; 118  : 		m[1][2] = A.m[0][2] * B.m[1][0] + A.m[1][2] * B.m[1][1] + A.m[2][2] * B.m[1][2];
; 119  : 		m[1][3] = 0;
; 120  : 
; 121  : 		m[2][0] = A.m[0][0] * B.m[2][0] + A.m[1][0] * B.m[2][1] + A.m[2][0] * B.m[2][2];

	movaps	xmm3, xmm5

; 122  : 		m[2][1] = A.m[0][1] * B.m[2][0] + A.m[1][1] * B.m[2][1] + A.m[2][1] * B.m[2][2];

	mulss	xmm5, DWORD PTR [edi+44]
	mulss	xmm4, DWORD PTR [edi+24]
	mulss	xmm7, DWORD PTR [edi+28]
	mulss	xmm3, DWORD PTR [edi+40]
	movss	DWORD PTR tv4953[esp+400], xmm0

; 123  : 		m[2][2] = A.m[0][2] * B.m[2][0] + A.m[1][2] * B.m[2][1] + A.m[2][2] * B.m[2][2];

	movss	xmm0, DWORD PTR [edi]
	mulss	xmm0, DWORD PTR [edi+48]
	movss	DWORD PTR tv4955[esp+400], xmm5
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h

; 64   : 		vx.mul				(m.i, B.max.x-B.min.x);	

	movss	xmm5, DWORD PTR [edx+32]
	subss	xmm5, DWORD PTR [edx+20]
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 123  : 		m[2][2] = A.m[0][2] * B.m[2][0] + A.m[1][2] * B.m[2][1] + A.m[2][2] * B.m[2][2];

	movss	DWORD PTR tv4956[esp+400], xmm0
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h

; 64   : 		vx.mul				(m.i, B.max.x-B.min.x);	

	movaps	xmm0, xmm6
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 111  : 		m[0][0] = A.m[0][0] * B.m[0][0] + A.m[1][0] * B.m[0][1] + A.m[2][0] * B.m[0][2];

	movss	DWORD PTR tv4948[esp+400], xmm6

; 112  : 		m[0][1] = A.m[0][1] * B.m[0][0] + A.m[1][1] * B.m[0][1] + A.m[2][1] * B.m[0][2];

	movss	DWORD PTR tv4949[esp+400], xmm1

; 113  : 		m[0][2] = A.m[0][2] * B.m[0][0] + A.m[1][2] * B.m[0][1] + A.m[2][2] * B.m[0][2];

	movss	DWORD PTR tv4950[esp+400], xmm2
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h

; 64   : 		vx.mul				(m.i, B.max.x-B.min.x);	

	mulss	xmm0, xmm5
	movss	DWORD PTR tv4754[esp+400], xmm0
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 42   : 	ICF SelfRef	mul(const Self &a, T s)					{ x=a.x*s;  y=a.y*s;	z=a.z*s;		return *this;	};

	movss	DWORD PTR _vx$26[esp+400], xmm0
	movaps	xmm0, xmm5
	mulss	xmm0, xmm1
	movss	DWORD PTR tv4756[esp+400], xmm0
	movss	DWORD PTR _vx$26[esp+404], xmm0
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h

; 25   : 	IC BOOL negative(const float &f)	{ return (*((unsigned*)(&f))&fdSGN);	}

	test	DWORD PTR _vx$26[esp+400], -2147483648	; 80000000H
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h

; 65   : 		vy.mul				(m.j, B.max.y-B.min.y);	

	movaps	xmm1, xmm4
	movss	xmm0, DWORD PTR [edx+36]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 42   : 	ICF SelfRef	mul(const Self &a, T s)					{ x=a.x*s;  y=a.y*s;	z=a.z*s;		return *this;	};

	mulss	xmm5, xmm2
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h

; 65   : 		vy.mul				(m.j, B.max.y-B.min.y);	

	movss	xmm2, DWORD PTR [edx+24]
	subss	xmm0, xmm2
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 42   : 	ICF SelfRef	mul(const Self &a, T s)					{ x=a.x*s;  y=a.y*s;	z=a.z*s;		return *this;	};

	movss	DWORD PTR tv4797[esp+400], xmm5
	movss	DWORD PTR _vx$26[esp+408], xmm5
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h

; 65   : 		vy.mul				(m.j, B.max.y-B.min.y);	

	mulss	xmm1, xmm0
	movss	DWORD PTR tv4800[esp+400], xmm1
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 42   : 	ICF SelfRef	mul(const Self &a, T s)					{ x=a.x*s;  y=a.y*s;	z=a.z*s;		return *this;	};

	movss	DWORD PTR _vy$24[esp+400], xmm1
	movaps	xmm1, xmm7
	mulss	xmm1, xmm0
	movss	DWORD PTR _vy$24[esp+404], xmm1
	movss	xmm1, DWORD PTR tv4953[esp+400]
	mulss	xmm1, xmm0
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h

; 66   : 		vz.mul				(m.k, B.max.z-B.min.z);	

	movss	xmm0, DWORD PTR [edx+40]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 42   : 	ICF SelfRef	mul(const Self &a, T s)					{ x=a.x*s;  y=a.y*s;	z=a.z*s;		return *this;	};

	movss	DWORD PTR _vy$24[esp+408], xmm1
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h

; 66   : 		vz.mul				(m.k, B.max.z-B.min.z);	

	movss	xmm1, DWORD PTR [edx+28]
	subss	xmm0, xmm1
	movaps	xmm5, xmm0
	mulss	xmm5, xmm3
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 42   : 	ICF SelfRef	mul(const Self &a, T s)					{ x=a.x*s;  y=a.y*s;	z=a.z*s;		return *this;	};

	movss	DWORD PTR _vz$23[esp+400], xmm5
	movss	xmm5, DWORD PTR tv4955[esp+400]
	movaps	xmm6, xmm5
	mulss	xmm6, xmm0
	movss	DWORD PTR _vz$23[esp+404], xmm6
	movss	xmm6, DWORD PTR tv4956[esp+400]
	mulss	xmm6, xmm0
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 499  : 		dest.x = v.x*_11 + v.y*_21 + v.z*_31 + _41;

	movss	xmm0, DWORD PTR [edx+20]
	mulss	xmm0, DWORD PTR tv4948[esp+400]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 42   : 	ICF SelfRef	mul(const Self &a, T s)					{ x=a.x*s;  y=a.y*s;	z=a.z*s;		return *this;	};

	movss	DWORD PTR _vz$23[esp+408], xmm6
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 499  : 		dest.x = v.x*_11 + v.y*_21 + v.z*_31 + _41;

	movss	DWORD PTR _ItemBB$1$[esp+400], xmm0
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 42   : 	ICF SelfRef	mul(const Self &a, T s)					{ x=a.x*s;  y=a.y*s;	z=a.z*s;		return *this;	};

	movaps	xmm0, xmm2
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 499  : 		dest.x = v.x*_11 + v.y*_21 + v.z*_31 + _41;

	movss	xmm6, DWORD PTR _ItemBB$1$[esp+400]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 42   : 	ICF SelfRef	mul(const Self &a, T s)					{ x=a.x*s;  y=a.y*s;	z=a.z*s;		return *this;	};

	mulss	xmm0, xmm4
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 499  : 		dest.x = v.x*_11 + v.y*_21 + v.z*_31 + _41;

	addss	xmm6, xmm0
	movaps	xmm0, xmm1
	mulss	xmm0, xmm3

; 500  : 		dest.y = v.x*_12 + v.y*_22 + v.z*_32 + _42;

	movss	xmm3, DWORD PTR [edx+20]
	movaps	xmm4, xmm3

; 501  : 		dest.z = v.x*_13 + v.y*_23 + v.z*_33 + _43;

	mulss	xmm3, DWORD PTR tv4950[esp+400]
	addss	xmm0, DWORD PTR [edi+56]
	mulss	xmm4, DWORD PTR tv4949[esp+400]
	addss	xmm6, xmm0
	movaps	xmm0, xmm2
	mulss	xmm2, DWORD PTR tv4953[esp+400]
	mulss	xmm0, xmm7
	addss	xmm3, xmm2
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 24   : 	ICF SelfRef	set(const _vector3<float> &v)			{ x = T(v.x);	y = T(v.y);	z = T(v.z);	return *this;	};

	movaps	xmm2, xmm6
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 500  : 		dest.y = v.x*_12 + v.y*_22 + v.z*_32 + _42;

	addss	xmm4, xmm0
	movaps	xmm0, xmm1

; 501  : 		dest.z = v.x*_13 + v.y*_23 + v.z*_33 + _43;

	mulss	xmm1, DWORD PTR tv4956[esp+400]
	mulss	xmm0, xmm5
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h

; 25   : 	IC BOOL negative(const float &f)	{ return (*((unsigned*)(&f))&fdSGN);	}

	movaps	xmm5, xmm6
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 501  : 		dest.z = v.x*_13 + v.y*_23 + v.z*_33 + _43;

	addss	xmm1, DWORD PTR [edi+64]
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h

; 25   : 	IC BOOL negative(const float &f)	{ return (*((unsigned*)(&f))&fdSGN);	}

	addss	xmm5, DWORD PTR tv4754[esp+400]
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 500  : 		dest.y = v.x*_12 + v.y*_22 + v.z*_32 + _42;

	addss	xmm0, DWORD PTR [edi+60]

; 501  : 		dest.z = v.x*_13 + v.y*_23 + v.z*_33 + _43;

	addss	xmm3, xmm1
	addss	xmm4, xmm0
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 24   : 	ICF SelfRef	set(const _vector3<float> &v)			{ x = T(v.x);	y = T(v.y);	z = T(v.z);	return *this;	};

	movaps	xmm0, xmm3
	movaps	xmm1, xmm4
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h

; 74   : 		if(negative(vx.x))	min.x += vx.x; else max.x += vx.x;

	je	SHORT $LN391@cache_Deco
	movaps	xmm6, xmm5
	jmp	SHORT $LN392@cache_Deco
$LN391@cache_Deco:
	movaps	xmm2, xmm5
$LN392@cache_Deco:
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h

; 25   : 	IC BOOL negative(const float &f)	{ return (*((unsigned*)(&f))&fdSGN);	}

	test	DWORD PTR _vx$26[esp+404], -2147483648	; 80000000H
	movaps	xmm7, xmm6
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h

; 75   : 		if(negative(vx.y))	min.y += vx.y; else max.y += vx.y;

	je	SHORT $LN393@cache_Deco
	addss	xmm4, DWORD PTR tv4756[esp+400]
	jmp	SHORT $LN394@cache_Deco
$LN393@cache_Deco:
	movaps	xmm1, xmm4
	addss	xmm1, DWORD PTR tv4756[esp+400]
$LN394@cache_Deco:
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h

; 25   : 	IC BOOL negative(const float &f)	{ return (*((unsigned*)(&f))&fdSGN);	}

	test	DWORD PTR _vx$26[esp+408], -2147483648	; 80000000H
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h

; 76   : 		if(negative(vx.z))	min.z += vx.z; else max.z += vx.z;

	je	SHORT $LN395@cache_Deco
	addss	xmm3, DWORD PTR tv4797[esp+400]
	jmp	SHORT $LN396@cache_Deco
$LN395@cache_Deco:
	movss	xmm0, DWORD PTR tv4797[esp+400]
	addss	xmm0, xmm3
$LN396@cache_Deco:
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h

; 25   : 	IC BOOL negative(const float &f)	{ return (*((unsigned*)(&f))&fdSGN);	}

	test	DWORD PTR _vy$24[esp+400], -2147483648	; 80000000H
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h

; 77   : 		if(negative(vy.x))	min.x += vy.x; else max.x += vy.x;

	je	SHORT $LN397@cache_Deco
	movss	xmm6, DWORD PTR tv4800[esp+400]
	addss	xmm6, xmm7
	jmp	SHORT $LN398@cache_Deco
$LN397@cache_Deco:
	addss	xmm2, DWORD PTR tv4800[esp+400]
$LN398@cache_Deco:
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h

; 25   : 	IC BOOL negative(const float &f)	{ return (*((unsigned*)(&f))&fdSGN);	}

	test	DWORD PTR _vy$24[esp+404], -2147483648	; 80000000H
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h

; 78   : 		if(negative(vy.y))	min.y += vy.y; else max.y += vy.y;

	je	SHORT $LN399@cache_Deco
	addss	xmm4, DWORD PTR _vy$24[esp+404]
	jmp	SHORT $LN400@cache_Deco
$LN399@cache_Deco:
	addss	xmm1, DWORD PTR _vy$24[esp+404]
$LN400@cache_Deco:
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h

; 25   : 	IC BOOL negative(const float &f)	{ return (*((unsigned*)(&f))&fdSGN);	}

	test	DWORD PTR _vy$24[esp+408], -2147483648	; 80000000H
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h

; 79   : 		if(negative(vy.z))	min.z += vy.z; else max.z += vy.z;

	je	SHORT $LN401@cache_Deco
	addss	xmm3, DWORD PTR _vy$24[esp+408]
	jmp	SHORT $LN402@cache_Deco
$LN401@cache_Deco:
	addss	xmm0, DWORD PTR _vy$24[esp+408]
$LN402@cache_Deco:
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h

; 25   : 	IC BOOL negative(const float &f)	{ return (*((unsigned*)(&f))&fdSGN);	}

	test	DWORD PTR _vz$23[esp+400], -2147483648	; 80000000H
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h

; 80   : 		if(negative(vz.x))	min.x += vz.x; else max.x += vz.x;

	je	SHORT $LN403@cache_Deco
	addss	xmm6, DWORD PTR _vz$23[esp+400]
	jmp	SHORT $LN404@cache_Deco
$LN403@cache_Deco:
	addss	xmm2, DWORD PTR _vz$23[esp+400]
$LN404@cache_Deco:
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h

; 25   : 	IC BOOL negative(const float &f)	{ return (*((unsigned*)(&f))&fdSGN);	}

	test	DWORD PTR _vz$23[esp+404], -2147483648	; 80000000H
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h

; 81   : 		if(negative(vz.y))	min.y += vz.y; else max.y += vz.y;

	je	SHORT $LN405@cache_Deco
	addss	xmm4, DWORD PTR _vz$23[esp+404]
	jmp	SHORT $LN406@cache_Deco
$LN405@cache_Deco:
	addss	xmm1, DWORD PTR _vz$23[esp+404]
$LN406@cache_Deco:
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h

; 25   : 	IC BOOL negative(const float &f)	{ return (*((unsigned*)(&f))&fdSGN);	}

	test	DWORD PTR _vz$23[esp+408], -2147483648	; 80000000H
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h

; 82   : 		if(negative(vz.z))	min.z += vz.z; else max.z += vz.z;

	je	SHORT $LN407@cache_Deco
	addss	xmm3, DWORD PTR _vz$23[esp+408]
	jmp	SHORT $LN408@cache_Deco
$LN407@cache_Deco:
	addss	xmm0, DWORD PTR _vz$23[esp+408]
$LN408@cache_Deco:
; File I:\Vitalya\mine\NSProjectX\xrCore\_std_extensions.h

; 93   : template <class T>	IC T		_min	(T a, T b)	{ return a<b?a:b;	}

	movss	xmm5, DWORD PTR _Bounds$2$[esp+400]
	comiss	xmm6, xmm5
	jbe	SHORT $LN446@cache_Deco
	movss	DWORD PTR _Bounds$2$[esp+400], xmm5
	jmp	SHORT $LN447@cache_Deco
$LN446@cache_Deco:
	movss	DWORD PTR _Bounds$2$[esp+400], xmm6
$LN447@cache_Deco:
	movss	xmm7, DWORD PTR _Bounds$4$[esp+400]
	comiss	xmm4, xmm7
	jbe	SHORT $LN450@cache_Deco
	movss	DWORD PTR _Bounds$4$[esp+400], xmm7
	jmp	SHORT $LN451@cache_Deco
$LN450@cache_Deco:
	movaps	xmm7, xmm4
	movss	DWORD PTR _Bounds$4$[esp+400], xmm4
$LN451@cache_Deco:
	movss	xmm5, DWORD PTR _Bounds$6$[esp+400]
	comiss	xmm3, xmm5
	jbe	SHORT $LN454@cache_Deco
	movss	DWORD PTR _Bounds$6$[esp+400], xmm5
	jmp	SHORT $LN455@cache_Deco
$LN454@cache_Deco:
	movss	DWORD PTR _Bounds$6$[esp+400], xmm3
$LN455@cache_Deco:

; 94   : template <class T>	IC T		_max	(T a, T b)	{ return a>b?a:b;	}

	movss	xmm5, DWORD PTR _Bounds$8$[esp+400]
	comiss	xmm5, xmm6
	jbe	SHORT $LN460@cache_Deco
	movss	DWORD PTR _Bounds$8$[esp+400], xmm5
	jmp	SHORT $LN461@cache_Deco
$LN460@cache_Deco:
	movaps	xmm5, xmm6
	movss	DWORD PTR _Bounds$8$[esp+400], xmm6
$LN461@cache_Deco:
	movss	xmm6, DWORD PTR _Bounds$10$[esp+400]
	comiss	xmm6, xmm4
	jbe	SHORT $LN464@cache_Deco
	movss	DWORD PTR _Bounds$10$[esp+400], xmm6
	jmp	SHORT $LN465@cache_Deco
$LN464@cache_Deco:
	movaps	xmm6, xmm4
	movss	DWORD PTR _Bounds$10$[esp+400], xmm4
$LN465@cache_Deco:
	movss	xmm4, DWORD PTR _Bounds$12$[esp+400]
	comiss	xmm4, xmm3
	jbe	SHORT $LN468@cache_Deco
	movss	DWORD PTR _Bounds$12$[esp+400], xmm4
	jmp	SHORT $LN469@cache_Deco
$LN468@cache_Deco:
	movaps	xmm4, xmm3
	movss	DWORD PTR _Bounds$12$[esp+400], xmm3
$LN469@cache_Deco:

; 93   : template <class T>	IC T		_min	(T a, T b)	{ return a<b?a:b;	}

	comiss	xmm2, DWORD PTR _Bounds$2$[esp+400]
	ja	SHORT $LN477@cache_Deco
	movss	DWORD PTR _Bounds$2$[esp+400], xmm2
$LN477@cache_Deco:
	comiss	xmm1, xmm7
	ja	SHORT $LN481@cache_Deco
	movaps	xmm3, xmm1
	movss	DWORD PTR _Bounds$4$[esp+400], xmm3
$LN481@cache_Deco:
	comiss	xmm0, DWORD PTR _Bounds$6$[esp+400]
	ja	SHORT $LN485@cache_Deco
	movss	DWORD PTR _Bounds$6$[esp+400], xmm0
$LN485@cache_Deco:

; 94   : template <class T>	IC T		_max	(T a, T b)	{ return a>b?a:b;	}

	comiss	xmm5, xmm2
	ja	SHORT $LN491@cache_Deco
	movss	DWORD PTR _Bounds$8$[esp+400], xmm2
$LN491@cache_Deco:
	comiss	xmm6, xmm1
	ja	SHORT $LN495@cache_Deco
	movss	DWORD PTR _Bounds$10$[esp+400], xmm1
$LN495@cache_Deco:
	comiss	xmm4, xmm0
	ja	SHORT $LN499@cache_Deco
	movss	DWORD PTR _Bounds$12$[esp+400], xmm0
$LN499@cache_Deco:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_Decompress.cpp

; 194  : 			Item.c_rgb.x					=	DS.r_qclr	(DS.c_r,	15);

	mov	ecx, DWORD PTR _DS$1$[esp+400]
	mov	eax, DWORD PTR [ecx+4]
	shr	eax, 20					; 00000014H
	and	eax, 15					; 0000000fH
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\detailformat.h

; 103  : 	float			r_qclr		(u32 v,   u32 range)	{	return float(v)/float(range); }

	mov	DWORD PTR tv5112[esp+400], eax
	fild	DWORD PTR tv5112[esp+400]
	jns	SHORT $LN659@cache_Deco
	fadd	DWORD PTR __real@4f800000
$LN659@cache_Deco:
	fld	DWORD PTR __real@3d888889
	movss	xmm2, DWORD PTR __real@3d888889
	fmul	ST(1), ST(0)
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_Decompress.cpp

; 194  : 			Item.c_rgb.x					=	DS.r_qclr	(DS.c_r,	15);

	fxch	ST(1)
	fstp	DWORD PTR [edi+84]

; 195  : 			Item.c_rgb.y					=	DS.r_qclr	(DS.c_g,	15);

	mov	al, BYTE PTR [ecx+7]
	and	al, 15					; 0000000fH
	movzx	eax, al
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\detailformat.h

; 103  : 	float			r_qclr		(u32 v,   u32 range)	{	return float(v)/float(range); }

	cvtsi2ss xmm0, eax
	mulss	xmm0, xmm2
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_Decompress.cpp

; 195  : 			Item.c_rgb.y					=	DS.r_qclr	(DS.c_g,	15);

	movss	DWORD PTR [edi+88], xmm0

; 196  : 			Item.c_rgb.z					=	DS.r_qclr	(DS.c_b,	15);

	mov	eax, DWORD PTR [ecx+4]
	shr	eax, 28					; 0000001cH
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\detailformat.h

; 103  : 	float			r_qclr		(u32 v,   u32 range)	{	return float(v)/float(range); }

	mov	DWORD PTR tv5111[esp+400], eax
	fild	DWORD PTR tv5111[esp+400]
	test	eax, eax
	jns	SHORT $LN660@cache_Deco
	fadd	DWORD PTR __real@4f800000
$LN660@cache_Deco:
	fmul	ST(0), ST(1)
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_Decompress.cpp

; 196  : 			Item.c_rgb.z					=	DS.r_qclr	(DS.c_b,	15);

	fstp	DWORD PTR [edi+92]

; 198  : 			Item.c_hemi						=	DS.r_qclr	(DS.c_hemi,	15);

	mov	ax, WORD PTR [ecx+6]
	and	ax, 15					; 0000000fH
	movzx	eax, ax
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\detailformat.h

; 103  : 	float			r_qclr		(u32 v,   u32 range)	{	return float(v)/float(range); }

	cvtsi2ss xmm0, eax
	mulss	xmm0, xmm2
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_Decompress.cpp

; 198  : 			Item.c_hemi						=	DS.r_qclr	(DS.c_hemi,	15);

	movss	DWORD PTR [edi+76], xmm0

; 199  : 			Item.c_sun						=	DS.r_qclr	(DS.c_dir,	15);

	mov	eax, DWORD PTR [ecx+4]
	shr	eax, 12					; 0000000cH
	and	eax, 15					; 0000000fH
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\detailformat.h

; 103  : 	float			r_qclr		(u32 v,   u32 range)	{	return float(v)/float(range); }

	mov	DWORD PTR tv5110[esp+400], eax
	fild	DWORD PTR tv5110[esp+400]
	jns	SHORT $LN661@cache_Deco
	fadd	DWORD PTR __real@4f800000
$LN661@cache_Deco:
	fmulp	ST(1), ST(0)
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_Decompress.cpp

; 199  : 			Item.c_sun						=	DS.r_qclr	(DS.c_dir,	15);

	fstp	DWORD PTR [edi+80]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\detailmanager.h

; 123  : 	IC bool							UseVS			()		{ return HW.Caps.geometry_major >= 1; }

	mov	eax, DWORD PTR __imp_?HW@@3VCHW@@A
	cmp	WORD PTR [eax+48], 1
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_Decompress.cpp

; 205  : 			if (!UseVS())

	jae	SHORT $LN30@cache_Deco

; 206  : 			{
; 207  : 				// Always still on CPU pipe
; 208  : 				Item.vis_ID	= 0;

	mov	DWORD PTR [edi+72], 0

; 209  : 			} else {

	jmp	SHORT $LN34@cache_Deco
$LN30@cache_Deco:
; File I:\Vitalya\mine\NSProjectX\xrCore\_flags.h

; 23   : 	IC 	BOOL	is		(const T mask)						const	{ return mask==(flags&mask);			}

	test	BYTE PTR [edx+44], 1
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_Decompress.cpp

; 210  : 				if (Dobj->m_Flags.is(DO_NO_WAVING))	Item.vis_ID	= 0;

	je	SHORT $LN32@cache_Deco
	mov	DWORD PTR [edi+72], 0
	jmp	SHORT $LN34@cache_Deco
$LN32@cache_Deco:
; File I:\Vitalya\mine\NSProjectX\xrCore\_random.h

; 33   : 	IC 	s32		randI	(s32 max)					{ VERIFY(max);  return randI()%max; }

	mov	ecx, DWORD PTR __imp_?Random@@3VCRandom@@A
	call	?randI@CRandom@@QAEHXZ			; CRandom::randI
	cdq
	mov	ecx, 3
	idiv	ecx
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_Decompress.cpp

; 213  : 					if (::Random.randI(0,3)==0)	Item.vis_ID	= 2;	// Second wave

	neg	edx
	sbb	edx, edx
	add	edx, 2
	mov	DWORD PTR [edi+72], edx
$LN34@cache_Deco:

; 214  : 					else						Item.vis_ID = 1;	// First wave
; 215  : 				}
; 216  : 			}
; 217  : 
; 218  : 			// Save it
; 219  : 			D.G[index].items.push_back(ItemP);

	imul	ecx, DWORD PTR _index$1$[esp+400], 52
	add	ecx, 72					; 00000048H
	add	ecx, esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 730  :         if (_Mylast != _My_data._Myend) {

	mov	eax, DWORD PTR [ecx+4]
	cmp	eax, DWORD PTR [ecx+8]
	je	SHORT $LN524@cache_Deco

; 713  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

	mov	DWORD PTR [eax], edi

; 714  :         _Orphan_range(_Mylast, _Mylast);
; 715  :         _Ty& _Result = *_Mylast;
; 716  :         ++_Mylast;

	add	DWORD PTR [ecx+4], 4

; 731  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

	jmp	SHORT $LN664@cache_Deco
$LN524@cache_Deco:

; 732  :         }
; 733  : 
; 734  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	lea	edx, DWORD PTR _ItemP$20[esp+400]
	push	edx
	push	eax
	call	??$_Emplace_reallocate@ABQAUSlotItem@CDetailManager@@@?$vector@PAUSlotItem@CDetailManager@@V?$xalloc@PAUSlotItem@CDetailManager@@@@@std@@QAEPAPAUSlotItem@CDetailManager@@QAPAU23@ABQAU23@@Z ; std::vector<CDetailManager::SlotItem *,xalloc<CDetailManager::SlotItem *> >::_Emplace_reallocate<CDetailManager::SlotItem * const &>
$LN664@cache_Deco:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_Decompress.cpp

; 100  : 		for (u32 x=0; x<=d_size; x++)

	fld1
$LN583@cache_Deco:
	movss	xmm0, DWORD PTR __real@3f800000
	movss	xmm1, DWORD PTR __real@3f000000
$LN11@cache_Deco:
	mov	edx, DWORD PTR _x$1$[esp+400]
	mov	esi, DWORD PTR _d_size$1$[esp+400]
	inc	edx
	mov	DWORD PTR _x$1$[esp+400], edx
	cmp	edx, esi
	jbe	$LN13@cache_Deco

; 98   : 	for (u32 z=0; z<=d_size; z++)

	mov	eax, DWORD PTR _z$1$[esp+400]
	inc	eax
	mov	DWORD PTR _z$1$[esp+400], eax
	cmp	eax, esi
	jbe	$LN10@cache_Deco

; 220  : 		}
; 221  : 	}
; 222  : 
; 223  : 	// Update bounds to more tight and real ones
; 224  : 	D.vis.clear			();

	mov	eax, DWORD PTR _S$[ebp]
	fstp	ST(0)
	lea	ecx, DWORD PTR [eax+12]
	call	?clear@vis_data@@QAEXXZ			; vis_data::clear
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 24   : 	ICF SelfRef	set(const _vector3<float> &v)			{ x = T(v.x);	y = T(v.y);	z = T(v.z);	return *this;	};

	movss	xmm2, DWORD PTR _Bounds$4$[esp+400]
	movss	xmm3, DWORD PTR _Bounds$6$[esp+400]
	movss	xmm0, DWORD PTR _Bounds$8$[esp+400]
	movss	xmm6, DWORD PTR _Bounds$10$[esp+400]
	movss	xmm4, DWORD PTR _Bounds$12$[esp+400]
	movss	xmm5, DWORD PTR _Bounds$2$[esp+400]
	movss	DWORD PTR [eax+40], xmm0
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h

; 97   : 		C.x = (min.x + max.x) * 0.5f;

	addss	xmm0, xmm5
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 24   : 	ICF SelfRef	set(const _vector3<float> &v)			{ x = T(v.x);	y = T(v.y);	z = T(v.z);	return *this;	};

	movss	DWORD PTR [eax+32], xmm2
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h

; 98   : 		C.y = (min.y + max.y) * 0.5f;

	addss	xmm2, xmm6
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 24   : 	ICF SelfRef	set(const _vector3<float> &v)			{ x = T(v.x);	y = T(v.y);	z = T(v.z);	return *this;	};

	movss	DWORD PTR [eax+36], xmm3
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h

; 99   : 		C.z = (min.z + max.z) * 0.5f;

	addss	xmm3, xmm4
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 24   : 	ICF SelfRef	set(const _vector3<float> &v)			{ x = T(v.x);	y = T(v.y);	z = T(v.z);	return *this;	};

	movss	DWORD PTR [eax+28], xmm5
	movss	DWORD PTR [eax+44], xmm6
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h

; 97   : 		C.x = (min.x + max.x) * 0.5f;

	mulss	xmm0, xmm1

; 98   : 		C.y = (min.y + max.y) * 0.5f;

	mulss	xmm2, xmm1

; 99   : 		C.z = (min.z + max.z) * 0.5f;

	mulss	xmm3, xmm1
	movss	DWORD PTR [ecx], xmm0
	movss	DWORD PTR [ecx+4], xmm2
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 287  : 	{	return (x-v.x)*(x-v.x) + (y-v.y)*(y-v.y) + (z-v.z)*(z-v.z);	}

	subss	xmm2, xmm6
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h

; 99   : 		C.z = (min.z + max.z) * 0.5f;

	movss	DWORD PTR [ecx+8], xmm3
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 287  : 	{	return (x-v.x)*(x-v.x) + (y-v.y)*(y-v.y) + (z-v.z)*(z-v.z);	}

	subss	xmm3, xmm4

; 24   : 	ICF SelfRef	set(const _vector3<float> &v)			{ x = T(v.x);	y = T(v.y);	z = T(v.z);	return *this;	};

	movss	DWORD PTR [eax+48], xmm4

; 287  : 	{	return (x-v.x)*(x-v.x) + (y-v.y)*(y-v.y) + (z-v.z)*(z-v.z);	}

	subss	xmm0, DWORD PTR [eax+40]
	mulss	xmm2, xmm2
	mulss	xmm3, xmm3
	mulss	xmm0, xmm0
	addss	xmm0, xmm2
	addss	xmm0, xmm3
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h

; 764  :             return (float)sqrt(_X);

	sqrtss	xmm0, xmm0
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h

; 116  : 		R = C.distance_to	(max);

	movss	DWORD PTR [eax+24], xmm0
$LN1@cache_Deco:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_Decompress.cpp

; 227  : }

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
$LN574@cache_Deco:
	DD	$LN231@cache_Deco
	DD	$LN232@cache_Deco
	DD	$LN233@cache_Deco
	DD	$LN234@cache_Deco
?cache_Decompress@CDetailManager@@QAEXPAUSlot@1@@Z ENDP	; CDetailManager::cache_Decompress
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\cl_intersect.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\cl_intersect.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\cl_intersect.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\cl_intersect.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\cl_intersect.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\cl_intersect.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\cl_intersect.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\cl_intersect.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\cl_intersect.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\cl_intersect.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\cl_intersect.h
;	COMDAT ?TestRayTri@CDB@@YA_NABU?$_vector3@M@@0PAU2@AAM22_N@Z
_TEXT	SEGMENT
tv927 = -24						; size = 4
tv926 = -20						; size = 4
tv908 = -16						; size = 4
tv915 = -12						; size = 4
tv907 = -8						; size = 4
tv906 = -4						; size = 4
tv905 = 8						; size = 4
_p$ = 8							; size = 4
_u$ = 12						; size = 4
_v$ = 16						; size = 4
_range$ = 20						; size = 4
_bCull$dead$ = 24					; size = 1
?TestRayTri@CDB@@YA_NABU?$_vector3@M@@0PAU2@AAM22_N@Z PROC ; CDB::TestRayTri, COMDAT
; _C$ = ecx
; _D$ = edx

; 68   : 	{

	sub	esp, 24					; 00000018H

; 69   : 		Fvector edge1, edge2, tvec, pvec, qvec;
; 70   : 		float det,inv_det;
; 71   : 		// find vectors for two edges sharing vert0
; 72   : 		edge1.sub(p[1], p[0]);

	mov	eax, DWORD PTR _p$[esp+20]
	push	esi
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	xmm0, DWORD PTR [eax+32]
	subss	xmm0, DWORD PTR [eax+8]
	movss	xmm4, DWORD PTR [eax+28]
	subss	xmm4, DWORD PTR [eax+4]
	movss	xmm6, DWORD PTR [eax+24]
	subss	xmm6, DWORD PTR [eax]
	movss	xmm1, DWORD PTR [eax+12]

; 273  : 		x = v1.y  * v2.z  - v1.z  * v2.y ;

	movaps	xmm5, xmm0
	mulss	xmm5, DWORD PTR [edx+4]

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	xmm2, DWORD PTR [eax+16]
	subss	xmm1, DWORD PTR [eax]
	subss	xmm2, DWORD PTR [eax+4]
	movss	DWORD PTR tv908[esp+28], xmm0

; 274  : 		y = v1.z  * v2.x  - v1.x  * v2.z ;

	movaps	xmm7, xmm6
	mulss	xmm7, DWORD PTR [edx+8]
	movaps	xmm0, xmm4
	mulss	xmm0, DWORD PTR [edx+8]

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	xmm3, DWORD PTR [eax+20]
	subss	xmm3, DWORD PTR [eax+8]

; 273  : 		x = v1.y  * v2.z  - v1.z  * v2.y ;

	subss	xmm5, xmm0

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	DWORD PTR tv907[esp+28], xmm4

; 274  : 		y = v1.z  * v2.x  - v1.x  * v2.z ;

	movss	xmm0, DWORD PTR tv908[esp+28]
	mulss	xmm0, DWORD PTR [edx]

; 275  : 		z = v1.x  * v2.y  - v1.y  * v2.x ;

	mulss	xmm4, DWORD PTR [edx]
	subss	xmm7, xmm0

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	DWORD PTR tv906[esp+28], xmm6

; 275  : 		z = v1.x  * v2.y  - v1.y  * v2.x ;

	movaps	xmm0, xmm6

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	DWORD PTR tv926[esp+28], xmm1

; 275  : 		z = v1.x  * v2.y  - v1.y  * v2.x ;

	mulss	xmm0, DWORD PTR [edx+4]

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	DWORD PTR tv927[esp+28], xmm2

; 275  : 		z = v1.x  * v2.y  - v1.y  * v2.x ;

	movaps	xmm6, xmm7

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	DWORD PTR tv905[esp+24], xmm3

; 275  : 		z = v1.x  * v2.y  - v1.y  * v2.x ;

	subss	xmm4, xmm0
	mulss	xmm6, xmm2

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	movaps	xmm0, xmm5
	mulss	xmm0, xmm1

; 275  : 		z = v1.x  * v2.y  - v1.y  * v2.x ;

	movss	DWORD PTR tv915[esp+28], xmm4

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	addss	xmm6, xmm0
	movaps	xmm0, xmm4
	mulss	xmm0, xmm3
	addss	xmm6, xmm0
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\cl_intersect.h

; 79   : 			if (det < EPS)  return false;

	movss	xmm0, DWORD PTR __real@3727c5ac
	comiss	xmm0, xmm6
	ja	$LN6@TestRayTri
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	xmm4, DWORD PTR [ecx]
	movss	xmm3, DWORD PTR [ecx+4]
	subss	xmm4, DWORD PTR [eax]
	subss	xmm3, DWORD PTR [eax+4]
	movss	xmm1, DWORD PTR [ecx+8]
	subss	xmm1, DWORD PTR [eax+8]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\cl_intersect.h

; 81   : 			u = tvec.dotproduct(pvec);			// calculate U parameter and test bounds

	mov	esi, DWORD PTR _u$[esp+24]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	movaps	xmm0, xmm4

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movaps	xmm2, xmm3

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	mulss	xmm0, xmm5

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	mulss	xmm2, xmm7
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\cl_intersect.h

; 82   : 			if (u < 0.0f || u > det) return false;

	xorps	xmm7, xmm7
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	addss	xmm2, xmm0
	movaps	xmm0, xmm1
	mulss	xmm0, DWORD PTR tv915[esp+28]
	addss	xmm2, xmm0
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\cl_intersect.h

; 82   : 			if (u < 0.0f || u > det) return false;

	comiss	xmm7, xmm2
	movss	DWORD PTR [esi], xmm2
	ja	$LN6@TestRayTri
	comiss	xmm2, xmm6
	ja	$LN6@TestRayTri
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 273  : 		x = v1.y  * v2.z  - v1.z  * v2.y ;

	movaps	xmm5, xmm3
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\cl_intersect.h

; 84   : 			v = D.dotproduct(qvec);			// calculate V parameter and test bounds

	mov	ecx, DWORD PTR _v$[esp+24]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 273  : 		x = v1.y  * v2.z  - v1.z  * v2.y ;

	mulss	xmm5, DWORD PTR tv905[esp+24]
	movaps	xmm0, xmm1
	mulss	xmm0, DWORD PTR tv927[esp+28]
	mulss	xmm1, DWORD PTR tv926[esp+28]

; 275  : 		z = v1.x  * v2.y  - v1.y  * v2.x ;

	mulss	xmm3, DWORD PTR tv926[esp+28]
	subss	xmm5, xmm0
	movaps	xmm0, xmm4
	mulss	xmm4, DWORD PTR tv927[esp+28]
	mulss	xmm0, DWORD PTR tv905[esp+24]
	subss	xmm4, xmm3

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	movaps	xmm3, xmm5
	mulss	xmm3, DWORD PTR [edx]

; 274  : 		y = v1.z  * v2.x  - v1.x  * v2.z ;

	subss	xmm1, xmm0

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	movaps	xmm0, xmm1
	mulss	xmm0, DWORD PTR [edx+4]
	addss	xmm3, xmm0
	movaps	xmm0, xmm4
	mulss	xmm0, DWORD PTR [edx+8]
	addss	xmm3, xmm0
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\cl_intersect.h

; 85   : 			if (v < 0.0f || u + v > det) return false;

	comiss	xmm7, xmm3
	movss	DWORD PTR [ecx], xmm3
	ja	SHORT $LN6@TestRayTri
	movaps	xmm0, xmm3
	addss	xmm0, xmm2
	comiss	xmm0, xmm6
	ja	SHORT $LN6@TestRayTri

; 87   : 			inv_det = 1.0f / det;

	movss	xmm0, DWORD PTR __real@3f800000
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	mulss	xmm1, DWORD PTR tv907[esp+28]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\cl_intersect.h

; 88   : 			range *= inv_det;

	mov	eax, DWORD PTR _range$[esp+24]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	mulss	xmm5, DWORD PTR tv906[esp+28]
	mulss	xmm4, DWORD PTR tv908[esp+28]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\cl_intersect.h

; 87   : 			inv_det = 1.0f / det;

	divss	xmm0, xmm6
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	addss	xmm1, xmm5
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\cl_intersect.h

; 89   : 			u *= inv_det;

	mulss	xmm2, xmm0

; 90   : 			v *= inv_det;

	mulss	xmm3, xmm0
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	addss	xmm1, xmm4
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\cl_intersect.h

; 89   : 			u *= inv_det;

	movss	DWORD PTR [esi], xmm2
	pop	esi

; 90   : 			v *= inv_det;

	movss	DWORD PTR [ecx], xmm3
	mulss	xmm1, xmm0
	movss	DWORD PTR [eax], xmm1

; 91   : 		}else{											// the non-culling branch
; 92   : 			if (det > -EPS && det < EPS) return false;
; 93   : 			inv_det = 1.0f / det;
; 94   : 			tvec.sub(C, p[0]);							// calculate distance from vert0 to ray origin
; 95   : 			u = tvec.dotproduct(pvec)*inv_det;	// calculate U parameter and test bounds
; 96   : 			if (u < 0.0f || u > 1.0f)    return false;
; 97   : 			qvec.crossproduct(tvec, edge1);				// prepare to test V parameter
; 98   : 			v = D.dotproduct(qvec)*inv_det;	// calculate V parameter and test bounds
; 99   : 			if (v < 0.0f || u + v > 1.0f) return false;
; 100  : 			range = edge2.dotproduct(qvec)*inv_det;// calculate t, ray intersects triangle
; 101  : 		}
; 102  : 		return true;

	mov	al, 1

; 103  : 	}

	add	esp, 24					; 00000018H
	ret	0
$LN6@TestRayTri:

; 82   : 			if (u < 0.0f || u > det) return false;

	xor	al, al
	pop	esi

; 103  : 	}

	add	esp, 24					; 00000018H
	ret	0
?TestRayTri@CDB@@YA_NABU?$_vector3@M@@0PAU2@AAM22_N@Z ENDP ; CDB::TestRayTri
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_Decompress.cpp
;	COMDAT ?Interpolate@@YAMPAMIII@Z
_TEXT	SEGMENT
_ifx$1$ = -8						; size = 4
_fx$1$ = -4						; size = 4
_y$ = 8							; size = 4
tv303 = 12						; size = 4
tv300 = 12						; size = 4
tv154 = 12						; size = 4
_ify$1$ = 12						; size = 4
_size$ = 12						; size = 4
?Interpolate@@YAMPAMIII@Z PROC				; Interpolate, COMDAT
; _base$ = ecx
; _x$ = edx

; 16   : 	float	f	= float(size);

	mov	eax, DWORD PTR _size$[esp-4]
	sub	esp, 8
	fild	DWORD PTR _size$[esp+4]
	test	eax, eax
	jns	SHORT $LN3@Interpolat
	fadd	DWORD PTR __real@4f800000
$LN3@Interpolat:

; 17   : 	float	fx	= float(x)/f; float ifx = 1.f-fx;

	fld1
	mov	DWORD PTR tv303[esp+4], edx
	fld	ST(0)
	fdivrp	ST(2), ST(0)
	fild	DWORD PTR tv303[esp+4]
	test	edx, edx
	jns	SHORT $LN4@Interpolat
	fadd	DWORD PTR __real@4f800000
$LN4@Interpolat:

; 18   : 	float	fy	= float(y)/f; float ify = 1.f-fy;

	mov	eax, DWORD PTR _y$[esp+4]
	fmul	ST(0), ST(2)
	fst	DWORD PTR _fx$1$[esp+8]
	fsubr	ST(0), ST(1)
	fst	DWORD PTR _ifx$1$[esp+8]
	fild	DWORD PTR _y$[esp+4]
	test	eax, eax
	jns	SHORT $LN5@Interpolat
	fadd	DWORD PTR __real@4f800000
$LN5@Interpolat:
	fmulp	ST(3), ST(0)
	fxch	ST(1)
	fsub	ST(0), ST(2)
	fstp	DWORD PTR _ify$1$[esp+4]

; 19   : 
; 20   : 	float	c01	= base[0]*ifx + base[1]*fx;
; 21   : 	float	c23	= base[2]*ifx + base[3]*fx;
; 22   : 	float	c02	= base[0]*ify + base[2]*fy;
; 23   : 	float	c13	= base[1]*ify + base[3]*fy;

	fld	DWORD PTR [ecx+4]
	fld	DWORD PTR [ecx+12]
	fld	DWORD PTR [ecx+8]
	fld	DWORD PTR [ecx]
	fmul	DWORD PTR _ify$1$[esp+4]
	fld	ST(1)
	fmul	ST(0), ST(6)
	faddp	ST(1), ST(0)

; 24   : 
; 25   : 	float	cx	= ify*c01 + fy*c23;
; 26   : 	float	cy	= ifx*c02 + fx*c13;

	fmulp	ST(4), ST(0)
	fld	ST(1)
	fmul	ST(0), ST(5)
	fld	ST(3)
	fmul	DWORD PTR _ify$1$[esp+4]
	faddp	ST(1), ST(0)
	fld	DWORD PTR _fx$1$[esp+8]
	fmul	ST(1), ST(0)
	fxch	ST(5)
	faddp	ST(1), ST(0)
	fld	DWORD PTR _ifx$1$[esp+8]
	fmulp	ST(2), ST(0)
	fxch	ST(2)
	fmulp	ST(4), ST(0)
	faddp	ST(3), ST(0)
	fxch	ST(2)
	fmulp	ST(3), ST(0)
	fld	DWORD PTR [ecx]
	fmul	DWORD PTR _ifx$1$[esp+8]
	fld	DWORD PTR _fx$1$[esp+8]
	fmulp	ST(2), ST(0)
	faddp	ST(1), ST(0)
	fmul	DWORD PTR _ify$1$[esp+4]
	faddp	ST(2), ST(0)

; 27   : 	return	(cx+cy)/2;

	faddp	ST(1), ST(0)
	fmul	DWORD PTR __real@3f000000

; 28   : }

	add	esp, 8
	ret	0
?Interpolate@@YAMPAMIII@Z ENDP				; Interpolate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_Decompress.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\vector.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_Decompress.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\vector.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_Decompress.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_Decompress.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h
; File I:\Vitalya\mine\NSProjectX\xrCore\vector.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_Decompress.cpp
;	COMDAT ?InterpolateAndDither@@YA_NPAMIIIIIQAY0BA@H@Z
_TEXT	SEGMENT
_ifx$1$ = -4						; size = 4
tv505 = 8						; size = 4
_ify$1$ = 8						; size = 4
_fy$1 = 8						; size = 4
_y$ = 8							; size = 4
_sx$ = 12						; size = 4
_sy$ = 16						; size = 4
tv514 = 20						; size = 4
tv508 = 20						; size = 4
_fx$2 = 20						; size = 4
_a$3 = 20						; size = 4
_size$ = 20						; size = 4
_dither$ = 24						; size = 4
?InterpolateAndDither@@YA_NPAMIIIIIQAY0BA@H@Z PROC	; InterpolateAndDither, COMDAT
; _alpha255$ = ecx
; _x$ = edx

; 31   : {

	push	ecx
	push	ebx
	push	ebp
; File I:\Vitalya\mine\NSProjectX\xrCore\vector.h

; 92   : 	if( val<_low ) val = _low; else if( val>_high ) val = _high;

	mov	ebp, DWORD PTR _y$[esp+8]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_Decompress.cpp

; 31   : {

	mov	ebx, edx
	push	esi

; 32   : 	clamp 	(x,(u32)0,size-1);

	mov	esi, DWORD PTR _size$[esp+12]

; 16   : 	float	f	= float(size);

	mov	DWORD PTR tv514[esp+12], esi
	fild	DWORD PTR tv514[esp+12]

; 31   : {

	push	edi

; 32   : 	clamp 	(x,(u32)0,size-1);

	lea	eax, DWORD PTR [esi-1]
; File I:\Vitalya\mine\NSProjectX\xrCore\vector.h

; 92   : 	if( val<_low ) val = _low; else if( val>_high ) val = _high;

	cmp	ebx, eax
	cmova	ebx, eax
	cmp	ebp, eax
	cmova	ebp, eax
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_Decompress.cpp

; 16   : 	float	f	= float(size);

	test	esi, esi
	jns	SHORT $LN22@Interpolat
	fadd	DWORD PTR __real@4f800000
$LN22@Interpolat:

; 17   : 	float	fx	= float(x)/f; float ifx = 1.f-fx;

	fld1
	fdivrp	ST(1), ST(0)
	mov	DWORD PTR tv508[esp+16], ebx
	fild	DWORD PTR tv508[esp+16]
	test	ebx, ebx
	jns	SHORT $LN23@Interpolat
	fadd	DWORD PTR __real@4f800000
$LN23@Interpolat:
	movss	xmm0, DWORD PTR __real@3f800000
	fmul	ST(0), ST(1)
	movaps	xmm1, xmm0

; 18   : 	float	fy	= float(y)/f; float ify = 1.f-fy;

	mov	DWORD PTR tv505[esp+16], ebp
	fstp	DWORD PTR _fx$2[esp+16]
	subss	xmm1, DWORD PTR _fx$2[esp+16]
	fild	DWORD PTR tv505[esp+16]
	movss	DWORD PTR _ifx$1$[esp+20], xmm1
	test	ebp, ebp
	jns	SHORT $LN24@Interpolat
	fadd	DWORD PTR __real@4f800000
$LN24@Interpolat:

; 21   : 	float	c23	= base[2]*ifx + base[3]*fx;
; 22   : 	float	c02	= base[0]*ify + base[2]*fy;

	movss	xmm3, DWORD PTR [ecx]
	movss	xmm6, DWORD PTR [ecx+8]
	movaps	xmm5, xmm3

; 23   : 	float	c13	= base[1]*ify + base[3]*fy;

	movss	xmm7, DWORD PTR [ecx+4]
	movss	xmm2, DWORD PTR [ecx+12]
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h

; 84   :     int exponent	= (127 + 31) - ((a >> 23) & 0xFF);

	mov	ecx, 158				; 0000009eH
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_Decompress.cpp

; 18   : 	float	fy	= float(y)/f; float ify = 1.f-fy;

	fmulp	ST(1), ST(0)

; 19   : 
; 20   : 	float	c01	= base[0]*ifx + base[1]*fx;

	mulss	xmm3, DWORD PTR _ifx$1$[esp+20]
	fstp	DWORD PTR _fy$1[esp+16]
	movss	xmm4, DWORD PTR _fy$1[esp+16]
	subss	xmm0, xmm4

; 21   : 	float	c23	= base[2]*ifx + base[3]*fx;
; 22   : 	float	c02	= base[0]*ify + base[2]*fy;

	mulss	xmm5, xmm0
	movss	DWORD PTR _ify$1$[esp+16], xmm0
	movaps	xmm0, xmm6
	mulss	xmm6, DWORD PTR _ifx$1$[esp+20]
	mulss	xmm0, xmm4
	addss	xmm5, xmm0

; 23   : 	float	c13	= base[1]*ify + base[3]*fy;

	movaps	xmm0, xmm7
	mulss	xmm7, DWORD PTR _fx$2[esp+16]
	mulss	xmm0, DWORD PTR _ify$1$[esp+16]

; 24   : 
; 25   : 	float	cx	= ify*c01 + fy*c23;
; 26   : 	float	cy	= ifx*c02 + fx*c13;

	mulss	xmm5, xmm1
	addss	xmm3, xmm7
	movaps	xmm1, xmm2
	mulss	xmm2, DWORD PTR _fx$2[esp+16]
	mulss	xmm1, xmm4
	mulss	xmm3, DWORD PTR _ify$1$[esp+16]
	addss	xmm6, xmm2
	addss	xmm1, xmm0
	mulss	xmm6, xmm4
	mulss	xmm1, DWORD PTR _fx$2[esp+16]
	addss	xmm6, xmm3
	addss	xmm5, xmm1

; 27   : 	return	(cx+cy)/2;

	addss	xmm5, xmm6

; 33   : 	clamp 	(y,(u32)0,size-1);
; 34   : 	int		c	= iFloor(Interpolate(alpha255,x,y,size)+.5f);

	addss	xmm5, DWORD PTR __real@3f800000
	mulss	xmm5, DWORD PTR __real@3f000000
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h

; 83   :     int a			= *(const int*)(&x);

	movss	DWORD PTR _a$3[esp+16], xmm5

; 84   :     int exponent	= (127 + 31) - ((a >> 23) & 0xFF);

	mov	esi, DWORD PTR _a$3[esp+16]
	mov	eax, esi
	sar	eax, 23					; 00000017H

; 85   :     int r			= (((u32)(a) << 8) | (1U << 31)) >> exponent;

	mov	edi, esi
	movzx	eax, al
	or	edi, -8388608				; ff800000H
	sub	ecx, eax
	shl	edi, 8
	shr	edi, cl

; 86   :     exponent		+= 31-127;
; 87   :     {
; 88   :         int imask	=	(!(((( (1<<(exponent)))-1)>>8)&a));

	mov	eax, 1
	sub	ecx, 96					; 00000060H

; 89   :         exponent	-=	(31-127)+32;
; 90   :         exponent	>>=	31;
; 91   :         a			>>=	31;

	mov	edx, esi
	shl	eax, cl
	dec	eax
	sar	edx, 31					; 0000001fH
	sar	eax, 8
	and	eax, esi
	neg	eax
	sbb	eax, eax
	inc	eax
	and	eax, edx

; 92   :         r			-=	(imask&a);

	sub	edi, eax
	lea	eax, DWORD PTR [ecx+64]
	sar	eax, 31					; 0000001fH

; 93   :         r			&=	exponent;

	and	edi, eax
	xor	edi, edx
; File I:\Vitalya\mine\NSProjectX\xrCore\vector.h

; 92   : 	if( val<_low ) val = _low; else if( val>_high ) val = _high;

	jge	SHORT $LN18@Interpolat
	xor	edi, edi
	jmp	SHORT $LN20@Interpolat
$LN18@Interpolat:
	mov	eax, 255				; 000000ffH
	cmp	edi, eax
	cmovg	edi, eax
$LN20@Interpolat:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_Decompress.cpp

; 38   : 	u32	col	= (x+sx) % 16;

	mov	ecx, DWORD PTR _sx$[esp+16]
	mov	eax, DWORD PTR _sy$[esp+16]
	add	ecx, ebx
	add	eax, ebp
	and	ecx, 15					; 0000000fH
	and	eax, 15					; 0000000fH
	shl	ecx, 4

; 39   : 	return	c	> dither[col][row];

	add	ecx, eax
	mov	eax, DWORD PTR _dither$[esp+16]
	cmp	edi, DWORD PTR [eax+ecx*4]
	pop	edi
	pop	esi
	pop	ebp
	setg	al
	pop	ebx

; 40   : }

	pop	ecx
	ret	0
?InterpolateAndDither@@YA_NPAMIIIIIQAY0BA@H@Z ENDP	; InterpolateAndDither
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\FixedVector.h
;	COMDAT ?empty@?$svector@H$03@@QBE_NXZ
_TEXT	SEGMENT
?empty@?$svector@H$03@@QBE_NXZ PROC			; svector<int,4>::empty, COMDAT
; _this$ = ecx

; 48   : 	IC bool		empty()		const			{ return 0==count;	}

	cmp	DWORD PTR [ecx+16], 0
	sete	al
	ret	0
?empty@?$svector@H$03@@QBE_NXZ ENDP			; svector<int,4>::empty
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\FixedVector.h
;	COMDAT ??A?$svector@H$03@@QAEAAHI@Z
_TEXT	SEGMENT
_id$ = 8						; size = 4
??A?$svector@H$03@@QAEAAHI@Z PROC			; svector<int,4>::operator[], COMDAT
; _this$ = ecx

; 38   : 	IC reference		operator[] (u32 id)			{ VERIFY(id<count); return array[id];	}

	mov	eax, DWORD PTR _id$[esp-4]
	lea	eax, DWORD PTR [ecx+eax*4]
	ret	4
??A?$svector@H$03@@QAEAAHI@Z ENDP			; svector<int,4>::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\FixedVector.h
;	COMDAT ?push_back@?$svector@H$03@@QAEXH@Z
_TEXT	SEGMENT
_e$ = 8							; size = 4
?push_back@?$svector@H$03@@QAEXH@Z PROC			; svector<int,4>::push_back, COMDAT
; _this$ = ecx

; 35   : 	IC void		push_back(value_type e)		{ VERIFY(count<dim); array[count++]=e;	}

	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR _e$[esp-4]
	mov	DWORD PTR [ecx+edx*4], eax
	inc	DWORD PTR [ecx+16]
	ret	4
?push_back@?$svector@H$03@@QAEXH@Z ENDP			; svector<int,4>::push_back
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\FixedVector.h
;	COMDAT ?clear@?$svector@H$03@@QAEXXZ
_TEXT	SEGMENT
?clear@?$svector@H$03@@QAEXXZ PROC			; svector<int,4>::clear, COMDAT
; _this$ = ecx

; 31   : 	IC void		clear()						{ count=0;								}

	mov	DWORD PTR [ecx+16], 0
	ret	0
?clear@?$svector@H$03@@QAEXXZ ENDP			; svector<int,4>::clear
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\FixedVector.h
;	COMDAT ?size@?$svector@H$03@@QBEIXZ
_TEXT	SEGMENT
?size@?$svector@H$03@@QBEIXZ PROC			; svector<int,4>::size, COMDAT
; _this$ = ecx

; 30   : 	IC u32		size()		const			{ return count;							}

	mov	eax, DWORD PTR [ecx+16]
	ret	0
?size@?$svector@H$03@@QBEIXZ ENDP			; svector<int,4>::size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\FixedVector.h
;	COMDAT ??0?$svector@H$03@@QAE@XZ
_TEXT	SEGMENT
??0?$svector@H$03@@QAE@XZ PROC				; svector<int,4>::svector<int,4>, COMDAT
; _this$ = ecx

; 21   : 	svector() : count(0) 

	mov	DWORD PTR [ecx+16], 0

; 22   : 	{}

	mov	eax, ecx
	ret	0
??0?$svector@H$03@@QAE@XZ ENDP				; svector<int,4>::svector<int,4>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\xrPool.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xrPool.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrPool.h
;	COMDAT ?create@?$poolSS@USlotItem@CDetailManager@@$0BAAA@@@QAEPAUSlotItem@CDetailManager@@XZ
_TEXT	SEGMENT
?create@?$poolSS@USlotItem@CDetailManager@@$0BAAA@@@QAEPAUSlotItem@CDetailManager@@XZ PROC ; poolSS<CDetailManager::SlotItem,4096>::create, COMDAT
; _this$ = ecx

; 39   : 	{

	push	esi
	mov	esi, ecx
	push	edi

; 40   : 		if (0==list)	block_create();

	mov	edi, DWORD PTR [esi]
	test	edi, edi
	jne	SHORT $LN2@create
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	393216					; 00060000H
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
	mov	edx, eax
; File I:\Vitalya\mine\NSProjectX\xrCore\xrPool.h

; 18   : 		blocks.push_back	(list);

	lea	ecx, DWORD PTR [esi+4]
	mov	DWORD PTR [esi], edx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 730  :         if (_Mylast != _My_data._Myend) {

	mov	eax, DWORD PTR [ecx+4]
	cmp	eax, DWORD PTR [ecx+8]
	je	SHORT $LN17@create

; 713  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

	mov	DWORD PTR [eax], edx

; 714  :         _Orphan_range(_Mylast, _Mylast);
; 715  :         _Ty& _Result = *_Mylast;
; 716  :         ++_Mylast;

	add	DWORD PTR [ecx+4], 4

; 731  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

	jmp	SHORT $LN16@create
$LN17@create:

; 732  :         }
; 733  : 
; 734  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	push	esi
	push	eax
	call	??$_Emplace_reallocate@ABQAUSlotItem@CDetailManager@@@?$vector@PAUSlotItem@CDetailManager@@V?$xalloc@PAUSlotItem@CDetailManager@@@@@std@@QAEPAPAUSlotItem@CDetailManager@@QAPAU23@ABQAU23@@Z ; std::vector<CDetailManager::SlotItem *,xalloc<CDetailManager::SlotItem *> >::_Emplace_reallocate<CDetailManager::SlotItem * const &>
$LN16@create:
; File I:\Vitalya\mine\NSProjectX\xrCore\xrPool.h

; 21   : 		for (int it=0; it<(granularity-1); it++)

	xor	edx, edx
	npad	5
$LL10@create:

; 22   : 		{
; 23   : 			T*		E			= list+it;

	mov	ecx, DWORD PTR [esi]

; 24   : 			*access(E)			= E+1;

	lea	eax, DWORD PTR [ecx+96]
	add	eax, edx
	mov	DWORD PTR [ecx+edx], eax
	add	edx, 96					; 00000060H
	cmp	edx, 393120				; 0005ffa0H
	jl	SHORT $LL10@create

; 25   : 		}
; 26   : 		*access(list+granularity-1)	= NULL;

	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [eax+393120], 0
	mov	edi, DWORD PTR [esi]
$LN2@create:

; 41   : 
; 42   : 		T* E			= list;
; 43   : 		list			= *access(list);

	mov	ecx, DWORD PTR [edi]

; 44   : 		return			new (E) T();

	push	96					; 00000060H
	push	0
	push	edi
	mov	DWORD PTR [esi], ecx
	call	_memset
	add	esp, 12					; 0000000cH
	mov	eax, edi
	pop	edi
	pop	esi

; 45   : 	}

	ret	0
?create@?$poolSS@USlotItem@CDetailManager@@$0BAAA@@@QAEPAUSlotItem@CDetailManager@@XZ ENDP ; poolSS<CDetailManager::SlotItem,4096>::create
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h
;	COMDAT ?get_CD@?$_box3@M@@QBEABV1@AAU?$_vector3@M@@0@Z
_TEXT	SEGMENT
_bc$ = 8						; size = 4
_bd$ = 12						; size = 4
?get_CD@?$_box3@M@@QBEABV1@AAU?$_vector3@M@@0@Z PROC	; _box3<float>::get_CD, COMDAT
; _this$ = ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	xmm4, DWORD PTR [ecx+12]
	subss	xmm4, DWORD PTR [ecx]
	mov	edx, DWORD PTR _bd$[esp-4]

; 40   : 	ICF SelfRef	mul(T s)								{ x*=s;		y*=s;		z*=s;			return *this;	};

	movss	xmm0, DWORD PTR __real@3f000000

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	mov	eax, DWORD PTR _bc$[esp-4]

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	DWORD PTR [edx], xmm4
	movss	xmm3, DWORD PTR [ecx+16]
	subss	xmm3, DWORD PTR [ecx+4]

; 40   : 	ICF SelfRef	mul(T s)								{ x*=s;		y*=s;		z*=s;			return *this;	};

	mulss	xmm4, xmm0

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	DWORD PTR [edx+4], xmm3
	movss	xmm2, DWORD PTR [ecx+20]
	movss	xmm1, DWORD PTR [ecx+8]
	subss	xmm2, xmm1

; 40   : 	ICF SelfRef	mul(T s)								{ x*=s;		y*=s;		z*=s;			return *this;	};

	mulss	xmm3, xmm0
	movss	DWORD PTR [edx], xmm4
	movss	DWORD PTR [edx+4], xmm3
	mulss	xmm2, xmm0
	movss	DWORD PTR [edx+8], xmm2

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	addss	xmm4, DWORD PTR [ecx]
	movss	DWORD PTR [eax], xmm4
	movss	xmm0, DWORD PTR [edx+4]
	addss	xmm0, DWORD PTR [ecx+4]
	movss	DWORD PTR [eax+4], xmm0
	movss	xmm0, DWORD PTR [ecx+8]
	addss	xmm0, DWORD PTR [edx+8]
	movss	DWORD PTR [eax+8], xmm0
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h

; 106  : 		return				*this;

	mov	eax, ecx

; 107  : 	}

	ret	8
?get_CD@?$_box3@M@@QBEABV1@AAU?$_vector3@M@@0@Z ENDP	; _box3<float>::get_CD
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h
;	COMDAT ?xform@?$_box3@M@@QAEAAV1@ABV1@ABU?$_matrix@M@@@Z
_TEXT	SEGMENT
tv625 = -40						; size = 4
_vy$ = -36						; size = 12
_vz$ = -24						; size = 12
_vx$ = -12						; size = 12
_vz$3$ = 8						; size = 4
_B$ = 8							; size = 4
tv602 = 12						; size = 4
_m$ = 12						; size = 4
?xform@?$_box3@M@@QAEAAV1@ABV1@ABU?$_matrix@M@@@Z PROC	; _box3<float>::xform, COMDAT
; _this$ = ecx

; 60   : 	{

	sub	esp, 40					; 00000028H

; 64   : 		vx.mul				(m.i, B.max.x-B.min.x);	

	mov	edx, DWORD PTR _B$[esp+36]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 42   : 	ICF SelfRef	mul(const Self &a, T s)					{ x=a.x*s;  y=a.y*s;	z=a.z*s;		return *this;	};

	mov	eax, DWORD PTR _m$[esp+36]
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h

; 64   : 		vx.mul				(m.i, B.max.x-B.min.x);	

	movss	xmm0, DWORD PTR [edx+12]
	subss	xmm0, DWORD PTR [edx]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 42   : 	ICF SelfRef	mul(const Self &a, T s)					{ x=a.x*s;  y=a.y*s;	z=a.z*s;		return *this;	};

	movss	xmm6, DWORD PTR [eax]
	movss	xmm2, DWORD PTR [eax+16]
	movaps	xmm1, xmm6
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 499  : 		dest.x = v.x*_11 + v.y*_21 + v.z*_31 + _41;

	mulss	xmm6, DWORD PTR [edx]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 42   : 	ICF SelfRef	mul(const Self &a, T s)					{ x=a.x*s;  y=a.y*s;	z=a.z*s;		return *this;	};

	movaps	xmm7, xmm2
	mulss	xmm1, xmm0
	movaps	xmm5, xmm0
	mulss	xmm0, DWORD PTR [eax+8]
	mulss	xmm5, DWORD PTR [eax+4]
	movss	DWORD PTR _vx$[esp+48], xmm0
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h

; 65   : 		vy.mul				(m.j, B.max.y-B.min.y);	

	movss	xmm0, DWORD PTR [edx+16]
	subss	xmm0, DWORD PTR [edx+4]
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 499  : 		dest.x = v.x*_11 + v.y*_21 + v.z*_31 + _41;

	mulss	xmm2, DWORD PTR [edx+4]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 42   : 	ICF SelfRef	mul(const Self &a, T s)					{ x=a.x*s;  y=a.y*s;	z=a.z*s;		return *this;	};

	movss	DWORD PTR _vx$[esp+40], xmm1
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h

; 25   : 	IC BOOL negative(const float &f)	{ return (*((unsigned*)(&f))&fdSGN);	}

	test	DWORD PTR _vx$[esp+40], -2147483648	; 80000000H
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 42   : 	ICF SelfRef	mul(const Self &a, T s)					{ x=a.x*s;  y=a.y*s;	z=a.z*s;		return *this;	};

	mulss	xmm7, xmm0
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 499  : 		dest.x = v.x*_11 + v.y*_21 + v.z*_31 + _41;

	addss	xmm6, xmm2
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 42   : 	ICF SelfRef	mul(const Self &a, T s)					{ x=a.x*s;  y=a.y*s;	z=a.z*s;		return *this;	};

	movss	DWORD PTR tv602[esp+36], xmm1
	movaps	xmm1, xmm0
	mulss	xmm0, DWORD PTR [eax+24]
	mulss	xmm1, DWORD PTR [eax+20]
	movss	DWORD PTR _vy$[esp+48], xmm0
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h

; 66   : 		vz.mul				(m.k, B.max.z-B.min.z);	

	movss	xmm0, DWORD PTR [edx+20]
	subss	xmm0, DWORD PTR [edx+8]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 42   : 	ICF SelfRef	mul(const Self &a, T s)					{ x=a.x*s;  y=a.y*s;	z=a.z*s;		return *this;	};

	movss	DWORD PTR _vx$[esp+44], xmm5
	movss	DWORD PTR tv625[esp+40], xmm7
	movss	DWORD PTR _vy$[esp+40], xmm7
	movss	DWORD PTR _vy$[esp+44], xmm1
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h

; 66   : 		vz.mul				(m.k, B.max.z-B.min.z);	

	movss	DWORD PTR _vz$3$[esp+36], xmm0
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 42   : 	ICF SelfRef	mul(const Self &a, T s)					{ x=a.x*s;  y=a.y*s;	z=a.z*s;		return *this;	};

	movss	xmm0, DWORD PTR [eax+32]
	movss	xmm7, DWORD PTR _vz$3$[esp+36]
	movaps	xmm5, xmm0
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 499  : 		dest.x = v.x*_11 + v.y*_21 + v.z*_31 + _41;

	mulss	xmm0, DWORD PTR [edx+8]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 42   : 	ICF SelfRef	mul(const Self &a, T s)					{ x=a.x*s;  y=a.y*s;	z=a.z*s;		return *this;	};

	mulss	xmm5, xmm7
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 499  : 		dest.x = v.x*_11 + v.y*_21 + v.z*_31 + _41;

	addss	xmm0, DWORD PTR [eax+48]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 42   : 	ICF SelfRef	mul(const Self &a, T s)					{ x=a.x*s;  y=a.y*s;	z=a.z*s;		return *this;	};

	movss	DWORD PTR _vz$[esp+40], xmm5
	movaps	xmm5, xmm7
	mulss	xmm7, DWORD PTR [eax+40]
	mulss	xmm5, DWORD PTR [eax+36]
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 499  : 		dest.x = v.x*_11 + v.y*_21 + v.z*_31 + _41;

	addss	xmm6, xmm0
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 42   : 	ICF SelfRef	mul(const Self &a, T s)					{ x=a.x*s;  y=a.y*s;	z=a.z*s;		return *this;	};

	movss	DWORD PTR _vz$3$[esp+36], xmm7
	movss	DWORD PTR _vz$[esp+48], xmm7
	movss	DWORD PTR _vz$[esp+44], xmm5
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 499  : 		dest.x = v.x*_11 + v.y*_21 + v.z*_31 + _41;

	movss	DWORD PTR [ecx], xmm6

; 500  : 		dest.y = v.x*_12 + v.y*_22 + v.z*_32 + _42;

	movss	xmm0, DWORD PTR [edx]
	mulss	xmm0, DWORD PTR [eax+4]
	movss	xmm2, DWORD PTR [eax+20]
	mulss	xmm2, DWORD PTR [edx+4]
	addss	xmm2, xmm0
	movss	xmm0, DWORD PTR [eax+36]
	mulss	xmm0, DWORD PTR [edx+8]
	addss	xmm0, DWORD PTR [eax+52]
	addss	xmm2, xmm0
	movss	DWORD PTR [ecx+4], xmm2

; 501  : 		dest.z = v.x*_13 + v.y*_23 + v.z*_33 + _43;

	movss	xmm0, DWORD PTR [edx]
	mulss	xmm0, DWORD PTR [eax+8]
	movss	xmm1, DWORD PTR [eax+24]
	mulss	xmm1, DWORD PTR [edx+4]
	addss	xmm1, xmm0
	movss	xmm0, DWORD PTR [eax+40]
	mulss	xmm0, DWORD PTR [edx+8]
	addss	xmm0, DWORD PTR [eax+56]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 24   : 	ICF SelfRef	set(const _vector3<float> &v)			{ x = T(v.x);	y = T(v.y);	z = T(v.z);	return *this;	};

	movss	DWORD PTR [ecx+12], xmm6
	movss	DWORD PTR [ecx+16], xmm2
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 501  : 		dest.z = v.x*_13 + v.y*_23 + v.z*_33 + _43;

	addss	xmm1, xmm0
	movss	DWORD PTR [ecx+8], xmm1
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 24   : 	ICF SelfRef	set(const _vector3<float> &v)			{ x = T(v.x);	y = T(v.y);	z = T(v.z);	return *this;	};

	movss	DWORD PTR [ecx+20], xmm1
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h

; 74   : 		if(negative(vx.x))	min.x += vx.x; else max.x += vx.x;

	je	SHORT $LN2@xform
	movss	xmm0, DWORD PTR tv602[esp+36]
	addss	xmm0, xmm6
	movss	DWORD PTR [ecx], xmm0
	jmp	SHORT $LN3@xform
$LN2@xform:
	addss	xmm6, DWORD PTR tv602[esp+36]
	movss	DWORD PTR [ecx+12], xmm6
$LN3@xform:
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h

; 25   : 	IC BOOL negative(const float &f)	{ return (*((unsigned*)(&f))&fdSGN);	}

	test	DWORD PTR _vx$[esp+44], -2147483648	; 80000000H
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h

; 75   : 		if(negative(vx.y))	min.y += vx.y; else max.y += vx.y;

	movss	xmm5, DWORD PTR _vx$[esp+44]
	addss	xmm5, xmm2
	je	SHORT $LN4@xform
	movss	DWORD PTR [ecx+4], xmm5
	jmp	SHORT $LN5@xform
$LN4@xform:
	movss	DWORD PTR [ecx+16], xmm5
	movaps	xmm5, xmm2
$LN5@xform:
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h

; 25   : 	IC BOOL negative(const float &f)	{ return (*((unsigned*)(&f))&fdSGN);	}

	test	DWORD PTR _vx$[esp+48], -2147483648	; 80000000H
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h

; 76   : 		if(negative(vx.z))	min.z += vx.z; else max.z += vx.z;

	je	SHORT $LN6@xform
	addss	xmm1, DWORD PTR _vx$[esp+48]
	movss	DWORD PTR [ecx+8], xmm1
	jmp	SHORT $LN7@xform
$LN6@xform:
	movss	xmm0, DWORD PTR _vx$[esp+48]
	addss	xmm0, xmm1
	movss	DWORD PTR [ecx+20], xmm0
$LN7@xform:
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h

; 25   : 	IC BOOL negative(const float &f)	{ return (*((unsigned*)(&f))&fdSGN);	}

	test	DWORD PTR _vy$[esp+40], -2147483648	; 80000000H
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h

; 77   : 		if(negative(vy.x))	min.x += vy.x; else max.x += vy.x;

	movss	xmm7, DWORD PTR tv625[esp+40]
	je	SHORT $LN8@xform
	addss	xmm7, DWORD PTR [ecx]
	movss	DWORD PTR [ecx], xmm7
	jmp	SHORT $LN9@xform
$LN8@xform:
	addss	xmm6, xmm7
	movss	DWORD PTR [ecx+12], xmm6
$LN9@xform:
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h

; 25   : 	IC BOOL negative(const float &f)	{ return (*((unsigned*)(&f))&fdSGN);	}

	test	DWORD PTR _vy$[esp+44], -2147483648	; 80000000H
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h

; 78   : 		if(negative(vy.y))	min.y += vy.y; else max.y += vy.y;

	je	SHORT $LN10@xform
	addss	xmm5, DWORD PTR _vy$[esp+44]
	movss	DWORD PTR [ecx+4], xmm5
	jmp	SHORT $LN11@xform
$LN10@xform:
	movss	xmm0, DWORD PTR _vy$[esp+44]
	addss	xmm0, DWORD PTR [ecx+16]
	movss	DWORD PTR [ecx+16], xmm0
$LN11@xform:
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h

; 25   : 	IC BOOL negative(const float &f)	{ return (*((unsigned*)(&f))&fdSGN);	}

	test	DWORD PTR _vy$[esp+48], -2147483648	; 80000000H
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h

; 79   : 		if(negative(vy.z))	min.z += vy.z; else max.z += vy.z;

	je	SHORT $LN12@xform
	addss	xmm1, DWORD PTR _vy$[esp+48]
	movss	DWORD PTR [ecx+8], xmm1
	jmp	SHORT $LN13@xform
$LN12@xform:
	movss	xmm0, DWORD PTR _vy$[esp+48]
	addss	xmm0, DWORD PTR [ecx+20]
	movss	DWORD PTR [ecx+20], xmm0
$LN13@xform:
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h

; 25   : 	IC BOOL negative(const float &f)	{ return (*((unsigned*)(&f))&fdSGN);	}

	test	DWORD PTR _vz$[esp+40], -2147483648	; 80000000H
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h

; 80   : 		if(negative(vz.x))	min.x += vz.x; else max.x += vz.x;

	je	SHORT $LN14@xform
	movss	xmm0, DWORD PTR _vz$[esp+40]
	addss	xmm0, DWORD PTR [ecx]
	movss	DWORD PTR [ecx], xmm0
	jmp	SHORT $LN15@xform
$LN14@xform:
	addss	xmm6, DWORD PTR _vz$[esp+40]
	movss	DWORD PTR [ecx+12], xmm6
$LN15@xform:
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h

; 25   : 	IC BOOL negative(const float &f)	{ return (*((unsigned*)(&f))&fdSGN);	}

	test	DWORD PTR _vz$[esp+44], -2147483648	; 80000000H
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h

; 81   : 		if(negative(vz.y))	min.y += vz.y; else max.y += vz.y;

	je	SHORT $LN16@xform
	addss	xmm5, DWORD PTR _vz$[esp+44]
	movss	DWORD PTR [ecx+4], xmm5
	jmp	SHORT $LN17@xform
$LN16@xform:
	movss	xmm0, DWORD PTR _vz$[esp+44]
	addss	xmm0, DWORD PTR [ecx+16]
	movss	DWORD PTR [ecx+16], xmm0
$LN17@xform:
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h

; 25   : 	IC BOOL negative(const float &f)	{ return (*((unsigned*)(&f))&fdSGN);	}

	test	DWORD PTR _vz$[esp+48], -2147483648	; 80000000H
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h

; 82   : 		if(negative(vz.z))	min.z += vz.z; else max.z += vz.z;

	mov	eax, ecx
	je	SHORT $LN18@xform
	addss	xmm1, DWORD PTR _vz$3$[esp+36]
	movss	DWORD PTR [ecx+8], xmm1

; 83   : 		return *this;
; 84   : 	}

	add	esp, 40					; 00000028H
	ret	8
$LN18@xform:

; 82   : 		if(negative(vz.z))	min.z += vz.z; else max.z += vz.z;

	movss	xmm0, DWORD PTR _vz$3$[esp+36]
	addss	xmm0, DWORD PTR [ecx+20]
	movss	DWORD PTR [ecx+20], xmm0

; 83   : 		return *this;
; 84   : 	}

	add	esp, 40					; 00000028H
	ret	8
?xform@?$_box3@M@@QAEAAV1@ABV1@ABU?$_matrix@M@@@Z ENDP	; _box3<float>::xform
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h
;	COMDAT ?set@?$_box3@M@@QAEAAV1@ABV1@@Z
_TEXT	SEGMENT
_b$ = 8							; size = 4
?set@?$_box3@M@@QAEAAV1@ABV1@@Z PROC			; _box3<float>::set, COMDAT
; _this$ = ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 24   : 	ICF SelfRef	set(const _vector3<float> &v)			{ x = T(v.x);	y = T(v.y);	z = T(v.z);	return *this;	};

	mov	eax, DWORD PTR _b$[esp-4]
	fld	DWORD PTR [eax]
	fstp	DWORD PTR [ecx]
	fld	DWORD PTR [eax+4]
	fstp	DWORD PTR [ecx+4]
	fld	DWORD PTR [eax+8]
	fstp	DWORD PTR [ecx+8]
	fld	DWORD PTR [eax+12]
	fstp	DWORD PTR [ecx+12]
	fld	DWORD PTR [eax+16]
	fstp	DWORD PTR [ecx+16]
	fld	DWORD PTR [eax+20]
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h

; 32   : 	IC	SelfRef	set			(SelfCRef b)								{ min.set(b.min);	max.set(b.max);		return *this;	};

	mov	eax, ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 24   : 	ICF SelfRef	set(const _vector3<float> &v)			{ x = T(v.x);	y = T(v.y);	z = T(v.z);	return *this;	};

	fstp	DWORD PTR [ecx+20]
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h

; 32   : 	IC	SelfRef	set			(SelfCRef b)								{ min.set(b.min);	max.set(b.max);		return *this;	};

	ret	4
?set@?$_box3@M@@QAEAAV1@ABV1@@Z ENDP			; _box3<float>::set
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
;	COMDAT ?rotateY@?$_matrix@M@@QAEAAU1@M@Z
_TEXT	SEGMENT
_cosa$ = 8						; size = 4
_Angle$ = 8						; size = 4
?rotateY@?$_matrix@M@@QAEAAU1@M@Z PROC			; _matrix<float>::rotateY, COMDAT
; _this$ = ecx
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h

; 653  :             return (float)cos(_X);

	fld	DWORD PTR _Angle$[esp-4]
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 284  : 		return *this;

	mov	eax, ecx
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h

; 653  :             return (float)cos(_X);

	fld	ST(0)
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 23   : 	ICF	SelfRef	set(T _x, T _y, T _z)					{ x = _x;		y = _y;		z = _z;		return *this;	};

	mov	DWORD PTR [ecx+4], 0
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h

; 653  :             return (float)cos(_X);

	fcos
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 280  : 		i.set		(cosa,	0,	   -sina);	_14 = 0;

	mov	DWORD PTR [ecx+12], 0
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 23   : 	ICF	SelfRef	set(T _x, T _y, T _z)					{ x = _x;		y = _y;		z = _z;		return *this;	};

	mov	DWORD PTR [ecx+16], 0
	mov	DWORD PTR [ecx+20], 1065353216		; 3f800000H
	mov	DWORD PTR [ecx+24], 0
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 281  : 		j.set		(0,		1,		0	);	_24 = 0;

	mov	DWORD PTR [ecx+28], 0
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 23   : 	ICF	SelfRef	set(T _x, T _y, T _z)					{ x = _x;		y = _y;		z = _z;		return *this;	};

	mov	DWORD PTR [ecx+36], 0
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 282  : 		k.set		(sina,  0,		cosa);	_34 = 0;

	mov	DWORD PTR [ecx+44], 0
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 23   : 	ICF	SelfRef	set(T _x, T _y, T _z)					{ x = _x;		y = _y;		z = _z;		return *this;	};

	mov	DWORD PTR [ecx+48], 0
	mov	DWORD PTR [ecx+52], 0
	mov	DWORD PTR [ecx+56], 0
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 283  : 		c.set		(0,		0,		0	);	_44 = 1;

	mov	DWORD PTR [ecx+60], 1065353216		; 3f800000H
	fst	DWORD PTR _cosa$[esp-4]
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h

; 754  :             return (float)sin(_X);

	fxch	ST(1)
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 23   : 	ICF	SelfRef	set(T _x, T _y, T _z)					{ x = _x;		y = _y;		z = _z;		return *this;	};

	movss	xmm0, DWORD PTR _cosa$[esp-4]
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h

; 754  :             return (float)sin(_X);

	fsin
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 23   : 	ICF	SelfRef	set(T _x, T _y, T _z)					{ x = _x;		y = _y;		z = _z;		return *this;	};

	fxch	ST(1)
	movss	DWORD PTR [ecx+40], xmm0
	fstp	DWORD PTR [ecx]
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 280  : 		i.set		(cosa,	0,	   -sina);	_14 = 0;

	fld	ST(0)
	fchs
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 23   : 	ICF	SelfRef	set(T _x, T _y, T _z)					{ x = _x;		y = _y;		z = _z;		return *this;	};

	fstp	DWORD PTR [ecx+8]
	fstp	DWORD PTR [ecx+32]
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 285  : 	}

	ret	4
?rotateY@?$_matrix@M@@QAEAAU1@M@Z ENDP			; _matrix<float>::rotateY
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
;	COMDAT ?scale@?$_matrix@M@@QAEAAU1@MMM@Z
_TEXT	SEGMENT
_x$ = 8							; size = 4
_y$ = 12						; size = 4
_z$ = 16						; size = 4
?scale@?$_matrix@M@@QAEAAU1@MMM@Z PROC			; _matrix<float>::scale, COMDAT
; _this$ = ecx

; 260  : 		identity(); m[0][0]=x; m[1][1]=y; m[2][2]=z; 

	movss	xmm0, DWORD PTR _x$[esp-4]

; 261  : 		return *this;

	mov	eax, ecx
	movss	DWORD PTR [ecx], xmm0
	movss	xmm0, DWORD PTR _y$[esp-4]
	movss	DWORD PTR [ecx+20], xmm0
	movss	xmm0, DWORD PTR _z$[esp-4]

; 72   : 		_11=1; _12=0; _13=0; _14=0;

	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0
	mov	DWORD PTR [ecx+12], 0

; 73   : 		_21=0; _22=1; _23=0; _24=0;

	mov	DWORD PTR [ecx+16], 0
	mov	DWORD PTR [ecx+24], 0
	mov	DWORD PTR [ecx+28], 0

; 74   : 		_31=0; _32=0; _33=1; _34=0;

	mov	DWORD PTR [ecx+32], 0
	mov	DWORD PTR [ecx+36], 0
	mov	DWORD PTR [ecx+44], 0

; 75   : 		_41=0; _42=0; _43=0; _44=1;

	mov	DWORD PTR [ecx+48], 0
	mov	DWORD PTR [ecx+52], 0
	mov	DWORD PTR [ecx+56], 0
	mov	DWORD PTR [ecx+60], 1065353216		; 3f800000H

; 260  : 		identity(); m[0][0]=x; m[1][1]=y; m[2][2]=z; 

	movss	DWORD PTR [ecx+40], xmm0

; 262  : 	}

	ret	12					; 0000000cH
?scale@?$_matrix@M@@QAEAAU1@MMM@Z ENDP			; _matrix<float>::scale
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
;	COMDAT ?translate_over@?$_matrix@M@@QAEAAU1@ABU?$_vector3@M@@@Z
_TEXT	SEGMENT
_Loc$ = 8						; size = 4
?translate_over@?$_matrix@M@@QAEAAU1@ABU?$_vector3@M@@@Z PROC ; _matrix<float>::translate_over, COMDAT
; _this$ = ecx

; 245  : 		c.set	(Loc.x,Loc.y,Loc.z);				

	mov	eax, DWORD PTR _Loc$[esp-4]
	movss	xmm0, DWORD PTR [eax+4]
	movss	xmm1, DWORD PTR [eax+8]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 23   : 	ICF	SelfRef	set(T _x, T _y, T _z)					{ x = _x;		y = _y;		z = _z;		return *this;	};

	fld	DWORD PTR [eax]
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 246  : 		return *this;

	mov	eax, ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 23   : 	ICF	SelfRef	set(T _x, T _y, T _z)					{ x = _x;		y = _y;		z = _z;		return *this;	};

	fstp	DWORD PTR [ecx+48]
	movss	DWORD PTR [ecx+52], xmm0
	movss	DWORD PTR [ecx+56], xmm1
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 247  : 	}

	ret	4
?translate_over@?$_matrix@M@@QAEAAU1@ABU?$_vector3@M@@@Z ENDP ; _matrix<float>::translate_over
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
;	COMDAT ?add@?$_vector3@M@@QAEAAU1@ABU1@0@Z
_TEXT	SEGMENT
_a$ = 8							; size = 4
_v$ = 12						; size = 4
?add@?$_vector3@M@@QAEAAU1@ABU1@0@Z PROC		; _vector3<float>::add, COMDAT
; _this$ = ecx

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	mov	edx, DWORD PTR _a$[esp-4]
	mov	eax, DWORD PTR _v$[esp-4]
	movss	xmm0, DWORD PTR [edx]
	addss	xmm0, DWORD PTR [eax]
	movss	DWORD PTR [ecx], xmm0
	movss	xmm0, DWORD PTR [edx+4]
	addss	xmm0, DWORD PTR [eax+4]
	movss	DWORD PTR [ecx+4], xmm0
	movss	xmm0, DWORD PTR [edx+8]
	addss	xmm0, DWORD PTR [eax+8]
	mov	eax, ecx
	movss	DWORD PTR [ecx+8], xmm0
	ret	8
?add@?$_vector3@M@@QAEAAU1@ABU1@0@Z ENDP		; _vector3<float>::add
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\xrPool.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xrPool.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrPool.h
;	COMDAT ?block_create@?$poolSS@USlotItem@CDetailManager@@$0BAAA@@@AAEXXZ
_TEXT	SEGMENT
?block_create@?$poolSS@USlotItem@CDetailManager@@$0BAAA@@@AAEXXZ PROC ; poolSS<CDetailManager::SlotItem,4096>::block_create, COMDAT
; _this$ = ecx

; 14   : 	{

	push	esi
	mov	esi, ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	393216					; 00060000H
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
; File I:\Vitalya\mine\NSProjectX\xrCore\xrPool.h

; 18   : 		blocks.push_back	(list);

	lea	ecx, DWORD PTR [esi+4]
	mov	DWORD PTR [esi], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 730  :         if (_Mylast != _My_data._Myend) {

	mov	edx, DWORD PTR [ecx+4]
	cmp	edx, DWORD PTR [ecx+8]
	je	SHORT $LN14@block_crea

; 713  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

	mov	DWORD PTR [edx], eax

; 714  :         _Orphan_range(_Mylast, _Mylast);
; 715  :         _Ty& _Result = *_Mylast;
; 716  :         ++_Mylast;

	add	DWORD PTR [ecx+4], 4

; 731  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

	jmp	SHORT $LN13@block_crea
$LN14@block_crea:

; 732  :         }
; 733  : 
; 734  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	push	esi
	push	edx
	call	??$_Emplace_reallocate@ABQAUSlotItem@CDetailManager@@@?$vector@PAUSlotItem@CDetailManager@@V?$xalloc@PAUSlotItem@CDetailManager@@@@@std@@QAEPAPAUSlotItem@CDetailManager@@QAPAU23@ABQAU23@@Z ; std::vector<CDetailManager::SlotItem *,xalloc<CDetailManager::SlotItem *> >::_Emplace_reallocate<CDetailManager::SlotItem * const &>
$LN13@block_crea:
; File I:\Vitalya\mine\NSProjectX\xrCore\xrPool.h

; 21   : 		for (int it=0; it<(granularity-1); it++)

	xor	eax, eax
$LL7@block_crea:

; 22   : 		{
; 23   : 			T*		E			= list+it;

	mov	edx, DWORD PTR [esi]

; 24   : 			*access(E)			= E+1;

	lea	ecx, DWORD PTR [edx+96]
	add	ecx, eax
	mov	DWORD PTR [edx+eax], ecx
	add	eax, 96					; 00000060H
	cmp	eax, 393120				; 0005ffa0H
	jl	SHORT $LL7@block_crea

; 25   : 		}
; 26   : 		*access(list+granularity-1)	= NULL;

	mov	eax, DWORD PTR [esi]
	pop	esi
	mov	DWORD PTR [eax+393120], 0

; 27   : 	}

	ret	0
?block_create@?$poolSS@USlotItem@CDetailManager@@$0BAAA@@@AAEXXZ ENDP ; poolSS<CDetailManager::SlotItem,4096>::block_create
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
;	COMDAT ?mul@?$_vector3@M@@QAEAAU1@ABU1@M@Z
_TEXT	SEGMENT
_a$ = 8							; size = 4
_s$ = 12						; size = 4
?mul@?$_vector3@M@@QAEAAU1@ABU1@M@Z PROC		; _vector3<float>::mul, COMDAT
; _this$ = ecx

; 42   : 	ICF SelfRef	mul(const Self &a, T s)					{ x=a.x*s;  y=a.y*s;	z=a.z*s;		return *this;	};

	mov	eax, DWORD PTR _a$[esp-4]
	movss	xmm1, DWORD PTR _s$[esp-4]
	movaps	xmm0, xmm1
	mulss	xmm0, DWORD PTR [eax]
	movss	DWORD PTR [ecx], xmm0
	movaps	xmm0, xmm1
	mulss	xmm0, DWORD PTR [eax+4]
	movss	DWORD PTR [ecx+4], xmm0
	mulss	xmm1, DWORD PTR [eax+8]
	mov	eax, ecx
	movss	DWORD PTR [ecx+8], xmm1
	ret	8
?mul@?$_vector3@M@@QAEAAU1@ABU1@M@Z ENDP		; _vector3<float>::mul
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\vector.h
;	COMDAT ??$clamp@I@@YAXAAIABI1@Z
_TEXT	SEGMENT
__high$ = 8						; size = 4
??$clamp@I@@YAXAAIABI1@Z PROC				; clamp<unsigned int>, COMDAT
; _val$ = ecx
; __low$ = edx

; 92   : 	if( val<_low ) val = _low; else if( val>_high ) val = _high;

	mov	eax, DWORD PTR [edx]
	cmp	DWORD PTR [ecx], eax
	jb	SHORT $LN6@clamp
	mov	eax, DWORD PTR __high$[esp-4]
	mov	eax, DWORD PTR [eax]
	cmp	DWORD PTR [ecx], eax
	jbe	SHORT $LN4@clamp
$LN6@clamp:

; 93   : };

	mov	DWORD PTR [ecx], eax
$LN4@clamp:
	ret	0
??$clamp@I@@YAXAAIABI1@Z ENDP				; clamp<unsigned int>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
;	COMDAT ??$xr_alloc@USlotItem@CDetailManager@@@@YAPAUSlotItem@CDetailManager@@I@Z
_TEXT	SEGMENT
??$xr_alloc@USlotItem@CDetailManager@@@@YAPAUSlotItem@CDetailManager@@I@Z PROC ; xr_alloc<CDetailManager::SlotItem>, COMDAT
; _count$dead$ = ecx

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	393216					; 00060000H
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
	ret	0
??$xr_alloc@USlotItem@CDetailManager@@@@YAPAUSlotItem@CDetailManager@@I@Z ENDP ; xr_alloc<CDetailManager::SlotItem>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
;	COMDAT ?identity@?$_matrix@M@@QAEAAU1@XZ
_TEXT	SEGMENT
?identity@?$_matrix@M@@QAEAAU1@XZ PROC			; _matrix<float>::identity, COMDAT
; _this$ = ecx

; 72   : 		_11=1; _12=0; _13=0; _14=0;

	mov	DWORD PTR [ecx], 1065353216		; 3f800000H

; 73   : 		_21=0; _22=1; _23=0; _24=0;
; 74   : 		_31=0; _32=0; _33=1; _34=0;
; 75   : 		_41=0; _42=0; _43=0; _44=1;
; 76   : 		return *this;

	mov	eax, ecx
	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0
	mov	DWORD PTR [ecx+12], 0
	mov	DWORD PTR [ecx+16], 0
	mov	DWORD PTR [ecx+20], 1065353216		; 3f800000H
	mov	DWORD PTR [ecx+24], 0
	mov	DWORD PTR [ecx+28], 0
	mov	DWORD PTR [ecx+32], 0
	mov	DWORD PTR [ecx+36], 0
	mov	DWORD PTR [ecx+40], 1065353216		; 3f800000H
	mov	DWORD PTR [ecx+44], 0
	mov	DWORD PTR [ecx+48], 0
	mov	DWORD PTR [ecx+52], 0
	mov	DWORD PTR [ecx+56], 0
	mov	DWORD PTR [ecx+60], 1065353216		; 3f800000H

; 77   : 	}

	ret	0
?identity@?$_matrix@M@@QAEAAU1@XZ ENDP			; _matrix<float>::identity
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h
;	COMDAT _sinf
_TEXT	SEGMENT
__X$ = 8						; size = 4
_sinf	PROC						; COMDAT

; 754  :             return (float)sin(_X);

	fld	DWORD PTR __X$[esp-4]
	fsin

; 755  :         }

	ret	0
_sinf	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_std_extensions.h
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_std_extensions.h
;	COMDAT ?_sin@@YAMM@Z
_TEXT	SEGMENT
_x$ = 8							; size = 4
?_sin@@YAMM@Z PROC					; _sin, COMDAT
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h

; 754  :             return (float)sin(_X);

	fld	DWORD PTR _x$[esp-4]
	fsin
; File I:\Vitalya\mine\NSProjectX\xrCore\_std_extensions.h

; 100  : IC float	_sin	(float x)		{ return sinf(x); }

	ret	0
?_sin@@YAMM@Z ENDP					; _sin
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h
;	COMDAT _cosf
_TEXT	SEGMENT
__X$ = 8						; size = 4
_cosf	PROC						; COMDAT

; 653  :             return (float)cos(_X);

	fld	DWORD PTR __X$[esp-4]
	fcos

; 654  :         }

	ret	0
_cosf	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_std_extensions.h
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_std_extensions.h
;	COMDAT ?_cos@@YAMM@Z
_TEXT	SEGMENT
_x$ = 8							; size = 4
?_cos@@YAMM@Z PROC					; _cos, COMDAT
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h

; 653  :             return (float)cos(_X);

	fld	DWORD PTR _x$[esp-4]
	fcos
; File I:\Vitalya\mine\NSProjectX\xrCore\_std_extensions.h

; 101  : IC float	_cos	(float x)		{ return cosf(x); }

	ret	0
?_cos@@YAMM@Z ENDP					; _cos
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h
;	COMDAT ?negative@@YAHABM@Z
_TEXT	SEGMENT
?negative@@YAHABM@Z PROC				; negative, COMDAT
; _f$ = ecx

; 25   : 	IC BOOL negative(const float &f)	{ return (*((unsigned*)(&f))&fdSGN);	}

	mov	eax, DWORD PTR [ecx]
	and	eax, -2147483648			; 80000000H
	ret	0
?negative@@YAHABM@Z ENDP				; negative
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
;	COMDAT ?set@?$_vector3@M@@QAEAAU1@ABU1@@Z
_TEXT	SEGMENT
_v$ = 8							; size = 4
?set@?$_vector3@M@@QAEAAU1@ABU1@@Z PROC			; _vector3<float>::set, COMDAT
; _this$ = ecx

; 24   : 	ICF SelfRef	set(const _vector3<float> &v)			{ x = T(v.x);	y = T(v.y);	z = T(v.z);	return *this;	};

	mov	eax, DWORD PTR _v$[esp-4]
	fld	DWORD PTR [eax]
	fstp	DWORD PTR [ecx]
	fld	DWORD PTR [eax+4]
	fstp	DWORD PTR [ecx+4]
	fld	DWORD PTR [eax+8]
	mov	eax, ecx
	fstp	DWORD PTR [ecx+8]
	ret	4
?set@?$_vector3@M@@QAEAAU1@ABU1@@Z ENDP			; _vector3<float>::set
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
;	COMDAT ?transform_tiny@?$_matrix@M@@QBEXAAU?$_vector3@M@@ABU2@@Z
_TEXT	SEGMENT
_dest$ = 8						; size = 4
_v$ = 12						; size = 4
?transform_tiny@?$_matrix@M@@QBEXAAU?$_vector3@M@@ABU2@@Z PROC ; _matrix<float>::transform_tiny, COMDAT
; _this$ = ecx

; 499  : 		dest.x = v.x*_11 + v.y*_21 + v.z*_31 + _41;

	mov	edx, DWORD PTR _v$[esp-4]
	movss	xmm1, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR _dest$[esp-4]
	mulss	xmm1, DWORD PTR [edx+4]
	movss	xmm0, DWORD PTR [edx]
	mulss	xmm0, DWORD PTR [ecx]
	addss	xmm1, xmm0
	movss	xmm0, DWORD PTR [ecx+32]
	mulss	xmm0, DWORD PTR [edx+8]
	addss	xmm0, DWORD PTR [ecx+48]
	addss	xmm1, xmm0
	movss	DWORD PTR [eax], xmm1

; 500  : 		dest.y = v.x*_12 + v.y*_22 + v.z*_32 + _42;

	movss	xmm1, DWORD PTR [ecx+4]
	mulss	xmm1, DWORD PTR [edx]
	movss	xmm0, DWORD PTR [ecx+20]
	mulss	xmm0, DWORD PTR [edx+4]
	addss	xmm1, xmm0
	movss	xmm0, DWORD PTR [ecx+36]
	mulss	xmm0, DWORD PTR [edx+8]
	addss	xmm0, DWORD PTR [ecx+52]
	addss	xmm1, xmm0
	movss	DWORD PTR [eax+4], xmm1

; 501  : 		dest.z = v.x*_13 + v.y*_23 + v.z*_33 + _43;

	movss	xmm0, DWORD PTR [ecx+24]
	mulss	xmm0, DWORD PTR [edx+4]
	movss	xmm1, DWORD PTR [ecx+8]
	mulss	xmm1, DWORD PTR [edx]
	addss	xmm1, xmm0
	movss	xmm0, DWORD PTR [ecx+40]
	mulss	xmm0, DWORD PTR [edx+8]
	addss	xmm0, DWORD PTR [ecx+56]
	addss	xmm1, xmm0
	movss	DWORD PTR [eax+8], xmm1

; 502  : 	}

	ret	8
?transform_tiny@?$_matrix@M@@QBEXAAU?$_vector3@M@@ABU2@@Z ENDP ; _matrix<float>::transform_tiny
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
;	COMDAT ?mul@?$_vector3@M@@QAEAAU1@M@Z
_TEXT	SEGMENT
_s$ = 8							; size = 4
?mul@?$_vector3@M@@QAEAAU1@M@Z PROC			; _vector3<float>::mul, COMDAT
; _this$ = ecx

; 40   : 	ICF SelfRef	mul(T s)								{ x*=s;		y*=s;		z*=s;			return *this;	};

	movss	xmm1, DWORD PTR _s$[esp-4]
	mov	eax, ecx
	movaps	xmm0, xmm1
	mulss	xmm0, DWORD PTR [ecx]
	movss	DWORD PTR [ecx], xmm0
	movaps	xmm0, xmm1
	mulss	xmm0, DWORD PTR [ecx+4]
	mulss	xmm1, DWORD PTR [ecx+8]
	movss	DWORD PTR [ecx+4], xmm0
	movss	DWORD PTR [ecx+8], xmm1
	ret	4
?mul@?$_vector3@M@@QAEAAU1@M@Z ENDP			; _vector3<float>::mul
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\detailformat.h
;	COMDAT ?r_qclr@DetailSlot@@QAEMII@Z
_TEXT	SEGMENT
tv68 = 8						; size = 4
_v$ = 8							; size = 4
_range$dead$ = 12					; size = 4
?r_qclr@DetailSlot@@QAEMII@Z PROC			; DetailSlot::r_qclr, COMDAT
; _this$dead$ = ecx

; 103  : 	float			r_qclr		(u32 v,   u32 range)	{	return float(v)/float(range); }

	mov	eax, DWORD PTR _v$[esp-4]
	fild	DWORD PTR _v$[esp-4]
	test	eax, eax
	jns	SHORT $LN3@r_qclr
	fadd	DWORD PTR __real@4f800000
$LN3@r_qclr:
	fmul	DWORD PTR __real@3d888889
	ret	8
?r_qclr@DetailSlot@@QAEMII@Z ENDP			; DetailSlot::r_qclr
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
;	COMDAT ?mul_43@?$_matrix@M@@QAEAAU1@ABU1@0@Z
_TEXT	SEGMENT
_A$ = 8							; size = 4
_B$ = 12						; size = 4
?mul_43@?$_matrix@M@@QAEAAU1@ABU1@0@Z PROC		; _matrix<float>::mul_43, COMDAT
; _this$ = ecx

; 110  : 		VERIFY	((this!=&A)&&(this!=&B));
; 111  : 		m[0][0] = A.m[0][0] * B.m[0][0] + A.m[1][0] * B.m[0][1] + A.m[2][0] * B.m[0][2];

	mov	edx, DWORD PTR _A$[esp-4]
	mov	eax, DWORD PTR _B$[esp-4]
	movss	xmm1, DWORD PTR [edx]
	mulss	xmm1, DWORD PTR [eax]
	movss	xmm0, DWORD PTR [eax+4]
	mulss	xmm0, DWORD PTR [edx+16]
	addss	xmm1, xmm0
	movss	xmm0, DWORD PTR [eax+8]
	mulss	xmm0, DWORD PTR [edx+32]
	addss	xmm1, xmm0
	movss	DWORD PTR [ecx], xmm1

; 112  : 		m[0][1] = A.m[0][1] * B.m[0][0] + A.m[1][1] * B.m[0][1] + A.m[2][1] * B.m[0][2];

	movss	xmm1, DWORD PTR [edx+20]
	mulss	xmm1, DWORD PTR [eax+4]
	movss	xmm0, DWORD PTR [edx+4]
	mulss	xmm0, DWORD PTR [eax]
	addss	xmm1, xmm0
	movss	xmm0, DWORD PTR [edx+36]
	mulss	xmm0, DWORD PTR [eax+8]
	addss	xmm1, xmm0
	movss	DWORD PTR [ecx+4], xmm1

; 113  : 		m[0][2] = A.m[0][2] * B.m[0][0] + A.m[1][2] * B.m[0][1] + A.m[2][2] * B.m[0][2];

	movss	xmm1, DWORD PTR [edx+24]
	mulss	xmm1, DWORD PTR [eax+4]
	movss	xmm0, DWORD PTR [edx+8]
	mulss	xmm0, DWORD PTR [eax]
	addss	xmm1, xmm0
	movss	xmm0, DWORD PTR [edx+40]
	mulss	xmm0, DWORD PTR [eax+8]

; 114  : 		m[0][3] = 0;

	mov	DWORD PTR [ecx+12], 0
	addss	xmm1, xmm0
	movss	DWORD PTR [ecx+8], xmm1

; 115  : 
; 116  : 		m[1][0] = A.m[0][0] * B.m[1][0] + A.m[1][0] * B.m[1][1] + A.m[2][0] * B.m[1][2];

	movss	xmm1, DWORD PTR [edx]
	mulss	xmm1, DWORD PTR [eax+16]
	movss	xmm0, DWORD PTR [edx+16]
	mulss	xmm0, DWORD PTR [eax+20]
	addss	xmm1, xmm0
	movss	xmm0, DWORD PTR [edx+32]
	mulss	xmm0, DWORD PTR [eax+24]
	addss	xmm1, xmm0
	movss	DWORD PTR [ecx+16], xmm1

; 117  : 		m[1][1] = A.m[0][1] * B.m[1][0] + A.m[1][1] * B.m[1][1] + A.m[2][1] * B.m[1][2];

	movss	xmm1, DWORD PTR [edx+20]
	mulss	xmm1, DWORD PTR [eax+20]
	movss	xmm0, DWORD PTR [edx+4]
	mulss	xmm0, DWORD PTR [eax+16]
	addss	xmm1, xmm0
	movss	xmm0, DWORD PTR [edx+36]
	mulss	xmm0, DWORD PTR [eax+24]
	addss	xmm1, xmm0
	movss	DWORD PTR [ecx+20], xmm1

; 118  : 		m[1][2] = A.m[0][2] * B.m[1][0] + A.m[1][2] * B.m[1][1] + A.m[2][2] * B.m[1][2];

	movss	xmm1, DWORD PTR [edx+24]
	mulss	xmm1, DWORD PTR [eax+20]
	movss	xmm0, DWORD PTR [edx+8]
	mulss	xmm0, DWORD PTR [eax+16]
	addss	xmm1, xmm0
	movss	xmm0, DWORD PTR [edx+40]
	mulss	xmm0, DWORD PTR [eax+24]

; 119  : 		m[1][3] = 0;

	mov	DWORD PTR [ecx+28], 0
	addss	xmm1, xmm0
	movss	DWORD PTR [ecx+24], xmm1

; 120  : 
; 121  : 		m[2][0] = A.m[0][0] * B.m[2][0] + A.m[1][0] * B.m[2][1] + A.m[2][0] * B.m[2][2];

	movss	xmm1, DWORD PTR [edx]
	mulss	xmm1, DWORD PTR [eax+32]
	movss	xmm0, DWORD PTR [eax+36]
	mulss	xmm0, DWORD PTR [edx+16]
	addss	xmm1, xmm0
	movss	xmm0, DWORD PTR [edx+32]
	mulss	xmm0, DWORD PTR [eax+40]
	addss	xmm1, xmm0
	movss	DWORD PTR [ecx+32], xmm1

; 122  : 		m[2][1] = A.m[0][1] * B.m[2][0] + A.m[1][1] * B.m[2][1] + A.m[2][1] * B.m[2][2];

	movss	xmm1, DWORD PTR [edx+20]
	mulss	xmm1, DWORD PTR [eax+36]
	movss	xmm0, DWORD PTR [edx+4]
	mulss	xmm0, DWORD PTR [eax+32]
	addss	xmm1, xmm0
	movss	xmm0, DWORD PTR [edx+36]
	mulss	xmm0, DWORD PTR [eax+40]
	addss	xmm1, xmm0
	movss	DWORD PTR [ecx+36], xmm1

; 123  : 		m[2][2] = A.m[0][2] * B.m[2][0] + A.m[1][2] * B.m[2][1] + A.m[2][2] * B.m[2][2];

	movss	xmm1, DWORD PTR [edx+24]
	movss	xmm0, DWORD PTR [edx+8]
	mulss	xmm1, DWORD PTR [eax+36]
	mulss	xmm0, DWORD PTR [eax+32]
	addss	xmm1, xmm0
	movss	xmm0, DWORD PTR [edx+40]
	mulss	xmm0, DWORD PTR [eax+40]

; 124  : 		m[2][3] = 0;

	mov	DWORD PTR [ecx+44], 0
	addss	xmm1, xmm0
	movss	DWORD PTR [ecx+40], xmm1

; 125  : 
; 126  : 		m[3][0] = A.m[0][0] * B.m[3][0] + A.m[1][0] * B.m[3][1] + A.m[2][0] * B.m[3][2] + A.m[3][0];

	movss	xmm0, DWORD PTR [eax+52]
	mulss	xmm0, DWORD PTR [edx+16]
	movss	xmm1, DWORD PTR [edx]
	mulss	xmm1, DWORD PTR [eax+48]
	addss	xmm1, xmm0
	movss	xmm0, DWORD PTR [eax+56]
	mulss	xmm0, DWORD PTR [edx+32]
	addss	xmm0, DWORD PTR [edx+48]
	addss	xmm1, xmm0
	movss	DWORD PTR [ecx+48], xmm1

; 127  : 		m[3][1] = A.m[0][1] * B.m[3][0] + A.m[1][1] * B.m[3][1] + A.m[2][1] * B.m[3][2] + A.m[3][1];

	movss	xmm1, DWORD PTR [edx+20]
	mulss	xmm1, DWORD PTR [eax+52]
	movss	xmm0, DWORD PTR [edx+4]
	mulss	xmm0, DWORD PTR [eax+48]
	addss	xmm1, xmm0
	movss	xmm0, DWORD PTR [edx+36]
	mulss	xmm0, DWORD PTR [eax+56]
	addss	xmm0, DWORD PTR [edx+52]
	addss	xmm1, xmm0
	movss	DWORD PTR [ecx+52], xmm1

; 128  : 		m[3][2] = A.m[0][2] * B.m[3][0] + A.m[1][2] * B.m[3][1] + A.m[2][2] * B.m[3][2] + A.m[3][2];

	movss	xmm0, DWORD PTR [edx+8]
	mulss	xmm0, DWORD PTR [eax+48]
	movss	xmm1, DWORD PTR [edx+24]
	mulss	xmm1, DWORD PTR [eax+52]
	addss	xmm1, xmm0
	movss	xmm0, DWORD PTR [edx+40]
	mulss	xmm0, DWORD PTR [eax+56]

; 129  : 		m[3][3] = 1;
; 130  : 		return *this;

	mov	eax, ecx
	addss	xmm0, DWORD PTR [edx+56]
	mov	DWORD PTR [ecx+60], 1065353216		; 3f800000H
	addss	xmm1, xmm0
	movss	DWORD PTR [ecx+56], xmm1

; 131  : 	}

	ret	8
?mul_43@?$_matrix@M@@QAEAAU1@ABU1@0@Z ENDP		; _matrix<float>::mul_43
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@URESULT@CDB@@@std@@@std@@@std@@QBEABURESULT@CDB@@XZ
_TEXT	SEGMENT
??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@URESULT@CDB@@@std@@@std@@@std@@QBEABURESULT@CDB@@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CDB::RESULT> > >::operator*, COMDAT
; _this$ = ecx

; 46   : #if _ITERATOR_DEBUG_LEVEL != 0
; 47   :         const auto _Mycont = static_cast<const _Myvec*>(this->_Getcont());
; 48   :         _STL_VERIFY(_Ptr, "can't dereference value-initialized vector iterator");
; 49   :         _STL_VERIFY(
; 50   :             _Mycont->_Myfirst <= _Ptr && _Ptr < _Mycont->_Mylast, "can't dereference out of range vector iterator");
; 51   : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 52   : 
; 53   :         return *_Ptr;

	mov	eax, DWORD PTR [ecx]

; 54   :     }

	ret	0
??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@URESULT@CDB@@@std@@@std@@@std@@QBEABURESULT@CDB@@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CDB::RESULT> > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@URESULT@CDB@@@std@@@std@@@std@@QBEAAURESULT@CDB@@XZ
_TEXT	SEGMENT
??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@URESULT@CDB@@@std@@@std@@@std@@QBEAAURESULT@CDB@@XZ PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CDB::RESULT> > >::operator*, COMDAT
; _this$ = ecx

; 261  :         return const_cast<reference>(_Mybase::operator*());

	mov	eax, DWORD PTR [ecx]

; 262  :     }

	ret	0
??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@URESULT@CDB@@@std@@@std@@@std@@QBEAAURESULT@CDB@@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CDB::RESULT> > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@URESULT@CDB@@@std@@@std@@@std@@QAE@PAURESULT@CDB@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Pvector$dead$ = 12					; size = 4
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@URESULT@CDB@@@std@@@std@@@std@@QAE@PAURESULT@CDB@@PBU_Container_base0@1@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CDB::RESULT> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CDB::RESULT> > >, COMDAT
; _this$ = ecx

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	eax, DWORD PTR __Parg$[esp-4]
	mov	DWORD PTR [ecx], eax

; 42   :         this->_Adopt(_Pvector);
; 43   :     }

	mov	eax, ecx
	ret	8
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@URESULT@CDB@@@std@@@std@@@std@@QAE@PAURESULT@CDB@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CDB::RESULT> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CDB::RESULT> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@URESULT@CDB@@@std@@@std@@@std@@QAE@PAURESULT@CDB@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
___param0$ = 8						; size = 4
___param1$dead$ = 12					; size = 4
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@URESULT@CDB@@@std@@@std@@@std@@QAE@PAURESULT@CDB@@PBU_Container_base0@1@@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CDB::RESULT> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<CDB::RESULT> > >, COMDAT
; _this$ = ecx

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	eax, DWORD PTR ___param0$[esp-4]
	mov	DWORD PTR [ecx], eax
	mov	eax, ecx
	ret	8
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@URESULT@CDB@@@std@@@std@@@std@@QAE@PAURESULT@CDB@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CDB::RESULT> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<CDB::RESULT> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef
;	COMDAT ??$addressof@V?$_Vector_val@U?$_Simple_types@URESULT@CDB@@@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@URESULT@CDB@@@std@@@0@AAV10@@Z
_TEXT	SEGMENT
??$addressof@V?$_Vector_val@U?$_Simple_types@URESULT@CDB@@@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@URESULT@CDB@@@std@@@0@AAV10@@Z PROC ; std::addressof<std::_Vector_val<std::_Simple_types<CDB::RESULT> > >, COMDAT
; __Val$ = ecx

; 253  :     return __builtin_addressof(_Val);

	mov	eax, ecx

; 254  : }

	ret	0
??$addressof@V?$_Vector_val@U?$_Simple_types@URESULT@CDB@@@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@URESULT@CDB@@@std@@@0@AAV10@@Z ENDP ; std::addressof<std::_Vector_val<std::_Simple_types<CDB::RESULT> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?begin@?$vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@URESULT@CDB@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@URESULT@CDB@@@std@@@std@@@2@XZ PROC ; std::vector<CDB::RESULT,xalloc<CDB::RESULT> >::begin, COMDAT
; _this$ = ecx

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	ecx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], ecx

; 1462 :         auto& _My_data = _Mypair._Myval2;
; 1463 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));
; 1464 :     }

	ret	4
?begin@?$vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@URESULT@CDB@@@std@@@std@@@2@XZ ENDP ; std::vector<CDB::RESULT,xalloc<CDB::RESULT> >::begin
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_random.h
;	COMDAT ?maxF@CRandom@@QAEMXZ
_TEXT	SEGMENT
?maxF@CRandom@@QAEMXZ PROC				; CRandom::maxF, COMDAT
; _this$dead$ = ecx

; 38   : 	IC 	float	maxF	()							{ return 32767.f;	}

	fld	DWORD PTR __real@46fffe00
	ret	0
?maxF@CRandom@@QAEMXZ ENDP				; CRandom::maxF
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_random.h
;	COMDAT ?randF@CRandom@@QAEMXZ
_TEXT	SEGMENT
tv68 = -4						; size = 4
?randF@CRandom@@QAEMXZ PROC				; CRandom::randF, COMDAT
; _this$ = ecx

; 39   : 	IC 	float	randF	()							{ return float(randI())/maxF();	}

	push	ecx
	call	?randI@CRandom@@QAEHXZ			; CRandom::randI
	mov	DWORD PTR tv68[esp+4], eax
	fild	DWORD PTR tv68[esp+4]
	fmul	DWORD PTR __real@38000100
	pop	ecx
	ret	0
?randF@CRandom@@QAEMXZ ENDP				; CRandom::randF
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_random.h
;	COMDAT ?randF@CRandom@@QAEMM@Z
_TEXT	SEGMENT
tv129 = -4						; size = 4
_max$ = 8						; size = 4
?randF@CRandom@@QAEMM@Z PROC				; CRandom::randF, COMDAT
; _this$ = ecx

; 40   : 	IC 	float	randF	(float max)					{ return randF()*max; }

	push	ecx

; 39   : 	IC 	float	randF	()							{ return float(randI())/maxF();	}

	call	?randI@CRandom@@QAEHXZ			; CRandom::randI
	mov	DWORD PTR tv129[esp+4], eax
	fild	DWORD PTR tv129[esp+4]
	fmul	DWORD PTR __real@38000100

; 40   : 	IC 	float	randF	(float max)					{ return randF()*max; }

	fmul	DWORD PTR _max$[esp]
	pop	ecx
	ret	4
?randF@CRandom@@QAEMM@Z ENDP				; CRandom::randF
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_random.h
;	COMDAT ?randF@CRandom@@QAEMMM@Z
_TEXT	SEGMENT
tv131 = -4						; size = 4
_min$ = 8						; size = 4
_max$ = 12						; size = 4
?randF@CRandom@@QAEMMM@Z PROC				; CRandom::randF, COMDAT
; _this$ = ecx

; 41   : 	IC 	float	randF	(float min,float max)		{ return min+randF(max-min); }

	push	ecx

; 39   : 	IC 	float	randF	()							{ return float(randI())/maxF();	}

	call	?randI@CRandom@@QAEHXZ			; CRandom::randI
	mov	DWORD PTR tv131[esp+4], eax
	fild	DWORD PTR tv131[esp+4]
	fmul	DWORD PTR __real@38000100

; 41   : 	IC 	float	randF	(float min,float max)		{ return min+randF(max-min); }

	fld	DWORD PTR _max$[esp]
	fld	DWORD PTR _min$[esp]
	fsub	ST(1), ST(0)

; 40   : 	IC 	float	randF	(float max)					{ return randF()*max; }

	fxch	ST(2)
	fmulp	ST(1), ST(0)

; 41   : 	IC 	float	randF	(float min,float max)		{ return min+randF(max-min); }

	faddp	ST(1), ST(0)
	pop	ecx
	ret	8
?randF@CRandom@@QAEMMM@Z ENDP				; CRandom::randF
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_random.h
;	COMDAT ?randFs@CRandom@@QAEMM@Z
_TEXT	SEGMENT
tv149 = -4						; size = 4
_range$ = 8						; size = 4
?randFs@CRandom@@QAEMM@Z PROC				; CRandom::randFs, COMDAT
; _this$ = ecx

; 42   : 	IC 	float	randFs	(float range)				{ return randF(-range,range); }

	push	ecx

; 39   : 	IC 	float	randF	()							{ return float(randI())/maxF();	}

	call	?randI@CRandom@@QAEHXZ			; CRandom::randI
	mov	DWORD PTR tv149[esp+4], eax
	fild	DWORD PTR tv149[esp+4]

; 40   : 	IC 	float	randF	(float max)					{ return randF()*max; }

	fld	DWORD PTR _range$[esp]
	fld	DWORD PTR __real@38800100
	fmul	ST(0), ST(1)
	fmulp	ST(2), ST(0)

; 41   : 	IC 	float	randF	(float min,float max)		{ return min+randF(max-min); }

	fsubp	ST(1), ST(0)

; 42   : 	IC 	float	randFs	(float range)				{ return randF(-range,range); }

	pop	ecx
	ret	4
?randFs@CRandom@@QAEMM@Z ENDP				; CRandom::randFs
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_random.h
;	COMDAT ??0CRandom@@QAE@H@Z
_TEXT	SEGMENT
__seed$ = 8						; size = 4
??0CRandom@@QAE@H@Z PROC				; CRandom::CRandom, COMDAT
; _this$ = ecx

; 27   : 	CRandom(s32 _seed)	: holdrand(_seed)			{};

	mov	eax, DWORD PTR __seed$[esp-4]
	mov	DWORD PTR [ecx], eax
	mov	eax, ecx
	ret	4
??0CRandom@@QAE@H@Z ENDP				; CRandom::CRandom
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h
;	COMDAT ?iCeil@@YAHM@Z
_TEXT	SEGMENT
_x$ = 8							; size = 4
?iCeil@@YAHM@Z PROC					; iCeil, COMDAT

; 104  :     int a			= (*(const int*)(&x));
; 105  :     int exponent	= (127 + 31) - ((a >> 23) & 0xFF);

	mov	edx, DWORD PTR _x$[esp-4]
	mov	ecx, 158				; 0000009eH
	mov	eax, edx
	sar	eax, 23					; 00000017H
	movzx	eax, al
	sub	ecx, eax

; 106  :     int r			= (((u32)(a) << 8) | (1U << 31)) >> exponent;

	mov	eax, edx
	or	eax, -8388608				; ff800000H
	push	esi
	shl	eax, 8

; 107  :     exponent		+= 31-127;
; 108  :     {
; 109  :         int imask	=	(!(((( (1<<(exponent)))-1)>>8)&a));

	mov	esi, 1
	shr	eax, cl
	sub	ecx, 96					; 00000060H
	shl	esi, cl
	dec	esi
	sar	esi, 8
	and	esi, edx
	neg	esi
	sbb	esi, esi

; 110  :         exponent	-=	(31-127)+32;
; 111  :         exponent	>>=	31;
; 112  :         a			=	~((a-1)>>31);		/* change sign */

	dec	edx
	sar	edx, 31					; 0000001fH
	inc	esi
	not	edx
	add	ecx, 64					; 00000040H

; 113  :         r			-=	(imask&a);

	and	esi, edx
	sar	ecx, 31					; 0000001fH
	sub	eax, esi

; 114  :         r			&=	exponent;

	and	eax, ecx

; 115  :         r			^=	a;

	xor	eax, edx

; 116  :         r			=	-r;                 /* change sign */

	neg	eax

; 117  :     }
; 118  :     return r;								/* r = (int)(ceil(f)) */

	pop	esi

; 119  : }

	ret	0
?iCeil@@YAHM@Z ENDP					; iCeil
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?size@?$vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@std@@QBEIXZ PROC ; std::vector<CDB::RESULT,xalloc<CDB::RESULT> >::size, COMDAT
; _this$ = ecx

; 1535 :         auto& _My_data = _Mypair._Myval2;
; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	eax, DWORD PTR [ecx+4]
	sub	eax, DWORD PTR [ecx]
	sar	eax, 3
	imul	eax, eax, -1227133513

; 1537 :     }

	ret	0
?size@?$vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@std@@QBEIXZ ENDP ; std::vector<CDB::RESULT,xalloc<CDB::RESULT> >::size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?size@?$xr_vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@@QBEIXZ
_TEXT	SEGMENT
?size@?$xr_vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@@QBEIXZ PROC ; xr_vector<CDB::RESULT,xalloc<CDB::RESULT> >::size, COMDAT
; _this$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	eax, DWORD PTR [ecx+4]
	sub	eax, DWORD PTR [ecx]
	sar	eax, 3
	imul	eax, eax, -1227133513
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 125  : 	u32		size				() const							{ return (u32)inherited::size();} 

	ret	0
?size@?$xr_vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@@QBEIXZ ENDP ; xr_vector<CDB::RESULT,xalloc<CDB::RESULT> >::size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\vector.h
;	COMDAT ??$clamp@H@@YAXAAHABH1@Z
_TEXT	SEGMENT
__high$ = 8						; size = 4
??$clamp@H@@YAXAAHABH1@Z PROC				; clamp<int>, COMDAT
; _val$ = ecx
; __low$ = edx

; 92   : 	if( val<_low ) val = _low; else if( val>_high ) val = _high;

	mov	eax, DWORD PTR [edx]
	cmp	DWORD PTR [ecx], eax
	jl	SHORT $LN6@clamp
	mov	eax, DWORD PTR __high$[esp-4]
	mov	eax, DWORD PTR [eax]
	cmp	DWORD PTR [ecx], eax
	jle	SHORT $LN4@clamp
$LN6@clamp:

; 93   : };

	mov	DWORD PTR [ecx], eax
$LN4@clamp:
	ret	0
??$clamp@H@@YAXAAHABH1@Z ENDP				; clamp<int>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
;	COMDAT ?crossproduct@?$_vector3@M@@QAEAAU1@ABU1@0@Z
_TEXT	SEGMENT
_v1$ = 8						; size = 4
_v2$ = 12						; size = 4
?crossproduct@?$_vector3@M@@QAEAAU1@ABU1@0@Z PROC	; _vector3<float>::crossproduct, COMDAT
; _this$ = ecx

; 273  : 		x = v1.y  * v2.z  - v1.z  * v2.y ;

	mov	eax, DWORD PTR _v2$[esp-4]
	mov	edx, DWORD PTR _v1$[esp-4]
	movss	xmm1, DWORD PTR [eax+8]
	mulss	xmm1, DWORD PTR [edx+4]
	movss	xmm0, DWORD PTR [edx+8]
	mulss	xmm0, DWORD PTR [eax+4]
	subss	xmm1, xmm0
	movss	DWORD PTR [ecx], xmm1

; 274  : 		y = v1.z  * v2.x  - v1.x  * v2.z ;

	movss	xmm1, DWORD PTR [edx+8]
	mulss	xmm1, DWORD PTR [eax]
	movss	xmm0, DWORD PTR [edx]
	mulss	xmm0, DWORD PTR [eax+8]
	subss	xmm1, xmm0
	movss	DWORD PTR [ecx+4], xmm1

; 275  : 		z = v1.x  * v2.y  - v1.y  * v2.x ;

	movss	xmm0, DWORD PTR [eax]
	movss	xmm1, DWORD PTR [edx]
	mulss	xmm1, DWORD PTR [eax+4]

; 276  : 		return *this;	

	mov	eax, ecx
	mulss	xmm0, DWORD PTR [edx+4]
	subss	xmm1, xmm0
	movss	DWORD PTR [ecx+8], xmm1

; 277  : 	}

	ret	8
?crossproduct@?$_vector3@M@@QAEAAU1@ABU1@0@Z ENDP	; _vector3<float>::crossproduct
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
;	COMDAT ?dotproduct@?$_vector3@M@@QBEMABU1@@Z
_TEXT	SEGMENT
_v$ = 8							; size = 4
?dotproduct@?$_vector3@M@@QBEMABU1@@Z PROC		; _vector3<float>::dotproduct, COMDAT
; _this$ = ecx

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	mov	eax, DWORD PTR _v$[esp-4]
	fld	DWORD PTR [eax+4]
	fmul	DWORD PTR [ecx+4]
	fld	DWORD PTR [eax]
	fmul	DWORD PTR [ecx]
	faddp	ST(1), ST(0)
	fld	DWORD PTR [eax+8]
	fmul	DWORD PTR [ecx+8]
	faddp	ST(1), ST(0)
	ret	4
?dotproduct@?$_vector3@M@@QBEMABU1@@Z ENDP		; _vector3<float>::dotproduct
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
;	COMDAT ?sub@?$_vector3@M@@QAEAAU1@ABU1@0@Z
_TEXT	SEGMENT
_a$ = 8							; size = 4
_v$ = 12						; size = 4
?sub@?$_vector3@M@@QAEAAU1@ABU1@0@Z PROC		; _vector3<float>::sub, COMDAT
; _this$ = ecx

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	mov	edx, DWORD PTR _a$[esp-4]
	mov	eax, DWORD PTR _v$[esp-4]
	movss	xmm0, DWORD PTR [edx]
	subss	xmm0, DWORD PTR [eax]
	movss	DWORD PTR [ecx], xmm0
	movss	xmm0, DWORD PTR [edx+4]
	subss	xmm0, DWORD PTR [eax+4]
	movss	DWORD PTR [ecx+4], xmm0
	movss	xmm0, DWORD PTR [edx+8]
	subss	xmm0, DWORD PTR [eax+8]
	mov	eax, ecx
	movss	DWORD PTR [ecx+8], xmm0
	ret	8
?sub@?$_vector3@M@@QAEAAU1@ABU1@0@Z ENDP		; _vector3<float>::sub
_TEXT	ENDS
END
