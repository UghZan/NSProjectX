; Listing generated by Microsoft (R) Optimizing Compiler Version 19.29.30146.0 

	TITLE	i:\vitalya\mine\nsprojectx\nspx_build\intermediate\release-win32\xrrender_r1\flod.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	??_C@_0L@JNMPPJCO@FLOD?3?3Load@			; `string'
PUBLIC	??_C@_0DE@DGAELPKD@I?3?2Vitalya?2mine?2NSProjectX?2laye@ ; `string'
PUBLIC	??_C@_0BO@MFDMOBON@data?9?$DOfind_chunk?$CIOGF_LODDEF2?$CJ@ ; `string'
EXTRN	__imp_?find_chunk@?$IReaderBase@VIReader@@@@QAEIIPAH@Z:PROC
EXTRN	?Copy@FHierrarhyVisual@@UAEXPAVIRender_Visual@@@Z:PROC ; FHierrarhyVisual::Copy
EXTRN	__imp_?Copy@FHierrarhyVisual@@UAEXPAVIRender_Visual@@@Z:PROC
EXTRN	?Load@FHierrarhyVisual@@UAEXPBDPAVIReader@@I@Z:PROC ; FHierrarhyVisual::Load
EXTRN	__imp_?Load@FHierrarhyVisual@@UAEXPBDPAVIReader@@I@Z:PROC
;	COMDAT ?ignore_always@?3??Load@FLOD@@UAEXPBDPAVIReader@@I@Z@4_NA
_BSS	SEGMENT
?ignore_always@?3??Load@FLOD@@UAEXPBDPAVIReader@@I@Z@4_NA DB 01H DUP (?) ; `FLOD::Load'::`4'::ignore_always
_BSS	ENDS
;	COMDAT ??_C@_0BO@MFDMOBON@data?9?$DOfind_chunk?$CIOGF_LODDEF2?$CJ@
CONST	SEGMENT
??_C@_0BO@MFDMOBON@data?9?$DOfind_chunk?$CIOGF_LODDEF2?$CJ@ DB 'data->fin'
	DB	'd_chunk(OGF_LODDEF2)', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DE@DGAELPKD@I?3?2Vitalya?2mine?2NSProjectX?2laye@
CONST	SEGMENT
??_C@_0DE@DGAELPKD@I?3?2Vitalya?2mine?2NSProjectX?2laye@ DB 'I:\Vitalya\m'
	DB	'ine\NSProjectX\layers\xrRender\FLOD.cpp', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@JNMPPJCO@FLOD?3?3Load@
CONST	SEGMENT
??_C@_0L@JNMPPJCO@FLOD?3?3Load@ DB 'FLOD::Load', 00H	; `string'
PUBLIC	?mknormal@?$_vector3@M@@QAEAAU1@ABU1@00@Z	; _vector3<float>::mknormal
PUBLIC	?normalize_safe@?$_vector3@M@@QAEAAU1@XZ	; _vector3<float>::normalize_safe
PUBLIC	?min@?$numeric_limits@M@std@@SAMXZ		; std::numeric_limits<float>::min
PUBLIC	?mknormal_non_normalized@?$_vector3@M@@QAEAAU1@ABU1@00@Z ; _vector3<float>::mknormal_non_normalized
PUBLIC	?add@?$_vector3@M@@QAEAAU1@ABU1@@Z		; _vector3<float>::add
PUBLIC	?div@?$_vector3@M@@QAEAAU1@M@Z			; _vector3<float>::div
PUBLIC	?getradius@?$_box3@M@@QBEXAAU?$_vector3@M@@@Z	; _box3<float>::getradius
PUBLIC	?getsize@?$_box3@M@@QBEXAAU?$_vector3@M@@@Z	; _box3<float>::getsize
PUBLIC	??$forward@AAPAM@std@@YAAAPAMAAPAM@Z		; std::forward<float * &>
PUBLIC	??$swap@M$0A@@std@@YAXAAM0@Z			; std::swap<float,0>
PUBLIC	??$_Med3_unchecked@PAMU?$less@X@std@@@std@@YAXPAM00U?$less@X@0@@Z ; std::_Med3_unchecked<float *,std::less<void> >
PUBLIC	??$_Pop_heap_hole_unchecked@PAMMU?$less@X@std@@@std@@YAXPAM00$$QAMU?$less@X@0@@Z ; std::_Pop_heap_hole_unchecked<float *,float,std::less<void> >
PUBLIC	??$_Push_heap_by_index@PAMMU?$less@X@std@@@std@@YAXPAMHH$$QAMU?$less@X@0@@Z ; std::_Push_heap_by_index<float *,float,std::less<void> >
PUBLIC	??$forward@M@std@@YA$$QAMAAM@Z			; std::forward<float>
PUBLIC	??$_To_address@PAM@std@@YA?A_PABQAM@Z		; std::_To_address<float *>
PUBLIC	??$_Copy_backward_memmove@PAMPAM@std@@YAPAMPAM00@Z ; std::_Copy_backward_memmove<float *,float *>
PUBLIC	??$?0AAPAMAAPAM$0A@@?$pair@PAMPAM@std@@QAE@AAPAM0@Z ; std::pair<float *,float *>::pair<float *,float *><float * &,float * &,0>
PUBLIC	??$iter_swap@PAMPAM@std@@YAXPAM0@Z		; std::iter_swap<float *,float *>
PUBLIC	??$_Next_iter@PAM@std@@YAPAMPAM@Z		; std::_Next_iter<float *>
PUBLIC	??$_Guess_median_unchecked@PAMU?$less@X@std@@@std@@YAXPAM00U?$less@X@0@@Z ; std::_Guess_median_unchecked<float *,std::less<void> >
PUBLIC	??$_Prev_iter@PAM@std@@YAPAMPAM@Z		; std::_Prev_iter<float *>
PUBLIC	??$_Pop_heap_unchecked@PAMU?$less@X@std@@@std@@YAXPAM0U?$less@X@0@@Z ; std::_Pop_heap_unchecked<float *,std::less<void> >
PUBLIC	??$_Pop_heap_hole_by_index@PAMMU?$less@X@std@@@std@@YAXPAMHH$$QAMU?$less@X@0@@Z ; std::_Pop_heap_hole_by_index<float *,float,std::less<void> >
PUBLIC	??$_Move_backward_unchecked@PAMPAM@std@@YAPAMPAM00@Z ; std::_Move_backward_unchecked<float *,float *>
PUBLIC	??$?RAAMAAM@?$less@X@std@@QBE_NAAM0@Z		; std::less<void>::operator()<float &,float &>
PUBLIC	??$move@AAM@std@@YA$$QAMAAM@Z			; std::move<float &>
PUBLIC	??$_Partition_by_median_guess_unchecked@PAMU?$less@X@std@@@std@@YA?AU?$pair@PAMPAM@0@PAM0U?$less@X@0@@Z ; std::_Partition_by_median_guess_unchecked<float *,std::less<void> >
PUBLIC	??$_Sort_heap_unchecked@PAMU?$less@X@std@@@std@@YAXPAM0U?$less@X@0@@Z ; std::_Sort_heap_unchecked<float *,std::less<void> >
PUBLIC	??$_Make_heap_unchecked@PAMU?$less@X@std@@@std@@YAXPAM0U?$less@X@0@@Z ; std::_Make_heap_unchecked<float *,std::less<void> >
PUBLIC	??$_Insertion_sort_unchecked@PAMU?$less@X@std@@@std@@YAPAMQAM0U?$less@X@0@@Z ; std::_Insertion_sort_unchecked<float *,std::less<void> >
PUBLIC	??$_Sort_unchecked@PAMU?$less@X@std@@@std@@YAXPAM0HU?$less@X@0@@Z ; std::_Sort_unchecked<float *,std::less<void> >
PUBLIC	??$_Pass_fn@U?$less@X@std@@$0A@@std@@YA?AU?$less@X@0@U10@@Z ; std::_Pass_fn<std::less<void>,0>
PUBLIC	??$_Adl_verify_range@PAMPAM@std@@YAXABQAM0@Z	; std::_Adl_verify_range<float *,float *>
PUBLIC	??$_Get_unwrapped@ABQAM@std@@YA?A_TABQAM@Z	; std::_Get_unwrapped<float * const &>
PUBLIC	??$sort@PAMU?$less@X@std@@@std@@YAXQAM0U?$less@X@0@@Z ; std::sort<float *,std::less<void> >
PUBLIC	??$sort@PAM@std@@YAXQAM0@Z			; std::sort<float *>
PUBLIC	?invert@?$_vector3@M@@QAEAAU1@XZ		; _vector3<float>::invert
PUBLIC	?normalize@?$_vector3@M@@QAEAAU1@ABU1@@Z	; _vector3<float>::normalize
PUBLIC	?Render@FLOD@@UAEXM@Z				; FLOD::Render
PUBLIC	?Copy@FLOD@@UAEXPAVIRender_Visual@@@Z		; FLOD::Copy
PUBLIC	?Load@FLOD@@UAEXPBDPAVIReader@@I@Z		; FLOD::Load
?dwDecl@@3PAU_D3DVERTEXELEMENT9@@A DW 00H		; dwDecl
	DW	00H
	DB	02H
	DB	00H
	DB	00H
	DB	00H
	DW	00H
	DW	0cH
	DB	02H
	DB	00H
	DB	00H
	DB	01H
	DW	00H
	DW	018H
	DB	02H
	DB	00H
	DB	03H
	DB	00H
	DW	00H
	DW	024H
	DB	02H
	DB	00H
	DB	03H
	DB	01H
	DW	00H
	DW	030H
	DB	04H
	DB	00H
	DB	0aH
	DB	00H
	DW	00H
	DW	034H
	DB	01H
	DB	00H
	DB	05H
	DB	00H
	DW	00H
	DW	03cH
	DB	01H
	DB	00H
	DB	05H
	DB	01H
	DW	00H
	DW	044H
	DB	04H
	DB	00H
	DB	05H
	DB	02H
	DW	00H
	DW	048H
	DB	04H
	DB	00H
	DB	05H
	DB	03H
	DW	0ffH
	DW	00H
	DB	011H
	DB	00H
	DB	00H
	DB	00H
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FLOD.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FLOD.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FLOD.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FLOD.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FLOD.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FLOD.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FLOD.cpp
_TEXT	SEGMENT
_S$ = -56						; size = 12
_this$1$ = -44						; size = 4
tv2637 = -40						; size = 4
tv2664 = -36						; size = 4
tv2619 = -32						; size = 4
tv2625 = -28						; size = 4
tv2641 = -24						; size = 4
tv2622 = -20						; size = 4
tv2561 = -16						; size = 4
tv2639 = -12						; size = 4
_T$1$sroa$1037$2$ = -8					; size = 4
_T$1$sroa$1037$1$ = -8					; size = 4
tv2629 = -4						; size = 4
_magnitude$1$ = 8					; size = 4
_T$1$sroa$895$1$ = 8					; size = 4
tv2631 = 8						; size = 4
tv2107 = 8						; size = 4
_N$ = 8							; size = 4
_r$ = 12						; size = 4
_data$ = 12						; size = 4
_magnitude$1$ = 16					; size = 4
_T$1$sroa$897$2$ = 16					; size = 4
$T2 = 16						; size = 1
tv2627 = 16						; size = 4
tv1327 = 16						; size = 4
_dwFlags$ = 16						; size = 4
?Load@FLOD@@UAEXPBDPAVIReader@@I@Z PROC			; FLOD::Load
; _this$ = ecx

; 32   : {

	sub	esp, 56					; 00000038H
	push	esi

; 33   : 	inherited::Load		(N,data,dwFlags);

	mov	esi, DWORD PTR _data$[esp+56]
	push	edi
	push	DWORD PTR _dwFlags$[esp+60]
	mov	edi, ecx
	push	esi
	push	DWORD PTR _N$[esp+68]
	mov	DWORD PTR _this$1$[esp+76], edi
	call	DWORD PTR __imp_?Load@FHierrarhyVisual@@UAEXPBDPAVIReader@@I@Z

; 34   : 
; 35   : 	// LOD-def
; 36   : 	R_ASSERT			(data->find_chunk(OGF_LODDEF2));

	cmp	BYTE PTR ?ignore_always@?3??Load@FLOD@@UAEXPBDPAVIReader@@I@Z@4_NA, 0
	jne	SHORT $LN2@Load
	push	0
	push	11					; 0000000bH
	mov	ecx, esi
	call	DWORD PTR __imp_?find_chunk@?$IReaderBase@VIReader@@@@QAEIIPAH@Z
	test	eax, eax
	jne	SHORT $LN2@Load
	mov	ecx, DWORD PTR __imp_?Debug@@3VxrDebug@@A
	push	OFFSET ?ignore_always@?3??Load@FLOD@@UAEXPBDPAVIReader@@I@Z@4_NA
	push	OFFSET ??_C@_0L@JNMPPJCO@FLOD?3?3Load@
	push	36					; 00000024H
	push	OFFSET ??_C@_0DE@DGAELPKD@I?3?2Vitalya?2mine?2NSProjectX?2laye@
	push	OFFSET ??_C@_0BO@MFDMOBON@data?9?$DOfind_chunk?$CIOGF_LODDEF2?$CJ@
	call	DWORD PTR __imp_?fail@xrDebug@@QAEXPBD0H0AA_N@Z
$LN2@Load:

; 37   : 	for (int f=0; f<8; f++)

	add	edi, 124				; 0000007cH
	mov	DWORD PTR tv2664[esp+64], 8
$LL7@Load:

; 38   : 	{
; 39   : 		data->r					(facets[f].v,sizeof(facets[f].v));

	mov	ecx, DWORD PTR _data$[esp+60]
	lea	esi, DWORD PTR [edi-36]
	push	112					; 00000070H
	push	esi
	call	DWORD PTR __imp_?r@IReader@@QAEXPAXH@Z
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	xmm1, DWORD PTR [edi+28]
	subss	xmm1, DWORD PTR [edi]
	movss	xmm5, DWORD PTR [edi+20]
	subss	xmm5, DWORD PTR [edi-8]
	movss	xmm0, DWORD PTR [edi-4]
	subss	xmm0, DWORD PTR [edi-32]
	movss	xmm2, DWORD PTR [edi+24]
	subss	xmm2, DWORD PTR [edi-4]
	movss	xmm7, DWORD PTR [edi]
	movss	xmm3, DWORD PTR [edi-28]
	movss	xmm4, DWORD PTR [esi]
	subss	xmm7, xmm3
	movss	xmm6, DWORD PTR [edi-8]
	movss	DWORD PTR tv2622[esp+64], xmm0
	subss	xmm6, xmm4
	movss	DWORD PTR tv2627[esp+60], xmm5
	movaps	xmm5, xmm1
	mulss	xmm5, xmm0

; 273  : 		x = v1.y  * v2.z  - v1.z  * v2.y ;

	movaps	xmm0, xmm2
	mulss	xmm0, xmm7

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	DWORD PTR tv2629[esp+64], xmm2

; 273  : 		x = v1.y  * v2.z  - v1.z  * v2.y ;

	movss	xmm2, DWORD PTR tv2627[esp+60]
	subss	xmm5, xmm0
	mulss	xmm2, xmm7

; 274  : 		y = v1.z  * v2.x  - v1.x  * v2.z ;

	movaps	xmm0, xmm1

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	DWORD PTR tv2625[esp+64], xmm7

; 274  : 		y = v1.z  * v2.x  - v1.x  * v2.z ;

	movss	xmm7, DWORD PTR tv2629[esp+64]
	mulss	xmm0, xmm6
	mulss	xmm7, xmm6
	subss	xmm2, xmm0

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	DWORD PTR tv2631[esp+60], xmm1

; 275  : 		z = v1.x  * v2.y  - v1.y  * v2.x ;

	movss	xmm0, DWORD PTR tv2627[esp+60]

; 200  : 		T magnitude=x*x + y*y + z*z;

	movaps	xmm1, xmm5

; 275  : 		z = v1.x  * v2.y  - v1.y  * v2.x ;

	mulss	xmm0, DWORD PTR tv2622[esp+64]

; 200  : 		T magnitude=x*x + y*y + z*z;

	mulss	xmm1, xmm5

; 275  : 		z = v1.x  * v2.y  - v1.y  * v2.x ;

	subss	xmm7, xmm0

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	DWORD PTR tv2619[esp+64], xmm6

; 275  : 		z = v1.x  * v2.y  - v1.y  * v2.x ;

	movaps	xmm0, xmm2
	movss	DWORD PTR _T$1$sroa$1037$1$[esp+64], xmm5
	mulss	xmm0, xmm2

; 200  : 		T magnitude=x*x + y*y + z*z;

	addss	xmm1, xmm0
	movaps	xmm0, xmm7
	mulss	xmm0, xmm7
	addss	xmm1, xmm0

; 201  : 		if (magnitude> std::numeric_limits<T>::min()) {

	comiss	xmm1, DWORD PTR __real@00800000
	jbe	SHORT $LN23@Load

; 202  : 			magnitude=_sqrt(1/magnitude);

	movss	xmm0, DWORD PTR __real@3f800000
	divss	xmm0, xmm1
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h

; 764  :             return (float)sqrt(_X);

	sqrtss	xmm0, xmm0
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 202  : 			magnitude=_sqrt(1/magnitude);

	mulss	xmm5, xmm0

; 203  : 			x *= magnitude;

	mulss	xmm2, xmm0
	movss	DWORD PTR _T$1$sroa$1037$1$[esp+64], xmm5

; 204  : 			y *= magnitude;

	mulss	xmm7, xmm0
$LN23@Load:

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	xmm0, DWORD PTR [edi+52]
	subss	xmm0, DWORD PTR [edi+24]
	movss	xmm1, DWORD PTR [edi+56]
	subss	xmm1, DWORD PTR [edi+28]
	movss	xmm5, DWORD PTR [edi+48]
	subss	xmm5, DWORD PTR [edi+20]
	movss	DWORD PTR tv2639[esp+64], xmm0

; 273  : 		x = v1.y  * v2.z  - v1.z  * v2.y ;

	mulss	xmm0, DWORD PTR tv2631[esp+60]

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	DWORD PTR tv2641[esp+64], xmm1
	mulss	xmm1, DWORD PTR tv2629[esp+64]

; 273  : 		x = v1.y  * v2.z  - v1.z  * v2.y ;

	movaps	xmm6, xmm5
	mulss	xmm6, DWORD PTR tv2631[esp+60]
	subss	xmm1, xmm0

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	DWORD PTR tv2637[esp+64], xmm5

; 274  : 		y = v1.z  * v2.x  - v1.x  * v2.z ;

	movss	xmm0, DWORD PTR tv2641[esp+64]
	mulss	xmm0, DWORD PTR tv2627[esp+60]
	subss	xmm6, xmm0
	movss	xmm0, DWORD PTR tv2639[esp+64]
	mulss	xmm0, DWORD PTR tv2627[esp+60]
	movss	DWORD PTR _T$1$sroa$897$2$[esp+60], xmm0

; 275  : 		z = v1.x  * v2.y  - v1.y  * v2.x ;

	movaps	xmm0, xmm5
	mulss	xmm0, DWORD PTR tv2629[esp+64]
	movss	xmm5, DWORD PTR _T$1$sroa$897$2$[esp+60]
	subss	xmm5, xmm0
	movaps	xmm0, xmm6
	mulss	xmm0, xmm6
	movss	DWORD PTR _T$1$sroa$897$2$[esp+60], xmm5

; 200  : 		T magnitude=x*x + y*y + z*z;

	movaps	xmm5, xmm1
	mulss	xmm5, xmm1
	addss	xmm5, xmm0
	movss	xmm0, DWORD PTR _T$1$sroa$897$2$[esp+60]
	mulss	xmm0, xmm0
	addss	xmm5, xmm0

; 201  : 		if (magnitude> std::numeric_limits<T>::min()) {

	comiss	xmm5, DWORD PTR __real@00800000
	movss	DWORD PTR _magnitude$1$[esp+60], xmm5
	movss	xmm5, DWORD PTR _T$1$sroa$1037$1$[esp+64]
	jbe	SHORT $LN44@Load

; 202  : 			magnitude=_sqrt(1/magnitude);

	movss	xmm0, DWORD PTR __real@3f800000
	divss	xmm0, DWORD PTR _magnitude$1$[esp+60]

; 204  : 			y *= magnitude;

	movss	xmm5, DWORD PTR _T$1$sroa$897$2$[esp+60]
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h

; 764  :             return (float)sqrt(_X);

	sqrtss	xmm0, xmm0
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 204  : 			y *= magnitude;

	mulss	xmm5, xmm0
	mulss	xmm1, xmm0
	movss	DWORD PTR _T$1$sroa$897$2$[esp+60], xmm5
	movss	xmm5, DWORD PTR _T$1$sroa$1037$1$[esp+64]

; 203  : 			x *= magnitude;

	mulss	xmm6, xmm0
$LN44@Load:

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	subss	xmm3, DWORD PTR [edi+56]
	subss	xmm4, DWORD PTR [edi+48]

; 29   : 	ICF	SelfRef	add(const Self &v)						{ x+=v.x;	y+=v.y;		z+=v.z;			return *this;	};

	addss	xmm2, xmm6

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	xmm6, DWORD PTR [edi-32]
	subss	xmm6, DWORD PTR [edi+52]

; 29   : 	ICF	SelfRef	add(const Self &v)						{ x+=v.x;	y+=v.y;		z+=v.z;			return *this;	};

	addss	xmm1, xmm5
	addss	xmm7, DWORD PTR _T$1$sroa$897$2$[esp+60]

; 273  : 		x = v1.y  * v2.z  - v1.z  * v2.y ;

	movaps	xmm5, xmm4
	mulss	xmm5, DWORD PTR tv2641[esp+64]
	movaps	xmm0, xmm6

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	DWORD PTR tv2561[esp+64], xmm6

; 273  : 		x = v1.y  * v2.z  - v1.z  * v2.y ;

	mulss	xmm0, DWORD PTR tv2641[esp+64]

; 274  : 		y = v1.z  * v2.x  - v1.x  * v2.z ;

	mulss	xmm6, DWORD PTR tv2637[esp+64]

; 29   : 	ICF	SelfRef	add(const Self &v)						{ x+=v.x;	y+=v.y;		z+=v.z;			return *this;	};

	movss	DWORD PTR _T$1$sroa$1037$2$[esp+64], xmm1

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movaps	xmm1, xmm3
	mulss	xmm1, DWORD PTR tv2639[esp+64]

; 29   : 	ICF	SelfRef	add(const Self &v)						{ x+=v.x;	y+=v.y;		z+=v.z;			return *this;	};

	movss	DWORD PTR _T$1$sroa$895$1$[esp+60], xmm2

; 273  : 		x = v1.y  * v2.z  - v1.z  * v2.y ;

	subss	xmm1, xmm0

; 274  : 		y = v1.z  * v2.x  - v1.x  * v2.z ;

	movaps	xmm0, xmm3
	mulss	xmm0, DWORD PTR tv2637[esp+64]
	subss	xmm5, xmm0

; 275  : 		z = v1.x  * v2.y  - v1.y  * v2.x ;

	movaps	xmm0, xmm4
	mulss	xmm0, DWORD PTR tv2639[esp+64]
	subss	xmm6, xmm0

; 200  : 		T magnitude=x*x + y*y + z*z;

	movaps	xmm0, xmm1
	mulss	xmm0, xmm1
	movss	DWORD PTR _magnitude$1$[esp+60], xmm0

; 275  : 		z = v1.x  * v2.y  - v1.y  * v2.x ;

	movaps	xmm0, xmm5

; 200  : 		T magnitude=x*x + y*y + z*z;

	movss	xmm2, DWORD PTR _magnitude$1$[esp+60]

; 275  : 		z = v1.x  * v2.y  - v1.y  * v2.x ;

	mulss	xmm0, xmm5

; 200  : 		T magnitude=x*x + y*y + z*z;

	addss	xmm2, xmm0
	movaps	xmm0, xmm6
	mulss	xmm0, xmm6
	addss	xmm2, xmm0

; 201  : 		if (magnitude> std::numeric_limits<T>::min()) {

	movaps	xmm0, xmm2
	movss	DWORD PTR _magnitude$1$[esp+60], xmm2
	comiss	xmm0, DWORD PTR __real@00800000
	movss	xmm2, DWORD PTR _T$1$sroa$895$1$[esp+60]
	jbe	SHORT $LN65@Load

; 202  : 			magnitude=_sqrt(1/magnitude);

	movss	xmm0, DWORD PTR __real@3f800000
	divss	xmm0, DWORD PTR _magnitude$1$[esp+60]
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h

; 764  :             return (float)sqrt(_X);

	sqrtss	xmm0, xmm0
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 202  : 			magnitude=_sqrt(1/magnitude);

	mulss	xmm1, xmm0

; 203  : 			x *= magnitude;

	mulss	xmm5, xmm0

; 204  : 			y *= magnitude;

	mulss	xmm6, xmm0
$LN65@Load:

; 29   : 	ICF	SelfRef	add(const Self &v)						{ x+=v.x;	y+=v.y;		z+=v.z;			return *this;	};

	addss	xmm6, xmm7

; 273  : 		x = v1.y  * v2.z  - v1.z  * v2.y ;

	movaps	xmm0, xmm3

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	xmm7, DWORD PTR tv2561[esp+64]

; 29   : 	ICF	SelfRef	add(const Self &v)						{ x+=v.x;	y+=v.y;		z+=v.z;			return *this;	};

	addss	xmm5, xmm2

; 273  : 		x = v1.y  * v2.z  - v1.z  * v2.y ;

	mulss	xmm0, DWORD PTR tv2622[esp+64]

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movaps	xmm2, xmm7
	mulss	xmm2, DWORD PTR tv2625[esp+64]

; 273  : 		x = v1.y  * v2.z  - v1.z  * v2.y ;

	mulss	xmm3, DWORD PTR tv2619[esp+64]

; 275  : 		z = v1.x  * v2.y  - v1.y  * v2.x ;

	mulss	xmm7, DWORD PTR tv2619[esp+64]
	subss	xmm2, xmm0
	movaps	xmm0, xmm4
	mulss	xmm4, DWORD PTR tv2622[esp+64]
	mulss	xmm0, DWORD PTR tv2625[esp+64]

; 29   : 	ICF	SelfRef	add(const Self &v)						{ x+=v.x;	y+=v.y;		z+=v.z;			return *this;	};

	addss	xmm1, DWORD PTR _T$1$sroa$1037$2$[esp+64]

; 275  : 		z = v1.x  * v2.y  - v1.y  * v2.x ;

	subss	xmm4, xmm7

; 200  : 		T magnitude=x*x + y*y + z*z;

	movaps	xmm7, xmm2

; 274  : 		y = v1.z  * v2.x  - v1.x  * v2.z ;

	subss	xmm3, xmm0

; 200  : 		T magnitude=x*x + y*y + z*z;

	mulss	xmm7, xmm2

; 275  : 		z = v1.x  * v2.y  - v1.y  * v2.x ;

	movaps	xmm0, xmm3
	mulss	xmm0, xmm3

; 200  : 		T magnitude=x*x + y*y + z*z;

	addss	xmm7, xmm0
	movaps	xmm0, xmm4
	mulss	xmm0, xmm4
	addss	xmm7, xmm0

; 201  : 		if (magnitude> std::numeric_limits<T>::min()) {

	comiss	xmm7, DWORD PTR __real@00800000
	jbe	SHORT $LN86@Load

; 202  : 			magnitude=_sqrt(1/magnitude);

	movss	xmm0, DWORD PTR __real@3f800000
	divss	xmm0, xmm7
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h

; 764  :             return (float)sqrt(_X);

	sqrtss	xmm0, xmm0
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 202  : 			magnitude=_sqrt(1/magnitude);

	mulss	xmm2, xmm0

; 203  : 			x *= magnitude;

	mulss	xmm3, xmm0

; 204  : 			y *= magnitude;

	mulss	xmm4, xmm0
$LN86@Load:

; 29   : 	ICF	SelfRef	add(const Self &v)						{ x+=v.x;	y+=v.y;		z+=v.z;			return *this;	};

	addss	xmm2, xmm1
	addss	xmm3, xmm5
	movss	xmm5, DWORD PTR __real@3e800000
	addss	xmm4, xmm6

; 214  : 		T mag=_sqrt(1/(v.x*v.x + v.y*v.y + v.z*v.z));

	movaps	xmm0, xmm2
	mulss	xmm0, xmm2
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FLOD.cpp

; 49   : 		facets[f].N.normalize	(N);

	movaps	xmm1, xmm3
	mulss	xmm1, xmm3
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 29   : 	ICF	SelfRef	add(const Self &v)						{ x+=v.x;	y+=v.y;		z+=v.z;			return *this;	};

	mulss	xmm2, xmm5

; 214  : 		T mag=_sqrt(1/(v.x*v.x + v.y*v.y + v.z*v.z));

	addss	xmm1, xmm0

; 45   : 	ICF SelfRef	div(T s)								{ x/=s;		y/=s;    z/=s;				return *this;	};

	mulss	xmm3, xmm5

; 214  : 		T mag=_sqrt(1/(v.x*v.x + v.y*v.y + v.z*v.z));

	movaps	xmm0, xmm4
	mulss	xmm0, xmm4

; 45   : 	ICF SelfRef	div(T s)								{ x/=s;		y/=s;    z/=s;				return *this;	};

	mulss	xmm4, xmm5

; 214  : 		T mag=_sqrt(1/(v.x*v.x + v.y*v.y + v.z*v.z));

	addss	xmm1, xmm0
	movss	xmm0, DWORD PTR __real@41800000
	divss	xmm0, xmm1

; 49   : 	IC	SelfRef	invert()								{ x=-x; y=-y; z=-z;						return *this;	}

	movss	xmm1, DWORD PTR __xmm@80000000800000008000000080000000
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h

; 764  :             return (float)sqrt(_X);

	sqrtss	xmm0, xmm0
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 214  : 		T mag=_sqrt(1/(v.x*v.x + v.y*v.y + v.z*v.z));

	mulss	xmm2, xmm0

; 215  : 		x = v.x*mag;

	mulss	xmm3, xmm0

; 216  : 		y = v.y*mag;

	mulss	xmm4, xmm0

; 49   : 	IC	SelfRef	invert()								{ x=-x; y=-y; z=-z;						return *this;	}

	xorps	xmm2, xmm1
	xorps	xmm3, xmm1
	movss	DWORD PTR [edi+76], xmm2
	movss	DWORD PTR [edi+80], xmm3
	xorps	xmm4, xmm1
	movss	DWORD PTR [edi+84], xmm4
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FLOD.cpp

; 37   : 	for (int f=0; f<8; f++)

	add	edi, 124				; 0000007cH
	sub	DWORD PTR tv2664[esp+64], 1
	jne	$LL7@Load

; 50   : 		facets[f].N.invert		();
; 51   : 	}
; 52   : 
; 53   : 	// VS
; 54   : 	geom.create			(dwDecl, RCache.Vertex.Buffer(), RCache.QuadIB);

	mov	eax, DWORD PTR __imp_?RCache@@3VCBackend@@A
	mov	esi, DWORD PTR _this$1$[esp+64]
	push	DWORD PTR [eax+40]
	lea	ecx, DWORD PTR [esi+84]
	push	DWORD PTR [eax]
	push	OFFSET ?dwDecl@@3PAU_D3DVERTEXELEMENT9@@A
	call	DWORD PTR __imp_?create@resptrcode_geom@@QAEXPAU_D3DVERTEXELEMENT9@@PAUIDirect3DVertexBuffer9@@PAUIDirect3DIndexBuffer9@@@Z
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	xmm0, DWORD PTR [esi+36]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 7080 :     _Sort_unchecked(_UFirst, _ULast, _ULast - _UFirst, _Pass_fn(_Pred));

	lea	edx, DWORD PTR _S$[esp+76]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	subss	xmm0, DWORD PTR [esi+24]
	movss	xmm1, DWORD PTR __real@3f000000
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 7080 :     _Sort_unchecked(_UFirst, _ULast, _ULast - _UFirst, _Pass_fn(_Pred));

	lea	ecx, DWORD PTR _S$[esp+64]
	mov	BYTE PTR $T2[esp+60], 0
	push	DWORD PTR $T2[esp+60]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	mulss	xmm0, xmm1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 7080 :     _Sort_unchecked(_UFirst, _ULast, _ULast - _UFirst, _Pass_fn(_Pred));

	push	3
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 40   : 	ICF SelfRef	mul(T s)								{ x*=s;		y*=s;		z*=s;			return *this;	};

	movss	DWORD PTR _S$[esp+72], xmm0

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	xmm0, DWORD PTR [esi+40]
	subss	xmm0, DWORD PTR [esi+28]

; 40   : 	ICF SelfRef	mul(T s)								{ x*=s;		y*=s;		z*=s;			return *this;	};

	mulss	xmm0, xmm1
	movss	DWORD PTR _S$[esp+76], xmm0

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	xmm0, DWORD PTR [esi+44]
	subss	xmm0, DWORD PTR [esi+32]

; 40   : 	ICF SelfRef	mul(T s)								{ x*=s;		y*=s;		z*=s;			return *this;	};

	mulss	xmm0, xmm1
	movss	DWORD PTR _S$[esp+80], xmm0
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FLOD.cpp

; 59   : 	float r 			= vis.sphere.R;

	movss	xmm0, DWORD PTR [esi+20]
	movss	DWORD PTR _r$[esp+68], xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 7080 :     _Sort_unchecked(_UFirst, _ULast, _ULast - _UFirst, _Pass_fn(_Pred));

	call	??$_Sort_unchecked@PAMU?$less@X@std@@@std@@YAXPAM0HU?$less@X@0@@Z ; std::_Sort_unchecked<float *,std::less<void> >
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FLOD.cpp

; 62   : 	float Sf			= 4.f*(0.5f*(r*r*asin(a/r)+a*_sqrt(r*r-a*a)));

	movss	xmm1, DWORD PTR _S$[esp+76]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 7080 :     _Sort_unchecked(_UFirst, _ULast, _ULast - _UFirst, _Pass_fn(_Pred));

	add	esp, 8
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FLOD.cpp

; 62   : 	float Sf			= 4.f*(0.5f*(r*r*asin(a/r)+a*_sqrt(r*r-a*a)));

	movss	xmm2, DWORD PTR _r$[esp+60]
	movaps	xmm0, xmm1
	fld	DWORD PTR _S$[esp+68]
	fdiv	DWORD PTR _r$[esp+60]
	mulss	xmm2, xmm2
	mulss	xmm0, xmm1
	movss	DWORD PTR tv1327[esp+60], xmm2
	subss	xmm2, xmm0
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h

; 764  :             return (float)sqrt(_X);

	sqrtss	xmm0, xmm2
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FLOD.cpp

; 62   : 	float Sf			= 4.f*(0.5f*(r*r*asin(a/r)+a*_sqrt(r*r-a*a)));

	mulss	xmm0, xmm1
	movss	DWORD PTR tv2107[esp+60], xmm0
	call	__CIasin
	fmul	DWORD PTR tv1327[esp+60]
	fld	DWORD PTR tv2107[esp+60]
	fadd	ST(0), ST(0)
	fxch	ST(1)
	fadd	ST(0), ST(0)

; 63   : 	float Ss			= M_PI*r*r;
; 64   : 	lod_factor			= Sf/Ss;

	pop	edi
	faddp	ST(1), ST(0)
	fld	DWORD PTR _r$[esp+56]
	fld	DWORD PTR __real@40490fdb
	fmul	ST(0), ST(1)
	fmulp	ST(1), ST(0)
	fdivp	ST(1), ST(0)
	fstp	DWORD PTR [esi+1080]
	pop	esi

; 65   : }

	add	esp, 56					; 00000038H
	ret	12					; 0000000cH
?Load@FLOD@@UAEXPBDPAVIReader@@I@Z ENDP			; FLOD::Load
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FLOD.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FLOD.cpp
_TEXT	SEGMENT
_pFrom$ = 8						; size = 4
?Copy@FLOD@@UAEXPAVIRender_Visual@@@Z PROC		; FLOD::Copy
; _this$ = ecx

; 67   : {

	push	ebx

; 68   : 	inherited::Copy		(pFrom);

	mov	ebx, DWORD PTR _pFrom$[esp]
	push	ebp
	push	esi
	push	edi
	push	ebx
	mov	edi, ecx
	call	DWORD PTR __imp_?Copy@FHierrarhyVisual@@UAEXPAVIRender_Visual@@@Z
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 48   : 	ICF		T *			_get	() const							{	return p_;																					}

	mov	esi, DWORD PTR [ebx+84]

; 46   : 	ICF		void		_set	(T * rhs) 							{	if (0!=rhs) rhs->dwReference++;	_dec(); p_ = rhs;											}

	test	esi, esi
	je	SHORT $LN10@Copy
	inc	DWORD PTR [esi]
$LN10@Copy:
	lea	ecx, DWORD PTR [edi+84]
	call	DWORD PTR __imp_?_dec@?$resptr_base@USGeometry@@@@IAEXXZ
	mov	DWORD PTR [edi+84], esi
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FLOD.cpp

; 73   : 	CopyMemory		(facets,F->facets,sizeof(facets));

	mov	ecx, 248				; 000000f8H
	fld	DWORD PTR [ebx+1080]
	lea	esi, DWORD PTR [ebx+88]
	fstp	DWORD PTR [edi+1080]
	add	edi, 88					; 00000058H
	rep movsd
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 74   : }

	ret	4
?Copy@FLOD@@UAEXPAVIRender_Visual@@@Z ENDP		; FLOD::Copy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FLOD.cpp
_TEXT	SEGMENT
_LOD$ = 8						; size = 4
?Render@FLOD@@UAEXM@Z PROC				; FLOD::Render
; _this$ = ecx

; 77   : 	/*
; 78   : 	Fvector				Ldir;
; 79   : 	Ldir.sub			(vis.sphere.P,Device.vCameraPosition);
; 80   : 	Ldir.normalize		();
; 81   : 
; 82   : 	int					best_id		= 0;
; 83   : 	float				best_dot	= Ldir.dotproduct(facets[0].N);
; 84   : 	float				dot;
; 85   : 
; 86   : 	dot	= Ldir.dotproduct	(facets[1].N); if (dot>best_dot) { best_id=1; best_dot=dot; }
; 87   : 	dot	= Ldir.dotproduct	(facets[2].N); if (dot>best_dot) { best_id=2; best_dot=dot; }
; 88   : 	dot	= Ldir.dotproduct	(facets[3].N); if (dot>best_dot) { best_id=3; best_dot=dot; }
; 89   : 	dot	= Ldir.dotproduct	(facets[4].N); if (dot>best_dot) { best_id=4; best_dot=dot; }
; 90   : 	dot	= Ldir.dotproduct	(facets[5].N); if (dot>best_dot) { best_id=5; best_dot=dot; }
; 91   : 	dot	= Ldir.dotproduct	(facets[6].N); if (dot>best_dot) { best_id=6; best_dot=dot; }
; 92   : 	dot	= Ldir.dotproduct	(facets[7].N); if (dot>best_dot) { best_id=7; best_dot=dot; }
; 93   : 
; 94   : #pragma todo("Smooth transitions")
; 95   : #pragma todo("5-coloring")
; 96   : 
; 97   : 	// Fill VB
; 98   : 	_face&		F					= facets[best_id];
; 99   : 	u32			vOffset				= 0;
; 100  : 	_hw*		V					= (_hw*) RCache.Vertex.Lock(4,geom->vb_stride,vOffset);
; 101  : 	V[0].set	(F.v[0].v,F.N,F.v[0].c_rgb_hemi,F.v[0].t.x,F.v[0].t.y);
; 102  : 	V[1].set	(F.v[1].v,F.N,F.v[1].c_rgb_hemi,F.v[1].t.x,F.v[1].t.y);
; 103  : 	V[2].set	(F.v[2].v,F.N,F.v[2].c_rgb_hemi,F.v[2].t.x,F.v[2].t.y);
; 104  : 	V[3].set	(F.v[3].v,F.N,F.v[3].c_rgb_hemi,F.v[3].t.x,F.v[3].t.y);
; 105  : 	RCache.Vertex.Unlock			(4,geom->vb_stride);
; 106  : 
; 107  : 	// Draw IT
; 108  : 	RCache.set_Geometry		(geom);
; 109  : 	RCache.Render			(D3DPT_TRIANGLEFAN,vOffset,2);
; 110  : 	*/
; 111  : }

	ret	4
?Render@FLOD@@UAEXM@Z ENDP				; FLOD::Render
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
;	COMDAT ?normalize@?$_vector3@M@@QAEAAU1@ABU1@@Z
_TEXT	SEGMENT
_v$ = 8							; size = 4
?normalize@?$_vector3@M@@QAEAAU1@ABU1@@Z PROC		; _vector3<float>::normalize, COMDAT
; _this$ = ecx

; 213  : 		VERIFY((v.x*v.x+v.y*v.y+v.z*v.z)>flt_zero);
; 214  : 		T mag=_sqrt(1/(v.x*v.x + v.y*v.y + v.z*v.z));

	mov	eax, DWORD PTR _v$[esp-4]
	movss	xmm3, DWORD PTR [eax]
	movss	xmm2, DWORD PTR [eax+4]
	movaps	xmm1, xmm3
	movss	xmm0, DWORD PTR [eax+8]
	mulss	xmm1, xmm3
	mulss	xmm2, xmm2
	mulss	xmm0, xmm0
	addss	xmm1, xmm2
	addss	xmm1, xmm0
	movss	xmm0, DWORD PTR __real@3f800000
	divss	xmm0, xmm1
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h

; 764  :             return (float)sqrt(_X);

	sqrtss	xmm1, xmm0
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 215  : 		x = v.x*mag;

	mulss	xmm3, xmm1

; 216  : 		y = v.y*mag;

	movaps	xmm0, xmm1
	movss	DWORD PTR [ecx], xmm3
	mulss	xmm0, DWORD PTR [eax+4]
	movss	DWORD PTR [ecx+4], xmm0

; 217  : 		z = v.z*mag;

	mulss	xmm1, DWORD PTR [eax+8]

; 218  : 		return *this;	

	mov	eax, ecx
	movss	DWORD PTR [ecx+8], xmm1

; 219  : 	}

	ret	4
?normalize@?$_vector3@M@@QAEAAU1@ABU1@@Z ENDP		; _vector3<float>::normalize
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
;	COMDAT ?invert@?$_vector3@M@@QAEAAU1@XZ
_TEXT	SEGMENT
?invert@?$_vector3@M@@QAEAAU1@XZ PROC			; _vector3<float>::invert, COMDAT
; _this$ = ecx

; 49   : 	IC	SelfRef	invert()								{ x=-x; y=-y; z=-z;						return *this;	}

	movss	xmm0, DWORD PTR [ecx]
	mov	eax, ecx
	movss	xmm1, DWORD PTR __xmm@80000000800000008000000080000000
	xorps	xmm0, xmm1
	movss	DWORD PTR [ecx], xmm0
	movss	xmm0, DWORD PTR [ecx+4]
	xorps	xmm0, xmm1
	movss	DWORD PTR [ecx+4], xmm0
	movss	xmm0, DWORD PTR [ecx+8]
	xorps	xmm0, xmm1
	movss	DWORD PTR [ecx+8], xmm0
	ret	0
?invert@?$_vector3@M@@QAEAAU1@XZ ENDP			; _vector3<float>::invert
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
;	COMDAT ??$sort@PAM@std@@YAXQAM0@Z
_TEXT	SEGMENT
$T1 = -4						; size = 1
??$sort@PAM@std@@YAXQAM0@Z PROC				; std::sort<float *>, COMDAT
; __First$ = ecx
; __Last$ = edx

; 7084 : _CONSTEXPR20 void sort(const _RanIt _First, const _RanIt _Last) { // order [_First, _Last)

	push	ecx

; 7080 :     _Sort_unchecked(_UFirst, _ULast, _ULast - _UFirst, _Pass_fn(_Pred));

	mov	eax, edx
	mov	BYTE PTR $T1[esp+4], 0
	push	DWORD PTR $T1[esp+4]
	sub	eax, ecx
	sar	eax, 2
	push	eax
	call	??$_Sort_unchecked@PAMU?$less@X@std@@@std@@YAXPAM0HU?$less@X@0@@Z ; std::_Sort_unchecked<float *,std::less<void> >

; 7085 :     _STD sort(_First, _Last, less<>{});
; 7086 : }

	add	esp, 12					; 0000000cH
	ret	0
??$sort@PAM@std@@YAXQAM0@Z ENDP				; std::sort<float *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
;	COMDAT ??$sort@PAMU?$less@X@std@@@std@@YAXQAM0U?$less@X@0@@Z
_TEXT	SEGMENT
__Pred$ = 8						; size = 1
??$sort@PAMU?$less@X@std@@@std@@YAXQAM0U?$less@X@0@@Z PROC ; std::sort<float *,std::less<void> >, COMDAT
; __First$ = ecx
; __Last$ = edx

; 7077 :     _Adl_verify_range(_First, _Last);
; 7078 :     const auto _UFirst = _Get_unwrapped(_First);
; 7079 :     const auto _ULast  = _Get_unwrapped(_Last);
; 7080 :     _Sort_unchecked(_UFirst, _ULast, _ULast - _UFirst, _Pass_fn(_Pred));

	push	DWORD PTR __Pred$[esp-4]
	mov	eax, edx
	sub	eax, ecx
	sar	eax, 2
	push	eax
	call	??$_Sort_unchecked@PAMU?$less@X@std@@@std@@YAXPAM0HU?$less@X@0@@Z ; std::_Sort_unchecked<float *,std::less<void> >
	add	esp, 8

; 7081 : }

	ret	0
??$sort@PAMU?$less@X@std@@@std@@YAXQAM0U?$less@X@0@@Z ENDP ; std::sort<float *,std::less<void> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_Get_unwrapped@ABQAM@std@@YA?A_TABQAM@Z
_TEXT	SEGMENT
??$_Get_unwrapped@ABQAM@std@@YA?A_TABQAM@Z PROC		; std::_Get_unwrapped<float * const &>, COMDAT
; __It$ = ecx

; 1275 :     // unwrap an iterator previously subjected to _Adl_verify_range or otherwise validated
; 1276 :     if constexpr (is_pointer_v<decay_t<_Iter>>) { // special-case pointers and arrays
; 1277 :         return _It + 0;

	mov	eax, DWORD PTR [ecx]

; 1278 :     } else if constexpr (_Unwrappable_v<_Iter>) {
; 1279 :         return static_cast<_Iter&&>(_It)._Unwrapped();
; 1280 :     } else {
; 1281 :         return static_cast<_Iter&&>(_It);
; 1282 :     }
; 1283 : }

	ret	0
??$_Get_unwrapped@ABQAM@std@@YA?A_TABQAM@Z ENDP		; std::_Get_unwrapped<float * const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_Adl_verify_range@PAMPAM@std@@YAXABQAM0@Z
_TEXT	SEGMENT
??$_Adl_verify_range@PAMPAM@std@@YAXABQAM0@Z PROC	; std::_Adl_verify_range<float *,float *>, COMDAT
; __First$dead$ = ecx
; __Last$dead$ = edx

; 1259 :     // check that [_First, _Last) forms an iterator range
; 1260 :     if constexpr (_Range_verifiable_v<_Iter, _Sentinel>) {
; 1261 :         _Verify_range(_First, _Last);
; 1262 :     }
; 1263 : }

	ret	0
??$_Adl_verify_range@PAMPAM@std@@YAXABQAM0@Z ENDP	; std::_Adl_verify_range<float *,float *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_Pass_fn@U?$less@X@std@@$0A@@std@@YA?AU?$less@X@0@U10@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 1
??$_Pass_fn@U?$less@X@std@@$0A@@std@@YA?AU?$less@X@0@U10@@Z PROC ; std::_Pass_fn<std::less<void>,0>, COMDAT

; 253  :     return _Val;

	mov	al, BYTE PTR __Val$[esp-4]

; 254  : }

	ret	0
??$_Pass_fn@U?$less@X@std@@$0A@@std@@YA?AU?$less@X@0@U10@@Z ENDP ; std::_Pass_fn<std::less<void>,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
;	COMDAT ??$_Sort_unchecked@PAMU?$less@X@std@@@std@@YAXPAM0HU?$less@X@0@@Z
_TEXT	SEGMENT
__Last$1$ = -16						; size = 4
__First$1$ = -12					; size = 4
__Bottom$1$ = -12					; size = 4
tv2100 = -12						; size = 4
tv2028 = -8						; size = 4
__Val$1$ = -4						; size = 4
tv2114 = -4						; size = 4
__Val$2 = -4						; size = 4
__Ideal$ = 8						; size = 4
__Pred$ = 12						; size = 1
??$_Sort_unchecked@PAMU?$less@X@std@@@std@@YAXPAM0HU?$less@X@0@@Z PROC ; std::_Sort_unchecked<float *,std::less<void> >, COMDAT
; __First$ = ecx
; __Last$ = edx

; 7046 : _CONSTEXPR20 void _Sort_unchecked(_RanIt _First, _RanIt _Last, _Iter_diff_t<_RanIt> _Ideal, _Pr _Pred) {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	sub	esp, 20					; 00000014H
	push	ebx
	mov	ebx, ecx
	mov	DWORD PTR __Last$1$[esp+24], edx

; 7047 :     // order [_First, _Last)
; 7048 :     for (;;) {
; 7049 :         if (_Last - _First <= _ISORT_MAX) { // small

	mov	ecx, edx
	sub	edx, ebx
	mov	eax, edx
	and	eax, -4					; fffffffcH
	push	esi
	push	edi
	cmp	eax, 128				; 00000080H
	jle	$LN330@Sort_unche
$LL2@Sort_unche:

; 7050 :             _Insertion_sort_unchecked(_First, _Last, _Pred);
; 7051 :             return;
; 7052 :         }
; 7053 : 
; 7054 :         if (_Ideal <= 0) { // heap sort if too many divisions

	cmp	DWORD PTR __Ideal$[ebp], 0
	jle	$LN331@Sort_unche

; 6979 :     _Guess_median_unchecked(_First, _Mid, _Prev_iter(_Last), _Pred);

	lea	edi, DWORD PTR [ecx-4]
	sar	edx, 3

; 6962 :     const _Diff _Count = _Last - _First;

	mov	eax, edi
	sub	eax, ebx
	sar	eax, 2

; 6978 :     _RanIt _Mid = _First + ((_Last - _First) >> 1); // shift for codegen

	lea	esi, DWORD PTR [ebx+edx*4]

; 6963 :     if (40 < _Count) { // Tukey's ninther

	cmp	eax, 40					; 00000028H
	jle	$LN103@Sort_unche
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef

; 221  :         return static_cast<_Ty1&&>(_Left) < static_cast<_Ty2&&>(_Right);

	movss	xmm0, DWORD PTR [ebx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 6964 :         const _Diff _Step     = (_Count + 1) >> 3; // +1 can't overflow because range was made inclusive in caller

	inc	eax
	sar	eax, 3

; 6965 :         const _Diff _Two_step = _Step << 1; // note: intentionally discards low-order bit
; 6966 :         _Med3_unchecked(_First, _First + _Step, _First + _Two_step, _Pred);

	lea	edx, DWORD PTR [eax*8]
	shl	eax, 2
	mov	DWORD PTR tv2100[esp+32], edx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef

; 221  :         return static_cast<_Ty1&&>(_Left) < static_cast<_Ty2&&>(_Right);

	movss	xmm1, DWORD PTR [eax+ebx]
	comiss	xmm0, xmm1
	jbe	SHORT $LN113@Sort_unche
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 101  :     _Left    = _STD move(_Right);

	movss	DWORD PTR [eax+ebx], xmm0

; 102  :     _Right   = _STD move(_Tmp);

	movss	DWORD PTR [ebx], xmm1
	movss	xmm1, DWORD PTR [eax+ebx]
$LN113@Sort_unche:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef

; 221  :         return static_cast<_Ty1&&>(_Left) < static_cast<_Ty2&&>(_Right);

	movss	xmm0, DWORD PTR [edx+ebx]
	comiss	xmm1, xmm0
	jbe	SHORT $LN109@Sort_unche
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 101  :     _Left    = _STD move(_Right);

	movss	DWORD PTR [edx+ebx], xmm1

; 102  :     _Right   = _STD move(_Tmp);

	movss	DWORD PTR [eax+ebx], xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef

; 221  :         return static_cast<_Ty1&&>(_Left) < static_cast<_Ty2&&>(_Right);

	movss	xmm1, DWORD PTR [ebx]
	comiss	xmm1, xmm0
	jbe	SHORT $LN109@Sort_unche
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 101  :     _Left    = _STD move(_Right);

	movss	DWORD PTR [eax+ebx], xmm1

; 102  :     _Right   = _STD move(_Tmp);

	movss	DWORD PTR [ebx], xmm0
$LN109@Sort_unche:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef

; 221  :         return static_cast<_Ty1&&>(_Left) < static_cast<_Ty2&&>(_Right);

	movss	xmm0, DWORD PTR [esi]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 6967 :         _Med3_unchecked(_Mid - _Step, _Mid, _Mid + _Step, _Pred);

	mov	edx, esi
	sub	edx, eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef

; 221  :         return static_cast<_Ty1&&>(_Left) < static_cast<_Ty2&&>(_Right);

	movss	xmm1, DWORD PTR [edx]
	comiss	xmm1, xmm0
	jbe	SHORT $LN142@Sort_unche
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 101  :     _Left    = _STD move(_Right);

	movss	DWORD PTR [esi], xmm1

; 102  :     _Right   = _STD move(_Tmp);

	movss	DWORD PTR [edx], xmm0
	movss	xmm0, DWORD PTR [esi]
$LN142@Sort_unche:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef

; 221  :         return static_cast<_Ty1&&>(_Left) < static_cast<_Ty2&&>(_Right);

	movss	xmm1, DWORD PTR [esi+eax]
	comiss	xmm0, xmm1
	jbe	SHORT $LN138@Sort_unche
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 101  :     _Left    = _STD move(_Right);

	movss	DWORD PTR [esi+eax], xmm0

; 102  :     _Right   = _STD move(_Tmp);

	movss	DWORD PTR [esi], xmm1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef

; 221  :         return static_cast<_Ty1&&>(_Left) < static_cast<_Ty2&&>(_Right);

	movss	xmm0, DWORD PTR [edx]
	comiss	xmm0, xmm1
	jbe	SHORT $LN138@Sort_unche
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 101  :     _Left    = _STD move(_Right);

	movss	DWORD PTR [esi], xmm0

; 102  :     _Right   = _STD move(_Tmp);

	movss	DWORD PTR [edx], xmm1
$LN138@Sort_unche:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 6968 :         _Med3_unchecked(_Last - _Two_step, _Last - _Step, _Last, _Pred);

	mov	edx, edi
	mov	ecx, edi
	sub	ecx, DWORD PTR tv2100[esp+32]
	sub	edx, eax
	mov	DWORD PTR __First$1$[esp+32], ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef

; 221  :         return static_cast<_Ty1&&>(_Left) < static_cast<_Ty2&&>(_Right);

	movss	xmm0, DWORD PTR [edx]
	movss	xmm1, DWORD PTR [ecx]
	comiss	xmm1, xmm0
	jbe	SHORT $LN171@Sort_unche
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 101  :     _Left    = _STD move(_Right);

	movss	DWORD PTR [edx], xmm1

; 102  :     _Right   = _STD move(_Tmp);

	movss	DWORD PTR [ecx], xmm0
	movss	xmm0, DWORD PTR [edx]
$LN171@Sort_unche:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef

; 221  :         return static_cast<_Ty1&&>(_Left) < static_cast<_Ty2&&>(_Right);

	movss	xmm1, DWORD PTR [edi]
	comiss	xmm0, xmm1
	mov	ecx, DWORD PTR __Last$1$[esp+32]
	jbe	SHORT $LN167@Sort_unche
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 101  :     _Left    = _STD move(_Right);

	movss	DWORD PTR [edi], xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef

; 221  :         return static_cast<_Ty1&&>(_Left) < static_cast<_Ty2&&>(_Right);

	mov	edi, DWORD PTR __First$1$[esp+32]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 102  :     _Right   = _STD move(_Tmp);

	movss	DWORD PTR [edx], xmm1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef

; 221  :         return static_cast<_Ty1&&>(_Left) < static_cast<_Ty2&&>(_Right);

	movss	xmm0, DWORD PTR [edi]
	comiss	xmm0, xmm1
	jbe	SHORT $LN167@Sort_unche
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 101  :     _Left    = _STD move(_Right);

	movss	DWORD PTR [edx], xmm0

; 102  :     _Right   = _STD move(_Tmp);

	movss	DWORD PTR [edi], xmm1
$LN167@Sort_unche:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef

; 221  :         return static_cast<_Ty1&&>(_Left) < static_cast<_Ty2&&>(_Right);

	movss	xmm0, DWORD PTR [esi]
	movss	xmm1, DWORD PTR [eax+ebx]
	comiss	xmm1, xmm0
	jbe	SHORT $LN200@Sort_unche
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 101  :     _Left    = _STD move(_Right);

	movss	DWORD PTR [esi], xmm1

; 102  :     _Right   = _STD move(_Tmp);

	movss	DWORD PTR [eax+ebx], xmm0
	movss	xmm0, DWORD PTR [esi]
$LN200@Sort_unche:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef

; 221  :         return static_cast<_Ty1&&>(_Left) < static_cast<_Ty2&&>(_Right);

	movss	xmm1, DWORD PTR [edx]
	comiss	xmm0, xmm1
	jbe	SHORT $LN225@Sort_unche
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 101  :     _Left    = _STD move(_Right);

	movss	DWORD PTR [edx], xmm0

; 102  :     _Right   = _STD move(_Tmp);

	movss	DWORD PTR [esi], xmm1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef

; 221  :         return static_cast<_Ty1&&>(_Left) < static_cast<_Ty2&&>(_Right);

	movss	xmm0, DWORD PTR [eax+ebx]
	comiss	xmm0, xmm1
	jbe	SHORT $LN225@Sort_unche
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 101  :     _Left    = _STD move(_Right);

	movss	DWORD PTR [esi], xmm0

; 102  :     _Right   = _STD move(_Tmp);

	movss	DWORD PTR [eax+ebx], xmm1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 6970 :     } else {

	jmp	SHORT $LN225@Sort_unche
$LN103@Sort_unche:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef

; 221  :         return static_cast<_Ty1&&>(_Left) < static_cast<_Ty2&&>(_Right);

	movss	xmm0, DWORD PTR [esi]
	movss	xmm1, DWORD PTR [ebx]
	comiss	xmm1, xmm0
	jbe	SHORT $LN229@Sort_unche
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 101  :     _Left    = _STD move(_Right);

	movss	DWORD PTR [esi], xmm1

; 102  :     _Right   = _STD move(_Tmp);

	movss	DWORD PTR [ebx], xmm0
	movss	xmm0, DWORD PTR [esi]
$LN229@Sort_unche:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef

; 221  :         return static_cast<_Ty1&&>(_Left) < static_cast<_Ty2&&>(_Right);

	movss	xmm1, DWORD PTR [edi]
	comiss	xmm0, xmm1
	jbe	SHORT $LN225@Sort_unche
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 101  :     _Left    = _STD move(_Right);

	movss	DWORD PTR [edi], xmm0

; 102  :     _Right   = _STD move(_Tmp);

	movss	DWORD PTR [esi], xmm1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef

; 221  :         return static_cast<_Ty1&&>(_Left) < static_cast<_Ty2&&>(_Right);

	movss	xmm0, DWORD PTR [ebx]
	comiss	xmm0, xmm1
	jbe	SHORT $LN225@Sort_unche
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 101  :     _Left    = _STD move(_Right);

	movss	DWORD PTR [esi], xmm0

; 102  :     _Right   = _STD move(_Tmp);

	movss	DWORD PTR [ebx], xmm1
$LN225@Sort_unche:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 6981 :     _RanIt _Plast  = _Next_iter(_Pfirst);

	lea	edi, DWORD PTR [esi+4]

; 6982 : 
; 6983 :     while (_First < _Pfirst && !_DEBUG_LT_PRED(_Pred, *_Prev_iter(_Pfirst), *_Pfirst)
; 6984 :            && !_Pred(*_Pfirst, *_Prev_iter(_Pfirst))) {

	cmp	ebx, esi
	jae	SHORT $LN407@Sort_unche
	movss	xmm1, DWORD PTR [esi]
$LL70@Sort_unche:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef

; 221  :         return static_cast<_Ty1&&>(_Left) < static_cast<_Ty2&&>(_Right);

	movss	xmm0, DWORD PTR [esi-4]
	comiss	xmm1, xmm0
	ja	SHORT $LN407@Sort_unche
	comiss	xmm0, xmm1
	ja	SHORT $LN407@Sort_unche
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 6985 :         --_Pfirst;

	add	esi, -4					; fffffffcH
	movaps	xmm1, xmm0
	cmp	ebx, esi
	jb	SHORT $LL70@Sort_unche
$LN407@Sort_unche:

; 6988 :     while (_Plast < _Last && !_DEBUG_LT_PRED(_Pred, *_Plast, *_Pfirst) && !_Pred(*_Pfirst, *_Plast)) {

	cmp	edi, ecx
	jae	SHORT $LN408@Sort_unche
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef

; 221  :         return static_cast<_Ty1&&>(_Left) < static_cast<_Ty2&&>(_Right);

	movss	xmm1, DWORD PTR [esi]
$LL72@Sort_unche:
	movss	xmm0, DWORD PTR [edi]
	comiss	xmm1, xmm0
	ja	SHORT $LN408@Sort_unche
	comiss	xmm0, xmm1
	ja	SHORT $LN408@Sort_unche
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 6988 :     while (_Plast < _Last && !_DEBUG_LT_PRED(_Pred, *_Plast, *_Pfirst) && !_Pred(*_Pfirst, *_Plast)) {

	add	edi, 4
	cmp	edi, ecx
	jb	SHORT $LL72@Sort_unche
$LN408@Sort_unche:
	mov	edx, DWORD PTR __Last$1$[esp+32]

; 6989 :         ++_Plast;
; 6990 :     }
; 6991 : 
; 6992 :     _RanIt _Gfirst = _Plast;

	mov	eax, edi

; 6993 :     _RanIt _Glast  = _Pfirst;

	mov	ecx, esi
$LL74@Sort_unche:

; 6996 :         for (; _Gfirst < _Last; ++_Gfirst) {

	cmp	eax, edx
	jae	SHORT $LN409@Sort_unche
	npad	8
$LL79@Sort_unche:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef

; 221  :         return static_cast<_Ty1&&>(_Left) < static_cast<_Ty2&&>(_Right);

	movss	xmm0, DWORD PTR [esi]
	movss	xmm1, DWORD PTR [eax]
	comiss	xmm1, xmm0
	ja	SHORT $LN77@Sort_unche
	comiss	xmm0, xmm1
	ja	SHORT $LN409@Sort_unche
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 7001 :             } else if (_Plast != _Gfirst) {

	mov	edx, DWORD PTR __Last$1$[esp+32]
	cmp	edi, eax
	je	SHORT $LN87@Sort_unche
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 100  :     _Ty _Tmp = _STD move(_Left);

	movss	xmm0, DWORD PTR [edi]

; 101  :     _Left    = _STD move(_Right);

	movss	DWORD PTR [edi], xmm1

; 102  :     _Right   = _STD move(_Tmp);

	movss	DWORD PTR [eax], xmm0
$LN87@Sort_unche:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 6996 :         for (; _Gfirst < _Last; ++_Gfirst) {

	add	edi, 4
$LN77@Sort_unche:
	add	eax, 4
	cmp	eax, edx
	jb	SHORT $LL79@Sort_unche
$LN409@Sort_unche:

; 7009 :         for (; _First < _Glast; --_Glast) {

	cmp	ecx, ebx
	jbe	SHORT $LN412@Sort_unche
	lea	edx, DWORD PTR [ecx-4]
	npad	9
$LL82@Sort_unche:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef

; 221  :         return static_cast<_Ty1&&>(_Left) < static_cast<_Ty2&&>(_Right);

	movss	xmm1, DWORD PTR [edx]
	movss	xmm0, DWORD PTR [esi]
	comiss	xmm0, xmm1
	ja	SHORT $LN80@Sort_unche
	comiss	xmm1, xmm0
	ja	SHORT $LN410@Sort_unche
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 7014 :             } else if (--_Pfirst != _Prev_iter(_Glast)) {

	sub	esi, 4
	cmp	esi, edx
	je	SHORT $LN80@Sort_unche
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 100  :     _Ty _Tmp = _STD move(_Left);

	movss	xmm0, DWORD PTR [esi]

; 101  :     _Left    = _STD move(_Right);

	movss	DWORD PTR [esi], xmm1

; 102  :     _Right   = _STD move(_Tmp);

	movss	DWORD PTR [edx], xmm0
$LN80@Sort_unche:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 7009 :         for (; _First < _Glast; --_Glast) {

	sub	ecx, 4
	sub	edx, 4
	cmp	ebx, ecx
	jb	SHORT $LL82@Sort_unche
$LN410@Sort_unche:
	mov	edx, DWORD PTR __Last$1$[esp+32]

; 7015 :                 _STD iter_swap(_Pfirst, _Prev_iter(_Glast));
; 7016 :             }
; 7017 :         }
; 7018 : 
; 7019 :         if (_Glast == _First && _Gfirst == _Last) {

	cmp	ecx, ebx
$LN412@Sort_unche:
	jne	SHORT $LN95@Sort_unche
	cmp	eax, edx
	je	SHORT $LN329@Sort_unche

; 7020 :             return pair<_RanIt, _RanIt>(_Pfirst, _Plast);
; 7021 :         }
; 7022 : 
; 7023 :         if (_Glast == _First) { // no room at bottom, rotate pivot upward
; 7024 :             if (_Plast != _Gfirst) {

	cmp	edi, eax
	je	SHORT $LN97@Sort_unche
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 101  :     _Left    = _STD move(_Right);

	fld	DWORD PTR [edi]
	movss	xmm0, DWORD PTR [esi]
	fstp	DWORD PTR [esi]

; 102  :     _Right   = _STD move(_Tmp);

	movss	DWORD PTR [edi], xmm0
$LN97@Sort_unche:

; 101  :     _Left    = _STD move(_Right);

	fld	DWORD PTR [eax]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 7028 :             ++_Plast;

	add	edi, 4
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 100  :     _Ty _Tmp = _STD move(_Left);

	movss	xmm0, DWORD PTR [esi]

; 101  :     _Left    = _STD move(_Right);

	fstp	DWORD PTR [esi]

; 102  :     _Right   = _STD move(_Tmp);

	movss	DWORD PTR [eax], xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 7030 :             ++_Pfirst;

	add	esi, 4

; 7031 :             ++_Gfirst;

	add	eax, 4
	jmp	$LL74@Sort_unche
$LN95@Sort_unche:

; 7032 :         } else if (_Gfirst == _Last) { // no room at top, rotate pivot downward

	add	ecx, -4					; fffffffcH
	cmp	eax, edx
	jne	SHORT $LN98@Sort_unche

; 7033 :             if (--_Glast != --_Pfirst) {

	sub	esi, 4
	cmp	ecx, esi
	je	SHORT $LN352@Sort_unche
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 101  :     _Left    = _STD move(_Right);

	fld	DWORD PTR [esi]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 7037 :             _STD iter_swap(_Pfirst, --_Plast);

	sub	edi, 4
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 100  :     _Ty _Tmp = _STD move(_Left);

	movss	xmm0, DWORD PTR [ecx]

; 101  :     _Left    = _STD move(_Right);

	fstp	DWORD PTR [ecx]

; 102  :     _Right   = _STD move(_Tmp);

	movss	DWORD PTR [esi], xmm0

; 101  :     _Left    = _STD move(_Right);

	fld	DWORD PTR [edi]
	fstp	DWORD PTR [esi]

; 102  :     _Right   = _STD move(_Tmp);

	movss	DWORD PTR [edi], xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 7038 :         } else {

	jmp	$LL74@Sort_unche
$LN352@Sort_unche:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 101  :     _Left    = _STD move(_Right);

	fld	DWORD PTR [edi-4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 7037 :             _STD iter_swap(_Pfirst, --_Plast);

	sub	edi, 4
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 102  :     _Right   = _STD move(_Tmp);

	movss	xmm0, DWORD PTR [esi]

; 101  :     _Left    = _STD move(_Right);

	fstp	DWORD PTR [esi]

; 102  :     _Right   = _STD move(_Tmp);

	movss	DWORD PTR [edi], xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 7038 :         } else {

	jmp	$LL74@Sort_unche
$LN98@Sort_unche:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 100  :     _Ty _Tmp = _STD move(_Left);

	movss	xmm0, DWORD PTR [eax]

; 101  :     _Left    = _STD move(_Right);

	fld	DWORD PTR [ecx]
	fstp	DWORD PTR [eax]

; 102  :     _Right   = _STD move(_Tmp);

	movss	DWORD PTR [ecx], xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 7040 :             ++_Gfirst;

	add	eax, 4

; 7041 :         }
; 7042 :     }

	jmp	$LL74@Sort_unche
$LN329@Sort_unche:

; 7057 :             return;
; 7058 :         }
; 7059 : 
; 7060 :         // divide and conquer by quicksort
; 7061 :         auto _Mid = _Partition_by_median_guess_unchecked(_First, _Last, _Pred);
; 7062 : 
; 7063 :         _Ideal = (_Ideal >> 1) + (_Ideal >> 2); // allow 1.5 log2(N) divisions

	mov	edx, DWORD PTR __Ideal$[ebp]
	mov	eax, edx
	mov	ecx, DWORD PTR __Last$1$[esp+32]

; 7064 : 
; 7065 :         if (_Mid.first - _First < _Last - _Mid.second) { // loop on second half

	push	DWORD PTR __Pred$[ebp]
	sar	eax, 2
	sub	ecx, edi
	sar	edx, 1
	and	ecx, -4					; fffffffcH
	add	edx, eax
	mov	eax, esi
	sub	eax, ebx
	mov	DWORD PTR __Ideal$[ebp], edx
	and	eax, -4					; fffffffcH
	push	edx
	cmp	eax, ecx
	jge	SHORT $LN7@Sort_unche

; 7066 :             _Sort_unchecked(_First, _Mid.first, _Ideal, _Pred);

	mov	edx, esi
	mov	ecx, ebx
	call	??$_Sort_unchecked@PAMU?$less@X@std@@@std@@YAXPAM0HU?$less@X@0@@Z ; std::_Sort_unchecked<float *,std::less<void> >

; 7067 :             _First = _Mid.second;
; 7068 :         } else { // loop on first half

	mov	ecx, DWORD PTR __Last$1$[esp+40]
	mov	ebx, edi
	jmp	SHORT $LN413@Sort_unche
$LN7@Sort_unche:

; 7069 :             _Sort_unchecked(_Mid.second, _Last, _Ideal, _Pred);

	mov	edx, DWORD PTR __Last$1$[esp+40]
	mov	ecx, edi
	call	??$_Sort_unchecked@PAMU?$less@X@std@@@std@@YAXPAM0HU?$less@X@0@@Z ; std::_Sort_unchecked<float *,std::less<void> >

; 7070 :             _Last = _Mid.first;

	mov	ecx, esi
	mov	DWORD PTR __Last$1$[esp+40], ecx
$LN413@Sort_unche:

; 7047 :     // order [_First, _Last)
; 7048 :     for (;;) {
; 7049 :         if (_Last - _First <= _ISORT_MAX) { // small

	mov	edx, ecx
	add	esp, 8
	sub	edx, ebx
	mov	eax, edx
	and	eax, -4					; fffffffcH
	cmp	eax, 128				; 00000080H
	jg	$LL2@Sort_unche
$LN330@Sort_unche:

; 6921 :     if (_First != _Last) {

	cmp	ebx, ecx
	je	$LN61@Sort_unche

; 6922 :         for (_BidIt _Mid = _First; ++_Mid != _Last;) { // order next element

	lea	esi, DWORD PTR [ebx+4]
	cmp	esi, ecx
	je	$LN61@Sort_unche
	npad	5
$LL11@Sort_unche:

; 6924 :             _Iter_value_t<_BidIt> _Val = _STD move(*_Mid);

	movss	xmm1, DWORD PTR [esi]
	mov	edx, esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef

; 221  :         return static_cast<_Ty1&&>(_Left) < static_cast<_Ty2&&>(_Right);

	movss	xmm0, DWORD PTR [ebx]
	mov	eax, esi
	comiss	xmm0, xmm1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 6924 :             _Iter_value_t<_BidIt> _Val = _STD move(*_Mid);

	movss	DWORD PTR __Val$1$[esp+32], xmm1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef

; 221  :         return static_cast<_Ty1&&>(_Left) < static_cast<_Ty2&&>(_Right);

	jbe	$LL16@Sort_unche
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility

; 4254 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	mov	ecx, esi
	sub	ecx, ebx

; 4255 :     auto _Result                = _CSTD memmove(_Dest_ch - _Count, _First_ch, _Count);

	push	ecx
	sub	eax, ecx
	add	eax, 4
	push	ebx
	push	eax
	call	_memmove
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 6928 :                 *_First = _STD move(_Val);

	movss	xmm0, DWORD PTR __Val$1$[esp+44]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility

; 4255 :     auto _Result                = _CSTD memmove(_Dest_ch - _Count, _First_ch, _Count);

	add	esp, 12					; 0000000cH
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 6929 :             } else { // look for insertion point after first

	mov	ecx, DWORD PTR __Last$1$[esp+32]
	movss	DWORD PTR [ebx], xmm0
	jmp	$LN19@Sort_unche
$LN331@Sort_unche:

; 5547 :     _Diff _Bottom = _Last - _First;

	sar	edx, 2

; 5548 :     for (_Diff _Hole = _Bottom >> 1; _Hole > 0;) { // shift for codegen

	mov	esi, edx
	mov	DWORD PTR __Bottom$1$[esp+32], edx
	sar	esi, 1
	test	esi, esi
	jle	$LN37@Sort_unche
	lea	ecx, DWORD PTR [edx-1]

; 5385 :     const _Diff _Max_sequence_non_leaf = (_Bottom - 1) >> 1; // shift for codegen

	mov	DWORD PTR tv2028[esp+32], 1
	mov	edi, ecx
	mov	DWORD PTR tv2114[esp+32], ecx
	sar	edi, 1
	npad	8
$LL36@Sort_unche:

; 5551 :         _Iter_value_t<_RanIt> _Val = _STD move(*(_First + _Hole));

	movss	xmm1, DWORD PTR [ebx+esi*4-4]
	dec	esi

; 5552 :         _Pop_heap_hole_by_index(_First, _Hole, _Bottom, _STD move(_Val), _Pred);

	mov	edx, esi

; 5381 :     _Diff _Idx       = _Hole;

	mov	eax, esi

; 5386 :     while (_Idx < _Max_sequence_non_leaf) { // move _Hole down to larger child

	cmp	esi, edi
	jge	SHORT $LN42@Sort_unche
	npad	1
$LL41@Sort_unche:

; 5387 :         _Idx = 2 * _Idx + 2;

	lea	ecx, DWORD PTR [eax+eax]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef

; 221  :         return static_cast<_Ty1&&>(_Left) < static_cast<_Ty2&&>(_Right);

	mov	eax, 2
	movss	xmm0, DWORD PTR [ebx+ecx*4+4]
	comiss	xmm0, DWORD PTR [ebx+ecx*4+8]
	cmova	eax, DWORD PTR tv2028[esp+32]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 5391 :         *(_First + _Hole) = _STD move(*(_First + _Idx));

	add	eax, ecx
	fld	DWORD PTR [ebx+eax*4]
	fstp	DWORD PTR [ebx+edx*4]

; 5392 :         _Hole             = _Idx;

	mov	edx, eax
	cmp	eax, edi
	jl	SHORT $LL41@Sort_unche
	mov	ecx, DWORD PTR tv2114[esp+32]
$LN42@Sort_unche:

; 5393 :     }
; 5394 : 
; 5395 :     if (_Idx == _Max_sequence_non_leaf && _Bottom % 2 == 0) { // only child at bottom, move _Hole down to it

	cmp	edx, edi
	jne	SHORT $LN44@Sort_unche
	mov	eax, DWORD PTR __Bottom$1$[esp+32]
	test	al, 1
	jne	SHORT $LN44@Sort_unche

; 5396 :         *(_First + _Hole) = _STD move(*(_First + (_Bottom - 1)));

	fld	DWORD PTR [ebx+eax*4-4]
	fstp	DWORD PTR [ebx+edx*4]

; 5397 :         _Hole             = _Bottom - 1;

	mov	edx, ecx
$LN44@Sort_unche:

; 5268 :          _Top < _Hole && _DEBUG_LT_PRED(_Pred, *(_First + _Idx), _Val); //

	cmp	esi, edx
	jge	SHORT $LN411@Sort_unche
$LL53@Sort_unche:

; 5267 :     for (_Diff _Idx = (_Hole - 1) >> 1; // shift for codegen

	lea	eax, DWORD PTR [edx-1]
	sar	eax, 1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef

; 221  :         return static_cast<_Ty1&&>(_Left) < static_cast<_Ty2&&>(_Right);

	movss	xmm0, DWORD PTR [ebx+eax*4]
	comiss	xmm1, xmm0
	jbe	SHORT $LN411@Sort_unche
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 5272 :         _Hole             = _Idx;

	movss	DWORD PTR [ebx+edx*4], xmm0
	mov	edx, eax
	cmp	esi, eax
	jl	SHORT $LL53@Sort_unche
$LN411@Sort_unche:

; 5273 :     }
; 5274 : 
; 5275 :     *(_First + _Hole) = _STD forward<_Ty>(_Val); // drop _Val into final hole

	movss	DWORD PTR [ebx+edx*4], xmm1

; 5548 :     for (_Diff _Hole = _Bottom >> 1; _Hole > 0;) { // shift for codegen

	test	esi, esi
	jg	SHORT $LL36@Sort_unche
	mov	ecx, DWORD PTR __Last$1$[esp+32]
	mov	edx, DWORD PTR __Bottom$1$[esp+32]
$LN37@Sort_unche:

; 5774 :     for (; _Last - _First >= 2; --_Last) {

	cmp	edx, 2
	jl	$LN61@Sort_unche

; 7055 :             _Make_heap_unchecked(_First, _Last, _Pred);
; 7056 :             _Sort_heap_unchecked(_First, _Last, _Pred);

	mov	edi, DWORD PTR __Pred$[ebp]
	sub	ecx, ebx
	mov	eax, ecx
	mov	DWORD PTR __Last$1$[esp+32], ecx
	sar	eax, 2

; 5417 :     if (2 <= _Last - _First) {

	cmp	eax, 2
	jl	SHORT $LN60@Sort_unche
$LN415@Sort_unche:

; 5418 :         --_Last;
; 5419 :         _Iter_value_t<_RanIt> _Val = _STD move(*_Last);

	movss	xmm0, DWORD PTR [ebx+ecx-4]

; 5410 :     _Pop_heap_hole_by_index(

	lea	eax, DWORD PTR __Val$2[esp+32]
	fld	DWORD PTR [ebx]
	xor	edx, edx
	push	edi
	push	eax
	lea	eax, DWORD PTR [ecx-4]

; 5419 :         _Iter_value_t<_RanIt> _Val = _STD move(*_Last);

	movss	DWORD PTR __Val$2[esp+40], xmm0

; 5410 :     _Pop_heap_hole_by_index(

	sar	eax, 2
	fstp	DWORD PTR [ebx+ecx-4]
	push	eax
	mov	ecx, ebx
	call	??$_Pop_heap_hole_by_index@PAMMU?$less@X@std@@@std@@YAXPAMHH$$QAMU?$less@X@0@@Z ; std::_Pop_heap_hole_by_index<float *,float,std::less<void> >
	mov	ecx, DWORD PTR __Last$1$[esp+44]
	add	esp, 12					; 0000000cH
$LN60@Sort_unche:

; 5774 :     for (; _Last - _First >= 2; --_Last) {

	sub	ecx, 4
	mov	eax, ecx
	mov	DWORD PTR __Last$1$[esp+32], ecx
	sar	eax, 2
	cmp	eax, 2
	jge	SHORT $LN415@Sort_unche

; 7071 :         }
; 7072 :     }
; 7073 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LL16@Sort_unche:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef

; 221  :         return static_cast<_Ty1&&>(_Left) < static_cast<_Ty2&&>(_Right);

	movss	xmm0, DWORD PTR [eax-4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 6930 :                 for (_BidIt _Prev = _Hole; _DEBUG_LT_PRED(_Pred, _Val, *--_Prev); _Hole = _Prev) {

	sub	eax, 4
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef

; 221  :         return static_cast<_Ty1&&>(_Left) < static_cast<_Ty2&&>(_Right);

	comiss	xmm0, xmm1
	jbe	SHORT $LN33@Sort_unche
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 6930 :                 for (_BidIt _Prev = _Hole; _DEBUG_LT_PRED(_Pred, _Val, *--_Prev); _Hole = _Prev) {

	movss	DWORD PTR [edx], xmm0
	mov	edx, eax
	jmp	SHORT $LL16@Sort_unche
$LN33@Sort_unche:

; 6931 :                     *_Hole = _STD move(*_Prev); // move hole down
; 6932 :                 }
; 6933 : 
; 6934 :                 *_Hole = _STD move(_Val); // insert element in hole

	movss	DWORD PTR [edx], xmm1
$LN19@Sort_unche:

; 6922 :         for (_BidIt _Mid = _First; ++_Mid != _Last;) { // order next element

	add	esi, 4
	cmp	esi, ecx
	jne	$LL11@Sort_unche
$LN61@Sort_unche:

; 7071 :         }
; 7072 :     }
; 7073 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Sort_unchecked@PAMU?$less@X@std@@@std@@YAXPAM0HU?$less@X@0@@Z ENDP ; std::_Sort_unchecked<float *,std::less<void> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
;	COMDAT ??$_Insertion_sort_unchecked@PAMU?$less@X@std@@@std@@YAPAMQAM0U?$less@X@0@@Z
_TEXT	SEGMENT
__Val$1$ = -4						; size = 4
__Pred$ = 8						; size = 1
??$_Insertion_sort_unchecked@PAMU?$less@X@std@@@std@@YAPAMQAM0U?$less@X@0@@Z PROC ; std::_Insertion_sort_unchecked<float *,std::less<void> >, COMDAT
; __First$ = ecx
; __Last$ = edx

; 6919 : _CONSTEXPR20 _BidIt _Insertion_sort_unchecked(const _BidIt _First, const _BidIt _Last, _Pr _Pred) {

	push	ecx
	push	ebx
	push	edi
	mov	ebx, edx
	mov	edi, ecx

; 6920 :     // insertion sort [_First, _Last)
; 6921 :     if (_First != _Last) {

	cmp	edi, ebx
	je	SHORT $LN34@Insertion_

; 6922 :         for (_BidIt _Mid = _First; ++_Mid != _Last;) { // order next element

	push	esi
	lea	esi, DWORD PTR [edi+4]
	cmp	esi, ebx
	je	SHORT $LN35@Insertion_
$LL2@Insertion_:

; 6924 :             _Iter_value_t<_BidIt> _Val = _STD move(*_Mid);

	movss	xmm1, DWORD PTR [esi]
	mov	ecx, esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef

; 221  :         return static_cast<_Ty1&&>(_Left) < static_cast<_Ty2&&>(_Right);

	movss	xmm0, DWORD PTR [edi]
	mov	eax, esi
	comiss	xmm0, xmm1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 6924 :             _Iter_value_t<_BidIt> _Val = _STD move(*_Mid);

	movss	DWORD PTR __Val$1$[esp+16], xmm1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef

; 221  :         return static_cast<_Ty1&&>(_Left) < static_cast<_Ty2&&>(_Right);

	jbe	SHORT $LL7@Insertion_
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility

; 4254 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	sub	ecx, edi

; 4255 :     auto _Result                = _CSTD memmove(_Dest_ch - _Count, _First_ch, _Count);

	push	ecx
	sub	eax, ecx
	add	eax, 4
	push	edi
	push	eax
	call	_memmove
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 6928 :                 *_First = _STD move(_Val);

	movss	xmm0, DWORD PTR __Val$1$[esp+28]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility

; 4255 :     auto _Result                = _CSTD memmove(_Dest_ch - _Count, _First_ch, _Count);

	add	esp, 12					; 0000000cH
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 6928 :                 *_First = _STD move(_Val);

	movss	DWORD PTR [edi], xmm0

; 6929 :             } else { // look for insertion point after first

	jmp	SHORT $LN10@Insertion_
	npad	8
$LL7@Insertion_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef

; 221  :         return static_cast<_Ty1&&>(_Left) < static_cast<_Ty2&&>(_Right);

	movss	xmm0, DWORD PTR [eax-4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 6930 :                 for (_BidIt _Prev = _Hole; _DEBUG_LT_PRED(_Pred, _Val, *--_Prev); _Hole = _Prev) {

	sub	eax, 4
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef

; 221  :         return static_cast<_Ty1&&>(_Left) < static_cast<_Ty2&&>(_Right);

	comiss	xmm0, xmm1
	jbe	SHORT $LN24@Insertion_
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 6930 :                 for (_BidIt _Prev = _Hole; _DEBUG_LT_PRED(_Pred, _Val, *--_Prev); _Hole = _Prev) {

	movss	DWORD PTR [ecx], xmm0
	mov	ecx, eax
	jmp	SHORT $LL7@Insertion_
$LN24@Insertion_:

; 6931 :                     *_Hole = _STD move(*_Prev); // move hole down
; 6932 :                 }
; 6933 : 
; 6934 :                 *_Hole = _STD move(_Val); // insert element in hole

	movss	DWORD PTR [ecx], xmm1
$LN10@Insertion_:

; 6922 :         for (_BidIt _Mid = _First; ++_Mid != _Last;) { // order next element

	add	esi, 4
	cmp	esi, ebx
	jne	SHORT $LL2@Insertion_
$LN35@Insertion_:
	pop	esi
	pop	edi

; 6935 :             }
; 6936 :         }
; 6937 :     }
; 6938 : 
; 6939 :     return _Last;

	mov	eax, ebx

; 6940 : }

	pop	ebx
	pop	ecx
	ret	0
$LN34@Insertion_:
	pop	edi

; 6935 :             }
; 6936 :         }
; 6937 :     }
; 6938 : 
; 6939 :     return _Last;

	mov	eax, ebx

; 6940 : }

	pop	ebx
	pop	ecx
	ret	0
??$_Insertion_sort_unchecked@PAMU?$less@X@std@@@std@@YAPAMQAM0U?$less@X@0@@Z ENDP ; std::_Insertion_sort_unchecked<float *,std::less<void> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
;	COMDAT ??$_Make_heap_unchecked@PAMU?$less@X@std@@@std@@YAXPAM0U?$less@X@0@@Z
_TEXT	SEGMENT
__Bottom$1$ = -8					; size = 4
tv463 = -4						; size = 4
__Pred$ = 8						; size = 1
??$_Make_heap_unchecked@PAMU?$less@X@std@@@std@@YAXPAM0U?$less@X@0@@Z PROC ; std::_Make_heap_unchecked<float *,std::less<void> >, COMDAT
; __First$ = ecx
; __Last$ = edx

; 5544 : _CONSTEXPR20 void _Make_heap_unchecked(_RanIt _First, _RanIt _Last, _Pr _Pred) {

	sub	esp, 8
	push	esi
	mov	esi, ecx
	mov	DWORD PTR __Bottom$1$[esp+12], edx

; 5545 :     // make [_First, _Last) into a heap
; 5546 :     using _Diff   = _Iter_diff_t<_RanIt>;
; 5547 :     _Diff _Bottom = _Last - _First;

	mov	ecx, edx
	sub	ecx, esi
	sar	ecx, 2
	push	edi

; 5548 :     for (_Diff _Hole = _Bottom >> 1; _Hole > 0;) { // shift for codegen

	mov	edi, ecx
	mov	DWORD PTR __Bottom$1$[esp+16], ecx
	sar	edi, 1
	test	edi, edi
	jle	$LN3@Make_heap_

; 5385 :     const _Diff _Max_sequence_non_leaf = (_Bottom - 1) >> 1; // shift for codegen

	push	ebx
	push	ebp
	lea	ebp, DWORD PTR [ecx-1]
	mov	DWORD PTR tv463[esp+24], 1
	mov	ebx, ebp
	sar	ebx, 1
$LL2@Make_heap_:

; 5549 :         // reheap top half, bottom to top
; 5550 :         --_Hole;
; 5551 :         _Iter_value_t<_RanIt> _Val = _STD move(*(_First + _Hole));

	movss	xmm1, DWORD PTR [esi+edi*4-4]
	dec	edi

; 5552 :         _Pop_heap_hole_by_index(_First, _Hole, _Bottom, _STD move(_Val), _Pred);

	mov	edx, edi

; 5381 :     _Diff _Idx       = _Hole;

	mov	eax, edi

; 5386 :     while (_Idx < _Max_sequence_non_leaf) { // move _Hole down to larger child

	cmp	edi, ebx
	jge	SHORT $LN8@Make_heap_
$LL7@Make_heap_:

; 5387 :         _Idx = 2 * _Idx + 2;

	lea	ecx, DWORD PTR [eax+eax]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef

; 221  :         return static_cast<_Ty1&&>(_Left) < static_cast<_Ty2&&>(_Right);

	mov	eax, 2
	movss	xmm0, DWORD PTR [esi+ecx*4+4]
	comiss	xmm0, DWORD PTR [esi+ecx*4+8]
	cmova	eax, DWORD PTR tv463[esp+24]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 5391 :         *(_First + _Hole) = _STD move(*(_First + _Idx));

	add	eax, ecx
	fld	DWORD PTR [esi+eax*4]
	fstp	DWORD PTR [esi+edx*4]

; 5392 :         _Hole             = _Idx;

	mov	edx, eax
	cmp	eax, ebx
	jl	SHORT $LL7@Make_heap_
	mov	ecx, DWORD PTR __Bottom$1$[esp+24]
$LN8@Make_heap_:

; 5393 :     }
; 5394 : 
; 5395 :     if (_Idx == _Max_sequence_non_leaf && _Bottom % 2 == 0) { // only child at bottom, move _Hole down to it

	cmp	edx, ebx
	jne	SHORT $LN10@Make_heap_
	test	cl, 1
	jne	SHORT $LN10@Make_heap_

; 5396 :         *(_First + _Hole) = _STD move(*(_First + (_Bottom - 1)));

	fld	DWORD PTR [esi+ecx*4-4]
	fstp	DWORD PTR [esi+edx*4]

; 5397 :         _Hole             = _Bottom - 1;

	mov	edx, ebp
$LN10@Make_heap_:

; 5268 :          _Top < _Hole && _DEBUG_LT_PRED(_Pred, *(_First + _Idx), _Val); //

	cmp	edi, edx
	jge	SHORT $LN38@Make_heap_
$LL19@Make_heap_:

; 5267 :     for (_Diff _Idx = (_Hole - 1) >> 1; // shift for codegen

	lea	eax, DWORD PTR [edx-1]
	sar	eax, 1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef

; 221  :         return static_cast<_Ty1&&>(_Left) < static_cast<_Ty2&&>(_Right);

	movss	xmm0, DWORD PTR [esi+eax*4]
	comiss	xmm1, xmm0
	jbe	SHORT $LN38@Make_heap_
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 5272 :         _Hole             = _Idx;

	movss	DWORD PTR [esi+edx*4], xmm0
	mov	edx, eax
	cmp	edi, eax
	jl	SHORT $LL19@Make_heap_
$LN38@Make_heap_:

; 5273 :     }
; 5274 : 
; 5275 :     *(_First + _Hole) = _STD forward<_Ty>(_Val); // drop _Val into final hole

	movss	DWORD PTR [esi+edx*4], xmm1

; 5548 :     for (_Diff _Hole = _Bottom >> 1; _Hole > 0;) { // shift for codegen

	test	edi, edi
	jg	SHORT $LL2@Make_heap_
	pop	ebp
	pop	ebx
$LN3@Make_heap_:
	pop	edi

; 5553 :     }
; 5554 : }

	pop	esi
	add	esp, 8
	ret	0
??$_Make_heap_unchecked@PAMU?$less@X@std@@@std@@YAXPAM0U?$less@X@0@@Z ENDP ; std::_Make_heap_unchecked<float *,std::less<void> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
;	COMDAT ??$_Sort_heap_unchecked@PAMU?$less@X@std@@@std@@YAXPAM0U?$less@X@0@@Z
_TEXT	SEGMENT
__Val$1 = -4						; size = 4
__Pred$ = 8						; size = 1
??$_Sort_heap_unchecked@PAMU?$less@X@std@@@std@@YAXPAM0U?$less@X@0@@Z PROC ; std::_Sort_heap_unchecked<float *,std::less<void> >, COMDAT
; __First$ = ecx
; __Last$ = edx

; 5772 : _CONSTEXPR20 void _Sort_heap_unchecked(_RanIt _First, _RanIt _Last, _Pr _Pred) {

	push	ecx
	push	esi
	push	edi
	mov	esi, edx
	mov	edi, ecx

; 5773 :     // order heap by repeatedly popping
; 5774 :     for (; _Last - _First >= 2; --_Last) {

	sub	esi, edi
	mov	eax, esi
	and	eax, -4					; fffffffcH
	cmp	eax, 8
	jl	SHORT $LN3@Sort_heap_
	push	ebx
	mov	ebx, DWORD PTR __Pred$[esp+12]
	npad	8
$LL4@Sort_heap_:

; 5419 :         _Iter_value_t<_RanIt> _Val = _STD move(*_Last);

	movss	xmm0, DWORD PTR [edi+esi-4]

; 5410 :     _Pop_heap_hole_by_index(

	lea	eax, DWORD PTR __Val$1[esp+16]
	fld	DWORD PTR [edi]
	xor	edx, edx
	push	ebx
	push	eax
	lea	eax, DWORD PTR [esi-4]

; 5419 :         _Iter_value_t<_RanIt> _Val = _STD move(*_Last);

	movss	DWORD PTR __Val$1[esp+24], xmm0

; 5410 :     _Pop_heap_hole_by_index(

	sar	eax, 2
	mov	ecx, edi
	push	eax
	fstp	DWORD PTR [edi+esi-4]
	call	??$_Pop_heap_hole_by_index@PAMMU?$less@X@std@@@std@@YAXPAMHH$$QAMU?$less@X@0@@Z ; std::_Pop_heap_hole_by_index<float *,float,std::less<void> >

; 5773 :     // order heap by repeatedly popping
; 5774 :     for (; _Last - _First >= 2; --_Last) {

	sub	esi, 4

; 5410 :     _Pop_heap_hole_by_index(

	add	esp, 12					; 0000000cH

; 5773 :     // order heap by repeatedly popping
; 5774 :     for (; _Last - _First >= 2; --_Last) {

	mov	eax, esi
	and	eax, -4					; fffffffcH
	cmp	eax, 8
	jge	SHORT $LL4@Sort_heap_
	pop	ebx
$LN3@Sort_heap_:
	pop	edi

; 5775 :         _Pop_heap_unchecked(_First, _Last, _Pred);
; 5776 :     }
; 5777 : }

	pop	esi
	pop	ecx
	ret	0
??$_Sort_heap_unchecked@PAMU?$less@X@std@@@std@@YAXPAM0U?$less@X@0@@Z ENDP ; std::_Sort_heap_unchecked<float *,std::less<void> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
;	COMDAT ??$_Partition_by_median_guess_unchecked@PAMU?$less@X@std@@@std@@YA?AU?$pair@PAMPAM@0@PAM0U?$less@X@0@@Z
_TEXT	SEGMENT
___$ReturnUdt$1$ = -4					; size = 4
tv1331 = 8						; size = 4
__Last$ = 8						; size = 4
__Pred$ = 12						; size = 1
??$_Partition_by_median_guess_unchecked@PAMU?$less@X@std@@@std@@YA?AU?$pair@PAMPAM@0@PAM0U?$less@X@0@@Z PROC ; std::_Partition_by_median_guess_unchecked<float *,std::less<void> >, COMDAT
; ___$ReturnUdt$ = ecx
; __First$ = edx

; 6976 : _CONSTEXPR20 pair<_RanIt, _RanIt> _Partition_by_median_guess_unchecked(_RanIt _First, _RanIt _Last, _Pr _Pred) {

	push	ecx
	push	ebx
	push	ebp

; 6977 :     // partition [_First, _Last)
; 6978 :     _RanIt _Mid = _First + ((_Last - _First) >> 1); // shift for codegen

	mov	ebp, DWORD PTR __Last$[esp+8]
	mov	ebx, edx
	mov	eax, ebp
	mov	DWORD PTR ___$ReturnUdt$1$[esp+12], ecx
	sub	eax, ebx
	sar	eax, 3
	push	esi
	push	edi
	lea	esi, DWORD PTR [ebx+eax*4]

; 6962 :     const _Diff _Count = _Last - _First;

	lea	eax, DWORD PTR [ebp-4]
	sub	eax, ebx
	sar	eax, 2

; 6963 :     if (40 < _Count) { // Tukey's ninther

	cmp	eax, 40					; 00000028H
	jle	$LN35@Partition_
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef

; 221  :         return static_cast<_Ty1&&>(_Left) < static_cast<_Ty2&&>(_Right);

	movss	xmm0, DWORD PTR [ebx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 6964 :         const _Diff _Step     = (_Count + 1) >> 3; // +1 can't overflow because range was made inclusive in caller

	inc	eax
	sar	eax, 3

; 6965 :         const _Diff _Two_step = _Step << 1; // note: intentionally discards low-order bit
; 6966 :         _Med3_unchecked(_First, _First + _Step, _First + _Two_step, _Pred);

	lea	ecx, DWORD PTR [eax*8]
	shl	eax, 2
	mov	DWORD PTR tv1331[esp+16], ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef

; 221  :         return static_cast<_Ty1&&>(_Left) < static_cast<_Ty2&&>(_Right);

	movss	xmm1, DWORD PTR [eax+ebx]
	comiss	xmm0, xmm1
	jbe	SHORT $LN45@Partition_
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 101  :     _Left    = _STD move(_Right);

	movss	DWORD PTR [eax+ebx], xmm0

; 102  :     _Right   = _STD move(_Tmp);

	movss	DWORD PTR [ebx], xmm1
	movss	xmm1, DWORD PTR [eax+ebx]
$LN45@Partition_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef

; 221  :         return static_cast<_Ty1&&>(_Left) < static_cast<_Ty2&&>(_Right);

	movss	xmm0, DWORD PTR [ecx+ebx]
	comiss	xmm1, xmm0
	jbe	SHORT $LN41@Partition_
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 101  :     _Left    = _STD move(_Right);

	movss	DWORD PTR [ecx+ebx], xmm1

; 102  :     _Right   = _STD move(_Tmp);

	movss	DWORD PTR [eax+ebx], xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef

; 221  :         return static_cast<_Ty1&&>(_Left) < static_cast<_Ty2&&>(_Right);

	movss	xmm1, DWORD PTR [ebx]
	comiss	xmm1, xmm0
	jbe	SHORT $LN41@Partition_
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 101  :     _Left    = _STD move(_Right);

	movss	DWORD PTR [eax+ebx], xmm1

; 102  :     _Right   = _STD move(_Tmp);

	movss	DWORD PTR [ebx], xmm0
$LN41@Partition_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef

; 221  :         return static_cast<_Ty1&&>(_Left) < static_cast<_Ty2&&>(_Right);

	movss	xmm0, DWORD PTR [esi]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 6967 :         _Med3_unchecked(_Mid - _Step, _Mid, _Mid + _Step, _Pred);

	mov	ecx, esi
	sub	ecx, eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef

; 221  :         return static_cast<_Ty1&&>(_Left) < static_cast<_Ty2&&>(_Right);

	movss	xmm1, DWORD PTR [ecx]
	comiss	xmm1, xmm0
	jbe	SHORT $LN74@Partition_
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 101  :     _Left    = _STD move(_Right);

	movss	DWORD PTR [esi], xmm1

; 102  :     _Right   = _STD move(_Tmp);

	movss	DWORD PTR [ecx], xmm0
	movss	xmm0, DWORD PTR [esi]
$LN74@Partition_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef

; 221  :         return static_cast<_Ty1&&>(_Left) < static_cast<_Ty2&&>(_Right);

	movss	xmm1, DWORD PTR [eax+esi]
	comiss	xmm0, xmm1
	jbe	SHORT $LN70@Partition_
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 101  :     _Left    = _STD move(_Right);

	movss	DWORD PTR [eax+esi], xmm0

; 102  :     _Right   = _STD move(_Tmp);

	movss	DWORD PTR [esi], xmm1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef

; 221  :         return static_cast<_Ty1&&>(_Left) < static_cast<_Ty2&&>(_Right);

	movss	xmm0, DWORD PTR [ecx]
	comiss	xmm0, xmm1
	jbe	SHORT $LN70@Partition_
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 101  :     _Left    = _STD move(_Right);

	movss	DWORD PTR [esi], xmm0

; 102  :     _Right   = _STD move(_Tmp);

	movss	DWORD PTR [ecx], xmm1
$LN70@Partition_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 6968 :         _Med3_unchecked(_Last - _Two_step, _Last - _Step, _Last, _Pred);

	lea	ecx, DWORD PTR [ebp-4]
	lea	edi, DWORD PTR [ebp-4]
	sub	ecx, eax
	sub	edi, DWORD PTR tv1331[esp+16]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef

; 221  :         return static_cast<_Ty1&&>(_Left) < static_cast<_Ty2&&>(_Right);

	movss	xmm0, DWORD PTR [ecx]
	movss	xmm1, DWORD PTR [edi]
	comiss	xmm1, xmm0
	jbe	SHORT $LN103@Partition_
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 101  :     _Left    = _STD move(_Right);

	movss	DWORD PTR [ecx], xmm1

; 102  :     _Right   = _STD move(_Tmp);

	movss	DWORD PTR [edi], xmm0
	movss	xmm0, DWORD PTR [ecx]
$LN103@Partition_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef

; 221  :         return static_cast<_Ty1&&>(_Left) < static_cast<_Ty2&&>(_Right);

	movss	xmm1, DWORD PTR [ebp-4]
	comiss	xmm0, xmm1
	jbe	SHORT $LN99@Partition_
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 101  :     _Left    = _STD move(_Right);

	movss	DWORD PTR [ebp-4], xmm0

; 102  :     _Right   = _STD move(_Tmp);

	movss	DWORD PTR [ecx], xmm1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef

; 221  :         return static_cast<_Ty1&&>(_Left) < static_cast<_Ty2&&>(_Right);

	movss	xmm0, DWORD PTR [edi]
	comiss	xmm0, xmm1
	jbe	SHORT $LN99@Partition_
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 101  :     _Left    = _STD move(_Right);

	movss	DWORD PTR [ecx], xmm0

; 102  :     _Right   = _STD move(_Tmp);

	movss	DWORD PTR [edi], xmm1
$LN99@Partition_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef

; 221  :         return static_cast<_Ty1&&>(_Left) < static_cast<_Ty2&&>(_Right);

	movss	xmm0, DWORD PTR [esi]
	movss	xmm1, DWORD PTR [eax+ebx]
	comiss	xmm1, xmm0
	jbe	SHORT $LN132@Partition_
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 101  :     _Left    = _STD move(_Right);

	movss	DWORD PTR [esi], xmm1

; 102  :     _Right   = _STD move(_Tmp);

	movss	DWORD PTR [eax+ebx], xmm0
	movss	xmm0, DWORD PTR [esi]
$LN132@Partition_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef

; 221  :         return static_cast<_Ty1&&>(_Left) < static_cast<_Ty2&&>(_Right);

	movss	xmm1, DWORD PTR [ecx]
	comiss	xmm0, xmm1
	jbe	SHORT $LN157@Partition_
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 101  :     _Left    = _STD move(_Right);

	movss	DWORD PTR [ecx], xmm0

; 102  :     _Right   = _STD move(_Tmp);

	movss	DWORD PTR [esi], xmm1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef

; 221  :         return static_cast<_Ty1&&>(_Left) < static_cast<_Ty2&&>(_Right);

	movss	xmm0, DWORD PTR [eax+ebx]
	comiss	xmm0, xmm1
	jbe	SHORT $LN157@Partition_
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 101  :     _Left    = _STD move(_Right);

	movss	DWORD PTR [esi], xmm0

; 102  :     _Right   = _STD move(_Tmp);

	movss	DWORD PTR [eax+ebx], xmm1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 6970 :     } else {

	jmp	SHORT $LN157@Partition_
$LN35@Partition_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef

; 221  :         return static_cast<_Ty1&&>(_Left) < static_cast<_Ty2&&>(_Right);

	movss	xmm0, DWORD PTR [esi]
	movss	xmm1, DWORD PTR [ebx]
	comiss	xmm1, xmm0
	jbe	SHORT $LN161@Partition_
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 101  :     _Left    = _STD move(_Right);

	movss	DWORD PTR [esi], xmm1

; 102  :     _Right   = _STD move(_Tmp);

	movss	DWORD PTR [ebx], xmm0
	movss	xmm0, DWORD PTR [esi]
$LN161@Partition_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef

; 221  :         return static_cast<_Ty1&&>(_Left) < static_cast<_Ty2&&>(_Right);

	movss	xmm1, DWORD PTR [ebp-4]
	comiss	xmm0, xmm1
	jbe	SHORT $LN157@Partition_
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 101  :     _Left    = _STD move(_Right);

	movss	DWORD PTR [ebp-4], xmm0

; 102  :     _Right   = _STD move(_Tmp);

	movss	DWORD PTR [esi], xmm1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef

; 221  :         return static_cast<_Ty1&&>(_Left) < static_cast<_Ty2&&>(_Right);

	movss	xmm0, DWORD PTR [ebx]
	comiss	xmm0, xmm1
	jbe	SHORT $LN157@Partition_
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 101  :     _Left    = _STD move(_Right);

	movss	DWORD PTR [esi], xmm0

; 102  :     _Right   = _STD move(_Tmp);

	movss	DWORD PTR [ebx], xmm1
$LN157@Partition_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 6981 :     _RanIt _Plast  = _Next_iter(_Pfirst);

	lea	ecx, DWORD PTR [esi+4]

; 6982 : 
; 6983 :     while (_First < _Pfirst && !_DEBUG_LT_PRED(_Pred, *_Prev_iter(_Pfirst), *_Pfirst)
; 6984 :            && !_Pred(*_Pfirst, *_Prev_iter(_Pfirst))) {

	cmp	ebx, esi
	jae	SHORT $LN301@Partition_
	movss	xmm1, DWORD PTR [esi]
$LL2@Partition_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef

; 221  :         return static_cast<_Ty1&&>(_Left) < static_cast<_Ty2&&>(_Right);

	movss	xmm0, DWORD PTR [esi-4]
	comiss	xmm1, xmm0
	ja	SHORT $LN301@Partition_
	comiss	xmm0, xmm1
	ja	SHORT $LN301@Partition_
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 6985 :         --_Pfirst;

	add	esi, -4					; fffffffcH
	movaps	xmm1, xmm0
	cmp	ebx, esi
	jb	SHORT $LL2@Partition_
$LN301@Partition_:

; 6988 :     while (_Plast < _Last && !_DEBUG_LT_PRED(_Pred, *_Plast, *_Pfirst) && !_Pred(*_Pfirst, *_Plast)) {

	cmp	ecx, ebp
	jae	SHORT $LN302@Partition_
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef

; 221  :         return static_cast<_Ty1&&>(_Left) < static_cast<_Ty2&&>(_Right);

	movss	xmm1, DWORD PTR [esi]
$LL4@Partition_:
	movss	xmm0, DWORD PTR [ecx]
	comiss	xmm1, xmm0
	ja	SHORT $LN302@Partition_
	comiss	xmm0, xmm1
	ja	SHORT $LN302@Partition_
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 6988 :     while (_Plast < _Last && !_DEBUG_LT_PRED(_Pred, *_Plast, *_Pfirst) && !_Pred(*_Pfirst, *_Plast)) {

	add	ecx, 4
	cmp	ecx, ebp
	jb	SHORT $LL4@Partition_
$LN302@Partition_:

; 6989 :         ++_Plast;
; 6990 :     }
; 6991 : 
; 6992 :     _RanIt _Gfirst = _Plast;

	mov	eax, ecx

; 6993 :     _RanIt _Glast  = _Pfirst;

	mov	edx, esi
	npad	5
$LL6@Partition_:

; 6996 :         for (; _Gfirst < _Last; ++_Gfirst) {

	cmp	eax, ebp
	jae	SHORT $LN303@Partition_
$LL11@Partition_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef

; 221  :         return static_cast<_Ty1&&>(_Left) < static_cast<_Ty2&&>(_Right);

	movss	xmm0, DWORD PTR [esi]
	movss	xmm1, DWORD PTR [eax]
	comiss	xmm1, xmm0
	ja	SHORT $LN9@Partition_
	comiss	xmm0, xmm1
	ja	SHORT $LN303@Partition_
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 7001 :             } else if (_Plast != _Gfirst) {

	cmp	ecx, eax
	je	SHORT $LN19@Partition_
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 100  :     _Ty _Tmp = _STD move(_Left);

	movss	xmm0, DWORD PTR [ecx]

; 101  :     _Left    = _STD move(_Right);

	movss	DWORD PTR [ecx], xmm1

; 102  :     _Right   = _STD move(_Tmp);

	movss	DWORD PTR [eax], xmm0
$LN19@Partition_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 6996 :         for (; _Gfirst < _Last; ++_Gfirst) {

	add	ecx, 4
$LN9@Partition_:
	add	eax, 4
	cmp	eax, ebp
	jb	SHORT $LL11@Partition_
$LN303@Partition_:

; 7009 :         for (; _First < _Glast; --_Glast) {

	cmp	edx, ebx
	jbe	SHORT $LN305@Partition_
	lea	edi, DWORD PTR [edx-4]
	npad	9
$LL14@Partition_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef

; 221  :         return static_cast<_Ty1&&>(_Left) < static_cast<_Ty2&&>(_Right);

	movss	xmm1, DWORD PTR [edi]
	movss	xmm0, DWORD PTR [esi]
	comiss	xmm0, xmm1
	ja	SHORT $LN12@Partition_
	comiss	xmm1, xmm0
	ja	SHORT $LN304@Partition_
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 7014 :             } else if (--_Pfirst != _Prev_iter(_Glast)) {

	sub	esi, 4
	cmp	esi, edi
	je	SHORT $LN12@Partition_
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 100  :     _Ty _Tmp = _STD move(_Left);

	movss	xmm0, DWORD PTR [esi]

; 101  :     _Left    = _STD move(_Right);

	movss	DWORD PTR [esi], xmm1

; 102  :     _Right   = _STD move(_Tmp);

	movss	DWORD PTR [edi], xmm0
$LN12@Partition_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 7009 :         for (; _First < _Glast; --_Glast) {

	sub	edx, 4
	sub	edi, 4
	cmp	ebx, edx
	jb	SHORT $LL14@Partition_
$LN304@Partition_:

; 7015 :                 _STD iter_swap(_Pfirst, _Prev_iter(_Glast));
; 7016 :             }
; 7017 :         }
; 7018 : 
; 7019 :         if (_Glast == _First && _Gfirst == _Last) {

	cmp	edx, ebx
$LN305@Partition_:
	jne	SHORT $LN27@Partition_
	cmp	eax, ebp
	je	SHORT $LN253@Partition_

; 7021 :         }
; 7022 : 
; 7023 :         if (_Glast == _First) { // no room at bottom, rotate pivot upward
; 7024 :             if (_Plast != _Gfirst) {

	cmp	ecx, eax
	je	SHORT $LN29@Partition_
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 101  :     _Left    = _STD move(_Right);

	fld	DWORD PTR [ecx]
	movss	xmm0, DWORD PTR [esi]
	fstp	DWORD PTR [esi]

; 102  :     _Right   = _STD move(_Tmp);

	movss	DWORD PTR [ecx], xmm0
$LN29@Partition_:

; 101  :     _Left    = _STD move(_Right);

	fld	DWORD PTR [eax]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 7028 :             ++_Plast;

	add	ecx, 4
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 100  :     _Ty _Tmp = _STD move(_Left);

	movss	xmm0, DWORD PTR [esi]

; 101  :     _Left    = _STD move(_Right);

	fstp	DWORD PTR [esi]

; 102  :     _Right   = _STD move(_Tmp);

	movss	DWORD PTR [eax], xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 7030 :             ++_Pfirst;

	add	esi, 4

; 7031 :             ++_Gfirst;

	add	eax, 4
	jmp	$LL6@Partition_
$LN27@Partition_:

; 7032 :         } else if (_Gfirst == _Last) { // no room at top, rotate pivot downward

	add	edx, -4					; fffffffcH
	cmp	eax, ebp
	jne	SHORT $LN30@Partition_

; 7033 :             if (--_Glast != --_Pfirst) {

	sub	esi, 4
	cmp	edx, esi
	je	SHORT $LN263@Partition_
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 101  :     _Left    = _STD move(_Right);

	fld	DWORD PTR [esi]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 7037 :             _STD iter_swap(_Pfirst, --_Plast);

	sub	ecx, 4
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 100  :     _Ty _Tmp = _STD move(_Left);

	movss	xmm0, DWORD PTR [edx]

; 101  :     _Left    = _STD move(_Right);

	fstp	DWORD PTR [edx]

; 102  :     _Right   = _STD move(_Tmp);

	movss	DWORD PTR [esi], xmm0

; 101  :     _Left    = _STD move(_Right);

	fld	DWORD PTR [ecx]
	fstp	DWORD PTR [esi]

; 102  :     _Right   = _STD move(_Tmp);

	movss	DWORD PTR [ecx], xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 7038 :         } else {

	jmp	$LL6@Partition_
$LN263@Partition_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 101  :     _Left    = _STD move(_Right);

	fld	DWORD PTR [ecx-4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 7037 :             _STD iter_swap(_Pfirst, --_Plast);

	sub	ecx, 4
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 102  :     _Right   = _STD move(_Tmp);

	movss	xmm0, DWORD PTR [esi]

; 101  :     _Left    = _STD move(_Right);

	fstp	DWORD PTR [esi]

; 102  :     _Right   = _STD move(_Tmp);

	movss	DWORD PTR [ecx], xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 7038 :         } else {

	jmp	$LL6@Partition_
$LN30@Partition_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 100  :     _Ty _Tmp = _STD move(_Left);

	movss	xmm0, DWORD PTR [eax]

; 101  :     _Left    = _STD move(_Right);

	fld	DWORD PTR [edx]
	fstp	DWORD PTR [eax]

; 102  :     _Right   = _STD move(_Tmp);

	movss	DWORD PTR [edx], xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 7040 :             ++_Gfirst;

	add	eax, 4

; 7041 :         }
; 7042 :     }

	jmp	$LL6@Partition_
$LN253@Partition_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 186  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

	mov	eax, DWORD PTR ___$ReturnUdt$1$[esp+20]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 7020 :             return pair<_RanIt, _RanIt>(_Pfirst, _Plast);

	pop	edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 186  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

	mov	DWORD PTR [eax], esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 7020 :             return pair<_RanIt, _RanIt>(_Pfirst, _Plast);

	pop	esi
	pop	ebp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 186  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

	mov	DWORD PTR [eax+4], ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 7020 :             return pair<_RanIt, _RanIt>(_Pfirst, _Plast);

	pop	ebx

; 7043 : }

	pop	ecx
	ret	0
??$_Partition_by_median_guess_unchecked@PAMU?$less@X@std@@@std@@YA?AU?$pair@PAMPAM@0@PAM0U?$less@X@0@@Z ENDP ; std::_Partition_by_median_guess_unchecked<float *,std::less<void> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\type_traits
;	COMDAT ??$move@AAM@std@@YA$$QAMAAM@Z
_TEXT	SEGMENT
??$move@AAM@std@@YA$$QAMAAM@Z PROC			; std::move<float &>, COMDAT
; __Arg$ = ecx

; 1397 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

	mov	eax, ecx

; 1398 : }

	ret	0
??$move@AAM@std@@YA$$QAMAAM@Z ENDP			; std::move<float &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef
;	COMDAT ??$?RAAMAAM@?$less@X@std@@QBE_NAAM0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$?RAAMAAM@?$less@X@std@@QBE_NAAM0@Z PROC		; std::less<void>::operator()<float &,float &>, COMDAT
; _this$dead$ = ecx

; 221  :         return static_cast<_Ty1&&>(_Left) < static_cast<_Ty2&&>(_Right);

	mov	eax, DWORD PTR __Right$[esp-4]
	movss	xmm0, DWORD PTR [eax]
	mov	eax, DWORD PTR __Left$[esp-4]
	comiss	xmm0, DWORD PTR [eax]
	jbe	SHORT $LN3@operator
	mov	al, 1

; 222  :     }

	ret	8
$LN3@operator:

; 221  :         return static_cast<_Ty1&&>(_Left) < static_cast<_Ty2&&>(_Right);

	xor	al, al

; 222  :     }

	ret	8
??$?RAAMAAM@?$less@X@std@@QBE_NAAM0@Z ENDP		; std::less<void>::operator()<float &,float &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_Move_backward_unchecked@PAMPAM@std@@YAPAMPAM00@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
??$_Move_backward_unchecked@PAMPAM@std@@YAPAMPAM00@Z PROC ; std::_Move_backward_unchecked<float *,float *>, COMDAT
; __First$ = ecx
; __Last$ = edx

; 4255 :     auto _Result                = _CSTD memmove(_Dest_ch - _Count, _First_ch, _Count);

	mov	eax, DWORD PTR __Dest$[esp-4]
	sub	edx, ecx
	push	edx
	push	ecx
	sub	eax, edx
	push	eax
	call	_memmove
	add	esp, 12					; 0000000cH

; 4351 :     // move [_First, _Last) backwards to [..., _Dest)
; 4352 :     // note: _Move_backward_unchecked has callers other than the move_backward family
; 4353 :     if constexpr (_Ptr_move_cat<_BidIt1, _BidIt2>::_Trivially_copyable) {
; 4354 : #ifdef __cpp_lib_is_constant_evaluated
; 4355 :         if (!_STD is_constant_evaluated())
; 4356 : #endif // __cpp_lib_is_constant_evaluated
; 4357 :         {
; 4358 :             return _Copy_backward_memmove(_First, _Last, _Dest);
; 4359 :         }
; 4360 :     }
; 4361 : 
; 4362 :     while (_First != _Last) {
; 4363 :         *--_Dest = _STD move(*--_Last);
; 4364 :     }
; 4365 : 
; 4366 :     return _Dest;
; 4367 : }

	ret	0
??$_Move_backward_unchecked@PAMPAM@std@@YAPAMPAM00@Z ENDP ; std::_Move_backward_unchecked<float *,float *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
;	COMDAT ??$_Pop_heap_hole_by_index@PAMMU?$less@X@std@@@std@@YAXPAMHH$$QAMU?$less@X@0@@Z
_TEXT	SEGMENT
tv396 = -4						; size = 4
__Bottom$ = 8						; size = 4
__Val$ = 12						; size = 4
__Pred$ = 16						; size = 1
??$_Pop_heap_hole_by_index@PAMMU?$less@X@std@@@std@@YAXPAMHH$$QAMU?$less@X@0@@Z PROC ; std::_Pop_heap_hole_by_index<float *,float,std::less<void> >, COMDAT
; __First$ = ecx
; __Hole$ = edx

; 5375 :     _RanIt _First, _Iter_diff_t<_RanIt> _Hole, _Iter_diff_t<_RanIt> _Bottom, _Ty&& _Val, _Pr _Pred) {

	push	ecx
	push	ebx
	push	ebp
	push	esi
	mov	esi, ecx

; 5376 :     // percolate _Hole to _Bottom, then push _Val
; 5377 :     _STL_INTERNAL_CHECK(_Bottom > 0);
; 5378 : 
; 5379 :     using _Diff      = _Iter_diff_t<_RanIt>;
; 5380 :     const _Diff _Top = _Hole;

	mov	ebx, edx

; 5381 :     _Diff _Idx       = _Hole;
; 5382 : 
; 5383 :     // Check whether _Idx can have a child before calculating that child's index, since
; 5384 :     // calculating the child's index can trigger integer overflows
; 5385 :     const _Diff _Max_sequence_non_leaf = (_Bottom - 1) >> 1; // shift for codegen

	mov	ecx, DWORD PTR __Bottom$[esp+12]
	mov	eax, edx
	push	edi
	lea	ebp, DWORD PTR [ecx-1]
	mov	edi, ebp
	sar	edi, 1

; 5386 :     while (_Idx < _Max_sequence_non_leaf) { // move _Hole down to larger child

	cmp	edx, edi
	jge	SHORT $LN3@Pop_heap_h
	mov	DWORD PTR tv396[esp+20], 1
$LL2@Pop_heap_h:

; 5387 :         _Idx = 2 * _Idx + 2;

	lea	ecx, DWORD PTR [eax+eax]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef

; 221  :         return static_cast<_Ty1&&>(_Left) < static_cast<_Ty2&&>(_Right);

	mov	eax, 2
	movss	xmm0, DWORD PTR [esi+ecx*4+4]
	comiss	xmm0, DWORD PTR [esi+ecx*4+8]
	cmova	eax, DWORD PTR tv396[esp+20]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 5391 :         *(_First + _Hole) = _STD move(*(_First + _Idx));

	add	eax, ecx
	fld	DWORD PTR [esi+eax*4]
	fstp	DWORD PTR [esi+edx*4]

; 5392 :         _Hole             = _Idx;

	mov	edx, eax
	cmp	eax, edi
	jl	SHORT $LL2@Pop_heap_h
	mov	ecx, DWORD PTR __Bottom$[esp+16]
$LN3@Pop_heap_h:

; 5393 :     }
; 5394 : 
; 5395 :     if (_Idx == _Max_sequence_non_leaf && _Bottom % 2 == 0) { // only child at bottom, move _Hole down to it

	cmp	eax, edi
	jne	SHORT $LN5@Pop_heap_h
	test	cl, 1
	jne	SHORT $LN5@Pop_heap_h

; 5396 :         *(_First + _Hole) = _STD move(*(_First + (_Bottom - 1)));

	fld	DWORD PTR [esi+ecx*4-4]
	fstp	DWORD PTR [esi+edx*4]

; 5397 :         _Hole             = _Bottom - 1;

	mov	edx, ebp
$LN5@Pop_heap_h:

; 5268 :          _Top < _Hole && _DEBUG_LT_PRED(_Pred, *(_First + _Idx), _Val); //

	cmp	ebx, edx
	jge	SHORT $LN30@Pop_heap_h
	mov	ecx, DWORD PTR __Val$[esp+16]
$LL14@Pop_heap_h:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef

; 221  :         return static_cast<_Ty1&&>(_Left) < static_cast<_Ty2&&>(_Right);

	movss	xmm0, DWORD PTR [ecx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 5267 :     for (_Diff _Idx = (_Hole - 1) >> 1; // shift for codegen

	lea	eax, DWORD PTR [edx-1]
	sar	eax, 1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef

; 221  :         return static_cast<_Ty1&&>(_Left) < static_cast<_Ty2&&>(_Right);

	movss	xmm1, DWORD PTR [esi+eax*4]
	comiss	xmm0, xmm1
	jbe	SHORT $LN29@Pop_heap_h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 5272 :         _Hole             = _Idx;

	movss	DWORD PTR [esi+edx*4], xmm1
	mov	edx, eax
	cmp	ebx, eax
	jl	SHORT $LL14@Pop_heap_h
$LN29@Pop_heap_h:

; 5398 :     }
; 5399 : 
; 5400 :     _Push_heap_by_index(_First, _Hole, _Top, _STD forward<_Ty>(_Val), _Pred);
; 5401 : }

	fld	DWORD PTR [ecx]
	pop	edi
	fstp	DWORD PTR [esi+edx*4]
	pop	esi
	pop	ebp
	pop	ebx
	pop	ecx
	ret	0
$LN30@Pop_heap_h:

; 5275 :     *(_First + _Hole) = _STD forward<_Ty>(_Val); // drop _Val into final hole

	mov	eax, DWORD PTR __Val$[esp+16]
	pop	edi
	fld	DWORD PTR [eax]

; 5398 :     }
; 5399 : 
; 5400 :     _Push_heap_by_index(_First, _Hole, _Top, _STD forward<_Ty>(_Val), _Pred);
; 5401 : }

	fstp	DWORD PTR [esi+edx*4]
	pop	esi
	pop	ebp
	pop	ebx
	pop	ecx
	ret	0
??$_Pop_heap_hole_by_index@PAMMU?$less@X@std@@@std@@YAXPAMHH$$QAMU?$less@X@0@@Z ENDP ; std::_Pop_heap_hole_by_index<float *,float,std::less<void> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
;	COMDAT ??$_Pop_heap_unchecked@PAMU?$less@X@std@@@std@@YAXPAM0U?$less@X@0@@Z
_TEXT	SEGMENT
__Val$1 = -4						; size = 4
__Pred$ = 8						; size = 1
??$_Pop_heap_unchecked@PAMU?$less@X@std@@@std@@YAXPAM0U?$less@X@0@@Z PROC ; std::_Pop_heap_unchecked<float *,std::less<void> >, COMDAT
; __First$ = ecx
; __Last$ = edx

; 5415 : _CONSTEXPR20 void _Pop_heap_unchecked(_RanIt _First, _RanIt _Last, _Pr _Pred) {

	push	ecx

; 5416 :     // pop *_First to *(_Last - 1) and reheap
; 5417 :     if (2 <= _Last - _First) {

	mov	eax, edx
	sub	eax, ecx
	and	eax, -4					; fffffffcH
	cmp	eax, 8
	jl	SHORT $LN2@Pop_heap_u

; 5419 :         _Iter_value_t<_RanIt> _Val = _STD move(*_Last);

	movss	xmm0, DWORD PTR [edx-4]

; 5410 :     _Pop_heap_hole_by_index(

	lea	eax, DWORD PTR __Val$1[esp+4]
	fld	DWORD PTR [ecx]

; 5418 :         --_Last;

	sub	edx, 4

; 5410 :     _Pop_heap_hole_by_index(

	push	DWORD PTR __Pred$[esp]

; 5419 :         _Iter_value_t<_RanIt> _Val = _STD move(*_Last);

	movss	DWORD PTR __Val$1[esp+8], xmm0

; 5410 :     _Pop_heap_hole_by_index(

	push	eax
	fstp	DWORD PTR [edx]
	sub	edx, ecx
	sar	edx, 2
	push	edx
	xor	edx, edx
	call	??$_Pop_heap_hole_by_index@PAMMU?$less@X@std@@@std@@YAXPAMHH$$QAMU?$less@X@0@@Z ; std::_Pop_heap_hole_by_index<float *,float,std::less<void> >
	add	esp, 12					; 0000000cH
$LN2@Pop_heap_u:

; 5420 :         _Pop_heap_hole_unchecked(_First, _Last, _Last, _STD move(_Val), _Pred);
; 5421 :     }
; 5422 : }

	pop	ecx
	ret	0
??$_Pop_heap_unchecked@PAMU?$less@X@std@@@std@@YAXPAM0U?$less@X@0@@Z ENDP ; std::_Pop_heap_unchecked<float *,std::less<void> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_Prev_iter@PAM@std@@YAPAMPAM@Z
_TEXT	SEGMENT
??$_Prev_iter@PAM@std@@YAPAMPAM@Z PROC			; std::_Prev_iter<float *>, COMDAT
; __First$ = ecx

; 1554 :     return --_First;

	lea	eax, DWORD PTR [ecx-4]

; 1555 : }

	ret	0
??$_Prev_iter@PAM@std@@YAPAMPAM@Z ENDP			; std::_Prev_iter<float *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
;	COMDAT ??$_Guess_median_unchecked@PAMU?$less@X@std@@@std@@YAXPAM00U?$less@X@0@@Z
_TEXT	SEGMENT
__Last$ = 8						; size = 4
__Pred$ = 12						; size = 1
??$_Guess_median_unchecked@PAMU?$less@X@std@@@std@@YAXPAM00U?$less@X@0@@Z PROC ; std::_Guess_median_unchecked<float *,std::less<void> >, COMDAT
; __First$ = ecx
; __Mid$ = edx

; 6959 : _CONSTEXPR20 void _Guess_median_unchecked(_RanIt _First, _RanIt _Mid, _RanIt _Last, _Pr _Pred) {

	push	edi

; 6960 :     // sort median element to middle
; 6961 :     using _Diff        = _Iter_diff_t<_RanIt>;
; 6962 :     const _Diff _Count = _Last - _First;

	mov	edi, DWORD PTR __Last$[esp]
	mov	eax, edi
	sub	eax, ecx
	sar	eax, 2

; 6963 :     if (40 < _Count) { // Tukey's ninther

	cmp	eax, 40					; 00000028H
	jle	$LN2@Guess_medi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef

; 221  :         return static_cast<_Ty1&&>(_Left) < static_cast<_Ty2&&>(_Right);

	movss	xmm0, DWORD PTR [ecx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 6964 :         const _Diff _Step     = (_Count + 1) >> 3; // +1 can't overflow because range was made inclusive in caller

	inc	eax
	sar	eax, 3
	push	ebx
	push	ebp
	push	esi

; 6965 :         const _Diff _Two_step = _Step << 1; // note: intentionally discards low-order bit
; 6966 :         _Med3_unchecked(_First, _First + _Step, _First + _Two_step, _Pred);

	lea	ebp, DWORD PTR [eax*8]
	shl	eax, 2
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef

; 221  :         return static_cast<_Ty1&&>(_Left) < static_cast<_Ty2&&>(_Right);

	movss	xmm1, DWORD PTR [eax+ecx]
	comiss	xmm0, xmm1
	jbe	SHORT $LN6@Guess_medi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 101  :     _Left    = _STD move(_Right);

	movss	DWORD PTR [eax+ecx], xmm0

; 102  :     _Right   = _STD move(_Tmp);

	movss	DWORD PTR [ecx], xmm1
	movss	xmm1, DWORD PTR [eax+ecx]
$LN6@Guess_medi:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef

; 221  :         return static_cast<_Ty1&&>(_Left) < static_cast<_Ty2&&>(_Right);

	movss	xmm0, DWORD PTR [ecx+ebp]
	comiss	xmm1, xmm0
	jbe	SHORT $LN8@Guess_medi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 101  :     _Left    = _STD move(_Right);

	movss	DWORD PTR [ecx+ebp], xmm1

; 102  :     _Right   = _STD move(_Tmp);

	movss	DWORD PTR [eax+ecx], xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef

; 221  :         return static_cast<_Ty1&&>(_Left) < static_cast<_Ty2&&>(_Right);

	movss	xmm1, DWORD PTR [ecx]
	comiss	xmm1, xmm0
	jbe	SHORT $LN8@Guess_medi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 101  :     _Left    = _STD move(_Right);

	movss	DWORD PTR [eax+ecx], xmm1

; 102  :     _Right   = _STD move(_Tmp);

	movss	DWORD PTR [ecx], xmm0
$LN8@Guess_medi:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef

; 221  :         return static_cast<_Ty1&&>(_Left) < static_cast<_Ty2&&>(_Right);

	movss	xmm0, DWORD PTR [edx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 6967 :         _Med3_unchecked(_Mid - _Step, _Mid, _Mid + _Step, _Pred);

	mov	esi, edx
	sub	esi, eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef

; 221  :         return static_cast<_Ty1&&>(_Left) < static_cast<_Ty2&&>(_Right);

	movss	xmm1, DWORD PTR [esi]
	comiss	xmm1, xmm0
	jbe	SHORT $LN35@Guess_medi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 101  :     _Left    = _STD move(_Right);

	movss	DWORD PTR [edx], xmm1

; 102  :     _Right   = _STD move(_Tmp);

	movss	DWORD PTR [esi], xmm0
	movss	xmm0, DWORD PTR [edx]
$LN35@Guess_medi:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef

; 221  :         return static_cast<_Ty1&&>(_Left) < static_cast<_Ty2&&>(_Right);

	movss	xmm1, DWORD PTR [eax+edx]
	comiss	xmm0, xmm1
	jbe	SHORT $LN37@Guess_medi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 101  :     _Left    = _STD move(_Right);

	movss	DWORD PTR [eax+edx], xmm0

; 102  :     _Right   = _STD move(_Tmp);

	movss	DWORD PTR [edx], xmm1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef

; 221  :         return static_cast<_Ty1&&>(_Left) < static_cast<_Ty2&&>(_Right);

	movss	xmm0, DWORD PTR [esi]
	comiss	xmm0, xmm1
	jbe	SHORT $LN37@Guess_medi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 101  :     _Left    = _STD move(_Right);

	movss	DWORD PTR [edx], xmm0

; 102  :     _Right   = _STD move(_Tmp);

	movss	DWORD PTR [esi], xmm1
$LN37@Guess_medi:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 6968 :         _Med3_unchecked(_Last - _Two_step, _Last - _Step, _Last, _Pred);

	mov	esi, edi
	mov	ebx, edi
	sub	esi, eax
	sub	ebx, ebp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef

; 221  :         return static_cast<_Ty1&&>(_Left) < static_cast<_Ty2&&>(_Right);

	movss	xmm0, DWORD PTR [esi]
	movss	xmm1, DWORD PTR [ebx]
	comiss	xmm1, xmm0
	jbe	SHORT $LN64@Guess_medi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 101  :     _Left    = _STD move(_Right);

	movss	DWORD PTR [esi], xmm1

; 102  :     _Right   = _STD move(_Tmp);

	movss	DWORD PTR [ebx], xmm0
	movss	xmm0, DWORD PTR [esi]
$LN64@Guess_medi:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef

; 221  :         return static_cast<_Ty1&&>(_Left) < static_cast<_Ty2&&>(_Right);

	movss	xmm1, DWORD PTR [edi]
	comiss	xmm0, xmm1
	jbe	SHORT $LN66@Guess_medi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 101  :     _Left    = _STD move(_Right);

	movss	DWORD PTR [edi], xmm0

; 102  :     _Right   = _STD move(_Tmp);

	movss	DWORD PTR [esi], xmm1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef

; 221  :         return static_cast<_Ty1&&>(_Left) < static_cast<_Ty2&&>(_Right);

	movss	xmm0, DWORD PTR [ebx]
	comiss	xmm0, xmm1
	jbe	SHORT $LN66@Guess_medi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 101  :     _Left    = _STD move(_Right);

	movss	DWORD PTR [esi], xmm0

; 102  :     _Right   = _STD move(_Tmp);

	movss	DWORD PTR [ebx], xmm1
$LN66@Guess_medi:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef

; 221  :         return static_cast<_Ty1&&>(_Left) < static_cast<_Ty2&&>(_Right);

	movss	xmm0, DWORD PTR [edx]
	movss	xmm1, DWORD PTR [eax+ecx]
	comiss	xmm1, xmm0
	jbe	SHORT $LN93@Guess_medi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 101  :     _Left    = _STD move(_Right);

	movss	DWORD PTR [edx], xmm1

; 102  :     _Right   = _STD move(_Tmp);

	movss	DWORD PTR [eax+ecx], xmm0
	movss	xmm0, DWORD PTR [edx]
$LN93@Guess_medi:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef

; 221  :         return static_cast<_Ty1&&>(_Left) < static_cast<_Ty2&&>(_Right);

	movss	xmm1, DWORD PTR [esi]
	comiss	xmm0, xmm1
	jbe	SHORT $LN165@Guess_medi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 101  :     _Left    = _STD move(_Right);

	movss	DWORD PTR [esi], xmm0

; 102  :     _Right   = _STD move(_Tmp);

	movss	DWORD PTR [edx], xmm1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef

; 221  :         return static_cast<_Ty1&&>(_Left) < static_cast<_Ty2&&>(_Right);

	movss	xmm0, DWORD PTR [eax+ecx]
	comiss	xmm0, xmm1
	jbe	SHORT $LN165@Guess_medi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 101  :     _Left    = _STD move(_Right);

	movss	DWORD PTR [edx], xmm0

; 102  :     _Right   = _STD move(_Tmp);

	movss	DWORD PTR [eax+ecx], xmm1
$LN165@Guess_medi:
	pop	esi
	pop	ebp
	pop	ebx
$LN124@Guess_medi:
	pop	edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 6973 : }

	ret	0
$LN2@Guess_medi:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef

; 221  :         return static_cast<_Ty1&&>(_Left) < static_cast<_Ty2&&>(_Right);

	movss	xmm0, DWORD PTR [edx]
	movss	xmm1, DWORD PTR [ecx]
	comiss	xmm1, xmm0
	jbe	SHORT $LN122@Guess_medi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 101  :     _Left    = _STD move(_Right);

	movss	DWORD PTR [edx], xmm1

; 102  :     _Right   = _STD move(_Tmp);

	movss	DWORD PTR [ecx], xmm0
	movss	xmm0, DWORD PTR [edx]
$LN122@Guess_medi:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef

; 221  :         return static_cast<_Ty1&&>(_Left) < static_cast<_Ty2&&>(_Right);

	movss	xmm1, DWORD PTR [edi]
	comiss	xmm0, xmm1
	jbe	SHORT $LN124@Guess_medi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 101  :     _Left    = _STD move(_Right);

	movss	DWORD PTR [edi], xmm0

; 102  :     _Right   = _STD move(_Tmp);

	movss	DWORD PTR [edx], xmm1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef

; 221  :         return static_cast<_Ty1&&>(_Left) < static_cast<_Ty2&&>(_Right);

	movss	xmm0, DWORD PTR [ecx]
	comiss	xmm0, xmm1
	jbe	SHORT $LN124@Guess_medi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 101  :     _Left    = _STD move(_Right);

	movss	DWORD PTR [edx], xmm0

; 102  :     _Right   = _STD move(_Tmp);

	movss	DWORD PTR [ecx], xmm1
	pop	edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 6973 : }

	ret	0
??$_Guess_median_unchecked@PAMU?$less@X@std@@@std@@YAXPAM00U?$less@X@0@@Z ENDP ; std::_Guess_median_unchecked<float *,std::less<void> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_Next_iter@PAM@std@@YAPAMPAM@Z
_TEXT	SEGMENT
??$_Next_iter@PAM@std@@YAPAMPAM@Z PROC			; std::_Next_iter<float *>, COMDAT
; __First$ = ecx

; 1541 :     return ++_First;

	lea	eax, DWORD PTR [ecx+4]

; 1542 : }

	ret	0
??$_Next_iter@PAM@std@@YAPAMPAM@Z ENDP			; std::_Next_iter<float *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
;	COMDAT ??$iter_swap@PAMPAM@std@@YAXPAM0@Z
_TEXT	SEGMENT
??$iter_swap@PAMPAM@std@@YAXPAM0@Z PROC			; std::iter_swap<float *,float *>, COMDAT
; __Left$ = ecx
; __Right$ = edx

; 101  :     _Left    = _STD move(_Right);

	fld	DWORD PTR [edx]
	movss	xmm0, DWORD PTR [ecx]
	fstp	DWORD PTR [ecx]

; 102  :     _Right   = _STD move(_Tmp);

	movss	DWORD PTR [edx], xmm0

; 78   :     swap(*_Left, *_Right);
; 79   : }

	ret	0
??$iter_swap@PAMPAM@std@@YAXPAM0@Z ENDP			; std::iter_swap<float *,float *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
;	COMDAT ??$?0AAPAMAAPAM$0A@@?$pair@PAMPAM@std@@QAE@AAPAM0@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??$?0AAPAMAAPAM$0A@@?$pair@PAMPAM@std@@QAE@AAPAM0@Z PROC ; std::pair<float *,float *>::pair<float *,float *><float * &,float * &,0>, COMDAT
; _this$ = ecx

; 186  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

	mov	eax, DWORD PTR __Val1$[esp-4]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR __Val2$[esp-4]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx+4], eax
	mov	eax, ecx
	ret	8
??$?0AAPAMAAPAM$0A@@?$pair@PAMPAM@std@@QAE@AAPAM0@Z ENDP ; std::pair<float *,float *>::pair<float *,float *><float * &,float * &,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_Copy_backward_memmove@PAMPAM@std@@YAPAMPAM00@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
??$_Copy_backward_memmove@PAMPAM@std@@YAPAMPAM00@Z PROC	; std::_Copy_backward_memmove<float *,float *>, COMDAT
; __First$ = ecx
; __Last$ = edx

; 4247 :     // implement copy_backward-like function as memmove
; 4248 :     auto _FirstPtr              = _To_address(_First);
; 4249 :     auto _LastPtr               = _To_address(_Last);
; 4250 :     auto _DestPtr               = _To_address(_Dest);
; 4251 :     const char* const _First_ch = const_cast<const char*>(reinterpret_cast<const volatile char*>(_FirstPtr));
; 4252 :     const char* const _Last_ch  = const_cast<const char*>(reinterpret_cast<const volatile char*>(_LastPtr));
; 4253 :     char* const _Dest_ch        = const_cast<char*>(reinterpret_cast<const volatile char*>(_DestPtr));
; 4254 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);
; 4255 :     auto _Result                = _CSTD memmove(_Dest_ch - _Count, _First_ch, _Count);

	mov	eax, DWORD PTR __Dest$[esp-4]
	sub	edx, ecx
	push	edx
	push	ecx
	sub	eax, edx
	push	eax
	call	_memmove
	add	esp, 12					; 0000000cH

; 4256 :     if constexpr (is_pointer_v<_CtgIt2>) {
; 4257 :         return static_cast<_CtgIt2>(_Result);
; 4258 :     } else {
; 4259 :         return _Dest - (_LastPtr - _FirstPtr);
; 4260 :     }
; 4261 : }

	ret	0
??$_Copy_backward_memmove@PAMPAM@std@@YAPAMPAM00@Z ENDP	; std::_Copy_backward_memmove<float *,float *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_To_address@PAM@std@@YA?A_PABQAM@Z
_TEXT	SEGMENT
??$_To_address@PAM@std@@YA?A_PABQAM@Z PROC		; std::_To_address<float *>, COMDAT
; __Val$ = ecx

; 3981 :     _STL_INTERNAL_STATIC_ASSERT(is_pointer_v<_Iter>);
; 3982 :     return _Val;

	mov	eax, DWORD PTR [ecx]

; 3983 : }

	ret	0
??$_To_address@PAM@std@@YA?A_PABQAM@Z ENDP		; std::_To_address<float *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\type_traits
;	COMDAT ??$forward@M@std@@YA$$QAMAAM@Z
_TEXT	SEGMENT
??$forward@M@std@@YA$$QAMAAM@Z PROC			; std::forward<float>, COMDAT
; __Arg$ = ecx

; 1386 :     return static_cast<_Ty&&>(_Arg);

	mov	eax, ecx

; 1387 : }

	ret	0
??$forward@M@std@@YA$$QAMAAM@Z ENDP			; std::forward<float>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
;	COMDAT ??$_Push_heap_by_index@PAMMU?$less@X@std@@@std@@YAXPAMHH$$QAMU?$less@X@0@@Z
_TEXT	SEGMENT
__Top$ = 8						; size = 4
__Val$ = 12						; size = 4
__Pred$ = 16						; size = 1
??$_Push_heap_by_index@PAMMU?$less@X@std@@@std@@YAXPAMHH$$QAMU?$less@X@0@@Z PROC ; std::_Push_heap_by_index<float *,float,std::less<void> >, COMDAT
; __First$ = ecx
; __Hole$ = edx

; 5264 :     _RanIt _First, _Iter_diff_t<_RanIt> _Hole, _Iter_diff_t<_RanIt> _Top, _Ty&& _Val, _Pr _Pred) {

	push	edi

; 5268 :          _Top < _Hole && _DEBUG_LT_PRED(_Pred, *(_First + _Idx), _Val); //

	mov	edi, DWORD PTR __Top$[esp]
	cmp	edi, edx
	jge	SHORT $LN16@Push_heap_
	push	esi
	mov	esi, DWORD PTR __Val$[esp+4]
	npad	2
$LL4@Push_heap_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef

; 221  :         return static_cast<_Ty1&&>(_Left) < static_cast<_Ty2&&>(_Right);

	movss	xmm0, DWORD PTR [esi]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 5267 :     for (_Diff _Idx = (_Hole - 1) >> 1; // shift for codegen

	lea	eax, DWORD PTR [edx-1]
	sar	eax, 1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef

; 221  :         return static_cast<_Ty1&&>(_Left) < static_cast<_Ty2&&>(_Right);

	movss	xmm1, DWORD PTR [ecx+eax*4]
	comiss	xmm0, xmm1
	jbe	SHORT $LN15@Push_heap_
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 5272 :         _Hole             = _Idx;

	movss	DWORD PTR [ecx+edx*4], xmm1
	mov	edx, eax
	cmp	edi, eax
	jl	SHORT $LL4@Push_heap_
$LN15@Push_heap_:

; 5273 :     }
; 5274 : 
; 5275 :     *(_First + _Hole) = _STD forward<_Ty>(_Val); // drop _Val into final hole

	fld	DWORD PTR [esi]
	pop	esi
	fstp	DWORD PTR [ecx+edx*4]
	pop	edi

; 5276 : }

	ret	0
$LN16@Push_heap_:

; 5273 :     }
; 5274 : 
; 5275 :     *(_First + _Hole) = _STD forward<_Ty>(_Val); // drop _Val into final hole

	mov	eax, DWORD PTR __Val$[esp]
	pop	edi
	fld	DWORD PTR [eax]
	fstp	DWORD PTR [ecx+edx*4]

; 5276 : }

	ret	0
??$_Push_heap_by_index@PAMMU?$less@X@std@@@std@@YAXPAMHH$$QAMU?$less@X@0@@Z ENDP ; std::_Push_heap_by_index<float *,float,std::less<void> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
;	COMDAT ??$_Pop_heap_hole_unchecked@PAMMU?$less@X@std@@@std@@YAXPAM00$$QAMU?$less@X@0@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Val$ = 12						; size = 4
__Pred$ = 16						; size = 1
??$_Pop_heap_hole_unchecked@PAMMU?$less@X@std@@@std@@YAXPAM00$$QAMU?$less@X@0@@Z PROC ; std::_Pop_heap_hole_unchecked<float *,float,std::less<void> >, COMDAT
; __First$ = ecx
; __Last$ = edx

; 5405 :     // pop *_First to *_Dest and reheap
; 5406 :     // precondition: _First != _Last
; 5407 :     // precondition: _First != _Dest
; 5408 :     *_Dest      = _STD move(*_First);

	mov	eax, DWORD PTR __Dest$[esp-4]

; 5409 :     using _Diff = _Iter_diff_t<_RanIt>;
; 5410 :     _Pop_heap_hole_by_index(

	sub	edx, ecx
	fld	DWORD PTR [ecx]
	sar	edx, 2
	mov	DWORD PTR __Dest$[esp-4], edx
	xor	edx, edx
	fstp	DWORD PTR [eax]
	jmp	??$_Pop_heap_hole_by_index@PAMMU?$less@X@std@@@std@@YAXPAMHH$$QAMU?$less@X@0@@Z ; std::_Pop_heap_hole_by_index<float *,float,std::less<void> >
??$_Pop_heap_hole_unchecked@PAMMU?$less@X@std@@@std@@YAXPAM00$$QAMU?$less@X@0@@Z ENDP ; std::_Pop_heap_hole_unchecked<float *,float,std::less<void> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
;	COMDAT ??$_Med3_unchecked@PAMU?$less@X@std@@@std@@YAXPAM00U?$less@X@0@@Z
_TEXT	SEGMENT
__Last$ = 8						; size = 4
__Pred$ = 12						; size = 1
??$_Med3_unchecked@PAMU?$less@X@std@@@std@@YAXPAM00U?$less@X@0@@Z PROC ; std::_Med3_unchecked<float *,std::less<void> >, COMDAT
; __First$ = ecx
; __Mid$ = edx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef

; 221  :         return static_cast<_Ty1&&>(_Left) < static_cast<_Ty2&&>(_Right);

	movss	xmm0, DWORD PTR [edx]
	movss	xmm1, DWORD PTR [ecx]
	comiss	xmm1, xmm0
	jbe	SHORT $LN2@Med3_unche
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 101  :     _Left    = _STD move(_Right);

	movss	DWORD PTR [edx], xmm1

; 102  :     _Right   = _STD move(_Tmp);

	movss	DWORD PTR [ecx], xmm0
	movss	xmm0, DWORD PTR [edx]
$LN2@Med3_unche:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef

; 221  :         return static_cast<_Ty1&&>(_Left) < static_cast<_Ty2&&>(_Right);

	mov	eax, DWORD PTR __Last$[esp-4]
	movss	xmm1, DWORD PTR [eax]
	comiss	xmm0, xmm1
	jbe	SHORT $LN4@Med3_unche
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 101  :     _Left    = _STD move(_Right);

	movss	DWORD PTR [eax], xmm0

; 102  :     _Right   = _STD move(_Tmp);

	movss	DWORD PTR [edx], xmm1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef

; 221  :         return static_cast<_Ty1&&>(_Left) < static_cast<_Ty2&&>(_Right);

	movss	xmm0, DWORD PTR [ecx]
	comiss	xmm0, xmm1
	jbe	SHORT $LN4@Med3_unche
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 101  :     _Left    = _STD move(_Right);

	movss	DWORD PTR [edx], xmm0

; 102  :     _Right   = _STD move(_Tmp);

	movss	DWORD PTR [ecx], xmm1
$LN4@Med3_unche:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 6956 : }

	ret	0
??$_Med3_unchecked@PAMU?$less@X@std@@@std@@YAXPAM00U?$less@X@0@@Z ENDP ; std::_Med3_unchecked<float *,std::less<void> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
;	COMDAT ??$swap@M$0A@@std@@YAXAAM0@Z
_TEXT	SEGMENT
??$swap@M$0A@@std@@YAXAAM0@Z PROC			; std::swap<float,0>, COMDAT
; __Left$ = ecx
; __Right$ = edx

; 100  :     _Ty _Tmp = _STD move(_Left);
; 101  :     _Left    = _STD move(_Right);

	fld	DWORD PTR [edx]
	movss	xmm0, DWORD PTR [ecx]
	fstp	DWORD PTR [ecx]

; 102  :     _Right   = _STD move(_Tmp);

	movss	DWORD PTR [edx], xmm0

; 103  : }

	ret	0
??$swap@M$0A@@std@@YAXAAM0@Z ENDP			; std::swap<float,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\type_traits
;	COMDAT ??$forward@AAPAM@std@@YAAAPAMAAPAM@Z
_TEXT	SEGMENT
??$forward@AAPAM@std@@YAAAPAMAAPAM@Z PROC		; std::forward<float * &>, COMDAT
; __Arg$ = ecx

; 1386 :     return static_cast<_Ty&&>(_Arg);

	mov	eax, ecx

; 1387 : }

	ret	0
??$forward@AAPAM@std@@YAAAPAMAAPAM@Z ENDP		; std::forward<float * &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h
;	COMDAT ?getsize@?$_box3@M@@QBEXAAU?$_vector3@M@@@Z
_TEXT	SEGMENT
_R$ = 8							; size = 4
?getsize@?$_box3@M@@QBEXAAU?$_vector3@M@@@Z PROC	; _box3<float>::getsize, COMDAT
; _this$ = ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	xmm0, DWORD PTR [ecx+12]
	subss	xmm0, DWORD PTR [ecx]
	mov	eax, DWORD PTR _R$[esp-4]
	movss	DWORD PTR [eax], xmm0
	movss	xmm0, DWORD PTR [ecx+16]
	subss	xmm0, DWORD PTR [ecx+4]
	movss	DWORD PTR [eax+4], xmm0
	movss	xmm0, DWORD PTR [ecx+20]
	subss	xmm0, DWORD PTR [ecx+8]
	movss	DWORD PTR [eax+8], xmm0
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h

; 92   : 	IC	void		getsize		(Tvector& R )	const 	{ R.sub( max, min ); };

	ret	4
?getsize@?$_box3@M@@QBEXAAU?$_vector3@M@@@Z ENDP	; _box3<float>::getsize
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h
;	COMDAT ?getradius@?$_box3@M@@QBEXAAU?$_vector3@M@@@Z
_TEXT	SEGMENT
_R$ = 8							; size = 4
?getradius@?$_box3@M@@QBEXAAU?$_vector3@M@@@Z PROC	; _box3<float>::getradius, COMDAT
; _this$ = ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	xmm4, DWORD PTR [ecx+12]
	subss	xmm4, DWORD PTR [ecx]
	mov	eax, DWORD PTR _R$[esp-4]

; 40   : 	ICF SelfRef	mul(T s)								{ x*=s;		y*=s;		z*=s;			return *this;	};

	movss	xmm0, DWORD PTR __real@3f000000

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	DWORD PTR [eax], xmm4
	movss	xmm3, DWORD PTR [ecx+16]
	subss	xmm3, DWORD PTR [ecx+4]

; 40   : 	ICF SelfRef	mul(T s)								{ x*=s;		y*=s;		z*=s;			return *this;	};

	mulss	xmm4, xmm0

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	DWORD PTR [eax+4], xmm3
	movss	xmm2, DWORD PTR [ecx+20]
	movss	xmm1, DWORD PTR [ecx+8]
	subss	xmm2, xmm1

; 40   : 	ICF SelfRef	mul(T s)								{ x*=s;		y*=s;		z*=s;			return *this;	};

	mulss	xmm3, xmm0
	movss	DWORD PTR [eax], xmm4
	movss	DWORD PTR [eax+4], xmm3
	mulss	xmm2, xmm0
	movss	DWORD PTR [eax+8], xmm2
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h

; 93   : 	IC	void		getradius	(Tvector& R )	const 	{ getsize(R); R.mul(0.5f); };

	ret	4
?getradius@?$_box3@M@@QBEXAAU?$_vector3@M@@@Z ENDP	; _box3<float>::getradius
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
;	COMDAT ?div@?$_vector3@M@@QAEAAU1@M@Z
_TEXT	SEGMENT
_s$ = 8							; size = 4
?div@?$_vector3@M@@QAEAAU1@M@Z PROC			; _vector3<float>::div, COMDAT
; _this$ = ecx

; 45   : 	ICF SelfRef	div(T s)								{ x/=s;		y/=s;    z/=s;				return *this;	};

	movss	xmm1, DWORD PTR __real@3f800000
	mov	eax, ecx
	divss	xmm1, DWORD PTR _s$[esp-4]
	movaps	xmm0, xmm1
	mulss	xmm0, DWORD PTR [ecx]
	movss	DWORD PTR [ecx], xmm0
	movaps	xmm0, xmm1
	mulss	xmm0, DWORD PTR [ecx+4]
	mulss	xmm1, DWORD PTR [ecx+8]
	movss	DWORD PTR [ecx+4], xmm0
	movss	DWORD PTR [ecx+8], xmm1
	ret	4
?div@?$_vector3@M@@QAEAAU1@M@Z ENDP			; _vector3<float>::div
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
;	COMDAT ?add@?$_vector3@M@@QAEAAU1@ABU1@@Z
_TEXT	SEGMENT
_v$ = 8							; size = 4
?add@?$_vector3@M@@QAEAAU1@ABU1@@Z PROC			; _vector3<float>::add, COMDAT
; _this$ = ecx

; 29   : 	ICF	SelfRef	add(const Self &v)						{ x+=v.x;	y+=v.y;		z+=v.z;			return *this;	};

	mov	eax, DWORD PTR _v$[esp-4]
	movss	xmm0, DWORD PTR [eax]
	addss	xmm0, DWORD PTR [ecx]
	movss	DWORD PTR [ecx], xmm0
	movss	xmm0, DWORD PTR [eax+4]
	addss	xmm0, DWORD PTR [ecx+4]
	movss	DWORD PTR [ecx+4], xmm0
	movss	xmm0, DWORD PTR [eax+8]
	mov	eax, ecx
	addss	xmm0, DWORD PTR [ecx+8]
	movss	DWORD PTR [ecx+8], xmm0
	ret	4
?add@?$_vector3@M@@QAEAAU1@ABU1@@Z ENDP			; _vector3<float>::add
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
;	COMDAT ?mknormal_non_normalized@?$_vector3@M@@QAEAAU1@ABU1@00@Z
_TEXT	SEGMENT
_p0$ = 8						; size = 4
_p1$ = 12						; size = 4
_p2$ = 16						; size = 4
?mknormal_non_normalized@?$_vector3@M@@QAEAAU1@ABU1@00@Z PROC ; _vector3<float>::mknormal_non_normalized, COMDAT
; _this$ = ecx

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	mov	edx, DWORD PTR _p1$[esp-4]
	mov	eax, DWORD PTR _p0$[esp-4]
	movss	xmm7, DWORD PTR [edx]
	subss	xmm7, DWORD PTR [eax]
	movss	xmm6, DWORD PTR [edx+4]
	subss	xmm6, DWORD PTR [eax+4]
	movss	xmm3, DWORD PTR [edx+8]
	subss	xmm3, DWORD PTR [eax+8]
	mov	eax, DWORD PTR _p2$[esp-4]
	movss	xmm4, DWORD PTR [eax+4]
	movss	xmm2, DWORD PTR [eax+8]
	subss	xmm4, DWORD PTR [edx+4]
	subss	xmm2, DWORD PTR [edx+8]
	movss	xmm5, DWORD PTR [eax]

; 317  :     	_vector3<T> v01,v12;
; 318  :     	v01.sub( p1, p0 );
; 319  :     	v12.sub( p2, p1 );
; 320  :     	crossproduct( v01, v12 );
; 321  : 		return *this;	

	mov	eax, ecx

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	subss	xmm5, DWORD PTR [edx]

; 273  : 		x = v1.y  * v2.z  - v1.z  * v2.y ;

	movaps	xmm0, xmm4

; 274  : 		y = v1.z  * v2.x  - v1.x  * v2.z ;

	mulss	xmm4, xmm7

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movaps	xmm1, xmm2

; 273  : 		x = v1.y  * v2.z  - v1.z  * v2.y ;

	mulss	xmm0, xmm3

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	mulss	xmm1, xmm6

; 274  : 		y = v1.z  * v2.x  - v1.x  * v2.z ;

	mulss	xmm2, xmm7
	subss	xmm1, xmm0
	movaps	xmm0, xmm5
	mulss	xmm0, xmm3

; 275  : 		z = v1.x  * v2.y  - v1.y  * v2.x ;

	mulss	xmm5, xmm6
	subss	xmm0, xmm2
	movss	DWORD PTR [ecx], xmm1
	subss	xmm4, xmm5
	movss	DWORD PTR [ecx+4], xmm0
	movss	DWORD PTR [ecx+8], xmm4

; 322  :     };

	ret	12					; 0000000cH
?mknormal_non_normalized@?$_vector3@M@@QAEAAU1@ABU1@00@Z ENDP ; _vector3<float>::mknormal_non_normalized
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\limits
;	COMDAT ?min@?$numeric_limits@M@std@@SAMXZ
_TEXT	SEGMENT
?min@?$numeric_limits@M@std@@SAMXZ PROC			; std::numeric_limits<float>::min, COMDAT

; 849  :         return FLT_MIN;

	fld	DWORD PTR __real@00800000

; 850  :     }

	ret	0
?min@?$numeric_limits@M@std@@SAMXZ ENDP			; std::numeric_limits<float>::min
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
;	COMDAT ?normalize_safe@?$_vector3@M@@QAEAAU1@XZ
_TEXT	SEGMENT
?normalize_safe@?$_vector3@M@@QAEAAU1@XZ PROC		; _vector3<float>::normalize_safe, COMDAT
; _this$ = ecx

; 200  : 		T magnitude=x*x + y*y + z*z;

	movss	xmm3, DWORD PTR [ecx+4]

; 201  : 		if (magnitude> std::numeric_limits<T>::min()) {

	mov	eax, ecx
	movss	xmm2, DWORD PTR [ecx]
	movaps	xmm0, xmm3
	movss	xmm4, DWORD PTR [ecx+8]
	movaps	xmm1, xmm2
	mulss	xmm0, xmm3
	mulss	xmm1, xmm2
	addss	xmm1, xmm0
	movaps	xmm0, xmm4
	mulss	xmm0, xmm4
	addss	xmm1, xmm0
	comiss	xmm1, DWORD PTR __real@00800000
	jbe	SHORT $LN2@normalize_

; 202  : 			magnitude=_sqrt(1/magnitude);

	movss	xmm0, DWORD PTR __real@3f800000
	divss	xmm0, xmm1
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h

; 764  :             return (float)sqrt(_X);

	sqrtss	xmm0, xmm0
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 203  : 			x *= magnitude;

	mulss	xmm2, xmm0

; 204  : 			y *= magnitude;

	mulss	xmm3, xmm0

; 205  : 			z *= magnitude;

	mulss	xmm4, xmm0
	movss	DWORD PTR [ecx], xmm2
	movss	DWORD PTR [ecx+4], xmm3
	movss	DWORD PTR [ecx+8], xmm4
$LN2@normalize_:

; 206  : 		}
; 207  : 		return *this;	
; 208  : 	}

	ret	0
?normalize_safe@?$_vector3@M@@QAEAAU1@XZ ENDP		; _vector3<float>::normalize_safe
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
;	COMDAT ?mknormal@?$_vector3@M@@QAEAAU1@ABU1@00@Z
_TEXT	SEGMENT
_p0$ = 8						; size = 4
tv365 = 12						; size = 4
_p1$ = 12						; size = 4
_p2$ = 16						; size = 4
?mknormal@?$_vector3@M@@QAEAAU1@ABU1@00@Z PROC		; _vector3<float>::mknormal, COMDAT
; _this$ = ecx

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	mov	edx, DWORD PTR _p1$[esp-4]
	mov	eax, DWORD PTR _p0$[esp-4]
	movss	xmm3, DWORD PTR [edx+8]
	subss	xmm3, DWORD PTR [eax+8]
	movss	xmm6, DWORD PTR [edx]
	subss	xmm6, DWORD PTR [eax]
	movss	xmm5, DWORD PTR [edx+4]
	subss	xmm5, DWORD PTR [eax+4]
	mov	eax, DWORD PTR _p2$[esp-4]
	movss	xmm2, DWORD PTR [eax+4]
	movss	xmm1, DWORD PTR [eax+8]
	subss	xmm2, DWORD PTR [edx+4]
	subss	xmm1, DWORD PTR [edx+8]
	movss	xmm4, DWORD PTR [eax]

; 201  : 		if (magnitude> std::numeric_limits<T>::min()) {

	mov	eax, ecx

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	subss	xmm4, DWORD PTR [edx]

; 273  : 		x = v1.y  * v2.z  - v1.z  * v2.y ;

	movaps	xmm0, xmm2

; 274  : 		y = v1.z  * v2.x  - v1.x  * v2.z ;

	mulss	xmm2, xmm6
	mulss	xmm0, xmm3

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movaps	xmm7, xmm1
	mulss	xmm7, xmm5

; 274  : 		y = v1.z  * v2.x  - v1.x  * v2.z ;

	mulss	xmm1, xmm6
	subss	xmm7, xmm0
	movaps	xmm0, xmm4
	mulss	xmm0, xmm3

; 275  : 		z = v1.x  * v2.y  - v1.y  * v2.x ;

	mulss	xmm4, xmm5
	subss	xmm0, xmm1
	movss	DWORD PTR [ecx], xmm7

; 200  : 		T magnitude=x*x + y*y + z*z;

	movaps	xmm3, xmm7

; 275  : 		z = v1.x  * v2.y  - v1.y  * v2.x ;

	subss	xmm2, xmm4

; 200  : 		T magnitude=x*x + y*y + z*z;

	mulss	xmm3, xmm7
	movaps	xmm1, xmm0

; 274  : 		y = v1.z  * v2.x  - v1.x  * v2.z ;

	movss	DWORD PTR [ecx+4], xmm0

; 200  : 		T magnitude=x*x + y*y + z*z;

	mulss	xmm0, xmm1

; 275  : 		z = v1.x  * v2.y  - v1.y  * v2.x ;

	movss	DWORD PTR [ecx+8], xmm2

; 200  : 		T magnitude=x*x + y*y + z*z;

	addss	xmm3, xmm0
	movaps	xmm0, xmm2
	mulss	xmm0, xmm2
	addss	xmm3, xmm0

; 201  : 		if (magnitude> std::numeric_limits<T>::min()) {

	comiss	xmm3, DWORD PTR __real@00800000
	jbe	SHORT $LN12@mknormal

; 202  : 			magnitude=_sqrt(1/magnitude);

	movss	xmm0, DWORD PTR __real@3f800000
	divss	xmm0, xmm3
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h

; 764  :             return (float)sqrt(_X);

	sqrtss	xmm0, xmm0
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 203  : 			x *= magnitude;

	mulss	xmm7, xmm0

; 204  : 			y *= magnitude;

	mulss	xmm1, xmm0

; 205  : 			z *= magnitude;

	mulss	xmm2, xmm0
	movss	DWORD PTR [ecx], xmm7
	movss	DWORD PTR [ecx+4], xmm1
	movss	DWORD PTR [ecx+8], xmm2
$LN12@mknormal:

; 325  : 		mknormal_non_normalized(p0,p1,p2);
; 326  :     	normalize_safe();
; 327  : 		return *this;	
; 328  :     };

	ret	12					; 0000000cH
?mknormal@?$_vector3@M@@QAEAAU1@ABU1@00@Z ENDP		; _vector3<float>::mknormal
_TEXT	ENDS
END
