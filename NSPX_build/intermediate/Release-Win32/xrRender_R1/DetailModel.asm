; Listing generated by Microsoft (R) Optimizing Compiler Version 19.29.30146.0 

	TITLE	i:\vitalya\mine\nsprojectx\nspx_build\intermediate\release-win32\xrrender_r1\detailmodel.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	??_C@_0O@MGDDPLHN@CDetail?3?3Load@		; `string'
PUBLIC	??_C@_0DL@GJHFBGFO@I?3?2Vitalya?2mine?2NSProjectX?2laye@ ; `string'
PUBLIC	??_C@_0BG@MKHFKJHC@0?$DN?$DN?$CInumber_indices?$CF3?$CJ@ ; `string'
EXTRN	__imp_?r_float@?$IReaderBase@VIReader@@@@QAEMXZ:PROC
EXTRN	__imp_?r_stringZ@IReader@@QAEXPADI@Z:PROC
EXTRN	__imp_?_set@?$resptr_base@UShader@@@@QAEXPAUShader@@@Z:PROC
EXTRN	__imp_?destroy@resptrcode_shader@@QAEXXZ:PROC
;	COMDAT ?ignore_always@?3??Load@CDetail@@QAEXPAVIReader@@@Z@4_NA
_BSS	SEGMENT
?ignore_always@?3??Load@CDetail@@QAEXPAVIReader@@@Z@4_NA DB 01H DUP (?) ; `CDetail::Load'::`4'::ignore_always
_BSS	ENDS
;	COMDAT ??_C@_0BG@MKHFKJHC@0?$DN?$DN?$CInumber_indices?$CF3?$CJ@
CONST	SEGMENT
??_C@_0BG@MKHFKJHC@0?$DN?$DN?$CInumber_indices?$CF3?$CJ@ DB '0==(number_i'
	DB	'ndices%3)', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0DL@GJHFBGFO@I?3?2Vitalya?2mine?2NSProjectX?2laye@
CONST	SEGMENT
??_C@_0DL@GJHFBGFO@I?3?2Vitalya?2mine?2NSProjectX?2laye@ DB 'I:\Vitalya\m'
	DB	'ine\NSProjectX\layers\xrRender\DetailModel.cpp', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@MGDDPLHN@CDetail?3?3Load@
CONST	SEGMENT
??_C@_0O@MGDDPLHN@CDetail?3?3Load@ DB 'CDetail::Load', 00H ; `string'
?_Fake_alloc@std@@3U_Fake_allocator@1@B	ORG $+1		; std::_Fake_alloc
PUBLIC	??$_Convert_size@I@std@@YAII@Z			; std::_Convert_size<unsigned int>
PUBLIC	?construct@?$xalloc@UfvfVertexIn@IRender_DetailModel@@@@QAEXPAUfvfVertexIn@IRender_DetailModel@@ABU23@@Z ; xalloc<IRender_DetailModel::fvfVertexIn>::construct
PUBLIC	??$construct@UfvfVertexIn@IRender_DetailModel@@AAU12@@?$_Normal_allocator_traits@V?$xalloc@UfvfVertexIn@IRender_DetailModel@@@@@std@@SAXAAV?$xalloc@UfvfVertexIn@IRender_DetailModel@@@@PAUfvfVertexIn@IRender_DetailModel@@AAU34@@Z ; std::_Normal_allocator_traits<xalloc<IRender_DetailModel::fvfVertexIn> >::construct<IRender_DetailModel::fvfVertexIn,IRender_DetailModel::fvfVertexIn &>
PUBLIC	??$forward@AAUfvfVertexIn@IRender_DetailModel@@@std@@YAAAUfvfVertexIn@IRender_DetailModel@@AAU12@@Z ; std::forward<IRender_DetailModel::fvfVertexIn &>
PUBLIC	??$construct@GAAG@?$_Normal_allocator_traits@V?$xalloc@G@@@std@@SAXAAV?$xalloc@G@@PAGAAG@Z ; std::_Normal_allocator_traits<xalloc<unsigned short> >::construct<unsigned short,unsigned short &>
PUBLIC	??$forward@AAG@std@@YAAAGAAG@Z			; std::forward<unsigned short &>
PUBLIC	?construct@?$xalloc@G@@QAEXPAGABG@Z		; xalloc<unsigned short>::construct
PUBLIC	??$construct@GG@?$_Normal_allocator_traits@V?$xalloc@G@@@std@@SAXAAV?$xalloc@G@@PAG$$QAG@Z ; std::_Normal_allocator_traits<xalloc<unsigned short> >::construct<unsigned short,unsigned short>
PUBLIC	??$forward@G@std@@YA$$QAGAAG@Z			; std::forward<unsigned short>
PUBLIC	??$_Emplace_back@AAUfvfVertexIn@IRender_DetailModel@@@?$_Uninitialized_backout_al@V?$xalloc@UfvfVertexIn@IRender_DetailModel@@@@@std@@QAEXAAUfvfVertexIn@IRender_DetailModel@@@Z ; std::_Uninitialized_backout_al<xalloc<IRender_DetailModel::fvfVertexIn> >::_Emplace_back<IRender_DetailModel::fvfVertexIn &>
PUBLIC	??$_Emplace_back@AAG@?$_Uninitialized_backout_al@V?$xalloc@G@@@std@@QAEXAAG@Z ; std::_Uninitialized_backout_al<xalloc<unsigned short> >::_Emplace_back<unsigned short &>
PUBLIC	??0?$_Uninitialized_backout_al@V?$xalloc@UfvfVertexIn@IRender_DetailModel@@@@@std@@QAE@PAUfvfVertexIn@IRender_DetailModel@@AAV?$xalloc@UfvfVertexIn@IRender_DetailModel@@@@@Z ; std::_Uninitialized_backout_al<xalloc<IRender_DetailModel::fvfVertexIn> >::_Uninitialized_backout_al<xalloc<IRender_DetailModel::fvfVertexIn> >
PUBLIC	??1?$_Uninitialized_backout_al@V?$xalloc@UfvfVertexIn@IRender_DetailModel@@@@@std@@QAE@XZ ; std::_Uninitialized_backout_al<xalloc<IRender_DetailModel::fvfVertexIn> >::~_Uninitialized_backout_al<xalloc<IRender_DetailModel::fvfVertexIn> >
PUBLIC	?_Release@?$_Uninitialized_backout_al@V?$xalloc@UfvfVertexIn@IRender_DetailModel@@@@@std@@QAEPAUfvfVertexIn@IRender_DetailModel@@XZ ; std::_Uninitialized_backout_al<xalloc<IRender_DetailModel::fvfVertexIn> >::_Release
PUBLIC	??$_Emplace_back@G@?$_Uninitialized_backout_al@V?$xalloc@G@@@std@@QAEX$$QAG@Z ; std::_Uninitialized_backout_al<xalloc<unsigned short> >::_Emplace_back<unsigned short>
PUBLIC	??$move@AAG@std@@YA$$QAGAAG@Z			; std::move<unsigned short &>
PUBLIC	??$construct@G$$V@?$_Normal_allocator_traits@V?$xalloc@G@@@std@@SAXAAV?$xalloc@G@@PAG@Z ; std::_Normal_allocator_traits<xalloc<unsigned short> >::construct<unsigned short>
PUBLIC	??$_Get_unwrapped@ABQAUfvfVertexIn@IRender_DetailModel@@@std@@YA?A_TABQAUfvfVertexIn@IRender_DetailModel@@@Z ; std::_Get_unwrapped<IRender_DetailModel::fvfVertexIn * const &>
PUBLIC	??$_Uninitialized_copy@PAUfvfVertexIn@IRender_DetailModel@@V?$xalloc@UfvfVertexIn@IRender_DetailModel@@@@@std@@YAPAUfvfVertexIn@IRender_DetailModel@@QAU12@0PAU12@AAV?$xalloc@UfvfVertexIn@IRender_DetailModel@@@@@Z ; std::_Uninitialized_copy<IRender_DetailModel::fvfVertexIn *,xalloc<IRender_DetailModel::fvfVertexIn> >
PUBLIC	??$_To_address@PAUfvfVertexIn@IRender_DetailModel@@@std@@YA?A_PABQAUfvfVertexIn@IRender_DetailModel@@@Z ; std::_To_address<IRender_DetailModel::fvfVertexIn *>
PUBLIC	??$_Copy_memmove@PAUfvfVertexIn@IRender_DetailModel@@PAU12@@std@@YAPAUfvfVertexIn@IRender_DetailModel@@PAU12@00@Z ; std::_Copy_memmove<IRender_DetailModel::fvfVertexIn *,IRender_DetailModel::fvfVertexIn *>
PUBLIC	??$advance@PAUfvfVertexIn@IRender_DetailModel@@H@std@@YAXAAPAUfvfVertexIn@IRender_DetailModel@@H@Z ; std::advance<IRender_DetailModel::fvfVertexIn *,int>
PUBLIC	??$_Uninitialized_copy@PAGV?$xalloc@G@@@std@@YAPAGQAG0PAGAAV?$xalloc@G@@@Z ; std::_Uninitialized_copy<unsigned short *,xalloc<unsigned short> >
PUBLIC	??$_Copy_memmove@PAGPAG@std@@YAPAGPAG00@Z	; std::_Copy_memmove<unsigned short *,unsigned short *>
PUBLIC	??$advance@PAGH@std@@YAXAAPAGH@Z		; std::advance<unsigned short *,int>
PUBLIC	??$_Get_unwrapped@ABQAG@std@@YA?A_TABQAG@Z	; std::_Get_unwrapped<unsigned short * const &>
PUBLIC	??$_Uninitialized_move@PAGV?$xalloc@G@@@std@@YAPAGQAG0PAGAAV?$xalloc@G@@@Z ; std::_Uninitialized_move<unsigned short *,xalloc<unsigned short> >
PUBLIC	??$_Destroy_in_place@PAG@std@@YAXAAPAG@Z	; std::_Destroy_in_place<unsigned short *>
PUBLIC	??$_Destroy_in_place@PAUfvfVertexIn@IRender_DetailModel@@@std@@YAXAAPAUfvfVertexIn@IRender_DetailModel@@@Z ; std::_Destroy_in_place<IRender_DetailModel::fvfVertexIn *>
PUBLIC	??$_Emplace_back@$$V@?$_Uninitialized_backout_al@V?$xalloc@G@@@std@@QAEXXZ ; std::_Uninitialized_backout_al<xalloc<unsigned short> >::_Emplace_back<>
PUBLIC	??$_To_address@PAG@std@@YA?A_PABQAG@Z		; std::_To_address<unsigned short *>
PUBLIC	??$_Zero_range@PAG@std@@YAPAGQAG0@Z		; std::_Zero_range<unsigned short *>
PUBLIC	??$_Ucopy@PAUfvfVertexIn@IRender_DetailModel@@@?$vector@UfvfVertexIn@IRender_DetailModel@@V?$xalloc@UfvfVertexIn@IRender_DetailModel@@@@@std@@AAEPAUfvfVertexIn@IRender_DetailModel@@PAU23@00@Z ; std::vector<IRender_DetailModel::fvfVertexIn,xalloc<IRender_DetailModel::fvfVertexIn> >::_Ucopy<IRender_DetailModel::fvfVertexIn *>
PUBLIC	??$_Copy_unchecked@PAUfvfVertexIn@IRender_DetailModel@@PAU12@@std@@YAPAUfvfVertexIn@IRender_DetailModel@@PAU12@00@Z ; std::_Copy_unchecked<IRender_DetailModel::fvfVertexIn *,IRender_DetailModel::fvfVertexIn *>
PUBLIC	??$next@PAUfvfVertexIn@IRender_DetailModel@@@std@@YAPAUfvfVertexIn@IRender_DetailModel@@PAU12@H@Z ; std::next<IRender_DetailModel::fvfVertexIn *>
PUBLIC	??$distance@PAUfvfVertexIn@IRender_DetailModel@@@std@@YAHPAUfvfVertexIn@IRender_DetailModel@@0@Z ; std::distance<IRender_DetailModel::fvfVertexIn *>
PUBLIC	??$_Ucopy@PAG@?$vector@GV?$xalloc@G@@@std@@AAEPAGPAG00@Z ; std::vector<unsigned short,xalloc<unsigned short> >::_Ucopy<unsigned short *>
PUBLIC	??$_Copy_unchecked@PAGPAG@std@@YAPAGPAG00@Z	; std::_Copy_unchecked<unsigned short *,unsigned short *>
PUBLIC	??$next@PAG@std@@YAPAGPAGH@Z			; std::next<unsigned short *>
PUBLIC	??$distance@PAG@std@@YAHPAG0@Z			; std::distance<unsigned short *>
PUBLIC	?max_size@?$xalloc@UfvfVertexIn@IRender_DetailModel@@@@QBEIXZ ; xalloc<IRender_DetailModel::fvfVertexIn>::max_size
PUBLIC	?_Get_first@?$_Compressed_pair@V?$xalloc@UfvfVertexIn@IRender_DetailModel@@@@V?$_Vector_val@U?$_Simple_types@UfvfVertexIn@IRender_DetailModel@@@std@@@std@@$00@std@@QBEABV?$xalloc@UfvfVertexIn@IRender_DetailModel@@@@XZ ; std::_Compressed_pair<xalloc<IRender_DetailModel::fvfVertexIn>,std::_Vector_val<std::_Simple_types<IRender_DetailModel::fvfVertexIn> >,1>::_Get_first
PUBLIC	?max_size@?$xalloc@G@@QBEIXZ			; xalloc<unsigned short>::max_size
PUBLIC	?_Get_first@?$_Compressed_pair@V?$xalloc@G@@V?$_Vector_val@U?$_Simple_types@G@std@@@std@@$00@std@@QBEABV?$xalloc@G@@XZ ; std::_Compressed_pair<xalloc<unsigned short>,std::_Vector_val<std::_Simple_types<unsigned short> >,1>::_Get_first
PUBLIC	?allocate@?$xalloc@UfvfVertexIn@IRender_DetailModel@@@@QBEPAUfvfVertexIn@IRender_DetailModel@@IPBX@Z ; xalloc<IRender_DetailModel::fvfVertexIn>::allocate
PUBLIC	?max_size@?$_Normal_allocator_traits@V?$xalloc@UfvfVertexIn@IRender_DetailModel@@@@@std@@SAIABV?$xalloc@UfvfVertexIn@IRender_DetailModel@@@@@Z ; std::_Normal_allocator_traits<xalloc<IRender_DetailModel::fvfVertexIn> >::max_size
PUBLIC	?capacity@?$vector@UfvfVertexIn@IRender_DetailModel@@V?$xalloc@UfvfVertexIn@IRender_DetailModel@@@@@std@@QBEIXZ ; std::vector<IRender_DetailModel::fvfVertexIn,xalloc<IRender_DetailModel::fvfVertexIn> >::capacity
PUBLIC	?_Getal@?$vector@UfvfVertexIn@IRender_DetailModel@@V?$xalloc@UfvfVertexIn@IRender_DetailModel@@@@@std@@ABEABV?$xalloc@UfvfVertexIn@IRender_DetailModel@@@@XZ ; std::vector<IRender_DetailModel::fvfVertexIn,xalloc<IRender_DetailModel::fvfVertexIn> >::_Getal
PUBLIC	?max_size@?$_Normal_allocator_traits@V?$xalloc@G@@@std@@SAIABV?$xalloc@G@@@Z ; std::_Normal_allocator_traits<xalloc<unsigned short> >::max_size
PUBLIC	?capacity@?$vector@GV?$xalloc@G@@@std@@QBEIXZ	; std::vector<unsigned short,xalloc<unsigned short> >::capacity
PUBLIC	?_Umove_if_noexcept1@?$vector@GV?$xalloc@G@@@std@@AAEXPAG00U?$integral_constant@_N$00@2@@Z ; std::vector<unsigned short,xalloc<unsigned short> >::_Umove_if_noexcept1
PUBLIC	?_Buy_raw@?$vector@GV?$xalloc@G@@@std@@AAEXI@Z	; std::vector<unsigned short,xalloc<unsigned short> >::_Buy_raw
PUBLIC	?_Getal@?$vector@GV?$xalloc@G@@@std@@ABEABV?$xalloc@G@@XZ ; std::vector<unsigned short,xalloc<unsigned short> >::_Getal
PUBLIC	?max_size@?$vector@UfvfVertexIn@IRender_DetailModel@@V?$xalloc@UfvfVertexIn@IRender_DetailModel@@@@@std@@QBEIXZ ; std::vector<IRender_DetailModel::fvfVertexIn,xalloc<IRender_DetailModel::fvfVertexIn> >::max_size
PUBLIC	?_Calculate_growth@?$vector@UfvfVertexIn@IRender_DetailModel@@V?$xalloc@UfvfVertexIn@IRender_DetailModel@@@@@std@@ABEII@Z ; std::vector<IRender_DetailModel::fvfVertexIn,xalloc<IRender_DetailModel::fvfVertexIn> >::_Calculate_growth
PUBLIC	?_Buy_raw@?$vector@UfvfVertexIn@IRender_DetailModel@@V?$xalloc@UfvfVertexIn@IRender_DetailModel@@@@@std@@AAEXI@Z ; std::vector<IRender_DetailModel::fvfVertexIn,xalloc<IRender_DetailModel::fvfVertexIn> >::_Buy_raw
PUBLIC	?_Xlength@?$vector@UfvfVertexIn@IRender_DetailModel@@V?$xalloc@UfvfVertexIn@IRender_DetailModel@@@@@std@@CAXXZ ; std::vector<IRender_DetailModel::fvfVertexIn,xalloc<IRender_DetailModel::fvfVertexIn> >::_Xlength
PUBLIC	?allocate@?$xalloc@G@@QBEPAGIPBX@Z		; xalloc<unsigned short>::allocate
PUBLIC	?destroy@?$xalloc@G@@QAEXPAG@Z			; xalloc<unsigned short>::destroy
PUBLIC	?_Clear_and_reserve_geometric@?$vector@GV?$xalloc@G@@@std@@AAEXI@Z ; std::vector<unsigned short,xalloc<unsigned short> >::_Clear_and_reserve_geometric
PUBLIC	?max_size@?$vector@GV?$xalloc@G@@@std@@QBEIXZ	; std::vector<unsigned short,xalloc<unsigned short> >::max_size
PUBLIC	?_Umove_if_noexcept@?$vector@GV?$xalloc@G@@@std@@AAEXPAG00@Z ; std::vector<unsigned short,xalloc<unsigned short> >::_Umove_if_noexcept
PUBLIC	?_Calculate_growth@?$vector@GV?$xalloc@G@@@std@@ABEII@Z ; std::vector<unsigned short,xalloc<unsigned short> >::_Calculate_growth
PUBLIC	?_Change_array@?$vector@GV?$xalloc@G@@@std@@AAEXQAGII@Z ; std::vector<unsigned short,xalloc<unsigned short> >::_Change_array
PUBLIC	?_Xlength@?$vector@GV?$xalloc@G@@@std@@CAXXZ	; std::vector<unsigned short,xalloc<unsigned short> >::_Xlength
PUBLIC	?destroy@?$xalloc@UfvfVertexIn@IRender_DetailModel@@@@QAEXPAUfvfVertexIn@IRender_DetailModel@@@Z ; xalloc<IRender_DetailModel::fvfVertexIn>::destroy
PUBLIC	?_Clear_and_reserve_geometric@?$vector@UfvfVertexIn@IRender_DetailModel@@V?$xalloc@UfvfVertexIn@IRender_DetailModel@@@@@std@@AAEXI@Z ; std::vector<IRender_DetailModel::fvfVertexIn,xalloc<IRender_DetailModel::fvfVertexIn> >::_Clear_and_reserve_geometric
PUBLIC	??0?$_Uninitialized_backout_al@V?$xalloc@G@@@std@@QAE@PAGAAV?$xalloc@G@@@Z ; std::_Uninitialized_backout_al<xalloc<unsigned short> >::_Uninitialized_backout_al<xalloc<unsigned short> >
PUBLIC	??1?$_Uninitialized_backout_al@V?$xalloc@G@@@std@@QAE@XZ ; std::_Uninitialized_backout_al<xalloc<unsigned short> >::~_Uninitialized_backout_al<xalloc<unsigned short> >
PUBLIC	?_Release@?$_Uninitialized_backout_al@V?$xalloc@G@@@std@@QAEPAGXZ ; std::_Uninitialized_backout_al<xalloc<unsigned short> >::_Release
PUBLIC	??$_Uninitialized_value_construct_n@V?$xalloc@G@@@std@@YAPAGPAGIAAV?$xalloc@G@@@Z ; std::_Uninitialized_value_construct_n<xalloc<unsigned short> >
PUBLIC	??$destroy@G@?$_Normal_allocator_traits@V?$xalloc@G@@@std@@SAXAAV?$xalloc@G@@PAG@Z ; std::_Normal_allocator_traits<xalloc<unsigned short> >::destroy<unsigned short>
PUBLIC	??$_Unfancy@G@std@@YAPAGPAG@Z			; std::_Unfancy<unsigned short>
PUBLIC	??$destroy@UfvfVertexIn@IRender_DetailModel@@@?$_Normal_allocator_traits@V?$xalloc@UfvfVertexIn@IRender_DetailModel@@@@@std@@SAXAAV?$xalloc@UfvfVertexIn@IRender_DetailModel@@@@PAUfvfVertexIn@IRender_DetailModel@@@Z ; std::_Normal_allocator_traits<xalloc<IRender_DetailModel::fvfVertexIn> >::destroy<IRender_DetailModel::fvfVertexIn>
PUBLIC	??$_Unfancy@UfvfVertexIn@IRender_DetailModel@@@std@@YAPAUfvfVertexIn@IRender_DetailModel@@PAU12@@Z ; std::_Unfancy<IRender_DetailModel::fvfVertexIn>
PUBLIC	??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@GV?$xalloc@G@@@std@@AAEXIABU_Value_init_tag@1@@Z ; std::vector<unsigned short,xalloc<unsigned short> >::_Resize_reallocate<std::_Value_init_tag>
PUBLIC	??$_Assign_range@PAUfvfVertexIn@IRender_DetailModel@@@?$vector@UfvfVertexIn@IRender_DetailModel@@V?$xalloc@UfvfVertexIn@IRender_DetailModel@@@@@std@@AAEXPAUfvfVertexIn@IRender_DetailModel@@0Uforward_iterator_tag@1@@Z ; std::vector<IRender_DetailModel::fvfVertexIn,xalloc<IRender_DetailModel::fvfVertexIn> >::_Assign_range<IRender_DetailModel::fvfVertexIn *>
PUBLIC	??$_Adl_verify_range@PAUfvfVertexIn@IRender_DetailModel@@PAU12@@std@@YAXABQAUfvfVertexIn@IRender_DetailModel@@0@Z ; std::_Adl_verify_range<IRender_DetailModel::fvfVertexIn *,IRender_DetailModel::fvfVertexIn *>
PUBLIC	??$_Assign_range@PAG@?$vector@GV?$xalloc@G@@@std@@AAEXPAG0Uforward_iterator_tag@1@@Z ; std::vector<unsigned short,xalloc<unsigned short> >::_Assign_range<unsigned short *>
PUBLIC	??$_Adl_verify_range@PAGPAG@std@@YAXABQAG0@Z	; std::_Adl_verify_range<unsigned short *,unsigned short *>
PUBLIC	??0?$xalloc@G@@QAE@XZ				; xalloc<unsigned short>::xalloc<unsigned short>
PUBLIC	?_Ufill@?$vector@GV?$xalloc@G@@@std@@AAEPAGPAGIU_Value_init_tag@2@@Z ; std::vector<unsigned short,xalloc<unsigned short> >::_Ufill
PUBLIC	?_Orphan_range@?$vector@GV?$xalloc@G@@@std@@ABEXPAG0@Z ; std::vector<unsigned short,xalloc<unsigned short> >::_Orphan_range
PUBLIC	??0?$_Vector_val@U?$_Simple_types@G@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<unsigned short> >::_Vector_val<std::_Simple_types<unsigned short> >
PUBLIC	??0?$xalloc@UfvfVertexIn@IRender_DetailModel@@@@QAE@XZ ; xalloc<IRender_DetailModel::fvfVertexIn>::xalloc<IRender_DetailModel::fvfVertexIn>
PUBLIC	??0?$_Vector_val@U?$_Simple_types@UfvfVertexIn@IRender_DetailModel@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<IRender_DetailModel::fvfVertexIn> >::_Vector_val<std::_Simple_types<IRender_DetailModel::fvfVertexIn> >
PUBLIC	??$_Destroy_range@V?$xalloc@G@@@std@@YAXPAGQAGAAV?$xalloc@G@@@Z ; std::_Destroy_range<xalloc<unsigned short> >
PUBLIC	??$_Destroy_range@V?$xalloc@UfvfVertexIn@IRender_DetailModel@@@@@std@@YAXPAUfvfVertexIn@IRender_DetailModel@@QAU12@AAV?$xalloc@UfvfVertexIn@IRender_DetailModel@@@@@Z ; std::_Destroy_range<xalloc<IRender_DetailModel::fvfVertexIn> >
PUBLIC	??$?0$$V@?$_Compressed_pair@V?$xalloc@G@@V?$_Vector_val@U?$_Simple_types@G@std@@@std@@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<xalloc<unsigned short>,std::_Vector_val<std::_Simple_types<unsigned short> >,1>::_Compressed_pair<xalloc<unsigned short>,std::_Vector_val<std::_Simple_types<unsigned short> >,1><>
PUBLIC	??$?0$$V@?$_Compressed_pair@V?$xalloc@UfvfVertexIn@IRender_DetailModel@@@@V?$_Vector_val@U?$_Simple_types@UfvfVertexIn@IRender_DetailModel@@@std@@@std@@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<xalloc<IRender_DetailModel::fvfVertexIn>,std::_Vector_val<std::_Simple_types<IRender_DetailModel::fvfVertexIn> >,1>::_Compressed_pair<xalloc<IRender_DetailModel::fvfVertexIn>,std::_Vector_val<std::_Simple_types<IRender_DetailModel::fvfVertexIn> >,1><>
PUBLIC	??$addressof@V?$_Vector_val@U?$_Simple_types@UfvfVertexIn@IRender_DetailModel@@@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@UfvfVertexIn@IRender_DetailModel@@@std@@@0@AAV10@@Z ; std::addressof<std::_Vector_val<std::_Simple_types<IRender_DetailModel::fvfVertexIn> > >
PUBLIC	??$_Resize@U_Value_init_tag@std@@@?$vector@GV?$xalloc@G@@@std@@AAEXIABU_Value_init_tag@1@@Z ; std::vector<unsigned short,xalloc<unsigned short> >::_Resize<std::_Value_init_tag>
PUBLIC	??$addressof@V?$_Vector_val@U?$_Simple_types@G@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@G@std@@@0@AAV10@@Z ; std::addressof<std::_Vector_val<std::_Simple_types<unsigned short> > >
PUBLIC	??$_Get_unwrapped@AAPAUfvfVertexIn@IRender_DetailModel@@@std@@YA?A_TAAPAUfvfVertexIn@IRender_DetailModel@@@Z ; std::_Get_unwrapped<IRender_DetailModel::fvfVertexIn * &>
PUBLIC	??$assign@PAUfvfVertexIn@IRender_DetailModel@@$0A@@?$vector@UfvfVertexIn@IRender_DetailModel@@V?$xalloc@UfvfVertexIn@IRender_DetailModel@@@@@std@@QAEXPAUfvfVertexIn@IRender_DetailModel@@0@Z ; std::vector<IRender_DetailModel::fvfVertexIn,xalloc<IRender_DetailModel::fvfVertexIn> >::assign<IRender_DetailModel::fvfVertexIn *,0>
PUBLIC	??$_Get_unwrapped@AAPAG@std@@YA?A_TAAPAG@Z	; std::_Get_unwrapped<unsigned short * &>
PUBLIC	??$assign@PAG$0A@@?$vector@GV?$xalloc@G@@@std@@QAEXPAG0@Z ; std::vector<unsigned short,xalloc<unsigned short> >::assign<unsigned short *,0>
PUBLIC	??$xr_alloc@G@@YAPAGI@Z				; xr_alloc<unsigned short>
PUBLIC	??$xr_alloc@UfvfVertexIn@IRender_DetailModel@@@@YAPAUfvfVertexIn@IRender_DetailModel@@I@Z ; xr_alloc<IRender_DetailModel::fvfVertexIn>
PUBLIC	??$xr_free@G@@YAXAAPAG@Z			; xr_free<unsigned short>
PUBLIC	??$xr_free@UfvfVertexIn@IRender_DetailModel@@@@YAXAAPAUfvfVertexIn@IRender_DetailModel@@@Z ; xr_free<IRender_DetailModel::fvfVertexIn>
PUBLIC	?_Verify_offset@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@G@std@@@std@@@std@@QBEXH@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned short> > >::_Verify_offset
PUBLIC	?_Verify_offset@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UfvfVertexIn@IRender_DetailModel@@@std@@@std@@@std@@QBEXH@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<IRender_DetailModel::fvfVertexIn> > >::_Verify_offset
PUBLIC	?_Get_first@?$_Compressed_pair@V?$xalloc@G@@V?$_Vector_val@U?$_Simple_types@G@std@@@std@@$00@std@@QAEAAV?$xalloc@G@@XZ ; std::_Compressed_pair<xalloc<unsigned short>,std::_Vector_val<std::_Simple_types<unsigned short> >,1>::_Get_first
PUBLIC	??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@G@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned short> > >::operator+=
PUBLIC	?_Get_first@?$_Compressed_pair@V?$xalloc@UfvfVertexIn@IRender_DetailModel@@@@V?$_Vector_val@U?$_Simple_types@UfvfVertexIn@IRender_DetailModel@@@std@@@std@@$00@std@@QAEAAV?$xalloc@UfvfVertexIn@IRender_DetailModel@@@@XZ ; std::_Compressed_pair<xalloc<IRender_DetailModel::fvfVertexIn>,std::_Vector_val<std::_Simple_types<IRender_DetailModel::fvfVertexIn> >,1>::_Get_first
PUBLIC	??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UfvfVertexIn@IRender_DetailModel@@@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<IRender_DetailModel::fvfVertexIn> > >::operator+=
PUBLIC	?deallocate@?$xalloc@G@@QBEXPAGI@Z		; xalloc<unsigned short>::deallocate
PUBLIC	?_Destroy@?$vector@GV?$xalloc@G@@@std@@AAEXPAG0@Z ; std::vector<unsigned short,xalloc<unsigned short> >::_Destroy
PUBLIC	?_Getal@?$vector@GV?$xalloc@G@@@std@@AAEAAV?$xalloc@G@@XZ ; std::vector<unsigned short,xalloc<unsigned short> >::_Getal
PUBLIC	??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@G@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned short> > >::operator+=
PUBLIC	?deallocate@?$xalloc@UfvfVertexIn@IRender_DetailModel@@@@QBEXPAUfvfVertexIn@IRender_DetailModel@@I@Z ; xalloc<IRender_DetailModel::fvfVertexIn>::deallocate
PUBLIC	?_Destroy@?$vector@UfvfVertexIn@IRender_DetailModel@@V?$xalloc@UfvfVertexIn@IRender_DetailModel@@@@@std@@AAEXPAUfvfVertexIn@IRender_DetailModel@@0@Z ; std::vector<IRender_DetailModel::fvfVertexIn,xalloc<IRender_DetailModel::fvfVertexIn> >::_Destroy
PUBLIC	?_Getal@?$vector@UfvfVertexIn@IRender_DetailModel@@V?$xalloc@UfvfVertexIn@IRender_DetailModel@@@@@std@@AAEAAV?$xalloc@UfvfVertexIn@IRender_DetailModel@@@@XZ ; std::vector<IRender_DetailModel::fvfVertexIn,xalloc<IRender_DetailModel::fvfVertexIn> >::_Getal
PUBLIC	??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UfvfVertexIn@IRender_DetailModel@@@std@@@std@@@std@@QAE@PAUfvfVertexIn@IRender_DetailModel@@PBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<IRender_DetailModel::fvfVertexIn> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<IRender_DetailModel::fvfVertexIn> > >
PUBLIC	??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UfvfVertexIn@IRender_DetailModel@@@std@@@std@@@std@@QBEABUfvfVertexIn@IRender_DetailModel@@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<IRender_DetailModel::fvfVertexIn> > >::operator*
PUBLIC	??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UfvfVertexIn@IRender_DetailModel@@@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<IRender_DetailModel::fvfVertexIn> > >::operator+=
PUBLIC	??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UfvfVertexIn@IRender_DetailModel@@@std@@@std@@@std@@QAE@PAUfvfVertexIn@IRender_DetailModel@@PBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<IRender_DetailModel::fvfVertexIn> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<IRender_DetailModel::fvfVertexIn> > >
PUBLIC	??0?$vector@GV?$xalloc@G@@@std@@QAE@XZ		; std::vector<unsigned short,xalloc<unsigned short> >::vector<unsigned short,xalloc<unsigned short> >
PUBLIC	?size@?$vector@GV?$xalloc@G@@@std@@QBEIXZ	; std::vector<unsigned short,xalloc<unsigned short> >::size
PUBLIC	?_Tidy@?$vector@GV?$xalloc@G@@@std@@AAEXXZ	; std::vector<unsigned short,xalloc<unsigned short> >::_Tidy
PUBLIC	??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@G@std@@@std@@@std@@QAE@PAGPBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned short> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned short> > >
PUBLIC	??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@G@std@@@std@@@std@@QBEABGXZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned short> > >::operator*
PUBLIC	??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@G@std@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned short> > >::operator+
PUBLIC	??0?$vector@UfvfVertexIn@IRender_DetailModel@@V?$xalloc@UfvfVertexIn@IRender_DetailModel@@@@@std@@QAE@XZ ; std::vector<IRender_DetailModel::fvfVertexIn,xalloc<IRender_DetailModel::fvfVertexIn> >::vector<IRender_DetailModel::fvfVertexIn,xalloc<IRender_DetailModel::fvfVertexIn> >
PUBLIC	?begin@?$vector@UfvfVertexIn@IRender_DetailModel@@V?$xalloc@UfvfVertexIn@IRender_DetailModel@@@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UfvfVertexIn@IRender_DetailModel@@@std@@@std@@@2@XZ ; std::vector<IRender_DetailModel::fvfVertexIn,xalloc<IRender_DetailModel::fvfVertexIn> >::begin
PUBLIC	?size@?$vector@UfvfVertexIn@IRender_DetailModel@@V?$xalloc@UfvfVertexIn@IRender_DetailModel@@@@@std@@QBEIXZ ; std::vector<IRender_DetailModel::fvfVertexIn,xalloc<IRender_DetailModel::fvfVertexIn> >::size
PUBLIC	?_Tidy@?$vector@UfvfVertexIn@IRender_DetailModel@@V?$xalloc@UfvfVertexIn@IRender_DetailModel@@@@@std@@AAEXXZ ; std::vector<IRender_DetailModel::fvfVertexIn,xalloc<IRender_DetailModel::fvfVertexIn> >::_Tidy
PUBLIC	??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UfvfVertexIn@IRender_DetailModel@@@std@@@std@@@std@@QBEAAUfvfVertexIn@IRender_DetailModel@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<IRender_DetailModel::fvfVertexIn> > >::operator*
PUBLIC	??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UfvfVertexIn@IRender_DetailModel@@@std@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<IRender_DetailModel::fvfVertexIn> > >::operator+
PUBLIC	??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@G@std@@@std@@@std@@QAE@PAGPBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned short> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned short> > >
PUBLIC	??1?$vector@GV?$xalloc@G@@@std@@QAE@XZ		; std::vector<unsigned short,xalloc<unsigned short> >::~vector<unsigned short,xalloc<unsigned short> >
PUBLIC	?resize@?$vector@GV?$xalloc@G@@@std@@QAEXI@Z	; std::vector<unsigned short,xalloc<unsigned short> >::resize
PUBLIC	?begin@?$vector@GV?$xalloc@G@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@G@std@@@std@@@2@XZ ; std::vector<unsigned short,xalloc<unsigned short> >::begin
PUBLIC	??0?$xr_vector@GV?$xalloc@G@@@@QAE@XZ		; xr_vector<unsigned short,xalloc<unsigned short> >::xr_vector<unsigned short,xalloc<unsigned short> >
PUBLIC	?size@?$xr_vector@GV?$xalloc@G@@@@QBEIXZ	; xr_vector<unsigned short,xalloc<unsigned short> >::size
PUBLIC	??A?$xr_vector@GV?$xalloc@G@@@@QAEAAGI@Z	; xr_vector<unsigned short,xalloc<unsigned short> >::operator[]
PUBLIC	?assign@?$_flags@I@@QAEAAU1@I@Z			; _flags<unsigned int>::assign
PUBLIC	??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@G@std@@@std@@@std@@QBEAAGXZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned short> > >::operator*
PUBLIC	??1?$vector@UfvfVertexIn@IRender_DetailModel@@V?$xalloc@UfvfVertexIn@IRender_DetailModel@@@@@std@@QAE@XZ ; std::vector<IRender_DetailModel::fvfVertexIn,xalloc<IRender_DetailModel::fvfVertexIn> >::~vector<IRender_DetailModel::fvfVertexIn,xalloc<IRender_DetailModel::fvfVertexIn> >
PUBLIC	??0?$xr_vector@UfvfVertexIn@IRender_DetailModel@@V?$xalloc@UfvfVertexIn@IRender_DetailModel@@@@@@QAE@XZ ; xr_vector<IRender_DetailModel::fvfVertexIn,xalloc<IRender_DetailModel::fvfVertexIn> >::xr_vector<IRender_DetailModel::fvfVertexIn,xalloc<IRender_DetailModel::fvfVertexIn> >
PUBLIC	?size@?$xr_vector@UfvfVertexIn@IRender_DetailModel@@V?$xalloc@UfvfVertexIn@IRender_DetailModel@@@@@@QBEIXZ ; xr_vector<IRender_DetailModel::fvfVertexIn,xalloc<IRender_DetailModel::fvfVertexIn> >::size
PUBLIC	??A?$xr_vector@UfvfVertexIn@IRender_DetailModel@@V?$xalloc@UfvfVertexIn@IRender_DetailModel@@@@@@QAEAAUfvfVertexIn@IRender_DetailModel@@I@Z ; xr_vector<IRender_DetailModel::fvfVertexIn,xalloc<IRender_DetailModel::fvfVertexIn> >::operator[]
PUBLIC	??1?$xr_vector@UfvfVertexIn@IRender_DetailModel@@V?$xalloc@UfvfVertexIn@IRender_DetailModel@@@@@@QAE@XZ ; xr_vector<IRender_DetailModel::fvfVertexIn,xalloc<IRender_DetailModel::fvfVertexIn> >::~xr_vector<IRender_DetailModel::fvfVertexIn,xalloc<IRender_DetailModel::fvfVertexIn> >
PUBLIC	??1?$xr_vector@GV?$xalloc@G@@@@QAE@XZ		; xr_vector<unsigned short,xalloc<unsigned short> >::~xr_vector<unsigned short,xalloc<unsigned short> >
PUBLIC	?Optimize@CDetail@@QAEXXZ			; CDetail::Optimize
PUBLIC	?Load@CDetail@@QAEXPAVIReader@@@Z		; CDetail::Load
PUBLIC	?Unload@CDetail@@UAEXXZ				; CDetail::Unload
PUBLIC	??1CDetail@@UAE@XZ				; CDetail::~CDetail
PUBLIC	?transfer@CDetail@@UAEXAAU?$_matrix@M@@PAUfvfVertexOut@IRender_DetailModel@@IPAGIMM@Z ; CDetail::transfer
PUBLIC	?transfer@CDetail@@UAEXAAU?$_matrix@M@@PAUfvfVertexOut@IRender_DetailModel@@IPAGI@Z ; CDetail::transfer
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@GV?$xalloc@G@@@std@@AAEXIABU_Value_init_tag@1@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@GV?$xalloc@G@@@std@@AAEXIABU_Value_init_tag@1@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@GV?$xalloc@G@@@std@@AAEXIABU_Value_init_tag@1@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
__unwindtable$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@GV?$xalloc@G@@@std@@AAEXIABU_Value_init_tag@1@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@GV?$xalloc@G@@@std@@AAEXIABU_Value_init_tag@1@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@GV?$xalloc@G@@@std@@AAEXIABU_Value_init_tag@1@@Z$2
__catchsym$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@GV?$xalloc@G@@@std@@AAEXIABU_Value_init_tag@1@@Z$2 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@GV?$xalloc@G@@@std@@AAEXIABU_Value_init_tag@1@@Z$0
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailModel.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailModel.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailModel.cpp
_TEXT	SEGMENT
_mXform$ = 8						; size = 4
_vDest$ = 12						; size = 4
_C$ = 16						; size = 4
_iDest$ = 20						; size = 4
_iOffset$ = 24						; size = 4
?transfer@CDetail@@UAEXAAU?$_matrix@M@@PAUfvfVertexOut@IRender_DetailModel@@IPAGI@Z PROC ; CDetail::transfer
; _this$ = ecx

; 17   : {

	push	ebx
	push	esi
	push	edi
	mov	edi, ecx

; 18   : 	// Transfer vertices
; 19   : 	{
; 20   : 		CDetail::fvfVertexIn	*srcIt = vertices, *srcEnd = vertices+number_vertices;

	mov	eax, DWORD PTR [edi+64]
	mov	edx, DWORD PTR [edi+60]
	lea	eax, DWORD PTR [eax+eax*4]
	lea	esi, DWORD PTR [edx+eax*4]

; 21   : 		CDetail::fvfVertexOut	*dstIt = vDest;
; 22   : 		for	(; srcIt!=srcEnd; srcIt++, dstIt++)

	cmp	edx, esi
	je	$LN7@transfer

; 18   : 	// Transfer vertices
; 19   : 	{
; 20   : 		CDetail::fvfVertexIn	*srcIt = vertices, *srcEnd = vertices+number_vertices;

	mov	eax, DWORD PTR _vDest$[esp+8]
	mov	ecx, DWORD PTR _mXform$[esp+8]
	add	eax, 8
	mov	ebx, DWORD PTR _C$[esp+8]
	npad	8
$LL4@transfer:
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 499  : 		dest.x = v.x*_11 + v.y*_21 + v.z*_31 + _41;

	movss	xmm1, DWORD PTR [edx]
	mulss	xmm1, DWORD PTR [ecx]
	movss	xmm0, DWORD PTR [ecx+16]
	mulss	xmm0, DWORD PTR [edx+4]
	addss	xmm1, xmm0
	movss	xmm0, DWORD PTR [edx+8]
	mulss	xmm0, DWORD PTR [ecx+32]
	addss	xmm0, DWORD PTR [ecx+48]
	addss	xmm1, xmm0
	movss	DWORD PTR [eax-8], xmm1

; 500  : 		dest.y = v.x*_12 + v.y*_22 + v.z*_32 + _42;

	movss	xmm1, DWORD PTR [edx]
	mulss	xmm1, DWORD PTR [ecx+4]
	movss	xmm0, DWORD PTR [edx+4]
	mulss	xmm0, DWORD PTR [ecx+20]
	addss	xmm1, xmm0
	movss	xmm0, DWORD PTR [edx+8]
	mulss	xmm0, DWORD PTR [ecx+36]
	addss	xmm0, DWORD PTR [ecx+52]
	addss	xmm1, xmm0
	movss	DWORD PTR [eax-4], xmm1

; 501  : 		dest.z = v.x*_13 + v.y*_23 + v.z*_33 + _43;

	movss	xmm0, DWORD PTR [edx+4]
	movss	xmm1, DWORD PTR [edx]
	mulss	xmm0, DWORD PTR [ecx+24]
	mulss	xmm1, DWORD PTR [ecx+8]
	addss	xmm1, xmm0
	movss	xmm0, DWORD PTR [edx+8]
	mulss	xmm0, DWORD PTR [ecx+40]
	addss	xmm0, DWORD PTR [ecx+56]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailModel.cpp

; 25   : 			dstIt->C	= C;

	mov	DWORD PTR [eax+4], ebx
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 501  : 		dest.z = v.x*_13 + v.y*_23 + v.z*_33 + _43;

	addss	xmm1, xmm0
	movss	DWORD PTR [eax], xmm1
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailModel.cpp

; 26   : 			dstIt->u	= srcIt->u;

	fld	DWORD PTR [edx+12]
	fstp	DWORD PTR [eax+8]

; 27   : 			dstIt->v	= srcIt->v;

	fld	DWORD PTR [edx+16]
	add	edx, 20					; 00000014H
	fstp	DWORD PTR [eax+12]
	add	eax, 24					; 00000018H
	cmp	edx, esi
	jne	$LL4@transfer
$LN7@transfer:

; 28   : 		}
; 29   : 	}
; 30   : 	
; 31   : 	// Transfer indices (in 32bit lines)
; 32   : 	VERIFY	(iOffset<65535);
; 33   : 	{
; 34   : 		u32	item	= (iOffset<<16) | iOffset;
; 35   : 		u32	count	= number_indices/2;

	mov	ebx, DWORD PTR [edi+72]
	mov	eax, ebx

; 36   : 		LPDWORD	sit		= LPDWORD(indices);

	mov	ecx, DWORD PTR [edi+68]
	mov	esi, DWORD PTR _iOffset$[esp+8]

; 37   : 		LPDWORD	send	= sit+count;
; 38   : 		LPDWORD	dit		= LPDWORD(iDest);

	mov	edx, DWORD PTR _iDest$[esp+8]
	shr	eax, 1
	shl	esi, 16					; 00000010H
	or	esi, DWORD PTR _iOffset$[esp+8]
	push	ebp
	lea	ebp, DWORD PTR [ecx+eax*4]

; 39   : 		for		(; sit!=send; dit++,sit++)	*dit=*sit+item;

	cmp	ecx, ebp
	je	SHORT $LN9@transfer
	npad	7
$LL10@transfer:
	mov	eax, DWORD PTR [ecx]
	lea	edx, DWORD PTR [edx+4]
	add	eax, esi
	add	ecx, 4
	mov	DWORD PTR [edx-4], eax
	cmp	ecx, ebp
	jne	SHORT $LL10@transfer
	mov	ebx, DWORD PTR [edi+72]
$LN9@transfer:

; 40   : 		if		(number_indices&1)	

	pop	ebp
	test	bl, 1
	je	SHORT $LN11@transfer

; 41   : 			iDest[number_indices-1]=u16(indices[number_indices-1]+u16(iOffset));

	mov	eax, DWORD PTR [edi+68]
	mov	ecx, DWORD PTR _iDest$[esp+8]
	mov	ax, WORD PTR [eax+ebx*2-2]
	add	ax, WORD PTR _iOffset$[esp+8]
	mov	WORD PTR [ecx+ebx*2-2], ax
$LN11@transfer:

; 42   : 	}
; 43   : }

	pop	edi
	pop	esi
	pop	ebx
	ret	20					; 00000014H
?transfer@CDetail@@UAEXAAU?$_matrix@M@@PAUfvfVertexOut@IRender_DetailModel@@IPAGI@Z ENDP ; CDetail::transfer
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailModel.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailModel.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailModel.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailModel.cpp
_TEXT	SEGMENT
_mXform$ = 8						; size = 4
_vDest$ = 12						; size = 4
_C$ = 16						; size = 4
_iDest$ = 20						; size = 4
_iOffset$ = 24						; size = 4
_du$ = 28						; size = 4
_dv$ = 32						; size = 4
?transfer@CDetail@@UAEXAAU?$_matrix@M@@PAUfvfVertexOut@IRender_DetailModel@@IPAGIMM@Z PROC ; CDetail::transfer
; _this$ = ecx

; 46   : {

	push	ebx
	push	esi
	push	edi
	mov	edi, ecx

; 47   : 	// Transfer vertices
; 48   : 	{
; 49   : 		CDetail::fvfVertexIn	*srcIt = vertices, *srcEnd = vertices+number_vertices;

	mov	eax, DWORD PTR [edi+64]
	mov	edx, DWORD PTR [edi+60]
	lea	eax, DWORD PTR [eax+eax*4]
	lea	esi, DWORD PTR [edx+eax*4]

; 50   : 		CDetail::fvfVertexOut	*dstIt = vDest;
; 51   : 		for	(; srcIt!=srcEnd; srcIt++, dstIt++)

	cmp	edx, esi
	je	$LN7@transfer

; 47   : 	// Transfer vertices
; 48   : 	{
; 49   : 		CDetail::fvfVertexIn	*srcIt = vertices, *srcEnd = vertices+number_vertices;

	mov	eax, DWORD PTR _vDest$[esp+8]
	mov	ecx, DWORD PTR _mXform$[esp+8]
	add	eax, 8
	movss	xmm2, DWORD PTR _dv$[esp+8]
	movss	xmm3, DWORD PTR _du$[esp+8]
	mov	ebx, DWORD PTR _C$[esp+8]
	npad	12
$LL4@transfer:
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 499  : 		dest.x = v.x*_11 + v.y*_21 + v.z*_31 + _41;

	movss	xmm1, DWORD PTR [edx]
	mulss	xmm1, DWORD PTR [ecx]
	movss	xmm0, DWORD PTR [edx+4]
	mulss	xmm0, DWORD PTR [ecx+16]
	addss	xmm1, xmm0
	movss	xmm0, DWORD PTR [ecx+32]
	mulss	xmm0, DWORD PTR [edx+8]
	addss	xmm0, DWORD PTR [ecx+48]
	addss	xmm1, xmm0
	movss	DWORD PTR [eax-8], xmm1

; 500  : 		dest.y = v.x*_12 + v.y*_22 + v.z*_32 + _42;

	movss	xmm1, DWORD PTR [edx+4]
	mulss	xmm1, DWORD PTR [ecx+20]
	movss	xmm0, DWORD PTR [edx]
	mulss	xmm0, DWORD PTR [ecx+4]
	addss	xmm1, xmm0
	movss	xmm0, DWORD PTR [edx+8]
	mulss	xmm0, DWORD PTR [ecx+36]
	addss	xmm0, DWORD PTR [ecx+52]
	addss	xmm1, xmm0
	movss	DWORD PTR [eax-4], xmm1

; 501  : 		dest.z = v.x*_13 + v.y*_23 + v.z*_33 + _43;

	movss	xmm0, DWORD PTR [edx]
	mulss	xmm0, DWORD PTR [ecx+8]
	movss	xmm1, DWORD PTR [edx+4]
	mulss	xmm1, DWORD PTR [ecx+24]
	addss	xmm1, xmm0
	movss	xmm0, DWORD PTR [edx+8]
	mulss	xmm0, DWORD PTR [ecx+40]
	addss	xmm0, DWORD PTR [ecx+56]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailModel.cpp

; 54   : 			dstIt->C	= C;

	mov	DWORD PTR [eax+4], ebx
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 501  : 		dest.z = v.x*_13 + v.y*_23 + v.z*_33 + _43;

	addss	xmm1, xmm0
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailModel.cpp

; 55   : 			dstIt->u	= srcIt->u+du;

	movaps	xmm0, xmm3
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 501  : 		dest.z = v.x*_13 + v.y*_23 + v.z*_33 + _43;

	movss	DWORD PTR [eax], xmm1
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailModel.cpp

; 55   : 			dstIt->u	= srcIt->u+du;

	addss	xmm0, DWORD PTR [edx+12]
	movss	DWORD PTR [eax+8], xmm0

; 56   : 			dstIt->v	= srcIt->v+dv;

	movaps	xmm0, xmm2
	addss	xmm0, DWORD PTR [edx+16]
	add	edx, 20					; 00000014H
	movss	DWORD PTR [eax+12], xmm0
	add	eax, 24					; 00000018H
	cmp	edx, esi
	jne	$LL4@transfer
$LN7@transfer:

; 57   : 		}
; 58   : 	}
; 59   : 	
; 60   : 	// Transfer indices (in 32bit lines)
; 61   : 	VERIFY	(iOffset<65535);
; 62   : 	{
; 63   : 		u32	item	= (iOffset<<16) | iOffset;
; 64   : 		u32	count	= number_indices/2;

	mov	ebx, DWORD PTR [edi+72]
	mov	eax, ebx

; 65   : 		LPDWORD	sit		= LPDWORD(indices);

	mov	ecx, DWORD PTR [edi+68]
	mov	esi, DWORD PTR _iOffset$[esp+8]

; 66   : 		LPDWORD	send	= sit+count;
; 67   : 		LPDWORD	dit		= LPDWORD(iDest);

	mov	edx, DWORD PTR _iDest$[esp+8]
	shr	eax, 1
	shl	esi, 16					; 00000010H
	or	esi, DWORD PTR _iOffset$[esp+8]
	push	ebp
	lea	ebp, DWORD PTR [ecx+eax*4]

; 68   : 		for		(; sit!=send; dit++,sit++)	*dit=*sit+item;

	cmp	ecx, ebp
	je	SHORT $LN9@transfer
$LL10@transfer:
	mov	eax, DWORD PTR [ecx]
	lea	edx, DWORD PTR [edx+4]
	add	eax, esi
	add	ecx, 4
	mov	DWORD PTR [edx-4], eax
	cmp	ecx, ebp
	jne	SHORT $LL10@transfer
	mov	ebx, DWORD PTR [edi+72]
$LN9@transfer:

; 69   : 		if		(number_indices&1)	

	pop	ebp
	test	bl, 1
	je	SHORT $LN11@transfer

; 70   : 			iDest[number_indices-1]=u16(indices[number_indices-1]+u16(iOffset));

	mov	eax, DWORD PTR [edi+68]
	mov	ecx, DWORD PTR _iDest$[esp+8]
	mov	ax, WORD PTR [eax+ebx*2-2]
	add	ax, WORD PTR _iOffset$[esp+8]
	mov	WORD PTR [ecx+ebx*2-2], ax
$LN11@transfer:

; 71   : 	}
; 72   : }

	pop	edi
	pop	esi
	pop	ebx
	ret	28					; 0000001cH
?transfer@CDetail@@UAEXAAU?$_matrix@M@@PAUfvfVertexOut@IRender_DetailModel@@IPAGIMM@Z ENDP ; CDetail::transfer
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailModel.cpp
_TEXT	SEGMENT
??1CDetail@@UAE@XZ PROC					; CDetail::~CDetail
; _this$ = ecx

; 6    : {

	mov	DWORD PTR [ecx], OFFSET ??_7CDetail@@6B@

; 7    : }

	jmp	DWORD PTR __imp_??1IRender_DetailModel@@UAE@XZ
??1CDetail@@UAE@XZ ENDP					; CDetail::~CDetail
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailModel.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailModel.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailModel.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailModel.cpp
_TEXT	SEGMENT
?Unload@CDetail@@UAEXXZ PROC				; CDetail::Unload
; _this$ = ecx

; 10   : {

	push	esi
	mov	esi, ecx

; 11   : 	if (vertices)		{ xr_free(vertices);	vertices=0; }

	mov	eax, DWORD PTR [esi+60]
	test	eax, eax
	je	SHORT $LN2@Unload
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailModel.cpp

; 11   : 	if (vertices)		{ xr_free(vertices);	vertices=0; }

	mov	DWORD PTR [esi+60], 0
$LN2@Unload:

; 12   : 	if (indices)		{ xr_free(indices);		indices=0;	}

	mov	eax, DWORD PTR [esi+68]
	test	eax, eax
	je	SHORT $LN3@Unload
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailModel.cpp

; 12   : 	if (indices)		{ xr_free(indices);		indices=0;	}

	mov	DWORD PTR [esi+68], 0
$LN3@Unload:
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 46   : 	ICF		void		_set	(T * rhs) 							{	if (0!=rhs) rhs->dwReference++;	_dec(); p_ = rhs;											}

	lea	ecx, DWORD PTR [esi+56]
	call	DWORD PTR __imp_?_dec@?$resptr_base@UShader@@@@IAEXXZ
	mov	DWORD PTR [esi+56], 0
	pop	esi
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailModel.cpp

; 14   : }

	ret	0
?Unload@CDetail@@UAEXXZ ENDP				; CDetail::Unload
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailModel.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_flags.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailModel.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailModel.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailModel.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailModel.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailModel.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailModel.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailModel.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_std_extensions.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_std_extensions.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_std_extensions.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_std_extensions.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_std_extensions.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_std_extensions.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailModel.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailModel.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailModel.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailModel.cpp
_TEXT	SEGMENT
_fnT$ = -512						; size = 256
_fnS$ = -256						; size = 256
_S$ = 8							; size = 4
?Load@CDetail@@QAEXPAVIReader@@@Z PROC			; CDetail::Load
; _this$ = ecx

; 75   : {

	sub	esp, 512				; 00000200H

; 76   : 	// Shader
; 77   : 	string256		fnT,fnS;
; 78   : 	S->r_stringZ	(fnS,sizeof(fnS));

	lea	eax, DWORD PTR _fnS$[esp+512]
	push	ebp
	push	esi
	mov	esi, DWORD PTR __imp_?r_stringZ@IReader@@QAEXPADI@Z
	mov	ebp, ecx
	push	edi
	mov	edi, DWORD PTR _S$[esp+520]
	mov	ecx, edi
	push	256					; 00000100H
	push	eax
	call	esi

; 79   : 	S->r_stringZ	(fnT,sizeof(fnT));

	push	256					; 00000100H
	lea	eax, DWORD PTR _fnT$[esp+528]
	mov	ecx, edi
	push	eax
	call	esi

; 80   : 	shader.create	(fnS,	fnT);

	push	0
	push	0
	lea	eax, DWORD PTR _fnT$[esp+532]
	push	eax
	lea	eax, DWORD PTR _fnS$[esp+536]
	push	eax
	lea	ecx, DWORD PTR [ebp+56]
	call	DWORD PTR __imp_?create@resptrcode_shader@@QAEXPBD000@Z

; 81   : 
; 82   : 	// Params
; 83   : 	m_Flags.assign	(S->r_u32	());

	mov	ecx, edi
	call	DWORD PTR __imp_?r_u32@?$IReaderBase@VIReader@@@@QAEIXZ

; 84   : 	m_fMinScale		= S->r_float();

	mov	ecx, edi
; File I:\Vitalya\mine\NSProjectX\xrCore\_flags.h

; 21   : 	IC	SelfRef	assign	(const T mask)								{ flags	=	mask;		return *this;	}

	mov	DWORD PTR [ebp+44], eax
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailModel.cpp

; 84   : 	m_fMinScale		= S->r_float();

	call	DWORD PTR __imp_?r_float@?$IReaderBase@VIReader@@@@QAEMXZ
	fstp	DWORD PTR [ebp+48]

; 85   : 	m_fMaxScale		= S->r_float();

	mov	ecx, edi
	call	DWORD PTR __imp_?r_float@?$IReaderBase@VIReader@@@@QAEMXZ

; 86   : 	number_vertices	= S->r_u32	();

	mov	ecx, edi
	fstp	DWORD PTR [ebp+52]
	call	DWORD PTR __imp_?r_u32@?$IReaderBase@VIReader@@@@QAEIXZ

; 87   : 	number_indices	= S->r_u32	();

	mov	ecx, edi
	mov	DWORD PTR [ebp+64], eax
	call	DWORD PTR __imp_?r_u32@?$IReaderBase@VIReader@@@@QAEIXZ
	mov	DWORD PTR [ebp+72], eax

; 88   : 	R_ASSERT		(0==(number_indices%3));

	cmp	BYTE PTR ?ignore_always@?3??Load@CDetail@@QAEXPAVIReader@@@Z@4_NA, 0
	jne	SHORT $LN2@Load
	xor	edx, edx
	mov	ecx, 3
	div	ecx
	test	edx, edx
	je	SHORT $LN2@Load
	mov	ecx, DWORD PTR __imp_?Debug@@3VxrDebug@@A
	push	OFFSET ?ignore_always@?3??Load@CDetail@@QAEXPAVIReader@@@Z@4_NA
	push	OFFSET ??_C@_0O@MGDDPLHN@CDetail?3?3Load@
	push	88					; 00000058H
	push	OFFSET ??_C@_0DL@GJHFBGFO@I?3?2Vitalya?2mine?2NSProjectX?2laye@
	push	OFFSET ??_C@_0BG@MKHFKJHC@0?$DN?$DN?$CInumber_indices?$CF3?$CJ@
	call	DWORD PTR __imp_?fail@xrDebug@@QAEXPBD0H0AA_N@Z
$LN2@Load:

; 91   : 	u32				size_vertices		= number_vertices*sizeof(fvfVertexIn); 

	mov	eax, DWORD PTR [ebp+64]
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailModel.cpp

; 91   : 	u32				size_vertices		= number_vertices*sizeof(fvfVertexIn); 

	lea	esi, DWORD PTR [eax+eax*4]
	shl	esi, 2
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	push	esi
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailModel.cpp

; 93   : 	S->r			(vertices,size_vertices);

	push	esi
	mov	ecx, edi
	mov	DWORD PTR [ebp+60], eax
	mov	edi, DWORD PTR __imp_?r@IReader@@QAEXPAXH@Z
	push	eax
	call	edi

; 96   : 	u32				size_indices		= number_indices*sizeof(u16);

	mov	esi, DWORD PTR [ebp+72]
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailModel.cpp

; 96   : 	u32				size_indices		= number_indices*sizeof(u16);

	add	esi, esi
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	push	esi
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailModel.cpp

; 98   : 	S->r			(indices,size_indices);

	mov	ecx, DWORD PTR _S$[esp+520]
	push	esi
	push	eax
	mov	DWORD PTR [ebp+68], eax
	call	edi

; 108  : 	for (u32 i=0; i<number_vertices; i++)

	xor	edx, edx
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 23   : 	ICF	SelfRef	set(T _x, T _y, T _z)					{ x = _x;		y = _y;		z = _z;		return *this;	};

	mov	DWORD PTR [ebp+20], 2139095039		; 7f7fffffH
	mov	DWORD PTR [ebp+24], 2139095039		; 7f7fffffH
	mov	DWORD PTR [ebp+28], 2139095039		; 7f7fffffH
	mov	DWORD PTR [ebp+32], -8388609		; ff7fffffH
	mov	DWORD PTR [ebp+36], -8388609		; ff7fffffH
	mov	DWORD PTR [ebp+40], -8388609		; ff7fffffH
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailModel.cpp

; 108  : 	for (u32 i=0; i<number_vertices; i++)

	cmp	DWORD PTR [ebp+64], edx
	jbe	$LN79@Load

; 91   : 	u32				size_vertices		= number_vertices*sizeof(fvfVertexIn); 

	xor	ecx, ecx
	npad	4
$LL7@Load:

; 109  : 		bv_bb.modify	(vertices[i].P);

	mov	eax, DWORD PTR [ebp+60]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 53   : 	IC	SelfRef	min(const Self &v)						{ x = _min(x,v.x);	y = _min(y,v.y);	z = _min(z,v.z);			return *this;	}

	movss	xmm0, DWORD PTR [ebp+20]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailModel.cpp

; 109  : 		bv_bb.modify	(vertices[i].P);

	add	eax, ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 53   : 	IC	SelfRef	min(const Self &v)						{ x = _min(x,v.x);	y = _min(y,v.y);	z = _min(z,v.z);			return *this;	}

	movss	xmm1, DWORD PTR [eax]
; File I:\Vitalya\mine\NSProjectX\xrCore\_std_extensions.h

; 93   : template <class T>	IC T		_min	(T a, T b)	{ return a<b?a:b;	}

	comiss	xmm1, xmm0
	ja	SHORT $LN41@Load
	movaps	xmm0, xmm1
$LN41@Load:
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 53   : 	IC	SelfRef	min(const Self &v)						{ x = _min(x,v.x);	y = _min(y,v.y);	z = _min(z,v.z);			return *this;	}

	movss	DWORD PTR [ebp+20], xmm0
	movss	xmm0, DWORD PTR [ebp+24]
	movss	xmm1, DWORD PTR [eax+4]
; File I:\Vitalya\mine\NSProjectX\xrCore\_std_extensions.h

; 93   : template <class T>	IC T		_min	(T a, T b)	{ return a<b?a:b;	}

	comiss	xmm1, xmm0
	ja	SHORT $LN45@Load
	movaps	xmm0, xmm1
$LN45@Load:
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 53   : 	IC	SelfRef	min(const Self &v)						{ x = _min(x,v.x);	y = _min(y,v.y);	z = _min(z,v.z);			return *this;	}

	movss	DWORD PTR [ebp+24], xmm0
	movss	xmm0, DWORD PTR [ebp+28]
	movss	xmm1, DWORD PTR [eax+8]
; File I:\Vitalya\mine\NSProjectX\xrCore\_std_extensions.h

; 93   : template <class T>	IC T		_min	(T a, T b)	{ return a<b?a:b;	}

	comiss	xmm1, xmm0
	ja	SHORT $LN49@Load
	movaps	xmm0, xmm1
$LN49@Load:
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 53   : 	IC	SelfRef	min(const Self &v)						{ x = _min(x,v.x);	y = _min(y,v.y);	z = _min(z,v.z);			return *this;	}

	movss	DWORD PTR [ebp+28], xmm0

; 55   : 	IC	SelfRef	max(const Self &v)						{ x = _max(x,v.x);	y = _max(y,v.y);	z = _max(z,v.z);			return *this;	}

	movss	xmm0, DWORD PTR [ebp+32]
	movss	xmm1, DWORD PTR [eax]
; File I:\Vitalya\mine\NSProjectX\xrCore\_std_extensions.h

; 94   : template <class T>	IC T		_max	(T a, T b)	{ return a>b?a:b;	}

	comiss	xmm0, xmm1
	ja	SHORT $LN55@Load
	movaps	xmm0, xmm1
$LN55@Load:
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 55   : 	IC	SelfRef	max(const Self &v)						{ x = _max(x,v.x);	y = _max(y,v.y);	z = _max(z,v.z);			return *this;	}

	movss	DWORD PTR [ebp+32], xmm0
	movss	xmm0, DWORD PTR [ebp+36]
	movss	xmm1, DWORD PTR [eax+4]
; File I:\Vitalya\mine\NSProjectX\xrCore\_std_extensions.h

; 94   : template <class T>	IC T		_max	(T a, T b)	{ return a>b?a:b;	}

	comiss	xmm0, xmm1
	ja	SHORT $LN59@Load
	movaps	xmm0, xmm1
$LN59@Load:
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 55   : 	IC	SelfRef	max(const Self &v)						{ x = _max(x,v.x);	y = _max(y,v.y);	z = _max(z,v.z);			return *this;	}

	movss	DWORD PTR [ebp+36], xmm0
	movss	xmm0, DWORD PTR [ebp+40]
	movss	xmm1, DWORD PTR [eax+8]
; File I:\Vitalya\mine\NSProjectX\xrCore\_std_extensions.h

; 94   : template <class T>	IC T		_max	(T a, T b)	{ return a>b?a:b;	}

	comiss	xmm0, xmm1
	ja	SHORT $LN63@Load
	movaps	xmm0, xmm1
$LN63@Load:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailModel.cpp

; 108  : 	for (u32 i=0; i<number_vertices; i++)

	inc	edx
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 55   : 	IC	SelfRef	max(const Self &v)						{ x = _max(x,v.x);	y = _max(y,v.y);	z = _max(z,v.z);			return *this;	}

	movss	DWORD PTR [ebp+40], xmm0
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailModel.cpp

; 108  : 	for (u32 i=0; i<number_vertices; i++)

	add	ecx, 20					; 00000014H
	cmp	edx, DWORD PTR [ebp+64]
	jb	$LL7@Load
$LN79@Load:
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h

; 97   : 		C.x = (min.x + max.x) * 0.5f;

	movss	xmm3, DWORD PTR [ebp+32]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailModel.cpp

; 113  : 	Optimize	();

	mov	ecx, ebp
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h

; 97   : 		C.x = (min.x + max.x) * 0.5f;

	addss	xmm3, DWORD PTR [ebp+20]
	movss	xmm0, DWORD PTR __real@3f000000
	mulss	xmm3, xmm0
	movss	DWORD PTR [ebp+4], xmm3

; 98   : 		C.y = (min.y + max.y) * 0.5f;

	movss	xmm2, DWORD PTR [ebp+36]
	addss	xmm2, DWORD PTR [ebp+24]
	mulss	xmm2, xmm0
	movss	DWORD PTR [ebp+8], xmm2

; 99   : 		C.z = (min.z + max.z) * 0.5f;

	movss	xmm1, DWORD PTR [ebp+40]
	addss	xmm1, DWORD PTR [ebp+28]
	mulss	xmm1, xmm0
	movss	DWORD PTR [ebp+12], xmm1
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 287  : 	{	return (x-v.x)*(x-v.x) + (y-v.y)*(y-v.y) + (z-v.z)*(z-v.z);	}

	subss	xmm3, DWORD PTR [ebp+32]
	subss	xmm2, DWORD PTR [ebp+36]
	subss	xmm1, DWORD PTR [ebp+40]
	mulss	xmm3, xmm3
	mulss	xmm2, xmm2
	mulss	xmm1, xmm1
	addss	xmm3, xmm2
	addss	xmm3, xmm1
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h

; 764  :             return (float)sqrt(_X);

	sqrtss	xmm0, xmm3
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h

; 116  : 		R = C.distance_to	(max);

	movss	DWORD PTR [ebp+16], xmm0
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailModel.cpp

; 113  : 	Optimize	();

	call	?Optimize@CDetail@@QAEXXZ		; CDetail::Optimize
	pop	edi
	pop	esi
	pop	ebp

; 114  : #endif
; 115  : }

	add	esp, 512				; 00000200H
	ret	4
?Load@CDetail@@QAEXPAVIReader@@@Z ENDP			; CDetail::Load
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailModel.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailModel.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailModel.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailModel.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailModel.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailModel.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailModel.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailModel.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailModel.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailModel.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailModel.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailModel.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailModel.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailModel.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailModel.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailModel.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailModel.cpp
_TEXT	SEGMENT
_this$1$ = -32						; size = 4
tv1170 = -28						; size = 4
_vec_permute$ = -24					; size = 12
_vec_indices$ = -12					; size = 12
?Optimize@CDetail@@QAEXXZ PROC				; CDetail::Optimize
; _this$ = ecx

; 121  : {

	sub	esp, 32					; 00000020H

; 123  : 	const int			cache			= HW.Caps.geometry.dwVertexCache;

	mov	eax, DWORD PTR __imp_?HW@@3VCHW@@A
	push	ebx
	mov	ebx, ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR _vec_permute$[esp+36], 0
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailModel.cpp

; 121  : {

	push	ebp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR _vec_permute$[esp+44], 0
	mov	DWORD PTR _vec_permute$[esp+48], 0
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailModel.cpp

; 123  : 	const int			cache			= HW.Caps.geometry.dwVertexCache;

	movzx	ebp, BYTE PTR [eax+57]

; 126  : 	vec_indices.assign	(indices,indices+number_indices);

	mov	ecx, DWORD PTR [ebx+68]
	mov	eax, DWORD PTR [ebx+72]
	push	esi
	push	edi
	mov	DWORD PTR _this$1$[esp+48], ebx
	lea	eax, DWORD PTR [ecx+eax*2]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR _vec_indices$[esp+48], 0
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailModel.cpp

; 126  : 	vec_indices.assign	(indices,indices+number_indices);

	push	eax
	push	ecx
	lea	ecx, DWORD PTR _vec_indices$[esp+56]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR _vec_indices$[esp+60], 0
	mov	DWORD PTR _vec_indices$[esp+64], 0
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailModel.cpp

; 126  : 	vec_indices.assign	(indices,indices+number_indices);

	call	??$assign@PAG$0A@@?$vector@GV?$xalloc@G@@@std@@QAEXPAG0@Z ; std::vector<unsigned short,xalloc<unsigned short> >::assign<unsigned short *,0>
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1250 :         const auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);

	mov	edi, DWORD PTR _vec_permute$[esp+52]
	mov	ecx, edi
	mov	edx, DWORD PTR _vec_permute$[esp+48]
	sub	ecx, edx
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailModel.cpp

; 127  : 	vec_permute.resize	(number_vertices);

	mov	esi, DWORD PTR [ebx+64]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1250 :         const auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);

	sar	ecx, 1

; 1251 :         if (_Newsize < _Oldsize) { // trim

	cmp	esi, ecx
	jae	SHORT $LN26@Optimize

; 1252 :             const pointer _Newlast = _Myfirst + _Newsize;

	lea	eax, DWORD PTR [edx+esi*2]

; 1253 :             _Orphan_range(_Newlast, _Mylast);
; 1254 :             _Destroy(_Newlast, _Mylast);
; 1255 :             _Mylast = _Newlast;
; 1256 :             return;

	jmp	SHORT $LN218@Optimize
$LN26@Optimize:

; 1257 :         }
; 1258 : 
; 1259 :         if (_Newsize > _Oldsize) { // append

	jbe	SHORT $LN27@Optimize

; 1260 :             const auto _Oldcapacity = static_cast<size_type>(_My_data._Myend - _Myfirst);

	mov	eax, DWORD PTR _vec_permute$[esp+56]
	sub	eax, edx
	sar	eax, 1

; 1261 :             if (_Newsize > _Oldcapacity) { // reallocate

	cmp	esi, eax
	jbe	SHORT $LN28@Optimize

; 1262 :                 _Resize_reallocate(_Newsize, _Val);

	push	ecx
	push	esi
	lea	ecx, DWORD PTR _vec_permute$[esp+56]
	call	??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@GV?$xalloc@G@@@std@@AAEXIABU_Value_init_tag@1@@Z ; std::vector<unsigned short,xalloc<unsigned short> >::_Resize_reallocate<std::_Value_init_tag>

; 1263 :                 return;

	jmp	SHORT $LN27@Optimize
$LN28@Optimize:

; 1264 :             }
; 1265 : 
; 1266 :             const pointer _Oldlast = _Mylast;
; 1267 :             _Mylast                = _Ufill(_Oldlast, _Newsize - _Oldsize, _Val);

	sub	esi, ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1807 :             _Zero_range(_PFirst, _PFirst + _Count);

	add	esi, esi

; 1792 :     _CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

	push	esi
	push	0
	push	edi
	call	_memset
	add	esp, 12					; 0000000cH

; 1808 :             return _First + _Count;

	lea	eax, DWORD PTR [esi+edi]
$LN218@Optimize:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailModel.cpp

; 128  : 	int vt_old			= xrSimulate(vec_indices,cache);

	mov	DWORD PTR _vec_permute$[esp+52], eax
$LN27@Optimize:
	mov	edx, ebp
	lea	ecx, DWORD PTR _vec_indices$[esp+48]
	call	?xrSimulate@@YAHAAV?$xr_vector@GV?$xalloc@G@@@@H@Z ; xrSimulate

; 129  : 	xrStripify			(vec_indices,vec_permute,cache,0);

	push	ecx
	push	ebp
	lea	edx, DWORD PTR _vec_permute$[esp+56]
	mov	esi, eax
	lea	ecx, DWORD PTR _vec_indices$[esp+56]
	call	?xrStripify@@YAXAAV?$xr_vector@GV?$xalloc@G@@@@0HH@Z ; xrStripify
	add	esp, 8

; 130  : 	int vt_new			= xrSimulate(vec_indices,cache);

	lea	ecx, DWORD PTR _vec_indices$[esp+48]
	mov	edx, ebp
	call	?xrSimulate@@YAHAAV?$xr_vector@GV?$xalloc@G@@@@H@Z ; xrSimulate

; 131  : 	if (vt_new<vt_old)	

	mov	ebp, DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
	cmp	eax, esi
	mov	esi, DWORD PTR _vec_indices$[esp+48]
	jge	$LN181@Optimize
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	eax, DWORD PTR _vec_indices$[esp+52]
	sub	eax, esi
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailModel.cpp

; 136  : 		CopyMemory			(indices,&*vec_indices.begin(),vec_indices.size()*sizeof(u16));

	and	eax, -2					; fffffffeH
	push	eax
	push	esi
	push	DWORD PTR [ebx+68]
	call	_memcpy

; 140  : 		verts.assign			(vertices,vertices+number_vertices);

	mov	eax, DWORD PTR [ebx+64]
	add	esp, 12					; 0000000cH
	mov	esi, DWORD PTR [ebx+60]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	xor	edi, edi
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailModel.cpp

; 140  : 		verts.assign			(vertices,vertices+number_vertices);

	lea	ecx, DWORD PTR [eax+eax*4]
	shl	ecx, 2
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility

; 1525 :         return _Last - _First; // assume the iterator will do debug checking

	mov	eax, ecx
	sar	eax, 2
	imul	ebx, eax, -858993459
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailModel.cpp

; 140  : 		verts.assign			(vertices,vertices+number_vertices);

	lea	ebp, DWORD PTR [esi+ecx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1153 :         if (_Newsize > _Oldsize) {

	test	ebx, ebx
	je	SHORT $LN68@Optimize

; 1337 :         if (_Newsize > max_size()) {

	cmp	ebx, 214748364				; 0cccccccH
	ja	$LN220@Optimize
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	lea	eax, DWORD PTR [ebx+ebx*4]
	shl	eax, 2
	push	eax
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
	mov	edi, eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	edx, edi

; 1658 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	esi, ebp
	je	SHORT $LN69@Optimize
	npad	1
$LL112@Optimize:
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	ecx, DWORD PTR [esi]
	mov	DWORD PTR [edx], ecx
	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [edx+4], eax
	mov	eax, DWORD PTR [esi+8]
	mov	DWORD PTR [edx+8], eax
	mov	eax, DWORD PTR [esi+12]
	mov	DWORD PTR [edx+12], eax
	mov	eax, DWORD PTR [esi+16]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1658 :     for (; _UFirst != _ULast; ++_UFirst) {

	add	esi, 20					; 00000014H
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	DWORD PTR [edx+16], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1621 :         ++_Last;

	add	edx, 20					; 00000014H

; 1658 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	esi, ebp
	jne	SHORT $LL112@Optimize
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1164 :         } else {

	jmp	SHORT $LN69@Optimize
$LN68@Optimize:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility

; 4066 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	push	ecx
	push	esi
	push	0
	call	_memmove
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1165 :             const pointer _Newlast = _Myfirst + _Newsize;

	lea	edx, DWORD PTR [ebx+ebx*4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility

; 4066 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	add	esp, 12					; 0000000cH
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1165 :             const pointer _Newlast = _Myfirst + _Newsize;

	shl	edx, 2
$LN69@Optimize:

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	sub	edx, edi
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailModel.cpp

; 141  : 		for(u32 i=0; i<verts.size(); i++)

	xor	esi, esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	sar	edx, 2
	imul	eax, edx, -858993459
	mov	DWORD PTR tv1170[esp+48], eax
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailModel.cpp

; 141  : 		for(u32 i=0; i<verts.size(); i++)

	test	eax, eax
	je	SHORT $LN3@Optimize
	mov	ebp, DWORD PTR _this$1$[esp+48]
	xor	ebx, ebx
$LL4@Optimize:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 119  :         _Ptr += _Off;

	mov	eax, DWORD PTR _vec_permute$[esp+48]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailModel.cpp

; 142  : 			vertices[i]=verts[vec_permute[i]];

	mov	edx, DWORD PTR [ebp+60]
	add	edx, ebx
	add	ebx, 20					; 00000014H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 119  :         _Ptr += _Off;

	movzx	eax, WORD PTR [eax+esi*2]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailModel.cpp

; 141  : 		for(u32 i=0; i<verts.size(); i++)

	inc	esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 119  :         _Ptr += _Off;

	lea	eax, DWORD PTR [eax+eax*4]
	lea	ecx, DWORD PTR [edi+eax*4]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailModel.cpp

; 142  : 			vertices[i]=verts[vec_permute[i]];

	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], eax
	mov	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+8], eax
	mov	eax, DWORD PTR [ecx+12]
	mov	DWORD PTR [edx+12], eax
	mov	eax, DWORD PTR [ecx+16]
	mov	DWORD PTR [edx+16], eax
	cmp	esi, DWORD PTR tv1170[esp+48]
	jb	SHORT $LL4@Optimize
$LN3@Optimize:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	ebp, DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
	test	edi, edi
	je	SHORT $LN216@Optimize
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	edi
	call	ebp
$LN216@Optimize:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	esi, DWORD PTR _vec_indices$[esp+48]
$LN181@Optimize:
	mov	eax, DWORD PTR _vec_permute$[esp+48]
	test	eax, eax
	je	SHORT $LN188@Optimize
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	ebp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR _vec_permute$[esp+48], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR _vec_permute$[esp+52], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR _vec_permute$[esp+56], 0
$LN188@Optimize:

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	test	esi, esi
	je	SHORT $LN205@Optimize
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	esi
	call	ebp
$LN205@Optimize:
	pop	edi
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailModel.cpp

; 144  : }

	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 32					; 00000020H
	ret	0
$LN220@Optimize:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1338 :             _Xlength();

	call	?_Xlength@?$vector@UfvfVertexIn@IRender_DetailModel@@V?$xalloc@UfvfVertexIn@IRender_DetailModel@@@@@std@@CAXXZ ; std::vector<IRender_DetailModel::fvfVertexIn,xalloc<IRender_DetailModel::fvfVertexIn> >::_Xlength
$LN217@Optimize:
	int	3
?Optimize@CDetail@@QAEXXZ ENDP				; CDetail::Optimize
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??1?$xr_vector@GV?$xalloc@G@@@@QAE@XZ
_TEXT	SEGMENT
??1?$xr_vector@GV?$xalloc@G@@@@QAE@XZ PROC		; xr_vector<unsigned short,xalloc<unsigned short> >::~xr_vector<unsigned short,xalloc<unsigned short> >, COMDAT
; _this$ = ecx

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	push	esi
	mov	esi, ecx
	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN6@xr_vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+4], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+8], 0
$LN6@xr_vector:
	pop	esi
	ret	0
??1?$xr_vector@GV?$xalloc@G@@@@QAE@XZ ENDP		; xr_vector<unsigned short,xalloc<unsigned short> >::~xr_vector<unsigned short,xalloc<unsigned short> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??1?$xr_vector@UfvfVertexIn@IRender_DetailModel@@V?$xalloc@UfvfVertexIn@IRender_DetailModel@@@@@@QAE@XZ
_TEXT	SEGMENT
??1?$xr_vector@UfvfVertexIn@IRender_DetailModel@@V?$xalloc@UfvfVertexIn@IRender_DetailModel@@@@@@QAE@XZ PROC ; xr_vector<IRender_DetailModel::fvfVertexIn,xalloc<IRender_DetailModel::fvfVertexIn> >::~xr_vector<IRender_DetailModel::fvfVertexIn,xalloc<IRender_DetailModel::fvfVertexIn> >, COMDAT
; _this$ = ecx

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	push	esi
	mov	esi, ecx
	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN6@xr_vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+4], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+8], 0
$LN6@xr_vector:
	pop	esi
	ret	0
??1?$xr_vector@UfvfVertexIn@IRender_DetailModel@@V?$xalloc@UfvfVertexIn@IRender_DetailModel@@@@@@QAE@XZ ENDP ; xr_vector<IRender_DetailModel::fvfVertexIn,xalloc<IRender_DetailModel::fvfVertexIn> >::~xr_vector<IRender_DetailModel::fvfVertexIn,xalloc<IRender_DetailModel::fvfVertexIn> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ??A?$xr_vector@UfvfVertexIn@IRender_DetailModel@@V?$xalloc@UfvfVertexIn@IRender_DetailModel@@@@@@QAEAAUfvfVertexIn@IRender_DetailModel@@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$xr_vector@UfvfVertexIn@IRender_DetailModel@@V?$xalloc@UfvfVertexIn@IRender_DetailModel@@@@@@QAEAAUfvfVertexIn@IRender_DetailModel@@I@Z PROC ; xr_vector<IRender_DetailModel::fvfVertexIn,xalloc<IRender_DetailModel::fvfVertexIn> >::operator[], COMDAT
; _this$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 119  :         _Ptr += _Off;

	mov	eax, DWORD PTR __Pos$[esp-4]
	lea	edx, DWORD PTR [eax+eax*4]
	mov	eax, DWORD PTR [ecx]
	lea	eax, DWORD PTR [eax+edx*4]
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 138  : 	reference operator[]		(size_type _Pos)					{ {VERIFY(_Pos<size());} return (*(begin() + _Pos)); }

	ret	4
??A?$xr_vector@UfvfVertexIn@IRender_DetailModel@@V?$xalloc@UfvfVertexIn@IRender_DetailModel@@@@@@QAEAAUfvfVertexIn@IRender_DetailModel@@I@Z ENDP ; xr_vector<IRender_DetailModel::fvfVertexIn,xalloc<IRender_DetailModel::fvfVertexIn> >::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?size@?$xr_vector@UfvfVertexIn@IRender_DetailModel@@V?$xalloc@UfvfVertexIn@IRender_DetailModel@@@@@@QBEIXZ
_TEXT	SEGMENT
?size@?$xr_vector@UfvfVertexIn@IRender_DetailModel@@V?$xalloc@UfvfVertexIn@IRender_DetailModel@@@@@@QBEIXZ PROC ; xr_vector<IRender_DetailModel::fvfVertexIn,xalloc<IRender_DetailModel::fvfVertexIn> >::size, COMDAT
; _this$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	eax, DWORD PTR [ecx+4]
	sub	eax, DWORD PTR [ecx]
	sar	eax, 2
	imul	eax, eax, -858993459
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 125  : 	u32		size				() const							{ return (u32)inherited::size();} 

	ret	0
?size@?$xr_vector@UfvfVertexIn@IRender_DetailModel@@V?$xalloc@UfvfVertexIn@IRender_DetailModel@@@@@@QBEIXZ ENDP ; xr_vector<IRender_DetailModel::fvfVertexIn,xalloc<IRender_DetailModel::fvfVertexIn> >::size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ??0?$xr_vector@UfvfVertexIn@IRender_DetailModel@@V?$xalloc@UfvfVertexIn@IRender_DetailModel@@@@@@QAE@XZ
_TEXT	SEGMENT
??0?$xr_vector@UfvfVertexIn@IRender_DetailModel@@V?$xalloc@UfvfVertexIn@IRender_DetailModel@@@@@@QAE@XZ PROC ; xr_vector<IRender_DetailModel::fvfVertexIn,xalloc<IRender_DetailModel::fvfVertexIn> >::xr_vector<IRender_DetailModel::fvfVertexIn,xalloc<IRender_DetailModel::fvfVertexIn> >, COMDAT
; _this$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx], 0
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 122  : 			xr_vector			()									: inherited	()					{}

	mov	eax, ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 122  : 			xr_vector			()									: inherited	()					{}

	ret	0
??0?$xr_vector@UfvfVertexIn@IRender_DetailModel@@V?$xalloc@UfvfVertexIn@IRender_DetailModel@@@@@@QAE@XZ ENDP ; xr_vector<IRender_DetailModel::fvfVertexIn,xalloc<IRender_DetailModel::fvfVertexIn> >::xr_vector<IRender_DetailModel::fvfVertexIn,xalloc<IRender_DetailModel::fvfVertexIn> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??1?$vector@UfvfVertexIn@IRender_DetailModel@@V?$xalloc@UfvfVertexIn@IRender_DetailModel@@@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@UfvfVertexIn@IRender_DetailModel@@V?$xalloc@UfvfVertexIn@IRender_DetailModel@@@@@std@@QAE@XZ PROC ; std::vector<IRender_DetailModel::fvfVertexIn,xalloc<IRender_DetailModel::fvfVertexIn> >::~vector<IRender_DetailModel::fvfVertexIn,xalloc<IRender_DetailModel::fvfVertexIn> >, COMDAT
; _this$ = ecx

; 698  :     _CONSTEXPR20_CONTAINER ~vector() noexcept {

	push	esi
	mov	esi, ecx

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN4@vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+4], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+8], 0
$LN4@vector:
	pop	esi

; 699  :         _Tidy();
; 700  : #if _ITERATOR_DEBUG_LEVEL != 0
; 701  :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 702  :         _Delete_plain_internal(_Alproxy, _STD exchange(_Mypair._Myval2._Myproxy, nullptr));
; 703  : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 704  :     }

	ret	0
??1?$vector@UfvfVertexIn@IRender_DetailModel@@V?$xalloc@UfvfVertexIn@IRender_DetailModel@@@@@std@@QAE@XZ ENDP ; std::vector<IRender_DetailModel::fvfVertexIn,xalloc<IRender_DetailModel::fvfVertexIn> >::~vector<IRender_DetailModel::fvfVertexIn,xalloc<IRender_DetailModel::fvfVertexIn> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@G@std@@@std@@@std@@QBEAAGXZ
_TEXT	SEGMENT
??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@G@std@@@std@@@std@@QBEAAGXZ PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned short> > >::operator*, COMDAT
; _this$ = ecx

; 261  :         return const_cast<reference>(_Mybase::operator*());

	mov	eax, DWORD PTR [ecx]

; 262  :     }

	ret	0
??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@G@std@@@std@@@std@@QBEAAGXZ ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned short> > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_flags.h
;	COMDAT ?assign@?$_flags@I@@QAEAAU1@I@Z
_TEXT	SEGMENT
_mask$ = 8						; size = 4
?assign@?$_flags@I@@QAEAAU1@I@Z PROC			; _flags<unsigned int>::assign, COMDAT
; _this$ = ecx

; 21   : 	IC	SelfRef	assign	(const T mask)								{ flags	=	mask;		return *this;	}

	mov	eax, DWORD PTR _mask$[esp-4]
	mov	DWORD PTR [ecx], eax
	mov	eax, ecx
	ret	4
?assign@?$_flags@I@@QAEAAU1@I@Z ENDP			; _flags<unsigned int>::assign
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ??A?$xr_vector@GV?$xalloc@G@@@@QAEAAGI@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$xr_vector@GV?$xalloc@G@@@@QAEAAGI@Z PROC		; xr_vector<unsigned short,xalloc<unsigned short> >::operator[], COMDAT
; _this$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 119  :         _Ptr += _Off;

	mov	ecx, DWORD PTR [ecx]
	mov	eax, DWORD PTR __Pos$[esp-4]
	lea	eax, DWORD PTR [ecx+eax*2]
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 138  : 	reference operator[]		(size_type _Pos)					{ {VERIFY(_Pos<size());} return (*(begin() + _Pos)); }

	ret	4
??A?$xr_vector@GV?$xalloc@G@@@@QAEAAGI@Z ENDP		; xr_vector<unsigned short,xalloc<unsigned short> >::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?size@?$xr_vector@GV?$xalloc@G@@@@QBEIXZ
_TEXT	SEGMENT
?size@?$xr_vector@GV?$xalloc@G@@@@QBEIXZ PROC		; xr_vector<unsigned short,xalloc<unsigned short> >::size, COMDAT
; _this$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	eax, DWORD PTR [ecx+4]
	sub	eax, DWORD PTR [ecx]
	sar	eax, 1
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 125  : 	u32		size				() const							{ return (u32)inherited::size();} 

	ret	0
?size@?$xr_vector@GV?$xalloc@G@@@@QBEIXZ ENDP		; xr_vector<unsigned short,xalloc<unsigned short> >::size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ??0?$xr_vector@GV?$xalloc@G@@@@QAE@XZ
_TEXT	SEGMENT
??0?$xr_vector@GV?$xalloc@G@@@@QAE@XZ PROC		; xr_vector<unsigned short,xalloc<unsigned short> >::xr_vector<unsigned short,xalloc<unsigned short> >, COMDAT
; _this$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx], 0
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 122  : 			xr_vector			()									: inherited	()					{}

	mov	eax, ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 122  : 			xr_vector			()									: inherited	()					{}

	ret	0
??0?$xr_vector@GV?$xalloc@G@@@@QAE@XZ ENDP		; xr_vector<unsigned short,xalloc<unsigned short> >::xr_vector<unsigned short,xalloc<unsigned short> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?begin@?$vector@GV?$xalloc@G@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@G@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@GV?$xalloc@G@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@G@std@@@std@@@2@XZ PROC ; std::vector<unsigned short,xalloc<unsigned short> >::begin, COMDAT
; _this$ = ecx

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	ecx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], ecx

; 1462 :         auto& _My_data = _Mypair._Myval2;
; 1463 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));
; 1464 :     }

	ret	4
?begin@?$vector@GV?$xalloc@G@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@G@std@@@std@@@2@XZ ENDP ; std::vector<unsigned short,xalloc<unsigned short> >::begin
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?resize@?$vector@GV?$xalloc@G@@@std@@QAEXI@Z
_TEXT	SEGMENT
__Newsize$ = 8						; size = 4
?resize@?$vector@GV?$xalloc@G@@@std@@QAEXI@Z PROC	; std::vector<unsigned short,xalloc<unsigned short> >::resize, COMDAT
; _this$ = ecx

; 1275 :     _CONSTEXPR20_CONTAINER void resize(_CRT_GUARDOVERFLOW const size_type _Newsize) {

	push	ebx
	push	esi

; 1251 :         if (_Newsize < _Oldsize) { // trim

	mov	esi, DWORD PTR __Newsize$[esp+4]

; 1275 :     _CONSTEXPR20_CONTAINER void resize(_CRT_GUARDOVERFLOW const size_type _Newsize) {

	push	edi
	mov	edi, ecx

; 1250 :         const auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);

	mov	ebx, DWORD PTR [edi+4]
	mov	ecx, ebx
	mov	edx, DWORD PTR [edi]
	sub	ecx, edx
	sar	ecx, 1

; 1251 :         if (_Newsize < _Oldsize) { // trim

	cmp	esi, ecx
	jae	SHORT $LN4@resize

; 1252 :             const pointer _Newlast = _Myfirst + _Newsize;

	lea	eax, DWORD PTR [edx+esi*2]

; 1278 :     }

	mov	DWORD PTR [edi+4], eax
	pop	edi
	pop	esi
	pop	ebx
	ret	4
$LN4@resize:

; 1259 :         if (_Newsize > _Oldsize) { // append

	jbe	SHORT $LN5@resize

; 1260 :             const auto _Oldcapacity = static_cast<size_type>(_My_data._Myend - _Myfirst);

	mov	eax, DWORD PTR [edi+8]
	sub	eax, edx
	sar	eax, 1

; 1261 :             if (_Newsize > _Oldcapacity) { // reallocate

	cmp	esi, eax
	jbe	SHORT $LN6@resize

; 1262 :                 _Resize_reallocate(_Newsize, _Val);

	push	ecx
	push	esi
	mov	ecx, edi
	call	??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@GV?$xalloc@G@@@std@@AAEXIABU_Value_init_tag@1@@Z ; std::vector<unsigned short,xalloc<unsigned short> >::_Resize_reallocate<std::_Value_init_tag>
	pop	edi

; 1278 :     }

	pop	esi
	pop	ebx
	ret	4
$LN6@resize:

; 1267 :             _Mylast                = _Ufill(_Oldlast, _Newsize - _Oldsize, _Val);

	sub	esi, ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1807 :             _Zero_range(_PFirst, _PFirst + _Count);

	add	esi, esi

; 1792 :     _CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

	push	esi
	push	0
	push	ebx
	call	_memset

; 1808 :             return _First + _Count;

	lea	eax, DWORD PTR [esi+ebx]

; 1792 :     _CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

	add	esp, 12					; 0000000cH
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1278 :     }

	mov	DWORD PTR [edi+4], eax
$LN5@resize:
	pop	edi
	pop	esi
	pop	ebx
	ret	4
?resize@?$vector@GV?$xalloc@G@@@std@@QAEXI@Z ENDP	; std::vector<unsigned short,xalloc<unsigned short> >::resize
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??1?$vector@GV?$xalloc@G@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@GV?$xalloc@G@@@std@@QAE@XZ PROC		; std::vector<unsigned short,xalloc<unsigned short> >::~vector<unsigned short,xalloc<unsigned short> >, COMDAT
; _this$ = ecx

; 698  :     _CONSTEXPR20_CONTAINER ~vector() noexcept {

	push	esi
	mov	esi, ecx

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN4@vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+4], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+8], 0
$LN4@vector:
	pop	esi

; 699  :         _Tidy();
; 700  : #if _ITERATOR_DEBUG_LEVEL != 0
; 701  :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 702  :         _Delete_plain_internal(_Alproxy, _STD exchange(_Mypair._Myval2._Myproxy, nullptr));
; 703  : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 704  :     }

	ret	0
??1?$vector@GV?$xalloc@G@@@std@@QAE@XZ ENDP		; std::vector<unsigned short,xalloc<unsigned short> >::~vector<unsigned short,xalloc<unsigned short> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@G@std@@@std@@@std@@QAE@PAGPBU_Container_base0@1@@Z
_TEXT	SEGMENT
___param0$ = 8						; size = 4
___param1$dead$ = 12					; size = 4
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@G@std@@@std@@@std@@QAE@PAGPBU_Container_base0@1@@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned short> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned short> > >, COMDAT
; _this$ = ecx

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	eax, DWORD PTR ___param0$[esp-4]
	mov	DWORD PTR [ecx], eax
	mov	eax, ecx
	ret	8
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@G@std@@@std@@@std@@QAE@PAGPBU_Container_base0@1@@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned short> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned short> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UfvfVertexIn@IRender_DetailModel@@@std@@@std@@@std@@QBE?AV01@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UfvfVertexIn@IRender_DetailModel@@@std@@@std@@@std@@QBE?AV01@H@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<IRender_DetailModel::fvfVertexIn> > >::operator+, COMDAT
; _this$ = ecx

; 119  :         _Ptr += _Off;

	mov	eax, DWORD PTR __Off$[esp-4]
	lea	edx, DWORD PTR [eax+eax*4]
	mov	eax, DWORD PTR [ecx]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 303  :         _Vector_iterator _Tmp = *this;
; 304  :         _Tmp += _Off; // TRANSITION, LLVM-49342
; 305  :         return _Tmp;
; 306  :     }

	ret	8
??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UfvfVertexIn@IRender_DetailModel@@@std@@@std@@@std@@QBE?AV01@H@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<IRender_DetailModel::fvfVertexIn> > >::operator+
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UfvfVertexIn@IRender_DetailModel@@@std@@@std@@@std@@QBEAAUfvfVertexIn@IRender_DetailModel@@XZ
_TEXT	SEGMENT
??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UfvfVertexIn@IRender_DetailModel@@@std@@@std@@@std@@QBEAAUfvfVertexIn@IRender_DetailModel@@XZ PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<IRender_DetailModel::fvfVertexIn> > >::operator*, COMDAT
; _this$ = ecx

; 261  :         return const_cast<reference>(_Mybase::operator*());

	mov	eax, DWORD PTR [ecx]

; 262  :     }

	ret	0
??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UfvfVertexIn@IRender_DetailModel@@@std@@@std@@@std@@QBEAAUfvfVertexIn@IRender_DetailModel@@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<IRender_DetailModel::fvfVertexIn> > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Tidy@?$vector@UfvfVertexIn@IRender_DetailModel@@V?$xalloc@UfvfVertexIn@IRender_DetailModel@@@@@std@@AAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@UfvfVertexIn@IRender_DetailModel@@V?$xalloc@UfvfVertexIn@IRender_DetailModel@@@@@std@@AAEXXZ PROC ; std::vector<IRender_DetailModel::fvfVertexIn,xalloc<IRender_DetailModel::fvfVertexIn> >::_Tidy, COMDAT
; _this$ = ecx

; 1742 :     _CONSTEXPR20_CONTAINER void _Tidy() noexcept { // free all storage

	push	esi
	mov	esi, ecx

; 1743 :         auto& _My_data    = _Mypair._Myval2;
; 1744 :         pointer& _Myfirst = _My_data._Myfirst;
; 1745 :         pointer& _Mylast  = _My_data._Mylast;
; 1746 :         pointer& _Myend   = _My_data._Myend;
; 1747 : 
; 1748 :         _My_data._Orphan_all();
; 1749 : 
; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN2@Tidy
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+4], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+8], 0
$LN2@Tidy:

; 1757 :         }
; 1758 :     }

	pop	esi
	ret	0
?_Tidy@?$vector@UfvfVertexIn@IRender_DetailModel@@V?$xalloc@UfvfVertexIn@IRender_DetailModel@@@@@std@@AAEXXZ ENDP ; std::vector<IRender_DetailModel::fvfVertexIn,xalloc<IRender_DetailModel::fvfVertexIn> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?size@?$vector@UfvfVertexIn@IRender_DetailModel@@V?$xalloc@UfvfVertexIn@IRender_DetailModel@@@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@UfvfVertexIn@IRender_DetailModel@@V?$xalloc@UfvfVertexIn@IRender_DetailModel@@@@@std@@QBEIXZ PROC ; std::vector<IRender_DetailModel::fvfVertexIn,xalloc<IRender_DetailModel::fvfVertexIn> >::size, COMDAT
; _this$ = ecx

; 1535 :         auto& _My_data = _Mypair._Myval2;
; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	eax, DWORD PTR [ecx+4]
	sub	eax, DWORD PTR [ecx]
	sar	eax, 2
	imul	eax, eax, -858993459

; 1537 :     }

	ret	0
?size@?$vector@UfvfVertexIn@IRender_DetailModel@@V?$xalloc@UfvfVertexIn@IRender_DetailModel@@@@@std@@QBEIXZ ENDP ; std::vector<IRender_DetailModel::fvfVertexIn,xalloc<IRender_DetailModel::fvfVertexIn> >::size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?begin@?$vector@UfvfVertexIn@IRender_DetailModel@@V?$xalloc@UfvfVertexIn@IRender_DetailModel@@@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UfvfVertexIn@IRender_DetailModel@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@UfvfVertexIn@IRender_DetailModel@@V?$xalloc@UfvfVertexIn@IRender_DetailModel@@@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UfvfVertexIn@IRender_DetailModel@@@std@@@std@@@2@XZ PROC ; std::vector<IRender_DetailModel::fvfVertexIn,xalloc<IRender_DetailModel::fvfVertexIn> >::begin, COMDAT
; _this$ = ecx

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	ecx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], ecx

; 1462 :         auto& _My_data = _Mypair._Myval2;
; 1463 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));
; 1464 :     }

	ret	4
?begin@?$vector@UfvfVertexIn@IRender_DetailModel@@V?$xalloc@UfvfVertexIn@IRender_DetailModel@@@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UfvfVertexIn@IRender_DetailModel@@@std@@@std@@@2@XZ ENDP ; std::vector<IRender_DetailModel::fvfVertexIn,xalloc<IRender_DetailModel::fvfVertexIn> >::begin
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0?$vector@UfvfVertexIn@IRender_DetailModel@@V?$xalloc@UfvfVertexIn@IRender_DetailModel@@@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@UfvfVertexIn@IRender_DetailModel@@V?$xalloc@UfvfVertexIn@IRender_DetailModel@@@@@std@@QAE@XZ PROC ; std::vector<IRender_DetailModel::fvfVertexIn,xalloc<IRender_DetailModel::fvfVertexIn> >::vector<IRender_DetailModel::fvfVertexIn,xalloc<IRender_DetailModel::fvfVertexIn> >, COMDAT
; _this$ = ecx

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx], 0

; 464  :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 465  :     }

	mov	eax, ecx

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0

; 464  :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 465  :     }

	ret	0
??0?$vector@UfvfVertexIn@IRender_DetailModel@@V?$xalloc@UfvfVertexIn@IRender_DetailModel@@@@@std@@QAE@XZ ENDP ; std::vector<IRender_DetailModel::fvfVertexIn,xalloc<IRender_DetailModel::fvfVertexIn> >::vector<IRender_DetailModel::fvfVertexIn,xalloc<IRender_DetailModel::fvfVertexIn> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@G@std@@@std@@@std@@QBE?AV01@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@G@std@@@std@@@std@@QBE?AV01@H@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned short> > >::operator+, COMDAT
; _this$ = ecx

; 119  :         _Ptr += _Off;

	mov	eax, DWORD PTR __Off$[esp-4]
	mov	ecx, DWORD PTR [ecx]
	lea	ecx, DWORD PTR [ecx+eax*2]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 303  :         _Vector_iterator _Tmp = *this;
; 304  :         _Tmp += _Off; // TRANSITION, LLVM-49342
; 305  :         return _Tmp;
; 306  :     }

	ret	8
??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@G@std@@@std@@@std@@QBE?AV01@H@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned short> > >::operator+
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@G@std@@@std@@@std@@QBEABGXZ
_TEXT	SEGMENT
??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@G@std@@@std@@@std@@QBEABGXZ PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned short> > >::operator*, COMDAT
; _this$ = ecx

; 46   : #if _ITERATOR_DEBUG_LEVEL != 0
; 47   :         const auto _Mycont = static_cast<const _Myvec*>(this->_Getcont());
; 48   :         _STL_VERIFY(_Ptr, "can't dereference value-initialized vector iterator");
; 49   :         _STL_VERIFY(
; 50   :             _Mycont->_Myfirst <= _Ptr && _Ptr < _Mycont->_Mylast, "can't dereference out of range vector iterator");
; 51   : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 52   : 
; 53   :         return *_Ptr;

	mov	eax, DWORD PTR [ecx]

; 54   :     }

	ret	0
??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@G@std@@@std@@@std@@QBEABGXZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned short> > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@G@std@@@std@@@std@@QAE@PAGPBU_Container_base0@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Pvector$dead$ = 12					; size = 4
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@G@std@@@std@@@std@@QAE@PAGPBU_Container_base0@1@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned short> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned short> > >, COMDAT
; _this$ = ecx

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	eax, DWORD PTR __Parg$[esp-4]
	mov	DWORD PTR [ecx], eax

; 42   :         this->_Adopt(_Pvector);
; 43   :     }

	mov	eax, ecx
	ret	8
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@G@std@@@std@@@std@@QAE@PAGPBU_Container_base0@1@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned short> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned short> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Tidy@?$vector@GV?$xalloc@G@@@std@@AAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@GV?$xalloc@G@@@std@@AAEXXZ PROC		; std::vector<unsigned short,xalloc<unsigned short> >::_Tidy, COMDAT
; _this$ = ecx

; 1742 :     _CONSTEXPR20_CONTAINER void _Tidy() noexcept { // free all storage

	push	esi
	mov	esi, ecx

; 1743 :         auto& _My_data    = _Mypair._Myval2;
; 1744 :         pointer& _Myfirst = _My_data._Myfirst;
; 1745 :         pointer& _Mylast  = _My_data._Mylast;
; 1746 :         pointer& _Myend   = _My_data._Myend;
; 1747 : 
; 1748 :         _My_data._Orphan_all();
; 1749 : 
; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN2@Tidy
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+4], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+8], 0
$LN2@Tidy:

; 1757 :         }
; 1758 :     }

	pop	esi
	ret	0
?_Tidy@?$vector@GV?$xalloc@G@@@std@@AAEXXZ ENDP		; std::vector<unsigned short,xalloc<unsigned short> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?size@?$vector@GV?$xalloc@G@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@GV?$xalloc@G@@@std@@QBEIXZ PROC		; std::vector<unsigned short,xalloc<unsigned short> >::size, COMDAT
; _this$ = ecx

; 1535 :         auto& _My_data = _Mypair._Myval2;
; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	eax, DWORD PTR [ecx+4]
	sub	eax, DWORD PTR [ecx]
	sar	eax, 1

; 1537 :     }

	ret	0
?size@?$vector@GV?$xalloc@G@@@std@@QBEIXZ ENDP		; std::vector<unsigned short,xalloc<unsigned short> >::size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0?$vector@GV?$xalloc@G@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@GV?$xalloc@G@@@std@@QAE@XZ PROC		; std::vector<unsigned short,xalloc<unsigned short> >::vector<unsigned short,xalloc<unsigned short> >, COMDAT
; _this$ = ecx

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx], 0

; 464  :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 465  :     }

	mov	eax, ecx

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0

; 464  :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 465  :     }

	ret	0
??0?$vector@GV?$xalloc@G@@@std@@QAE@XZ ENDP		; std::vector<unsigned short,xalloc<unsigned short> >::vector<unsigned short,xalloc<unsigned short> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UfvfVertexIn@IRender_DetailModel@@@std@@@std@@@std@@QAE@PAUfvfVertexIn@IRender_DetailModel@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
___param0$ = 8						; size = 4
___param1$dead$ = 12					; size = 4
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UfvfVertexIn@IRender_DetailModel@@@std@@@std@@@std@@QAE@PAUfvfVertexIn@IRender_DetailModel@@PBU_Container_base0@1@@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<IRender_DetailModel::fvfVertexIn> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<IRender_DetailModel::fvfVertexIn> > >, COMDAT
; _this$ = ecx

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	eax, DWORD PTR ___param0$[esp-4]
	mov	DWORD PTR [ecx], eax
	mov	eax, ecx
	ret	8
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UfvfVertexIn@IRender_DetailModel@@@std@@@std@@@std@@QAE@PAUfvfVertexIn@IRender_DetailModel@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<IRender_DetailModel::fvfVertexIn> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<IRender_DetailModel::fvfVertexIn> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UfvfVertexIn@IRender_DetailModel@@@std@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UfvfVertexIn@IRender_DetailModel@@@std@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<IRender_DetailModel::fvfVertexIn> > >::operator+=, COMDAT
; _this$ = ecx

; 119  :         _Ptr += _Off;

	mov	eax, DWORD PTR __Off$[esp-4]
	lea	eax, DWORD PTR [eax+eax*4]
	shl	eax, 2
	add	DWORD PTR [ecx], eax

; 298  :         _Mybase::operator+=(_Off);
; 299  :         return *this;

	mov	eax, ecx

; 300  :     }

	ret	4
??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UfvfVertexIn@IRender_DetailModel@@@std@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<IRender_DetailModel::fvfVertexIn> > >::operator+=
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UfvfVertexIn@IRender_DetailModel@@@std@@@std@@@std@@QBEABUfvfVertexIn@IRender_DetailModel@@XZ
_TEXT	SEGMENT
??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UfvfVertexIn@IRender_DetailModel@@@std@@@std@@@std@@QBEABUfvfVertexIn@IRender_DetailModel@@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<IRender_DetailModel::fvfVertexIn> > >::operator*, COMDAT
; _this$ = ecx

; 46   : #if _ITERATOR_DEBUG_LEVEL != 0
; 47   :         const auto _Mycont = static_cast<const _Myvec*>(this->_Getcont());
; 48   :         _STL_VERIFY(_Ptr, "can't dereference value-initialized vector iterator");
; 49   :         _STL_VERIFY(
; 50   :             _Mycont->_Myfirst <= _Ptr && _Ptr < _Mycont->_Mylast, "can't dereference out of range vector iterator");
; 51   : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 52   : 
; 53   :         return *_Ptr;

	mov	eax, DWORD PTR [ecx]

; 54   :     }

	ret	0
??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UfvfVertexIn@IRender_DetailModel@@@std@@@std@@@std@@QBEABUfvfVertexIn@IRender_DetailModel@@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<IRender_DetailModel::fvfVertexIn> > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UfvfVertexIn@IRender_DetailModel@@@std@@@std@@@std@@QAE@PAUfvfVertexIn@IRender_DetailModel@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Pvector$dead$ = 12					; size = 4
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UfvfVertexIn@IRender_DetailModel@@@std@@@std@@@std@@QAE@PAUfvfVertexIn@IRender_DetailModel@@PBU_Container_base0@1@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<IRender_DetailModel::fvfVertexIn> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<IRender_DetailModel::fvfVertexIn> > >, COMDAT
; _this$ = ecx

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	eax, DWORD PTR __Parg$[esp-4]
	mov	DWORD PTR [ecx], eax

; 42   :         this->_Adopt(_Pvector);
; 43   :     }

	mov	eax, ecx
	ret	8
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UfvfVertexIn@IRender_DetailModel@@@std@@@std@@@std@@QAE@PAUfvfVertexIn@IRender_DetailModel@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<IRender_DetailModel::fvfVertexIn> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<IRender_DetailModel::fvfVertexIn> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Getal@?$vector@UfvfVertexIn@IRender_DetailModel@@V?$xalloc@UfvfVertexIn@IRender_DetailModel@@@@@std@@AAEAAV?$xalloc@UfvfVertexIn@IRender_DetailModel@@@@XZ
_TEXT	SEGMENT
?_Getal@?$vector@UfvfVertexIn@IRender_DetailModel@@V?$xalloc@UfvfVertexIn@IRender_DetailModel@@@@@std@@AAEAAV?$xalloc@UfvfVertexIn@IRender_DetailModel@@@@XZ PROC ; std::vector<IRender_DetailModel::fvfVertexIn,xalloc<IRender_DetailModel::fvfVertexIn> >::_Getal, COMDAT
; _this$ = ecx

; 1805 :         return _Mypair._Get_first();

	mov	eax, ecx

; 1806 :     }

	ret	0
?_Getal@?$vector@UfvfVertexIn@IRender_DetailModel@@V?$xalloc@UfvfVertexIn@IRender_DetailModel@@@@@std@@AAEAAV?$xalloc@UfvfVertexIn@IRender_DetailModel@@@@XZ ENDP ; std::vector<IRender_DetailModel::fvfVertexIn,xalloc<IRender_DetailModel::fvfVertexIn> >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Destroy@?$vector@UfvfVertexIn@IRender_DetailModel@@V?$xalloc@UfvfVertexIn@IRender_DetailModel@@@@@std@@AAEXPAUfvfVertexIn@IRender_DetailModel@@0@Z
_TEXT	SEGMENT
__First$dead$ = 8					; size = 4
__Last$dead$ = 12					; size = 4
?_Destroy@?$vector@UfvfVertexIn@IRender_DetailModel@@V?$xalloc@UfvfVertexIn@IRender_DetailModel@@@@@std@@AAEXPAUfvfVertexIn@IRender_DetailModel@@0@Z PROC ; std::vector<IRender_DetailModel::fvfVertexIn,xalloc<IRender_DetailModel::fvfVertexIn> >::_Destroy, COMDAT
; _this$dead$ = ecx

; 1666 :         // destroy [_First, _Last) using allocator
; 1667 :         _Destroy_range(_First, _Last, _Getal());
; 1668 :     }

	ret	8
?_Destroy@?$vector@UfvfVertexIn@IRender_DetailModel@@V?$xalloc@UfvfVertexIn@IRender_DetailModel@@@@@std@@AAEXPAUfvfVertexIn@IRender_DetailModel@@0@Z ENDP ; std::vector<IRender_DetailModel::fvfVertexIn,xalloc<IRender_DetailModel::fvfVertexIn> >::_Destroy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?deallocate@?$xalloc@UfvfVertexIn@IRender_DetailModel@@@@QBEXPAUfvfVertexIn@IRender_DetailModel@@I@Z
_TEXT	SEGMENT
_p$ = 8							; size = 4
_n$dead$ = 12						; size = 4
?deallocate@?$xalloc@UfvfVertexIn@IRender_DetailModel@@@@QBEXPAUfvfVertexIn@IRender_DetailModel@@I@Z PROC ; xalloc<IRender_DetailModel::fvfVertexIn>::deallocate, COMDAT
; _this$dead$ = ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	eax, DWORD PTR _p$[esp-4]
	test	eax, eax
	je	SHORT $LN4@deallocate
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN4@deallocate:
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 82   : 							void					deallocate		(pointer p, size_type n) const			{	xr_free	(p);				}

	ret	8
?deallocate@?$xalloc@UfvfVertexIn@IRender_DetailModel@@@@QBEXPAUfvfVertexIn@IRender_DetailModel@@I@Z ENDP ; xalloc<IRender_DetailModel::fvfVertexIn>::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@G@std@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@G@std@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned short> > >::operator+=, COMDAT
; _this$ = ecx

; 119  :         _Ptr += _Off;

	mov	eax, DWORD PTR __Off$[esp-4]
	add	eax, eax
	add	DWORD PTR [ecx], eax

; 298  :         _Mybase::operator+=(_Off);
; 299  :         return *this;

	mov	eax, ecx

; 300  :     }

	ret	4
??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@G@std@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned short> > >::operator+=
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Getal@?$vector@GV?$xalloc@G@@@std@@AAEAAV?$xalloc@G@@XZ
_TEXT	SEGMENT
?_Getal@?$vector@GV?$xalloc@G@@@std@@AAEAAV?$xalloc@G@@XZ PROC ; std::vector<unsigned short,xalloc<unsigned short> >::_Getal, COMDAT
; _this$ = ecx

; 1805 :         return _Mypair._Get_first();

	mov	eax, ecx

; 1806 :     }

	ret	0
?_Getal@?$vector@GV?$xalloc@G@@@std@@AAEAAV?$xalloc@G@@XZ ENDP ; std::vector<unsigned short,xalloc<unsigned short> >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Destroy@?$vector@GV?$xalloc@G@@@std@@AAEXPAG0@Z
_TEXT	SEGMENT
__First$dead$ = 8					; size = 4
__Last$dead$ = 12					; size = 4
?_Destroy@?$vector@GV?$xalloc@G@@@std@@AAEXPAG0@Z PROC	; std::vector<unsigned short,xalloc<unsigned short> >::_Destroy, COMDAT
; _this$dead$ = ecx

; 1666 :         // destroy [_First, _Last) using allocator
; 1667 :         _Destroy_range(_First, _Last, _Getal());
; 1668 :     }

	ret	8
?_Destroy@?$vector@GV?$xalloc@G@@@std@@AAEXPAG0@Z ENDP	; std::vector<unsigned short,xalloc<unsigned short> >::_Destroy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?deallocate@?$xalloc@G@@QBEXPAGI@Z
_TEXT	SEGMENT
_p$ = 8							; size = 4
_n$dead$ = 12						; size = 4
?deallocate@?$xalloc@G@@QBEXPAGI@Z PROC			; xalloc<unsigned short>::deallocate, COMDAT
; _this$dead$ = ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	eax, DWORD PTR _p$[esp-4]
	test	eax, eax
	je	SHORT $LN4@deallocate
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN4@deallocate:
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 82   : 							void					deallocate		(pointer p, size_type n) const			{	xr_free	(p);				}

	ret	8
?deallocate@?$xalloc@G@@QBEXPAGI@Z ENDP			; xalloc<unsigned short>::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UfvfVertexIn@IRender_DetailModel@@@std@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UfvfVertexIn@IRender_DetailModel@@@std@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<IRender_DetailModel::fvfVertexIn> > >::operator+=, COMDAT
; _this$ = ecx

; 118  :         _Verify_offset(_Off);
; 119  :         _Ptr += _Off;

	mov	eax, DWORD PTR __Off$[esp-4]
	lea	eax, DWORD PTR [eax+eax*4]
	shl	eax, 2
	add	DWORD PTR [ecx], eax

; 120  :         return *this;

	mov	eax, ecx

; 121  :     }

	ret	4
??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UfvfVertexIn@IRender_DetailModel@@@std@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<IRender_DetailModel::fvfVertexIn> > >::operator+=
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$xalloc@UfvfVertexIn@IRender_DetailModel@@@@V?$_Vector_val@U?$_Simple_types@UfvfVertexIn@IRender_DetailModel@@@std@@@std@@$00@std@@QAEAAV?$xalloc@UfvfVertexIn@IRender_DetailModel@@@@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@V?$xalloc@UfvfVertexIn@IRender_DetailModel@@@@V?$_Vector_val@U?$_Simple_types@UfvfVertexIn@IRender_DetailModel@@@std@@@std@@$00@std@@QAEAAV?$xalloc@UfvfVertexIn@IRender_DetailModel@@@@XZ PROC ; std::_Compressed_pair<xalloc<IRender_DetailModel::fvfVertexIn>,std::_Vector_val<std::_Simple_types<IRender_DetailModel::fvfVertexIn> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 1339 :         return *this;

	mov	eax, ecx

; 1340 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$xalloc@UfvfVertexIn@IRender_DetailModel@@@@V?$_Vector_val@U?$_Simple_types@UfvfVertexIn@IRender_DetailModel@@@std@@@std@@$00@std@@QAEAAV?$xalloc@UfvfVertexIn@IRender_DetailModel@@@@XZ ENDP ; std::_Compressed_pair<xalloc<IRender_DetailModel::fvfVertexIn>,std::_Vector_val<std::_Simple_types<IRender_DetailModel::fvfVertexIn> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@G@std@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@G@std@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned short> > >::operator+=, COMDAT
; _this$ = ecx

; 118  :         _Verify_offset(_Off);
; 119  :         _Ptr += _Off;

	mov	eax, DWORD PTR __Off$[esp-4]
	add	eax, eax
	add	DWORD PTR [ecx], eax

; 120  :         return *this;

	mov	eax, ecx

; 121  :     }

	ret	4
??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@G@std@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned short> > >::operator+=
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$xalloc@G@@V?$_Vector_val@U?$_Simple_types@G@std@@@std@@$00@std@@QAEAAV?$xalloc@G@@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@V?$xalloc@G@@V?$_Vector_val@U?$_Simple_types@G@std@@@std@@$00@std@@QAEAAV?$xalloc@G@@XZ PROC ; std::_Compressed_pair<xalloc<unsigned short>,std::_Vector_val<std::_Simple_types<unsigned short> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 1339 :         return *this;

	mov	eax, ecx

; 1340 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$xalloc@G@@V?$_Vector_val@U?$_Simple_types@G@std@@@std@@$00@std@@QAEAAV?$xalloc@G@@XZ ENDP ; std::_Compressed_pair<xalloc<unsigned short>,std::_Vector_val<std::_Simple_types<unsigned short> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Verify_offset@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UfvfVertexIn@IRender_DetailModel@@@std@@@std@@@std@@QBEXH@Z
_TEXT	SEGMENT
__Off$dead$ = 8						; size = 4
?_Verify_offset@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UfvfVertexIn@IRender_DetailModel@@@std@@@std@@@std@@QBEXH@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<IRender_DetailModel::fvfVertexIn> > >::_Verify_offset, COMDAT
; _this$dead$ = ecx

; 102  : #if _ITERATOR_DEBUG_LEVEL == 0
; 103  :         (void) _Off;
; 104  : #else // ^^^ _ITERATOR_DEBUG_LEVEL == 0 ^^^ // vvv _ITERATOR_DEBUG_LEVEL != 0 vvv
; 105  :         const auto _Mycont = static_cast<const _Myvec*>(this->_Getcont());
; 106  :         _STL_VERIFY(_Off == 0 || _Ptr, "cannot seek value-initialized vector iterator");
; 107  :         if (_Off < 0) {
; 108  :             _STL_VERIFY(_Off >= _Mycont->_Myfirst - _Ptr, "cannot seek vector iterator before begin");
; 109  :         }
; 110  : 
; 111  :         if (_Off > 0) {
; 112  :             _STL_VERIFY(_Off <= _Mycont->_Mylast - _Ptr, "cannot seek vector iterator after end");
; 113  :         }
; 114  : #endif // _ITERATOR_DEBUG_LEVEL == 0
; 115  :     }

	ret	4
?_Verify_offset@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UfvfVertexIn@IRender_DetailModel@@@std@@@std@@@std@@QBEXH@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<IRender_DetailModel::fvfVertexIn> > >::_Verify_offset
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Verify_offset@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@G@std@@@std@@@std@@QBEXH@Z
_TEXT	SEGMENT
__Off$dead$ = 8						; size = 4
?_Verify_offset@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@G@std@@@std@@@std@@QBEXH@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned short> > >::_Verify_offset, COMDAT
; _this$dead$ = ecx

; 102  : #if _ITERATOR_DEBUG_LEVEL == 0
; 103  :         (void) _Off;
; 104  : #else // ^^^ _ITERATOR_DEBUG_LEVEL == 0 ^^^ // vvv _ITERATOR_DEBUG_LEVEL != 0 vvv
; 105  :         const auto _Mycont = static_cast<const _Myvec*>(this->_Getcont());
; 106  :         _STL_VERIFY(_Off == 0 || _Ptr, "cannot seek value-initialized vector iterator");
; 107  :         if (_Off < 0) {
; 108  :             _STL_VERIFY(_Off >= _Mycont->_Myfirst - _Ptr, "cannot seek vector iterator before begin");
; 109  :         }
; 110  : 
; 111  :         if (_Off > 0) {
; 112  :             _STL_VERIFY(_Off <= _Mycont->_Mylast - _Ptr, "cannot seek vector iterator after end");
; 113  :         }
; 114  : #endif // _ITERATOR_DEBUG_LEVEL == 0
; 115  :     }

	ret	4
?_Verify_offset@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@G@std@@@std@@@std@@QBEXH@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned short> > >::_Verify_offset
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
;	COMDAT ??$xr_free@UfvfVertexIn@IRender_DetailModel@@@@YAXAAPAUfvfVertexIn@IRender_DetailModel@@@Z
_TEXT	SEGMENT
??$xr_free@UfvfVertexIn@IRender_DetailModel@@@@YAXAAPAUfvfVertexIn@IRender_DetailModel@@@Z PROC ; xr_free<IRender_DetailModel::fvfVertexIn>, COMDAT
; _P$ = ecx

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	push	esi
	mov	esi, ecx
	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN2@xr_free
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
	mov	DWORD PTR [esi], 0
$LN2@xr_free:
	pop	esi
	ret	0
??$xr_free@UfvfVertexIn@IRender_DetailModel@@@@YAXAAPAUfvfVertexIn@IRender_DetailModel@@@Z ENDP ; xr_free<IRender_DetailModel::fvfVertexIn>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
;	COMDAT ??$xr_free@G@@YAXAAPAG@Z
_TEXT	SEGMENT
??$xr_free@G@@YAXAAPAG@Z PROC				; xr_free<unsigned short>, COMDAT
; _P$ = ecx

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	push	esi
	mov	esi, ecx
	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN2@xr_free
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
	mov	DWORD PTR [esi], 0
$LN2@xr_free:
	pop	esi
	ret	0
??$xr_free@G@@YAXAAPAG@Z ENDP				; xr_free<unsigned short>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
;	COMDAT ??$xr_alloc@UfvfVertexIn@IRender_DetailModel@@@@YAPAUfvfVertexIn@IRender_DetailModel@@I@Z
_TEXT	SEGMENT
??$xr_alloc@UfvfVertexIn@IRender_DetailModel@@@@YAPAUfvfVertexIn@IRender_DetailModel@@I@Z PROC ; xr_alloc<IRender_DetailModel::fvfVertexIn>, COMDAT
; _count$ = ecx

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	lea	eax, DWORD PTR [ecx+ecx*4]
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	shl	eax, 2
	push	eax
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
	ret	0
??$xr_alloc@UfvfVertexIn@IRender_DetailModel@@@@YAPAUfvfVertexIn@IRender_DetailModel@@I@Z ENDP ; xr_alloc<IRender_DetailModel::fvfVertexIn>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
;	COMDAT ??$xr_alloc@G@@YAPAGI@Z
_TEXT	SEGMENT
??$xr_alloc@G@@YAPAGI@Z PROC				; xr_alloc<unsigned short>, COMDAT
; _count$ = ecx

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	lea	eax, DWORD PTR [ecx+ecx]
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
	ret	0
??$xr_alloc@G@@YAPAGI@Z ENDP				; xr_alloc<unsigned short>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??$assign@PAG$0A@@?$vector@GV?$xalloc@G@@@std@@QAEXPAG0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$assign@PAG$0A@@?$vector@GV?$xalloc@G@@@std@@QAEXPAG0@Z PROC ; std::vector<unsigned short,xalloc<unsigned short> >::assign<unsigned short *,0>, COMDAT
; _this$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility

; 1525 :         return _Last - _First; // assume the iterator will do debug checking

	mov	edx, DWORD PTR __First$[esp-4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1174 :     _CONSTEXPR20_CONTAINER void assign(_Iter _First, _Iter _Last) {

	push	ebx
	push	ebp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility

; 1525 :         return _Last - _First; // assume the iterator will do debug checking

	mov	ebp, DWORD PTR __Last$[esp+4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1174 :     _CONSTEXPR20_CONTAINER void assign(_Iter _First, _Iter _Last) {

	push	esi
	push	edi
	mov	edi, ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility

; 1525 :         return _Last - _First; // assume the iterator will do debug checking

	mov	ecx, ebp
	sub	ecx, edx
	mov	esi, ecx
	sar	esi, 1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1151 :         auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);

	mov	eax, DWORD PTR [edi+4]
	mov	ebx, DWORD PTR [edi]
	sub	eax, ebx
	sar	eax, 1

; 1152 : 
; 1153 :         if (_Newsize > _Oldsize) {

	cmp	esi, eax
	jbe	$LN4@assign

; 1154 :             const auto _Oldcapacity = static_cast<size_type>(_Myend - _Myfirst);

	mov	ecx, DWORD PTR [edi+8]
	sub	ecx, ebx
	sar	ecx, 1

; 1155 :             if (_Newsize > _Oldcapacity) { // reallocate

	cmp	esi, ecx
	jbe	SHORT $LN6@assign

; 1337 :         if (_Newsize > max_size()) {

	cmp	esi, 2147483647				; 7fffffffH
	ja	$LN70@assign

; 1675 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	edx, ecx
	mov	eax, 2147483647				; 7fffffffH
	shr	edx, 1
	sub	eax, edx
	cmp	ecx, eax
	jbe	SHORT $LN15@assign

; 1676 :             return _Max; // geometric growth would overflow

	mov	esi, 2147483647				; 7fffffffH
	jmp	SHORT $LN16@assign
$LN15@assign:

; 1677 :         }
; 1678 : 
; 1679 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	lea	eax, DWORD PTR [edx+ecx]

; 1680 : 
; 1681 :         if (_Geometric < _Newsize) {

	cmp	eax, esi
	cmovb	eax, esi
	mov	esi, eax
$LN16@assign:

; 1343 :         if (_Myfirst) { // destroy and deallocate old array

	test	ebx, ebx
	je	SHORT $LN12@assign
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	ebx
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1347 :             _Myfirst = nullptr;

	mov	DWORD PTR [edi], 0

; 1348 :             _Mylast  = nullptr;

	mov	DWORD PTR [edi+4], 0

; 1349 :             _Myend   = nullptr;

	mov	DWORD PTR [edi+8], 0
$LN12@assign:
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	add	esi, esi
	push	esi
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
	mov	edx, DWORD PTR __First$[esp+12]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1698 :         const auto _Newvec = _Getal().allocate(_Newcapacity);

	mov	ebx, eax

; 1699 :         _Myfirst           = _Newvec;

	mov	DWORD PTR [edi], ebx

; 1157 :                 _Oldsize = 0;

	xor	eax, eax

; 1700 :         _Mylast            = _Newvec;

	mov	DWORD PTR [edi+4], ebx

; 1701 :         _Myend             = _Newvec + _Newcapacity;

	lea	ecx, DWORD PTR [esi+ebx]
	mov	DWORD PTR [edi+8], ecx
$LN6@assign:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility

; 1497 :         _Where += _Off;

	lea	esi, DWORD PTR [eax+eax]

; 4066 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	push	esi
	push	edx
	push	ebx
	call	_memmove

; 1497 :         _Where += _Off;

	mov	eax, DWORD PTR __First$[esp+24]

; 4066 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	add	esp, 12					; 0000000cH
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	edx, DWORD PTR [edi+4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility

; 1497 :         _Where += _Off;

	add	eax, esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1658 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	eax, ebp
	je	SHORT $LN47@assign
$LL48@assign:

; 1620 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

	mov	cx, WORD PTR [eax]

; 1658 :     for (; _UFirst != _ULast; ++_UFirst) {

	add	eax, 2

; 1620 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

	mov	WORD PTR [edx], cx

; 1621 :         ++_Last;

	add	edx, 2

; 1658 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	eax, ebp
	jne	SHORT $LL48@assign
$LN47@assign:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1163 :             _Mylast = _Ucopy(_Mid, _Last, _Mylast);

	mov	DWORD PTR [edi+4], edx
	pop	edi

; 1175 :         _Adl_verify_range(_First, _Last);
; 1176 :         _Assign_range(_Get_unwrapped(_First), _Get_unwrapped(_Last), _Iter_cat_t<_Iter>{});
; 1177 :     }

	pop	esi
	pop	ebp
	pop	ebx
	ret	8
$LN4@assign:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility

; 4066 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	push	ecx
	push	edx
	push	ebx
	call	_memmove
	add	esp, 12					; 0000000cH
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1165 :             const pointer _Newlast = _Myfirst + _Newsize;

	lea	eax, DWORD PTR [ebx+esi*2]

; 1166 :             _Copy_unchecked(_First, _Last, _Myfirst);
; 1167 :             _Destroy(_Newlast, _Mylast);
; 1168 :             _Mylast = _Newlast;

	mov	DWORD PTR [edi+4], eax
	pop	edi

; 1175 :         _Adl_verify_range(_First, _Last);
; 1176 :         _Assign_range(_Get_unwrapped(_First), _Get_unwrapped(_Last), _Iter_cat_t<_Iter>{});
; 1177 :     }

	pop	esi
	pop	ebp
	pop	ebx
	ret	8
$LN70@assign:

; 1338 :             _Xlength();

	call	?_Xlength@?$vector@GV?$xalloc@G@@@std@@CAXXZ ; std::vector<unsigned short,xalloc<unsigned short> >::_Xlength
$LN68@assign:
	int	3
??$assign@PAG$0A@@?$vector@GV?$xalloc@G@@@std@@QAEXPAG0@Z ENDP ; std::vector<unsigned short,xalloc<unsigned short> >::assign<unsigned short *,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_Get_unwrapped@AAPAG@std@@YA?A_TAAPAG@Z
_TEXT	SEGMENT
??$_Get_unwrapped@AAPAG@std@@YA?A_TAAPAG@Z PROC		; std::_Get_unwrapped<unsigned short * &>, COMDAT
; __It$ = ecx

; 1275 :     // unwrap an iterator previously subjected to _Adl_verify_range or otherwise validated
; 1276 :     if constexpr (is_pointer_v<decay_t<_Iter>>) { // special-case pointers and arrays
; 1277 :         return _It + 0;

	mov	eax, DWORD PTR [ecx]

; 1278 :     } else if constexpr (_Unwrappable_v<_Iter>) {
; 1279 :         return static_cast<_Iter&&>(_It)._Unwrapped();
; 1280 :     } else {
; 1281 :         return static_cast<_Iter&&>(_It);
; 1282 :     }
; 1283 : }

	ret	0
??$_Get_unwrapped@AAPAG@std@@YA?A_TAAPAG@Z ENDP		; std::_Get_unwrapped<unsigned short * &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??$assign@PAUfvfVertexIn@IRender_DetailModel@@$0A@@?$vector@UfvfVertexIn@IRender_DetailModel@@V?$xalloc@UfvfVertexIn@IRender_DetailModel@@@@@std@@QAEXPAUfvfVertexIn@IRender_DetailModel@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
tv490 = 12						; size = 4
__Last$ = 12						; size = 4
??$assign@PAUfvfVertexIn@IRender_DetailModel@@$0A@@?$vector@UfvfVertexIn@IRender_DetailModel@@V?$xalloc@UfvfVertexIn@IRender_DetailModel@@@@@std@@QAEXPAUfvfVertexIn@IRender_DetailModel@@0@Z PROC ; std::vector<IRender_DetailModel::fvfVertexIn,xalloc<IRender_DetailModel::fvfVertexIn> >::assign<IRender_DetailModel::fvfVertexIn *,0>, COMDAT
; _this$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility

; 1525 :         return _Last - _First; // assume the iterator will do debug checking

	mov	edx, DWORD PTR __First$[esp-4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1174 :     _CONSTEXPR20_CONTAINER void assign(_Iter _First, _Iter _Last) {

	push	ebx
	push	ebp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility

; 1525 :         return _Last - _First; // assume the iterator will do debug checking

	mov	ebp, DWORD PTR __Last$[esp+4]
	mov	eax, ebp
	sub	eax, edx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1174 :     _CONSTEXPR20_CONTAINER void assign(_Iter _First, _Iter _Last) {

	push	esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility

; 1525 :         return _Last - _First; // assume the iterator will do debug checking

	mov	DWORD PTR tv490[esp+8], eax
	sar	eax, 2
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1174 :     _CONSTEXPR20_CONTAINER void assign(_Iter _First, _Iter _Last) {

	push	edi
	mov	edi, ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility

; 1525 :         return _Last - _First; // assume the iterator will do debug checking

	imul	esi, eax, -858993459
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1151 :         auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);

	mov	eax, DWORD PTR [edi+4]
	mov	ebx, DWORD PTR [edi]
	sub	eax, ebx
	sar	eax, 2
	imul	ecx, eax, -858993459

; 1152 : 
; 1153 :         if (_Newsize > _Oldsize) {

	cmp	esi, ecx
	jbe	$LN4@assign

; 1154 :             const auto _Oldcapacity = static_cast<size_type>(_Myend - _Myfirst);

	mov	eax, DWORD PTR [edi+8]
	sub	eax, ebx
	sar	eax, 2
	imul	edx, eax, -858993459

; 1155 :             if (_Newsize > _Oldcapacity) { // reallocate

	cmp	esi, edx
	jbe	SHORT $LN6@assign

; 1337 :         if (_Newsize > max_size()) {

	cmp	esi, 214748364				; 0cccccccH
	ja	$LN74@assign

; 1675 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	ecx, edx
	mov	eax, 214748364				; 0cccccccH
	shr	ecx, 1
	sub	eax, ecx
	cmp	edx, eax
	jbe	SHORT $LN15@assign

; 1676 :             return _Max; // geometric growth would overflow

	mov	esi, 214748364				; 0cccccccH
	jmp	SHORT $LN16@assign
$LN15@assign:

; 1677 :         }
; 1678 : 
; 1679 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	lea	eax, DWORD PTR [ecx+edx]

; 1680 : 
; 1681 :         if (_Geometric < _Newsize) {

	cmp	eax, esi
	cmovb	eax, esi
	mov	esi, eax
$LN16@assign:

; 1343 :         if (_Myfirst) { // destroy and deallocate old array

	test	ebx, ebx
	je	SHORT $LN12@assign
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	ebx
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1347 :             _Myfirst = nullptr;

	mov	DWORD PTR [edi], 0

; 1348 :             _Mylast  = nullptr;

	mov	DWORD PTR [edi+4], 0

; 1349 :             _Myend   = nullptr;

	mov	DWORD PTR [edi+8], 0
$LN12@assign:
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	lea	esi, DWORD PTR [esi+esi*4]
	shl	esi, 2
	push	esi
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1698 :         const auto _Newvec = _Getal().allocate(_Newcapacity);

	mov	ebx, eax

; 1699 :         _Myfirst           = _Newvec;

	mov	DWORD PTR [edi], ebx

; 1700 :         _Mylast            = _Newvec;

	mov	DWORD PTR [edi+4], ebx

; 1701 :         _Myend             = _Newvec + _Newcapacity;

	lea	ecx, DWORD PTR [esi+ebx]
	mov	DWORD PTR [edi+8], ecx

; 1157 :                 _Oldsize = 0;

	xor	ecx, ecx
$LN6@assign:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility

; 1497 :         _Where += _Off;

	lea	esi, DWORD PTR [ecx+ecx*4]
	shl	esi, 2

; 4066 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	push	esi
	push	DWORD PTR __First$[esp+16]
	push	ebx
	call	_memmove

; 1497 :         _Where += _Off;

	mov	eax, DWORD PTR __First$[esp+24]

; 4066 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	add	esp, 12					; 0000000cH
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	edx, DWORD PTR [edi+4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility

; 1497 :         _Where += _Off;

	add	eax, esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1658 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	eax, ebp
	je	SHORT $LN47@assign
	npad	3
$LL48@assign:
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ecx
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR [edx+8], ecx
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR [edx+12], ecx
	mov	ecx, DWORD PTR [eax+16]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1658 :     for (; _UFirst != _ULast; ++_UFirst) {

	add	eax, 20					; 00000014H
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	DWORD PTR [edx+16], ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1621 :         ++_Last;

	add	edx, 20					; 00000014H

; 1658 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	eax, ebp
	jne	SHORT $LL48@assign
$LN47@assign:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1163 :             _Mylast = _Ucopy(_Mid, _Last, _Mylast);

	mov	DWORD PTR [edi+4], edx
	pop	edi

; 1175 :         _Adl_verify_range(_First, _Last);
; 1176 :         _Assign_range(_Get_unwrapped(_First), _Get_unwrapped(_Last), _Iter_cat_t<_Iter>{});
; 1177 :     }

	pop	esi
	pop	ebp
	pop	ebx
	ret	8
$LN4@assign:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility

; 4066 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	push	DWORD PTR tv490[esp+12]
	push	edx
	push	ebx
	call	_memmove
	add	esp, 12					; 0000000cH
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1165 :             const pointer _Newlast = _Myfirst + _Newsize;

	lea	eax, DWORD PTR [esi+esi*4]
	lea	eax, DWORD PTR [ebx+eax*4]

; 1166 :             _Copy_unchecked(_First, _Last, _Myfirst);
; 1167 :             _Destroy(_Newlast, _Mylast);
; 1168 :             _Mylast = _Newlast;

	mov	DWORD PTR [edi+4], eax
	pop	edi

; 1175 :         _Adl_verify_range(_First, _Last);
; 1176 :         _Assign_range(_Get_unwrapped(_First), _Get_unwrapped(_Last), _Iter_cat_t<_Iter>{});
; 1177 :     }

	pop	esi
	pop	ebp
	pop	ebx
	ret	8
$LN74@assign:

; 1338 :             _Xlength();

	call	?_Xlength@?$vector@UfvfVertexIn@IRender_DetailModel@@V?$xalloc@UfvfVertexIn@IRender_DetailModel@@@@@std@@CAXXZ ; std::vector<IRender_DetailModel::fvfVertexIn,xalloc<IRender_DetailModel::fvfVertexIn> >::_Xlength
$LN72@assign:
	int	3
??$assign@PAUfvfVertexIn@IRender_DetailModel@@$0A@@?$vector@UfvfVertexIn@IRender_DetailModel@@V?$xalloc@UfvfVertexIn@IRender_DetailModel@@@@@std@@QAEXPAUfvfVertexIn@IRender_DetailModel@@0@Z ENDP ; std::vector<IRender_DetailModel::fvfVertexIn,xalloc<IRender_DetailModel::fvfVertexIn> >::assign<IRender_DetailModel::fvfVertexIn *,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_Get_unwrapped@AAPAUfvfVertexIn@IRender_DetailModel@@@std@@YA?A_TAAPAUfvfVertexIn@IRender_DetailModel@@@Z
_TEXT	SEGMENT
??$_Get_unwrapped@AAPAUfvfVertexIn@IRender_DetailModel@@@std@@YA?A_TAAPAUfvfVertexIn@IRender_DetailModel@@@Z PROC ; std::_Get_unwrapped<IRender_DetailModel::fvfVertexIn * &>, COMDAT
; __It$ = ecx

; 1275 :     // unwrap an iterator previously subjected to _Adl_verify_range or otherwise validated
; 1276 :     if constexpr (is_pointer_v<decay_t<_Iter>>) { // special-case pointers and arrays
; 1277 :         return _It + 0;

	mov	eax, DWORD PTR [ecx]

; 1278 :     } else if constexpr (_Unwrappable_v<_Iter>) {
; 1279 :         return static_cast<_Iter&&>(_It)._Unwrapped();
; 1280 :     } else {
; 1281 :         return static_cast<_Iter&&>(_It);
; 1282 :     }
; 1283 : }

	ret	0
??$_Get_unwrapped@AAPAUfvfVertexIn@IRender_DetailModel@@@std@@YA?A_TAAPAUfvfVertexIn@IRender_DetailModel@@@Z ENDP ; std::_Get_unwrapped<IRender_DetailModel::fvfVertexIn * &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef
;	COMDAT ??$addressof@V?$_Vector_val@U?$_Simple_types@G@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@G@std@@@0@AAV10@@Z
_TEXT	SEGMENT
??$addressof@V?$_Vector_val@U?$_Simple_types@G@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@G@std@@@0@AAV10@@Z PROC ; std::addressof<std::_Vector_val<std::_Simple_types<unsigned short> > >, COMDAT
; __Val$ = ecx

; 253  :     return __builtin_addressof(_Val);

	mov	eax, ecx

; 254  : }

	ret	0
??$addressof@V?$_Vector_val@U?$_Simple_types@G@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@G@std@@@0@AAV10@@Z ENDP ; std::addressof<std::_Vector_val<std::_Simple_types<unsigned short> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??$_Resize@U_Value_init_tag@std@@@?$vector@GV?$xalloc@G@@@std@@AAEXIABU_Value_init_tag@1@@Z
_TEXT	SEGMENT
__Newsize$ = 8						; size = 4
__Val$dead$ = 12					; size = 4
??$_Resize@U_Value_init_tag@std@@@?$vector@GV?$xalloc@G@@@std@@AAEXIABU_Value_init_tag@1@@Z PROC ; std::vector<unsigned short,xalloc<unsigned short> >::_Resize<std::_Value_init_tag>, COMDAT
; _this$ = ecx

; 1245 :     _CONSTEXPR20_CONTAINER void _Resize(const size_type _Newsize, const _Ty2& _Val) {

	push	ebx
	push	esi

; 1246 :         // trim or append elements, provide strong guarantee
; 1247 :         auto& _My_data      = _Mypair._Myval2;
; 1248 :         pointer& _Myfirst   = _My_data._Myfirst;
; 1249 :         pointer& _Mylast    = _My_data._Mylast;
; 1250 :         const auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);
; 1251 :         if (_Newsize < _Oldsize) { // trim

	mov	esi, DWORD PTR __Newsize$[esp+4]
	push	edi
	mov	edi, ecx
	mov	ebx, DWORD PTR [edi+4]
	mov	ecx, ebx
	mov	edx, DWORD PTR [edi]
	sub	ecx, edx
	sar	ecx, 1
	cmp	esi, ecx
	jae	SHORT $LN2@Resize

; 1252 :             const pointer _Newlast = _Myfirst + _Newsize;

	lea	eax, DWORD PTR [edx+esi*2]

; 1272 :     }

	mov	DWORD PTR [edi+4], eax
	pop	edi
	pop	esi
	pop	ebx
	ret	8
$LN2@Resize:

; 1253 :             _Orphan_range(_Newlast, _Mylast);
; 1254 :             _Destroy(_Newlast, _Mylast);
; 1255 :             _Mylast = _Newlast;
; 1256 :             return;
; 1257 :         }
; 1258 : 
; 1259 :         if (_Newsize > _Oldsize) { // append

	jbe	SHORT $LN3@Resize

; 1260 :             const auto _Oldcapacity = static_cast<size_type>(_My_data._Myend - _Myfirst);

	mov	eax, DWORD PTR [edi+8]
	sub	eax, edx
	sar	eax, 1

; 1261 :             if (_Newsize > _Oldcapacity) { // reallocate

	cmp	esi, eax
	jbe	SHORT $LN4@Resize

; 1262 :                 _Resize_reallocate(_Newsize, _Val);

	push	ecx
	push	esi
	mov	ecx, edi
	call	??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@GV?$xalloc@G@@@std@@AAEXIABU_Value_init_tag@1@@Z ; std::vector<unsigned short,xalloc<unsigned short> >::_Resize_reallocate<std::_Value_init_tag>
	pop	edi

; 1272 :     }

	pop	esi
	pop	ebx
	ret	8
$LN4@Resize:

; 1263 :                 return;
; 1264 :             }
; 1265 : 
; 1266 :             const pointer _Oldlast = _Mylast;
; 1267 :             _Mylast                = _Ufill(_Oldlast, _Newsize - _Oldsize, _Val);

	sub	esi, ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1807 :             _Zero_range(_PFirst, _PFirst + _Count);

	add	esi, esi

; 1792 :     _CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

	push	esi
	push	0
	push	ebx
	call	_memset

; 1808 :             return _First + _Count;

	lea	eax, DWORD PTR [esi+ebx]

; 1792 :     _CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

	add	esp, 12					; 0000000cH
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1272 :     }

	mov	DWORD PTR [edi+4], eax
$LN3@Resize:
	pop	edi
	pop	esi
	pop	ebx
	ret	8
??$_Resize@U_Value_init_tag@std@@@?$vector@GV?$xalloc@G@@@std@@AAEXIABU_Value_init_tag@1@@Z ENDP ; std::vector<unsigned short,xalloc<unsigned short> >::_Resize<std::_Value_init_tag>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef
;	COMDAT ??$addressof@V?$_Vector_val@U?$_Simple_types@UfvfVertexIn@IRender_DetailModel@@@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@UfvfVertexIn@IRender_DetailModel@@@std@@@0@AAV10@@Z
_TEXT	SEGMENT
??$addressof@V?$_Vector_val@U?$_Simple_types@UfvfVertexIn@IRender_DetailModel@@@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@UfvfVertexIn@IRender_DetailModel@@@std@@@0@AAV10@@Z PROC ; std::addressof<std::_Vector_val<std::_Simple_types<IRender_DetailModel::fvfVertexIn> > >, COMDAT
; __Val$ = ecx

; 253  :     return __builtin_addressof(_Val);

	mov	eax, ecx

; 254  : }

	ret	0
??$addressof@V?$_Vector_val@U?$_Simple_types@UfvfVertexIn@IRender_DetailModel@@@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@UfvfVertexIn@IRender_DetailModel@@@std@@@0@AAV10@@Z ENDP ; std::addressof<std::_Vector_val<std::_Simple_types<IRender_DetailModel::fvfVertexIn> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$?0$$V@?$_Compressed_pair@V?$xalloc@UfvfVertexIn@IRender_DetailModel@@@@V?$_Vector_val@U?$_Simple_types@UfvfVertexIn@IRender_DetailModel@@@std@@@std@@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$?0$$V@?$_Compressed_pair@V?$xalloc@UfvfVertexIn@IRender_DetailModel@@@@V?$_Vector_val@U?$_Simple_types@UfvfVertexIn@IRender_DetailModel@@@std@@@std@@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<xalloc<IRender_DetailModel::fvfVertexIn>,std::_Vector_val<std::_Simple_types<IRender_DetailModel::fvfVertexIn> >,1>::_Compressed_pair<xalloc<IRender_DetailModel::fvfVertexIn>,std::_Vector_val<std::_Simple_types<IRender_DetailModel::fvfVertexIn> >,1><>, COMDAT
; _this$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1331 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	eax, ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1331 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	ret	4
??$?0$$V@?$_Compressed_pair@V?$xalloc@UfvfVertexIn@IRender_DetailModel@@@@V?$_Vector_val@U?$_Simple_types@UfvfVertexIn@IRender_DetailModel@@@std@@@std@@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<xalloc<IRender_DetailModel::fvfVertexIn>,std::_Vector_val<std::_Simple_types<IRender_DetailModel::fvfVertexIn> >,1>::_Compressed_pair<xalloc<IRender_DetailModel::fvfVertexIn>,std::_Vector_val<std::_Simple_types<IRender_DetailModel::fvfVertexIn> >,1><>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$?0$$V@?$_Compressed_pair@V?$xalloc@G@@V?$_Vector_val@U?$_Simple_types@G@std@@@std@@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$?0$$V@?$_Compressed_pair@V?$xalloc@G@@V?$_Vector_val@U?$_Simple_types@G@std@@@std@@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<xalloc<unsigned short>,std::_Vector_val<std::_Simple_types<unsigned short> >,1>::_Compressed_pair<xalloc<unsigned short>,std::_Vector_val<std::_Simple_types<unsigned short> >,1><>, COMDAT
; _this$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1331 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	eax, ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1331 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	ret	4
??$?0$$V@?$_Compressed_pair@V?$xalloc@G@@V?$_Vector_val@U?$_Simple_types@G@std@@@std@@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<xalloc<unsigned short>,std::_Vector_val<std::_Simple_types<unsigned short> >,1>::_Compressed_pair<xalloc<unsigned short>,std::_Vector_val<std::_Simple_types<unsigned short> >,1><>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Destroy_range@V?$xalloc@UfvfVertexIn@IRender_DetailModel@@@@@std@@YAXPAUfvfVertexIn@IRender_DetailModel@@QAU12@AAV?$xalloc@UfvfVertexIn@IRender_DetailModel@@@@@Z
_TEXT	SEGMENT
__Al$dead$ = 8						; size = 4
??$_Destroy_range@V?$xalloc@UfvfVertexIn@IRender_DetailModel@@@@@std@@YAXPAUfvfVertexIn@IRender_DetailModel@@QAU12@AAV?$xalloc@UfvfVertexIn@IRender_DetailModel@@@@@Z PROC ; std::_Destroy_range<xalloc<IRender_DetailModel::fvfVertexIn> >, COMDAT
; __First$dead$ = ecx
; __Last$dead$ = edx

; 901  :     // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
; 902  :     using _Ty = typename _Alloc::value_type;
; 903  :     if constexpr (!conjunction_v<is_trivially_destructible<_Ty>, _Uses_default_destroy<_Alloc, _Ty*>>) {
; 904  :         for (; _First != _Last; ++_First) {
; 905  :             allocator_traits<_Alloc>::destroy(_Al, _Unfancy(_First));
; 906  :         }
; 907  :     }
; 908  : }

	ret	0
??$_Destroy_range@V?$xalloc@UfvfVertexIn@IRender_DetailModel@@@@@std@@YAXPAUfvfVertexIn@IRender_DetailModel@@QAU12@AAV?$xalloc@UfvfVertexIn@IRender_DetailModel@@@@@Z ENDP ; std::_Destroy_range<xalloc<IRender_DetailModel::fvfVertexIn> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Destroy_range@V?$xalloc@G@@@std@@YAXPAGQAGAAV?$xalloc@G@@@Z
_TEXT	SEGMENT
__Al$dead$ = 8						; size = 4
??$_Destroy_range@V?$xalloc@G@@@std@@YAXPAGQAGAAV?$xalloc@G@@@Z PROC ; std::_Destroy_range<xalloc<unsigned short> >, COMDAT
; __First$dead$ = ecx
; __Last$dead$ = edx

; 901  :     // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
; 902  :     using _Ty = typename _Alloc::value_type;
; 903  :     if constexpr (!conjunction_v<is_trivially_destructible<_Ty>, _Uses_default_destroy<_Alloc, _Ty*>>) {
; 904  :         for (; _First != _Last; ++_First) {
; 905  :             allocator_traits<_Alloc>::destroy(_Al, _Unfancy(_First));
; 906  :         }
; 907  :     }
; 908  : }

	ret	0
??$_Destroy_range@V?$xalloc@G@@@std@@YAXPAGQAGAAV?$xalloc@G@@@Z ENDP ; std::_Destroy_range<xalloc<unsigned short> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@UfvfVertexIn@IRender_DetailModel@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Vector_val@U?$_Simple_types@UfvfVertexIn@IRender_DetailModel@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<std::_Simple_types<IRender_DetailModel::fvfVertexIn> >::_Vector_val<std::_Simple_types<IRender_DetailModel::fvfVertexIn> >, COMDAT
; _this$ = ecx

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx], 0
	mov	eax, ecx
	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0
	ret	0
??0?$_Vector_val@U?$_Simple_types@UfvfVertexIn@IRender_DetailModel@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<std::_Simple_types<IRender_DetailModel::fvfVertexIn> >::_Vector_val<std::_Simple_types<IRender_DetailModel::fvfVertexIn> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ??0?$xalloc@UfvfVertexIn@IRender_DetailModel@@@@QAE@XZ
_TEXT	SEGMENT
??0?$xalloc@UfvfVertexIn@IRender_DetailModel@@@@QAE@XZ PROC ; xalloc<IRender_DetailModel::fvfVertexIn>::xalloc<IRender_DetailModel::fvfVertexIn>, COMDAT
; _this$ = ecx

; 76   : 													xalloc			()										{	}

	mov	eax, ecx
	ret	0
??0?$xalloc@UfvfVertexIn@IRender_DetailModel@@@@QAE@XZ ENDP ; xalloc<IRender_DetailModel::fvfVertexIn>::xalloc<IRender_DetailModel::fvfVertexIn>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@G@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Vector_val@U?$_Simple_types@G@std@@@std@@QAE@XZ PROC ; std::_Vector_val<std::_Simple_types<unsigned short> >::_Vector_val<std::_Simple_types<unsigned short> >, COMDAT
; _this$ = ecx

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx], 0
	mov	eax, ecx
	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0
	ret	0
??0?$_Vector_val@U?$_Simple_types@G@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<std::_Simple_types<unsigned short> >::_Vector_val<std::_Simple_types<unsigned short> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Orphan_range@?$vector@GV?$xalloc@G@@@std@@ABEXPAG0@Z
_TEXT	SEGMENT
___formal$dead$ = 8					; size = 4
___formal$dead$ = 12					; size = 4
?_Orphan_range@?$vector@GV?$xalloc@G@@@std@@ABEXPAG0@Z PROC ; std::vector<unsigned short,xalloc<unsigned short> >::_Orphan_range, COMDAT
; _this$dead$ = ecx

; 1801 :     _CONSTEXPR20_CONTAINER void _Orphan_range(pointer, pointer) const {}

	ret	8
?_Orphan_range@?$vector@GV?$xalloc@G@@@std@@ABEXPAG0@Z ENDP ; std::vector<unsigned short,xalloc<unsigned short> >::_Orphan_range
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Ufill@?$vector@GV?$xalloc@G@@@std@@AAEPAGPAGIU_Value_init_tag@2@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Count$ = 12						; size = 4
___formal$ = 16						; size = 1
?_Ufill@?$vector@GV?$xalloc@G@@@std@@AAEPAGPAGIU_Value_init_tag@2@@Z PROC ; std::vector<unsigned short,xalloc<unsigned short> >::_Ufill, COMDAT
; _this$dead$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1807 :             _Zero_range(_PFirst, _PFirst + _Count);

	mov	eax, DWORD PTR __Count$[esp-4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1633 :     _CONSTEXPR20_CONTAINER pointer _Ufill(pointer _Dest, const size_type _Count, _Value_init_tag) {

	push	esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1792 :     _CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

	mov	esi, DWORD PTR __Dest$[esp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1633 :     _CONSTEXPR20_CONTAINER pointer _Ufill(pointer _Dest, const size_type _Count, _Value_init_tag) {

	push	edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1807 :             _Zero_range(_PFirst, _PFirst + _Count);

	lea	edi, DWORD PTR [eax+eax]

; 1792 :     _CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

	push	edi
	push	0
	push	esi
	call	_memset
	add	esp, 12					; 0000000cH

; 1808 :             return _First + _Count;

	lea	eax, DWORD PTR [edi+esi]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1635 :         return _Uninitialized_value_construct_n(_Dest, _Count, _Getal());

	pop	edi
	pop	esi

; 1636 :     }

	ret	12					; 0000000cH
?_Ufill@?$vector@GV?$xalloc@G@@@std@@AAEPAGPAGIU_Value_init_tag@2@@Z ENDP ; std::vector<unsigned short,xalloc<unsigned short> >::_Ufill
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ??0?$xalloc@G@@QAE@XZ
_TEXT	SEGMENT
??0?$xalloc@G@@QAE@XZ PROC				; xalloc<unsigned short>::xalloc<unsigned short>, COMDAT
; _this$ = ecx

; 76   : 													xalloc			()										{	}

	mov	eax, ecx
	ret	0
??0?$xalloc@G@@QAE@XZ ENDP				; xalloc<unsigned short>::xalloc<unsigned short>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_Adl_verify_range@PAGPAG@std@@YAXABQAG0@Z
_TEXT	SEGMENT
??$_Adl_verify_range@PAGPAG@std@@YAXABQAG0@Z PROC	; std::_Adl_verify_range<unsigned short *,unsigned short *>, COMDAT
; __First$dead$ = ecx
; __Last$dead$ = edx

; 1259 :     // check that [_First, _Last) forms an iterator range
; 1260 :     if constexpr (_Range_verifiable_v<_Iter, _Sentinel>) {
; 1261 :         _Verify_range(_First, _Last);
; 1262 :     }
; 1263 : }

	ret	0
??$_Adl_verify_range@PAGPAG@std@@YAXABQAG0@Z ENDP	; std::_Adl_verify_range<unsigned short *,unsigned short *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??$_Assign_range@PAG@?$vector@GV?$xalloc@G@@@std@@AAEXPAG0Uforward_iterator_tag@1@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
___formal$ = 16						; size = 1
??$_Assign_range@PAG@?$vector@GV?$xalloc@G@@@std@@AAEXPAG0Uforward_iterator_tag@1@@Z PROC ; std::vector<unsigned short,xalloc<unsigned short> >::_Assign_range<unsigned short *>, COMDAT
; _this$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility

; 1525 :         return _Last - _First; // assume the iterator will do debug checking

	mov	edx, DWORD PTR __First$[esp-4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1125 :     _CONSTEXPR20_CONTAINER void _Assign_range(_Iter _First, _Iter _Last, forward_iterator_tag) {

	push	ebx
	push	ebp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility

; 1525 :         return _Last - _First; // assume the iterator will do debug checking

	mov	ebp, DWORD PTR __Last$[esp+4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1125 :     _CONSTEXPR20_CONTAINER void _Assign_range(_Iter _First, _Iter _Last, forward_iterator_tag) {

	push	esi
	push	edi
	mov	edi, ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility

; 1525 :         return _Last - _First; // assume the iterator will do debug checking

	mov	ecx, ebp
	sub	ecx, edx
	mov	esi, ecx
	sar	esi, 1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1151 :         auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);

	mov	eax, DWORD PTR [edi+4]
	mov	ebx, DWORD PTR [edi]
	sub	eax, ebx
	sar	eax, 1

; 1152 : 
; 1153 :         if (_Newsize > _Oldsize) {

	cmp	esi, eax
	jbe	$LN2@Assign_ran

; 1154 :             const auto _Oldcapacity = static_cast<size_type>(_Myend - _Myfirst);

	mov	ecx, DWORD PTR [edi+8]
	sub	ecx, ebx
	sar	ecx, 1

; 1155 :             if (_Newsize > _Oldcapacity) { // reallocate

	cmp	esi, ecx
	jbe	SHORT $LN4@Assign_ran

; 1337 :         if (_Newsize > max_size()) {

	cmp	esi, 2147483647				; 7fffffffH
	ja	$LN67@Assign_ran

; 1675 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	edx, ecx
	mov	eax, 2147483647				; 7fffffffH
	shr	edx, 1
	sub	eax, edx
	cmp	ecx, eax
	jbe	SHORT $LN13@Assign_ran

; 1676 :             return _Max; // geometric growth would overflow

	mov	esi, 2147483647				; 7fffffffH
	jmp	SHORT $LN14@Assign_ran
$LN13@Assign_ran:

; 1677 :         }
; 1678 : 
; 1679 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	lea	eax, DWORD PTR [edx+ecx]

; 1680 : 
; 1681 :         if (_Geometric < _Newsize) {

	cmp	eax, esi
	cmovb	eax, esi
	mov	esi, eax
$LN14@Assign_ran:

; 1343 :         if (_Myfirst) { // destroy and deallocate old array

	test	ebx, ebx
	je	SHORT $LN10@Assign_ran
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	ebx
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1347 :             _Myfirst = nullptr;

	mov	DWORD PTR [edi], 0

; 1348 :             _Mylast  = nullptr;

	mov	DWORD PTR [edi+4], 0

; 1349 :             _Myend   = nullptr;

	mov	DWORD PTR [edi+8], 0
$LN10@Assign_ran:
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	add	esi, esi
	push	esi
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
	mov	edx, DWORD PTR __First$[esp+12]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1698 :         const auto _Newvec = _Getal().allocate(_Newcapacity);

	mov	ebx, eax

; 1699 :         _Myfirst           = _Newvec;

	mov	DWORD PTR [edi], ebx

; 1156 :                 _Clear_and_reserve_geometric(_Newsize);
; 1157 :                 _Oldsize = 0;

	xor	eax, eax

; 1700 :         _Mylast            = _Newvec;

	mov	DWORD PTR [edi+4], ebx

; 1701 :         _Myend             = _Newvec + _Newcapacity;

	lea	ecx, DWORD PTR [esi+ebx]
	mov	DWORD PTR [edi+8], ecx
$LN4@Assign_ran:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility

; 1497 :         _Where += _Off;

	lea	esi, DWORD PTR [eax+eax]

; 4066 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	push	esi
	push	edx
	push	ebx
	call	_memmove

; 1497 :         _Where += _Off;

	mov	eax, DWORD PTR __First$[esp+24]

; 4066 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	add	esp, 12					; 0000000cH
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	edx, DWORD PTR [edi+4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility

; 1497 :         _Where += _Off;

	add	eax, esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1658 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	eax, ebp
	je	SHORT $LN45@Assign_ran
$LL46@Assign_ran:

; 1620 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

	mov	cx, WORD PTR [eax]

; 1658 :     for (; _UFirst != _ULast; ++_UFirst) {

	add	eax, 2

; 1620 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

	mov	WORD PTR [edx], cx

; 1621 :         ++_Last;

	add	edx, 2

; 1658 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	eax, ebp
	jne	SHORT $LL46@Assign_ran
$LN45@Assign_ran:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1163 :             _Mylast = _Ucopy(_Mid, _Last, _Mylast);

	mov	DWORD PTR [edi+4], edx
	pop	edi

; 1169 :         }
; 1170 :     }

	pop	esi
	pop	ebp
	pop	ebx
	ret	12					; 0000000cH
$LN2@Assign_ran:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility

; 4066 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	push	ecx
	push	edx
	push	ebx
	call	_memmove
	add	esp, 12					; 0000000cH
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1165 :             const pointer _Newlast = _Myfirst + _Newsize;

	lea	eax, DWORD PTR [ebx+esi*2]

; 1166 :             _Copy_unchecked(_First, _Last, _Myfirst);
; 1167 :             _Destroy(_Newlast, _Mylast);
; 1168 :             _Mylast = _Newlast;

	mov	DWORD PTR [edi+4], eax
	pop	edi

; 1169 :         }
; 1170 :     }

	pop	esi
	pop	ebp
	pop	ebx
	ret	12					; 0000000cH
$LN67@Assign_ran:

; 1338 :             _Xlength();

	call	?_Xlength@?$vector@GV?$xalloc@G@@@std@@CAXXZ ; std::vector<unsigned short,xalloc<unsigned short> >::_Xlength
$LN65@Assign_ran:
	int	3
??$_Assign_range@PAG@?$vector@GV?$xalloc@G@@@std@@AAEXPAG0Uforward_iterator_tag@1@@Z ENDP ; std::vector<unsigned short,xalloc<unsigned short> >::_Assign_range<unsigned short *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_Adl_verify_range@PAUfvfVertexIn@IRender_DetailModel@@PAU12@@std@@YAXABQAUfvfVertexIn@IRender_DetailModel@@0@Z
_TEXT	SEGMENT
??$_Adl_verify_range@PAUfvfVertexIn@IRender_DetailModel@@PAU12@@std@@YAXABQAUfvfVertexIn@IRender_DetailModel@@0@Z PROC ; std::_Adl_verify_range<IRender_DetailModel::fvfVertexIn *,IRender_DetailModel::fvfVertexIn *>, COMDAT
; __First$dead$ = ecx
; __Last$dead$ = edx

; 1259 :     // check that [_First, _Last) forms an iterator range
; 1260 :     if constexpr (_Range_verifiable_v<_Iter, _Sentinel>) {
; 1261 :         _Verify_range(_First, _Last);
; 1262 :     }
; 1263 : }

	ret	0
??$_Adl_verify_range@PAUfvfVertexIn@IRender_DetailModel@@PAU12@@std@@YAXABQAUfvfVertexIn@IRender_DetailModel@@0@Z ENDP ; std::_Adl_verify_range<IRender_DetailModel::fvfVertexIn *,IRender_DetailModel::fvfVertexIn *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??$_Assign_range@PAUfvfVertexIn@IRender_DetailModel@@@?$vector@UfvfVertexIn@IRender_DetailModel@@V?$xalloc@UfvfVertexIn@IRender_DetailModel@@@@@std@@AAEXPAUfvfVertexIn@IRender_DetailModel@@0Uforward_iterator_tag@1@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
tv481 = 12						; size = 4
__Last$ = 12						; size = 4
___formal$ = 16						; size = 1
??$_Assign_range@PAUfvfVertexIn@IRender_DetailModel@@@?$vector@UfvfVertexIn@IRender_DetailModel@@V?$xalloc@UfvfVertexIn@IRender_DetailModel@@@@@std@@AAEXPAUfvfVertexIn@IRender_DetailModel@@0Uforward_iterator_tag@1@@Z PROC ; std::vector<IRender_DetailModel::fvfVertexIn,xalloc<IRender_DetailModel::fvfVertexIn> >::_Assign_range<IRender_DetailModel::fvfVertexIn *>, COMDAT
; _this$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility

; 1525 :         return _Last - _First; // assume the iterator will do debug checking

	mov	edx, DWORD PTR __First$[esp-4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1125 :     _CONSTEXPR20_CONTAINER void _Assign_range(_Iter _First, _Iter _Last, forward_iterator_tag) {

	push	ebx
	push	ebp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility

; 1525 :         return _Last - _First; // assume the iterator will do debug checking

	mov	ebp, DWORD PTR __Last$[esp+4]
	mov	eax, ebp
	sub	eax, edx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1125 :     _CONSTEXPR20_CONTAINER void _Assign_range(_Iter _First, _Iter _Last, forward_iterator_tag) {

	push	esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility

; 1525 :         return _Last - _First; // assume the iterator will do debug checking

	mov	DWORD PTR tv481[esp+8], eax
	sar	eax, 2
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1125 :     _CONSTEXPR20_CONTAINER void _Assign_range(_Iter _First, _Iter _Last, forward_iterator_tag) {

	push	edi
	mov	edi, ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility

; 1525 :         return _Last - _First; // assume the iterator will do debug checking

	imul	esi, eax, -858993459
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1151 :         auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);

	mov	eax, DWORD PTR [edi+4]
	mov	ebx, DWORD PTR [edi]
	sub	eax, ebx
	sar	eax, 2
	imul	ecx, eax, -858993459

; 1152 : 
; 1153 :         if (_Newsize > _Oldsize) {

	cmp	esi, ecx
	jbe	$LN2@Assign_ran

; 1154 :             const auto _Oldcapacity = static_cast<size_type>(_Myend - _Myfirst);

	mov	eax, DWORD PTR [edi+8]
	sub	eax, ebx
	sar	eax, 2
	imul	edx, eax, -858993459

; 1155 :             if (_Newsize > _Oldcapacity) { // reallocate

	cmp	esi, edx
	jbe	SHORT $LN4@Assign_ran

; 1337 :         if (_Newsize > max_size()) {

	cmp	esi, 214748364				; 0cccccccH
	ja	$LN71@Assign_ran

; 1675 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	ecx, edx
	mov	eax, 214748364				; 0cccccccH
	shr	ecx, 1
	sub	eax, ecx
	cmp	edx, eax
	jbe	SHORT $LN13@Assign_ran

; 1676 :             return _Max; // geometric growth would overflow

	mov	esi, 214748364				; 0cccccccH
	jmp	SHORT $LN14@Assign_ran
$LN13@Assign_ran:

; 1677 :         }
; 1678 : 
; 1679 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	lea	eax, DWORD PTR [ecx+edx]

; 1680 : 
; 1681 :         if (_Geometric < _Newsize) {

	cmp	eax, esi
	cmovb	eax, esi
	mov	esi, eax
$LN14@Assign_ran:

; 1343 :         if (_Myfirst) { // destroy and deallocate old array

	test	ebx, ebx
	je	SHORT $LN10@Assign_ran
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	ebx
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1347 :             _Myfirst = nullptr;

	mov	DWORD PTR [edi], 0

; 1348 :             _Mylast  = nullptr;

	mov	DWORD PTR [edi+4], 0

; 1349 :             _Myend   = nullptr;

	mov	DWORD PTR [edi+8], 0
$LN10@Assign_ran:
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	lea	esi, DWORD PTR [esi+esi*4]
	shl	esi, 2
	push	esi
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1698 :         const auto _Newvec = _Getal().allocate(_Newcapacity);

	mov	ebx, eax

; 1699 :         _Myfirst           = _Newvec;

	mov	DWORD PTR [edi], ebx

; 1700 :         _Mylast            = _Newvec;

	mov	DWORD PTR [edi+4], ebx

; 1701 :         _Myend             = _Newvec + _Newcapacity;

	lea	ecx, DWORD PTR [esi+ebx]
	mov	DWORD PTR [edi+8], ecx

; 1156 :                 _Clear_and_reserve_geometric(_Newsize);
; 1157 :                 _Oldsize = 0;

	xor	ecx, ecx
$LN4@Assign_ran:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility

; 1497 :         _Where += _Off;

	lea	esi, DWORD PTR [ecx+ecx*4]
	shl	esi, 2

; 4066 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	push	esi
	push	DWORD PTR __First$[esp+16]
	push	ebx
	call	_memmove

; 1497 :         _Where += _Off;

	mov	eax, DWORD PTR __First$[esp+24]

; 4066 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	add	esp, 12					; 0000000cH
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	edx, DWORD PTR [edi+4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility

; 1497 :         _Where += _Off;

	add	eax, esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1658 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	eax, ebp
	je	SHORT $LN45@Assign_ran
	npad	3
$LL46@Assign_ran:
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ecx
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR [edx+8], ecx
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR [edx+12], ecx
	mov	ecx, DWORD PTR [eax+16]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1658 :     for (; _UFirst != _ULast; ++_UFirst) {

	add	eax, 20					; 00000014H
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	DWORD PTR [edx+16], ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1621 :         ++_Last;

	add	edx, 20					; 00000014H

; 1658 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	eax, ebp
	jne	SHORT $LL46@Assign_ran
$LN45@Assign_ran:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1163 :             _Mylast = _Ucopy(_Mid, _Last, _Mylast);

	mov	DWORD PTR [edi+4], edx
	pop	edi

; 1169 :         }
; 1170 :     }

	pop	esi
	pop	ebp
	pop	ebx
	ret	12					; 0000000cH
$LN2@Assign_ran:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility

; 4066 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	push	DWORD PTR tv481[esp+12]
	push	edx
	push	ebx
	call	_memmove
	add	esp, 12					; 0000000cH
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1165 :             const pointer _Newlast = _Myfirst + _Newsize;

	lea	eax, DWORD PTR [esi+esi*4]
	lea	eax, DWORD PTR [ebx+eax*4]

; 1166 :             _Copy_unchecked(_First, _Last, _Myfirst);
; 1167 :             _Destroy(_Newlast, _Mylast);
; 1168 :             _Mylast = _Newlast;

	mov	DWORD PTR [edi+4], eax
	pop	edi

; 1169 :         }
; 1170 :     }

	pop	esi
	pop	ebp
	pop	ebx
	ret	12					; 0000000cH
$LN71@Assign_ran:

; 1338 :             _Xlength();

	call	?_Xlength@?$vector@UfvfVertexIn@IRender_DetailModel@@V?$xalloc@UfvfVertexIn@IRender_DetailModel@@@@@std@@CAXXZ ; std::vector<IRender_DetailModel::fvfVertexIn,xalloc<IRender_DetailModel::fvfVertexIn> >::_Xlength
$LN69@Assign_ran:
	int	3
??$_Assign_range@PAUfvfVertexIn@IRender_DetailModel@@@?$vector@UfvfVertexIn@IRender_DetailModel@@V?$xalloc@UfvfVertexIn@IRender_DetailModel@@@@@std@@AAEXPAUfvfVertexIn@IRender_DetailModel@@0Uforward_iterator_tag@1@@Z ENDP ; std::vector<IRender_DetailModel::fvfVertexIn,xalloc<IRender_DetailModel::fvfVertexIn> >::_Assign_range<IRender_DetailModel::fvfVertexIn *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@GV?$xalloc@G@@@std@@AAEXIABU_Value_init_tag@1@@Z
_TEXT	SEGMENT
__Backout$2 = -40					; size = 12
__Newvec$ = -28						; size = 4
__UFirst$3 = -24					; size = 4
__Newcapacity$1$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Newsize$ = 8						; size = 4
__Val$dead$ = 12					; size = 4
??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@GV?$xalloc@G@@@std@@AAEXIABU_Value_init_tag@1@@Z PROC ; std::vector<unsigned short,xalloc<unsigned short> >::_Resize_reallocate<std::_Value_init_tag>, COMDAT
; _this$ = ecx

; 1216 :     _CONSTEXPR20_CONTAINER void _Resize_reallocate(const size_type _Newsize, const _Ty2& _Val) {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@GV?$xalloc@G@@@std@@AAEXIABU_Value_init_tag@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 28					; 0000001cH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	esi, ecx

; 1217 :         if (_Newsize > max_size()) {

	mov	edx, DWORD PTR __Newsize$[ebp]
	cmp	edx, 2147483647				; 7fffffffH
	ja	$LN66@Resize_rea

; 1219 :         }
; 1220 : 
; 1221 :         auto& _My_data    = _Mypair._Myval2;
; 1222 :         pointer& _Myfirst = _My_data._Myfirst;
; 1223 :         pointer& _Mylast  = _My_data._Mylast;
; 1224 : 
; 1225 :         const auto _Oldsize          = static_cast<size_type>(_Mylast - _Myfirst);

	mov	edi, DWORD PTR [esi+4]
	sub	edi, DWORD PTR [esi]
	sar	edi, 1

; 1546 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	ecx, DWORD PTR [esi+8]
	sub	ecx, DWORD PTR [esi]
	sar	ecx, 1

; 1675 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	ebx, ecx
	shr	ebx, 1
	mov	eax, 2147483647				; 7fffffffH
	sub	eax, ebx
	cmp	ecx, eax
	jbe	SHORT $LN10@Resize_rea

; 1676 :             return _Max; // geometric growth would overflow

	mov	eax, 2147483647				; 7fffffffH
	jmp	SHORT $LN64@Resize_rea
$LN10@Resize_rea:

; 1677 :         }
; 1678 : 
; 1679 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	lea	eax, DWORD PTR [ebx+ecx]

; 1680 : 
; 1681 :         if (_Geometric < _Newsize) {

	cmp	eax, edx
	cmovb	eax, edx
$LN64@Resize_rea:
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	mov	DWORD PTR __Newcapacity$1$[ebp], eax
	add	eax, eax
	push	eax
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1228 :         const pointer _Newvec         = _Getal().allocate(_Newcapacity);

	mov	ebx, eax
	mov	DWORD PTR __Newvec$[ebp], ebx

; 1229 :         const pointer _Appended_first = _Newvec + _Oldsize;

	lea	ecx, DWORD PTR [ebx+edi*2]

; 1230 :         pointer _Appended_last        = _Appended_first;
; 1231 : 
; 1232 :         _TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 1233 :         _Appended_last = _Ufill(_Appended_first, _Newsize - _Oldsize, _Val);

	mov	eax, DWORD PTR __Newsize$[ebp]
	sub	eax, edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1807 :             _Zero_range(_PFirst, _PFirst + _Count);

	add	eax, eax

; 1792 :     _CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

	push	eax
	push	0
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1234 :         _Umove_if_noexcept(_Myfirst, _Mylast, _Newvec);

	mov	edi, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1703 :     auto _UFirst      = _Get_unwrapped(_First);

	mov	DWORD PTR __UFirst$3[ebp], ecx

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	DWORD PTR __Backout$2[ebp], ebx
	mov	edx, ebx
	mov	DWORD PTR __Backout$2[ebp+4], edx
	mov	DWORD PTR __Backout$2[ebp+8], esi
$LL43@Resize_rea:

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	ecx, edi
	je	SHORT $LN42@Resize_rea

; 1620 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

	mov	ax, WORD PTR [ecx]
	mov	WORD PTR [edx], ax

; 1621 :         ++_Last;

	add	edx, 2
	mov	DWORD PTR __Backout$2[ebp+4], edx

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	add	ecx, 2
	mov	DWORD PTR __UFirst$3[ebp], ecx
	jmp	SHORT $LL43@Resize_rea
$LN42@Resize_rea:

; 1625 :         _First = _Last;

	mov	DWORD PTR __Backout$2[ebp], edx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
	mov	DWORD PTR __$EHRec$[ebp+12], -1

; 1732 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN57@Resize_rea
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	push	eax
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN57@Resize_rea:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1737 :         _Myfirst = _Newvec;

	mov	DWORD PTR [esi], ebx

; 1738 :         _Mylast  = _Newvec + _Newsize;

	mov	eax, DWORD PTR __Newsize$[ebp]
	lea	eax, DWORD PTR [ebx+eax*2]
	mov	DWORD PTR [esi+4], eax

; 1739 :         _Myend   = _Newvec + _Newcapacity;

	mov	eax, DWORD PTR __Newcapacity$1$[ebp]
	lea	eax, DWORD PTR [ebx+eax*2]
	mov	DWORD PTR [esi+8], eax

; 1239 :         _CATCH_END
; 1240 : 
; 1241 :         _Change_array(_Newvec, _Newsize, _Newcapacity);
; 1242 :     }

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
__catch$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@GV?$xalloc@G@@@std@@AAEXIABU_Value_init_tag@1@@Z$0:

; 1235 :         _CATCH_ALL
; 1236 :         _Destroy(_Appended_first, _Appended_last);
; 1237 :         _Getal().deallocate(_Newvec, _Newcapacity);

	push	ecx
	push	DWORD PTR __Newvec$[ebp]
	call	?deallocate@?$xalloc@G@@QBEXPAGI@Z	; xalloc<unsigned short>::deallocate

; 1238 :         _RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$LN66@Resize_rea:

; 1218 :             _Xlength();

	call	?_Xlength@?$vector@GV?$xalloc@G@@@std@@CAXXZ ; std::vector<unsigned short,xalloc<unsigned short> >::_Xlength
$LN63@Resize_rea:
	int	3
	int	3
	int	3
	int	3
	int	3
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@GV?$xalloc@G@@@std@@AAEXIABU_Value_init_tag@1@@Z:
	npad	1
	npad	1
	mov	eax, OFFSET __ehfuncinfo$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@GV?$xalloc@G@@@std@@AAEXIABU_Value_init_tag@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@GV?$xalloc@G@@@std@@AAEXIABU_Value_init_tag@1@@Z ENDP ; std::vector<unsigned short,xalloc<unsigned short> >::_Resize_reallocate<std::_Value_init_tag>
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef
;	COMDAT ??$_Unfancy@UfvfVertexIn@IRender_DetailModel@@@std@@YAPAUfvfVertexIn@IRender_DetailModel@@PAU12@@Z
_TEXT	SEGMENT
??$_Unfancy@UfvfVertexIn@IRender_DetailModel@@@std@@YAPAUfvfVertexIn@IRender_DetailModel@@PAU12@@Z PROC ; std::_Unfancy<IRender_DetailModel::fvfVertexIn>, COMDAT
; __Ptr$ = ecx

; 266  :     return _Ptr;

	mov	eax, ecx

; 267  : }

	ret	0
??$_Unfancy@UfvfVertexIn@IRender_DetailModel@@@std@@YAPAUfvfVertexIn@IRender_DetailModel@@PAU12@@Z ENDP ; std::_Unfancy<IRender_DetailModel::fvfVertexIn>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$destroy@UfvfVertexIn@IRender_DetailModel@@@?$_Normal_allocator_traits@V?$xalloc@UfvfVertexIn@IRender_DetailModel@@@@@std@@SAXAAV?$xalloc@UfvfVertexIn@IRender_DetailModel@@@@PAUfvfVertexIn@IRender_DetailModel@@@Z
_TEXT	SEGMENT
??$destroy@UfvfVertexIn@IRender_DetailModel@@@?$_Normal_allocator_traits@V?$xalloc@UfvfVertexIn@IRender_DetailModel@@@@@std@@SAXAAV?$xalloc@UfvfVertexIn@IRender_DetailModel@@@@PAUfvfVertexIn@IRender_DetailModel@@@Z PROC ; std::_Normal_allocator_traits<xalloc<IRender_DetailModel::fvfVertexIn> >::destroy<IRender_DetailModel::fvfVertexIn>, COMDAT
; __Al$dead$ = ecx
; __Ptr$dead$ = edx

; 579  :         if constexpr (_Uses_default_destroy<_Alloc, _Ty*>::value) {
; 580  : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 581  :             _STD destroy_at(_Ptr);
; 582  : #else // __cpp_lib_constexpr_dynamic_alloc
; 583  :             _Ptr->~_Ty();
; 584  : #endif // __cpp_lib_constexpr_dynamic_alloc
; 585  :         } else {
; 586  :             _Al.destroy(_Ptr);
; 587  :         }
; 588  :     }

	ret	0
??$destroy@UfvfVertexIn@IRender_DetailModel@@@?$_Normal_allocator_traits@V?$xalloc@UfvfVertexIn@IRender_DetailModel@@@@@std@@SAXAAV?$xalloc@UfvfVertexIn@IRender_DetailModel@@@@PAUfvfVertexIn@IRender_DetailModel@@@Z ENDP ; std::_Normal_allocator_traits<xalloc<IRender_DetailModel::fvfVertexIn> >::destroy<IRender_DetailModel::fvfVertexIn>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef
;	COMDAT ??$_Unfancy@G@std@@YAPAGPAG@Z
_TEXT	SEGMENT
??$_Unfancy@G@std@@YAPAGPAG@Z PROC			; std::_Unfancy<unsigned short>, COMDAT
; __Ptr$ = ecx

; 266  :     return _Ptr;

	mov	eax, ecx

; 267  : }

	ret	0
??$_Unfancy@G@std@@YAPAGPAG@Z ENDP			; std::_Unfancy<unsigned short>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$destroy@G@?$_Normal_allocator_traits@V?$xalloc@G@@@std@@SAXAAV?$xalloc@G@@PAG@Z
_TEXT	SEGMENT
??$destroy@G@?$_Normal_allocator_traits@V?$xalloc@G@@@std@@SAXAAV?$xalloc@G@@PAG@Z PROC ; std::_Normal_allocator_traits<xalloc<unsigned short> >::destroy<unsigned short>, COMDAT
; __Al$dead$ = ecx
; __Ptr$dead$ = edx

; 579  :         if constexpr (_Uses_default_destroy<_Alloc, _Ty*>::value) {
; 580  : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 581  :             _STD destroy_at(_Ptr);
; 582  : #else // __cpp_lib_constexpr_dynamic_alloc
; 583  :             _Ptr->~_Ty();
; 584  : #endif // __cpp_lib_constexpr_dynamic_alloc
; 585  :         } else {
; 586  :             _Al.destroy(_Ptr);
; 587  :         }
; 588  :     }

	ret	0
??$destroy@G@?$_Normal_allocator_traits@V?$xalloc@G@@@std@@SAXAAV?$xalloc@G@@PAG@Z ENDP ; std::_Normal_allocator_traits<xalloc<unsigned short> >::destroy<unsigned short>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Uninitialized_value_construct_n@V?$xalloc@G@@@std@@YAPAGPAGIAAV?$xalloc@G@@@Z
_TEXT	SEGMENT
__Al$dead$ = 8						; size = 4
??$_Uninitialized_value_construct_n@V?$xalloc@G@@@std@@YAPAGPAGIAAV?$xalloc@G@@@Z PROC ; std::_Uninitialized_value_construct_n<xalloc<unsigned short> >, COMDAT
; __First$ = ecx
; __Count$ = edx

; 1798 :     _Alloc_ptr_t<_Alloc> _First, _Alloc_size_t<_Alloc> _Count, _Alloc& _Al) {

	push	esi
	push	edi

; 1799 :     // value-initialize _Count objects to raw _First, using _Al
; 1800 :     using _Ptrty = typename _Alloc::value_type*;
; 1801 :     if constexpr (_Use_memset_value_construct_v<_Ptrty> && _Uses_default_construct<_Alloc, _Ptrty>::value) {
; 1802 : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 1803 :         if (!_STD is_constant_evaluated())
; 1804 : #endif // __cpp_lib_constexpr_dynamic_alloc
; 1805 :         {
; 1806 :             auto _PFirst = _Unfancy(_First);
; 1807 :             _Zero_range(_PFirst, _PFirst + _Count);

	lea	esi, DWORD PTR [edx+edx]
	mov	edi, ecx

; 1792 :     _CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

	push	esi
	push	0
	push	edi
	call	_memset
	add	esp, 12					; 0000000cH

; 1808 :             return _First + _Count;

	lea	eax, DWORD PTR [esi+edi]
	pop	edi
	pop	esi

; 1809 :         }
; 1810 :     }
; 1811 : 
; 1812 :     _Uninitialized_backout_al<_Alloc> _Backout{_First, _Al};
; 1813 :     for (; 0 < _Count; --_Count) {
; 1814 :         _Backout._Emplace_back();
; 1815 :     }
; 1816 : 
; 1817 :     return _Backout._Release();
; 1818 : }

	ret	0
??$_Uninitialized_value_construct_n@V?$xalloc@G@@@std@@YAPAGPAGIAAV?$xalloc@G@@@Z ENDP ; std::_Uninitialized_value_construct_n<xalloc<unsigned short> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Release@?$_Uninitialized_backout_al@V?$xalloc@G@@@std@@QAEPAGXZ
_TEXT	SEGMENT
?_Release@?$_Uninitialized_backout_al@V?$xalloc@G@@@std@@QAEPAGXZ PROC ; std::_Uninitialized_backout_al<xalloc<unsigned short> >::_Release, COMDAT
; _this$ = ecx

; 1625 :         _First = _Last;

	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [ecx], eax

; 1626 :         return _Last;
; 1627 :     }

	ret	0
?_Release@?$_Uninitialized_backout_al@V?$xalloc@G@@@std@@QAEPAGXZ ENDP ; std::_Uninitialized_backout_al<xalloc<unsigned short> >::_Release
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??1?$_Uninitialized_backout_al@V?$xalloc@G@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Uninitialized_backout_al@V?$xalloc@G@@@std@@QAE@XZ PROC ; std::_Uninitialized_backout_al<xalloc<unsigned short> >::~_Uninitialized_backout_al<xalloc<unsigned short> >, COMDAT
; _this$ = ecx

; 1615 :         _Destroy_range(_First, _Last, _Al);
; 1616 :     }

	ret	0
??1?$_Uninitialized_backout_al@V?$xalloc@G@@@std@@QAE@XZ ENDP ; std::_Uninitialized_backout_al<xalloc<unsigned short> >::~_Uninitialized_backout_al<xalloc<unsigned short> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??0?$_Uninitialized_backout_al@V?$xalloc@G@@@std@@QAE@PAGAAV?$xalloc@G@@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Al_$ = 12						; size = 4
??0?$_Uninitialized_backout_al@V?$xalloc@G@@@std@@QAE@PAGAAV?$xalloc@G@@@Z PROC ; std::_Uninitialized_backout_al<xalloc<unsigned short> >::_Uninitialized_backout_al<xalloc<unsigned short> >, COMDAT
; _this$ = ecx

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	eax, DWORD PTR __Dest$[esp-4]
	mov	DWORD PTR [ecx], eax
	mov	DWORD PTR [ecx+4], eax
	mov	eax, DWORD PTR __Al_$[esp-4]
	mov	DWORD PTR [ecx+8], eax
	mov	eax, ecx
	ret	8
??0?$_Uninitialized_backout_al@V?$xalloc@G@@@std@@QAE@PAGAAV?$xalloc@G@@@Z ENDP ; std::_Uninitialized_backout_al<xalloc<unsigned short> >::_Uninitialized_backout_al<xalloc<unsigned short> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Clear_and_reserve_geometric@?$vector@UfvfVertexIn@IRender_DetailModel@@V?$xalloc@UfvfVertexIn@IRender_DetailModel@@@@@std@@AAEXI@Z
_TEXT	SEGMENT
__Newsize$ = 8						; size = 4
?_Clear_and_reserve_geometric@?$vector@UfvfVertexIn@IRender_DetailModel@@V?$xalloc@UfvfVertexIn@IRender_DetailModel@@@@@std@@AAEXI@Z PROC ; std::vector<IRender_DetailModel::fvfVertexIn,xalloc<IRender_DetailModel::fvfVertexIn> >::_Clear_and_reserve_geometric, COMDAT
; _this$ = ecx

; 1326 :     _CONSTEXPR20_CONTAINER void _Clear_and_reserve_geometric(const size_type _Newsize) {

	push	edi
	mov	edi, ecx

; 1327 :         auto& _My_data    = _Mypair._Myval2;
; 1328 :         pointer& _Myfirst = _My_data._Myfirst;
; 1329 :         pointer& _Mylast  = _My_data._Mylast;
; 1330 :         pointer& _Myend   = _My_data._Myend;
; 1331 : 
; 1332 : #if _ITERATOR_DEBUG_LEVEL != 0 && defined(_ENABLE_STL_INTERNAL_CHECK)
; 1333 :         _STL_INTERNAL_CHECK(_Newsize != 0);
; 1334 :         _Check_all_orphaned();
; 1335 : #endif // _ITERATOR_DEBUG_LEVEL != 0 && defined(_ENABLE_STL_INTERNAL_CHECK)
; 1336 : 
; 1337 :         if (_Newsize > max_size()) {

	mov	ecx, DWORD PTR __Newsize$[esp]
	cmp	ecx, 214748364				; 0cccccccH
	ja	SHORT $LN24@Clear_and_

; 1546 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	eax, DWORD PTR [edi+8]
	mov	edx, DWORD PTR [edi]
	sub	eax, edx
	sar	eax, 2
	push	ebx
	imul	ebx, eax, -858993459

; 1675 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	eax, 214748364				; 0cccccccH
	push	esi
	mov	esi, ebx
	shr	esi, 1
	sub	eax, esi
	cmp	ebx, eax
	jbe	SHORT $LN6@Clear_and_

; 1676 :             return _Max; // geometric growth would overflow

	mov	esi, 214748364				; 0cccccccH
	jmp	SHORT $LN7@Clear_and_
$LN6@Clear_and_:

; 1677 :         }
; 1678 : 
; 1679 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	add	esi, ebx

; 1680 : 
; 1681 :         if (_Geometric < _Newsize) {

	cmp	esi, ecx
	cmovb	esi, ecx
$LN7@Clear_and_:

; 1339 :         }
; 1340 : 
; 1341 :         const size_type _Newcapacity = _Calculate_growth(_Newsize);
; 1342 : 
; 1343 :         if (_Myfirst) { // destroy and deallocate old array

	test	edx, edx
	je	SHORT $LN3@Clear_and_
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	edx
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1347 :             _Myfirst = nullptr;

	mov	DWORD PTR [edi], 0

; 1348 :             _Mylast  = nullptr;

	mov	DWORD PTR [edi+4], 0

; 1349 :             _Myend   = nullptr;

	mov	DWORD PTR [edi+8], 0
$LN3@Clear_and_:
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	lea	esi, DWORD PTR [esi+esi*4]
	shl	esi, 2
	push	esi
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1699 :         _Myfirst           = _Newvec;

	mov	DWORD PTR [edi], eax

; 1700 :         _Mylast            = _Newvec;

	mov	DWORD PTR [edi+4], eax

; 1701 :         _Myend             = _Newvec + _Newcapacity;

	add	eax, esi
	pop	esi
	pop	ebx
	mov	DWORD PTR [edi+8], eax
	pop	edi

; 1350 :         }
; 1351 : 
; 1352 :         _Buy_raw(_Newcapacity);
; 1353 :     }

	ret	4
$LN24@Clear_and_:

; 1338 :             _Xlength();

	call	?_Xlength@?$vector@UfvfVertexIn@IRender_DetailModel@@V?$xalloc@UfvfVertexIn@IRender_DetailModel@@@@@std@@CAXXZ ; std::vector<IRender_DetailModel::fvfVertexIn,xalloc<IRender_DetailModel::fvfVertexIn> >::_Xlength
$LN22@Clear_and_:
	int	3
?_Clear_and_reserve_geometric@?$vector@UfvfVertexIn@IRender_DetailModel@@V?$xalloc@UfvfVertexIn@IRender_DetailModel@@@@@std@@AAEXI@Z ENDP ; std::vector<IRender_DetailModel::fvfVertexIn,xalloc<IRender_DetailModel::fvfVertexIn> >::_Clear_and_reserve_geometric
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?destroy@?$xalloc@UfvfVertexIn@IRender_DetailModel@@@@QAEXPAUfvfVertexIn@IRender_DetailModel@@@Z
_TEXT	SEGMENT
_p$dead$ = 8						; size = 4
?destroy@?$xalloc@UfvfVertexIn@IRender_DetailModel@@@@QAEXPAUfvfVertexIn@IRender_DetailModel@@@Z PROC ; xalloc<IRender_DetailModel::fvfVertexIn>::destroy, COMDAT
; _this$dead$ = ecx

; 85   : 							void					destroy			(pointer p)								{	std::_Destroy_in_place(p);			}

	ret	4
?destroy@?$xalloc@UfvfVertexIn@IRender_DetailModel@@@@QAEXPAUfvfVertexIn@IRender_DetailModel@@@Z ENDP ; xalloc<IRender_DetailModel::fvfVertexIn>::destroy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Xlength@?$vector@GV?$xalloc@G@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@GV?$xalloc@G@@@std@@CAXXZ PROC	; std::vector<unsigned short,xalloc<unsigned short> >::_Xlength, COMDAT

; 1761 :         _Xlength_error("vector too long");

	push	OFFSET ??_C@_0BA@FOIKENOD@vector?5too?5long@
	call	DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN3@Xlength:
	int	3
?_Xlength@?$vector@GV?$xalloc@G@@@std@@CAXXZ ENDP	; std::vector<unsigned short,xalloc<unsigned short> >::_Xlength
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Change_array@?$vector@GV?$xalloc@G@@@std@@AAEXQAGII@Z
_TEXT	SEGMENT
__Newvec$ = 8						; size = 4
__Newsize$ = 12						; size = 4
__Newcapacity$ = 16					; size = 4
?_Change_array@?$vector@GV?$xalloc@G@@@std@@AAEXQAGII@Z PROC ; std::vector<unsigned short,xalloc<unsigned short> >::_Change_array, COMDAT
; _this$ = ecx

; 1723 :         const pointer _Newvec, const size_type _Newsize, const size_type _Newcapacity) {

	push	esi
	mov	esi, ecx

; 1724 :         // orphan all iterators, discard old array, acquire new array
; 1725 :         auto& _My_data    = _Mypair._Myval2;
; 1726 :         pointer& _Myfirst = _My_data._Myfirst;
; 1727 :         pointer& _Mylast  = _My_data._Mylast;
; 1728 :         pointer& _Myend   = _My_data._Myend;
; 1729 : 
; 1730 :         _My_data._Orphan_all();
; 1731 : 
; 1732 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN7@Change_arr
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN7@Change_arr:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1737 :         _Myfirst = _Newvec;

	mov	ecx, DWORD PTR __Newvec$[esp]

; 1738 :         _Mylast  = _Newvec + _Newsize;

	mov	eax, DWORD PTR __Newsize$[esp]
	mov	DWORD PTR [esi], ecx
	lea	eax, DWORD PTR [ecx+eax*2]
	mov	DWORD PTR [esi+4], eax

; 1739 :         _Myend   = _Newvec + _Newcapacity;

	mov	eax, DWORD PTR __Newcapacity$[esp]
	lea	eax, DWORD PTR [ecx+eax*2]
	mov	DWORD PTR [esi+8], eax
	pop	esi

; 1740 :     }

	ret	12					; 0000000cH
?_Change_array@?$vector@GV?$xalloc@G@@@std@@AAEXQAGII@Z ENDP ; std::vector<unsigned short,xalloc<unsigned short> >::_Change_array
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Calculate_growth@?$vector@GV?$xalloc@G@@@std@@ABEII@Z
_TEXT	SEGMENT
__Newsize$ = 8						; size = 4
?_Calculate_growth@?$vector@GV?$xalloc@G@@@std@@ABEII@Z PROC ; std::vector<unsigned short,xalloc<unsigned short> >::_Calculate_growth, COMDAT
; _this$ = ecx

; 1546 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	edx, DWORD PTR [ecx+8]
	sub	edx, DWORD PTR [ecx]

; 1671 :         // given _Oldcapacity and _Newsize, calculate geometric growth
; 1672 :         const size_type _Oldcapacity = capacity();
; 1673 :         const auto _Max              = max_size();
; 1674 : 
; 1675 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	ecx, 2147483647				; 7fffffffH

; 1546 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	sar	edx, 1

; 1670 :     _CONSTEXPR20_CONTAINER size_type _Calculate_growth(const size_type _Newsize) const {

	push	esi

; 1671 :         // given _Oldcapacity and _Newsize, calculate geometric growth
; 1672 :         const size_type _Oldcapacity = capacity();
; 1673 :         const auto _Max              = max_size();
; 1674 : 
; 1675 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	esi, edx
	shr	esi, 1
	sub	ecx, esi
	cmp	edx, ecx
	jbe	SHORT $LN2@Calculate_

; 1676 :             return _Max; // geometric growth would overflow

	mov	eax, 2147483647				; 7fffffffH
	pop	esi

; 1682 :             return _Newsize; // geometric growth would be insufficient
; 1683 :         }
; 1684 : 
; 1685 :         return _Geometric; // geometric growth is sufficient
; 1686 :     }

	ret	4
$LN2@Calculate_:

; 1677 :         }
; 1678 : 
; 1679 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	lea	eax, DWORD PTR [esi+edx]

; 1680 : 
; 1681 :         if (_Geometric < _Newsize) {

	cmp	eax, DWORD PTR __Newsize$[esp]
	pop	esi
	cmovb	eax, DWORD PTR __Newsize$[esp-4]

; 1682 :             return _Newsize; // geometric growth would be insufficient
; 1683 :         }
; 1684 : 
; 1685 :         return _Geometric; // geometric growth is sufficient
; 1686 :     }

	ret	4
?_Calculate_growth@?$vector@GV?$xalloc@G@@@std@@ABEII@Z ENDP ; std::vector<unsigned short,xalloc<unsigned short> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Umove_if_noexcept@?$vector@GV?$xalloc@G@@@std@@AAEXPAG00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
?_Umove_if_noexcept@?$vector@GV?$xalloc@G@@@std@@AAEXPAG00@Z PROC ; std::vector<unsigned short,xalloc<unsigned short> >::_Umove_if_noexcept, COMDAT
; _this$dead$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1703 :     auto _UFirst      = _Get_unwrapped(_First);

	mov	eax, DWORD PTR __First$[esp-4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1659 :     _CONSTEXPR20_CONTAINER void _Umove_if_noexcept(pointer _First, pointer _Last, pointer _Dest) {

	push	esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	mov	esi, DWORD PTR __Last$[esp]
	cmp	eax, esi
	je	SHORT $LN7@Umove_if_n

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	edx, DWORD PTR __Dest$[esp]
	sub	edx, eax
$LL8@Umove_if_n:

; 1620 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

	mov	cx, WORD PTR [eax]
	mov	WORD PTR [edx+eax], cx

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	add	eax, 2
	cmp	eax, esi
	jne	SHORT $LL8@Umove_if_n
$LN7@Umove_if_n:
	pop	esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1663 :     }

	ret	12					; 0000000cH
?_Umove_if_noexcept@?$vector@GV?$xalloc@G@@@std@@AAEXPAG00@Z ENDP ; std::vector<unsigned short,xalloc<unsigned short> >::_Umove_if_noexcept
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?max_size@?$vector@GV?$xalloc@G@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@GV?$xalloc@G@@@std@@QBEIXZ PROC	; std::vector<unsigned short,xalloc<unsigned short> >::max_size, COMDAT
; _this$dead$ = ecx

; 1540 :         return (_STD min)(

	mov	eax, 2147483647				; 7fffffffH

; 1541 :             static_cast<size_type>((numeric_limits<difference_type>::max)()), _Alty_traits::max_size(_Getal()));
; 1542 :     }

	ret	0
?max_size@?$vector@GV?$xalloc@G@@@std@@QBEIXZ ENDP	; std::vector<unsigned short,xalloc<unsigned short> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Clear_and_reserve_geometric@?$vector@GV?$xalloc@G@@@std@@AAEXI@Z
_TEXT	SEGMENT
__Newsize$ = 8						; size = 4
?_Clear_and_reserve_geometric@?$vector@GV?$xalloc@G@@@std@@AAEXI@Z PROC ; std::vector<unsigned short,xalloc<unsigned short> >::_Clear_and_reserve_geometric, COMDAT
; _this$ = ecx

; 1326 :     _CONSTEXPR20_CONTAINER void _Clear_and_reserve_geometric(const size_type _Newsize) {

	push	ebp

; 1327 :         auto& _My_data    = _Mypair._Myval2;
; 1328 :         pointer& _Myfirst = _My_data._Myfirst;
; 1329 :         pointer& _Mylast  = _My_data._Mylast;
; 1330 :         pointer& _Myend   = _My_data._Myend;
; 1331 : 
; 1332 : #if _ITERATOR_DEBUG_LEVEL != 0 && defined(_ENABLE_STL_INTERNAL_CHECK)
; 1333 :         _STL_INTERNAL_CHECK(_Newsize != 0);
; 1334 :         _Check_all_orphaned();
; 1335 : #endif // _ITERATOR_DEBUG_LEVEL != 0 && defined(_ENABLE_STL_INTERNAL_CHECK)
; 1336 : 
; 1337 :         if (_Newsize > max_size()) {

	mov	ebp, DWORD PTR __Newsize$[esp]
	push	edi
	mov	edi, ecx
	cmp	ebp, 2147483647				; 7fffffffH
	ja	SHORT $LN24@Clear_and_

; 1546 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	ecx, DWORD PTR [edi+8]

; 1675 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	eax, 2147483647				; 7fffffffH
	push	ebx

; 1546 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	ebx, DWORD PTR [edi]
	sub	ecx, ebx
	sar	ecx, 1

; 1675 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	edx, ecx
	shr	edx, 1
	sub	eax, edx
	push	esi
	cmp	ecx, eax
	jbe	SHORT $LN6@Clear_and_

; 1676 :             return _Max; // geometric growth would overflow

	mov	esi, 2147483647				; 7fffffffH
	jmp	SHORT $LN7@Clear_and_
$LN6@Clear_and_:

; 1677 :         }
; 1678 : 
; 1679 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	lea	esi, DWORD PTR [edx+ecx]

; 1680 : 
; 1681 :         if (_Geometric < _Newsize) {

	cmp	esi, ebp
	cmovb	esi, ebp
$LN7@Clear_and_:

; 1339 :         }
; 1340 : 
; 1341 :         const size_type _Newcapacity = _Calculate_growth(_Newsize);
; 1342 : 
; 1343 :         if (_Myfirst) { // destroy and deallocate old array

	test	ebx, ebx
	je	SHORT $LN3@Clear_and_
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	ebx
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1347 :             _Myfirst = nullptr;

	mov	DWORD PTR [edi], 0

; 1348 :             _Mylast  = nullptr;

	mov	DWORD PTR [edi+4], 0

; 1349 :             _Myend   = nullptr;

	mov	DWORD PTR [edi+8], 0
$LN3@Clear_and_:
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	add	esi, esi
	push	esi
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1699 :         _Myfirst           = _Newvec;

	mov	DWORD PTR [edi], eax

; 1700 :         _Mylast            = _Newvec;

	mov	DWORD PTR [edi+4], eax

; 1701 :         _Myend             = _Newvec + _Newcapacity;

	add	eax, esi
	pop	esi
	pop	ebx
	mov	DWORD PTR [edi+8], eax
	pop	edi

; 1350 :         }
; 1351 : 
; 1352 :         _Buy_raw(_Newcapacity);
; 1353 :     }

	pop	ebp
	ret	4
$LN24@Clear_and_:

; 1338 :             _Xlength();

	call	?_Xlength@?$vector@GV?$xalloc@G@@@std@@CAXXZ ; std::vector<unsigned short,xalloc<unsigned short> >::_Xlength
$LN22@Clear_and_:
	int	3
?_Clear_and_reserve_geometric@?$vector@GV?$xalloc@G@@@std@@AAEXI@Z ENDP ; std::vector<unsigned short,xalloc<unsigned short> >::_Clear_and_reserve_geometric
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?destroy@?$xalloc@G@@QAEXPAG@Z
_TEXT	SEGMENT
_p$dead$ = 8						; size = 4
?destroy@?$xalloc@G@@QAEXPAG@Z PROC			; xalloc<unsigned short>::destroy, COMDAT
; _this$dead$ = ecx

; 85   : 							void					destroy			(pointer p)								{	std::_Destroy_in_place(p);			}

	ret	4
?destroy@?$xalloc@G@@QAEXPAG@Z ENDP			; xalloc<unsigned short>::destroy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?allocate@?$xalloc@G@@QBEPAGIPBX@Z
_TEXT	SEGMENT
_n$ = 8							; size = 4
_p$dead$ = 12						; size = 4
?allocate@?$xalloc@G@@QBEPAGIPBX@Z PROC			; xalloc<unsigned short>::allocate, COMDAT
; _this$dead$ = ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	mov	eax, DWORD PTR _n$[esp-4]
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	add	eax, eax
	push	eax
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 80   : 							pointer					allocate		(size_type n, const void* p=0) const	{	return xr_alloc<T>((u32)n);	}

	ret	8
?allocate@?$xalloc@G@@QBEPAGIPBX@Z ENDP			; xalloc<unsigned short>::allocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Xlength@?$vector@UfvfVertexIn@IRender_DetailModel@@V?$xalloc@UfvfVertexIn@IRender_DetailModel@@@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@UfvfVertexIn@IRender_DetailModel@@V?$xalloc@UfvfVertexIn@IRender_DetailModel@@@@@std@@CAXXZ PROC ; std::vector<IRender_DetailModel::fvfVertexIn,xalloc<IRender_DetailModel::fvfVertexIn> >::_Xlength, COMDAT

; 1761 :         _Xlength_error("vector too long");

	push	OFFSET ??_C@_0BA@FOIKENOD@vector?5too?5long@
	call	DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN3@Xlength:
	int	3
?_Xlength@?$vector@UfvfVertexIn@IRender_DetailModel@@V?$xalloc@UfvfVertexIn@IRender_DetailModel@@@@@std@@CAXXZ ENDP ; std::vector<IRender_DetailModel::fvfVertexIn,xalloc<IRender_DetailModel::fvfVertexIn> >::_Xlength
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Buy_raw@?$vector@UfvfVertexIn@IRender_DetailModel@@V?$xalloc@UfvfVertexIn@IRender_DetailModel@@@@@std@@AAEXI@Z
_TEXT	SEGMENT
__Newcapacity$ = 8					; size = 4
?_Buy_raw@?$vector@UfvfVertexIn@IRender_DetailModel@@V?$xalloc@UfvfVertexIn@IRender_DetailModel@@@@@std@@AAEXI@Z PROC ; std::vector<IRender_DetailModel::fvfVertexIn,xalloc<IRender_DetailModel::fvfVertexIn> >::_Buy_raw, COMDAT
; _this$ = ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	mov	eax, DWORD PTR __Newcapacity$[esp-4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1688 :     _CONSTEXPR20_CONTAINER void _Buy_raw(const size_type _Newcapacity) {

	push	esi
	push	edi
	mov	edi, ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	lea	esi, DWORD PTR [eax+eax*4]
	shl	esi, 2
	push	esi
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1699 :         _Myfirst           = _Newvec;

	mov	DWORD PTR [edi], eax

; 1700 :         _Mylast            = _Newvec;

	mov	DWORD PTR [edi+4], eax

; 1701 :         _Myend             = _Newvec + _Newcapacity;

	add	eax, esi
	mov	DWORD PTR [edi+8], eax
	pop	edi
	pop	esi

; 1702 :     }

	ret	4
?_Buy_raw@?$vector@UfvfVertexIn@IRender_DetailModel@@V?$xalloc@UfvfVertexIn@IRender_DetailModel@@@@@std@@AAEXI@Z ENDP ; std::vector<IRender_DetailModel::fvfVertexIn,xalloc<IRender_DetailModel::fvfVertexIn> >::_Buy_raw
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Calculate_growth@?$vector@UfvfVertexIn@IRender_DetailModel@@V?$xalloc@UfvfVertexIn@IRender_DetailModel@@@@@std@@ABEII@Z
_TEXT	SEGMENT
__Newsize$ = 8						; size = 4
?_Calculate_growth@?$vector@UfvfVertexIn@IRender_DetailModel@@V?$xalloc@UfvfVertexIn@IRender_DetailModel@@@@@std@@ABEII@Z PROC ; std::vector<IRender_DetailModel::fvfVertexIn,xalloc<IRender_DetailModel::fvfVertexIn> >::_Calculate_growth, COMDAT
; _this$ = ecx

; 1546 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx]

; 1671 :         // given _Oldcapacity and _Newsize, calculate geometric growth
; 1672 :         const size_type _Oldcapacity = capacity();
; 1673 :         const auto _Max              = max_size();
; 1674 : 
; 1675 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	ecx, 214748364				; 0cccccccH

; 1546 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	sar	eax, 2

; 1670 :     _CONSTEXPR20_CONTAINER size_type _Calculate_growth(const size_type _Newsize) const {

	push	esi

; 1546 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	imul	esi, eax, -858993459

; 1671 :         // given _Oldcapacity and _Newsize, calculate geometric growth
; 1672 :         const size_type _Oldcapacity = capacity();
; 1673 :         const auto _Max              = max_size();
; 1674 : 
; 1675 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	edx, esi
	shr	edx, 1
	sub	ecx, edx
	cmp	esi, ecx
	jbe	SHORT $LN2@Calculate_

; 1676 :             return _Max; // geometric growth would overflow

	mov	eax, 214748364				; 0cccccccH
	pop	esi

; 1682 :             return _Newsize; // geometric growth would be insufficient
; 1683 :         }
; 1684 : 
; 1685 :         return _Geometric; // geometric growth is sufficient
; 1686 :     }

	ret	4
$LN2@Calculate_:

; 1677 :         }
; 1678 : 
; 1679 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	lea	eax, DWORD PTR [edx+esi]

; 1680 : 
; 1681 :         if (_Geometric < _Newsize) {

	cmp	eax, DWORD PTR __Newsize$[esp]
	pop	esi
	cmovb	eax, DWORD PTR __Newsize$[esp-4]

; 1682 :             return _Newsize; // geometric growth would be insufficient
; 1683 :         }
; 1684 : 
; 1685 :         return _Geometric; // geometric growth is sufficient
; 1686 :     }

	ret	4
?_Calculate_growth@?$vector@UfvfVertexIn@IRender_DetailModel@@V?$xalloc@UfvfVertexIn@IRender_DetailModel@@@@@std@@ABEII@Z ENDP ; std::vector<IRender_DetailModel::fvfVertexIn,xalloc<IRender_DetailModel::fvfVertexIn> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?max_size@?$vector@UfvfVertexIn@IRender_DetailModel@@V?$xalloc@UfvfVertexIn@IRender_DetailModel@@@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@UfvfVertexIn@IRender_DetailModel@@V?$xalloc@UfvfVertexIn@IRender_DetailModel@@@@@std@@QBEIXZ PROC ; std::vector<IRender_DetailModel::fvfVertexIn,xalloc<IRender_DetailModel::fvfVertexIn> >::max_size, COMDAT
; _this$dead$ = ecx

; 1540 :         return (_STD min)(

	mov	eax, 214748364				; 0cccccccH

; 1541 :             static_cast<size_type>((numeric_limits<difference_type>::max)()), _Alty_traits::max_size(_Getal()));
; 1542 :     }

	ret	0
?max_size@?$vector@UfvfVertexIn@IRender_DetailModel@@V?$xalloc@UfvfVertexIn@IRender_DetailModel@@@@@std@@QBEIXZ ENDP ; std::vector<IRender_DetailModel::fvfVertexIn,xalloc<IRender_DetailModel::fvfVertexIn> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Getal@?$vector@GV?$xalloc@G@@@std@@ABEABV?$xalloc@G@@XZ
_TEXT	SEGMENT
?_Getal@?$vector@GV?$xalloc@G@@@std@@ABEABV?$xalloc@G@@XZ PROC ; std::vector<unsigned short,xalloc<unsigned short> >::_Getal, COMDAT
; _this$ = ecx

; 1809 :         return _Mypair._Get_first();

	mov	eax, ecx

; 1810 :     }

	ret	0
?_Getal@?$vector@GV?$xalloc@G@@@std@@ABEABV?$xalloc@G@@XZ ENDP ; std::vector<unsigned short,xalloc<unsigned short> >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Buy_raw@?$vector@GV?$xalloc@G@@@std@@AAEXI@Z
_TEXT	SEGMENT
__Newcapacity$ = 8					; size = 4
?_Buy_raw@?$vector@GV?$xalloc@G@@@std@@AAEXI@Z PROC	; std::vector<unsigned short,xalloc<unsigned short> >::_Buy_raw, COMDAT
; _this$ = ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	mov	eax, DWORD PTR __Newcapacity$[esp-4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1688 :     _CONSTEXPR20_CONTAINER void _Buy_raw(const size_type _Newcapacity) {

	push	esi
	push	edi
	mov	edi, ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	lea	esi, DWORD PTR [eax+eax]
	push	esi
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1699 :         _Myfirst           = _Newvec;

	mov	DWORD PTR [edi], eax

; 1700 :         _Mylast            = _Newvec;

	mov	DWORD PTR [edi+4], eax

; 1701 :         _Myend             = _Newvec + _Newcapacity;

	add	eax, esi
	mov	DWORD PTR [edi+8], eax
	pop	edi
	pop	esi

; 1702 :     }

	ret	4
?_Buy_raw@?$vector@GV?$xalloc@G@@@std@@AAEXI@Z ENDP	; std::vector<unsigned short,xalloc<unsigned short> >::_Buy_raw
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Umove_if_noexcept1@?$vector@GV?$xalloc@G@@@std@@AAEXPAG00U?$integral_constant@_N$00@2@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
?_Umove_if_noexcept1@?$vector@GV?$xalloc@G@@@std@@AAEXPAG00U?$integral_constant@_N$00@2@@Z PROC ; std::vector<unsigned short,xalloc<unsigned short> >::_Umove_if_noexcept1, COMDAT
; _this$dead$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1703 :     auto _UFirst      = _Get_unwrapped(_First);

	mov	eax, DWORD PTR __First$[esp-4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1649 :     _CONSTEXPR20_CONTAINER void _Umove_if_noexcept1(pointer _First, pointer _Last, pointer _Dest, true_type) {

	push	esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	mov	esi, DWORD PTR __Last$[esp]
	cmp	eax, esi
	je	SHORT $LN5@Umove_if_n

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	edx, DWORD PTR __Dest$[esp]
	sub	edx, eax
$LL6@Umove_if_n:

; 1620 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

	mov	cx, WORD PTR [eax]
	mov	WORD PTR [edx+eax], cx

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	add	eax, 2
	cmp	eax, esi
	jne	SHORT $LL6@Umove_if_n
$LN5@Umove_if_n:
	pop	esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1652 :     }

	ret	16					; 00000010H
?_Umove_if_noexcept1@?$vector@GV?$xalloc@G@@@std@@AAEXPAG00U?$integral_constant@_N$00@2@@Z ENDP ; std::vector<unsigned short,xalloc<unsigned short> >::_Umove_if_noexcept1
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?capacity@?$vector@GV?$xalloc@G@@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@GV?$xalloc@G@@@std@@QBEIXZ PROC	; std::vector<unsigned short,xalloc<unsigned short> >::capacity, COMDAT
; _this$ = ecx

; 1545 :         auto& _My_data = _Mypair._Myval2;
; 1546 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx]
	sar	eax, 1

; 1547 :     }

	ret	0
?capacity@?$vector@GV?$xalloc@G@@@std@@QBEIXZ ENDP	; std::vector<unsigned short,xalloc<unsigned short> >::capacity
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?max_size@?$_Normal_allocator_traits@V?$xalloc@G@@@std@@SAIABV?$xalloc@G@@@Z
_TEXT	SEGMENT
?max_size@?$_Normal_allocator_traits@V?$xalloc@G@@@std@@SAIABV?$xalloc@G@@@Z PROC ; std::_Normal_allocator_traits<xalloc<unsigned short> >::max_size, COMDAT
; __Al$dead$ = ecx

; 591  :         if constexpr (_Has_max_size<_Alloc>::value) {
; 592  :             return _Al.max_size();

	mov	eax, 2147483647				; 7fffffffH

; 593  :         } else {
; 594  :             return (numeric_limits<size_type>::max)() / sizeof(value_type);
; 595  :         }
; 596  :     }

	ret	0
?max_size@?$_Normal_allocator_traits@V?$xalloc@G@@@std@@SAIABV?$xalloc@G@@@Z ENDP ; std::_Normal_allocator_traits<xalloc<unsigned short> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Getal@?$vector@UfvfVertexIn@IRender_DetailModel@@V?$xalloc@UfvfVertexIn@IRender_DetailModel@@@@@std@@ABEABV?$xalloc@UfvfVertexIn@IRender_DetailModel@@@@XZ
_TEXT	SEGMENT
?_Getal@?$vector@UfvfVertexIn@IRender_DetailModel@@V?$xalloc@UfvfVertexIn@IRender_DetailModel@@@@@std@@ABEABV?$xalloc@UfvfVertexIn@IRender_DetailModel@@@@XZ PROC ; std::vector<IRender_DetailModel::fvfVertexIn,xalloc<IRender_DetailModel::fvfVertexIn> >::_Getal, COMDAT
; _this$ = ecx

; 1809 :         return _Mypair._Get_first();

	mov	eax, ecx

; 1810 :     }

	ret	0
?_Getal@?$vector@UfvfVertexIn@IRender_DetailModel@@V?$xalloc@UfvfVertexIn@IRender_DetailModel@@@@@std@@ABEABV?$xalloc@UfvfVertexIn@IRender_DetailModel@@@@XZ ENDP ; std::vector<IRender_DetailModel::fvfVertexIn,xalloc<IRender_DetailModel::fvfVertexIn> >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?capacity@?$vector@UfvfVertexIn@IRender_DetailModel@@V?$xalloc@UfvfVertexIn@IRender_DetailModel@@@@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@UfvfVertexIn@IRender_DetailModel@@V?$xalloc@UfvfVertexIn@IRender_DetailModel@@@@@std@@QBEIXZ PROC ; std::vector<IRender_DetailModel::fvfVertexIn,xalloc<IRender_DetailModel::fvfVertexIn> >::capacity, COMDAT
; _this$ = ecx

; 1545 :         auto& _My_data = _Mypair._Myval2;
; 1546 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx]
	sar	eax, 2
	imul	eax, eax, -858993459

; 1547 :     }

	ret	0
?capacity@?$vector@UfvfVertexIn@IRender_DetailModel@@V?$xalloc@UfvfVertexIn@IRender_DetailModel@@@@@std@@QBEIXZ ENDP ; std::vector<IRender_DetailModel::fvfVertexIn,xalloc<IRender_DetailModel::fvfVertexIn> >::capacity
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?max_size@?$_Normal_allocator_traits@V?$xalloc@UfvfVertexIn@IRender_DetailModel@@@@@std@@SAIABV?$xalloc@UfvfVertexIn@IRender_DetailModel@@@@@Z
_TEXT	SEGMENT
?max_size@?$_Normal_allocator_traits@V?$xalloc@UfvfVertexIn@IRender_DetailModel@@@@@std@@SAIABV?$xalloc@UfvfVertexIn@IRender_DetailModel@@@@@Z PROC ; std::_Normal_allocator_traits<xalloc<IRender_DetailModel::fvfVertexIn> >::max_size, COMDAT
; __Al$dead$ = ecx

; 591  :         if constexpr (_Has_max_size<_Alloc>::value) {
; 592  :             return _Al.max_size();

	mov	eax, 214748364				; 0cccccccH

; 593  :         } else {
; 594  :             return (numeric_limits<size_type>::max)() / sizeof(value_type);
; 595  :         }
; 596  :     }

	ret	0
?max_size@?$_Normal_allocator_traits@V?$xalloc@UfvfVertexIn@IRender_DetailModel@@@@@std@@SAIABV?$xalloc@UfvfVertexIn@IRender_DetailModel@@@@@Z ENDP ; std::_Normal_allocator_traits<xalloc<IRender_DetailModel::fvfVertexIn> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?allocate@?$xalloc@UfvfVertexIn@IRender_DetailModel@@@@QBEPAUfvfVertexIn@IRender_DetailModel@@IPBX@Z
_TEXT	SEGMENT
_n$ = 8							; size = 4
_p$dead$ = 12						; size = 4
?allocate@?$xalloc@UfvfVertexIn@IRender_DetailModel@@@@QBEPAUfvfVertexIn@IRender_DetailModel@@IPBX@Z PROC ; xalloc<IRender_DetailModel::fvfVertexIn>::allocate, COMDAT
; _this$dead$ = ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	mov	eax, DWORD PTR _n$[esp-4]
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	lea	eax, DWORD PTR [eax+eax*4]
	shl	eax, 2
	push	eax
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 80   : 							pointer					allocate		(size_type n, const void* p=0) const	{	return xr_alloc<T>((u32)n);	}

	ret	8
?allocate@?$xalloc@UfvfVertexIn@IRender_DetailModel@@@@QBEPAUfvfVertexIn@IRender_DetailModel@@IPBX@Z ENDP ; xalloc<IRender_DetailModel::fvfVertexIn>::allocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$xalloc@G@@V?$_Vector_val@U?$_Simple_types@G@std@@@std@@$00@std@@QBEABV?$xalloc@G@@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@V?$xalloc@G@@V?$_Vector_val@U?$_Simple_types@G@std@@@std@@$00@std@@QBEABV?$xalloc@G@@XZ PROC ; std::_Compressed_pair<xalloc<unsigned short>,std::_Vector_val<std::_Simple_types<unsigned short> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 1343 :         return *this;

	mov	eax, ecx

; 1344 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$xalloc@G@@V?$_Vector_val@U?$_Simple_types@G@std@@@std@@$00@std@@QBEABV?$xalloc@G@@XZ ENDP ; std::_Compressed_pair<xalloc<unsigned short>,std::_Vector_val<std::_Simple_types<unsigned short> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?max_size@?$xalloc@G@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$xalloc@G@@QBEIXZ PROC			; xalloc<unsigned short>::max_size, COMDAT
; _this$dead$ = ecx

; 86   : 							size_type				max_size		() const								{	size_type _Count = (size_type)(-1) / sizeof (T);	return (0 < _Count ? _Count : 1);	}

	mov	eax, 2147483647				; 7fffffffH
	ret	0
?max_size@?$xalloc@G@@QBEIXZ ENDP			; xalloc<unsigned short>::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$xalloc@UfvfVertexIn@IRender_DetailModel@@@@V?$_Vector_val@U?$_Simple_types@UfvfVertexIn@IRender_DetailModel@@@std@@@std@@$00@std@@QBEABV?$xalloc@UfvfVertexIn@IRender_DetailModel@@@@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@V?$xalloc@UfvfVertexIn@IRender_DetailModel@@@@V?$_Vector_val@U?$_Simple_types@UfvfVertexIn@IRender_DetailModel@@@std@@@std@@$00@std@@QBEABV?$xalloc@UfvfVertexIn@IRender_DetailModel@@@@XZ PROC ; std::_Compressed_pair<xalloc<IRender_DetailModel::fvfVertexIn>,std::_Vector_val<std::_Simple_types<IRender_DetailModel::fvfVertexIn> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 1343 :         return *this;

	mov	eax, ecx

; 1344 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$xalloc@UfvfVertexIn@IRender_DetailModel@@@@V?$_Vector_val@U?$_Simple_types@UfvfVertexIn@IRender_DetailModel@@@std@@@std@@$00@std@@QBEABV?$xalloc@UfvfVertexIn@IRender_DetailModel@@@@XZ ENDP ; std::_Compressed_pair<xalloc<IRender_DetailModel::fvfVertexIn>,std::_Vector_val<std::_Simple_types<IRender_DetailModel::fvfVertexIn> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?max_size@?$xalloc@UfvfVertexIn@IRender_DetailModel@@@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$xalloc@UfvfVertexIn@IRender_DetailModel@@@@QBEIXZ PROC ; xalloc<IRender_DetailModel::fvfVertexIn>::max_size, COMDAT
; _this$dead$ = ecx

; 86   : 							size_type				max_size		() const								{	size_type _Count = (size_type)(-1) / sizeof (T);	return (0 < _Count ? _Count : 1);	}

	mov	eax, 214748364				; 0cccccccH
	ret	0
?max_size@?$xalloc@UfvfVertexIn@IRender_DetailModel@@@@QBEIXZ ENDP ; xalloc<IRender_DetailModel::fvfVertexIn>::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$distance@PAG@std@@YAHPAG0@Z
_TEXT	SEGMENT
??$distance@PAG@std@@YAHPAG0@Z PROC			; std::distance<unsigned short *>, COMDAT
; __First$ = ecx
; __Last$ = edx

; 1524 :     if constexpr (_Is_random_iter_v<_InIt>) {
; 1525 :         return _Last - _First; // assume the iterator will do debug checking

	sub	edx, ecx
	sar	edx, 1
	mov	eax, edx

; 1526 :     } else {
; 1527 :         _Adl_verify_range(_First, _Last);
; 1528 :         auto _UFirst             = _Get_unwrapped(_First);
; 1529 :         const auto _ULast        = _Get_unwrapped(_Last);
; 1530 :         _Iter_diff_t<_InIt> _Off = 0;
; 1531 :         for (; _UFirst != _ULast; ++_UFirst) {
; 1532 :             ++_Off;
; 1533 :         }
; 1534 : 
; 1535 :         return _Off;
; 1536 :     }
; 1537 : }

	ret	0
??$distance@PAG@std@@YAHPAG0@Z ENDP			; std::distance<unsigned short *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$next@PAG@std@@YAPAGPAGH@Z
_TEXT	SEGMENT
??$next@PAG@std@@YAPAGPAGH@Z PROC			; std::next<unsigned short *>, COMDAT
; __First$ = ecx
; __Off$ = edx

; 1497 :         _Where += _Off;

	lea	eax, DWORD PTR [ecx+edx*2]

; 1546 :     static_assert(_Is_input_iter_v<_InIt>, "next requires input iterator");
; 1547 : 
; 1548 :     _STD advance(_First, _Off);
; 1549 :     return _First;
; 1550 : }

	ret	0
??$next@PAG@std@@YAPAGPAGH@Z ENDP			; std::next<unsigned short *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_Copy_unchecked@PAGPAG@std@@YAPAGPAG00@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
??$_Copy_unchecked@PAGPAG@std@@YAPAGPAG00@Z PROC	; std::_Copy_unchecked<unsigned short *,unsigned short *>, COMDAT
; __First$ = ecx
; __Last$ = edx

; 4083 : _CONSTEXPR20 _OutIt _Copy_unchecked(_InIt _First, _InIt _Last, _OutIt _Dest) {

	push	esi

; 4066 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	esi, DWORD PTR __Dest$[esp]

; 4083 : _CONSTEXPR20 _OutIt _Copy_unchecked(_InIt _First, _InIt _Last, _OutIt _Dest) {

	push	edi
	mov	edi, edx

; 4065 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	sub	edi, ecx

; 4066 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	push	edi
	push	ecx
	push	esi
	call	_memmove
	add	esp, 12					; 0000000cH

; 4067 :     if constexpr (is_pointer_v<_OutCtgIt>) {
; 4068 :         return reinterpret_cast<_OutCtgIt>(_Dest_ch + _Count);

	lea	eax, DWORD PTR [edi+esi]

; 4084 :     // copy [_First, _Last) to [_Dest, ...)
; 4085 :     // note: _Copy_unchecked has callers other than the copy family
; 4086 :     if constexpr (_Ptr_copy_cat<_InIt, _OutIt>::_Trivially_copyable) {
; 4087 : #ifdef __cpp_lib_is_constant_evaluated
; 4088 :         if (!_STD is_constant_evaluated())
; 4089 : #endif // __cpp_lib_is_constant_evaluated
; 4090 :         {
; 4091 :             return _Copy_memmove(_First, _Last, _Dest);

	pop	edi
	pop	esi

; 4092 :         }
; 4093 :     }
; 4094 : 
; 4095 :     for (; _First != _Last; ++_Dest, (void) ++_First) {
; 4096 :         *_Dest = *_First;
; 4097 :     }
; 4098 : 
; 4099 :     return _Dest;
; 4100 : }

	ret	0
??$_Copy_unchecked@PAGPAG@std@@YAPAGPAG00@Z ENDP	; std::_Copy_unchecked<unsigned short *,unsigned short *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??$_Ucopy@PAG@?$vector@GV?$xalloc@G@@@std@@AAEPAGPAG00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Ucopy@PAG@?$vector@GV?$xalloc@G@@@std@@AAEPAGPAG00@Z PROC ; std::vector<unsigned short,xalloc<unsigned short> >::_Ucopy<unsigned short *>, COMDAT
; _this$dead$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1658 :     for (; _UFirst != _ULast; ++_UFirst) {

	mov	ecx, DWORD PTR __First$[esp-4]

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	eax, DWORD PTR __Dest$[esp-4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1639 :     _CONSTEXPR20_CONTAINER pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Dest) {

	push	esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1658 :     for (; _UFirst != _ULast; ++_UFirst) {

	mov	esi, DWORD PTR __Last$[esp]
	cmp	ecx, esi
	je	SHORT $LN5@Ucopy
$LL6@Ucopy:

; 1620 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

	mov	dx, WORD PTR [ecx]

; 1621 :         ++_Last;

	add	ecx, 2
	mov	WORD PTR [eax], dx
	add	eax, 2

; 1658 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	ecx, esi
	jne	SHORT $LL6@Ucopy
$LN5@Ucopy:
	pop	esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1642 :     }

	ret	12					; 0000000cH
??$_Ucopy@PAG@?$vector@GV?$xalloc@G@@@std@@AAEPAGPAG00@Z ENDP ; std::vector<unsigned short,xalloc<unsigned short> >::_Ucopy<unsigned short *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$distance@PAUfvfVertexIn@IRender_DetailModel@@@std@@YAHPAUfvfVertexIn@IRender_DetailModel@@0@Z
_TEXT	SEGMENT
??$distance@PAUfvfVertexIn@IRender_DetailModel@@@std@@YAHPAUfvfVertexIn@IRender_DetailModel@@0@Z PROC ; std::distance<IRender_DetailModel::fvfVertexIn *>, COMDAT
; __First$ = ecx
; __Last$ = edx

; 1524 :     if constexpr (_Is_random_iter_v<_InIt>) {
; 1525 :         return _Last - _First; // assume the iterator will do debug checking

	sub	edx, ecx
	sar	edx, 2
	imul	eax, edx, -858993459

; 1526 :     } else {
; 1527 :         _Adl_verify_range(_First, _Last);
; 1528 :         auto _UFirst             = _Get_unwrapped(_First);
; 1529 :         const auto _ULast        = _Get_unwrapped(_Last);
; 1530 :         _Iter_diff_t<_InIt> _Off = 0;
; 1531 :         for (; _UFirst != _ULast; ++_UFirst) {
; 1532 :             ++_Off;
; 1533 :         }
; 1534 : 
; 1535 :         return _Off;
; 1536 :     }
; 1537 : }

	ret	0
??$distance@PAUfvfVertexIn@IRender_DetailModel@@@std@@YAHPAUfvfVertexIn@IRender_DetailModel@@0@Z ENDP ; std::distance<IRender_DetailModel::fvfVertexIn *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$next@PAUfvfVertexIn@IRender_DetailModel@@@std@@YAPAUfvfVertexIn@IRender_DetailModel@@PAU12@H@Z
_TEXT	SEGMENT
??$next@PAUfvfVertexIn@IRender_DetailModel@@@std@@YAPAUfvfVertexIn@IRender_DetailModel@@PAU12@H@Z PROC ; std::next<IRender_DetailModel::fvfVertexIn *>, COMDAT
; __First$ = ecx
; __Off$ = edx

; 1497 :         _Where += _Off;

	lea	eax, DWORD PTR [edx+edx*4]
	lea	eax, DWORD PTR [ecx+eax*4]

; 1546 :     static_assert(_Is_input_iter_v<_InIt>, "next requires input iterator");
; 1547 : 
; 1548 :     _STD advance(_First, _Off);
; 1549 :     return _First;
; 1550 : }

	ret	0
??$next@PAUfvfVertexIn@IRender_DetailModel@@@std@@YAPAUfvfVertexIn@IRender_DetailModel@@PAU12@H@Z ENDP ; std::next<IRender_DetailModel::fvfVertexIn *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_Copy_unchecked@PAUfvfVertexIn@IRender_DetailModel@@PAU12@@std@@YAPAUfvfVertexIn@IRender_DetailModel@@PAU12@00@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
??$_Copy_unchecked@PAUfvfVertexIn@IRender_DetailModel@@PAU12@@std@@YAPAUfvfVertexIn@IRender_DetailModel@@PAU12@00@Z PROC ; std::_Copy_unchecked<IRender_DetailModel::fvfVertexIn *,IRender_DetailModel::fvfVertexIn *>, COMDAT
; __First$ = ecx
; __Last$ = edx

; 4083 : _CONSTEXPR20 _OutIt _Copy_unchecked(_InIt _First, _InIt _Last, _OutIt _Dest) {

	push	esi

; 4066 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	esi, DWORD PTR __Dest$[esp]

; 4083 : _CONSTEXPR20 _OutIt _Copy_unchecked(_InIt _First, _InIt _Last, _OutIt _Dest) {

	push	edi
	mov	edi, edx

; 4065 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	sub	edi, ecx

; 4066 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	push	edi
	push	ecx
	push	esi
	call	_memmove
	add	esp, 12					; 0000000cH

; 4067 :     if constexpr (is_pointer_v<_OutCtgIt>) {
; 4068 :         return reinterpret_cast<_OutCtgIt>(_Dest_ch + _Count);

	lea	eax, DWORD PTR [edi+esi]

; 4084 :     // copy [_First, _Last) to [_Dest, ...)
; 4085 :     // note: _Copy_unchecked has callers other than the copy family
; 4086 :     if constexpr (_Ptr_copy_cat<_InIt, _OutIt>::_Trivially_copyable) {
; 4087 : #ifdef __cpp_lib_is_constant_evaluated
; 4088 :         if (!_STD is_constant_evaluated())
; 4089 : #endif // __cpp_lib_is_constant_evaluated
; 4090 :         {
; 4091 :             return _Copy_memmove(_First, _Last, _Dest);

	pop	edi
	pop	esi

; 4092 :         }
; 4093 :     }
; 4094 : 
; 4095 :     for (; _First != _Last; ++_Dest, (void) ++_First) {
; 4096 :         *_Dest = *_First;
; 4097 :     }
; 4098 : 
; 4099 :     return _Dest;
; 4100 : }

	ret	0
??$_Copy_unchecked@PAUfvfVertexIn@IRender_DetailModel@@PAU12@@std@@YAPAUfvfVertexIn@IRender_DetailModel@@PAU12@00@Z ENDP ; std::_Copy_unchecked<IRender_DetailModel::fvfVertexIn *,IRender_DetailModel::fvfVertexIn *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??$_Ucopy@PAUfvfVertexIn@IRender_DetailModel@@@?$vector@UfvfVertexIn@IRender_DetailModel@@V?$xalloc@UfvfVertexIn@IRender_DetailModel@@@@@std@@AAEPAUfvfVertexIn@IRender_DetailModel@@PAU23@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Ucopy@PAUfvfVertexIn@IRender_DetailModel@@@?$vector@UfvfVertexIn@IRender_DetailModel@@V?$xalloc@UfvfVertexIn@IRender_DetailModel@@@@@std@@AAEPAUfvfVertexIn@IRender_DetailModel@@PAU23@00@Z PROC ; std::vector<IRender_DetailModel::fvfVertexIn,xalloc<IRender_DetailModel::fvfVertexIn> >::_Ucopy<IRender_DetailModel::fvfVertexIn *>, COMDAT
; _this$dead$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1658 :     for (; _UFirst != _ULast; ++_UFirst) {

	mov	ecx, DWORD PTR __First$[esp-4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1639 :     _CONSTEXPR20_CONTAINER pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Dest) {

	push	esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	esi, DWORD PTR __Dest$[esp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1639 :     _CONSTEXPR20_CONTAINER pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Dest) {

	push	edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1658 :     for (; _UFirst != _ULast; ++_UFirst) {

	mov	edi, DWORD PTR __Last$[esp+4]
	cmp	ecx, edi
	je	SHORT $LN22@Ucopy
$LL6@Ucopy:
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [esi], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [esi+4], eax
	mov	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR [esi+8], eax
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR [esi+12], edx
	mov	edx, DWORD PTR [ecx+16]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1621 :         ++_Last;

	add	ecx, 20					; 00000014H
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	DWORD PTR [esi+16], edx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1621 :         ++_Last;

	add	esi, 20					; 00000014H

; 1658 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	ecx, edi
	jne	SHORT $LL6@Ucopy
$LN22@Ucopy:
	pop	edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1642 :     }

	mov	eax, esi
	pop	esi
	ret	12					; 0000000cH
??$_Ucopy@PAUfvfVertexIn@IRender_DetailModel@@@?$vector@UfvfVertexIn@IRender_DetailModel@@V?$xalloc@UfvfVertexIn@IRender_DetailModel@@@@@std@@AAEPAUfvfVertexIn@IRender_DetailModel@@PAU23@00@Z ENDP ; std::vector<IRender_DetailModel::fvfVertexIn,xalloc<IRender_DetailModel::fvfVertexIn> >::_Ucopy<IRender_DetailModel::fvfVertexIn *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Zero_range@PAG@std@@YAPAGQAG0@Z
_TEXT	SEGMENT
??$_Zero_range@PAG@std@@YAPAGQAG0@Z PROC		; std::_Zero_range<unsigned short *>, COMDAT
; __First$ = ecx
; __Last$ = edx

; 1789 : _Ptr _Zero_range(const _Ptr _First, const _Ptr _Last) { // fill [_First, _Last) with zeroes

	push	esi
	mov	esi, edx

; 1790 :     char* const _First_ch = reinterpret_cast<char*>(_To_address(_First));
; 1791 :     char* const _Last_ch  = reinterpret_cast<char*>(_To_address(_Last));
; 1792 :     _CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

	mov	eax, esi
	sub	eax, ecx
	push	eax
	push	0
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 1793 :     return _Last;

	mov	eax, esi
	pop	esi

; 1794 : }

	ret	0
??$_Zero_range@PAG@std@@YAPAGQAG0@Z ENDP		; std::_Zero_range<unsigned short *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_To_address@PAG@std@@YA?A_PABQAG@Z
_TEXT	SEGMENT
??$_To_address@PAG@std@@YA?A_PABQAG@Z PROC		; std::_To_address<unsigned short *>, COMDAT
; __Val$ = ecx

; 3981 :     _STL_INTERNAL_STATIC_ASSERT(is_pointer_v<_Iter>);
; 3982 :     return _Val;

	mov	eax, DWORD PTR [ecx]

; 3983 : }

	ret	0
??$_To_address@PAG@std@@YA?A_PABQAG@Z ENDP		; std::_To_address<unsigned short *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Emplace_back@$$V@?$_Uninitialized_backout_al@V?$xalloc@G@@@std@@QAEXXZ
_TEXT	SEGMENT
??$_Emplace_back@$$V@?$_Uninitialized_backout_al@V?$xalloc@G@@@std@@QAEXXZ PROC ; std::_Uninitialized_backout_al<xalloc<unsigned short> >::_Emplace_back<>, COMDAT
; _this$ = ecx

; 570  :             ::new (static_cast<void*>(_Ptr)) _Ty(_STD forward<_Types>(_Args)...);

	mov	eax, DWORD PTR [ecx+4]
	xor	edx, edx
	mov	WORD PTR [eax], dx

; 1620 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);
; 1621 :         ++_Last;

	add	DWORD PTR [ecx+4], 2

; 1622 :     }

	ret	0
??$_Emplace_back@$$V@?$_Uninitialized_backout_al@V?$xalloc@G@@@std@@QAEXXZ ENDP ; std::_Uninitialized_backout_al<xalloc<unsigned short> >::_Emplace_back<>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Destroy_in_place@PAUfvfVertexIn@IRender_DetailModel@@@std@@YAXAAPAUfvfVertexIn@IRender_DetailModel@@@Z
_TEXT	SEGMENT
??$_Destroy_in_place@PAUfvfVertexIn@IRender_DetailModel@@@std@@YAXAAPAUfvfVertexIn@IRender_DetailModel@@@Z PROC ; std::_Destroy_in_place<IRender_DetailModel::fvfVertexIn *>, COMDAT
; __Obj$dead$ = ecx

; 295  :     if constexpr (is_array_v<_Ty>) {
; 296  :         _Destroy_range(_Obj, _Obj + extent_v<_Ty>);
; 297  :     } else {
; 298  :         _Obj.~_Ty();
; 299  :     }
; 300  : }

	ret	0
??$_Destroy_in_place@PAUfvfVertexIn@IRender_DetailModel@@@std@@YAXAAPAUfvfVertexIn@IRender_DetailModel@@@Z ENDP ; std::_Destroy_in_place<IRender_DetailModel::fvfVertexIn *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Destroy_in_place@PAG@std@@YAXAAPAG@Z
_TEXT	SEGMENT
??$_Destroy_in_place@PAG@std@@YAXAAPAG@Z PROC		; std::_Destroy_in_place<unsigned short *>, COMDAT
; __Obj$dead$ = ecx

; 295  :     if constexpr (is_array_v<_Ty>) {
; 296  :         _Destroy_range(_Obj, _Obj + extent_v<_Ty>);
; 297  :     } else {
; 298  :         _Obj.~_Ty();
; 299  :     }
; 300  : }

	ret	0
??$_Destroy_in_place@PAG@std@@YAXAAPAG@Z ENDP		; std::_Destroy_in_place<unsigned short *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Uninitialized_move@PAGV?$xalloc@G@@@std@@YAPAGQAG0PAGAAV?$xalloc@G@@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Al$dead$ = 12						; size = 4
??$_Uninitialized_move@PAGV?$xalloc@G@@@std@@YAPAGQAG0PAGAAV?$xalloc@G@@@Z PROC ; std::_Uninitialized_move<unsigned short *,xalloc<unsigned short> >, COMDAT
; __First$ = ecx
; __Last$ = edx

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	eax, DWORD PTR __Dest$[esp-4]

; 1699 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

	push	esi
	mov	esi, edx

; 1700 :     // move [_First, _Last) to raw _Dest, using _Al
; 1701 :     // note: only called internally from elsewhere in the STL
; 1702 :     using _Ptrval     = typename _Alloc::value_type*;
; 1703 :     auto _UFirst      = _Get_unwrapped(_First);
; 1704 :     const auto _ULast = _Get_unwrapped(_Last);
; 1705 :     if constexpr (conjunction_v<bool_constant<_Ptr_move_cat<decltype(_UFirst), _Ptrval>::_Really_trivial>,
; 1706 :                       _Uses_default_construct<_Alloc, _Ptrval, decltype(_STD move(*_UFirst))>>) {
; 1707 : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 1708 :         if (!_STD is_constant_evaluated())
; 1709 : #endif // __cpp_lib_constexpr_dynamic_alloc
; 1710 :         {
; 1711 :             _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));
; 1712 :             return _Dest + (_ULast - _UFirst);
; 1713 :         }
; 1714 :     }
; 1715 : 
; 1716 :     _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	ecx, esi
	je	SHORT $LN3@Uninitiali
	npad	5
$LL4@Uninitiali:

; 1620 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

	mov	dx, WORD PTR [ecx]

; 1621 :         ++_Last;

	add	ecx, 2
	mov	WORD PTR [eax], dx
	add	eax, 2

; 1700 :     // move [_First, _Last) to raw _Dest, using _Al
; 1701 :     // note: only called internally from elsewhere in the STL
; 1702 :     using _Ptrval     = typename _Alloc::value_type*;
; 1703 :     auto _UFirst      = _Get_unwrapped(_First);
; 1704 :     const auto _ULast = _Get_unwrapped(_Last);
; 1705 :     if constexpr (conjunction_v<bool_constant<_Ptr_move_cat<decltype(_UFirst), _Ptrval>::_Really_trivial>,
; 1706 :                       _Uses_default_construct<_Alloc, _Ptrval, decltype(_STD move(*_UFirst))>>) {
; 1707 : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 1708 :         if (!_STD is_constant_evaluated())
; 1709 : #endif // __cpp_lib_constexpr_dynamic_alloc
; 1710 :         {
; 1711 :             _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));
; 1712 :             return _Dest + (_ULast - _UFirst);
; 1713 :         }
; 1714 :     }
; 1715 : 
; 1716 :     _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	ecx, esi
	jne	SHORT $LL4@Uninitiali
$LN3@Uninitiali:
	pop	esi

; 1718 :         _Backout._Emplace_back(_STD move(*_UFirst));
; 1719 :     }
; 1720 : 
; 1721 :     return _Backout._Release();
; 1722 : }

	ret	0
??$_Uninitialized_move@PAGV?$xalloc@G@@@std@@YAPAGQAG0PAGAAV?$xalloc@G@@@Z ENDP ; std::_Uninitialized_move<unsigned short *,xalloc<unsigned short> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_Get_unwrapped@ABQAG@std@@YA?A_TABQAG@Z
_TEXT	SEGMENT
??$_Get_unwrapped@ABQAG@std@@YA?A_TABQAG@Z PROC		; std::_Get_unwrapped<unsigned short * const &>, COMDAT
; __It$ = ecx

; 1275 :     // unwrap an iterator previously subjected to _Adl_verify_range or otherwise validated
; 1276 :     if constexpr (is_pointer_v<decay_t<_Iter>>) { // special-case pointers and arrays
; 1277 :         return _It + 0;

	mov	eax, DWORD PTR [ecx]

; 1278 :     } else if constexpr (_Unwrappable_v<_Iter>) {
; 1279 :         return static_cast<_Iter&&>(_It)._Unwrapped();
; 1280 :     } else {
; 1281 :         return static_cast<_Iter&&>(_It);
; 1282 :     }
; 1283 : }

	ret	0
??$_Get_unwrapped@ABQAG@std@@YA?A_TABQAG@Z ENDP		; std::_Get_unwrapped<unsigned short * const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$advance@PAGH@std@@YAXAAPAGH@Z
_TEXT	SEGMENT
??$advance@PAGH@std@@YAXAAPAGH@Z PROC			; std::advance<unsigned short *,int>, COMDAT
; __Where$ = ecx
; __Off$ = edx

; 1496 :     if constexpr (_Is_random_iter_v<_InIt>) {
; 1497 :         _Where += _Off;

	lea	eax, DWORD PTR [edx+edx]
	add	DWORD PTR [ecx], eax

; 1498 :     } else {
; 1499 :         if constexpr (is_signed_v<_Diff> && !_Is_bidi_iter_v<_InIt>) {
; 1500 :             _STL_ASSERT(_Off >= 0, "negative advance of non-bidirectional iterator");
; 1501 :         }
; 1502 : 
; 1503 :         decltype(auto) _UWhere      = _Get_unwrapped_n(_STD move(_Where), _Off);
; 1504 :         constexpr bool _Need_rewrap = !is_reference_v<decltype(_Get_unwrapped_n(_STD move(_Where), _Off))>;
; 1505 : 
; 1506 :         if constexpr (is_signed_v<_Diff> && _Is_bidi_iter_v<_InIt>) {
; 1507 :             for (; _Off < 0; ++_Off) {
; 1508 :                 --_UWhere;
; 1509 :             }
; 1510 :         }
; 1511 : 
; 1512 :         for (; 0 < _Off; --_Off) {
; 1513 :             ++_UWhere;
; 1514 :         }
; 1515 : 
; 1516 :         if constexpr (_Need_rewrap) {
; 1517 :             _Seek_wrapped(_Where, _STD move(_UWhere));
; 1518 :         }
; 1519 :     }
; 1520 : }

	ret	0
??$advance@PAGH@std@@YAXAAPAGH@Z ENDP			; std::advance<unsigned short *,int>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_Copy_memmove@PAGPAG@std@@YAPAGPAG00@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
??$_Copy_memmove@PAGPAG@std@@YAPAGPAG00@Z PROC		; std::_Copy_memmove<unsigned short *,unsigned short *>, COMDAT
; __First$ = ecx
; __Last$ = edx

; 4058 : _OutCtgIt _Copy_memmove(_CtgIt _First, _CtgIt _Last, _OutCtgIt _Dest) {

	push	esi

; 4059 :     auto _FirstPtr              = _To_address(_First);
; 4060 :     auto _LastPtr               = _To_address(_Last);
; 4061 :     auto _DestPtr               = _To_address(_Dest);
; 4062 :     const char* const _First_ch = const_cast<const char*>(reinterpret_cast<const volatile char*>(_FirstPtr));
; 4063 :     const char* const _Last_ch  = const_cast<const char*>(reinterpret_cast<const volatile char*>(_LastPtr));
; 4064 :     char* const _Dest_ch        = const_cast<char*>(reinterpret_cast<const volatile char*>(_DestPtr));
; 4065 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);
; 4066 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	esi, DWORD PTR __Dest$[esp]
	push	edi
	mov	edi, edx
	sub	edi, ecx
	push	edi
	push	ecx
	push	esi
	call	_memmove
	add	esp, 12					; 0000000cH

; 4067 :     if constexpr (is_pointer_v<_OutCtgIt>) {
; 4068 :         return reinterpret_cast<_OutCtgIt>(_Dest_ch + _Count);

	lea	eax, DWORD PTR [edi+esi]
	pop	edi
	pop	esi

; 4069 :     } else {
; 4070 :         return _Dest + (_LastPtr - _FirstPtr);
; 4071 :     }
; 4072 : }

	ret	0
??$_Copy_memmove@PAGPAG@std@@YAPAGPAG00@Z ENDP		; std::_Copy_memmove<unsigned short *,unsigned short *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Uninitialized_copy@PAGV?$xalloc@G@@@std@@YAPAGQAG0PAGAAV?$xalloc@G@@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Al$dead$ = 12						; size = 4
??$_Uninitialized_copy@PAGV?$xalloc@G@@@std@@YAPAGQAG0PAGAAV?$xalloc@G@@@Z PROC ; std::_Uninitialized_copy<unsigned short *,xalloc<unsigned short> >, COMDAT
; __First$ = ecx
; __Last$ = edx

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	eax, DWORD PTR __Dest$[esp-4]

; 1637 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

	push	esi
	mov	esi, edx

; 1638 :     // copy [_First, _Last) to raw _Dest, using _Al
; 1639 :     // note: only called internally from elsewhere in the STL
; 1640 :     using _Ptrval = typename _Alloc::value_type*;
; 1641 : 
; 1642 :     auto _UFirst      = _Get_unwrapped(_First);
; 1643 :     const auto _ULast = _Get_unwrapped(_Last);
; 1644 : 
; 1645 :     if constexpr (conjunction_v<bool_constant<_Ptr_copy_cat<decltype(_UFirst), _Ptrval>::_Really_trivial>,
; 1646 :                       _Uses_default_construct<_Alloc, _Ptrval, decltype(*_UFirst)>>) {
; 1647 : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 1648 :         if (!_STD is_constant_evaluated())
; 1649 : #endif // __cpp_lib_constexpr_dynamic_alloc
; 1650 :         {
; 1651 :             _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));
; 1652 :             _Dest += _ULast - _UFirst;
; 1653 :             return _Dest;
; 1654 :         }
; 1655 :     }
; 1656 : 
; 1657 :     _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1658 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	ecx, esi
	je	SHORT $LN3@Uninitiali
	npad	5
$LL4@Uninitiali:

; 1620 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

	mov	dx, WORD PTR [ecx]

; 1621 :         ++_Last;

	add	ecx, 2
	mov	WORD PTR [eax], dx
	add	eax, 2

; 1638 :     // copy [_First, _Last) to raw _Dest, using _Al
; 1639 :     // note: only called internally from elsewhere in the STL
; 1640 :     using _Ptrval = typename _Alloc::value_type*;
; 1641 : 
; 1642 :     auto _UFirst      = _Get_unwrapped(_First);
; 1643 :     const auto _ULast = _Get_unwrapped(_Last);
; 1644 : 
; 1645 :     if constexpr (conjunction_v<bool_constant<_Ptr_copy_cat<decltype(_UFirst), _Ptrval>::_Really_trivial>,
; 1646 :                       _Uses_default_construct<_Alloc, _Ptrval, decltype(*_UFirst)>>) {
; 1647 : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 1648 :         if (!_STD is_constant_evaluated())
; 1649 : #endif // __cpp_lib_constexpr_dynamic_alloc
; 1650 :         {
; 1651 :             _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));
; 1652 :             _Dest += _ULast - _UFirst;
; 1653 :             return _Dest;
; 1654 :         }
; 1655 :     }
; 1656 : 
; 1657 :     _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1658 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	ecx, esi
	jne	SHORT $LL4@Uninitiali
$LN3@Uninitiali:
	pop	esi

; 1659 :         _Backout._Emplace_back(*_UFirst);
; 1660 :     }
; 1661 : 
; 1662 :     return _Backout._Release();
; 1663 : }

	ret	0
??$_Uninitialized_copy@PAGV?$xalloc@G@@@std@@YAPAGQAG0PAGAAV?$xalloc@G@@@Z ENDP ; std::_Uninitialized_copy<unsigned short *,xalloc<unsigned short> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$advance@PAUfvfVertexIn@IRender_DetailModel@@H@std@@YAXAAPAUfvfVertexIn@IRender_DetailModel@@H@Z
_TEXT	SEGMENT
??$advance@PAUfvfVertexIn@IRender_DetailModel@@H@std@@YAXAAPAUfvfVertexIn@IRender_DetailModel@@H@Z PROC ; std::advance<IRender_DetailModel::fvfVertexIn *,int>, COMDAT
; __Where$ = ecx
; __Off$ = edx

; 1496 :     if constexpr (_Is_random_iter_v<_InIt>) {
; 1497 :         _Where += _Off;

	lea	eax, DWORD PTR [edx+edx*4]
	shl	eax, 2
	add	DWORD PTR [ecx], eax

; 1498 :     } else {
; 1499 :         if constexpr (is_signed_v<_Diff> && !_Is_bidi_iter_v<_InIt>) {
; 1500 :             _STL_ASSERT(_Off >= 0, "negative advance of non-bidirectional iterator");
; 1501 :         }
; 1502 : 
; 1503 :         decltype(auto) _UWhere      = _Get_unwrapped_n(_STD move(_Where), _Off);
; 1504 :         constexpr bool _Need_rewrap = !is_reference_v<decltype(_Get_unwrapped_n(_STD move(_Where), _Off))>;
; 1505 : 
; 1506 :         if constexpr (is_signed_v<_Diff> && _Is_bidi_iter_v<_InIt>) {
; 1507 :             for (; _Off < 0; ++_Off) {
; 1508 :                 --_UWhere;
; 1509 :             }
; 1510 :         }
; 1511 : 
; 1512 :         for (; 0 < _Off; --_Off) {
; 1513 :             ++_UWhere;
; 1514 :         }
; 1515 : 
; 1516 :         if constexpr (_Need_rewrap) {
; 1517 :             _Seek_wrapped(_Where, _STD move(_UWhere));
; 1518 :         }
; 1519 :     }
; 1520 : }

	ret	0
??$advance@PAUfvfVertexIn@IRender_DetailModel@@H@std@@YAXAAPAUfvfVertexIn@IRender_DetailModel@@H@Z ENDP ; std::advance<IRender_DetailModel::fvfVertexIn *,int>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_Copy_memmove@PAUfvfVertexIn@IRender_DetailModel@@PAU12@@std@@YAPAUfvfVertexIn@IRender_DetailModel@@PAU12@00@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
??$_Copy_memmove@PAUfvfVertexIn@IRender_DetailModel@@PAU12@@std@@YAPAUfvfVertexIn@IRender_DetailModel@@PAU12@00@Z PROC ; std::_Copy_memmove<IRender_DetailModel::fvfVertexIn *,IRender_DetailModel::fvfVertexIn *>, COMDAT
; __First$ = ecx
; __Last$ = edx

; 4058 : _OutCtgIt _Copy_memmove(_CtgIt _First, _CtgIt _Last, _OutCtgIt _Dest) {

	push	esi

; 4059 :     auto _FirstPtr              = _To_address(_First);
; 4060 :     auto _LastPtr               = _To_address(_Last);
; 4061 :     auto _DestPtr               = _To_address(_Dest);
; 4062 :     const char* const _First_ch = const_cast<const char*>(reinterpret_cast<const volatile char*>(_FirstPtr));
; 4063 :     const char* const _Last_ch  = const_cast<const char*>(reinterpret_cast<const volatile char*>(_LastPtr));
; 4064 :     char* const _Dest_ch        = const_cast<char*>(reinterpret_cast<const volatile char*>(_DestPtr));
; 4065 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);
; 4066 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	esi, DWORD PTR __Dest$[esp]
	push	edi
	mov	edi, edx
	sub	edi, ecx
	push	edi
	push	ecx
	push	esi
	call	_memmove
	add	esp, 12					; 0000000cH

; 4067 :     if constexpr (is_pointer_v<_OutCtgIt>) {
; 4068 :         return reinterpret_cast<_OutCtgIt>(_Dest_ch + _Count);

	lea	eax, DWORD PTR [edi+esi]
	pop	edi
	pop	esi

; 4069 :     } else {
; 4070 :         return _Dest + (_LastPtr - _FirstPtr);
; 4071 :     }
; 4072 : }

	ret	0
??$_Copy_memmove@PAUfvfVertexIn@IRender_DetailModel@@PAU12@@std@@YAPAUfvfVertexIn@IRender_DetailModel@@PAU12@00@Z ENDP ; std::_Copy_memmove<IRender_DetailModel::fvfVertexIn *,IRender_DetailModel::fvfVertexIn *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_To_address@PAUfvfVertexIn@IRender_DetailModel@@@std@@YA?A_PABQAUfvfVertexIn@IRender_DetailModel@@@Z
_TEXT	SEGMENT
??$_To_address@PAUfvfVertexIn@IRender_DetailModel@@@std@@YA?A_PABQAUfvfVertexIn@IRender_DetailModel@@@Z PROC ; std::_To_address<IRender_DetailModel::fvfVertexIn *>, COMDAT
; __Val$ = ecx

; 3981 :     _STL_INTERNAL_STATIC_ASSERT(is_pointer_v<_Iter>);
; 3982 :     return _Val;

	mov	eax, DWORD PTR [ecx]

; 3983 : }

	ret	0
??$_To_address@PAUfvfVertexIn@IRender_DetailModel@@@std@@YA?A_PABQAUfvfVertexIn@IRender_DetailModel@@@Z ENDP ; std::_To_address<IRender_DetailModel::fvfVertexIn *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Uninitialized_copy@PAUfvfVertexIn@IRender_DetailModel@@V?$xalloc@UfvfVertexIn@IRender_DetailModel@@@@@std@@YAPAUfvfVertexIn@IRender_DetailModel@@QAU12@0PAU12@AAV?$xalloc@UfvfVertexIn@IRender_DetailModel@@@@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Al$dead$ = 12						; size = 4
??$_Uninitialized_copy@PAUfvfVertexIn@IRender_DetailModel@@V?$xalloc@UfvfVertexIn@IRender_DetailModel@@@@@std@@YAPAUfvfVertexIn@IRender_DetailModel@@QAU12@0PAU12@AAV?$xalloc@UfvfVertexIn@IRender_DetailModel@@@@@Z PROC ; std::_Uninitialized_copy<IRender_DetailModel::fvfVertexIn *,xalloc<IRender_DetailModel::fvfVertexIn> >, COMDAT
; __First$ = ecx
; __Last$ = edx

; 1637 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

	push	esi

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	esi, DWORD PTR __Dest$[esp]

; 1637 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

	push	edi
	mov	edi, edx

; 1638 :     // copy [_First, _Last) to raw _Dest, using _Al
; 1639 :     // note: only called internally from elsewhere in the STL
; 1640 :     using _Ptrval = typename _Alloc::value_type*;
; 1641 : 
; 1642 :     auto _UFirst      = _Get_unwrapped(_First);
; 1643 :     const auto _ULast = _Get_unwrapped(_Last);
; 1644 : 
; 1645 :     if constexpr (conjunction_v<bool_constant<_Ptr_copy_cat<decltype(_UFirst), _Ptrval>::_Really_trivial>,
; 1646 :                       _Uses_default_construct<_Alloc, _Ptrval, decltype(*_UFirst)>>) {
; 1647 : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 1648 :         if (!_STD is_constant_evaluated())
; 1649 : #endif // __cpp_lib_constexpr_dynamic_alloc
; 1650 :         {
; 1651 :             _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));
; 1652 :             _Dest += _ULast - _UFirst;
; 1653 :             return _Dest;
; 1654 :         }
; 1655 :     }
; 1656 : 
; 1657 :     _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1658 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	ecx, edi
	je	SHORT $LN20@Uninitiali
	npad	4
$LL4@Uninitiali:
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [esi], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [esi+4], eax
	mov	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR [esi+8], eax
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR [esi+12], edx
	mov	edx, DWORD PTR [ecx+16]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1621 :         ++_Last;

	add	ecx, 20					; 00000014H
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	DWORD PTR [esi+16], edx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1621 :         ++_Last;

	add	esi, 20					; 00000014H

; 1638 :     // copy [_First, _Last) to raw _Dest, using _Al
; 1639 :     // note: only called internally from elsewhere in the STL
; 1640 :     using _Ptrval = typename _Alloc::value_type*;
; 1641 : 
; 1642 :     auto _UFirst      = _Get_unwrapped(_First);
; 1643 :     const auto _ULast = _Get_unwrapped(_Last);
; 1644 : 
; 1645 :     if constexpr (conjunction_v<bool_constant<_Ptr_copy_cat<decltype(_UFirst), _Ptrval>::_Really_trivial>,
; 1646 :                       _Uses_default_construct<_Alloc, _Ptrval, decltype(*_UFirst)>>) {
; 1647 : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 1648 :         if (!_STD is_constant_evaluated())
; 1649 : #endif // __cpp_lib_constexpr_dynamic_alloc
; 1650 :         {
; 1651 :             _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));
; 1652 :             _Dest += _ULast - _UFirst;
; 1653 :             return _Dest;
; 1654 :         }
; 1655 :     }
; 1656 : 
; 1657 :     _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1658 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	ecx, edi
	jne	SHORT $LL4@Uninitiali
$LN20@Uninitiali:
	pop	edi

; 1659 :         _Backout._Emplace_back(*_UFirst);
; 1660 :     }
; 1661 : 
; 1662 :     return _Backout._Release();
; 1663 : }

	mov	eax, esi
	pop	esi
	ret	0
??$_Uninitialized_copy@PAUfvfVertexIn@IRender_DetailModel@@V?$xalloc@UfvfVertexIn@IRender_DetailModel@@@@@std@@YAPAUfvfVertexIn@IRender_DetailModel@@QAU12@0PAU12@AAV?$xalloc@UfvfVertexIn@IRender_DetailModel@@@@@Z ENDP ; std::_Uninitialized_copy<IRender_DetailModel::fvfVertexIn *,xalloc<IRender_DetailModel::fvfVertexIn> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_Get_unwrapped@ABQAUfvfVertexIn@IRender_DetailModel@@@std@@YA?A_TABQAUfvfVertexIn@IRender_DetailModel@@@Z
_TEXT	SEGMENT
??$_Get_unwrapped@ABQAUfvfVertexIn@IRender_DetailModel@@@std@@YA?A_TABQAUfvfVertexIn@IRender_DetailModel@@@Z PROC ; std::_Get_unwrapped<IRender_DetailModel::fvfVertexIn * const &>, COMDAT
; __It$ = ecx

; 1275 :     // unwrap an iterator previously subjected to _Adl_verify_range or otherwise validated
; 1276 :     if constexpr (is_pointer_v<decay_t<_Iter>>) { // special-case pointers and arrays
; 1277 :         return _It + 0;

	mov	eax, DWORD PTR [ecx]

; 1278 :     } else if constexpr (_Unwrappable_v<_Iter>) {
; 1279 :         return static_cast<_Iter&&>(_It)._Unwrapped();
; 1280 :     } else {
; 1281 :         return static_cast<_Iter&&>(_It);
; 1282 :     }
; 1283 : }

	ret	0
??$_Get_unwrapped@ABQAUfvfVertexIn@IRender_DetailModel@@@std@@YA?A_TABQAUfvfVertexIn@IRender_DetailModel@@@Z ENDP ; std::_Get_unwrapped<IRender_DetailModel::fvfVertexIn * const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$construct@G$$V@?$_Normal_allocator_traits@V?$xalloc@G@@@std@@SAXAAV?$xalloc@G@@PAG@Z
_TEXT	SEGMENT
??$construct@G$$V@?$_Normal_allocator_traits@V?$xalloc@G@@@std@@SAXAAV?$xalloc@G@@PAG@Z PROC ; std::_Normal_allocator_traits<xalloc<unsigned short> >::construct<unsigned short>, COMDAT
; __Al$dead$ = ecx
; __Ptr$ = edx

; 565  :         if constexpr (_Uses_default_construct<_Alloc, _Ty*, _Types...>::value) {
; 566  :             (void) _Al; // TRANSITION, DevCom-1004719
; 567  : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 568  :             _STD construct_at(_Ptr, _STD forward<_Types>(_Args)...);
; 569  : #else // __cpp_lib_constexpr_dynamic_alloc
; 570  :             ::new (static_cast<void*>(_Ptr)) _Ty(_STD forward<_Types>(_Args)...);

	xor	eax, eax
	mov	WORD PTR [edx], ax

; 571  : #endif // __cpp_lib_constexpr_dynamic_alloc
; 572  :         } else {
; 573  :             _Al.construct(_Ptr, _STD forward<_Types>(_Args)...);
; 574  :         }
; 575  :     }

	ret	0
??$construct@G$$V@?$_Normal_allocator_traits@V?$xalloc@G@@@std@@SAXAAV?$xalloc@G@@PAG@Z ENDP ; std::_Normal_allocator_traits<xalloc<unsigned short> >::construct<unsigned short>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\type_traits
;	COMDAT ??$move@AAG@std@@YA$$QAGAAG@Z
_TEXT	SEGMENT
??$move@AAG@std@@YA$$QAGAAG@Z PROC			; std::move<unsigned short &>, COMDAT
; __Arg$ = ecx

; 1397 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

	mov	eax, ecx

; 1398 : }

	ret	0
??$move@AAG@std@@YA$$QAGAAG@Z ENDP			; std::move<unsigned short &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Emplace_back@G@?$_Uninitialized_backout_al@V?$xalloc@G@@@std@@QAEX$$QAG@Z
_TEXT	SEGMENT
_<_Vals_0>$ = 8						; size = 4
??$_Emplace_back@G@?$_Uninitialized_backout_al@V?$xalloc@G@@@std@@QAEX$$QAG@Z PROC ; std::_Uninitialized_backout_al<xalloc<unsigned short> >::_Emplace_back<unsigned short>, COMDAT
; _this$ = ecx

; 1620 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

	mov	eax, DWORD PTR _<_Vals_0>$[esp-4]
	mov	edx, DWORD PTR [ecx+4]
	mov	ax, WORD PTR [eax]
	mov	WORD PTR [edx], ax

; 1621 :         ++_Last;

	add	DWORD PTR [ecx+4], 2

; 1622 :     }

	ret	4
??$_Emplace_back@G@?$_Uninitialized_backout_al@V?$xalloc@G@@@std@@QAEX$$QAG@Z ENDP ; std::_Uninitialized_backout_al<xalloc<unsigned short> >::_Emplace_back<unsigned short>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Release@?$_Uninitialized_backout_al@V?$xalloc@UfvfVertexIn@IRender_DetailModel@@@@@std@@QAEPAUfvfVertexIn@IRender_DetailModel@@XZ
_TEXT	SEGMENT
?_Release@?$_Uninitialized_backout_al@V?$xalloc@UfvfVertexIn@IRender_DetailModel@@@@@std@@QAEPAUfvfVertexIn@IRender_DetailModel@@XZ PROC ; std::_Uninitialized_backout_al<xalloc<IRender_DetailModel::fvfVertexIn> >::_Release, COMDAT
; _this$ = ecx

; 1625 :         _First = _Last;

	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [ecx], eax

; 1626 :         return _Last;
; 1627 :     }

	ret	0
?_Release@?$_Uninitialized_backout_al@V?$xalloc@UfvfVertexIn@IRender_DetailModel@@@@@std@@QAEPAUfvfVertexIn@IRender_DetailModel@@XZ ENDP ; std::_Uninitialized_backout_al<xalloc<IRender_DetailModel::fvfVertexIn> >::_Release
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??1?$_Uninitialized_backout_al@V?$xalloc@UfvfVertexIn@IRender_DetailModel@@@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Uninitialized_backout_al@V?$xalloc@UfvfVertexIn@IRender_DetailModel@@@@@std@@QAE@XZ PROC ; std::_Uninitialized_backout_al<xalloc<IRender_DetailModel::fvfVertexIn> >::~_Uninitialized_backout_al<xalloc<IRender_DetailModel::fvfVertexIn> >, COMDAT
; _this$ = ecx

; 1615 :         _Destroy_range(_First, _Last, _Al);
; 1616 :     }

	ret	0
??1?$_Uninitialized_backout_al@V?$xalloc@UfvfVertexIn@IRender_DetailModel@@@@@std@@QAE@XZ ENDP ; std::_Uninitialized_backout_al<xalloc<IRender_DetailModel::fvfVertexIn> >::~_Uninitialized_backout_al<xalloc<IRender_DetailModel::fvfVertexIn> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??0?$_Uninitialized_backout_al@V?$xalloc@UfvfVertexIn@IRender_DetailModel@@@@@std@@QAE@PAUfvfVertexIn@IRender_DetailModel@@AAV?$xalloc@UfvfVertexIn@IRender_DetailModel@@@@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Al_$ = 12						; size = 4
??0?$_Uninitialized_backout_al@V?$xalloc@UfvfVertexIn@IRender_DetailModel@@@@@std@@QAE@PAUfvfVertexIn@IRender_DetailModel@@AAV?$xalloc@UfvfVertexIn@IRender_DetailModel@@@@@Z PROC ; std::_Uninitialized_backout_al<xalloc<IRender_DetailModel::fvfVertexIn> >::_Uninitialized_backout_al<xalloc<IRender_DetailModel::fvfVertexIn> >, COMDAT
; _this$ = ecx

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	eax, DWORD PTR __Dest$[esp-4]
	mov	DWORD PTR [ecx], eax
	mov	DWORD PTR [ecx+4], eax
	mov	eax, DWORD PTR __Al_$[esp-4]
	mov	DWORD PTR [ecx+8], eax
	mov	eax, ecx
	ret	8
??0?$_Uninitialized_backout_al@V?$xalloc@UfvfVertexIn@IRender_DetailModel@@@@@std@@QAE@PAUfvfVertexIn@IRender_DetailModel@@AAV?$xalloc@UfvfVertexIn@IRender_DetailModel@@@@@Z ENDP ; std::_Uninitialized_backout_al<xalloc<IRender_DetailModel::fvfVertexIn> >::_Uninitialized_backout_al<xalloc<IRender_DetailModel::fvfVertexIn> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Emplace_back@AAG@?$_Uninitialized_backout_al@V?$xalloc@G@@@std@@QAEXAAG@Z
_TEXT	SEGMENT
_<_Vals_0>$ = 8						; size = 4
??$_Emplace_back@AAG@?$_Uninitialized_backout_al@V?$xalloc@G@@@std@@QAEXAAG@Z PROC ; std::_Uninitialized_backout_al<xalloc<unsigned short> >::_Emplace_back<unsigned short &>, COMDAT
; _this$ = ecx

; 1620 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

	mov	eax, DWORD PTR _<_Vals_0>$[esp-4]
	mov	edx, DWORD PTR [ecx+4]
	mov	ax, WORD PTR [eax]
	mov	WORD PTR [edx], ax

; 1621 :         ++_Last;

	add	DWORD PTR [ecx+4], 2

; 1622 :     }

	ret	4
??$_Emplace_back@AAG@?$_Uninitialized_backout_al@V?$xalloc@G@@@std@@QAEXAAG@Z ENDP ; std::_Uninitialized_backout_al<xalloc<unsigned short> >::_Emplace_back<unsigned short &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Emplace_back@AAUfvfVertexIn@IRender_DetailModel@@@?$_Uninitialized_backout_al@V?$xalloc@UfvfVertexIn@IRender_DetailModel@@@@@std@@QAEXAAUfvfVertexIn@IRender_DetailModel@@@Z
_TEXT	SEGMENT
_<_Vals_0>$ = 8						; size = 4
??$_Emplace_back@AAUfvfVertexIn@IRender_DetailModel@@@?$_Uninitialized_backout_al@V?$xalloc@UfvfVertexIn@IRender_DetailModel@@@@@std@@QAEXAAUfvfVertexIn@IRender_DetailModel@@@Z PROC ; std::_Uninitialized_backout_al<xalloc<IRender_DetailModel::fvfVertexIn> >::_Emplace_back<IRender_DetailModel::fvfVertexIn &>, COMDAT
; _this$ = ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	edx, DWORD PTR _<_Vals_0>$[esp-4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1619 :     _CONSTEXPR20_DYNALLOC void _Emplace_back(_Types&&... _Vals) { // construct a new element at *_Last and increment

	push	esi
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	esi, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [esi], eax
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [esi+4], eax
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR [esi+8], eax
	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR [esi+12], eax
	mov	eax, DWORD PTR [edx+16]
	mov	DWORD PTR [esi+16], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1621 :         ++_Last;

	add	DWORD PTR [ecx+4], 20			; 00000014H
	pop	esi

; 1622 :     }

	ret	4
??$_Emplace_back@AAUfvfVertexIn@IRender_DetailModel@@@?$_Uninitialized_backout_al@V?$xalloc@UfvfVertexIn@IRender_DetailModel@@@@@std@@QAEXAAUfvfVertexIn@IRender_DetailModel@@@Z ENDP ; std::_Uninitialized_backout_al<xalloc<IRender_DetailModel::fvfVertexIn> >::_Emplace_back<IRender_DetailModel::fvfVertexIn &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\type_traits
;	COMDAT ??$forward@G@std@@YA$$QAGAAG@Z
_TEXT	SEGMENT
??$forward@G@std@@YA$$QAGAAG@Z PROC			; std::forward<unsigned short>, COMDAT
; __Arg$ = ecx

; 1386 :     return static_cast<_Ty&&>(_Arg);

	mov	eax, ecx

; 1387 : }

	ret	0
??$forward@G@std@@YA$$QAGAAG@Z ENDP			; std::forward<unsigned short>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$construct@GG@?$_Normal_allocator_traits@V?$xalloc@G@@@std@@SAXAAV?$xalloc@G@@PAG$$QAG@Z
_TEXT	SEGMENT
_<_Args_0>$ = 8						; size = 4
??$construct@GG@?$_Normal_allocator_traits@V?$xalloc@G@@@std@@SAXAAV?$xalloc@G@@PAG$$QAG@Z PROC ; std::_Normal_allocator_traits<xalloc<unsigned short> >::construct<unsigned short,unsigned short>, COMDAT
; __Al$dead$ = ecx
; __Ptr$ = edx

; 565  :         if constexpr (_Uses_default_construct<_Alloc, _Ty*, _Types...>::value) {
; 566  :             (void) _Al; // TRANSITION, DevCom-1004719
; 567  : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 568  :             _STD construct_at(_Ptr, _STD forward<_Types>(_Args)...);
; 569  : #else // __cpp_lib_constexpr_dynamic_alloc
; 570  :             ::new (static_cast<void*>(_Ptr)) _Ty(_STD forward<_Types>(_Args)...);
; 571  : #endif // __cpp_lib_constexpr_dynamic_alloc
; 572  :         } else {
; 573  :             _Al.construct(_Ptr, _STD forward<_Types>(_Args)...);

	mov	eax, DWORD PTR _<_Args_0>$[esp-4]
	mov	ax, WORD PTR [eax]
	mov	WORD PTR [edx], ax

; 574  :         }
; 575  :     }

	ret	0
??$construct@GG@?$_Normal_allocator_traits@V?$xalloc@G@@@std@@SAXAAV?$xalloc@G@@PAG$$QAG@Z ENDP ; std::_Normal_allocator_traits<xalloc<unsigned short> >::construct<unsigned short,unsigned short>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?construct@?$xalloc@G@@QAEXPAGABG@Z
_TEXT	SEGMENT
_p$ = 8							; size = 4
__Val$ = 12						; size = 4
?construct@?$xalloc@G@@QAEXPAGABG@Z PROC		; xalloc<unsigned short>::construct, COMDAT
; _this$dead$ = ecx

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	eax, DWORD PTR __Val$[esp-4]
	mov	cx, WORD PTR [eax]
	mov	eax, DWORD PTR _p$[esp-4]
	mov	WORD PTR [eax], cx
	ret	8
?construct@?$xalloc@G@@QAEXPAGABG@Z ENDP		; xalloc<unsigned short>::construct
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\type_traits
;	COMDAT ??$forward@AAG@std@@YAAAGAAG@Z
_TEXT	SEGMENT
??$forward@AAG@std@@YAAAGAAG@Z PROC			; std::forward<unsigned short &>, COMDAT
; __Arg$ = ecx

; 1386 :     return static_cast<_Ty&&>(_Arg);

	mov	eax, ecx

; 1387 : }

	ret	0
??$forward@AAG@std@@YAAAGAAG@Z ENDP			; std::forward<unsigned short &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$construct@GAAG@?$_Normal_allocator_traits@V?$xalloc@G@@@std@@SAXAAV?$xalloc@G@@PAGAAG@Z
_TEXT	SEGMENT
_<_Args_0>$ = 8						; size = 4
??$construct@GAAG@?$_Normal_allocator_traits@V?$xalloc@G@@@std@@SAXAAV?$xalloc@G@@PAGAAG@Z PROC ; std::_Normal_allocator_traits<xalloc<unsigned short> >::construct<unsigned short,unsigned short &>, COMDAT
; __Al$dead$ = ecx
; __Ptr$ = edx

; 565  :         if constexpr (_Uses_default_construct<_Alloc, _Ty*, _Types...>::value) {
; 566  :             (void) _Al; // TRANSITION, DevCom-1004719
; 567  : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 568  :             _STD construct_at(_Ptr, _STD forward<_Types>(_Args)...);
; 569  : #else // __cpp_lib_constexpr_dynamic_alloc
; 570  :             ::new (static_cast<void*>(_Ptr)) _Ty(_STD forward<_Types>(_Args)...);
; 571  : #endif // __cpp_lib_constexpr_dynamic_alloc
; 572  :         } else {
; 573  :             _Al.construct(_Ptr, _STD forward<_Types>(_Args)...);

	mov	eax, DWORD PTR _<_Args_0>$[esp-4]
	mov	ax, WORD PTR [eax]
	mov	WORD PTR [edx], ax

; 574  :         }
; 575  :     }

	ret	0
??$construct@GAAG@?$_Normal_allocator_traits@V?$xalloc@G@@@std@@SAXAAV?$xalloc@G@@PAGAAG@Z ENDP ; std::_Normal_allocator_traits<xalloc<unsigned short> >::construct<unsigned short,unsigned short &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\type_traits
;	COMDAT ??$forward@AAUfvfVertexIn@IRender_DetailModel@@@std@@YAAAUfvfVertexIn@IRender_DetailModel@@AAU12@@Z
_TEXT	SEGMENT
??$forward@AAUfvfVertexIn@IRender_DetailModel@@@std@@YAAAUfvfVertexIn@IRender_DetailModel@@AAU12@@Z PROC ; std::forward<IRender_DetailModel::fvfVertexIn &>, COMDAT
; __Arg$ = ecx

; 1386 :     return static_cast<_Ty&&>(_Arg);

	mov	eax, ecx

; 1387 : }

	ret	0
??$forward@AAUfvfVertexIn@IRender_DetailModel@@@std@@YAAAUfvfVertexIn@IRender_DetailModel@@AAU12@@Z ENDP ; std::forward<IRender_DetailModel::fvfVertexIn &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$construct@UfvfVertexIn@IRender_DetailModel@@AAU12@@?$_Normal_allocator_traits@V?$xalloc@UfvfVertexIn@IRender_DetailModel@@@@@std@@SAXAAV?$xalloc@UfvfVertexIn@IRender_DetailModel@@@@PAUfvfVertexIn@IRender_DetailModel@@AAU34@@Z
_TEXT	SEGMENT
_<_Args_0>$ = 8						; size = 4
??$construct@UfvfVertexIn@IRender_DetailModel@@AAU12@@?$_Normal_allocator_traits@V?$xalloc@UfvfVertexIn@IRender_DetailModel@@@@@std@@SAXAAV?$xalloc@UfvfVertexIn@IRender_DetailModel@@@@PAUfvfVertexIn@IRender_DetailModel@@AAU34@@Z PROC ; std::_Normal_allocator_traits<xalloc<IRender_DetailModel::fvfVertexIn> >::construct<IRender_DetailModel::fvfVertexIn,IRender_DetailModel::fvfVertexIn &>, COMDAT
; __Al$dead$ = ecx
; __Ptr$ = edx
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	ecx, DWORD PTR _<_Args_0>$[esp-4]
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], eax
	mov	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+8], eax
	mov	eax, DWORD PTR [ecx+12]
	mov	DWORD PTR [edx+12], eax
	mov	eax, DWORD PTR [ecx+16]
	mov	DWORD PTR [edx+16], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 575  :     }

	ret	0
??$construct@UfvfVertexIn@IRender_DetailModel@@AAU12@@?$_Normal_allocator_traits@V?$xalloc@UfvfVertexIn@IRender_DetailModel@@@@@std@@SAXAAV?$xalloc@UfvfVertexIn@IRender_DetailModel@@@@PAUfvfVertexIn@IRender_DetailModel@@AAU34@@Z ENDP ; std::_Normal_allocator_traits<xalloc<IRender_DetailModel::fvfVertexIn> >::construct<IRender_DetailModel::fvfVertexIn,IRender_DetailModel::fvfVertexIn &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?construct@?$xalloc@UfvfVertexIn@IRender_DetailModel@@@@QAEXPAUfvfVertexIn@IRender_DetailModel@@ABU23@@Z
_TEXT	SEGMENT
_p$ = 8							; size = 4
__Val$ = 12						; size = 4
?construct@?$xalloc@UfvfVertexIn@IRender_DetailModel@@@@QAEXPAUfvfVertexIn@IRender_DetailModel@@ABU23@@Z PROC ; xalloc<IRender_DetailModel::fvfVertexIn>::construct, COMDAT
; _this$dead$ = ecx

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	edx, DWORD PTR __Val$[esp-4]
	mov	ecx, DWORD PTR _p$[esp-4]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+4], eax
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR [ecx+8], eax
	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR [ecx+12], eax
	mov	eax, DWORD PTR [edx+16]
	mov	DWORD PTR [ecx+16], eax
	ret	8
?construct@?$xalloc@UfvfVertexIn@IRender_DetailModel@@@@QAEXPAUfvfVertexIn@IRender_DetailModel@@ABU23@@Z ENDP ; xalloc<IRender_DetailModel::fvfVertexIn>::construct
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Convert_size@I@std@@YAII@Z
_TEXT	SEGMENT
??$_Convert_size@I@std@@YAII@Z PROC			; std::_Convert_size<unsigned int>, COMDAT
; __Len$ = ecx

; 922  :     // convert size_t to _Size_type, avoiding truncation
; 923  :     if constexpr (!is_same_v<_Size_type, size_t>) {
; 924  :         if (_Len > (numeric_limits<_Size_type>::max)()) {
; 925  :             _Xlength_error("size_t too long for _Size_type");
; 926  :         }
; 927  :     }
; 928  : 
; 929  :     return static_cast<_Size_type>(_Len);

	mov	eax, ecx

; 930  : }

	ret	0
??$_Convert_size@I@std@@YAII@Z ENDP			; std::_Convert_size<unsigned int>
_TEXT	ENDS
END
