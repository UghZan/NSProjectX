; Listing generated by Microsoft (R) Optimizing Compiler Version 19.29.30146.0 

	TITLE	i:\vitalya\mine\nsprojectx\nspx_build\intermediate\release-win32\xrrender_r1\hom.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	??_C@_09BOGGFEJG@level?4hom@			; `string'
PUBLIC	??_C@_0CI@IFBDOHNF@?5WARNING?3?5Occlusion?5map?5?8?$CFs?8?5no@ ; `string'
PUBLIC	??_C@_0BC@DFKPBAHM@?$CK?5Loading?5HOM?3?5?$CFs@	; `string'
PUBLIC	??_C@_0DI@NJHJIMJP@?$CB?5Invalid?5HOM?5triangle?5?$CI?$CFf?0?$CFf?0?$CF@ ; `string'
EXTRN	__imp_??0Collector@CDB@@QAE@XZ:PROC
EXTRN	__imp_??1Collector@CDB@@QAE@XZ:PROC
EXTRN	__imp_?eof@?$IReaderBase@VIReader@@@@QBEHXZ:PROC
EXTRN	__imp_?impl@?$IReaderBase@VIReader@@@@QBEABVIReader@@XZ:PROC
EXTRN	__imp_??1MODEL@CDB@@QAE@XZ:PROC
EXTRN	__imp_??0MODEL@CDB@@QAE@XZ:PROC
EXTRN	__imp_?elapsed@IReader@@QBEHXZ:PROC
EXTRN	__imp_?ClipPoly@CFrustum@@QBEPAV?$svector@U?$_vector3@M@@$0DA@@@AAV2@0@Z:PROC
EXTRN	__imp_?r_end@COLLIDER@CDB@@QAEPAURESULT@2@XZ:PROC
EXTRN	__imp_?r_end@xrXRC@@QAEPAURESULT@CDB@@XZ:PROC
EXTRN	__imp_?frustum_query@xrXRC@@QAEXPBVMODEL@CDB@@ABVCFrustum@@@Z:PROC
EXTRN	__imp_?frustum_options@COLLIDER@CDB@@QAEXI@Z:PROC
EXTRN	__imp_?frustum_options@xrXRC@@QAEXI@Z:PROC
EXTRN	__imp_?getVS@Collector@CDB@@QAEIXZ:PROC
EXTRN	__imp_?build@MODEL@CDB@@QAEXPAU?$_vector3@M@@HPAVTRI@2@HP6GX0H1HPAX@Z2@Z:PROC
EXTRN	__imp_?getV@Collector@CDB@@QAEPAU?$_vector3@M@@XZ:PROC
EXTRN	__imp_?getT@Collector@CDB@@QAEPAVTRI@2@XZ:PROC
EXTRN	__imp_?getTS@Collector@CDB@@QAEIXZ:PROC
EXTRN	__imp_?calc_adjacency@Collector@CDB@@QAEXAAV?$xr_vector@IV?$xalloc@I@@@@@Z:PROC
EXTRN	__imp_?add_face_packed_D@Collector@CDB@@QAEXABU?$_vector3@M@@00IM@Z:PROC
EXTRN	__imp_?exist@CLocatorAPI@@QAEPBUfile@1@PBD@Z:PROC
;	COMDAT ??_C@_0DI@NJHJIMJP@?$CB?5Invalid?5HOM?5triangle?5?$CI?$CFf?0?$CFf?0?$CF@
CONST	SEGMENT
??_C@_0DI@NJHJIMJP@?$CB?5Invalid?5HOM?5triangle?5?$CI?$CFf?0?$CFf?0?$CF@ DB '!'
	DB	' Invalid HOM triangle (%f,%f,%f)-(%f,%f,%f)-(%f,%f,%f)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@DFKPBAHM@?$CK?5Loading?5HOM?3?5?$CFs@
CONST	SEGMENT
??_C@_0BC@DFKPBAHM@?$CK?5Loading?5HOM?3?5?$CFs@ DB '* Loading HOM: %s', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@IFBDOHNF@?5WARNING?3?5Occlusion?5map?5?8?$CFs?8?5no@
CONST	SEGMENT
??_C@_0CI@IFBDOHNF@?5WARNING?3?5Occlusion?5map?5?8?$CFs?8?5no@ DB ' WARNI'
	DB	'NG: Occlusion map ''%s'' not found.', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09BOGGFEJG@level?4hom@
CONST	SEGMENT
??_C@_09BOGGFEJG@level?4hom@ DB 'level.hom', 00H	; `string'
?_Fake_alloc@std@@3U_Fake_allocator@1@B	ORG $+1		; std::_Fake_alloc
PUBLIC	??0?$xr_vector@IV?$xalloc@I@@@@QAE@XZ		; xr_vector<unsigned int,xalloc<unsigned int> >::xr_vector<unsigned int,xalloc<unsigned int> >
PUBLIC	??1?$vector@IV?$xalloc@I@@@std@@QAE@XZ		; std::vector<unsigned int,xalloc<unsigned int> >::~vector<unsigned int,xalloc<unsigned int> >
PUBLIC	?_Tidy@?$vector@IV?$xalloc@I@@@std@@AAEXXZ	; std::vector<unsigned int,xalloc<unsigned int> >::_Tidy
PUBLIC	?_Getal@?$vector@IV?$xalloc@I@@@std@@AAEAAV?$xalloc@I@@XZ ; std::vector<unsigned int,xalloc<unsigned int> >::_Getal
PUBLIC	?_Get_first@?$_Compressed_pair@V?$xalloc@I@@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@$00@std@@QAEAAV?$xalloc@I@@XZ ; std::_Compressed_pair<xalloc<unsigned int>,std::_Vector_val<std::_Simple_types<unsigned int> >,1>::_Get_first
PUBLIC	?deallocate@?$xalloc@I@@QBEXPAII@Z		; xalloc<unsigned int>::deallocate
PUBLIC	??$xr_free@I@@YAXAAPAI@Z			; xr_free<unsigned int>
PUBLIC	?_Destroy@?$vector@IV?$xalloc@I@@@std@@AAEXPAI0@Z ; std::vector<unsigned int,xalloc<unsigned int> >::_Destroy
PUBLIC	??$_Destroy_range@V?$xalloc@I@@@std@@YAXPAIQAIAAV?$xalloc@I@@@Z ; std::_Destroy_range<xalloc<unsigned int> >
PUBLIC	??$_Unfancy@I@std@@YAPAIPAI@Z			; std::_Unfancy<unsigned int>
PUBLIC	??$destroy@I@?$_Normal_allocator_traits@V?$xalloc@I@@@std@@SAXAAV?$xalloc@I@@PAI@Z ; std::_Normal_allocator_traits<xalloc<unsigned int> >::destroy<unsigned int>
PUBLIC	?destroy@?$xalloc@I@@QAEXPAI@Z			; xalloc<unsigned int>::destroy
PUBLIC	??$_Destroy_in_place@PAI@std@@YAXAAPAI@Z	; std::_Destroy_in_place<unsigned int *>
PUBLIC	??0?$vector@IV?$xalloc@I@@@std@@QAE@XZ		; std::vector<unsigned int,xalloc<unsigned int> >::vector<unsigned int,xalloc<unsigned int> >
PUBLIC	??$?0$$V@?$_Compressed_pair@V?$xalloc@I@@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<xalloc<unsigned int>,std::_Vector_val<std::_Simple_types<unsigned int> >,1>::_Compressed_pair<xalloc<unsigned int>,std::_Vector_val<std::_Simple_types<unsigned int> >,1><>
PUBLIC	??0?$_Vector_val@U?$_Simple_types@I@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<unsigned int> >::_Vector_val<std::_Simple_types<unsigned int> >
PUBLIC	??0?$xalloc@I@@QAE@XZ				; xalloc<unsigned int>::xalloc<unsigned int>
PUBLIC	??1?$xr_vector@IV?$xalloc@I@@@@QAE@XZ		; xr_vector<unsigned int,xalloc<unsigned int> >::~xr_vector<unsigned int,xalloc<unsigned int> >
PUBLIC	?end@?$vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@URESULT@CDB@@@std@@@std@@@2@XZ ; std::vector<CDB::RESULT,xalloc<CDB::RESULT> >::end
PUBLIC	??0?$svector@U?$_vector3@M@@$0DA@@@QAE@XZ	; svector<_vector3<float>,48>::svector<_vector3<float>,48>
PUBLIC	?classify@?$_plane@M@@QBEMABU?$_vector3@M@@@Z	; _plane<float>::classify
PUBLIC	??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >::operator+
PUBLIC	??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >::operator+=
PUBLIC	??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >::operator+=
PUBLIC	?_Verify_offset@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QBEXH@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >::_Verify_offset
PUBLIC	?begin@?$vector@IV?$xalloc@I@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@2@XZ ; std::vector<unsigned int,xalloc<unsigned int> >::begin
PUBLIC	??$addressof@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@I@std@@@0@AAV10@@Z ; std::addressof<std::_Vector_val<std::_Simple_types<unsigned int> > >
PUBLIC	??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QAE@PAIPBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >
PUBLIC	??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QAE@PAIPBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >
PUBLIC	??$move@AAURESULT@CDB@@@std@@YA$$QAURESULT@CDB@@AAU12@@Z ; std::move<CDB::RESULT &>
PUBLIC	??$_To_address@PAURESULT@CDB@@@std@@YA?A_PABQAURESULT@CDB@@@Z ; std::_To_address<CDB::RESULT *>
PUBLIC	??$swap@URESULT@CDB@@$0A@@std@@YAXAAURESULT@CDB@@0@Z ; std::swap<CDB::RESULT,0>
PUBLIC	??$_Med3_unchecked@PAURESULT@CDB@@U?$_Ref_fn@Vpred_fb@@@std@@@std@@YAXPAURESULT@CDB@@00U?$_Ref_fn@Vpred_fb@@@0@@Z ; std::_Med3_unchecked<CDB::RESULT *,std::_Ref_fn<pred_fb> >
PUBLIC	??$_Pop_heap_hole_unchecked@PAURESULT@CDB@@U12@U?$_Ref_fn@Vpred_fb@@@std@@@std@@YAXPAURESULT@CDB@@00$$QAU12@U?$_Ref_fn@Vpred_fb@@@0@@Z ; std::_Pop_heap_hole_unchecked<CDB::RESULT *,CDB::RESULT,std::_Ref_fn<pred_fb> >
PUBLIC	??$_Push_heap_by_index@PAURESULT@CDB@@U12@U?$_Ref_fn@Vpred_fb@@@std@@@std@@YAXPAURESULT@CDB@@HH$$QAU12@U?$_Ref_fn@Vpred_fb@@@0@@Z ; std::_Push_heap_by_index<CDB::RESULT *,CDB::RESULT,std::_Ref_fn<pred_fb> >
PUBLIC	??$forward@URESULT@CDB@@@std@@YA$$QAURESULT@CDB@@AAU12@@Z ; std::forward<CDB::RESULT>
PUBLIC	??$_Copy_backward_memmove@PAURESULT@CDB@@PAU12@@std@@YAPAURESULT@CDB@@PAU12@00@Z ; std::_Copy_backward_memmove<CDB::RESULT *,CDB::RESULT *>
PUBLIC	??$?0AAPAURESULT@CDB@@AAPAU01@$0A@@?$pair@PAURESULT@CDB@@PAU12@@std@@QAE@AAPAURESULT@CDB@@0@Z ; std::pair<CDB::RESULT *,CDB::RESULT *>::pair<CDB::RESULT *,CDB::RESULT *><CDB::RESULT * &,CDB::RESULT * &,0>
PUBLIC	??$iter_swap@PAURESULT@CDB@@PAU12@@std@@YAXPAURESULT@CDB@@0@Z ; std::iter_swap<CDB::RESULT *,CDB::RESULT *>
PUBLIC	??$_Next_iter@PAURESULT@CDB@@@std@@YAPAURESULT@CDB@@PAU12@@Z ; std::_Next_iter<CDB::RESULT *>
PUBLIC	??$_Guess_median_unchecked@PAURESULT@CDB@@U?$_Ref_fn@Vpred_fb@@@std@@@std@@YAXPAURESULT@CDB@@00U?$_Ref_fn@Vpred_fb@@@0@@Z ; std::_Guess_median_unchecked<CDB::RESULT *,std::_Ref_fn<pred_fb> >
PUBLIC	??$_Prev_iter@PAURESULT@CDB@@@std@@YAPAURESULT@CDB@@PAU12@@Z ; std::_Prev_iter<CDB::RESULT *>
PUBLIC	??$_Pop_heap_unchecked@PAURESULT@CDB@@U?$_Ref_fn@Vpred_fb@@@std@@@std@@YAXPAURESULT@CDB@@0U?$_Ref_fn@Vpred_fb@@@0@@Z ; std::_Pop_heap_unchecked<CDB::RESULT *,std::_Ref_fn<pred_fb> >
PUBLIC	??$_Pop_heap_hole_by_index@PAURESULT@CDB@@U12@U?$_Ref_fn@Vpred_fb@@@std@@@std@@YAXPAURESULT@CDB@@HH$$QAU12@U?$_Ref_fn@Vpred_fb@@@0@@Z ; std::_Pop_heap_hole_by_index<CDB::RESULT *,CDB::RESULT,std::_Ref_fn<pred_fb> >
PUBLIC	??$_Move_backward_unchecked@PAURESULT@CDB@@PAU12@@std@@YAPAURESULT@CDB@@PAU12@00@Z ; std::_Move_backward_unchecked<CDB::RESULT *,CDB::RESULT *>
PUBLIC	??$_Partition_by_median_guess_unchecked@PAURESULT@CDB@@U?$_Ref_fn@Vpred_fb@@@std@@@std@@YA?AU?$pair@PAURESULT@CDB@@PAU12@@0@PAURESULT@CDB@@0U?$_Ref_fn@Vpred_fb@@@0@@Z ; std::_Partition_by_median_guess_unchecked<CDB::RESULT *,std::_Ref_fn<pred_fb> >
PUBLIC	??$_Sort_heap_unchecked@PAURESULT@CDB@@U?$_Ref_fn@Vpred_fb@@@std@@@std@@YAXPAURESULT@CDB@@0U?$_Ref_fn@Vpred_fb@@@0@@Z ; std::_Sort_heap_unchecked<CDB::RESULT *,std::_Ref_fn<pred_fb> >
PUBLIC	??$_Make_heap_unchecked@PAURESULT@CDB@@U?$_Ref_fn@Vpred_fb@@@std@@@std@@YAXPAURESULT@CDB@@0U?$_Ref_fn@Vpred_fb@@@0@@Z ; std::_Make_heap_unchecked<CDB::RESULT *,std::_Ref_fn<pred_fb> >
PUBLIC	??$?RAAURESULT@CDB@@AAU01@@?$_Ref_fn@Vpred_fb@@@std@@QAE?A_TAAURESULT@CDB@@0@Z ; std::_Ref_fn<pred_fb>::operator()<CDB::RESULT &,CDB::RESULT &>
PUBLIC	??$_Insertion_sort_unchecked@PAURESULT@CDB@@U?$_Ref_fn@Vpred_fb@@@std@@@std@@YAPAURESULT@CDB@@QAU12@0U?$_Ref_fn@Vpred_fb@@@0@@Z ; std::_Insertion_sort_unchecked<CDB::RESULT *,std::_Ref_fn<pred_fb> >
PUBLIC	??$forward@AAPAURESULT@CDB@@@std@@YAAAPAURESULT@CDB@@AAPAU12@@Z ; std::forward<CDB::RESULT * &>
PUBLIC	??$forward@AAURESULT@CDB@@@std@@YAAAURESULT@CDB@@AAU12@@Z ; std::forward<CDB::RESULT &>
PUBLIC	??$_Sort_unchecked@PAURESULT@CDB@@U?$_Ref_fn@Vpred_fb@@@std@@@std@@YAXPAURESULT@CDB@@0HU?$_Ref_fn@Vpred_fb@@@0@@Z ; std::_Sort_unchecked<CDB::RESULT *,std::_Ref_fn<pred_fb> >
PUBLIC	??$_Seek_wrapped@PAURESULT@CDB@@AAPAU12@@std@@YAXAAPAURESULT@CDB@@0@Z ; std::_Seek_wrapped<CDB::RESULT *,CDB::RESULT * &>
PUBLIC	??$?RAAURESULT@CDB@@@?$_Ref_fn@Vpred_fb@@@std@@QAE?A_TAAURESULT@CDB@@@Z ; std::_Ref_fn<pred_fb>::operator()<CDB::RESULT &>
PUBLIC	??$find_if@PAURESULT@CDB@@U?$_Ref_fn@Vpred_fb@@@std@@@std@@YAPAURESULT@CDB@@PAU12@QAU12@U?$_Ref_fn@Vpred_fb@@@0@@Z ; std::find_if<CDB::RESULT *,std::_Ref_fn<pred_fb> >
PUBLIC	??$_Pass_fn@Vpred_fb@@$0A@@std@@YA?AU?$_Ref_fn@Vpred_fb@@@0@AAVpred_fb@@@Z ; std::_Pass_fn<pred_fb,0>
PUBLIC	??$_Adl_verify_range@PAURESULT@CDB@@PAU12@@std@@YAXABQAURESULT@CDB@@0@Z ; std::_Adl_verify_range<CDB::RESULT *,CDB::RESULT *>
PUBLIC	??_GMODEL@CDB@@QAEPAXI@Z			; CDB::MODEL::`scalar deleting destructor'
PUBLIC	??R?$xr_special_free@$0A@VMODEL@CDB@@@@QAEXAAPAVMODEL@CDB@@@Z ; xr_special_free<0,CDB::MODEL>::operator()
PUBLIC	??$sort@PAURESULT@CDB@@Vpred_fb@@@std@@YAXQAURESULT@CDB@@0Vpred_fb@@@Z ; std::sort<CDB::RESULT *,pred_fb>
PUBLIC	??$_Get_unwrapped@ABQAURESULT@CDB@@@std@@YA?A_TABQAURESULT@CDB@@@Z ; std::_Get_unwrapped<CDB::RESULT * const &>
PUBLIC	??$_Get_unwrapped@AAPAURESULT@CDB@@@std@@YA?A_TAAPAURESULT@CDB@@@Z ; std::_Get_unwrapped<CDB::RESULT * &>
PUBLIC	??$remove_if@PAURESULT@CDB@@Vpred_fb@@@std@@YAPAURESULT@CDB@@PAU12@QAU12@Vpred_fb@@@Z ; std::remove_if<CDB::RESULT *,pred_fb>
PUBLIC	??$xr_free@VoccTri@@@@YAXAAPAVoccTri@@@Z	; xr_free<occTri>
PUBLIC	??$xr_delete@VMODEL@CDB@@@@YAXAAPAVMODEL@CDB@@@Z ; xr_delete<CDB::MODEL>
PUBLIC	??$xr_new@VMODEL@CDB@@@@YAPAVMODEL@CDB@@XZ	; xr_new<CDB::MODEL>
PUBLIC	??$xr_alloc@VoccTri@@@@YAPAVoccTri@@I@Z		; xr_alloc<occTri>
PUBLIC	??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QBEABIXZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >::operator*
PUBLIC	?normalize@?$_vector3@M@@QAEAAU1@XZ		; _vector3<float>::normalize
PUBLIC	?contains@?$_box3@M@@QBEHMMM@Z			; _box3<float>::contains
PUBLIC	??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QBEAAIXZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >::operator*
PUBLIC	??A?$xr_vector@IV?$xalloc@I@@@@QAEAAII@Z	; xr_vector<unsigned int,xalloc<unsigned int> >::operator[]
PUBLIC	?mul@?$_matrix@M@@QAEAAU1@ABU1@0@Z		; _matrix<float>::mul
PUBLIC	?transform@?$_matrix@M@@QBEXAAU?$_vector3@M@@ABU2@@Z ; _matrix<float>::transform
PUBLIC	?contains@?$_box3@M@@QBEHABU?$_vector3@M@@@Z	; _box3<float>::contains
PUBLIC	?build@?$_plane@M@@QAEAAV1@ABU?$_vector3@M@@00@Z ; _plane<float>::build
PUBLIC	?size@?$svector@U?$_vector3@M@@$0DA@@@QBEIXZ	; svector<_vector3<float>,48>::size
PUBLIC	?clear@?$svector@U?$_vector3@M@@$0DA@@@QAEXXZ	; svector<_vector3<float>,48>::clear
PUBLIC	?push_back@?$svector@U?$_vector3@M@@$0DA@@@QAEXU?$_vector3@M@@@Z ; svector<_vector3<float>,48>::push_back
PUBLIC	??A?$svector@U?$_vector3@M@@$0DA@@@QAEAAU?$_vector3@M@@I@Z ; svector<_vector3<float>,48>::operator[]
PUBLIC	?front@?$svector@U?$_vector3@M@@$0DA@@@QAEAAU?$_vector3@M@@XZ ; svector<_vector3<float>,48>::front
PUBLIC	?Enable@CHOM@@QAEXXZ				; CHOM::Enable
PUBLIC	?Disable@CHOM@@QAEXXZ				; CHOM::Disable
PUBLIC	?visible@CHOM@@QAEHAAV?$svector@U?$_vector3@M@@$0DA@@@@Z ; CHOM::visible
PUBLIC	?visible@CHOM@@QAEHAAV?$_box2@M@@M@Z		; CHOM::visible
PUBLIC	?visible@CHOM@@QAEHAAV?$_box3@M@@@Z		; CHOM::visible
PUBLIC	?_visible@@YAHAAV?$_box3@M@@AAU?$_matrix@M@@@Z	; _visible
PUBLIC	?xform_b1@@YAHAAU?$_vector2@M@@0AAMAAU?$_matrix@M@@MMM@Z ; xform_b1
PUBLIC	?xform_b0@@YAHAAU?$_vector2@M@@0AAMAAU?$_matrix@M@@MMM@Z ; xform_b0
PUBLIC	?Render@CHOM@@QAEXAAVCFrustum@@@Z		; CHOM::Render
PUBLIC	?Render_DB@CHOM@@AAEXAAVCFrustum@@@Z		; CHOM::Render_DB
PUBLIC	??Rpred_fb@@QBE_NABURESULT@CDB@@@Z		; pred_fb::operator()
PUBLIC	??Rpred_fb@@QBE_NABURESULT@CDB@@0@Z		; pred_fb::operator()
PUBLIC	??0pred_fb@@QAE@PAVoccTri@@AAU?$_vector3@M@@@Z	; pred_fb::pred_fb
PUBLIC	??0pred_fb@@QAE@PAVoccTri@@@Z			; pred_fb::pred_fb
PUBLIC	?Unload@CHOM@@QAEXXZ				; CHOM::Unload
PUBLIC	?Load@CHOM@@QAEXXZ				; CHOM::Load
PUBLIC	?Area@@YAMAAU?$_vector3@M@@00@Z			; Area
PUBLIC	??1CHOM@@QAE@XZ					; CHOM::~CHOM
PUBLIC	??0CHOM@@QAE@XZ					; CHOM::CHOM
PUBLIC	?MT_RENDER@CHOM@@QAGXXZ				; CHOM::MT_RENDER
PUBLIC	?visible@CHOM@@QAEHAAUvis_data@@@Z		; CHOM::visible
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:?MT_RENDER@CHOM@@QAGXXZ
	DD	038H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:?Render@CHOM@@QAEXAAVCFrustum@@@Z
	DD	0b3H
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_random.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp
_TEXT	SEGMENT
_vis$ = 8						; size = 4
?visible@CHOM@@QAEHAAUvis_data@@@Z PROC			; CHOM::visible
; _this$ = ecx

; 288  : 	if (Device.dwFrame<vis.hom_frame)	return TRUE;				// not at this time :)

	mov	eax, DWORD PTR __imp_?Device@@3VCRenderDevice@@A
	push	ebx
	push	esi
	mov	esi, DWORD PTR _vis$[esp+4]
	push	edi
	mov	edi, DWORD PTR [eax+244]
	cmp	edi, DWORD PTR [esi+48]
	jb	SHORT $LN152@visible

; 289  : 	if (!bEnabled)						return TRUE;				// return - everything visible

	cmp	DWORD PTR [ecx+32], 0
	je	SHORT $LN152@visible

; 290  : 	
; 291  : 	// Now, the test time comes
; 292  : 	// 0. The object was hidden, and we must prove that each frame	- test		| frame-old, tested-new, hom_res = false;
; 293  : 	// 1. The object was visible, but we must to re-check it		- test		| frame-new, tested-???, hom_res = true;
; 294  : 	// 2. New object slides into view								- delay test| frame-old, tested-old, hom_res = ???;
; 295  : 	u32 frame_current	= Device.dwFrame;
; 296  : 	// u32	frame_prev		= frame_current-1;
; 297  : 
; 298  : #ifdef DEBUG
; 299  : 	Device.Statistic->RenderCALC_HOM.Begin	();
; 300  : #endif
; 301  : 	BOOL result			= _visible			(vis.box,m_xform_01);

	lea	edx, DWORD PTR [ecx+100]
	lea	ecx, DWORD PTR [esi+16]
	call	?_visible@@YAHAAV?$_box3@M@@AAU?$_matrix@M@@@Z ; _visible
	mov	ebx, eax

; 302  : 	u32  delay			= 1;

	mov	edx, 1

; 303  : 	if (result)

	test	ebx, ebx
	je	SHORT $LN4@visible
; File I:\Vitalya\mine\NSProjectX\xrCore\_random.h

; 33   : 	IC 	s32		randI	(s32 max)					{ VERIFY(max);  return randI()%max; }

	mov	ecx, DWORD PTR __imp_?Random@@3VCRandom@@A
	call	?randI@CRandom@@QAEHXZ			; CRandom::randI
	cdq
	mov	ecx, 15					; 0000000fH
	idiv	ecx

; 34   : 	IC 	s32		randI	(s32 min, s32 max)			{ return min+randI(max-min); }

	add	edx, 10					; 0000000aH
$LN4@visible:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp

; 310  : 	vis.hom_frame			= frame_current + delay;

	lea	eax, DWORD PTR [edx+edi]

; 311  : 	vis.hom_tested			= frame_current	;

	mov	DWORD PTR [esi+52], edi
	mov	DWORD PTR [esi+48], eax

; 312  : #ifdef DEBUG
; 313  : 	Device.Statistic->RenderCALC_HOM.End	();
; 314  : #endif
; 315  : 
; 316  : 	return result;

	mov	eax, ebx

; 317  : }

	pop	edi
	pop	esi
	pop	ebx
	ret	4
$LN152@visible:
	pop	edi
	pop	esi
	mov	eax, 1
	pop	ebx
	ret	4
?visible@CHOM@@QAEHAAUvis_data@@@Z ENDP			; CHOM::visible
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp
_TEXT	SEGMENT
_ViewBase$1 = -248					; size = 244
?MT_RENDER@CHOM@@QAGXXZ PROC				; CHOM::MT_RENDER
; _this$ = ecx

; 13   : {

	sub	esp, 252				; 000000fcH
	push	esi
	mov	esi, ecx
	push	edi

; 14   : 	MT.Enter					();

	lea	ecx, DWORD PTR [esi+164]
	call	DWORD PTR __imp_?Enter@xrCriticalSection@@QAEXXZ

; 15   : 	bool b_main_menu_is_active = (g_pGamePersistent->m_pMainMenu && g_pGamePersistent->m_pMainMenu->IsActive() );

	mov	eax, DWORD PTR __imp_?g_pGamePersistent@@3PAVIGame_Persistent@@A
	mov	eax, DWORD PTR [eax]
	mov	ecx, DWORD PTR [eax+1112]
	test	ecx, ecx
	je	SHORT $LN4@MT_RENDER
	mov	eax, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax+8]
	call	eax
	test	al, al
	je	SHORT $LN4@MT_RENDER
	mov	cl, 1
	jmp	SHORT $LN5@MT_RENDER
$LN4@MT_RENDER:
	xor	cl, cl
$LN5@MT_RENDER:

; 16   : 	if (MT_frame_rendered!=Device.dwFrame && !b_main_menu_is_active)

	mov	eax, DWORD PTR [esi+168]
	mov	edx, DWORD PTR __imp_?Device@@3VCRenderDevice@@A
	cmp	eax, DWORD PTR [edx+244]
	je	SHORT $LN2@MT_RENDER
	test	cl, cl
	jne	SHORT $LN2@MT_RENDER

; 17   : 	{
; 18   : 		CFrustum					ViewBase;
; 19   : 		ViewBase.CreateFromMatrix	(Device.mFullTransform, FRUSTUM_P_LRTB + FRUSTUM_P_FAR);

	push	47					; 0000002fH
	lea	eax, DWORD PTR [edx+664]
	push	eax
	lea	ecx, DWORD PTR _ViewBase$1[esp+268]
	call	DWORD PTR __imp_?CreateFromMatrix@CFrustum@@QAEXAAU?$_matrix@M@@I@Z

; 340  : 	bEnabled			= m_pModel?TRUE:FALSE;

	xor	eax, eax

; 20   : 		Enable						();
; 21   : 		Render						(ViewBase);

	mov	ecx, esi

; 340  : 	bEnabled			= m_pModel?TRUE:FALSE;

	cmp	DWORD PTR [esi+24], eax
	setne	al
	mov	DWORD PTR [esi+32], eax

; 20   : 		Enable						();
; 21   : 		Render						(ViewBase);

	lea	eax, DWORD PTR _ViewBase$1[esp+260]
	push	eax
	call	?Render@CHOM@@QAEXAAVCFrustum@@@Z	; CHOM::Render
$LN2@MT_RENDER:

; 22   : 	}
; 23   : 	MT.Leave					();

	lea	ecx, DWORD PTR [esi+164]

; 24   : }

	pop	edi
	pop	esi
	add	esp, 252				; 000000fcH

; 22   : 	}
; 23   : 	MT.Leave					();

	jmp	DWORD PTR __imp_?Leave@xrCriticalSection@@QAEXXZ
?MT_RENDER@CHOM@@QAGXXZ ENDP				; CHOM::MT_RENDER
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp
_TEXT	SEGMENT
??0CHOM@@QAE@XZ PROC					; CHOM::CHOM
; _this$ = ecx

; 31   : {

	push	esi
	mov	esi, ecx
	call	DWORD PTR __imp_??0xrXRC@@QAE@XZ
	lea	ecx, DWORD PTR [esi+164]
	call	DWORD PTR __imp_??0xrCriticalSection@@QAE@XZ

; 32   : 	bEnabled		= FALSE;

	mov	DWORD PTR [esi+32], 0

; 33   : 	m_pModel		= 0;
; 34   : 	m_pTris			= 0;
; 35   : #ifdef DEBUG
; 36   : 	Device.seqRender.Add(this,REG_PRIORITY_LOW-1000);
; 37   : #endif
; 38   : }

	mov	eax, esi
	mov	DWORD PTR [esi+24], 0
	mov	DWORD PTR [esi+28], 0
	pop	esi
	ret	0
??0CHOM@@QAE@XZ ENDP					; CHOM::CHOM
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp
_TEXT	SEGMENT
??1CHOM@@QAE@XZ PROC					; CHOM::~CHOM
; _this$ = ecx

; 41   : {

	push	esi
	mov	esi, ecx

; 42   : #ifdef DEBUG
; 43   : 	Device.seqRender.Remove(this);
; 44   : #endif
; 45   : }

	lea	ecx, DWORD PTR [esi+164]
	call	DWORD PTR __imp_??1xrCriticalSection@@QAE@XZ
	mov	ecx, esi
	pop	esi
	jmp	DWORD PTR __imp_??1xrXRC@@QAE@XZ
??1CHOM@@QAE@XZ ENDP					; CHOM::~CHOM
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp
;	COMDAT ?Area@@YAMAAU?$_vector3@M@@00@Z
_TEXT	SEGMENT
_e3$ = -16						; size = 4
_e2$ = -12						; size = 4
_e1$ = -8						; size = 4
tv496 = -4						; size = 4
_p$ = 8							; size = 4
_v2$ = 8						; size = 4
?Area@@YAMAAU?$_vector3@M@@00@Z PROC			; Area, COMDAT
; _v0$ = ecx
; _v1$ = edx

; 56   : {

	sub	esp, 16					; 00000010H
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 287  : 	{	return (x-v.x)*(x-v.x) + (y-v.y)*(y-v.y) + (z-v.z)*(z-v.z);	}

	mov	eax, DWORD PTR _v2$[esp+12]
	movss	xmm4, DWORD PTR [ecx]
	movss	xmm6, DWORD PTR [ecx+4]
	movaps	xmm1, xmm4
	movss	xmm3, DWORD PTR [ecx+8]
	movaps	xmm2, xmm6
	subss	xmm4, DWORD PTR [eax]
	subss	xmm6, DWORD PTR [eax+4]
	subss	xmm2, DWORD PTR [edx+4]
	subss	xmm1, DWORD PTR [edx]
	movss	xmm7, DWORD PTR [edx+8]
	movaps	xmm0, xmm3
	subss	xmm3, DWORD PTR [eax+8]
	mulss	xmm4, xmm4
	subss	xmm0, xmm7
	subss	xmm7, DWORD PTR [eax+8]
	mulss	xmm6, xmm6
	mulss	xmm3, xmm3
	addss	xmm4, xmm6
	mulss	xmm2, xmm2
	mulss	xmm1, xmm1
	mulss	xmm0, xmm0
	addss	xmm4, xmm3
	mulss	xmm7, xmm7
	addss	xmm1, xmm2
	movss	xmm2, DWORD PTR [edx]
	subss	xmm2, DWORD PTR [eax]
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h

; 764  :             return (float)sqrt(_X);

	sqrtss	xmm3, xmm4
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 287  : 	{	return (x-v.x)*(x-v.x) + (y-v.y)*(y-v.y) + (z-v.z)*(z-v.z);	}

	movss	xmm4, DWORD PTR [edx+4]
	addss	xmm1, xmm0
	subss	xmm4, DWORD PTR [eax+4]
	mulss	xmm2, xmm2
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp

; 58   : 	float	e2 = v0.distance_to(v2);

	movss	DWORD PTR _e2$[esp+16], xmm3
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h

; 764  :             return (float)sqrt(_X);

	sqrtss	xmm5, xmm1
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 287  : 	{	return (x-v.x)*(x-v.x) + (y-v.y)*(y-v.y) + (z-v.z)*(z-v.z);	}

	mulss	xmm4, xmm4
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp

; 61   : 	float	p  = (e1+e2+e3)/2.f;

	addss	xmm3, xmm5
	movss	DWORD PTR _e1$[esp+16], xmm5
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 287  : 	{	return (x-v.x)*(x-v.x) + (y-v.y)*(y-v.y) + (z-v.z)*(z-v.z);	}

	addss	xmm2, xmm4
	addss	xmm2, xmm7
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h

; 764  :             return (float)sqrt(_X);

	sqrtss	xmm0, xmm2
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp

; 61   : 	float	p  = (e1+e2+e3)/2.f;

	addss	xmm3, xmm0
	movss	DWORD PTR _e3$[esp+16], xmm0
	mulss	xmm3, DWORD PTR __real@3f000000
	movss	DWORD PTR _p$[esp+12], xmm3

; 62   : 	return	_sqrt( p*(p-e1)*(p-e2)*(p-e3) );

	fld	DWORD PTR _p$[esp+12]
	fld	DWORD PTR _e3$[esp+16]
	fsubr	ST(0), ST(1)
	movss	DWORD PTR tv496[esp+16], xmm3
	fld	ST(1)
	fsub	DWORD PTR _e2$[esp+16]
	fmulp	ST(1), ST(0)
	fxch	ST(1)
	fsub	DWORD PTR _e1$[esp+16]
	fmul	DWORD PTR tv496[esp+16]
	fmulp	ST(1), ST(0)
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h

; 764  :             return (float)sqrt(_X);

	fsqrt
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp

; 63   : }

	add	esp, 16					; 00000010H
	ret	0
?Area@@YAMAAU?$_vector3@M@@00@Z ENDP			; Area
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\FS.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\FS.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_plane.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_plane.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_plane.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp
_TEXT	SEGMENT
tv1515 = -632						; size = 4
tv1516 = -628						; size = 4
_adjacency$ = -624					; size = 12
_v1$1$ = -612						; size = 4
_it$1$ = -608						; size = 4
tv1514 = -604						; size = 4
_CL$ = -600						; size = 24
_v0$1$ = -576						; size = 4
_v2$1$ = -572						; size = 4
_S$1$ = -568						; size = 4
_fs$ = -564						; size = 4
_P$1 = -560						; size = 40
_fName$ = -520						; size = 520
?Load@CHOM@@QAEXXZ PROC					; CHOM::Load
; _this$ = ecx

; 66   : {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	sub	esp, 636				; 0000027cH

; 67   : 	// Find and open file
; 68   : 	string_path		fName;
; 69   : 	FS.update_path	(fName,"$level$","level.hom");

	lea	eax, DWORD PTR _fName$[esp+636]
	push	ebx
	push	esi
	push	edi
	mov	ebx, ecx
	mov	ecx, DWORD PTR __imp_?xr_FS@@3PAVCLocatorAPI@@A
	push	OFFSET ??_C@_09BOGGFEJG@level?4hom@
	push	OFFSET ??_C@_07DJIBDFPO@$level$@
	push	eax
	mov	ecx, DWORD PTR [ecx]
	call	DWORD PTR __imp_?update_path@CLocatorAPI@@QAEPBDAAY0CAI@DPBD1@Z

; 70   : 	if (!FS.exist(fName))

	mov	ecx, DWORD PTR __imp_?xr_FS@@3PAVCLocatorAPI@@A
	lea	eax, DWORD PTR _fName$[esp+648]
	push	eax
	mov	ecx, DWORD PTR [ecx]
	call	DWORD PTR __imp_?exist@CLocatorAPI@@QAEPBUfile@1@PBD@Z
	test	eax, eax
	lea	eax, DWORD PTR _fName$[esp+648]
	push	eax
	jne	SHORT $LN7@Load

; 71   : 	{
; 72   : 		Msg		(" WARNING: Occlusion map '%s' not found.",fName);

	push	OFFSET ??_C@_0CI@IFBDOHNF@?5WARNING?3?5Occlusion?5map?5?8?$CFs?8?5no@
	call	DWORD PTR __imp_?Msg@@YAXPBDZZ
	add	esp, 8

; 121  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN7@Load:

; 73   : 		return;
; 74   : 	}
; 75   : 	Msg	("* Loading HOM: %s",fName);

	push	OFFSET ??_C@_0BC@DFKPBAHM@?$CK?5Loading?5HOM?3?5?$CFs@
	call	DWORD PTR __imp_?Msg@@YAXPBDZZ

; 76   : 	
; 77   : 	IReader* fs				= FS.r_open(fName);

	mov	ecx, DWORD PTR __imp_?xr_FS@@3PAVCLocatorAPI@@A
	lea	eax, DWORD PTR _fName$[esp+656]
	add	esp, 8
	mov	ecx, DWORD PTR [ecx]
	push	eax
	call	DWORD PTR __imp_?r_open@CLocatorAPI@@QAEPAVIReader@@PBD@Z

; 78   : 	IReader* S				= fs->open_chunk(1);

	push	1
	mov	ecx, eax
	mov	DWORD PTR _fs$[esp+652], eax
	call	DWORD PTR __imp_?open_chunk@IReader@@QAEPAV1@I@Z
	mov	esi, eax

; 79   : 
; 80   : 	// Load tris and merge them
; 81   : 	CDB::Collector		CL;

	lea	ecx, DWORD PTR _CL$[esp+648]
	mov	DWORD PTR _S$1$[esp+648], esi
	call	DWORD PTR __imp_??0Collector@CDB@@QAE@XZ
; File I:\Vitalya\mine\NSProjectX\xrCore\FS.h

; 260  : 	IC int			elapsed		()	const		{	return Size-Pos;		};

	mov	ecx, DWORD PTR [esi+12]
	sub	ecx, DWORD PTR [esi+8]

; 139  : 	IC BOOL			eof			()	const		{return impl().elapsed()<=0;	};

	test	ecx, ecx
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp

; 82   : 	while (!S->eof())

	jle	SHORT $LN3@Load
	mov	edi, DWORD PTR __imp_?r@IReader@@QAEXPAXH@Z
$LL2@Load:

; 83   : 	{
; 84   : 		HOM_poly				P;
; 85   : 		S->r					(&P,sizeof(P));

	push	40					; 00000028H
	lea	eax, DWORD PTR _P$1[esp+652]
	mov	ecx, esi
	push	eax
	call	edi

; 86   : 		CL.add_face_packed_D	(P.v1,P.v2,P.v3,P.flags,0.01f);

	fld	DWORD PTR __real@3c23d70a
	lea	eax, DWORD PTR _P$1[esp+672]
	push	ecx
	fstp	DWORD PTR [esp]
	push	DWORD PTR _P$1[esp+688]
	lea	ecx, DWORD PTR _CL$[esp+656]
	push	eax
	lea	eax, DWORD PTR _P$1[esp+672]
	push	eax
	lea	eax, DWORD PTR _P$1[esp+664]
	push	eax
	call	DWORD PTR __imp_?add_face_packed_D@Collector@CDB@@QAEXABU?$_vector3@M@@00IM@Z
; File I:\Vitalya\mine\NSProjectX\xrCore\FS.h

; 260  : 	IC int			elapsed		()	const		{	return Size-Pos;		};

	mov	eax, DWORD PTR [esi+12]
	sub	eax, DWORD PTR [esi+8]

; 139  : 	IC BOOL			eof			()	const		{return impl().elapsed()<=0;	};

	test	eax, eax
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp

; 82   : 	while (!S->eof())

	jg	SHORT $LL2@Load
$LN3@Load:

; 91   : 	CL.calc_adjacency	(adjacency);

	lea	eax, DWORD PTR _adjacency$[esp+648]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR _adjacency$[esp+648], 0
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp

; 91   : 	CL.calc_adjacency	(adjacency);

	push	eax
	lea	ecx, DWORD PTR _CL$[esp+652]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR _adjacency$[esp+656], 0
	mov	DWORD PTR _adjacency$[esp+660], 0
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp

; 91   : 	CL.calc_adjacency	(adjacency);

	call	DWORD PTR __imp_?calc_adjacency@Collector@CDB@@QAEXAAV?$xr_vector@IV?$xalloc@I@@@@@Z

; 92   : 
; 93   : 	// Create RASTER-triangles
; 94   : 	m_pTris				= xr_alloc<occTri>	(u32(CL.getTS()));

	lea	ecx, DWORD PTR _CL$[esp+648]
	call	DWORD PTR __imp_?getTS@Collector@CDB@@QAEIXZ
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	imul	eax, eax, 88
	push	eax
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp

; 95   : 	for (u32 it=0; it<CL.getTS(); it++)

	lea	ecx, DWORD PTR _CL$[esp+648]
	mov	DWORD PTR [ebx+28], eax
	mov	DWORD PTR _it$1$[esp+648], 0
	call	DWORD PTR __imp_?getTS@Collector@CDB@@QAEIXZ
	test	eax, eax
	je	$LN5@Load
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	xor	esi, esi
	mov	DWORD PTR tv1516[esp+648], 0
	mov	DWORD PTR tv1515[esp+648], 0
	mov	DWORD PTR tv1514[esp+648], esi
	npad	6
$LL6@Load:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp

; 97   : 		CDB::TRI&	clT = CL.getT()[it];

	lea	ecx, DWORD PTR _CL$[esp+648]
	call	DWORD PTR __imp_?getT@Collector@CDB@@QAEPAVTRI@2@XZ

; 98   : 		occTri&		rT	= m_pTris[it];
; 99   : 		Fvector&	v0	= CL.getV()[clT.verts[0]];

	lea	ecx, DWORD PTR _CL$[esp+648]
	lea	edi, DWORD PTR [esi+eax]
	mov	esi, DWORD PTR [ebx+28]
	add	esi, DWORD PTR tv1515[esp+648]
	call	DWORD PTR __imp_?getV@Collector@CDB@@QAEPAU?$_vector3@M@@XZ
	mov	ecx, DWORD PTR [edi]
	lea	ecx, DWORD PTR [ecx+ecx*2]
	lea	eax, DWORD PTR [eax+ecx*4]

; 100  : 		Fvector&	v1	= CL.getV()[clT.verts[1]];

	lea	ecx, DWORD PTR _CL$[esp+648]
	mov	DWORD PTR _v0$1$[esp+648], eax
	call	DWORD PTR __imp_?getV@Collector@CDB@@QAEPAU?$_vector3@M@@XZ
	mov	ecx, DWORD PTR [edi+4]
	lea	ecx, DWORD PTR [ecx+ecx*2]
	lea	eax, DWORD PTR [eax+ecx*4]

; 101  : 		Fvector&	v2	= CL.getV()[clT.verts[2]];

	lea	ecx, DWORD PTR _CL$[esp+648]
	mov	DWORD PTR _v1$1$[esp+648], eax
	call	DWORD PTR __imp_?getV@Collector@CDB@@QAEPAU?$_vector3@M@@XZ
	mov	ecx, DWORD PTR [edi+8]

; 102  : 		rT.adjacent[0]	= (0xffffffff==adjacency[3*it+0])?((occTri*) (-1)):(m_pTris+adjacency[3*it+0]);

	mov	edx, DWORD PTR tv1516[esp+648]
	lea	ecx, DWORD PTR [ecx+ecx*2]
	lea	ecx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR _adjacency$[esp+648]
	mov	DWORD PTR _v2$1$[esp+648], ecx
	mov	eax, DWORD PTR [edx+eax]
	cmp	eax, -1
	jne	SHORT $LN52@Load
	or	eax, eax
	jmp	SHORT $LN11@Load
$LN52@Load:
	imul	eax, eax, 88
	add	eax, DWORD PTR [ebx+28]
$LN11@Load:
	mov	DWORD PTR [esi], eax

; 103  : 		rT.adjacent[1]	= (0xffffffff==adjacency[3*it+1])?((occTri*) (-1)):(m_pTris+adjacency[3*it+1]);

	mov	eax, DWORD PTR _adjacency$[esp+648]
	mov	eax, DWORD PTR [edx+eax+4]
	cmp	eax, -1
	jne	SHORT $LN86@Load
	or	eax, eax
	jmp	SHORT $LN13@Load
$LN86@Load:
	imul	eax, eax, 88
	add	eax, DWORD PTR [ebx+28]
$LN13@Load:
	mov	DWORD PTR [esi+4], eax

; 104  : 		rT.adjacent[2]	= (0xffffffff==adjacency[3*it+2])?((occTri*) (-1)):(m_pTris+adjacency[3*it+2]);

	mov	eax, DWORD PTR _adjacency$[esp+648]
	mov	eax, DWORD PTR [edx+eax+8]
	cmp	eax, -1
	jne	SHORT $LN120@Load
	or	eax, eax
	jmp	SHORT $LN15@Load
$LN120@Load:
	imul	eax, eax, 88
	add	eax, DWORD PTR [ebx+28]
$LN15@Load:
	mov	DWORD PTR [esi+8], eax

; 105  : 		rT.flags		= clT.dummy;

	mov	eax, DWORD PTR [edi+12]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 287  : 	{	return (x-v.x)*(x-v.x) + (y-v.y)*(y-v.y) + (z-v.z)*(z-v.z);	}

	mov	edi, DWORD PTR _v0$1$[esp+648]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp

; 105  : 		rT.flags		= clT.dummy;

	mov	DWORD PTR [esi+68], eax
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 287  : 	{	return (x-v.x)*(x-v.x) + (y-v.y)*(y-v.y) + (z-v.z)*(z-v.z);	}

	mov	eax, DWORD PTR _v1$1$[esp+648]
	movss	xmm4, DWORD PTR [edi]
	movss	xmm5, DWORD PTR [edi+4]
	movaps	xmm1, xmm4
	subss	xmm4, DWORD PTR [ecx]
	movss	xmm3, DWORD PTR [edi+8]
	movaps	xmm2, xmm5
	subss	xmm5, DWORD PTR [ecx+4]
	subss	xmm2, DWORD PTR [eax+4]
	subss	xmm1, DWORD PTR [eax]
	movss	xmm6, DWORD PTR [eax+8]
	movaps	xmm0, xmm3
	subss	xmm3, DWORD PTR [ecx+8]
	mulss	xmm4, xmm4
	subss	xmm0, xmm6
	subss	xmm6, DWORD PTR [ecx+8]
	mulss	xmm5, xmm5
	mulss	xmm2, xmm2
	addss	xmm4, xmm5
	mulss	xmm3, xmm3
	mulss	xmm1, xmm1
	mulss	xmm0, xmm0
	addss	xmm4, xmm3
	mulss	xmm6, xmm6
	addss	xmm1, xmm2
	movss	xmm2, DWORD PTR [eax]
	subss	xmm2, DWORD PTR [ecx]
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h

; 764  :             return (float)sqrt(_X);

	sqrtss	xmm3, xmm4
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 287  : 	{	return (x-v.x)*(x-v.x) + (y-v.y)*(y-v.y) + (z-v.z)*(z-v.z);	}

	movss	xmm4, DWORD PTR [eax+4]
	addss	xmm1, xmm0
	subss	xmm4, DWORD PTR [ecx+4]
	mulss	xmm2, xmm2
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h

; 764  :             return (float)sqrt(_X);

	sqrtss	xmm7, xmm1
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 287  : 	{	return (x-v.x)*(x-v.x) + (y-v.y)*(y-v.y) + (z-v.z)*(z-v.z);	}

	mulss	xmm4, xmm4
	addss	xmm2, xmm4
	addss	xmm2, xmm6
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h

; 764  :             return (float)sqrt(_X);

	sqrtss	xmm0, xmm2
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp

; 61   : 	float	p  = (e1+e2+e3)/2.f;

	movaps	xmm2, xmm3
	addss	xmm2, xmm7
	addss	xmm2, xmm0
	mulss	xmm2, DWORD PTR __real@3f000000

; 62   : 	return	_sqrt( p*(p-e1)*(p-e2)*(p-e3) );

	movaps	xmm1, xmm2
	subss	xmm1, xmm0
	movaps	xmm0, xmm2
	subss	xmm0, xmm3
	mulss	xmm1, xmm0
	movaps	xmm0, xmm2
	subss	xmm0, xmm7
	mulss	xmm0, xmm2
	mulss	xmm1, xmm0
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h

; 764  :             return (float)sqrt(_X);

	sqrtss	xmm0, xmm1
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp

; 107  : 		if (rT.area<EPS_L)	{

	movss	xmm1, DWORD PTR __real@3a83126f
	comiss	xmm1, xmm0
	movss	DWORD PTR [esi+64], xmm0
	jbe	SHORT $LN8@Load

; 108  : 			Msg	("! Invalid HOM triangle (%f,%f,%f)-(%f,%f,%f)-(%f,%f,%f)",VPUSH(v0),VPUSH(v1),VPUSH(v2));

	fld	DWORD PTR [ecx+8]
	sub	esp, 72					; 00000048H
	fstp	QWORD PTR [esp+64]
	fld	DWORD PTR [ecx+4]
	fstp	QWORD PTR [esp+56]
	fld	DWORD PTR [ecx]
	fstp	QWORD PTR [esp+48]
	fld	DWORD PTR [eax+8]
	fstp	QWORD PTR [esp+40]
	fld	DWORD PTR [eax+4]
	fstp	QWORD PTR [esp+32]
	fld	DWORD PTR [eax]
	fstp	QWORD PTR [esp+24]
	fld	DWORD PTR [edi+8]
	fstp	QWORD PTR [esp+16]
	fld	DWORD PTR [edi+4]
	fstp	QWORD PTR [esp+8]
	fld	DWORD PTR [edi]
	fstp	QWORD PTR [esp]
	push	OFFSET ??_C@_0DI@NJHJIMJP@?$CB?5Invalid?5HOM?5triangle?5?$CI?$CFf?0?$CFf?0?$CF@
	call	DWORD PTR __imp_?Msg@@YAXPBDZZ
	mov	eax, DWORD PTR _v1$1$[esp+724]
	add	esp, 76					; 0000004cH
	mov	ecx, DWORD PTR _v2$1$[esp+648]
	mov	edx, DWORD PTR tv1516[esp+648]
$LN8@Load:
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	xmm3, DWORD PTR [edi+4]
	movss	xmm6, DWORD PTR [edi+8]
	movaps	xmm2, xmm3
	subss	xmm3, DWORD PTR [eax+4]
	subss	xmm2, DWORD PTR [ecx+4]
	movss	xmm7, DWORD PTR [edi]
	movaps	xmm1, xmm6
	subss	xmm6, DWORD PTR [eax+8]
	subss	xmm1, DWORD PTR [ecx+8]
; File I:\Vitalya\mine\NSProjectX\xrCore\_plane.h

; 28   : 		n.crossproduct(t1.sub(v1,v2), t2.sub(v1,v3)).normalize();

	movaps	xmm5, xmm3
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp

; 95   : 	for (u32 it=0; it<CL.getTS(); it++)

	add	DWORD PTR tv1515[esp+648], 88		; 00000058H
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movaps	xmm4, xmm7
	subss	xmm7, DWORD PTR [eax]
	subss	xmm4, DWORD PTR [ecx]

; 273  : 		x = v1.y  * v2.z  - v1.z  * v2.y ;

	movaps	xmm0, xmm6
; File I:\Vitalya\mine\NSProjectX\xrCore\_plane.h

; 28   : 		n.crossproduct(t1.sub(v1,v2), t2.sub(v1,v3)).normalize();

	mulss	xmm5, xmm1
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 273  : 		x = v1.y  * v2.z  - v1.z  * v2.y ;

	mulss	xmm0, xmm2
	mulss	xmm6, xmm4
	subss	xmm5, xmm0

; 275  : 		z = v1.x  * v2.y  - v1.y  * v2.x ;

	mulss	xmm3, xmm4
	movaps	xmm0, xmm7

; 45   : 	ICF SelfRef	div(T s)								{ x/=s;		y/=s;    z/=s;				return *this;	};

	movss	xmm4, DWORD PTR __real@3eaaaaab

; 274  : 		y = v1.z  * v2.x  - v1.x  * v2.z ;

	mulss	xmm0, xmm1
	mulss	xmm7, xmm2

; 190  : 		T mag=_sqrt(T(1)/(x*x + y*y + z*z));

	movaps	xmm1, xmm5

; 274  : 		y = v1.z  * v2.x  - v1.x  * v2.z ;

	subss	xmm6, xmm0

; 190  : 		T mag=_sqrt(T(1)/(x*x + y*y + z*z));

	mulss	xmm1, xmm5

; 275  : 		z = v1.x  * v2.y  - v1.y  * v2.x ;

	subss	xmm7, xmm3

; 190  : 		T mag=_sqrt(T(1)/(x*x + y*y + z*z));

	movaps	xmm0, xmm6
	mulss	xmm0, xmm6
	addss	xmm1, xmm0
	movaps	xmm0, xmm7
	mulss	xmm0, xmm7
	addss	xmm1, xmm0
	movss	xmm0, DWORD PTR __real@3f800000
	divss	xmm0, xmm1
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h

; 764  :             return (float)sqrt(_X);

	sqrtss	xmm0, xmm0
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 192  : 		y *= mag;

	mulss	xmm6, xmm0
	mulss	xmm5, xmm0
	movss	DWORD PTR [esi+52], xmm6

; 193  : 		z *= mag;

	mulss	xmm7, xmm0
	movss	DWORD PTR [esi+48], xmm5
	movss	DWORD PTR [esi+56], xmm7

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	mulss	xmm6, DWORD PTR [edi+4]
	mulss	xmm5, DWORD PTR [edi]
	mulss	xmm7, DWORD PTR [edi+8]
	addss	xmm6, xmm5
	addss	xmm6, xmm7
	xorps	xmm6, DWORD PTR __xmm@80000000800000008000000080000000
; File I:\Vitalya\mine\NSProjectX\xrCore\_plane.h

; 29   : 		d = -n.dotproduct(v1);

	movss	DWORD PTR [esi+60], xmm6
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp

; 111  : 		rT.skip			= 0;

	mov	DWORD PTR [esi+72], 0
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	movss	xmm3, DWORD PTR [edi]
	addss	xmm3, DWORD PTR [eax]
	movss	DWORD PTR [esi+76], xmm3
	movss	xmm2, DWORD PTR [eax+4]
	addss	xmm2, DWORD PTR [edi+4]
	movss	DWORD PTR [esi+80], xmm2
	movss	xmm1, DWORD PTR [eax+8]
	addss	xmm1, DWORD PTR [edi+8]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp

; 95   : 	for (u32 it=0; it<CL.getTS(); it++)

	mov	edi, DWORD PTR _it$1$[esp+648]
	inc	edi
	mov	DWORD PTR _it$1$[esp+648], edi
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	movss	DWORD PTR [esi+84], xmm1

; 29   : 	ICF	SelfRef	add(const Self &v)						{ x+=v.x;	y+=v.y;		z+=v.z;			return *this;	};

	addss	xmm3, DWORD PTR [ecx]
	movss	DWORD PTR [esi+76], xmm3
	addss	xmm2, DWORD PTR [ecx+4]

; 45   : 	ICF SelfRef	div(T s)								{ x/=s;		y/=s;    z/=s;				return *this;	};

	mulss	xmm3, xmm4

; 29   : 	ICF	SelfRef	add(const Self &v)						{ x+=v.x;	y+=v.y;		z+=v.z;			return *this;	};

	movss	DWORD PTR [esi+80], xmm2
	movss	xmm0, DWORD PTR [ecx+8]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp

; 95   : 	for (u32 it=0; it<CL.getTS(); it++)

	lea	ecx, DWORD PTR _CL$[esp+648]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 45   : 	ICF SelfRef	div(T s)								{ x/=s;		y/=s;    z/=s;				return *this;	};

	addss	xmm0, xmm1
	mulss	xmm2, xmm4
	movss	DWORD PTR [esi+76], xmm3
	movss	DWORD PTR [esi+80], xmm2
	mulss	xmm0, xmm4
	movss	DWORD PTR [esi+84], xmm0
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp

; 95   : 	for (u32 it=0; it<CL.getTS(); it++)

	mov	esi, DWORD PTR tv1514[esp+648]
	add	esi, 16					; 00000010H
	add	edx, 12					; 0000000cH
	mov	DWORD PTR tv1514[esp+648], esi
	mov	DWORD PTR tv1516[esp+648], edx
	call	DWORD PTR __imp_?getTS@Collector@CDB@@QAEIXZ
	cmp	edi, eax
	jb	$LL6@Load
	mov	esi, DWORD PTR _S$1$[esp+648]
$LN5@Load:
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h

; 68   : 	T* ptr	= (T*)Memory.mem_alloc(sizeof(T));

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	28					; 0000001cH
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z

; 69   : 	return new (ptr) T();

	mov	ecx, eax
	call	DWORD PTR __imp_??0MODEL@CDB@@QAE@XZ
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp

; 117  : 	m_pModel->build		(CL.getV(),int(CL.getVS()),CL.getT(),int(CL.getTS()));

	push	0
	push	0
	lea	ecx, DWORD PTR _CL$[esp+656]
	mov	DWORD PTR [ebx+24], eax
	call	DWORD PTR __imp_?getTS@Collector@CDB@@QAEIXZ
	push	eax
	lea	ecx, DWORD PTR _CL$[esp+660]
	call	DWORD PTR __imp_?getT@Collector@CDB@@QAEPAVTRI@2@XZ
	push	eax
	lea	ecx, DWORD PTR _CL$[esp+664]
	call	DWORD PTR __imp_?getVS@Collector@CDB@@QAEIXZ
	push	eax
	lea	ecx, DWORD PTR _CL$[esp+668]
	call	DWORD PTR __imp_?getV@Collector@CDB@@QAEPAU?$_vector3@M@@XZ
	mov	ecx, DWORD PTR [ebx+24]
	push	eax
	call	DWORD PTR __imp_?build@MODEL@CDB@@QAEXPAU?$_vector3@M@@HPAVTRI@2@HP6GX0H1HPAX@Z2@Z

; 118  : 	bEnabled			= TRUE;
; 119  : 	S->close			();

	mov	ecx, esi
	mov	DWORD PTR [ebx+32], 1
	call	DWORD PTR __imp_?close@IReader@@QAEXXZ

; 120  : 	FS.r_close			(fs);

	mov	ecx, DWORD PTR __imp_?xr_FS@@3PAVCLocatorAPI@@A
	lea	eax, DWORD PTR _fs$[esp+648]
	push	eax
	mov	ecx, DWORD PTR [ecx]
	call	DWORD PTR __imp_?r_close@CLocatorAPI@@QAEXAAPAVIReader@@@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR _adjacency$[esp+648]
	test	eax, eax
	je	SHORT $LN196@Load
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR _adjacency$[esp+648], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR _adjacency$[esp+652], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR _adjacency$[esp+656], 0
$LN196@Load:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp

; 121  : }

	lea	ecx, DWORD PTR _CL$[esp+648]
	call	DWORD PTR __imp_??1Collector@CDB@@QAE@XZ
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Load@CHOM@@QAEXXZ ENDP					; CHOM::Load
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp
_TEXT	SEGMENT
?Unload@CHOM@@QAEXXZ PROC				; CHOM::Unload
; _this$ = ecx

; 124  : {

	push	esi
	mov	esi, ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h

; 151  : 	if (ptr) 

	mov	ecx, DWORD PTR [esi+24]
	test	ecx, ecx
	je	SHORT $LN4@Unload
	call	DWORD PTR __imp_??1MODEL@CDB@@QAE@XZ

; 144  : 		Memory.mem_free	(ptr);

	push	DWORD PTR [esi+24]
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z

; 154  : 		ptr = nullptr;

	mov	DWORD PTR [esi+24], 0
$LN4@Unload:
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	eax, DWORD PTR [esi+28]
	test	eax, eax
	je	SHORT $LN14@Unload
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
	mov	DWORD PTR [esi+28], 0
$LN14@Unload:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp

; 128  : }

	mov	DWORD PTR [esi+32], 0
	pop	esi
	ret	0
?Unload@CHOM@@QAEXXZ ENDP				; CHOM::Unload
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp
;	COMDAT ??0pred_fb@@QAE@PAVoccTri@@@Z
_TEXT	SEGMENT
__t$ = 8						; size = 4
??0pred_fb@@QAE@PAVoccTri@@@Z PROC			; pred_fb::pred_fb, COMDAT
; _this$ = ecx

; 135  : 	pred_fb		(occTri* _t) : m_pTris(_t)	{}

	mov	eax, DWORD PTR __t$[esp-4]
	mov	DWORD PTR [ecx], eax
	mov	eax, ecx
	ret	4
??0pred_fb@@QAE@PAVoccTri@@@Z ENDP			; pred_fb::pred_fb
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp
;	COMDAT ??0pred_fb@@QAE@PAVoccTri@@AAU?$_vector3@M@@@Z
_TEXT	SEGMENT
__t$ = 8						; size = 4
__c$ = 12						; size = 4
??0pred_fb@@QAE@PAVoccTri@@AAU?$_vector3@M@@@Z PROC	; pred_fb::pred_fb, COMDAT
; _this$ = ecx

; 136  : 	pred_fb		(occTri* _t, Fvector& _c) : m_pTris(_t), camera(_c)	{}

	mov	edx, DWORD PTR __c$[esp-4]
	mov	eax, DWORD PTR __t$[esp-4]
	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx+4], eax
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+8], eax
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR [ecx+12], eax
	mov	eax, ecx
	ret	8
??0pred_fb@@QAE@PAVoccTri@@AAU?$_vector3@M@@@Z ENDP	; pred_fb::pred_fb
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp
;	COMDAT ??Rpred_fb@@QBE_NABURESULT@CDB@@0@Z
_TEXT	SEGMENT
__1$ = 8						; size = 4
__2$ = 12						; size = 4
??Rpred_fb@@QBE_NABURESULT@CDB@@0@Z PROC		; pred_fb::operator(), COMDAT
; _this$ = ecx

; 138  : 		occTri&	t0	= m_pTris	[_1.id];

	mov	eax, DWORD PTR __1$[esp-4]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 287  : 	{	return (x-v.x)*(x-v.x) + (y-v.y)*(y-v.y) + (z-v.z)*(z-v.z);	}

	movss	xmm5, DWORD PTR [ecx+8]
	movss	xmm4, DWORD PTR [ecx+4]
	movaps	xmm1, xmm5
	movss	xmm2, DWORD PTR [ecx+12]
	movaps	xmm3, xmm4
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp

; 138  : 		occTri&	t0	= m_pTris	[_1.id];

	imul	edx, DWORD PTR [eax+40], 88
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 287  : 	{	return (x-v.x)*(x-v.x) + (y-v.y)*(y-v.y) + (z-v.z)*(z-v.z);	}

	movaps	xmm0, xmm2
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp

; 139  : 		occTri&	t1	= m_pTris	[_2.id];

	mov	eax, DWORD PTR __2$[esp-4]
	push	esi

; 140  : 		return	camera.distance_to_sqr(t0.center) < camera.distance_to_sqr(t1.center);

	mov	esi, DWORD PTR [ecx]
	imul	eax, DWORD PTR [eax+40], 88
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 287  : 	{	return (x-v.x)*(x-v.x) + (y-v.y)*(y-v.y) + (z-v.z)*(z-v.z);	}

	subss	xmm3, DWORD PTR [edx+esi+76]
	subss	xmm1, DWORD PTR [edx+esi+80]
	subss	xmm0, DWORD PTR [edx+esi+84]
	subss	xmm4, DWORD PTR [eax+esi+76]
	subss	xmm5, DWORD PTR [eax+esi+80]
	subss	xmm2, DWORD PTR [eax+esi+84]
	mulss	xmm3, xmm3
	pop	esi
	mulss	xmm4, xmm4
	mulss	xmm1, xmm1
	mulss	xmm5, xmm5
	addss	xmm3, xmm1
	mulss	xmm0, xmm0
	addss	xmm4, xmm5
	mulss	xmm2, xmm2
	addss	xmm3, xmm0
	addss	xmm4, xmm2
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp

; 140  : 		return	camera.distance_to_sqr(t0.center) < camera.distance_to_sqr(t1.center);

	comiss	xmm4, xmm3
	jbe	SHORT $LN3@operator
	mov	al, 1

; 141  : 	}

	ret	8
$LN3@operator:

; 140  : 		return	camera.distance_to_sqr(t0.center) < camera.distance_to_sqr(t1.center);

	xor	al, al

; 141  : 	}

	ret	8
??Rpred_fb@@QBE_NABURESULT@CDB@@0@Z ENDP		; pred_fb::operator()
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp
;	COMDAT ??Rpred_fb@@QBE_NABURESULT@CDB@@@Z
_TEXT	SEGMENT
__1$ = 8						; size = 4
??Rpred_fb@@QBE_NABURESULT@CDB@@@Z PROC			; pred_fb::operator(), COMDAT
; _this$ = ecx

; 143  : 		occTri&	T	= m_pTris	[_1.id];

	mov	eax, DWORD PTR __1$[esp-4]
	imul	edx, DWORD PTR [eax+40], 88

; 144  : 		return	T.skip>Device.dwFrame;

	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+eax+72]
	mov	eax, DWORD PTR __imp_?Device@@3VCRenderDevice@@A
	cmp	ecx, DWORD PTR [eax+244]
	seta	al

; 145  : 	}

	ret	4
??Rpred_fb@@QBE_NABURESULT@CDB@@@Z ENDP			; pred_fb::operator()
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp
; File I:\Vitalya\mine\NSProjectX\xrCDB\xrCDB.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\FixedVector.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_random.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_random.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_plane.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_plane.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp
; File I:\Vitalya\mine\NSProjectX\xrCDB\xrCDB.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp
; File I:\Vitalya\mine\NSProjectX\xrCDB\xrCDB.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\FixedVector.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\FixedVector.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\FixedVector.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\FixedVector.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\FixedVector.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp
_TEXT	SEGMENT
$T1 = -1472						; size = 4
tv4228 = -1472						; size = 4
_next$1$ = -1468					; size = 4
_it$1$ = -1468						; size = 4
$T2 = -1464						; size = 4
_pixels$1$ = -1464					; size = 4
_end$1$ = -1460						; size = 4
tv4288 = -1460						; size = 4
__UNext$1$ = -1456					; size = 4
$T3 = -1452						; size = 4
__frame$1$ = -1452					; size = 4
$T4 = -1448						; size = 4
_COP$ = -1444						; size = 12
__Pred$ = -1432						; size = 16
_src$ = -1416						; size = 580
_clip$ = -832						; size = 244
_dst$ = -584						; size = 580
_base$ = 8						; size = 4
?Render_DB@CHOM@@AAEXAAVCFrustum@@@Z PROC		; CHOM::Render_DB
; _this$ = ecx

; 149  : {

	sub	esp, 1472				; 000005c0H
	push	ebx
	push	ebp
	push	esi
	push	edi

; 152  : 	xrc.frustum_query			(m_pModel,base);

	push	DWORD PTR _base$[esp+1484]
	mov	ebx, ecx
	push	DWORD PTR [ebx+24]
; File I:\Vitalya\mine\NSProjectX\xrCDB\xrCDB.h

; 151  : 		ICF void		frustum_options	(u32 f)	{	frustum_mode = f;	}

	mov	DWORD PTR [ebx+8], 0
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp

; 152  : 	xrc.frustum_query			(m_pModel,base);

	call	DWORD PTR __imp_?frustum_query@xrXRC@@QAEXPBVMODEL@CDB@@ABVCFrustum@@@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	eax, DWORD PTR [ebx+16]
	sub	eax, DWORD PTR [ebx+12]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp

; 153  : 	if (0==xrc.r_count())		return;

	je	$LN3@Render_DB

; 154  : 
; 155  : 	// Prepare
; 156  : 	CDB::RESULT*	it			= xrc.r_begin	();

	mov	ecx, ebx
	call	DWORD PTR __imp_?r_begin@xrXRC@@QAEPAURESULT@CDB@@XZ
	mov	ebp, eax

; 157  : 	CDB::RESULT*	end			= xrc.r_end		();

	mov	ecx, ebx
	mov	DWORD PTR _it$1$[esp+1488], ebp
	call	DWORD PTR __imp_?r_end@xrXRC@@QAEPAURESULT@CDB@@XZ

; 158  : 	
; 159  : 	Fvector			COP			= Device.vCameraPosition;

	mov	ecx, DWORD PTR __imp_?Device@@3VCRenderDevice@@A
	mov	esi, eax

; 135  : 	pred_fb		(occTri* _t) : m_pTris(_t)	{}

	mov	edi, DWORD PTR [ebx+28]

; 157  : 	CDB::RESULT*	end			= xrc.r_end		();

	mov	DWORD PTR _end$1$[esp+1488], esi

; 135  : 	pred_fb		(occTri* _t) : m_pTris(_t)	{}

	mov	DWORD PTR $T2[esp+1488], edi

; 158  : 	
; 159  : 	Fvector			COP			= Device.vCameraPosition;

	mov	eax, DWORD PTR [ecx+488]
	mov	DWORD PTR $T1[esp+1488], eax
	mov	DWORD PTR _COP$[esp+1488], eax
	mov	eax, DWORD PTR [ecx+492]
	mov	DWORD PTR $T4[esp+1488], eax
	mov	DWORD PTR _COP$[esp+1492], eax
	mov	eax, DWORD PTR [ecx+496]
	mov	DWORD PTR $T3[esp+1488], eax
	mov	DWORD PTR _COP$[esp+1496], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility

; 5529 :     auto _UFirst      = _Get_unwrapped(_First);

	mov	DWORD PTR __UNext$1$[esp+1488], ebp

; 5530 :     const auto _ULast = _Get_unwrapped(_Last);
; 5531 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	ebp, esi
	je	SHORT $LN57@Render_DB
	mov	edx, DWORD PTR [ecx+244]
$LL66@Render_DB:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp

; 143  : 		occTri&	T	= m_pTris	[_1.id];

	imul	eax, DWORD PTR [ebp+40], 88

; 144  : 		return	T.skip>Device.dwFrame;

	cmp	DWORD PTR [eax+edi+72], edx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility

; 5532 :         if (_Pred(*_UFirst)) {

	ja	SHORT $LN163@Render_DB

; 5530 :     const auto _ULast = _Get_unwrapped(_Last);
; 5531 :     for (; _UFirst != _ULast; ++_UFirst) {

	add	ebp, 56					; 00000038H
	cmp	ebp, esi
	jne	SHORT $LL66@Render_DB
$LN163@Render_DB:
	mov	DWORD PTR __UNext$1$[esp+1488], ebp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1983 :     if (_UFirst != _ULast) {

	cmp	ebp, esi
	je	SHORT $LN57@Render_DB

; 1984 :         while (++_UFirst != _ULast) {

	lea	edx, DWORD PTR [ebp+56]
	cmp	edx, esi
	je	SHORT $LN57@Render_DB
$LL56@Render_DB:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp

; 143  : 		occTri&	T	= m_pTris	[_1.id];

	imul	eax, DWORD PTR [edx+40], 88

; 144  : 		return	T.skip>Device.dwFrame;

	mov	eax, DWORD PTR [eax+edi+72]
	cmp	eax, DWORD PTR [ecx+244]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1985 :             if (!_Pred(*_UFirst)) {

	ja	SHORT $LN59@Render_DB

; 1986 :                 *_UNext = _STD move(*_UFirst);

	mov	edi, ebp
	mov	ecx, 14					; 0000000eH
	mov	esi, edx

; 1987 :                 ++_UNext;

	add	ebp, 56					; 00000038H
	rep movsd
	mov	ecx, DWORD PTR __imp_?Device@@3VCRenderDevice@@A
	mov	esi, DWORD PTR _end$1$[esp+1488]
	mov	edi, DWORD PTR $T2[esp+1488]
$LN59@Render_DB:

; 1984 :         while (++_UFirst != _ULast) {

	add	edx, 56					; 00000038H
	cmp	edx, esi
	jne	SHORT $LL56@Render_DB
	mov	DWORD PTR __UNext$1$[esp+1488], ebp
$LN57@Render_DB:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp

; 136  : 	pred_fb		(occTri* _t, Fvector& _c) : m_pTris(_t), camera(_c)	{}

	mov	eax, DWORD PTR [ebx+28]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 7080 :     _Sort_unchecked(_UFirst, _ULast, _ULast - _UFirst, _Pass_fn(_Pred));

	mov	edx, ebp
	mov	esi, DWORD PTR _it$1$[esp+1488]
	mov	ecx, esi
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp

; 161  : 	std::sort		(it,end,pred_fb(m_pTris,COP));

	mov	DWORD PTR __Pred$[esp+1488], eax
	mov	eax, DWORD PTR $T1[esp+1488]
	mov	DWORD PTR __Pred$[esp+1492], eax
	mov	eax, DWORD PTR $T4[esp+1488]
	mov	DWORD PTR __Pred$[esp+1496], eax
	mov	eax, DWORD PTR $T3[esp+1488]
	mov	DWORD PTR __Pred$[esp+1500], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 7080 :     _Sort_unchecked(_UFirst, _ULast, _ULast - _UFirst, _Pass_fn(_Pred));

	lea	eax, DWORD PTR __Pred$[esp+1488]
	push	eax
	mov	eax, ebp
	sub	eax, esi
	sar	eax, 3
	imul	eax, eax, -1227133513
	push	eax
	call	??$_Sort_unchecked@PAURESULT@CDB@@U?$_Ref_fn@Vpred_fb@@@std@@@std@@YAXPAURESULT@CDB@@0HU?$_Ref_fn@Vpred_fb@@@0@@Z ; std::_Sort_unchecked<CDB::RESULT *,std::_Ref_fn<pred_fb> >
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp

; 176  : 	m_xform.mul					(m_viewport,	Device.mFullTransform);

	mov	eax, DWORD PTR __imp_?Device@@3VCRenderDevice@@A
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 7080 :     _Sort_unchecked(_UFirst, _ULast, _ULast - _UFirst, _Pass_fn(_Pred));

	add	esp, 8
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 85   : 		m[0][0] = A.m[0][0] * B.m[0][0] + A.m[1][0] * B.m[0][1] + A.m[2][0] * B.m[0][2] + A.m[3][0] * B.m[0][3];

	movss	xmm2, DWORD PTR __real@42000000
	movss	xmm0, DWORD PTR [eax+664]
	addss	xmm0, DWORD PTR [eax+676]
	mulss	xmm0, xmm2
	movss	DWORD PTR [ebx+36], xmm0

; 86   : 		m[0][1] = A.m[0][1] * B.m[0][0] + A.m[1][1] * B.m[0][1] + A.m[2][1] * B.m[0][2] + A.m[3][1] * B.m[0][3];

	movss	xmm1, DWORD PTR [eax+676]
	movss	xmm0, DWORD PTR [eax+668]
	mulss	xmm0, xmm2
	mulss	xmm1, xmm2
	subss	xmm1, xmm0
	movss	DWORD PTR [ebx+40], xmm1

; 87   : 		m[0][2] = A.m[0][2] * B.m[0][0] + A.m[1][2] * B.m[0][1] + A.m[2][2] * B.m[0][2] + A.m[3][2] * B.m[0][3];

	fld	DWORD PTR [eax+672]
	fstp	DWORD PTR [ebx+44]

; 88   : 		m[0][3] = A.m[0][3] * B.m[0][0] + A.m[1][3] * B.m[0][1] + A.m[2][3] * B.m[0][2] + A.m[3][3] * B.m[0][3];

	fld	DWORD PTR [eax+676]
	fstp	DWORD PTR [ebx+48]

; 89   : 
; 90   : 		m[1][0] = A.m[0][0] * B.m[1][0] + A.m[1][0] * B.m[1][1] + A.m[2][0] * B.m[1][2] + A.m[3][0] * B.m[1][3];

	movss	xmm0, DWORD PTR [eax+680]
	addss	xmm0, DWORD PTR [eax+692]
	mulss	xmm0, xmm2
	movss	DWORD PTR [ebx+52], xmm0

; 91   : 		m[1][1] = A.m[0][1] * B.m[1][0] + A.m[1][1] * B.m[1][1] + A.m[2][1] * B.m[1][2] + A.m[3][1] * B.m[1][3];

	movss	xmm1, DWORD PTR [eax+692]
	movss	xmm0, DWORD PTR [eax+684]
	mulss	xmm0, xmm2
	mulss	xmm1, xmm2
	subss	xmm1, xmm0
	movss	DWORD PTR [ebx+56], xmm1

; 92   : 		m[1][2] = A.m[0][2] * B.m[1][0] + A.m[1][2] * B.m[1][1] + A.m[2][2] * B.m[1][2] + A.m[3][2] * B.m[1][3];

	fld	DWORD PTR [eax+688]
	fstp	DWORD PTR [ebx+60]

; 93   : 		m[1][3] = A.m[0][3] * B.m[1][0] + A.m[1][3] * B.m[1][1] + A.m[2][3] * B.m[1][2] + A.m[3][3] * B.m[1][3];

	fld	DWORD PTR [eax+692]
	fstp	DWORD PTR [ebx+64]

; 94   : 
; 95   : 		m[2][0] = A.m[0][0] * B.m[2][0] + A.m[1][0] * B.m[2][1] + A.m[2][0] * B.m[2][2] + A.m[3][0] * B.m[2][3];

	movss	xmm0, DWORD PTR [eax+696]
	addss	xmm0, DWORD PTR [eax+708]
	mulss	xmm0, xmm2
	movss	DWORD PTR [ebx+68], xmm0

; 96   : 		m[2][1] = A.m[0][1] * B.m[2][0] + A.m[1][1] * B.m[2][1] + A.m[2][1] * B.m[2][2] + A.m[3][1] * B.m[2][3];

	movss	xmm1, DWORD PTR [eax+708]
	movss	xmm0, DWORD PTR [eax+700]
	mulss	xmm0, xmm2
	mulss	xmm1, xmm2
	subss	xmm1, xmm0
	movss	DWORD PTR [ebx+72], xmm1

; 97   : 		m[2][2] = A.m[0][2] * B.m[2][0] + A.m[1][2] * B.m[2][1] + A.m[2][2] * B.m[2][2] + A.m[3][2] * B.m[2][3];

	fld	DWORD PTR [eax+704]
	fstp	DWORD PTR [ebx+76]

; 98   : 		m[2][3] = A.m[0][3] * B.m[2][0] + A.m[1][3] * B.m[2][1] + A.m[2][3] * B.m[2][2] + A.m[3][3] * B.m[2][3];

	fld	DWORD PTR [eax+708]
	fstp	DWORD PTR [ebx+80]

; 99   : 
; 100  : 		m[3][0] = A.m[0][0] * B.m[3][0] + A.m[1][0] * B.m[3][1] + A.m[2][0] * B.m[3][2] + A.m[3][0] * B.m[3][3];

	movss	xmm0, DWORD PTR [eax+712]
	addss	xmm0, DWORD PTR [eax+724]
	mulss	xmm0, xmm2
	movss	DWORD PTR [ebx+84], xmm0

; 101  : 		m[3][1] = A.m[0][1] * B.m[3][0] + A.m[1][1] * B.m[3][1] + A.m[2][1] * B.m[3][2] + A.m[3][1] * B.m[3][3];

	movss	xmm0, DWORD PTR [eax+716]
	movss	xmm1, DWORD PTR [eax+724]
	mulss	xmm0, xmm2
	mulss	xmm1, xmm2
	subss	xmm1, xmm0
	movss	DWORD PTR [ebx+88], xmm1

; 102  : 		m[3][2] = A.m[0][2] * B.m[3][0] + A.m[1][2] * B.m[3][1] + A.m[2][2] * B.m[3][2] + A.m[3][2] * B.m[3][3];

	fld	DWORD PTR [eax+720]
	fstp	DWORD PTR [ebx+92]

; 103  : 		m[3][3] = A.m[0][3] * B.m[3][0] + A.m[1][3] * B.m[3][1] + A.m[2][3] * B.m[3][2] + A.m[3][3] * B.m[3][3];

	fld	DWORD PTR [eax+724]
	fstp	DWORD PTR [ebx+96]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp

; 177  : 	m_xform_01.mul				(m_viewport_01,	Device.mFullTransform);

	mov	eax, DWORD PTR __imp_?Device@@3VCRenderDevice@@A
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 85   : 		m[0][0] = A.m[0][0] * B.m[0][0] + A.m[1][0] * B.m[0][1] + A.m[2][0] * B.m[0][2] + A.m[3][0] * B.m[0][3];

	movss	xmm0, DWORD PTR [eax+664]
	addss	xmm0, DWORD PTR [eax+676]
	movss	xmm2, DWORD PTR __real@3f000000
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp

; 181  : 	clip.CreateFromMatrix		(Device.mFullTransform,FRUSTUM_P_NEAR);

	lea	ecx, DWORD PTR _clip$[esp+1488]
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 85   : 		m[0][0] = A.m[0][0] * B.m[0][0] + A.m[1][0] * B.m[0][1] + A.m[2][0] * B.m[0][2] + A.m[3][0] * B.m[0][3];

	mulss	xmm0, xmm2
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp

; 181  : 	clip.CreateFromMatrix		(Device.mFullTransform,FRUSTUM_P_NEAR);

	push	16					; 00000010H
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 85   : 		m[0][0] = A.m[0][0] * B.m[0][0] + A.m[1][0] * B.m[0][1] + A.m[2][0] * B.m[0][2] + A.m[3][0] * B.m[0][3];

	movss	DWORD PTR [ebx+100], xmm0

; 86   : 		m[0][1] = A.m[0][1] * B.m[0][0] + A.m[1][1] * B.m[0][1] + A.m[2][1] * B.m[0][2] + A.m[3][1] * B.m[0][3];

	movss	xmm1, DWORD PTR [eax+676]
	movss	xmm0, DWORD PTR [eax+668]
	mulss	xmm0, xmm2
	mulss	xmm1, xmm2
	subss	xmm1, xmm0
	movss	DWORD PTR [ebx+104], xmm1

; 87   : 		m[0][2] = A.m[0][2] * B.m[0][0] + A.m[1][2] * B.m[0][1] + A.m[2][2] * B.m[0][2] + A.m[3][2] * B.m[0][3];

	fld	DWORD PTR [eax+672]
	fstp	DWORD PTR [ebx+108]

; 88   : 		m[0][3] = A.m[0][3] * B.m[0][0] + A.m[1][3] * B.m[0][1] + A.m[2][3] * B.m[0][2] + A.m[3][3] * B.m[0][3];

	fld	DWORD PTR [eax+676]
	fstp	DWORD PTR [ebx+112]

; 89   : 
; 90   : 		m[1][0] = A.m[0][0] * B.m[1][0] + A.m[1][0] * B.m[1][1] + A.m[2][0] * B.m[1][2] + A.m[3][0] * B.m[1][3];

	movss	xmm0, DWORD PTR [eax+680]
	addss	xmm0, DWORD PTR [eax+692]
	mulss	xmm0, xmm2
	movss	DWORD PTR [ebx+116], xmm0

; 91   : 		m[1][1] = A.m[0][1] * B.m[1][0] + A.m[1][1] * B.m[1][1] + A.m[2][1] * B.m[1][2] + A.m[3][1] * B.m[1][3];

	movss	xmm1, DWORD PTR [eax+692]
	movss	xmm0, DWORD PTR [eax+684]
	mulss	xmm0, xmm2
	mulss	xmm1, xmm2
	subss	xmm1, xmm0
	movss	DWORD PTR [ebx+120], xmm1

; 92   : 		m[1][2] = A.m[0][2] * B.m[1][0] + A.m[1][2] * B.m[1][1] + A.m[2][2] * B.m[1][2] + A.m[3][2] * B.m[1][3];

	fld	DWORD PTR [eax+688]
	fstp	DWORD PTR [ebx+124]

; 93   : 		m[1][3] = A.m[0][3] * B.m[1][0] + A.m[1][3] * B.m[1][1] + A.m[2][3] * B.m[1][2] + A.m[3][3] * B.m[1][3];

	fld	DWORD PTR [eax+692]
	fstp	DWORD PTR [ebx+128]

; 94   : 
; 95   : 		m[2][0] = A.m[0][0] * B.m[2][0] + A.m[1][0] * B.m[2][1] + A.m[2][0] * B.m[2][2] + A.m[3][0] * B.m[2][3];

	movss	xmm0, DWORD PTR [eax+696]
	addss	xmm0, DWORD PTR [eax+708]
	mulss	xmm0, xmm2
	movss	DWORD PTR [ebx+132], xmm0

; 96   : 		m[2][1] = A.m[0][1] * B.m[2][0] + A.m[1][1] * B.m[2][1] + A.m[2][1] * B.m[2][2] + A.m[3][1] * B.m[2][3];

	movss	xmm1, DWORD PTR [eax+708]
	movss	xmm0, DWORD PTR [eax+700]
	mulss	xmm0, xmm2
	mulss	xmm1, xmm2
	subss	xmm1, xmm0
	movss	DWORD PTR [ebx+136], xmm1

; 97   : 		m[2][2] = A.m[0][2] * B.m[2][0] + A.m[1][2] * B.m[2][1] + A.m[2][2] * B.m[2][2] + A.m[3][2] * B.m[2][3];

	fld	DWORD PTR [eax+704]
	fstp	DWORD PTR [ebx+140]

; 98   : 		m[2][3] = A.m[0][3] * B.m[2][0] + A.m[1][3] * B.m[2][1] + A.m[2][3] * B.m[2][2] + A.m[3][3] * B.m[2][3];

	fld	DWORD PTR [eax+708]
	fstp	DWORD PTR [ebx+144]

; 99   : 
; 100  : 		m[3][0] = A.m[0][0] * B.m[3][0] + A.m[1][0] * B.m[3][1] + A.m[2][0] * B.m[3][2] + A.m[3][0] * B.m[3][3];

	movss	xmm0, DWORD PTR [eax+712]
	addss	xmm0, DWORD PTR [eax+724]
	mulss	xmm0, xmm2
	movss	DWORD PTR [ebx+148], xmm0

; 101  : 		m[3][1] = A.m[0][1] * B.m[3][0] + A.m[1][1] * B.m[3][1] + A.m[2][1] * B.m[3][2] + A.m[3][1] * B.m[3][3];

	movss	xmm1, DWORD PTR [eax+724]
	movss	xmm0, DWORD PTR [eax+716]
	mulss	xmm1, xmm2
	mulss	xmm0, xmm2
	subss	xmm1, xmm0
	movss	DWORD PTR [ebx+152], xmm1

; 102  : 		m[3][2] = A.m[0][2] * B.m[3][0] + A.m[1][2] * B.m[3][1] + A.m[2][2] * B.m[3][2] + A.m[3][2] * B.m[3][3];

	fld	DWORD PTR [eax+720]
	fstp	DWORD PTR [ebx+156]

; 103  : 		m[3][3] = A.m[0][3] * B.m[3][0] + A.m[1][3] * B.m[3][1] + A.m[2][3] * B.m[3][2] + A.m[3][3] * B.m[3][3];

	fld	DWORD PTR [eax+724]
	fstp	DWORD PTR [ebx+160]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp

; 181  : 	clip.CreateFromMatrix		(Device.mFullTransform,FRUSTUM_P_NEAR);

	mov	eax, DWORD PTR __imp_?Device@@3VCRenderDevice@@A
	add	eax, 664				; 00000298H
	push	eax
	call	DWORD PTR __imp_?CreateFromMatrix@CFrustum@@QAEXAAU?$_matrix@M@@I@Z

; 183  : 	u32		_frame				= Device.dwFrame	;

	mov	eax, DWORD PTR __imp_?Device@@3VCRenderDevice@@A
; File I:\Vitalya\mine\NSProjectX\xrCore\FixedVector.h

; 21   : 	svector() : count(0) 

	mov	DWORD PTR _src$[esp+2064], 0
	mov	DWORD PTR _dst$[esp+2064], 0
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp

; 183  : 	u32		_frame				= Device.dwFrame	;

	mov	eax, DWORD PTR [eax+244]
	mov	DWORD PTR __frame$1$[esp+1488], eax

; 184  : #ifdef DEBUG
; 185  : 	tris_in_frame				= xrc.r_count();
; 186  : 	tris_in_frame_visible		= 0;
; 187  : #endif
; 188  : 
; 189  : 	// Perfrom selection, sorting, culling
; 190  : 	for (; it!=end; it++)

	cmp	esi, ebp
	je	$LN3@Render_DB

; 161  : 	std::sort		(it,end,pred_fb(m_pTris,COP));

	add	esi, 40					; 00000028H
	xorps	xmm2, xmm2
	mov	DWORD PTR tv4228[esp+1488], esi
	npad	1
$LL4@Render_DB:

; 193  : 		occTri& T			= m_pTris	[it->id];

	imul	edi, DWORD PTR [esi], 88
; File I:\Vitalya\mine\NSProjectX\xrCore\_random.h

; 33   : 	IC 	s32		randI	(s32 max)					{ VERIFY(max);  return randI()%max; }

	mov	ecx, DWORD PTR __imp_?Random@@3VCRandom@@A
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp

; 193  : 		occTri& T			= m_pTris	[it->id];

	add	edi, DWORD PTR [ebx+28]
; File I:\Vitalya\mine\NSProjectX\xrCore\_random.h

; 33   : 	IC 	s32		randI	(s32 max)					{ VERIFY(max);  return randI()%max; }

	call	?randI@CRandom@@QAEHXZ			; CRandom::randI
	cdq
	mov	ecx, 7
	idiv	ecx
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp

; 194  : 		u32	next			= _frame + ::Random.randI(3,10);

	mov	eax, DWORD PTR __frame$1$[esp+1488]
	add	eax, 3
	add	eax, edx

; 197  : 		if (!(T.flags || (T.plane.classify(COP)>0)))	

	cmp	DWORD PTR [edi+68], 0
	mov	DWORD PTR _next$1$[esp+1488], eax
	jne	SHORT $LN9@Render_DB
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	movss	xmm0, DWORD PTR _COP$[esp+1488]
	mulss	xmm0, DWORD PTR [edi+48]
	movss	xmm1, DWORD PTR _COP$[esp+1492]
	mulss	xmm1, DWORD PTR [edi+52]
; File I:\Vitalya\mine\NSProjectX\xrCore\_plane.h

; 57   : 		return n.dotproduct(v)+d;

	addss	xmm1, xmm0
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	movss	xmm0, DWORD PTR _COP$[esp+1496]
	mulss	xmm0, DWORD PTR [edi+56]
; File I:\Vitalya\mine\NSProjectX\xrCore\_plane.h

; 57   : 		return n.dotproduct(v)+d;

	addss	xmm0, DWORD PTR [edi+60]
	addss	xmm1, xmm0
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp

; 197  : 		if (!(T.flags || (T.plane.classify(COP)>0)))	

	comiss	xmm1, xmm2
	jbe	$LN162@Render_DB
$LN9@Render_DB:

; 201  : 		CDB::TRI& t		= m_pModel->get_tris()	[it->id];

	mov	edx, DWORD PTR [esi]
; File I:\Vitalya\mine\NSProjectX\xrCDB\xrCDB.h

; 86   : 		IC TRI*					get_tris		()			{ return tris;		}

	mov	eax, DWORD PTR [ebx+24]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp

; 201  : 		CDB::TRI& t		= m_pModel->get_tris()	[it->id];

	shl	edx, 4
	add	edx, DWORD PTR [eax+12]
; File I:\Vitalya\mine\NSProjectX\xrCDB\xrCDB.h

; 84   : 		IC Fvector*				get_verts		()			{ return verts;		}

	mov	esi, DWORD PTR [eax+20]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp

; 203  : 		src.clear		();	dst.clear	();

	mov	DWORD PTR _dst$[esp+2064], 0

; 204  : 		src.push_back	(v[t.verts[0]]);

	mov	eax, DWORD PTR [edx]
	lea	ecx, DWORD PTR [eax+eax*2]
; File I:\Vitalya\mine\NSProjectX\xrCore\FixedVector.h

; 35   : 	IC void		push_back(value_type e)		{ VERIFY(count<dim); array[count++]=e;	}

	mov	eax, DWORD PTR [esi+ecx*4]
	mov	DWORD PTR _src$[esp+1488], eax
	mov	eax, DWORD PTR [esi+ecx*4+4]
	mov	DWORD PTR _src$[esp+1492], eax
	mov	eax, DWORD PTR [esi+ecx*4+8]
	mov	DWORD PTR _src$[esp+1496], eax
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp

; 205  : 		src.push_back	(v[t.verts[1]]);

	mov	eax, DWORD PTR [edx+4]
	lea	ecx, DWORD PTR [eax+eax*2]
; File I:\Vitalya\mine\NSProjectX\xrCore\FixedVector.h

; 35   : 	IC void		push_back(value_type e)		{ VERIFY(count<dim); array[count++]=e;	}

	mov	eax, DWORD PTR [esi+ecx*4]
	mov	DWORD PTR _src$[esp+1500], eax
	mov	eax, DWORD PTR [esi+ecx*4+4]
	mov	DWORD PTR _src$[esp+1504], eax
	mov	eax, DWORD PTR [esi+ecx*4+8]
	mov	DWORD PTR _src$[esp+1508], eax
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp

; 206  : 		src.push_back	(v[t.verts[2]]);

	mov	eax, DWORD PTR [edx+8]
	lea	ecx, DWORD PTR [eax+eax*2]
; File I:\Vitalya\mine\NSProjectX\xrCore\FixedVector.h

; 35   : 	IC void		push_back(value_type e)		{ VERIFY(count<dim); array[count++]=e;	}

	mov	eax, DWORD PTR [esi+ecx*4]
	mov	DWORD PTR _src$[esp+1512], eax
	mov	eax, DWORD PTR [esi+ecx*4+4]
	mov	DWORD PTR _src$[esp+1516], eax
	mov	eax, DWORD PTR [esi+ecx*4+8]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp

; 207  : 		sPoly* P =		clip.ClipPoly	(src,dst);

	lea	ecx, DWORD PTR _clip$[esp+1488]
; File I:\Vitalya\mine\NSProjectX\xrCore\FixedVector.h

; 35   : 	IC void		push_back(value_type e)		{ VERIFY(count<dim); array[count++]=e;	}

	mov	DWORD PTR _src$[esp+1520], eax
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp

; 207  : 		sPoly* P =		clip.ClipPoly	(src,dst);

	lea	eax, DWORD PTR _dst$[esp+1488]
	push	eax
	lea	eax, DWORD PTR _src$[esp+1492]
; File I:\Vitalya\mine\NSProjectX\xrCore\FixedVector.h

; 35   : 	IC void		push_back(value_type e)		{ VERIFY(count<dim); array[count++]=e;	}

	mov	DWORD PTR _src$[esp+2068], 3
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp

; 207  : 		sPoly* P =		clip.ClipPoly	(src,dst);

	push	eax
	call	DWORD PTR __imp_?ClipPoly@CFrustum@@QBEPAV?$svector@U?$_vector3@M@@$0DA@@@AAV2@0@Z
	mov	esi, eax

; 208  : 		if (0==P)		{ T.skip=next; continue; }

	test	esi, esi
	je	$LN166@Render_DB

; 209  : 
; 210  : 		// XForm and Rasterize
; 211  : #ifdef DEBUG
; 212  : 		tris_in_frame_visible	++;
; 213  : #endif
; 214  : 		u32		pixels			= 0;
; 215  : 		int		limit			= int(P->size())-1;

	mov	ecx, DWORD PTR [esi+576]
	dec	ecx
	mov	DWORD PTR _pixels$1$[esp+1488], 0

; 216  : 		for (int v=1; v<limit; v++)	{

	cmp	ecx, 1
	jle	$LN166@Render_DB

; 217  : 			m_xform.transform	(T.raster[0],(*P)[0]);

	dec	ecx
	lea	ebp, DWORD PTR [esi+32]
	mov	DWORD PTR tv4288[esp+1488], ecx
$LL7@Render_DB:
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 529  : 		T iw	= 1.f/(v.x*_14 + v.y*_24 + v.z*_34 + _44);

	movss	xmm4, DWORD PTR [esi+4]
	movss	xmm2, DWORD PTR [esi]
	movaps	xmm0, xmm4
	mulss	xmm0, DWORD PTR [ebx+64]
	movaps	xmm1, xmm2
	mulss	xmm1, DWORD PTR [ebx+48]
	movss	xmm3, DWORD PTR [esi+8]
	movss	xmm6, DWORD PTR __real@3f800000
	addss	xmm1, xmm0

; 530  : 		dest.x	= (v.x*_11 + v.y*_21 + v.z*_31 + _41)*iw;

	mulss	xmm4, DWORD PTR [ebx+52]
	movaps	xmm0, xmm3
	mulss	xmm2, DWORD PTR [ebx+36]
	mulss	xmm0, DWORD PTR [ebx+80]
	movaps	xmm5, xmm6
	mulss	xmm3, DWORD PTR [ebx+68]
	addss	xmm4, xmm2
	addss	xmm0, DWORD PTR [ebx+96]
	addss	xmm3, DWORD PTR [ebx+84]
	addss	xmm1, xmm0
	addss	xmm4, xmm3
	divss	xmm5, xmm1
	mulss	xmm4, xmm5
	movss	DWORD PTR [edi+12], xmm4

; 531  : 		dest.y	= (v.x*_12 + v.y*_22 + v.z*_32 + _42)*iw;

	movss	xmm1, DWORD PTR [ebx+40]
	mulss	xmm1, DWORD PTR [esi]
	movss	xmm0, DWORD PTR [ebx+56]
	mulss	xmm0, DWORD PTR [esi+4]
	addss	xmm1, xmm0
	movss	xmm0, DWORD PTR [ebx+72]
	mulss	xmm0, DWORD PTR [esi+8]
	addss	xmm0, DWORD PTR [ebx+88]
	addss	xmm1, xmm0
	mulss	xmm1, xmm5
	movss	DWORD PTR [edi+16], xmm1

; 532  : 		dest.z	= (v.x*_13 + v.y*_23 + v.z*_33 + _43)*iw;

	movss	xmm1, DWORD PTR [ebx+44]
	mulss	xmm1, DWORD PTR [esi]
	movss	xmm0, DWORD PTR [ebx+60]
	mulss	xmm0, DWORD PTR [esi+4]
	addss	xmm1, xmm0
	movss	xmm0, DWORD PTR [ebx+76]
	mulss	xmm0, DWORD PTR [esi+8]
	addss	xmm0, DWORD PTR [ebx+92]
	addss	xmm1, xmm0
	mulss	xmm1, xmm5

; 529  : 		T iw	= 1.f/(v.x*_14 + v.y*_24 + v.z*_34 + _44);

	movaps	xmm5, xmm6

; 532  : 		dest.z	= (v.x*_13 + v.y*_23 + v.z*_33 + _43)*iw;

	movss	DWORD PTR [edi+20], xmm1

; 529  : 		T iw	= 1.f/(v.x*_14 + v.y*_24 + v.z*_34 + _44);

	movss	xmm4, DWORD PTR [ebp-16]
	movss	xmm2, DWORD PTR [ebp-20]
	movaps	xmm0, xmm4
	mulss	xmm0, DWORD PTR [ebx+64]
	movaps	xmm1, xmm2
	mulss	xmm1, DWORD PTR [ebx+48]
	movss	xmm3, DWORD PTR [ebp-12]

; 530  : 		dest.x	= (v.x*_11 + v.y*_21 + v.z*_31 + _41)*iw;

	mulss	xmm4, DWORD PTR [ebx+52]
	addss	xmm1, xmm0
	mulss	xmm2, DWORD PTR [ebx+36]
	movaps	xmm0, xmm3
	mulss	xmm3, DWORD PTR [ebx+68]
	mulss	xmm0, DWORD PTR [ebx+80]
	addss	xmm4, xmm2
	addss	xmm3, DWORD PTR [ebx+84]
	addss	xmm0, DWORD PTR [ebx+96]
	addss	xmm4, xmm3
	addss	xmm1, xmm0
	divss	xmm5, xmm1
	mulss	xmm4, xmm5
	movss	DWORD PTR [edi+24], xmm4

; 531  : 		dest.y	= (v.x*_12 + v.y*_22 + v.z*_32 + _42)*iw;

	movss	xmm1, DWORD PTR [ebx+40]
	mulss	xmm1, DWORD PTR [ebp-20]
	movss	xmm0, DWORD PTR [ebx+56]
	mulss	xmm0, DWORD PTR [ebp-16]
	addss	xmm1, xmm0
	movss	xmm0, DWORD PTR [ebx+72]
	mulss	xmm0, DWORD PTR [ebp-12]
	addss	xmm0, DWORD PTR [ebx+88]
	addss	xmm1, xmm0
	mulss	xmm1, xmm5
	movss	DWORD PTR [edi+28], xmm1

; 532  : 		dest.z	= (v.x*_13 + v.y*_23 + v.z*_33 + _43)*iw;

	movss	xmm1, DWORD PTR [ebx+44]
	mulss	xmm1, DWORD PTR [ebp-20]
	movss	xmm0, DWORD PTR [ebx+60]
	mulss	xmm0, DWORD PTR [ebp-16]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp

; 220  : 			pixels	+=			Raster.rasterize(&T);

	push	edi
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 532  : 		dest.z	= (v.x*_13 + v.y*_23 + v.z*_33 + _43)*iw;

	addss	xmm1, xmm0
	movss	xmm0, DWORD PTR [ebx+76]
	mulss	xmm0, DWORD PTR [ebp-12]
	addss	xmm0, DWORD PTR [ebx+92]
	addss	xmm1, xmm0
	mulss	xmm1, xmm5

; 529  : 		T iw	= 1.f/(v.x*_14 + v.y*_24 + v.z*_34 + _44);

	movaps	xmm5, xmm6

; 532  : 		dest.z	= (v.x*_13 + v.y*_23 + v.z*_33 + _43)*iw;

	movss	DWORD PTR [edi+32], xmm1

; 529  : 		T iw	= 1.f/(v.x*_14 + v.y*_24 + v.z*_34 + _44);

	movss	xmm4, DWORD PTR [ebp-4]
	movss	xmm2, DWORD PTR [ebp-8]
	movaps	xmm0, xmm4
	mulss	xmm0, DWORD PTR [ebx+64]
	movaps	xmm1, xmm2
	mulss	xmm1, DWORD PTR [ebx+48]
	movss	xmm3, DWORD PTR [ebp]

; 530  : 		dest.x	= (v.x*_11 + v.y*_21 + v.z*_31 + _41)*iw;

	mulss	xmm4, DWORD PTR [ebx+52]
	addss	xmm1, xmm0
	mulss	xmm2, DWORD PTR [ebx+36]
	movaps	xmm0, xmm3
	mulss	xmm3, DWORD PTR [ebx+68]
	mulss	xmm0, DWORD PTR [ebx+80]
	addss	xmm4, xmm2
	addss	xmm3, DWORD PTR [ebx+84]
	addss	xmm0, DWORD PTR [ebx+96]
	addss	xmm4, xmm3
	addss	xmm1, xmm0
	divss	xmm5, xmm1
	mulss	xmm4, xmm5
	movss	DWORD PTR [edi+36], xmm4

; 531  : 		dest.y	= (v.x*_12 + v.y*_22 + v.z*_32 + _42)*iw;

	movss	xmm1, DWORD PTR [ebp-4]
	mulss	xmm1, DWORD PTR [ebx+56]
	movss	xmm0, DWORD PTR [ebp-8]
	mulss	xmm0, DWORD PTR [ebx+40]
	addss	xmm1, xmm0
	movss	xmm0, DWORD PTR [ebp]
	mulss	xmm0, DWORD PTR [ebx+72]
	addss	xmm0, DWORD PTR [ebx+88]
	addss	xmm1, xmm0
	mulss	xmm1, xmm5
	movss	DWORD PTR [edi+40], xmm1

; 532  : 		dest.z	= (v.x*_13 + v.y*_23 + v.z*_33 + _43)*iw;

	movss	xmm0, DWORD PTR [ebp-4]
	mulss	xmm0, DWORD PTR [ebx+60]
	movss	xmm1, DWORD PTR [ebx+44]
	mulss	xmm1, DWORD PTR [ebp-8]
	addss	xmm1, xmm0
	movss	xmm0, DWORD PTR [ebp]
	mulss	xmm0, DWORD PTR [ebx+76]
	addss	xmm0, DWORD PTR [ebx+92]
	addss	xmm1, xmm0
	mulss	xmm1, xmm5
	movss	DWORD PTR [edi+44], xmm1
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp

; 220  : 			pixels	+=			Raster.rasterize(&T);

	call	?rasterize@occRasterizer@@QAEIPAVoccTri@@@Z ; occRasterizer::rasterize
	mov	ecx, DWORD PTR _pixels$1$[esp+1488]
	add	ebp, 12					; 0000000cH
	add	ecx, eax
	sub	DWORD PTR tv4288[esp+1488], 1
	mov	DWORD PTR _pixels$1$[esp+1488], ecx
	jne	$LL7@Render_DB

; 221  : 		}
; 222  : 		if (0==pixels)	{ T.skip=next; continue; }

	mov	ebp, DWORD PTR __UNext$1$[esp+1488]
	mov	esi, DWORD PTR tv4228[esp+1488]
	test	ecx, ecx
	jne	SHORT $LN2@Render_DB

; 208  : 		if (0==P)		{ T.skip=next; continue; }

	jmp	SHORT $LN168@Render_DB
$LN166@Render_DB:

; 221  : 		}
; 222  : 		if (0==pixels)	{ T.skip=next; continue; }

	mov	esi, DWORD PTR tv4228[esp+1488]
$LN168@Render_DB:
	mov	eax, DWORD PTR _next$1$[esp+1488]
$LN162@Render_DB:
	mov	DWORD PTR [edi+72], eax
$LN2@Render_DB:

; 184  : #ifdef DEBUG
; 185  : 	tris_in_frame				= xrc.r_count();
; 186  : 	tris_in_frame_visible		= 0;
; 187  : #endif
; 188  : 
; 189  : 	// Perfrom selection, sorting, culling
; 190  : 	for (; it!=end; it++)

	add	esi, 56					; 00000038H
	xorps	xmm2, xmm2
	mov	DWORD PTR tv4228[esp+1488], esi
	lea	eax, DWORD PTR [esi-40]
	cmp	eax, ebp
	jne	$LL4@Render_DB
$LN3@Render_DB:

; 223  : 	}
; 224  : }

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 1472				; 000005c0H
	ret	4
?Render_DB@CHOM@@AAEXAAVCFrustum@@@Z ENDP		; CHOM::Render_DB
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\FTimer.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\FTimer.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\occRasterizer.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\FTimer.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp
_TEXT	SEGMENT
_f$1 = -4						; size = 4
_base$ = 8						; size = 4
?Render@CHOM@@QAEXAAVCFrustum@@@Z PROC			; CHOM::Render
; _this$ = ecx

; 227  : {

	sub	esp, 8
	push	esi
	push	edi
	mov	edi, ecx

; 228  : 	if (!bEnabled)		return;

	cmp	DWORD PTR [edi+32], 0
	je	$LN134@Render

; 230  : 	Device.Statistic->RenderCALC_HOM.Begin	();

	mov	eax, DWORD PTR __imp_?Device@@3VCRenderDevice@@A
	mov	esi, DWORD PTR [eax+436]
; File I:\Vitalya\mine\NSProjectX\xrCore\FTimer.h

; 173  : 	ICF void	Begin			()		{	if (!g_bEnableStatGather) return;	count++; T.Start();				}

	mov	eax, DWORD PTR __imp_?g_bEnableStatGather@@3HA
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp

; 230  : 	Device.Statistic->RenderCALC_HOM.Begin	();

	add	esi, 1352				; 00000548H
; File I:\Vitalya\mine\NSProjectX\xrCore\FTimer.h

; 173  : 	ICF void	Begin			()		{	if (!g_bEnableStatGather) return;	count++; T.Start();				}

	cmp	DWORD PTR [eax], 0
	je	SHORT $LN7@Render
	inc	DWORD PTR [esi+68]

; 73   : 		if (bPause)

	cmp	DWORD PTR [esi+24], 0
	jne	SHORT $LN7@Render

; 29   : 	ICF	void	Start			()		{	if(bPause) return;	qwStartTime = CPU::QPC()-qwPauseAccum;		}

	call	DWORD PTR __imp_?QPC@CPU@@YA_KXZ
	sub	eax, DWORD PTR [esi+16]
	mov	DWORD PTR [esi], eax
	sbb	edx, DWORD PTR [esi+20]
	mov	DWORD PTR [esi+4], edx

; 78   : 		m_real_ticks	= 0;

	mov	DWORD PTR [esi+40], 0
	mov	DWORD PTR [esi+44], 0

; 79   : 		m_ticks			= 0;

	mov	DWORD PTR [esi+48], 0
	mov	DWORD PTR [esi+52], 0
$LN7@Render:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\occRasterizer.cpp

; 63   : 	Memory.mem_fill32	(bufFrame,0,size);

	mov	eax, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	4624					; 00001210H
	push	0
	push	OFFSET ?Raster@@3VoccRasterizer@@A	; Raster
	mov	eax, DWORD PTR [eax+16]
	mov	DWORD PTR _f$1[esp+28], 1065353216	; 3f800000H
	call	eax

; 64   : 	Memory.mem_fill32	(bufDepth,*LPDWORD(&f),size);

	mov	eax, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	4624					; 00001210H
	push	DWORD PTR _f$1[esp+20]
	mov	eax, DWORD PTR [eax+16]
	push	OFFSET ?Raster@@3VoccRasterizer@@A+18496
	call	eax
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp

; 232  : 	Render_DB			(base);

	push	DWORD PTR _base$[esp+12]
	mov	ecx, edi
	call	?Render_DB@CHOM@@AAEXAAVCFrustum@@@Z	; CHOM::Render_DB

; 233  : 	Raster.propagade	();

	call	?propagade@occRasterizer@@QAEXXZ	; occRasterizer::propagade

; 234  : 	MT_frame_rendered	= Device.dwFrame;

	mov	eax, DWORD PTR __imp_?Device@@3VCRenderDevice@@A
	mov	eax, DWORD PTR [eax+244]
	mov	DWORD PTR [edi+168], eax

; 235  : 	Device.Statistic->RenderCALC_HOM.End	();

	mov	eax, DWORD PTR __imp_?Device@@3VCRenderDevice@@A
	mov	esi, DWORD PTR [eax+436]
; File I:\Vitalya\mine\NSProjectX\xrCore\FTimer.h

; 174  : 	ICF void	End				()		{	if (!g_bEnableStatGather) return;	accum += T.GetElapsed_ticks();	}

	mov	eax, DWORD PTR __imp_?g_bEnableStatGather@@3HA
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN134@Render
	lea	ecx, DWORD PTR [esi+1352]
	call	DWORD PTR __imp_?GetElapsed_ticks@CTimer@@QBE_KXZ
	add	DWORD PTR [esi+1408], eax
	adc	DWORD PTR [esi+1412], edx
$LN134@Render:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp

; 236  : }

	pop	edi
	pop	esi
	add	esp, 8
	ret	4
?Render@CHOM@@QAEXAAVCFrustum@@@Z ENDP			; CHOM::Render
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp
;	COMDAT ?xform_b0@@YAHAAU?$_vector2@M@@0AAMAAU?$_matrix@M@@MMM@Z
_TEXT	SEGMENT
_minz$ = 8						; size = 4
_X$ = 12						; size = 4
__x$ = 16						; size = 4
__y$ = 20						; size = 4
__z$ = 24						; size = 4
?xform_b0@@YAHAAU?$_vector2@M@@0AAMAAU?$_matrix@M@@MMM@Z PROC ; xform_b0, COMDAT
; _min$ = ecx
; _max$ = edx

; 240  : 	float z		= _x*X._13 + _y*X._23 + _z*X._33 + X._43;			if (z<EPS) return TRUE;

	mov	eax, DWORD PTR _X$[esp-4]
	movss	xmm4, DWORD PTR __x$[esp-4]
	movss	xmm6, DWORD PTR __y$[esp-4]
	movaps	xmm3, xmm4
	movss	xmm5, DWORD PTR __z$[esp-4]
	movaps	xmm0, xmm6
	mulss	xmm0, DWORD PTR [eax+24]
	mulss	xmm3, DWORD PTR [eax+8]
	addss	xmm3, xmm0
	movaps	xmm0, xmm5
	mulss	xmm0, DWORD PTR [eax+40]
	addss	xmm0, DWORD PTR [eax+56]
	addss	xmm3, xmm0
	movss	xmm0, DWORD PTR __real@3727c5ac
	comiss	xmm0, xmm3
	jbe	SHORT $LN2@xform_b0
	mov	eax, 1

; 246  : }

	ret	0
$LN2@xform_b0:

; 241  : 	float iw	= 1.f/(_x*X._14 + _y*X._24 + _z*X._34 + X._44);		

	movss	xmm2, DWORD PTR __real@3f800000
	movaps	xmm1, xmm4
	mulss	xmm1, DWORD PTR [eax+12]
	movaps	xmm0, xmm6
	mulss	xmm0, DWORD PTR [eax+28]
	addss	xmm1, xmm0
	movaps	xmm0, xmm5
	mulss	xmm0, DWORD PTR [eax+44]
	addss	xmm0, DWORD PTR [eax+60]
	addss	xmm1, xmm0

; 242  : 	min.x=max.x	= (_x*X._11 + _y*X._21 + _z*X._31 + X._41)*iw;

	movaps	xmm0, xmm4
	mulss	xmm0, DWORD PTR [eax]

; 243  : 	min.y=max.y	= (_x*X._12 + _y*X._22 + _z*X._32 + X._42)*iw;	

	mulss	xmm4, DWORD PTR [eax+4]
	divss	xmm2, xmm1
	movaps	xmm1, xmm6
	mulss	xmm6, DWORD PTR [eax+20]
	mulss	xmm1, DWORD PTR [eax+16]
	addss	xmm4, xmm6
	addss	xmm1, xmm0
	movaps	xmm0, xmm5
	mulss	xmm0, DWORD PTR [eax+32]
	mulss	xmm5, DWORD PTR [eax+36]
	addss	xmm0, DWORD PTR [eax+48]
	addss	xmm5, DWORD PTR [eax+52]

; 244  : 	minz		= 0.f+z*iw;

	mov	eax, DWORD PTR _minz$[esp-4]
	addss	xmm1, xmm0
	addss	xmm4, xmm5
	mulss	xmm1, xmm2
	mulss	xmm4, xmm2
	mulss	xmm2, xmm3
	movss	DWORD PTR [edx], xmm1
	movss	DWORD PTR [ecx], xmm1
	movss	DWORD PTR [eax], xmm2

; 245  : 	return FALSE;

	xor	eax, eax
	movss	DWORD PTR [edx+4], xmm4
	movss	DWORD PTR [ecx+4], xmm4

; 246  : }

	ret	0
?xform_b0@@YAHAAU?$_vector2@M@@0AAMAAU?$_matrix@M@@MMM@Z ENDP ; xform_b0
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp
;	COMDAT ?xform_b1@@YAHAAU?$_vector2@M@@0AAMAAU?$_matrix@M@@MMM@Z
_TEXT	SEGMENT
_minz$ = 8						; size = 4
_X$ = 12						; size = 4
__x$ = 16						; size = 4
__y$ = 20						; size = 4
__z$ = 24						; size = 4
?xform_b1@@YAHAAU?$_vector2@M@@0AAMAAU?$_matrix@M@@MMM@Z PROC ; xform_b1, COMDAT
; _min$ = ecx
; _max$ = edx

; 249  : 	float t;
; 250  : 	float z		= _x*X._13 + _y*X._23 + _z*X._33 + X._43;		if (z<EPS)	return TRUE;

	mov	eax, DWORD PTR _X$[esp-4]
	movss	xmm2, DWORD PTR __x$[esp-4]
	movss	xmm6, DWORD PTR __y$[esp-4]
	movaps	xmm4, xmm2
	movss	xmm5, DWORD PTR __z$[esp-4]
	movaps	xmm0, xmm6
	mulss	xmm0, DWORD PTR [eax+24]
	mulss	xmm4, DWORD PTR [eax+8]
	addss	xmm4, xmm0
	movaps	xmm0, xmm5
	mulss	xmm0, DWORD PTR [eax+40]
	addss	xmm0, DWORD PTR [eax+56]
	addss	xmm4, xmm0
	movss	xmm0, DWORD PTR __real@3727c5ac
	comiss	xmm0, xmm4
	jbe	SHORT $LN2@xform_b1
	mov	eax, 1

; 256  : }

	ret	0
$LN2@xform_b1:

; 251  : 	float iw	= 1.f/(_x*X._14 + _y*X._24 + _z*X._34 + X._44);

	movss	xmm3, DWORD PTR __real@3f800000
	movaps	xmm1, xmm2
	mulss	xmm1, DWORD PTR [eax+12]
	movaps	xmm0, xmm6
	mulss	xmm0, DWORD PTR [eax+28]
	addss	xmm1, xmm0
	movaps	xmm0, xmm5
	mulss	xmm0, DWORD PTR [eax+44]
	addss	xmm0, DWORD PTR [eax+60]
	addss	xmm1, xmm0

; 252  : 	t 			= (_x*X._11 + _y*X._21 + _z*X._31 + X._41)*iw;	if (t<min.x) min.x=t; else if (t>max.x) max.x=t;

	movaps	xmm0, xmm2
	mulss	xmm0, DWORD PTR [eax]
	divss	xmm3, xmm1
	movaps	xmm1, xmm6
	mulss	xmm1, DWORD PTR [eax+16]
	addss	xmm1, xmm0
	movaps	xmm0, xmm5
	mulss	xmm0, DWORD PTR [eax+32]
	addss	xmm0, DWORD PTR [eax+48]
	addss	xmm1, xmm0
	movss	xmm0, DWORD PTR [ecx]
	mulss	xmm1, xmm3
	comiss	xmm0, xmm1
	jbe	SHORT $LN3@xform_b1
	movss	DWORD PTR [ecx], xmm1
	jmp	SHORT $LN5@xform_b1
$LN3@xform_b1:
	comiss	xmm1, DWORD PTR [edx]
	jbe	SHORT $LN5@xform_b1
	movss	DWORD PTR [edx], xmm1
$LN5@xform_b1:

; 253  : 	t			= (_x*X._12 + _y*X._22 + _z*X._32 + X._42)*iw;	if (t<min.y) min.y=t; else if (t>max.y) max.y=t;

	mulss	xmm2, DWORD PTR [eax+4]
	mulss	xmm6, DWORD PTR [eax+20]
	mulss	xmm5, DWORD PTR [eax+36]
	movss	xmm0, DWORD PTR [ecx+4]
	addss	xmm2, xmm6
	addss	xmm5, DWORD PTR [eax+52]
	addss	xmm2, xmm5
	mulss	xmm2, xmm3
	comiss	xmm0, xmm2
	jbe	SHORT $LN6@xform_b1
	movss	DWORD PTR [ecx+4], xmm2
	jmp	SHORT $LN8@xform_b1
$LN6@xform_b1:
	comiss	xmm2, DWORD PTR [edx+4]
	jbe	SHORT $LN8@xform_b1
	movss	DWORD PTR [edx+4], xmm2
$LN8@xform_b1:

; 254  : 	t			= 0.f+z*iw;										if (t<minz)	 minz =t;

	mov	eax, DWORD PTR _minz$[esp-4]
	mulss	xmm3, xmm4
	movss	xmm0, DWORD PTR [eax]
	comiss	xmm0, xmm3
	jbe	SHORT $LN9@xform_b1
	movss	DWORD PTR [eax], xmm3
$LN9@xform_b1:

; 255  : 	return FALSE;

	xor	eax, eax

; 256  : }

	ret	0
?xform_b1@@YAHAAU?$_vector2@M@@0AAMAAU?$_matrix@M@@MMM@Z ENDP ; xform_b1
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp
;	COMDAT ?_visible@@YAHAAV?$_box3@M@@AAU?$_matrix@M@@@Z
_TEXT	SEGMENT
_z$ = -104						; size = 4
_max$$sroa$820$ = -100					; size = 4
_max$$sroa$818$ = -96					; size = 4
_min$$sroa$821$ = -92					; size = 4
_min$$sroa$819$ = -88					; size = 4
_t$2$ = -84						; size = 4
_t$3$ = -84						; size = 4
tv921 = -84						; size = 4
_t$1$ = -80						; size = 4
tv1123 = -80						; size = 4
_t$2$ = -76						; size = 4
_t$3$ = -76						; size = 4
_z$1$ = -76						; size = 4
tv983 = -76						; size = 4
__z$1$ = -72						; size = 4
_t$3$ = -68						; size = 4
_z$1$ = -68						; size = 4
_z$1$ = -68						; size = 4
tv953 = -68						; size = 4
_z$1$ = -64						; size = 4
tv1128 = -64						; size = 4
tv1069 = -64						; size = 4
tv1112 = -60						; size = 4
tv1034 = -60						; size = 4
tv1096 = -56						; size = 4
tv1057 = -56						; size = 4
_t$3$ = -52						; size = 4
tv1100 = -52						; size = 4
tv1079 = -52						; size = 4
tv1044 = -52						; size = 4
tv1104 = -48						; size = 4
tv1077 = -48						; size = 4
tv1031 = -48						; size = 4
_t$3$ = -44						; size = 4
_z$1$ = -44						; size = 4
tv1108 = -44						; size = 4
tv1081 = -44						; size = 4
tv1030 = -40						; size = 4
_z$1$ = -36						; size = 4
tv1074 = -36						; size = 4
_t$1$ = -32						; size = 4
tv1126 = -32						; size = 4
tv1087 = -32						; size = 4
tv1041 = -32						; size = 4
_t$2$ = -28						; size = 4
tv1121 = -28						; size = 4
tv1053 = -28						; size = 4
_z$1$ = -24						; size = 4
tv1092 = -24						; size = 4
tv1066 = -24						; size = 4
_z$1$ = -20						; size = 4
__x$1$ = -20						; size = 4
_z$1$ = -16						; size = 4
tv1035 = -16						; size = 4
tv1049 = -12						; size = 4
tv1061 = -8						; size = 4
tv1071 = -4						; size = 4
?_visible@@YAHAAV?$_box3@M@@AAU?$_matrix@M@@@Z PROC	; _visible, COMDAT
; _B$ = ecx
; _m_xform_01$ = edx

; 258  : {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	sub	esp, 104				; 00000068H

; 240  : 	float z		= _x*X._13 + _y*X._23 + _z*X._33 + X._43;			if (z<EPS) return TRUE;

	movss	xmm1, DWORD PTR [edx+24]
	movss	xmm0, DWORD PTR [edx+8]

; 259  : 	// Find min/max points of xformed-box
; 260  : 	Fvector2	min,max;
; 261  : 	float		z;
; 262  : 	if (xform_b0(min,max,z,m_xform_01,B.min.x, B.min.y, B.min.z)) return TRUE;

	movss	xmm5, DWORD PTR [ecx]
	movss	xmm3, DWORD PTR [ecx+4]
	movss	xmm4, DWORD PTR [ecx+8]

; 240  : 	float z		= _x*X._13 + _y*X._23 + _z*X._33 + X._43;			if (z<EPS) return TRUE;

	movss	xmm2, DWORD PTR [edx+56]
	mulss	xmm1, xmm3
	mulss	xmm0, xmm5
	movss	DWORD PTR tv1030[esp+104], xmm1

; 259  : 	// Find min/max points of xformed-box
; 260  : 	Fvector2	min,max;
; 261  : 	float		z;
; 262  : 	if (xform_b0(min,max,z,m_xform_01,B.min.x, B.min.y, B.min.z)) return TRUE;

	movss	DWORD PTR __z$1$[esp+104], xmm4

; 240  : 	float z		= _x*X._13 + _y*X._23 + _z*X._33 + X._43;			if (z<EPS) return TRUE;

	addss	xmm0, xmm1
	movss	DWORD PTR tv1035[esp+104], xmm2
	movss	xmm1, DWORD PTR [edx+40]
	mulss	xmm1, xmm4
	movss	DWORD PTR tv1031[esp+104], xmm0
	movss	DWORD PTR tv1034[esp+104], xmm1
	addss	xmm1, xmm0
	movss	xmm0, DWORD PTR __real@3727c5ac
	addss	xmm1, xmm2
	comiss	xmm0, xmm1
	movss	DWORD PTR _z$1$[esp+104], xmm1
	ja	$LN91@visible

; 241  : 	float iw	= 1.f/(_x*X._14 + _y*X._24 + _z*X._34 + X._44);		

	movss	xmm0, DWORD PTR [edx+28]
	movss	xmm2, DWORD PTR [edx+12]
	mulss	xmm0, xmm3
	movss	xmm1, DWORD PTR [edx+60]
	mulss	xmm2, xmm5
	movss	DWORD PTR tv1041[esp+104], xmm0

; 242  : 	min.x=max.x	= (_x*X._11 + _y*X._21 + _z*X._31 + X._41)*iw;

	movss	xmm6, DWORD PTR [edx]
	addss	xmm2, xmm0
	movss	xmm7, DWORD PTR [edx+32]
	movss	xmm0, DWORD PTR [edx+44]
	mulss	xmm0, xmm4
	movss	DWORD PTR tv1049[esp+104], xmm1
	mulss	xmm6, xmm5
	movss	DWORD PTR tv921[esp+104], xmm0
	addss	xmm0, xmm2
	movss	DWORD PTR tv1044[esp+104], xmm2
	movss	xmm2, DWORD PTR [edx+48]
	movss	DWORD PTR tv1061[esp+104], xmm2
	addss	xmm0, xmm1
	movss	xmm1, DWORD PTR __real@3f800000
	divss	xmm1, xmm0
	movss	xmm0, DWORD PTR [edx+16]
	mulss	xmm0, xmm3
	addss	xmm6, xmm0
	movss	DWORD PTR tv1053[esp+104], xmm0
	movaps	xmm0, xmm7
	mulss	xmm0, xmm4
	movss	DWORD PTR tv1057[esp+104], xmm6
	movaps	xmm3, xmm0
	movss	DWORD PTR _t$1$[esp+104], xmm0

; 243  : 	min.y=max.y	= (_x*X._12 + _y*X._22 + _z*X._32 + X._42)*iw;	

	movss	xmm0, DWORD PTR [edx+4]
	addss	xmm3, xmm6
	mulss	xmm0, xmm5
	movss	xmm5, DWORD PTR [edx+36]
	addss	xmm3, xmm2
	movss	xmm2, DWORD PTR [edx+20]
	mulss	xmm2, DWORD PTR [ecx+4]
	addss	xmm0, xmm2
	movss	DWORD PTR tv1066[esp+104], xmm2
	movaps	xmm2, xmm5
	mulss	xmm3, xmm1
	mulss	xmm2, xmm4
	movss	DWORD PTR tv1069[esp+104], xmm0
	movaps	xmm6, xmm3
	movss	xmm0, DWORD PTR [edx+52]
	addss	xmm2, DWORD PTR tv1069[esp+104]
	movss	DWORD PTR tv1071[esp+104], xmm0
	movss	DWORD PTR _max$$sroa$818$[esp+104], xmm3
	movss	DWORD PTR _min$$sroa$819$[esp+104], xmm6
	addss	xmm2, xmm0

; 250  : 	float z		= _x*X._13 + _y*X._23 + _z*X._33 + X._43;		if (z<EPS)	return TRUE;

	movss	xmm0, DWORD PTR [edx+40]
	mulss	xmm0, DWORD PTR [ecx+20]

; 243  : 	min.y=max.y	= (_x*X._12 + _y*X._22 + _z*X._32 + X._42)*iw;	

	mulss	xmm2, xmm1

; 244  : 	minz		= 0.f+z*iw;

	mulss	xmm1, DWORD PTR _z$1$[esp+104]

; 250  : 	float z		= _x*X._13 + _y*X._23 + _z*X._33 + X._43;		if (z<EPS)	return TRUE;

	movss	DWORD PTR tv1074[esp+104], xmm0

; 243  : 	min.y=max.y	= (_x*X._12 + _y*X._22 + _z*X._32 + X._42)*iw;	

	movaps	xmm4, xmm2

; 250  : 	float z		= _x*X._13 + _y*X._23 + _z*X._33 + X._43;		if (z<EPS)	return TRUE;

	addss	xmm0, DWORD PTR tv1031[esp+104]

; 244  : 	minz		= 0.f+z*iw;

	movss	DWORD PTR _z$1$[esp+104], xmm1
	movss	DWORD PTR _z$[esp+104], xmm1
	movss	DWORD PTR _max$$sroa$820$[esp+104], xmm2
	movss	DWORD PTR _min$$sroa$821$[esp+104], xmm4

; 250  : 	float z		= _x*X._13 + _y*X._23 + _z*X._33 + X._43;		if (z<EPS)	return TRUE;

	movaps	xmm1, xmm0
	movss	xmm0, DWORD PTR __real@3727c5ac
	addss	xmm1, DWORD PTR [edx+56]
	comiss	xmm0, xmm1
	movss	DWORD PTR _z$1$[esp+104], xmm1
	ja	$LN91@visible

; 251  : 	float iw	= 1.f/(_x*X._14 + _y*X._24 + _z*X._34 + X._44);

	movss	xmm0, DWORD PTR [edx+44]
	mulss	xmm0, DWORD PTR [ecx+20]
	movss	xmm1, DWORD PTR __real@3f800000
	movss	DWORD PTR tv1077[esp+104], xmm0
	addss	xmm0, DWORD PTR tv1044[esp+104]
	addss	xmm0, DWORD PTR [edx+60]
	divss	xmm1, xmm0

; 252  : 	t 			= (_x*X._11 + _y*X._21 + _z*X._31 + X._41)*iw;	if (t<min.x) min.x=t; else if (t>max.x) max.x=t;

	movaps	xmm0, xmm7
	movss	DWORD PTR _t$3$[esp+104], xmm1
	movss	xmm1, DWORD PTR [ecx+20]
	movss	xmm7, DWORD PTR _t$3$[esp+104]
	mulss	xmm0, xmm1
	movss	DWORD PTR tv1079[esp+104], xmm0
	addss	xmm0, DWORD PTR tv1057[esp+104]
	addss	xmm0, DWORD PTR [edx+48]
	mulss	xmm0, xmm7
	comiss	xmm6, xmm0
	jbe	SHORT $LN16@visible
	movaps	xmm6, xmm0
	movss	DWORD PTR _min$$sroa$819$[esp+104], xmm6
	jmp	SHORT $LN18@visible
$LN16@visible:
	comiss	xmm0, xmm3
	jbe	SHORT $LN18@visible
	movaps	xmm3, xmm0
	movss	DWORD PTR _max$$sroa$818$[esp+104], xmm3
$LN18@visible:

; 253  : 	t			= (_x*X._12 + _y*X._22 + _z*X._32 + X._42)*iw;	if (t<min.y) min.y=t; else if (t>max.y) max.y=t;

	movaps	xmm0, xmm5
	mulss	xmm0, xmm1
	movss	DWORD PTR tv1081[esp+104], xmm0
	addss	xmm0, DWORD PTR tv1069[esp+104]
	addss	xmm0, DWORD PTR [edx+52]
	mulss	xmm0, xmm7
	comiss	xmm4, xmm0
	jbe	SHORT $LN19@visible
	movaps	xmm4, xmm0
	movss	DWORD PTR _min$$sroa$821$[esp+104], xmm4
	jmp	SHORT $LN21@visible
$LN19@visible:
	comiss	xmm0, xmm2
	jbe	SHORT $LN21@visible
	movaps	xmm2, xmm0
	movss	DWORD PTR _max$$sroa$820$[esp+104], xmm2
$LN21@visible:

; 254  : 	t			= 0.f+z*iw;										if (t<minz)	 minz =t;

	mulss	xmm7, DWORD PTR _z$1$[esp+104]
	movss	xmm1, DWORD PTR _z$1$[esp+104]
	comiss	xmm1, xmm7
	jbe	SHORT $LN22@visible
	movaps	xmm1, xmm7
	movss	DWORD PTR _z$[esp+104], xmm1
$LN22@visible:

; 263  : 	if (xform_b1(min,max,z,m_xform_01,B.min.x, B.min.y, B.max.z)) return TRUE;
; 264  : 	if (xform_b1(min,max,z,m_xform_01,B.max.x, B.min.y, B.max.z)) return TRUE;

	movss	xmm0, DWORD PTR [ecx+12]

; 250  : 	float z		= _x*X._13 + _y*X._23 + _z*X._33 + X._43;		if (z<EPS)	return TRUE;

	movss	xmm7, DWORD PTR __real@3727c5ac

; 263  : 	if (xform_b1(min,max,z,m_xform_01,B.min.x, B.min.y, B.max.z)) return TRUE;
; 264  : 	if (xform_b1(min,max,z,m_xform_01,B.max.x, B.min.y, B.max.z)) return TRUE;

	movss	DWORD PTR __x$1$[esp+104], xmm0

; 250  : 	float z		= _x*X._13 + _y*X._23 + _z*X._33 + X._43;		if (z<EPS)	return TRUE;

	movss	xmm0, DWORD PTR [edx+8]
	mulss	xmm0, DWORD PTR [ecx+12]
	addss	xmm0, DWORD PTR tv1030[esp+104]
	movss	DWORD PTR _z$1$[esp+104], xmm0
	addss	xmm0, DWORD PTR tv1074[esp+104]
	addss	xmm0, DWORD PTR [edx+56]
	comiss	xmm7, xmm0
	movss	xmm7, DWORD PTR [ecx+12]
	movss	DWORD PTR _z$1$[esp+104], xmm0
	ja	$LN91@visible

; 251  : 	float iw	= 1.f/(_x*X._14 + _y*X._24 + _z*X._34 + X._44);

	movss	xmm0, DWORD PTR [edx+12]
	mulss	xmm0, xmm7
	movss	xmm7, DWORD PTR __real@3f800000
	addss	xmm0, DWORD PTR tv1041[esp+104]
	movss	DWORD PTR tv1087[esp+104], xmm0
	addss	xmm0, DWORD PTR tv1077[esp+104]
	addss	xmm0, DWORD PTR [edx+60]
	divss	xmm7, xmm0
	movss	DWORD PTR _t$3$[esp+104], xmm7

; 252  : 	t 			= (_x*X._11 + _y*X._21 + _z*X._31 + X._41)*iw;	if (t<min.x) min.x=t; else if (t>max.x) max.x=t;

	movss	xmm7, DWORD PTR [edx]
	mulss	xmm7, DWORD PTR [ecx+12]
	addss	xmm7, DWORD PTR tv1053[esp+104]
	movaps	xmm0, xmm7
	addss	xmm0, DWORD PTR tv1079[esp+104]
	addss	xmm0, DWORD PTR [edx+48]
	mulss	xmm0, DWORD PTR _t$3$[esp+104]
	comiss	xmm6, xmm0
	jbe	SHORT $LN26@visible
	movaps	xmm6, xmm0
	movss	DWORD PTR _min$$sroa$819$[esp+104], xmm6
	jmp	SHORT $LN28@visible
$LN26@visible:
	comiss	xmm0, xmm3
	jbe	SHORT $LN28@visible
	movaps	xmm3, xmm0
	movss	DWORD PTR _max$$sroa$818$[esp+104], xmm3
$LN28@visible:

; 253  : 	t			= (_x*X._12 + _y*X._22 + _z*X._32 + X._42)*iw;	if (t<min.y) min.y=t; else if (t>max.y) max.y=t;

	movss	xmm0, DWORD PTR [edx+4]
	mulss	xmm0, DWORD PTR [ecx+12]
	addss	xmm0, DWORD PTR tv1066[esp+104]
	movss	DWORD PTR tv1092[esp+104], xmm0
	addss	xmm0, DWORD PTR tv1081[esp+104]
	addss	xmm0, DWORD PTR [edx+52]
	mulss	xmm0, DWORD PTR _t$3$[esp+104]
	comiss	xmm4, xmm0
	jbe	SHORT $LN29@visible
	movaps	xmm4, xmm0
	movss	DWORD PTR _min$$sroa$821$[esp+104], xmm4
	jmp	SHORT $LN31@visible
$LN29@visible:
	comiss	xmm0, xmm2
	jbe	SHORT $LN31@visible
	movaps	xmm2, xmm0
	movss	DWORD PTR _max$$sroa$820$[esp+104], xmm2
$LN31@visible:

; 254  : 	t			= 0.f+z*iw;										if (t<minz)	 minz =t;

	movss	xmm0, DWORD PTR _t$3$[esp+104]
	mulss	xmm0, DWORD PTR _z$1$[esp+104]
	comiss	xmm1, xmm0
	jbe	SHORT $LN32@visible
	movaps	xmm1, xmm0
	movss	DWORD PTR _z$[esp+104], xmm1
$LN32@visible:

; 250  : 	float z		= _x*X._13 + _y*X._23 + _z*X._33 + X._43;		if (z<EPS)	return TRUE;

	movss	xmm0, DWORD PTR _z$1$[esp+104]
	addss	xmm0, DWORD PTR tv1034[esp+104]
	movss	xmm5, DWORD PTR __real@3727c5ac
	addss	xmm0, DWORD PTR [edx+56]
	comiss	xmm5, xmm0
	movss	DWORD PTR _z$1$[esp+104], xmm0
	ja	$LN91@visible

; 251  : 	float iw	= 1.f/(_x*X._14 + _y*X._24 + _z*X._34 + X._44);

	movss	xmm0, DWORD PTR tv921[esp+104]
	addss	xmm0, DWORD PTR tv1087[esp+104]
	movss	xmm5, DWORD PTR __real@3f800000

; 252  : 	t 			= (_x*X._11 + _y*X._21 + _z*X._31 + X._41)*iw;	if (t<min.x) min.x=t; else if (t>max.x) max.x=t;

	addss	xmm7, DWORD PTR _t$1$[esp+104]
	addss	xmm0, DWORD PTR [edx+60]
	addss	xmm7, DWORD PTR [edx+48]
	divss	xmm5, xmm0
	mulss	xmm7, xmm5
	comiss	xmm6, xmm7
	jbe	SHORT $LN36@visible
	movaps	xmm6, xmm7
	movss	DWORD PTR _min$$sroa$819$[esp+104], xmm6
	jmp	SHORT $LN38@visible
$LN36@visible:
	comiss	xmm7, xmm3
	jbe	SHORT $LN38@visible
	movaps	xmm3, xmm7
	movss	DWORD PTR _max$$sroa$818$[esp+104], xmm3
$LN38@visible:

; 253  : 	t			= (_x*X._12 + _y*X._22 + _z*X._32 + X._42)*iw;	if (t<min.y) min.y=t; else if (t>max.y) max.y=t;

	movss	xmm0, DWORD PTR [edx+36]
	movaps	xmm7, xmm5
	mulss	xmm0, DWORD PTR [ecx+8]
	movss	DWORD PTR _t$2$[esp+104], xmm0
	addss	xmm0, DWORD PTR tv1092[esp+104]
	addss	xmm0, DWORD PTR [edx+52]
	mulss	xmm0, xmm7
	comiss	xmm4, xmm0
	jbe	SHORT $LN39@visible
	movaps	xmm4, xmm0
	movss	DWORD PTR _min$$sroa$821$[esp+104], xmm4
	jmp	SHORT $LN41@visible
$LN39@visible:
	comiss	xmm0, xmm2
	jbe	SHORT $LN41@visible
	movaps	xmm2, xmm0
	movss	DWORD PTR _max$$sroa$820$[esp+104], xmm2
$LN41@visible:

; 254  : 	t			= 0.f+z*iw;										if (t<minz)	 minz =t;

	mulss	xmm7, DWORD PTR _z$1$[esp+104]
	comiss	xmm1, xmm7
	jbe	SHORT $LN42@visible
	movaps	xmm1, xmm7
	movss	DWORD PTR _z$[esp+104], xmm1
$LN42@visible:

; 250  : 	float z		= _x*X._13 + _y*X._23 + _z*X._33 + X._43;		if (z<EPS)	return TRUE;

	movss	xmm0, DWORD PTR [edx+24]

; 265  : 	if (xform_b1(min,max,z,m_xform_01,B.max.x, B.min.y, B.min.z)) return TRUE;
; 266  : 	if (xform_b1(min,max,z,m_xform_01,B.min.x, B.max.y, B.min.z)) return TRUE;

	movss	xmm7, DWORD PTR [ecx+16]

; 250  : 	float z		= _x*X._13 + _y*X._23 + _z*X._33 + X._43;		if (z<EPS)	return TRUE;

	mulss	xmm0, xmm7
	movss	xmm5, DWORD PTR __real@3727c5ac
	movss	DWORD PTR tv1096[esp+104], xmm0
	movss	xmm0, DWORD PTR [edx+8]
	mulss	xmm0, DWORD PTR [ecx]
	addss	xmm0, DWORD PTR tv1096[esp+104]
	movss	DWORD PTR _z$1$[esp+104], xmm0
	addss	xmm0, DWORD PTR tv1034[esp+104]
	addss	xmm0, DWORD PTR [edx+56]
	comiss	xmm5, xmm0
	movss	DWORD PTR _z$1$[esp+104], xmm0
	ja	$LN91@visible

; 251  : 	float iw	= 1.f/(_x*X._14 + _y*X._24 + _z*X._34 + X._44);

	movss	xmm0, DWORD PTR [edx+28]
	movss	xmm5, DWORD PTR tv921[esp+104]
	mulss	xmm0, xmm7
	movss	DWORD PTR tv1100[esp+104], xmm0
	movss	xmm0, DWORD PTR [edx+12]
	mulss	xmm0, DWORD PTR [ecx]
	addss	xmm0, DWORD PTR tv1100[esp+104]
	addss	xmm5, xmm0
	movss	DWORD PTR tv953[esp+104], xmm0
	movaps	xmm0, xmm5

; 252  : 	t 			= (_x*X._11 + _y*X._21 + _z*X._31 + X._41)*iw;	if (t<min.x) min.x=t; else if (t>max.x) max.x=t;

	movss	xmm5, DWORD PTR [edx+16]
	addss	xmm0, DWORD PTR [edx+60]
	mulss	xmm5, xmm7
	movss	xmm7, DWORD PTR [edx]
	mulss	xmm7, DWORD PTR [ecx]
	movss	DWORD PTR tv921[esp+104], xmm0
	movss	xmm0, DWORD PTR __real@3f800000
	divss	xmm0, DWORD PTR tv921[esp+104]
	addss	xmm7, xmm5
	movss	DWORD PTR tv1104[esp+104], xmm5
	movss	xmm5, DWORD PTR _t$1$[esp+104]
	movss	DWORD PTR _t$3$[esp+104], xmm0
	addss	xmm5, xmm7
	movss	DWORD PTR _t$1$[esp+104], xmm7
	addss	xmm5, DWORD PTR [edx+48]
	mulss	xmm5, xmm0
	movaps	xmm0, xmm5
	comiss	xmm6, xmm0
	jbe	SHORT $LN46@visible
	movaps	xmm6, xmm0
	movss	DWORD PTR _min$$sroa$819$[esp+104], xmm6
	jmp	SHORT $LN48@visible
$LN46@visible:
	comiss	xmm0, xmm3
	jbe	SHORT $LN48@visible
	movaps	xmm3, xmm0
	movss	DWORD PTR _max$$sroa$818$[esp+104], xmm3
$LN48@visible:

; 253  : 	t			= (_x*X._12 + _y*X._22 + _z*X._32 + X._42)*iw;	if (t<min.y) min.y=t; else if (t>max.y) max.y=t;

	movss	xmm0, DWORD PTR [edx+20]
	mulss	xmm0, DWORD PTR [ecx+16]
	movss	xmm5, DWORD PTR _t$2$[esp+104]
	movss	DWORD PTR tv1108[esp+104], xmm0
	movss	xmm0, DWORD PTR [edx+4]
	mulss	xmm0, DWORD PTR [ecx]
	addss	xmm0, DWORD PTR tv1108[esp+104]
	addss	xmm5, xmm0
	movss	DWORD PTR _t$2$[esp+104], xmm0
	addss	xmm5, DWORD PTR [edx+52]
	mulss	xmm5, DWORD PTR _t$3$[esp+104]
	comiss	xmm4, xmm5
	jbe	SHORT $LN49@visible
	movaps	xmm4, xmm5
	movss	DWORD PTR _min$$sroa$821$[esp+104], xmm4
	jmp	SHORT $LN51@visible
$LN49@visible:
	comiss	xmm5, xmm2
	jbe	SHORT $LN51@visible
	movaps	xmm2, xmm5
	movss	DWORD PTR _max$$sroa$820$[esp+104], xmm2
$LN51@visible:

; 254  : 	t			= 0.f+z*iw;										if (t<minz)	 minz =t;

	movss	xmm5, DWORD PTR _t$3$[esp+104]
	mulss	xmm5, DWORD PTR _z$1$[esp+104]
	comiss	xmm1, xmm5
	jbe	SHORT $LN52@visible
	movaps	xmm1, xmm5
	movss	DWORD PTR _z$[esp+104], xmm1
$LN52@visible:

; 250  : 	float z		= _x*X._13 + _y*X._23 + _z*X._33 + X._43;		if (z<EPS)	return TRUE;

	movss	xmm7, DWORD PTR [edx+40]
	mulss	xmm7, DWORD PTR [ecx+20]
	movss	xmm0, DWORD PTR __real@3727c5ac
	movss	DWORD PTR tv1112[esp+104], xmm7
	movss	xmm7, DWORD PTR _z$1$[esp+104]
	addss	xmm7, DWORD PTR tv1112[esp+104]
	addss	xmm7, DWORD PTR [edx+56]
	comiss	xmm0, xmm7
	movss	xmm0, DWORD PTR _t$2$[esp+104]
	movss	DWORD PTR _z$1$[esp+104], xmm7
	movss	xmm7, DWORD PTR _t$1$[esp+104]
	ja	$LN91@visible

; 251  : 	float iw	= 1.f/(_x*X._14 + _y*X._24 + _z*X._34 + X._44);

	movss	xmm5, DWORD PTR [edx+44]
	mulss	xmm5, DWORD PTR [ecx+20]
	movss	DWORD PTR tv983[esp+104], xmm5
	movss	xmm5, DWORD PTR tv953[esp+104]
	addss	xmm5, DWORD PTR tv983[esp+104]
	addss	xmm5, DWORD PTR [edx+60]
	movss	DWORD PTR tv953[esp+104], xmm5
	movss	xmm5, DWORD PTR __real@3f800000
	divss	xmm5, DWORD PTR tv953[esp+104]
	movss	DWORD PTR _t$3$[esp+104], xmm5

; 252  : 	t 			= (_x*X._11 + _y*X._21 + _z*X._31 + X._41)*iw;	if (t<min.x) min.x=t; else if (t>max.x) max.x=t;

	movss	xmm5, DWORD PTR [edx+32]
	mulss	xmm5, DWORD PTR [ecx+20]
	addss	xmm7, xmm5
	addss	xmm7, DWORD PTR [edx+48]
	mulss	xmm7, DWORD PTR _t$3$[esp+104]
	comiss	xmm6, xmm7
	jbe	SHORT $LN56@visible
	movaps	xmm6, xmm7
	movss	DWORD PTR _min$$sroa$819$[esp+104], xmm6
	jmp	SHORT $LN58@visible
$LN56@visible:
	comiss	xmm7, xmm3
	jbe	SHORT $LN58@visible
	movaps	xmm3, xmm7
	movss	DWORD PTR _max$$sroa$818$[esp+104], xmm3
$LN58@visible:

; 253  : 	t			= (_x*X._12 + _y*X._22 + _z*X._32 + X._42)*iw;	if (t<min.y) min.y=t; else if (t>max.y) max.y=t;

	movss	xmm7, DWORD PTR [edx+36]
	mulss	xmm7, DWORD PTR [ecx+20]
	addss	xmm0, xmm7
	movss	DWORD PTR _t$2$[esp+104], xmm7
	addss	xmm0, DWORD PTR [edx+52]
	mulss	xmm0, DWORD PTR _t$3$[esp+104]
	comiss	xmm4, xmm0
	jbe	SHORT $LN59@visible
	movaps	xmm4, xmm0
	movss	DWORD PTR _min$$sroa$821$[esp+104], xmm4
	jmp	SHORT $LN61@visible
$LN59@visible:
	comiss	xmm0, xmm2
	jbe	SHORT $LN61@visible
	movaps	xmm2, xmm0
	movss	DWORD PTR _max$$sroa$820$[esp+104], xmm2
$LN61@visible:

; 254  : 	t			= 0.f+z*iw;										if (t<minz)	 minz =t;

	movss	xmm0, DWORD PTR _t$3$[esp+104]
	mulss	xmm0, DWORD PTR _z$1$[esp+104]
	comiss	xmm1, xmm0
	jbe	SHORT $LN62@visible
	movaps	xmm1, xmm0
	movss	DWORD PTR _z$[esp+104], xmm1
$LN62@visible:

; 250  : 	float z		= _x*X._13 + _y*X._23 + _z*X._33 + X._43;		if (z<EPS)	return TRUE;

	movss	xmm0, DWORD PTR [edx+8]
	mulss	xmm0, DWORD PTR __x$1$[esp+104]
	movss	xmm7, DWORD PTR __real@3727c5ac
	addss	xmm0, DWORD PTR tv1096[esp+104]
	movss	DWORD PTR tv1121[esp+104], xmm0
	addss	xmm0, DWORD PTR tv1112[esp+104]
	addss	xmm0, DWORD PTR [edx+56]
	comiss	xmm7, xmm0
	movss	DWORD PTR _z$1$[esp+104], xmm0
	ja	$LN91@visible

; 251  : 	float iw	= 1.f/(_x*X._14 + _y*X._24 + _z*X._34 + X._44);

	movss	xmm7, DWORD PTR [edx+12]
	mulss	xmm7, DWORD PTR [ecx+12]
	movaps	xmm0, xmm7

; 252  : 	t 			= (_x*X._11 + _y*X._21 + _z*X._31 + X._41)*iw;	if (t<min.x) min.x=t; else if (t>max.x) max.x=t;

	movss	xmm7, DWORD PTR [edx]
	addss	xmm0, DWORD PTR tv1100[esp+104]
	mulss	xmm7, DWORD PTR [ecx+12]
	movss	DWORD PTR tv1123[esp+104], xmm0
	movss	xmm0, DWORD PTR tv983[esp+104]
	addss	xmm0, DWORD PTR tv1123[esp+104]
	addss	xmm7, DWORD PTR tv1104[esp+104]
	addss	xmm0, DWORD PTR [edx+60]
	movss	DWORD PTR tv1126[esp+104], xmm7
	movss	DWORD PTR tv983[esp+104], xmm0
	movss	xmm0, DWORD PTR __real@3f800000
	divss	xmm0, DWORD PTR tv983[esp+104]
	movss	DWORD PTR _t$3$[esp+104], xmm0
	movaps	xmm0, xmm5
	addss	xmm0, xmm7
	addss	xmm0, DWORD PTR [edx+48]
	mulss	xmm0, DWORD PTR _t$3$[esp+104]
	comiss	xmm6, xmm0
	jbe	SHORT $LN66@visible
	movaps	xmm6, xmm0
	movss	DWORD PTR _min$$sroa$819$[esp+104], xmm6
	jmp	SHORT $LN68@visible
$LN66@visible:
	comiss	xmm0, xmm3
	jbe	SHORT $LN68@visible
	movaps	xmm3, xmm0
	movss	DWORD PTR _max$$sroa$818$[esp+104], xmm3
$LN68@visible:

; 253  : 	t			= (_x*X._12 + _y*X._22 + _z*X._32 + X._42)*iw;	if (t<min.y) min.y=t; else if (t>max.y) max.y=t;

	movss	xmm5, DWORD PTR [edx+4]
	mulss	xmm5, DWORD PTR [ecx+12]
	movss	xmm7, DWORD PTR _t$2$[esp+104]
	movaps	xmm0, xmm5
	addss	xmm0, DWORD PTR tv1108[esp+104]
	addss	xmm7, xmm0
	movss	DWORD PTR tv1128[esp+104], xmm0
	movss	xmm0, DWORD PTR _t$3$[esp+104]
	addss	xmm7, DWORD PTR [edx+52]
	mulss	xmm7, xmm0
	comiss	xmm4, xmm7
	jbe	SHORT $LN69@visible
	movaps	xmm4, xmm7
	movss	DWORD PTR _min$$sroa$821$[esp+104], xmm4
	jmp	SHORT $LN71@visible
$LN69@visible:
	comiss	xmm7, xmm2
	jbe	SHORT $LN71@visible
	movaps	xmm2, xmm7
	movss	DWORD PTR _max$$sroa$820$[esp+104], xmm2
$LN71@visible:

; 254  : 	t			= 0.f+z*iw;										if (t<minz)	 minz =t;

	mulss	xmm0, DWORD PTR _z$1$[esp+104]
	movss	xmm5, DWORD PTR [edx+36]
	comiss	xmm1, xmm0
	jbe	SHORT $LN72@visible
	movaps	xmm1, xmm0
	movss	DWORD PTR _z$[esp+104], xmm1
$LN72@visible:

; 250  : 	float z		= _x*X._13 + _y*X._23 + _z*X._33 + X._43;		if (z<EPS)	return TRUE;

	movss	xmm0, DWORD PTR [edx+40]
	mulss	xmm0, DWORD PTR __z$1$[esp+104]
	movss	xmm7, DWORD PTR __real@3727c5ac
	addss	xmm0, DWORD PTR tv1121[esp+104]
	addss	xmm0, DWORD PTR tv1035[esp+104]
	comiss	xmm7, xmm0
	movss	DWORD PTR _z$1$[esp+104], xmm0
	ja	$LN91@visible

; 251  : 	float iw	= 1.f/(_x*X._14 + _y*X._24 + _z*X._34 + X._44);

	movss	xmm0, DWORD PTR [edx+44]
	mulss	xmm0, DWORD PTR __z$1$[esp+104]
	movss	xmm7, DWORD PTR __real@3f800000
	addss	xmm0, DWORD PTR tv1123[esp+104]
	addss	xmm0, DWORD PTR tv1049[esp+104]
	divss	xmm7, xmm0

; 252  : 	t 			= (_x*X._11 + _y*X._21 + _z*X._31 + X._41)*iw;	if (t<min.x) min.x=t; else if (t>max.x) max.x=t;

	movss	xmm0, DWORD PTR [edx+32]
	mulss	xmm0, DWORD PTR __z$1$[esp+104]
	addss	xmm0, DWORD PTR tv1126[esp+104]
	addss	xmm0, DWORD PTR tv1061[esp+104]
	mulss	xmm0, xmm7
	comiss	xmm6, xmm0
	jbe	SHORT $LN76@visible
	movss	DWORD PTR _min$$sroa$819$[esp+104], xmm0
	jmp	SHORT $LN78@visible
$LN76@visible:
	comiss	xmm0, xmm3
	jbe	SHORT $LN78@visible
	movss	DWORD PTR _max$$sroa$818$[esp+104], xmm0
$LN78@visible:

; 253  : 	t			= (_x*X._12 + _y*X._22 + _z*X._32 + X._42)*iw;	if (t<min.y) min.y=t; else if (t>max.y) max.y=t;

	mulss	xmm5, DWORD PTR __z$1$[esp+104]
	addss	xmm5, DWORD PTR tv1128[esp+104]
	addss	xmm5, DWORD PTR tv1071[esp+104]
	mulss	xmm5, xmm7
	comiss	xmm4, xmm5
	jbe	SHORT $LN79@visible
	movss	DWORD PTR _min$$sroa$821$[esp+104], xmm5
	jmp	SHORT $LN81@visible
$LN79@visible:
	comiss	xmm5, xmm2
	jbe	SHORT $LN81@visible
	movss	DWORD PTR _max$$sroa$820$[esp+104], xmm5
$LN81@visible:

; 254  : 	t			= 0.f+z*iw;										if (t<minz)	 minz =t;

	mulss	xmm7, DWORD PTR _z$1$[esp+104]
	comiss	xmm1, xmm7
	jbe	SHORT $LN9@visible
	movss	DWORD PTR _z$[esp+104], xmm7
$LN9@visible:

; 270  : 	return Raster.test	(min.x,min.y,max.x,max.y,z);

	fld	DWORD PTR _z$[esp+104]
	sub	esp, 20					; 00000014H
	fstp	DWORD PTR [esp+16]
	fld	DWORD PTR _max$$sroa$820$[esp+124]
	fstp	DWORD PTR [esp+12]
	fld	DWORD PTR _max$$sroa$818$[esp+124]
	fstp	DWORD PTR [esp+8]
	fld	DWORD PTR _min$$sroa$821$[esp+124]
	fstp	DWORD PTR [esp+4]
	fld	DWORD PTR _min$$sroa$819$[esp+124]
	fstp	DWORD PTR [esp]
	call	?test@occRasterizer@@QAEHMMMMM@Z	; occRasterizer::test

; 271  : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN91@visible:

; 267  : 	if (xform_b1(min,max,z,m_xform_01,B.min.x, B.max.y, B.max.z)) return TRUE;
; 268  : 	if (xform_b1(min,max,z,m_xform_01,B.max.x, B.max.y, B.max.z)) return TRUE;
; 269  : 	if (xform_b1(min,max,z,m_xform_01,B.max.x, B.max.y, B.min.z)) return TRUE;

	mov	eax, 1

; 271  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?_visible@@YAHAAV?$_box3@M@@AAU?$_matrix@M@@@Z ENDP	; _visible
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp
_TEXT	SEGMENT
_B$ = 8							; size = 4
?visible@CHOM@@QAEHAAV?$_box3@M@@@Z PROC		; CHOM::visible
; _this$ = ecx

; 274  : {

	mov	edx, ecx

; 275  : 	if (!bEnabled)							return TRUE;

	cmp	DWORD PTR [edx+32], 0
	je	SHORT $LN173@visible

; 276  : 	if (B.contains(Device.vCameraPosition))	return TRUE;

	mov	eax, DWORD PTR __imp_?Device@@3VCRenderDevice@@A
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h

; 49   : 	ICF	BOOL	contains	(T x, T y, T z)		const		{ return (x>=x1) && (x<=x2) && (y>=y1) && (y<=y2) && (z>=z1) && (z<=z2); };

	mov	ecx, DWORD PTR _B$[esp-4]

; 50   : 	ICF	BOOL	contains	(const Tvector &p)	const		{ return contains(p.x,p.y,p.z);	};

	movss	xmm1, DWORD PTR [eax+488]

; 49   : 	ICF	BOOL	contains	(T x, T y, T z)		const		{ return (x>=x1) && (x<=x2) && (y>=y1) && (y<=y2) && (z>=z1) && (z<=z2); };

	comiss	xmm1, DWORD PTR [ecx]
	jb	SHORT $LN3@visible
	movss	xmm0, DWORD PTR [ecx+12]
	comiss	xmm0, xmm1
	jb	SHORT $LN3@visible

; 50   : 	ICF	BOOL	contains	(const Tvector &p)	const		{ return contains(p.x,p.y,p.z);	};

	movss	xmm1, DWORD PTR [eax+492]

; 49   : 	ICF	BOOL	contains	(T x, T y, T z)		const		{ return (x>=x1) && (x<=x2) && (y>=y1) && (y<=y2) && (z>=z1) && (z<=z2); };

	comiss	xmm1, DWORD PTR [ecx+4]
	jb	SHORT $LN3@visible
	movss	xmm0, DWORD PTR [ecx+16]
	comiss	xmm0, xmm1
	jb	SHORT $LN3@visible

; 50   : 	ICF	BOOL	contains	(const Tvector &p)	const		{ return contains(p.x,p.y,p.z);	};

	movss	xmm1, DWORD PTR [eax+496]

; 49   : 	ICF	BOOL	contains	(T x, T y, T z)		const		{ return (x>=x1) && (x<=x2) && (y>=y1) && (y<=y2) && (z>=z1) && (z<=z2); };

	comiss	xmm1, DWORD PTR [ecx+8]
	jb	SHORT $LN3@visible
	movss	xmm0, DWORD PTR [ecx+20]
	comiss	xmm0, xmm1
	jae	SHORT $LN173@visible
$LN3@visible:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp

; 277  : 	return _visible		(B,m_xform_01)		;

	add	edx, 100				; 00000064H
	call	?_visible@@YAHAAV?$_box3@M@@AAU?$_matrix@M@@@Z ; _visible

; 278  : }

	ret	4
$LN173@visible:

; 276  : 	if (B.contains(Device.vCameraPosition))	return TRUE;

	mov	eax, 1

; 278  : }

	ret	4
?visible@CHOM@@QAEHAAV?$_box3@M@@@Z ENDP		; CHOM::visible
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp
_TEXT	SEGMENT
_B$ = 8							; size = 4
_depth$ = 12						; size = 4
?visible@CHOM@@QAEHAAV?$_box2@M@@M@Z PROC		; CHOM::visible
; _this$ = ecx

; 281  : {

	push	ecx

; 282  : 	if (!bEnabled)		return TRUE;

	cmp	DWORD PTR [ecx+32], 0
	jne	SHORT $LN2@visible
	mov	eax, 1

; 284  : }

	pop	ecx
	ret	8
$LN2@visible:

; 283  : 	return Raster.test	(B.min.x,B.min.y,B.max.x,B.max.y,depth);

	mov	eax, DWORD PTR _B$[esp]
	sub	esp, 20					; 00000014H
	fld	DWORD PTR _depth$[esp+20]
	fstp	DWORD PTR [esp+16]
	fld	DWORD PTR [eax+12]
	fstp	DWORD PTR [esp+12]
	fld	DWORD PTR [eax+8]
	fstp	DWORD PTR [esp+8]
	fld	DWORD PTR [eax+4]
	fstp	DWORD PTR [esp+4]
	fld	DWORD PTR [eax]
	fstp	DWORD PTR [esp]
	call	?test@occRasterizer@@QAEHMMMMM@Z	; occRasterizer::test

; 284  : }

	pop	ecx
	ret	8
?visible@CHOM@@QAEHAAV?$_box2@M@@M@Z ENDP		; CHOM::visible
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp
_TEXT	SEGMENT
_z$ = -20						; size = 4
_max$$sroa$314$ = -16					; size = 4
_min$$sroa$317$ = -12					; size = 4
_min$$sroa$315$ = -8					; size = 4
_max$$sroa$316$ = -4					; size = 4
_P$ = 8							; size = 4
?visible@CHOM@@QAEHAAV?$svector@U?$_vector3@M@@$0DA@@@@Z PROC ; CHOM::visible
; _this$ = ecx

; 320  : {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	sub	esp, 20					; 00000014H
	mov	edx, ecx

; 321  : 	if (!bEnabled)		return TRUE;

	cmp	DWORD PTR [edx+32], 0
	push	esi
	je	$LN38@visible

; 322  : 
; 323  : 	// Find min/max points of xformed-box
; 324  : 	Fvector2	min,max;
; 325  : 	float		z;
; 326  : 	
; 327  : 	if (xform_b0(min,max,z,m_xform_01,P.front().x,P.front().y,P.front().z)) return TRUE;

	mov	eax, DWORD PTR _P$[ebp]

; 240  : 	float z		= _x*X._13 + _y*X._23 + _z*X._33 + X._43;			if (z<EPS) return TRUE;

	movss	xmm0, DWORD PTR [edx+108]
	movss	xmm3, DWORD PTR [edx+124]

; 322  : 
; 323  : 	// Find min/max points of xformed-box
; 324  : 	Fvector2	min,max;
; 325  : 	float		z;
; 326  : 	
; 327  : 	if (xform_b0(min,max,z,m_xform_01,P.front().x,P.front().y,P.front().z)) return TRUE;

	movss	xmm4, DWORD PTR [eax]
	movss	xmm5, DWORD PTR [eax+4]
	movss	xmm6, DWORD PTR [eax+8]

; 240  : 	float z		= _x*X._13 + _y*X._23 + _z*X._33 + X._43;			if (z<EPS) return TRUE;

	mulss	xmm0, xmm4
	mulss	xmm3, xmm5
	addss	xmm3, xmm0
	movss	xmm0, DWORD PTR [edx+140]
	mulss	xmm0, xmm6
	addss	xmm0, DWORD PTR [edx+156]
	addss	xmm3, xmm0
	movss	xmm0, DWORD PTR __real@3727c5ac
	comiss	xmm0, xmm3
	ja	$LN38@visible

; 241  : 	float iw	= 1.f/(_x*X._14 + _y*X._24 + _z*X._34 + X._44);		

	movss	xmm1, DWORD PTR [edx+128]

; 328  : 	for (u32 it=1; it<P.size(); it++)

	mov	ecx, 1

; 241  : 	float iw	= 1.f/(_x*X._14 + _y*X._24 + _z*X._34 + X._44);		

	movss	xmm0, DWORD PTR [edx+112]
	mulss	xmm0, xmm4

; 328  : 	for (u32 it=1; it<P.size(); it++)

	mov	esi, DWORD PTR [eax+576]

; 241  : 	float iw	= 1.f/(_x*X._14 + _y*X._24 + _z*X._34 + X._44);		

	movss	xmm2, DWORD PTR __real@3f800000
	mulss	xmm1, xmm5

; 242  : 	min.x=max.x	= (_x*X._11 + _y*X._21 + _z*X._31 + X._41)*iw;
; 243  : 	min.y=max.y	= (_x*X._12 + _y*X._22 + _z*X._32 + X._42)*iw;	

	movss	xmm7, DWORD PTR [edx+120]
	mulss	xmm7, xmm5
	addss	xmm1, xmm0
	movss	xmm0, DWORD PTR [edx+144]
	mulss	xmm0, xmm6
	addss	xmm0, DWORD PTR [edx+160]
	addss	xmm1, xmm0
	movss	xmm0, DWORD PTR [edx+116]
	mulss	xmm0, xmm5
	divss	xmm2, xmm1
	movss	xmm1, DWORD PTR [edx+100]
	mulss	xmm1, xmm4
	addss	xmm1, xmm0
	movss	xmm0, DWORD PTR [edx+132]
	mulss	xmm0, xmm6
	addss	xmm0, DWORD PTR [edx+148]
	addss	xmm1, xmm0
	movss	xmm0, DWORD PTR [edx+104]
	mulss	xmm0, xmm4
	mulss	xmm1, xmm2
	addss	xmm7, xmm0
	movss	xmm0, DWORD PTR [edx+136]
	mulss	xmm0, xmm6
	movss	DWORD PTR _max$$sroa$314$[esp+24], xmm1
	movss	DWORD PTR _min$$sroa$315$[esp+24], xmm1
	addss	xmm0, DWORD PTR [edx+152]
	addss	xmm7, xmm0
	mulss	xmm7, xmm2

; 244  : 	minz		= 0.f+z*iw;

	mulss	xmm2, xmm3
	movss	DWORD PTR _max$$sroa$316$[esp+24], xmm7
	movss	DWORD PTR _min$$sroa$317$[esp+24], xmm7
	movss	DWORD PTR _z$[esp+24], xmm2

; 328  : 	for (u32 it=1; it<P.size(); it++)

	cmp	esi, ecx
	jbe	$LN3@visible
	add	eax, 20					; 00000014H
	npad	1
$LL4@visible:

; 250  : 	float z		= _x*X._13 + _y*X._23 + _z*X._33 + X._43;		if (z<EPS)	return TRUE;

	movss	xmm0, DWORD PTR [edx+124]

; 329  : 		if (xform_b1(min,max,z,m_xform_01,P[it].x,P[it].y,P[it].z)) return TRUE;

	movss	xmm4, DWORD PTR [eax-8]
	movss	xmm5, DWORD PTR [eax-4]

; 250  : 	float z		= _x*X._13 + _y*X._23 + _z*X._33 + X._43;		if (z<EPS)	return TRUE;

	movss	xmm3, DWORD PTR [edx+108]

; 329  : 		if (xform_b1(min,max,z,m_xform_01,P[it].x,P[it].y,P[it].z)) return TRUE;

	movss	xmm6, DWORD PTR [eax]

; 250  : 	float z		= _x*X._13 + _y*X._23 + _z*X._33 + X._43;		if (z<EPS)	return TRUE;

	mulss	xmm0, xmm5
	mulss	xmm3, xmm4
	addss	xmm3, xmm0
	movss	xmm0, DWORD PTR [edx+140]
	mulss	xmm0, xmm6
	addss	xmm0, DWORD PTR [edx+156]
	addss	xmm3, xmm0
	movss	xmm0, DWORD PTR __real@3727c5ac
	comiss	xmm0, xmm3
	ja	$LN38@visible

; 251  : 	float iw	= 1.f/(_x*X._14 + _y*X._24 + _z*X._34 + X._44);

	movss	xmm1, DWORD PTR [edx+112]
	movss	xmm0, DWORD PTR [edx+128]
	mulss	xmm0, xmm5
	movss	xmm2, DWORD PTR __real@3f800000
	mulss	xmm1, xmm4
	addss	xmm1, xmm0
	movss	xmm0, DWORD PTR [edx+144]
	mulss	xmm0, xmm6
	addss	xmm0, DWORD PTR [edx+160]
	addss	xmm1, xmm0

; 252  : 	t 			= (_x*X._11 + _y*X._21 + _z*X._31 + X._41)*iw;	if (t<min.x) min.x=t; else if (t>max.x) max.x=t;

	movss	xmm0, DWORD PTR [edx+100]
	mulss	xmm0, xmm4
	divss	xmm2, xmm1
	movss	xmm1, DWORD PTR [edx+116]
	mulss	xmm1, xmm5
	addss	xmm1, xmm0
	movss	xmm0, DWORD PTR [edx+132]
	mulss	xmm0, xmm6
	addss	xmm0, DWORD PTR [edx+148]
	addss	xmm1, xmm0
	movss	xmm0, DWORD PTR _min$$sroa$315$[esp+24]
	mulss	xmm1, xmm2
	comiss	xmm0, xmm1
	jbe	SHORT $LN29@visible
	movss	DWORD PTR _min$$sroa$315$[esp+24], xmm1
	jmp	SHORT $LN31@visible
$LN29@visible:
	comiss	xmm1, DWORD PTR _max$$sroa$314$[esp+24]
	jbe	SHORT $LN31@visible
	movaps	xmm0, xmm1
	movss	DWORD PTR _max$$sroa$314$[esp+24], xmm0
$LN31@visible:

; 253  : 	t			= (_x*X._12 + _y*X._22 + _z*X._32 + X._42)*iw;	if (t<min.y) min.y=t; else if (t>max.y) max.y=t;

	movss	xmm0, DWORD PTR [edx+120]
	movss	xmm1, DWORD PTR [edx+104]
	mulss	xmm0, xmm5
	mulss	xmm1, xmm4
	addss	xmm1, xmm0
	movss	xmm0, DWORD PTR [edx+136]
	mulss	xmm0, xmm6
	addss	xmm0, DWORD PTR [edx+152]
	addss	xmm1, xmm0
	movss	xmm0, DWORD PTR _min$$sroa$317$[esp+24]
	mulss	xmm1, xmm2
	comiss	xmm0, xmm1
	jbe	SHORT $LN32@visible
	movss	DWORD PTR _min$$sroa$317$[esp+24], xmm1
	jmp	SHORT $LN34@visible
$LN32@visible:
	comiss	xmm1, xmm7
	jbe	SHORT $LN34@visible
	movaps	xmm7, xmm1
	movss	DWORD PTR _max$$sroa$316$[esp+24], xmm7
$LN34@visible:

; 254  : 	t			= 0.f+z*iw;										if (t<minz)	 minz =t;

	movss	xmm0, DWORD PTR _z$[esp+24]
	mulss	xmm2, xmm3
	comiss	xmm0, xmm2
	jbe	SHORT $LN35@visible
	movaps	xmm0, xmm2
	movss	DWORD PTR _z$[esp+24], xmm0
$LN35@visible:

; 328  : 	for (u32 it=1; it<P.size(); it++)

	inc	ecx
	add	eax, 12					; 0000000cH
	cmp	ecx, esi
	jb	$LL4@visible
$LN3@visible:

; 330  : 	return Raster.test	(min.x,min.y,max.x,max.y,z);

	fld	DWORD PTR _z$[esp+24]
	sub	esp, 20					; 00000014H
	fstp	DWORD PTR [esp+16]
	fld	DWORD PTR _max$$sroa$316$[esp+44]
	fstp	DWORD PTR [esp+12]
	fld	DWORD PTR _max$$sroa$314$[esp+44]
	fstp	DWORD PTR [esp+8]
	fld	DWORD PTR _min$$sroa$317$[esp+44]
	fstp	DWORD PTR [esp+4]
	fld	DWORD PTR _min$$sroa$315$[esp+44]
	fstp	DWORD PTR [esp]
	call	?test@occRasterizer@@QAEHMMMMM@Z	; occRasterizer::test

; 331  : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
$LN38@visible:

; 329  : 		if (xform_b1(min,max,z,m_xform_01,P[it].x,P[it].y,P[it].z)) return TRUE;

	mov	eax, 1

; 331  : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
?visible@CHOM@@QAEHAAV?$svector@U?$_vector3@M@@$0DA@@@@Z ENDP ; CHOM::visible
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp
_TEXT	SEGMENT
?Disable@CHOM@@QAEXXZ PROC				; CHOM::Disable
; _this$ = ecx

; 335  : 	bEnabled			= FALSE;

	mov	DWORD PTR [ecx+32], 0

; 336  : }

	ret	0
?Disable@CHOM@@QAEXXZ ENDP				; CHOM::Disable
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp
_TEXT	SEGMENT
?Enable@CHOM@@QAEXXZ PROC				; CHOM::Enable
; _this$ = ecx

; 340  : 	bEnabled			= m_pModel?TRUE:FALSE;

	xor	eax, eax
	cmp	DWORD PTR [ecx+24], eax
	setne	al
	mov	DWORD PTR [ecx+32], eax

; 341  : }

	ret	0
?Enable@CHOM@@QAEXXZ ENDP				; CHOM::Enable
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\FixedVector.h
;	COMDAT ?front@?$svector@U?$_vector3@M@@$0DA@@@QAEAAU?$_vector3@M@@XZ
_TEXT	SEGMENT
?front@?$svector@U?$_vector3@M@@$0DA@@@QAEAAU?$_vector3@M@@XZ PROC ; svector<_vector3<float>,48>::front, COMDAT
; _this$ = ecx

; 41   : 	IC reference		front()				{ return array[0];						}

	mov	eax, ecx
	ret	0
?front@?$svector@U?$_vector3@M@@$0DA@@@QAEAAU?$_vector3@M@@XZ ENDP ; svector<_vector3<float>,48>::front
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\FixedVector.h
;	COMDAT ??A?$svector@U?$_vector3@M@@$0DA@@@QAEAAU?$_vector3@M@@I@Z
_TEXT	SEGMENT
_id$ = 8						; size = 4
??A?$svector@U?$_vector3@M@@$0DA@@@QAEAAU?$_vector3@M@@I@Z PROC ; svector<_vector3<float>,48>::operator[], COMDAT
; _this$ = ecx

; 38   : 	IC reference		operator[] (u32 id)			{ VERIFY(id<count); return array[id];	}

	mov	eax, DWORD PTR _id$[esp-4]
	lea	eax, DWORD PTR [eax+eax*2]
	lea	eax, DWORD PTR [ecx+eax*4]
	ret	4
??A?$svector@U?$_vector3@M@@$0DA@@@QAEAAU?$_vector3@M@@I@Z ENDP ; svector<_vector3<float>,48>::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\FixedVector.h
;	COMDAT ?push_back@?$svector@U?$_vector3@M@@$0DA@@@QAEXU?$_vector3@M@@@Z
_TEXT	SEGMENT
_e$ = 8							; size = 12
?push_back@?$svector@U?$_vector3@M@@$0DA@@@QAEXU?$_vector3@M@@@Z PROC ; svector<_vector3<float>,48>::push_back, COMDAT
; _this$ = ecx

; 35   : 	IC void		push_back(value_type e)		{ VERIFY(count<dim); array[count++]=e;	}

	mov	eax, DWORD PTR [ecx+576]
	lea	eax, DWORD PTR [eax+eax*2]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _e$[esp-4]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR _e$[esp]
	mov	DWORD PTR [edx+4], eax
	mov	eax, DWORD PTR _e$[esp+4]
	mov	DWORD PTR [edx+8], eax
	inc	DWORD PTR [ecx+576]
	ret	12					; 0000000cH
?push_back@?$svector@U?$_vector3@M@@$0DA@@@QAEXU?$_vector3@M@@@Z ENDP ; svector<_vector3<float>,48>::push_back
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\FixedVector.h
;	COMDAT ?clear@?$svector@U?$_vector3@M@@$0DA@@@QAEXXZ
_TEXT	SEGMENT
?clear@?$svector@U?$_vector3@M@@$0DA@@@QAEXXZ PROC	; svector<_vector3<float>,48>::clear, COMDAT
; _this$ = ecx

; 31   : 	IC void		clear()						{ count=0;								}

	mov	DWORD PTR [ecx+576], 0
	ret	0
?clear@?$svector@U?$_vector3@M@@$0DA@@@QAEXXZ ENDP	; svector<_vector3<float>,48>::clear
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\FixedVector.h
;	COMDAT ?size@?$svector@U?$_vector3@M@@$0DA@@@QBEIXZ
_TEXT	SEGMENT
?size@?$svector@U?$_vector3@M@@$0DA@@@QBEIXZ PROC	; svector<_vector3<float>,48>::size, COMDAT
; _this$ = ecx

; 30   : 	IC u32		size()		const			{ return count;							}

	mov	eax, DWORD PTR [ecx+576]
	ret	0
?size@?$svector@U?$_vector3@M@@$0DA@@@QBEIXZ ENDP	; svector<_vector3<float>,48>::size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_plane.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_plane.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_plane.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_plane.h
;	COMDAT ?build@?$_plane@M@@QAEAAV1@ABU?$_vector3@M@@00@Z
_TEXT	SEGMENT
_v1$ = 8						; size = 4
_v2$ = 12						; size = 4
_v3$ = 16						; size = 4
?build@?$_plane@M@@QAEAAV1@ABU?$_vector3@M@@00@Z PROC	; _plane<float>::build, COMDAT
; _this$ = ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	mov	edx, DWORD PTR _v1$[esp-4]
	mov	eax, DWORD PTR _v3$[esp-4]
	movss	xmm7, DWORD PTR [edx]
	movss	xmm6, DWORD PTR [edx+8]
	movaps	xmm4, xmm7
	movss	xmm3, DWORD PTR [edx+4]
	movaps	xmm1, xmm6
	subss	xmm1, DWORD PTR [eax+8]
	subss	xmm4, DWORD PTR [eax]
	movaps	xmm2, xmm3
	subss	xmm2, DWORD PTR [eax+4]
	mov	eax, DWORD PTR _v2$[esp-4]
	subss	xmm6, DWORD PTR [eax+8]
	subss	xmm3, DWORD PTR [eax+4]
	subss	xmm7, DWORD PTR [eax]
; File I:\Vitalya\mine\NSProjectX\xrCore\_plane.h

; 30   : 		return *this;

	mov	eax, ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 273  : 		x = v1.y  * v2.z  - v1.z  * v2.y ;

	movaps	xmm0, xmm6
	mulss	xmm6, xmm4
	mulss	xmm0, xmm2
; File I:\Vitalya\mine\NSProjectX\xrCore\_plane.h

; 28   : 		n.crossproduct(t1.sub(v1,v2), t2.sub(v1,v3)).normalize();

	movaps	xmm5, xmm3
	mulss	xmm5, xmm1
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 275  : 		z = v1.x  * v2.y  - v1.y  * v2.x ;

	mulss	xmm3, xmm4
	subss	xmm5, xmm0
	movaps	xmm0, xmm7
	mulss	xmm0, xmm1
	mulss	xmm7, xmm2
	subss	xmm6, xmm0

; 190  : 		T mag=_sqrt(T(1)/(x*x + y*y + z*z));

	movaps	xmm1, xmm5
	mulss	xmm1, xmm5

; 275  : 		z = v1.x  * v2.y  - v1.y  * v2.x ;

	subss	xmm7, xmm3

; 190  : 		T mag=_sqrt(T(1)/(x*x + y*y + z*z));

	movaps	xmm0, xmm6
	mulss	xmm0, xmm6
	addss	xmm1, xmm0
	movaps	xmm0, xmm7
	mulss	xmm0, xmm7
	addss	xmm1, xmm0
	movss	xmm0, DWORD PTR __real@3f800000
	divss	xmm0, xmm1
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h

; 764  :             return (float)sqrt(_X);

	sqrtss	xmm0, xmm0
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 192  : 		y *= mag;

	mulss	xmm6, xmm0
	mulss	xmm5, xmm0
	movss	DWORD PTR [ecx+4], xmm6

; 193  : 		z *= mag;

	mulss	xmm7, xmm0
	movss	DWORD PTR [ecx], xmm5
	movss	DWORD PTR [ecx+8], xmm7

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	mulss	xmm6, DWORD PTR [edx+4]
	mulss	xmm5, DWORD PTR [edx]
	mulss	xmm7, DWORD PTR [edx+8]
	addss	xmm6, xmm5
	addss	xmm6, xmm7
	xorps	xmm6, DWORD PTR __xmm@80000000800000008000000080000000
; File I:\Vitalya\mine\NSProjectX\xrCore\_plane.h

; 29   : 		d = -n.dotproduct(v1);

	movss	DWORD PTR [ecx+12], xmm6

; 31   : 	}

	ret	12					; 0000000cH
?build@?$_plane@M@@QAEAAV1@ABU?$_vector3@M@@00@Z ENDP	; _plane<float>::build
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h
;	COMDAT ?contains@?$_box3@M@@QBEHABU?$_vector3@M@@@Z
_TEXT	SEGMENT
_p$ = 8							; size = 4
?contains@?$_box3@M@@QBEHABU?$_vector3@M@@@Z PROC	; _box3<float>::contains, COMDAT
; _this$ = ecx

; 50   : 	ICF	BOOL	contains	(const Tvector &p)	const		{ return contains(p.x,p.y,p.z);	};

	mov	eax, DWORD PTR _p$[esp-4]
	movss	xmm1, DWORD PTR [eax]

; 49   : 	ICF	BOOL	contains	(T x, T y, T z)		const		{ return (x>=x1) && (x<=x2) && (y>=y1) && (y<=y2) && (z>=z1) && (z<=z2); };

	comiss	xmm1, DWORD PTR [ecx]
	jb	SHORT $LN5@contains
	movss	xmm0, DWORD PTR [ecx+12]
	comiss	xmm0, xmm1
	jb	SHORT $LN5@contains

; 50   : 	ICF	BOOL	contains	(const Tvector &p)	const		{ return contains(p.x,p.y,p.z);	};

	movss	xmm1, DWORD PTR [eax+4]

; 49   : 	ICF	BOOL	contains	(T x, T y, T z)		const		{ return (x>=x1) && (x<=x2) && (y>=y1) && (y<=y2) && (z>=z1) && (z<=z2); };

	comiss	xmm1, DWORD PTR [ecx+4]
	jb	SHORT $LN5@contains
	movss	xmm0, DWORD PTR [ecx+16]
	comiss	xmm0, xmm1
	jb	SHORT $LN5@contains

; 50   : 	ICF	BOOL	contains	(const Tvector &p)	const		{ return contains(p.x,p.y,p.z);	};

	movss	xmm1, DWORD PTR [eax+8]

; 49   : 	ICF	BOOL	contains	(T x, T y, T z)		const		{ return (x>=x1) && (x<=x2) && (y>=y1) && (y<=y2) && (z>=z1) && (z<=z2); };

	comiss	xmm1, DWORD PTR [ecx+8]
	jb	SHORT $LN5@contains
	movss	xmm0, DWORD PTR [ecx+20]
	comiss	xmm0, xmm1
	jb	SHORT $LN5@contains

; 50   : 	ICF	BOOL	contains	(const Tvector &p)	const		{ return contains(p.x,p.y,p.z);	};

	mov	eax, 1
	ret	4
$LN5@contains:
	xor	eax, eax
	ret	4
?contains@?$_box3@M@@QBEHABU?$_vector3@M@@@Z ENDP	; _box3<float>::contains
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
;	COMDAT ?transform@?$_matrix@M@@QBEXAAU?$_vector3@M@@ABU2@@Z
_TEXT	SEGMENT
_dest$ = 8						; size = 4
_v$ = 12						; size = 4
?transform@?$_matrix@M@@QBEXAAU?$_vector3@M@@ABU2@@Z PROC ; _matrix<float>::transform, COMDAT
; _this$ = ecx

; 529  : 		T iw	= 1.f/(v.x*_14 + v.y*_24 + v.z*_34 + _44);

	mov	edx, DWORD PTR _v$[esp-4]
	movss	xmm5, DWORD PTR __real@3f800000

; 530  : 		dest.x	= (v.x*_11 + v.y*_21 + v.z*_31 + _41)*iw;

	mov	eax, DWORD PTR _dest$[esp-4]
	movss	xmm4, DWORD PTR [edx+4]
	movss	xmm2, DWORD PTR [edx]
	movaps	xmm0, xmm4
	mulss	xmm0, DWORD PTR [ecx+28]
	movaps	xmm1, xmm2
	mulss	xmm1, DWORD PTR [ecx+12]
	movss	xmm3, DWORD PTR [edx+8]
	mulss	xmm4, DWORD PTR [ecx+16]
	addss	xmm1, xmm0
	mulss	xmm2, DWORD PTR [ecx]
	movaps	xmm0, xmm3
	mulss	xmm3, DWORD PTR [ecx+32]
	mulss	xmm0, DWORD PTR [ecx+44]
	addss	xmm4, xmm2
	addss	xmm3, DWORD PTR [ecx+48]
	addss	xmm0, DWORD PTR [ecx+60]
	addss	xmm4, xmm3
	addss	xmm1, xmm0
	divss	xmm5, xmm1
	mulss	xmm4, xmm5
	movss	DWORD PTR [eax], xmm4

; 531  : 		dest.y	= (v.x*_12 + v.y*_22 + v.z*_32 + _42)*iw;

	movss	xmm1, DWORD PTR [ecx+20]
	mulss	xmm1, DWORD PTR [edx+4]
	movss	xmm0, DWORD PTR [ecx+4]
	mulss	xmm0, DWORD PTR [edx]
	addss	xmm1, xmm0
	movss	xmm0, DWORD PTR [ecx+36]
	mulss	xmm0, DWORD PTR [edx+8]
	addss	xmm0, DWORD PTR [ecx+52]
	addss	xmm1, xmm0
	mulss	xmm1, xmm5
	movss	DWORD PTR [eax+4], xmm1

; 532  : 		dest.z	= (v.x*_13 + v.y*_23 + v.z*_33 + _43)*iw;

	movss	xmm0, DWORD PTR [ecx+8]
	mulss	xmm0, DWORD PTR [edx]
	movss	xmm1, DWORD PTR [ecx+24]
	mulss	xmm1, DWORD PTR [edx+4]
	addss	xmm1, xmm0
	movss	xmm0, DWORD PTR [ecx+40]
	mulss	xmm0, DWORD PTR [edx+8]
	addss	xmm0, DWORD PTR [ecx+56]
	addss	xmm1, xmm0
	mulss	xmm1, xmm5
	movss	DWORD PTR [eax+8], xmm1

; 533  : 	}

	ret	8
?transform@?$_matrix@M@@QBEXAAU?$_vector3@M@@ABU2@@Z ENDP ; _matrix<float>::transform
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
;	COMDAT ?mul@?$_matrix@M@@QAEAAU1@ABU1@0@Z
_TEXT	SEGMENT
_A$ = 8							; size = 4
_B$ = 12						; size = 4
?mul@?$_matrix@M@@QAEAAU1@ABU1@0@Z PROC			; _matrix<float>::mul, COMDAT
; _this$ = ecx

; 84   : 		VERIFY	((this!=&A)&&(this!=&B));
; 85   : 		m[0][0] = A.m[0][0] * B.m[0][0] + A.m[1][0] * B.m[0][1] + A.m[2][0] * B.m[0][2] + A.m[3][0] * B.m[0][3];

	mov	edx, DWORD PTR _A$[esp-4]
	mov	eax, DWORD PTR _B$[esp-4]
	movss	xmm2, DWORD PTR [edx]
	mulss	xmm2, DWORD PTR [eax]
	movss	xmm0, DWORD PTR [eax+4]
	mulss	xmm0, DWORD PTR [edx+16]
	movss	xmm1, DWORD PTR [eax+8]
	mulss	xmm1, DWORD PTR [edx+32]
	addss	xmm2, xmm0
	movss	xmm0, DWORD PTR [eax+12]
	mulss	xmm0, DWORD PTR [edx+48]
	addss	xmm1, xmm0
	addss	xmm2, xmm1
	movss	DWORD PTR [ecx], xmm2

; 86   : 		m[0][1] = A.m[0][1] * B.m[0][0] + A.m[1][1] * B.m[0][1] + A.m[2][1] * B.m[0][2] + A.m[3][1] * B.m[0][3];

	movss	xmm2, DWORD PTR [edx+36]
	mulss	xmm2, DWORD PTR [eax+8]
	movss	xmm0, DWORD PTR [eax+12]
	mulss	xmm0, DWORD PTR [edx+52]
	movss	xmm1, DWORD PTR [edx+20]
	mulss	xmm1, DWORD PTR [eax+4]
	addss	xmm2, xmm0
	movss	xmm0, DWORD PTR [edx+4]
	mulss	xmm0, DWORD PTR [eax]
	addss	xmm1, xmm0
	addss	xmm2, xmm1
	movss	DWORD PTR [ecx+4], xmm2

; 87   : 		m[0][2] = A.m[0][2] * B.m[0][0] + A.m[1][2] * B.m[0][1] + A.m[2][2] * B.m[0][2] + A.m[3][2] * B.m[0][3];

	movss	xmm2, DWORD PTR [edx+24]
	mulss	xmm2, DWORD PTR [eax+4]
	movss	xmm0, DWORD PTR [edx+8]
	mulss	xmm0, DWORD PTR [eax]
	movss	xmm1, DWORD PTR [eax+8]
	mulss	xmm1, DWORD PTR [edx+40]
	addss	xmm2, xmm0
	movss	xmm0, DWORD PTR [eax+12]
	mulss	xmm0, DWORD PTR [edx+56]
	addss	xmm1, xmm0
	addss	xmm2, xmm1
	movss	DWORD PTR [ecx+8], xmm2

; 88   : 		m[0][3] = A.m[0][3] * B.m[0][0] + A.m[1][3] * B.m[0][1] + A.m[2][3] * B.m[0][2] + A.m[3][3] * B.m[0][3];

	movss	xmm2, DWORD PTR [eax+4]
	mulss	xmm2, DWORD PTR [edx+28]
	movss	xmm0, DWORD PTR [eax]
	mulss	xmm0, DWORD PTR [edx+12]
	movss	xmm1, DWORD PTR [edx+60]
	mulss	xmm1, DWORD PTR [eax+12]
	addss	xmm2, xmm0
	movss	xmm0, DWORD PTR [eax+8]
	mulss	xmm0, DWORD PTR [edx+44]
	addss	xmm1, xmm0
	addss	xmm2, xmm1
	movss	DWORD PTR [ecx+12], xmm2

; 89   : 
; 90   : 		m[1][0] = A.m[0][0] * B.m[1][0] + A.m[1][0] * B.m[1][1] + A.m[2][0] * B.m[1][2] + A.m[3][0] * B.m[1][3];

	movss	xmm2, DWORD PTR [edx]
	mulss	xmm2, DWORD PTR [eax+16]
	movss	xmm0, DWORD PTR [eax+20]
	mulss	xmm0, DWORD PTR [edx+16]
	movss	xmm1, DWORD PTR [eax+28]
	mulss	xmm1, DWORD PTR [edx+48]
	addss	xmm2, xmm0
	movss	xmm0, DWORD PTR [eax+24]
	mulss	xmm0, DWORD PTR [edx+32]
	addss	xmm1, xmm0
	addss	xmm2, xmm1
	movss	DWORD PTR [ecx+16], xmm2

; 91   : 		m[1][1] = A.m[0][1] * B.m[1][0] + A.m[1][1] * B.m[1][1] + A.m[2][1] * B.m[1][2] + A.m[3][1] * B.m[1][3];

	movss	xmm2, DWORD PTR [edx+36]
	mulss	xmm2, DWORD PTR [eax+24]
	movss	xmm0, DWORD PTR [eax+28]
	mulss	xmm0, DWORD PTR [edx+52]
	movss	xmm1, DWORD PTR [edx+20]
	mulss	xmm1, DWORD PTR [eax+20]
	addss	xmm2, xmm0
	movss	xmm0, DWORD PTR [edx+4]
	mulss	xmm0, DWORD PTR [eax+16]
	addss	xmm1, xmm0
	addss	xmm2, xmm1
	movss	DWORD PTR [ecx+20], xmm2

; 92   : 		m[1][2] = A.m[0][2] * B.m[1][0] + A.m[1][2] * B.m[1][1] + A.m[2][2] * B.m[1][2] + A.m[3][2] * B.m[1][3];

	movss	xmm2, DWORD PTR [edx+24]
	movss	xmm0, DWORD PTR [edx+8]
	mulss	xmm2, DWORD PTR [eax+20]
	mulss	xmm0, DWORD PTR [eax+16]
	movss	xmm1, DWORD PTR [eax+24]
	mulss	xmm1, DWORD PTR [edx+40]
	addss	xmm2, xmm0
	movss	xmm0, DWORD PTR [eax+28]
	mulss	xmm0, DWORD PTR [edx+56]
	addss	xmm1, xmm0
	addss	xmm2, xmm1
	movss	DWORD PTR [ecx+24], xmm2

; 93   : 		m[1][3] = A.m[0][3] * B.m[1][0] + A.m[1][3] * B.m[1][1] + A.m[2][3] * B.m[1][2] + A.m[3][3] * B.m[1][3];

	movss	xmm2, DWORD PTR [eax+20]
	mulss	xmm2, DWORD PTR [edx+28]
	movss	xmm0, DWORD PTR [eax+16]
	mulss	xmm0, DWORD PTR [edx+12]
	movss	xmm1, DWORD PTR [eax+28]
	mulss	xmm1, DWORD PTR [edx+60]
	addss	xmm2, xmm0
	movss	xmm0, DWORD PTR [eax+24]
	mulss	xmm0, DWORD PTR [edx+44]
	addss	xmm1, xmm0
	addss	xmm2, xmm1
	movss	DWORD PTR [ecx+28], xmm2

; 94   : 
; 95   : 		m[2][0] = A.m[0][0] * B.m[2][0] + A.m[1][0] * B.m[2][1] + A.m[2][0] * B.m[2][2] + A.m[3][0] * B.m[2][3];

	movss	xmm2, DWORD PTR [edx]
	mulss	xmm2, DWORD PTR [eax+32]
	movss	xmm0, DWORD PTR [eax+36]
	mulss	xmm0, DWORD PTR [edx+16]
	movss	xmm1, DWORD PTR [eax+44]
	mulss	xmm1, DWORD PTR [edx+48]
	addss	xmm2, xmm0
	movss	xmm0, DWORD PTR [eax+40]
	mulss	xmm0, DWORD PTR [edx+32]
	addss	xmm1, xmm0
	addss	xmm2, xmm1
	movss	DWORD PTR [ecx+32], xmm2

; 96   : 		m[2][1] = A.m[0][1] * B.m[2][0] + A.m[1][1] * B.m[2][1] + A.m[2][1] * B.m[2][2] + A.m[3][1] * B.m[2][3];

	movss	xmm2, DWORD PTR [edx+36]
	mulss	xmm2, DWORD PTR [eax+40]
	movss	xmm0, DWORD PTR [eax+44]
	mulss	xmm0, DWORD PTR [edx+52]
	movss	xmm1, DWORD PTR [edx+4]
	mulss	xmm1, DWORD PTR [eax+32]
	addss	xmm2, xmm0
	movss	xmm0, DWORD PTR [edx+20]
	mulss	xmm0, DWORD PTR [eax+36]
	addss	xmm1, xmm0
	addss	xmm2, xmm1
	movss	DWORD PTR [ecx+36], xmm2

; 97   : 		m[2][2] = A.m[0][2] * B.m[2][0] + A.m[1][2] * B.m[2][1] + A.m[2][2] * B.m[2][2] + A.m[3][2] * B.m[2][3];

	movss	xmm2, DWORD PTR [edx+8]
	mulss	xmm2, DWORD PTR [eax+32]
	movss	xmm0, DWORD PTR [edx+24]
	mulss	xmm0, DWORD PTR [eax+36]
	movss	xmm1, DWORD PTR [eax+40]
	mulss	xmm1, DWORD PTR [edx+40]
	addss	xmm2, xmm0
	movss	xmm0, DWORD PTR [eax+44]
	mulss	xmm0, DWORD PTR [edx+56]
	addss	xmm1, xmm0
	addss	xmm2, xmm1
	movss	DWORD PTR [ecx+40], xmm2

; 98   : 		m[2][3] = A.m[0][3] * B.m[2][0] + A.m[1][3] * B.m[2][1] + A.m[2][3] * B.m[2][2] + A.m[3][3] * B.m[2][3];

	movss	xmm2, DWORD PTR [eax+44]
	mulss	xmm2, DWORD PTR [edx+60]
	movss	xmm0, DWORD PTR [eax+40]
	mulss	xmm0, DWORD PTR [edx+44]
	movss	xmm1, DWORD PTR [eax+36]
	mulss	xmm1, DWORD PTR [edx+28]
	addss	xmm2, xmm0
	movss	xmm0, DWORD PTR [eax+32]
	mulss	xmm0, DWORD PTR [edx+12]
	addss	xmm1, xmm0
	addss	xmm2, xmm1
	movss	DWORD PTR [ecx+44], xmm2

; 99   : 
; 100  : 		m[3][0] = A.m[0][0] * B.m[3][0] + A.m[1][0] * B.m[3][1] + A.m[2][0] * B.m[3][2] + A.m[3][0] * B.m[3][3];

	movss	xmm2, DWORD PTR [eax+60]
	mulss	xmm2, DWORD PTR [edx+48]
	movss	xmm0, DWORD PTR [edx+32]
	mulss	xmm0, DWORD PTR [eax+56]
	movss	xmm1, DWORD PTR [eax+48]
	mulss	xmm1, DWORD PTR [edx]
	addss	xmm2, xmm0
	movss	xmm0, DWORD PTR [eax+52]
	mulss	xmm0, DWORD PTR [edx+16]
	addss	xmm1, xmm0
	addss	xmm2, xmm1
	movss	DWORD PTR [ecx+48], xmm2

; 101  : 		m[3][1] = A.m[0][1] * B.m[3][0] + A.m[1][1] * B.m[3][1] + A.m[2][1] * B.m[3][2] + A.m[3][1] * B.m[3][3];

	movss	xmm2, DWORD PTR [eax+48]
	movss	xmm0, DWORD PTR [edx+20]
	mulss	xmm2, DWORD PTR [edx+4]
	mulss	xmm0, DWORD PTR [eax+52]
	movss	xmm1, DWORD PTR [edx+36]
	addss	xmm2, xmm0
	mulss	xmm1, DWORD PTR [eax+56]
	movss	xmm0, DWORD PTR [eax+60]
	mulss	xmm0, DWORD PTR [edx+52]
	addss	xmm1, xmm0
	addss	xmm2, xmm1
	movss	DWORD PTR [ecx+52], xmm2

; 102  : 		m[3][2] = A.m[0][2] * B.m[3][0] + A.m[1][2] * B.m[3][1] + A.m[2][2] * B.m[3][2] + A.m[3][2] * B.m[3][3];

	movss	xmm0, DWORD PTR [eax+48]
	mulss	xmm0, DWORD PTR [edx+8]
	movss	xmm2, DWORD PTR [edx+24]
	mulss	xmm2, DWORD PTR [eax+52]
	movss	xmm1, DWORD PTR [eax+60]
	mulss	xmm1, DWORD PTR [edx+56]
	addss	xmm2, xmm0
	movss	xmm0, DWORD PTR [edx+40]
	mulss	xmm0, DWORD PTR [eax+56]
	addss	xmm1, xmm0
	addss	xmm2, xmm1
	movss	DWORD PTR [ecx+56], xmm2

; 103  : 		m[3][3] = A.m[0][3] * B.m[3][0] + A.m[1][3] * B.m[3][1] + A.m[2][3] * B.m[3][2] + A.m[3][3] * B.m[3][3];

	movss	xmm0, DWORD PTR [eax+52]
	movss	xmm2, DWORD PTR [eax+48]
	mulss	xmm0, DWORD PTR [edx+28]
	mulss	xmm2, DWORD PTR [edx+12]
	movss	xmm1, DWORD PTR [eax+60]
	mulss	xmm1, DWORD PTR [edx+60]
	addss	xmm2, xmm0
	movss	xmm0, DWORD PTR [edx+44]
	mulss	xmm0, DWORD PTR [eax+56]

; 104  : 		return *this;

	mov	eax, ecx
	addss	xmm1, xmm0
	addss	xmm2, xmm1
	movss	DWORD PTR [ecx+60], xmm2

; 105  : 	}

	ret	8
?mul@?$_matrix@M@@QAEAAU1@ABU1@0@Z ENDP			; _matrix<float>::mul
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ??A?$xr_vector@IV?$xalloc@I@@@@QAEAAII@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$xr_vector@IV?$xalloc@I@@@@QAEAAII@Z PROC		; xr_vector<unsigned int,xalloc<unsigned int> >::operator[], COMDAT
; _this$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 119  :         _Ptr += _Off;

	mov	ecx, DWORD PTR [ecx]
	mov	eax, DWORD PTR __Pos$[esp-4]
	lea	eax, DWORD PTR [ecx+eax*4]
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 138  : 	reference operator[]		(size_type _Pos)					{ {VERIFY(_Pos<size());} return (*(begin() + _Pos)); }

	ret	4
??A?$xr_vector@IV?$xalloc@I@@@@QAEAAII@Z ENDP		; xr_vector<unsigned int,xalloc<unsigned int> >::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QBEAAIXZ
_TEXT	SEGMENT
??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QBEAAIXZ PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >::operator*, COMDAT
; _this$ = ecx

; 261  :         return const_cast<reference>(_Mybase::operator*());

	mov	eax, DWORD PTR [ecx]

; 262  :     }

	ret	0
??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QBEAAIXZ ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h
;	COMDAT ?contains@?$_box3@M@@QBEHMMM@Z
_TEXT	SEGMENT
_x$ = 8							; size = 4
_y$ = 12						; size = 4
_z$ = 16						; size = 4
?contains@?$_box3@M@@QBEHMMM@Z PROC			; _box3<float>::contains, COMDAT
; _this$ = ecx

; 49   : 	ICF	BOOL	contains	(T x, T y, T z)		const		{ return (x>=x1) && (x<=x2) && (y>=y1) && (y<=y2) && (z>=z1) && (z<=z2); };

	movss	xmm1, DWORD PTR _x$[esp-4]
	comiss	xmm1, DWORD PTR [ecx]
	jb	SHORT $LN3@contains
	movss	xmm0, DWORD PTR [ecx+12]
	comiss	xmm0, xmm1
	jb	SHORT $LN3@contains
	movss	xmm1, DWORD PTR _y$[esp-4]
	comiss	xmm1, DWORD PTR [ecx+4]
	jb	SHORT $LN3@contains
	movss	xmm0, DWORD PTR [ecx+16]
	comiss	xmm0, xmm1
	jb	SHORT $LN3@contains
	movss	xmm1, DWORD PTR _z$[esp-4]
	comiss	xmm1, DWORD PTR [ecx+8]
	jb	SHORT $LN3@contains
	movss	xmm0, DWORD PTR [ecx+20]
	comiss	xmm0, xmm1
	jb	SHORT $LN3@contains
	mov	eax, 1
	ret	12					; 0000000cH
$LN3@contains:
	xor	eax, eax
	ret	12					; 0000000cH
?contains@?$_box3@M@@QBEHMMM@Z ENDP			; _box3<float>::contains
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
;	COMDAT ?normalize@?$_vector3@M@@QAEAAU1@XZ
_TEXT	SEGMENT
?normalize@?$_vector3@M@@QAEAAU1@XZ PROC		; _vector3<float>::normalize, COMDAT
; _this$ = ecx

; 189  : 		VERIFY(square_magnitude() > std::numeric_limits<T>::min());
; 190  : 		T mag=_sqrt(T(1)/(x*x + y*y + z*z));

	movss	xmm4, DWORD PTR [ecx+4]

; 194  : 		return *this;	

	mov	eax, ecx
	movss	xmm2, DWORD PTR [ecx]
	movaps	xmm0, xmm4
	movss	xmm3, DWORD PTR [ecx+8]
	movaps	xmm1, xmm2
	mulss	xmm0, xmm4
	mulss	xmm1, xmm2
	addss	xmm1, xmm0
	movaps	xmm0, xmm3
	mulss	xmm0, xmm3
	addss	xmm1, xmm0
	movss	xmm0, DWORD PTR __real@3f800000
	divss	xmm0, xmm1
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h

; 764  :             return (float)sqrt(_X);

	sqrtss	xmm0, xmm0
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 191  : 		x *= mag;

	mulss	xmm2, xmm0

; 192  : 		y *= mag;

	mulss	xmm4, xmm0

; 193  : 		z *= mag;

	mulss	xmm3, xmm0
	movss	DWORD PTR [ecx], xmm2
	movss	DWORD PTR [ecx+4], xmm4
	movss	DWORD PTR [ecx+8], xmm3

; 195  : 	}

	ret	0
?normalize@?$_vector3@M@@QAEAAU1@XZ ENDP		; _vector3<float>::normalize
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QBEABIXZ
_TEXT	SEGMENT
??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QBEABIXZ PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >::operator*, COMDAT
; _this$ = ecx

; 46   : #if _ITERATOR_DEBUG_LEVEL != 0
; 47   :         const auto _Mycont = static_cast<const _Myvec*>(this->_Getcont());
; 48   :         _STL_VERIFY(_Ptr, "can't dereference value-initialized vector iterator");
; 49   :         _STL_VERIFY(
; 50   :             _Mycont->_Myfirst <= _Ptr && _Ptr < _Mycont->_Mylast, "can't dereference out of range vector iterator");
; 51   : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 52   : 
; 53   :         return *_Ptr;

	mov	eax, DWORD PTR [ecx]

; 54   :     }

	ret	0
??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QBEABIXZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
;	COMDAT ??$xr_alloc@VoccTri@@@@YAPAVoccTri@@I@Z
_TEXT	SEGMENT
??$xr_alloc@VoccTri@@@@YAPAVoccTri@@I@Z PROC		; xr_alloc<occTri>, COMDAT
; _count$ = ecx

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	imul	eax, ecx, 88
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
	ret	0
??$xr_alloc@VoccTri@@@@YAPAVoccTri@@I@Z ENDP		; xr_alloc<occTri>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
;	COMDAT ??$xr_new@VMODEL@CDB@@@@YAPAVMODEL@CDB@@XZ
_TEXT	SEGMENT
??$xr_new@VMODEL@CDB@@@@YAPAVMODEL@CDB@@XZ PROC		; xr_new<CDB::MODEL>, COMDAT

; 68   : 	T* ptr	= (T*)Memory.mem_alloc(sizeof(T));

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	28					; 0000001cH
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z

; 69   : 	return new (ptr) T();

	mov	ecx, eax
	jmp	DWORD PTR __imp_??0MODEL@CDB@@QAE@XZ
??$xr_new@VMODEL@CDB@@@@YAPAVMODEL@CDB@@XZ ENDP		; xr_new<CDB::MODEL>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
;	COMDAT ??$xr_delete@VMODEL@CDB@@@@YAXAAPAVMODEL@CDB@@@Z
_TEXT	SEGMENT
??$xr_delete@VMODEL@CDB@@@@YAXAAPAVMODEL@CDB@@@Z PROC	; xr_delete<CDB::MODEL>, COMDAT
; _ptr$ = ecx

; 150  : {

	push	esi
	mov	esi, ecx

; 151  : 	if (ptr) 

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN2@xr_delete
	call	DWORD PTR __imp_??1MODEL@CDB@@QAE@XZ

; 144  : 		Memory.mem_free	(ptr);

	push	DWORD PTR [esi]
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z

; 152  : 	{
; 153  : 		xr_special_free<is_polymorphic<T>::result,T>()(ptr);
; 154  : 		ptr = nullptr;

	mov	DWORD PTR [esi], 0
$LN2@xr_delete:

; 155  : 	}
; 156  : }

	pop	esi
	ret	0
??$xr_delete@VMODEL@CDB@@@@YAXAAPAVMODEL@CDB@@@Z ENDP	; xr_delete<CDB::MODEL>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
;	COMDAT ??$xr_free@VoccTri@@@@YAXAAPAVoccTri@@@Z
_TEXT	SEGMENT
??$xr_free@VoccTri@@@@YAXAAPAVoccTri@@@Z PROC		; xr_free<occTri>, COMDAT
; _P$ = ecx

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	push	esi
	mov	esi, ecx
	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN2@xr_free
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
	mov	DWORD PTR [esi], 0
$LN2@xr_free:
	pop	esi
	ret	0
??$xr_free@VoccTri@@@@YAXAAPAVoccTri@@@Z ENDP		; xr_free<occTri>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$remove_if@PAURESULT@CDB@@Vpred_fb@@@std@@YAPAURESULT@CDB@@PAU12@QAU12@Vpred_fb@@@Z
_TEXT	SEGMENT
__Pred$ = 8						; size = 16
??$remove_if@PAURESULT@CDB@@Vpred_fb@@@std@@YAPAURESULT@CDB@@PAU12@QAU12@Vpred_fb@@@Z PROC ; std::remove_if<CDB::RESULT *,pred_fb>, COMDAT
; __First$ = ecx
; __Last$ = edx

; 1976 : _NODISCARD _CONSTEXPR20 _FwdIt remove_if(_FwdIt _First, const _FwdIt _Last, _Pr _Pred) {

	push	ebx
	push	ebp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility

; 5531 :     for (; _UFirst != _ULast; ++_UFirst) {

	mov	ebp, DWORD PTR __Pred$[esp+4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1976 : _NODISCARD _CONSTEXPR20 _FwdIt remove_if(_FwdIt _First, const _FwdIt _Last, _Pr _Pred) {

	mov	ebx, edx
	mov	eax, ecx
	push	esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility

; 5531 :     for (; _UFirst != _ULast; ++_UFirst) {

	mov	esi, DWORD PTR __imp_?Device@@3VCRenderDevice@@A
	cmp	eax, ebx
	je	SHORT $LN3@remove_if
	mov	edx, DWORD PTR [esi+244]
	npad	5
$LL12@remove_if:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp

; 143  : 		occTri&	T	= m_pTris	[_1.id];

	imul	ecx, DWORD PTR [eax+40], 88

; 144  : 		return	T.skip>Device.dwFrame;

	cmp	DWORD PTR [ecx+ebp+72], edx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility

; 5532 :         if (_Pred(*_UFirst)) {

	ja	SHORT $LN31@remove_if

; 5531 :     for (; _UFirst != _ULast; ++_UFirst) {

	add	eax, 56					; 00000038H
	cmp	eax, ebx
	jne	SHORT $LL12@remove_if
$LN31@remove_if:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1983 :     if (_UFirst != _ULast) {

	cmp	eax, ebx
	je	SHORT $LN3@remove_if

; 1984 :         while (++_UFirst != _ULast) {

	lea	edx, DWORD PTR [eax+56]
	cmp	edx, ebx
	je	SHORT $LN3@remove_if
	push	edi
	npad	3
$LL2@remove_if:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp

; 143  : 		occTri&	T	= m_pTris	[_1.id];

	imul	ecx, DWORD PTR [edx+40], 88

; 144  : 		return	T.skip>Device.dwFrame;

	mov	ecx, DWORD PTR [ecx+ebp+72]
	cmp	ecx, DWORD PTR [esi+244]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1985 :             if (!_Pred(*_UFirst)) {

	ja	SHORT $LN5@remove_if

; 1986 :                 *_UNext = _STD move(*_UFirst);

	mov	edi, eax
	mov	ecx, 14					; 0000000eH
	mov	esi, edx

; 1987 :                 ++_UNext;

	add	eax, 56					; 00000038H
	rep movsd
	mov	esi, DWORD PTR __imp_?Device@@3VCRenderDevice@@A
$LN5@remove_if:

; 1984 :         while (++_UFirst != _ULast) {

	add	edx, 56					; 00000038H
	cmp	edx, ebx
	jne	SHORT $LL2@remove_if

; 1988 :             }
; 1989 :         }
; 1990 :     }
; 1991 : 
; 1992 :     _Seek_wrapped(_First, _UNext);
; 1993 :     return _First;

	pop	edi
$LN3@remove_if:
	pop	esi

; 1994 : }

	pop	ebp
	pop	ebx
	ret	0
??$remove_if@PAURESULT@CDB@@Vpred_fb@@@std@@YAPAURESULT@CDB@@PAU12@QAU12@Vpred_fb@@@Z ENDP ; std::remove_if<CDB::RESULT *,pred_fb>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_Get_unwrapped@AAPAURESULT@CDB@@@std@@YA?A_TAAPAURESULT@CDB@@@Z
_TEXT	SEGMENT
??$_Get_unwrapped@AAPAURESULT@CDB@@@std@@YA?A_TAAPAURESULT@CDB@@@Z PROC ; std::_Get_unwrapped<CDB::RESULT * &>, COMDAT
; __It$ = ecx

; 1275 :     // unwrap an iterator previously subjected to _Adl_verify_range or otherwise validated
; 1276 :     if constexpr (is_pointer_v<decay_t<_Iter>>) { // special-case pointers and arrays
; 1277 :         return _It + 0;

	mov	eax, DWORD PTR [ecx]

; 1278 :     } else if constexpr (_Unwrappable_v<_Iter>) {
; 1279 :         return static_cast<_Iter&&>(_It)._Unwrapped();
; 1280 :     } else {
; 1281 :         return static_cast<_Iter&&>(_It);
; 1282 :     }
; 1283 : }

	ret	0
??$_Get_unwrapped@AAPAURESULT@CDB@@@std@@YA?A_TAAPAURESULT@CDB@@@Z ENDP ; std::_Get_unwrapped<CDB::RESULT * &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_Get_unwrapped@ABQAURESULT@CDB@@@std@@YA?A_TABQAURESULT@CDB@@@Z
_TEXT	SEGMENT
??$_Get_unwrapped@ABQAURESULT@CDB@@@std@@YA?A_TABQAURESULT@CDB@@@Z PROC ; std::_Get_unwrapped<CDB::RESULT * const &>, COMDAT
; __It$ = ecx

; 1275 :     // unwrap an iterator previously subjected to _Adl_verify_range or otherwise validated
; 1276 :     if constexpr (is_pointer_v<decay_t<_Iter>>) { // special-case pointers and arrays
; 1277 :         return _It + 0;

	mov	eax, DWORD PTR [ecx]

; 1278 :     } else if constexpr (_Unwrappable_v<_Iter>) {
; 1279 :         return static_cast<_Iter&&>(_It)._Unwrapped();
; 1280 :     } else {
; 1281 :         return static_cast<_Iter&&>(_It);
; 1282 :     }
; 1283 : }

	ret	0
??$_Get_unwrapped@ABQAURESULT@CDB@@@std@@YA?A_TABQAURESULT@CDB@@@Z ENDP ; std::_Get_unwrapped<CDB::RESULT * const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
;	COMDAT ??$sort@PAURESULT@CDB@@Vpred_fb@@@std@@YAXQAURESULT@CDB@@0Vpred_fb@@@Z
_TEXT	SEGMENT
__Pred$ = 8						; size = 16
??$sort@PAURESULT@CDB@@Vpred_fb@@@std@@YAXQAURESULT@CDB@@0Vpred_fb@@@Z PROC ; std::sort<CDB::RESULT *,pred_fb>, COMDAT
; __First$ = ecx
; __Last$ = edx

; 7076 : _CONSTEXPR20 void sort(const _RanIt _First, const _RanIt _Last, _Pr _Pred) { // order [_First, _Last)

	push	ecx

; 7077 :     _Adl_verify_range(_First, _Last);
; 7078 :     const auto _UFirst = _Get_unwrapped(_First);
; 7079 :     const auto _ULast  = _Get_unwrapped(_Last);
; 7080 :     _Sort_unchecked(_UFirst, _ULast, _ULast - _UFirst, _Pass_fn(_Pred));

	lea	eax, DWORD PTR __Pred$[esp]
	push	eax
	mov	eax, edx
	sub	eax, ecx
	sar	eax, 3
	imul	eax, eax, -1227133513
	push	eax
	call	??$_Sort_unchecked@PAURESULT@CDB@@U?$_Ref_fn@Vpred_fb@@@std@@@std@@YAXPAURESULT@CDB@@0HU?$_Ref_fn@Vpred_fb@@@0@@Z ; std::_Sort_unchecked<CDB::RESULT *,std::_Ref_fn<pred_fb> >
	add	esp, 8

; 7081 : }

	pop	ecx
	ret	0
??$sort@PAURESULT@CDB@@Vpred_fb@@@std@@YAXQAURESULT@CDB@@0Vpred_fb@@@Z ENDP ; std::sort<CDB::RESULT *,pred_fb>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
;	COMDAT ??R?$xr_special_free@$0A@VMODEL@CDB@@@@QAEXAAPAVMODEL@CDB@@@Z
_TEXT	SEGMENT
_ptr$ = 8						; size = 4
??R?$xr_special_free@$0A@VMODEL@CDB@@@@QAEXAAPAVMODEL@CDB@@@Z PROC ; xr_special_free<0,CDB::MODEL>::operator(), COMDAT
; _this$dead$ = ecx

; 142  : 	{

	push	esi

; 143  : 		ptr->~T			();

	mov	esi, DWORD PTR _ptr$[esp]
	mov	ecx, DWORD PTR [esi]
	call	DWORD PTR __imp_??1MODEL@CDB@@QAE@XZ

; 144  : 		Memory.mem_free	(ptr);

	push	DWORD PTR [esi]
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
	pop	esi

; 145  : 	}

	ret	4
??R?$xr_special_free@$0A@VMODEL@CDB@@@@QAEXAAPAVMODEL@CDB@@@Z ENDP ; xr_special_free<0,CDB::MODEL>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ??_GMODEL@CDB@@QAEPAXI@Z
_TEXT	SEGMENT
___flags$dead$ = 8					; size = 4
??_GMODEL@CDB@@QAEPAXI@Z PROC				; CDB::MODEL::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	call	DWORD PTR __imp_??1MODEL@CDB@@QAE@XZ
	mov	eax, esi
	pop	esi
	ret	4
??_GMODEL@CDB@@QAEPAXI@Z ENDP				; CDB::MODEL::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_Adl_verify_range@PAURESULT@CDB@@PAU12@@std@@YAXABQAURESULT@CDB@@0@Z
_TEXT	SEGMENT
??$_Adl_verify_range@PAURESULT@CDB@@PAU12@@std@@YAXABQAURESULT@CDB@@0@Z PROC ; std::_Adl_verify_range<CDB::RESULT *,CDB::RESULT *>, COMDAT
; __First$dead$ = ecx
; __Last$dead$ = edx

; 1259 :     // check that [_First, _Last) forms an iterator range
; 1260 :     if constexpr (_Range_verifiable_v<_Iter, _Sentinel>) {
; 1261 :         _Verify_range(_First, _Last);
; 1262 :     }
; 1263 : }

	ret	0
??$_Adl_verify_range@PAURESULT@CDB@@PAU12@@std@@YAXABQAURESULT@CDB@@0@Z ENDP ; std::_Adl_verify_range<CDB::RESULT *,CDB::RESULT *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_Pass_fn@Vpred_fb@@$0A@@std@@YA?AU?$_Ref_fn@Vpred_fb@@@0@AAVpred_fb@@@Z
_TEXT	SEGMENT
??$_Pass_fn@Vpred_fb@@$0A@@std@@YA?AU?$_Ref_fn@Vpred_fb@@@0@AAVpred_fb@@@Z PROC ; std::_Pass_fn<pred_fb,0>, COMDAT
; ___$ReturnUdt$ = ecx
; __Val$ = edx

; 258  :     return {_Val};

	mov	DWORD PTR [ecx], edx
	mov	eax, ecx

; 259  : }

	ret	0
??$_Pass_fn@Vpred_fb@@$0A@@std@@YA?AU?$_Ref_fn@Vpred_fb@@@0@AAVpred_fb@@@Z ENDP ; std::_Pass_fn<pred_fb,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$find_if@PAURESULT@CDB@@U?$_Ref_fn@Vpred_fb@@@std@@@std@@YAPAURESULT@CDB@@PAU12@QAU12@U?$_Ref_fn@Vpred_fb@@@0@@Z
_TEXT	SEGMENT
__Pred$ = 8						; size = 4
??$find_if@PAURESULT@CDB@@U?$_Ref_fn@Vpred_fb@@@std@@@std@@YAPAURESULT@CDB@@PAU12@QAU12@U?$_Ref_fn@Vpred_fb@@@0@@Z PROC ; std::find_if<CDB::RESULT *,std::_Ref_fn<pred_fb> >, COMDAT
; __First$ = ecx
; __Last$ = edx

; 5528 :     _Adl_verify_range(_First, _Last);
; 5529 :     auto _UFirst      = _Get_unwrapped(_First);
; 5530 :     const auto _ULast = _Get_unwrapped(_Last);
; 5531 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	ecx, edx
	je	SHORT $LN17@find_if
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp

; 143  : 		occTri&	T	= m_pTris	[_1.id];

	mov	eax, DWORD PTR __Pred$[esp-4]
	push	esi
	push	edi
	mov	esi, DWORD PTR [eax]
	mov	eax, DWORD PTR __imp_?Device@@3VCRenderDevice@@A
	mov	edi, DWORD PTR [eax+244]
	npad	9
$LL4@find_if:
	imul	eax, DWORD PTR [ecx+40], 88

; 144  : 		return	T.skip>Device.dwFrame;

	cmp	DWORD PTR [eax+esi+72], edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility

; 5532 :         if (_Pred(*_UFirst)) {

	ja	SHORT $LN16@find_if

; 5528 :     _Adl_verify_range(_First, _Last);
; 5529 :     auto _UFirst      = _Get_unwrapped(_First);
; 5530 :     const auto _ULast = _Get_unwrapped(_Last);
; 5531 :     for (; _UFirst != _ULast; ++_UFirst) {

	add	ecx, 56					; 00000038H
	cmp	ecx, edx
	jne	SHORT $LL4@find_if
$LN16@find_if:
	pop	edi

; 5533 :             break;
; 5534 :         }
; 5535 :     }
; 5536 : 
; 5537 :     _Seek_wrapped(_First, _UFirst);
; 5538 :     return _First;

	mov	eax, ecx
	pop	esi

; 5539 : }

	ret	0
$LN17@find_if:

; 5533 :             break;
; 5534 :         }
; 5535 :     }
; 5536 : 
; 5537 :     _Seek_wrapped(_First, _UFirst);
; 5538 :     return _First;

	mov	eax, ecx

; 5539 : }

	ret	0
??$find_if@PAURESULT@CDB@@U?$_Ref_fn@Vpred_fb@@@std@@@std@@YAPAURESULT@CDB@@PAU12@QAU12@U?$_Ref_fn@Vpred_fb@@@0@@Z ENDP ; std::find_if<CDB::RESULT *,std::_Ref_fn<pred_fb> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$?RAAURESULT@CDB@@@?$_Ref_fn@Vpred_fb@@@std@@QAE?A_TAAURESULT@CDB@@@Z
_TEXT	SEGMENT
_<_Vals_0>$ = 8						; size = 4
??$?RAAURESULT@CDB@@@?$_Ref_fn@Vpred_fb@@@std@@QAE?A_TAAURESULT@CDB@@@Z PROC ; std::_Ref_fn<pred_fb>::operator()<CDB::RESULT &>, COMDAT
; _this$ = ecx
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp

; 143  : 		occTri&	T	= m_pTris	[_1.id];

	mov	eax, DWORD PTR _<_Vals_0>$[esp-4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility

; 236  :     constexpr decltype(auto) operator()(_Args&&... _Vals) { // forward function call operator

	mov	edx, ecx
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp

; 143  : 		occTri&	T	= m_pTris	[_1.id];

	imul	ecx, DWORD PTR [eax+40], 88
	mov	eax, DWORD PTR [edx]

; 144  : 		return	T.skip>Device.dwFrame;

	mov	eax, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+eax+72]
	mov	eax, DWORD PTR __imp_?Device@@3VCRenderDevice@@A
	cmp	ecx, DWORD PTR [eax+244]
	seta	al
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility

; 242  :     }

	ret	4
??$?RAAURESULT@CDB@@@?$_Ref_fn@Vpred_fb@@@std@@QAE?A_TAAURESULT@CDB@@@Z ENDP ; std::_Ref_fn<pred_fb>::operator()<CDB::RESULT &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_Seek_wrapped@PAURESULT@CDB@@AAPAU12@@std@@YAXAAPAURESULT@CDB@@0@Z
_TEXT	SEGMENT
??$_Seek_wrapped@PAURESULT@CDB@@AAPAU12@@std@@YAXAAPAURESULT@CDB@@0@Z PROC ; std::_Seek_wrapped<CDB::RESULT *,CDB::RESULT * &>, COMDAT
; __It$ = ecx
; __UIt$ = edx

; 1375 :     if constexpr (_Wrapped_seekable_v<_Iter, _UIter>) {
; 1376 :         _It._Seek_to(_STD forward<_UIter>(_UIt));
; 1377 :     } else {
; 1378 :         _It = _STD forward<_UIter>(_UIt);

	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax

; 1379 :     }
; 1380 : }

	ret	0
??$_Seek_wrapped@PAURESULT@CDB@@AAPAU12@@std@@YAXAAPAURESULT@CDB@@0@Z ENDP ; std::_Seek_wrapped<CDB::RESULT *,CDB::RESULT * &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
;	COMDAT ??$_Sort_unchecked@PAURESULT@CDB@@U?$_Ref_fn@Vpred_fb@@@std@@@std@@YAXPAURESULT@CDB@@0HU?$_Ref_fn@Vpred_fb@@@0@@Z
_TEXT	SEGMENT
tv1293 = -92						; size = 4
$T1 = -88						; size = 4
__First$1$ = -84					; size = 4
__Last$1$ = -80						; size = 4
__Mid$1$ = -76						; size = 4
__Hole$1$ = -72						; size = 4
tv1313 = -68						; size = 4
__Mid$2 = -68						; size = 8
__Val$3 = -60						; size = 56
__Val$4 = -60						; size = 56
__Ideal$ = 8						; size = 4
__Pred$ = 12						; size = 4
??$_Sort_unchecked@PAURESULT@CDB@@U?$_Ref_fn@Vpred_fb@@@std@@@std@@YAXPAURESULT@CDB@@0HU?$_Ref_fn@Vpred_fb@@@0@@Z PROC ; std::_Sort_unchecked<CDB::RESULT *,std::_Ref_fn<pred_fb> >, COMDAT
; __First$ = ecx
; __Last$ = edx

; 7046 : _CONSTEXPR20 void _Sort_unchecked(_RanIt _First, _RanIt _Last, _Iter_diff_t<_RanIt> _Ideal, _Pr _Pred) {

	sub	esp, 92					; 0000005cH
	push	ebx
	push	ebp
	mov	ebp, edx
	mov	ebx, ecx

; 7047 :     // order [_First, _Last)
; 7048 :     for (;;) {
; 7049 :         if (_Last - _First <= _ISORT_MAX) { // small

	mov	eax, ebp
	mov	DWORD PTR __Last$1$[esp+100], ebp
	sub	eax, ebx
	mov	DWORD PTR __First$1$[esp+100], ebx
	push	esi
	push	edi
	cmp	eax, 1848				; 00000738H
	jl	$LN286@Sort_unche
	mov	esi, DWORD PTR __Ideal$[esp+104]
	npad	10
$LL2@Sort_unche:

; 7050 :             _Insertion_sort_unchecked(_First, _Last, _Pred);
; 7051 :             return;
; 7052 :         }
; 7053 : 
; 7054 :         if (_Ideal <= 0) { // heap sort if too many divisions

	push	DWORD PTR __Pred$[esp+104]
	test	esi, esi
	jle	$LN287@Sort_unche

; 7056 :             _Sort_heap_unchecked(_First, _Last, _Pred);
; 7057 :             return;
; 7058 :         }
; 7059 : 
; 7060 :         // divide and conquer by quicksort
; 7061 :         auto _Mid = _Partition_by_median_guess_unchecked(_First, _Last, _Pred);

	push	ebp
	mov	edx, ebx
	lea	ecx, DWORD PTR __Mid$2[esp+116]
	call	??$_Partition_by_median_guess_unchecked@PAURESULT@CDB@@U?$_Ref_fn@Vpred_fb@@@std@@@std@@YA?AU?$pair@PAURESULT@CDB@@PAU12@@0@PAURESULT@CDB@@0U?$_Ref_fn@Vpred_fb@@@0@@Z ; std::_Partition_by_median_guess_unchecked<CDB::RESULT *,std::_Ref_fn<pred_fb> >

; 7062 : 
; 7063 :         _Ideal = (_Ideal >> 1) + (_Ideal >> 2); // allow 1.5 log2(N) divisions
; 7064 : 
; 7065 :         if (_Mid.first - _First < _Last - _Mid.second) { // loop on second half

	mov	edi, DWORD PTR __Mid$2[esp+120]
	mov	eax, esi
	mov	edx, DWORD PTR __Mid$2[esp+116]
	add	esp, 8
	sar	eax, 2
	sar	esi, 1
	add	esi, eax
	mov	eax, ebp
	push	DWORD PTR __Pred$[esp+104]
	sub	eax, edi
	sar	eax, 3
	imul	ecx, eax, -1227133513
	mov	eax, edx
	sub	eax, ebx
	sar	eax, 3
	imul	eax, eax, -1227133513
	push	esi
	cmp	eax, ecx
	jge	SHORT $LN7@Sort_unche

; 7066 :             _Sort_unchecked(_First, _Mid.first, _Ideal, _Pred);

	mov	ecx, ebx
	call	??$_Sort_unchecked@PAURESULT@CDB@@U?$_Ref_fn@Vpred_fb@@@std@@@std@@YAXPAURESULT@CDB@@0HU?$_Ref_fn@Vpred_fb@@@0@@Z ; std::_Sort_unchecked<CDB::RESULT *,std::_Ref_fn<pred_fb> >

; 7067 :             _First = _Mid.second;

	mov	ebx, edi
	mov	DWORD PTR __First$1$[esp+116], ebx

; 7068 :         } else { // loop on first half

	jmp	SHORT $LN301@Sort_unche
$LN7@Sort_unche:

; 7069 :             _Sort_unchecked(_Mid.second, _Last, _Ideal, _Pred);

	mov	edx, ebp
	mov	ecx, edi
	call	??$_Sort_unchecked@PAURESULT@CDB@@U?$_Ref_fn@Vpred_fb@@@std@@@std@@YAXPAURESULT@CDB@@0HU?$_Ref_fn@Vpred_fb@@@0@@Z ; std::_Sort_unchecked<CDB::RESULT *,std::_Ref_fn<pred_fb> >

; 7070 :             _Last = _Mid.first;

	mov	ebp, DWORD PTR __Mid$2[esp+116]
	mov	DWORD PTR __Last$1$[esp+116], ebp
$LN301@Sort_unche:

; 7047 :     // order [_First, _Last)
; 7048 :     for (;;) {
; 7049 :         if (_Last - _First <= _ISORT_MAX) { // small

	mov	eax, ebp
	add	esp, 8
	sub	eax, ebx
	cmp	eax, 1848				; 00000738H
	jge	SHORT $LL2@Sort_unche
$LN286@Sort_unche:

; 6921 :     if (_First != _Last) {

	cmp	ebx, ebp
	je	$LN49@Sort_unche

; 6922 :         for (_BidIt _Mid = _First; ++_Mid != _Last;) { // order next element

	lea	edx, DWORD PTR [ebx+56]
	mov	DWORD PTR __Mid$1$[esp+108], edx
	cmp	edx, ebp
	je	$LN49@Sort_unche
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility

; 240  :             return _Fn(_STD forward<_Args>(_Vals)...);

	mov	eax, DWORD PTR __Pred$[esp+104]
	mov	DWORD PTR $T1[esp+108], eax
	mov	eax, edx
	sub	eax, ebx
	mov	DWORD PTR tv1293[esp+108], eax
	npad	12
$LL11@Sort_unche:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp

; 139  : 		occTri&	t1	= m_pTris	[_2.id];

	imul	eax, DWORD PTR [ebx+40], 88
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 6924 :             _Iter_value_t<_BidIt> _Val = _STD move(*_Mid);

	lea	edi, DWORD PTR __Val$4[esp+108]
	mov	ecx, 14					; 0000000eH
	mov	DWORD PTR __Hole$1$[esp+108], edx
	mov	esi, edx
	rep movsd
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp

; 138  : 		occTri&	t0	= m_pTris	[_1.id];

	imul	edi, DWORD PTR __Val$4[esp+148], 88

; 140  : 		return	camera.distance_to_sqr(t0.center) < camera.distance_to_sqr(t1.center);

	mov	esi, DWORD PTR $T1[esp+108]
	mov	ecx, DWORD PTR [esi]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 287  : 	{	return (x-v.x)*(x-v.x) + (y-v.y)*(y-v.y) + (z-v.z)*(z-v.z);	}

	movss	xmm5, DWORD PTR [esi+8]
	movss	xmm4, DWORD PTR [esi+4]
	movaps	xmm1, xmm5
	movss	xmm2, DWORD PTR [esi+12]
	movaps	xmm3, xmm4
	subss	xmm3, DWORD PTR [ecx+edi+76]
	subss	xmm4, DWORD PTR [eax+ecx+76]
	subss	xmm1, DWORD PTR [ecx+edi+80]
	subss	xmm5, DWORD PTR [eax+ecx+80]
	movaps	xmm0, xmm2
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp

; 138  : 		occTri&	t0	= m_pTris	[_1.id];

	mov	DWORD PTR tv1313[esp+108], edi
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 287  : 	{	return (x-v.x)*(x-v.x) + (y-v.y)*(y-v.y) + (z-v.z)*(z-v.z);	}

	subss	xmm0, DWORD PTR [ecx+edi+84]
	subss	xmm2, DWORD PTR [eax+ecx+84]
	mulss	xmm3, xmm3
	mulss	xmm4, xmm4
	mulss	xmm1, xmm1
	mulss	xmm5, xmm5
	addss	xmm3, xmm1
	mulss	xmm0, xmm0
	addss	xmm4, xmm5
	mulss	xmm2, xmm2
	addss	xmm3, xmm0
	addss	xmm4, xmm2
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp

; 140  : 		return	camera.distance_to_sqr(t0.center) < camera.distance_to_sqr(t1.center);

	comiss	xmm4, xmm3
	jbe	$LN18@Sort_unche
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility

; 4255 :     auto _Result                = _CSTD memmove(_Dest_ch - _Count, _First_ch, _Count);

	mov	ecx, DWORD PTR tv1293[esp+108]
	mov	eax, edx
	push	ecx
	sub	eax, ecx
	add	eax, 56					; 00000038H
	push	ebx
	push	eax
	call	_memmove
	add	esp, 12					; 0000000cH
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 6928 :                 *_First = _STD move(_Val);

	mov	edi, ebx

; 6929 :             } else { // look for insertion point after first

	jmp	$LN302@Sort_unche
$LN287@Sort_unche:

; 7055 :             _Make_heap_unchecked(_First, _Last, _Pred);

	mov	edx, ebp
	mov	ecx, ebx
	call	??$_Make_heap_unchecked@PAURESULT@CDB@@U?$_Ref_fn@Vpred_fb@@@std@@@std@@YAXPAURESULT@CDB@@0U?$_Ref_fn@Vpred_fb@@@0@@Z ; std::_Make_heap_unchecked<CDB::RESULT *,std::_Ref_fn<pred_fb> >

; 5774 :     for (; _Last - _First >= 2; --_Last) {

	mov	esi, ebp

; 7055 :             _Make_heap_unchecked(_First, _Last, _Pred);

	add	esp, 4

; 5774 :     for (; _Last - _First >= 2; --_Last) {

	sub	esi, ebx
	cmp	esi, 112				; 00000070H
	jl	$LN49@Sort_unche

; 7055 :             _Make_heap_unchecked(_First, _Last, _Pred);

	add	ebp, -56				; ffffffc8H
	npad	6
$LL50@Sort_unche:

; 5417 :     if (2 <= _Last - _First) {

	mov	eax, 613566757				; 24924925H
	mul	esi
	sub	esi, edx
	shr	esi, 1
	add	esi, edx
	shr	esi, 5
	cmp	esi, 2
	mov	esi, ebp
	jl	SHORT $LN300@Sort_unche

; 5418 :         --_Last;
; 5419 :         _Iter_value_t<_RanIt> _Val = _STD move(*_Last);

	mov	ecx, 14					; 0000000eH
	lea	edi, DWORD PTR __Val$3[esp+108]
	rep movsd

; 5408 :     *_Dest      = _STD move(*_First);

	mov	ecx, 14					; 0000000eH

; 5409 :     using _Diff = _Iter_diff_t<_RanIt>;
; 5410 :     _Pop_heap_hole_by_index(

	lea	eax, DWORD PTR __Val$3[esp+108]
	mov	esi, ebx
	mov	edi, ebp
	rep movsd
	push	DWORD PTR __Pred$[esp+104]
	mov	esi, ebp
	xor	edx, edx
	push	eax
	sub	esi, ebx
	mov	ecx, ebx
	mov	eax, esi
	sar	eax, 3
	imul	eax, eax, -1227133513
	push	eax
	call	??$_Pop_heap_hole_by_index@PAURESULT@CDB@@U12@U?$_Ref_fn@Vpred_fb@@@std@@@std@@YAXPAURESULT@CDB@@HH$$QAU12@U?$_Ref_fn@Vpred_fb@@@0@@Z ; std::_Pop_heap_hole_by_index<CDB::RESULT *,CDB::RESULT,std::_Ref_fn<pred_fb> >
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN48@Sort_unche
$LN300@Sort_unche:
	sub	esi, ebx
$LN48@Sort_unche:

; 5774 :     for (; _Last - _First >= 2; --_Last) {

	sub	ebp, 56					; 00000038H
	cmp	esi, 112				; 00000070H
	jge	SHORT $LL50@Sort_unche

; 7071 :         }
; 7072 :     }
; 7073 : }

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 92					; 0000005cH
	ret	0
$LN18@Sort_unche:
	mov	edi, DWORD PTR __Hole$1$[esp+108]
	mov	ebp, esi
	mov	ebx, DWORD PTR tv1313[esp+108]
$LL16@Sort_unche:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp

; 139  : 		occTri&	t1	= m_pTris	[_2.id];

	imul	eax, DWORD PTR [edx-16], 88
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 6930 :                 for (_BidIt _Prev = _Hole; _DEBUG_LT_PRED(_Pred, _Val, *--_Prev); _Hole = _Prev) {

	sub	edx, 56					; 00000038H
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp

; 140  : 		return	camera.distance_to_sqr(t0.center) < camera.distance_to_sqr(t1.center);

	mov	ecx, DWORD PTR [ebp]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 287  : 	{	return (x-v.x)*(x-v.x) + (y-v.y)*(y-v.y) + (z-v.z)*(z-v.z);	}

	movss	xmm5, DWORD PTR [ebp+8]
	movss	xmm4, DWORD PTR [ebp+4]
	movaps	xmm1, xmm5
	movss	xmm2, DWORD PTR [ebp+12]
	movaps	xmm3, xmm4
	subss	xmm3, DWORD PTR [ecx+ebx+76]
	subss	xmm1, DWORD PTR [ecx+ebx+80]
	movaps	xmm0, xmm2
	subss	xmm4, DWORD PTR [eax+ecx+76]
	subss	xmm5, DWORD PTR [eax+ecx+80]
	subss	xmm0, DWORD PTR [ecx+ebx+84]
	subss	xmm2, DWORD PTR [eax+ecx+84]
	mulss	xmm3, xmm3
	mulss	xmm4, xmm4
	mulss	xmm1, xmm1
	mulss	xmm5, xmm5
	addss	xmm3, xmm1
	mulss	xmm0, xmm0
	addss	xmm4, xmm5
	mulss	xmm2, xmm2
	addss	xmm3, xmm0
	addss	xmm4, xmm2
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp

; 140  : 		return	camera.distance_to_sqr(t0.center) < camera.distance_to_sqr(t1.center);

	comiss	xmm4, xmm3
	jbe	SHORT $LN41@Sort_unche
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 6931 :                     *_Hole = _STD move(*_Prev); // move hole down

	mov	ecx, 14					; 0000000eH
	mov	esi, edx
	rep movsd
	mov	edi, edx
	jmp	SHORT $LL16@Sort_unche
$LN41@Sort_unche:
	mov	ebx, DWORD PTR __First$1$[esp+108]
	mov	ebp, DWORD PTR __Last$1$[esp+108]
$LN302@Sort_unche:

; 6922 :         for (_BidIt _Mid = _First; ++_Mid != _Last;) { // order next element

	mov	edx, DWORD PTR __Mid$1$[esp+108]
	lea	esi, DWORD PTR __Val$4[esp+108]
	add	DWORD PTR tv1293[esp+108], 56		; 00000038H
	add	edx, 56					; 00000038H
	mov	DWORD PTR __Mid$1$[esp+108], edx
	mov	ecx, 14					; 0000000eH
	rep movsd
	cmp	edx, ebp
	jne	$LL11@Sort_unche
$LN49@Sort_unche:

; 7071 :         }
; 7072 :     }
; 7073 : }

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 92					; 0000005cH
	ret	0
??$_Sort_unchecked@PAURESULT@CDB@@U?$_Ref_fn@Vpred_fb@@@std@@@std@@YAXPAURESULT@CDB@@0HU?$_Ref_fn@Vpred_fb@@@0@@Z ENDP ; std::_Sort_unchecked<CDB::RESULT *,std::_Ref_fn<pred_fb> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\type_traits
;	COMDAT ??$forward@AAURESULT@CDB@@@std@@YAAAURESULT@CDB@@AAU12@@Z
_TEXT	SEGMENT
??$forward@AAURESULT@CDB@@@std@@YAAAURESULT@CDB@@AAU12@@Z PROC ; std::forward<CDB::RESULT &>, COMDAT
; __Arg$ = ecx

; 1386 :     return static_cast<_Ty&&>(_Arg);

	mov	eax, ecx

; 1387 : }

	ret	0
??$forward@AAURESULT@CDB@@@std@@YAAAURESULT@CDB@@AAU12@@Z ENDP ; std::forward<CDB::RESULT &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\type_traits
;	COMDAT ??$forward@AAPAURESULT@CDB@@@std@@YAAAPAURESULT@CDB@@AAPAU12@@Z
_TEXT	SEGMENT
??$forward@AAPAURESULT@CDB@@@std@@YAAAPAURESULT@CDB@@AAPAU12@@Z PROC ; std::forward<CDB::RESULT * &>, COMDAT
; __Arg$ = ecx

; 1386 :     return static_cast<_Ty&&>(_Arg);

	mov	eax, ecx

; 1387 : }

	ret	0
??$forward@AAPAURESULT@CDB@@@std@@YAAAPAURESULT@CDB@@AAPAU12@@Z ENDP ; std::forward<CDB::RESULT * &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
;	COMDAT ??$_Insertion_sort_unchecked@PAURESULT@CDB@@U?$_Ref_fn@Vpred_fb@@@std@@@std@@YAPAURESULT@CDB@@QAU12@0U?$_Ref_fn@Vpred_fb@@@0@@Z
_TEXT	SEGMENT
tv712 = -76						; size = 4
__Mid$1$ = -72						; size = 4
__First$1$ = -68					; size = 4
tv730 = -64						; size = 4
__Last$1$ = -60						; size = 4
__Val$1 = -56						; size = 56
__Pred$ = 8						; size = 4
??$_Insertion_sort_unchecked@PAURESULT@CDB@@U?$_Ref_fn@Vpred_fb@@@std@@@std@@YAPAURESULT@CDB@@QAU12@0U?$_Ref_fn@Vpred_fb@@@0@@Z PROC ; std::_Insertion_sort_unchecked<CDB::RESULT *,std::_Ref_fn<pred_fb> >, COMDAT
; __First$ = ecx
; __Last$ = edx

; 6919 : _CONSTEXPR20 _BidIt _Insertion_sort_unchecked(const _BidIt _First, const _BidIt _Last, _Pr _Pred) {

	sub	esp, 80					; 00000050H
	push	ebx
	push	ebp
	mov	eax, edx
	mov	DWORD PTR __First$1$[esp+88], ecx
	mov	DWORD PTR __Last$1$[esp+88], eax
	push	esi
	push	edi

; 6920 :     // insertion sort [_First, _Last)
; 6921 :     if (_First != _Last) {

	cmp	ecx, eax
	je	$LN3@Insertion_

; 6922 :         for (_BidIt _Mid = _First; ++_Mid != _Last;) { // order next element

	lea	ebx, DWORD PTR [ecx+56]
	mov	DWORD PTR __Mid$1$[esp+96], ebx
	cmp	ebx, eax
	je	$LN3@Insertion_
	mov	eax, DWORD PTR __Pred$[esp+92]
	mov	DWORD PTR tv712[esp+96], 56		; 00000038H
$LL2@Insertion_:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp

; 140  : 		return	camera.distance_to_sqr(t0.center) < camera.distance_to_sqr(t1.center);

	mov	edx, DWORD PTR [eax]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 6924 :             _Iter_value_t<_BidIt> _Val = _STD move(*_Mid);

	lea	edi, DWORD PTR __Val$1[esp+96]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 287  : 	{	return (x-v.x)*(x-v.x) + (y-v.y)*(y-v.y) + (z-v.z)*(z-v.z);	}

	movss	xmm5, DWORD PTR [eax+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 6924 :             _Iter_value_t<_BidIt> _Val = _STD move(*_Mid);

	mov	ecx, 14					; 0000000eH
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 287  : 	{	return (x-v.x)*(x-v.x) + (y-v.y)*(y-v.y) + (z-v.z)*(z-v.z);	}

	movss	xmm4, DWORD PTR [eax+4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 6924 :             _Iter_value_t<_BidIt> _Val = _STD move(*_Mid);

	mov	esi, ebx
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 287  : 	{	return (x-v.x)*(x-v.x) + (y-v.y)*(y-v.y) + (z-v.z)*(z-v.z);	}

	movss	xmm2, DWORD PTR [eax+12]
	movaps	xmm3, xmm4
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 6924 :             _Iter_value_t<_BidIt> _Val = _STD move(*_Mid);

	rep movsd
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp

; 139  : 		occTri&	t1	= m_pTris	[_2.id];

	mov	edi, DWORD PTR __First$1$[esp+96]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 287  : 	{	return (x-v.x)*(x-v.x) + (y-v.y)*(y-v.y) + (z-v.z)*(z-v.z);	}

	movaps	xmm1, xmm5
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp

; 138  : 		occTri&	t0	= m_pTris	[_1.id];

	imul	esi, DWORD PTR __Val$1[esp+136], 88
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 287  : 	{	return (x-v.x)*(x-v.x) + (y-v.y)*(y-v.y) + (z-v.z)*(z-v.z);	}

	movaps	xmm0, xmm2
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 6923 :             _BidIt _Hole               = _Mid;

	mov	ebp, ebx
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp

; 139  : 		occTri&	t1	= m_pTris	[_2.id];

	imul	ecx, DWORD PTR [edi+40], 88
	mov	DWORD PTR tv730[esp+96], esi
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 287  : 	{	return (x-v.x)*(x-v.x) + (y-v.y)*(y-v.y) + (z-v.z)*(z-v.z);	}

	subss	xmm3, DWORD PTR [edx+esi+76]
	subss	xmm1, DWORD PTR [edx+esi+80]
	subss	xmm0, DWORD PTR [edx+esi+84]
	subss	xmm4, DWORD PTR [ecx+edx+76]
	subss	xmm5, DWORD PTR [ecx+edx+80]
	subss	xmm2, DWORD PTR [ecx+edx+84]
	mulss	xmm3, xmm3
	mulss	xmm4, xmm4
	mulss	xmm1, xmm1
	mulss	xmm5, xmm5
	addss	xmm3, xmm1
	mulss	xmm0, xmm0
	addss	xmm4, xmm5
	mulss	xmm2, xmm2
	addss	xmm3, xmm0
	addss	xmm4, xmm2
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp

; 140  : 		return	camera.distance_to_sqr(t0.center) < camera.distance_to_sqr(t1.center);

	comiss	xmm4, xmm3
	jbe	SHORT $LL9@Insertion_
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility

; 4255 :     auto _Result                = _CSTD memmove(_Dest_ch - _Count, _First_ch, _Count);

	mov	ebp, DWORD PTR tv712[esp+96]
	mov	eax, ebx
	push	ebp
	sub	eax, ebp
	add	eax, 56					; 00000038H
	push	edi
	push	eax
	call	_memmove
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 6929 :             } else { // look for insertion point after first

	mov	eax, DWORD PTR __Pred$[esp+104]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility

; 4255 :     auto _Result                = _CSTD memmove(_Dest_ch - _Count, _First_ch, _Count);

	add	esp, 12					; 0000000cH
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 6929 :             } else { // look for insertion point after first

	jmp	$LN48@Insertion_
	npad	2
$LL9@Insertion_:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp

; 139  : 		occTri&	t1	= m_pTris	[_2.id];

	imul	ecx, DWORD PTR [ebx-16], 88
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 6930 :                 for (_BidIt _Prev = _Hole; _DEBUG_LT_PRED(_Pred, _Val, *--_Prev); _Hole = _Prev) {

	sub	ebx, 56					; 00000038H
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp

; 140  : 		return	camera.distance_to_sqr(t0.center) < camera.distance_to_sqr(t1.center);

	mov	edx, DWORD PTR [eax]
	mov	edi, ebp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 287  : 	{	return (x-v.x)*(x-v.x) + (y-v.y)*(y-v.y) + (z-v.z)*(z-v.z);	}

	movss	xmm5, DWORD PTR [eax+8]
	movss	xmm4, DWORD PTR [eax+4]
	movaps	xmm1, xmm5
	movss	xmm2, DWORD PTR [eax+12]
	movaps	xmm3, xmm4
	subss	xmm3, DWORD PTR [edx+esi+76]
	subss	xmm1, DWORD PTR [edx+esi+80]
	movaps	xmm0, xmm2
	subss	xmm4, DWORD PTR [ecx+edx+76]
	subss	xmm5, DWORD PTR [ecx+edx+80]
	subss	xmm0, DWORD PTR [edx+esi+84]
	subss	xmm2, DWORD PTR [ecx+edx+84]
	mulss	xmm3, xmm3
	mulss	xmm4, xmm4
	mulss	xmm1, xmm1
	mulss	xmm5, xmm5
	addss	xmm3, xmm1
	mulss	xmm0, xmm0
	addss	xmm4, xmm5
	mulss	xmm2, xmm2
	addss	xmm3, xmm0
	addss	xmm4, xmm2
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp

; 140  : 		return	camera.distance_to_sqr(t0.center) < camera.distance_to_sqr(t1.center);

	comiss	xmm4, xmm3
	jbe	SHORT $LN32@Insertion_
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 6931 :                     *_Hole = _STD move(*_Prev); // move hole down

	mov	ecx, 14					; 0000000eH
	mov	esi, ebx
	rep movsd
	mov	esi, DWORD PTR tv730[esp+96]
	mov	ebp, ebx
	jmp	$LL9@Insertion_
$LN32@Insertion_:
	mov	ebx, DWORD PTR __Mid$1$[esp+96]
	mov	ebp, DWORD PTR tv712[esp+96]
$LN48@Insertion_:

; 6922 :         for (_BidIt _Mid = _First; ++_Mid != _Last;) { // order next element

	mov	ecx, 14					; 0000000eH
	lea	esi, DWORD PTR __Val$1[esp+96]
	rep movsd
	mov	ecx, DWORD PTR __Last$1$[esp+96]
	add	ebx, 56					; 00000038H
	add	ebp, 56					; 00000038H
	mov	DWORD PTR __Mid$1$[esp+96], ebx
	mov	DWORD PTR tv712[esp+96], ebp
	cmp	ebx, ecx
	jne	$LL2@Insertion_

; 6932 :                 }
; 6933 : 
; 6934 :                 *_Hole = _STD move(_Val); // insert element in hole
; 6935 :             }
; 6936 :         }
; 6937 :     }
; 6938 : 
; 6939 :     return _Last;

	mov	eax, ecx
$LN3@Insertion_:

; 6940 : }

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 80					; 00000050H
	ret	0
??$_Insertion_sort_unchecked@PAURESULT@CDB@@U?$_Ref_fn@Vpred_fb@@@std@@@std@@YAPAURESULT@CDB@@QAU12@0U?$_Ref_fn@Vpred_fb@@@0@@Z ENDP ; std::_Insertion_sort_unchecked<CDB::RESULT *,std::_Ref_fn<pred_fb> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$?RAAURESULT@CDB@@AAU01@@?$_Ref_fn@Vpred_fb@@@std@@QAE?A_TAAURESULT@CDB@@0@Z
_TEXT	SEGMENT
_<_Vals_0>$ = 8						; size = 4
_<_Vals_1>$ = 12					; size = 4
??$?RAAURESULT@CDB@@AAU01@@?$_Ref_fn@Vpred_fb@@@std@@QAE?A_TAAURESULT@CDB@@0@Z PROC ; std::_Ref_fn<pred_fb>::operator()<CDB::RESULT &,CDB::RESULT &>, COMDAT
; _this$ = ecx
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp

; 138  : 		occTri&	t0	= m_pTris	[_1.id];

	mov	eax, DWORD PTR _<_Vals_0>$[esp-4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility

; 240  :             return _Fn(_STD forward<_Args>(_Vals)...);

	mov	ecx, DWORD PTR [ecx]
	push	esi
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp

; 138  : 		occTri&	t0	= m_pTris	[_1.id];

	imul	edx, DWORD PTR [eax+40], 88

; 139  : 		occTri&	t1	= m_pTris	[_2.id];

	mov	eax, DWORD PTR _<_Vals_1>$[esp]

; 140  : 		return	camera.distance_to_sqr(t0.center) < camera.distance_to_sqr(t1.center);

	mov	esi, DWORD PTR [ecx]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 287  : 	{	return (x-v.x)*(x-v.x) + (y-v.y)*(y-v.y) + (z-v.z)*(z-v.z);	}

	movss	xmm5, DWORD PTR [ecx+8]
	movss	xmm4, DWORD PTR [ecx+4]
	movaps	xmm1, xmm5
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp

; 139  : 		occTri&	t1	= m_pTris	[_2.id];

	imul	eax, DWORD PTR [eax+40], 88
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 287  : 	{	return (x-v.x)*(x-v.x) + (y-v.y)*(y-v.y) + (z-v.z)*(z-v.z);	}

	movaps	xmm3, xmm4
	movss	xmm2, DWORD PTR [ecx+12]
	movaps	xmm0, xmm2
	subss	xmm3, DWORD PTR [edx+esi+76]
	subss	xmm1, DWORD PTR [edx+esi+80]
	subss	xmm0, DWORD PTR [edx+esi+84]
	subss	xmm4, DWORD PTR [eax+esi+76]
	subss	xmm5, DWORD PTR [eax+esi+80]
	subss	xmm2, DWORD PTR [eax+esi+84]
	mulss	xmm3, xmm3
	pop	esi
	mulss	xmm4, xmm4
	mulss	xmm1, xmm1
	mulss	xmm5, xmm5
	addss	xmm3, xmm1
	mulss	xmm0, xmm0
	addss	xmm4, xmm5
	mulss	xmm2, xmm2
	addss	xmm3, xmm0
	addss	xmm4, xmm2
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp

; 140  : 		return	camera.distance_to_sqr(t0.center) < camera.distance_to_sqr(t1.center);

	comiss	xmm4, xmm3
	jbe	SHORT $LN5@operator
	mov	al, 1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility

; 242  :     }

	ret	8
$LN5@operator:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp

; 140  : 		return	camera.distance_to_sqr(t0.center) < camera.distance_to_sqr(t1.center);

	xor	al, al
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility

; 242  :     }

	ret	8
??$?RAAURESULT@CDB@@AAU01@@?$_Ref_fn@Vpred_fb@@@std@@QAE?A_TAAURESULT@CDB@@0@Z ENDP ; std::_Ref_fn<pred_fb>::operator()<CDB::RESULT &,CDB::RESULT &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
;	COMDAT ??$_Make_heap_unchecked@PAURESULT@CDB@@U?$_Ref_fn@Vpred_fb@@@std@@@std@@YAXPAURESULT@CDB@@0U?$_Ref_fn@Vpred_fb@@@0@@Z
_TEXT	SEGMENT
__Hole$1$ = -88						; size = 4
__Max_sequence_non_leaf$1$ = -84			; size = 4
__Bottom$1$ = -80					; size = 4
__First$1$ = -76					; size = 4
tv903 = -72						; size = 4
__Idx$1$ = -72						; size = 4
tv909 = -68						; size = 4
tv902 = -64						; size = 4
tv867 = -60						; size = 4
__Val$1 = -56						; size = 56
__Pred$ = 8						; size = 4
??$_Make_heap_unchecked@PAURESULT@CDB@@U?$_Ref_fn@Vpred_fb@@@std@@@std@@YAXPAURESULT@CDB@@0U?$_Ref_fn@Vpred_fb@@@0@@Z PROC ; std::_Make_heap_unchecked<CDB::RESULT *,std::_Ref_fn<pred_fb> >, COMDAT
; __First$ = ecx
; __Last$ = edx

; 5544 : _CONSTEXPR20 void _Make_heap_unchecked(_RanIt _First, _RanIt _Last, _Pr _Pred) {

	sub	esp, 88					; 00000058H
	push	ebx
	mov	ebx, ecx

; 5545 :     // make [_First, _Last) into a heap
; 5546 :     using _Diff   = _Iter_diff_t<_RanIt>;
; 5547 :     _Diff _Bottom = _Last - _First;

	sub	edx, ebx
	mov	DWORD PTR __First$1$[esp+92], ebx
	sar	edx, 3
	push	ebp
	push	esi
	imul	esi, edx, -1227133513
	push	edi

; 5548 :     for (_Diff _Hole = _Bottom >> 1; _Hole > 0;) { // shift for codegen

	mov	edx, esi
	mov	DWORD PTR __Bottom$1$[esp+104], esi
	sar	edx, 1
	test	edx, edx
	jle	$LN3@Make_heap_

; 5545 :     // make [_First, _Last) into a heap
; 5546 :     using _Diff   = _Iter_diff_t<_RanIt>;
; 5547 :     _Diff _Bottom = _Last - _First;

	lea	eax, DWORD PTR [esi-1]
	mov	DWORD PTR tv909[esp+104], eax
	sar	eax, 1
	mov	DWORD PTR __Max_sequence_non_leaf$1$[esp+104], eax
	lea	eax, DWORD PTR [edx*8]
	sub	eax, edx
	lea	ebp, DWORD PTR [ebx+eax*8]
	mov	eax, DWORD PTR __Pred$[esp+100]
$LL2@Make_heap_:

; 5549 :         // reheap top half, bottom to top
; 5550 :         --_Hole;

	sub	ebp, 56					; 00000038H

; 5551 :         _Iter_value_t<_RanIt> _Val = _STD move(*(_First + _Hole));

	lea	edi, DWORD PTR __Val$1[esp+104]
	mov	esi, ebp
	mov	DWORD PTR tv867[esp+104], ebp
	dec	edx
	mov	ecx, 14					; 0000000eH
	rep movsd

; 5386 :     while (_Idx < _Max_sequence_non_leaf) { // move _Hole down to larger child

	mov	ecx, DWORD PTR __Max_sequence_non_leaf$1$[esp+104]

; 5552 :         _Pop_heap_hole_by_index(_First, _Hole, _Bottom, _STD move(_Val), _Pred);

	mov	ebp, edx
	mov	DWORD PTR __Hole$1$[esp+104], edx

; 5381 :     _Diff _Idx       = _Hole;

	mov	DWORD PTR __Idx$1$[esp+104], edx

; 5382 : 
; 5383 :     // Check whether _Idx can have a child before calculating that child's index, since
; 5384 :     // calculating the child's index can trigger integer overflows
; 5385 :     const _Diff _Max_sequence_non_leaf = (_Bottom - 1) >> 1; // shift for codegen
; 5386 :     while (_Idx < _Max_sequence_non_leaf) { // move _Hole down to larger child

	cmp	edx, ecx
	jge	$LN8@Make_heap_
$LL7@Make_heap_:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp

; 140  : 		return	camera.distance_to_sqr(t0.center) < camera.distance_to_sqr(t1.center);

	mov	esi, DWORD PTR [eax]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 5387 :         _Idx = 2 * _Idx + 2;

	lea	edi, DWORD PTR [edx+edx]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 287  : 	{	return (x-v.x)*(x-v.x) + (y-v.y)*(y-v.y) + (z-v.z)*(z-v.z);	}

	movss	xmm3, DWORD PTR [eax+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 5388 :         if (_DEBUG_LT_PRED(_Pred, *(_First + _Idx), *(_First + (_Idx - 1)))) {

	lea	ecx, DWORD PTR [edi*8]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 287  : 	{	return (x-v.x)*(x-v.x) + (y-v.y)*(y-v.y) + (z-v.z)*(z-v.z);	}

	movss	xmm5, DWORD PTR [eax+4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 5388 :         if (_DEBUG_LT_PRED(_Pred, *(_First + _Idx), *(_First + (_Idx - 1)))) {

	sub	ecx, edi
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 287  : 	{	return (x-v.x)*(x-v.x) + (y-v.y)*(y-v.y) + (z-v.z)*(z-v.z);	}

	movss	xmm2, DWORD PTR [eax+12]
	movaps	xmm4, xmm5
	movaps	xmm1, xmm3
	movaps	xmm0, xmm2
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp

; 138  : 		occTri&	t0	= m_pTris	[_1.id];

	imul	edx, DWORD PTR [ebx+ecx*8+152], 88

; 139  : 		occTri&	t1	= m_pTris	[_2.id];

	imul	ecx, DWORD PTR [ebx+ecx*8+96], 88
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 287  : 	{	return (x-v.x)*(x-v.x) + (y-v.y)*(y-v.y) + (z-v.z)*(z-v.z);	}

	subss	xmm4, DWORD PTR [edx+esi+76]
	subss	xmm5, DWORD PTR [ecx+esi+76]
	subss	xmm3, DWORD PTR [ecx+esi+80]
	subss	xmm1, DWORD PTR [edx+esi+80]
	subss	xmm2, DWORD PTR [ecx+esi+84]
	subss	xmm0, DWORD PTR [edx+esi+84]
	mulss	xmm4, xmm4
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp

; 140  : 		return	camera.distance_to_sqr(t0.center) < camera.distance_to_sqr(t1.center);

	mov	edx, 1
	mov	ecx, 2
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 287  : 	{	return (x-v.x)*(x-v.x) + (y-v.y)*(y-v.y) + (z-v.z)*(z-v.z);	}

	mulss	xmm5, xmm5
	mulss	xmm1, xmm1
	mulss	xmm3, xmm3
	addss	xmm4, xmm1
	mulss	xmm0, xmm0
	addss	xmm5, xmm3
	mulss	xmm2, xmm2
	addss	xmm4, xmm0
	addss	xmm5, xmm2
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp

; 140  : 		return	camera.distance_to_sqr(t0.center) < camera.distance_to_sqr(t1.center);

	comiss	xmm5, xmm4
	cmova	ecx, edx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 5391 :         *(_First + _Hole) = _STD move(*(_First + _Idx));

	lea	edx, DWORD PTR [edi+ecx]
	lea	ecx, DWORD PTR [edx*8]
	sub	ecx, edx
	lea	esi, DWORD PTR [ebx+ecx*8]
	lea	ecx, DWORD PTR [ebp*8]
	sub	ecx, ebp

; 5392 :         _Hole             = _Idx;

	mov	ebp, edx
	lea	edi, DWORD PTR [ebx+ecx*8]
	mov	ecx, 14					; 0000000eH
	rep movsd
	mov	ecx, DWORD PTR __Max_sequence_non_leaf$1$[esp+104]
	cmp	edx, ecx
	jl	$LL7@Make_heap_
	mov	edx, DWORD PTR __Hole$1$[esp+104]
$LN8@Make_heap_:

; 5393 :     }
; 5394 : 
; 5395 :     if (_Idx == _Max_sequence_non_leaf && _Bottom % 2 == 0) { // only child at bottom, move _Hole down to it

	cmp	ebp, ecx
	jne	SHORT $LN10@Make_heap_
	mov	ecx, DWORD PTR __Bottom$1$[esp+104]
	test	cl, 1
	jne	SHORT $LN10@Make_heap_

; 5396 :         *(_First + _Hole) = _STD move(*(_First + (_Bottom - 1)));

	shl	ecx, 3
	sub	ecx, DWORD PTR __Bottom$1$[esp+104]
	add	ecx, -7					; fffffff9H
	lea	esi, DWORD PTR [ebx+ecx*8]
	lea	ecx, DWORD PTR [ebp*8]
	sub	ecx, ebp

; 5397 :         _Hole             = _Bottom - 1;

	mov	ebp, DWORD PTR tv909[esp+104]
	lea	edi, DWORD PTR [ebx+ecx*8]
	mov	ecx, 14					; 0000000eH
	rep movsd
$LN10@Make_heap_:

; 5267 :     for (_Diff _Idx = (_Hole - 1) >> 1; // shift for codegen

	lea	ebx, DWORD PTR [ebp-1]
	sar	ebx, 1

; 5268 :          _Top < _Hole && _DEBUG_LT_PRED(_Pred, *(_First + _Idx), _Val); //

	cmp	edx, ebp
	jge	$LN50@Make_heap_
	imul	edi, DWORD PTR __Val$1[esp+144], 88
	mov	DWORD PTR tv902[esp+104], edi
	npad	6
$LL25@Make_heap_:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp

; 138  : 		occTri&	t0	= m_pTris	[_1.id];

	mov	esi, DWORD PTR __First$1$[esp+104]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 5268 :          _Top < _Hole && _DEBUG_LT_PRED(_Pred, *(_First + _Idx), _Val); //

	lea	ecx, DWORD PTR [ebx*8]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp

; 140  : 		return	camera.distance_to_sqr(t0.center) < camera.distance_to_sqr(t1.center);

	mov	edx, DWORD PTR [eax]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 5268 :          _Top < _Hole && _DEBUG_LT_PRED(_Pred, *(_First + _Idx), _Val); //

	sub	ecx, ebx
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 287  : 	{	return (x-v.x)*(x-v.x) + (y-v.y)*(y-v.y) + (z-v.z)*(z-v.z);	}

	movss	xmm4, DWORD PTR [eax+8]
	movss	xmm3, DWORD PTR [eax+4]
	movaps	xmm5, xmm4
	movss	xmm2, DWORD PTR [eax+12]
	movaps	xmm1, xmm3
	subss	xmm3, DWORD PTR [edx+edi+76]
	subss	xmm4, DWORD PTR [edx+edi+80]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp

; 138  : 		occTri&	t0	= m_pTris	[_1.id];

	lea	ecx, DWORD PTR [esi+ecx*8]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 287  : 	{	return (x-v.x)*(x-v.x) + (y-v.y)*(y-v.y) + (z-v.z)*(z-v.z);	}

	movaps	xmm0, xmm2
	subss	xmm2, DWORD PTR [edx+edi+84]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp

; 138  : 		occTri&	t0	= m_pTris	[_1.id];

	mov	DWORD PTR tv903[esp+104], ecx
	imul	ecx, DWORD PTR [ecx+40], 88
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 287  : 	{	return (x-v.x)*(x-v.x) + (y-v.y)*(y-v.y) + (z-v.z)*(z-v.z);	}

	mulss	xmm3, xmm3
	mulss	xmm4, xmm4
	mulss	xmm2, xmm2
	addss	xmm3, xmm4
	subss	xmm5, DWORD PTR [ecx+edx+80]
	subss	xmm1, DWORD PTR [ecx+edx+76]
	subss	xmm0, DWORD PTR [ecx+edx+84]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp

; 140  : 		return	camera.distance_to_sqr(t0.center) < camera.distance_to_sqr(t1.center);

	mov	edx, DWORD PTR __Hole$1$[esp+104]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 287  : 	{	return (x-v.x)*(x-v.x) + (y-v.y)*(y-v.y) + (z-v.z)*(z-v.z);	}

	addss	xmm3, xmm2
	mulss	xmm5, xmm5
	mulss	xmm1, xmm1
	mulss	xmm0, xmm0
	addss	xmm5, xmm1
	addss	xmm5, xmm0
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp

; 140  : 		return	camera.distance_to_sqr(t0.center) < camera.distance_to_sqr(t1.center);

	comiss	xmm3, xmm5
	jbe	SHORT $LN50@Make_heap_
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 5271 :         *(_First + _Hole) = _STD move(*(_First + _Idx));

	lea	ecx, DWORD PTR [ebp*8]
	sub	ecx, ebp

; 5272 :         _Hole             = _Idx;

	mov	ebp, ebx
	dec	ebx
	sar	ebx, 1
	lea	edi, DWORD PTR [esi+ecx*8]
	mov	esi, DWORD PTR tv903[esp+104]
	mov	ecx, 14					; 0000000eH
	rep movsd
	mov	edi, DWORD PTR tv902[esp+104]
	cmp	edx, ebp
	jl	$LL25@Make_heap_
$LN50@Make_heap_:

; 5273 :     }
; 5274 : 
; 5275 :     *(_First + _Hole) = _STD forward<_Ty>(_Val); // drop _Val into final hole

	mov	ebx, DWORD PTR __First$1$[esp+104]
	lea	ecx, DWORD PTR [ebp*8]
	sub	ecx, ebp
	lea	esi, DWORD PTR __Val$1[esp+104]

; 5548 :     for (_Diff _Hole = _Bottom >> 1; _Hole > 0;) { // shift for codegen

	mov	ebp, DWORD PTR tv867[esp+104]

; 5275 :     *(_First + _Hole) = _STD forward<_Ty>(_Val); // drop _Val into final hole

	lea	edi, DWORD PTR [ebx+ecx*8]
	mov	ecx, 14					; 0000000eH
	rep movsd

; 5548 :     for (_Diff _Hole = _Bottom >> 1; _Hole > 0;) { // shift for codegen

	test	edx, edx
	jg	$LL2@Make_heap_
$LN3@Make_heap_:

; 5553 :     }
; 5554 : }

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 88					; 00000058H
	ret	0
??$_Make_heap_unchecked@PAURESULT@CDB@@U?$_Ref_fn@Vpred_fb@@@std@@@std@@YAXPAURESULT@CDB@@0U?$_Ref_fn@Vpred_fb@@@0@@Z ENDP ; std::_Make_heap_unchecked<CDB::RESULT *,std::_Ref_fn<pred_fb> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
;	COMDAT ??$_Sort_heap_unchecked@PAURESULT@CDB@@U?$_Ref_fn@Vpred_fb@@@std@@@std@@YAXPAURESULT@CDB@@0U?$_Ref_fn@Vpred_fb@@@0@@Z
_TEXT	SEGMENT
__Val$1 = -56						; size = 56
__Pred$ = 8						; size = 4
??$_Sort_heap_unchecked@PAURESULT@CDB@@U?$_Ref_fn@Vpred_fb@@@std@@@std@@YAXPAURESULT@CDB@@0U?$_Ref_fn@Vpred_fb@@@0@@Z PROC ; std::_Sort_heap_unchecked<CDB::RESULT *,std::_Ref_fn<pred_fb> >, COMDAT
; __First$ = ecx
; __Last$ = edx

; 5772 : _CONSTEXPR20 void _Sort_heap_unchecked(_RanIt _First, _RanIt _Last, _Pr _Pred) {

	sub	esp, 56					; 00000038H
	push	ebx
	push	ebp
	push	esi
	mov	ebp, ecx

; 5773 :     // order heap by repeatedly popping
; 5774 :     for (; _Last - _First >= 2; --_Last) {

	mov	esi, edx
	sub	esi, ebp
	push	edi
	cmp	esi, 112				; 00000070H
	jl	SHORT $LN3@Sort_heap_
	lea	ebx, DWORD PTR [edx-56]
$LL4@Sort_heap_:

; 5417 :     if (2 <= _Last - _First) {

	mov	eax, 613566757				; 24924925H
	mul	esi
	sub	esi, edx
	shr	esi, 1
	add	esi, edx
	shr	esi, 5
	cmp	esi, 2
	mov	esi, ebx
	jl	SHORT $LN16@Sort_heap_

; 5410 :     _Pop_heap_hole_by_index(

	push	DWORD PTR __Pred$[esp+68]

; 5419 :         _Iter_value_t<_RanIt> _Val = _STD move(*_Last);

	mov	ecx, 14					; 0000000eH
	lea	edi, DWORD PTR __Val$1[esp+76]
	rep movsd

; 5408 :     *_Dest      = _STD move(*_First);

	mov	ecx, 14					; 0000000eH

; 5409 :     using _Diff = _Iter_diff_t<_RanIt>;
; 5410 :     _Pop_heap_hole_by_index(

	lea	eax, DWORD PTR __Val$1[esp+76]
	mov	esi, ebp
	mov	edi, ebx
	rep movsd
	push	eax
	mov	esi, ebx
	xor	edx, edx
	sub	esi, ebp
	mov	ecx, ebp
	mov	eax, esi
	sar	eax, 3
	imul	eax, eax, -1227133513
	push	eax
	call	??$_Pop_heap_hole_by_index@PAURESULT@CDB@@U12@U?$_Ref_fn@Vpred_fb@@@std@@@std@@YAXPAURESULT@CDB@@HH$$QAU12@U?$_Ref_fn@Vpred_fb@@@0@@Z ; std::_Pop_heap_hole_by_index<CDB::RESULT *,CDB::RESULT,std::_Ref_fn<pred_fb> >
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN2@Sort_heap_
$LN16@Sort_heap_:
	sub	esi, ebp
$LN2@Sort_heap_:

; 5773 :     // order heap by repeatedly popping
; 5774 :     for (; _Last - _First >= 2; --_Last) {

	sub	ebx, 56					; 00000038H
	cmp	esi, 112				; 00000070H
	jge	SHORT $LL4@Sort_heap_
$LN3@Sort_heap_:

; 5775 :         _Pop_heap_unchecked(_First, _Last, _Pred);
; 5776 :     }
; 5777 : }

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 56					; 00000038H
	ret	0
??$_Sort_heap_unchecked@PAURESULT@CDB@@U?$_Ref_fn@Vpred_fb@@@std@@@std@@YAXPAURESULT@CDB@@0U?$_Ref_fn@Vpred_fb@@@0@@Z ENDP ; std::_Sort_heap_unchecked<CDB::RESULT *,std::_Ref_fn<pred_fb> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
;	COMDAT ??$_Partition_by_median_guess_unchecked@PAURESULT@CDB@@U?$_Ref_fn@Vpred_fb@@@std@@@std@@YA?AU?$pair@PAURESULT@CDB@@PAU12@@0@PAURESULT@CDB@@0U?$_Ref_fn@Vpred_fb@@@0@@Z
_TEXT	SEGMENT
tv2227 = -416						; size = 4
__Plast$1$ = -416					; size = 4
__Last$1$ = -412					; size = 4
__Glast$1$ = -412					; size = 4
tv2221 = -412						; size = 4
__Gfirst$1$ = -408					; size = 4
__Pfirst$1$ = -408					; size = 4
__First$1$ = -404					; size = 4
___$ReturnUdt$1$ = -400					; size = 4
__Tmp$1 = -396						; size = 56
__Tmp$2 = -340						; size = 56
__Tmp$3 = -284						; size = 56
__Tmp$4 = -228						; size = 56
__Tmp$5 = -172						; size = 56
__Tmp$6 = -116						; size = 56
__Tmp$7 = -60						; size = 56
__Last$ = 8						; size = 4
__Pred$ = 12						; size = 4
??$_Partition_by_median_guess_unchecked@PAURESULT@CDB@@U?$_Ref_fn@Vpred_fb@@@std@@@std@@YA?AU?$pair@PAURESULT@CDB@@PAU12@@0@PAURESULT@CDB@@0U?$_Ref_fn@Vpred_fb@@@0@@Z PROC ; std::_Partition_by_median_guess_unchecked<CDB::RESULT *,std::_Ref_fn<pred_fb> >, COMDAT
; ___$ReturnUdt$ = ecx
; __First$ = edx

; 6976 : _CONSTEXPR20 pair<_RanIt, _RanIt> _Partition_by_median_guess_unchecked(_RanIt _First, _RanIt _Last, _Pr _Pred) {

	sub	esp, 420				; 000001a4H
	push	ebx
	push	ebp
	push	esi
	push	edi

; 6977 :     // partition [_First, _Last)
; 6978 :     _RanIt _Mid = _First + ((_Last - _First) >> 1); // shift for codegen

	mov	edi, DWORD PTR __Last$[esp+432]
	mov	ebp, edx
	mov	eax, edi
	mov	DWORD PTR __First$1$[esp+436], ebp
	sub	eax, ebp
	mov	DWORD PTR ___$ReturnUdt$1$[esp+436], ecx
	sar	eax, 3

; 6979 :     _Guess_median_unchecked(_First, _Mid, _Prev_iter(_Last), _Pred);

	add	edi, -56				; ffffffc8H
	imul	esi, eax, -1227133513
	mov	DWORD PTR __Last$1$[esp+436], edi
	sar	esi, 1
	lea	eax, DWORD PTR [esi*8]
	sub	eax, esi

; 6963 :     if (40 < _Count) { // Tukey's ninther

	mov	esi, DWORD PTR __Pred$[esp+432]
	push	esi

; 6977 :     // partition [_First, _Last)
; 6978 :     _RanIt _Mid = _First + ((_Last - _First) >> 1); // shift for codegen

	lea	ebx, DWORD PTR [eax*8]

; 6962 :     const _Diff _Count = _Last - _First;

	mov	eax, edi
	sub	eax, ebp

; 6977 :     // partition [_First, _Last)
; 6978 :     _RanIt _Mid = _First + ((_Last - _First) >> 1); // shift for codegen

	add	ebx, ebp

; 6962 :     const _Diff _Count = _Last - _First;

	sar	eax, 3
	imul	eax, eax, -1227133513

; 6977 :     // partition [_First, _Last)
; 6978 :     _RanIt _Mid = _First + ((_Last - _First) >> 1); // shift for codegen

	mov	DWORD PTR __Pfirst$1$[esp+440], ebx

; 6963 :     if (40 < _Count) { // Tukey's ninther

	cmp	eax, 40					; 00000028H
	jle	SHORT $LN35@Partition_

; 6964 :         const _Diff _Step     = (_Count + 1) >> 3; // +1 can't overflow because range was made inclusive in caller

	inc	eax

; 6965 :         const _Diff _Two_step = _Step << 1; // note: intentionally discards low-order bit
; 6966 :         _Med3_unchecked(_First, _First + _Step, _First + _Two_step, _Pred);

	mov	edi, edx
	sar	eax, 3
	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax
	lea	ebx, DWORD PTR [eax*8]
	shl	ecx, 4
	sub	ebx, eax
	shl	ebx, 3
	mov	DWORD PTR tv2227[esp+440], ecx
	add	ebp, ebx
	mov	edx, ebp
	lea	eax, DWORD PTR [ecx+edi]
	mov	ecx, edi
	push	eax
	call	??$_Med3_unchecked@PAURESULT@CDB@@U?$_Ref_fn@Vpred_fb@@@std@@@std@@YAXPAURESULT@CDB@@00U?$_Ref_fn@Vpred_fb@@@0@@Z ; std::_Med3_unchecked<CDB::RESULT *,std::_Ref_fn<pred_fb> >

; 6967 :         _Med3_unchecked(_Mid - _Step, _Mid, _Mid + _Step, _Pred);

	mov	edx, DWORD PTR __Pfirst$1$[esp+444]
	mov	ecx, edx
	push	esi
	sub	ecx, ebx
	lea	eax, DWORD PTR [ebx+edx]
	push	eax
	call	??$_Med3_unchecked@PAURESULT@CDB@@U?$_Ref_fn@Vpred_fb@@@std@@@std@@YAXPAURESULT@CDB@@00U?$_Ref_fn@Vpred_fb@@@0@@Z ; std::_Med3_unchecked<CDB::RESULT *,std::_Ref_fn<pred_fb> >

; 6968 :         _Med3_unchecked(_Last - _Two_step, _Last - _Step, _Last, _Pred);

	mov	eax, DWORD PTR __Last$1$[esp+452]
	mov	edi, eax
	push	esi
	push	eax
	sub	eax, DWORD PTR tv2227[esp+460]
	sub	edi, ebx
	mov	edx, edi
	mov	ecx, eax
	call	??$_Med3_unchecked@PAURESULT@CDB@@U?$_Ref_fn@Vpred_fb@@@std@@@std@@YAXPAURESULT@CDB@@00U?$_Ref_fn@Vpred_fb@@@0@@Z ; std::_Med3_unchecked<CDB::RESULT *,std::_Ref_fn<pred_fb> >

; 6969 :         _Med3_unchecked(_First + _Step, _Mid, _Last - _Step, _Pred);

	mov	ebx, DWORD PTR __Pfirst$1$[esp+460]
	mov	ecx, ebp
	push	esi
	push	edi
	mov	edx, ebx
	call	??$_Med3_unchecked@PAURESULT@CDB@@U?$_Ref_fn@Vpred_fb@@@std@@@std@@YAXPAURESULT@CDB@@00U?$_Ref_fn@Vpred_fb@@@0@@Z ; std::_Med3_unchecked<CDB::RESULT *,std::_Ref_fn<pred_fb> >

; 6970 :     } else {

	mov	ebp, DWORD PTR __First$1$[esp+468]
	add	esp, 32					; 00000020H
	jmp	SHORT $LN36@Partition_
$LN35@Partition_:

; 6971 :         _Med3_unchecked(_First, _Mid, _Last, _Pred);

	push	edi
	mov	edx, ebx
	mov	ecx, ebp
	call	??$_Med3_unchecked@PAURESULT@CDB@@U?$_Ref_fn@Vpred_fb@@@std@@@std@@YAXPAURESULT@CDB@@00U?$_Ref_fn@Vpred_fb@@@0@@Z ; std::_Med3_unchecked<CDB::RESULT *,std::_Ref_fn<pred_fb> >
	add	esp, 8
$LN36@Partition_:

; 6980 :     _RanIt _Pfirst = _Mid;
; 6981 :     _RanIt _Plast  = _Next_iter(_Pfirst);

	lea	edi, DWORD PTR [ebx+56]
	mov	DWORD PTR __Plast$1$[esp+436], edi

; 6984 :            && !_Pred(*_Pfirst, *_Prev_iter(_Pfirst))) {

	cmp	ebp, ebx
	jae	$LN188@Partition_
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp

; 138  : 		occTri&	t0	= m_pTris	[_1.id];

	mov	edx, DWORD PTR [esi]
	movss	xmm4, DWORD PTR [esi+8]
	movss	xmm5, DWORD PTR [esi+4]
	movss	xmm6, DWORD PTR [esi+12]
$LL2@Partition_:
	imul	eax, DWORD PTR [ebx-16], 88
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 287  : 	{	return (x-v.x)*(x-v.x) + (y-v.y)*(y-v.y) + (z-v.z)*(z-v.z);	}

	movaps	xmm1, xmm4
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp

; 139  : 		occTri&	t1	= m_pTris	[_2.id];

	imul	ecx, DWORD PTR [ebx+40], 88
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 287  : 	{	return (x-v.x)*(x-v.x) + (y-v.y)*(y-v.y) + (z-v.z)*(z-v.z);	}

	movaps	xmm3, xmm5
	movaps	xmm0, xmm6
	movaps	xmm2, xmm5
	subss	xmm1, DWORD PTR [eax+edx+80]
	subss	xmm3, DWORD PTR [eax+edx+76]
	subss	xmm0, DWORD PTR [eax+edx+84]
	subss	xmm2, DWORD PTR [ecx+edx+76]
	mulss	xmm1, xmm1
	mulss	xmm3, xmm3
	mulss	xmm0, xmm0
	addss	xmm3, xmm1
	mulss	xmm2, xmm2
	movaps	xmm1, xmm4
	subss	xmm1, DWORD PTR [ecx+edx+80]
	addss	xmm3, xmm0
	movaps	xmm0, xmm6
	subss	xmm0, DWORD PTR [ecx+edx+84]
	mulss	xmm1, xmm1
	mulss	xmm0, xmm0
	addss	xmm2, xmm1
	addss	xmm2, xmm0
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp

; 140  : 		return	camera.distance_to_sqr(t0.center) < camera.distance_to_sqr(t1.center);

	comiss	xmm2, xmm3
	ja	SHORT $LN188@Partition_
	comiss	xmm3, xmm2
	ja	SHORT $LN188@Partition_
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 6984 :            && !_Pred(*_Pfirst, *_Prev_iter(_Pfirst))) {

	sub	ebx, 56					; 00000038H
	cmp	ebp, ebx
	jb	SHORT $LL2@Partition_
$LN188@Partition_:

; 6988 :     while (_Plast < _Last && !_DEBUG_LT_PRED(_Pred, *_Plast, *_Pfirst) && !_Pred(*_Pfirst, *_Plast)) {

	mov	ecx, DWORD PTR __Last$[esp+432]
	cmp	edi, ecx
	jae	$LN182@Partition_
	imul	eax, DWORD PTR [ebx+40], 88
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp

; 138  : 		occTri&	t0	= m_pTris	[_1.id];

	mov	edx, DWORD PTR [esi]
	movss	xmm4, DWORD PTR [esi+8]
	movss	xmm5, DWORD PTR [esi+4]
	movaps	xmm1, xmm4
	movss	xmm6, DWORD PTR [esi+12]
	movaps	xmm3, xmm5
	movaps	xmm0, xmm6
	subss	xmm3, DWORD PTR [eax+edx+76]
	subss	xmm1, DWORD PTR [eax+edx+80]
	subss	xmm0, DWORD PTR [eax+edx+84]
	mulss	xmm3, xmm3
	mulss	xmm1, xmm1
	mulss	xmm0, xmm0
	addss	xmm3, xmm1
	addss	xmm3, xmm0
	npad	6
$LL4@Partition_:
	imul	eax, DWORD PTR [edi+40], 88
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 287  : 	{	return (x-v.x)*(x-v.x) + (y-v.y)*(y-v.y) + (z-v.z)*(z-v.z);	}

	movaps	xmm1, xmm4
	movaps	xmm2, xmm5
	movaps	xmm0, xmm6
	subss	xmm2, DWORD PTR [eax+edx+76]
	subss	xmm1, DWORD PTR [eax+edx+80]
	subss	xmm0, DWORD PTR [eax+edx+84]
	mulss	xmm2, xmm2
	mulss	xmm1, xmm1
	mulss	xmm0, xmm0
	addss	xmm2, xmm1
	addss	xmm2, xmm0
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp

; 140  : 		return	camera.distance_to_sqr(t0.center) < camera.distance_to_sqr(t1.center);

	comiss	xmm3, xmm2
	ja	SHORT $LN189@Partition_
	comiss	xmm2, xmm3
	ja	SHORT $LN189@Partition_
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 6988 :     while (_Plast < _Last && !_DEBUG_LT_PRED(_Pred, *_Plast, *_Pfirst) && !_Pred(*_Pfirst, *_Plast)) {

	add	edi, 56					; 00000038H
	cmp	edi, ecx
	jb	SHORT $LL4@Partition_
$LN189@Partition_:
	mov	DWORD PTR __Plast$1$[esp+436], edi
$LN182@Partition_:

; 6989 :         ++_Plast;
; 6990 :     }
; 6991 : 
; 6992 :     _RanIt _Gfirst = _Plast;

	mov	ebp, edi

; 6993 :     _RanIt _Glast  = _Pfirst;

	mov	eax, ebx
$LN195@Partition_:

; 6994 : 
; 6995 :     for (;;) { // partition
; 6996 :         for (; _Gfirst < _Last; ++_Gfirst) {

	mov	DWORD PTR __Glast$1$[esp+436], eax
$LN194@Partition_:
	mov	DWORD PTR __Gfirst$1$[esp+436], ebp
$LL6@Partition_:
	cmp	ebp, ecx
	jae	$LN183@Partition_
	npad	4
$LL11@Partition_:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp

; 138  : 		occTri&	t0	= m_pTris	[_1.id];

	imul	eax, DWORD PTR [ebx+40], 88

; 139  : 		occTri&	t1	= m_pTris	[_2.id];

	imul	ecx, DWORD PTR [ebp+40], 88

; 140  : 		return	camera.distance_to_sqr(t0.center) < camera.distance_to_sqr(t1.center);

	mov	edx, DWORD PTR [esi]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 287  : 	{	return (x-v.x)*(x-v.x) + (y-v.y)*(y-v.y) + (z-v.z)*(z-v.z);	}

	movss	xmm3, DWORD PTR [esi+8]
	movss	xmm4, DWORD PTR [esi+4]
	movaps	xmm1, xmm3
	movss	xmm2, DWORD PTR [esi+12]
	movaps	xmm5, xmm4
	movaps	xmm0, xmm2
	subss	xmm5, DWORD PTR [eax+edx+76]
	subss	xmm4, DWORD PTR [ecx+edx+76]
	subss	xmm1, DWORD PTR [eax+edx+80]
	subss	xmm3, DWORD PTR [ecx+edx+80]
	subss	xmm0, DWORD PTR [eax+edx+84]
	subss	xmm2, DWORD PTR [ecx+edx+84]
	mulss	xmm5, xmm5
	mulss	xmm4, xmm4
	mulss	xmm1, xmm1
	mulss	xmm3, xmm3
	addss	xmm5, xmm1
	mulss	xmm0, xmm0
	addss	xmm4, xmm3
	mulss	xmm2, xmm2
	addss	xmm5, xmm0
	addss	xmm4, xmm2
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp

; 140  : 		return	camera.distance_to_sqr(t0.center) < camera.distance_to_sqr(t1.center);

	comiss	xmm4, xmm5
	ja	SHORT $LN9@Partition_
	comiss	xmm5, xmm4
	ja	SHORT $LN190@Partition_
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 7001 :             } else if (_Plast != _Gfirst) {

	lea	edx, DWORD PTR [edi+56]
	cmp	edi, ebp
	je	SHORT $LN19@Partition_
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 100  :     _Ty _Tmp = _STD move(_Left);

	mov	esi, edi
	mov	ecx, 14					; 0000000eH
	lea	edi, DWORD PTR __Tmp$1[esp+436]
	rep movsd

; 101  :     _Left    = _STD move(_Right);

	mov	edi, DWORD PTR __Plast$1$[esp+436]
	mov	ecx, 14					; 0000000eH
	mov	esi, ebp
	rep movsd

; 102  :     _Right   = _STD move(_Tmp);

	mov	ecx, 14					; 0000000eH
	lea	esi, DWORD PTR __Tmp$1[esp+436]
	mov	edi, ebp
	rep movsd
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 7004 :             } else {

	mov	esi, DWORD PTR __Pred$[esp+432]
$LN19@Partition_:

; 6994 : 
; 6995 :     for (;;) { // partition
; 6996 :         for (; _Gfirst < _Last; ++_Gfirst) {

	mov	edi, edx
	mov	DWORD PTR __Plast$1$[esp+436], edi
$LN9@Partition_:
	add	ebp, 56					; 00000038H
	cmp	ebp, DWORD PTR __Last$[esp+432]
	jb	$LL11@Partition_
$LN190@Partition_:
	mov	eax, DWORD PTR __Glast$1$[esp+436]
	mov	DWORD PTR __Gfirst$1$[esp+436], ebp
$LN183@Partition_:

; 7009 :         for (; _First < _Glast; --_Glast) {

	mov	edi, DWORD PTR __First$1$[esp+436]
	cmp	eax, edi
	jbe	$LN193@Partition_
	mov	ebp, DWORD PTR __Glast$1$[esp+436]
	lea	eax, DWORD PTR [ebp-56]
	mov	DWORD PTR tv2221[esp+436], eax
$LL14@Partition_:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp

; 138  : 		occTri&	t0	= m_pTris	[_1.id];

	imul	eax, DWORD PTR [eax+40], 88

; 139  : 		occTri&	t1	= m_pTris	[_2.id];

	imul	ecx, DWORD PTR [ebx+40], 88

; 140  : 		return	camera.distance_to_sqr(t0.center) < camera.distance_to_sqr(t1.center);

	mov	edx, DWORD PTR [esi]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 287  : 	{	return (x-v.x)*(x-v.x) + (y-v.y)*(y-v.y) + (z-v.z)*(z-v.z);	}

	movss	xmm3, DWORD PTR [esi+8]
	movss	xmm4, DWORD PTR [esi+4]
	movaps	xmm1, xmm3
	movss	xmm2, DWORD PTR [esi+12]
	movaps	xmm5, xmm4
	movaps	xmm0, xmm2
	subss	xmm5, DWORD PTR [eax+edx+76]
	subss	xmm4, DWORD PTR [ecx+edx+76]
	subss	xmm1, DWORD PTR [eax+edx+80]
	subss	xmm3, DWORD PTR [ecx+edx+80]
	subss	xmm0, DWORD PTR [eax+edx+84]
	subss	xmm2, DWORD PTR [ecx+edx+84]
	mulss	xmm5, xmm5
	mulss	xmm4, xmm4
	mulss	xmm1, xmm1
	mulss	xmm3, xmm3
	addss	xmm5, xmm1
	mulss	xmm0, xmm0
	addss	xmm4, xmm3
	mulss	xmm2, xmm2
	addss	xmm5, xmm0
	addss	xmm4, xmm2
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp

; 140  : 		return	camera.distance_to_sqr(t0.center) < camera.distance_to_sqr(t1.center);

	comiss	xmm4, xmm5
	ja	SHORT $LN192@Partition_
	comiss	xmm5, xmm4
	ja	SHORT $LN191@Partition_
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 7014 :             } else if (--_Pfirst != _Prev_iter(_Glast)) {

	mov	eax, DWORD PTR tv2221[esp+436]
	sub	ebx, 56					; 00000038H
	cmp	ebx, eax
	je	SHORT $LN12@Partition_
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 100  :     _Ty _Tmp = _STD move(_Left);

	mov	ecx, 14					; 0000000eH
	lea	edi, DWORD PTR __Tmp$2[esp+436]
	mov	esi, ebx
	rep movsd

; 101  :     _Left    = _STD move(_Right);

	mov	ecx, 14					; 0000000eH
	mov	esi, eax
	mov	edi, ebx
	rep movsd

; 102  :     _Right   = _STD move(_Tmp);

	mov	ecx, 14					; 0000000eH
	lea	esi, DWORD PTR __Tmp$2[esp+436]
	mov	edi, eax
	rep movsd
	mov	esi, DWORD PTR __Pred$[esp+432]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp

; 140  : 		return	camera.distance_to_sqr(t0.center) < camera.distance_to_sqr(t1.center);

	mov	edi, DWORD PTR __First$1$[esp+436]
	jmp	SHORT $LN12@Partition_
$LN192@Partition_:
	mov	eax, DWORD PTR tv2221[esp+436]
$LN12@Partition_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 7009 :         for (; _First < _Glast; --_Glast) {

	sub	ebp, 56					; 00000038H
	sub	eax, 56					; 00000038H
	mov	DWORD PTR tv2221[esp+436], eax
	cmp	edi, ebp
	jb	$LL14@Partition_
$LN191@Partition_:
	mov	DWORD PTR __Glast$1$[esp+436], ebp
	mov	eax, DWORD PTR __Glast$1$[esp+436]

; 7015 :                 _STD iter_swap(_Pfirst, _Prev_iter(_Glast));
; 7016 :             }
; 7017 :         }
; 7018 : 
; 7019 :         if (_Glast == _First && _Gfirst == _Last) {

	cmp	eax, edi
	mov	ebp, DWORD PTR __Gfirst$1$[esp+436]
$LN193@Partition_:
	jne	$LN27@Partition_
	mov	eax, DWORD PTR __Plast$1$[esp+436]
	cmp	ebp, DWORD PTR __Last$[esp+432]
	je	$LN156@Partition_

; 7021 :         }
; 7022 : 
; 7023 :         if (_Glast == _First) { // no room at bottom, rotate pivot upward
; 7024 :             if (_Plast != _Gfirst) {

	cmp	eax, ebp
	je	SHORT $LN29@Partition_
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 100  :     _Ty _Tmp = _STD move(_Left);

	mov	ecx, 14					; 0000000eH
	lea	edi, DWORD PTR __Tmp$3[esp+436]
	mov	esi, ebx
	rep movsd

; 101  :     _Left    = _STD move(_Right);

	mov	ecx, 14					; 0000000eH
	mov	esi, eax
	mov	edi, ebx
	rep movsd

; 102  :     _Right   = _STD move(_Tmp);

	mov	ecx, 14					; 0000000eH
	lea	esi, DWORD PTR __Tmp$3[esp+436]
	mov	edi, eax
	rep movsd
$LN29@Partition_:

; 100  :     _Ty _Tmp = _STD move(_Left);

	mov	esi, ebx
	lea	edi, DWORD PTR __Tmp$4[esp+436]
	mov	ecx, 14					; 0000000eH
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 7028 :             ++_Plast;

	add	eax, 56					; 00000038H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 100  :     _Ty _Tmp = _STD move(_Left);

	rep movsd

; 101  :     _Left    = _STD move(_Right);

	mov	esi, ebp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 7028 :             ++_Plast;

	mov	DWORD PTR __Plast$1$[esp+436], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 101  :     _Left    = _STD move(_Right);

	mov	edi, ebx
	mov	ecx, 14					; 0000000eH
	rep movsd

; 102  :     _Right   = _STD move(_Tmp);

	mov	edi, ebp
	lea	esi, DWORD PTR __Tmp$4[esp+436]
	mov	ecx, 14					; 0000000eH
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 7030 :             ++_Pfirst;

	add	ebx, 56					; 00000038H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 102  :     _Right   = _STD move(_Tmp);

	rep movsd
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 7031 :             ++_Gfirst;

	mov	esi, DWORD PTR __Pred$[esp+432]
	mov	edi, eax
	mov	eax, DWORD PTR __Glast$1$[esp+436]
	add	ebp, 56					; 00000038H
	mov	ecx, DWORD PTR __Last$[esp+432]
	jmp	$LN194@Partition_
$LN27@Partition_:

; 7032 :         } else if (_Gfirst == _Last) { // no room at top, rotate pivot downward

	add	eax, -56				; ffffffc8H
	mov	DWORD PTR __Glast$1$[esp+436], eax
	cmp	ebp, DWORD PTR __Last$[esp+432]
	jne	$LN30@Partition_

; 7033 :             if (--_Glast != --_Pfirst) {

	sub	ebx, 56					; 00000038H
	cmp	eax, ebx
	je	SHORT $LN32@Partition_
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 100  :     _Ty _Tmp = _STD move(_Left);

	mov	ecx, 14					; 0000000eH
	lea	edi, DWORD PTR __Tmp$5[esp+436]
	mov	esi, eax
	rep movsd

; 101  :     _Left    = _STD move(_Right);

	mov	ecx, 14					; 0000000eH
	mov	esi, ebx
	mov	edi, eax
	rep movsd

; 102  :     _Right   = _STD move(_Tmp);

	mov	ecx, 14					; 0000000eH
	lea	esi, DWORD PTR __Tmp$5[esp+436]
	mov	edi, ebx
	rep movsd
$LN32@Partition_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 7037 :             _STD iter_swap(_Pfirst, --_Plast);

	mov	eax, DWORD PTR __Plast$1$[esp+436]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 100  :     _Ty _Tmp = _STD move(_Left);

	lea	edi, DWORD PTR __Tmp$6[esp+436]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 7037 :             _STD iter_swap(_Pfirst, --_Plast);

	sub	eax, 56					; 00000038H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 100  :     _Ty _Tmp = _STD move(_Left);

	mov	ecx, 14					; 0000000eH
	mov	esi, ebx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 7037 :             _STD iter_swap(_Pfirst, --_Plast);

	mov	DWORD PTR __Plast$1$[esp+436], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 100  :     _Ty _Tmp = _STD move(_Left);

	rep movsd

; 101  :     _Left    = _STD move(_Right);

	mov	esi, eax
	mov	ecx, 14					; 0000000eH
	mov	edi, ebx
	rep movsd

; 102  :     _Right   = _STD move(_Tmp);

	mov	edi, eax
	lea	esi, DWORD PTR __Tmp$6[esp+436]
	mov	ecx, 14					; 0000000eH
	rep movsd
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 7038 :         } else {

	mov	esi, DWORD PTR __Pred$[esp+432]
	mov	edi, eax
	mov	eax, DWORD PTR __Glast$1$[esp+436]
	mov	ecx, DWORD PTR __Last$[esp+432]
	jmp	$LL6@Partition_
$LN30@Partition_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 100  :     _Ty _Tmp = _STD move(_Left);

	mov	esi, ebp
	lea	edi, DWORD PTR __Tmp$7[esp+436]
	mov	ecx, 14					; 0000000eH
	rep movsd

; 101  :     _Left    = _STD move(_Right);

	mov	edi, ebp
	mov	ecx, 14					; 0000000eH
	mov	esi, eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 7040 :             ++_Gfirst;

	add	ebp, 56					; 00000038H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 101  :     _Left    = _STD move(_Right);

	rep movsd

; 102  :     _Right   = _STD move(_Tmp);

	mov	ecx, 14					; 0000000eH
	lea	esi, DWORD PTR __Tmp$7[esp+436]
	mov	edi, eax
	rep movsd
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 7042 :     }

	mov	esi, DWORD PTR __Pred$[esp+432]
	mov	edi, DWORD PTR __Plast$1$[esp+436]
	mov	ecx, DWORD PTR __Last$[esp+432]
	jmp	$LN195@Partition_
$LN156@Partition_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 186  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

	mov	ecx, DWORD PTR ___$ReturnUdt$1$[esp+436]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 7043 : }

	pop	edi
	pop	esi
	pop	ebp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 186  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

	mov	DWORD PTR [ecx], ebx
	mov	DWORD PTR [ecx+4], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 7020 :             return pair<_RanIt, _RanIt>(_Pfirst, _Plast);

	mov	eax, ecx

; 7043 : }

	pop	ebx
	add	esp, 420				; 000001a4H
	ret	0
??$_Partition_by_median_guess_unchecked@PAURESULT@CDB@@U?$_Ref_fn@Vpred_fb@@@std@@@std@@YA?AU?$pair@PAURESULT@CDB@@PAU12@@0@PAURESULT@CDB@@0U?$_Ref_fn@Vpred_fb@@@0@@Z ENDP ; std::_Partition_by_median_guess_unchecked<CDB::RESULT *,std::_Ref_fn<pred_fb> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_Move_backward_unchecked@PAURESULT@CDB@@PAU12@@std@@YAPAURESULT@CDB@@PAU12@00@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
??$_Move_backward_unchecked@PAURESULT@CDB@@PAU12@@std@@YAPAURESULT@CDB@@PAU12@00@Z PROC ; std::_Move_backward_unchecked<CDB::RESULT *,CDB::RESULT *>, COMDAT
; __First$ = ecx
; __Last$ = edx

; 4255 :     auto _Result                = _CSTD memmove(_Dest_ch - _Count, _First_ch, _Count);

	mov	eax, DWORD PTR __Dest$[esp-4]
	sub	edx, ecx
	push	edx
	push	ecx
	sub	eax, edx
	push	eax
	call	_memmove
	add	esp, 12					; 0000000cH

; 4351 :     // move [_First, _Last) backwards to [..., _Dest)
; 4352 :     // note: _Move_backward_unchecked has callers other than the move_backward family
; 4353 :     if constexpr (_Ptr_move_cat<_BidIt1, _BidIt2>::_Trivially_copyable) {
; 4354 : #ifdef __cpp_lib_is_constant_evaluated
; 4355 :         if (!_STD is_constant_evaluated())
; 4356 : #endif // __cpp_lib_is_constant_evaluated
; 4357 :         {
; 4358 :             return _Copy_backward_memmove(_First, _Last, _Dest);
; 4359 :         }
; 4360 :     }
; 4361 : 
; 4362 :     while (_First != _Last) {
; 4363 :         *--_Dest = _STD move(*--_Last);
; 4364 :     }
; 4365 : 
; 4366 :     return _Dest;
; 4367 : }

	ret	0
??$_Move_backward_unchecked@PAURESULT@CDB@@PAU12@@std@@YAPAURESULT@CDB@@PAU12@00@Z ENDP ; std::_Move_backward_unchecked<CDB::RESULT *,CDB::RESULT *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
;	COMDAT ??$_Pop_heap_hole_by_index@PAURESULT@CDB@@U12@U?$_Ref_fn@Vpred_fb@@@std@@@std@@YAXPAURESULT@CDB@@HH$$QAU12@U?$_Ref_fn@Vpred_fb@@@0@@Z
_TEXT	SEGMENT
__Max_sequence_non_leaf$1$ = -12			; size = 4
__Top$1$ = -8						; size = 4
__First$1$ = -4						; size = 4
tv857 = 8						; size = 4
__Bottom$ = 8						; size = 4
__Val$ = 12						; size = 4
__Pred$ = 16						; size = 4
??$_Pop_heap_hole_by_index@PAURESULT@CDB@@U12@U?$_Ref_fn@Vpred_fb@@@std@@@std@@YAXPAURESULT@CDB@@HH$$QAU12@U?$_Ref_fn@Vpred_fb@@@0@@Z PROC ; std::_Pop_heap_hole_by_index<CDB::RESULT *,CDB::RESULT,std::_Ref_fn<pred_fb> >, COMDAT
; __First$ = ecx
; __Hole$ = edx

; 5375 :     _RanIt _First, _Iter_diff_t<_RanIt> _Hole, _Iter_diff_t<_RanIt> _Bottom, _Ty&& _Val, _Pr _Pred) {

	sub	esp, 12					; 0000000cH

; 5376 :     // percolate _Hole to _Bottom, then push _Val
; 5377 :     _STL_INTERNAL_CHECK(_Bottom > 0);
; 5378 : 
; 5379 :     using _Diff      = _Iter_diff_t<_RanIt>;
; 5380 :     const _Diff _Top = _Hole;
; 5381 :     _Diff _Idx       = _Hole;
; 5382 : 
; 5383 :     // Check whether _Idx can have a child before calculating that child's index, since
; 5384 :     // calculating the child's index can trigger integer overflows
; 5385 :     const _Diff _Max_sequence_non_leaf = (_Bottom - 1) >> 1; // shift for codegen

	mov	eax, DWORD PTR __Bottom$[esp+8]
	push	ebx
	dec	eax
	mov	ebx, edx
	push	ebp
	sar	eax, 1
	mov	ebp, ecx
	push	esi
	mov	DWORD PTR __Max_sequence_non_leaf$1$[esp+24], eax

; 5386 :     while (_Idx < _Max_sequence_non_leaf) { // move _Hole down to larger child

	cmp	ebx, eax
	mov	eax, DWORD PTR __Pred$[esp+20]
	push	edi
	mov	DWORD PTR __First$1$[esp+28], ebp
	mov	DWORD PTR __Top$1$[esp+28], ebx
	jge	$LN42@Pop_heap_h
	npad	6
$LL2@Pop_heap_h:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp

; 140  : 		return	camera.distance_to_sqr(t0.center) < camera.distance_to_sqr(t1.center);

	mov	esi, DWORD PTR [eax]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 5387 :         _Idx = 2 * _Idx + 2;

	lea	edi, DWORD PTR [edx+edx]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 287  : 	{	return (x-v.x)*(x-v.x) + (y-v.y)*(y-v.y) + (z-v.z)*(z-v.z);	}

	movss	xmm3, DWORD PTR [eax+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 5388 :         if (_DEBUG_LT_PRED(_Pred, *(_First + _Idx), *(_First + (_Idx - 1)))) {

	lea	ecx, DWORD PTR [edi*8]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 287  : 	{	return (x-v.x)*(x-v.x) + (y-v.y)*(y-v.y) + (z-v.z)*(z-v.z);	}

	movss	xmm5, DWORD PTR [eax+4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 5388 :         if (_DEBUG_LT_PRED(_Pred, *(_First + _Idx), *(_First + (_Idx - 1)))) {

	sub	ecx, edi
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 287  : 	{	return (x-v.x)*(x-v.x) + (y-v.y)*(y-v.y) + (z-v.z)*(z-v.z);	}

	movss	xmm2, DWORD PTR [eax+12]
	movaps	xmm4, xmm5
	movaps	xmm1, xmm3
	movaps	xmm0, xmm2
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp

; 138  : 		occTri&	t0	= m_pTris	[_1.id];

	imul	edx, DWORD PTR [ebp+ecx*8+152], 88

; 139  : 		occTri&	t1	= m_pTris	[_2.id];

	imul	ecx, DWORD PTR [ebp+ecx*8+96], 88
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 287  : 	{	return (x-v.x)*(x-v.x) + (y-v.y)*(y-v.y) + (z-v.z)*(z-v.z);	}

	subss	xmm4, DWORD PTR [edx+esi+76]
	subss	xmm5, DWORD PTR [ecx+esi+76]
	subss	xmm3, DWORD PTR [ecx+esi+80]
	subss	xmm1, DWORD PTR [edx+esi+80]
	subss	xmm2, DWORD PTR [ecx+esi+84]
	subss	xmm0, DWORD PTR [edx+esi+84]
	mulss	xmm4, xmm4
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp

; 140  : 		return	camera.distance_to_sqr(t0.center) < camera.distance_to_sqr(t1.center);

	mov	edx, 1
	mov	ecx, 2
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 287  : 	{	return (x-v.x)*(x-v.x) + (y-v.y)*(y-v.y) + (z-v.z)*(z-v.z);	}

	mulss	xmm5, xmm5
	mulss	xmm1, xmm1
	mulss	xmm3, xmm3
	addss	xmm4, xmm1
	mulss	xmm0, xmm0
	addss	xmm5, xmm3
	mulss	xmm2, xmm2
	addss	xmm4, xmm0
	addss	xmm5, xmm2
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp

; 140  : 		return	camera.distance_to_sqr(t0.center) < camera.distance_to_sqr(t1.center);

	comiss	xmm5, xmm4
	cmova	ecx, edx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 5391 :         *(_First + _Hole) = _STD move(*(_First + _Idx));

	lea	edx, DWORD PTR [edi+ecx]
	lea	ecx, DWORD PTR [edx*8]
	sub	ecx, edx
	lea	esi, DWORD PTR [ecx*8]
	lea	ecx, DWORD PTR [ebx*8]
	add	esi, ebp
	sub	ecx, ebx

; 5392 :         _Hole             = _Idx;

	mov	ebx, edx
	lea	edi, DWORD PTR [ecx*8]
	mov	ecx, 14					; 0000000eH
	add	edi, ebp
	rep movsd
	mov	ecx, DWORD PTR __Max_sequence_non_leaf$1$[esp+28]
	cmp	edx, ecx
	jl	$LL2@Pop_heap_h

; 5386 :     while (_Idx < _Max_sequence_non_leaf) { // move _Hole down to larger child

	jmp	SHORT $LN3@Pop_heap_h
$LN42@Pop_heap_h:
	mov	ecx, DWORD PTR __Max_sequence_non_leaf$1$[esp+28]
$LN3@Pop_heap_h:

; 5393 :     }
; 5394 : 
; 5395 :     if (_Idx == _Max_sequence_non_leaf && _Bottom % 2 == 0) { // only child at bottom, move _Hole down to it

	cmp	edx, ecx
	jne	SHORT $LN5@Pop_heap_h
	mov	edx, DWORD PTR __Bottom$[esp+24]
	test	dl, 1
	jne	SHORT $LN5@Pop_heap_h

; 5396 :         *(_First + _Hole) = _STD move(*(_First + (_Bottom - 1)));

	lea	ecx, DWORD PTR [edx*8]
	sub	ecx, edx
	lea	esi, DWORD PTR [ecx*8-56]
	lea	ecx, DWORD PTR [ebx*8]
	add	esi, ebp
	sub	ecx, ebx

; 5397 :         _Hole             = _Bottom - 1;

	lea	ebx, DWORD PTR [edx-1]
	lea	edi, DWORD PTR [ecx*8]
	mov	ecx, 14					; 0000000eH
	add	edi, ebp
	rep movsd
$LN5@Pop_heap_h:

; 5267 :     for (_Diff _Idx = (_Hole - 1) >> 1; // shift for codegen

	lea	ebp, DWORD PTR [ebx-1]
	sar	ebp, 1

; 5268 :          _Top < _Hole && _DEBUG_LT_PRED(_Pred, *(_First + _Idx), _Val); //

	cmp	DWORD PTR __Top$1$[esp+28], ebx
	jge	$LN41@Pop_heap_h
	npad	5
$LL20@Pop_heap_h:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp

; 138  : 		occTri&	t0	= m_pTris	[_1.id];

	mov	edi, DWORD PTR __First$1$[esp+28]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 5268 :          _Top < _Hole && _DEBUG_LT_PRED(_Pred, *(_First + _Idx), _Val); //

	lea	ecx, DWORD PTR [ebp*8]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp

; 139  : 		occTri&	t1	= m_pTris	[_2.id];

	mov	edx, DWORD PTR __Val$[esp+24]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 5268 :          _Top < _Hole && _DEBUG_LT_PRED(_Pred, *(_First + _Idx), _Val); //

	sub	ecx, ebp
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp

; 140  : 		return	camera.distance_to_sqr(t0.center) < camera.distance_to_sqr(t1.center);

	mov	esi, DWORD PTR [eax]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 287  : 	{	return (x-v.x)*(x-v.x) + (y-v.y)*(y-v.y) + (z-v.z)*(z-v.z);	}

	movss	xmm5, DWORD PTR [eax+8]
	movss	xmm4, DWORD PTR [eax+4]
	movaps	xmm1, xmm5
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp

; 139  : 		occTri&	t1	= m_pTris	[_2.id];

	imul	edx, DWORD PTR [edx+40], 88
	lea	ecx, DWORD PTR [edi+ecx*8]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 287  : 	{	return (x-v.x)*(x-v.x) + (y-v.y)*(y-v.y) + (z-v.z)*(z-v.z);	}

	movss	xmm2, DWORD PTR [eax+12]
	movaps	xmm3, xmm4
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp

; 138  : 		occTri&	t0	= m_pTris	[_1.id];

	mov	DWORD PTR tv857[esp+24], ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 287  : 	{	return (x-v.x)*(x-v.x) + (y-v.y)*(y-v.y) + (z-v.z)*(z-v.z);	}

	movaps	xmm0, xmm2
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp

; 138  : 		occTri&	t0	= m_pTris	[_1.id];

	imul	ecx, DWORD PTR [ecx+40], 88
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 287  : 	{	return (x-v.x)*(x-v.x) + (y-v.y)*(y-v.y) + (z-v.z)*(z-v.z);	}

	subss	xmm4, DWORD PTR [edx+esi+76]
	subss	xmm5, DWORD PTR [edx+esi+80]
	subss	xmm2, DWORD PTR [edx+esi+84]
	subss	xmm3, DWORD PTR [ecx+esi+76]
	subss	xmm1, DWORD PTR [ecx+esi+80]
	subss	xmm0, DWORD PTR [ecx+esi+84]
	mulss	xmm4, xmm4
	mulss	xmm3, xmm3
	mulss	xmm1, xmm1
	mulss	xmm5, xmm5
	addss	xmm3, xmm1
	mulss	xmm0, xmm0
	addss	xmm4, xmm5
	mulss	xmm2, xmm2
	addss	xmm3, xmm0
	addss	xmm4, xmm2
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp

; 140  : 		return	camera.distance_to_sqr(t0.center) < camera.distance_to_sqr(t1.center);

	comiss	xmm4, xmm3
	jbe	SHORT $LN41@Pop_heap_h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 5271 :         *(_First + _Hole) = _STD move(*(_First + _Idx));

	mov	esi, DWORD PTR tv857[esp+24]
	lea	ecx, DWORD PTR [ebx*8]
	sub	ecx, ebx

; 5272 :         _Hole             = _Idx;

	mov	ebx, ebp
	dec	ebp
	sar	ebp, 1
	lea	edi, DWORD PTR [edi+ecx*8]
	mov	ecx, 14					; 0000000eH
	rep movsd
	cmp	DWORD PTR __Top$1$[esp+28], ebx
	jl	$LL20@Pop_heap_h
$LN41@Pop_heap_h:

; 5273 :     }
; 5274 : 
; 5275 :     *(_First + _Hole) = _STD forward<_Ty>(_Val); // drop _Val into final hole

	mov	ecx, DWORD PTR __First$1$[esp+28]
	lea	eax, DWORD PTR [ebx*8]
	mov	esi, DWORD PTR __Val$[esp+24]
	sub	eax, ebx
	lea	edi, DWORD PTR [ecx+eax*8]
	mov	ecx, 14					; 0000000eH
	rep movsd
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 5398 :     }
; 5399 : 
; 5400 :     _Push_heap_by_index(_First, _Hole, _Top, _STD forward<_Ty>(_Val), _Pred);
; 5401 : }

	add	esp, 12					; 0000000cH
	ret	0
??$_Pop_heap_hole_by_index@PAURESULT@CDB@@U12@U?$_Ref_fn@Vpred_fb@@@std@@@std@@YAXPAURESULT@CDB@@HH$$QAU12@U?$_Ref_fn@Vpred_fb@@@0@@Z ENDP ; std::_Pop_heap_hole_by_index<CDB::RESULT *,CDB::RESULT,std::_Ref_fn<pred_fb> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
;	COMDAT ??$_Pop_heap_unchecked@PAURESULT@CDB@@U?$_Ref_fn@Vpred_fb@@@std@@@std@@YAXPAURESULT@CDB@@0U?$_Ref_fn@Vpred_fb@@@0@@Z
_TEXT	SEGMENT
__Val$1 = -56						; size = 56
__Pred$ = 8						; size = 4
??$_Pop_heap_unchecked@PAURESULT@CDB@@U?$_Ref_fn@Vpred_fb@@@std@@@std@@YAXPAURESULT@CDB@@0U?$_Ref_fn@Vpred_fb@@@0@@Z PROC ; std::_Pop_heap_unchecked<CDB::RESULT *,std::_Ref_fn<pred_fb> >, COMDAT
; __First$ = ecx
; __Last$ = edx

; 5415 : _CONSTEXPR20 void _Pop_heap_unchecked(_RanIt _First, _RanIt _Last, _Pr _Pred) {

	sub	esp, 60					; 0000003cH

; 5416 :     // pop *_First to *(_Last - 1) and reheap
; 5417 :     if (2 <= _Last - _First) {

	mov	eax, edx
	push	ebx
	mov	ebx, ecx
	sub	eax, ebx
	sar	eax, 3
	imul	eax, eax, -1227133513
	push	esi
	push	edi
	cmp	eax, 2
	jl	SHORT $LN2@Pop_heap_u

; 5410 :     _Pop_heap_hole_by_index(

	push	DWORD PTR __Pred$[esp+68]

; 5418 :         --_Last;

	sub	edx, 56					; 00000038H

; 5419 :         _Iter_value_t<_RanIt> _Val = _STD move(*_Last);

	lea	edi, DWORD PTR __Val$1[esp+76]
	mov	esi, edx

; 5410 :     _Pop_heap_hole_by_index(

	lea	eax, DWORD PTR __Val$1[esp+76]

; 5419 :         _Iter_value_t<_RanIt> _Val = _STD move(*_Last);

	mov	ecx, 14					; 0000000eH
	rep movsd

; 5408 :     *_Dest      = _STD move(*_First);

	mov	edi, edx
	mov	ecx, 14					; 0000000eH

; 5409 :     using _Diff = _Iter_diff_t<_RanIt>;
; 5410 :     _Pop_heap_hole_by_index(

	sub	edx, ebx
	mov	esi, ebx
	sar	edx, 3
	push	eax
	imul	eax, edx, -1227133513
	xor	edx, edx
	rep movsd
	push	eax
	mov	ecx, ebx
	call	??$_Pop_heap_hole_by_index@PAURESULT@CDB@@U12@U?$_Ref_fn@Vpred_fb@@@std@@@std@@YAXPAURESULT@CDB@@HH$$QAU12@U?$_Ref_fn@Vpred_fb@@@0@@Z ; std::_Pop_heap_hole_by_index<CDB::RESULT *,CDB::RESULT,std::_Ref_fn<pred_fb> >
	add	esp, 12					; 0000000cH
$LN2@Pop_heap_u:

; 5420 :         _Pop_heap_hole_unchecked(_First, _Last, _Last, _STD move(_Val), _Pred);
; 5421 :     }
; 5422 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 60					; 0000003cH
	ret	0
??$_Pop_heap_unchecked@PAURESULT@CDB@@U?$_Ref_fn@Vpred_fb@@@std@@@std@@YAXPAURESULT@CDB@@0U?$_Ref_fn@Vpred_fb@@@0@@Z ENDP ; std::_Pop_heap_unchecked<CDB::RESULT *,std::_Ref_fn<pred_fb> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_Prev_iter@PAURESULT@CDB@@@std@@YAPAURESULT@CDB@@PAU12@@Z
_TEXT	SEGMENT
??$_Prev_iter@PAURESULT@CDB@@@std@@YAPAURESULT@CDB@@PAU12@@Z PROC ; std::_Prev_iter<CDB::RESULT *>, COMDAT
; __First$ = ecx

; 1554 :     return --_First;

	lea	eax, DWORD PTR [ecx-56]

; 1555 : }

	ret	0
??$_Prev_iter@PAURESULT@CDB@@@std@@YAPAURESULT@CDB@@PAU12@@Z ENDP ; std::_Prev_iter<CDB::RESULT *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
;	COMDAT ??$_Guess_median_unchecked@PAURESULT@CDB@@U?$_Ref_fn@Vpred_fb@@@std@@@std@@YAXPAURESULT@CDB@@00U?$_Ref_fn@Vpred_fb@@@0@@Z
_TEXT	SEGMENT
__Mid$1$ = -8						; size = 4
__First$1$ = -4						; size = 4
__Last$ = 8						; size = 4
__Pred$ = 12						; size = 4
??$_Guess_median_unchecked@PAURESULT@CDB@@U?$_Ref_fn@Vpred_fb@@@std@@@std@@YAXPAURESULT@CDB@@00U?$_Ref_fn@Vpred_fb@@@0@@Z PROC ; std::_Guess_median_unchecked<CDB::RESULT *,std::_Ref_fn<pred_fb> >, COMDAT
; __First$ = ecx
; __Mid$ = edx

; 6959 : _CONSTEXPR20 void _Guess_median_unchecked(_RanIt _First, _RanIt _Mid, _RanIt _Last, _Pr _Pred) {

	sub	esp, 12					; 0000000cH
	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	edi, ecx
	mov	DWORD PTR __Mid$1$[esp+28], edx

; 6960 :     // sort median element to middle
; 6961 :     using _Diff        = _Iter_diff_t<_RanIt>;
; 6962 :     const _Diff _Count = _Last - _First;

	mov	ecx, DWORD PTR __Last$[esp+24]
	mov	eax, ecx
	sub	eax, edi
	mov	DWORD PTR __First$1$[esp+28], edi
	sar	eax, 3
	imul	eax, eax, -1227133513

; 6963 :     if (40 < _Count) { // Tukey's ninther

	cmp	eax, 40					; 00000028H
	jle	SHORT $LN2@Guess_medi

; 6964 :         const _Diff _Step     = (_Count + 1) >> 3; // +1 can't overflow because range was made inclusive in caller
; 6965 :         const _Diff _Two_step = _Step << 1; // note: intentionally discards low-order bit
; 6966 :         _Med3_unchecked(_First, _First + _Step, _First + _Two_step, _Pred);

	mov	esi, DWORD PTR __Pred$[esp+24]
	inc	eax
	sar	eax, 3
	mov	ecx, edi
	imul	ebp, eax, 112
	push	esi
	lea	ebx, DWORD PTR [eax*8]
	sub	ebx, eax
	shl	ebx, 3
	lea	eax, DWORD PTR [edi+ebp]
	lea	edx, DWORD PTR [ebx+edi]
	push	eax
	call	??$_Med3_unchecked@PAURESULT@CDB@@U?$_Ref_fn@Vpred_fb@@@std@@@std@@YAXPAURESULT@CDB@@00U?$_Ref_fn@Vpred_fb@@@0@@Z ; std::_Med3_unchecked<CDB::RESULT *,std::_Ref_fn<pred_fb> >

; 6967 :         _Med3_unchecked(_Mid - _Step, _Mid, _Mid + _Step, _Pred);

	mov	edx, DWORD PTR __Mid$1$[esp+36]
	mov	ecx, edx
	push	esi
	sub	ecx, ebx
	lea	eax, DWORD PTR [ebx+edx]
	push	eax
	call	??$_Med3_unchecked@PAURESULT@CDB@@U?$_Ref_fn@Vpred_fb@@@std@@@std@@YAXPAURESULT@CDB@@00U?$_Ref_fn@Vpred_fb@@@0@@Z ; std::_Med3_unchecked<CDB::RESULT *,std::_Ref_fn<pred_fb> >

; 6968 :         _Med3_unchecked(_Last - _Two_step, _Last - _Step, _Last, _Pred);

	mov	eax, DWORD PTR __Last$[esp+40]
	mov	edi, eax
	push	esi
	push	eax
	sub	eax, ebp
	sub	edi, ebx
	mov	edx, edi
	mov	ecx, eax
	call	??$_Med3_unchecked@PAURESULT@CDB@@U?$_Ref_fn@Vpred_fb@@@std@@@std@@YAXPAURESULT@CDB@@00U?$_Ref_fn@Vpred_fb@@@0@@Z ; std::_Med3_unchecked<CDB::RESULT *,std::_Ref_fn<pred_fb> >

; 6969 :         _Med3_unchecked(_First + _Step, _Mid, _Last - _Step, _Pred);

	mov	ecx, DWORD PTR __First$1$[esp+52]
	mov	edx, DWORD PTR __Mid$1$[esp+52]
	push	esi
	push	edi
	lea	ecx, DWORD PTR [ebx+ecx]
	call	??$_Med3_unchecked@PAURESULT@CDB@@U?$_Ref_fn@Vpred_fb@@@std@@@std@@YAXPAURESULT@CDB@@00U?$_Ref_fn@Vpred_fb@@@0@@Z ; std::_Med3_unchecked<CDB::RESULT *,std::_Ref_fn<pred_fb> >
	add	esp, 32					; 00000020H

; 6972 :     }
; 6973 : }

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 12					; 0000000cH
	ret	0
$LN2@Guess_medi:

; 6970 :     } else {
; 6971 :         _Med3_unchecked(_First, _Mid, _Last, _Pred);

	push	DWORD PTR __Pred$[esp+24]
	push	ecx
	mov	ecx, edi
	call	??$_Med3_unchecked@PAURESULT@CDB@@U?$_Ref_fn@Vpred_fb@@@std@@@std@@YAXPAURESULT@CDB@@00U?$_Ref_fn@Vpred_fb@@@0@@Z ; std::_Med3_unchecked<CDB::RESULT *,std::_Ref_fn<pred_fb> >
	add	esp, 8

; 6972 :     }
; 6973 : }

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 12					; 0000000cH
	ret	0
??$_Guess_median_unchecked@PAURESULT@CDB@@U?$_Ref_fn@Vpred_fb@@@std@@@std@@YAXPAURESULT@CDB@@00U?$_Ref_fn@Vpred_fb@@@0@@Z ENDP ; std::_Guess_median_unchecked<CDB::RESULT *,std::_Ref_fn<pred_fb> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_Next_iter@PAURESULT@CDB@@@std@@YAPAURESULT@CDB@@PAU12@@Z
_TEXT	SEGMENT
??$_Next_iter@PAURESULT@CDB@@@std@@YAPAURESULT@CDB@@PAU12@@Z PROC ; std::_Next_iter<CDB::RESULT *>, COMDAT
; __First$ = ecx

; 1541 :     return ++_First;

	lea	eax, DWORD PTR [ecx+56]

; 1542 : }

	ret	0
??$_Next_iter@PAURESULT@CDB@@@std@@YAPAURESULT@CDB@@PAU12@@Z ENDP ; std::_Next_iter<CDB::RESULT *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
;	COMDAT ??$iter_swap@PAURESULT@CDB@@PAU12@@std@@YAXPAURESULT@CDB@@0@Z
_TEXT	SEGMENT
__Tmp$1 = -60						; size = 56
??$iter_swap@PAURESULT@CDB@@PAU12@@std@@YAXPAURESULT@CDB@@0@Z PROC ; std::iter_swap<CDB::RESULT *,CDB::RESULT *>, COMDAT
; __Left$ = ecx
; __Right$ = edx

; 77   : _CONSTEXPR20 void iter_swap(_FwdIt1 _Left, _FwdIt2 _Right) { // swap *_Left and *_Right

	sub	esp, 60					; 0000003cH
	mov	eax, ecx

; 100  :     _Ty _Tmp = _STD move(_Left);

	mov	ecx, 14					; 0000000eH

; 77   : _CONSTEXPR20 void iter_swap(_FwdIt1 _Left, _FwdIt2 _Right) { // swap *_Left and *_Right

	push	esi
	push	edi

; 100  :     _Ty _Tmp = _STD move(_Left);

	mov	esi, eax
	lea	edi, DWORD PTR __Tmp$1[esp+68]
	rep movsd

; 101  :     _Left    = _STD move(_Right);

	mov	ecx, 14					; 0000000eH
	mov	esi, edx
	mov	edi, eax
	rep movsd

; 102  :     _Right   = _STD move(_Tmp);

	mov	ecx, 14					; 0000000eH
	lea	esi, DWORD PTR __Tmp$1[esp+68]
	mov	edi, edx
	rep movsd

; 78   :     swap(*_Left, *_Right);
; 79   : }

	pop	edi
	pop	esi
	add	esp, 60					; 0000003cH
	ret	0
??$iter_swap@PAURESULT@CDB@@PAU12@@std@@YAXPAURESULT@CDB@@0@Z ENDP ; std::iter_swap<CDB::RESULT *,CDB::RESULT *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
;	COMDAT ??$?0AAPAURESULT@CDB@@AAPAU01@$0A@@?$pair@PAURESULT@CDB@@PAU12@@std@@QAE@AAPAURESULT@CDB@@0@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??$?0AAPAURESULT@CDB@@AAPAU01@$0A@@?$pair@PAURESULT@CDB@@PAU12@@std@@QAE@AAPAURESULT@CDB@@0@Z PROC ; std::pair<CDB::RESULT *,CDB::RESULT *>::pair<CDB::RESULT *,CDB::RESULT *><CDB::RESULT * &,CDB::RESULT * &,0>, COMDAT
; _this$ = ecx

; 186  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

	mov	eax, DWORD PTR __Val1$[esp-4]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR __Val2$[esp-4]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx+4], eax
	mov	eax, ecx
	ret	8
??$?0AAPAURESULT@CDB@@AAPAU01@$0A@@?$pair@PAURESULT@CDB@@PAU12@@std@@QAE@AAPAURESULT@CDB@@0@Z ENDP ; std::pair<CDB::RESULT *,CDB::RESULT *>::pair<CDB::RESULT *,CDB::RESULT *><CDB::RESULT * &,CDB::RESULT * &,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_Copy_backward_memmove@PAURESULT@CDB@@PAU12@@std@@YAPAURESULT@CDB@@PAU12@00@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
??$_Copy_backward_memmove@PAURESULT@CDB@@PAU12@@std@@YAPAURESULT@CDB@@PAU12@00@Z PROC ; std::_Copy_backward_memmove<CDB::RESULT *,CDB::RESULT *>, COMDAT
; __First$ = ecx
; __Last$ = edx

; 4247 :     // implement copy_backward-like function as memmove
; 4248 :     auto _FirstPtr              = _To_address(_First);
; 4249 :     auto _LastPtr               = _To_address(_Last);
; 4250 :     auto _DestPtr               = _To_address(_Dest);
; 4251 :     const char* const _First_ch = const_cast<const char*>(reinterpret_cast<const volatile char*>(_FirstPtr));
; 4252 :     const char* const _Last_ch  = const_cast<const char*>(reinterpret_cast<const volatile char*>(_LastPtr));
; 4253 :     char* const _Dest_ch        = const_cast<char*>(reinterpret_cast<const volatile char*>(_DestPtr));
; 4254 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);
; 4255 :     auto _Result                = _CSTD memmove(_Dest_ch - _Count, _First_ch, _Count);

	mov	eax, DWORD PTR __Dest$[esp-4]
	sub	edx, ecx
	push	edx
	push	ecx
	sub	eax, edx
	push	eax
	call	_memmove
	add	esp, 12					; 0000000cH

; 4256 :     if constexpr (is_pointer_v<_CtgIt2>) {
; 4257 :         return static_cast<_CtgIt2>(_Result);
; 4258 :     } else {
; 4259 :         return _Dest - (_LastPtr - _FirstPtr);
; 4260 :     }
; 4261 : }

	ret	0
??$_Copy_backward_memmove@PAURESULT@CDB@@PAU12@@std@@YAPAURESULT@CDB@@PAU12@00@Z ENDP ; std::_Copy_backward_memmove<CDB::RESULT *,CDB::RESULT *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\type_traits
;	COMDAT ??$forward@URESULT@CDB@@@std@@YA$$QAURESULT@CDB@@AAU12@@Z
_TEXT	SEGMENT
??$forward@URESULT@CDB@@@std@@YA$$QAURESULT@CDB@@AAU12@@Z PROC ; std::forward<CDB::RESULT>, COMDAT
; __Arg$ = ecx

; 1386 :     return static_cast<_Ty&&>(_Arg);

	mov	eax, ecx

; 1387 : }

	ret	0
??$forward@URESULT@CDB@@@std@@YA$$QAURESULT@CDB@@AAU12@@Z ENDP ; std::forward<CDB::RESULT>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
;	COMDAT ??$_Push_heap_by_index@PAURESULT@CDB@@U12@U?$_Ref_fn@Vpred_fb@@@std@@@std@@YAXPAURESULT@CDB@@HH$$QAU12@U?$_Ref_fn@Vpred_fb@@@0@@Z
_TEXT	SEGMENT
tv368 = -4						; size = 4
__Top$ = 8						; size = 4
__Val$ = 12						; size = 4
__Pred$ = 16						; size = 4
??$_Push_heap_by_index@PAURESULT@CDB@@U12@U?$_Ref_fn@Vpred_fb@@@std@@@std@@YAXPAURESULT@CDB@@HH$$QAU12@U?$_Ref_fn@Vpred_fb@@@0@@Z PROC ; std::_Push_heap_by_index<CDB::RESULT *,CDB::RESULT,std::_Ref_fn<pred_fb> >, COMDAT
; __First$ = ecx
; __Hole$ = edx

; 5264 :     _RanIt _First, _Iter_diff_t<_RanIt> _Hole, _Iter_diff_t<_RanIt> _Top, _Ty&& _Val, _Pr _Pred) {

	push	ecx
	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	edi, edx
	mov	ebp, ecx

; 5265 :     // percolate _Hole to _Top or where _Val belongs
; 5266 :     using _Diff = _Iter_diff_t<_RanIt>;
; 5267 :     for (_Diff _Idx = (_Hole - 1) >> 1; // shift for codegen

	lea	ebx, DWORD PTR [edi-1]
	sar	ebx, 1

; 5268 :          _Top < _Hole && _DEBUG_LT_PRED(_Pred, *(_First + _Idx), _Val); //

	cmp	DWORD PTR __Top$[esp+16], edi
	jge	$LN21@Push_heap_
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp

; 140  : 		return	camera.distance_to_sqr(t0.center) < camera.distance_to_sqr(t1.center);

	mov	eax, DWORD PTR __Pred$[esp+16]
	npad	4
$LL4@Push_heap_:

; 139  : 		occTri&	t1	= m_pTris	[_2.id];

	mov	edx, DWORD PTR __Val$[esp+16]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 5268 :          _Top < _Hole && _DEBUG_LT_PRED(_Pred, *(_First + _Idx), _Val); //

	lea	ecx, DWORD PTR [ebx*8]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp

; 140  : 		return	camera.distance_to_sqr(t0.center) < camera.distance_to_sqr(t1.center);

	mov	esi, DWORD PTR [eax]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 5268 :          _Top < _Hole && _DEBUG_LT_PRED(_Pred, *(_First + _Idx), _Val); //

	sub	ecx, ebx
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 287  : 	{	return (x-v.x)*(x-v.x) + (y-v.y)*(y-v.y) + (z-v.z)*(z-v.z);	}

	movss	xmm5, DWORD PTR [eax+8]
	movss	xmm4, DWORD PTR [eax+4]
	movaps	xmm1, xmm5
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp

; 139  : 		occTri&	t1	= m_pTris	[_2.id];

	imul	edx, DWORD PTR [edx+40], 88
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 287  : 	{	return (x-v.x)*(x-v.x) + (y-v.y)*(y-v.y) + (z-v.z)*(z-v.z);	}

	movaps	xmm3, xmm4
	movss	xmm2, DWORD PTR [eax+12]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp

; 138  : 		occTri&	t0	= m_pTris	[_1.id];

	lea	ecx, DWORD PTR [ecx*8]
	add	ecx, ebp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 287  : 	{	return (x-v.x)*(x-v.x) + (y-v.y)*(y-v.y) + (z-v.z)*(z-v.z);	}

	movaps	xmm0, xmm2
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp

; 138  : 		occTri&	t0	= m_pTris	[_1.id];

	mov	DWORD PTR tv368[esp+20], ecx
	imul	ecx, DWORD PTR [ecx+40], 88
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 287  : 	{	return (x-v.x)*(x-v.x) + (y-v.y)*(y-v.y) + (z-v.z)*(z-v.z);	}

	subss	xmm4, DWORD PTR [edx+esi+76]
	subss	xmm5, DWORD PTR [edx+esi+80]
	subss	xmm2, DWORD PTR [edx+esi+84]
	mulss	xmm4, xmm4
	subss	xmm3, DWORD PTR [ecx+esi+76]
	subss	xmm1, DWORD PTR [ecx+esi+80]
	subss	xmm0, DWORD PTR [ecx+esi+84]
	mulss	xmm5, xmm5
	mulss	xmm3, xmm3
	mulss	xmm1, xmm1
	addss	xmm4, xmm5
	mulss	xmm0, xmm0
	addss	xmm3, xmm1
	mulss	xmm2, xmm2
	addss	xmm4, xmm2
	addss	xmm3, xmm0
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp

; 140  : 		return	camera.distance_to_sqr(t0.center) < camera.distance_to_sqr(t1.center);

	comiss	xmm4, xmm3
	jbe	SHORT $LN21@Push_heap_
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 5271 :         *(_First + _Hole) = _STD move(*(_First + _Idx));

	mov	esi, DWORD PTR tv368[esp+20]
	lea	ecx, DWORD PTR [edi*8]
	sub	ecx, edi
	lea	edi, DWORD PTR [ecx*8]
	mov	ecx, 14					; 0000000eH
	add	edi, ebp
	rep movsd

; 5272 :         _Hole             = _Idx;

	mov	edi, ebx
	dec	ebx
	sar	ebx, 1
	cmp	DWORD PTR __Top$[esp+16], edi
	jl	$LL4@Push_heap_
$LN21@Push_heap_:

; 5273 :     }
; 5274 : 
; 5275 :     *(_First + _Hole) = _STD forward<_Ty>(_Val); // drop _Val into final hole

	mov	esi, DWORD PTR __Val$[esp+16]
	lea	eax, DWORD PTR [edi*8]
	sub	eax, edi
	mov	ecx, 14					; 0000000eH
	lea	edi, DWORD PTR [eax*8]
	add	edi, ebp
	rep movsd
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 5276 : }

	pop	ecx
	ret	0
??$_Push_heap_by_index@PAURESULT@CDB@@U12@U?$_Ref_fn@Vpred_fb@@@std@@@std@@YAXPAURESULT@CDB@@HH$$QAU12@U?$_Ref_fn@Vpred_fb@@@0@@Z ENDP ; std::_Push_heap_by_index<CDB::RESULT *,CDB::RESULT,std::_Ref_fn<pred_fb> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
;	COMDAT ??$_Pop_heap_hole_unchecked@PAURESULT@CDB@@U12@U?$_Ref_fn@Vpred_fb@@@std@@@std@@YAXPAURESULT@CDB@@00$$QAU12@U?$_Ref_fn@Vpred_fb@@@0@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Val$ = 12						; size = 4
__Pred$ = 16						; size = 4
??$_Pop_heap_hole_unchecked@PAURESULT@CDB@@U12@U?$_Ref_fn@Vpred_fb@@@std@@@std@@YAXPAURESULT@CDB@@00$$QAU12@U?$_Ref_fn@Vpred_fb@@@0@@Z PROC ; std::_Pop_heap_hole_unchecked<CDB::RESULT *,CDB::RESULT,std::_Ref_fn<pred_fb> >, COMDAT
; __First$ = ecx
; __Last$ = edx

; 5404 : _CONSTEXPR20 void _Pop_heap_hole_unchecked(_RanIt _First, _RanIt _Last, _RanIt _Dest, _Ty&& _Val, _Pr _Pred) {

	push	ebx
	mov	ebx, ecx

; 5405 :     // pop *_First to *_Dest and reheap
; 5406 :     // precondition: _First != _Last
; 5407 :     // precondition: _First != _Dest
; 5408 :     *_Dest      = _STD move(*_First);

	mov	ecx, 14					; 0000000eH
	push	esi
	push	edi

; 5409 :     using _Diff = _Iter_diff_t<_RanIt>;
; 5410 :     _Pop_heap_hole_by_index(

	push	DWORD PTR __Pred$[esp+8]
	mov	edi, DWORD PTR __Dest$[esp+12]
	sub	edx, ebx
	push	DWORD PTR __Val$[esp+12]
	sar	edx, 3
	mov	esi, ebx
	imul	eax, edx, -1227133513
	xor	edx, edx
	rep movsd
	push	eax
	mov	ecx, ebx
	call	??$_Pop_heap_hole_by_index@PAURESULT@CDB@@U12@U?$_Ref_fn@Vpred_fb@@@std@@@std@@YAXPAURESULT@CDB@@HH$$QAU12@U?$_Ref_fn@Vpred_fb@@@0@@Z ; std::_Pop_heap_hole_by_index<CDB::RESULT *,CDB::RESULT,std::_Ref_fn<pred_fb> >
	add	esp, 12					; 0000000cH
	pop	edi
	pop	esi
	pop	ebx

; 5411 :         _First, static_cast<_Diff>(0), static_cast<_Diff>(_Last - _First), _STD forward<_Ty>(_Val), _Pred);
; 5412 : }

	ret	0
??$_Pop_heap_hole_unchecked@PAURESULT@CDB@@U12@U?$_Ref_fn@Vpred_fb@@@std@@@std@@YAXPAURESULT@CDB@@00$$QAU12@U?$_Ref_fn@Vpred_fb@@@0@@Z ENDP ; std::_Pop_heap_hole_unchecked<CDB::RESULT *,CDB::RESULT,std::_Ref_fn<pred_fb> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
;	COMDAT ??$_Med3_unchecked@PAURESULT@CDB@@U?$_Ref_fn@Vpred_fb@@@std@@@std@@YAXPAURESULT@CDB@@00U?$_Ref_fn@Vpred_fb@@@0@@Z
_TEXT	SEGMENT
__Tmp$1 = -60						; size = 56
__Tmp$2 = -60						; size = 56
__Last$ = 8						; size = 4
__Pred$ = 12						; size = 4
??$_Med3_unchecked@PAURESULT@CDB@@U?$_Ref_fn@Vpred_fb@@@std@@@std@@YAXPAURESULT@CDB@@00U?$_Ref_fn@Vpred_fb@@@0@@Z PROC ; std::_Med3_unchecked<CDB::RESULT *,std::_Ref_fn<pred_fb> >, COMDAT
; __First$ = ecx
; __Mid$ = edx

; 6943 : _CONSTEXPR20 void _Med3_unchecked(_RanIt _First, _RanIt _Mid, _RanIt _Last, _Pr _Pred) {

	mov	eax, DWORD PTR __Pred$[esp-4]
	sub	esp, 60					; 0000003cH
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 287  : 	{	return (x-v.x)*(x-v.x) + (y-v.y)*(y-v.y) + (z-v.z)*(z-v.z);	}

	movss	xmm6, DWORD PTR [eax+8]
	movss	xmm5, DWORD PTR [eax+4]
	movaps	xmm3, xmm6
	movss	xmm7, DWORD PTR [eax+12]
	movaps	xmm4, xmm5
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 6943 : _CONSTEXPR20 void _Med3_unchecked(_RanIt _First, _RanIt _Mid, _RanIt _Last, _Pr _Pred) {

	push	ebx
	push	ebp
	mov	ebp, edx
	mov	ebx, ecx
	push	esi
	push	edi
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp

; 140  : 		return	camera.distance_to_sqr(t0.center) < camera.distance_to_sqr(t1.center);

	mov	edi, DWORD PTR [eax]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 287  : 	{	return (x-v.x)*(x-v.x) + (y-v.y)*(y-v.y) + (z-v.z)*(z-v.z);	}

	movaps	xmm2, xmm6
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp

; 139  : 		occTri&	t1	= m_pTris	[_2.id];

	imul	ecx, DWORD PTR [ebx+40], 88
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 287  : 	{	return (x-v.x)*(x-v.x) + (y-v.y)*(y-v.y) + (z-v.z)*(z-v.z);	}

	movaps	xmm1, xmm7
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp

; 138  : 		occTri&	t0	= m_pTris	[_1.id];

	mov	edx, DWORD PTR [ebp+40]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 287  : 	{	return (x-v.x)*(x-v.x) + (y-v.y)*(y-v.y) + (z-v.z)*(z-v.z);	}

	movaps	xmm0, xmm7
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp

; 138  : 		occTri&	t0	= m_pTris	[_1.id];

	imul	esi, edx, 88
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 287  : 	{	return (x-v.x)*(x-v.x) + (y-v.y)*(y-v.y) + (z-v.z)*(z-v.z);	}

	subss	xmm5, DWORD PTR [ecx+edi+76]
	subss	xmm2, DWORD PTR [ecx+edi+80]
	subss	xmm4, DWORD PTR [esi+edi+76]
	subss	xmm3, DWORD PTR [esi+edi+80]
	subss	xmm1, DWORD PTR [esi+edi+84]
	subss	xmm0, DWORD PTR [ecx+edi+84]
	mulss	xmm5, xmm5
	mulss	xmm4, xmm4
	mulss	xmm3, xmm3
	mulss	xmm2, xmm2
	addss	xmm4, xmm3
	mulss	xmm1, xmm1
	addss	xmm5, xmm2
	mulss	xmm0, xmm0
	addss	xmm4, xmm1
	addss	xmm5, xmm0
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp

; 140  : 		return	camera.distance_to_sqr(t0.center) < camera.distance_to_sqr(t1.center);

	comiss	xmm5, xmm4
	jbe	SHORT $LN2@Med3_unche
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 100  :     _Ty _Tmp = _STD move(_Left);

	mov	ecx, 14					; 0000000eH
	lea	edi, DWORD PTR __Tmp$2[esp+76]
	mov	esi, ebp
	rep movsd

; 101  :     _Left    = _STD move(_Right);

	mov	ecx, 14					; 0000000eH
	mov	esi, ebx
	mov	edi, ebp
	rep movsd

; 102  :     _Right   = _STD move(_Tmp);

	mov	ecx, 14					; 0000000eH
	lea	esi, DWORD PTR __Tmp$2[esp+76]
	mov	edi, ebx
	rep movsd
	mov	edx, DWORD PTR [ebp+40]
	mov	edi, DWORD PTR [eax]
	movss	xmm6, DWORD PTR [eax+8]
	movss	xmm7, DWORD PTR [eax+12]
$LN2@Med3_unche:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp

; 138  : 		occTri&	t0	= m_pTris	[_1.id];

	mov	ecx, DWORD PTR __Last$[esp+72]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 287  : 	{	return (x-v.x)*(x-v.x) + (y-v.y)*(y-v.y) + (z-v.z)*(z-v.z);	}

	movaps	xmm1, xmm6
	movss	xmm3, DWORD PTR [eax+4]
	movaps	xmm0, xmm7
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp

; 139  : 		occTri&	t1	= m_pTris	[_2.id];

	imul	edx, edx, 88
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 287  : 	{	return (x-v.x)*(x-v.x) + (y-v.y)*(y-v.y) + (z-v.z)*(z-v.z);	}

	movaps	xmm2, xmm3
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp

; 138  : 		occTri&	t0	= m_pTris	[_1.id];

	imul	ecx, DWORD PTR [ecx+40], 88
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 287  : 	{	return (x-v.x)*(x-v.x) + (y-v.y)*(y-v.y) + (z-v.z)*(z-v.z);	}

	subss	xmm3, DWORD PTR [edx+edi+76]
	subss	xmm6, DWORD PTR [edx+edi+80]
	subss	xmm2, DWORD PTR [ecx+edi+76]
	subss	xmm1, DWORD PTR [ecx+edi+80]
	subss	xmm0, DWORD PTR [ecx+edi+84]
	subss	xmm7, DWORD PTR [edx+edi+84]
	mulss	xmm3, xmm3
	mulss	xmm2, xmm2
	mulss	xmm1, xmm1
	mulss	xmm6, xmm6
	addss	xmm2, xmm1
	mulss	xmm0, xmm0
	addss	xmm3, xmm6
	mulss	xmm7, xmm7
	addss	xmm2, xmm0
	addss	xmm3, xmm7
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp

; 140  : 		return	camera.distance_to_sqr(t0.center) < camera.distance_to_sqr(t1.center);

	comiss	xmm3, xmm2
	jbe	$LN4@Med3_unche
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 100  :     _Ty _Tmp = _STD move(_Left);

	mov	esi, DWORD PTR __Last$[esp+72]
	lea	edi, DWORD PTR __Tmp$1[esp+76]
	mov	ecx, 14					; 0000000eH
	rep movsd

; 101  :     _Left    = _STD move(_Right);

	mov	edi, DWORD PTR __Last$[esp+72]
	mov	ecx, 14					; 0000000eH
	mov	esi, ebp
	rep movsd

; 102  :     _Right   = _STD move(_Tmp);

	mov	ecx, 14					; 0000000eH
	lea	esi, DWORD PTR __Tmp$1[esp+76]
	mov	edi, ebp
	rep movsd
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp

; 138  : 		occTri&	t0	= m_pTris	[_1.id];

	imul	ecx, DWORD PTR [ebp+40], 88

; 139  : 		occTri&	t1	= m_pTris	[_2.id];

	imul	edx, DWORD PTR [ebx+40], 88

; 140  : 		return	camera.distance_to_sqr(t0.center) < camera.distance_to_sqr(t1.center);

	mov	esi, DWORD PTR [eax]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 287  : 	{	return (x-v.x)*(x-v.x) + (y-v.y)*(y-v.y) + (z-v.z)*(z-v.z);	}

	movss	xmm5, DWORD PTR [eax+8]
	movss	xmm4, DWORD PTR [eax+4]
	movaps	xmm1, xmm5
	movss	xmm2, DWORD PTR [eax+12]
	movaps	xmm3, xmm4
	movaps	xmm0, xmm2
	subss	xmm3, DWORD PTR [ecx+esi+76]
	subss	xmm4, DWORD PTR [edx+esi+76]
	subss	xmm1, DWORD PTR [ecx+esi+80]
	subss	xmm5, DWORD PTR [edx+esi+80]
	subss	xmm0, DWORD PTR [ecx+esi+84]
	subss	xmm2, DWORD PTR [edx+esi+84]
	mulss	xmm3, xmm3
	mulss	xmm4, xmm4
	mulss	xmm1, xmm1
	mulss	xmm5, xmm5
	addss	xmm3, xmm1
	mulss	xmm0, xmm0
	addss	xmm4, xmm5
	mulss	xmm2, xmm2
	addss	xmm3, xmm0
	addss	xmm4, xmm2
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp

; 140  : 		return	camera.distance_to_sqr(t0.center) < camera.distance_to_sqr(t1.center);

	comiss	xmm4, xmm3
	jbe	SHORT $LN4@Med3_unche
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 101  :     _Left    = _STD move(_Right);

	mov	ecx, 14					; 0000000eH
	mov	esi, ebx
	mov	edi, ebp
	rep movsd

; 102  :     _Right   = _STD move(_Tmp);

	mov	ecx, 14					; 0000000eH
	lea	esi, DWORD PTR __Tmp$1[esp+76]
	mov	edi, ebx
	rep movsd
$LN4@Med3_unche:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 6956 : }

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 60					; 0000003cH
	ret	0
??$_Med3_unchecked@PAURESULT@CDB@@U?$_Ref_fn@Vpred_fb@@@std@@@std@@YAXPAURESULT@CDB@@00U?$_Ref_fn@Vpred_fb@@@0@@Z ENDP ; std::_Med3_unchecked<CDB::RESULT *,std::_Ref_fn<pred_fb> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
;	COMDAT ??$swap@URESULT@CDB@@$0A@@std@@YAXAAURESULT@CDB@@0@Z
_TEXT	SEGMENT
__Tmp$ = -60						; size = 56
??$swap@URESULT@CDB@@$0A@@std@@YAXAAURESULT@CDB@@0@Z PROC ; std::swap<CDB::RESULT,0>, COMDAT
; __Left$ = ecx
; __Right$ = edx

; 99   :     is_nothrow_move_constructible_v<_Ty>&& is_nothrow_move_assignable_v<_Ty>) {

	sub	esp, 60					; 0000003cH
	mov	eax, ecx

; 100  :     _Ty _Tmp = _STD move(_Left);

	mov	ecx, 14					; 0000000eH
	push	esi
	push	edi
	mov	esi, eax
	lea	edi, DWORD PTR __Tmp$[esp+68]
	rep movsd

; 101  :     _Left    = _STD move(_Right);

	mov	ecx, 14					; 0000000eH
	mov	esi, edx
	mov	edi, eax
	rep movsd

; 102  :     _Right   = _STD move(_Tmp);

	mov	ecx, 14					; 0000000eH
	lea	esi, DWORD PTR __Tmp$[esp+68]
	mov	edi, edx
	rep movsd

; 103  : }

	pop	edi
	pop	esi
	add	esp, 60					; 0000003cH
	ret	0
??$swap@URESULT@CDB@@$0A@@std@@YAXAAURESULT@CDB@@0@Z ENDP ; std::swap<CDB::RESULT,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_To_address@PAURESULT@CDB@@@std@@YA?A_PABQAURESULT@CDB@@@Z
_TEXT	SEGMENT
??$_To_address@PAURESULT@CDB@@@std@@YA?A_PABQAURESULT@CDB@@@Z PROC ; std::_To_address<CDB::RESULT *>, COMDAT
; __Val$ = ecx

; 3981 :     _STL_INTERNAL_STATIC_ASSERT(is_pointer_v<_Iter>);
; 3982 :     return _Val;

	mov	eax, DWORD PTR [ecx]

; 3983 : }

	ret	0
??$_To_address@PAURESULT@CDB@@@std@@YA?A_PABQAURESULT@CDB@@@Z ENDP ; std::_To_address<CDB::RESULT *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\type_traits
;	COMDAT ??$move@AAURESULT@CDB@@@std@@YA$$QAURESULT@CDB@@AAU12@@Z
_TEXT	SEGMENT
??$move@AAURESULT@CDB@@@std@@YA$$QAURESULT@CDB@@AAU12@@Z PROC ; std::move<CDB::RESULT &>, COMDAT
; __Arg$ = ecx

; 1397 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

	mov	eax, ecx

; 1398 : }

	ret	0
??$move@AAURESULT@CDB@@@std@@YA$$QAURESULT@CDB@@AAU12@@Z ENDP ; std::move<CDB::RESULT &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QAE@PAIPBU_Container_base0@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Pvector$dead$ = 12					; size = 4
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QAE@PAIPBU_Container_base0@1@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >, COMDAT
; _this$ = ecx

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	eax, DWORD PTR __Parg$[esp-4]
	mov	DWORD PTR [ecx], eax

; 42   :         this->_Adopt(_Pvector);
; 43   :     }

	mov	eax, ecx
	ret	8
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QAE@PAIPBU_Container_base0@1@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QAE@PAIPBU_Container_base0@1@@Z
_TEXT	SEGMENT
___param0$ = 8						; size = 4
___param1$dead$ = 12					; size = 4
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QAE@PAIPBU_Container_base0@1@@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >, COMDAT
; _this$ = ecx

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	eax, DWORD PTR ___param0$[esp-4]
	mov	DWORD PTR [ecx], eax
	mov	eax, ecx
	ret	8
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QAE@PAIPBU_Container_base0@1@@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef
;	COMDAT ??$addressof@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@I@std@@@0@AAV10@@Z
_TEXT	SEGMENT
??$addressof@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@I@std@@@0@AAV10@@Z PROC ; std::addressof<std::_Vector_val<std::_Simple_types<unsigned int> > >, COMDAT
; __Val$ = ecx

; 253  :     return __builtin_addressof(_Val);

	mov	eax, ecx

; 254  : }

	ret	0
??$addressof@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@I@std@@@0@AAV10@@Z ENDP ; std::addressof<std::_Vector_val<std::_Simple_types<unsigned int> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?begin@?$vector@IV?$xalloc@I@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@IV?$xalloc@I@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@2@XZ PROC ; std::vector<unsigned int,xalloc<unsigned int> >::begin, COMDAT
; _this$ = ecx

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	ecx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], ecx

; 1462 :         auto& _My_data = _Mypair._Myval2;
; 1463 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));
; 1464 :     }

	ret	4
?begin@?$vector@IV?$xalloc@I@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@2@XZ ENDP ; std::vector<unsigned int,xalloc<unsigned int> >::begin
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Verify_offset@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QBEXH@Z
_TEXT	SEGMENT
__Off$dead$ = 8						; size = 4
?_Verify_offset@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QBEXH@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >::_Verify_offset, COMDAT
; _this$dead$ = ecx

; 102  : #if _ITERATOR_DEBUG_LEVEL == 0
; 103  :         (void) _Off;
; 104  : #else // ^^^ _ITERATOR_DEBUG_LEVEL == 0 ^^^ // vvv _ITERATOR_DEBUG_LEVEL != 0 vvv
; 105  :         const auto _Mycont = static_cast<const _Myvec*>(this->_Getcont());
; 106  :         _STL_VERIFY(_Off == 0 || _Ptr, "cannot seek value-initialized vector iterator");
; 107  :         if (_Off < 0) {
; 108  :             _STL_VERIFY(_Off >= _Mycont->_Myfirst - _Ptr, "cannot seek vector iterator before begin");
; 109  :         }
; 110  : 
; 111  :         if (_Off > 0) {
; 112  :             _STL_VERIFY(_Off <= _Mycont->_Mylast - _Ptr, "cannot seek vector iterator after end");
; 113  :         }
; 114  : #endif // _ITERATOR_DEBUG_LEVEL == 0
; 115  :     }

	ret	4
?_Verify_offset@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QBEXH@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >::_Verify_offset
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >::operator+=, COMDAT
; _this$ = ecx

; 118  :         _Verify_offset(_Off);
; 119  :         _Ptr += _Off;

	mov	eax, DWORD PTR __Off$[esp-4]
	shl	eax, 2
	add	DWORD PTR [ecx], eax

; 120  :         return *this;

	mov	eax, ecx

; 121  :     }

	ret	4
??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >::operator+=
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >::operator+=, COMDAT
; _this$ = ecx

; 119  :         _Ptr += _Off;

	mov	eax, DWORD PTR __Off$[esp-4]
	shl	eax, 2
	add	DWORD PTR [ecx], eax

; 298  :         _Mybase::operator+=(_Off);
; 299  :         return *this;

	mov	eax, ecx

; 300  :     }

	ret	4
??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >::operator+=
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QBE?AV01@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QBE?AV01@H@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >::operator+, COMDAT
; _this$ = ecx

; 119  :         _Ptr += _Off;

	mov	eax, DWORD PTR __Off$[esp-4]
	mov	ecx, DWORD PTR [ecx]
	lea	ecx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 303  :         _Vector_iterator _Tmp = *this;
; 304  :         _Tmp += _Off; // TRANSITION, LLVM-49342
; 305  :         return _Tmp;
; 306  :     }

	ret	8
??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QBE?AV01@H@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >::operator+
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_plane.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_plane.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_plane.h
;	COMDAT ?classify@?$_plane@M@@QBEMABU?$_vector3@M@@@Z
_TEXT	SEGMENT
_v$ = 8							; size = 4
?classify@?$_plane@M@@QBEMABU?$_vector3@M@@@Z PROC	; _plane<float>::classify, COMDAT
; _this$ = ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	mov	eax, DWORD PTR _v$[esp-4]
	fld	DWORD PTR [eax+4]
	fmul	DWORD PTR [ecx+4]
	fld	DWORD PTR [eax]
	fmul	DWORD PTR [ecx]
; File I:\Vitalya\mine\NSProjectX\xrCore\_plane.h

; 57   : 		return n.dotproduct(v)+d;

	faddp	ST(1), ST(0)
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	fld	DWORD PTR [eax+8]
	fmul	DWORD PTR [ecx+8]
; File I:\Vitalya\mine\NSProjectX\xrCore\_plane.h

; 57   : 		return n.dotproduct(v)+d;

	fadd	DWORD PTR [ecx+12]
	faddp	ST(1), ST(0)

; 58   : 	}

	ret	4
?classify@?$_plane@M@@QBEMABU?$_vector3@M@@@Z ENDP	; _plane<float>::classify
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\FixedVector.h
;	COMDAT ??0?$svector@U?$_vector3@M@@$0DA@@@QAE@XZ
_TEXT	SEGMENT
??0?$svector@U?$_vector3@M@@$0DA@@@QAE@XZ PROC		; svector<_vector3<float>,48>::svector<_vector3<float>,48>, COMDAT
; _this$ = ecx

; 21   : 	svector() : count(0) 

	mov	DWORD PTR [ecx+576], 0

; 22   : 	{}

	mov	eax, ecx
	ret	0
??0?$svector@U?$_vector3@M@@$0DA@@@QAE@XZ ENDP		; svector<_vector3<float>,48>::svector<_vector3<float>,48>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?end@?$vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@URESULT@CDB@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@URESULT@CDB@@@std@@@std@@@2@XZ PROC ; std::vector<CDB::RESULT,xalloc<CDB::RESULT> >::end, COMDAT
; _this$ = ecx

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	ecx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax], ecx

; 1472 :         auto& _My_data = _Mypair._Myval2;
; 1473 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));
; 1474 :     }

	ret	4
?end@?$vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@URESULT@CDB@@@std@@@std@@@2@XZ ENDP ; std::vector<CDB::RESULT,xalloc<CDB::RESULT> >::end
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??1?$xr_vector@IV?$xalloc@I@@@@QAE@XZ
_TEXT	SEGMENT
??1?$xr_vector@IV?$xalloc@I@@@@QAE@XZ PROC		; xr_vector<unsigned int,xalloc<unsigned int> >::~xr_vector<unsigned int,xalloc<unsigned int> >, COMDAT
; _this$ = ecx

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	push	esi
	mov	esi, ecx
	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN6@xr_vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+4], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+8], 0
$LN6@xr_vector:
	pop	esi
	ret	0
??1?$xr_vector@IV?$xalloc@I@@@@QAE@XZ ENDP		; xr_vector<unsigned int,xalloc<unsigned int> >::~xr_vector<unsigned int,xalloc<unsigned int> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ??0?$xalloc@I@@QAE@XZ
_TEXT	SEGMENT
??0?$xalloc@I@@QAE@XZ PROC				; xalloc<unsigned int>::xalloc<unsigned int>, COMDAT
; _this$ = ecx

; 76   : 													xalloc			()										{	}

	mov	eax, ecx
	ret	0
??0?$xalloc@I@@QAE@XZ ENDP				; xalloc<unsigned int>::xalloc<unsigned int>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@I@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Vector_val@U?$_Simple_types@I@std@@@std@@QAE@XZ PROC ; std::_Vector_val<std::_Simple_types<unsigned int> >::_Vector_val<std::_Simple_types<unsigned int> >, COMDAT
; _this$ = ecx

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx], 0
	mov	eax, ecx
	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0
	ret	0
??0?$_Vector_val@U?$_Simple_types@I@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<std::_Simple_types<unsigned int> >::_Vector_val<std::_Simple_types<unsigned int> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$?0$$V@?$_Compressed_pair@V?$xalloc@I@@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$?0$$V@?$_Compressed_pair@V?$xalloc@I@@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<xalloc<unsigned int>,std::_Vector_val<std::_Simple_types<unsigned int> >,1>::_Compressed_pair<xalloc<unsigned int>,std::_Vector_val<std::_Simple_types<unsigned int> >,1><>, COMDAT
; _this$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1331 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	eax, ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1331 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	ret	4
??$?0$$V@?$_Compressed_pair@V?$xalloc@I@@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<xalloc<unsigned int>,std::_Vector_val<std::_Simple_types<unsigned int> >,1>::_Compressed_pair<xalloc<unsigned int>,std::_Vector_val<std::_Simple_types<unsigned int> >,1><>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0?$vector@IV?$xalloc@I@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@IV?$xalloc@I@@@std@@QAE@XZ PROC		; std::vector<unsigned int,xalloc<unsigned int> >::vector<unsigned int,xalloc<unsigned int> >, COMDAT
; _this$ = ecx

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx], 0

; 464  :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 465  :     }

	mov	eax, ecx

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0

; 464  :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 465  :     }

	ret	0
??0?$vector@IV?$xalloc@I@@@std@@QAE@XZ ENDP		; std::vector<unsigned int,xalloc<unsigned int> >::vector<unsigned int,xalloc<unsigned int> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Destroy_in_place@PAI@std@@YAXAAPAI@Z
_TEXT	SEGMENT
??$_Destroy_in_place@PAI@std@@YAXAAPAI@Z PROC		; std::_Destroy_in_place<unsigned int *>, COMDAT
; __Obj$dead$ = ecx

; 295  :     if constexpr (is_array_v<_Ty>) {
; 296  :         _Destroy_range(_Obj, _Obj + extent_v<_Ty>);
; 297  :     } else {
; 298  :         _Obj.~_Ty();
; 299  :     }
; 300  : }

	ret	0
??$_Destroy_in_place@PAI@std@@YAXAAPAI@Z ENDP		; std::_Destroy_in_place<unsigned int *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?destroy@?$xalloc@I@@QAEXPAI@Z
_TEXT	SEGMENT
_p$dead$ = 8						; size = 4
?destroy@?$xalloc@I@@QAEXPAI@Z PROC			; xalloc<unsigned int>::destroy, COMDAT
; _this$dead$ = ecx

; 85   : 							void					destroy			(pointer p)								{	std::_Destroy_in_place(p);			}

	ret	4
?destroy@?$xalloc@I@@QAEXPAI@Z ENDP			; xalloc<unsigned int>::destroy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$destroy@I@?$_Normal_allocator_traits@V?$xalloc@I@@@std@@SAXAAV?$xalloc@I@@PAI@Z
_TEXT	SEGMENT
??$destroy@I@?$_Normal_allocator_traits@V?$xalloc@I@@@std@@SAXAAV?$xalloc@I@@PAI@Z PROC ; std::_Normal_allocator_traits<xalloc<unsigned int> >::destroy<unsigned int>, COMDAT
; __Al$dead$ = ecx
; __Ptr$dead$ = edx

; 579  :         if constexpr (_Uses_default_destroy<_Alloc, _Ty*>::value) {
; 580  : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 581  :             _STD destroy_at(_Ptr);
; 582  : #else // __cpp_lib_constexpr_dynamic_alloc
; 583  :             _Ptr->~_Ty();
; 584  : #endif // __cpp_lib_constexpr_dynamic_alloc
; 585  :         } else {
; 586  :             _Al.destroy(_Ptr);
; 587  :         }
; 588  :     }

	ret	0
??$destroy@I@?$_Normal_allocator_traits@V?$xalloc@I@@@std@@SAXAAV?$xalloc@I@@PAI@Z ENDP ; std::_Normal_allocator_traits<xalloc<unsigned int> >::destroy<unsigned int>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef
;	COMDAT ??$_Unfancy@I@std@@YAPAIPAI@Z
_TEXT	SEGMENT
??$_Unfancy@I@std@@YAPAIPAI@Z PROC			; std::_Unfancy<unsigned int>, COMDAT
; __Ptr$ = ecx

; 266  :     return _Ptr;

	mov	eax, ecx

; 267  : }

	ret	0
??$_Unfancy@I@std@@YAPAIPAI@Z ENDP			; std::_Unfancy<unsigned int>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Destroy_range@V?$xalloc@I@@@std@@YAXPAIQAIAAV?$xalloc@I@@@Z
_TEXT	SEGMENT
__Al$dead$ = 8						; size = 4
??$_Destroy_range@V?$xalloc@I@@@std@@YAXPAIQAIAAV?$xalloc@I@@@Z PROC ; std::_Destroy_range<xalloc<unsigned int> >, COMDAT
; __First$dead$ = ecx
; __Last$dead$ = edx

; 901  :     // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
; 902  :     using _Ty = typename _Alloc::value_type;
; 903  :     if constexpr (!conjunction_v<is_trivially_destructible<_Ty>, _Uses_default_destroy<_Alloc, _Ty*>>) {
; 904  :         for (; _First != _Last; ++_First) {
; 905  :             allocator_traits<_Alloc>::destroy(_Al, _Unfancy(_First));
; 906  :         }
; 907  :     }
; 908  : }

	ret	0
??$_Destroy_range@V?$xalloc@I@@@std@@YAXPAIQAIAAV?$xalloc@I@@@Z ENDP ; std::_Destroy_range<xalloc<unsigned int> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Destroy@?$vector@IV?$xalloc@I@@@std@@AAEXPAI0@Z
_TEXT	SEGMENT
__First$dead$ = 8					; size = 4
__Last$dead$ = 12					; size = 4
?_Destroy@?$vector@IV?$xalloc@I@@@std@@AAEXPAI0@Z PROC	; std::vector<unsigned int,xalloc<unsigned int> >::_Destroy, COMDAT
; _this$dead$ = ecx

; 1666 :         // destroy [_First, _Last) using allocator
; 1667 :         _Destroy_range(_First, _Last, _Getal());
; 1668 :     }

	ret	8
?_Destroy@?$vector@IV?$xalloc@I@@@std@@AAEXPAI0@Z ENDP	; std::vector<unsigned int,xalloc<unsigned int> >::_Destroy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
;	COMDAT ??$xr_free@I@@YAXAAPAI@Z
_TEXT	SEGMENT
??$xr_free@I@@YAXAAPAI@Z PROC				; xr_free<unsigned int>, COMDAT
; _P$ = ecx

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	push	esi
	mov	esi, ecx
	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN2@xr_free
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
	mov	DWORD PTR [esi], 0
$LN2@xr_free:
	pop	esi
	ret	0
??$xr_free@I@@YAXAAPAI@Z ENDP				; xr_free<unsigned int>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?deallocate@?$xalloc@I@@QBEXPAII@Z
_TEXT	SEGMENT
_p$ = 8							; size = 4
_n$dead$ = 12						; size = 4
?deallocate@?$xalloc@I@@QBEXPAII@Z PROC			; xalloc<unsigned int>::deallocate, COMDAT
; _this$dead$ = ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	eax, DWORD PTR _p$[esp-4]
	test	eax, eax
	je	SHORT $LN4@deallocate
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN4@deallocate:
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 82   : 							void					deallocate		(pointer p, size_type n) const			{	xr_free	(p);				}

	ret	8
?deallocate@?$xalloc@I@@QBEXPAII@Z ENDP			; xalloc<unsigned int>::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$xalloc@I@@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@$00@std@@QAEAAV?$xalloc@I@@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@V?$xalloc@I@@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@$00@std@@QAEAAV?$xalloc@I@@XZ PROC ; std::_Compressed_pair<xalloc<unsigned int>,std::_Vector_val<std::_Simple_types<unsigned int> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 1339 :         return *this;

	mov	eax, ecx

; 1340 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$xalloc@I@@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@$00@std@@QAEAAV?$xalloc@I@@XZ ENDP ; std::_Compressed_pair<xalloc<unsigned int>,std::_Vector_val<std::_Simple_types<unsigned int> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Getal@?$vector@IV?$xalloc@I@@@std@@AAEAAV?$xalloc@I@@XZ
_TEXT	SEGMENT
?_Getal@?$vector@IV?$xalloc@I@@@std@@AAEAAV?$xalloc@I@@XZ PROC ; std::vector<unsigned int,xalloc<unsigned int> >::_Getal, COMDAT
; _this$ = ecx

; 1805 :         return _Mypair._Get_first();

	mov	eax, ecx

; 1806 :     }

	ret	0
?_Getal@?$vector@IV?$xalloc@I@@@std@@AAEAAV?$xalloc@I@@XZ ENDP ; std::vector<unsigned int,xalloc<unsigned int> >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Tidy@?$vector@IV?$xalloc@I@@@std@@AAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@IV?$xalloc@I@@@std@@AAEXXZ PROC		; std::vector<unsigned int,xalloc<unsigned int> >::_Tidy, COMDAT
; _this$ = ecx

; 1742 :     _CONSTEXPR20_CONTAINER void _Tidy() noexcept { // free all storage

	push	esi
	mov	esi, ecx

; 1743 :         auto& _My_data    = _Mypair._Myval2;
; 1744 :         pointer& _Myfirst = _My_data._Myfirst;
; 1745 :         pointer& _Mylast  = _My_data._Mylast;
; 1746 :         pointer& _Myend   = _My_data._Myend;
; 1747 : 
; 1748 :         _My_data._Orphan_all();
; 1749 : 
; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN2@Tidy
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+4], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+8], 0
$LN2@Tidy:

; 1757 :         }
; 1758 :     }

	pop	esi
	ret	0
?_Tidy@?$vector@IV?$xalloc@I@@@std@@AAEXXZ ENDP		; std::vector<unsigned int,xalloc<unsigned int> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??1?$vector@IV?$xalloc@I@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@IV?$xalloc@I@@@std@@QAE@XZ PROC		; std::vector<unsigned int,xalloc<unsigned int> >::~vector<unsigned int,xalloc<unsigned int> >, COMDAT
; _this$ = ecx

; 698  :     _CONSTEXPR20_CONTAINER ~vector() noexcept {

	push	esi
	mov	esi, ecx

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN4@vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+4], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+8], 0
$LN4@vector:
	pop	esi

; 699  :         _Tidy();
; 700  : #if _ITERATOR_DEBUG_LEVEL != 0
; 701  :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 702  :         _Delete_plain_internal(_Alproxy, _STD exchange(_Mypair._Myval2._Myproxy, nullptr));
; 703  : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 704  :     }

	ret	0
??1?$vector@IV?$xalloc@I@@@std@@QAE@XZ ENDP		; std::vector<unsigned int,xalloc<unsigned int> >::~vector<unsigned int,xalloc<unsigned int> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ??0?$xr_vector@IV?$xalloc@I@@@@QAE@XZ
_TEXT	SEGMENT
??0?$xr_vector@IV?$xalloc@I@@@@QAE@XZ PROC		; xr_vector<unsigned int,xalloc<unsigned int> >::xr_vector<unsigned int,xalloc<unsigned int> >, COMDAT
; _this$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx], 0
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 122  : 			xr_vector			()									: inherited	()					{}

	mov	eax, ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 122  : 			xr_vector			()									: inherited	()					{}

	ret	0
??0?$xr_vector@IV?$xalloc@I@@@@QAE@XZ ENDP		; xr_vector<unsigned int,xalloc<unsigned int> >::xr_vector<unsigned int,xalloc<unsigned int> >
_TEXT	ENDS
END
