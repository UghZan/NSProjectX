; Listing generated by Microsoft (R) Optimizing Compiler Version 19.29.30146.0 

	TITLE	i:\vitalya\mine\nsprojectx\nspx_build\intermediate\release-win32\xrrender_r1\occrasterizer.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	?MT_SYNC@CHOM@@QAEXXZ				; CHOM::MT_SYNC
PUBLIC	?test_Level@@YAHPAHHMMMMH@Z			; test_Level
PUBLIC	?shared@@YAHPAVoccTri@@0@Z			; shared
PUBLIC	??1occRasterizer@@QAE@XZ			; occRasterizer::~occRasterizer
PUBLIC	??0occRasterizer@@QAE@XZ			; occRasterizer::occRasterizer
PUBLIC	?propagade_depth@@YAXPAX0H@Z			; propagade_depth
PUBLIC	?get_depth_level@occRasterizer@@QAEPAHH@Z	; occRasterizer::get_depth_level
PUBLIC	?get_depth@occRasterizer@@QAEPAMXZ		; occRasterizer::get_depth
PUBLIC	?get_frame@occRasterizer@@QAEPAPAVoccTri@@XZ	; occRasterizer::get_frame
PUBLIC	?df_2_s32up@occRasterizer@@QAEHM@Z		; occRasterizer::df_2_s32up
PUBLIC	?df_2_s32@occRasterizer@@QAEHM@Z		; occRasterizer::df_2_s32
PUBLIC	?clear@occRasterizer@@QAEXXZ			; occRasterizer::clear
PUBLIC	?propagade@occRasterizer@@QAEXXZ		; occRasterizer::propagade
PUBLIC	?test@occRasterizer@@QAEHMMMMM@Z		; occRasterizer::test
PUBLIC	?Raster@@3VoccRasterizer@@A			; Raster
	ALIGN	4

?Raster@@3VoccRasterizer@@A DB 0e580H DUP (?)		; Raster
_BSS	ENDS
?Raster$initializer$@@3P6AXXZA DD FLAT:??__ERaster@@YAXXZ ; Raster$initializer$
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\occRasterizer.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\occRasterizer.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\occRasterizer.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\occRasterizer.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\occRasterizer.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\occRasterizer.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\occRasterizer.cpp
_TEXT	SEGMENT
__x0$ = 8						; size = 4
__y0$ = 12						; size = 4
__x1$ = 16						; size = 4
__y1$ = 20						; size = 4
_a$1 = 24						; size = 4
__z$ = 24						; size = 4
?test@occRasterizer@@QAEHMMMMM@Z PROC			; occRasterizer::test
; _this$dead$ = ecx

; 144  : { 

	push	ecx
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\occRasterizer.h

; 40   : 	IC int			df_2_s32up		(float d)	{ return iCeil	(d*occQ_s32);				}

	movss	xmm0, DWORD PTR __z$[esp]
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h

; 105  :     int exponent	= (127 + 31) - ((a >> 23) & 0xFF);

	mov	ecx, 158				; 0000009eH
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\occRasterizer.h

; 40   : 	IC int			df_2_s32up		(float d)	{ return iCeil	(d*occQ_s32);				}

	mulss	xmm0, DWORD PTR __real@4e800000
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\occRasterizer.cpp

; 144  : { 

	push	ebx
	push	esi
	push	edi
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h

; 104  :     int a			= (*(const int*)(&x));

	movss	DWORD PTR _a$1[esp+12], xmm0

; 109  :         int imask	=	(!(((( (1<<(exponent)))-1)>>8)&a));

	mov	esi, 1
	mov	edi, DWORD PTR _a$1[esp+12]
	mov	eax, edi
	sar	eax, 23					; 00000017H
	mov	ebx, edi
	movzx	eax, al
	or	ebx, -8388608				; ff800000H
	sub	ecx, eax
	shl	ebx, 8
	shr	ebx, cl

; 110  :         exponent	-=	(31-127)+32;
; 111  :         exponent	>>=	31;
; 112  :         a			=	~((a-1)>>31);		/* change sign */

	lea	edx, DWORD PTR [edi-1]
	sub	ecx, 96					; 00000060H
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\occRasterizer.cpp

; 146  : 	return		test_Level		(get_depth_level(0),occ_dim_0,_x0,_y0,_x1,_y1,z);

	fld	DWORD PTR __y1$[esp+12]
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h

; 109  :         int imask	=	(!(((( (1<<(exponent)))-1)>>8)&a));

	mov	eax, esi

; 110  :         exponent	-=	(31-127)+32;
; 111  :         exponent	>>=	31;
; 112  :         a			=	~((a-1)>>31);		/* change sign */

	sar	edx, 31					; 0000001fH
	shl	eax, cl
	not	edx
	dec	eax
	sar	eax, 8
	and	eax, edi
	neg	eax
	sbb	eax, eax
	inc	eax
	and	eax, edx

; 113  :         r			-=	(imask&a);

	sub	ebx, eax
	lea	eax, DWORD PTR [ecx+64]
	sar	eax, 31					; 0000001fH
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\occRasterizer.cpp

; 146  : 	return		test_Level		(get_depth_level(0),occ_dim_0,_x0,_y0,_x1,_y1,z);

	mov	ecx, OFFSET ?Raster@@3VoccRasterizer@@A+36992
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h

; 114  :         r			&=	exponent;

	and	ebx, eax
	xor	ebx, edx
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\occRasterizer.cpp

; 145  : 	occD	z	= df_2_s32up	(_z)+1;

	sub	esi, ebx

; 146  : 	return		test_Level		(get_depth_level(0),occ_dim_0,_x0,_y0,_x1,_y1,z);

	push	esi
	sub	esp, 16					; 00000010H
	fstp	DWORD PTR [esp+12]
	fld	DWORD PTR __x1$[esp+32]
	fstp	DWORD PTR [esp+8]
	fld	DWORD PTR __y0$[esp+32]
	fstp	DWORD PTR [esp+4]
	fld	DWORD PTR __x0$[esp+32]
	fstp	DWORD PTR [esp]
	call	?test_Level@@YAHPAHHMMMMH@Z		; test_Level
	add	esp, 20					; 00000014H

; 147  : 	/*
; 148  : 	if	(test_Level(get_depth_level(2),occ_dim_2,_x0,_y0,_x1,_y1,z))
; 149  : 	{
; 150  : 		// Visbible on level 2 - test level 0
; 151  : 		return test_Level(get_depth_level(0),occ_dim_0,_x0,_y0,_x1,_y1,z);
; 152  : 	}
; 153  : 	return FALSE;
; 154  : 	*/
; 155  : }

	pop	edi
	pop	esi
	pop	ebx
	pop	ecx
	ret	20					; 00000014H
?test@occRasterizer@@QAEHMMMMM@Z ENDP			; occRasterizer::test
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\occRasterizer.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\vector.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\occRasterizer.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\occRasterizer.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\occRasterizer.cpp
_TEXT	SEGMENT
tv1249 = -16						; size = 4
tv1245 = -12						; size = 4
tv1247 = -8						; size = 4
_a$1 = -4						; size = 4
?propagade@occRasterizer@@QAEXXZ PROC			; occRasterizer::propagade
; _this$dead$ = ecx

; 77   : {

	sub	esp, 16					; 00000010H

; 78   : 	// Clip-and-propagade zero level
; 79   : 	occTri**	pFrame	= get_frame	();

	movss	xmm4, DWORD PTR __real@3f000000
	mov	eax, OFFSET ?Raster@@3VoccRasterizer@@A+19048
	movss	xmm3, DWORD PTR __real@bffeb852
	movss	xmm2, DWORD PTR __real@3ffeb852
	movss	xmm5, DWORD PTR __real@4e800000
	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	ebp, OFFSET ?Raster@@3VoccRasterizer@@A+36992
	mov	DWORD PTR tv1245[esp+32], eax
	mov	DWORD PTR tv1247[esp+32], 64		; 00000040H
	npad	3
$LL4@propagade:

; 83   : 		for (int x=0; x<occ_dim_0; x++)

	mov	ebx, eax
	mov	DWORD PTR tv1249[esp+32], 64		; 00000040H
	npad	6
$LL7@propagade:

; 84   : 		{
; 85   : 			int				ox=x+2, oy=y+2;
; 86   : 			
; 87   : 			// Y2-connect
; 88   : 			int	pos			= oy*occ_dim+ox;
; 89   : 			int	pos_up		= pos-occ_dim;
; 90   : 			int	pos_down	= pos+occ_dim;
; 91   : 			int	pos_down2	= pos_down+occ_dim;
; 92   : 			
; 93   : 			occTri* Tu1		= pFrame	[pos_up];

	mov	eax, DWORD PTR [ebx-18768]

; 94   : 			if (Tu1) {

	test	eax, eax
	je	SHORT $LN13@propagade

; 95   : 				// We has pixel 1scan up
; 96   : 				if (shared(Tu1,pFrame[pos_down]))

	mov	ecx, DWORD PTR [ebx-18224]

; 69   : 	if (T1==T2)					return TRUE;

	cmp	eax, ecx
	je	SHORT $LN46@propagade

; 70   : 	if (T1->adjacent[0]==T2)	return TRUE;

	mov	edx, DWORD PTR [eax]
	cmp	edx, ecx
	je	SHORT $LN46@propagade

; 71   : 	if (T1->adjacent[1]==T2)	return TRUE;

	mov	esi, DWORD PTR [eax+4]
	cmp	esi, ecx
	je	SHORT $LN46@propagade

; 72   : 	if (T1->adjacent[2]==T2)	return TRUE;

	mov	edi, DWORD PTR [eax+8]
	cmp	edi, ecx
	je	SHORT $LN46@propagade

; 100  : 					if (ZR<pDepth[pos])	{ pFrame[pos] = Tu1; pDepth[pos] = ZR; }
; 101  : 				} else if (shared(Tu1,pFrame[pos_down2])) 

	mov	ecx, DWORD PTR [ebx-17952]

; 69   : 	if (T1==T2)					return TRUE;

	cmp	eax, ecx
	je	SHORT $LN47@propagade

; 70   : 	if (T1->adjacent[0]==T2)	return TRUE;

	cmp	edx, ecx
	je	SHORT $LN47@propagade

; 71   : 	if (T1->adjacent[1]==T2)	return TRUE;

	cmp	esi, ecx
	je	SHORT $LN47@propagade

; 72   : 	if (T1->adjacent[2]==T2)	return TRUE;

	cmp	edi, ecx
	jne	SHORT $LN13@propagade
$LN47@propagade:

; 102  : 				{
; 103  : 					// We has pixel 2scan down
; 104  : 					float ZR			= (pDepth[pos_up]+pDepth[pos_down2])/2;

	movss	xmm1, DWORD PTR [ebx+544]

; 105  : 					if (ZR<pDepth[pos])	{ pFrame[pos] = Tu1; pDepth[pos] = ZR; }

	jmp	SHORT $LN49@propagade
$LN46@propagade:

; 97   : 				{
; 98   : 					// We has pixel 1scan down
; 99   : 					float ZR			= (pDepth[pos_up]+pDepth[pos_down])/2;

	movss	xmm1, DWORD PTR [ebx+272]
$LN49@propagade:

; 106  : 				}
; 107  : 			}
; 108  : 			
; 109  : 			//
; 110  : 			float d				= pDepth[pos];

	addss	xmm1, DWORD PTR [ebx-272]
	movss	xmm0, DWORD PTR [ebx]
	mulss	xmm1, xmm4
	comiss	xmm0, xmm1
	jbe	SHORT $LN13@propagade
	movss	DWORD PTR [ebx], xmm1
	mov	DWORD PTR [ebx-18496], eax
$LN13@propagade:
	movss	xmm0, DWORD PTR [ebx]
; File I:\Vitalya\mine\NSProjectX\xrCore\vector.h

; 92   : 	if( val<_low ) val = _low; else if( val>_high ) val = _high;

	comiss	xmm3, xmm0
	jbe	SHORT $LN30@propagade
	movaps	xmm0, xmm3
	jmp	SHORT $LN32@propagade
$LN30@propagade:
	comiss	xmm0, xmm2
	jbe	SHORT $LN32@propagade
	movaps	xmm0, xmm2
$LN32@propagade:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\occRasterizer.h

; 38   : 	IC int			df_2_s32		(float d)	{ return iFloor	(d*occQ_s32);				}

	mulss	xmm0, xmm5
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h

; 84   :     int exponent	= (127 + 31) - ((a >> 23) & 0xFF);

	mov	ecx, 158				; 0000009eH
	movss	DWORD PTR _a$1[esp+32], xmm0
	mov	esi, DWORD PTR _a$1[esp+32]
	mov	eax, esi
	sar	eax, 23					; 00000017H

; 85   :     int r			= (((u32)(a) << 8) | (1U << 31)) >> exponent;

	mov	edi, esi
	movzx	eax, al
	or	edi, -8388608				; ff800000H
	sub	ecx, eax
	shl	edi, 8
	shr	edi, cl

; 88   :         int imask	=	(!(((( (1<<(exponent)))-1)>>8)&a));

	mov	eax, 1
	sub	ecx, 96					; 00000060H

; 89   :         exponent	-=	(31-127)+32;
; 90   :         exponent	>>=	31;
; 91   :         a			>>=	31;

	mov	edx, esi
	shl	eax, cl
	dec	eax
	sar	edx, 31					; 0000001fH
	sar	eax, 8
	and	eax, esi
	neg	eax
	sbb	eax, eax
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\occRasterizer.cpp

; 83   : 		for (int x=0; x<occ_dim_0; x++)

	add	ebx, 4
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h

; 88   :         int imask	=	(!(((( (1<<(exponent)))-1)>>8)&a));

	inc	eax

; 89   :         exponent	-=	(31-127)+32;
; 90   :         exponent	>>=	31;
; 91   :         a			>>=	31;

	and	eax, edx

; 92   :         r			-=	(imask&a);

	sub	edi, eax
	lea	eax, DWORD PTR [ecx+64]
	sar	eax, 31					; 0000001fH

; 93   :         r			&=	exponent;

	and	edi, eax
	xor	edi, edx
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\occRasterizer.cpp

; 112  : 			bufDepth_0[y][x]	= df_2_s32	(d);

	mov	DWORD PTR [ebp], edi
	add	ebp, 4
	sub	DWORD PTR tv1249[esp+32], 1
	jne	$LL7@propagade

; 80   : 	float*		pDepth	= get_depth	();
; 81   : 	for (int y=0; y<occ_dim_0; y++)

	mov	eax, DWORD PTR tv1245[esp+32]
	add	eax, 272				; 00000110H
	sub	DWORD PTR tv1247[esp+32], 1
	mov	DWORD PTR tv1245[esp+32], eax
	jne	$LL4@propagade

; 113  : 		}
; 114  : 	}
; 115  : 	
; 116  : 	// Propagade other levels
; 117  : 	propagade_depth	(bufDepth_1,bufDepth_0,occ_dim_1);

	push	32					; 00000020H
	mov	edx, OFFSET ?Raster@@3VoccRasterizer@@A+36992
	mov	ecx, OFFSET ?Raster@@3VoccRasterizer@@A+53376
	call	?propagade_depth@@YAXPAX0H@Z		; propagade_depth

; 118  : 	propagade_depth	(bufDepth_2,bufDepth_1,occ_dim_2);

	push	16					; 00000010H
	mov	edx, OFFSET ?Raster@@3VoccRasterizer@@A+53376
	mov	ecx, OFFSET ?Raster@@3VoccRasterizer@@A+57472
	call	?propagade_depth@@YAXPAX0H@Z		; propagade_depth

; 119  : 	propagade_depth	(bufDepth_3,bufDepth_2,occ_dim_3);

	push	8
	mov	edx, OFFSET ?Raster@@3VoccRasterizer@@A+57472
	mov	ecx, OFFSET ?Raster@@3VoccRasterizer@@A+58496
	call	?propagade_depth@@YAXPAX0H@Z		; propagade_depth
	add	esp, 12					; 0000000cH
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 120  : }

	add	esp, 16					; 00000010H
	ret	0
?propagade@occRasterizer@@QAEXXZ ENDP			; occRasterizer::propagade
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\occRasterizer.cpp
_TEXT	SEGMENT
_f$ = -4						; size = 4
?clear@occRasterizer@@QAEXXZ PROC			; occRasterizer::clear
; _this$dead$ = ecx

; 60   : {

	push	ecx

; 61   : 	u32 size			= occ_dim*occ_dim;
; 62   : 	float f				= 1.f;
; 63   : 	Memory.mem_fill32	(bufFrame,0,size);

	mov	eax, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	4624					; 00001210H
	push	0
	push	OFFSET ?Raster@@3VoccRasterizer@@A	; Raster
	mov	eax, DWORD PTR [eax+16]
	mov	DWORD PTR _f$[esp+16], 1065353216	; 3f800000H
	call	eax

; 64   : 	Memory.mem_fill32	(bufDepth,*LPDWORD(&f),size);

	mov	eax, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	4624					; 00001210H
	push	DWORD PTR _f$[esp+8]
	mov	eax, DWORD PTR [eax+16]
	push	OFFSET ?Raster@@3VoccRasterizer@@A+18496
	call	eax

; 65   : }

	pop	ecx
	ret	0
?clear@occRasterizer@@QAEXXZ ENDP			; occRasterizer::clear
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\occRasterizer.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\occRasterizer.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\occRasterizer.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\occRasterizer.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\occRasterizer.h
;	COMDAT ?df_2_s32@occRasterizer@@QAEHM@Z
_TEXT	SEGMENT
_a$1 = 8						; size = 4
_d$ = 8							; size = 4
?df_2_s32@occRasterizer@@QAEHM@Z PROC			; occRasterizer::df_2_s32, COMDAT
; _this$dead$ = ecx

; 38   : 	IC int			df_2_s32		(float d)	{ return iFloor	(d*occQ_s32);				}

	movss	xmm0, DWORD PTR _d$[esp-4]
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h

; 84   :     int exponent	= (127 + 31) - ((a >> 23) & 0xFF);

	mov	ecx, 158				; 0000009eH
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\occRasterizer.h

; 38   : 	IC int			df_2_s32		(float d)	{ return iFloor	(d*occQ_s32);				}

	mulss	xmm0, DWORD PTR __real@4e800000
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h

; 88   :         int imask	=	(!(((( (1<<(exponent)))-1)>>8)&a));

	mov	edx, 1
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\occRasterizer.h

; 38   : 	IC int			df_2_s32		(float d)	{ return iFloor	(d*occQ_s32);				}

	push	esi
	push	edi
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h

; 83   :     int a			= *(const int*)(&x);

	movss	DWORD PTR _a$1[esp+4], xmm0

; 84   :     int exponent	= (127 + 31) - ((a >> 23) & 0xFF);

	mov	edi, DWORD PTR _a$1[esp+4]
	mov	eax, edi
	sar	eax, 23					; 00000017H

; 91   :         a			>>=	31;

	mov	esi, edi
	movzx	eax, al
	sub	ecx, eax
	sar	esi, 31					; 0000001fH
	mov	eax, edi
	or	eax, -8388608				; ff800000H
	shl	eax, 8
	shr	eax, cl
	sub	ecx, 96					; 00000060H
	shl	edx, cl
	dec	edx
	sar	edx, 8
	and	edx, edi
	neg	edx
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\occRasterizer.h

; 38   : 	IC int			df_2_s32		(float d)	{ return iFloor	(d*occQ_s32);				}

	pop	edi
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h

; 88   :         int imask	=	(!(((( (1<<(exponent)))-1)>>8)&a));

	sbb	edx, edx

; 89   :         exponent	-=	(31-127)+32;

	add	ecx, 64					; 00000040H
	inc	edx

; 90   :         exponent	>>=	31;

	sar	ecx, 31					; 0000001fH

; 91   :         a			>>=	31;

	and	edx, esi

; 92   :         r			-=	(imask&a);

	sub	eax, edx

; 93   :         r			&=	exponent;

	and	eax, ecx
	xor	eax, esi
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\occRasterizer.h

; 38   : 	IC int			df_2_s32		(float d)	{ return iFloor	(d*occQ_s32);				}

	pop	esi
	ret	4
?df_2_s32@occRasterizer@@QAEHM@Z ENDP			; occRasterizer::df_2_s32
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\occRasterizer.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\occRasterizer.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\occRasterizer.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\occRasterizer.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\occRasterizer.h
;	COMDAT ?df_2_s32up@occRasterizer@@QAEHM@Z
_TEXT	SEGMENT
_a$1 = 8						; size = 4
_d$ = 8							; size = 4
?df_2_s32up@occRasterizer@@QAEHM@Z PROC			; occRasterizer::df_2_s32up, COMDAT
; _this$dead$ = ecx

; 40   : 	IC int			df_2_s32up		(float d)	{ return iCeil	(d*occQ_s32);				}

	movss	xmm0, DWORD PTR _d$[esp-4]
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h

; 105  :     int exponent	= (127 + 31) - ((a >> 23) & 0xFF);

	mov	ecx, 158				; 0000009eH
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\occRasterizer.h

; 40   : 	IC int			df_2_s32up		(float d)	{ return iCeil	(d*occQ_s32);				}

	mulss	xmm0, DWORD PTR __real@4e800000
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h

; 109  :         int imask	=	(!(((( (1<<(exponent)))-1)>>8)&a));

	mov	edx, 1
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\occRasterizer.h

; 40   : 	IC int			df_2_s32up		(float d)	{ return iCeil	(d*occQ_s32);				}

	push	esi
	push	edi
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h

; 104  :     int a			= (*(const int*)(&x));

	movss	DWORD PTR _a$1[esp+4], xmm0

; 105  :     int exponent	= (127 + 31) - ((a >> 23) & 0xFF);

	mov	edi, DWORD PTR _a$1[esp+4]
	mov	eax, edi
	sar	eax, 23					; 00000017H
	movzx	eax, al
	sub	ecx, eax

; 106  :     int r			= (((u32)(a) << 8) | (1U << 31)) >> exponent;

	mov	eax, edi
	or	eax, -8388608				; ff800000H

; 112  :         a			=	~((a-1)>>31);		/* change sign */

	lea	esi, DWORD PTR [edi-1]
	shl	eax, 8
	shr	eax, cl
	sub	ecx, 96					; 00000060H
	shl	edx, cl
	dec	edx
	sar	esi, 31					; 0000001fH
	sar	edx, 8
	not	esi
	and	edx, edi
	neg	edx
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\occRasterizer.h

; 40   : 	IC int			df_2_s32up		(float d)	{ return iCeil	(d*occQ_s32);				}

	pop	edi
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h

; 109  :         int imask	=	(!(((( (1<<(exponent)))-1)>>8)&a));

	sbb	edx, edx

; 110  :         exponent	-=	(31-127)+32;

	add	ecx, 64					; 00000040H
	inc	edx

; 111  :         exponent	>>=	31;

	sar	ecx, 31					; 0000001fH

; 112  :         a			=	~((a-1)>>31);		/* change sign */

	and	edx, esi

; 113  :         r			-=	(imask&a);

	sub	eax, edx

; 114  :         r			&=	exponent;

	and	eax, ecx
	xor	eax, esi

; 115  :         r			^=	a;
; 116  :         r			=	-r;                 /* change sign */

	neg	eax
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\occRasterizer.h

; 40   : 	IC int			df_2_s32up		(float d)	{ return iCeil	(d*occQ_s32);				}

	pop	esi
	ret	4
?df_2_s32up@occRasterizer@@QAEHM@Z ENDP			; occRasterizer::df_2_s32up
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\occRasterizer.h
;	COMDAT ?get_frame@occRasterizer@@QAEPAPAVoccTri@@XZ
_TEXT	SEGMENT
?get_frame@occRasterizer@@QAEPAPAVoccTri@@XZ PROC	; occRasterizer::get_frame, COMDAT
; _this$dead$ = ecx

; 50   : 	occTri**		get_frame	()			{ return &(bufFrame[0][0]);	}

	mov	eax, OFFSET ?Raster@@3VoccRasterizer@@A	; Raster
	ret	0
?get_frame@occRasterizer@@QAEPAPAVoccTri@@XZ ENDP	; occRasterizer::get_frame
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\occRasterizer.h
;	COMDAT ?get_depth@occRasterizer@@QAEPAMXZ
_TEXT	SEGMENT
?get_depth@occRasterizer@@QAEPAMXZ PROC			; occRasterizer::get_depth, COMDAT
; _this$dead$ = ecx

; 51   : 	float*			get_depth	()			{ return &(bufDepth[0][0]);	}

	mov	eax, OFFSET ?Raster@@3VoccRasterizer@@A+18496
	ret	0
?get_depth@occRasterizer@@QAEPAMXZ ENDP			; occRasterizer::get_depth
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\occRasterizer.h
;	COMDAT ?get_depth_level@occRasterizer@@QAEPAHH@Z
_TEXT	SEGMENT
_level$dead$ = 8					; size = 4
?get_depth_level@occRasterizer@@QAEPAHH@Z PROC		; occRasterizer::get_depth_level, COMDAT
; _this$dead$ = ecx

; 54   : 		switch (level)
; 55   : 		{
; 56   : 		case 0:		return &(bufDepth_0[0][0]);	

	mov	eax, OFFSET ?Raster@@3VoccRasterizer@@A+36992

; 57   : 		case 1:		return &(bufDepth_1[0][0]);	
; 58   : 		case 2:		return &(bufDepth_2[0][0]);	
; 59   : 		case 3:		return &(bufDepth_3[0][0]);	
; 60   : 		default:	return NULL;
; 61   : 		}
; 62   : 	}

	ret	4
?get_depth_level@occRasterizer@@QAEPAHH@Z ENDP		; occRasterizer::get_depth_level
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\occRasterizer.cpp
;	COMDAT ??__ERaster@@YAXXZ
text$di	SEGMENT
??__ERaster@@YAXXZ PROC					; `dynamic initializer for 'Raster'', COMDAT

; 8    : occRasterizer	Raster;

	push	OFFSET ??__FRaster@@YAXXZ		; `dynamic atexit destructor for 'Raster''
	call	_atexit
	pop	ecx
	ret	0
??__ERaster@@YAXXZ ENDP					; `dynamic initializer for 'Raster''
text$di	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ??__FRaster@@YAXXZ
text$yd	SEGMENT
??__FRaster@@YAXXZ PROC					; `dynamic atexit destructor for 'Raster'', COMDAT
	ret	0
??__FRaster@@YAXXZ ENDP					; `dynamic atexit destructor for 'Raster''
text$yd	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\occRasterizer.cpp
;	COMDAT ?propagade_depth@@YAXPAX0H@Z
_TEXT	SEGMENT
tv975 = -24						; size = 4
_p_src$1$ = -20						; size = 4
tv972 = -16						; size = 4
tv970 = -12						; size = 4
_p_dest$1$ = -8						; size = 4
tv971 = -4						; size = 4
_dim$ = 8						; size = 4
?propagade_depth@@YAXPAX0H@Z PROC			; propagade_depth, COMDAT
; _p_dest$ = ecx
; _p_src$ = edx

; 22   : {

	sub	esp, 24					; 00000018H
	mov	DWORD PTR _p_dest$1$[esp+24], ecx
	mov	eax, edx

; 23   : 	occD*	dest = (occD*)p_dest;
; 24   : 	occD*	src	 = (occD*)p_src;
; 25   : 
; 26   : 	for (int y=0; y<dim; y++)

	mov	ecx, DWORD PTR _dim$[esp+20]
	mov	DWORD PTR _p_src$1$[esp+24], edx
	test	ecx, ecx
	jle	$LN3@propagade_
	push	ebx
	mov	edx, ecx
	mov	DWORD PTR tv975[esp+28], 0
	shl	edx, 4
	push	ebp
	mov	DWORD PTR tv971[esp+32], edx
	lea	edx, DWORD PTR [eax+ecx*8]
	push	esi
	mov	DWORD PTR tv972[esp+36], edx
	mov	DWORD PTR tv970[esp+36], ecx
	push	edi
	npad	7
$LL4@propagade_:

; 27   : 	{
; 28   : 		for (int x=0; x<dim; x++)

	mov	ebp, eax
	xor	ebx, ebx
	mov	eax, edx
$LL7@propagade_:

; 29   : 		{
; 30   : 			occD*	base0		= src + (y*2+0)*(dim*2) + (x*2);
; 31   : 			occD*	base1		= src + (y*2+1)*(dim*2) + (x*2);
; 32   : 			occD	f1			= base0[0];
; 33   : 			occD	f2			= base0[1];

	mov	edx, DWORD PTR [ebp+4]
	lea	eax, DWORD PTR [eax+8]

; 34   : 			occD	f3			= base1[0];
; 35   : 			occD	f4			= base1[1];
; 36   : 			occD	f			= f1;
; 37   : 			if (f2>f)	f		= f2;
; 38   : 			if (f3>f)	f		= f3;

	cmp	edx, DWORD PTR [ebp]
	mov	esi, DWORD PTR [eax-8]
	cmovle	edx, DWORD PTR [ebp]
	lea	ebp, DWORD PTR [ebp+8]
	mov	edi, DWORD PTR [eax-4]

; 39   : 			if (f4>f)	f		= f4;

	cmp	esi, edx
	cmovle	esi, edx

; 40   : 			dest[y*dim+x]		= f;

	mov	edx, DWORD PTR tv975[esp+40]
	cmp	edi, esi
	cmovle	edi, esi
	mov	esi, DWORD PTR _p_dest$1$[esp+40]
	lea	ecx, DWORD PTR [edx+ebx]
	inc	ebx
	mov	DWORD PTR [esi+ecx*4], edi
	mov	ecx, DWORD PTR _dim$[esp+36]
	cmp	ebx, ecx
	jl	SHORT $LL7@propagade_

; 23   : 	occD*	dest = (occD*)p_dest;
; 24   : 	occD*	src	 = (occD*)p_src;
; 25   : 
; 26   : 	for (int y=0; y<dim; y++)

	mov	eax, DWORD PTR _p_src$1$[esp+40]
	add	edx, ecx
	add	eax, DWORD PTR tv971[esp+40]
	mov	DWORD PTR tv975[esp+40], edx
	mov	edx, DWORD PTR tv972[esp+40]
	add	edx, DWORD PTR tv971[esp+40]
	sub	DWORD PTR tv970[esp+40], 1
	mov	DWORD PTR _p_src$1$[esp+40], eax
	mov	DWORD PTR tv972[esp+40], edx
	jne	SHORT $LL4@propagade_
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
$LN3@propagade_:

; 41   : 		}
; 42   : 	}
; 43   : }

	add	esp, 24					; 00000018H
	ret	0
?propagade_depth@@YAXPAX0H@Z ENDP			; propagade_depth
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\occRasterizer.cpp
_TEXT	SEGMENT
??0occRasterizer@@QAE@XZ PROC				; occRasterizer::occRasterizer
; _this$dead$ = ecx

; 51   : 	
; 52   : }

	mov	eax, OFFSET ?Raster@@3VoccRasterizer@@A	; Raster
	ret	0
??0occRasterizer@@QAE@XZ ENDP				; occRasterizer::occRasterizer
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\occRasterizer.cpp
_TEXT	SEGMENT
??1occRasterizer@@QAE@XZ PROC				; occRasterizer::~occRasterizer
; _this$ = ecx

; 56   : 	
; 57   : }

	ret	0
??1occRasterizer@@QAE@XZ ENDP				; occRasterizer::~occRasterizer
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\occRasterizer.cpp
;	COMDAT ?shared@@YAHPAVoccTri@@0@Z
_TEXT	SEGMENT
?shared@@YAHPAVoccTri@@0@Z PROC				; shared, COMDAT
; _T1$ = ecx
; _T2$ = edx

; 69   : 	if (T1==T2)					return TRUE;

	cmp	ecx, edx
	je	SHORT $LN7@shared

; 70   : 	if (T1->adjacent[0]==T2)	return TRUE;

	cmp	DWORD PTR [ecx], edx
	je	SHORT $LN7@shared

; 71   : 	if (T1->adjacent[1]==T2)	return TRUE;

	cmp	DWORD PTR [ecx+4], edx
	je	SHORT $LN7@shared

; 72   : 	if (T1->adjacent[2]==T2)	return TRUE;

	cmp	DWORD PTR [ecx+8], edx
	je	SHORT $LN7@shared

; 73   : 	return FALSE;

	xor	eax, eax

; 74   : }

	ret	0
$LN7@shared:

; 72   : 	if (T1->adjacent[2]==T2)	return TRUE;

	mov	eax, 1

; 74   : }

	ret	0
?shared@@YAHPAVoccTri@@0@Z ENDP				; shared
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\occRasterizer.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h
; File I:\Vitalya\mine\NSProjectX\xrCore\vector.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h
; File I:\Vitalya\mine\NSProjectX\xrCore\vector.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\occRasterizer.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\occRasterizer.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h
; File I:\Vitalya\mine\NSProjectX\xrCore\vector.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\occRasterizer.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\occRasterizer.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h
; File I:\Vitalya\mine\NSProjectX\xrCore\vector.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\occRasterizer.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\occRasterizer.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h
; File I:\Vitalya\mine\NSProjectX\xrCore\vector.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\hom.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\occRasterizer.cpp
;	COMDAT ?test_Level@@YAHPAHHMMMMH@Z
_TEXT	SEGMENT
_depth$1$ = -4						; size = 4
_x1$2$ = 8						; size = 4
_a$1 = 8						; size = 4
_a$2 = 8						; size = 4
__x0$ = 8						; size = 4
__y0$ = 12						; size = 4
_a$3 = 16						; size = 4
_a$4 = 16						; size = 4
__x1$ = 16						; size = 4
__y1$ = 20						; size = 4
_z$ = 24						; size = 4
?test_Level@@YAHPAHHMMMMH@Z PROC			; test_Level, COMDAT
; _depth$ = ecx
; _dim$dead$ = edx

; 123  : {

	sub	esp, 8

; 124  : 	int x0		= iFloor	(_x0*dim+.5f);	clamp(x0,0,		dim-1);

	movss	xmm0, DWORD PTR __x0$[esp+4]
	movss	xmm1, DWORD PTR __real@42800000
	movss	xmm2, DWORD PTR __real@3f000000
	mulss	xmm0, xmm1
	push	ebx
	push	ebp
	push	esi
	addss	xmm0, xmm2
	mov	DWORD PTR _depth$1$[esp+20], ecx
	push	edi
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h

; 84   :     int exponent	= (127 + 31) - ((a >> 23) & 0xFF);

	mov	edi, 158				; 0000009eH
	mov	ecx, edi
	movss	DWORD PTR _a$2[esp+20], xmm0
	mov	esi, DWORD PTR _a$2[esp+20]
	mov	eax, esi
	sar	eax, 23					; 00000017H

; 85   :     int r			= (((u32)(a) << 8) | (1U << 31)) >> exponent;

	mov	ebp, esi
	movzx	eax, al
	or	ebp, -8388608				; ff800000H
	sub	ecx, eax
	shl	ebp, 8
	shr	ebp, cl

; 86   :     exponent		+= 31-127;
; 87   :     {
; 88   :         int imask	=	(!(((( (1<<(exponent)))-1)>>8)&a));

	mov	eax, 1
	sub	ecx, 96					; 00000060H

; 89   :         exponent	-=	(31-127)+32;
; 90   :         exponent	>>=	31;
; 91   :         a			>>=	31;

	mov	edx, esi
	shl	eax, cl
	dec	eax
	sar	edx, 31					; 0000001fH
	sar	eax, 8
	and	eax, esi
	neg	eax
	sbb	eax, eax
	inc	eax
	and	eax, edx

; 92   :         r			-=	(imask&a);

	sub	ebp, eax
	lea	eax, DWORD PTR [ecx+64]
	sar	eax, 31					; 0000001fH

; 93   :         r			&=	exponent;

	and	ebp, eax
; File I:\Vitalya\mine\NSProjectX\xrCore\vector.h

; 92   : 	if( val<_low ) val = _low; else if( val>_high ) val = _high;

	lea	eax, DWORD PTR [edi-95]
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h

; 93   :         r			&=	exponent;

	xor	ebp, edx
; File I:\Vitalya\mine\NSProjectX\xrCore\vector.h

; 92   : 	if( val<_low ) val = _low; else if( val>_high ) val = _high;

	jge	SHORT $LN13@test_Level
	xor	ebp, ebp
	jmp	SHORT $LN15@test_Level
$LN13@test_Level:
	cmp	ebp, eax
	cmovg	ebp, eax
$LN15@test_Level:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\occRasterizer.cpp

; 125  : 	int x1		= iFloor	(_x1*dim+.5f);	clamp(x1,x0,	dim-1);

	movss	xmm0, DWORD PTR __x1$[esp+20]
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h

; 84   :     int exponent	= (127 + 31) - ((a >> 23) & 0xFF);

	mov	ecx, edi
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\occRasterizer.cpp

; 125  : 	int x1		= iFloor	(_x1*dim+.5f);	clamp(x1,x0,	dim-1);

	mulss	xmm0, xmm1
	addss	xmm0, xmm2
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h

; 83   :     int a			= *(const int*)(&x);

	movss	DWORD PTR _a$1[esp+20], xmm0

; 84   :     int exponent	= (127 + 31) - ((a >> 23) & 0xFF);

	mov	esi, DWORD PTR _a$1[esp+20]
	mov	eax, esi
	sar	eax, 23					; 00000017H

; 85   :     int r			= (((u32)(a) << 8) | (1U << 31)) >> exponent;

	mov	ebx, esi
	movzx	eax, al
	or	ebx, -8388608				; ff800000H
	sub	ecx, eax
	shl	ebx, 8
	shr	ebx, cl

; 86   :     exponent		+= 31-127;
; 87   :     {
; 88   :         int imask	=	(!(((( (1<<(exponent)))-1)>>8)&a));

	mov	eax, 1
	sub	ecx, 96					; 00000060H

; 89   :         exponent	-=	(31-127)+32;
; 90   :         exponent	>>=	31;
; 91   :         a			>>=	31;

	mov	edx, esi
	shl	eax, cl
	dec	eax
	sar	edx, 31					; 0000001fH
	sar	eax, 8
	and	eax, esi
	neg	eax
	sbb	eax, eax
	inc	eax
	and	eax, edx

; 92   :         r			-=	(imask&a);

	sub	ebx, eax
	lea	eax, DWORD PTR [ecx+64]
	sar	eax, 31					; 0000001fH

; 93   :         r			&=	exponent;

	and	ebx, eax
	xor	ebx, edx
; File I:\Vitalya\mine\NSProjectX\xrCore\vector.h

; 92   : 	if( val<_low ) val = _low; else if( val>_high ) val = _high;

	cmp	ebx, ebp
	jge	SHORT $LN20@test_Level
	mov	DWORD PTR _x1$2$[esp+20], ebp
	jmp	SHORT $LN22@test_Level
$LN20@test_Level:
	cmp	ebx, 63					; 0000003fH
	mov	eax, 63					; 0000003fH
	cmovg	ebx, eax
	mov	DWORD PTR _x1$2$[esp+20], ebx
$LN22@test_Level:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\occRasterizer.cpp

; 126  : 	int y0		= iFloor	(_y0*dim+.5f);	clamp(y0,0,		dim-1);

	movss	xmm0, DWORD PTR __y0$[esp+20]
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h

; 84   :     int exponent	= (127 + 31) - ((a >> 23) & 0xFF);

	mov	ecx, edi
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\occRasterizer.cpp

; 126  : 	int y0		= iFloor	(_y0*dim+.5f);	clamp(y0,0,		dim-1);

	mulss	xmm0, xmm1
	addss	xmm0, xmm2
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h

; 83   :     int a			= *(const int*)(&x);

	movss	DWORD PTR _a$4[esp+20], xmm0

; 84   :     int exponent	= (127 + 31) - ((a >> 23) & 0xFF);

	mov	esi, DWORD PTR _a$4[esp+20]
	mov	eax, esi
	sar	eax, 23					; 00000017H

; 85   :     int r			= (((u32)(a) << 8) | (1U << 31)) >> exponent;

	mov	edi, esi
	movzx	eax, al
	or	edi, -8388608				; ff800000H
	sub	ecx, eax
	shl	edi, 8
	shr	edi, cl

; 86   :     exponent		+= 31-127;
; 87   :     {
; 88   :         int imask	=	(!(((( (1<<(exponent)))-1)>>8)&a));

	mov	eax, 1
	sub	ecx, 96					; 00000060H

; 89   :         exponent	-=	(31-127)+32;
; 90   :         exponent	>>=	31;
; 91   :         a			>>=	31;

	mov	edx, esi
	shl	eax, cl
	dec	eax
	sar	edx, 31					; 0000001fH
	sar	eax, 8
	and	eax, esi
	neg	eax
	sbb	eax, eax
	inc	eax
	and	eax, edx

; 92   :         r			-=	(imask&a);

	sub	edi, eax
	lea	eax, DWORD PTR [ecx+64]
	sar	eax, 31					; 0000001fH

; 93   :         r			&=	exponent;

	and	edi, eax
	xor	edi, edx
; File I:\Vitalya\mine\NSProjectX\xrCore\vector.h

; 92   : 	if( val<_low ) val = _low; else if( val>_high ) val = _high;

	jge	SHORT $LN27@test_Level
	xor	edi, edi
	jmp	SHORT $LN29@test_Level
$LN27@test_Level:
	cmp	edi, 63					; 0000003fH
	mov	eax, 63					; 0000003fH
	cmovg	edi, eax
$LN29@test_Level:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\occRasterizer.cpp

; 127  : 	int y1		= iFloor	(_y1*dim+.5f);	clamp(y1,y0,	dim-1);

	movss	xmm0, DWORD PTR __y1$[esp+20]
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h

; 84   :     int exponent	= (127 + 31) - ((a >> 23) & 0xFF);

	mov	ecx, 158				; 0000009eH
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\occRasterizer.cpp

; 127  : 	int y1		= iFloor	(_y1*dim+.5f);	clamp(y1,y0,	dim-1);

	mulss	xmm0, xmm1
	addss	xmm0, xmm2
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h

; 83   :     int a			= *(const int*)(&x);

	movss	DWORD PTR _a$3[esp+20], xmm0

; 84   :     int exponent	= (127 + 31) - ((a >> 23) & 0xFF);

	mov	esi, DWORD PTR _a$3[esp+20]
	mov	eax, esi
	sar	eax, 23					; 00000017H

; 85   :     int r			= (((u32)(a) << 8) | (1U << 31)) >> exponent;

	mov	ebx, esi
	movzx	eax, al
	or	ebx, -8388608				; ff800000H
	sub	ecx, eax
	shl	ebx, 8
	shr	ebx, cl

; 86   :     exponent		+= 31-127;
; 87   :     {
; 88   :         int imask	=	(!(((( (1<<(exponent)))-1)>>8)&a));

	mov	eax, 1
	sub	ecx, 96					; 00000060H

; 89   :         exponent	-=	(31-127)+32;
; 90   :         exponent	>>=	31;
; 91   :         a			>>=	31;

	mov	edx, esi
	shl	eax, cl
	dec	eax
	sar	edx, 31					; 0000001fH
	sar	eax, 8
	and	eax, esi
	neg	eax
	sbb	eax, eax
	inc	eax
	and	eax, edx

; 92   :         r			-=	(imask&a);

	sub	ebx, eax
	lea	eax, DWORD PTR [ecx+64]
	sar	eax, 31					; 0000001fH

; 93   :         r			&=	exponent;

	and	ebx, eax
	xor	ebx, edx
; File I:\Vitalya\mine\NSProjectX\xrCore\vector.h

; 92   : 	if( val<_low ) val = _low; else if( val>_high ) val = _high;

	cmp	ebx, edi
	jge	SHORT $LN34@test_Level
	mov	ebx, edi
	jmp	SHORT $LN36@test_Level
$LN34@test_Level:
	cmp	ebx, 63					; 0000003fH
	mov	eax, 63					; 0000003fH
	cmovg	ebx, eax
$LN36@test_Level:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\hom.h

; 44   : 		if (g_pGamePersistent->m_pMainMenu && g_pGamePersistent->m_pMainMenu->IsActive())

	mov	eax, DWORD PTR __imp_?g_pGamePersistent@@3PAVIGame_Persistent@@A
	mov	eax, DWORD PTR [eax]
	mov	ecx, DWORD PTR [eax+1112]
	test	ecx, ecx
	je	SHORT $LN39@test_Level
	mov	eax, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax+8]
	call	eax
	test	al, al
	jne	SHORT $LN38@test_Level
$LN39@test_Level:

; 45   : 			return;
; 46   : 
; 47   : 		MT_RENDER			(); 

	mov	ecx, OFFSET ?RImplementation@@3VCRender@@A+712
	call	?MT_RENDER@CHOM@@QAGXXZ			; CHOM::MT_RENDER
$LN38@test_Level:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\occRasterizer.cpp

; 132  : 	for (int y=y0; y<=y1; y++)

	cmp	edi, ebx
	jg	SHORT $LN50@test_Level
	mov	eax, DWORD PTR _x1$2$[esp+20]
	mov	ecx, edi
	mov	edx, DWORD PTR _z$[esp+20]
	shl	ecx, 8
	shl	eax, 2
	add	ecx, eax
	shl	ebp, 2
	add	ecx, DWORD PTR _depth$1$[esp+24]
	sub	ebp, eax
$LL4@test_Level:

; 133  : 	{
; 134  : 		occD* base	= depth+y*dim;
; 135  : 		occD* it	= base + x0;

	lea	eax, DWORD PTR [ecx+ebp]

; 136  : 		occD* end	= base + x1;
; 137  : 		for (; it<=end; it++)

	cmp	eax, ecx
	ja	SHORT $LN2@test_Level
	npad	2
$LL7@test_Level:

; 138  : 			if (z<*it)	return TRUE;

	cmp	edx, DWORD PTR [eax]
	jl	SHORT $LN43@test_Level

; 136  : 		occD* end	= base + x1;
; 137  : 		for (; it<=end; it++)

	add	eax, 4
	cmp	eax, ecx
	jbe	SHORT $LL7@test_Level
$LN2@test_Level:

; 132  : 	for (int y=y0; y<=y1; y++)

	inc	edi
	add	ecx, 256				; 00000100H
	cmp	edi, ebx
	jle	SHORT $LL4@test_Level
$LN50@test_Level:

; 139  : 	}
; 140  : 	return FALSE;

	xor	eax, eax

; 141  : }

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 8
	ret	0
$LN43@test_Level:
	pop	edi
	pop	esi
	pop	ebp
	mov	eax, 1
	pop	ebx
	add	esp, 8
	ret	0
?test_Level@@YAHPAHHMMMMH@Z ENDP			; test_Level
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\hom.h
;	COMDAT ?MT_SYNC@CHOM@@QAEXXZ
_TEXT	SEGMENT
?MT_SYNC@CHOM@@QAEXXZ PROC				; CHOM::MT_SYNC, COMDAT
; _this$ = ecx

; 44   : 		if (g_pGamePersistent->m_pMainMenu && g_pGamePersistent->m_pMainMenu->IsActive())

	mov	eax, DWORD PTR __imp_?g_pGamePersistent@@3PAVIGame_Persistent@@A
	push	esi
	mov	esi, ecx
	mov	eax, DWORD PTR [eax]
	mov	ecx, DWORD PTR [eax+1112]
	test	ecx, ecx
	je	SHORT $LN2@MT_SYNC
	mov	eax, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax+8]
	call	eax
	test	al, al
	jne	SHORT $LN1@MT_SYNC
$LN2@MT_SYNC:

; 45   : 			return;
; 46   : 
; 47   : 		MT_RENDER			(); 

	mov	ecx, esi

; 48   : 	}

	pop	esi

; 45   : 			return;
; 46   : 
; 47   : 		MT_RENDER			(); 

	jmp	?MT_RENDER@CHOM@@QAGXXZ			; CHOM::MT_RENDER
$LN1@MT_SYNC:

; 48   : 	}

	pop	esi
	ret	0
?MT_SYNC@CHOM@@QAEXXZ ENDP				; CHOM::MT_SYNC
_TEXT	ENDS
END
