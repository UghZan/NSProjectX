; Listing generated by Microsoft (R) Optimizing Compiler Version 19.29.30146.0 

	TITLE	i:\vitalya\mine\nsprojectx\nspx_build\intermediate\release-win32\xrrender_r1\nvtristrip.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

?_Fake_alloc@std@@3U_Fake_allocator@1@B	ORG $+1		; std::_Fake_alloc
?bStitchStrips@@3_NA DB 01H				; bStitchStrips
PUBLIC	?_Destroy@?$vector@HV?$xalloc@H@@@std@@AAEXPAH0@Z ; std::vector<int,xalloc<int> >::_Destroy
PUBLIC	?_Getal@?$vector@HV?$xalloc@H@@@std@@AAEAAV?$xalloc@H@@XZ ; std::vector<int,xalloc<int> >::_Getal
PUBLIC	?_Get_first@?$_Compressed_pair@V?$xalloc@H@@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@$00@std@@QAEAAV?$xalloc@H@@XZ ; std::_Compressed_pair<xalloc<int>,std::_Vector_val<std::_Simple_types<int> >,1>::_Get_first
PUBLIC	??$_Destroy_range@V?$xalloc@H@@@std@@YAXPAHQAHAAV?$xalloc@H@@@Z ; std::_Destroy_range<xalloc<int> >
PUBLIC	??$_Unfancy@H@std@@YAPAHPAH@Z			; std::_Unfancy<int>
PUBLIC	??$destroy@H@?$_Normal_allocator_traits@V?$xalloc@H@@@std@@SAXAAV?$xalloc@H@@PAH@Z ; std::_Normal_allocator_traits<xalloc<int> >::destroy<int>
PUBLIC	?destroy@?$xalloc@H@@QAEXPAH@Z			; xalloc<int>::destroy
PUBLIC	??$_Destroy_in_place@PAH@std@@YAXAAPAH@Z	; std::_Destroy_in_place<int *>
PUBLIC	??0?$_Vector_val@U?$_Simple_types@H@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<int> >::_Vector_val<std::_Simple_types<int> >
PUBLIC	?construct@?$xalloc@UPrimitiveGroup@@@@QAEXPAUPrimitiveGroup@@ABU2@@Z ; xalloc<PrimitiveGroup>::construct
PUBLIC	??$construct@UPrimitiveGroup@@U1@@?$_Normal_allocator_traits@V?$xalloc@UPrimitiveGroup@@@@@std@@SAXAAV?$xalloc@UPrimitiveGroup@@@@PAUPrimitiveGroup@@$$QAU3@@Z ; std::_Normal_allocator_traits<xalloc<PrimitiveGroup> >::construct<PrimitiveGroup,PrimitiveGroup>
PUBLIC	??$forward@UPrimitiveGroup@@@std@@YA$$QAUPrimitiveGroup@@AAU1@@Z ; std::forward<PrimitiveGroup>
PUBLIC	??$_Destroy_in_place@PAUPrimitiveGroup@@@std@@YAXAAPAUPrimitiveGroup@@@Z ; std::_Destroy_in_place<PrimitiveGroup *>
PUBLIC	??$_Emplace_back@UPrimitiveGroup@@@?$_Uninitialized_backout_al@V?$xalloc@UPrimitiveGroup@@@@@std@@QAEX$$QAUPrimitiveGroup@@@Z ; std::_Uninitialized_backout_al<xalloc<PrimitiveGroup> >::_Emplace_back<PrimitiveGroup>
PUBLIC	??$move@AAUPrimitiveGroup@@@std@@YA$$QAUPrimitiveGroup@@AAU1@@Z ; std::move<PrimitiveGroup &>
PUBLIC	??$construct@UPrimitiveGroup@@$$V@?$_Normal_allocator_traits@V?$xalloc@UPrimitiveGroup@@@@@std@@SAXAAV?$xalloc@UPrimitiveGroup@@@@PAUPrimitiveGroup@@@Z ; std::_Normal_allocator_traits<xalloc<PrimitiveGroup> >::construct<PrimitiveGroup>
PUBLIC	?destroy@?$xalloc@UPrimitiveGroup@@@@QAEXPAUPrimitiveGroup@@@Z ; xalloc<PrimitiveGroup>::destroy
PUBLIC	??$_Get_unwrapped@ABQAUPrimitiveGroup@@@std@@YA?A_TABQAUPrimitiveGroup@@@Z ; std::_Get_unwrapped<PrimitiveGroup * const &>
PUBLIC	??$_Uninitialized_move@PAUPrimitiveGroup@@V?$xalloc@UPrimitiveGroup@@@@@std@@YAPAUPrimitiveGroup@@QAU1@0PAU1@AAV?$xalloc@UPrimitiveGroup@@@@@Z ; std::_Uninitialized_move<PrimitiveGroup *,xalloc<PrimitiveGroup> >
PUBLIC	??$_Destroy_in_place@PAPAVNvFaceInfo@@@std@@YAXAAPAPAVNvFaceInfo@@@Z ; std::_Destroy_in_place<NvFaceInfo * *>
PUBLIC	??$_Destroy_in_place@PAPAVNvStripInfo@@@std@@YAXAAPAPAVNvStripInfo@@@Z ; std::_Destroy_in_place<NvStripInfo * *>
PUBLIC	??$xr_alloc@UPrimitiveGroup@@@@YAPAUPrimitiveGroup@@I@Z ; xr_alloc<PrimitiveGroup>
PUBLIC	??$xr_free@UPrimitiveGroup@@@@YAXAAPAUPrimitiveGroup@@@Z ; xr_free<PrimitiveGroup>
PUBLIC	??$_Emplace_back@$$V@?$_Uninitialized_backout_al@V?$xalloc@UPrimitiveGroup@@@@@std@@QAEXXZ ; std::_Uninitialized_backout_al<xalloc<PrimitiveGroup> >::_Emplace_back<>
PUBLIC	??$destroy@UPrimitiveGroup@@@?$_Normal_allocator_traits@V?$xalloc@UPrimitiveGroup@@@@@std@@SAXAAV?$xalloc@UPrimitiveGroup@@@@PAUPrimitiveGroup@@@Z ; std::_Normal_allocator_traits<xalloc<PrimitiveGroup> >::destroy<PrimitiveGroup>
PUBLIC	??$_Unfancy@UPrimitiveGroup@@@std@@YAPAUPrimitiveGroup@@PAU1@@Z ; std::_Unfancy<PrimitiveGroup>
PUBLIC	?max_size@?$xalloc@UPrimitiveGroup@@@@QBEIXZ	; xalloc<PrimitiveGroup>::max_size
PUBLIC	?_Get_first@?$_Compressed_pair@V?$xalloc@UPrimitiveGroup@@@@V?$_Vector_val@U?$_Simple_types@UPrimitiveGroup@@@std@@@std@@$00@std@@QBEABV?$xalloc@UPrimitiveGroup@@@@XZ ; std::_Compressed_pair<xalloc<PrimitiveGroup>,std::_Vector_val<std::_Simple_types<PrimitiveGroup> >,1>::_Get_first
PUBLIC	?max_size@?$_Normal_allocator_traits@V?$xalloc@UPrimitiveGroup@@@@@std@@SAIABV?$xalloc@UPrimitiveGroup@@@@@Z ; std::_Normal_allocator_traits<xalloc<PrimitiveGroup> >::max_size
PUBLIC	?capacity@?$vector@UPrimitiveGroup@@V?$xalloc@UPrimitiveGroup@@@@@std@@QBEIXZ ; std::vector<PrimitiveGroup,xalloc<PrimitiveGroup> >::capacity
PUBLIC	?_Umove_if_noexcept1@?$vector@UPrimitiveGroup@@V?$xalloc@UPrimitiveGroup@@@@@std@@AAEXPAUPrimitiveGroup@@00U?$integral_constant@_N$00@2@@Z ; std::vector<PrimitiveGroup,xalloc<PrimitiveGroup> >::_Umove_if_noexcept1
PUBLIC	?_Getal@?$vector@UPrimitiveGroup@@V?$xalloc@UPrimitiveGroup@@@@@std@@ABEABV?$xalloc@UPrimitiveGroup@@@@XZ ; std::vector<PrimitiveGroup,xalloc<PrimitiveGroup> >::_Getal
PUBLIC	?destroy@?$xalloc@PAVNvFaceInfo@@@@QAEXPAPAVNvFaceInfo@@@Z ; xalloc<NvFaceInfo *>::destroy
PUBLIC	?destroy@?$xalloc@PAVNvStripInfo@@@@QAEXPAPAVNvStripInfo@@@Z ; xalloc<NvStripInfo *>::destroy
PUBLIC	?allocate@?$xalloc@UPrimitiveGroup@@@@QBEPAUPrimitiveGroup@@IPBX@Z ; xalloc<PrimitiveGroup>::allocate
PUBLIC	?deallocate@?$xalloc@UPrimitiveGroup@@@@QBEXPAUPrimitiveGroup@@I@Z ; xalloc<PrimitiveGroup>::deallocate
PUBLIC	?max_size@?$vector@UPrimitiveGroup@@V?$xalloc@UPrimitiveGroup@@@@@std@@QBEIXZ ; std::vector<PrimitiveGroup,xalloc<PrimitiveGroup> >::max_size
PUBLIC	?_Umove_if_noexcept@?$vector@UPrimitiveGroup@@V?$xalloc@UPrimitiveGroup@@@@@std@@AAEXPAUPrimitiveGroup@@00@Z ; std::vector<PrimitiveGroup,xalloc<PrimitiveGroup> >::_Umove_if_noexcept
PUBLIC	?_Calculate_growth@?$vector@UPrimitiveGroup@@V?$xalloc@UPrimitiveGroup@@@@@std@@ABEII@Z ; std::vector<PrimitiveGroup,xalloc<PrimitiveGroup> >::_Calculate_growth
PUBLIC	?_Change_array@?$vector@UPrimitiveGroup@@V?$xalloc@UPrimitiveGroup@@@@@std@@AAEXQAUPrimitiveGroup@@II@Z ; std::vector<PrimitiveGroup,xalloc<PrimitiveGroup> >::_Change_array
PUBLIC	?_Xlength@?$vector@UPrimitiveGroup@@V?$xalloc@UPrimitiveGroup@@@@@std@@CAXXZ ; std::vector<PrimitiveGroup,xalloc<PrimitiveGroup> >::_Xlength
PUBLIC	??0?$_Uninitialized_backout_al@V?$xalloc@UPrimitiveGroup@@@@@std@@QAE@PAUPrimitiveGroup@@AAV?$xalloc@UPrimitiveGroup@@@@@Z ; std::_Uninitialized_backout_al<xalloc<PrimitiveGroup> >::_Uninitialized_backout_al<xalloc<PrimitiveGroup> >
PUBLIC	??1?$_Uninitialized_backout_al@V?$xalloc@UPrimitiveGroup@@@@@std@@QAE@XZ ; std::_Uninitialized_backout_al<xalloc<PrimitiveGroup> >::~_Uninitialized_backout_al<xalloc<PrimitiveGroup> >
PUBLIC	?_Release@?$_Uninitialized_backout_al@V?$xalloc@UPrimitiveGroup@@@@@std@@QAEPAUPrimitiveGroup@@XZ ; std::_Uninitialized_backout_al<xalloc<PrimitiveGroup> >::_Release
PUBLIC	??$_Uninitialized_value_construct_n@V?$xalloc@UPrimitiveGroup@@@@@std@@YAPAUPrimitiveGroup@@PAU1@IAAV?$xalloc@UPrimitiveGroup@@@@@Z ; std::_Uninitialized_value_construct_n<xalloc<PrimitiveGroup> >
PUBLIC	??$_Destroy_range@V?$xalloc@UPrimitiveGroup@@@@@std@@YAXPAUPrimitiveGroup@@QAU1@AAV?$xalloc@UPrimitiveGroup@@@@@Z ; std::_Destroy_range<xalloc<PrimitiveGroup> >
PUBLIC	??$destroy@PAVNvFaceInfo@@@?$_Normal_allocator_traits@V?$xalloc@PAVNvFaceInfo@@@@@std@@SAXAAV?$xalloc@PAVNvFaceInfo@@@@PAPAVNvFaceInfo@@@Z ; std::_Normal_allocator_traits<xalloc<NvFaceInfo *> >::destroy<NvFaceInfo *>
PUBLIC	??$_Unfancy@PAVNvFaceInfo@@@std@@YAPAPAVNvFaceInfo@@PAPAV1@@Z ; std::_Unfancy<NvFaceInfo *>
PUBLIC	??$destroy@PAVNvStripInfo@@@?$_Normal_allocator_traits@V?$xalloc@PAVNvStripInfo@@@@@std@@SAXAAV?$xalloc@PAVNvStripInfo@@@@PAPAVNvStripInfo@@@Z ; std::_Normal_allocator_traits<xalloc<NvStripInfo *> >::destroy<NvStripInfo *>
PUBLIC	??$_Unfancy@PAVNvStripInfo@@@std@@YAPAPAVNvStripInfo@@PAPAV1@@Z ; std::_Unfancy<NvStripInfo *>
PUBLIC	??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UPrimitiveGroup@@V?$xalloc@UPrimitiveGroup@@@@@std@@AAEXIABU_Value_init_tag@1@@Z ; std::vector<PrimitiveGroup,xalloc<PrimitiveGroup> >::_Resize_reallocate<std::_Value_init_tag>
PUBLIC	?_Get_first@?$_Compressed_pair@V?$xalloc@UPrimitiveGroup@@@@V?$_Vector_val@U?$_Simple_types@UPrimitiveGroup@@@std@@@std@@$00@std@@QAEAAV?$xalloc@UPrimitiveGroup@@@@XZ ; std::_Compressed_pair<xalloc<PrimitiveGroup>,std::_Vector_val<std::_Simple_types<PrimitiveGroup> >,1>::_Get_first
PUBLIC	?_Getal@?$vector@UPrimitiveGroup@@V?$xalloc@UPrimitiveGroup@@@@@std@@AAEAAV?$xalloc@UPrimitiveGroup@@@@XZ ; std::vector<PrimitiveGroup,xalloc<PrimitiveGroup> >::_Getal
PUBLIC	??1NvStripInfo@@QAE@XZ				; NvStripInfo::~NvStripInfo
PUBLIC	??_GNvStripInfo@@QAEPAXI@Z			; NvStripInfo::`scalar deleting destructor'
PUBLIC	??0?$xalloc@H@@QAE@XZ				; xalloc<int>::xalloc<int>
PUBLIC	??0?$xalloc@PAVNvFaceInfo@@@@QAE@XZ		; xalloc<NvFaceInfo *>::xalloc<NvFaceInfo *>
PUBLIC	??0?$_Vector_val@U?$_Simple_types@PAVNvFaceInfo@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<NvFaceInfo *> >::_Vector_val<std::_Simple_types<NvFaceInfo *> >
PUBLIC	??0?$xalloc@PAVNvStripInfo@@@@QAE@XZ		; xalloc<NvStripInfo *>::xalloc<NvStripInfo *>
PUBLIC	??0?$_Vector_val@U?$_Simple_types@PAVNvStripInfo@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<NvStripInfo *> >::_Vector_val<std::_Simple_types<NvStripInfo *> >
PUBLIC	?_Ufill@?$vector@UPrimitiveGroup@@V?$xalloc@UPrimitiveGroup@@@@@std@@AAEPAUPrimitiveGroup@@PAU3@IU_Value_init_tag@2@@Z ; std::vector<PrimitiveGroup,xalloc<PrimitiveGroup> >::_Ufill
PUBLIC	?_Destroy@?$vector@UPrimitiveGroup@@V?$xalloc@UPrimitiveGroup@@@@@std@@AAEXPAUPrimitiveGroup@@0@Z ; std::vector<PrimitiveGroup,xalloc<PrimitiveGroup> >::_Destroy
PUBLIC	?_Orphan_range@?$vector@UPrimitiveGroup@@V?$xalloc@UPrimitiveGroup@@@@@std@@ABEXPAUPrimitiveGroup@@0@Z ; std::vector<PrimitiveGroup,xalloc<PrimitiveGroup> >::_Orphan_range
PUBLIC	??R?$xr_special_free@$0A@VNvFaceInfo@@@@QAEXAAPAVNvFaceInfo@@@Z ; xr_special_free<0,NvFaceInfo>::operator()
PUBLIC	??R?$xr_special_free@$0A@VNvStripInfo@@@@QAEXAAPAVNvStripInfo@@@Z ; xr_special_free<0,NvStripInfo>::operator()
PUBLIC	??$xr_free@PAVNvFaceInfo@@@@YAXAAPAPAVNvFaceInfo@@@Z ; xr_free<NvFaceInfo *>
PUBLIC	??$_Destroy_range@V?$xalloc@PAVNvFaceInfo@@@@@std@@YAXPAPAVNvFaceInfo@@QAPAV1@AAV?$xalloc@PAVNvFaceInfo@@@@@Z ; std::_Destroy_range<xalloc<NvFaceInfo *> >
PUBLIC	??$xr_free@PAVNvStripInfo@@@@YAXAAPAPAVNvStripInfo@@@Z ; xr_free<NvStripInfo *>
PUBLIC	??$_Destroy_range@V?$xalloc@PAVNvStripInfo@@@@@std@@YAXPAPAVNvStripInfo@@QAPAV1@AAV?$xalloc@PAVNvStripInfo@@@@@Z ; std::_Destroy_range<xalloc<NvStripInfo *> >
PUBLIC	??$?0$$V@?$_Compressed_pair@V?$xalloc@H@@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<xalloc<int>,std::_Vector_val<std::_Simple_types<int> >,1>::_Compressed_pair<xalloc<int>,std::_Vector_val<std::_Simple_types<int> >,1><>
PUBLIC	??$addressof@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@H@std@@@0@AAV10@@Z ; std::addressof<std::_Vector_val<std::_Simple_types<int> > >
PUBLIC	??$?0$$V@?$_Compressed_pair@V?$xalloc@PAVNvFaceInfo@@@@V?$_Vector_val@U?$_Simple_types@PAVNvFaceInfo@@@std@@@std@@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<xalloc<NvFaceInfo *>,std::_Vector_val<std::_Simple_types<NvFaceInfo *> >,1>::_Compressed_pair<xalloc<NvFaceInfo *>,std::_Vector_val<std::_Simple_types<NvFaceInfo *> >,1><>
PUBLIC	??$addressof@V?$_Vector_val@U?$_Simple_types@PAVNvFaceInfo@@@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@PAVNvFaceInfo@@@std@@@0@AAV10@@Z ; std::addressof<std::_Vector_val<std::_Simple_types<NvFaceInfo *> > >
PUBLIC	??$?0$$V@?$_Compressed_pair@V?$xalloc@PAVNvStripInfo@@@@V?$_Vector_val@U?$_Simple_types@PAVNvStripInfo@@@std@@@std@@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<xalloc<NvStripInfo *>,std::_Vector_val<std::_Simple_types<NvStripInfo *> >,1>::_Compressed_pair<xalloc<NvStripInfo *>,std::_Vector_val<std::_Simple_types<NvStripInfo *> >,1><>
PUBLIC	??$addressof@V?$_Vector_val@U?$_Simple_types@PAVNvStripInfo@@@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@PAVNvStripInfo@@@std@@@0@AAV10@@Z ; std::addressof<std::_Vector_val<std::_Simple_types<NvStripInfo *> > >
PUBLIC	??$addressof@V?$_Vector_val@U?$_Simple_types@UPrimitiveGroup@@@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@UPrimitiveGroup@@@std@@@0@AAV10@@Z ; std::addressof<std::_Vector_val<std::_Simple_types<PrimitiveGroup> > >
PUBLIC	??$addressof@$$CBV?$_Vector_val@U?$_Simple_types@UPrimitiveGroup@@@std@@@std@@@std@@YAPBV?$_Vector_val@U?$_Simple_types@UPrimitiveGroup@@@std@@@0@ABV10@@Z ; std::addressof<std::_Vector_val<std::_Simple_types<PrimitiveGroup> > const >
PUBLIC	??$_Resize@U_Value_init_tag@std@@@?$vector@UPrimitiveGroup@@V?$xalloc@UPrimitiveGroup@@@@@std@@AAEXIABU_Value_init_tag@1@@Z ; std::vector<PrimitiveGroup,xalloc<PrimitiveGroup> >::_Resize<std::_Value_init_tag>
PUBLIC	??$xr_free@H@@YAXAAPAH@Z			; xr_free<int>
PUBLIC	??$xr_alloc@H@@YAPAHI@Z				; xr_alloc<int>
PUBLIC	??$xr_delete@VNvStripInfo@@@@YAXAAPAVNvStripInfo@@@Z ; xr_delete<NvStripInfo>
PUBLIC	??$xr_delete@VNvFaceInfo@@@@YAXAAPAVNvFaceInfo@@@Z ; xr_delete<NvFaceInfo>
PUBLIC	?_Verify_offset@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVNvStripInfo@@@std@@@std@@@std@@QBEXH@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<NvStripInfo *> > >::_Verify_offset
PUBLIC	?_Verify_offset@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVNvFaceInfo@@@std@@@std@@@std@@QBEXH@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<NvFaceInfo *> > >::_Verify_offset
PUBLIC	?_Verify_offset@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QBEXH@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int> > >::_Verify_offset
PUBLIC	?_Get_first@?$_Compressed_pair@V?$xalloc@PAVNvFaceInfo@@@@V?$_Vector_val@U?$_Simple_types@PAVNvFaceInfo@@@std@@@std@@$00@std@@QAEAAV?$xalloc@PAVNvFaceInfo@@@@XZ ; std::_Compressed_pair<xalloc<NvFaceInfo *>,std::_Vector_val<std::_Simple_types<NvFaceInfo *> >,1>::_Get_first
PUBLIC	?_Get_first@?$_Compressed_pair@V?$xalloc@PAVNvStripInfo@@@@V?$_Vector_val@U?$_Simple_types@PAVNvStripInfo@@@std@@@std@@$00@std@@QAEAAV?$xalloc@PAVNvStripInfo@@@@XZ ; std::_Compressed_pair<xalloc<NvStripInfo *>,std::_Vector_val<std::_Simple_types<NvStripInfo *> >,1>::_Get_first
PUBLIC	?_Verify_offset@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UPrimitiveGroup@@@std@@@std@@@std@@QBEXH@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<PrimitiveGroup> > >::_Verify_offset
PUBLIC	??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVNvStripInfo@@@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<NvStripInfo *> > >::operator+=
PUBLIC	??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVNvFaceInfo@@@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<NvFaceInfo *> > >::operator+=
PUBLIC	??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int> > >::operator+=
PUBLIC	?deallocate@?$xalloc@H@@QBEXPAHI@Z		; xalloc<int>::deallocate
PUBLIC	?deallocate@?$xalloc@PAVNvFaceInfo@@@@QBEXPAPAVNvFaceInfo@@I@Z ; xalloc<NvFaceInfo *>::deallocate
PUBLIC	?_Destroy@?$vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@std@@AAEXPAPAVNvFaceInfo@@0@Z ; std::vector<NvFaceInfo *,xalloc<NvFaceInfo *> >::_Destroy
PUBLIC	?_Getal@?$vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@std@@AAEAAV?$xalloc@PAVNvFaceInfo@@@@XZ ; std::vector<NvFaceInfo *,xalloc<NvFaceInfo *> >::_Getal
PUBLIC	?deallocate@?$xalloc@PAVNvStripInfo@@@@QBEXPAPAVNvStripInfo@@I@Z ; xalloc<NvStripInfo *>::deallocate
PUBLIC	?_Destroy@?$vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@std@@AAEXPAPAVNvStripInfo@@0@Z ; std::vector<NvStripInfo *,xalloc<NvStripInfo *> >::_Destroy
PUBLIC	?_Getal@?$vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@std@@AAEAAV?$xalloc@PAVNvStripInfo@@@@XZ ; std::vector<NvStripInfo *,xalloc<NvStripInfo *> >::_Getal
PUBLIC	??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UPrimitiveGroup@@@std@@@std@@@std@@QAE@PAUPrimitiveGroup@@PBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<PrimitiveGroup> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<PrimitiveGroup> > >
PUBLIC	??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UPrimitiveGroup@@@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<PrimitiveGroup> > >::operator+=
PUBLIC	??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UPrimitiveGroup@@@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<PrimitiveGroup> > >::operator+=
PUBLIC	??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVNvStripInfo@@@std@@@std@@@std@@QAE@PAPAVNvStripInfo@@PBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<NvStripInfo *> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<NvStripInfo *> > >
PUBLIC	??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVNvStripInfo@@@std@@@std@@@std@@QBEABQAVNvStripInfo@@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<NvStripInfo *> > >::operator*
PUBLIC	??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVNvStripInfo@@@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NvStripInfo *> > >::operator+=
PUBLIC	??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVNvFaceInfo@@@std@@@std@@@std@@QAE@PAPAVNvFaceInfo@@PBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<NvFaceInfo *> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<NvFaceInfo *> > >
PUBLIC	??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVNvFaceInfo@@@std@@@std@@@std@@QBEABQAVNvFaceInfo@@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<NvFaceInfo *> > >::operator*
PUBLIC	??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVNvFaceInfo@@@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NvFaceInfo *> > >::operator+=
PUBLIC	??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@PAHPBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int> > >
PUBLIC	??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QBEABHXZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int> > >::operator*
PUBLIC	??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int> > >::operator+=
PUBLIC	??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@PAHPBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<int> > >
PUBLIC	??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVNvFaceInfo@@@std@@@std@@@std@@QAE@PAPAVNvFaceInfo@@PBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NvFaceInfo *> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<NvFaceInfo *> > >
PUBLIC	??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVNvStripInfo@@@std@@@std@@@std@@QAE@PAPAVNvStripInfo@@PBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NvStripInfo *> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<NvStripInfo *> > >
PUBLIC	??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UPrimitiveGroup@@@std@@@std@@@std@@QAE@PAUPrimitiveGroup@@PBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<PrimitiveGroup> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<PrimitiveGroup> > >
PUBLIC	??0?$vector@HV?$xalloc@H@@@std@@QAE@XZ		; std::vector<int,xalloc<int> >::vector<int,xalloc<int> >
PUBLIC	?begin@?$vector@HV?$xalloc@H@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@XZ ; std::vector<int,xalloc<int> >::begin
PUBLIC	?size@?$vector@HV?$xalloc@H@@@std@@QBEIXZ	; std::vector<int,xalloc<int> >::size
PUBLIC	?_Tidy@?$vector@HV?$xalloc@H@@@std@@AAEXXZ	; std::vector<int,xalloc<int> >::_Tidy
PUBLIC	??0?$vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@std@@QAE@XZ ; std::vector<NvFaceInfo *,xalloc<NvFaceInfo *> >::vector<NvFaceInfo *,xalloc<NvFaceInfo *> >
PUBLIC	?begin@?$vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVNvFaceInfo@@@std@@@std@@@2@XZ ; std::vector<NvFaceInfo *,xalloc<NvFaceInfo *> >::begin
PUBLIC	?size@?$vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@std@@QBEIXZ ; std::vector<NvFaceInfo *,xalloc<NvFaceInfo *> >::size
PUBLIC	?_Tidy@?$vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@std@@AAEXXZ ; std::vector<NvFaceInfo *,xalloc<NvFaceInfo *> >::_Tidy
PUBLIC	??0?$vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@std@@QAE@XZ ; std::vector<NvStripInfo *,xalloc<NvStripInfo *> >::vector<NvStripInfo *,xalloc<NvStripInfo *> >
PUBLIC	?begin@?$vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVNvStripInfo@@@std@@@std@@@2@XZ ; std::vector<NvStripInfo *,xalloc<NvStripInfo *> >::begin
PUBLIC	?size@?$vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@std@@QBEIXZ ; std::vector<NvStripInfo *,xalloc<NvStripInfo *> >::size
PUBLIC	?_Tidy@?$vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@std@@AAEXXZ ; std::vector<NvStripInfo *,xalloc<NvStripInfo *> >::_Tidy
PUBLIC	?begin@?$vector@UPrimitiveGroup@@V?$xalloc@UPrimitiveGroup@@@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UPrimitiveGroup@@@std@@@std@@@2@XZ ; std::vector<PrimitiveGroup,xalloc<PrimitiveGroup> >::begin
PUBLIC	?begin@?$vector@UPrimitiveGroup@@V?$xalloc@UPrimitiveGroup@@@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UPrimitiveGroup@@@std@@@std@@@2@XZ ; std::vector<PrimitiveGroup,xalloc<PrimitiveGroup> >::begin
PUBLIC	?size@?$vector@UPrimitiveGroup@@V?$xalloc@UPrimitiveGroup@@@@@std@@QBEIXZ ; std::vector<PrimitiveGroup,xalloc<PrimitiveGroup> >::size
PUBLIC	??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UPrimitiveGroup@@@std@@@std@@@std@@QBEABUPrimitiveGroup@@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<PrimitiveGroup> > >::operator*
PUBLIC	??H?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UPrimitiveGroup@@@std@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<PrimitiveGroup> > >::operator+
PUBLIC	??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UPrimitiveGroup@@@std@@@std@@@std@@QBEAAUPrimitiveGroup@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<PrimitiveGroup> > >::operator*
PUBLIC	??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UPrimitiveGroup@@@std@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<PrimitiveGroup> > >::operator+
PUBLIC	??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVNvStripInfo@@@std@@@std@@@std@@QBEAAPAVNvStripInfo@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NvStripInfo *> > >::operator*
PUBLIC	??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVNvStripInfo@@@std@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NvStripInfo *> > >::operator+
PUBLIC	??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVNvFaceInfo@@@std@@@std@@@std@@QBEAAPAVNvFaceInfo@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NvFaceInfo *> > >::operator*
PUBLIC	??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVNvFaceInfo@@@std@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NvFaceInfo *> > >::operator+
PUBLIC	??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QBEAAHXZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int> > >::operator*
PUBLIC	??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int> > >::operator+
PUBLIC	??1?$vector@HV?$xalloc@H@@@std@@QAE@XZ		; std::vector<int,xalloc<int> >::~vector<int,xalloc<int> >
PUBLIC	??0?$xr_vector@HV?$xalloc@H@@@@QAE@XZ		; xr_vector<int,xalloc<int> >::xr_vector<int,xalloc<int> >
PUBLIC	?size@?$xr_vector@HV?$xalloc@H@@@@QBEIXZ	; xr_vector<int,xalloc<int> >::size
PUBLIC	??A?$xr_vector@HV?$xalloc@H@@@@QAEAAHI@Z	; xr_vector<int,xalloc<int> >::operator[]
PUBLIC	??1?$vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@std@@QAE@XZ ; std::vector<NvFaceInfo *,xalloc<NvFaceInfo *> >::~vector<NvFaceInfo *,xalloc<NvFaceInfo *> >
PUBLIC	??0?$xr_vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@@QAE@XZ ; xr_vector<NvFaceInfo *,xalloc<NvFaceInfo *> >::xr_vector<NvFaceInfo *,xalloc<NvFaceInfo *> >
PUBLIC	?size@?$xr_vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@@QBEIXZ ; xr_vector<NvFaceInfo *,xalloc<NvFaceInfo *> >::size
PUBLIC	??A?$xr_vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@@QAEAAPAVNvFaceInfo@@I@Z ; xr_vector<NvFaceInfo *,xalloc<NvFaceInfo *> >::operator[]
PUBLIC	??1?$vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@std@@QAE@XZ ; std::vector<NvStripInfo *,xalloc<NvStripInfo *> >::~vector<NvStripInfo *,xalloc<NvStripInfo *> >
PUBLIC	??0?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@QAE@XZ ; xr_vector<NvStripInfo *,xalloc<NvStripInfo *> >::xr_vector<NvStripInfo *,xalloc<NvStripInfo *> >
PUBLIC	?size@?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@QBEIXZ ; xr_vector<NvStripInfo *,xalloc<NvStripInfo *> >::size
PUBLIC	??A?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@QAEAAPAVNvStripInfo@@I@Z ; xr_vector<NvStripInfo *,xalloc<NvStripInfo *> >::operator[]
PUBLIC	?resize@?$vector@UPrimitiveGroup@@V?$xalloc@UPrimitiveGroup@@@@@std@@QAEXI@Z ; std::vector<PrimitiveGroup,xalloc<PrimitiveGroup> >::resize
PUBLIC	?size@?$xr_vector@UPrimitiveGroup@@V?$xalloc@UPrimitiveGroup@@@@@@QBEIXZ ; xr_vector<PrimitiveGroup,xalloc<PrimitiveGroup> >::size
PUBLIC	??A?$xr_vector@UPrimitiveGroup@@V?$xalloc@UPrimitiveGroup@@@@@@QBEABUPrimitiveGroup@@I@Z ; xr_vector<PrimitiveGroup,xalloc<PrimitiveGroup> >::operator[]
PUBLIC	??A?$xr_vector@UPrimitiveGroup@@V?$xalloc@UPrimitiveGroup@@@@@@QAEAAUPrimitiveGroup@@I@Z ; xr_vector<PrimitiveGroup,xalloc<PrimitiveGroup> >::operator[]
PUBLIC	?RemapIndices@@YAXABV?$xr_vector@UPrimitiveGroup@@V?$xalloc@UPrimitiveGroup@@@@@@GAAV1@@Z ; RemapIndices
PUBLIC	??1?$xr_vector@HV?$xalloc@H@@@@QAE@XZ		; xr_vector<int,xalloc<int> >::~xr_vector<int,xalloc<int> >
PUBLIC	??1?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@QAE@XZ ; xr_vector<NvStripInfo *,xalloc<NvStripInfo *> >::~xr_vector<NvStripInfo *,xalloc<NvStripInfo *> >
PUBLIC	?GenerateStrips@@YAXPBGHAAV?$xr_vector@UPrimitiveGroup@@V?$xalloc@UPrimitiveGroup@@@@@@@Z ; GenerateStrips
PUBLIC	?SetMinStripSize@@YAXI@Z			; SetMinStripSize
PUBLIC	?SetCacheSize@@YAXI@Z				; SetCacheSize
PUBLIC	?SetListsOnly@@YAX_N@Z				; SetListsOnly
PUBLIC	??0PrimitiveGroup@@QAE@XZ			; PrimitiveGroup::PrimitiveGroup
PUBLIC	??1?$xr_vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@@QAE@XZ ; xr_vector<NvFaceInfo *,xalloc<NvFaceInfo *> >::~xr_vector<NvFaceInfo *,xalloc<NvFaceInfo *> >
?minStripSize@@3IA DD 01H DUP (?)			; minStripSize
?bListsOnly@@3_NA DB 01H DUP (?)			; bListsOnly
_BSS	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UPrimitiveGroup@@V?$xalloc@UPrimitiveGroup@@@@@std@@AAEXIABU_Value_init_tag@1@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UPrimitiveGroup@@V?$xalloc@UPrimitiveGroup@@@@@std@@AAEXIABU_Value_init_tag@1@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UPrimitiveGroup@@V?$xalloc@UPrimitiveGroup@@@@@std@@AAEXIABU_Value_init_tag@1@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
__unwindtable$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UPrimitiveGroup@@V?$xalloc@UPrimitiveGroup@@@@@std@@AAEXIABU_Value_init_tag@1@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UPrimitiveGroup@@V?$xalloc@UPrimitiveGroup@@@@@std@@AAEXIABU_Value_init_tag@1@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UPrimitiveGroup@@V?$xalloc@UPrimitiveGroup@@@@@std@@AAEXIABU_Value_init_tag@1@@Z$2
__catchsym$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UPrimitiveGroup@@V?$xalloc@UPrimitiveGroup@@@@@std@@AAEXIABU_Value_init_tag@1@@Z$2 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UPrimitiveGroup@@V?$xalloc@UPrimitiveGroup@@@@@std@@AAEXIABU_Value_init_tag@1@@Z$0
?cacheSize@@3IA DD 010H					; cacheSize
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??1?$xr_vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@@QAE@XZ
_TEXT	SEGMENT
??1?$xr_vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@@QAE@XZ PROC ; xr_vector<NvFaceInfo *,xalloc<NvFaceInfo *> >::~xr_vector<NvFaceInfo *,xalloc<NvFaceInfo *> >, COMDAT
; _this$ = ecx

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	push	esi
	mov	esi, ecx
	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN6@xr_vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+4], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+8], 0
$LN6@xr_vector:
	pop	esi
	ret	0
??1?$xr_vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@@QAE@XZ ENDP ; xr_vector<NvFaceInfo *,xalloc<NvFaceInfo *> >::~xr_vector<NvFaceInfo *,xalloc<NvFaceInfo *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStrip.h
;	COMDAT ??0PrimitiveGroup@@QAE@XZ
_TEXT	SEGMENT
??0PrimitiveGroup@@QAE@XZ PROC				; PrimitiveGroup::PrimitiveGroup, COMDAT
; _this$ = ecx

; 33   : 	PrimitiveGroup() : type(PT_STRIP), numIndices(0), indices(NULL) {}

	mov	DWORD PTR [ecx], 1
	mov	eax, ecx
	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0
	ret	0
??0PrimitiveGroup@@QAE@XZ ENDP				; PrimitiveGroup::PrimitiveGroup
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStrip.cpp
_TEXT	SEGMENT
?SetListsOnly@@YAX_N@Z PROC				; SetListsOnly
; __bListsOnly$dead$ = cl

; 23   : 	bListsOnly = _bListsOnly;

	mov	BYTE PTR ?bListsOnly@@3_NA, 1

; 24   : }

	ret	0
?SetListsOnly@@YAX_N@Z ENDP				; SetListsOnly
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStrip.cpp
_TEXT	SEGMENT
?SetCacheSize@@YAXI@Z PROC				; SetCacheSize
; __cacheSize$ = ecx

; 38   : 	cacheSize = _cacheSize;

	mov	DWORD PTR ?cacheSize@@3IA, ecx

; 39   : }

	ret	0
?SetCacheSize@@YAXI@Z ENDP				; SetCacheSize
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStrip.cpp
_TEXT	SEGMENT
?SetMinStripSize@@YAXI@Z PROC				; SetMinStripSize
; __minStripSize$dead$ = ecx

; 68   : 	minStripSize = _minStripSize;

	mov	DWORD PTR ?minStripSize@@3IA, 0

; 69   : }

	ret	0
?SetMinStripSize@@YAXI@Z ENDP				; SetMinStripSize
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStrip.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStrip.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStrip.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStrip.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStrip.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStrip.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStrip.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStrip.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStrip.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStrip.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStrip.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStrip.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStrip.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStrip.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStrip.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStrip.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStrip.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStrip.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStrip.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStrip.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStrip.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStrip.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStrip.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStrip.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStrip.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStrip.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStrip.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStrip.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStrip.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStrip.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStrip.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStrip.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStrip.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStrip.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStrip.cpp
_TEXT	SEGMENT
tv4425 = -96						; size = 4
tv4424 = -96						; size = 4
_indexCtr$1$ = -96					; size = 4
_numSeparateStrips$ = -96				; size = 4
tv4412 = -92						; size = 4
tv4423 = -88						; size = 4
_j$1$ = -88						; size = 4
$T1 = -84						; size = 4
tv4391 = -80						; size = 4
_tempFaces$ = -76					; size = 12
_tempStrips$ = -64					; size = 12
_stripIndices$ = -52					; size = 12
_tempIndices$ = -40					; size = 12
_stripifier$ = -28					; size = 28
_primGroups$ = 8					; size = 4
?GenerateStrips@@YAXPBGHAAV?$xr_vector@UPrimitiveGroup@@V?$xalloc@UPrimitiveGroup@@@@@@@Z PROC ; GenerateStrips
; _in_indices$ = ecx
; _in_numIndices$ = edx

; 82   : {

	sub	esp, 96					; 00000060H
	push	ebx
	push	ebp
	push	esi
	mov	esi, edx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR _tempIndices$[esp+108], 0
	mov	DWORD PTR _tempIndices$[esp+112], 0
	mov	DWORD PTR _tempIndices$[esp+116], 0
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStrip.cpp

; 82   : {

	push	edi
	mov	edi, ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1259 :         if (_Newsize > _Oldsize) { // append

	test	esi, esi
	je	SHORT $LN58@GenerateSt

; 1260 :             const auto _Oldcapacity = static_cast<size_type>(_My_data._Myend - _Myfirst);
; 1261 :             if (_Newsize > _Oldcapacity) { // reallocate
; 1262 :                 _Resize_reallocate(_Newsize, _Val);

	push	ecx
	push	esi
	lea	ecx, DWORD PTR _tempIndices$[esp+120]
	call	??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@GV?$xalloc@G@@@std@@AAEXIABU_Value_init_tag@1@@Z ; std::vector<unsigned short,xalloc<unsigned short> >::_Resize_reallocate<std::_Value_init_tag>
$LN58@GenerateSt:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStrip.cpp

; 87   : 	for(i = 0; i < in_numIndices; i++)

	xor	edx, edx
	test	esi, esi
	jle	SHORT $LN1041@GenerateSt
	npad	8
$LL4@GenerateSt:

; 88   : 		tempIndices[i] = in_indices[i];

	mov	eax, DWORD PTR _tempIndices$[esp+112]
	mov	cx, WORD PTR [edi+edx*2]
	mov	WORD PTR [eax+edx*2], cx
	inc	edx
	cmp	edx, esi
	jl	SHORT $LL4@GenerateSt
$LN1041@GenerateSt:

; 95   : 	stripifier.Stripify(tempIndices, cacheSize, minStripSize, tempStrips, tempFaces);

	lea	eax, DWORD PTR _tempFaces$[esp+112]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR _tempStrips$[esp+112], 0
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStrip.cpp

; 95   : 	stripifier.Stripify(tempIndices, cacheSize, minStripSize, tempStrips, tempFaces);

	push	eax
	lea	eax, DWORD PTR _tempStrips$[esp+116]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR _tempStrips$[esp+120], 0
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStrip.cpp

; 95   : 	stripifier.Stripify(tempIndices, cacheSize, minStripSize, tempStrips, tempFaces);

	push	eax
	sub	esp, 8
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR _tempStrips$[esp+136], 0
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStrip.cpp

; 95   : 	stripifier.Stripify(tempIndices, cacheSize, minStripSize, tempStrips, tempFaces);

	lea	eax, DWORD PTR _tempIndices$[esp+128]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR _tempFaces$[esp+128], 0
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStrip.cpp

; 95   : 	stripifier.Stripify(tempIndices, cacheSize, minStripSize, tempStrips, tempFaces);

	lea	ecx, DWORD PTR _stripifier$[esp+128]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR _tempFaces$[esp+132], 0
	mov	DWORD PTR _tempFaces$[esp+136], 0
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStrip.cpp

; 95   : 	stripifier.Stripify(tempIndices, cacheSize, minStripSize, tempStrips, tempFaces);

	push	eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR _stripifier$[esp+132], 0
	mov	DWORD PTR _stripifier$[esp+136], 0
	mov	DWORD PTR _stripifier$[esp+140], 0
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStrip.cpp

; 95   : 	stripifier.Stripify(tempIndices, cacheSize, minStripSize, tempStrips, tempFaces);

	call	?Stripify@NvStripifier@@QAEXABV?$xr_vector@GV?$xalloc@G@@@@HHAAV?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@AAV?$xr_vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@@@Z ; NvStripifier::Stripify

; 100  : 
; 101  : 	if(bListsOnly)

	cmp	BYTE PTR ?bListsOnly@@3_NA, 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR _stripIndices$[esp+112], 0
	mov	DWORD PTR _stripIndices$[esp+116], 0
	mov	DWORD PTR _stripIndices$[esp+120], 0
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStrip.cpp

; 99   : 	unsigned int numSeparateStrips = 0;

	mov	DWORD PTR _numSeparateStrips$[esp+112], 0

; 100  : 
; 101  : 	if(bListsOnly)

	je	$LN38@GenerateSt

; 102  : 	{
; 103  : 		//if we're outputting only lists, we're done
; 104  : 		primGroups.resize	(1);

	mov	edi, DWORD PTR _primGroups$[esp+108]
	mov	ecx, edi
	push	1
	call	?resize@?$vector@UPrimitiveGroup@@V?$xalloc@UPrimitiveGroup@@@@@std@@QAEXI@Z ; std::vector<PrimitiveGroup,xalloc<PrimitiveGroup> >::resize
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	ebx, DWORD PTR _tempStrips$[esp+116]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStrip.cpp

; 107  : 		unsigned int numIndices = 0;

	xor	ebp, ebp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	sub	ebx, DWORD PTR _tempStrips$[esp+112]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStrip.cpp

; 108  : 		for(int i = 0; i < tempStrips.size(); i++)

	xor	edx, edx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	sar	ebx, 2
	mov	DWORD PTR tv4424[esp+112], ebx
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStrip.cpp

; 108  : 		for(int i = 0; i < tempStrips.size(); i++)

	test	ebx, ebx
	je	SHORT $LN6@GenerateSt
	mov	edi, DWORD PTR _tempStrips$[esp+112]
	npad	7
$LL7@GenerateSt:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1535 :         auto& _My_data = _Mypair._Myval2;

	mov	eax, DWORD PTR [edi+edx*4]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStrip.cpp

; 108  : 		for(int i = 0; i < tempStrips.size(); i++)

	inc	edx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	ecx, DWORD PTR [eax+16]
	sub	ecx, DWORD PTR [eax+12]
	sar	ecx, 2
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStrip.cpp

; 110  : 			numIndices += tempStrips[i]->m_faces.size() * 3;

	lea	eax, DWORD PTR [ecx+ebp]
	lea	ebp, DWORD PTR [eax+ecx*2]
	cmp	edx, ebx
	jb	SHORT $LL7@GenerateSt
	mov	edi, DWORD PTR _primGroups$[esp+108]
$LN6@GenerateSt:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	esi, DWORD PTR _tempFaces$[esp+116]
	sub	esi, DWORD PTR _tempFaces$[esp+112]
	sar	esi, 2
	mov	DWORD PTR tv4412[esp+112], esi
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStrip.cpp

; 114  : 		numIndices += tempFaces.size() * 3;

	lea	eax, DWORD PTR [esi+ebp]
	lea	ecx, DWORD PTR [eax+esi*2]

; 115  : 
; 116  : 		primGroups[0].type       = PT_LIST;

	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR [eax], 0

; 117  : 		primGroups[0].numIndices = numIndices;

	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR [eax+4], ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	lea	eax, DWORD PTR [ecx+ecx]
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStrip.cpp

; 118  : 		primGroups[0].indices    = xr_alloc<u16> (numIndices);

	mov	ecx, DWORD PTR [edi]

; 119  : 
; 120  : 		//do strips
; 121  : 		unsigned int indexCtr = 0;

	xor	ebp, ebp
	mov	DWORD PTR [ecx+8], eax

; 122  : 		for(u32 i = 0; i < tempStrips.size(); i++)

	test	ebx, ebx
	je	$LN9@GenerateSt
	mov	esi, DWORD PTR _tempStrips$[esp+112]
$LL10@GenerateSt:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1535 :         auto& _My_data = _Mypair._Myval2;

	mov	eax, DWORD PTR [esi]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStrip.cpp

; 124  : 			for(int j = 0; j < tempStrips[i]->m_faces.size(); j++)

	mov	DWORD PTR _j$1$[esp+112], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	ecx, DWORD PTR [eax+12]
	mov	eax, DWORD PTR [eax+16]
	sub	eax, ecx
	sar	eax, 2
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStrip.cpp

; 124  : 			for(int j = 0; j < tempStrips[i]->m_faces.size(); j++)

	test	eax, eax
	je	SHORT $LN8@GenerateSt
	mov	ebx, DWORD PTR _j$1$[esp+112]
	npad	3
$LL218@GenerateSt:

; 125  : 			{
; 126  : 				primGroups[0].indices[indexCtr++] = u16(tempStrips[i]->m_faces[j]->m_v0);

	mov	edx, DWORD PTR [ecx+ebx*4]
	mov	eax, DWORD PTR [edi]
	mov	ecx, DWORD PTR [eax+8]
	movzx	eax, WORD PTR [edx]
	mov	WORD PTR [ecx+ebp*2], ax

; 127  : 				primGroups[0].indices[indexCtr++] = u16(tempStrips[i]->m_faces[j]->m_v1);

	mov	eax, DWORD PTR [esi]
	mov	eax, DWORD PTR [eax+12]
	mov	edx, DWORD PTR [eax+ebx*4]
	mov	eax, DWORD PTR [edi]
	mov	ecx, DWORD PTR [eax+8]
	movzx	eax, WORD PTR [edx+4]
	mov	WORD PTR [ecx+ebp*2+2], ax

; 128  : 				primGroups[0].indices[indexCtr++] = u16(tempStrips[i]->m_faces[j]->m_v2);

	mov	eax, DWORD PTR [esi]
	mov	eax, DWORD PTR [eax+12]
	mov	edx, DWORD PTR [eax+ebx*4]
	inc	ebx
	mov	eax, DWORD PTR [edi]
	mov	ecx, DWORD PTR [eax+8]
	movzx	eax, WORD PTR [edx+8]
	mov	WORD PTR [ecx+ebp*2+4], ax
	add	ebp, 3
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1535 :         auto& _My_data = _Mypair._Myval2;

	mov	eax, DWORD PTR [esi]

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	ecx, DWORD PTR [eax+12]
	mov	eax, DWORD PTR [eax+16]
	sub	eax, ecx
	sar	eax, 2
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStrip.cpp

; 124  : 			for(int j = 0; j < tempStrips[i]->m_faces.size(); j++)

	cmp	ebx, eax
	jb	SHORT $LL218@GenerateSt
	mov	ebx, DWORD PTR tv4424[esp+112]
$LN8@GenerateSt:

; 122  : 		for(u32 i = 0; i < tempStrips.size(); i++)

	add	esi, 4
	sub	ebx, 1
	mov	DWORD PTR tv4424[esp+112], ebx
	jne	SHORT $LL10@GenerateSt
	mov	esi, DWORD PTR tv4412[esp+112]
$LN9@GenerateSt:

; 129  : 			}
; 130  : 		}
; 131  : 
; 132  : 		//do lists
; 133  : 		for(u32 i = 0; i < tempFaces.size(); i++)

	xor	ebx, ebx
	test	esi, esi
	je	$LN1028@GenerateSt
	npad	2
$LL16@GenerateSt:

; 134  : 		{
; 135  : 			primGroups[0].indices[indexCtr++] = u16(tempFaces[i]->m_v0);

	mov	eax, DWORD PTR _tempFaces$[esp+112]

; 136  : 			primGroups[0].indices[indexCtr++] = u16(tempFaces[i]->m_v1);
; 137  : 			primGroups[0].indices[indexCtr++] = u16(tempFaces[i]->m_v2);

	lea	ebp, DWORD PTR [ebp+3]
	mov	edx, DWORD PTR [eax+ebx*4]
	mov	eax, DWORD PTR [edi]
	mov	ecx, DWORD PTR [eax+8]
	movzx	eax, WORD PTR [edx]
	mov	WORD PTR [ecx+ebp*2-6], ax
	mov	eax, DWORD PTR _tempFaces$[esp+112]
	mov	edx, DWORD PTR [eax+ebx*4]
	mov	eax, DWORD PTR [edi]
	mov	ecx, DWORD PTR [eax+8]
	movzx	eax, WORD PTR [edx+4]
	mov	WORD PTR [ecx+ebp*2-4], ax
	mov	eax, DWORD PTR _tempFaces$[esp+112]
	mov	edx, DWORD PTR [eax+ebx*4]
	inc	ebx
	mov	eax, DWORD PTR [edi]
	mov	ecx, DWORD PTR [eax+8]
	movzx	eax, WORD PTR [edx+8]
	mov	WORD PTR [ecx+ebp*2-2], ax
	cmp	ebx, esi
	jb	SHORT $LL16@GenerateSt

; 138  : 		}
; 139  : 	}

	jmp	$LN1028@GenerateSt
$LN38@GenerateSt:

; 140  : 	else
; 141  : 	{
; 142  : 		stripifier.CreateStrips(tempStrips, stripIndices, bStitchStrips, numSeparateStrips);

	lea	eax, DWORD PTR _numSeparateStrips$[esp+112]
	push	eax
	push	ecx
	lea	eax, DWORD PTR _stripIndices$[esp+120]
	push	eax
	lea	eax, DWORD PTR _tempStrips$[esp+124]
	push	eax
	call	?CreateStrips@NvStripifier@@QAEXABV?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@AAV?$xr_vector@HV?$xalloc@H@@@@_NAAI@Z ; NvStripifier::CreateStrips
	mov	eax, DWORD PTR _numSeparateStrips$[esp+112]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	esi, DWORD PTR _tempFaces$[esp+116]
	sub	esi, DWORD PTR _tempFaces$[esp+112]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStrip.cpp

; 151  : 		primGroups.resize	(numGroups);

	mov	ebx, DWORD PTR _primGroups$[esp+108]
	mov	ecx, ebx
	movzx	eax, ax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	sar	esi, 2
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStrip.cpp

; 151  : 		primGroups.resize	(numGroups);

	test	esi, esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	DWORD PTR tv4412[esp+112], esi
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStrip.cpp

; 151  : 		primGroups.resize	(numGroups);

	lea	ebp, DWORD PTR [eax+1]
	cmove	ebp, eax
	push	ebp
	mov	DWORD PTR tv4391[esp+116], ebp
	call	?resize@?$vector@UPrimitiveGroup@@V?$xalloc@UPrimitiveGroup@@@@@std@@QAEXI@Z ; std::vector<PrimitiveGroup,xalloc<PrimitiveGroup> >::resize

; 152  : 		
; 153  : 		//first, the strips
; 154  : 		int startingLoc = 0;
; 155  : 		int stripCtr;
; 156  : 		for	(stripCtr = 0; stripCtr < numSeparateStrips; stripCtr++)

	mov	edx, DWORD PTR _numSeparateStrips$[esp+112]
	xor	edi, edi
	test	edx, edx
	je	$LN18@GenerateSt

; 140  : 	else
; 141  : 	{
; 142  : 		stripifier.CreateStrips(tempStrips, stripIndices, bStitchStrips, numSeparateStrips);

	mov	eax, DWORD PTR _stripIndices$[esp+116]
	mov	ecx, DWORD PTR _stripIndices$[esp+112]
	sub	eax, ecx
	sar	eax, 2
	xor	ebp, ebp
	mov	DWORD PTR $T1[esp+112], eax
	mov	DWORD PTR tv4423[esp+112], edx

; 152  : 		
; 153  : 		//first, the strips
; 154  : 		int startingLoc = 0;
; 155  : 		int stripCtr;
; 156  : 		for	(stripCtr = 0; stripCtr < numSeparateStrips; stripCtr++)

	jmp	SHORT $LN19@GenerateSt
$LL1043@GenerateSt:
	mov	ecx, DWORD PTR _stripIndices$[esp+112]
$LN19@GenerateSt:

; 157  : 		{
; 158  : 			int stripLength = 0;
; 159  : 			if(numSeparateStrips != 1)

	cmp	edx, 1
	je	SHORT $LN41@GenerateSt

; 160  : 			{
; 161  : 				//if we've got multiple strips, we need to figure out the correct length
; 162  : 				int i;
; 163  : 				for(i = startingLoc; i < stripIndices.size(); i++)

	mov	esi, edi
	cmp	edi, eax
	jae	SHORT $LN1042@GenerateSt
$LL22@GenerateSt:

; 164  : 				{
; 165  : 					if(stripIndices[i] == -1)

	cmp	DWORD PTR [ecx+esi*4], -1
	je	SHORT $LN1042@GenerateSt

; 160  : 			{
; 161  : 				//if we've got multiple strips, we need to figure out the correct length
; 162  : 				int i;
; 163  : 				for(i = startingLoc; i < stripIndices.size(); i++)

	inc	esi
	cmp	esi, eax
	jb	SHORT $LL22@GenerateSt
$LN1042@GenerateSt:

; 166  : 						break;
; 167  : 				}
; 168  : 				
; 169  : 				stripLength = i - startingLoc;

	sub	esi, edi

; 170  : 			}

	jmp	SHORT $LN527@GenerateSt
$LN41@GenerateSt:

; 171  : 			else
; 172  : 				stripLength = stripIndices.size();

	mov	esi, eax
$LN527@GenerateSt:

; 173  : 			
; 174  : 			primGroups[stripCtr].type       = PT_STRIP;

	mov	eax, DWORD PTR [ebx]
	mov	DWORD PTR [eax+ebp], 1
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	lea	eax, DWORD PTR [esi+esi]
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStrip.cpp

; 175  : 			primGroups[stripCtr].indices    = xr_alloc<u16>	(stripLength);

	mov	ecx, DWORD PTR [ebx]
	mov	DWORD PTR [ecx+ebp+8], eax

; 176  : 			primGroups[stripCtr].numIndices = stripLength;

	mov	eax, DWORD PTR [ebx]
	mov	DWORD PTR [eax+ebp+4], esi

; 177  : 			
; 178  : 			int indexCtr = 0;
; 179  : 			for(int i = startingLoc; i < stripLength + startingLoc; i++)

	add	esi, edi
	cmp	edi, esi
	jge	SHORT $LN24@GenerateSt
	xor	edx, edx
$LL25@GenerateSt:

; 180  : 				primGroups[stripCtr].indices[indexCtr++] = u16(stripIndices[i]);

	mov	eax, DWORD PTR [ebx]
	lea	edx, DWORD PTR [edx+2]
	mov	ecx, DWORD PTR [eax+ebp+8]
	mov	eax, DWORD PTR _stripIndices$[esp+112]
	mov	ax, WORD PTR [eax+edi*4]
	inc	edi
	mov	WORD PTR [edx+ecx-2], ax
	cmp	edi, esi
	jl	SHORT $LL25@GenerateSt
$LN24@GenerateSt:

; 152  : 		
; 153  : 		//first, the strips
; 154  : 		int startingLoc = 0;
; 155  : 		int stripCtr;
; 156  : 		for	(stripCtr = 0; stripCtr < numSeparateStrips; stripCtr++)

	mov	eax, DWORD PTR $T1[esp+112]

; 181  : 			
; 182  : 			startingLoc += stripLength + 1; //we add 1 to account for the -1 separating strips

	lea	edi, DWORD PTR [esi+1]
	mov	edx, DWORD PTR _numSeparateStrips$[esp+112]
	add	ebp, 12					; 0000000cH
	sub	DWORD PTR tv4423[esp+112], 1
	jne	SHORT $LL1043@GenerateSt
	mov	esi, DWORD PTR tv4412[esp+112]
	mov	ebp, DWORD PTR tv4391[esp+112]
$LN18@GenerateSt:

; 183  : 		}
; 184  : 		
; 185  : 		//next, the list
; 186  : 		if(tempFaces.size() != 0)

	test	esi, esi
	je	$LN1028@GenerateSt

; 189  : 			primGroups[faceGroupLoc].type       = PT_LIST;

	mov	eax, DWORD PTR [ebx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 119  :         _Ptr += _Off;

	lea	edi, DWORD PTR [ebp*2]
	add	edi, ebp
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStrip.cpp

; 189  : 			primGroups[faceGroupLoc].type       = PT_LIST;

	mov	DWORD PTR [eax+edi*4-12], 0
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	lea	eax, DWORD PTR [esi+esi*2]
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	add	eax, eax
	push	eax
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStrip.cpp

; 190  : 			primGroups[faceGroupLoc].indices    = xr_alloc<u16>	(tempFaces.size() * 3);

	mov	ecx, DWORD PTR [ebx]

; 191  : 			primGroups[faceGroupLoc].numIndices = tempFaces.size() * 3;
; 192  : 			int indexCtr = 0;
; 193  : 			for(int i = 0; i < tempFaces.size(); i++)

	xor	ebp, ebp
	mov	DWORD PTR _indexCtr$1$[esp+112], 0
	mov	DWORD PTR [ecx+edi*4-4], eax
	lea	ecx, DWORD PTR [esi+esi*2]
	mov	eax, DWORD PTR [ebx]
	mov	DWORD PTR [eax+edi*4-8], ecx
	test	esi, esi
	je	SHORT $LN1028@GenerateSt
$LL28@GenerateSt:

; 194  : 			{
; 195  : 				primGroups[faceGroupLoc].indices[indexCtr++] = u16(tempFaces[i]->m_v0);

	mov	eax, DWORD PTR _tempFaces$[esp+112]
	mov	edx, DWORD PTR [eax+ebp*4]
	mov	eax, DWORD PTR [ebx]
	mov	ecx, DWORD PTR [eax+edi*4-4]
	movzx	eax, WORD PTR [edx]
	mov	edx, DWORD PTR _indexCtr$1$[esp+112]
	mov	WORD PTR [ecx+edx*2], ax

; 196  : 				primGroups[faceGroupLoc].indices[indexCtr++] = u16(tempFaces[i]->m_v1);

	mov	eax, DWORD PTR _tempFaces$[esp+112]
	mov	edx, DWORD PTR [eax+ebp*4]
	mov	eax, DWORD PTR [ebx]
	mov	ecx, DWORD PTR [eax+edi*4-4]
	movzx	eax, WORD PTR [edx+4]
	mov	edx, DWORD PTR _indexCtr$1$[esp+112]
	mov	WORD PTR [ecx+edx*2+2], ax

; 197  : 				primGroups[faceGroupLoc].indices[indexCtr++] = u16(tempFaces[i]->m_v2);

	mov	eax, DWORD PTR _tempFaces$[esp+112]
	mov	edx, DWORD PTR [eax+ebp*4]
	inc	ebp
	mov	eax, DWORD PTR [ebx]
	mov	ecx, DWORD PTR [eax+edi*4-4]
	movzx	eax, WORD PTR [edx+8]
	mov	edx, DWORD PTR _indexCtr$1$[esp+112]
	mov	WORD PTR [ecx+edx*2+4], ax
	add	edx, 3
	mov	DWORD PTR _indexCtr$1$[esp+112], edx
	cmp	ebp, esi
	jb	SHORT $LL28@GenerateSt
$LN1028@GenerateSt:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	ecx, DWORD PTR _tempStrips$[esp+116]
	mov	ebx, DWORD PTR _tempStrips$[esp+112]
	sub	ecx, ebx
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStrip.cpp

; 205  : 	for(u32 i = 0; i < tempStrips.size(); i++)

	mov	ebp, DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	sar	ecx, 2
	mov	DWORD PTR tv4425[esp+112], ecx
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStrip.cpp

; 205  : 	for(u32 i = 0; i < tempStrips.size(); i++)

	test	ecx, ecx
	je	$LN30@GenerateSt
	npad	5
$LL31@GenerateSt:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1535 :         auto& _My_data = _Mypair._Myval2;

	mov	esi, DWORD PTR [ebx]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStrip.cpp

; 207  : 		for(int j = 0; j < tempStrips[i]->m_faces.size(); j++)

	xor	edi, edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	eax, DWORD PTR [esi+16]
	sub	eax, DWORD PTR [esi+12]
	sar	eax, 2
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStrip.cpp

; 207  : 		for(int j = 0; j < tempStrips[i]->m_faces.size(); j++)

	test	eax, eax
	je	SHORT $LN849@GenerateSt
$LL789@GenerateSt:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 119  :         _Ptr += _Off;

	mov	eax, DWORD PTR [esi+12]
	lea	esi, DWORD PTR [eax+edi*4]
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h

; 151  : 	if (ptr) 

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN32@GenerateSt

; 144  : 		Memory.mem_free	(ptr);

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	ebp

; 154  : 		ptr = nullptr;

	mov	DWORD PTR [esi], 0
$LN32@GenerateSt:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1535 :         auto& _My_data = _Mypair._Myval2;

	mov	esi, DWORD PTR [ebx]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStrip.cpp

; 207  : 		for(int j = 0; j < tempStrips[i]->m_faces.size(); j++)

	inc	edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	eax, DWORD PTR [esi+16]
	sub	eax, DWORD PTR [esi+12]
	sar	eax, 2
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStrip.cpp

; 207  : 		for(int j = 0; j < tempStrips[i]->m_faces.size(); j++)

	cmp	edi, eax
	jb	SHORT $LL789@GenerateSt
	mov	ecx, DWORD PTR tv4425[esp+112]
$LN849@GenerateSt:
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h

; 151  : 	if (ptr) 

	test	esi, esi
	je	SHORT $LN29@GenerateSt
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [esi+12]
	test	eax, eax
	je	SHORT $LN878@GenerateSt
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	ebp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi+12], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+16], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+20], 0
	mov	esi, DWORD PTR [ebx]
$LN878@GenerateSt:
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h

; 144  : 		Memory.mem_free	(ptr);

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	esi
	call	ebp
	mov	ecx, DWORD PTR tv4425[esp+112]

; 154  : 		ptr = nullptr;

	mov	DWORD PTR [ebx], 0
$LN29@GenerateSt:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStrip.cpp

; 205  : 	for(u32 i = 0; i < tempStrips.size(); i++)

	add	ebx, 4
	sub	ecx, 1
	mov	DWORD PTR tv4425[esp+112], ecx
	jne	$LL31@GenerateSt
	mov	ebx, DWORD PTR _tempStrips$[esp+112]
$LN30@GenerateSt:

; 215  : 	for(u32 i = 0; i < tempFaces.size(); i++)

	mov	edi, DWORD PTR tv4412[esp+112]
	xor	esi, esi
	test	edi, edi
	je	SHORT $LN36@GenerateSt
	mov	ebx, DWORD PTR _tempFaces$[esp+112]
$LL37@GenerateSt:
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h

; 151  : 	if (ptr) 

	mov	eax, DWORD PTR [ebx+esi*4]
	test	eax, eax
	je	SHORT $LN35@GenerateSt

; 144  : 		Memory.mem_free	(ptr);

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	ebp

; 154  : 		ptr = nullptr;

	mov	DWORD PTR [ebx+esi*4], 0
$LN35@GenerateSt:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStrip.cpp

; 215  : 	for(u32 i = 0; i < tempFaces.size(); i++)

	inc	esi
	cmp	esi, edi
	jb	SHORT $LL37@GenerateSt
	mov	ebx, DWORD PTR _tempStrips$[esp+112]
$LN36@GenerateSt:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR _stripIndices$[esp+112]
	test	eax, eax
	je	SHORT $LN921@GenerateSt
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	ebp
$LN921@GenerateSt:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR _stripifier$[esp+112]
	test	eax, eax
	je	SHORT $LN935@GenerateSt
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	ebp
$LN935@GenerateSt:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR _tempFaces$[esp+112]
	test	eax, eax
	je	SHORT $LN947@GenerateSt
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	ebp
$LN947@GenerateSt:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	test	ebx, ebx
	je	SHORT $LN959@GenerateSt
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	ebx
	call	ebp
$LN959@GenerateSt:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR _tempIndices$[esp+112]
	test	eax, eax
	je	SHORT $LN971@GenerateSt
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	ebp
$LN971@GenerateSt:
	pop	edi
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStrip.cpp

; 219  : }

	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 96					; 00000060H
	ret	0
?GenerateStrips@@YAXPBGHAAV?$xr_vector@UPrimitiveGroup@@V?$xalloc@UPrimitiveGroup@@@@@@@Z ENDP ; GenerateStrips
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??1?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@QAE@XZ
_TEXT	SEGMENT
??1?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@QAE@XZ PROC ; xr_vector<NvStripInfo *,xalloc<NvStripInfo *> >::~xr_vector<NvStripInfo *,xalloc<NvStripInfo *> >, COMDAT
; _this$ = ecx

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	push	esi
	mov	esi, ecx
	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN6@xr_vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+4], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+8], 0
$LN6@xr_vector:
	pop	esi
	ret	0
??1?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@QAE@XZ ENDP ; xr_vector<NvStripInfo *,xalloc<NvStripInfo *> >::~xr_vector<NvStripInfo *,xalloc<NvStripInfo *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??1?$xr_vector@HV?$xalloc@H@@@@QAE@XZ
_TEXT	SEGMENT
??1?$xr_vector@HV?$xalloc@H@@@@QAE@XZ PROC		; xr_vector<int,xalloc<int> >::~xr_vector<int,xalloc<int> >, COMDAT
; _this$ = ecx

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	push	esi
	mov	esi, ecx
	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN6@xr_vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+4], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+8], 0
$LN6@xr_vector:
	pop	esi
	ret	0
??1?$xr_vector@HV?$xalloc@H@@@@QAE@XZ ENDP		; xr_vector<int,xalloc<int> >::~xr_vector<int,xalloc<int> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStrip.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStrip.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStrip.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStrip.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStrip.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStrip.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStrip.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStrip.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStrip.cpp
_TEXT	SEGMENT
_numGroups$1$ = -8					; size = 4
_in_primGroups$1$ = -4					; size = 4
_remappedGroups$ = 8					; size = 4
?RemapIndices@@YAXABV?$xr_vector@UPrimitiveGroup@@V?$xalloc@UPrimitiveGroup@@@@@@GAAV1@@Z PROC ; RemapIndices
; _in_primGroups$ = ecx
; _numVerts$ = dx

; 237  : {

	sub	esp, 8
	push	ebx
	push	ebp
	mov	ebp, ecx

; 239  : 	remappedGroups.resize	(numGroups);

	mov	ecx, DWORD PTR _remappedGroups$[esp+12]
	push	esi
	push	edi
	mov	si, dx
	mov	DWORD PTR _in_primGroups$1$[esp+24], ebp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	eax, DWORD PTR [ebp+4]
	sub	eax, DWORD PTR [ebp]
	sar	eax, 2
	imul	eax, eax, -1431655765
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStrip.cpp

; 239  : 	remappedGroups.resize	(numGroups);

	push	eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	DWORD PTR _numGroups$1$[esp+28], eax
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStrip.cpp

; 239  : 	remappedGroups.resize	(numGroups);

	call	?resize@?$vector@UPrimitiveGroup@@V?$xalloc@UPrimitiveGroup@@@@@std@@QAEXI@Z ; std::vector<PrimitiveGroup,xalloc<PrimitiveGroup> >::resize
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStrip.cpp

; 243  : 	indexCache	= xr_alloc<int> (numVerts);

	movzx	esi, si
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	shl	esi, 2
	push	esi
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStrip.cpp

; 244  : 	FillMemory	(indexCache, sizeof(int)*numVerts, -1);

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	mov	ebx, eax
	push	esi
	push	-1
	push	ebx
	mov	ecx, DWORD PTR [ecx+12]
	call	ecx

; 245  : 	
; 246  : 	//loop over primitive groups
; 247  : 	unsigned int indexCtr = 0;

	xor	edi, edi

; 248  : 	for(int i = 0; i < numGroups; i++)

	cmp	DWORD PTR _numGroups$1$[esp+24], edi
	jle	$LN3@RemapIndic
	mov	edx, DWORD PTR _remappedGroups$[esp+20]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	xor	esi, esi
$LL4@RemapIndic:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStrip.cpp

; 250  : 		unsigned int numIndices = in_primGroups[i].numIndices;

	mov	eax, DWORD PTR [ebp]

; 251  : 
; 252  : 		//init remapped group
; 253  : 		remappedGroups[i].type       = in_primGroups[i].type;

	mov	ecx, DWORD PTR [edx]
	mov	ebp, DWORD PTR [esi+eax+4]
	mov	eax, DWORD PTR [esi+eax]
	mov	DWORD PTR [esi+ecx], eax

; 254  : 		remappedGroups[i].numIndices = numIndices;

	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [esi+eax+4], ebp
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	lea	eax, DWORD PTR [ebp*2]
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStrip.cpp

; 255  : 		remappedGroups[i].indices    = xr_alloc<u16>	(numIndices);

	mov	edx, DWORD PTR _remappedGroups$[esp+20]
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [esi+ecx+8], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 119  :         _Ptr += _Off;

	xor	eax, eax
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStrip.cpp

; 257  : 		for(int j = 0; j < numIndices; j++)

	test	ebp, ebp
	je	SHORT $LN2@RemapIndic
	npad	4
$LL7@RemapIndic:

; 258  : 		{
; 259  : 			int cachedIndex = indexCache[in_primGroups[i].indices[j]];

	mov	ecx, DWORD PTR _in_primGroups$1$[esp+24]
	mov	ecx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [esi+ecx+8]
	movzx	ecx, WORD PTR [ecx+eax*2]
	mov	edx, DWORD PTR [ebx+ecx*4]

; 260  : 			if(cachedIndex == -1) //we haven't seen this index before

	mov	ecx, DWORD PTR _remappedGroups$[esp+20]
	mov	ecx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [ecx+esi+8]
	cmp	edx, -1
	jne	SHORT $LN142@RemapIndic

; 261  : 			{
; 262  : 				//point to "last" vertex in VB
; 263  : 				remappedGroups[i].indices[j] = u16(indexCtr);

	mov	WORD PTR [ecx+eax*2], di

; 264  : 
; 265  : 				//add to index cache, increment
; 266  : 				indexCache[in_primGroups[i].indices[j]] = indexCtr++;

	mov	ecx, DWORD PTR _in_primGroups$1$[esp+24]
	mov	ecx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [esi+ecx+8]
	movzx	ecx, WORD PTR [ecx+eax*2]
	mov	DWORD PTR [ebx+ecx*4], edi
	inc	edi

; 267  : 			}

	jmp	SHORT $LN5@RemapIndic
$LN142@RemapIndic:

; 268  : 			else
; 269  : 			{
; 270  : 				//we've seen this index before
; 271  : 				remappedGroups[i].indices[j] = u16(cachedIndex);

	mov	WORD PTR [ecx+eax*2], dx
$LN5@RemapIndic:

; 257  : 		for(int j = 0; j < numIndices; j++)

	inc	eax
	cmp	eax, ebp
	jb	SHORT $LL7@RemapIndic
	mov	edx, DWORD PTR _remappedGroups$[esp+20]
$LN2@RemapIndic:

; 248  : 	for(int i = 0; i < numGroups; i++)

	mov	ebp, DWORD PTR _in_primGroups$1$[esp+24]
	add	esi, 12					; 0000000cH
	sub	DWORD PTR _numGroups$1$[esp+24], 1
	jne	$LL4@RemapIndic
$LN3@RemapIndic:
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	test	ebx, ebx
	je	SHORT $LN157@RemapIndic
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	ebx
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN157@RemapIndic:
	pop	edi
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStrip.cpp

; 277  : }

	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 8
	ret	0
?RemapIndices@@YAXABV?$xr_vector@UPrimitiveGroup@@V?$xalloc@UPrimitiveGroup@@@@@@GAAV1@@Z ENDP ; RemapIndices
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ??A?$xr_vector@UPrimitiveGroup@@V?$xalloc@UPrimitiveGroup@@@@@@QAEAAUPrimitiveGroup@@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$xr_vector@UPrimitiveGroup@@V?$xalloc@UPrimitiveGroup@@@@@@QAEAAUPrimitiveGroup@@I@Z PROC ; xr_vector<PrimitiveGroup,xalloc<PrimitiveGroup> >::operator[], COMDAT
; _this$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 119  :         _Ptr += _Off;

	mov	eax, DWORD PTR __Pos$[esp-4]
	lea	edx, DWORD PTR [eax+eax*2]
	mov	eax, DWORD PTR [ecx]
	lea	eax, DWORD PTR [eax+edx*4]
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 138  : 	reference operator[]		(size_type _Pos)					{ {VERIFY(_Pos<size());} return (*(begin() + _Pos)); }

	ret	4
??A?$xr_vector@UPrimitiveGroup@@V?$xalloc@UPrimitiveGroup@@@@@@QAEAAUPrimitiveGroup@@I@Z ENDP ; xr_vector<PrimitiveGroup,xalloc<PrimitiveGroup> >::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ??A?$xr_vector@UPrimitiveGroup@@V?$xalloc@UPrimitiveGroup@@@@@@QBEABUPrimitiveGroup@@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$xr_vector@UPrimitiveGroup@@V?$xalloc@UPrimitiveGroup@@@@@@QBEABUPrimitiveGroup@@I@Z PROC ; xr_vector<PrimitiveGroup,xalloc<PrimitiveGroup> >::operator[], COMDAT
; _this$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 119  :         _Ptr += _Off;

	mov	eax, DWORD PTR __Pos$[esp-4]
	lea	edx, DWORD PTR [eax+eax*2]
	mov	eax, DWORD PTR [ecx]
	lea	eax, DWORD PTR [eax+edx*4]
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 137  : 	const_reference operator[]	(size_type _Pos) const				{ {VERIFY(_Pos<size());} return (*(begin() + _Pos)); }

	ret	4
??A?$xr_vector@UPrimitiveGroup@@V?$xalloc@UPrimitiveGroup@@@@@@QBEABUPrimitiveGroup@@I@Z ENDP ; xr_vector<PrimitiveGroup,xalloc<PrimitiveGroup> >::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?size@?$xr_vector@UPrimitiveGroup@@V?$xalloc@UPrimitiveGroup@@@@@@QBEIXZ
_TEXT	SEGMENT
?size@?$xr_vector@UPrimitiveGroup@@V?$xalloc@UPrimitiveGroup@@@@@@QBEIXZ PROC ; xr_vector<PrimitiveGroup,xalloc<PrimitiveGroup> >::size, COMDAT
; _this$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	eax, DWORD PTR [ecx+4]
	sub	eax, DWORD PTR [ecx]
	sar	eax, 2
	imul	eax, eax, -1431655765
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 125  : 	u32		size				() const							{ return (u32)inherited::size();} 

	ret	0
?size@?$xr_vector@UPrimitiveGroup@@V?$xalloc@UPrimitiveGroup@@@@@@QBEIXZ ENDP ; xr_vector<PrimitiveGroup,xalloc<PrimitiveGroup> >::size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?resize@?$vector@UPrimitiveGroup@@V?$xalloc@UPrimitiveGroup@@@@@std@@QAEXI@Z
_TEXT	SEGMENT
$T1 = 8							; size = 1
__Newsize$ = 8						; size = 4
?resize@?$vector@UPrimitiveGroup@@V?$xalloc@UPrimitiveGroup@@@@@std@@QAEXI@Z PROC ; std::vector<PrimitiveGroup,xalloc<PrimitiveGroup> >::resize, COMDAT
; _this$ = ecx

; 1275 :     _CONSTEXPR20_CONTAINER void resize(_CRT_GUARDOVERFLOW const size_type _Newsize) {

	mov	edx, ecx

; 1251 :         if (_Newsize < _Oldsize) { // trim

	mov	ecx, DWORD PTR __Newsize$[esp-4]

; 1275 :     _CONSTEXPR20_CONTAINER void resize(_CRT_GUARDOVERFLOW const size_type _Newsize) {

	push	esi
	push	edi

; 1250 :         const auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);

	mov	eax, DWORD PTR [edx+4]
	mov	edi, DWORD PTR [edx]
	sub	eax, edi
	sar	eax, 2
	imul	esi, eax, -1431655765

; 1251 :         if (_Newsize < _Oldsize) { // trim

	cmp	ecx, esi
	jae	SHORT $LN4@resize

; 1252 :             const pointer _Newlast = _Myfirst + _Newsize;

	lea	eax, DWORD PTR [ecx+ecx*2]
	lea	eax, DWORD PTR [edi+eax*4]
	pop	edi

; 1276 :         // trim or append value-initialized elements, provide strong guarantee
; 1277 :         _Resize(_Newsize, _Value_init_tag{});
; 1278 :     }

	mov	DWORD PTR [edx+4], eax
	pop	esi
	ret	4
$LN4@resize:

; 1259 :         if (_Newsize > _Oldsize) { // append

	jbe	SHORT $LN5@resize

; 1260 :             const auto _Oldcapacity = static_cast<size_type>(_My_data._Myend - _Myfirst);

	mov	eax, DWORD PTR [edx+8]
	sub	eax, edi
	sar	eax, 2
	imul	eax, eax, -1431655765

; 1261 :             if (_Newsize > _Oldcapacity) { // reallocate

	cmp	ecx, eax
	jbe	SHORT $LN6@resize

; 1262 :                 _Resize_reallocate(_Newsize, _Val);

	lea	eax, DWORD PTR $T1[esp+4]
	push	eax
	push	ecx
	mov	ecx, edx
	call	??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UPrimitiveGroup@@V?$xalloc@UPrimitiveGroup@@@@@std@@AAEXIABU_Value_init_tag@1@@Z ; std::vector<PrimitiveGroup,xalloc<PrimitiveGroup> >::_Resize_reallocate<std::_Value_init_tag>
	pop	edi

; 1276 :         // trim or append value-initialized elements, provide strong guarantee
; 1277 :         _Resize(_Newsize, _Value_init_tag{});
; 1278 :     }

	pop	esi
	ret	4
$LN6@resize:

; 1267 :             _Mylast                = _Ufill(_Oldlast, _Newsize - _Oldsize, _Val);

	push	DWORD PTR $T1[esp+4]
	sub	ecx, esi
	push	ecx
	push	DWORD PTR [edx+4]
	call	?_Ufill@?$vector@UPrimitiveGroup@@V?$xalloc@UPrimitiveGroup@@@@@std@@AAEPAUPrimitiveGroup@@PAU3@IU_Value_init_tag@2@@Z ; std::vector<PrimitiveGroup,xalloc<PrimitiveGroup> >::_Ufill

; 1276 :         // trim or append value-initialized elements, provide strong guarantee
; 1277 :         _Resize(_Newsize, _Value_init_tag{});
; 1278 :     }

	mov	DWORD PTR [edx+4], eax
$LN5@resize:
	pop	edi
	pop	esi
	ret	4
?resize@?$vector@UPrimitiveGroup@@V?$xalloc@UPrimitiveGroup@@@@@std@@QAEXI@Z ENDP ; std::vector<PrimitiveGroup,xalloc<PrimitiveGroup> >::resize
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ??A?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@QAEAAPAVNvStripInfo@@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@QAEAAPAVNvStripInfo@@I@Z PROC ; xr_vector<NvStripInfo *,xalloc<NvStripInfo *> >::operator[], COMDAT
; _this$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 119  :         _Ptr += _Off;

	mov	ecx, DWORD PTR [ecx]
	mov	eax, DWORD PTR __Pos$[esp-4]
	lea	eax, DWORD PTR [ecx+eax*4]
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 138  : 	reference operator[]		(size_type _Pos)					{ {VERIFY(_Pos<size());} return (*(begin() + _Pos)); }

	ret	4
??A?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@QAEAAPAVNvStripInfo@@I@Z ENDP ; xr_vector<NvStripInfo *,xalloc<NvStripInfo *> >::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?size@?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@QBEIXZ
_TEXT	SEGMENT
?size@?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@QBEIXZ PROC ; xr_vector<NvStripInfo *,xalloc<NvStripInfo *> >::size, COMDAT
; _this$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	eax, DWORD PTR [ecx+4]
	sub	eax, DWORD PTR [ecx]
	sar	eax, 2
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 125  : 	u32		size				() const							{ return (u32)inherited::size();} 

	ret	0
?size@?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@QBEIXZ ENDP ; xr_vector<NvStripInfo *,xalloc<NvStripInfo *> >::size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ??0?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@QAE@XZ
_TEXT	SEGMENT
??0?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@QAE@XZ PROC ; xr_vector<NvStripInfo *,xalloc<NvStripInfo *> >::xr_vector<NvStripInfo *,xalloc<NvStripInfo *> >, COMDAT
; _this$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx], 0
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 122  : 			xr_vector			()									: inherited	()					{}

	mov	eax, ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 122  : 			xr_vector			()									: inherited	()					{}

	ret	0
??0?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@QAE@XZ ENDP ; xr_vector<NvStripInfo *,xalloc<NvStripInfo *> >::xr_vector<NvStripInfo *,xalloc<NvStripInfo *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??1?$vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@std@@QAE@XZ PROC ; std::vector<NvStripInfo *,xalloc<NvStripInfo *> >::~vector<NvStripInfo *,xalloc<NvStripInfo *> >, COMDAT
; _this$ = ecx

; 698  :     _CONSTEXPR20_CONTAINER ~vector() noexcept {

	push	esi
	mov	esi, ecx

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN4@vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+4], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+8], 0
$LN4@vector:
	pop	esi

; 699  :         _Tidy();
; 700  : #if _ITERATOR_DEBUG_LEVEL != 0
; 701  :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 702  :         _Delete_plain_internal(_Alproxy, _STD exchange(_Mypair._Myval2._Myproxy, nullptr));
; 703  : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 704  :     }

	ret	0
??1?$vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@std@@QAE@XZ ENDP ; std::vector<NvStripInfo *,xalloc<NvStripInfo *> >::~vector<NvStripInfo *,xalloc<NvStripInfo *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ??A?$xr_vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@@QAEAAPAVNvFaceInfo@@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$xr_vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@@QAEAAPAVNvFaceInfo@@I@Z PROC ; xr_vector<NvFaceInfo *,xalloc<NvFaceInfo *> >::operator[], COMDAT
; _this$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 119  :         _Ptr += _Off;

	mov	ecx, DWORD PTR [ecx]
	mov	eax, DWORD PTR __Pos$[esp-4]
	lea	eax, DWORD PTR [ecx+eax*4]
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 138  : 	reference operator[]		(size_type _Pos)					{ {VERIFY(_Pos<size());} return (*(begin() + _Pos)); }

	ret	4
??A?$xr_vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@@QAEAAPAVNvFaceInfo@@I@Z ENDP ; xr_vector<NvFaceInfo *,xalloc<NvFaceInfo *> >::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?size@?$xr_vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@@QBEIXZ
_TEXT	SEGMENT
?size@?$xr_vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@@QBEIXZ PROC ; xr_vector<NvFaceInfo *,xalloc<NvFaceInfo *> >::size, COMDAT
; _this$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	eax, DWORD PTR [ecx+4]
	sub	eax, DWORD PTR [ecx]
	sar	eax, 2
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 125  : 	u32		size				() const							{ return (u32)inherited::size();} 

	ret	0
?size@?$xr_vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@@QBEIXZ ENDP ; xr_vector<NvFaceInfo *,xalloc<NvFaceInfo *> >::size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ??0?$xr_vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@@QAE@XZ
_TEXT	SEGMENT
??0?$xr_vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@@QAE@XZ PROC ; xr_vector<NvFaceInfo *,xalloc<NvFaceInfo *> >::xr_vector<NvFaceInfo *,xalloc<NvFaceInfo *> >, COMDAT
; _this$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx], 0
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 122  : 			xr_vector			()									: inherited	()					{}

	mov	eax, ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 122  : 			xr_vector			()									: inherited	()					{}

	ret	0
??0?$xr_vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@@QAE@XZ ENDP ; xr_vector<NvFaceInfo *,xalloc<NvFaceInfo *> >::xr_vector<NvFaceInfo *,xalloc<NvFaceInfo *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??1?$vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@std@@QAE@XZ PROC ; std::vector<NvFaceInfo *,xalloc<NvFaceInfo *> >::~vector<NvFaceInfo *,xalloc<NvFaceInfo *> >, COMDAT
; _this$ = ecx

; 698  :     _CONSTEXPR20_CONTAINER ~vector() noexcept {

	push	esi
	mov	esi, ecx

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN4@vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+4], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+8], 0
$LN4@vector:
	pop	esi

; 699  :         _Tidy();
; 700  : #if _ITERATOR_DEBUG_LEVEL != 0
; 701  :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 702  :         _Delete_plain_internal(_Alproxy, _STD exchange(_Mypair._Myval2._Myproxy, nullptr));
; 703  : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 704  :     }

	ret	0
??1?$vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@std@@QAE@XZ ENDP ; std::vector<NvFaceInfo *,xalloc<NvFaceInfo *> >::~vector<NvFaceInfo *,xalloc<NvFaceInfo *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ??A?$xr_vector@HV?$xalloc@H@@@@QAEAAHI@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$xr_vector@HV?$xalloc@H@@@@QAEAAHI@Z PROC		; xr_vector<int,xalloc<int> >::operator[], COMDAT
; _this$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 119  :         _Ptr += _Off;

	mov	ecx, DWORD PTR [ecx]
	mov	eax, DWORD PTR __Pos$[esp-4]
	lea	eax, DWORD PTR [ecx+eax*4]
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 138  : 	reference operator[]		(size_type _Pos)					{ {VERIFY(_Pos<size());} return (*(begin() + _Pos)); }

	ret	4
??A?$xr_vector@HV?$xalloc@H@@@@QAEAAHI@Z ENDP		; xr_vector<int,xalloc<int> >::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?size@?$xr_vector@HV?$xalloc@H@@@@QBEIXZ
_TEXT	SEGMENT
?size@?$xr_vector@HV?$xalloc@H@@@@QBEIXZ PROC		; xr_vector<int,xalloc<int> >::size, COMDAT
; _this$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	eax, DWORD PTR [ecx+4]
	sub	eax, DWORD PTR [ecx]
	sar	eax, 2
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 125  : 	u32		size				() const							{ return (u32)inherited::size();} 

	ret	0
?size@?$xr_vector@HV?$xalloc@H@@@@QBEIXZ ENDP		; xr_vector<int,xalloc<int> >::size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ??0?$xr_vector@HV?$xalloc@H@@@@QAE@XZ
_TEXT	SEGMENT
??0?$xr_vector@HV?$xalloc@H@@@@QAE@XZ PROC		; xr_vector<int,xalloc<int> >::xr_vector<int,xalloc<int> >, COMDAT
; _this$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx], 0
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 122  : 			xr_vector			()									: inherited	()					{}

	mov	eax, ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 122  : 			xr_vector			()									: inherited	()					{}

	ret	0
??0?$xr_vector@HV?$xalloc@H@@@@QAE@XZ ENDP		; xr_vector<int,xalloc<int> >::xr_vector<int,xalloc<int> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??1?$vector@HV?$xalloc@H@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@HV?$xalloc@H@@@std@@QAE@XZ PROC		; std::vector<int,xalloc<int> >::~vector<int,xalloc<int> >, COMDAT
; _this$ = ecx

; 698  :     _CONSTEXPR20_CONTAINER ~vector() noexcept {

	push	esi
	mov	esi, ecx

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN4@vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+4], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+8], 0
$LN4@vector:
	pop	esi

; 699  :         _Tidy();
; 700  : #if _ITERATOR_DEBUG_LEVEL != 0
; 701  :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 702  :         _Delete_plain_internal(_Alproxy, _STD exchange(_Mypair._Myval2._Myproxy, nullptr));
; 703  : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 704  :     }

	ret	0
??1?$vector@HV?$xalloc@H@@@std@@QAE@XZ ENDP		; std::vector<int,xalloc<int> >::~vector<int,xalloc<int> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QBE?AV01@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QBE?AV01@H@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int> > >::operator+, COMDAT
; _this$ = ecx

; 119  :         _Ptr += _Off;

	mov	eax, DWORD PTR __Off$[esp-4]
	mov	ecx, DWORD PTR [ecx]
	lea	ecx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 303  :         _Vector_iterator _Tmp = *this;
; 304  :         _Tmp += _Off; // TRANSITION, LLVM-49342
; 305  :         return _Tmp;
; 306  :     }

	ret	8
??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QBE?AV01@H@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int> > >::operator+
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QBEAAHXZ
_TEXT	SEGMENT
??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QBEAAHXZ PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int> > >::operator*, COMDAT
; _this$ = ecx

; 261  :         return const_cast<reference>(_Mybase::operator*());

	mov	eax, DWORD PTR [ecx]

; 262  :     }

	ret	0
??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QBEAAHXZ ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int> > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVNvFaceInfo@@@std@@@std@@@std@@QBE?AV01@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVNvFaceInfo@@@std@@@std@@@std@@QBE?AV01@H@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NvFaceInfo *> > >::operator+, COMDAT
; _this$ = ecx

; 119  :         _Ptr += _Off;

	mov	eax, DWORD PTR __Off$[esp-4]
	mov	ecx, DWORD PTR [ecx]
	lea	ecx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 303  :         _Vector_iterator _Tmp = *this;
; 304  :         _Tmp += _Off; // TRANSITION, LLVM-49342
; 305  :         return _Tmp;
; 306  :     }

	ret	8
??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVNvFaceInfo@@@std@@@std@@@std@@QBE?AV01@H@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NvFaceInfo *> > >::operator+
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVNvFaceInfo@@@std@@@std@@@std@@QBEAAPAVNvFaceInfo@@XZ
_TEXT	SEGMENT
??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVNvFaceInfo@@@std@@@std@@@std@@QBEAAPAVNvFaceInfo@@XZ PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NvFaceInfo *> > >::operator*, COMDAT
; _this$ = ecx

; 261  :         return const_cast<reference>(_Mybase::operator*());

	mov	eax, DWORD PTR [ecx]

; 262  :     }

	ret	0
??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVNvFaceInfo@@@std@@@std@@@std@@QBEAAPAVNvFaceInfo@@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NvFaceInfo *> > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVNvStripInfo@@@std@@@std@@@std@@QBE?AV01@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVNvStripInfo@@@std@@@std@@@std@@QBE?AV01@H@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NvStripInfo *> > >::operator+, COMDAT
; _this$ = ecx

; 119  :         _Ptr += _Off;

	mov	eax, DWORD PTR __Off$[esp-4]
	mov	ecx, DWORD PTR [ecx]
	lea	ecx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 303  :         _Vector_iterator _Tmp = *this;
; 304  :         _Tmp += _Off; // TRANSITION, LLVM-49342
; 305  :         return _Tmp;
; 306  :     }

	ret	8
??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVNvStripInfo@@@std@@@std@@@std@@QBE?AV01@H@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NvStripInfo *> > >::operator+
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVNvStripInfo@@@std@@@std@@@std@@QBEAAPAVNvStripInfo@@XZ
_TEXT	SEGMENT
??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVNvStripInfo@@@std@@@std@@@std@@QBEAAPAVNvStripInfo@@XZ PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NvStripInfo *> > >::operator*, COMDAT
; _this$ = ecx

; 261  :         return const_cast<reference>(_Mybase::operator*());

	mov	eax, DWORD PTR [ecx]

; 262  :     }

	ret	0
??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVNvStripInfo@@@std@@@std@@@std@@QBEAAPAVNvStripInfo@@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NvStripInfo *> > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UPrimitiveGroup@@@std@@@std@@@std@@QBE?AV01@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UPrimitiveGroup@@@std@@@std@@@std@@QBE?AV01@H@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<PrimitiveGroup> > >::operator+, COMDAT
; _this$ = ecx

; 119  :         _Ptr += _Off;

	mov	eax, DWORD PTR __Off$[esp-4]
	lea	edx, DWORD PTR [eax+eax*2]
	mov	eax, DWORD PTR [ecx]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 303  :         _Vector_iterator _Tmp = *this;
; 304  :         _Tmp += _Off; // TRANSITION, LLVM-49342
; 305  :         return _Tmp;
; 306  :     }

	ret	8
??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UPrimitiveGroup@@@std@@@std@@@std@@QBE?AV01@H@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<PrimitiveGroup> > >::operator+
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UPrimitiveGroup@@@std@@@std@@@std@@QBEAAUPrimitiveGroup@@XZ
_TEXT	SEGMENT
??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UPrimitiveGroup@@@std@@@std@@@std@@QBEAAUPrimitiveGroup@@XZ PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<PrimitiveGroup> > >::operator*, COMDAT
; _this$ = ecx

; 261  :         return const_cast<reference>(_Mybase::operator*());

	mov	eax, DWORD PTR [ecx]

; 262  :     }

	ret	0
??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UPrimitiveGroup@@@std@@@std@@@std@@QBEAAUPrimitiveGroup@@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<PrimitiveGroup> > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??H?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UPrimitiveGroup@@@std@@@std@@@std@@QBE?AV01@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??H?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UPrimitiveGroup@@@std@@@std@@@std@@QBE?AV01@H@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<PrimitiveGroup> > >::operator+, COMDAT
; _this$ = ecx

; 119  :         _Ptr += _Off;

	mov	eax, DWORD PTR __Off$[esp-4]
	lea	edx, DWORD PTR [eax+eax*2]
	mov	eax, DWORD PTR [ecx]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 124  :         _Vector_const_iterator _Tmp = *this;
; 125  :         _Tmp += _Off; // TRANSITION, LLVM-49342
; 126  :         return _Tmp;
; 127  :     }

	ret	8
??H?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UPrimitiveGroup@@@std@@@std@@@std@@QBE?AV01@H@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<PrimitiveGroup> > >::operator+
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UPrimitiveGroup@@@std@@@std@@@std@@QBEABUPrimitiveGroup@@XZ
_TEXT	SEGMENT
??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UPrimitiveGroup@@@std@@@std@@@std@@QBEABUPrimitiveGroup@@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<PrimitiveGroup> > >::operator*, COMDAT
; _this$ = ecx

; 46   : #if _ITERATOR_DEBUG_LEVEL != 0
; 47   :         const auto _Mycont = static_cast<const _Myvec*>(this->_Getcont());
; 48   :         _STL_VERIFY(_Ptr, "can't dereference value-initialized vector iterator");
; 49   :         _STL_VERIFY(
; 50   :             _Mycont->_Myfirst <= _Ptr && _Ptr < _Mycont->_Mylast, "can't dereference out of range vector iterator");
; 51   : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 52   : 
; 53   :         return *_Ptr;

	mov	eax, DWORD PTR [ecx]

; 54   :     }

	ret	0
??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UPrimitiveGroup@@@std@@@std@@@std@@QBEABUPrimitiveGroup@@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<PrimitiveGroup> > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?size@?$vector@UPrimitiveGroup@@V?$xalloc@UPrimitiveGroup@@@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@UPrimitiveGroup@@V?$xalloc@UPrimitiveGroup@@@@@std@@QBEIXZ PROC ; std::vector<PrimitiveGroup,xalloc<PrimitiveGroup> >::size, COMDAT
; _this$ = ecx

; 1535 :         auto& _My_data = _Mypair._Myval2;
; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	eax, DWORD PTR [ecx+4]
	sub	eax, DWORD PTR [ecx]
	sar	eax, 2
	imul	eax, eax, -1431655765

; 1537 :     }

	ret	0
?size@?$vector@UPrimitiveGroup@@V?$xalloc@UPrimitiveGroup@@@@@std@@QBEIXZ ENDP ; std::vector<PrimitiveGroup,xalloc<PrimitiveGroup> >::size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?begin@?$vector@UPrimitiveGroup@@V?$xalloc@UPrimitiveGroup@@@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UPrimitiveGroup@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@UPrimitiveGroup@@V?$xalloc@UPrimitiveGroup@@@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UPrimitiveGroup@@@std@@@std@@@2@XZ PROC ; std::vector<PrimitiveGroup,xalloc<PrimitiveGroup> >::begin, COMDAT
; _this$ = ecx

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	ecx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], ecx

; 1467 :         auto& _My_data = _Mypair._Myval2;
; 1468 :         return const_iterator(_My_data._Myfirst, _STD addressof(_My_data));
; 1469 :     }

	ret	4
?begin@?$vector@UPrimitiveGroup@@V?$xalloc@UPrimitiveGroup@@@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UPrimitiveGroup@@@std@@@std@@@2@XZ ENDP ; std::vector<PrimitiveGroup,xalloc<PrimitiveGroup> >::begin
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?begin@?$vector@UPrimitiveGroup@@V?$xalloc@UPrimitiveGroup@@@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UPrimitiveGroup@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@UPrimitiveGroup@@V?$xalloc@UPrimitiveGroup@@@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UPrimitiveGroup@@@std@@@std@@@2@XZ PROC ; std::vector<PrimitiveGroup,xalloc<PrimitiveGroup> >::begin, COMDAT
; _this$ = ecx

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	ecx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], ecx

; 1462 :         auto& _My_data = _Mypair._Myval2;
; 1463 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));
; 1464 :     }

	ret	4
?begin@?$vector@UPrimitiveGroup@@V?$xalloc@UPrimitiveGroup@@@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UPrimitiveGroup@@@std@@@std@@@2@XZ ENDP ; std::vector<PrimitiveGroup,xalloc<PrimitiveGroup> >::begin
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Tidy@?$vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@std@@AAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@std@@AAEXXZ PROC ; std::vector<NvStripInfo *,xalloc<NvStripInfo *> >::_Tidy, COMDAT
; _this$ = ecx

; 1742 :     _CONSTEXPR20_CONTAINER void _Tidy() noexcept { // free all storage

	push	esi
	mov	esi, ecx

; 1743 :         auto& _My_data    = _Mypair._Myval2;
; 1744 :         pointer& _Myfirst = _My_data._Myfirst;
; 1745 :         pointer& _Mylast  = _My_data._Mylast;
; 1746 :         pointer& _Myend   = _My_data._Myend;
; 1747 : 
; 1748 :         _My_data._Orphan_all();
; 1749 : 
; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN2@Tidy
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+4], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+8], 0
$LN2@Tidy:

; 1757 :         }
; 1758 :     }

	pop	esi
	ret	0
?_Tidy@?$vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@std@@AAEXXZ ENDP ; std::vector<NvStripInfo *,xalloc<NvStripInfo *> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?size@?$vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@std@@QBEIXZ PROC ; std::vector<NvStripInfo *,xalloc<NvStripInfo *> >::size, COMDAT
; _this$ = ecx

; 1535 :         auto& _My_data = _Mypair._Myval2;
; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	eax, DWORD PTR [ecx+4]
	sub	eax, DWORD PTR [ecx]
	sar	eax, 2

; 1537 :     }

	ret	0
?size@?$vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@std@@QBEIXZ ENDP ; std::vector<NvStripInfo *,xalloc<NvStripInfo *> >::size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?begin@?$vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVNvStripInfo@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVNvStripInfo@@@std@@@std@@@2@XZ PROC ; std::vector<NvStripInfo *,xalloc<NvStripInfo *> >::begin, COMDAT
; _this$ = ecx

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	ecx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], ecx

; 1462 :         auto& _My_data = _Mypair._Myval2;
; 1463 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));
; 1464 :     }

	ret	4
?begin@?$vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVNvStripInfo@@@std@@@std@@@2@XZ ENDP ; std::vector<NvStripInfo *,xalloc<NvStripInfo *> >::begin
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0?$vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@std@@QAE@XZ PROC ; std::vector<NvStripInfo *,xalloc<NvStripInfo *> >::vector<NvStripInfo *,xalloc<NvStripInfo *> >, COMDAT
; _this$ = ecx

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx], 0

; 464  :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 465  :     }

	mov	eax, ecx

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0

; 464  :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 465  :     }

	ret	0
??0?$vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@std@@QAE@XZ ENDP ; std::vector<NvStripInfo *,xalloc<NvStripInfo *> >::vector<NvStripInfo *,xalloc<NvStripInfo *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Tidy@?$vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@std@@AAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@std@@AAEXXZ PROC ; std::vector<NvFaceInfo *,xalloc<NvFaceInfo *> >::_Tidy, COMDAT
; _this$ = ecx

; 1742 :     _CONSTEXPR20_CONTAINER void _Tidy() noexcept { // free all storage

	push	esi
	mov	esi, ecx

; 1743 :         auto& _My_data    = _Mypair._Myval2;
; 1744 :         pointer& _Myfirst = _My_data._Myfirst;
; 1745 :         pointer& _Mylast  = _My_data._Mylast;
; 1746 :         pointer& _Myend   = _My_data._Myend;
; 1747 : 
; 1748 :         _My_data._Orphan_all();
; 1749 : 
; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN2@Tidy
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+4], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+8], 0
$LN2@Tidy:

; 1757 :         }
; 1758 :     }

	pop	esi
	ret	0
?_Tidy@?$vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@std@@AAEXXZ ENDP ; std::vector<NvFaceInfo *,xalloc<NvFaceInfo *> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?size@?$vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@std@@QBEIXZ PROC ; std::vector<NvFaceInfo *,xalloc<NvFaceInfo *> >::size, COMDAT
; _this$ = ecx

; 1535 :         auto& _My_data = _Mypair._Myval2;
; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	eax, DWORD PTR [ecx+4]
	sub	eax, DWORD PTR [ecx]
	sar	eax, 2

; 1537 :     }

	ret	0
?size@?$vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@std@@QBEIXZ ENDP ; std::vector<NvFaceInfo *,xalloc<NvFaceInfo *> >::size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?begin@?$vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVNvFaceInfo@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVNvFaceInfo@@@std@@@std@@@2@XZ PROC ; std::vector<NvFaceInfo *,xalloc<NvFaceInfo *> >::begin, COMDAT
; _this$ = ecx

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	ecx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], ecx

; 1462 :         auto& _My_data = _Mypair._Myval2;
; 1463 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));
; 1464 :     }

	ret	4
?begin@?$vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVNvFaceInfo@@@std@@@std@@@2@XZ ENDP ; std::vector<NvFaceInfo *,xalloc<NvFaceInfo *> >::begin
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0?$vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@std@@QAE@XZ PROC ; std::vector<NvFaceInfo *,xalloc<NvFaceInfo *> >::vector<NvFaceInfo *,xalloc<NvFaceInfo *> >, COMDAT
; _this$ = ecx

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx], 0

; 464  :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 465  :     }

	mov	eax, ecx

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0

; 464  :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 465  :     }

	ret	0
??0?$vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@std@@QAE@XZ ENDP ; std::vector<NvFaceInfo *,xalloc<NvFaceInfo *> >::vector<NvFaceInfo *,xalloc<NvFaceInfo *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Tidy@?$vector@HV?$xalloc@H@@@std@@AAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@HV?$xalloc@H@@@std@@AAEXXZ PROC		; std::vector<int,xalloc<int> >::_Tidy, COMDAT
; _this$ = ecx

; 1742 :     _CONSTEXPR20_CONTAINER void _Tidy() noexcept { // free all storage

	push	esi
	mov	esi, ecx

; 1743 :         auto& _My_data    = _Mypair._Myval2;
; 1744 :         pointer& _Myfirst = _My_data._Myfirst;
; 1745 :         pointer& _Mylast  = _My_data._Mylast;
; 1746 :         pointer& _Myend   = _My_data._Myend;
; 1747 : 
; 1748 :         _My_data._Orphan_all();
; 1749 : 
; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN2@Tidy
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+4], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+8], 0
$LN2@Tidy:

; 1757 :         }
; 1758 :     }

	pop	esi
	ret	0
?_Tidy@?$vector@HV?$xalloc@H@@@std@@AAEXXZ ENDP		; std::vector<int,xalloc<int> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?size@?$vector@HV?$xalloc@H@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@HV?$xalloc@H@@@std@@QBEIXZ PROC		; std::vector<int,xalloc<int> >::size, COMDAT
; _this$ = ecx

; 1535 :         auto& _My_data = _Mypair._Myval2;
; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	eax, DWORD PTR [ecx+4]
	sub	eax, DWORD PTR [ecx]
	sar	eax, 2

; 1537 :     }

	ret	0
?size@?$vector@HV?$xalloc@H@@@std@@QBEIXZ ENDP		; std::vector<int,xalloc<int> >::size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?begin@?$vector@HV?$xalloc@H@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@HV?$xalloc@H@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@XZ PROC ; std::vector<int,xalloc<int> >::begin, COMDAT
; _this$ = ecx

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	ecx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], ecx

; 1462 :         auto& _My_data = _Mypair._Myval2;
; 1463 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));
; 1464 :     }

	ret	4
?begin@?$vector@HV?$xalloc@H@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@XZ ENDP ; std::vector<int,xalloc<int> >::begin
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0?$vector@HV?$xalloc@H@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@HV?$xalloc@H@@@std@@QAE@XZ PROC		; std::vector<int,xalloc<int> >::vector<int,xalloc<int> >, COMDAT
; _this$ = ecx

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx], 0

; 464  :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 465  :     }

	mov	eax, ecx

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0

; 464  :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 465  :     }

	ret	0
??0?$vector@HV?$xalloc@H@@@std@@QAE@XZ ENDP		; std::vector<int,xalloc<int> >::vector<int,xalloc<int> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UPrimitiveGroup@@@std@@@std@@@std@@QAE@PAUPrimitiveGroup@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
___param0$ = 8						; size = 4
___param1$dead$ = 12					; size = 4
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UPrimitiveGroup@@@std@@@std@@@std@@QAE@PAUPrimitiveGroup@@PBU_Container_base0@1@@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<PrimitiveGroup> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<PrimitiveGroup> > >, COMDAT
; _this$ = ecx

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	eax, DWORD PTR ___param0$[esp-4]
	mov	DWORD PTR [ecx], eax
	mov	eax, ecx
	ret	8
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UPrimitiveGroup@@@std@@@std@@@std@@QAE@PAUPrimitiveGroup@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<PrimitiveGroup> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<PrimitiveGroup> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVNvStripInfo@@@std@@@std@@@std@@QAE@PAPAVNvStripInfo@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
___param0$ = 8						; size = 4
___param1$dead$ = 12					; size = 4
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVNvStripInfo@@@std@@@std@@@std@@QAE@PAPAVNvStripInfo@@PBU_Container_base0@1@@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NvStripInfo *> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<NvStripInfo *> > >, COMDAT
; _this$ = ecx

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	eax, DWORD PTR ___param0$[esp-4]
	mov	DWORD PTR [ecx], eax
	mov	eax, ecx
	ret	8
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVNvStripInfo@@@std@@@std@@@std@@QAE@PAPAVNvStripInfo@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NvStripInfo *> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<NvStripInfo *> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVNvFaceInfo@@@std@@@std@@@std@@QAE@PAPAVNvFaceInfo@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
___param0$ = 8						; size = 4
___param1$dead$ = 12					; size = 4
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVNvFaceInfo@@@std@@@std@@@std@@QAE@PAPAVNvFaceInfo@@PBU_Container_base0@1@@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NvFaceInfo *> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<NvFaceInfo *> > >, COMDAT
; _this$ = ecx

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	eax, DWORD PTR ___param0$[esp-4]
	mov	DWORD PTR [ecx], eax
	mov	eax, ecx
	ret	8
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVNvFaceInfo@@@std@@@std@@@std@@QAE@PAPAVNvFaceInfo@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NvFaceInfo *> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<NvFaceInfo *> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@PAHPBU_Container_base0@1@@Z
_TEXT	SEGMENT
___param0$ = 8						; size = 4
___param1$dead$ = 12					; size = 4
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@PAHPBU_Container_base0@1@@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<int> > >, COMDAT
; _this$ = ecx

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	eax, DWORD PTR ___param0$[esp-4]
	mov	DWORD PTR [ecx], eax
	mov	eax, ecx
	ret	8
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@PAHPBU_Container_base0@1@@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<int> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int> > >::operator+=, COMDAT
; _this$ = ecx

; 119  :         _Ptr += _Off;

	mov	eax, DWORD PTR __Off$[esp-4]
	shl	eax, 2
	add	DWORD PTR [ecx], eax

; 298  :         _Mybase::operator+=(_Off);
; 299  :         return *this;

	mov	eax, ecx

; 300  :     }

	ret	4
??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int> > >::operator+=
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QBEABHXZ
_TEXT	SEGMENT
??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QBEABHXZ PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int> > >::operator*, COMDAT
; _this$ = ecx

; 46   : #if _ITERATOR_DEBUG_LEVEL != 0
; 47   :         const auto _Mycont = static_cast<const _Myvec*>(this->_Getcont());
; 48   :         _STL_VERIFY(_Ptr, "can't dereference value-initialized vector iterator");
; 49   :         _STL_VERIFY(
; 50   :             _Mycont->_Myfirst <= _Ptr && _Ptr < _Mycont->_Mylast, "can't dereference out of range vector iterator");
; 51   : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 52   : 
; 53   :         return *_Ptr;

	mov	eax, DWORD PTR [ecx]

; 54   :     }

	ret	0
??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QBEABHXZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int> > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@PAHPBU_Container_base0@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Pvector$dead$ = 12					; size = 4
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@PAHPBU_Container_base0@1@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int> > >, COMDAT
; _this$ = ecx

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	eax, DWORD PTR __Parg$[esp-4]
	mov	DWORD PTR [ecx], eax

; 42   :         this->_Adopt(_Pvector);
; 43   :     }

	mov	eax, ecx
	ret	8
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@PAHPBU_Container_base0@1@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVNvFaceInfo@@@std@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVNvFaceInfo@@@std@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NvFaceInfo *> > >::operator+=, COMDAT
; _this$ = ecx

; 119  :         _Ptr += _Off;

	mov	eax, DWORD PTR __Off$[esp-4]
	shl	eax, 2
	add	DWORD PTR [ecx], eax

; 298  :         _Mybase::operator+=(_Off);
; 299  :         return *this;

	mov	eax, ecx

; 300  :     }

	ret	4
??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVNvFaceInfo@@@std@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NvFaceInfo *> > >::operator+=
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVNvFaceInfo@@@std@@@std@@@std@@QBEABQAVNvFaceInfo@@XZ
_TEXT	SEGMENT
??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVNvFaceInfo@@@std@@@std@@@std@@QBEABQAVNvFaceInfo@@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<NvFaceInfo *> > >::operator*, COMDAT
; _this$ = ecx

; 46   : #if _ITERATOR_DEBUG_LEVEL != 0
; 47   :         const auto _Mycont = static_cast<const _Myvec*>(this->_Getcont());
; 48   :         _STL_VERIFY(_Ptr, "can't dereference value-initialized vector iterator");
; 49   :         _STL_VERIFY(
; 50   :             _Mycont->_Myfirst <= _Ptr && _Ptr < _Mycont->_Mylast, "can't dereference out of range vector iterator");
; 51   : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 52   : 
; 53   :         return *_Ptr;

	mov	eax, DWORD PTR [ecx]

; 54   :     }

	ret	0
??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVNvFaceInfo@@@std@@@std@@@std@@QBEABQAVNvFaceInfo@@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<NvFaceInfo *> > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVNvFaceInfo@@@std@@@std@@@std@@QAE@PAPAVNvFaceInfo@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Pvector$dead$ = 12					; size = 4
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVNvFaceInfo@@@std@@@std@@@std@@QAE@PAPAVNvFaceInfo@@PBU_Container_base0@1@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<NvFaceInfo *> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<NvFaceInfo *> > >, COMDAT
; _this$ = ecx

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	eax, DWORD PTR __Parg$[esp-4]
	mov	DWORD PTR [ecx], eax

; 42   :         this->_Adopt(_Pvector);
; 43   :     }

	mov	eax, ecx
	ret	8
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVNvFaceInfo@@@std@@@std@@@std@@QAE@PAPAVNvFaceInfo@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<NvFaceInfo *> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<NvFaceInfo *> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVNvStripInfo@@@std@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVNvStripInfo@@@std@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NvStripInfo *> > >::operator+=, COMDAT
; _this$ = ecx

; 119  :         _Ptr += _Off;

	mov	eax, DWORD PTR __Off$[esp-4]
	shl	eax, 2
	add	DWORD PTR [ecx], eax

; 298  :         _Mybase::operator+=(_Off);
; 299  :         return *this;

	mov	eax, ecx

; 300  :     }

	ret	4
??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVNvStripInfo@@@std@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NvStripInfo *> > >::operator+=
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVNvStripInfo@@@std@@@std@@@std@@QBEABQAVNvStripInfo@@XZ
_TEXT	SEGMENT
??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVNvStripInfo@@@std@@@std@@@std@@QBEABQAVNvStripInfo@@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<NvStripInfo *> > >::operator*, COMDAT
; _this$ = ecx

; 46   : #if _ITERATOR_DEBUG_LEVEL != 0
; 47   :         const auto _Mycont = static_cast<const _Myvec*>(this->_Getcont());
; 48   :         _STL_VERIFY(_Ptr, "can't dereference value-initialized vector iterator");
; 49   :         _STL_VERIFY(
; 50   :             _Mycont->_Myfirst <= _Ptr && _Ptr < _Mycont->_Mylast, "can't dereference out of range vector iterator");
; 51   : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 52   : 
; 53   :         return *_Ptr;

	mov	eax, DWORD PTR [ecx]

; 54   :     }

	ret	0
??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVNvStripInfo@@@std@@@std@@@std@@QBEABQAVNvStripInfo@@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<NvStripInfo *> > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVNvStripInfo@@@std@@@std@@@std@@QAE@PAPAVNvStripInfo@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Pvector$dead$ = 12					; size = 4
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVNvStripInfo@@@std@@@std@@@std@@QAE@PAPAVNvStripInfo@@PBU_Container_base0@1@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<NvStripInfo *> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<NvStripInfo *> > >, COMDAT
; _this$ = ecx

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	eax, DWORD PTR __Parg$[esp-4]
	mov	DWORD PTR [ecx], eax

; 42   :         this->_Adopt(_Pvector);
; 43   :     }

	mov	eax, ecx
	ret	8
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVNvStripInfo@@@std@@@std@@@std@@QAE@PAPAVNvStripInfo@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<NvStripInfo *> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<NvStripInfo *> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UPrimitiveGroup@@@std@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UPrimitiveGroup@@@std@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<PrimitiveGroup> > >::operator+=, COMDAT
; _this$ = ecx

; 119  :         _Ptr += _Off;

	mov	eax, DWORD PTR __Off$[esp-4]
	lea	eax, DWORD PTR [eax+eax*2]
	shl	eax, 2
	add	DWORD PTR [ecx], eax

; 298  :         _Mybase::operator+=(_Off);
; 299  :         return *this;

	mov	eax, ecx

; 300  :     }

	ret	4
??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UPrimitiveGroup@@@std@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<PrimitiveGroup> > >::operator+=
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UPrimitiveGroup@@@std@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UPrimitiveGroup@@@std@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<PrimitiveGroup> > >::operator+=, COMDAT
; _this$ = ecx

; 118  :         _Verify_offset(_Off);
; 119  :         _Ptr += _Off;

	mov	eax, DWORD PTR __Off$[esp-4]
	lea	eax, DWORD PTR [eax+eax*2]
	shl	eax, 2
	add	DWORD PTR [ecx], eax

; 120  :         return *this;

	mov	eax, ecx

; 121  :     }

	ret	4
??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UPrimitiveGroup@@@std@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<PrimitiveGroup> > >::operator+=
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UPrimitiveGroup@@@std@@@std@@@std@@QAE@PAUPrimitiveGroup@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Pvector$dead$ = 12					; size = 4
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UPrimitiveGroup@@@std@@@std@@@std@@QAE@PAUPrimitiveGroup@@PBU_Container_base0@1@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<PrimitiveGroup> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<PrimitiveGroup> > >, COMDAT
; _this$ = ecx

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	eax, DWORD PTR __Parg$[esp-4]
	mov	DWORD PTR [ecx], eax

; 42   :         this->_Adopt(_Pvector);
; 43   :     }

	mov	eax, ecx
	ret	8
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UPrimitiveGroup@@@std@@@std@@@std@@QAE@PAUPrimitiveGroup@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<PrimitiveGroup> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<PrimitiveGroup> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Getal@?$vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@std@@AAEAAV?$xalloc@PAVNvStripInfo@@@@XZ
_TEXT	SEGMENT
?_Getal@?$vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@std@@AAEAAV?$xalloc@PAVNvStripInfo@@@@XZ PROC ; std::vector<NvStripInfo *,xalloc<NvStripInfo *> >::_Getal, COMDAT
; _this$ = ecx

; 1805 :         return _Mypair._Get_first();

	mov	eax, ecx

; 1806 :     }

	ret	0
?_Getal@?$vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@std@@AAEAAV?$xalloc@PAVNvStripInfo@@@@XZ ENDP ; std::vector<NvStripInfo *,xalloc<NvStripInfo *> >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Destroy@?$vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@std@@AAEXPAPAVNvStripInfo@@0@Z
_TEXT	SEGMENT
__First$dead$ = 8					; size = 4
__Last$dead$ = 12					; size = 4
?_Destroy@?$vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@std@@AAEXPAPAVNvStripInfo@@0@Z PROC ; std::vector<NvStripInfo *,xalloc<NvStripInfo *> >::_Destroy, COMDAT
; _this$dead$ = ecx

; 1666 :         // destroy [_First, _Last) using allocator
; 1667 :         _Destroy_range(_First, _Last, _Getal());
; 1668 :     }

	ret	8
?_Destroy@?$vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@std@@AAEXPAPAVNvStripInfo@@0@Z ENDP ; std::vector<NvStripInfo *,xalloc<NvStripInfo *> >::_Destroy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?deallocate@?$xalloc@PAVNvStripInfo@@@@QBEXPAPAVNvStripInfo@@I@Z
_TEXT	SEGMENT
_p$ = 8							; size = 4
_n$dead$ = 12						; size = 4
?deallocate@?$xalloc@PAVNvStripInfo@@@@QBEXPAPAVNvStripInfo@@I@Z PROC ; xalloc<NvStripInfo *>::deallocate, COMDAT
; _this$dead$ = ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	eax, DWORD PTR _p$[esp-4]
	test	eax, eax
	je	SHORT $LN4@deallocate
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN4@deallocate:
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 82   : 							void					deallocate		(pointer p, size_type n) const			{	xr_free	(p);				}

	ret	8
?deallocate@?$xalloc@PAVNvStripInfo@@@@QBEXPAPAVNvStripInfo@@I@Z ENDP ; xalloc<NvStripInfo *>::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Getal@?$vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@std@@AAEAAV?$xalloc@PAVNvFaceInfo@@@@XZ
_TEXT	SEGMENT
?_Getal@?$vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@std@@AAEAAV?$xalloc@PAVNvFaceInfo@@@@XZ PROC ; std::vector<NvFaceInfo *,xalloc<NvFaceInfo *> >::_Getal, COMDAT
; _this$ = ecx

; 1805 :         return _Mypair._Get_first();

	mov	eax, ecx

; 1806 :     }

	ret	0
?_Getal@?$vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@std@@AAEAAV?$xalloc@PAVNvFaceInfo@@@@XZ ENDP ; std::vector<NvFaceInfo *,xalloc<NvFaceInfo *> >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Destroy@?$vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@std@@AAEXPAPAVNvFaceInfo@@0@Z
_TEXT	SEGMENT
__First$dead$ = 8					; size = 4
__Last$dead$ = 12					; size = 4
?_Destroy@?$vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@std@@AAEXPAPAVNvFaceInfo@@0@Z PROC ; std::vector<NvFaceInfo *,xalloc<NvFaceInfo *> >::_Destroy, COMDAT
; _this$dead$ = ecx

; 1666 :         // destroy [_First, _Last) using allocator
; 1667 :         _Destroy_range(_First, _Last, _Getal());
; 1668 :     }

	ret	8
?_Destroy@?$vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@std@@AAEXPAPAVNvFaceInfo@@0@Z ENDP ; std::vector<NvFaceInfo *,xalloc<NvFaceInfo *> >::_Destroy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?deallocate@?$xalloc@PAVNvFaceInfo@@@@QBEXPAPAVNvFaceInfo@@I@Z
_TEXT	SEGMENT
_p$ = 8							; size = 4
_n$dead$ = 12						; size = 4
?deallocate@?$xalloc@PAVNvFaceInfo@@@@QBEXPAPAVNvFaceInfo@@I@Z PROC ; xalloc<NvFaceInfo *>::deallocate, COMDAT
; _this$dead$ = ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	eax, DWORD PTR _p$[esp-4]
	test	eax, eax
	je	SHORT $LN4@deallocate
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN4@deallocate:
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 82   : 							void					deallocate		(pointer p, size_type n) const			{	xr_free	(p);				}

	ret	8
?deallocate@?$xalloc@PAVNvFaceInfo@@@@QBEXPAPAVNvFaceInfo@@I@Z ENDP ; xalloc<NvFaceInfo *>::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?deallocate@?$xalloc@H@@QBEXPAHI@Z
_TEXT	SEGMENT
_p$ = 8							; size = 4
_n$dead$ = 12						; size = 4
?deallocate@?$xalloc@H@@QBEXPAHI@Z PROC			; xalloc<int>::deallocate, COMDAT
; _this$dead$ = ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	eax, DWORD PTR _p$[esp-4]
	test	eax, eax
	je	SHORT $LN4@deallocate
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN4@deallocate:
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 82   : 							void					deallocate		(pointer p, size_type n) const			{	xr_free	(p);				}

	ret	8
?deallocate@?$xalloc@H@@QBEXPAHI@Z ENDP			; xalloc<int>::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int> > >::operator+=, COMDAT
; _this$ = ecx

; 118  :         _Verify_offset(_Off);
; 119  :         _Ptr += _Off;

	mov	eax, DWORD PTR __Off$[esp-4]
	shl	eax, 2
	add	DWORD PTR [ecx], eax

; 120  :         return *this;

	mov	eax, ecx

; 121  :     }

	ret	4
??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int> > >::operator+=
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVNvFaceInfo@@@std@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVNvFaceInfo@@@std@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<NvFaceInfo *> > >::operator+=, COMDAT
; _this$ = ecx

; 118  :         _Verify_offset(_Off);
; 119  :         _Ptr += _Off;

	mov	eax, DWORD PTR __Off$[esp-4]
	shl	eax, 2
	add	DWORD PTR [ecx], eax

; 120  :         return *this;

	mov	eax, ecx

; 121  :     }

	ret	4
??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVNvFaceInfo@@@std@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<NvFaceInfo *> > >::operator+=
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVNvStripInfo@@@std@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVNvStripInfo@@@std@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<NvStripInfo *> > >::operator+=, COMDAT
; _this$ = ecx

; 118  :         _Verify_offset(_Off);
; 119  :         _Ptr += _Off;

	mov	eax, DWORD PTR __Off$[esp-4]
	shl	eax, 2
	add	DWORD PTR [ecx], eax

; 120  :         return *this;

	mov	eax, ecx

; 121  :     }

	ret	4
??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVNvStripInfo@@@std@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<NvStripInfo *> > >::operator+=
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Verify_offset@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UPrimitiveGroup@@@std@@@std@@@std@@QBEXH@Z
_TEXT	SEGMENT
__Off$dead$ = 8						; size = 4
?_Verify_offset@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UPrimitiveGroup@@@std@@@std@@@std@@QBEXH@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<PrimitiveGroup> > >::_Verify_offset, COMDAT
; _this$dead$ = ecx

; 102  : #if _ITERATOR_DEBUG_LEVEL == 0
; 103  :         (void) _Off;
; 104  : #else // ^^^ _ITERATOR_DEBUG_LEVEL == 0 ^^^ // vvv _ITERATOR_DEBUG_LEVEL != 0 vvv
; 105  :         const auto _Mycont = static_cast<const _Myvec*>(this->_Getcont());
; 106  :         _STL_VERIFY(_Off == 0 || _Ptr, "cannot seek value-initialized vector iterator");
; 107  :         if (_Off < 0) {
; 108  :             _STL_VERIFY(_Off >= _Mycont->_Myfirst - _Ptr, "cannot seek vector iterator before begin");
; 109  :         }
; 110  : 
; 111  :         if (_Off > 0) {
; 112  :             _STL_VERIFY(_Off <= _Mycont->_Mylast - _Ptr, "cannot seek vector iterator after end");
; 113  :         }
; 114  : #endif // _ITERATOR_DEBUG_LEVEL == 0
; 115  :     }

	ret	4
?_Verify_offset@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UPrimitiveGroup@@@std@@@std@@@std@@QBEXH@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<PrimitiveGroup> > >::_Verify_offset
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$xalloc@PAVNvStripInfo@@@@V?$_Vector_val@U?$_Simple_types@PAVNvStripInfo@@@std@@@std@@$00@std@@QAEAAV?$xalloc@PAVNvStripInfo@@@@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@V?$xalloc@PAVNvStripInfo@@@@V?$_Vector_val@U?$_Simple_types@PAVNvStripInfo@@@std@@@std@@$00@std@@QAEAAV?$xalloc@PAVNvStripInfo@@@@XZ PROC ; std::_Compressed_pair<xalloc<NvStripInfo *>,std::_Vector_val<std::_Simple_types<NvStripInfo *> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 1339 :         return *this;

	mov	eax, ecx

; 1340 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$xalloc@PAVNvStripInfo@@@@V?$_Vector_val@U?$_Simple_types@PAVNvStripInfo@@@std@@@std@@$00@std@@QAEAAV?$xalloc@PAVNvStripInfo@@@@XZ ENDP ; std::_Compressed_pair<xalloc<NvStripInfo *>,std::_Vector_val<std::_Simple_types<NvStripInfo *> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$xalloc@PAVNvFaceInfo@@@@V?$_Vector_val@U?$_Simple_types@PAVNvFaceInfo@@@std@@@std@@$00@std@@QAEAAV?$xalloc@PAVNvFaceInfo@@@@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@V?$xalloc@PAVNvFaceInfo@@@@V?$_Vector_val@U?$_Simple_types@PAVNvFaceInfo@@@std@@@std@@$00@std@@QAEAAV?$xalloc@PAVNvFaceInfo@@@@XZ PROC ; std::_Compressed_pair<xalloc<NvFaceInfo *>,std::_Vector_val<std::_Simple_types<NvFaceInfo *> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 1339 :         return *this;

	mov	eax, ecx

; 1340 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$xalloc@PAVNvFaceInfo@@@@V?$_Vector_val@U?$_Simple_types@PAVNvFaceInfo@@@std@@@std@@$00@std@@QAEAAV?$xalloc@PAVNvFaceInfo@@@@XZ ENDP ; std::_Compressed_pair<xalloc<NvFaceInfo *>,std::_Vector_val<std::_Simple_types<NvFaceInfo *> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Verify_offset@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QBEXH@Z
_TEXT	SEGMENT
__Off$dead$ = 8						; size = 4
?_Verify_offset@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QBEXH@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int> > >::_Verify_offset, COMDAT
; _this$dead$ = ecx

; 102  : #if _ITERATOR_DEBUG_LEVEL == 0
; 103  :         (void) _Off;
; 104  : #else // ^^^ _ITERATOR_DEBUG_LEVEL == 0 ^^^ // vvv _ITERATOR_DEBUG_LEVEL != 0 vvv
; 105  :         const auto _Mycont = static_cast<const _Myvec*>(this->_Getcont());
; 106  :         _STL_VERIFY(_Off == 0 || _Ptr, "cannot seek value-initialized vector iterator");
; 107  :         if (_Off < 0) {
; 108  :             _STL_VERIFY(_Off >= _Mycont->_Myfirst - _Ptr, "cannot seek vector iterator before begin");
; 109  :         }
; 110  : 
; 111  :         if (_Off > 0) {
; 112  :             _STL_VERIFY(_Off <= _Mycont->_Mylast - _Ptr, "cannot seek vector iterator after end");
; 113  :         }
; 114  : #endif // _ITERATOR_DEBUG_LEVEL == 0
; 115  :     }

	ret	4
?_Verify_offset@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QBEXH@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int> > >::_Verify_offset
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Verify_offset@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVNvFaceInfo@@@std@@@std@@@std@@QBEXH@Z
_TEXT	SEGMENT
__Off$dead$ = 8						; size = 4
?_Verify_offset@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVNvFaceInfo@@@std@@@std@@@std@@QBEXH@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<NvFaceInfo *> > >::_Verify_offset, COMDAT
; _this$dead$ = ecx

; 102  : #if _ITERATOR_DEBUG_LEVEL == 0
; 103  :         (void) _Off;
; 104  : #else // ^^^ _ITERATOR_DEBUG_LEVEL == 0 ^^^ // vvv _ITERATOR_DEBUG_LEVEL != 0 vvv
; 105  :         const auto _Mycont = static_cast<const _Myvec*>(this->_Getcont());
; 106  :         _STL_VERIFY(_Off == 0 || _Ptr, "cannot seek value-initialized vector iterator");
; 107  :         if (_Off < 0) {
; 108  :             _STL_VERIFY(_Off >= _Mycont->_Myfirst - _Ptr, "cannot seek vector iterator before begin");
; 109  :         }
; 110  : 
; 111  :         if (_Off > 0) {
; 112  :             _STL_VERIFY(_Off <= _Mycont->_Mylast - _Ptr, "cannot seek vector iterator after end");
; 113  :         }
; 114  : #endif // _ITERATOR_DEBUG_LEVEL == 0
; 115  :     }

	ret	4
?_Verify_offset@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVNvFaceInfo@@@std@@@std@@@std@@QBEXH@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<NvFaceInfo *> > >::_Verify_offset
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Verify_offset@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVNvStripInfo@@@std@@@std@@@std@@QBEXH@Z
_TEXT	SEGMENT
__Off$dead$ = 8						; size = 4
?_Verify_offset@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVNvStripInfo@@@std@@@std@@@std@@QBEXH@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<NvStripInfo *> > >::_Verify_offset, COMDAT
; _this$dead$ = ecx

; 102  : #if _ITERATOR_DEBUG_LEVEL == 0
; 103  :         (void) _Off;
; 104  : #else // ^^^ _ITERATOR_DEBUG_LEVEL == 0 ^^^ // vvv _ITERATOR_DEBUG_LEVEL != 0 vvv
; 105  :         const auto _Mycont = static_cast<const _Myvec*>(this->_Getcont());
; 106  :         _STL_VERIFY(_Off == 0 || _Ptr, "cannot seek value-initialized vector iterator");
; 107  :         if (_Off < 0) {
; 108  :             _STL_VERIFY(_Off >= _Mycont->_Myfirst - _Ptr, "cannot seek vector iterator before begin");
; 109  :         }
; 110  : 
; 111  :         if (_Off > 0) {
; 112  :             _STL_VERIFY(_Off <= _Mycont->_Mylast - _Ptr, "cannot seek vector iterator after end");
; 113  :         }
; 114  : #endif // _ITERATOR_DEBUG_LEVEL == 0
; 115  :     }

	ret	4
?_Verify_offset@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVNvStripInfo@@@std@@@std@@@std@@QBEXH@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<NvStripInfo *> > >::_Verify_offset
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
;	COMDAT ??$xr_delete@VNvFaceInfo@@@@YAXAAPAVNvFaceInfo@@@Z
_TEXT	SEGMENT
??$xr_delete@VNvFaceInfo@@@@YAXAAPAVNvFaceInfo@@@Z PROC	; xr_delete<NvFaceInfo>, COMDAT
; _ptr$ = ecx

; 150  : {

	push	esi
	mov	esi, ecx

; 151  : 	if (ptr) 

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN2@xr_delete

; 144  : 		Memory.mem_free	(ptr);

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z

; 152  : 	{
; 153  : 		xr_special_free<is_polymorphic<T>::result,T>()(ptr);
; 154  : 		ptr = nullptr;

	mov	DWORD PTR [esi], 0
$LN2@xr_delete:

; 155  : 	}
; 156  : }

	pop	esi
	ret	0
??$xr_delete@VNvFaceInfo@@@@YAXAAPAVNvFaceInfo@@@Z ENDP	; xr_delete<NvFaceInfo>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
;	COMDAT ??$xr_delete@VNvStripInfo@@@@YAXAAPAVNvStripInfo@@@Z
_TEXT	SEGMENT
??$xr_delete@VNvStripInfo@@@@YAXAAPAVNvStripInfo@@@Z PROC ; xr_delete<NvStripInfo>, COMDAT
; _ptr$ = ecx

; 150  : {

	push	esi
	push	edi
	mov	edi, ecx

; 151  : 	if (ptr) 

	mov	esi, DWORD PTR [edi]
	test	esi, esi
	je	SHORT $LN2@xr_delete
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [esi+12]
	test	eax, eax
	je	SHORT $LN16@xr_delete
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi+12], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+16], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+20], 0
	mov	esi, DWORD PTR [edi]
$LN16@xr_delete:
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h

; 144  : 		Memory.mem_free	(ptr);

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	esi
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z

; 152  : 	{
; 153  : 		xr_special_free<is_polymorphic<T>::result,T>()(ptr);
; 154  : 		ptr = nullptr;

	mov	DWORD PTR [edi], 0
$LN2@xr_delete:

; 155  : 	}
; 156  : }

	pop	edi
	pop	esi
	ret	0
??$xr_delete@VNvStripInfo@@@@YAXAAPAVNvStripInfo@@@Z ENDP ; xr_delete<NvStripInfo>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
;	COMDAT ??$xr_alloc@H@@YAPAHI@Z
_TEXT	SEGMENT
??$xr_alloc@H@@YAPAHI@Z PROC				; xr_alloc<int>, COMDAT
; _count$ = ecx

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	lea	eax, DWORD PTR [ecx*4]
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
	ret	0
??$xr_alloc@H@@YAPAHI@Z ENDP				; xr_alloc<int>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
;	COMDAT ??$xr_free@H@@YAXAAPAH@Z
_TEXT	SEGMENT
??$xr_free@H@@YAXAAPAH@Z PROC				; xr_free<int>, COMDAT
; _P$ = ecx

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	push	esi
	mov	esi, ecx
	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN2@xr_free
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
	mov	DWORD PTR [esi], 0
$LN2@xr_free:
	pop	esi
	ret	0
??$xr_free@H@@YAXAAPAH@Z ENDP				; xr_free<int>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??$_Resize@U_Value_init_tag@std@@@?$vector@UPrimitiveGroup@@V?$xalloc@UPrimitiveGroup@@@@@std@@AAEXIABU_Value_init_tag@1@@Z
_TEXT	SEGMENT
__Newsize$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Resize@U_Value_init_tag@std@@@?$vector@UPrimitiveGroup@@V?$xalloc@UPrimitiveGroup@@@@@std@@AAEXIABU_Value_init_tag@1@@Z PROC ; std::vector<PrimitiveGroup,xalloc<PrimitiveGroup> >::_Resize<std::_Value_init_tag>, COMDAT
; _this$ = ecx

; 1245 :     _CONSTEXPR20_CONTAINER void _Resize(const size_type _Newsize, const _Ty2& _Val) {

	mov	edx, ecx

; 1246 :         // trim or append elements, provide strong guarantee
; 1247 :         auto& _My_data      = _Mypair._Myval2;
; 1248 :         pointer& _Myfirst   = _My_data._Myfirst;
; 1249 :         pointer& _Mylast    = _My_data._Mylast;
; 1250 :         const auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);
; 1251 :         if (_Newsize < _Oldsize) { // trim

	mov	ecx, DWORD PTR __Newsize$[esp-4]
	push	esi
	push	edi
	mov	eax, DWORD PTR [edx+4]
	mov	edi, DWORD PTR [edx]
	sub	eax, edi
	sar	eax, 2
	imul	esi, eax, -1431655765
	cmp	ecx, esi
	jae	SHORT $LN2@Resize

; 1252 :             const pointer _Newlast = _Myfirst + _Newsize;

	lea	eax, DWORD PTR [ecx+ecx*2]
	lea	eax, DWORD PTR [edi+eax*4]
	pop	edi

; 1268 :             _Orphan_range(_Oldlast, _Oldlast);
; 1269 :         }
; 1270 : 
; 1271 :         // if _Newsize == _Oldsize, do nothing; avoid invalidating iterators
; 1272 :     }

	mov	DWORD PTR [edx+4], eax
	pop	esi
	ret	8
$LN2@Resize:

; 1253 :             _Orphan_range(_Newlast, _Mylast);
; 1254 :             _Destroy(_Newlast, _Mylast);
; 1255 :             _Mylast = _Newlast;
; 1256 :             return;
; 1257 :         }
; 1258 : 
; 1259 :         if (_Newsize > _Oldsize) { // append

	jbe	SHORT $LN3@Resize

; 1260 :             const auto _Oldcapacity = static_cast<size_type>(_My_data._Myend - _Myfirst);

	mov	eax, DWORD PTR [edx+8]
	sub	eax, edi
	sar	eax, 2
	imul	eax, eax, -1431655765

; 1261 :             if (_Newsize > _Oldcapacity) { // reallocate

	cmp	ecx, eax
	jbe	SHORT $LN4@Resize

; 1268 :             _Orphan_range(_Oldlast, _Oldlast);
; 1269 :         }
; 1270 : 
; 1271 :         // if _Newsize == _Oldsize, do nothing; avoid invalidating iterators
; 1272 :     }

	pop	edi
	pop	esi

; 1262 :                 _Resize_reallocate(_Newsize, _Val);

	mov	DWORD PTR __Newsize$[esp-4], ecx
	mov	ecx, edx
	jmp	??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UPrimitiveGroup@@V?$xalloc@UPrimitiveGroup@@@@@std@@AAEXIABU_Value_init_tag@1@@Z ; std::vector<PrimitiveGroup,xalloc<PrimitiveGroup> >::_Resize_reallocate<std::_Value_init_tag>
$LN4@Resize:

; 1263 :                 return;
; 1264 :             }
; 1265 : 
; 1266 :             const pointer _Oldlast = _Mylast;
; 1267 :             _Mylast                = _Ufill(_Oldlast, _Newsize - _Oldsize, _Val);

	mov	eax, DWORD PTR __Val$[esp+4]
	sub	ecx, esi
	movzx	eax, BYTE PTR [eax]
	push	eax
	push	ecx
	push	DWORD PTR [edx+4]
	call	?_Ufill@?$vector@UPrimitiveGroup@@V?$xalloc@UPrimitiveGroup@@@@@std@@AAEPAUPrimitiveGroup@@PAU3@IU_Value_init_tag@2@@Z ; std::vector<PrimitiveGroup,xalloc<PrimitiveGroup> >::_Ufill

; 1268 :             _Orphan_range(_Oldlast, _Oldlast);
; 1269 :         }
; 1270 : 
; 1271 :         // if _Newsize == _Oldsize, do nothing; avoid invalidating iterators
; 1272 :     }

	mov	DWORD PTR [edx+4], eax
$LN3@Resize:
	pop	edi
	pop	esi
	ret	8
??$_Resize@U_Value_init_tag@std@@@?$vector@UPrimitiveGroup@@V?$xalloc@UPrimitiveGroup@@@@@std@@AAEXIABU_Value_init_tag@1@@Z ENDP ; std::vector<PrimitiveGroup,xalloc<PrimitiveGroup> >::_Resize<std::_Value_init_tag>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef
;	COMDAT ??$addressof@$$CBV?$_Vector_val@U?$_Simple_types@UPrimitiveGroup@@@std@@@std@@@std@@YAPBV?$_Vector_val@U?$_Simple_types@UPrimitiveGroup@@@std@@@0@ABV10@@Z
_TEXT	SEGMENT
??$addressof@$$CBV?$_Vector_val@U?$_Simple_types@UPrimitiveGroup@@@std@@@std@@@std@@YAPBV?$_Vector_val@U?$_Simple_types@UPrimitiveGroup@@@std@@@0@ABV10@@Z PROC ; std::addressof<std::_Vector_val<std::_Simple_types<PrimitiveGroup> > const >, COMDAT
; __Val$ = ecx

; 253  :     return __builtin_addressof(_Val);

	mov	eax, ecx

; 254  : }

	ret	0
??$addressof@$$CBV?$_Vector_val@U?$_Simple_types@UPrimitiveGroup@@@std@@@std@@@std@@YAPBV?$_Vector_val@U?$_Simple_types@UPrimitiveGroup@@@std@@@0@ABV10@@Z ENDP ; std::addressof<std::_Vector_val<std::_Simple_types<PrimitiveGroup> > const >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef
;	COMDAT ??$addressof@V?$_Vector_val@U?$_Simple_types@UPrimitiveGroup@@@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@UPrimitiveGroup@@@std@@@0@AAV10@@Z
_TEXT	SEGMENT
??$addressof@V?$_Vector_val@U?$_Simple_types@UPrimitiveGroup@@@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@UPrimitiveGroup@@@std@@@0@AAV10@@Z PROC ; std::addressof<std::_Vector_val<std::_Simple_types<PrimitiveGroup> > >, COMDAT
; __Val$ = ecx

; 253  :     return __builtin_addressof(_Val);

	mov	eax, ecx

; 254  : }

	ret	0
??$addressof@V?$_Vector_val@U?$_Simple_types@UPrimitiveGroup@@@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@UPrimitiveGroup@@@std@@@0@AAV10@@Z ENDP ; std::addressof<std::_Vector_val<std::_Simple_types<PrimitiveGroup> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef
;	COMDAT ??$addressof@V?$_Vector_val@U?$_Simple_types@PAVNvStripInfo@@@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@PAVNvStripInfo@@@std@@@0@AAV10@@Z
_TEXT	SEGMENT
??$addressof@V?$_Vector_val@U?$_Simple_types@PAVNvStripInfo@@@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@PAVNvStripInfo@@@std@@@0@AAV10@@Z PROC ; std::addressof<std::_Vector_val<std::_Simple_types<NvStripInfo *> > >, COMDAT
; __Val$ = ecx

; 253  :     return __builtin_addressof(_Val);

	mov	eax, ecx

; 254  : }

	ret	0
??$addressof@V?$_Vector_val@U?$_Simple_types@PAVNvStripInfo@@@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@PAVNvStripInfo@@@std@@@0@AAV10@@Z ENDP ; std::addressof<std::_Vector_val<std::_Simple_types<NvStripInfo *> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$?0$$V@?$_Compressed_pair@V?$xalloc@PAVNvStripInfo@@@@V?$_Vector_val@U?$_Simple_types@PAVNvStripInfo@@@std@@@std@@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$?0$$V@?$_Compressed_pair@V?$xalloc@PAVNvStripInfo@@@@V?$_Vector_val@U?$_Simple_types@PAVNvStripInfo@@@std@@@std@@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<xalloc<NvStripInfo *>,std::_Vector_val<std::_Simple_types<NvStripInfo *> >,1>::_Compressed_pair<xalloc<NvStripInfo *>,std::_Vector_val<std::_Simple_types<NvStripInfo *> >,1><>, COMDAT
; _this$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1331 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	eax, ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1331 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	ret	4
??$?0$$V@?$_Compressed_pair@V?$xalloc@PAVNvStripInfo@@@@V?$_Vector_val@U?$_Simple_types@PAVNvStripInfo@@@std@@@std@@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<xalloc<NvStripInfo *>,std::_Vector_val<std::_Simple_types<NvStripInfo *> >,1>::_Compressed_pair<xalloc<NvStripInfo *>,std::_Vector_val<std::_Simple_types<NvStripInfo *> >,1><>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef
;	COMDAT ??$addressof@V?$_Vector_val@U?$_Simple_types@PAVNvFaceInfo@@@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@PAVNvFaceInfo@@@std@@@0@AAV10@@Z
_TEXT	SEGMENT
??$addressof@V?$_Vector_val@U?$_Simple_types@PAVNvFaceInfo@@@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@PAVNvFaceInfo@@@std@@@0@AAV10@@Z PROC ; std::addressof<std::_Vector_val<std::_Simple_types<NvFaceInfo *> > >, COMDAT
; __Val$ = ecx

; 253  :     return __builtin_addressof(_Val);

	mov	eax, ecx

; 254  : }

	ret	0
??$addressof@V?$_Vector_val@U?$_Simple_types@PAVNvFaceInfo@@@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@PAVNvFaceInfo@@@std@@@0@AAV10@@Z ENDP ; std::addressof<std::_Vector_val<std::_Simple_types<NvFaceInfo *> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$?0$$V@?$_Compressed_pair@V?$xalloc@PAVNvFaceInfo@@@@V?$_Vector_val@U?$_Simple_types@PAVNvFaceInfo@@@std@@@std@@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$?0$$V@?$_Compressed_pair@V?$xalloc@PAVNvFaceInfo@@@@V?$_Vector_val@U?$_Simple_types@PAVNvFaceInfo@@@std@@@std@@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<xalloc<NvFaceInfo *>,std::_Vector_val<std::_Simple_types<NvFaceInfo *> >,1>::_Compressed_pair<xalloc<NvFaceInfo *>,std::_Vector_val<std::_Simple_types<NvFaceInfo *> >,1><>, COMDAT
; _this$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1331 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	eax, ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1331 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	ret	4
??$?0$$V@?$_Compressed_pair@V?$xalloc@PAVNvFaceInfo@@@@V?$_Vector_val@U?$_Simple_types@PAVNvFaceInfo@@@std@@@std@@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<xalloc<NvFaceInfo *>,std::_Vector_val<std::_Simple_types<NvFaceInfo *> >,1>::_Compressed_pair<xalloc<NvFaceInfo *>,std::_Vector_val<std::_Simple_types<NvFaceInfo *> >,1><>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef
;	COMDAT ??$addressof@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@H@std@@@0@AAV10@@Z
_TEXT	SEGMENT
??$addressof@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@H@std@@@0@AAV10@@Z PROC ; std::addressof<std::_Vector_val<std::_Simple_types<int> > >, COMDAT
; __Val$ = ecx

; 253  :     return __builtin_addressof(_Val);

	mov	eax, ecx

; 254  : }

	ret	0
??$addressof@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@H@std@@@0@AAV10@@Z ENDP ; std::addressof<std::_Vector_val<std::_Simple_types<int> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$?0$$V@?$_Compressed_pair@V?$xalloc@H@@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$?0$$V@?$_Compressed_pair@V?$xalloc@H@@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<xalloc<int>,std::_Vector_val<std::_Simple_types<int> >,1>::_Compressed_pair<xalloc<int>,std::_Vector_val<std::_Simple_types<int> >,1><>, COMDAT
; _this$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1331 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	eax, ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1331 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	ret	4
??$?0$$V@?$_Compressed_pair@V?$xalloc@H@@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<xalloc<int>,std::_Vector_val<std::_Simple_types<int> >,1>::_Compressed_pair<xalloc<int>,std::_Vector_val<std::_Simple_types<int> >,1><>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Destroy_range@V?$xalloc@PAVNvStripInfo@@@@@std@@YAXPAPAVNvStripInfo@@QAPAV1@AAV?$xalloc@PAVNvStripInfo@@@@@Z
_TEXT	SEGMENT
__Al$dead$ = 8						; size = 4
??$_Destroy_range@V?$xalloc@PAVNvStripInfo@@@@@std@@YAXPAPAVNvStripInfo@@QAPAV1@AAV?$xalloc@PAVNvStripInfo@@@@@Z PROC ; std::_Destroy_range<xalloc<NvStripInfo *> >, COMDAT
; __First$dead$ = ecx
; __Last$dead$ = edx

; 901  :     // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
; 902  :     using _Ty = typename _Alloc::value_type;
; 903  :     if constexpr (!conjunction_v<is_trivially_destructible<_Ty>, _Uses_default_destroy<_Alloc, _Ty*>>) {
; 904  :         for (; _First != _Last; ++_First) {
; 905  :             allocator_traits<_Alloc>::destroy(_Al, _Unfancy(_First));
; 906  :         }
; 907  :     }
; 908  : }

	ret	0
??$_Destroy_range@V?$xalloc@PAVNvStripInfo@@@@@std@@YAXPAPAVNvStripInfo@@QAPAV1@AAV?$xalloc@PAVNvStripInfo@@@@@Z ENDP ; std::_Destroy_range<xalloc<NvStripInfo *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
;	COMDAT ??$xr_free@PAVNvStripInfo@@@@YAXAAPAPAVNvStripInfo@@@Z
_TEXT	SEGMENT
??$xr_free@PAVNvStripInfo@@@@YAXAAPAPAVNvStripInfo@@@Z PROC ; xr_free<NvStripInfo *>, COMDAT
; _P$ = ecx

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	push	esi
	mov	esi, ecx
	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN2@xr_free
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
	mov	DWORD PTR [esi], 0
$LN2@xr_free:
	pop	esi
	ret	0
??$xr_free@PAVNvStripInfo@@@@YAXAAPAPAVNvStripInfo@@@Z ENDP ; xr_free<NvStripInfo *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Destroy_range@V?$xalloc@PAVNvFaceInfo@@@@@std@@YAXPAPAVNvFaceInfo@@QAPAV1@AAV?$xalloc@PAVNvFaceInfo@@@@@Z
_TEXT	SEGMENT
__Al$dead$ = 8						; size = 4
??$_Destroy_range@V?$xalloc@PAVNvFaceInfo@@@@@std@@YAXPAPAVNvFaceInfo@@QAPAV1@AAV?$xalloc@PAVNvFaceInfo@@@@@Z PROC ; std::_Destroy_range<xalloc<NvFaceInfo *> >, COMDAT
; __First$dead$ = ecx
; __Last$dead$ = edx

; 901  :     // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
; 902  :     using _Ty = typename _Alloc::value_type;
; 903  :     if constexpr (!conjunction_v<is_trivially_destructible<_Ty>, _Uses_default_destroy<_Alloc, _Ty*>>) {
; 904  :         for (; _First != _Last; ++_First) {
; 905  :             allocator_traits<_Alloc>::destroy(_Al, _Unfancy(_First));
; 906  :         }
; 907  :     }
; 908  : }

	ret	0
??$_Destroy_range@V?$xalloc@PAVNvFaceInfo@@@@@std@@YAXPAPAVNvFaceInfo@@QAPAV1@AAV?$xalloc@PAVNvFaceInfo@@@@@Z ENDP ; std::_Destroy_range<xalloc<NvFaceInfo *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
;	COMDAT ??$xr_free@PAVNvFaceInfo@@@@YAXAAPAPAVNvFaceInfo@@@Z
_TEXT	SEGMENT
??$xr_free@PAVNvFaceInfo@@@@YAXAAPAPAVNvFaceInfo@@@Z PROC ; xr_free<NvFaceInfo *>, COMDAT
; _P$ = ecx

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	push	esi
	mov	esi, ecx
	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN2@xr_free
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
	mov	DWORD PTR [esi], 0
$LN2@xr_free:
	pop	esi
	ret	0
??$xr_free@PAVNvFaceInfo@@@@YAXAAPAPAVNvFaceInfo@@@Z ENDP ; xr_free<NvFaceInfo *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
;	COMDAT ??R?$xr_special_free@$0A@VNvStripInfo@@@@QAEXAAPAVNvStripInfo@@@Z
_TEXT	SEGMENT
_ptr$ = 8						; size = 4
??R?$xr_special_free@$0A@VNvStripInfo@@@@QAEXAAPAVNvStripInfo@@@Z PROC ; xr_special_free<0,NvStripInfo>::operator(), COMDAT
; _this$dead$ = ecx

; 142  : 	{

	push	ebx
	mov	ebx, DWORD PTR _ptr$[esp]
	push	esi

; 143  : 		ptr->~T			();

	mov	esi, DWORD PTR [ebx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [esi+12]
	test	eax, eax
	je	SHORT $LN13@operator
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi+12], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+16], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+20], 0
	mov	esi, DWORD PTR [ebx]
$LN13@operator:
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h

; 144  : 		Memory.mem_free	(ptr);

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	esi
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
	pop	esi
	pop	ebx

; 145  : 	}

	ret	4
??R?$xr_special_free@$0A@VNvStripInfo@@@@QAEXAAPAVNvStripInfo@@@Z ENDP ; xr_special_free<0,NvStripInfo>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
;	COMDAT ??R?$xr_special_free@$0A@VNvFaceInfo@@@@QAEXAAPAVNvFaceInfo@@@Z
_TEXT	SEGMENT
_ptr$ = 8						; size = 4
??R?$xr_special_free@$0A@VNvFaceInfo@@@@QAEXAAPAVNvFaceInfo@@@Z PROC ; xr_special_free<0,NvFaceInfo>::operator(), COMDAT
; _this$dead$ = ecx

; 143  : 		ptr->~T			();
; 144  : 		Memory.mem_free	(ptr);

	mov	eax, DWORD PTR _ptr$[esp-4]
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	DWORD PTR [eax]
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z

; 145  : 	}

	ret	4
??R?$xr_special_free@$0A@VNvFaceInfo@@@@QAEXAAPAVNvFaceInfo@@@Z ENDP ; xr_special_free<0,NvFaceInfo>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Orphan_range@?$vector@UPrimitiveGroup@@V?$xalloc@UPrimitiveGroup@@@@@std@@ABEXPAUPrimitiveGroup@@0@Z
_TEXT	SEGMENT
___formal$dead$ = 8					; size = 4
___formal$dead$ = 12					; size = 4
?_Orphan_range@?$vector@UPrimitiveGroup@@V?$xalloc@UPrimitiveGroup@@@@@std@@ABEXPAUPrimitiveGroup@@0@Z PROC ; std::vector<PrimitiveGroup,xalloc<PrimitiveGroup> >::_Orphan_range, COMDAT
; _this$dead$ = ecx

; 1801 :     _CONSTEXPR20_CONTAINER void _Orphan_range(pointer, pointer) const {}

	ret	8
?_Orphan_range@?$vector@UPrimitiveGroup@@V?$xalloc@UPrimitiveGroup@@@@@std@@ABEXPAUPrimitiveGroup@@0@Z ENDP ; std::vector<PrimitiveGroup,xalloc<PrimitiveGroup> >::_Orphan_range
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Destroy@?$vector@UPrimitiveGroup@@V?$xalloc@UPrimitiveGroup@@@@@std@@AAEXPAUPrimitiveGroup@@0@Z
_TEXT	SEGMENT
__First$dead$ = 8					; size = 4
__Last$dead$ = 12					; size = 4
?_Destroy@?$vector@UPrimitiveGroup@@V?$xalloc@UPrimitiveGroup@@@@@std@@AAEXPAUPrimitiveGroup@@0@Z PROC ; std::vector<PrimitiveGroup,xalloc<PrimitiveGroup> >::_Destroy, COMDAT
; _this$dead$ = ecx

; 1666 :         // destroy [_First, _Last) using allocator
; 1667 :         _Destroy_range(_First, _Last, _Getal());
; 1668 :     }

	ret	8
?_Destroy@?$vector@UPrimitiveGroup@@V?$xalloc@UPrimitiveGroup@@@@@std@@AAEXPAUPrimitiveGroup@@0@Z ENDP ; std::vector<PrimitiveGroup,xalloc<PrimitiveGroup> >::_Destroy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStrip.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Ufill@?$vector@UPrimitiveGroup@@V?$xalloc@UPrimitiveGroup@@@@@std@@AAEPAUPrimitiveGroup@@PAU3@IU_Value_init_tag@2@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Count$ = 12						; size = 4
___formal$ = 16						; size = 1
?_Ufill@?$vector@UPrimitiveGroup@@V?$xalloc@UPrimitiveGroup@@@@@std@@AAEPAUPrimitiveGroup@@PAU3@IU_Value_init_tag@2@@Z PROC ; std::vector<PrimitiveGroup,xalloc<PrimitiveGroup> >::_Ufill, COMDAT
; _this$dead$ = ecx

; 1634 :         // fill raw _Dest with _Count value-initialized objects, using allocator
; 1635 :         return _Uninitialized_value_construct_n(_Dest, _Count, _Getal());

	mov	ecx, DWORD PTR __Count$[esp-4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	eax, DWORD PTR __Dest$[esp-4]

; 1813 :     for (; 0 < _Count; --_Count) {

	test	ecx, ecx
	je	SHORT $LN5@Ufill
	npad	4
$LL6@Ufill:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStrip.h

; 33   : 	PrimitiveGroup() : type(PT_STRIP), numIndices(0), indices(NULL) {}

	mov	DWORD PTR [eax], 1
	mov	DWORD PTR [eax+4], 0
	mov	DWORD PTR [eax+8], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1621 :         ++_Last;

	add	eax, 12					; 0000000cH

; 1813 :     for (; 0 < _Count; --_Count) {

	sub	ecx, 1
	jne	SHORT $LL6@Ufill
$LN5@Ufill:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1636 :     }

	ret	12					; 0000000cH
?_Ufill@?$vector@UPrimitiveGroup@@V?$xalloc@UPrimitiveGroup@@@@@std@@AAEPAUPrimitiveGroup@@PAU3@IU_Value_init_tag@2@@Z ENDP ; std::vector<PrimitiveGroup,xalloc<PrimitiveGroup> >::_Ufill
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@PAVNvStripInfo@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Vector_val@U?$_Simple_types@PAVNvStripInfo@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<std::_Simple_types<NvStripInfo *> >::_Vector_val<std::_Simple_types<NvStripInfo *> >, COMDAT
; _this$ = ecx

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx], 0
	mov	eax, ecx
	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0
	ret	0
??0?$_Vector_val@U?$_Simple_types@PAVNvStripInfo@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<std::_Simple_types<NvStripInfo *> >::_Vector_val<std::_Simple_types<NvStripInfo *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ??0?$xalloc@PAVNvStripInfo@@@@QAE@XZ
_TEXT	SEGMENT
??0?$xalloc@PAVNvStripInfo@@@@QAE@XZ PROC		; xalloc<NvStripInfo *>::xalloc<NvStripInfo *>, COMDAT
; _this$ = ecx

; 76   : 													xalloc			()										{	}

	mov	eax, ecx
	ret	0
??0?$xalloc@PAVNvStripInfo@@@@QAE@XZ ENDP		; xalloc<NvStripInfo *>::xalloc<NvStripInfo *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@PAVNvFaceInfo@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Vector_val@U?$_Simple_types@PAVNvFaceInfo@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<std::_Simple_types<NvFaceInfo *> >::_Vector_val<std::_Simple_types<NvFaceInfo *> >, COMDAT
; _this$ = ecx

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx], 0
	mov	eax, ecx
	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0
	ret	0
??0?$_Vector_val@U?$_Simple_types@PAVNvFaceInfo@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<std::_Simple_types<NvFaceInfo *> >::_Vector_val<std::_Simple_types<NvFaceInfo *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ??0?$xalloc@PAVNvFaceInfo@@@@QAE@XZ
_TEXT	SEGMENT
??0?$xalloc@PAVNvFaceInfo@@@@QAE@XZ PROC		; xalloc<NvFaceInfo *>::xalloc<NvFaceInfo *>, COMDAT
; _this$ = ecx

; 76   : 													xalloc			()										{	}

	mov	eax, ecx
	ret	0
??0?$xalloc@PAVNvFaceInfo@@@@QAE@XZ ENDP		; xalloc<NvFaceInfo *>::xalloc<NvFaceInfo *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ??0?$xalloc@H@@QAE@XZ
_TEXT	SEGMENT
??0?$xalloc@H@@QAE@XZ PROC				; xalloc<int>::xalloc<int>, COMDAT
; _this$ = ecx

; 76   : 													xalloc			()										{	}

	mov	eax, ecx
	ret	0
??0?$xalloc@H@@QAE@XZ ENDP				; xalloc<int>::xalloc<int>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??_GNvStripInfo@@QAEPAXI@Z
_TEXT	SEGMENT
___flags$dead$ = 8					; size = 4
??_GNvStripInfo@@QAEPAXI@Z PROC				; NvStripInfo::`scalar deleting destructor', COMDAT
; _this$ = ecx

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	push	esi
	mov	esi, ecx
	mov	eax, DWORD PTR [esi+12]
	test	eax, eax
	je	SHORT $LN18@scalar
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi+12], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+16], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+20], 0
$LN18@scalar:
	mov	eax, esi
	pop	esi
	ret	4
??_GNvStripInfo@@QAEPAXI@Z ENDP				; NvStripInfo::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??1NvStripInfo@@QAE@XZ
_TEXT	SEGMENT
??1NvStripInfo@@QAE@XZ PROC				; NvStripInfo::~NvStripInfo, COMDAT
; _this$ = ecx

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	push	esi
	mov	esi, ecx
	mov	eax, DWORD PTR [esi+12]
	test	eax, eax
	je	SHORT $LN8@NvStripInf
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi+12], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+16], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+20], 0
$LN8@NvStripInf:
	pop	esi
	ret	0
??1NvStripInfo@@QAE@XZ ENDP				; NvStripInfo::~NvStripInfo
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Getal@?$vector@UPrimitiveGroup@@V?$xalloc@UPrimitiveGroup@@@@@std@@AAEAAV?$xalloc@UPrimitiveGroup@@@@XZ
_TEXT	SEGMENT
?_Getal@?$vector@UPrimitiveGroup@@V?$xalloc@UPrimitiveGroup@@@@@std@@AAEAAV?$xalloc@UPrimitiveGroup@@@@XZ PROC ; std::vector<PrimitiveGroup,xalloc<PrimitiveGroup> >::_Getal, COMDAT
; _this$ = ecx

; 1805 :         return _Mypair._Get_first();

	mov	eax, ecx

; 1806 :     }

	ret	0
?_Getal@?$vector@UPrimitiveGroup@@V?$xalloc@UPrimitiveGroup@@@@@std@@AAEAAV?$xalloc@UPrimitiveGroup@@@@XZ ENDP ; std::vector<PrimitiveGroup,xalloc<PrimitiveGroup> >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$xalloc@UPrimitiveGroup@@@@V?$_Vector_val@U?$_Simple_types@UPrimitiveGroup@@@std@@@std@@$00@std@@QAEAAV?$xalloc@UPrimitiveGroup@@@@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@V?$xalloc@UPrimitiveGroup@@@@V?$_Vector_val@U?$_Simple_types@UPrimitiveGroup@@@std@@@std@@$00@std@@QAEAAV?$xalloc@UPrimitiveGroup@@@@XZ PROC ; std::_Compressed_pair<xalloc<PrimitiveGroup>,std::_Vector_val<std::_Simple_types<PrimitiveGroup> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 1339 :         return *this;

	mov	eax, ecx

; 1340 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$xalloc@UPrimitiveGroup@@@@V?$_Vector_val@U?$_Simple_types@UPrimitiveGroup@@@std@@@std@@$00@std@@QAEAAV?$xalloc@UPrimitiveGroup@@@@XZ ENDP ; std::_Compressed_pair<xalloc<PrimitiveGroup>,std::_Vector_val<std::_Simple_types<PrimitiveGroup> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UPrimitiveGroup@@V?$xalloc@UPrimitiveGroup@@@@@std@@AAEXIABU_Value_init_tag@1@@Z
_TEXT	SEGMENT
__Backout$2 = -36					; size = 12
__UFirst$3 = -24					; size = 4
__Newvec$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__ULast$1$ = 8						; size = 4
__Oldsize$1$ = 8					; size = 4
__Newsize$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UPrimitiveGroup@@V?$xalloc@UPrimitiveGroup@@@@@std@@AAEXIABU_Value_init_tag@1@@Z PROC ; std::vector<PrimitiveGroup,xalloc<PrimitiveGroup> >::_Resize_reallocate<std::_Value_init_tag>, COMDAT
; _this$ = ecx

; 1216 :     _CONSTEXPR20_CONTAINER void _Resize_reallocate(const size_type _Newsize, const _Ty2& _Val) {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UPrimitiveGroup@@V?$xalloc@UPrimitiveGroup@@@@@std@@AAEXIABU_Value_init_tag@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 24					; 00000018H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	edi, ecx

; 1217 :         if (_Newsize > max_size()) {

	mov	ebx, DWORD PTR __Newsize$[ebp]
	cmp	ebx, 357913941				; 15555555H
	ja	$LN52@Resize_rea

; 1219 :         }
; 1220 : 
; 1221 :         auto& _My_data    = _Mypair._Myval2;
; 1222 :         pointer& _Myfirst = _My_data._Myfirst;
; 1223 :         pointer& _Mylast  = _My_data._Mylast;
; 1224 : 
; 1225 :         const auto _Oldsize          = static_cast<size_type>(_Mylast - _Myfirst);

	mov	eax, DWORD PTR [edi+4]
	sub	eax, DWORD PTR [edi]
	sar	eax, 2
	imul	eax, eax, -1431655765
	mov	DWORD PTR __Oldsize$1$[ebp], eax

; 1546 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	eax, DWORD PTR [edi+8]
	sub	eax, DWORD PTR [edi]
	sar	eax, 2
	imul	edx, eax, -1431655765

; 1675 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	ecx, edx
	shr	ecx, 1
	mov	eax, 357913941				; 15555555H
	sub	eax, ecx
	cmp	edx, eax
	jbe	SHORT $LN10@Resize_rea

; 1676 :             return _Max; // geometric growth would overflow

	mov	esi, 357913941				; 15555555H
	jmp	SHORT $LN11@Resize_rea
$LN10@Resize_rea:

; 1677 :         }
; 1678 : 
; 1679 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	lea	esi, DWORD PTR [ecx+edx]

; 1680 : 
; 1681 :         if (_Geometric < _Newsize) {

	cmp	esi, ebx
	cmovb	esi, ebx
$LN11@Resize_rea:
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	lea	eax, DWORD PTR [esi+esi*2]
	shl	eax, 2
	push	eax
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1228 :         const pointer _Newvec         = _Getal().allocate(_Newcapacity);

	mov	edx, eax
	mov	DWORD PTR __Newvec$[ebp], edx

; 1229 :         const pointer _Appended_first = _Newvec + _Oldsize;

	mov	eax, DWORD PTR __Oldsize$1$[ebp]
	lea	ecx, DWORD PTR [eax+eax*2]
	lea	ecx, DWORD PTR [edx+ecx*4]

; 1230 :         pointer _Appended_last        = _Appended_first;
; 1231 : 
; 1232 :         _TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 1233 :         _Appended_last = _Ufill(_Appended_first, _Newsize - _Oldsize, _Val);

	mov	eax, DWORD PTR __Val$[ebp]
	movzx	eax, BYTE PTR [eax]
	push	eax
	mov	eax, ebx
	sub	eax, DWORD PTR __Oldsize$1$[ebp]
	push	eax
	push	ecx
	call	?_Ufill@?$vector@UPrimitiveGroup@@V?$xalloc@UPrimitiveGroup@@@@@std@@AAEPAUPrimitiveGroup@@PAU3@IU_Value_init_tag@2@@Z ; std::vector<PrimitiveGroup,xalloc<PrimitiveGroup> >::_Ufill

; 1234 :         _Umove_if_noexcept(_Myfirst, _Mylast, _Newvec);

	mov	eax, DWORD PTR [edi+4]
	mov	DWORD PTR __ULast$1$[ebp], eax
	mov	ecx, DWORD PTR [edi]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1703 :     auto _UFirst      = _Get_unwrapped(_First);

	mov	DWORD PTR __UFirst$3[ebp], ecx

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	DWORD PTR __Backout$2[ebp], edx
	mov	DWORD PTR __Backout$2[ebp+4], edx
	mov	DWORD PTR __Backout$2[ebp+8], edi
	npad	2
$LL26@Resize_rea:

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	ecx, eax
	je	SHORT $LN25@Resize_rea
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], eax
	mov	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+8], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1621 :         ++_Last;

	add	edx, 12					; 0000000cH
	mov	DWORD PTR __Backout$2[ebp+4], edx

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	add	ecx, 12					; 0000000cH
	mov	DWORD PTR __UFirst$3[ebp], ecx
	mov	eax, DWORD PTR __ULast$1$[ebp]
	jmp	SHORT $LL26@Resize_rea
$LN25@Resize_rea:

; 1625 :         _First = _Last;

	mov	DWORD PTR __Backout$2[ebp], edx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
	mov	DWORD PTR __$EHRec$[ebp+12], -1

; 1732 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [edi]
	test	eax, eax
	je	SHORT $LN44@Resize_rea
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	push	eax
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN44@Resize_rea:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1737 :         _Myfirst = _Newvec;

	mov	ecx, DWORD PTR __Newvec$[ebp]
	mov	DWORD PTR [edi], ecx

; 1738 :         _Mylast  = _Newvec + _Newsize;

	lea	eax, DWORD PTR [ebx+ebx*2]
	lea	eax, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR [edi+4], eax

; 1739 :         _Myend   = _Newvec + _Newcapacity;

	lea	eax, DWORD PTR [esi+esi*2]
	lea	eax, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR [edi+8], eax

; 1239 :         _CATCH_END
; 1240 : 
; 1241 :         _Change_array(_Newvec, _Newsize, _Newcapacity);
; 1242 :     }

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
__catch$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UPrimitiveGroup@@V?$xalloc@UPrimitiveGroup@@@@@std@@AAEXIABU_Value_init_tag@1@@Z$0:

; 1235 :         _CATCH_ALL
; 1236 :         _Destroy(_Appended_first, _Appended_last);
; 1237 :         _Getal().deallocate(_Newvec, _Newcapacity);

	push	ecx
	push	DWORD PTR __Newvec$[ebp]
	call	?deallocate@?$xalloc@UPrimitiveGroup@@@@QBEXPAUPrimitiveGroup@@I@Z ; xalloc<PrimitiveGroup>::deallocate

; 1238 :         _RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$LN52@Resize_rea:

; 1218 :             _Xlength();

	call	?_Xlength@?$vector@UPrimitiveGroup@@V?$xalloc@UPrimitiveGroup@@@@@std@@CAXXZ ; std::vector<PrimitiveGroup,xalloc<PrimitiveGroup> >::_Xlength
$LN50@Resize_rea:
	int	3
	int	3
	int	3
	int	3
	int	3
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UPrimitiveGroup@@V?$xalloc@UPrimitiveGroup@@@@@std@@AAEXIABU_Value_init_tag@1@@Z:
	npad	1
	npad	1
	mov	eax, OFFSET __ehfuncinfo$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UPrimitiveGroup@@V?$xalloc@UPrimitiveGroup@@@@@std@@AAEXIABU_Value_init_tag@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UPrimitiveGroup@@V?$xalloc@UPrimitiveGroup@@@@@std@@AAEXIABU_Value_init_tag@1@@Z ENDP ; std::vector<PrimitiveGroup,xalloc<PrimitiveGroup> >::_Resize_reallocate<std::_Value_init_tag>
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef
;	COMDAT ??$_Unfancy@PAVNvStripInfo@@@std@@YAPAPAVNvStripInfo@@PAPAV1@@Z
_TEXT	SEGMENT
??$_Unfancy@PAVNvStripInfo@@@std@@YAPAPAVNvStripInfo@@PAPAV1@@Z PROC ; std::_Unfancy<NvStripInfo *>, COMDAT
; __Ptr$ = ecx

; 266  :     return _Ptr;

	mov	eax, ecx

; 267  : }

	ret	0
??$_Unfancy@PAVNvStripInfo@@@std@@YAPAPAVNvStripInfo@@PAPAV1@@Z ENDP ; std::_Unfancy<NvStripInfo *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$destroy@PAVNvStripInfo@@@?$_Normal_allocator_traits@V?$xalloc@PAVNvStripInfo@@@@@std@@SAXAAV?$xalloc@PAVNvStripInfo@@@@PAPAVNvStripInfo@@@Z
_TEXT	SEGMENT
??$destroy@PAVNvStripInfo@@@?$_Normal_allocator_traits@V?$xalloc@PAVNvStripInfo@@@@@std@@SAXAAV?$xalloc@PAVNvStripInfo@@@@PAPAVNvStripInfo@@@Z PROC ; std::_Normal_allocator_traits<xalloc<NvStripInfo *> >::destroy<NvStripInfo *>, COMDAT
; __Al$dead$ = ecx
; __Ptr$dead$ = edx

; 579  :         if constexpr (_Uses_default_destroy<_Alloc, _Ty*>::value) {
; 580  : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 581  :             _STD destroy_at(_Ptr);
; 582  : #else // __cpp_lib_constexpr_dynamic_alloc
; 583  :             _Ptr->~_Ty();
; 584  : #endif // __cpp_lib_constexpr_dynamic_alloc
; 585  :         } else {
; 586  :             _Al.destroy(_Ptr);
; 587  :         }
; 588  :     }

	ret	0
??$destroy@PAVNvStripInfo@@@?$_Normal_allocator_traits@V?$xalloc@PAVNvStripInfo@@@@@std@@SAXAAV?$xalloc@PAVNvStripInfo@@@@PAPAVNvStripInfo@@@Z ENDP ; std::_Normal_allocator_traits<xalloc<NvStripInfo *> >::destroy<NvStripInfo *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef
;	COMDAT ??$_Unfancy@PAVNvFaceInfo@@@std@@YAPAPAVNvFaceInfo@@PAPAV1@@Z
_TEXT	SEGMENT
??$_Unfancy@PAVNvFaceInfo@@@std@@YAPAPAVNvFaceInfo@@PAPAV1@@Z PROC ; std::_Unfancy<NvFaceInfo *>, COMDAT
; __Ptr$ = ecx

; 266  :     return _Ptr;

	mov	eax, ecx

; 267  : }

	ret	0
??$_Unfancy@PAVNvFaceInfo@@@std@@YAPAPAVNvFaceInfo@@PAPAV1@@Z ENDP ; std::_Unfancy<NvFaceInfo *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$destroy@PAVNvFaceInfo@@@?$_Normal_allocator_traits@V?$xalloc@PAVNvFaceInfo@@@@@std@@SAXAAV?$xalloc@PAVNvFaceInfo@@@@PAPAVNvFaceInfo@@@Z
_TEXT	SEGMENT
??$destroy@PAVNvFaceInfo@@@?$_Normal_allocator_traits@V?$xalloc@PAVNvFaceInfo@@@@@std@@SAXAAV?$xalloc@PAVNvFaceInfo@@@@PAPAVNvFaceInfo@@@Z PROC ; std::_Normal_allocator_traits<xalloc<NvFaceInfo *> >::destroy<NvFaceInfo *>, COMDAT
; __Al$dead$ = ecx
; __Ptr$dead$ = edx

; 579  :         if constexpr (_Uses_default_destroy<_Alloc, _Ty*>::value) {
; 580  : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 581  :             _STD destroy_at(_Ptr);
; 582  : #else // __cpp_lib_constexpr_dynamic_alloc
; 583  :             _Ptr->~_Ty();
; 584  : #endif // __cpp_lib_constexpr_dynamic_alloc
; 585  :         } else {
; 586  :             _Al.destroy(_Ptr);
; 587  :         }
; 588  :     }

	ret	0
??$destroy@PAVNvFaceInfo@@@?$_Normal_allocator_traits@V?$xalloc@PAVNvFaceInfo@@@@@std@@SAXAAV?$xalloc@PAVNvFaceInfo@@@@PAPAVNvFaceInfo@@@Z ENDP ; std::_Normal_allocator_traits<xalloc<NvFaceInfo *> >::destroy<NvFaceInfo *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Destroy_range@V?$xalloc@UPrimitiveGroup@@@@@std@@YAXPAUPrimitiveGroup@@QAU1@AAV?$xalloc@UPrimitiveGroup@@@@@Z
_TEXT	SEGMENT
__Al$dead$ = 8						; size = 4
??$_Destroy_range@V?$xalloc@UPrimitiveGroup@@@@@std@@YAXPAUPrimitiveGroup@@QAU1@AAV?$xalloc@UPrimitiveGroup@@@@@Z PROC ; std::_Destroy_range<xalloc<PrimitiveGroup> >, COMDAT
; __First$dead$ = ecx
; __Last$dead$ = edx

; 901  :     // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
; 902  :     using _Ty = typename _Alloc::value_type;
; 903  :     if constexpr (!conjunction_v<is_trivially_destructible<_Ty>, _Uses_default_destroy<_Alloc, _Ty*>>) {
; 904  :         for (; _First != _Last; ++_First) {
; 905  :             allocator_traits<_Alloc>::destroy(_Al, _Unfancy(_First));
; 906  :         }
; 907  :     }
; 908  : }

	ret	0
??$_Destroy_range@V?$xalloc@UPrimitiveGroup@@@@@std@@YAXPAUPrimitiveGroup@@QAU1@AAV?$xalloc@UPrimitiveGroup@@@@@Z ENDP ; std::_Destroy_range<xalloc<PrimitiveGroup> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStrip.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Uninitialized_value_construct_n@V?$xalloc@UPrimitiveGroup@@@@@std@@YAPAUPrimitiveGroup@@PAU1@IAAV?$xalloc@UPrimitiveGroup@@@@@Z
_TEXT	SEGMENT
__Al$dead$ = 8						; size = 4
??$_Uninitialized_value_construct_n@V?$xalloc@UPrimitiveGroup@@@@@std@@YAPAUPrimitiveGroup@@PAU1@IAAV?$xalloc@UPrimitiveGroup@@@@@Z PROC ; std::_Uninitialized_value_construct_n<xalloc<PrimitiveGroup> >, COMDAT
; __First$ = ecx
; __Count$ = edx

; 1799 :     // value-initialize _Count objects to raw _First, using _Al
; 1800 :     using _Ptrty = typename _Alloc::value_type*;
; 1801 :     if constexpr (_Use_memset_value_construct_v<_Ptrty> && _Uses_default_construct<_Alloc, _Ptrty>::value) {
; 1802 : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 1803 :         if (!_STD is_constant_evaluated())
; 1804 : #endif // __cpp_lib_constexpr_dynamic_alloc
; 1805 :         {
; 1806 :             auto _PFirst = _Unfancy(_First);
; 1807 :             _Zero_range(_PFirst, _PFirst + _Count);
; 1808 :             return _First + _Count;
; 1809 :         }
; 1810 :     }
; 1811 : 
; 1812 :     _Uninitialized_backout_al<_Alloc> _Backout{_First, _Al};
; 1813 :     for (; 0 < _Count; --_Count) {

	test	edx, edx
	je	SHORT $LN20@Uninitiali
	npad	12
$LL4@Uninitiali:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStrip.h

; 33   : 	PrimitiveGroup() : type(PT_STRIP), numIndices(0), indices(NULL) {}

	mov	DWORD PTR [ecx], 1
	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1621 :         ++_Last;

	add	ecx, 12					; 0000000cH

; 1799 :     // value-initialize _Count objects to raw _First, using _Al
; 1800 :     using _Ptrty = typename _Alloc::value_type*;
; 1801 :     if constexpr (_Use_memset_value_construct_v<_Ptrty> && _Uses_default_construct<_Alloc, _Ptrty>::value) {
; 1802 : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 1803 :         if (!_STD is_constant_evaluated())
; 1804 : #endif // __cpp_lib_constexpr_dynamic_alloc
; 1805 :         {
; 1806 :             auto _PFirst = _Unfancy(_First);
; 1807 :             _Zero_range(_PFirst, _PFirst + _Count);
; 1808 :             return _First + _Count;
; 1809 :         }
; 1810 :     }
; 1811 : 
; 1812 :     _Uninitialized_backout_al<_Alloc> _Backout{_First, _Al};
; 1813 :     for (; 0 < _Count; --_Count) {

	sub	edx, 1
	jne	SHORT $LL4@Uninitiali
$LN20@Uninitiali:

; 1814 :         _Backout._Emplace_back();
; 1815 :     }
; 1816 : 
; 1817 :     return _Backout._Release();
; 1818 : }

	mov	eax, ecx
	ret	0
??$_Uninitialized_value_construct_n@V?$xalloc@UPrimitiveGroup@@@@@std@@YAPAUPrimitiveGroup@@PAU1@IAAV?$xalloc@UPrimitiveGroup@@@@@Z ENDP ; std::_Uninitialized_value_construct_n<xalloc<PrimitiveGroup> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Release@?$_Uninitialized_backout_al@V?$xalloc@UPrimitiveGroup@@@@@std@@QAEPAUPrimitiveGroup@@XZ
_TEXT	SEGMENT
?_Release@?$_Uninitialized_backout_al@V?$xalloc@UPrimitiveGroup@@@@@std@@QAEPAUPrimitiveGroup@@XZ PROC ; std::_Uninitialized_backout_al<xalloc<PrimitiveGroup> >::_Release, COMDAT
; _this$ = ecx

; 1625 :         _First = _Last;

	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [ecx], eax

; 1626 :         return _Last;
; 1627 :     }

	ret	0
?_Release@?$_Uninitialized_backout_al@V?$xalloc@UPrimitiveGroup@@@@@std@@QAEPAUPrimitiveGroup@@XZ ENDP ; std::_Uninitialized_backout_al<xalloc<PrimitiveGroup> >::_Release
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??1?$_Uninitialized_backout_al@V?$xalloc@UPrimitiveGroup@@@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Uninitialized_backout_al@V?$xalloc@UPrimitiveGroup@@@@@std@@QAE@XZ PROC ; std::_Uninitialized_backout_al<xalloc<PrimitiveGroup> >::~_Uninitialized_backout_al<xalloc<PrimitiveGroup> >, COMDAT
; _this$ = ecx

; 1615 :         _Destroy_range(_First, _Last, _Al);
; 1616 :     }

	ret	0
??1?$_Uninitialized_backout_al@V?$xalloc@UPrimitiveGroup@@@@@std@@QAE@XZ ENDP ; std::_Uninitialized_backout_al<xalloc<PrimitiveGroup> >::~_Uninitialized_backout_al<xalloc<PrimitiveGroup> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??0?$_Uninitialized_backout_al@V?$xalloc@UPrimitiveGroup@@@@@std@@QAE@PAUPrimitiveGroup@@AAV?$xalloc@UPrimitiveGroup@@@@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Al_$ = 12						; size = 4
??0?$_Uninitialized_backout_al@V?$xalloc@UPrimitiveGroup@@@@@std@@QAE@PAUPrimitiveGroup@@AAV?$xalloc@UPrimitiveGroup@@@@@Z PROC ; std::_Uninitialized_backout_al<xalloc<PrimitiveGroup> >::_Uninitialized_backout_al<xalloc<PrimitiveGroup> >, COMDAT
; _this$ = ecx

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	eax, DWORD PTR __Dest$[esp-4]
	mov	DWORD PTR [ecx], eax
	mov	DWORD PTR [ecx+4], eax
	mov	eax, DWORD PTR __Al_$[esp-4]
	mov	DWORD PTR [ecx+8], eax
	mov	eax, ecx
	ret	8
??0?$_Uninitialized_backout_al@V?$xalloc@UPrimitiveGroup@@@@@std@@QAE@PAUPrimitiveGroup@@AAV?$xalloc@UPrimitiveGroup@@@@@Z ENDP ; std::_Uninitialized_backout_al<xalloc<PrimitiveGroup> >::_Uninitialized_backout_al<xalloc<PrimitiveGroup> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Xlength@?$vector@UPrimitiveGroup@@V?$xalloc@UPrimitiveGroup@@@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@UPrimitiveGroup@@V?$xalloc@UPrimitiveGroup@@@@@std@@CAXXZ PROC ; std::vector<PrimitiveGroup,xalloc<PrimitiveGroup> >::_Xlength, COMDAT

; 1761 :         _Xlength_error("vector too long");

	push	OFFSET ??_C@_0BA@FOIKENOD@vector?5too?5long@
	call	DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN3@Xlength:
	int	3
?_Xlength@?$vector@UPrimitiveGroup@@V?$xalloc@UPrimitiveGroup@@@@@std@@CAXXZ ENDP ; std::vector<PrimitiveGroup,xalloc<PrimitiveGroup> >::_Xlength
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Change_array@?$vector@UPrimitiveGroup@@V?$xalloc@UPrimitiveGroup@@@@@std@@AAEXQAUPrimitiveGroup@@II@Z
_TEXT	SEGMENT
__Newvec$ = 8						; size = 4
__Newsize$ = 12						; size = 4
__Newcapacity$ = 16					; size = 4
?_Change_array@?$vector@UPrimitiveGroup@@V?$xalloc@UPrimitiveGroup@@@@@std@@AAEXQAUPrimitiveGroup@@II@Z PROC ; std::vector<PrimitiveGroup,xalloc<PrimitiveGroup> >::_Change_array, COMDAT
; _this$ = ecx

; 1723 :         const pointer _Newvec, const size_type _Newsize, const size_type _Newcapacity) {

	push	esi
	mov	esi, ecx

; 1724 :         // orphan all iterators, discard old array, acquire new array
; 1725 :         auto& _My_data    = _Mypair._Myval2;
; 1726 :         pointer& _Myfirst = _My_data._Myfirst;
; 1727 :         pointer& _Mylast  = _My_data._Mylast;
; 1728 :         pointer& _Myend   = _My_data._Myend;
; 1729 : 
; 1730 :         _My_data._Orphan_all();
; 1731 : 
; 1732 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN7@Change_arr
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN7@Change_arr:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1737 :         _Myfirst = _Newvec;

	mov	ecx, DWORD PTR __Newvec$[esp]

; 1738 :         _Mylast  = _Newvec + _Newsize;

	mov	eax, DWORD PTR __Newsize$[esp]
	mov	DWORD PTR [esi], ecx
	lea	eax, DWORD PTR [eax+eax*2]
	lea	eax, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR [esi+4], eax

; 1739 :         _Myend   = _Newvec + _Newcapacity;

	mov	eax, DWORD PTR __Newcapacity$[esp]
	lea	eax, DWORD PTR [eax+eax*2]
	lea	eax, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR [esi+8], eax
	pop	esi

; 1740 :     }

	ret	12					; 0000000cH
?_Change_array@?$vector@UPrimitiveGroup@@V?$xalloc@UPrimitiveGroup@@@@@std@@AAEXQAUPrimitiveGroup@@II@Z ENDP ; std::vector<PrimitiveGroup,xalloc<PrimitiveGroup> >::_Change_array
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Calculate_growth@?$vector@UPrimitiveGroup@@V?$xalloc@UPrimitiveGroup@@@@@std@@ABEII@Z
_TEXT	SEGMENT
__Newsize$ = 8						; size = 4
?_Calculate_growth@?$vector@UPrimitiveGroup@@V?$xalloc@UPrimitiveGroup@@@@@std@@ABEII@Z PROC ; std::vector<PrimitiveGroup,xalloc<PrimitiveGroup> >::_Calculate_growth, COMDAT
; _this$ = ecx

; 1546 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx]

; 1671 :         // given _Oldcapacity and _Newsize, calculate geometric growth
; 1672 :         const size_type _Oldcapacity = capacity();
; 1673 :         const auto _Max              = max_size();
; 1674 : 
; 1675 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	ecx, 357913941				; 15555555H

; 1546 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	sar	eax, 2

; 1670 :     _CONSTEXPR20_CONTAINER size_type _Calculate_growth(const size_type _Newsize) const {

	push	esi

; 1546 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	imul	esi, eax, -1431655765

; 1671 :         // given _Oldcapacity and _Newsize, calculate geometric growth
; 1672 :         const size_type _Oldcapacity = capacity();
; 1673 :         const auto _Max              = max_size();
; 1674 : 
; 1675 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	edx, esi
	shr	edx, 1
	sub	ecx, edx
	cmp	esi, ecx
	jbe	SHORT $LN2@Calculate_

; 1676 :             return _Max; // geometric growth would overflow

	mov	eax, 357913941				; 15555555H
	pop	esi

; 1682 :             return _Newsize; // geometric growth would be insufficient
; 1683 :         }
; 1684 : 
; 1685 :         return _Geometric; // geometric growth is sufficient
; 1686 :     }

	ret	4
$LN2@Calculate_:

; 1677 :         }
; 1678 : 
; 1679 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	lea	eax, DWORD PTR [edx+esi]

; 1680 : 
; 1681 :         if (_Geometric < _Newsize) {

	cmp	eax, DWORD PTR __Newsize$[esp]
	pop	esi
	cmovb	eax, DWORD PTR __Newsize$[esp-4]

; 1682 :             return _Newsize; // geometric growth would be insufficient
; 1683 :         }
; 1684 : 
; 1685 :         return _Geometric; // geometric growth is sufficient
; 1686 :     }

	ret	4
?_Calculate_growth@?$vector@UPrimitiveGroup@@V?$xalloc@UPrimitiveGroup@@@@@std@@ABEII@Z ENDP ; std::vector<PrimitiveGroup,xalloc<PrimitiveGroup> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Umove_if_noexcept@?$vector@UPrimitiveGroup@@V?$xalloc@UPrimitiveGroup@@@@@std@@AAEXPAUPrimitiveGroup@@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
?_Umove_if_noexcept@?$vector@UPrimitiveGroup@@V?$xalloc@UPrimitiveGroup@@@@@std@@AAEXPAUPrimitiveGroup@@00@Z PROC ; std::vector<PrimitiveGroup,xalloc<PrimitiveGroup> >::_Umove_if_noexcept, COMDAT
; _this$dead$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1703 :     auto _UFirst      = _Get_unwrapped(_First);

	mov	eax, DWORD PTR __First$[esp-4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1659 :     _CONSTEXPR20_CONTAINER void _Umove_if_noexcept(pointer _First, pointer _Last, pointer _Dest) {

	push	esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	mov	esi, DWORD PTR __Last$[esp]
	cmp	eax, esi
	je	SHORT $LN7@Umove_if_n

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	edx, DWORD PTR __Dest$[esp]
	sub	edx, eax
$LL8@Umove_if_n:
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx+eax], ecx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+eax+4], ecx
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR [edx+eax+8], ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	add	eax, 12					; 0000000cH
	cmp	eax, esi
	jne	SHORT $LL8@Umove_if_n
$LN7@Umove_if_n:
	pop	esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1663 :     }

	ret	12					; 0000000cH
?_Umove_if_noexcept@?$vector@UPrimitiveGroup@@V?$xalloc@UPrimitiveGroup@@@@@std@@AAEXPAUPrimitiveGroup@@00@Z ENDP ; std::vector<PrimitiveGroup,xalloc<PrimitiveGroup> >::_Umove_if_noexcept
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?max_size@?$vector@UPrimitiveGroup@@V?$xalloc@UPrimitiveGroup@@@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@UPrimitiveGroup@@V?$xalloc@UPrimitiveGroup@@@@@std@@QBEIXZ PROC ; std::vector<PrimitiveGroup,xalloc<PrimitiveGroup> >::max_size, COMDAT
; _this$dead$ = ecx

; 1540 :         return (_STD min)(

	mov	eax, 357913941				; 15555555H

; 1541 :             static_cast<size_type>((numeric_limits<difference_type>::max)()), _Alty_traits::max_size(_Getal()));
; 1542 :     }

	ret	0
?max_size@?$vector@UPrimitiveGroup@@V?$xalloc@UPrimitiveGroup@@@@@std@@QBEIXZ ENDP ; std::vector<PrimitiveGroup,xalloc<PrimitiveGroup> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?deallocate@?$xalloc@UPrimitiveGroup@@@@QBEXPAUPrimitiveGroup@@I@Z
_TEXT	SEGMENT
_p$ = 8							; size = 4
_n$dead$ = 12						; size = 4
?deallocate@?$xalloc@UPrimitiveGroup@@@@QBEXPAUPrimitiveGroup@@I@Z PROC ; xalloc<PrimitiveGroup>::deallocate, COMDAT
; _this$dead$ = ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	eax, DWORD PTR _p$[esp-4]
	test	eax, eax
	je	SHORT $LN4@deallocate
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN4@deallocate:
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 82   : 							void					deallocate		(pointer p, size_type n) const			{	xr_free	(p);				}

	ret	8
?deallocate@?$xalloc@UPrimitiveGroup@@@@QBEXPAUPrimitiveGroup@@I@Z ENDP ; xalloc<PrimitiveGroup>::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?allocate@?$xalloc@UPrimitiveGroup@@@@QBEPAUPrimitiveGroup@@IPBX@Z
_TEXT	SEGMENT
_n$ = 8							; size = 4
_p$dead$ = 12						; size = 4
?allocate@?$xalloc@UPrimitiveGroup@@@@QBEPAUPrimitiveGroup@@IPBX@Z PROC ; xalloc<PrimitiveGroup>::allocate, COMDAT
; _this$dead$ = ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	mov	eax, DWORD PTR _n$[esp-4]
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	lea	eax, DWORD PTR [eax+eax*2]
	shl	eax, 2
	push	eax
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 80   : 							pointer					allocate		(size_type n, const void* p=0) const	{	return xr_alloc<T>((u32)n);	}

	ret	8
?allocate@?$xalloc@UPrimitiveGroup@@@@QBEPAUPrimitiveGroup@@IPBX@Z ENDP ; xalloc<PrimitiveGroup>::allocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?destroy@?$xalloc@PAVNvStripInfo@@@@QAEXPAPAVNvStripInfo@@@Z
_TEXT	SEGMENT
_p$dead$ = 8						; size = 4
?destroy@?$xalloc@PAVNvStripInfo@@@@QAEXPAPAVNvStripInfo@@@Z PROC ; xalloc<NvStripInfo *>::destroy, COMDAT
; _this$dead$ = ecx

; 85   : 							void					destroy			(pointer p)								{	std::_Destroy_in_place(p);			}

	ret	4
?destroy@?$xalloc@PAVNvStripInfo@@@@QAEXPAPAVNvStripInfo@@@Z ENDP ; xalloc<NvStripInfo *>::destroy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?destroy@?$xalloc@PAVNvFaceInfo@@@@QAEXPAPAVNvFaceInfo@@@Z
_TEXT	SEGMENT
_p$dead$ = 8						; size = 4
?destroy@?$xalloc@PAVNvFaceInfo@@@@QAEXPAPAVNvFaceInfo@@@Z PROC ; xalloc<NvFaceInfo *>::destroy, COMDAT
; _this$dead$ = ecx

; 85   : 							void					destroy			(pointer p)								{	std::_Destroy_in_place(p);			}

	ret	4
?destroy@?$xalloc@PAVNvFaceInfo@@@@QAEXPAPAVNvFaceInfo@@@Z ENDP ; xalloc<NvFaceInfo *>::destroy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Getal@?$vector@UPrimitiveGroup@@V?$xalloc@UPrimitiveGroup@@@@@std@@ABEABV?$xalloc@UPrimitiveGroup@@@@XZ
_TEXT	SEGMENT
?_Getal@?$vector@UPrimitiveGroup@@V?$xalloc@UPrimitiveGroup@@@@@std@@ABEABV?$xalloc@UPrimitiveGroup@@@@XZ PROC ; std::vector<PrimitiveGroup,xalloc<PrimitiveGroup> >::_Getal, COMDAT
; _this$ = ecx

; 1809 :         return _Mypair._Get_first();

	mov	eax, ecx

; 1810 :     }

	ret	0
?_Getal@?$vector@UPrimitiveGroup@@V?$xalloc@UPrimitiveGroup@@@@@std@@ABEABV?$xalloc@UPrimitiveGroup@@@@XZ ENDP ; std::vector<PrimitiveGroup,xalloc<PrimitiveGroup> >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Umove_if_noexcept1@?$vector@UPrimitiveGroup@@V?$xalloc@UPrimitiveGroup@@@@@std@@AAEXPAUPrimitiveGroup@@00U?$integral_constant@_N$00@2@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
?_Umove_if_noexcept1@?$vector@UPrimitiveGroup@@V?$xalloc@UPrimitiveGroup@@@@@std@@AAEXPAUPrimitiveGroup@@00U?$integral_constant@_N$00@2@@Z PROC ; std::vector<PrimitiveGroup,xalloc<PrimitiveGroup> >::_Umove_if_noexcept1, COMDAT
; _this$dead$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1703 :     auto _UFirst      = _Get_unwrapped(_First);

	mov	eax, DWORD PTR __First$[esp-4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1649 :     _CONSTEXPR20_CONTAINER void _Umove_if_noexcept1(pointer _First, pointer _Last, pointer _Dest, true_type) {

	push	esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	mov	esi, DWORD PTR __Last$[esp]
	cmp	eax, esi
	je	SHORT $LN5@Umove_if_n

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	edx, DWORD PTR __Dest$[esp]
	sub	edx, eax
$LL6@Umove_if_n:
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx+eax], ecx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+eax+4], ecx
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR [edx+eax+8], ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	add	eax, 12					; 0000000cH
	cmp	eax, esi
	jne	SHORT $LL6@Umove_if_n
$LN5@Umove_if_n:
	pop	esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1652 :     }

	ret	16					; 00000010H
?_Umove_if_noexcept1@?$vector@UPrimitiveGroup@@V?$xalloc@UPrimitiveGroup@@@@@std@@AAEXPAUPrimitiveGroup@@00U?$integral_constant@_N$00@2@@Z ENDP ; std::vector<PrimitiveGroup,xalloc<PrimitiveGroup> >::_Umove_if_noexcept1
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?capacity@?$vector@UPrimitiveGroup@@V?$xalloc@UPrimitiveGroup@@@@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@UPrimitiveGroup@@V?$xalloc@UPrimitiveGroup@@@@@std@@QBEIXZ PROC ; std::vector<PrimitiveGroup,xalloc<PrimitiveGroup> >::capacity, COMDAT
; _this$ = ecx

; 1545 :         auto& _My_data = _Mypair._Myval2;
; 1546 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx]
	sar	eax, 2
	imul	eax, eax, -1431655765

; 1547 :     }

	ret	0
?capacity@?$vector@UPrimitiveGroup@@V?$xalloc@UPrimitiveGroup@@@@@std@@QBEIXZ ENDP ; std::vector<PrimitiveGroup,xalloc<PrimitiveGroup> >::capacity
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?max_size@?$_Normal_allocator_traits@V?$xalloc@UPrimitiveGroup@@@@@std@@SAIABV?$xalloc@UPrimitiveGroup@@@@@Z
_TEXT	SEGMENT
?max_size@?$_Normal_allocator_traits@V?$xalloc@UPrimitiveGroup@@@@@std@@SAIABV?$xalloc@UPrimitiveGroup@@@@@Z PROC ; std::_Normal_allocator_traits<xalloc<PrimitiveGroup> >::max_size, COMDAT
; __Al$dead$ = ecx

; 591  :         if constexpr (_Has_max_size<_Alloc>::value) {
; 592  :             return _Al.max_size();

	mov	eax, 357913941				; 15555555H

; 593  :         } else {
; 594  :             return (numeric_limits<size_type>::max)() / sizeof(value_type);
; 595  :         }
; 596  :     }

	ret	0
?max_size@?$_Normal_allocator_traits@V?$xalloc@UPrimitiveGroup@@@@@std@@SAIABV?$xalloc@UPrimitiveGroup@@@@@Z ENDP ; std::_Normal_allocator_traits<xalloc<PrimitiveGroup> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$xalloc@UPrimitiveGroup@@@@V?$_Vector_val@U?$_Simple_types@UPrimitiveGroup@@@std@@@std@@$00@std@@QBEABV?$xalloc@UPrimitiveGroup@@@@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@V?$xalloc@UPrimitiveGroup@@@@V?$_Vector_val@U?$_Simple_types@UPrimitiveGroup@@@std@@@std@@$00@std@@QBEABV?$xalloc@UPrimitiveGroup@@@@XZ PROC ; std::_Compressed_pair<xalloc<PrimitiveGroup>,std::_Vector_val<std::_Simple_types<PrimitiveGroup> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 1343 :         return *this;

	mov	eax, ecx

; 1344 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$xalloc@UPrimitiveGroup@@@@V?$_Vector_val@U?$_Simple_types@UPrimitiveGroup@@@std@@@std@@$00@std@@QBEABV?$xalloc@UPrimitiveGroup@@@@XZ ENDP ; std::_Compressed_pair<xalloc<PrimitiveGroup>,std::_Vector_val<std::_Simple_types<PrimitiveGroup> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?max_size@?$xalloc@UPrimitiveGroup@@@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$xalloc@UPrimitiveGroup@@@@QBEIXZ PROC	; xalloc<PrimitiveGroup>::max_size, COMDAT
; _this$dead$ = ecx

; 86   : 							size_type				max_size		() const								{	size_type _Count = (size_type)(-1) / sizeof (T);	return (0 < _Count ? _Count : 1);	}

	mov	eax, 357913941				; 15555555H
	ret	0
?max_size@?$xalloc@UPrimitiveGroup@@@@QBEIXZ ENDP	; xalloc<PrimitiveGroup>::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef
;	COMDAT ??$_Unfancy@UPrimitiveGroup@@@std@@YAPAUPrimitiveGroup@@PAU1@@Z
_TEXT	SEGMENT
??$_Unfancy@UPrimitiveGroup@@@std@@YAPAUPrimitiveGroup@@PAU1@@Z PROC ; std::_Unfancy<PrimitiveGroup>, COMDAT
; __Ptr$ = ecx

; 266  :     return _Ptr;

	mov	eax, ecx

; 267  : }

	ret	0
??$_Unfancy@UPrimitiveGroup@@@std@@YAPAUPrimitiveGroup@@PAU1@@Z ENDP ; std::_Unfancy<PrimitiveGroup>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$destroy@UPrimitiveGroup@@@?$_Normal_allocator_traits@V?$xalloc@UPrimitiveGroup@@@@@std@@SAXAAV?$xalloc@UPrimitiveGroup@@@@PAUPrimitiveGroup@@@Z
_TEXT	SEGMENT
??$destroy@UPrimitiveGroup@@@?$_Normal_allocator_traits@V?$xalloc@UPrimitiveGroup@@@@@std@@SAXAAV?$xalloc@UPrimitiveGroup@@@@PAUPrimitiveGroup@@@Z PROC ; std::_Normal_allocator_traits<xalloc<PrimitiveGroup> >::destroy<PrimitiveGroup>, COMDAT
; __Al$dead$ = ecx
; __Ptr$dead$ = edx

; 579  :         if constexpr (_Uses_default_destroy<_Alloc, _Ty*>::value) {
; 580  : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 581  :             _STD destroy_at(_Ptr);
; 582  : #else // __cpp_lib_constexpr_dynamic_alloc
; 583  :             _Ptr->~_Ty();
; 584  : #endif // __cpp_lib_constexpr_dynamic_alloc
; 585  :         } else {
; 586  :             _Al.destroy(_Ptr);
; 587  :         }
; 588  :     }

	ret	0
??$destroy@UPrimitiveGroup@@@?$_Normal_allocator_traits@V?$xalloc@UPrimitiveGroup@@@@@std@@SAXAAV?$xalloc@UPrimitiveGroup@@@@PAUPrimitiveGroup@@@Z ENDP ; std::_Normal_allocator_traits<xalloc<PrimitiveGroup> >::destroy<PrimitiveGroup>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStrip.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Emplace_back@$$V@?$_Uninitialized_backout_al@V?$xalloc@UPrimitiveGroup@@@@@std@@QAEXXZ
_TEXT	SEGMENT
??$_Emplace_back@$$V@?$_Uninitialized_backout_al@V?$xalloc@UPrimitiveGroup@@@@@std@@QAEXXZ PROC ; std::_Uninitialized_backout_al<xalloc<PrimitiveGroup> >::_Emplace_back<>, COMDAT
; _this$ = ecx

; 570  :             ::new (static_cast<void*>(_Ptr)) _Ty(_STD forward<_Types>(_Args)...);

	mov	eax, DWORD PTR [ecx+4]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStrip.h

; 33   : 	PrimitiveGroup() : type(PT_STRIP), numIndices(0), indices(NULL) {}

	mov	DWORD PTR [eax], 1
	mov	DWORD PTR [eax+4], 0
	mov	DWORD PTR [eax+8], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1621 :         ++_Last;

	add	DWORD PTR [ecx+4], 12			; 0000000cH

; 1622 :     }

	ret	0
??$_Emplace_back@$$V@?$_Uninitialized_backout_al@V?$xalloc@UPrimitiveGroup@@@@@std@@QAEXXZ ENDP ; std::_Uninitialized_backout_al<xalloc<PrimitiveGroup> >::_Emplace_back<>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
;	COMDAT ??$xr_free@UPrimitiveGroup@@@@YAXAAPAUPrimitiveGroup@@@Z
_TEXT	SEGMENT
??$xr_free@UPrimitiveGroup@@@@YAXAAPAUPrimitiveGroup@@@Z PROC ; xr_free<PrimitiveGroup>, COMDAT
; _P$ = ecx

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	push	esi
	mov	esi, ecx
	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN2@xr_free
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
	mov	DWORD PTR [esi], 0
$LN2@xr_free:
	pop	esi
	ret	0
??$xr_free@UPrimitiveGroup@@@@YAXAAPAUPrimitiveGroup@@@Z ENDP ; xr_free<PrimitiveGroup>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
;	COMDAT ??$xr_alloc@UPrimitiveGroup@@@@YAPAUPrimitiveGroup@@I@Z
_TEXT	SEGMENT
??$xr_alloc@UPrimitiveGroup@@@@YAPAUPrimitiveGroup@@I@Z PROC ; xr_alloc<PrimitiveGroup>, COMDAT
; _count$ = ecx

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	lea	eax, DWORD PTR [ecx+ecx*2]
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	shl	eax, 2
	push	eax
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
	ret	0
??$xr_alloc@UPrimitiveGroup@@@@YAPAUPrimitiveGroup@@I@Z ENDP ; xr_alloc<PrimitiveGroup>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Destroy_in_place@PAPAVNvStripInfo@@@std@@YAXAAPAPAVNvStripInfo@@@Z
_TEXT	SEGMENT
??$_Destroy_in_place@PAPAVNvStripInfo@@@std@@YAXAAPAPAVNvStripInfo@@@Z PROC ; std::_Destroy_in_place<NvStripInfo * *>, COMDAT
; __Obj$dead$ = ecx

; 295  :     if constexpr (is_array_v<_Ty>) {
; 296  :         _Destroy_range(_Obj, _Obj + extent_v<_Ty>);
; 297  :     } else {
; 298  :         _Obj.~_Ty();
; 299  :     }
; 300  : }

	ret	0
??$_Destroy_in_place@PAPAVNvStripInfo@@@std@@YAXAAPAPAVNvStripInfo@@@Z ENDP ; std::_Destroy_in_place<NvStripInfo * *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Destroy_in_place@PAPAVNvFaceInfo@@@std@@YAXAAPAPAVNvFaceInfo@@@Z
_TEXT	SEGMENT
??$_Destroy_in_place@PAPAVNvFaceInfo@@@std@@YAXAAPAPAVNvFaceInfo@@@Z PROC ; std::_Destroy_in_place<NvFaceInfo * *>, COMDAT
; __Obj$dead$ = ecx

; 295  :     if constexpr (is_array_v<_Ty>) {
; 296  :         _Destroy_range(_Obj, _Obj + extent_v<_Ty>);
; 297  :     } else {
; 298  :         _Obj.~_Ty();
; 299  :     }
; 300  : }

	ret	0
??$_Destroy_in_place@PAPAVNvFaceInfo@@@std@@YAXAAPAPAVNvFaceInfo@@@Z ENDP ; std::_Destroy_in_place<NvFaceInfo * *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Uninitialized_move@PAUPrimitiveGroup@@V?$xalloc@UPrimitiveGroup@@@@@std@@YAPAUPrimitiveGroup@@QAU1@0PAU1@AAV?$xalloc@UPrimitiveGroup@@@@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Al$dead$ = 12						; size = 4
??$_Uninitialized_move@PAUPrimitiveGroup@@V?$xalloc@UPrimitiveGroup@@@@@std@@YAPAUPrimitiveGroup@@QAU1@0PAU1@AAV?$xalloc@UPrimitiveGroup@@@@@Z PROC ; std::_Uninitialized_move<PrimitiveGroup *,xalloc<PrimitiveGroup> >, COMDAT
; __First$ = ecx
; __Last$ = edx

; 1699 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

	push	esi

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	esi, DWORD PTR __Dest$[esp]

; 1699 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

	push	edi
	mov	edi, edx

; 1700 :     // move [_First, _Last) to raw _Dest, using _Al
; 1701 :     // note: only called internally from elsewhere in the STL
; 1702 :     using _Ptrval     = typename _Alloc::value_type*;
; 1703 :     auto _UFirst      = _Get_unwrapped(_First);
; 1704 :     const auto _ULast = _Get_unwrapped(_Last);
; 1705 :     if constexpr (conjunction_v<bool_constant<_Ptr_move_cat<decltype(_UFirst), _Ptrval>::_Really_trivial>,
; 1706 :                       _Uses_default_construct<_Alloc, _Ptrval, decltype(_STD move(*_UFirst))>>) {
; 1707 : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 1708 :         if (!_STD is_constant_evaluated())
; 1709 : #endif // __cpp_lib_constexpr_dynamic_alloc
; 1710 :         {
; 1711 :             _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));
; 1712 :             return _Dest + (_ULast - _UFirst);
; 1713 :         }
; 1714 :     }
; 1715 : 
; 1716 :     _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	ecx, edi
	je	SHORT $LN20@Uninitiali
	npad	4
$LL4@Uninitiali:
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [esi], eax
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [esi+4], edx
	mov	edx, DWORD PTR [ecx+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1621 :         ++_Last;

	add	ecx, 12					; 0000000cH
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	DWORD PTR [esi+8], edx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1621 :         ++_Last;

	add	esi, 12					; 0000000cH

; 1700 :     // move [_First, _Last) to raw _Dest, using _Al
; 1701 :     // note: only called internally from elsewhere in the STL
; 1702 :     using _Ptrval     = typename _Alloc::value_type*;
; 1703 :     auto _UFirst      = _Get_unwrapped(_First);
; 1704 :     const auto _ULast = _Get_unwrapped(_Last);
; 1705 :     if constexpr (conjunction_v<bool_constant<_Ptr_move_cat<decltype(_UFirst), _Ptrval>::_Really_trivial>,
; 1706 :                       _Uses_default_construct<_Alloc, _Ptrval, decltype(_STD move(*_UFirst))>>) {
; 1707 : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 1708 :         if (!_STD is_constant_evaluated())
; 1709 : #endif // __cpp_lib_constexpr_dynamic_alloc
; 1710 :         {
; 1711 :             _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));
; 1712 :             return _Dest + (_ULast - _UFirst);
; 1713 :         }
; 1714 :     }
; 1715 : 
; 1716 :     _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	ecx, edi
	jne	SHORT $LL4@Uninitiali
$LN20@Uninitiali:
	pop	edi

; 1718 :         _Backout._Emplace_back(_STD move(*_UFirst));
; 1719 :     }
; 1720 : 
; 1721 :     return _Backout._Release();
; 1722 : }

	mov	eax, esi
	pop	esi
	ret	0
??$_Uninitialized_move@PAUPrimitiveGroup@@V?$xalloc@UPrimitiveGroup@@@@@std@@YAPAUPrimitiveGroup@@QAU1@0PAU1@AAV?$xalloc@UPrimitiveGroup@@@@@Z ENDP ; std::_Uninitialized_move<PrimitiveGroup *,xalloc<PrimitiveGroup> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_Get_unwrapped@ABQAUPrimitiveGroup@@@std@@YA?A_TABQAUPrimitiveGroup@@@Z
_TEXT	SEGMENT
??$_Get_unwrapped@ABQAUPrimitiveGroup@@@std@@YA?A_TABQAUPrimitiveGroup@@@Z PROC ; std::_Get_unwrapped<PrimitiveGroup * const &>, COMDAT
; __It$ = ecx

; 1275 :     // unwrap an iterator previously subjected to _Adl_verify_range or otherwise validated
; 1276 :     if constexpr (is_pointer_v<decay_t<_Iter>>) { // special-case pointers and arrays
; 1277 :         return _It + 0;

	mov	eax, DWORD PTR [ecx]

; 1278 :     } else if constexpr (_Unwrappable_v<_Iter>) {
; 1279 :         return static_cast<_Iter&&>(_It)._Unwrapped();
; 1280 :     } else {
; 1281 :         return static_cast<_Iter&&>(_It);
; 1282 :     }
; 1283 : }

	ret	0
??$_Get_unwrapped@ABQAUPrimitiveGroup@@@std@@YA?A_TABQAUPrimitiveGroup@@@Z ENDP ; std::_Get_unwrapped<PrimitiveGroup * const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?destroy@?$xalloc@UPrimitiveGroup@@@@QAEXPAUPrimitiveGroup@@@Z
_TEXT	SEGMENT
_p$dead$ = 8						; size = 4
?destroy@?$xalloc@UPrimitiveGroup@@@@QAEXPAUPrimitiveGroup@@@Z PROC ; xalloc<PrimitiveGroup>::destroy, COMDAT
; _this$dead$ = ecx

; 85   : 							void					destroy			(pointer p)								{	std::_Destroy_in_place(p);			}

	ret	4
?destroy@?$xalloc@UPrimitiveGroup@@@@QAEXPAUPrimitiveGroup@@@Z ENDP ; xalloc<PrimitiveGroup>::destroy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStrip.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$construct@UPrimitiveGroup@@$$V@?$_Normal_allocator_traits@V?$xalloc@UPrimitiveGroup@@@@@std@@SAXAAV?$xalloc@UPrimitiveGroup@@@@PAUPrimitiveGroup@@@Z
_TEXT	SEGMENT
??$construct@UPrimitiveGroup@@$$V@?$_Normal_allocator_traits@V?$xalloc@UPrimitiveGroup@@@@@std@@SAXAAV?$xalloc@UPrimitiveGroup@@@@PAUPrimitiveGroup@@@Z PROC ; std::_Normal_allocator_traits<xalloc<PrimitiveGroup> >::construct<PrimitiveGroup>, COMDAT
; __Al$dead$ = ecx
; __Ptr$ = edx
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStrip.h

; 33   : 	PrimitiveGroup() : type(PT_STRIP), numIndices(0), indices(NULL) {}

	mov	DWORD PTR [edx], 1
	mov	DWORD PTR [edx+4], 0
	mov	DWORD PTR [edx+8], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 575  :     }

	ret	0
??$construct@UPrimitiveGroup@@$$V@?$_Normal_allocator_traits@V?$xalloc@UPrimitiveGroup@@@@@std@@SAXAAV?$xalloc@UPrimitiveGroup@@@@PAUPrimitiveGroup@@@Z ENDP ; std::_Normal_allocator_traits<xalloc<PrimitiveGroup> >::construct<PrimitiveGroup>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\type_traits
;	COMDAT ??$move@AAUPrimitiveGroup@@@std@@YA$$QAUPrimitiveGroup@@AAU1@@Z
_TEXT	SEGMENT
??$move@AAUPrimitiveGroup@@@std@@YA$$QAUPrimitiveGroup@@AAU1@@Z PROC ; std::move<PrimitiveGroup &>, COMDAT
; __Arg$ = ecx

; 1397 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

	mov	eax, ecx

; 1398 : }

	ret	0
??$move@AAUPrimitiveGroup@@@std@@YA$$QAUPrimitiveGroup@@AAU1@@Z ENDP ; std::move<PrimitiveGroup &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Emplace_back@UPrimitiveGroup@@@?$_Uninitialized_backout_al@V?$xalloc@UPrimitiveGroup@@@@@std@@QAEX$$QAUPrimitiveGroup@@@Z
_TEXT	SEGMENT
_<_Vals_0>$ = 8						; size = 4
??$_Emplace_back@UPrimitiveGroup@@@?$_Uninitialized_backout_al@V?$xalloc@UPrimitiveGroup@@@@@std@@QAEX$$QAUPrimitiveGroup@@@Z PROC ; std::_Uninitialized_backout_al<xalloc<PrimitiveGroup> >::_Emplace_back<PrimitiveGroup>, COMDAT
; _this$ = ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	edx, DWORD PTR _<_Vals_0>$[esp-4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1619 :     _CONSTEXPR20_DYNALLOC void _Emplace_back(_Types&&... _Vals) { // construct a new element at *_Last and increment

	push	esi
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	esi, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [esi], eax
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [esi+4], eax
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR [esi+8], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1621 :         ++_Last;

	add	DWORD PTR [ecx+4], 12			; 0000000cH
	pop	esi

; 1622 :     }

	ret	4
??$_Emplace_back@UPrimitiveGroup@@@?$_Uninitialized_backout_al@V?$xalloc@UPrimitiveGroup@@@@@std@@QAEX$$QAUPrimitiveGroup@@@Z ENDP ; std::_Uninitialized_backout_al<xalloc<PrimitiveGroup> >::_Emplace_back<PrimitiveGroup>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Destroy_in_place@PAUPrimitiveGroup@@@std@@YAXAAPAUPrimitiveGroup@@@Z
_TEXT	SEGMENT
??$_Destroy_in_place@PAUPrimitiveGroup@@@std@@YAXAAPAUPrimitiveGroup@@@Z PROC ; std::_Destroy_in_place<PrimitiveGroup *>, COMDAT
; __Obj$dead$ = ecx

; 295  :     if constexpr (is_array_v<_Ty>) {
; 296  :         _Destroy_range(_Obj, _Obj + extent_v<_Ty>);
; 297  :     } else {
; 298  :         _Obj.~_Ty();
; 299  :     }
; 300  : }

	ret	0
??$_Destroy_in_place@PAUPrimitiveGroup@@@std@@YAXAAPAUPrimitiveGroup@@@Z ENDP ; std::_Destroy_in_place<PrimitiveGroup *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\type_traits
;	COMDAT ??$forward@UPrimitiveGroup@@@std@@YA$$QAUPrimitiveGroup@@AAU1@@Z
_TEXT	SEGMENT
??$forward@UPrimitiveGroup@@@std@@YA$$QAUPrimitiveGroup@@AAU1@@Z PROC ; std::forward<PrimitiveGroup>, COMDAT
; __Arg$ = ecx

; 1386 :     return static_cast<_Ty&&>(_Arg);

	mov	eax, ecx

; 1387 : }

	ret	0
??$forward@UPrimitiveGroup@@@std@@YA$$QAUPrimitiveGroup@@AAU1@@Z ENDP ; std::forward<PrimitiveGroup>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$construct@UPrimitiveGroup@@U1@@?$_Normal_allocator_traits@V?$xalloc@UPrimitiveGroup@@@@@std@@SAXAAV?$xalloc@UPrimitiveGroup@@@@PAUPrimitiveGroup@@$$QAU3@@Z
_TEXT	SEGMENT
_<_Args_0>$ = 8						; size = 4
??$construct@UPrimitiveGroup@@U1@@?$_Normal_allocator_traits@V?$xalloc@UPrimitiveGroup@@@@@std@@SAXAAV?$xalloc@UPrimitiveGroup@@@@PAUPrimitiveGroup@@$$QAU3@@Z PROC ; std::_Normal_allocator_traits<xalloc<PrimitiveGroup> >::construct<PrimitiveGroup,PrimitiveGroup>, COMDAT
; __Al$dead$ = ecx
; __Ptr$ = edx
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	ecx, DWORD PTR _<_Args_0>$[esp-4]
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], eax
	mov	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+8], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 575  :     }

	ret	0
??$construct@UPrimitiveGroup@@U1@@?$_Normal_allocator_traits@V?$xalloc@UPrimitiveGroup@@@@@std@@SAXAAV?$xalloc@UPrimitiveGroup@@@@PAUPrimitiveGroup@@$$QAU3@@Z ENDP ; std::_Normal_allocator_traits<xalloc<PrimitiveGroup> >::construct<PrimitiveGroup,PrimitiveGroup>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?construct@?$xalloc@UPrimitiveGroup@@@@QAEXPAUPrimitiveGroup@@ABU2@@Z
_TEXT	SEGMENT
_p$ = 8							; size = 4
__Val$ = 12						; size = 4
?construct@?$xalloc@UPrimitiveGroup@@@@QAEXPAUPrimitiveGroup@@ABU2@@Z PROC ; xalloc<PrimitiveGroup>::construct, COMDAT
; _this$dead$ = ecx

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	edx, DWORD PTR __Val$[esp-4]
	mov	ecx, DWORD PTR _p$[esp-4]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+4], eax
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR [ecx+8], eax
	ret	8
?construct@?$xalloc@UPrimitiveGroup@@@@QAEXPAUPrimitiveGroup@@ABU2@@Z ENDP ; xalloc<PrimitiveGroup>::construct
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@H@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Vector_val@U?$_Simple_types@H@std@@@std@@QAE@XZ PROC ; std::_Vector_val<std::_Simple_types<int> >::_Vector_val<std::_Simple_types<int> >, COMDAT
; _this$ = ecx

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx], 0
	mov	eax, ecx
	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0
	ret	0
??0?$_Vector_val@U?$_Simple_types@H@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<std::_Simple_types<int> >::_Vector_val<std::_Simple_types<int> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Destroy_in_place@PAH@std@@YAXAAPAH@Z
_TEXT	SEGMENT
??$_Destroy_in_place@PAH@std@@YAXAAPAH@Z PROC		; std::_Destroy_in_place<int *>, COMDAT
; __Obj$dead$ = ecx

; 295  :     if constexpr (is_array_v<_Ty>) {
; 296  :         _Destroy_range(_Obj, _Obj + extent_v<_Ty>);
; 297  :     } else {
; 298  :         _Obj.~_Ty();
; 299  :     }
; 300  : }

	ret	0
??$_Destroy_in_place@PAH@std@@YAXAAPAH@Z ENDP		; std::_Destroy_in_place<int *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?destroy@?$xalloc@H@@QAEXPAH@Z
_TEXT	SEGMENT
_p$dead$ = 8						; size = 4
?destroy@?$xalloc@H@@QAEXPAH@Z PROC			; xalloc<int>::destroy, COMDAT
; _this$dead$ = ecx

; 85   : 							void					destroy			(pointer p)								{	std::_Destroy_in_place(p);			}

	ret	4
?destroy@?$xalloc@H@@QAEXPAH@Z ENDP			; xalloc<int>::destroy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$destroy@H@?$_Normal_allocator_traits@V?$xalloc@H@@@std@@SAXAAV?$xalloc@H@@PAH@Z
_TEXT	SEGMENT
??$destroy@H@?$_Normal_allocator_traits@V?$xalloc@H@@@std@@SAXAAV?$xalloc@H@@PAH@Z PROC ; std::_Normal_allocator_traits<xalloc<int> >::destroy<int>, COMDAT
; __Al$dead$ = ecx
; __Ptr$dead$ = edx

; 579  :         if constexpr (_Uses_default_destroy<_Alloc, _Ty*>::value) {
; 580  : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 581  :             _STD destroy_at(_Ptr);
; 582  : #else // __cpp_lib_constexpr_dynamic_alloc
; 583  :             _Ptr->~_Ty();
; 584  : #endif // __cpp_lib_constexpr_dynamic_alloc
; 585  :         } else {
; 586  :             _Al.destroy(_Ptr);
; 587  :         }
; 588  :     }

	ret	0
??$destroy@H@?$_Normal_allocator_traits@V?$xalloc@H@@@std@@SAXAAV?$xalloc@H@@PAH@Z ENDP ; std::_Normal_allocator_traits<xalloc<int> >::destroy<int>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef
;	COMDAT ??$_Unfancy@H@std@@YAPAHPAH@Z
_TEXT	SEGMENT
??$_Unfancy@H@std@@YAPAHPAH@Z PROC			; std::_Unfancy<int>, COMDAT
; __Ptr$ = ecx

; 266  :     return _Ptr;

	mov	eax, ecx

; 267  : }

	ret	0
??$_Unfancy@H@std@@YAPAHPAH@Z ENDP			; std::_Unfancy<int>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Destroy_range@V?$xalloc@H@@@std@@YAXPAHQAHAAV?$xalloc@H@@@Z
_TEXT	SEGMENT
__Al$dead$ = 8						; size = 4
??$_Destroy_range@V?$xalloc@H@@@std@@YAXPAHQAHAAV?$xalloc@H@@@Z PROC ; std::_Destroy_range<xalloc<int> >, COMDAT
; __First$dead$ = ecx
; __Last$dead$ = edx

; 901  :     // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
; 902  :     using _Ty = typename _Alloc::value_type;
; 903  :     if constexpr (!conjunction_v<is_trivially_destructible<_Ty>, _Uses_default_destroy<_Alloc, _Ty*>>) {
; 904  :         for (; _First != _Last; ++_First) {
; 905  :             allocator_traits<_Alloc>::destroy(_Al, _Unfancy(_First));
; 906  :         }
; 907  :     }
; 908  : }

	ret	0
??$_Destroy_range@V?$xalloc@H@@@std@@YAXPAHQAHAAV?$xalloc@H@@@Z ENDP ; std::_Destroy_range<xalloc<int> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$xalloc@H@@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@$00@std@@QAEAAV?$xalloc@H@@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@V?$xalloc@H@@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@$00@std@@QAEAAV?$xalloc@H@@XZ PROC ; std::_Compressed_pair<xalloc<int>,std::_Vector_val<std::_Simple_types<int> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 1339 :         return *this;

	mov	eax, ecx

; 1340 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$xalloc@H@@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@$00@std@@QAEAAV?$xalloc@H@@XZ ENDP ; std::_Compressed_pair<xalloc<int>,std::_Vector_val<std::_Simple_types<int> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Getal@?$vector@HV?$xalloc@H@@@std@@AAEAAV?$xalloc@H@@XZ
_TEXT	SEGMENT
?_Getal@?$vector@HV?$xalloc@H@@@std@@AAEAAV?$xalloc@H@@XZ PROC ; std::vector<int,xalloc<int> >::_Getal, COMDAT
; _this$ = ecx

; 1805 :         return _Mypair._Get_first();

	mov	eax, ecx

; 1806 :     }

	ret	0
?_Getal@?$vector@HV?$xalloc@H@@@std@@AAEAAV?$xalloc@H@@XZ ENDP ; std::vector<int,xalloc<int> >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Destroy@?$vector@HV?$xalloc@H@@@std@@AAEXPAH0@Z
_TEXT	SEGMENT
__First$dead$ = 8					; size = 4
__Last$dead$ = 12					; size = 4
?_Destroy@?$vector@HV?$xalloc@H@@@std@@AAEXPAH0@Z PROC	; std::vector<int,xalloc<int> >::_Destroy, COMDAT
; _this$dead$ = ecx

; 1666 :         // destroy [_First, _Last) using allocator
; 1667 :         _Destroy_range(_First, _Last, _Getal());
; 1668 :     }

	ret	8
?_Destroy@?$vector@HV?$xalloc@H@@@std@@AAEXPAH0@Z ENDP	; std::vector<int,xalloc<int> >::_Destroy
_TEXT	ENDS
END
