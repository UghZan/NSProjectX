; Listing generated by Microsoft (R) Optimizing Compiler Version 19.29.30146.0 

	TITLE	i:\vitalya\mine\nsprojectx\nspx_build\intermediate\release-win32\xrrender_r1\vertexcache.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

?_Fake_alloc@std@@3U_Fake_allocator@1@B	ORG $+1		; std::_Fake_alloc
PUBLIC	?clear@?$xr_vector@HV?$xalloc@H@@@@QAEXXZ	; xr_vector<int,xalloc<int> >::clear
PUBLIC	?clear_and_free@?$xr_vector@HV?$xalloc@H@@@@QAEXXZ ; xr_vector<int,xalloc<int> >::clear_and_free
PUBLIC	?clear@?$vector@HV?$xalloc@H@@@std@@QAEXXZ	; std::vector<int,xalloc<int> >::clear
PUBLIC	??$_Emplace_back@ABH@?$_Uninitialized_backout_al@V?$xalloc@H@@@std@@QAEXABH@Z ; std::_Uninitialized_backout_al<xalloc<int> >::_Emplace_back<int const &>
PUBLIC	??$_To_address@PAH@std@@YA?A_PABQAH@Z		; std::_To_address<int *>
PUBLIC	??$_Fill_zero_memset@PAH@std@@YAXPAHI@Z		; std::_Fill_zero_memset<int *>
PUBLIC	??$_Is_all_bits_zero@H@std@@YA_NABH@Z		; std::_Is_all_bits_zero<int>
PUBLIC	??$_Adl_verify_range@PAHPAH@std@@YAXABQAH0@Z	; std::_Adl_verify_range<int *,int *>
PUBLIC	??$_Uninitialized_fill_n@V?$xalloc@H@@@std@@YAPAHPAHIABHAAV?$xalloc@H@@@Z ; std::_Uninitialized_fill_n<xalloc<int> >
PUBLIC	??$fill@PAHH@std@@YAXQAH0ABH@Z			; std::fill<int *,int>
PUBLIC	?_Buy_raw@?$vector@HV?$xalloc@H@@@std@@AAEXI@Z	; std::vector<int,xalloc<int> >::_Buy_raw
PUBLIC	?_Clear_and_reserve_geometric@?$vector@HV?$xalloc@H@@@std@@AAEXI@Z ; std::vector<int,xalloc<int> >::_Clear_and_reserve_geometric
PUBLIC	?_Ufill@?$vector@HV?$xalloc@H@@@std@@AAEPAHPAHIABH@Z ; std::vector<int,xalloc<int> >::_Ufill
PUBLIC	?assign@?$vector@HV?$xalloc@H@@@std@@QAEXIABH@Z	; std::vector<int,xalloc<int> >::assign
PUBLIC	??0VertexCache@@QAE@H@Z				; VertexCache::VertexCache
PUBLIC	??1VertexCache@@QAE@XZ				; VertexCache::~VertexCache
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\VertexCache.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\VertexCache.cpp
_TEXT	SEGMENT
??1VertexCache@@QAE@XZ PROC				; VertexCache::~VertexCache
; _this$ = ecx

; 17   : {

	push	esi
	mov	esi, ecx

; 18   : 	entries.clear	();

	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [esi+4], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	test	eax, eax
	je	SHORT $LN8@VertexCach
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+4], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+8], 0
$LN8@VertexCach:
	pop	esi
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\VertexCache.cpp

; 19   : }

	ret	0
??1VertexCache@@QAE@XZ ENDP				; VertexCache::~VertexCache
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\VertexCache.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\VertexCache.cpp
_TEXT	SEGMENT
$T1 = -4						; size = 4
_size$ = 8						; size = 4
??0VertexCache@@QAE@H@Z PROC				; VertexCache::VertexCache
; _this$ = ecx

; 11   : {

	push	ecx
	push	esi
	mov	esi, ecx

; 12   : 	entries.assign	(size,-1);

	mov	DWORD PTR $T1[esp+8], -1
	lea	eax, DWORD PTR $T1[esp+8]
	push	eax
	push	DWORD PTR _size$[esp+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [esi], 0
	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\VertexCache.cpp

; 12   : 	entries.assign	(size,-1);

	call	?assign@?$vector@HV?$xalloc@H@@@std@@QAEXIABH@Z ; std::vector<int,xalloc<int> >::assign

; 13   : }

	mov	eax, esi
	pop	esi
	pop	ecx
	ret	4
??0VertexCache@@QAE@H@Z ENDP				; VertexCache::VertexCache
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?assign@?$vector@HV?$xalloc@H@@@std@@QAEXIABH@Z
_TEXT	SEGMENT
__Oldcapacity$1$ = -4					; size = 4
__Zero$2 = 8						; size = 4
__Newsize$ = 8						; size = 4
__Zero$3 = 12						; size = 4
__Val$ = 12						; size = 4
?assign@?$vector@HV?$xalloc@H@@@std@@QAEXIABH@Z PROC	; std::vector<int,xalloc<int> >::assign, COMDAT
; _this$ = ecx

; 1066 :     _CONSTEXPR20_CONTAINER void assign(_CRT_GUARDOVERFLOW const size_type _Newsize, const _Ty& _Val) {

	push	ecx
	push	ebx
	push	ebp
	mov	ebp, ecx
	push	esi
	push	edi

; 1067 :         // assign _Newsize * _Val
; 1068 :         auto& _My_data    = _Mypair._Myval2;
; 1069 :         pointer& _Myfirst = _My_data._Myfirst;
; 1070 :         pointer& _Mylast  = _My_data._Mylast;
; 1071 : 
; 1072 :         _My_data._Orphan_all();
; 1073 : 
; 1074 :         auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);
; 1075 :         if (_Newsize > _Oldsize) {

	mov	edi, DWORD PTR __Newsize$[esp+16]
	mov	edx, DWORD PTR [ebp+4]
	mov	esi, edx
	mov	eax, DWORD PTR [ebp]
	sub	esi, eax
	sar	esi, 2
	cmp	edi, esi
	jbe	$LN2@assign

; 1076 :             const auto _Oldcapacity = static_cast<size_type>(_My_data._Myend - _Myfirst);

	mov	ecx, DWORD PTR [ebp+8]

; 1077 :             if (_Newsize > _Oldcapacity) { // reallocate

	mov	ebx, DWORD PTR __Val$[esp+16]
	sub	ecx, eax
	sar	ecx, 2
	mov	DWORD PTR __Oldcapacity$1$[esp+20], ecx
	cmp	edi, ecx
	jbe	SHORT $LN4@assign

; 1337 :         if (_Newsize > max_size()) {

	cmp	edi, 1073741823				; 3fffffffH
	ja	$LN76@assign

; 1675 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	edx, DWORD PTR __Oldcapacity$1$[esp+20]
	mov	esi, ecx
	shr	esi, 1
	mov	ecx, 1073741823				; 3fffffffH
	sub	ecx, esi
	cmp	edx, ecx
	jbe	SHORT $LN12@assign

; 1676 :             return _Max; // geometric growth would overflow

	mov	esi, 1073741823				; 3fffffffH
	jmp	SHORT $LN13@assign
$LN12@assign:

; 1677 :         }
; 1678 : 
; 1679 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	add	esi, edx

; 1680 : 
; 1681 :         if (_Geometric < _Newsize) {

	cmp	esi, edi
	cmovb	esi, edi
$LN13@assign:

; 1343 :         if (_Myfirst) { // destroy and deallocate old array

	test	eax, eax
	je	SHORT $LN9@assign
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1347 :             _Myfirst = nullptr;

	mov	DWORD PTR [ebp], 0

; 1348 :             _Mylast  = nullptr;

	mov	DWORD PTR [ebp+4], 0

; 1349 :             _Myend   = nullptr;

	mov	DWORD PTR [ebp+8], 0
$LN9@assign:
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	shl	esi, 2
	push	esi
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1699 :         _Myfirst           = _Newvec;

	mov	DWORD PTR [ebp], eax

; 1700 :         _Mylast            = _Newvec;

	mov	DWORD PTR [ebp+4], eax

; 1701 :         _Myend             = _Newvec + _Newcapacity;

	add	eax, esi
	mov	DWORD PTR [ebp+8], eax

; 1078 :                 _Clear_and_reserve_geometric(_Newsize);
; 1079 :                 _Oldsize = 0;

	xor	esi, esi

; 1080 :             } else {

	jmp	SHORT $LN31@assign
$LN4@assign:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility

; 4456 :     return _CSTD memcmp(&_Val, &_Zero, sizeof(_Ty)) == 0;

	mov	ecx, DWORD PTR [ebx]
	lea	edi, DWORD PTR __Zero$3[esp+16]
	mov	DWORD PTR __Zero$3[esp+16], 0
	cmp	ecx, DWORD PTR [edi]

; 4476 :                 if (_Is_all_bits_zero(_Val)) {

	mov	edi, DWORD PTR __Newsize$[esp+16]
	jne	SHORT $LN33@assign

; 4448 :     _CSTD memset(_To_address(_Dest), 0, _Count * sizeof(_Iter_value_t<_CtgIt>));

	lea	ecx, DWORD PTR [esi*4]
	push	ecx
	push	0
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 4478 :                     return;

	jmp	SHORT $LN31@assign
$LN33@assign:

; 4483 :         for (; _UFirst != _ULast; ++_UFirst) {

	cmp	eax, edx
	je	SHORT $LN31@assign
$LL32@assign:

; 4484 :             *_UFirst = _Val;

	mov	ecx, DWORD PTR [ebx]
	mov	DWORD PTR [eax], ecx
	add	eax, 4
	cmp	eax, edx
	jne	SHORT $LL32@assign
$LN31@assign:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	ecx, DWORD PTR [ebp+4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1084 :             _Mylast = _Ufill(_Mylast, _Newsize - _Oldsize, _Val);

	sub	edi, esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1750 :     for (; 0 < _Count; --_Count) {

	je	SHORT $LN43@assign
$LL44@assign:

; 1620 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

	mov	eax, DWORD PTR [ebx]
	mov	DWORD PTR [ecx], eax

; 1621 :         ++_Last;

	add	ecx, 4

; 1750 :     for (; 0 < _Count; --_Count) {

	sub	edi, 1
	jne	SHORT $LL44@assign
$LN43@assign:
	pop	edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1091 :     }

	pop	esi
	mov	DWORD PTR [ebp+4], ecx
	pop	ebp
	pop	ebx
	pop	ecx
	ret	8
$LN2@assign:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility

; 4456 :     return _CSTD memcmp(&_Val, &_Zero, sizeof(_Ty)) == 0;

	mov	edx, DWORD PTR __Val$[esp+16]
	lea	ebx, DWORD PTR __Zero$2[esp+16]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1086 :             const pointer _Newlast = _Myfirst + _Newsize;

	shl	edi, 2
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility

; 4455 :     constexpr _Ty _Zero{};

	mov	DWORD PTR __Zero$2[esp+16], 0

; 4456 :     return _CSTD memcmp(&_Val, &_Zero, sizeof(_Ty)) == 0;

	mov	ecx, DWORD PTR [edx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1086 :             const pointer _Newlast = _Myfirst + _Newsize;

	lea	esi, DWORD PTR [eax+edi]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility

; 4456 :     return _CSTD memcmp(&_Val, &_Zero, sizeof(_Ty)) == 0;

	cmp	ecx, DWORD PTR [ebx]

; 4476 :                 if (_Is_all_bits_zero(_Val)) {

	jne	SHORT $LN56@assign

; 4448 :     _CSTD memset(_To_address(_Dest), 0, _Count * sizeof(_Iter_value_t<_CtgIt>));

	and	edi, -4					; fffffffcH
	push	edi
	push	0
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1089 :             _Mylast = _Newlast;

	mov	DWORD PTR [ebp+4], esi
	pop	edi

; 1091 :     }

	pop	esi
	pop	ebp
	pop	ebx
	pop	ecx
	ret	8
$LN56@assign:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility

; 4483 :         for (; _UFirst != _ULast; ++_UFirst) {

	cmp	eax, esi
	je	SHORT $LN54@assign
$LL55@assign:

; 4484 :             *_UFirst = _Val;

	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx
	add	eax, 4
	cmp	eax, esi
	jne	SHORT $LL55@assign
$LN54@assign:
	pop	edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1089 :             _Mylast = _Newlast;

	mov	DWORD PTR [ebp+4], esi

; 1091 :     }

	pop	esi
	pop	ebp
	pop	ebx
	pop	ecx
	ret	8
$LN76@assign:

; 1338 :             _Xlength();

	call	?_Xlength@?$vector@HV?$xalloc@H@@@std@@CAXXZ ; std::vector<int,xalloc<int> >::_Xlength
$LN74@assign:
	int	3
?assign@?$vector@HV?$xalloc@H@@@std@@QAEXIABH@Z ENDP	; std::vector<int,xalloc<int> >::assign
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Ufill@?$vector@HV?$xalloc@H@@@std@@AAEPAHPAHIABH@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
?_Ufill@?$vector@HV?$xalloc@H@@@std@@AAEPAHPAHIABH@Z PROC ; std::vector<int,xalloc<int> >::_Ufill, COMDAT
; _this$dead$ = ecx

; 1630 :         return _Uninitialized_fill_n(_Dest, _Count, _Val, _Getal());

	mov	edx, DWORD PTR __Count$[esp-4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	eax, DWORD PTR __Dest$[esp-4]

; 1750 :     for (; 0 < _Count; --_Count) {

	test	edx, edx
	je	SHORT $LN5@Ufill
	push	esi
	mov	esi, DWORD PTR __Val$[esp]
$LL6@Ufill:

; 1620 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

	mov	ecx, DWORD PTR [esi]
	mov	DWORD PTR [eax], ecx

; 1621 :         ++_Last;

	add	eax, 4

; 1750 :     for (; 0 < _Count; --_Count) {

	sub	edx, 1
	jne	SHORT $LL6@Ufill
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1630 :         return _Uninitialized_fill_n(_Dest, _Count, _Val, _Getal());

	pop	esi
$LN5@Ufill:

; 1631 :     }

	ret	12					; 0000000cH
?_Ufill@?$vector@HV?$xalloc@H@@@std@@AAEPAHPAHIABH@Z ENDP ; std::vector<int,xalloc<int> >::_Ufill
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Clear_and_reserve_geometric@?$vector@HV?$xalloc@H@@@std@@AAEXI@Z
_TEXT	SEGMENT
__Newsize$ = 8						; size = 4
?_Clear_and_reserve_geometric@?$vector@HV?$xalloc@H@@@std@@AAEXI@Z PROC ; std::vector<int,xalloc<int> >::_Clear_and_reserve_geometric, COMDAT
; _this$ = ecx

; 1326 :     _CONSTEXPR20_CONTAINER void _Clear_and_reserve_geometric(const size_type _Newsize) {

	push	ebp

; 1327 :         auto& _My_data    = _Mypair._Myval2;
; 1328 :         pointer& _Myfirst = _My_data._Myfirst;
; 1329 :         pointer& _Mylast  = _My_data._Mylast;
; 1330 :         pointer& _Myend   = _My_data._Myend;
; 1331 : 
; 1332 : #if _ITERATOR_DEBUG_LEVEL != 0 && defined(_ENABLE_STL_INTERNAL_CHECK)
; 1333 :         _STL_INTERNAL_CHECK(_Newsize != 0);
; 1334 :         _Check_all_orphaned();
; 1335 : #endif // _ITERATOR_DEBUG_LEVEL != 0 && defined(_ENABLE_STL_INTERNAL_CHECK)
; 1336 : 
; 1337 :         if (_Newsize > max_size()) {

	mov	ebp, DWORD PTR __Newsize$[esp]
	push	edi
	mov	edi, ecx
	cmp	ebp, 1073741823				; 3fffffffH
	ja	SHORT $LN24@Clear_and_

; 1546 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	ecx, DWORD PTR [edi+8]

; 1675 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	eax, 1073741823				; 3fffffffH
	push	ebx

; 1546 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	ebx, DWORD PTR [edi]
	sub	ecx, ebx
	sar	ecx, 2

; 1675 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	edx, ecx
	shr	edx, 1
	sub	eax, edx
	push	esi
	cmp	ecx, eax
	jbe	SHORT $LN6@Clear_and_

; 1676 :             return _Max; // geometric growth would overflow

	mov	esi, 1073741823				; 3fffffffH
	jmp	SHORT $LN7@Clear_and_
$LN6@Clear_and_:

; 1677 :         }
; 1678 : 
; 1679 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	lea	esi, DWORD PTR [edx+ecx]

; 1680 : 
; 1681 :         if (_Geometric < _Newsize) {

	cmp	esi, ebp
	cmovb	esi, ebp
$LN7@Clear_and_:

; 1339 :         }
; 1340 : 
; 1341 :         const size_type _Newcapacity = _Calculate_growth(_Newsize);
; 1342 : 
; 1343 :         if (_Myfirst) { // destroy and deallocate old array

	test	ebx, ebx
	je	SHORT $LN3@Clear_and_
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	ebx
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1347 :             _Myfirst = nullptr;

	mov	DWORD PTR [edi], 0

; 1348 :             _Mylast  = nullptr;

	mov	DWORD PTR [edi+4], 0

; 1349 :             _Myend   = nullptr;

	mov	DWORD PTR [edi+8], 0
$LN3@Clear_and_:
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	shl	esi, 2
	push	esi
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1699 :         _Myfirst           = _Newvec;

	mov	DWORD PTR [edi], eax

; 1700 :         _Mylast            = _Newvec;

	mov	DWORD PTR [edi+4], eax

; 1701 :         _Myend             = _Newvec + _Newcapacity;

	add	eax, esi
	pop	esi
	pop	ebx
	mov	DWORD PTR [edi+8], eax
	pop	edi

; 1350 :         }
; 1351 : 
; 1352 :         _Buy_raw(_Newcapacity);
; 1353 :     }

	pop	ebp
	ret	4
$LN24@Clear_and_:

; 1338 :             _Xlength();

	call	?_Xlength@?$vector@HV?$xalloc@H@@@std@@CAXXZ ; std::vector<int,xalloc<int> >::_Xlength
$LN22@Clear_and_:
	int	3
?_Clear_and_reserve_geometric@?$vector@HV?$xalloc@H@@@std@@AAEXI@Z ENDP ; std::vector<int,xalloc<int> >::_Clear_and_reserve_geometric
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Buy_raw@?$vector@HV?$xalloc@H@@@std@@AAEXI@Z
_TEXT	SEGMENT
__Newcapacity$ = 8					; size = 4
?_Buy_raw@?$vector@HV?$xalloc@H@@@std@@AAEXI@Z PROC	; std::vector<int,xalloc<int> >::_Buy_raw, COMDAT
; _this$ = ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	mov	eax, DWORD PTR __Newcapacity$[esp-4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1688 :     _CONSTEXPR20_CONTAINER void _Buy_raw(const size_type _Newcapacity) {

	push	esi
	push	edi
	mov	edi, ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	lea	esi, DWORD PTR [eax*4]
	push	esi
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1699 :         _Myfirst           = _Newvec;

	mov	DWORD PTR [edi], eax

; 1700 :         _Mylast            = _Newvec;

	mov	DWORD PTR [edi+4], eax

; 1701 :         _Myend             = _Newvec + _Newcapacity;

	add	eax, esi
	mov	DWORD PTR [edi+8], eax
	pop	edi
	pop	esi

; 1702 :     }

	ret	4
?_Buy_raw@?$vector@HV?$xalloc@H@@@std@@AAEXI@Z ENDP	; std::vector<int,xalloc<int> >::_Buy_raw
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$fill@PAHH@std@@YAXQAH0ABH@Z
_TEXT	SEGMENT
__Zero$1 = -4						; size = 4
__Val$ = 8						; size = 4
??$fill@PAHH@std@@YAXQAH0ABH@Z PROC			; std::fill<int *,int>, COMDAT
; __First$ = ecx
; __Last$ = edx

; 4460 : _CONSTEXPR20 void fill(const _FwdIt _First, const _FwdIt _Last, const _Ty& _Val) {

	push	ecx
	push	esi

; 4456 :     return _CSTD memcmp(&_Val, &_Zero, sizeof(_Ty)) == 0;

	mov	esi, DWORD PTR __Val$[esp+4]

; 4460 : _CONSTEXPR20 void fill(const _FwdIt _First, const _FwdIt _Last, const _Ty& _Val) {

	push	edi

; 4456 :     return _CSTD memcmp(&_Val, &_Zero, sizeof(_Ty)) == 0;

	lea	edi, DWORD PTR __Zero$1[esp+12]
	mov	DWORD PTR __Zero$1[esp+12], 0
	mov	eax, DWORD PTR [esi]
	cmp	eax, DWORD PTR [edi]

; 4461 :     // copy _Val through [_First, _Last)
; 4462 :     _Adl_verify_range(_First, _Last);
; 4463 :     if constexpr (_Is_vb_iterator<_FwdIt, true>) {
; 4464 :         _Fill_vbool(_First, _Last, _Val);
; 4465 :     } else {
; 4466 :         auto _UFirst      = _Get_unwrapped(_First);
; 4467 :         const auto _ULast = _Get_unwrapped(_Last);
; 4468 : #ifdef __cpp_lib_is_constant_evaluated
; 4469 :         if (!_STD is_constant_evaluated())
; 4470 : #endif // __cpp_lib_is_constant_evaluated
; 4471 :         {
; 4472 :             if constexpr (_Fill_memset_is_safe<decltype(_UFirst), _Ty>) {
; 4473 :                 _Fill_memset(_UFirst, _Val, static_cast<size_t>(_ULast - _UFirst));
; 4474 :                 return;
; 4475 :             } else if constexpr (_Fill_zero_memset_is_safe<decltype(_UFirst), _Ty>) {
; 4476 :                 if (_Is_all_bits_zero(_Val)) {

	jne	SHORT $LN5@fill

; 4477 :                     _Fill_zero_memset(_UFirst, static_cast<size_t>(_ULast - _UFirst));

	sub	edx, ecx

; 4448 :     _CSTD memset(_To_address(_Dest), 0, _Count * sizeof(_Iter_value_t<_CtgIt>));

	and	edx, -4					; fffffffcH
	push	edx
	push	0
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH
	pop	edi

; 4485 :         }
; 4486 :     }
; 4487 : }

	pop	esi
	pop	ecx
	ret	0
$LN5@fill:

; 4478 :                     return;
; 4479 :                 }
; 4480 :             }
; 4481 :         }
; 4482 : 
; 4483 :         for (; _UFirst != _ULast; ++_UFirst) {

	cmp	ecx, edx
	je	SHORT $LN3@fill
$LL4@fill:

; 4484 :             *_UFirst = _Val;

	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [ecx], eax
	add	ecx, 4
	cmp	ecx, edx
	jne	SHORT $LL4@fill
$LN3@fill:
	pop	edi

; 4485 :         }
; 4486 :     }
; 4487 : }

	pop	esi
	pop	ecx
	ret	0
??$fill@PAHH@std@@YAXQAH0ABH@Z ENDP			; std::fill<int *,int>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Uninitialized_fill_n@V?$xalloc@H@@@std@@YAPAHPAHIABHAAV?$xalloc@H@@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
__Al$dead$ = 12						; size = 4
??$_Uninitialized_fill_n@V?$xalloc@H@@@std@@YAPAHPAHIABHAAV?$xalloc@H@@@Z PROC ; std::_Uninitialized_fill_n<xalloc<int> >, COMDAT
; __First$ = ecx
; __Count$ = edx

; 1727 :     // copy _Count copies of _Val to raw _First, using _Al
; 1728 :     using _Ty = typename _Alloc::value_type;
; 1729 :     if constexpr (_Fill_memset_is_safe<_Ty*, _Ty> && _Uses_default_construct<_Alloc, _Ty*, _Ty>::value) {
; 1730 : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 1731 :         if (!_STD is_constant_evaluated())
; 1732 : #endif // __cpp_lib_constexpr_dynamic_alloc
; 1733 :         {
; 1734 :             _Fill_memset(_Unfancy(_First), _Val, static_cast<size_t>(_Count));
; 1735 :             return _First + _Count;
; 1736 :         }
; 1737 :     } else if constexpr (_Fill_zero_memset_is_safe<_Ty*, _Ty> && _Uses_default_construct<_Alloc, _Ty*, _Ty>::value) {
; 1738 : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 1739 :         if (!_STD is_constant_evaluated())
; 1740 : #endif // __cpp_lib_constexpr_dynamic_alloc
; 1741 :         {
; 1742 :             if (_Is_all_bits_zero(_Val)) {
; 1743 :                 _Fill_zero_memset(_Unfancy(_First), static_cast<size_t>(_Count));
; 1744 :                 return _First + _Count;
; 1745 :             }
; 1746 :         }
; 1747 :     }
; 1748 : 
; 1749 :     _Uninitialized_backout_al<_Alloc> _Backout{_First, _Al};
; 1750 :     for (; 0 < _Count; --_Count) {

	test	edx, edx
	je	SHORT $LN16@Uninitiali
	push	esi
	mov	esi, DWORD PTR __Val$[esp]
	npad	7
$LL4@Uninitiali:

; 1620 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [ecx], eax

; 1621 :         ++_Last;

	add	ecx, 4

; 1727 :     // copy _Count copies of _Val to raw _First, using _Al
; 1728 :     using _Ty = typename _Alloc::value_type;
; 1729 :     if constexpr (_Fill_memset_is_safe<_Ty*, _Ty> && _Uses_default_construct<_Alloc, _Ty*, _Ty>::value) {
; 1730 : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 1731 :         if (!_STD is_constant_evaluated())
; 1732 : #endif // __cpp_lib_constexpr_dynamic_alloc
; 1733 :         {
; 1734 :             _Fill_memset(_Unfancy(_First), _Val, static_cast<size_t>(_Count));
; 1735 :             return _First + _Count;
; 1736 :         }
; 1737 :     } else if constexpr (_Fill_zero_memset_is_safe<_Ty*, _Ty> && _Uses_default_construct<_Alloc, _Ty*, _Ty>::value) {
; 1738 : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 1739 :         if (!_STD is_constant_evaluated())
; 1740 : #endif // __cpp_lib_constexpr_dynamic_alloc
; 1741 :         {
; 1742 :             if (_Is_all_bits_zero(_Val)) {
; 1743 :                 _Fill_zero_memset(_Unfancy(_First), static_cast<size_t>(_Count));
; 1744 :                 return _First + _Count;
; 1745 :             }
; 1746 :         }
; 1747 :     }
; 1748 : 
; 1749 :     _Uninitialized_backout_al<_Alloc> _Backout{_First, _Al};
; 1750 :     for (; 0 < _Count; --_Count) {

	sub	edx, 1
	jne	SHORT $LL4@Uninitiali

; 1751 :         _Backout._Emplace_back(_Val);
; 1752 :     }
; 1753 : 
; 1754 :     return _Backout._Release();

	pop	esi
$LN16@Uninitiali:

; 1755 : }

	mov	eax, ecx
	ret	0
??$_Uninitialized_fill_n@V?$xalloc@H@@@std@@YAPAHPAHIABHAAV?$xalloc@H@@@Z ENDP ; std::_Uninitialized_fill_n<xalloc<int> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_Adl_verify_range@PAHPAH@std@@YAXABQAH0@Z
_TEXT	SEGMENT
??$_Adl_verify_range@PAHPAH@std@@YAXABQAH0@Z PROC	; std::_Adl_verify_range<int *,int *>, COMDAT
; __First$dead$ = ecx
; __Last$dead$ = edx

; 1259 :     // check that [_First, _Last) forms an iterator range
; 1260 :     if constexpr (_Range_verifiable_v<_Iter, _Sentinel>) {
; 1261 :         _Verify_range(_First, _Last);
; 1262 :     }
; 1263 : }

	ret	0
??$_Adl_verify_range@PAHPAH@std@@YAXABQAH0@Z ENDP	; std::_Adl_verify_range<int *,int *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_Is_all_bits_zero@H@std@@YA_NABH@Z
_TEXT	SEGMENT
__Zero$ = -4						; size = 4
??$_Is_all_bits_zero@H@std@@YA_NABH@Z PROC		; std::_Is_all_bits_zero<int>, COMDAT
; __Val$ = ecx

; 4452 : _NODISCARD bool _Is_all_bits_zero(const _Ty& _Val) {

	push	ecx

; 4453 :     // checks if scalar type has all bits set to zero
; 4454 :     _STL_INTERNAL_STATIC_ASSERT(is_scalar_v<_Ty> && !is_member_pointer_v<_Ty>);
; 4455 :     constexpr _Ty _Zero{};
; 4456 :     return _CSTD memcmp(&_Val, &_Zero, sizeof(_Ty)) == 0;

	mov	eax, DWORD PTR [ecx]
	lea	edx, DWORD PTR __Zero$[esp+4]
	mov	DWORD PTR __Zero$[esp+4], 0
	cmp	eax, DWORD PTR [edx]
	sete	al

; 4457 : }

	pop	ecx
	ret	0
??$_Is_all_bits_zero@H@std@@YA_NABH@Z ENDP		; std::_Is_all_bits_zero<int>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_Fill_zero_memset@PAH@std@@YAXPAHI@Z
_TEXT	SEGMENT
??$_Fill_zero_memset@PAH@std@@YAXPAHI@Z PROC		; std::_Fill_zero_memset<int *>, COMDAT
; __Dest$ = ecx
; __Count$ = edx

; 4448 :     _CSTD memset(_To_address(_Dest), 0, _Count * sizeof(_Iter_value_t<_CtgIt>));

	lea	eax, DWORD PTR [edx*4]
	push	eax
	push	0
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 4449 : }

	ret	0
??$_Fill_zero_memset@PAH@std@@YAXPAHI@Z ENDP		; std::_Fill_zero_memset<int *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_To_address@PAH@std@@YA?A_PABQAH@Z
_TEXT	SEGMENT
??$_To_address@PAH@std@@YA?A_PABQAH@Z PROC		; std::_To_address<int *>, COMDAT
; __Val$ = ecx

; 3981 :     _STL_INTERNAL_STATIC_ASSERT(is_pointer_v<_Iter>);
; 3982 :     return _Val;

	mov	eax, DWORD PTR [ecx]

; 3983 : }

	ret	0
??$_To_address@PAH@std@@YA?A_PABQAH@Z ENDP		; std::_To_address<int *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Emplace_back@ABH@?$_Uninitialized_backout_al@V?$xalloc@H@@@std@@QAEXABH@Z
_TEXT	SEGMENT
_<_Vals_0>$ = 8						; size = 4
??$_Emplace_back@ABH@?$_Uninitialized_backout_al@V?$xalloc@H@@@std@@QAEXABH@Z PROC ; std::_Uninitialized_backout_al<xalloc<int> >::_Emplace_back<int const &>, COMDAT
; _this$ = ecx

; 1620 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _<_Vals_0>$[esp-4]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edx], eax

; 1621 :         ++_Last;

	add	DWORD PTR [ecx+4], 4

; 1622 :     }

	ret	4
??$_Emplace_back@ABH@?$_Uninitialized_backout_al@V?$xalloc@H@@@std@@QAEXABH@Z ENDP ; std::_Uninitialized_backout_al<xalloc<int> >::_Emplace_back<int const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?clear@?$vector@HV?$xalloc@H@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$vector@HV?$xalloc@H@@@std@@QAEXXZ PROC		; std::vector<int,xalloc<int> >::clear, COMDAT
; _this$ = ecx

; 1437 :         auto& _My_data    = _Mypair._Myval2;
; 1438 :         pointer& _Myfirst = _My_data._Myfirst;
; 1439 :         pointer& _Mylast  = _My_data._Mylast;
; 1440 : 
; 1441 :         _My_data._Orphan_all();
; 1442 :         _Destroy(_Myfirst, _Mylast);
; 1443 :         _Mylast = _Myfirst;

	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [ecx+4], eax

; 1444 :     }

	ret	0
?clear@?$vector@HV?$xalloc@H@@@std@@QAEXXZ ENDP		; std::vector<int,xalloc<int> >::clear
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?clear_and_free@?$xr_vector@HV?$xalloc@H@@@@QAEXXZ
_TEXT	SEGMENT
?clear_and_free@?$xr_vector@HV?$xalloc@H@@@@QAEXXZ PROC	; xr_vector<int,xalloc<int> >::clear_and_free, COMDAT
; _this$ = ecx

; 127  : 	void	clear_and_free		()									{ inherited::clear();			}

	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [ecx+4], eax
	ret	0
?clear_and_free@?$xr_vector@HV?$xalloc@H@@@@QAEXXZ ENDP	; xr_vector<int,xalloc<int> >::clear_and_free
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?clear@?$xr_vector@HV?$xalloc@H@@@@QAEXXZ
_TEXT	SEGMENT
?clear@?$xr_vector@HV?$xalloc@H@@@@QAEXXZ PROC		; xr_vector<int,xalloc<int> >::clear, COMDAT
; _this$ = ecx

; 132  : 	void	clear				()									{ clear_and_free	();			}

	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [ecx+4], eax
	ret	0
?clear@?$xr_vector@HV?$xalloc@H@@@@QAEXXZ ENDP		; xr_vector<int,xalloc<int> >::clear
_TEXT	ENDS
END
