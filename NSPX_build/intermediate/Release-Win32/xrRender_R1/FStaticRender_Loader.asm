; Listing generated by Microsoft (R) Optimizing Compiler Version 19.29.30146.0 

	TITLE	i:\vitalya\mine\nsprojectx\nspx_build\intermediate\release-win32\xrrender_r1\fstaticrender_loader.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	??_C@_0BE@FEDLFIOP@CRender?3?3level_Load@	; `string'
PUBLIC	??_C@_0EJ@JMNAGDJL@I?3?2Vitalya?2mine?2NSProjectX?2laye@ ; `string'
PUBLIC	??_C@_0BA@EJFFNEEE@0?$CB?$DNg_pGameLevel@	; `string'
PUBLIC	??_C@_09KIFGLFPA@?$CBb_loaded@			; `string'
PUBLIC	??_C@_0BD@KEPNOJAL@st_loading_shaders@		; `string'
PUBLIC	??_C@_0CB@IIMDNKNP@Level?5doesn?8t?5builded?5correctly@ ; `string'
PUBLIC	??_C@_05PBLOBLMM@chunk@				; `string'
PUBLIC	??_C@_0BG@KBNNKPDD@st_loading_components@	; `string'
PUBLIC	??_C@_0BE@FADLPPAM@st_loading_geometry@		; `string'
PUBLIC	??_C@_0L@CHEIOGBE@level?4geom@			; `string'
PUBLIC	??_C@_0BG@CDAOLGEJ@st_loading_spatial_db@	; `string'
PUBLIC	??_C@_0BD@HEMBJNGD@st_loading_details@		; `string'
PUBLIC	??_C@_0BL@FEBBHFPA@st_loading_sectors_portals@	; `string'
PUBLIC	??_C@_0P@OFDPMDIN@st_loading_hom@		; `string'
PUBLIC	??_C@_0BC@HOICMLHM@st_loading_lights@		; `string'
PUBLIC	??_C@_0BB@ENKKBJBI@st_unloading_hom@		; `string'
PUBLIC	??_C@_0BF@KKHKGJJG@st_unloading_details@	; `string'
PUBLIC	??_C@_0BN@DFGDFDJK@st_unloading_sectors_portals@ ; `string'
PUBLIC	??_C@_0BE@HOOIPLJB@st_unloading_lights@		; `string'
PUBLIC	??_C@_0BI@LMGCEJBB@st_unloading_spatial_db@	; `string'
PUBLIC	??_C@_0BG@JNDCECGL@st_unloading_geometry@	; `string'
PUBLIC	??_C@_0BI@DOLBFAGL@st_unloading_components@	; `string'
PUBLIC	??_C@_0BF@HKEGBNPO@st_unloading_shaders@	; `string'
PUBLIC	??_C@_0BP@KGJDKDMF@?$CK?5?$FLLoading?5VB?$FN?5?$CFd?5verts?0?5?$CFd?5Kb@ ; `string'
PUBLIC	??_C@_0BF@KHLLPJCI@CRender?3?3LoadBuffers@	; `string'
PUBLIC	??_C@_0FA@HIPOJFBP@HW?4pDevice?9?$DOCreateVertexBuffer?$CI@ ; `string'
PUBLIC	??_C@_0CC@CMHIHIBA@VB?$FLi?$FN?9?$DOLock?$CI0?00?0?$CIvoid?$CK?$CK?$CJ?$CGpData?0@ ; `string'
PUBLIC	??_C@_0BL@HKGNKNNH@DX7?9style?5FVFs?5unsupported@ ; `string'
PUBLIC	??_C@_0CB@HEHANKGG@?$CK?5?$FLLoading?5IB?$FN?5?$CFd?5indices?0?5?$CFd?5K@ ; `string'
PUBLIC	??_C@_0FI@FNGBGCHL@HW?4pDevice?9?$DOCreateIndexBuffer?$CIi@ ; `string'
PUBLIC	??_C@_0CC@JCCFJMA@IB?$FLi?$FN?9?$DOLock?$CI0?00?0?$CIvoid?$CK?$CK?$CJ?$CGpData?0@ ; `string'
PUBLIC	??_C@_0BB@CPIJMGHB@Can?8t?5find?5glows@		; `string'
PUBLIC	??_C@_0BE@OILIHGFK@CRender?3?3LoadLights@	; `string'
PUBLIC	??_C@_0BM@BIODNPP@chunk?5?$CG?$CG?5?$CCCan?8t?5find?5glows?$CC@ ; `string'
PUBLIC	??_C@_0BF@FFCEOBGG@CRender?3?3LoadSectors@	; `string'
PUBLIC	??_C@_0BJ@KPNNAFFO@0?$DN?$DNsize?$CFsizeof?$CIb_portal?$CJ@ ; `string'
EXTRN	__imp_?close@CStreamReader@@QAEXXZ:PROC
EXTRN	__imp_?find_chunk@?$IReaderBase@VCStreamReader@@@@QAEIIPAH@Z:PROC
EXTRN	__imp_?r_u32@?$IReaderBase@VCStreamReader@@@@QAEIXZ:PROC
EXTRN	__imp_??0IRender_Sector@@QAE@XZ:PROC
EXTRN	__imp__D3DXGetDeclLength@4:PROC
EXTRN	__imp_?r@CStreamReader@@QAEXPAXI@Z:PROC
EXTRN	__imp_?open_chunk@CStreamReader@@QAEPAV1@ABI@Z:PROC
EXTRN	__imp_?Evict@CResourceManager@@QAEXXZ:PROC
EXTRN	__imp_?DeferredUnload@CResourceManager@@QAEXXZ:PROC
EXTRN	__imp_?LoadEnd@CApplication@@QAEXXZ:PROC
EXTRN	__imp_?r_close@CLocatorAPI@@QAEXAAPAVCStreamReader@@@Z:PROC
EXTRN	__imp_?rs_open@CLocatorAPI@@QAEPAVCStreamReader@@PBD0@Z:PROC
EXTRN	__imp_?Create@CResourceManager@@QAEPAUShader@@PBD000@Z:PROC
EXTRN	__imp_?DeferredLoad@CResourceManager@@QAEXH@Z:PROC
EXTRN	__imp_?pApp@@3PAVCApplication@@A:DWORD
EXTRN	__imp_?LoadBegin@CApplication@@QAEXXZ:PROC
EXTRN	__imp_?advance@CStreamReader@@QAEXABH@Z:PROC
;	COMDAT ?ignore_always@?3??LoadSectors@CRender@@AAEXPAVIReader@@@Z@4_NA
_BSS	SEGMENT
?ignore_always@?3??LoadSectors@CRender@@AAEXPAVIReader@@@Z@4_NA DB 01H DUP (?) ; `CRender::LoadSectors'::`4'::ignore_always
_BSS	ENDS
;	COMDAT ?ignore_always@?3??LoadLights@CRender@@AAEXPAVIReader@@@Z@4_NA
_BSS	SEGMENT
?ignore_always@?3??LoadLights@CRender@@AAEXPAVIReader@@@Z@4_NA DB 01H DUP (?) ; `CRender::LoadLights'::`4'::ignore_always
_BSS	ENDS
;	COMDAT ?ignore_always@?BM@??LoadBuffers@CRender@@AAEXPAVCStreamReader@@@Z@4_NA
_BSS	SEGMENT
?ignore_always@?BM@??LoadBuffers@CRender@@AAEXPAVCStreamReader@@@Z@4_NA DB 01H DUP (?) ; `CRender::LoadBuffers'::`28'::ignore_always
_BSS	ENDS
;	COMDAT ?ignore_always@?BI@??LoadBuffers@CRender@@AAEXPAVCStreamReader@@@Z@4_NA
_BSS	SEGMENT
?ignore_always@?BI@??LoadBuffers@CRender@@AAEXPAVCStreamReader@@@Z@4_NA DB 01H DUP (?) ; `CRender::LoadBuffers'::`24'::ignore_always
_BSS	ENDS
;	COMDAT ?ignore_always@?N@??LoadBuffers@CRender@@AAEXPAVCStreamReader@@@Z@4_NA
_BSS	SEGMENT
?ignore_always@?N@??LoadBuffers@CRender@@AAEXPAVCStreamReader@@@Z@4_NA DB 01H DUP (?) ; `CRender::LoadBuffers'::`13'::ignore_always
_BSS	ENDS
;	COMDAT ?ignore_always@?8??LoadBuffers@CRender@@AAEXPAVCStreamReader@@@Z@4_NA
_BSS	SEGMENT
?ignore_always@?8??LoadBuffers@CRender@@AAEXPAVCStreamReader@@@Z@4_NA DB 01H DUP (?) ; `CRender::LoadBuffers'::`9'::ignore_always
_BSS	ENDS
;	COMDAT ?ignore_always@?N@??level_Load@CRender@@UAEXPAVIReader@@@Z@4_NA
_BSS	SEGMENT
?ignore_always@?N@??level_Load@CRender@@UAEXPAVIReader@@@Z@4_NA DB 01H DUP (?) ; `CRender::level_Load'::`13'::ignore_always
_BSS	ENDS
;	COMDAT ?ignore_always@?7??level_Load@CRender@@UAEXPAVIReader@@@Z@4_NA
_BSS	SEGMENT
?ignore_always@?7??level_Load@CRender@@UAEXPAVIReader@@@Z@4_NA DB 01H DUP (?) ; `CRender::level_Load'::`8'::ignore_always
_BSS	ENDS
;	COMDAT ?ignore_always@?3??level_Load@CRender@@UAEXPAVIReader@@@Z@4_NA
_BSS	SEGMENT
?ignore_always@?3??level_Load@CRender@@UAEXPAVIReader@@@Z@4_NA DB 01H DUP (?) ; `CRender::level_Load'::`4'::ignore_always
_BSS	ENDS
;	COMDAT ??_C@_0BJ@KPNNAFFO@0?$DN?$DNsize?$CFsizeof?$CIb_portal?$CJ@
CONST	SEGMENT
??_C@_0BJ@KPNNAFFO@0?$DN?$DNsize?$CFsizeof?$CIb_portal?$CJ@ DB '0==size%s'
	DB	'izeof(b_portal)', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@FFCEOBGG@CRender?3?3LoadSectors@
CONST	SEGMENT
??_C@_0BF@FFCEOBGG@CRender?3?3LoadSectors@ DB 'CRender::LoadSectors', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@BIODNPP@chunk?5?$CG?$CG?5?$CCCan?8t?5find?5glows?$CC@
CONST	SEGMENT
??_C@_0BM@BIODNPP@chunk?5?$CG?$CG?5?$CCCan?8t?5find?5glows?$CC@ DB 'chunk'
	DB	' && "Can''t find glows"', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@OILIHGFK@CRender?3?3LoadLights@
CONST	SEGMENT
??_C@_0BE@OILIHGFK@CRender?3?3LoadLights@ DB 'CRender::LoadLights', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@CPIJMGHB@Can?8t?5find?5glows@
CONST	SEGMENT
??_C@_0BB@CPIJMGHB@Can?8t?5find?5glows@ DB 'Can''t find glows', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@JCCFJMA@IB?$FLi?$FN?9?$DOLock?$CI0?00?0?$CIvoid?$CK?$CK?$CJ?$CGpData?0@
CONST	SEGMENT
??_C@_0CC@JCCFJMA@IB?$FLi?$FN?9?$DOLock?$CI0?00?0?$CIvoid?$CK?$CK?$CJ?$CGpData?0@ DB 'I'
	DB	'B[i]->Lock(0,0,(void**)&pData,0)', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0FI@FNGBGCHL@HW?4pDevice?9?$DOCreateIndexBuffer?$CIi@
CONST	SEGMENT
??_C@_0FI@FNGBGCHL@HW?4pDevice?9?$DOCreateIndexBuffer?$CIi@ DB 'HW.pDevic'
	DB	'e->CreateIndexBuffer(iCount*2,dwUsage,D3DFMT_INDEX16,D3DPOOL_'
	DB	'MANAGED,&IB[i],0)', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@HEHANKGG@?$CK?5?$FLLoading?5IB?$FN?5?$CFd?5indices?0?5?$CFd?5K@
CONST	SEGMENT
??_C@_0CB@HEHANKGG@?$CK?5?$FLLoading?5IB?$FN?5?$CFd?5indices?0?5?$CFd?5K@ DB '*'
	DB	' [Loading IB] %d indices, %d Kb', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@HKGNKNNH@DX7?9style?5FVFs?5unsupported@
CONST	SEGMENT
??_C@_0BL@HKGNKNNH@DX7?9style?5FVFs?5unsupported@ DB 'DX7-style FVFs unsu'
	DB	'pported', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@CMHIHIBA@VB?$FLi?$FN?9?$DOLock?$CI0?00?0?$CIvoid?$CK?$CK?$CJ?$CGpData?0@
CONST	SEGMENT
??_C@_0CC@CMHIHIBA@VB?$FLi?$FN?9?$DOLock?$CI0?00?0?$CIvoid?$CK?$CK?$CJ?$CGpData?0@ DB 'V'
	DB	'B[i]->Lock(0,0,(void**)&pData,0)', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0FA@HIPOJFBP@HW?4pDevice?9?$DOCreateVertexBuffer?$CI@
CONST	SEGMENT
??_C@_0FA@HIPOJFBP@HW?4pDevice?9?$DOCreateVertexBuffer?$CI@ DB 'HW.pDevic'
	DB	'e->CreateVertexBuffer(vCount*vSize,dwUsage,0,D3DPOOL_MANAGED,'
	DB	'&VB[i],0)', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@KHLLPJCI@CRender?3?3LoadBuffers@
CONST	SEGMENT
??_C@_0BF@KHLLPJCI@CRender?3?3LoadBuffers@ DB 'CRender::LoadBuffers', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@KGJDKDMF@?$CK?5?$FLLoading?5VB?$FN?5?$CFd?5verts?0?5?$CFd?5Kb@
CONST	SEGMENT
??_C@_0BP@KGJDKDMF@?$CK?5?$FLLoading?5VB?$FN?5?$CFd?5verts?0?5?$CFd?5Kb@ DB '*'
	DB	' [Loading VB] %d verts, %d Kb', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@HKEGBNPO@st_unloading_shaders@
CONST	SEGMENT
??_C@_0BF@HKEGBNPO@st_unloading_shaders@ DB 'st_unloading_shaders', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@DOLBFAGL@st_unloading_components@
CONST	SEGMENT
??_C@_0BI@DOLBFAGL@st_unloading_components@ DB 'st_unloading_components', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@JNDCECGL@st_unloading_geometry@
CONST	SEGMENT
??_C@_0BG@JNDCECGL@st_unloading_geometry@ DB 'st_unloading_geometry', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@LMGCEJBB@st_unloading_spatial_db@
CONST	SEGMENT
??_C@_0BI@LMGCEJBB@st_unloading_spatial_db@ DB 'st_unloading_spatial_db', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@HOOIPLJB@st_unloading_lights@
CONST	SEGMENT
??_C@_0BE@HOOIPLJB@st_unloading_lights@ DB 'st_unloading_lights', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@DFGDFDJK@st_unloading_sectors_portals@
CONST	SEGMENT
??_C@_0BN@DFGDFDJK@st_unloading_sectors_portals@ DB 'st_unloading_sectors'
	DB	'_portals', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@KKHKGJJG@st_unloading_details@
CONST	SEGMENT
??_C@_0BF@KKHKGJJG@st_unloading_details@ DB 'st_unloading_details', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@ENKKBJBI@st_unloading_hom@
CONST	SEGMENT
??_C@_0BB@ENKKBJBI@st_unloading_hom@ DB 'st_unloading_hom', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@HOICMLHM@st_loading_lights@
CONST	SEGMENT
??_C@_0BC@HOICMLHM@st_loading_lights@ DB 'st_loading_lights', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@OFDPMDIN@st_loading_hom@
CONST	SEGMENT
??_C@_0P@OFDPMDIN@st_loading_hom@ DB 'st_loading_hom', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@FEBBHFPA@st_loading_sectors_portals@
CONST	SEGMENT
??_C@_0BL@FEBBHFPA@st_loading_sectors_portals@ DB 'st_loading_sectors_por'
	DB	'tals', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@HEMBJNGD@st_loading_details@
CONST	SEGMENT
??_C@_0BD@HEMBJNGD@st_loading_details@ DB 'st_loading_details', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@CDAOLGEJ@st_loading_spatial_db@
CONST	SEGMENT
??_C@_0BG@CDAOLGEJ@st_loading_spatial_db@ DB 'st_loading_spatial_db', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@CHEIOGBE@level?4geom@
CONST	SEGMENT
??_C@_0L@CHEIOGBE@level?4geom@ DB 'level.geom', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@FADLPPAM@st_loading_geometry@
CONST	SEGMENT
??_C@_0BE@FADLPPAM@st_loading_geometry@ DB 'st_loading_geometry', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@KBNNKPDD@st_loading_components@
CONST	SEGMENT
??_C@_0BG@KBNNKPDD@st_loading_components@ DB 'st_loading_components', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_05PBLOBLMM@chunk@
CONST	SEGMENT
??_C@_05PBLOBLMM@chunk@ DB 'chunk', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@IIMDNKNP@Level?5doesn?8t?5builded?5correctly@
CONST	SEGMENT
??_C@_0CB@IIMDNKNP@Level?5doesn?8t?5builded?5correctly@ DB 'Level doesn'''
	DB	't builded correctly.', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@KEPNOJAL@st_loading_shaders@
CONST	SEGMENT
??_C@_0BD@KEPNOJAL@st_loading_shaders@ DB 'st_loading_shaders', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09KIFGLFPA@?$CBb_loaded@
CONST	SEGMENT
??_C@_09KIFGLFPA@?$CBb_loaded@ DB '!b_loaded', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@EJFFNEEE@0?$CB?$DNg_pGameLevel@
CONST	SEGMENT
??_C@_0BA@EJFFNEEE@0?$CB?$DNg_pGameLevel@ DB '0!=g_pGameLevel', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EJ@JMNAGDJL@I?3?2Vitalya?2mine?2NSProjectX?2laye@
CONST	SEGMENT
??_C@_0EJ@JMNAGDJL@I?3?2Vitalya?2mine?2NSProjectX?2laye@ DB 'I:\Vitalya\m'
	DB	'ine\NSProjectX\layers\xrRenderPC_R1\FStaticRender_Loader.cpp', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@FEDLFIOP@CRender?3?3level_Load@
CONST	SEGMENT
??_C@_0BE@FEDLFIOP@CRender?3?3level_Load@ DB 'CRender::level_Load', 00H ; `string'
?_Fake_alloc@std@@3U_Fake_allocator@1@B	ORG $+1		; std::_Fake_alloc
PUBLIC	?strchr@@YAPADQADH@Z				; strchr
PUBLIC	??0CSector@@QAE@XZ				; CSector::CSector
PUBLIC	??0?$xr_vector@U_scissor@@V?$xalloc@U_scissor@@@@@@QAE@XZ ; xr_vector<_scissor,xalloc<_scissor> >::xr_vector<_scissor,xalloc<_scissor> >
PUBLIC	??0?$vector@U_scissor@@V?$xalloc@U_scissor@@@@@std@@QAE@XZ ; std::vector<_scissor,xalloc<_scissor> >::vector<_scissor,xalloc<_scissor> >
PUBLIC	??$?0$$V@?$_Compressed_pair@V?$xalloc@U_scissor@@@@V?$_Vector_val@U?$_Simple_types@U_scissor@@@std@@@std@@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<xalloc<_scissor>,std::_Vector_val<std::_Simple_types<_scissor> >,1>::_Compressed_pair<xalloc<_scissor>,std::_Vector_val<std::_Simple_types<_scissor> >,1><>
PUBLIC	??0?$_Vector_val@U?$_Simple_types@U_scissor@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<_scissor> >::_Vector_val<std::_Simple_types<_scissor> >
PUBLIC	??0?$xalloc@U_scissor@@@@QAE@XZ			; xalloc<_scissor>::xalloc<_scissor>
PUBLIC	??0?$xr_vector@VCFrustum@@V?$xalloc@VCFrustum@@@@@@QAE@XZ ; xr_vector<CFrustum,xalloc<CFrustum> >::xr_vector<CFrustum,xalloc<CFrustum> >
PUBLIC	??0?$vector@VCFrustum@@V?$xalloc@VCFrustum@@@@@std@@QAE@XZ ; std::vector<CFrustum,xalloc<CFrustum> >::vector<CFrustum,xalloc<CFrustum> >
PUBLIC	??$?0$$V@?$_Compressed_pair@V?$xalloc@VCFrustum@@@@V?$_Vector_val@U?$_Simple_types@VCFrustum@@@std@@@std@@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<xalloc<CFrustum>,std::_Vector_val<std::_Simple_types<CFrustum> >,1>::_Compressed_pair<xalloc<CFrustum>,std::_Vector_val<std::_Simple_types<CFrustum> >,1><>
PUBLIC	??0?$_Vector_val@U?$_Simple_types@VCFrustum@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<CFrustum> >::_Vector_val<std::_Simple_types<CFrustum> >
PUBLIC	??0?$xalloc@VCFrustum@@@@QAE@XZ			; xalloc<CFrustum>::xalloc<CFrustum>
PUBLIC	??0?$xr_vector@PAVCPortal@@V?$xalloc@PAVCPortal@@@@@@QAE@XZ ; xr_vector<CPortal *,xalloc<CPortal *> >::xr_vector<CPortal *,xalloc<CPortal *> >
PUBLIC	??0?$vector@PAVCPortal@@V?$xalloc@PAVCPortal@@@@@std@@QAE@XZ ; std::vector<CPortal *,xalloc<CPortal *> >::vector<CPortal *,xalloc<CPortal *> >
PUBLIC	??$?0$$V@?$_Compressed_pair@V?$xalloc@PAVCPortal@@@@V?$_Vector_val@U?$_Simple_types@PAVCPortal@@@std@@@std@@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<xalloc<CPortal *>,std::_Vector_val<std::_Simple_types<CPortal *> >,1>::_Compressed_pair<xalloc<CPortal *>,std::_Vector_val<std::_Simple_types<CPortal *> >,1><>
PUBLIC	??0?$_Vector_val@U?$_Simple_types@PAVCPortal@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<CPortal *> >::_Vector_val<std::_Simple_types<CPortal *> >
PUBLIC	??0?$xalloc@PAVCPortal@@@@QAE@XZ		; xalloc<CPortal *>::xalloc<CPortal *>
PUBLIC	?construct@?$xalloc@PAVIRender_Portal@@@@QAEXPAPAVIRender_Portal@@ABQAV2@@Z ; xalloc<IRender_Portal *>::construct
PUBLIC	?construct@?$xalloc@UFSlideWindowItem@@@@QAEXPAUFSlideWindowItem@@ABU2@@Z ; xalloc<FSlideWindowItem>::construct
PUBLIC	?construct@?$xalloc@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@@QAEXPAV?$resptr_core@UShader@@Uresptrcode_shader@@@@ABV2@@Z ; xalloc<resptr_core<Shader,resptrcode_shader> >::construct
PUBLIC	?construct@?$xalloc@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@@QAEXPAV?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@ABV2@@Z ; xalloc<svector<_D3DVERTEXELEMENT9,65> >::construct
PUBLIC	?construct@?$xalloc@PAUIDirect3DVertexBuffer9@@@@QAEXPAPAUIDirect3DVertexBuffer9@@ABQAU2@@Z ; xalloc<IDirect3DVertexBuffer9 *>::construct
PUBLIC	?construct@?$xalloc@PAUIDirect3DIndexBuffer9@@@@QAEXPAPAUIDirect3DIndexBuffer9@@ABQAU2@@Z ; xalloc<IDirect3DIndexBuffer9 *>::construct
PUBLIC	??$construct@PAVIRender_Portal@@PAV1@@?$_Normal_allocator_traits@V?$xalloc@PAVIRender_Portal@@@@@std@@SAXAAV?$xalloc@PAVIRender_Portal@@@@PAPAVIRender_Portal@@$$QAPAV3@@Z ; std::_Normal_allocator_traits<xalloc<IRender_Portal *> >::construct<IRender_Portal *,IRender_Portal *>
PUBLIC	??$forward@PAVIRender_Portal@@@std@@YA$$QAPAVIRender_Portal@@AAPAV1@@Z ; std::forward<IRender_Portal *>
PUBLIC	??$construct@UFSlideWindowItem@@U1@@?$_Normal_allocator_traits@V?$xalloc@UFSlideWindowItem@@@@@std@@SAXAAV?$xalloc@UFSlideWindowItem@@@@PAUFSlideWindowItem@@$$QAU3@@Z ; std::_Normal_allocator_traits<xalloc<FSlideWindowItem> >::construct<FSlideWindowItem,FSlideWindowItem>
PUBLIC	??$forward@UFSlideWindowItem@@@std@@YA$$QAUFSlideWindowItem@@AAU1@@Z ; std::forward<FSlideWindowItem>
PUBLIC	??$construct@V?$resptr_core@UShader@@Uresptrcode_shader@@@@AAV1@@?$_Normal_allocator_traits@V?$xalloc@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@@@std@@SAXAAV?$xalloc@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@@PAV?$resptr_core@UShader@@Uresptrcode_shader@@@@AAV3@@Z ; std::_Normal_allocator_traits<xalloc<resptr_core<Shader,resptrcode_shader> > >::construct<resptr_core<Shader,resptrcode_shader>,resptr_core<Shader,resptrcode_shader> &>
PUBLIC	??$forward@AAV?$resptr_core@UShader@@Uresptrcode_shader@@@@@std@@YAAAV?$resptr_core@UShader@@Uresptrcode_shader@@@@AAV1@@Z ; std::forward<resptr_core<Shader,resptrcode_shader> &>
PUBLIC	??$construct@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@V1@@?$_Normal_allocator_traits@V?$xalloc@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@@@std@@SAXAAV?$xalloc@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@@PAV?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@$$QAV3@@Z ; std::_Normal_allocator_traits<xalloc<svector<_D3DVERTEXELEMENT9,65> > >::construct<svector<_D3DVERTEXELEMENT9,65>,svector<_D3DVERTEXELEMENT9,65> >
PUBLIC	??$forward@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@std@@YA$$QAV?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@AAV1@@Z ; std::forward<svector<_D3DVERTEXELEMENT9,65> >
PUBLIC	??$construct@PAUIDirect3DVertexBuffer9@@PAU1@@?$_Normal_allocator_traits@V?$xalloc@PAUIDirect3DVertexBuffer9@@@@@std@@SAXAAV?$xalloc@PAUIDirect3DVertexBuffer9@@@@PAPAUIDirect3DVertexBuffer9@@$$QAPAU3@@Z ; std::_Normal_allocator_traits<xalloc<IDirect3DVertexBuffer9 *> >::construct<IDirect3DVertexBuffer9 *,IDirect3DVertexBuffer9 *>
PUBLIC	??$forward@PAUIDirect3DVertexBuffer9@@@std@@YA$$QAPAUIDirect3DVertexBuffer9@@AAPAU1@@Z ; std::forward<IDirect3DVertexBuffer9 *>
PUBLIC	??$construct@PAUIDirect3DIndexBuffer9@@PAU1@@?$_Normal_allocator_traits@V?$xalloc@PAUIDirect3DIndexBuffer9@@@@@std@@SAXAAV?$xalloc@PAUIDirect3DIndexBuffer9@@@@PAPAUIDirect3DIndexBuffer9@@$$QAPAU3@@Z ; std::_Normal_allocator_traits<xalloc<IDirect3DIndexBuffer9 *> >::construct<IDirect3DIndexBuffer9 *,IDirect3DIndexBuffer9 *>
PUBLIC	??$forward@PAUIDirect3DIndexBuffer9@@@std@@YA$$QAPAUIDirect3DIndexBuffer9@@AAPAU1@@Z ; std::forward<IDirect3DIndexBuffer9 *>
PUBLIC	??0?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@QAE@XZ	; svector<_D3DVERTEXELEMENT9,65>::svector<_D3DVERTEXELEMENT9,65>
PUBLIC	??$_Emplace_back@PAVIRender_Portal@@@?$_Uninitialized_backout_al@V?$xalloc@PAVIRender_Portal@@@@@std@@QAEX$$QAPAVIRender_Portal@@@Z ; std::_Uninitialized_backout_al<xalloc<IRender_Portal *> >::_Emplace_back<IRender_Portal *>
PUBLIC	??$move@AAPAVIRender_Portal@@@std@@YA$$QAPAVIRender_Portal@@AAPAV1@@Z ; std::move<IRender_Portal * &>
PUBLIC	??$_Emplace_back@UFSlideWindowItem@@@?$_Uninitialized_backout_al@V?$xalloc@UFSlideWindowItem@@@@@std@@QAEX$$QAUFSlideWindowItem@@@Z ; std::_Uninitialized_backout_al<xalloc<FSlideWindowItem> >::_Emplace_back<FSlideWindowItem>
PUBLIC	??$_Emplace_back@AAV?$resptr_core@UShader@@Uresptrcode_shader@@@@@?$_Uninitialized_backout_al@V?$xalloc@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@@@std@@QAEXAAV?$resptr_core@UShader@@Uresptrcode_shader@@@@@Z ; std::_Uninitialized_backout_al<xalloc<resptr_core<Shader,resptrcode_shader> > >::_Emplace_back<resptr_core<Shader,resptrcode_shader> &>
PUBLIC	??$_Emplace_back@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@?$_Uninitialized_backout_al@V?$xalloc@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@@@std@@QAEX$$QAV?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@Z ; std::_Uninitialized_backout_al<xalloc<svector<_D3DVERTEXELEMENT9,65> > >::_Emplace_back<svector<_D3DVERTEXELEMENT9,65> >
PUBLIC	??$move@AAV?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@std@@YA$$QAV?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@AAV1@@Z ; std::move<svector<_D3DVERTEXELEMENT9,65> &>
PUBLIC	??$_Emplace_back@PAUIDirect3DVertexBuffer9@@@?$_Uninitialized_backout_al@V?$xalloc@PAUIDirect3DVertexBuffer9@@@@@std@@QAEX$$QAPAUIDirect3DVertexBuffer9@@@Z ; std::_Uninitialized_backout_al<xalloc<IDirect3DVertexBuffer9 *> >::_Emplace_back<IDirect3DVertexBuffer9 *>
PUBLIC	??$move@AAPAUIDirect3DVertexBuffer9@@@std@@YA$$QAPAUIDirect3DVertexBuffer9@@AAPAU1@@Z ; std::move<IDirect3DVertexBuffer9 * &>
PUBLIC	??$_Emplace_back@PAUIDirect3DIndexBuffer9@@@?$_Uninitialized_backout_al@V?$xalloc@PAUIDirect3DIndexBuffer9@@@@@std@@QAEX$$QAPAUIDirect3DIndexBuffer9@@@Z ; std::_Uninitialized_backout_al<xalloc<IDirect3DIndexBuffer9 *> >::_Emplace_back<IDirect3DIndexBuffer9 *>
PUBLIC	??$move@AAPAUIDirect3DIndexBuffer9@@@std@@YA$$QAPAUIDirect3DIndexBuffer9@@AAPAU1@@Z ; std::move<IDirect3DIndexBuffer9 * &>
PUBLIC	??$construct@PAVIRender_Portal@@$$V@?$_Normal_allocator_traits@V?$xalloc@PAVIRender_Portal@@@@@std@@SAXAAV?$xalloc@PAVIRender_Portal@@@@PAPAVIRender_Portal@@@Z ; std::_Normal_allocator_traits<xalloc<IRender_Portal *> >::construct<IRender_Portal *>
PUBLIC	??$construct@UFSlideWindowItem@@$$V@?$_Normal_allocator_traits@V?$xalloc@UFSlideWindowItem@@@@@std@@SAXAAV?$xalloc@UFSlideWindowItem@@@@PAUFSlideWindowItem@@@Z ; std::_Normal_allocator_traits<xalloc<FSlideWindowItem> >::construct<FSlideWindowItem>
PUBLIC	??$construct@V?$resptr_core@UShader@@Uresptrcode_shader@@@@$$V@?$_Normal_allocator_traits@V?$xalloc@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@@@std@@SAXAAV?$xalloc@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@@PAV?$resptr_core@UShader@@Uresptrcode_shader@@@@@Z ; std::_Normal_allocator_traits<xalloc<resptr_core<Shader,resptrcode_shader> > >::construct<resptr_core<Shader,resptrcode_shader> >
PUBLIC	??$construct@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@$$V@?$_Normal_allocator_traits@V?$xalloc@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@@@std@@SAXAAV?$xalloc@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@@PAV?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@Z ; std::_Normal_allocator_traits<xalloc<svector<_D3DVERTEXELEMENT9,65> > >::construct<svector<_D3DVERTEXELEMENT9,65> >
PUBLIC	??$construct@PAUIDirect3DVertexBuffer9@@$$V@?$_Normal_allocator_traits@V?$xalloc@PAUIDirect3DVertexBuffer9@@@@@std@@SAXAAV?$xalloc@PAUIDirect3DVertexBuffer9@@@@PAPAUIDirect3DVertexBuffer9@@@Z ; std::_Normal_allocator_traits<xalloc<IDirect3DVertexBuffer9 *> >::construct<IDirect3DVertexBuffer9 *>
PUBLIC	??$construct@PAUIDirect3DIndexBuffer9@@$$V@?$_Normal_allocator_traits@V?$xalloc@PAUIDirect3DIndexBuffer9@@@@@std@@SAXAAV?$xalloc@PAUIDirect3DIndexBuffer9@@@@PAPAUIDirect3DIndexBuffer9@@@Z ; std::_Normal_allocator_traits<xalloc<IDirect3DIndexBuffer9 *> >::construct<IDirect3DIndexBuffer9 *>
PUBLIC	??$_Get_unwrapped@ABQAPAVIRender_Portal@@@std@@YA?A_TABQAPAVIRender_Portal@@@Z ; std::_Get_unwrapped<IRender_Portal * * const &>
PUBLIC	??$_Uninitialized_move@PAPAVIRender_Portal@@V?$xalloc@PAVIRender_Portal@@@@@std@@YAPAPAVIRender_Portal@@QAPAV1@0PAPAV1@AAV?$xalloc@PAVIRender_Portal@@@@@Z ; std::_Uninitialized_move<IRender_Portal * *,xalloc<IRender_Portal *> >
PUBLIC	??$_Get_unwrapped@ABQAUFSlideWindowItem@@@std@@YA?A_TABQAUFSlideWindowItem@@@Z ; std::_Get_unwrapped<FSlideWindowItem * const &>
PUBLIC	??$_Uninitialized_move@PAUFSlideWindowItem@@V?$xalloc@UFSlideWindowItem@@@@@std@@YAPAUFSlideWindowItem@@QAU1@0PAU1@AAV?$xalloc@UFSlideWindowItem@@@@@Z ; std::_Uninitialized_move<FSlideWindowItem *,xalloc<FSlideWindowItem> >
PUBLIC	??$_Get_unwrapped@ABQAV?$resptr_core@UShader@@Uresptrcode_shader@@@@@std@@YA?A_TABQAV?$resptr_core@UShader@@Uresptrcode_shader@@@@@Z ; std::_Get_unwrapped<resptr_core<Shader,resptrcode_shader> * const &>
PUBLIC	??$_Uninitialized_copy@PAV?$resptr_core@UShader@@Uresptrcode_shader@@@@V?$xalloc@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@@@std@@YAPAV?$resptr_core@UShader@@Uresptrcode_shader@@@@QAV1@0PAV1@AAV?$xalloc@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@@@Z ; std::_Uninitialized_copy<resptr_core<Shader,resptrcode_shader> *,xalloc<resptr_core<Shader,resptrcode_shader> > >
PUBLIC	??$_Get_unwrapped@ABQAV?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@std@@YA?A_TABQAV?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@Z ; std::_Get_unwrapped<svector<_D3DVERTEXELEMENT9,65> * const &>
PUBLIC	??$_Uninitialized_move@PAV?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@V?$xalloc@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@@@std@@YAPAV?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@QAV1@0PAV1@AAV?$xalloc@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@@@Z ; std::_Uninitialized_move<svector<_D3DVERTEXELEMENT9,65> *,xalloc<svector<_D3DVERTEXELEMENT9,65> > >
PUBLIC	??$_Get_unwrapped@ABQAPAUIDirect3DVertexBuffer9@@@std@@YA?A_TABQAPAUIDirect3DVertexBuffer9@@@Z ; std::_Get_unwrapped<IDirect3DVertexBuffer9 * * const &>
PUBLIC	??$_Uninitialized_move@PAPAUIDirect3DVertexBuffer9@@V?$xalloc@PAUIDirect3DVertexBuffer9@@@@@std@@YAPAPAUIDirect3DVertexBuffer9@@QAPAU1@0PAPAU1@AAV?$xalloc@PAUIDirect3DVertexBuffer9@@@@@Z ; std::_Uninitialized_move<IDirect3DVertexBuffer9 * *,xalloc<IDirect3DVertexBuffer9 *> >
PUBLIC	??$_Get_unwrapped@ABQAPAUIDirect3DIndexBuffer9@@@std@@YA?A_TABQAPAUIDirect3DIndexBuffer9@@@Z ; std::_Get_unwrapped<IDirect3DIndexBuffer9 * * const &>
PUBLIC	??$_Uninitialized_move@PAPAUIDirect3DIndexBuffer9@@V?$xalloc@PAUIDirect3DIndexBuffer9@@@@@std@@YAPAPAUIDirect3DIndexBuffer9@@QAPAU1@0PAPAU1@AAV?$xalloc@PAUIDirect3DIndexBuffer9@@@@@Z ; std::_Uninitialized_move<IDirect3DIndexBuffer9 * *,xalloc<IDirect3DIndexBuffer9 *> >
PUBLIC	??$xr_alloc@PAVIRender_Portal@@@@YAPAPAVIRender_Portal@@I@Z ; xr_alloc<IRender_Portal *>
PUBLIC	??$xr_alloc@UFSlideWindowItem@@@@YAPAUFSlideWindowItem@@I@Z ; xr_alloc<FSlideWindowItem>
PUBLIC	??$xr_alloc@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@@YAPAV?$resptr_core@UShader@@Uresptrcode_shader@@@@I@Z ; xr_alloc<resptr_core<Shader,resptrcode_shader> >
PUBLIC	??$xr_alloc@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@@YAPAV?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@I@Z ; xr_alloc<svector<_D3DVERTEXELEMENT9,65> >
PUBLIC	??$xr_alloc@PAUIDirect3DVertexBuffer9@@@@YAPAPAUIDirect3DVertexBuffer9@@I@Z ; xr_alloc<IDirect3DVertexBuffer9 *>
PUBLIC	??$xr_alloc@PAUIDirect3DIndexBuffer9@@@@YAPAPAUIDirect3DIndexBuffer9@@I@Z ; xr_alloc<IDirect3DIndexBuffer9 *>
PUBLIC	??$_Emplace_back@$$V@?$_Uninitialized_backout_al@V?$xalloc@PAVIRender_Portal@@@@@std@@QAEXXZ ; std::_Uninitialized_backout_al<xalloc<IRender_Portal *> >::_Emplace_back<>
PUBLIC	??$_To_address@PAPAVIRender_Portal@@@std@@YA?A_PABQAPAVIRender_Portal@@@Z ; std::_To_address<IRender_Portal * *>
PUBLIC	??$_Zero_range@PAPAVIRender_Portal@@@std@@YAPAPAVIRender_Portal@@QAPAV1@0@Z ; std::_Zero_range<IRender_Portal * *>
PUBLIC	??$_Emplace_back@$$V@?$_Uninitialized_backout_al@V?$xalloc@UFSlideWindowItem@@@@@std@@QAEXXZ ; std::_Uninitialized_backout_al<xalloc<FSlideWindowItem> >::_Emplace_back<>
PUBLIC	??$_Emplace_back@$$V@?$_Uninitialized_backout_al@V?$xalloc@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@@@std@@QAEXXZ ; std::_Uninitialized_backout_al<xalloc<resptr_core<Shader,resptrcode_shader> > >::_Emplace_back<>
PUBLIC	??$_Emplace_back@$$V@?$_Uninitialized_backout_al@V?$xalloc@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@@@std@@QAEXXZ ; std::_Uninitialized_backout_al<xalloc<svector<_D3DVERTEXELEMENT9,65> > >::_Emplace_back<>
PUBLIC	??$_Emplace_back@$$V@?$_Uninitialized_backout_al@V?$xalloc@PAUIDirect3DVertexBuffer9@@@@@std@@QAEXXZ ; std::_Uninitialized_backout_al<xalloc<IDirect3DVertexBuffer9 *> >::_Emplace_back<>
PUBLIC	??$_To_address@PAPAUIDirect3DVertexBuffer9@@@std@@YA?A_PABQAPAUIDirect3DVertexBuffer9@@@Z ; std::_To_address<IDirect3DVertexBuffer9 * *>
PUBLIC	??$_Zero_range@PAPAUIDirect3DVertexBuffer9@@@std@@YAPAPAUIDirect3DVertexBuffer9@@QAPAU1@0@Z ; std::_Zero_range<IDirect3DVertexBuffer9 * *>
PUBLIC	??$_Emplace_back@$$V@?$_Uninitialized_backout_al@V?$xalloc@PAUIDirect3DIndexBuffer9@@@@@std@@QAEXXZ ; std::_Uninitialized_backout_al<xalloc<IDirect3DIndexBuffer9 *> >::_Emplace_back<>
PUBLIC	??$_To_address@PAPAUIDirect3DIndexBuffer9@@@std@@YA?A_PABQAPAUIDirect3DIndexBuffer9@@@Z ; std::_To_address<IDirect3DIndexBuffer9 * *>
PUBLIC	??$_Zero_range@PAPAUIDirect3DIndexBuffer9@@@std@@YAPAPAUIDirect3DIndexBuffer9@@QAPAU1@0@Z ; std::_Zero_range<IDirect3DIndexBuffer9 * *>
PUBLIC	?max_size@?$xalloc@PAVIRender_Portal@@@@QBEIXZ	; xalloc<IRender_Portal *>::max_size
PUBLIC	?_Get_first@?$_Compressed_pair@V?$xalloc@PAVIRender_Portal@@@@V?$_Vector_val@U?$_Simple_types@PAVIRender_Portal@@@std@@@std@@$00@std@@QBEABV?$xalloc@PAVIRender_Portal@@@@XZ ; std::_Compressed_pair<xalloc<IRender_Portal *>,std::_Vector_val<std::_Simple_types<IRender_Portal *> >,1>::_Get_first
PUBLIC	?max_size@?$xalloc@UFSlideWindowItem@@@@QBEIXZ	; xalloc<FSlideWindowItem>::max_size
PUBLIC	?_Get_first@?$_Compressed_pair@V?$xalloc@UFSlideWindowItem@@@@V?$_Vector_val@U?$_Simple_types@UFSlideWindowItem@@@std@@@std@@$00@std@@QBEABV?$xalloc@UFSlideWindowItem@@@@XZ ; std::_Compressed_pair<xalloc<FSlideWindowItem>,std::_Vector_val<std::_Simple_types<FSlideWindowItem> >,1>::_Get_first
PUBLIC	?max_size@?$xalloc@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@@QBEIXZ ; xalloc<resptr_core<Shader,resptrcode_shader> >::max_size
PUBLIC	?_Get_first@?$_Compressed_pair@V?$xalloc@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@@V?$_Vector_val@U?$_Simple_types@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@std@@@std@@$00@std@@QBEABV?$xalloc@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@@XZ ; std::_Compressed_pair<xalloc<resptr_core<Shader,resptrcode_shader> >,std::_Vector_val<std::_Simple_types<resptr_core<Shader,resptrcode_shader> > >,1>::_Get_first
PUBLIC	?max_size@?$xalloc@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@@QBEIXZ ; xalloc<svector<_D3DVERTEXELEMENT9,65> >::max_size
PUBLIC	?_Get_first@?$_Compressed_pair@V?$xalloc@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@@V?$_Vector_val@U?$_Simple_types@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@std@@@std@@$00@std@@QBEABV?$xalloc@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@@XZ ; std::_Compressed_pair<xalloc<svector<_D3DVERTEXELEMENT9,65> >,std::_Vector_val<std::_Simple_types<svector<_D3DVERTEXELEMENT9,65> > >,1>::_Get_first
PUBLIC	?max_size@?$xalloc@PAUIDirect3DVertexBuffer9@@@@QBEIXZ ; xalloc<IDirect3DVertexBuffer9 *>::max_size
PUBLIC	?_Get_first@?$_Compressed_pair@V?$xalloc@PAUIDirect3DVertexBuffer9@@@@V?$_Vector_val@U?$_Simple_types@PAUIDirect3DVertexBuffer9@@@std@@@std@@$00@std@@QBEABV?$xalloc@PAUIDirect3DVertexBuffer9@@@@XZ ; std::_Compressed_pair<xalloc<IDirect3DVertexBuffer9 *>,std::_Vector_val<std::_Simple_types<IDirect3DVertexBuffer9 *> >,1>::_Get_first
PUBLIC	?max_size@?$xalloc@PAUIDirect3DIndexBuffer9@@@@QBEIXZ ; xalloc<IDirect3DIndexBuffer9 *>::max_size
PUBLIC	?_Get_first@?$_Compressed_pair@V?$xalloc@PAUIDirect3DIndexBuffer9@@@@V?$_Vector_val@U?$_Simple_types@PAUIDirect3DIndexBuffer9@@@std@@@std@@$00@std@@QBEABV?$xalloc@PAUIDirect3DIndexBuffer9@@@@XZ ; std::_Compressed_pair<xalloc<IDirect3DIndexBuffer9 *>,std::_Vector_val<std::_Simple_types<IDirect3DIndexBuffer9 *> >,1>::_Get_first
PUBLIC	?max_size@?$_Normal_allocator_traits@V?$xalloc@PAVIRender_Portal@@@@@std@@SAIABV?$xalloc@PAVIRender_Portal@@@@@Z ; std::_Normal_allocator_traits<xalloc<IRender_Portal *> >::max_size
PUBLIC	?capacity@?$vector@PAVIRender_Portal@@V?$xalloc@PAVIRender_Portal@@@@@std@@QBEIXZ ; std::vector<IRender_Portal *,xalloc<IRender_Portal *> >::capacity
PUBLIC	?_Umove_if_noexcept1@?$vector@PAVIRender_Portal@@V?$xalloc@PAVIRender_Portal@@@@@std@@AAEXPAPAVIRender_Portal@@00U?$integral_constant@_N$00@2@@Z ; std::vector<IRender_Portal *,xalloc<IRender_Portal *> >::_Umove_if_noexcept1
PUBLIC	?_Getal@?$vector@PAVIRender_Portal@@V?$xalloc@PAVIRender_Portal@@@@@std@@ABEABV?$xalloc@PAVIRender_Portal@@@@XZ ; std::vector<IRender_Portal *,xalloc<IRender_Portal *> >::_Getal
PUBLIC	?max_size@?$_Normal_allocator_traits@V?$xalloc@UFSlideWindowItem@@@@@std@@SAIABV?$xalloc@UFSlideWindowItem@@@@@Z ; std::_Normal_allocator_traits<xalloc<FSlideWindowItem> >::max_size
PUBLIC	?capacity@?$vector@UFSlideWindowItem@@V?$xalloc@UFSlideWindowItem@@@@@std@@QBEIXZ ; std::vector<FSlideWindowItem,xalloc<FSlideWindowItem> >::capacity
PUBLIC	?_Umove_if_noexcept1@?$vector@UFSlideWindowItem@@V?$xalloc@UFSlideWindowItem@@@@@std@@AAEXPAUFSlideWindowItem@@00U?$integral_constant@_N$00@2@@Z ; std::vector<FSlideWindowItem,xalloc<FSlideWindowItem> >::_Umove_if_noexcept1
PUBLIC	?_Getal@?$vector@UFSlideWindowItem@@V?$xalloc@UFSlideWindowItem@@@@@std@@ABEABV?$xalloc@UFSlideWindowItem@@@@XZ ; std::vector<FSlideWindowItem,xalloc<FSlideWindowItem> >::_Getal
PUBLIC	?max_size@?$_Normal_allocator_traits@V?$xalloc@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@@@std@@SAIABV?$xalloc@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@@@Z ; std::_Normal_allocator_traits<xalloc<resptr_core<Shader,resptrcode_shader> > >::max_size
PUBLIC	?capacity@?$vector@V?$resptr_core@UShader@@Uresptrcode_shader@@@@V?$xalloc@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@@@std@@QBEIXZ ; std::vector<resptr_core<Shader,resptrcode_shader>,xalloc<resptr_core<Shader,resptrcode_shader> > >::capacity
PUBLIC	?_Umove_if_noexcept1@?$vector@V?$resptr_core@UShader@@Uresptrcode_shader@@@@V?$xalloc@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@@@std@@AAEXPAV?$resptr_core@UShader@@Uresptrcode_shader@@@@00U?$integral_constant@_N$0A@@2@@Z ; std::vector<resptr_core<Shader,resptrcode_shader>,xalloc<resptr_core<Shader,resptrcode_shader> > >::_Umove_if_noexcept1
PUBLIC	?_Getal@?$vector@V?$resptr_core@UShader@@Uresptrcode_shader@@@@V?$xalloc@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@@@std@@ABEABV?$xalloc@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@@XZ ; std::vector<resptr_core<Shader,resptrcode_shader>,xalloc<resptr_core<Shader,resptrcode_shader> > >::_Getal
PUBLIC	?max_size@?$_Normal_allocator_traits@V?$xalloc@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@@@std@@SAIABV?$xalloc@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@@@Z ; std::_Normal_allocator_traits<xalloc<svector<_D3DVERTEXELEMENT9,65> > >::max_size
PUBLIC	?capacity@?$vector@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@V?$xalloc@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@@@std@@QBEIXZ ; std::vector<svector<_D3DVERTEXELEMENT9,65>,xalloc<svector<_D3DVERTEXELEMENT9,65> > >::capacity
PUBLIC	?_Umove_if_noexcept1@?$vector@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@V?$xalloc@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@@@std@@AAEXPAV?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@00U?$integral_constant@_N$00@2@@Z ; std::vector<svector<_D3DVERTEXELEMENT9,65>,xalloc<svector<_D3DVERTEXELEMENT9,65> > >::_Umove_if_noexcept1
PUBLIC	?_Getal@?$vector@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@V?$xalloc@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@@@std@@ABEABV?$xalloc@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@@XZ ; std::vector<svector<_D3DVERTEXELEMENT9,65>,xalloc<svector<_D3DVERTEXELEMENT9,65> > >::_Getal
PUBLIC	?max_size@?$_Normal_allocator_traits@V?$xalloc@PAUIDirect3DVertexBuffer9@@@@@std@@SAIABV?$xalloc@PAUIDirect3DVertexBuffer9@@@@@Z ; std::_Normal_allocator_traits<xalloc<IDirect3DVertexBuffer9 *> >::max_size
PUBLIC	?capacity@?$vector@PAUIDirect3DVertexBuffer9@@V?$xalloc@PAUIDirect3DVertexBuffer9@@@@@std@@QBEIXZ ; std::vector<IDirect3DVertexBuffer9 *,xalloc<IDirect3DVertexBuffer9 *> >::capacity
PUBLIC	?_Umove_if_noexcept1@?$vector@PAUIDirect3DVertexBuffer9@@V?$xalloc@PAUIDirect3DVertexBuffer9@@@@@std@@AAEXPAPAUIDirect3DVertexBuffer9@@00U?$integral_constant@_N$00@2@@Z ; std::vector<IDirect3DVertexBuffer9 *,xalloc<IDirect3DVertexBuffer9 *> >::_Umove_if_noexcept1
PUBLIC	?_Getal@?$vector@PAUIDirect3DVertexBuffer9@@V?$xalloc@PAUIDirect3DVertexBuffer9@@@@@std@@ABEABV?$xalloc@PAUIDirect3DVertexBuffer9@@@@XZ ; std::vector<IDirect3DVertexBuffer9 *,xalloc<IDirect3DVertexBuffer9 *> >::_Getal
PUBLIC	?max_size@?$_Normal_allocator_traits@V?$xalloc@PAUIDirect3DIndexBuffer9@@@@@std@@SAIABV?$xalloc@PAUIDirect3DIndexBuffer9@@@@@Z ; std::_Normal_allocator_traits<xalloc<IDirect3DIndexBuffer9 *> >::max_size
PUBLIC	?capacity@?$vector@PAUIDirect3DIndexBuffer9@@V?$xalloc@PAUIDirect3DIndexBuffer9@@@@@std@@QBEIXZ ; std::vector<IDirect3DIndexBuffer9 *,xalloc<IDirect3DIndexBuffer9 *> >::capacity
PUBLIC	?_Umove_if_noexcept1@?$vector@PAUIDirect3DIndexBuffer9@@V?$xalloc@PAUIDirect3DIndexBuffer9@@@@@std@@AAEXPAPAUIDirect3DIndexBuffer9@@00U?$integral_constant@_N$00@2@@Z ; std::vector<IDirect3DIndexBuffer9 *,xalloc<IDirect3DIndexBuffer9 *> >::_Umove_if_noexcept1
PUBLIC	?_Getal@?$vector@PAUIDirect3DIndexBuffer9@@V?$xalloc@PAUIDirect3DIndexBuffer9@@@@@std@@ABEABV?$xalloc@PAUIDirect3DIndexBuffer9@@@@XZ ; std::vector<IDirect3DIndexBuffer9 *,xalloc<IDirect3DIndexBuffer9 *> >::_Getal
PUBLIC	?allocate@?$xalloc@PAVIRender_Portal@@@@QBEPAPAVIRender_Portal@@IPBX@Z ; xalloc<IRender_Portal *>::allocate
PUBLIC	?max_size@?$vector@PAVIRender_Portal@@V?$xalloc@PAVIRender_Portal@@@@@std@@QBEIXZ ; std::vector<IRender_Portal *,xalloc<IRender_Portal *> >::max_size
PUBLIC	?_Umove_if_noexcept@?$vector@PAVIRender_Portal@@V?$xalloc@PAVIRender_Portal@@@@@std@@AAEXPAPAVIRender_Portal@@00@Z ; std::vector<IRender_Portal *,xalloc<IRender_Portal *> >::_Umove_if_noexcept
PUBLIC	?_Calculate_growth@?$vector@PAVIRender_Portal@@V?$xalloc@PAVIRender_Portal@@@@@std@@ABEII@Z ; std::vector<IRender_Portal *,xalloc<IRender_Portal *> >::_Calculate_growth
PUBLIC	?_Change_array@?$vector@PAVIRender_Portal@@V?$xalloc@PAVIRender_Portal@@@@@std@@AAEXQAPAVIRender_Portal@@II@Z ; std::vector<IRender_Portal *,xalloc<IRender_Portal *> >::_Change_array
PUBLIC	?_Xlength@?$vector@PAVIRender_Portal@@V?$xalloc@PAVIRender_Portal@@@@@std@@CAXXZ ; std::vector<IRender_Portal *,xalloc<IRender_Portal *> >::_Xlength
PUBLIC	?allocate@?$xalloc@UFSlideWindowItem@@@@QBEPAUFSlideWindowItem@@IPBX@Z ; xalloc<FSlideWindowItem>::allocate
PUBLIC	?max_size@?$vector@UFSlideWindowItem@@V?$xalloc@UFSlideWindowItem@@@@@std@@QBEIXZ ; std::vector<FSlideWindowItem,xalloc<FSlideWindowItem> >::max_size
PUBLIC	?_Umove_if_noexcept@?$vector@UFSlideWindowItem@@V?$xalloc@UFSlideWindowItem@@@@@std@@AAEXPAUFSlideWindowItem@@00@Z ; std::vector<FSlideWindowItem,xalloc<FSlideWindowItem> >::_Umove_if_noexcept
PUBLIC	?_Calculate_growth@?$vector@UFSlideWindowItem@@V?$xalloc@UFSlideWindowItem@@@@@std@@ABEII@Z ; std::vector<FSlideWindowItem,xalloc<FSlideWindowItem> >::_Calculate_growth
PUBLIC	?_Change_array@?$vector@UFSlideWindowItem@@V?$xalloc@UFSlideWindowItem@@@@@std@@AAEXQAUFSlideWindowItem@@II@Z ; std::vector<FSlideWindowItem,xalloc<FSlideWindowItem> >::_Change_array
PUBLIC	?_Xlength@?$vector@UFSlideWindowItem@@V?$xalloc@UFSlideWindowItem@@@@@std@@CAXXZ ; std::vector<FSlideWindowItem,xalloc<FSlideWindowItem> >::_Xlength
PUBLIC	?allocate@?$xalloc@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@@QBEPAV?$resptr_core@UShader@@Uresptrcode_shader@@@@IPBX@Z ; xalloc<resptr_core<Shader,resptrcode_shader> >::allocate
PUBLIC	?max_size@?$vector@V?$resptr_core@UShader@@Uresptrcode_shader@@@@V?$xalloc@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@@@std@@QBEIXZ ; std::vector<resptr_core<Shader,resptrcode_shader>,xalloc<resptr_core<Shader,resptrcode_shader> > >::max_size
PUBLIC	?_Umove_if_noexcept@?$vector@V?$resptr_core@UShader@@Uresptrcode_shader@@@@V?$xalloc@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@@@std@@AAEXPAV?$resptr_core@UShader@@Uresptrcode_shader@@@@00@Z ; std::vector<resptr_core<Shader,resptrcode_shader>,xalloc<resptr_core<Shader,resptrcode_shader> > >::_Umove_if_noexcept
PUBLIC	?_Calculate_growth@?$vector@V?$resptr_core@UShader@@Uresptrcode_shader@@@@V?$xalloc@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@@@std@@ABEII@Z ; std::vector<resptr_core<Shader,resptrcode_shader>,xalloc<resptr_core<Shader,resptrcode_shader> > >::_Calculate_growth
PUBLIC	?_Change_array@?$vector@V?$resptr_core@UShader@@Uresptrcode_shader@@@@V?$xalloc@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@@@std@@AAEXQAV?$resptr_core@UShader@@Uresptrcode_shader@@@@II@Z ; std::vector<resptr_core<Shader,resptrcode_shader>,xalloc<resptr_core<Shader,resptrcode_shader> > >::_Change_array
PUBLIC	?_Xlength@?$vector@V?$resptr_core@UShader@@Uresptrcode_shader@@@@V?$xalloc@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@@@std@@CAXXZ ; std::vector<resptr_core<Shader,resptrcode_shader>,xalloc<resptr_core<Shader,resptrcode_shader> > >::_Xlength
PUBLIC	?allocate@?$xalloc@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@@QBEPAV?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@IPBX@Z ; xalloc<svector<_D3DVERTEXELEMENT9,65> >::allocate
PUBLIC	?max_size@?$vector@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@V?$xalloc@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@@@std@@QBEIXZ ; std::vector<svector<_D3DVERTEXELEMENT9,65>,xalloc<svector<_D3DVERTEXELEMENT9,65> > >::max_size
PUBLIC	?_Umove_if_noexcept@?$vector@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@V?$xalloc@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@@@std@@AAEXPAV?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@00@Z ; std::vector<svector<_D3DVERTEXELEMENT9,65>,xalloc<svector<_D3DVERTEXELEMENT9,65> > >::_Umove_if_noexcept
PUBLIC	?_Calculate_growth@?$vector@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@V?$xalloc@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@@@std@@ABEII@Z ; std::vector<svector<_D3DVERTEXELEMENT9,65>,xalloc<svector<_D3DVERTEXELEMENT9,65> > >::_Calculate_growth
PUBLIC	?_Change_array@?$vector@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@V?$xalloc@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@@@std@@AAEXQAV?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@II@Z ; std::vector<svector<_D3DVERTEXELEMENT9,65>,xalloc<svector<_D3DVERTEXELEMENT9,65> > >::_Change_array
PUBLIC	?_Xlength@?$vector@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@V?$xalloc@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@@@std@@CAXXZ ; std::vector<svector<_D3DVERTEXELEMENT9,65>,xalloc<svector<_D3DVERTEXELEMENT9,65> > >::_Xlength
PUBLIC	?allocate@?$xalloc@PAUIDirect3DVertexBuffer9@@@@QBEPAPAUIDirect3DVertexBuffer9@@IPBX@Z ; xalloc<IDirect3DVertexBuffer9 *>::allocate
PUBLIC	?max_size@?$vector@PAUIDirect3DVertexBuffer9@@V?$xalloc@PAUIDirect3DVertexBuffer9@@@@@std@@QBEIXZ ; std::vector<IDirect3DVertexBuffer9 *,xalloc<IDirect3DVertexBuffer9 *> >::max_size
PUBLIC	?_Umove_if_noexcept@?$vector@PAUIDirect3DVertexBuffer9@@V?$xalloc@PAUIDirect3DVertexBuffer9@@@@@std@@AAEXPAPAUIDirect3DVertexBuffer9@@00@Z ; std::vector<IDirect3DVertexBuffer9 *,xalloc<IDirect3DVertexBuffer9 *> >::_Umove_if_noexcept
PUBLIC	?_Calculate_growth@?$vector@PAUIDirect3DVertexBuffer9@@V?$xalloc@PAUIDirect3DVertexBuffer9@@@@@std@@ABEII@Z ; std::vector<IDirect3DVertexBuffer9 *,xalloc<IDirect3DVertexBuffer9 *> >::_Calculate_growth
PUBLIC	?_Change_array@?$vector@PAUIDirect3DVertexBuffer9@@V?$xalloc@PAUIDirect3DVertexBuffer9@@@@@std@@AAEXQAPAUIDirect3DVertexBuffer9@@II@Z ; std::vector<IDirect3DVertexBuffer9 *,xalloc<IDirect3DVertexBuffer9 *> >::_Change_array
PUBLIC	?_Xlength@?$vector@PAUIDirect3DVertexBuffer9@@V?$xalloc@PAUIDirect3DVertexBuffer9@@@@@std@@CAXXZ ; std::vector<IDirect3DVertexBuffer9 *,xalloc<IDirect3DVertexBuffer9 *> >::_Xlength
PUBLIC	?allocate@?$xalloc@PAUIDirect3DIndexBuffer9@@@@QBEPAPAUIDirect3DIndexBuffer9@@IPBX@Z ; xalloc<IDirect3DIndexBuffer9 *>::allocate
PUBLIC	?max_size@?$vector@PAUIDirect3DIndexBuffer9@@V?$xalloc@PAUIDirect3DIndexBuffer9@@@@@std@@QBEIXZ ; std::vector<IDirect3DIndexBuffer9 *,xalloc<IDirect3DIndexBuffer9 *> >::max_size
PUBLIC	?_Umove_if_noexcept@?$vector@PAUIDirect3DIndexBuffer9@@V?$xalloc@PAUIDirect3DIndexBuffer9@@@@@std@@AAEXPAPAUIDirect3DIndexBuffer9@@00@Z ; std::vector<IDirect3DIndexBuffer9 *,xalloc<IDirect3DIndexBuffer9 *> >::_Umove_if_noexcept
PUBLIC	?_Calculate_growth@?$vector@PAUIDirect3DIndexBuffer9@@V?$xalloc@PAUIDirect3DIndexBuffer9@@@@@std@@ABEII@Z ; std::vector<IDirect3DIndexBuffer9 *,xalloc<IDirect3DIndexBuffer9 *> >::_Calculate_growth
PUBLIC	?_Change_array@?$vector@PAUIDirect3DIndexBuffer9@@V?$xalloc@PAUIDirect3DIndexBuffer9@@@@@std@@AAEXQAPAUIDirect3DIndexBuffer9@@II@Z ; std::vector<IDirect3DIndexBuffer9 *,xalloc<IDirect3DIndexBuffer9 *> >::_Change_array
PUBLIC	?_Xlength@?$vector@PAUIDirect3DIndexBuffer9@@V?$xalloc@PAUIDirect3DIndexBuffer9@@@@@std@@CAXXZ ; std::vector<IDirect3DIndexBuffer9 *,xalloc<IDirect3DIndexBuffer9 *> >::_Xlength
PUBLIC	??0?$_Uninitialized_backout_al@V?$xalloc@PAUIDirect3DIndexBuffer9@@@@@std@@QAE@PAPAUIDirect3DIndexBuffer9@@AAV?$xalloc@PAUIDirect3DIndexBuffer9@@@@@Z ; std::_Uninitialized_backout_al<xalloc<IDirect3DIndexBuffer9 *> >::_Uninitialized_backout_al<xalloc<IDirect3DIndexBuffer9 *> >
PUBLIC	??1?$_Uninitialized_backout_al@V?$xalloc@PAUIDirect3DIndexBuffer9@@@@@std@@QAE@XZ ; std::_Uninitialized_backout_al<xalloc<IDirect3DIndexBuffer9 *> >::~_Uninitialized_backout_al<xalloc<IDirect3DIndexBuffer9 *> >
PUBLIC	?_Release@?$_Uninitialized_backout_al@V?$xalloc@PAUIDirect3DIndexBuffer9@@@@@std@@QAEPAPAUIDirect3DIndexBuffer9@@XZ ; std::_Uninitialized_backout_al<xalloc<IDirect3DIndexBuffer9 *> >::_Release
PUBLIC	??0?$_Uninitialized_backout_al@V?$xalloc@PAUIDirect3DVertexBuffer9@@@@@std@@QAE@PAPAUIDirect3DVertexBuffer9@@AAV?$xalloc@PAUIDirect3DVertexBuffer9@@@@@Z ; std::_Uninitialized_backout_al<xalloc<IDirect3DVertexBuffer9 *> >::_Uninitialized_backout_al<xalloc<IDirect3DVertexBuffer9 *> >
PUBLIC	??1?$_Uninitialized_backout_al@V?$xalloc@PAUIDirect3DVertexBuffer9@@@@@std@@QAE@XZ ; std::_Uninitialized_backout_al<xalloc<IDirect3DVertexBuffer9 *> >::~_Uninitialized_backout_al<xalloc<IDirect3DVertexBuffer9 *> >
PUBLIC	?_Release@?$_Uninitialized_backout_al@V?$xalloc@PAUIDirect3DVertexBuffer9@@@@@std@@QAEPAPAUIDirect3DVertexBuffer9@@XZ ; std::_Uninitialized_backout_al<xalloc<IDirect3DVertexBuffer9 *> >::_Release
PUBLIC	??0?$_Uninitialized_backout_al@V?$xalloc@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@@@std@@QAE@PAV?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@AAV?$xalloc@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@@@Z ; std::_Uninitialized_backout_al<xalloc<svector<_D3DVERTEXELEMENT9,65> > >::_Uninitialized_backout_al<xalloc<svector<_D3DVERTEXELEMENT9,65> > >
PUBLIC	??1?$_Uninitialized_backout_al@V?$xalloc@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@@@std@@QAE@XZ ; std::_Uninitialized_backout_al<xalloc<svector<_D3DVERTEXELEMENT9,65> > >::~_Uninitialized_backout_al<xalloc<svector<_D3DVERTEXELEMENT9,65> > >
PUBLIC	?_Release@?$_Uninitialized_backout_al@V?$xalloc@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@@@std@@QAEPAV?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@XZ ; std::_Uninitialized_backout_al<xalloc<svector<_D3DVERTEXELEMENT9,65> > >::_Release
PUBLIC	??0?$_Uninitialized_backout_al@V?$xalloc@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@@@std@@QAE@PAV?$resptr_core@UShader@@Uresptrcode_shader@@@@AAV?$xalloc@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@@@Z ; std::_Uninitialized_backout_al<xalloc<resptr_core<Shader,resptrcode_shader> > >::_Uninitialized_backout_al<xalloc<resptr_core<Shader,resptrcode_shader> > >
PUBLIC	??1?$_Uninitialized_backout_al@V?$xalloc@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@@@std@@QAE@XZ ; std::_Uninitialized_backout_al<xalloc<resptr_core<Shader,resptrcode_shader> > >::~_Uninitialized_backout_al<xalloc<resptr_core<Shader,resptrcode_shader> > >
PUBLIC	?_Release@?$_Uninitialized_backout_al@V?$xalloc@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@@@std@@QAEPAV?$resptr_core@UShader@@Uresptrcode_shader@@@@XZ ; std::_Uninitialized_backout_al<xalloc<resptr_core<Shader,resptrcode_shader> > >::_Release
PUBLIC	??0?$_Uninitialized_backout_al@V?$xalloc@UFSlideWindowItem@@@@@std@@QAE@PAUFSlideWindowItem@@AAV?$xalloc@UFSlideWindowItem@@@@@Z ; std::_Uninitialized_backout_al<xalloc<FSlideWindowItem> >::_Uninitialized_backout_al<xalloc<FSlideWindowItem> >
PUBLIC	??1?$_Uninitialized_backout_al@V?$xalloc@UFSlideWindowItem@@@@@std@@QAE@XZ ; std::_Uninitialized_backout_al<xalloc<FSlideWindowItem> >::~_Uninitialized_backout_al<xalloc<FSlideWindowItem> >
PUBLIC	?_Release@?$_Uninitialized_backout_al@V?$xalloc@UFSlideWindowItem@@@@@std@@QAEPAUFSlideWindowItem@@XZ ; std::_Uninitialized_backout_al<xalloc<FSlideWindowItem> >::_Release
PUBLIC	??0?$_Uninitialized_backout_al@V?$xalloc@PAVIRender_Portal@@@@@std@@QAE@PAPAVIRender_Portal@@AAV?$xalloc@PAVIRender_Portal@@@@@Z ; std::_Uninitialized_backout_al<xalloc<IRender_Portal *> >::_Uninitialized_backout_al<xalloc<IRender_Portal *> >
PUBLIC	??1?$_Uninitialized_backout_al@V?$xalloc@PAVIRender_Portal@@@@@std@@QAE@XZ ; std::_Uninitialized_backout_al<xalloc<IRender_Portal *> >::~_Uninitialized_backout_al<xalloc<IRender_Portal *> >
PUBLIC	?_Release@?$_Uninitialized_backout_al@V?$xalloc@PAVIRender_Portal@@@@@std@@QAEPAPAVIRender_Portal@@XZ ; std::_Uninitialized_backout_al<xalloc<IRender_Portal *> >::_Release
PUBLIC	??$_Uninitialized_value_construct_n@V?$xalloc@PAVIRender_Portal@@@@@std@@YAPAPAVIRender_Portal@@PAPAV1@IAAV?$xalloc@PAVIRender_Portal@@@@@Z ; std::_Uninitialized_value_construct_n<xalloc<IRender_Portal *> >
PUBLIC	??$_Uninitialized_value_construct_n@V?$xalloc@UFSlideWindowItem@@@@@std@@YAPAUFSlideWindowItem@@PAU1@IAAV?$xalloc@UFSlideWindowItem@@@@@Z ; std::_Uninitialized_value_construct_n<xalloc<FSlideWindowItem> >
PUBLIC	??$_Uninitialized_value_construct_n@V?$xalloc@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@@@std@@YAPAV?$resptr_core@UShader@@Uresptrcode_shader@@@@PAV1@IAAV?$xalloc@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@@@Z ; std::_Uninitialized_value_construct_n<xalloc<resptr_core<Shader,resptrcode_shader> > >
PUBLIC	??$_Uninitialized_value_construct_n@V?$xalloc@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@@@std@@YAPAV?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@PAV1@IAAV?$xalloc@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@@@Z ; std::_Uninitialized_value_construct_n<xalloc<svector<_D3DVERTEXELEMENT9,65> > >
PUBLIC	??$_Uninitialized_value_construct_n@V?$xalloc@PAUIDirect3DVertexBuffer9@@@@@std@@YAPAPAUIDirect3DVertexBuffer9@@PAPAU1@IAAV?$xalloc@PAUIDirect3DVertexBuffer9@@@@@Z ; std::_Uninitialized_value_construct_n<xalloc<IDirect3DVertexBuffer9 *> >
PUBLIC	??$_Uninitialized_value_construct_n@V?$xalloc@PAUIDirect3DIndexBuffer9@@@@@std@@YAPAPAUIDirect3DIndexBuffer9@@PAPAU1@IAAV?$xalloc@PAUIDirect3DIndexBuffer9@@@@@Z ; std::_Uninitialized_value_construct_n<xalloc<IDirect3DIndexBuffer9 *> >
PUBLIC	??$move@AAUFSlideWindowItem@@@std@@YA$$QAUFSlideWindowItem@@AAU1@@Z ; std::move<FSlideWindowItem &>
PUBLIC	??$_To_address@PAUFSlideWindowItem@@@std@@YA?A_PABQAUFSlideWindowItem@@@Z ; std::_To_address<FSlideWindowItem *>
PUBLIC	??$_Copy_memmove@PAUFSlideWindowItem@@PAU1@@std@@YAPAUFSlideWindowItem@@PAU1@00@Z ; std::_Copy_memmove<FSlideWindowItem *,FSlideWindowItem *>
PUBLIC	??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@PAVIRender_Portal@@V?$xalloc@PAVIRender_Portal@@@@@std@@AAEXIABU_Value_init_tag@1@@Z ; std::vector<IRender_Portal *,xalloc<IRender_Portal *> >::_Resize_reallocate<std::_Value_init_tag>
PUBLIC	??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UFSlideWindowItem@@V?$xalloc@UFSlideWindowItem@@@@@std@@AAEXIABU_Value_init_tag@1@@Z ; std::vector<FSlideWindowItem,xalloc<FSlideWindowItem> >::_Resize_reallocate<std::_Value_init_tag>
PUBLIC	??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@V?$resptr_core@UShader@@Uresptrcode_shader@@@@V?$xalloc@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@@@std@@AAEXIABU_Value_init_tag@1@@Z ; std::vector<resptr_core<Shader,resptrcode_shader>,xalloc<resptr_core<Shader,resptrcode_shader> > >::_Resize_reallocate<std::_Value_init_tag>
PUBLIC	??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@V?$xalloc@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@@@std@@AAEXIABU_Value_init_tag@1@@Z ; std::vector<svector<_D3DVERTEXELEMENT9,65>,xalloc<svector<_D3DVERTEXELEMENT9,65> > >::_Resize_reallocate<std::_Value_init_tag>
PUBLIC	??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@PAUIDirect3DVertexBuffer9@@V?$xalloc@PAUIDirect3DVertexBuffer9@@@@@std@@AAEXIABU_Value_init_tag@1@@Z ; std::vector<IDirect3DVertexBuffer9 *,xalloc<IDirect3DVertexBuffer9 *> >::_Resize_reallocate<std::_Value_init_tag>
PUBLIC	??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@PAUIDirect3DIndexBuffer9@@V?$xalloc@PAUIDirect3DIndexBuffer9@@@@@std@@AAEXIABU_Value_init_tag@1@@Z ; std::vector<IDirect3DIndexBuffer9 *,xalloc<IDirect3DIndexBuffer9 *> >::_Resize_reallocate<std::_Value_init_tag>
PUBLIC	??_GCWallmarksEngine@@QAEPAXI@Z			; CWallmarksEngine::`scalar deleting destructor'
PUBLIC	??_GCGlowManager@@QAEPAXI@Z			; CGlowManager::`scalar deleting destructor'
PUBLIC	??_GCLight_DB@@QAEPAXI@Z			; CLight_DB::`scalar deleting destructor'
PUBLIC	??_GCLightProjector@@QAEPAXI@Z			; CLightProjector::`scalar deleting destructor'
PUBLIC	??_GCLightShadows@@QAEPAXI@Z			; CLightShadows::`scalar deleting destructor'
PUBLIC	?_Ufill@?$vector@PAVIRender_Portal@@V?$xalloc@PAVIRender_Portal@@@@@std@@AAEPAPAVIRender_Portal@@PAPAV3@IU_Value_init_tag@2@@Z ; std::vector<IRender_Portal *,xalloc<IRender_Portal *> >::_Ufill
PUBLIC	?_Orphan_range@?$vector@PAVIRender_Portal@@V?$xalloc@PAVIRender_Portal@@@@@std@@ABEXPAPAVIRender_Portal@@0@Z ; std::vector<IRender_Portal *,xalloc<IRender_Portal *> >::_Orphan_range
PUBLIC	?_Ufill@?$vector@UFSlideWindowItem@@V?$xalloc@UFSlideWindowItem@@@@@std@@AAEPAUFSlideWindowItem@@PAU3@IU_Value_init_tag@2@@Z ; std::vector<FSlideWindowItem,xalloc<FSlideWindowItem> >::_Ufill
PUBLIC	?_Ufill@?$vector@V?$resptr_core@UShader@@Uresptrcode_shader@@@@V?$xalloc@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@@@std@@AAEPAV?$resptr_core@UShader@@Uresptrcode_shader@@@@PAV3@IU_Value_init_tag@2@@Z ; std::vector<resptr_core<Shader,resptrcode_shader>,xalloc<resptr_core<Shader,resptrcode_shader> > >::_Ufill
PUBLIC	?_Orphan_range@?$vector@V?$resptr_core@UShader@@Uresptrcode_shader@@@@V?$xalloc@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@@@std@@ABEXPAV?$resptr_core@UShader@@Uresptrcode_shader@@@@0@Z ; std::vector<resptr_core<Shader,resptrcode_shader>,xalloc<resptr_core<Shader,resptrcode_shader> > >::_Orphan_range
PUBLIC	?_Ufill@?$vector@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@V?$xalloc@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@@@std@@AAEPAV?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@PAV3@IU_Value_init_tag@2@@Z ; std::vector<svector<_D3DVERTEXELEMENT9,65>,xalloc<svector<_D3DVERTEXELEMENT9,65> > >::_Ufill
PUBLIC	?_Orphan_range@?$vector@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@V?$xalloc@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@@@std@@ABEXPAV?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@0@Z ; std::vector<svector<_D3DVERTEXELEMENT9,65>,xalloc<svector<_D3DVERTEXELEMENT9,65> > >::_Orphan_range
PUBLIC	?_Ufill@?$vector@PAUIDirect3DVertexBuffer9@@V?$xalloc@PAUIDirect3DVertexBuffer9@@@@@std@@AAEPAPAUIDirect3DVertexBuffer9@@PAPAU3@IU_Value_init_tag@2@@Z ; std::vector<IDirect3DVertexBuffer9 *,xalloc<IDirect3DVertexBuffer9 *> >::_Ufill
PUBLIC	?_Orphan_range@?$vector@PAUIDirect3DVertexBuffer9@@V?$xalloc@PAUIDirect3DVertexBuffer9@@@@@std@@ABEXPAPAUIDirect3DVertexBuffer9@@0@Z ; std::vector<IDirect3DVertexBuffer9 *,xalloc<IDirect3DVertexBuffer9 *> >::_Orphan_range
PUBLIC	?_Ufill@?$vector@PAUIDirect3DIndexBuffer9@@V?$xalloc@PAUIDirect3DIndexBuffer9@@@@@std@@AAEPAPAUIDirect3DIndexBuffer9@@PAPAU3@IU_Value_init_tag@2@@Z ; std::vector<IDirect3DIndexBuffer9 *,xalloc<IDirect3DIndexBuffer9 *> >::_Ufill
PUBLIC	?_Orphan_range@?$vector@PAUIDirect3DIndexBuffer9@@V?$xalloc@PAUIDirect3DIndexBuffer9@@@@@std@@ABEXPAPAUIDirect3DIndexBuffer9@@0@Z ; std::vector<IDirect3DIndexBuffer9 *,xalloc<IDirect3DIndexBuffer9 *> >::_Orphan_range
PUBLIC	??R?$xr_special_free@$00VIRender_Sector@@@@QAEXAAPAVIRender_Sector@@@Z ; xr_special_free<1,IRender_Sector>::operator()
PUBLIC	??R?$xr_special_free@$00VIRender_Portal@@@@QAEXAAPAVIRender_Portal@@@Z ; xr_special_free<1,IRender_Portal>::operator()
PUBLIC	??R?$xr_special_free@$00VCDetailManager@@@@QAEXAAPAVCDetailManager@@@Z ; xr_special_free<1,CDetailManager>::operator()
PUBLIC	??R?$xr_special_free@$0A@VCWallmarksEngine@@@@QAEXAAPAVCWallmarksEngine@@@Z ; xr_special_free<0,CWallmarksEngine>::operator()
PUBLIC	??R?$xr_special_free@$0A@VCGlowManager@@@@QAEXAAPAVCGlowManager@@@Z ; xr_special_free<0,CGlowManager>::operator()
PUBLIC	??R?$xr_special_free@$0A@VCLight_DB@@@@QAEXAAPAVCLight_DB@@@Z ; xr_special_free<0,CLight_DB>::operator()
PUBLIC	??R?$xr_special_free@$00VCLightProjector@@@@QAEXAAPAVCLightProjector@@@Z ; xr_special_free<1,CLightProjector>::operator()
PUBLIC	??R?$xr_special_free@$0A@VCLightShadows@@@@QAEXAAPAVCLightShadows@@@Z ; xr_special_free<0,CLightShadows>::operator()
PUBLIC	??$_Move_unchecked@PAUFSlideWindowItem@@PAU1@@std@@YAPAUFSlideWindowItem@@PAU1@00@Z ; std::_Move_unchecked<FSlideWindowItem *,FSlideWindowItem *>
PUBLIC	??$_Resize@U_Value_init_tag@std@@@?$vector@PAVIRender_Portal@@V?$xalloc@PAVIRender_Portal@@@@@std@@AAEXIABU_Value_init_tag@1@@Z ; std::vector<IRender_Portal *,xalloc<IRender_Portal *> >::_Resize<std::_Value_init_tag>
PUBLIC	??$_Resize@U_Value_init_tag@std@@@?$vector@UFSlideWindowItem@@V?$xalloc@UFSlideWindowItem@@@@@std@@AAEXIABU_Value_init_tag@1@@Z ; std::vector<FSlideWindowItem,xalloc<FSlideWindowItem> >::_Resize<std::_Value_init_tag>
PUBLIC	??$_Resize@U_Value_init_tag@std@@@?$vector@V?$resptr_core@UShader@@Uresptrcode_shader@@@@V?$xalloc@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@@@std@@AAEXIABU_Value_init_tag@1@@Z ; std::vector<resptr_core<Shader,resptrcode_shader>,xalloc<resptr_core<Shader,resptrcode_shader> > >::_Resize<std::_Value_init_tag>
PUBLIC	??$_Resize@U_Value_init_tag@std@@@?$vector@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@V?$xalloc@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@@@std@@AAEXIABU_Value_init_tag@1@@Z ; std::vector<svector<_D3DVERTEXELEMENT9,65>,xalloc<svector<_D3DVERTEXELEMENT9,65> > >::_Resize<std::_Value_init_tag>
PUBLIC	??$_Resize@U_Value_init_tag@std@@@?$vector@PAUIDirect3DVertexBuffer9@@V?$xalloc@PAUIDirect3DVertexBuffer9@@@@@std@@AAEXIABU_Value_init_tag@1@@Z ; std::vector<IDirect3DVertexBuffer9 *,xalloc<IDirect3DVertexBuffer9 *> >::_Resize<std::_Value_init_tag>
PUBLIC	??$_Resize@U_Value_init_tag@std@@@?$vector@PAUIDirect3DIndexBuffer9@@V?$xalloc@PAUIDirect3DIndexBuffer9@@@@@std@@AAEXIABU_Value_init_tag@1@@Z ; std::vector<IDirect3DIndexBuffer9 *,xalloc<IDirect3DIndexBuffer9 *> >::_Resize<std::_Value_init_tag>
PUBLIC	??$xr_new@VCSector@@@@YAPAVCSector@@XZ		; xr_new<CSector>
PUBLIC	??$xr_new@VCPortal@@@@YAPAVCPortal@@XZ		; xr_new<CPortal>
PUBLIC	??$xr_delete@VCLightShadows@@@@YAXAAPAVCLightShadows@@@Z ; xr_delete<CLightShadows>
PUBLIC	??$xr_delete@VCLightProjector@@@@YAXAAPAVCLightProjector@@@Z ; xr_delete<CLightProjector>
PUBLIC	??$xr_delete@VCLight_DB@@@@YAXAAPAVCLight_DB@@@Z ; xr_delete<CLight_DB>
PUBLIC	??$xr_delete@VCGlowManager@@@@YAXAAPAVCGlowManager@@@Z ; xr_delete<CGlowManager>
PUBLIC	??$xr_delete@VCWallmarksEngine@@@@YAXAAPAVCWallmarksEngine@@@Z ; xr_delete<CWallmarksEngine>
PUBLIC	??$xr_delete@VCDetailManager@@@@YAXAAPAVCDetailManager@@@Z ; xr_delete<CDetailManager>
PUBLIC	??$xr_delete@VIRender_Portal@@@@YAXAAPAVIRender_Portal@@@Z ; xr_delete<IRender_Portal>
PUBLIC	??$xr_delete@VIRender_Sector@@@@YAXAAPAVIRender_Sector@@@Z ; xr_delete<IRender_Sector>
PUBLIC	??$xr_new@VCDetailManager@@@@YAPAVCDetailManager@@XZ ; xr_new<CDetailManager>
PUBLIC	??$xr_new@VCWallmarksEngine@@@@YAPAVCWallmarksEngine@@XZ ; xr_new<CWallmarksEngine>
PUBLIC	??$xr_new@VCGlowManager@@@@YAPAVCGlowManager@@XZ ; xr_new<CGlowManager>
PUBLIC	??$xr_new@VCLight_DB@@@@YAPAVCLight_DB@@XZ	; xr_new<CLight_DB>
PUBLIC	??$xr_new@VCLightProjector@@@@YAPAVCLightProjector@@XZ ; xr_new<CLightProjector>
PUBLIC	??$xr_new@VCLightShadows@@@@YAPAVCLightShadows@@XZ ; xr_new<CLightShadows>
PUBLIC	?clear@?$vector@UFSlideWindowItem@@V?$xalloc@UFSlideWindowItem@@@@@std@@QAEXXZ ; std::vector<FSlideWindowItem,xalloc<FSlideWindowItem> >::clear
PUBLIC	?_Orphan_range@?$vector@UFSlideWindowItem@@V?$xalloc@UFSlideWindowItem@@@@@std@@ABEXPAUFSlideWindowItem@@0@Z ; std::vector<FSlideWindowItem,xalloc<FSlideWindowItem> >::_Orphan_range
PUBLIC	?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UFSlideWindowItem@@@std@@@std@@@std@@QBEXABV12@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<FSlideWindowItem> > >::_Compat
PUBLIC	?clear@?$vector@PAVIRender_Portal@@V?$xalloc@PAVIRender_Portal@@@@@std@@QAEXXZ ; std::vector<IRender_Portal *,xalloc<IRender_Portal *> >::clear
PUBLIC	?size@?$vector@PAVIRender_Portal@@V?$xalloc@PAVIRender_Portal@@@@@std@@QBEIXZ ; std::vector<IRender_Portal *,xalloc<IRender_Portal *> >::size
PUBLIC	?erase@?$vector@UFSlideWindowItem@@V?$xalloc@UFSlideWindowItem@@@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UFSlideWindowItem@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UFSlideWindowItem@@@std@@@std@@@2@0@Z ; std::vector<FSlideWindowItem,xalloc<FSlideWindowItem> >::erase
PUBLIC	?size@?$vector@UFSlideWindowItem@@V?$xalloc@UFSlideWindowItem@@@@@std@@QBEIXZ ; std::vector<FSlideWindowItem,xalloc<FSlideWindowItem> >::size
PUBLIC	?clear_and_free@?$xr_vector@UFSlideWindowItem@@V?$xalloc@UFSlideWindowItem@@@@@@QAEXXZ ; xr_vector<FSlideWindowItem,xalloc<FSlideWindowItem> >::clear_and_free
PUBLIC	?clear@?$vector@V?$resptr_core@UShader@@Uresptrcode_shader@@@@V?$xalloc@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@@@std@@QAEXXZ ; std::vector<resptr_core<Shader,resptrcode_shader>,xalloc<resptr_core<Shader,resptrcode_shader> > >::clear
PUBLIC	?clear@?$vector@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@V?$xalloc@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@@@std@@QAEXXZ ; std::vector<svector<_D3DVERTEXELEMENT9,65>,xalloc<svector<_D3DVERTEXELEMENT9,65> > >::clear
PUBLIC	?clear@?$vector@PAUIDirect3DVertexBuffer9@@V?$xalloc@PAUIDirect3DVertexBuffer9@@@@@std@@QAEXXZ ; std::vector<IDirect3DVertexBuffer9 *,xalloc<IDirect3DVertexBuffer9 *> >::clear
PUBLIC	?size@?$vector@PAUIDirect3DVertexBuffer9@@V?$xalloc@PAUIDirect3DVertexBuffer9@@@@@std@@QBEIXZ ; std::vector<IDirect3DVertexBuffer9 *,xalloc<IDirect3DVertexBuffer9 *> >::size
PUBLIC	?clear@?$vector@PAUIDirect3DIndexBuffer9@@V?$xalloc@PAUIDirect3DIndexBuffer9@@@@@std@@QAEXXZ ; std::vector<IDirect3DIndexBuffer9 *,xalloc<IDirect3DIndexBuffer9 *> >::clear
PUBLIC	?size@?$vector@PAUIDirect3DIndexBuffer9@@V?$xalloc@PAUIDirect3DIndexBuffer9@@@@@std@@QBEIXZ ; std::vector<IDirect3DIndexBuffer9 *,xalloc<IDirect3DIndexBuffer9 *> >::size
PUBLIC	??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UFSlideWindowItem@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<FSlideWindowItem> > >::operator++
PUBLIC	??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UFSlideWindowItem@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<FSlideWindowItem> > >::operator==
PUBLIC	?resize@?$vector@PAVIRender_Portal@@V?$xalloc@PAVIRender_Portal@@@@@std@@QAEXI@Z ; std::vector<IRender_Portal *,xalloc<IRender_Portal *> >::resize
PUBLIC	?size@?$xr_vector@PAVIRender_Portal@@V?$xalloc@PAVIRender_Portal@@@@@@QBEIXZ ; xr_vector<IRender_Portal *,xalloc<IRender_Portal *> >::size
PUBLIC	?clear_and_free@?$xr_vector@PAVIRender_Portal@@V?$xalloc@PAVIRender_Portal@@@@@@QAEXXZ ; xr_vector<IRender_Portal *,xalloc<IRender_Portal *> >::clear_and_free
PUBLIC	?resize@?$vector@UFSlideWindowItem@@V?$xalloc@UFSlideWindowItem@@@@@std@@QAEXI@Z ; std::vector<FSlideWindowItem,xalloc<FSlideWindowItem> >::resize
PUBLIC	?end@?$vector@UFSlideWindowItem@@V?$xalloc@UFSlideWindowItem@@@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UFSlideWindowItem@@@std@@@std@@@2@XZ ; std::vector<FSlideWindowItem,xalloc<FSlideWindowItem> >::end
PUBLIC	?size@?$xr_vector@UFSlideWindowItem@@V?$xalloc@UFSlideWindowItem@@@@@@QBEIXZ ; xr_vector<FSlideWindowItem,xalloc<FSlideWindowItem> >::size
PUBLIC	?clear_not_free@?$xr_vector@UFSlideWindowItem@@V?$xalloc@UFSlideWindowItem@@@@@@QAEXXZ ; xr_vector<FSlideWindowItem,xalloc<FSlideWindowItem> >::clear_not_free
PUBLIC	?clear@?$xr_vector@UFSlideWindowItem@@V?$xalloc@UFSlideWindowItem@@@@@@QAEXXZ ; xr_vector<FSlideWindowItem,xalloc<FSlideWindowItem> >::clear
PUBLIC	?resize@?$vector@V?$resptr_core@UShader@@Uresptrcode_shader@@@@V?$xalloc@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@@@std@@QAEXI@Z ; std::vector<resptr_core<Shader,resptrcode_shader>,xalloc<resptr_core<Shader,resptrcode_shader> > >::resize
PUBLIC	?clear_and_free@?$xr_vector@V?$resptr_core@UShader@@Uresptrcode_shader@@@@V?$xalloc@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@@@@QAEXXZ ; xr_vector<resptr_core<Shader,resptrcode_shader>,xalloc<resptr_core<Shader,resptrcode_shader> > >::clear_and_free
PUBLIC	?resize@?$vector@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@V?$xalloc@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@@@std@@QAEXI@Z ; std::vector<svector<_D3DVERTEXELEMENT9,65>,xalloc<svector<_D3DVERTEXELEMENT9,65> > >::resize
PUBLIC	?clear_and_free@?$xr_vector@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@V?$xalloc@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@@@@QAEXXZ ; xr_vector<svector<_D3DVERTEXELEMENT9,65>,xalloc<svector<_D3DVERTEXELEMENT9,65> > >::clear_and_free
PUBLIC	?resize@?$vector@PAUIDirect3DVertexBuffer9@@V?$xalloc@PAUIDirect3DVertexBuffer9@@@@@std@@QAEXI@Z ; std::vector<IDirect3DVertexBuffer9 *,xalloc<IDirect3DVertexBuffer9 *> >::resize
PUBLIC	?size@?$xr_vector@PAUIDirect3DVertexBuffer9@@V?$xalloc@PAUIDirect3DVertexBuffer9@@@@@@QBEIXZ ; xr_vector<IDirect3DVertexBuffer9 *,xalloc<IDirect3DVertexBuffer9 *> >::size
PUBLIC	?clear_and_free@?$xr_vector@PAUIDirect3DVertexBuffer9@@V?$xalloc@PAUIDirect3DVertexBuffer9@@@@@@QAEXXZ ; xr_vector<IDirect3DVertexBuffer9 *,xalloc<IDirect3DVertexBuffer9 *> >::clear_and_free
PUBLIC	?resize@?$vector@PAUIDirect3DIndexBuffer9@@V?$xalloc@PAUIDirect3DIndexBuffer9@@@@@std@@QAEXI@Z ; std::vector<IDirect3DIndexBuffer9 *,xalloc<IDirect3DIndexBuffer9 *> >::resize
PUBLIC	?size@?$xr_vector@PAUIDirect3DIndexBuffer9@@V?$xalloc@PAUIDirect3DIndexBuffer9@@@@@@QBEIXZ ; xr_vector<IDirect3DIndexBuffer9 *,xalloc<IDirect3DIndexBuffer9 *> >::size
PUBLIC	?clear_and_free@?$xr_vector@PAUIDirect3DIndexBuffer9@@V?$xalloc@PAUIDirect3DIndexBuffer9@@@@@@QAEXXZ ; xr_vector<IDirect3DIndexBuffer9 *,xalloc<IDirect3DIndexBuffer9 *> >::clear_and_free
PUBLIC	?resize@?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@QAEXH@Z ; svector<_D3DVERTEXELEMENT9,65>::resize
PUBLIC	??0?$svector@U?$_vector3@M@@$05@@QAE@XZ		; svector<_vector3<float>,6>::svector<_vector3<float>,6>
PUBLIC	?begin@?$svector@U?$_vector3@M@@$05@@QAEPAU?$_vector3@M@@XZ ; svector<_vector3<float>,6>::begin
PUBLIC	?size@?$svector@U?$_vector3@M@@$05@@QBEIXZ	; svector<_vector3<float>,6>::size
PUBLIC	??A?$svector@U?$_vector3@M@@$05@@QAEAAU?$_vector3@M@@I@Z ; svector<_vector3<float>,6>::operator[]
PUBLIC	??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UFSlideWindowItem@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<FSlideWindowItem> > >::operator!=
PUBLIC	??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UFSlideWindowItem@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<FSlideWindowItem> > >::operator++
PUBLIC	?LoadSWIs@CRender@@AAEXPAVCStreamReader@@@Z	; CRender::LoadSWIs
PUBLIC	??0b_portal@@QAE@XZ				; b_portal::b_portal
PUBLIC	?LoadSectors@CRender@@AAEXPAVIReader@@@Z	; CRender::LoadSectors
PUBLIC	?LoadLights@CRender@@AAEXPAVIReader@@@Z		; CRender::LoadLights
PUBLIC	?LoadVisuals@CRender@@AAEXPAVIReader@@@Z	; CRender::LoadVisuals
PUBLIC	?LoadBuffers@CRender@@AAEXPAVCStreamReader@@@Z	; CRender::LoadBuffers
PUBLIC	?level_Load@CRender@@UAEXPAVIReader@@@Z		; CRender::level_Load
PUBLIC	?level_Unload@CRender@@UAEXXZ			; CRender::level_Unload
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@PAUIDirect3DIndexBuffer9@@V?$xalloc@PAUIDirect3DIndexBuffer9@@@@@std@@AAEXIABU_Value_init_tag@1@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@PAUIDirect3DIndexBuffer9@@V?$xalloc@PAUIDirect3DIndexBuffer9@@@@@std@@AAEXIABU_Value_init_tag@1@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@PAUIDirect3DIndexBuffer9@@V?$xalloc@PAUIDirect3DIndexBuffer9@@@@@std@@AAEXIABU_Value_init_tag@1@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
__unwindtable$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@PAUIDirect3DIndexBuffer9@@V?$xalloc@PAUIDirect3DIndexBuffer9@@@@@std@@AAEXIABU_Value_init_tag@1@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@PAUIDirect3DIndexBuffer9@@V?$xalloc@PAUIDirect3DIndexBuffer9@@@@@std@@AAEXIABU_Value_init_tag@1@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@PAUIDirect3DIndexBuffer9@@V?$xalloc@PAUIDirect3DIndexBuffer9@@@@@std@@AAEXIABU_Value_init_tag@1@@Z$2
__catchsym$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@PAUIDirect3DIndexBuffer9@@V?$xalloc@PAUIDirect3DIndexBuffer9@@@@@std@@AAEXIABU_Value_init_tag@1@@Z$2 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@PAUIDirect3DIndexBuffer9@@V?$xalloc@PAUIDirect3DIndexBuffer9@@@@@std@@AAEXIABU_Value_init_tag@1@@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@PAUIDirect3DVertexBuffer9@@V?$xalloc@PAUIDirect3DVertexBuffer9@@@@@std@@AAEXIABU_Value_init_tag@1@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@PAUIDirect3DVertexBuffer9@@V?$xalloc@PAUIDirect3DVertexBuffer9@@@@@std@@AAEXIABU_Value_init_tag@1@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@PAUIDirect3DVertexBuffer9@@V?$xalloc@PAUIDirect3DVertexBuffer9@@@@@std@@AAEXIABU_Value_init_tag@1@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
__unwindtable$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@PAUIDirect3DVertexBuffer9@@V?$xalloc@PAUIDirect3DVertexBuffer9@@@@@std@@AAEXIABU_Value_init_tag@1@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@PAUIDirect3DVertexBuffer9@@V?$xalloc@PAUIDirect3DVertexBuffer9@@@@@std@@AAEXIABU_Value_init_tag@1@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@PAUIDirect3DVertexBuffer9@@V?$xalloc@PAUIDirect3DVertexBuffer9@@@@@std@@AAEXIABU_Value_init_tag@1@@Z$2
__catchsym$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@PAUIDirect3DVertexBuffer9@@V?$xalloc@PAUIDirect3DVertexBuffer9@@@@@std@@AAEXIABU_Value_init_tag@1@@Z$2 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@PAUIDirect3DVertexBuffer9@@V?$xalloc@PAUIDirect3DVertexBuffer9@@@@@std@@AAEXIABU_Value_init_tag@1@@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@V?$xalloc@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@@@std@@AAEXIABU_Value_init_tag@1@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@V?$xalloc@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@@@std@@AAEXIABU_Value_init_tag@1@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@V?$xalloc@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@@@std@@AAEXIABU_Value_init_tag@1@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
__unwindtable$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@V?$xalloc@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@@@std@@AAEXIABU_Value_init_tag@1@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@V?$xalloc@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@@@std@@AAEXIABU_Value_init_tag@1@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@V?$xalloc@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@@@std@@AAEXIABU_Value_init_tag@1@@Z$2
__catchsym$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@V?$xalloc@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@@@std@@AAEXIABU_Value_init_tag@1@@Z$2 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@V?$xalloc@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@@@std@@AAEXIABU_Value_init_tag@1@@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@V?$resptr_core@UShader@@Uresptrcode_shader@@@@V?$xalloc@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@@@std@@AAEXIABU_Value_init_tag@1@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@V?$resptr_core@UShader@@Uresptrcode_shader@@@@V?$xalloc@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@@@std@@AAEXIABU_Value_init_tag@1@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@V?$resptr_core@UShader@@Uresptrcode_shader@@@@V?$xalloc@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@@@std@@AAEXIABU_Value_init_tag@1@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
__unwindtable$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@V?$resptr_core@UShader@@Uresptrcode_shader@@@@V?$xalloc@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@@@std@@AAEXIABU_Value_init_tag@1@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@V?$resptr_core@UShader@@Uresptrcode_shader@@@@V?$xalloc@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@@@std@@AAEXIABU_Value_init_tag@1@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@V?$resptr_core@UShader@@Uresptrcode_shader@@@@V?$xalloc@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@@@std@@AAEXIABU_Value_init_tag@1@@Z$2
__catchsym$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@V?$resptr_core@UShader@@Uresptrcode_shader@@@@V?$xalloc@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@@@std@@AAEXIABU_Value_init_tag@1@@Z$2 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@V?$resptr_core@UShader@@Uresptrcode_shader@@@@V?$xalloc@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@@@std@@AAEXIABU_Value_init_tag@1@@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UFSlideWindowItem@@V?$xalloc@UFSlideWindowItem@@@@@std@@AAEXIABU_Value_init_tag@1@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UFSlideWindowItem@@V?$xalloc@UFSlideWindowItem@@@@@std@@AAEXIABU_Value_init_tag@1@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UFSlideWindowItem@@V?$xalloc@UFSlideWindowItem@@@@@std@@AAEXIABU_Value_init_tag@1@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
__unwindtable$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UFSlideWindowItem@@V?$xalloc@UFSlideWindowItem@@@@@std@@AAEXIABU_Value_init_tag@1@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UFSlideWindowItem@@V?$xalloc@UFSlideWindowItem@@@@@std@@AAEXIABU_Value_init_tag@1@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UFSlideWindowItem@@V?$xalloc@UFSlideWindowItem@@@@@std@@AAEXIABU_Value_init_tag@1@@Z$2
__catchsym$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UFSlideWindowItem@@V?$xalloc@UFSlideWindowItem@@@@@std@@AAEXIABU_Value_init_tag@1@@Z$2 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UFSlideWindowItem@@V?$xalloc@UFSlideWindowItem@@@@@std@@AAEXIABU_Value_init_tag@1@@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@PAVIRender_Portal@@V?$xalloc@PAVIRender_Portal@@@@@std@@AAEXIABU_Value_init_tag@1@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@PAVIRender_Portal@@V?$xalloc@PAVIRender_Portal@@@@@std@@AAEXIABU_Value_init_tag@1@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@PAVIRender_Portal@@V?$xalloc@PAVIRender_Portal@@@@@std@@AAEXIABU_Value_init_tag@1@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
__unwindtable$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@PAVIRender_Portal@@V?$xalloc@PAVIRender_Portal@@@@@std@@AAEXIABU_Value_init_tag@1@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@PAVIRender_Portal@@V?$xalloc@PAVIRender_Portal@@@@@std@@AAEXIABU_Value_init_tag@1@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@PAVIRender_Portal@@V?$xalloc@PAVIRender_Portal@@@@@std@@AAEXIABU_Value_init_tag@1@@Z$2
__catchsym$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@PAVIRender_Portal@@V?$xalloc@PAVIRender_Portal@@@@@std@@AAEXIABU_Value_init_tag@1@@Z$2 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@PAVIRender_Portal@@V?$xalloc@PAVIRender_Portal@@@@@std@@AAEXIABU_Value_init_tag@1@@Z$0
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender_Loader.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender_Loader.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender_Loader.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\detailmanager.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender_Loader.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\detailmanager.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_VS.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File I:\Vitalya\mine\NSProjectX\xrCore\FixedVector.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\FixedVector.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
; File I:\Vitalya\mine\NSProjectX\xrCore\FixedVector.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\FixedVector.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender_Loader.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender_Loader.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender_Loader.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender_Loader.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender_Loader.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender_Loader.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender_Loader.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender_Loader.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender_Loader.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender_Loader.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\Light_DB.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\Light_DB.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender_Loader.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender_Loader.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender_Loader.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender_Loader.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender_Loader.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender_Loader.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender_Loader.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender_Loader.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender_Loader.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender_Loader.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender_Loader.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender_Loader.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender_Loader.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender_Loader.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender_Loader.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender_Loader.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender_Loader.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender_Loader.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender_Loader.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender_Loader.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender_Loader.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender_Loader.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender_Loader.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\Light_DB.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\Light_DB.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender_Loader.cpp
_TEXT	SEGMENT
$T1 = -8						; size = 4
$T2 = -8						; size = 4
_this$1$ = -8						; size = 4
_I$4$ = -8						; size = 4
_I$3$ = -8						; size = 4
_this$2$ = -4						; size = 4
?level_Unload@CRender@@UAEXXZ PROC			; CRender::level_Unload
; _this$ = ecx

; 98   : 	if (0==g_pGameLevel)		return;

	mov	eax, DWORD PTR __imp_?g_pGameLevel@@3PAVIGame_Level@@A
	sub	esp, 8
	cmp	DWORD PTR [eax], 0
	push	ebx
	mov	ebx, ecx
	je	$LN1@level_Unlo

; 99   : 	if (!b_loaded)				return;

	cmp	DWORD PTR [ebx+624], 0
	je	$LN1@level_Unlo

; 100  : 
; 101  : 	Device.Resources->DeferredUnload();

	mov	ecx, DWORD PTR __imp_?Device@@3VCRenderDevice@@A
	push	ebp
	mov	ecx, DWORD PTR [ecx+432]
	call	DWORD PTR __imp_?DeferredUnload@CResourceManager@@QAEXXZ

; 102  : 
; 103  : 	u32							I;
; 104  : 
; 105  : 	// HOM
; 106  : 	g_pGamePersistent->LoadTitle("st_unloading_hom");

	mov	eax, DWORD PTR __imp_?g_pGamePersistent@@3PAVIGame_Persistent@@A
	push	OFFSET ??_C@_0BB@ENKKBJBI@st_unloading_hom@
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+64]
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h

; 151  : 	if (ptr) 

	mov	ecx, DWORD PTR [ebx+736]
	mov	ebp, DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
	test	ecx, ecx
	je	SHORT $LN28@level_Unlo
	call	DWORD PTR __imp_??1MODEL@CDB@@QAE@XZ

; 144  : 		Memory.mem_free	(ptr);

	push	DWORD PTR [ebx+736]
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	ebp

; 154  : 		ptr = nullptr;

	mov	DWORD PTR [ebx+736], 0
$LN28@level_Unlo:
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	eax, DWORD PTR [ebx+740]
	test	eax, eax
	je	SHORT $LN36@level_Unlo
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	ebp
	mov	DWORD PTR [ebx+740], 0
$LN36@level_Unlo:
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender_Loader.cpp

; 110  : 	g_pGamePersistent->LoadTitle("st_unloading_details");

	mov	eax, DWORD PTR __imp_?g_pGamePersistent@@3PAVIGame_Persistent@@A
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp

; 127  : 	bEnabled			= FALSE;

	mov	DWORD PTR [ebx+744], 0
	push	esi
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender_Loader.cpp

; 110  : 	g_pGamePersistent->LoadTitle("st_unloading_details");

	push	OFFSET ??_C@_0BF@KKHKGJJG@st_unloading_details@
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+64]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\detailmanager.h

; 123  : 	IC bool							UseVS			()		{ return HW.Caps.geometry_major >= 1; }

	mov	eax, DWORD PTR __imp_?HW@@3VCHW@@A
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender_Loader.cpp

; 111  : 	Details->Unload				();

	mov	esi, DWORD PTR [ebx+1004]
	mov	DWORD PTR _this$1$[esp+20], esi
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\detailmanager.h

; 123  : 	IC bool							UseVS			()		{ return HW.Caps.geometry_major >= 1; }

	cmp	WORD PTR [eax+48], 1
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager.cpp

; 166  : 	if (UseVS())	hw_Unload	();

	jb	SHORT $LN42@level_Unlo
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 46   : 	ICF		void		_set	(T * rhs) 							{	if (0!=rhs) rhs->dwReference++;	_dec(); p_ = rhs;											}

	lea	ecx, DWORD PTR [esi+701228]
	call	DWORD PTR __imp_?_dec@?$resptr_base@USGeometry@@@@IAEXXZ
	mov	DWORD PTR [esi+701228], 0
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_VS.cpp

; 131  : 	_RELEASE					(hw_IB);

	mov	ecx, DWORD PTR [esi+701240]
	test	ecx, ecx
	je	SHORT $LN48@level_Unlo
	mov	eax, DWORD PTR [ecx]
	push	ecx
	call	DWORD PTR [eax+8]
	mov	DWORD PTR [esi+701240], 0
$LN48@level_Unlo:

; 132  : 	_RELEASE					(hw_VB);

	mov	ecx, DWORD PTR [esi+701236]
	test	ecx, ecx
	je	SHORT $LN43@level_Unlo
	mov	eax, DWORD PTR [ecx]
	push	ecx
	call	DWORD PTR [eax+8]
	mov	DWORD PTR [esi+701236], 0
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager.cpp

; 166  : 	if (UseVS())	hw_Unload	();

	jmp	SHORT $LN43@level_Unlo
$LN42@level_Unlo:
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 46   : 	ICF		void		_set	(T * rhs) 							{	if (0!=rhs) rhs->dwReference++;	_dec(); p_ = rhs;											}

	lea	ecx, DWORD PTR [esi+701224]
	call	DWORD PTR __imp_?_dec@?$resptr_base@USGeometry@@@@IAEXXZ
	mov	DWORD PTR [esi+701224], 0
$LN43@level_Unlo:
; File I:\Vitalya\mine\NSProjectX\xrCore\FixedVector.h

; 27   : 	IC iterator	end	 ()						{ return array+count;					}

	mov	eax, DWORD PTR [esi+1392]
	push	edi
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager.cpp

; 169  : 	for (DetailIt it=objects.begin(); it!=objects.end(); it++){

	lea	edi, DWORD PTR [esi+1136]
; File I:\Vitalya\mine\NSProjectX\xrCore\FixedVector.h

; 27   : 	IC iterator	end	 ()						{ return array+count;					}

	lea	eax, DWORD PTR [edi+eax*4]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager.cpp

; 169  : 	for (DetailIt it=objects.begin(); it!=objects.end(); it++){

	cmp	edi, eax
	je	SHORT $LN40@level_Unlo
	mov	esi, edi
	mov	DWORD PTR _this$2$[esp+24], esi
	npad	2
$LL41@level_Unlo:

; 170  : 		(*it)->Unload();

	mov	ecx, DWORD PTR [edi]
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+12]
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h

; 151  : 	if (ptr) 

	mov	eax, DWORD PTR [edi]
	test	eax, eax
	je	SHORT $LN39@level_Unlo

; 132  : 		void*	_real_ptr	= dynamic_cast<void*>(ptr);

	push	eax
	call	___RTCastToVoid

; 133  : 		ptr->~T			();

	mov	ecx, DWORD PTR [edi]
	add	esp, 4
	mov	esi, eax
	mov	edx, DWORD PTR [ecx]
	push	0
	call	DWORD PTR [edx+8]

; 134  : 		Memory.mem_free	(_real_ptr);

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	esi
	call	ebp
	mov	esi, DWORD PTR _this$2$[esp+24]

; 154  : 		ptr = nullptr;

	mov	DWORD PTR [edi], 0
$LN39@level_Unlo:
; File I:\Vitalya\mine\NSProjectX\xrCore\FixedVector.h

; 27   : 	IC iterator	end	 ()						{ return array+count;					}

	mov	eax, DWORD PTR [esi+256]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager.cpp

; 169  : 	for (DetailIt it=objects.begin(); it!=objects.end(); it++){

	add	edi, 4
; File I:\Vitalya\mine\NSProjectX\xrCore\FixedVector.h

; 27   : 	IC iterator	end	 ()						{ return array+count;					}

	lea	eax, DWORD PTR [esi+eax*4]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager.cpp

; 169  : 	for (DetailIt it=objects.begin(); it!=objects.end(); it++){

	cmp	edi, eax
	jne	SHORT $LL41@level_Unlo
	mov	esi, DWORD PTR _this$1$[esp+24]
$LN40@level_Unlo:

; 171  : 		xr_delete		(*it);
; 172  :     }
; 173  : 	objects.clear		();
; 174  : 	m_visibles[0].clear	();

	mov	eax, DWORD PTR [esi+1396]

; 175  : 	m_visibles[1].clear	();
; 176  : 	m_visibles[2].clear	();
; 177  : 	FS.r_close			(dtFS);

	mov	ecx, DWORD PTR __imp_?xr_FS@@3PAVCLocatorAPI@@A
	mov	DWORD PTR [esi+1400], eax
	mov	eax, DWORD PTR [esi+1408]
	mov	DWORD PTR [esi+1412], eax
	mov	eax, DWORD PTR [esi+1420]
	mov	DWORD PTR [esi+1424], eax
	lea	eax, DWORD PTR [esi+1088]
	mov	DWORD PTR [esi+1392], 0
	mov	ecx, DWORD PTR [ecx]
	push	eax
	call	DWORD PTR __imp_?r_close@CLocatorAPI@@QAEXAAPAVIReader@@@Z
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender_Loader.cpp

; 115  : 	g_pGamePersistent->LoadTitle("st_unloading_sectors_portals");

	mov	eax, DWORD PTR __imp_?g_pGamePersistent@@3PAVIGame_Persistent@@A
	push	OFFSET ??_C@_0BN@DFGDFDJK@st_unloading_sectors_portals@
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+64]
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h

; 151  : 	if (ptr) 

	mov	ecx, DWORD PTR [ebx+708]
	test	ecx, ecx
	je	SHORT $LN71@level_Unlo
	call	DWORD PTR __imp_??1MODEL@CDB@@QAE@XZ

; 144  : 		Memory.mem_free	(ptr);

	push	DWORD PTR [ebx+708]
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	ebp

; 154  : 		ptr = nullptr;

	mov	DWORD PTR [ebx+708], 0
$LN71@level_Unlo:
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender_Loader.cpp

; 117  : 	pLastSector					= 0;

	mov	DWORD PTR [ebx+640], 0

; 122  : 	for (I=0; I<Sectors.size(); I++)	xr_delete(Sectors[I]);

	xor	edi, edi
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 23   : 	ICF	SelfRef	set(T _x, T _y, T _z)					{ x = _x;		y = _y;		z = _z;		return *this;	};

	mov	DWORD PTR [ebx+644], 2139095039		; 7f7fffffH
	mov	DWORD PTR [ebx+648], 2139095039		; 7f7fffffH
	mov	DWORD PTR [ebx+652], 2139095039		; 7f7fffffH
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender_Loader.cpp

; 119  : 	uLastLTRACK					= 0;

	mov	DWORD PTR [ebx+656], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	eax, DWORD PTR [ebx+676]
	mov	ecx, DWORD PTR [ebx+672]
	sub	eax, ecx
	sar	eax, 2
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender_Loader.cpp

; 122  : 	for (I=0; I<Sectors.size(); I++)	xr_delete(Sectors[I]);

	test	eax, eax
	je	SHORT $LN3@level_Unlo
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h

; 154  : 		ptr = nullptr;

	mov	DWORD PTR $T1[esp+24], ecx
$LL4@level_Unlo:

; 151  : 	if (ptr) 

	mov	eax, DWORD PTR [ecx+edi*4]
	test	eax, eax
	je	SHORT $LN2@level_Unlo

; 132  : 		void*	_real_ptr	= dynamic_cast<void*>(ptr);

	push	eax
	call	___RTCastToVoid

; 133  : 		ptr->~T			();

	mov	ecx, DWORD PTR $T1[esp+28]
	add	esp, 4
	mov	esi, eax
	mov	ecx, DWORD PTR [ecx+edi*4]
	push	0
	mov	edx, DWORD PTR [ecx]
	call	DWORD PTR [edx]

; 134  : 		Memory.mem_free	(_real_ptr);

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	esi
	call	ebp

; 154  : 		ptr = nullptr;

	mov	eax, DWORD PTR $T1[esp+24]
	mov	DWORD PTR [eax+edi*4], 0
$LN2@level_Unlo:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	ecx, DWORD PTR [ebx+672]
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender_Loader.cpp

; 122  : 	for (I=0; I<Sectors.size(); I++)	xr_delete(Sectors[I]);

	inc	edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	eax, DWORD PTR [ebx+676]
	sub	eax, ecx
	mov	DWORD PTR $T1[esp+24], ecx
	sar	eax, 2
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender_Loader.cpp

; 122  : 	for (I=0; I<Sectors.size(); I++)	xr_delete(Sectors[I]);

	cmp	edi, eax
	jb	SHORT $LL4@level_Unlo
$LN3@level_Unlo:

; 123  : 	Sectors.clear_and_free		();

	mov	DWORD PTR [ebx+676], ecx

; 125  : 	for (I=0; I<Portals.size(); I++)	xr_delete(Portals[I]);

	xor	edi, edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	eax, DWORD PTR [ebx+664]
	mov	ecx, DWORD PTR [ebx+660]
	sub	eax, ecx
	sar	eax, 2
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender_Loader.cpp

; 125  : 	for (I=0; I<Portals.size(); I++)	xr_delete(Portals[I]);

	test	eax, eax
	je	SHORT $LN6@level_Unlo
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h

; 154  : 		ptr = nullptr;

	mov	DWORD PTR $T2[esp+24], ecx
	npad	1
$LL7@level_Unlo:

; 151  : 	if (ptr) 

	mov	eax, DWORD PTR [ecx+edi*4]
	test	eax, eax
	je	SHORT $LN5@level_Unlo

; 132  : 		void*	_real_ptr	= dynamic_cast<void*>(ptr);

	push	eax
	call	___RTCastToVoid

; 133  : 		ptr->~T			();

	mov	ecx, DWORD PTR $T2[esp+28]
	add	esp, 4
	mov	esi, eax
	mov	ecx, DWORD PTR [ecx+edi*4]
	push	0
	mov	edx, DWORD PTR [ecx]
	call	DWORD PTR [edx]

; 134  : 		Memory.mem_free	(_real_ptr);

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	esi
	call	ebp

; 154  : 		ptr = nullptr;

	mov	eax, DWORD PTR $T2[esp+24]
	mov	DWORD PTR [eax+edi*4], 0
$LN5@level_Unlo:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	ecx, DWORD PTR [ebx+660]
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender_Loader.cpp

; 125  : 	for (I=0; I<Portals.size(); I++)	xr_delete(Portals[I]);

	inc	edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	eax, DWORD PTR [ebx+664]
	sub	eax, ecx
	mov	DWORD PTR $T2[esp+24], ecx
	sar	eax, 2
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender_Loader.cpp

; 125  : 	for (I=0; I<Portals.size(); I++)	xr_delete(Portals[I]);

	cmp	edi, eax
	jb	SHORT $LL7@level_Unlo
$LN6@level_Unlo:

; 126  : 	Portals.clear_and_free		();
; 127  : 
; 128  : 	//*** Lights
; 129  : 	g_pGamePersistent->LoadTitle("st_unloading_lights");

	mov	eax, DWORD PTR __imp_?g_pGamePersistent@@3PAVIGame_Persistent@@A
	mov	DWORD PTR [ebx+664], ecx
	push	OFFSET ??_C@_0BE@HOOIPLJB@st_unloading_lights@
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+64]

; 130  : 	L_Glows->Unload				();

	mov	ecx, DWORD PTR [ebx+996]
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp

; 133  : 	SelectedToTest_2.clear	();

	mov	eax, DWORD PTR [ecx+24]
	mov	DWORD PTR [ecx+28], eax

; 134  : 	SelectedToTest_1.clear	();

	mov	eax, DWORD PTR [ecx+36]
	mov	DWORD PTR [ecx+40], eax

; 135  : 	SelectedToTest_0.clear	();

	mov	eax, DWORD PTR [ecx+48]
	mov	DWORD PTR [ecx+52], eax

; 136  : 	Selected.clear			();

	mov	eax, DWORD PTR [ecx+12]
	mov	DWORD PTR [ecx+16], eax

; 137  : 	Glows.clear				();

	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [ecx+4], eax
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender_Loader.cpp

; 131  : 	L_DB->Unload				();

	mov	edi, DWORD PTR [ebx+980]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\Light_DB.cpp

; 103  : 	v_static.clear			();

	mov	eax, DWORD PTR [edi]
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 46   : 	ICF		void		_set	(T * rhs) 							{	if (0!=rhs) rhs->dwReference++;	_dec(); p_ = rhs;											}

	lea	ecx, DWORD PTR [edi+12]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\Light_DB.cpp

; 103  : 	v_static.clear			();

	mov	DWORD PTR [edi+4], eax
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 46   : 	ICF		void		_set	(T * rhs) 							{	if (0!=rhs) rhs->dwReference++;	_dec(); p_ = rhs;											}

	call	DWORD PTR __imp_?_dec@?$resptr_base@VIRender_Light@@@@IAEXXZ
	lea	ecx, DWORD PTR [edi+16]
	mov	DWORD PTR [edi+12], 0
	call	DWORD PTR __imp_?_dec@?$resptr_base@VIRender_Light@@@@IAEXXZ
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender_Loader.cpp

; 134  : 	g_pGamePersistent->LoadTitle("st_unloading_spatial_db");

	mov	eax, DWORD PTR __imp_?g_pGamePersistent@@3PAVIGame_Persistent@@A
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 46   : 	ICF		void		_set	(T * rhs) 							{	if (0!=rhs) rhs->dwReference++;	_dec(); p_ = rhs;											}

	mov	DWORD PTR [edi+16], 0
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender_Loader.cpp

; 134  : 	g_pGamePersistent->LoadTitle("st_unloading_spatial_db");

	push	OFFSET ??_C@_0BI@LMGCEJBB@st_unloading_spatial_db@
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+64]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	eax, DWORD PTR [ebx+948]
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender_Loader.cpp

; 135  : 	for (I=0; I<Visuals.size(); I++)	{

	xor	ecx, ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	edx, DWORD PTR [ebx+944]
	sub	eax, edx
	sar	eax, 2
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender_Loader.cpp

; 135  : 	for (I=0; I<Visuals.size(); I++)	{

	mov	DWORD PTR _I$3$[esp+24], ecx
	test	eax, eax
	je	SHORT $LN9@level_Unlo
	npad	2
$LL10@level_Unlo:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 119  :         _Ptr += _Off;

	lea	esi, DWORD PTR [ecx*4]
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender_Loader.cpp

; 136  : 		Visuals[I]->Release();

	mov	ecx, DWORD PTR [esi+edx]
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 119  :         _Ptr += _Off;

	mov	edi, DWORD PTR [ebx+944]
	add	edi, esi
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h

; 151  : 	if (ptr) 

	mov	eax, DWORD PTR [edi]
	test	eax, eax
	je	SHORT $LN8@level_Unlo

; 132  : 		void*	_real_ptr	= dynamic_cast<void*>(ptr);

	push	eax
	call	___RTCastToVoid

; 133  : 		ptr->~T			();

	mov	ecx, DWORD PTR [edi]
	add	esp, 4
	mov	esi, eax
	mov	edx, DWORD PTR [ecx]
	push	0
	call	DWORD PTR [edx+36]

; 134  : 		Memory.mem_free	(_real_ptr);

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	esi
	call	ebp

; 154  : 		ptr = nullptr;

	mov	DWORD PTR [edi], 0
$LN8@level_Unlo:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	eax, DWORD PTR [ebx+948]
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender_Loader.cpp

; 135  : 	for (I=0; I<Visuals.size(); I++)	{

	mov	ecx, DWORD PTR _I$3$[esp+24]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	edx, DWORD PTR [ebx+944]
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender_Loader.cpp

; 135  : 	for (I=0; I<Visuals.size(); I++)	{

	inc	ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	sub	eax, edx
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender_Loader.cpp

; 135  : 	for (I=0; I<Visuals.size(); I++)	{

	mov	DWORD PTR _I$3$[esp+24], ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	sar	eax, 2
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender_Loader.cpp

; 135  : 	for (I=0; I<Visuals.size(); I++)	{

	cmp	ecx, eax
	jb	SHORT $LL10@level_Unlo
$LN9@level_Unlo:

; 137  : 		xr_delete(Visuals[I]);
; 138  : 	}
; 139  : 	Visuals.clear_and_free		();
; 140  : 
; 141  : 	//*** SWI
; 142  : 	g_pGamePersistent->LoadTitle("st_unloading_geometry");

	mov	eax, DWORD PTR __imp_?g_pGamePersistent@@3PAVIGame_Persistent@@A
	mov	DWORD PTR [ebx+948], edx
	push	OFFSET ??_C@_0BG@JNDCECGL@st_unloading_geometry@
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+64]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	eax, DWORD PTR [ebx+888]
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender_Loader.cpp

; 143  : 	for (I=0; I<SWIs.size();I++)xr_free	(SWIs[I].sw);

	xor	ecx, ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	esi, DWORD PTR [ebx+884]
	sub	eax, esi
	sar	eax, 3
	imul	eax, eax, -1431655765
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender_Loader.cpp

; 143  : 	for (I=0; I<SWIs.size();I++)xr_free	(SWIs[I].sw);

	mov	DWORD PTR _I$4$[esp+24], ecx
	test	eax, eax
	je	SHORT $LN12@level_Unlo
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h

; 154  : 		ptr = nullptr;

	xor	edi, edi
$LL13@level_Unlo:
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	eax, DWORD PTR [esi+edi]
	test	eax, eax
	je	SHORT $LN11@level_Unlo
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	ebp
	mov	ecx, DWORD PTR _I$4$[esp+24]
	mov	DWORD PTR [esi+edi], 0
$LN11@level_Unlo:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	eax, DWORD PTR [ebx+888]
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender_Loader.cpp

; 143  : 	for (I=0; I<SWIs.size();I++)xr_free	(SWIs[I].sw);

	inc	ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	esi, DWORD PTR [ebx+884]
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender_Loader.cpp

; 143  : 	for (I=0; I<SWIs.size();I++)xr_free	(SWIs[I].sw);

	add	edi, 24					; 00000018H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	sub	eax, esi
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender_Loader.cpp

; 143  : 	for (I=0; I<SWIs.size();I++)xr_free	(SWIs[I].sw);

	mov	DWORD PTR _I$4$[esp+24], ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	sar	eax, 3
	imul	eax, eax, -1431655765
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender_Loader.cpp

; 143  : 	for (I=0; I<SWIs.size();I++)xr_free	(SWIs[I].sw);

	cmp	ecx, eax
	jb	SHORT $LL13@level_Unlo
$LN12@level_Unlo:

; 144  : 	SWIs.clear					();
; 145  : 
; 146  : 	//*** VB/IB
; 147  : 	g_pGamePersistent->LoadTitle("st_unloading_geometry");

	mov	eax, DWORD PTR __imp_?g_pGamePersistent@@3PAVIGame_Persistent@@A
	mov	DWORD PTR [ebx+888], esi
	push	OFFSET ??_C@_0BG@JNDCECGL@st_unloading_geometry@
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+64]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	eax, DWORD PTR [ebx+924]
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender_Loader.cpp

; 148  : 	for (I=0; I<VB.size(); I++)	_RELEASE(VB[I]);

	xor	esi, esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	ecx, DWORD PTR [ebx+920]
	sub	eax, ecx
	sar	eax, 2
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender_Loader.cpp

; 148  : 	for (I=0; I<VB.size(); I++)	_RELEASE(VB[I]);

	test	eax, eax
	je	SHORT $LN15@level_Unlo
$LL16@level_Unlo:
	mov	ecx, DWORD PTR [ecx+esi*4]
	test	ecx, ecx
	je	SHORT $LN14@level_Unlo
	mov	eax, DWORD PTR [ecx]
	push	ecx
	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR [ebx+920]
	mov	DWORD PTR [eax+esi*4], 0
$LN14@level_Unlo:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	eax, DWORD PTR [ebx+924]
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender_Loader.cpp

; 148  : 	for (I=0; I<VB.size(); I++)	_RELEASE(VB[I]);

	inc	esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	ecx, DWORD PTR [ebx+920]
	sub	eax, ecx
	sar	eax, 2
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender_Loader.cpp

; 148  : 	for (I=0; I<VB.size(); I++)	_RELEASE(VB[I]);

	cmp	esi, eax
	jb	SHORT $LL16@level_Unlo
$LN15@level_Unlo:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	eax, DWORD PTR [ebx+936]
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender_Loader.cpp

; 149  : 	for (I=0; I<IB.size(); I++)	_RELEASE(IB[I]);

	xor	esi, esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	ecx, DWORD PTR [ebx+932]
	sub	eax, ecx
	sar	eax, 2
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender_Loader.cpp

; 149  : 	for (I=0; I<IB.size(); I++)	_RELEASE(IB[I]);

	test	eax, eax
	je	SHORT $LN18@level_Unlo
	npad	5
$LL19@level_Unlo:
	mov	ecx, DWORD PTR [ecx+esi*4]
	test	ecx, ecx
	je	SHORT $LN17@level_Unlo
	mov	eax, DWORD PTR [ecx]
	push	ecx
	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR [ebx+932]
	mov	DWORD PTR [eax+esi*4], 0
$LN17@level_Unlo:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	eax, DWORD PTR [ebx+936]
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender_Loader.cpp

; 149  : 	for (I=0; I<IB.size(); I++)	_RELEASE(IB[I]);

	inc	esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	ecx, DWORD PTR [ebx+932]
	sub	eax, ecx
	sar	eax, 2
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender_Loader.cpp

; 149  : 	for (I=0; I<IB.size(); I++)	_RELEASE(IB[I]);

	cmp	esi, eax
	jb	SHORT $LL19@level_Unlo
$LN18@level_Unlo:

; 150  : 	DCL.clear_and_free			();

	mov	eax, DWORD PTR [ebx+908]
	mov	DWORD PTR [ebx+912], eax

; 151  : 	VB.clear_and_free			();

	mov	eax, DWORD PTR [ebx+920]
	mov	DWORD PTR [ebx+924], eax

; 152  : 	IB.clear_and_free			();

	mov	eax, DWORD PTR [ebx+932]
	mov	DWORD PTR [ebx+936], eax

; 153  : 
; 154  : 	//*** Components
; 155  : 	g_pGamePersistent->LoadTitle("st_unloading_components");

	mov	eax, DWORD PTR __imp_?g_pGamePersistent@@3PAVIGame_Persistent@@A
	push	OFFSET ??_C@_0BI@DOLBFAGL@st_unloading_components@
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+64]
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h

; 151  : 	if (ptr) 

	mov	eax, DWORD PTR [ebx+1004]
	test	eax, eax
	je	SHORT $LN330@level_Unlo

; 132  : 		void*	_real_ptr	= dynamic_cast<void*>(ptr);

	push	eax
	call	___RTCastToVoid

; 133  : 		ptr->~T			();

	mov	ecx, DWORD PTR [ebx+1004]
	add	esp, 4
	mov	esi, eax
	mov	edx, DWORD PTR [ecx]
	push	0
	call	DWORD PTR [edx]

; 134  : 		Memory.mem_free	(_real_ptr);

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	esi
	call	ebp

; 154  : 		ptr = nullptr;

	mov	DWORD PTR [ebx+1004], 0
$LN330@level_Unlo:

; 151  : 	if (ptr) 

	mov	esi, DWORD PTR [ebx+1000]
	test	esi, esi
	je	$LN335@level_Unlo
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp

; 61   : 	clear			();

	mov	ecx, esi
	call	?clear@CWallmarksEngine@@QAEXXZ		; CWallmarksEngine::clear
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 46   : 	ICF		void		_set	(T * rhs) 							{	if (0!=rhs) rhs->dwReference++;	_dec(); p_ = rhs;											}

	lea	ecx, DWORD PTR [esi+24]
	call	DWORD PTR __imp_?_dec@?$resptr_base@USGeometry@@@@IAEXXZ
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp

; 63   : }

	lea	ecx, DWORD PTR [esi+1504]
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 46   : 	ICF		void		_set	(T * rhs) 							{	if (0!=rhs) rhs->dwReference++;	_dec(); p_ = rhs;											}

	mov	DWORD PTR [esi+24], 0
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp

; 63   : }

	call	DWORD PTR __imp_??1xrCriticalSection@@QAE@XZ
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [esi+1492]
	test	eax, eax
	je	SHORT $LN354@level_Unlo
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	ebp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi+1492], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+1496], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+1500], 0
$LN354@level_Unlo:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp

; 63   : }

	lea	ecx, DWORD PTR [esi+1468]
	call	DWORD PTR __imp_??1Collector@CDB@@QAE@XZ
	lea	ecx, DWORD PTR [esi+1444]
	call	DWORD PTR __imp_??1xrXRC@@QAE@XZ
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 64   : 						~resptr_core	()												{	_dec();						}

	lea	ecx, DWORD PTR [esi+24]
	call	DWORD PTR __imp_?_dec@?$resptr_base@USGeometry@@@@IAEXXZ
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [esi+12]
	test	eax, eax
	je	SHORT $LN368@level_Unlo
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	ebp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi+12], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+16], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+20], 0
$LN368@level_Unlo:

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN380@level_Unlo
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	ebp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+4], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+8], 0
$LN380@level_Unlo:
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h

; 144  : 		Memory.mem_free	(ptr);

	push	DWORD PTR [ebx+1000]
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	ebp

; 154  : 		ptr = nullptr;

	mov	DWORD PTR [ebx+1000], 0
$LN335@level_Unlo:

; 151  : 	if (ptr) 

	mov	esi, DWORD PTR [ebx+996]
	pop	edi
	test	esi, esi
	je	$LN388@level_Unlo
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp

; 92   : }

	lea	ecx, DWORD PTR [esi+60]
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 64   : 						~resptr_core	()												{	_dec();						}

	call	DWORD PTR __imp_?_dec@?$resptr_base@USGeometry@@@@IAEXXZ
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [esi+48]
	test	eax, eax
	je	SHORT $LN404@level_Unlo
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	ebp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi+48], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+52], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+56], 0
$LN404@level_Unlo:

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [esi+36]
	test	eax, eax
	je	SHORT $LN416@level_Unlo
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	ebp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi+36], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+40], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+44], 0
$LN416@level_Unlo:

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [esi+24]
	test	eax, eax
	je	SHORT $LN428@level_Unlo
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	ebp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi+24], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+28], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+32], 0
$LN428@level_Unlo:

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [esi+12]
	test	eax, eax
	je	SHORT $LN440@level_Unlo
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	ebp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi+12], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+16], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+20], 0
$LN440@level_Unlo:

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN452@level_Unlo
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	ebp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+4], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+8], 0
$LN452@level_Unlo:
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h

; 144  : 		Memory.mem_free	(ptr);

	push	DWORD PTR [ebx+996]
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	ebp

; 154  : 		ptr = nullptr;

	mov	DWORD PTR [ebx+996], 0
$LN388@level_Unlo:

; 151  : 	if (ptr) 

	mov	esi, DWORD PTR [ebx+980]
	test	esi, esi
	je	SHORT $LN460@level_Unlo
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\Light_DB.cpp

; 14   : }

	lea	ecx, DWORD PTR [esi+20]
	call	??1light_Package@@QAE@XZ
	lea	ecx, DWORD PTR [esi+16]
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 64   : 						~resptr_core	()												{	_dec();						}

	call	DWORD PTR __imp_?_dec@?$resptr_base@VIRender_Light@@@@IAEXXZ
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\Light_DB.cpp

; 14   : }

	lea	ecx, DWORD PTR [esi+12]
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 64   : 						~resptr_core	()												{	_dec();						}

	call	DWORD PTR __imp_?_dec@?$resptr_base@VIRender_Light@@@@IAEXXZ
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN478@level_Unlo
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	ebp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+4], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+8], 0
$LN478@level_Unlo:
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h

; 144  : 		Memory.mem_free	(ptr);

	push	DWORD PTR [ebx+980]
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	ebp

; 154  : 		ptr = nullptr;

	mov	DWORD PTR [ebx+980], 0
$LN460@level_Unlo:

; 151  : 	if (ptr) 

	mov	eax, DWORD PTR [ebx+992]
	test	eax, eax
	je	SHORT $LN486@level_Unlo

; 132  : 		void*	_real_ptr	= dynamic_cast<void*>(ptr);

	push	eax
	call	___RTCastToVoid
	mov	ecx, DWORD PTR [ebx+992]
	add	esp, 4
	mov	esi, eax
	call	??1CLightProjector@@QAE@XZ		; CLightProjector::~CLightProjector

; 134  : 		Memory.mem_free	(_real_ptr);

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	esi
	call	ebp

; 154  : 		ptr = nullptr;

	mov	DWORD PTR [ebx+992], 0
$LN486@level_Unlo:

; 151  : 	if (ptr) 

	mov	ecx, DWORD PTR [ebx+988]
	pop	esi
	test	ecx, ecx
	je	SHORT $LN494@level_Unlo
	call	??1CLightShadows@@QAE@XZ		; CLightShadows::~CLightShadows

; 144  : 		Memory.mem_free	(ptr);

	push	DWORD PTR [ebx+988]
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	ebp

; 154  : 		ptr = nullptr;

	mov	DWORD PTR [ebx+988], 0
$LN494@level_Unlo:
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender_Loader.cpp

; 164  : 	g_pGamePersistent->LoadTitle("st_unloading_shaders");

	mov	eax, DWORD PTR __imp_?g_pGamePersistent@@3PAVIGame_Persistent@@A
	push	OFFSET ??_C@_0BF@HKEGBNPO@st_unloading_shaders@
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+64]

; 165  : 	Shaders.clear_and_free		();

	mov	eax, DWORD PTR [ebx+896]
	mov	DWORD PTR [ebx+900], eax

; 166  : 
; 167  : 	//. dbg
; 168  : #ifdef DEBUG
; 169  : 	// Device.Resources->_DumpMemoryUsage	();
; 170  : 	Device.Resources->DBG_VerifyGeoms	();
; 171  : 	Device.Resources->DBG_VerifyTextures();
; 172  : #endif
; 173  : 	b_loaded					= FALSE;

	mov	DWORD PTR [ebx+624], 0
	pop	ebp
$LN1@level_Unlo:
	pop	ebx

; 174  : }

	add	esp, 8
	ret	0
?level_Unload@CRender@@UAEXXZ ENDP			; CRender::level_Unload
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender_Loader.cpp
; File I:\Vitalya\mine\NSProjectX\xrEngine\resourcemanager.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender_Loader.cpp
; File I:\Vitalya\mine\NSProjectX\xrEngine\resourcemanager.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender_Loader.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender_Loader.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender_Loader.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender_Loader.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\FS.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender_Loader.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\FS.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender_Loader.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\string.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender_Loader.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\string.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender_Loader.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender_Loader.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender_Loader.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender_Loader.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender_Loader.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender_Loader.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File I:\Vitalya\mine\NSProjectX\xrCore\FixedVector.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender_Loader.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\FixedVector.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\detailmanager.h
; File I:\Vitalya\mine\NSProjectX\xrCore\FixedVector.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\detailmanager.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrPool.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender_Loader.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender_Loader.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender_Loader.cpp
_TEXT	SEGMENT
__Count$1$ = -1092					; size = 4
_geom$2 = -1092						; size = 4
$T3 = -1092						; size = 4
_chunk$1$ = -1088					; size = 4
_V$4 = -1088						; size = 4
$T5 = -1088						; size = 4
__Backout$1$sroa$1484$1$ = -1084			; size = 4
_chunk$2$ = -1084					; size = 4
_this$1$ = -1080					; size = 4
$T6 = -1080						; size = 4
_this$1$ = -1076					; size = 4
_count$1$ = -1072					; size = 4
_H$7 = -1068						; size = 44
_n_sh$8 = -1024						; size = 512
_n_tlist$9 = -512					; size = 512
_fs$ = 8						; size = 4
?level_Load@CRender@@UAEXPAVIReader@@@Z PROC		; CRender::level_Load
; _this$ = ecx

; 15   : {

	sub	esp, 1092				; 00000444H

; 16   : 	R_ASSERT			(0!=g_pGameLevel);

	cmp	BYTE PTR ?ignore_always@?3??level_Load@CRender@@UAEXPAVIReader@@@Z@4_NA, 0
	mov	edx, DWORD PTR __imp_?fail@xrDebug@@QAEXPBD0H0AA_N@Z
	push	ebx
	push	ebp
	mov	ebp, ecx
	push	esi
	mov	DWORD PTR _this$1$[esp+1104], ebp
	jne	SHORT $LN2@level_Load
	mov	eax, DWORD PTR __imp_?g_pGameLevel@@3PAVIGame_Level@@A
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN2@level_Load
	mov	ecx, DWORD PTR __imp_?Debug@@3VxrDebug@@A
	push	OFFSET ?ignore_always@?3??level_Load@CRender@@UAEXPAVIReader@@@Z@4_NA
	push	OFFSET ??_C@_0BE@FEDLFIOP@CRender?3?3level_Load@
	push	16					; 00000010H
	push	OFFSET ??_C@_0EJ@JMNAGDJL@I?3?2Vitalya?2mine?2NSProjectX?2laye@
	push	OFFSET ??_C@_0BA@EJFFNEEE@0?$CB?$DNg_pGameLevel@
	call	edx
	mov	edx, DWORD PTR __imp_?fail@xrDebug@@QAEXPBD0H0AA_N@Z
$LN2@level_Load:

; 17   : 	R_ASSERT			(!b_loaded);

	cmp	BYTE PTR ?ignore_always@?7??level_Load@CRender@@UAEXPAVIReader@@@Z@4_NA, 0
	jne	SHORT $LN5@level_Load
	cmp	DWORD PTR [ebp+624], 0
	je	SHORT $LN5@level_Load
	mov	ecx, DWORD PTR __imp_?Debug@@3VxrDebug@@A
	push	OFFSET ?ignore_always@?7??level_Load@CRender@@UAEXPAVIReader@@@Z@4_NA
	push	OFFSET ??_C@_0BE@FEDLFIOP@CRender?3?3level_Load@
	push	17					; 00000011H
	push	OFFSET ??_C@_0EJ@JMNAGDJL@I?3?2Vitalya?2mine?2NSProjectX?2laye@
	push	OFFSET ??_C@_09KIFGLFPA@?$CBb_loaded@
	call	edx
$LN5@level_Load:

; 18   : 
; 19   : 	// Begin
; 20   : 	pApp->LoadBegin					();

	mov	ecx, DWORD PTR __imp_?pApp@@3PAVCApplication@@A
	mov	ecx, DWORD PTR [ecx]
	call	DWORD PTR __imp_?LoadBegin@CApplication@@QAEXXZ
; File I:\Vitalya\mine\NSProjectX\xrEngine\resourcemanager.h

; 171  : 	void			DeferredLoad(BOOL E) {bDeferredLoad = E;}

	mov	eax, DWORD PTR __imp_?Device@@3VCRenderDevice@@A
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender_Loader.cpp

; 25   : 	g_pGamePersistent->LoadTitle		("st_loading_shaders");

	push	OFFSET ??_C@_0BD@KEPNOJAL@st_loading_shaders@
; File I:\Vitalya\mine\NSProjectX\xrEngine\resourcemanager.h

; 171  : 	void			DeferredLoad(BOOL E) {bDeferredLoad = E;}

	mov	eax, DWORD PTR [eax+432]
	mov	DWORD PTR [eax+228], 1
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender_Loader.cpp

; 25   : 	g_pGamePersistent->LoadTitle		("st_loading_shaders");

	mov	eax, DWORD PTR __imp_?g_pGamePersistent@@3PAVIGame_Persistent@@A
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+64]

; 26   : 	{
; 27   : 		chunk = fs->open_chunk		(fsL_SHADERS);

	mov	ecx, DWORD PTR _fs$[esp+1100]
	push	2
	call	DWORD PTR __imp_?open_chunk@IReader@@QAEPAV1@I@Z

; 28   : 		R_ASSERT2					(chunk,"Level doesn't builded correctly.");

	cmp	BYTE PTR ?ignore_always@?N@??level_Load@CRender@@UAEXPAVIReader@@@Z@4_NA, 0
	mov	ebx, eax
	mov	DWORD PTR _chunk$1$[esp+1104], ebx
	jne	SHORT $LN8@level_Load
	test	ebx, ebx
	jne	SHORT $LN8@level_Load
	mov	ecx, DWORD PTR __imp_?Debug@@3VxrDebug@@A
	push	OFFSET ?ignore_always@?N@??level_Load@CRender@@UAEXPAVIReader@@@Z@4_NA
	push	OFFSET ??_C@_0BE@FEDLFIOP@CRender?3?3level_Load@
	push	28					; 0000001cH
	push	OFFSET ??_C@_0EJ@JMNAGDJL@I?3?2Vitalya?2mine?2NSProjectX?2laye@
	push	OFFSET ??_C@_0CB@IIMDNKNP@Level?5doesn?8t?5builded?5correctly@
	push	OFFSET ??_C@_05PBLOBLMM@chunk@
	call	DWORD PTR __imp_?fail@xrDebug@@QAEXPBD00H0AA_N@Z
$LN8@level_Load:

; 29   : 		u32 count = chunk->r_u32	();

	push	edi
	mov	ecx, ebx
	call	DWORD PTR __imp_?r_u32@?$IReaderBase@VIReader@@@@QAEIXZ
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1250 :         const auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);

	mov	edi, DWORD PTR [ebp+900]
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender_Loader.cpp

; 30   : 		Shaders.resize				(count);

	lea	edx, DWORD PTR [ebp+896]
	mov	esi, eax
	mov	DWORD PTR _this$1$[esp+1108], edx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1250 :         const auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);

	mov	eax, DWORD PTR [edx]
	mov	ecx, edi
	sub	ecx, eax
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender_Loader.cpp

; 29   : 		u32 count = chunk->r_u32	();

	mov	DWORD PTR _count$1$[esp+1108], esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1250 :         const auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);

	sar	ecx, 2
	mov	DWORD PTR __Backout$1$sroa$1484$1$[esp+1108], edi

; 1251 :         if (_Newsize < _Oldsize) { // trim

	cmp	esi, ecx
	jae	SHORT $LN27@level_Load

; 1252 :             const pointer _Newlast = _Myfirst + _Newsize;

	lea	eax, DWORD PTR [eax+esi*4]

; 1253 :             _Orphan_range(_Newlast, _Mylast);
; 1254 :             _Destroy(_Newlast, _Mylast);
; 1255 :             _Mylast = _Newlast;

	mov	DWORD PTR [edx+4], eax

; 1256 :             return;

	jmp	SHORT $LN28@level_Load
$LN27@level_Load:

; 1257 :         }
; 1258 : 
; 1259 :         if (_Newsize > _Oldsize) { // append

	jbe	SHORT $LN28@level_Load

; 1260 :             const auto _Oldcapacity = static_cast<size_type>(_My_data._Myend - _Myfirst);

	mov	eax, DWORD PTR [edx+8]
	sub	eax, DWORD PTR [edx]
	sar	eax, 2

; 1261 :             if (_Newsize > _Oldcapacity) { // reallocate

	cmp	esi, eax
	jbe	SHORT $LN29@level_Load

; 1262 :                 _Resize_reallocate(_Newsize, _Val);

	push	ecx
	push	esi
	mov	ecx, edx
	call	??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@V?$resptr_core@UShader@@Uresptrcode_shader@@@@V?$xalloc@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@@@std@@AAEXIABU_Value_init_tag@1@@Z ; std::vector<resptr_core<Shader,resptrcode_shader>,xalloc<resptr_core<Shader,resptrcode_shader> > >::_Resize_reallocate<std::_Value_init_tag>

; 1263 :                 return;

	jmp	SHORT $LN28@level_Load
$LN29@level_Load:

; 1267 :             _Mylast                = _Ufill(_Oldlast, _Newsize - _Oldsize, _Val);

	mov	eax, esi
	sub	eax, ecx
	mov	DWORD PTR __Count$1$[esp+1108], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1813 :     for (; 0 < _Count; --_Count) {

	je	SHORT $LN36@level_Load
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1267 :             _Mylast                = _Ufill(_Oldlast, _Newsize - _Oldsize, _Val);

	mov	ecx, eax
	xor	eax, eax
	rep stosd
	mov	edi, DWORD PTR __Backout$1$sroa$1484$1$[esp+1108]
	mov	eax, DWORD PTR __Count$1$[esp+1108]
	lea	edi, DWORD PTR [edi+eax*4]
$LN36@level_Load:
	mov	DWORD PTR [edx+4], edi
$LN28@level_Load:
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender_Loader.cpp

; 31   : 		for(u32 i=0; i<count; i++)	// skip first shader as "reserved" one

	xor	edi, edi
	test	esi, esi
	je	$LN12@level_Load
	mov	ebp, DWORD PTR _count$1$[esp+1108]
$LL13@level_Load:
; File I:\Vitalya\mine\NSProjectX\xrCore\FS.h

; 264  : 	IC void*		pointer		()	const		{	return &(data[Pos]);	};

	mov	esi, DWORD PTR [ebx+8]
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender_Loader.cpp

; 35   : 			chunk->skip_stringZ		();

	mov	ecx, ebx
; File I:\Vitalya\mine\NSProjectX\xrCore\FS.h

; 264  : 	IC void*		pointer		()	const		{	return &(data[Pos]);	};

	add	esi, DWORD PTR [ebx+4]
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender_Loader.cpp

; 35   : 			chunk->skip_stringZ		();

	call	DWORD PTR __imp_?skip_stringZ@IReader@@QAEXXZ

; 36   : 			if (0==n[0])			continue;

	cmp	BYTE PTR [esi], 0
	je	$LN11@level_Load

; 37   : 			strcpy					(n_sh,n);

	lea	ecx, DWORD PTR _n_sh$8[esp+1108]
	sub	ecx, esi
$LL20@level_Load:
	mov	al, BYTE PTR [esi]
	lea	esi, DWORD PTR [esi+1]
	mov	BYTE PTR [ecx+esi-1], al
	test	al, al
	jne	SHORT $LL20@level_Load
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\string.h

; 502  :         return const_cast<char*>(strchr(static_cast<char const*>(_String), _Ch));

	lea	eax, DWORD PTR _n_sh$8[esp+1108]
	push	47					; 0000002fH
	push	eax
	call	DWORD PTR __imp__strchr
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender_Loader.cpp

; 40   : 			strcpy					(n_tlist,delim+1);

	lea	edx, DWORD PTR _n_tlist$9[esp+1116]
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\string.h

; 502  :         return const_cast<char*>(strchr(static_cast<char const*>(_String), _Ch));

	add	esp, 8
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender_Loader.cpp

; 40   : 			strcpy					(n_tlist,delim+1);

	lea	ecx, DWORD PTR [eax+1]
	mov	BYTE PTR [eax], 0
	sub	edx, ecx
	npad	1
$LL21@level_Load:
	mov	al, BYTE PTR [ecx]
	lea	ecx, DWORD PTR [ecx+1]
	mov	BYTE PTR [edx+ecx-1], al
	test	al, al
	jne	SHORT $LL21@level_Load

; 41   : 			Shaders[i]				= Device.Resources->Create(n_sh,n_tlist);

	mov	ecx, DWORD PTR __imp_?Device@@3VCRenderDevice@@A
	lea	eax, DWORD PTR _n_tlist$9[esp+1108]
	push	0
	push	0
	push	eax
	mov	ecx, DWORD PTR [ecx+432]
	lea	eax, DWORD PTR _n_sh$8[esp+1120]
	push	eax
	call	DWORD PTR __imp_?Create@CResourceManager@@QAEPAUShader@@PBD000@Z
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 62   : 						resptr_core		(T * p, bool add_ref = true) 					{	p_ = p;	if(add_ref)	_inc(); }

	mov	esi, eax
	mov	DWORD PTR $T3[esp+1108], esi

; 43   : 	void				_inc	()									{	if (0==p_) return;	p_->dwReference++;														}

	test	esi, esi
	je	SHORT $LN57@level_Load
	inc	DWORD PTR [esi]
	mov	esi, DWORD PTR $T3[esp+1108]
$LN57@level_Load:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 119  :         _Ptr += _Off;

	mov	eax, DWORD PTR _this$1$[esp+1108]
	mov	eax, DWORD PTR [eax]
	lea	ebx, DWORD PTR [eax+edi*4]
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 48   : 	ICF		T *			_get	() const							{	return p_;																					}

	test	esi, esi

; 46   : 	ICF		void		_set	(T * rhs) 							{	if (0!=rhs) rhs->dwReference++;	_dec(); p_ = rhs;											}

	je	SHORT $LN78@level_Load
	inc	DWORD PTR [esi]
$LN78@level_Load:
	mov	ecx, ebx
	call	DWORD PTR __imp_?_dec@?$resptr_base@UShader@@@@IAEXXZ

; 64   : 						~resptr_core	()												{	_dec();						}

	lea	ecx, DWORD PTR $T3[esp+1108]

; 46   : 	ICF		void		_set	(T * rhs) 							{	if (0!=rhs) rhs->dwReference++;	_dec(); p_ = rhs;											}

	mov	DWORD PTR [ebx], esi

; 64   : 						~resptr_core	()												{	_dec();						}

	call	DWORD PTR __imp_?_dec@?$resptr_base@UShader@@@@IAEXXZ
	mov	ebx, DWORD PTR _chunk$1$[esp+1108]
$LN11@level_Load:
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender_Loader.cpp

; 31   : 		for(u32 i=0; i<count; i++)	// skip first shader as "reserved" one

	inc	edi
	cmp	edi, ebp
	jb	$LL13@level_Load
	mov	ebp, DWORD PTR _this$1$[esp+1108]
$LN12@level_Load:

; 42   : 		}
; 43   : 		chunk->close();

	mov	ecx, ebx
	call	DWORD PTR __imp_?close@IReader@@QAEXXZ

; 44   : 	}
; 45   : 
; 46   : 	// Components
; 47   : 	g_pGamePersistent->LoadTitle("st_loading_components");

	mov	eax, DWORD PTR __imp_?g_pGamePersistent@@3PAVIGame_Persistent@@A
	push	OFFSET ??_C@_0BG@KBNNKPDD@st_loading_components@
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+64]
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h

; 68   : 	T* ptr	= (T*)Memory.mem_alloc(sizeof(T));

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	mov	ebx, DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
	push	124					; 0000007cH
	call	ebx

; 69   : 	return new (ptr) T();

	mov	ecx, eax
	call	??0CLightShadows@@QAE@XZ		; CLightShadows::CLightShadows
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender_Loader.cpp

; 48   : 	L_Shadows					= xr_new<CLightShadows>		();

	mov	DWORD PTR [ebp+988], eax
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h

; 68   : 	T* ptr	= (T*)Memory.mem_alloc(sizeof(T));

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	60					; 0000003cH
	call	ebx

; 69   : 	return new (ptr) T();

	mov	ecx, eax
	call	??0CLightProjector@@QAE@XZ		; CLightProjector::CLightProjector
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender_Loader.cpp

; 49   : 	L_Projector					= xr_new<CLightProjector>	();

	mov	DWORD PTR [ebp+992], eax
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h

; 68   : 	T* ptr	= (T*)Memory.mem_alloc(sizeof(T));

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	56					; 00000038H
	call	ebx
	push	72					; 00000048H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [eax], 0
	mov	DWORD PTR [eax+4], 0
	mov	DWORD PTR [eax+8], 0
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 61   : 						resptr_core		()												{	p_ = 0;						}

	mov	DWORD PTR [eax+12], 0
	mov	DWORD PTR [eax+16], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [eax+20], 0
	mov	DWORD PTR [eax+24], 0
	mov	DWORD PTR [eax+28], 0
	mov	DWORD PTR [eax+32], 0
	mov	DWORD PTR [eax+36], 0
	mov	DWORD PTR [eax+40], 0
	mov	DWORD PTR [eax+44], 0
	mov	DWORD PTR [eax+48], 0
	mov	DWORD PTR [eax+52], 0
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender_Loader.cpp

; 50   : 	L_DB						= xr_new<CLight_DB>			();

	mov	DWORD PTR [ebp+980], eax
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h

; 68   : 	T* ptr	= (T*)Memory.mem_alloc(sizeof(T));

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	ebx
	push	1508					; 000005e4H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [eax], 0
	mov	DWORD PTR [eax+4], 0
	mov	DWORD PTR [eax+8], 0
	mov	DWORD PTR [eax+12], 0
	mov	DWORD PTR [eax+16], 0
	mov	DWORD PTR [eax+20], 0
	mov	DWORD PTR [eax+24], 0
	mov	DWORD PTR [eax+28], 0
	mov	DWORD PTR [eax+32], 0
	mov	DWORD PTR [eax+36], 0
	mov	DWORD PTR [eax+40], 0
	mov	DWORD PTR [eax+44], 0
	mov	DWORD PTR [eax+48], 0
	mov	DWORD PTR [eax+52], 0
	mov	DWORD PTR [eax+56], 0
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 61   : 						resptr_core		()												{	p_ = 0;						}

	mov	DWORD PTR [eax+60], 0
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender_Loader.cpp

; 51   : 	L_Glows						= xr_new<CGlowManager>		();

	mov	DWORD PTR [ebp+996], eax
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h

; 68   : 	T* ptr	= (T*)Memory.mem_alloc(sizeof(T));

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	ebx

; 69   : 	return new (ptr) T();

	mov	edi, eax
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp

; 53   : {

	lea	ecx, DWORD PTR [edi+1444]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [edi], 0
	mov	DWORD PTR [edi+4], 0
	mov	DWORD PTR [edi+8], 0
	mov	DWORD PTR [edi+12], 0
	mov	DWORD PTR [edi+16], 0
	mov	DWORD PTR [edi+20], 0
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 61   : 						resptr_core		()												{	p_ = 0;						}

	mov	DWORD PTR [edi+24], 0
; File I:\Vitalya\mine\NSProjectX\xrCore\FixedVector.h

; 21   : 	svector() : count(0) 

	mov	DWORD PTR [edi+860], 0
	mov	DWORD PTR [edi+1440], 0
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp

; 53   : {

	call	DWORD PTR __imp_??0xrXRC@@QAE@XZ
	lea	ecx, DWORD PTR [edi+1468]
	call	DWORD PTR __imp_??0Collector@CDB@@QAE@XZ
	lea	ecx, DWORD PTR [edi+1504]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [edi+1492], 0
	mov	DWORD PTR [edi+1496], 0
	mov	DWORD PTR [edi+1500], 0
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp

; 53   : {

	call	DWORD PTR __imp_??0xrCriticalSection@@QAE@XZ
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1546 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	eax, DWORD PTR [edi+8]
	sub	eax, DWORD PTR [edi]
	sar	eax, 2

; 1358 :         if (_Newcapacity > capacity()) { // something to do (reserve() never shrinks)

	cmp	eax, 256				; 00000100H
	jae	SHORT $LN209@level_Load

; 1359 :             if (_Newcapacity > max_size()) {
; 1360 :                 _Xlength();
; 1361 :             }
; 1362 : 
; 1363 :             _Reallocate_exactly(_Newcapacity);

	push	ecx
	mov	ecx, edi
	call	?_Reallocate_exactly@?$vector@PAUstatic_wallmark@CWallmarksEngine@@V?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@@std@@AAEXI@Z ; std::vector<CWallmarksEngine::static_wallmark *,xalloc<CWallmarksEngine::static_wallmark *> >::_Reallocate_exactly
$LN209@level_Load:

; 1546 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	eax, DWORD PTR [edi+20]
	sub	eax, DWORD PTR [edi+12]
	sar	eax, 2

; 1358 :         if (_Newcapacity > capacity()) { // something to do (reserve() never shrinks)

	cmp	eax, 256				; 00000100H
	jae	SHORT $LN216@level_Load

; 1359 :             if (_Newcapacity > max_size()) {
; 1360 :                 _Xlength();
; 1361 :             }
; 1362 : 
; 1363 :             _Reallocate_exactly(_Newcapacity);

	push	ecx
	lea	ecx, DWORD PTR [edi+12]
	call	?_Reallocate_exactly@?$vector@PAUwm_slot@WallmarksEngine@@V?$xalloc@PAUwm_slot@WallmarksEngine@@@@@std@@AAEXI@Z ; std::vector<WallmarksEngine::wm_slot *,xalloc<WallmarksEngine::wm_slot *> >::_Reallocate_exactly
$LN216@level_Load:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp

; 56   : 	hGeom.create			(FVF::F_LIT, RCache.Vertex.Buffer(), NULL);

	mov	eax, DWORD PTR __imp_?RCache@@3VCBackend@@A
	lea	ecx, DWORD PTR [edi+24]
	push	0
	push	DWORD PTR [eax]
	push	322					; 00000142H
	call	DWORD PTR __imp_?create@resptrcode_geom@@QAEXIPAUIDirect3DVertexBuffer9@@PAUIDirect3DIndexBuffer9@@@Z
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender_Loader.cpp

; 52   : 	Wallmarks					= xr_new<CWallmarksEngine>	();

	mov	DWORD PTR [ebp+1000], edi
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h

; 68   : 	T* ptr	= (T*)Memory.mem_alloc(sizeof(T));

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	701284					; 000ab364H
	call	ebx

; 69   : 	return new (ptr) T();

	mov	ebx, eax
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager.cpp

; 76   : {

	mov	DWORD PTR [ebx], OFFSET ??_7CDetailManager@@6B@
	lea	ecx, DWORD PTR [ebx+1432]
; File I:\Vitalya\mine\NSProjectX\xrCore\FixedVector.h

; 21   : 	svector() : count(0) 

	mov	DWORD PTR [ebx+1392], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ebx+1396], 0
	mov	DWORD PTR [ebx+1408], 0
	mov	DWORD PTR [ebx+1400], 0
	mov	DWORD PTR [ebx+1404], 0
	mov	DWORD PTR [ebx+1412], 0
	mov	DWORD PTR [ebx+1416], 0
	mov	DWORD PTR [ebx+1420], 0
	mov	DWORD PTR [ebx+1424], 0
	mov	DWORD PTR [ebx+1428], 0
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager.cpp

; 76   : {

	call	DWORD PTR __imp_??0xrXRC@@QAE@XZ
	lea	eax, DWORD PTR [ebx+1456]
	mov	edx, 144				; 00000090H
	npad	13
$LL244@level_Load:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\detailmanager.h

; 73   : 		CacheSlot1()				{empty=1; vis.clear();}

	lea	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [eax], 1
	call	?clear@vis_data@@QAEXXZ			; vis_data::clear
	lea	eax, DWORD PTR [eax+124]
	sub	edx, 1
	jne	SHORT $LL244@level_Load
; File I:\Vitalya\mine\NSProjectX\xrCore\FixedVector.h

; 21   : 	svector() : count(0) 

	mov	DWORD PTR [ebx+38520], edx
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager.cpp

; 76   : {

	lea	esi, DWORD PTR [ebx+38524]
	mov	edi, 2401				; 00000961H
$LL252@level_Load:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\detailmanager.h

; 67   : 									Slot()				{ frame=0;empty=1; type=stReady; sx=sz=0; vis.clear(); }

	push	OFFSET ??0SlotPart@CDetailManager@@QAE@XZ
	push	4
	push	52					; 00000034H
	lea	eax, DWORD PTR [esi+68]
	push	eax
	call	??_H@YGXPAXIIP6EPAX0@Z@Z
	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR [esi], 1
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+4], 0
	call	?clear@vis_data@@QAEXXZ			; vis_data::clear
	lea	esi, DWORD PTR [esi+276]
	sub	edi, 1
	jne	SHORT $LL252@level_Load
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager.cpp

; 76   : {

	lea	ecx, DWORD PTR [ebx+701272]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ebx+701212], edi
	mov	DWORD PTR [ebx+701216], edi
	mov	DWORD PTR [ebx+701220], edi
; File I:\Vitalya\mine\NSProjectX\xrCore\xrPool.h

; 31   : 		list				= 0;

	mov	DWORD PTR [ebx+701208], edi
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 61   : 						resptr_core		()												{	p_ = 0;						}

	mov	DWORD PTR [ebx+701224], edi
	mov	DWORD PTR [ebx+701228], edi
	mov	DWORD PTR [ebx+701244], edi
	mov	DWORD PTR [ebx+701248], edi
	mov	DWORD PTR [ebx+701252], edi
	mov	DWORD PTR [ebx+701256], edi
	mov	DWORD PTR [ebx+701260], edi
	mov	DWORD PTR [ebx+701264], edi
	mov	DWORD PTR [ebx+701268], edi
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager.cpp

; 76   : {

	call	DWORD PTR __imp_??0xrCriticalSection@@QAE@XZ
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 46   : 	ICF		void		_set	(T * rhs) 							{	if (0!=rhs) rhs->dwReference++;	_dec(); p_ = rhs;											}

	lea	ecx, DWORD PTR [ebx+701224]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager.cpp

; 77   : 	dtFS 		= 0;

	mov	DWORD PTR [ebx+1088], edi

; 78   : 	dtSlots		= 0;

	mov	DWORD PTR [ebx+1116], edi
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 62   : 						resptr_core		(T * p, bool add_ref = true) 					{	p_ = p;	if(add_ref)	_inc(); }

	mov	DWORD PTR $T5[esp+1108], edi

; 46   : 	ICF		void		_set	(T * rhs) 							{	if (0!=rhs) rhs->dwReference++;	_dec(); p_ = rhs;											}

	call	DWORD PTR __imp_?_dec@?$resptr_base@USGeometry@@@@IAEXXZ

; 64   : 						~resptr_core	()												{	_dec();						}

	lea	ecx, DWORD PTR $T5[esp+1108]

; 46   : 	ICF		void		_set	(T * rhs) 							{	if (0!=rhs) rhs->dwReference++;	_dec(); p_ = rhs;											}

	mov	DWORD PTR [ebx+701224], edi

; 64   : 						~resptr_core	()												{	_dec();						}

	call	DWORD PTR __imp_?_dec@?$resptr_base@USGeometry@@@@IAEXXZ

; 46   : 	ICF		void		_set	(T * rhs) 							{	if (0!=rhs) rhs->dwReference++;	_dec(); p_ = rhs;											}

	lea	ecx, DWORD PTR [ebx+701228]

; 62   : 						resptr_core		(T * p, bool add_ref = true) 					{	p_ = p;	if(add_ref)	_inc(); }

	mov	DWORD PTR $T6[esp+1108], edi

; 46   : 	ICF		void		_set	(T * rhs) 							{	if (0!=rhs) rhs->dwReference++;	_dec(); p_ = rhs;											}

	call	DWORD PTR __imp_?_dec@?$resptr_base@USGeometry@@@@IAEXXZ

; 64   : 						~resptr_core	()												{	_dec();						}

	lea	ecx, DWORD PTR $T6[esp+1108]

; 46   : 	ICF		void		_set	(T * rhs) 							{	if (0!=rhs) rhs->dwReference++;	_dec(); p_ = rhs;											}

	mov	DWORD PTR [ebx+701228], edi

; 64   : 						~resptr_core	()												{	_dec();						}

	call	DWORD PTR __imp_?_dec@?$resptr_base@USGeometry@@@@IAEXXZ
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager.cpp

; 81   : 	hw_BatchSize= 0;

	mov	DWORD PTR [ebx+701232], edi
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender_Loader.cpp

; 55   : 	rmFar						();

	mov	ecx, ebp
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager.cpp

; 82   : 	hw_VB		= 0;

	mov	DWORD PTR [ebx+701236], edi

; 83   : 	hw_IB		= 0;

	mov	DWORD PTR [ebx+701240], edi
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender_Loader.cpp

; 55   : 	rmFar						();

	mov	eax, DWORD PTR [ebp]
	mov	DWORD PTR [ebp+1004], ebx
	call	DWORD PTR [eax+216]

; 56   : 	rmNormal					();

	mov	eax, DWORD PTR [ebp]
	mov	ecx, ebp
	call	DWORD PTR [eax+220]

; 57   : 
; 58   : 	marker						= 0;
; 59   : 
; 60   : 	if	(!g_dedicated_server)	{

	mov	eax, DWORD PTR __imp_?g_dedicated_server@@3_NA
	mov	DWORD PTR [ebp+296], edi
	cmp	BYTE PTR [eax], 0
	jne	$LN399@level_Load

; 61   : 		// VB,IB,SWI
; 62   : 		g_pGamePersistent->LoadTitle("st_loading_geometry");

	mov	eax, DWORD PTR __imp_?g_pGamePersistent@@3PAVIGame_Persistent@@A
	push	OFFSET ??_C@_0BE@FADLPPAM@st_loading_geometry@
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+64]

; 63   : 		CStreamReader				*geom = FS.rs_open	("$level$","level.geom");

	mov	ecx, DWORD PTR __imp_?xr_FS@@3PAVCLocatorAPI@@A
	push	OFFSET ??_C@_0L@CHEIOGBE@level?4geom@
	push	OFFSET ??_C@_07DJIBDFPO@$level$@
	mov	ecx, DWORD PTR [ecx]
	call	DWORD PTR __imp_?rs_open@CLocatorAPI@@QAEPAVCStreamReader@@PBD0@Z

; 64   : 		LoadBuffers					(geom);

	push	eax
	mov	ecx, ebp
	mov	DWORD PTR _geom$2[esp+1112], eax
	call	?LoadBuffers@CRender@@AAEXPAVCStreamReader@@@Z ; CRender::LoadBuffers

; 65   : 		LoadSWIs					(geom);

	push	DWORD PTR _geom$2[esp+1108]
	mov	ecx, ebp
	call	?LoadSWIs@CRender@@AAEXPAVCStreamReader@@@Z ; CRender::LoadSWIs

; 66   : 		FS.r_close					(geom);

	mov	ecx, DWORD PTR __imp_?xr_FS@@3PAVCLocatorAPI@@A
	lea	eax, DWORD PTR _geom$2[esp+1108]
	push	eax
	mov	ecx, DWORD PTR [ecx]
	call	DWORD PTR __imp_?r_close@CLocatorAPI@@QAEXAAPAVCStreamReader@@@Z

; 67   : 
; 68   : 		// Visuals
; 69   : 		g_pGamePersistent->LoadTitle("st_loading_spatial_db");

	mov	eax, DWORD PTR __imp_?g_pGamePersistent@@3PAVIGame_Persistent@@A
	push	OFFSET ??_C@_0BG@CDAOLGEJ@st_loading_spatial_db@
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+64]

; 70   : 		chunk						= fs->open_chunk(fsL_VISUALS);

	mov	ecx, DWORD PTR _fs$[esp+1104]
	mov	ebx, DWORD PTR __imp_?open_chunk@IReader@@QAEPAV1@I@Z
	push	3
	call	ebx

; 257  : 	while ((chunk=fs->open_chunk(index))!=0)

	push	edi
	mov	ecx, eax

; 70   : 		chunk						= fs->open_chunk(fsL_VISUALS);

	mov	DWORD PTR _chunk$2$[esp+1112], eax

; 257  : 	while ((chunk=fs->open_chunk(index))!=0)

	call	ebx
	mov	edi, eax
	test	edi, edi
	je	SHORT $LN400@level_Load
	lea	esi, DWORD PTR [ebp+944]

; 262  : 		Visuals.push_back			(V);

	xor	ebp, ebp
$LL346@level_Load:

; 258  : 	{
; 259  : 		chunk->r_chunk_safe			(OGF_HEADER,&H,sizeof(H));

	push	44					; 0000002cH
	lea	eax, DWORD PTR _H$7[esp+1112]
	mov	ecx, edi
	push	eax
	push	1
	call	DWORD PTR __imp_?r_chunk_safe@?$IReaderBase@VIReader@@@@QAEHIPAXI@Z

; 260  : 		V = Models->Instance_Create	(H.type);

	movzx	eax, BYTE PTR _H$7[esp+1109]
	push	eax
	call	?Instance_Create@CModelPool@@QAEPAVIRender_Visual@@I@Z ; CModelPool::Instance_Create
	mov	ebx, eax

; 261  : 		V->Load						(0,chunk,0);

	push	0
	push	edi
	push	0
	mov	edx, DWORD PTR [ebx]
	mov	ecx, ebx
	mov	DWORD PTR _V$4[esp+1120], ebx
	call	DWORD PTR [edx+4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 730  :         if (_Mylast != _My_data._Myend) {

	mov	eax, DWORD PTR [esi+4]
	cmp	eax, DWORD PTR [esi+8]
	je	SHORT $LN352@level_Load

; 713  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

	mov	DWORD PTR [eax], ebx

; 714  :         _Orphan_range(_Mylast, _Mylast);
; 715  :         _Ty& _Result = *_Mylast;
; 716  :         ++_Mylast;

	add	DWORD PTR [esi+4], 4

; 731  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

	jmp	SHORT $LN351@level_Load
$LN352@level_Load:

; 732  :         }
; 733  : 
; 734  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	lea	ecx, DWORD PTR _V$4[esp+1108]
	push	ecx
	push	eax
	mov	ecx, esi
	call	??$_Emplace_reallocate@ABQAVIRender_Visual@@@?$vector@PAVIRender_Visual@@V?$xalloc@PAVIRender_Visual@@@@@std@@QAEPAPAVIRender_Visual@@QAPAV2@ABQAV2@@Z ; std::vector<IRender_Visual *,xalloc<IRender_Visual *> >::_Emplace_reallocate<IRender_Visual * const &>
$LN351@level_Load:
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender_Loader.cpp

; 264  : 		chunk->close();

	mov	ebx, DWORD PTR __imp_?close@IReader@@QAEXXZ
	mov	ecx, edi
	call	ebx
	mov	ecx, DWORD PTR _chunk$2$[esp+1108]

; 265  : 		index++;

	inc	ebp
	push	ebp
	call	DWORD PTR __imp_?open_chunk@IReader@@QAEPAV1@I@Z
	mov	edi, eax
	test	edi, edi
	jne	SHORT $LL346@level_Load
	mov	ebp, DWORD PTR _this$1$[esp+1108]

; 95   : 
; 96   : void CRender::level_Unload		()
; 97   : {
; 98   : 	if (0==g_pGameLevel)		return;
; 99   : 	if (!b_loaded)				return;
; 100  : 
; 101  : 	Device.Resources->DeferredUnload();
; 102  : 
; 103  : 	u32							I;
; 104  : 
; 105  : 	// HOM
; 106  : 	g_pGamePersistent->LoadTitle("st_unloading_hom");
; 107  : 	HOM.Unload					();
; 108  : 
; 109  : 	//*** Details
; 110  : 	g_pGamePersistent->LoadTitle("st_unloading_details");
; 111  : 	Details->Unload				();
; 112  : 
; 113  : 	//*** Sectors
; 114  : 	// 1.
; 115  : 	g_pGamePersistent->LoadTitle("st_unloading_sectors_portals");
; 116  : 	xr_delete					(rmPortals);
; 117  : 	pLastSector					= 0;
; 118  : 	vLastCameraPos.set			(flt_max,flt_max,flt_max);
; 119  : 	uLastLTRACK					= 0;
; 120  : 
; 121  : 	// 2.
; 122  : 	for (I=0; I<Sectors.size(); I++)	xr_delete(Sectors[I]);
; 123  : 	Sectors.clear_and_free		();
; 124  : 	// 3.
; 125  : 	for (I=0; I<Portals.size(); I++)	xr_delete(Portals[I]);
; 126  : 	Portals.clear_and_free		();
; 127  : 
; 128  : 	//*** Lights
; 129  : 	g_pGamePersistent->LoadTitle("st_unloading_lights");
; 130  : 	L_Glows->Unload				();
; 131  : 	L_DB->Unload				();
; 132  : 
; 133  : 	//*** Visuals
; 134  : 	g_pGamePersistent->LoadTitle("st_unloading_spatial_db");
; 135  : 	for (I=0; I<Visuals.size(); I++)	{
; 136  : 		Visuals[I]->Release();
; 137  : 		xr_delete(Visuals[I]);
; 138  : 	}
; 139  : 	Visuals.clear_and_free		();
; 140  : 
; 141  : 	//*** SWI
; 142  : 	g_pGamePersistent->LoadTitle("st_unloading_geometry");
; 143  : 	for (I=0; I<SWIs.size();I++)xr_free	(SWIs[I].sw);
; 144  : 	SWIs.clear					();
; 145  : 
; 146  : 	//*** VB/IB
; 147  : 	g_pGamePersistent->LoadTitle("st_unloading_geometry");
; 148  : 	for (I=0; I<VB.size(); I++)	_RELEASE(VB[I]);
; 149  : 	for (I=0; I<IB.size(); I++)	_RELEASE(IB[I]);
; 150  : 	DCL.clear_and_free			();
; 151  : 	VB.clear_and_free			();
; 152  : 	IB.clear_and_free			();
; 153  : 
; 154  : 	//*** Components
; 155  : 	g_pGamePersistent->LoadTitle("st_unloading_components");
; 156  : 	xr_delete					(Details);
; 157  : 	xr_delete					(Wallmarks);
; 158  : 	xr_delete					(L_Glows);
; 159  : 	xr_delete					(L_DB);
; 160  : 	xr_delete					(L_Projector);
; 161  : 	xr_delete					(L_Shadows);
; 162  : 
; 163  : 	//*** Shaders
; 164  : 	g_pGamePersistent->LoadTitle("st_unloading_shaders");
; 165  : 	Shaders.clear_and_free		();
; 166  : 
; 167  : 	//. dbg
; 168  : #ifdef DEBUG
; 169  : 	// Device.Resources->_DumpMemoryUsage	();
; 170  : 	Device.Resources->DBG_VerifyGeoms	();
; 171  : 	Device.Resources->DBG_VerifyTextures();
; 172  : #endif
; 173  : 	b_loaded					= FALSE;
; 174  : }
; 175  : 
; 176  : void CRender::LoadBuffers	(CStreamReader *base_fs)
; 177  : {
; 178  : 	Device.Resources->Evict	();
; 179  : 	u32	dwUsage				= D3DUSAGE_WRITEONLY | (HW.Caps.geometry.bSoftware?D3DUSAGE_SOFTWAREPROCESSING:0);
; 180  : 
; 181  : 	// Vertex buffers
; 182  : 	if (base_fs->find_chunk(fsL_VB))
; 183  : 	{
; 184  : 		// Use DX9-style declarators
; 185  : 		CStreamReader			*fs	= base_fs->open_chunk(fsL_VB);
; 186  : 		u32 count				= fs->r_u32();
; 187  : 		DCL.resize				(count);
; 188  : 		VB.resize				(count);
; 189  : 		for (u32 i=0; i<count; i++)
; 190  : 		{
; 191  : 			// decl
; 192  : 
; 193  : //			D3DVERTEXELEMENT9	*dcl = (D3DVERTEXELEMENT9*) fs->pointer();
; 194  : 			u32					buffer_size = (MAXD3DDECLLENGTH+1)*sizeof(D3DVERTEXELEMENT9);
; 195  : 			D3DVERTEXELEMENT9	*dcl = (D3DVERTEXELEMENT9*)_alloca(buffer_size);
; 196  : 			fs->r				(dcl,buffer_size);
; 197  : 			fs->advance			(-(int)buffer_size);
; 198  : 
; 199  : 			u32 dcl_len			= D3DXGetDeclLength		(dcl)+1;
; 200  : 
; 201  : 			DCL[i].resize		(dcl_len);
; 202  : 			fs->r				(DCL[i].begin(),dcl_len*sizeof(D3DVERTEXELEMENT9));
; 203  : 			//.????????? remove T&B from DCL[]
; 204  : 
; 205  : 			// count, size
; 206  : 			u32 vCount			= fs->r_u32	();
; 207  : 			u32 vSize			= D3DXGetDeclVertexSize	(dcl,0);
; 208  : 			Msg	("* [Loading VB] %d verts, %d Kb",vCount,(vCount*vSize)/1024);
; 209  : 
; 210  : 			// Create and fill
; 211  : 			BYTE*	pData		= 0;
; 212  : 			R_CHK				(HW.pDevice->CreateVertexBuffer(vCount*vSize,dwUsage,0,D3DPOOL_MANAGED,&VB[i],0));
; 213  : 			R_CHK				(VB[i]->Lock(0,0,(void**)&pData,0));
; 214  : 			fs->r				(pData,vCount*vSize);
; 215  : //			CopyMemory			(pData,fs->pointer(),vCount*vSize);	//.???? copy while skip T&B
; 216  : 			VB[i]->Unlock		();
; 217  : 
; 218  : //			fs->advance			(vCount*vSize);
; 219  : 		}
; 220  : 		fs->close				();
; 221  : 	} else {
; 222  : 		FATAL					("DX7-style FVFs unsupported");
; 223  : 	}
; 224  : 
; 225  : 	// Index buffers
; 226  : 	if (base_fs->find_chunk(fsL_IB))
; 227  : 	{
; 228  : 		CStreamReader			*fs	= base_fs->open_chunk(fsL_IB);
; 229  : 		u32 count				= fs->r_u32();
; 230  : 		IB.resize				(count);
; 231  : 		for (u32 i=0; i<count; i++)
; 232  : 		{
; 233  : 			u32 iCount		= fs->r_u32	();
; 234  : 			Msg("* [Loading IB] %d indices, %d Kb",iCount,(iCount*2)/1024);
; 235  : 
; 236  : 			// Create and fill
; 237  : 			BYTE*	pData		= 0;
; 238  : 			R_CHK				(HW.pDevice->CreateIndexBuffer(iCount*2,dwUsage,D3DFMT_INDEX16,D3DPOOL_MANAGED,&IB[i],0));
; 239  : 			R_CHK				(IB[i]->Lock(0,0,(void**)&pData,0));
; 240  : //			CopyMemory			(pData,fs->pointer(),iCount*2);
; 241  : 			fs->r				(pData,iCount*2);
; 242  : 			IB[i]->Unlock		();
; 243  : 
; 244  : //			fs->advance			(iCount*2);
; 245  : 		}
; 246  : 		fs->close				();
; 247  : 	}
; 248  : }
; 249  : 
; 250  : void CRender::LoadVisuals(IReader *fs)
; 251  : {
; 252  : 	IReader*		chunk	= 0;
; 253  : 	u32				index	= 0;
; 254  : 	IRender_Visual*	V		= 0;
; 255  : 	ogf_header		H;
; 256  : 
; 257  : 	while ((chunk=fs->open_chunk(index))!=0)

	jmp	SHORT $LN347@level_Load
$LN400@level_Load:
	mov	ebx, DWORD PTR __imp_?close@IReader@@QAEXXZ
$LN347@level_Load:

; 71   : 		LoadVisuals					(chunk);
; 72   : 		chunk->close				();

	mov	ecx, DWORD PTR _chunk$2$[esp+1108]
	call	ebx

; 73   : 
; 74   : 		// Details
; 75   : 		g_pGamePersistent->LoadTitle("st_loading_details");

	mov	eax, DWORD PTR __imp_?g_pGamePersistent@@3PAVIGame_Persistent@@A
	push	OFFSET ??_C@_0BD@HEMBJNGD@st_loading_details@
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+64]

; 76   : 		Details->Load				();

	mov	ecx, DWORD PTR [ebp+1004]
	call	?Load@CDetailManager@@QAEXXZ		; CDetailManager::Load
	jmp	SHORT $LN18@level_Load
$LN399@level_Load:

; 57   : 
; 58   : 	marker						= 0;
; 59   : 
; 60   : 	if	(!g_dedicated_server)	{

	mov	ebx, DWORD PTR __imp_?close@IReader@@QAEXXZ
$LN18@level_Load:

; 77   : 	}
; 78   : 	
; 79   : 	// Sectors
; 80   : 	g_pGamePersistent->LoadTitle("st_loading_sectors_portals");

	mov	eax, DWORD PTR __imp_?g_pGamePersistent@@3PAVIGame_Persistent@@A
	push	OFFSET ??_C@_0BL@FEBBHFPA@st_loading_sectors_portals@
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+64]

; 81   : 	LoadSectors					(fs);

	mov	esi, DWORD PTR _fs$[esp+1104]
	mov	ecx, ebp
	push	esi
	call	?LoadSectors@CRender@@AAEXPAVIReader@@@Z ; CRender::LoadSectors

; 82   : 
; 83   : 	// HOM
; 84   : 	g_pGamePersistent->LoadTitle("st_loading_hom");

	mov	eax, DWORD PTR __imp_?g_pGamePersistent@@3PAVIGame_Persistent@@A
	push	OFFSET ??_C@_0P@OFDPMDIN@st_loading_hom@
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+64]

; 85   : 	HOM.Load					();

	lea	ecx, DWORD PTR [ebp+712]
	call	?Load@CHOM@@QAEXXZ			; CHOM::Load

; 86   : 
; 87   : 	// Lights
; 88   : 	g_pGamePersistent->LoadTitle("st_loading_lights");

	mov	eax, DWORD PTR __imp_?g_pGamePersistent@@3PAVIGame_Persistent@@A
	push	OFFSET ??_C@_0BC@HOICMLHM@st_loading_lights@
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+64]

; 272  : 	L_DB->Load		(fs);

	mov	ecx, DWORD PTR [ebp+980]
	push	esi
	call	?Load@CLight_DB@@QAEXPAVIReader@@@Z	; CLight_DB::Load

; 273  : 
; 274  : 	// glows
; 275  : 	IReader			*chunk = fs->open_chunk(fsL_GLOWS);

	push	7
	mov	ecx, esi
	call	DWORD PTR __imp_?open_chunk@IReader@@QAEPAV1@I@Z

; 276  : 	R_ASSERT		(chunk && "Can't find glows");

	cmp	BYTE PTR ?ignore_always@?3??LoadLights@CRender@@AAEXPAVIReader@@@Z@4_NA, 0
	mov	esi, eax
	pop	edi
	jne	SHORT $LN357@level_Load
	test	esi, esi
	jne	SHORT $LN357@level_Load
	mov	ecx, DWORD PTR __imp_?Debug@@3VxrDebug@@A
	push	OFFSET ?ignore_always@?3??LoadLights@CRender@@AAEXPAVIReader@@@Z@4_NA
	push	OFFSET ??_C@_0BE@OILIHGFK@CRender?3?3LoadLights@
	push	276					; 00000114H
	push	OFFSET ??_C@_0EJ@JMNAGDJL@I?3?2Vitalya?2mine?2NSProjectX?2laye@
	push	OFFSET ??_C@_0BM@BIODNPP@chunk?5?$CG?$CG?5?$CCCan?8t?5find?5glows?$CC@
	call	DWORD PTR __imp_?fail@xrDebug@@QAEXPBD0H0AA_N@Z
$LN357@level_Load:

; 277  : 	L_Glows->Load	(chunk);

	mov	ecx, DWORD PTR [ebp+996]
	push	esi
	call	?Load@CGlowManager@@QAEXPAVIReader@@@Z	; CGlowManager::Load

; 278  : 	chunk->close	();

	mov	ecx, esi
	call	ebx

; 89   : 	LoadLights					(fs);
; 90   : 
; 91   : 	// End
; 92   : 	pApp->LoadEnd				();

	mov	ecx, DWORD PTR __imp_?pApp@@3PAVCApplication@@A
	mov	ecx, DWORD PTR [ecx]
	call	DWORD PTR __imp_?LoadEnd@CApplication@@QAEXXZ

; 93   : 	b_loaded					= TRUE	;

	pop	esi
	mov	DWORD PTR [ebp+624], 1
	pop	ebp
	pop	ebx

; 94   : }

	add	esp, 1092				; 00000444H
	ret	4
?level_Load@CRender@@UAEXPAVIReader@@@Z ENDP		; CRender::level_Load
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender_Loader.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender_Loader.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender_Loader.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender_Loader.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender_Loader.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender_Loader.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender_Loader.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender_Loader.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender_Loader.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender_Loader.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender_Loader.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender_Loader.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender_Loader.cpp
_TEXT	SEGMENT
$T1 = -36						; size = 4
$T2 = -36						; size = 4
_dwUsage$1$ = -32					; size = 4
__Oldlast$1$ = -28					; size = 4
tv1438 = -28						; size = 4
tv1416 = -28						; size = 4
$T3 = -28						; size = 1
tv1430 = -24						; size = 4
_pData$4 = -24						; size = 4
$T5 = -24						; size = 4
_count$1$ = -20						; size = 4
_pData$6 = -20						; size = 4
tv1437 = -16						; size = 4
__Oldlast$1$ = -12					; size = 4
_i$1$ = -12						; size = 4
_this$1$ = -8						; size = 4
_fs$1$ = -4						; size = 4
_fs$1$ = 8						; size = 4
_base_fs$ = 8						; size = 4
?LoadBuffers@CRender@@AAEXPAVCStreamReader@@@Z PROC	; CRender::LoadBuffers
; _this$ = ecx

; 177  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H
	push	ebx
	push	esi
	push	edi
	mov	edi, ecx

; 178  : 	Device.Resources->Evict	();

	mov	ecx, DWORD PTR __imp_?Device@@3VCRenderDevice@@A
	mov	DWORD PTR _this$1$[ebp], edi
	mov	ecx, DWORD PTR [ecx+432]
	call	DWORD PTR __imp_?Evict@CResourceManager@@QAEXXZ

; 179  : 	u32	dwUsage				= D3DUSAGE_WRITEONLY | (HW.Caps.geometry.bSoftware?D3DUSAGE_SOFTWAREPROCESSING:0);

	mov	eax, DWORD PTR __imp_?HW@@3VCHW@@A

; 180  : 
; 181  : 	// Vertex buffers
; 182  : 	if (base_fs->find_chunk(fsL_VB))

	mov	esi, DWORD PTR _base_fs$[ebp]
	mov	ecx, esi
	push	0
	push	9
	mov	eax, DWORD PTR [eax+56]
	and	eax, 1
	shl	eax, 4
	or	eax, 8
	mov	DWORD PTR _dwUsage$1$[ebp], eax
	call	DWORD PTR __imp_?find_chunk@?$IReaderBase@VCStreamReader@@@@QAEIIPAH@Z
	mov	ebx, DWORD PTR __imp_?error@xrDebug@@QAEXJPBD0H0AA_N@Z
	test	eax, eax
	je	$LN20@LoadBuffer

; 183  : 	{
; 184  : 		// Use DX9-style declarators
; 185  : 		CStreamReader			*fs	= base_fs->open_chunk(fsL_VB);

	lea	eax, DWORD PTR $T2[ebp]
	mov	DWORD PTR $T2[ebp], 9
	push	eax
	mov	ecx, esi
	call	DWORD PTR __imp_?open_chunk@CStreamReader@@QAEPAV1@ABI@Z

; 186  : 		u32 count				= fs->r_u32();

	mov	ecx, eax
	mov	DWORD PTR _fs$1$[ebp], eax
	call	DWORD PTR __imp_?r_u32@?$IReaderBase@VCStreamReader@@@@QAEIXZ
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1250 :         const auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);

	mov	ecx, DWORD PTR [edi+912]
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender_Loader.cpp

; 187  : 		DCL.resize				(count);

	add	edi, 908				; 0000038cH
	mov	ebx, eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1250 :         const auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);

	mov	eax, 1049152317				; 3e88cb3dH
	sub	ecx, DWORD PTR [edi]
	imul	ecx
	sar	edx, 7
	mov	esi, edx
	shr	esi, 31					; 0000001fH
	add	esi, edx

; 1251 :         if (_Newsize < _Oldsize) { // trim

	cmp	ebx, esi
	jae	SHORT $LN31@LoadBuffer

; 1252 :             const pointer _Newlast = _Myfirst + _Newsize;

	imul	eax, ebx, 524
	add	eax, DWORD PTR [edi]

; 1253 :             _Orphan_range(_Newlast, _Mylast);
; 1254 :             _Destroy(_Newlast, _Mylast);
; 1255 :             _Mylast = _Newlast;
; 1256 :             return;

	jmp	SHORT $LN229@LoadBuffer
$LN31@LoadBuffer:

; 1257 :         }
; 1258 : 
; 1259 :         if (_Newsize > _Oldsize) { // append

	jbe	SHORT $LN32@LoadBuffer

; 1260 :             const auto _Oldcapacity = static_cast<size_type>(_My_data._Myend - _Myfirst);

	mov	ecx, DWORD PTR [edi+8]
	mov	eax, 1049152317				; 3e88cb3dH
	sub	ecx, DWORD PTR [edi]
	imul	ecx
	sar	edx, 7
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx

; 1261 :             if (_Newsize > _Oldcapacity) { // reallocate

	cmp	ebx, eax
	jbe	SHORT $LN33@LoadBuffer

; 1262 :                 _Resize_reallocate(_Newsize, _Val);

	lea	eax, DWORD PTR $T3[ebp]
	mov	ecx, edi
	push	eax
	push	ebx
	call	??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@V?$xalloc@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@@@std@@AAEXIABU_Value_init_tag@1@@Z ; std::vector<svector<_D3DVERTEXELEMENT9,65>,xalloc<svector<_D3DVERTEXELEMENT9,65> > >::_Resize_reallocate<std::_Value_init_tag>

; 1263 :                 return;

	jmp	SHORT $LN32@LoadBuffer
$LN33@LoadBuffer:

; 1264 :             }
; 1265 : 
; 1266 :             const pointer _Oldlast = _Mylast;
; 1267 :             _Mylast                = _Ufill(_Oldlast, _Newsize - _Oldsize, _Val);

	push	DWORD PTR $T3[ebp]
	mov	eax, ebx
	sub	eax, esi
	push	eax
	push	DWORD PTR [edi+4]
	call	?_Ufill@?$vector@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@V?$xalloc@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@@@std@@AAEPAV?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@PAV3@IU_Value_init_tag@2@@Z ; std::vector<svector<_D3DVERTEXELEMENT9,65>,xalloc<svector<_D3DVERTEXELEMENT9,65> > >::_Ufill
$LN229@LoadBuffer:
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender_Loader.cpp

; 188  : 		VB.resize				(count);

	mov	DWORD PTR [edi+4], eax
$LN32@LoadBuffer:
	mov	edi, DWORD PTR _this$1$[ebp]
	add	edi, 920				; 00000398H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1250 :         const auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);

	mov	eax, DWORD PTR [edi+4]
	mov	ecx, eax
	mov	edx, DWORD PTR [edi]
	sub	ecx, edx
	sar	ecx, 2
	mov	DWORD PTR __Oldlast$1$[ebp], eax

; 1251 :         if (_Newsize < _Oldsize) { // trim

	cmp	ebx, ecx
	jae	SHORT $LN38@LoadBuffer

; 1252 :             const pointer _Newlast = _Myfirst + _Newsize;

	lea	eax, DWORD PTR [edx+ebx*4]

; 1253 :             _Orphan_range(_Newlast, _Mylast);
; 1254 :             _Destroy(_Newlast, _Mylast);
; 1255 :             _Mylast = _Newlast;
; 1256 :             return;

	jmp	SHORT $LN230@LoadBuffer
$LN38@LoadBuffer:

; 1257 :         }
; 1258 : 
; 1259 :         if (_Newsize > _Oldsize) { // append

	jbe	SHORT $LN39@LoadBuffer

; 1260 :             const auto _Oldcapacity = static_cast<size_type>(_My_data._Myend - _Myfirst);

	mov	eax, DWORD PTR [edi+8]
	sub	eax, edx
	sar	eax, 2

; 1261 :             if (_Newsize > _Oldcapacity) { // reallocate

	cmp	ebx, eax
	jbe	SHORT $LN40@LoadBuffer

; 1262 :                 _Resize_reallocate(_Newsize, _Val);

	push	ecx
	push	ebx
	mov	ecx, edi
	call	??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@PAUIDirect3DVertexBuffer9@@V?$xalloc@PAUIDirect3DVertexBuffer9@@@@@std@@AAEXIABU_Value_init_tag@1@@Z ; std::vector<IDirect3DVertexBuffer9 *,xalloc<IDirect3DVertexBuffer9 *> >::_Resize_reallocate<std::_Value_init_tag>

; 1263 :                 return;

	jmp	SHORT $LN39@LoadBuffer
$LN40@LoadBuffer:

; 1264 :             }
; 1265 : 
; 1266 :             const pointer _Oldlast = _Mylast;
; 1267 :             _Mylast                = _Ufill(_Oldlast, _Newsize - _Oldsize, _Val);

	mov	eax, ebx
	sub	eax, ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1807 :             _Zero_range(_PFirst, _PFirst + _Count);

	lea	esi, DWORD PTR [eax*4]

; 1792 :     _CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

	push	esi
	push	0
	push	DWORD PTR __Oldlast$1$[ebp]
	call	_memset

; 1808 :             return _First + _Count;

	mov	eax, DWORD PTR __Oldlast$1$[ebp]

; 1792 :     _CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

	add	esp, 12					; 0000000cH

; 1808 :             return _First + _Count;

	add	eax, esi
$LN230@LoadBuffer:
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender_Loader.cpp

; 189  : 		for (u32 i=0; i<count; i++)

	mov	DWORD PTR [edi+4], eax
$LN39@LoadBuffer:
	mov	DWORD PTR _i$1$[ebp], 0
	test	ebx, ebx
	je	$LN3@LoadBuffer
	xor	esi, esi
	mov	DWORD PTR tv1416[ebp], esi
	npad	6
$LL4@LoadBuffer:

; 190  : 		{
; 191  : 			// decl
; 192  : 
; 193  : //			D3DVERTEXELEMENT9	*dcl = (D3DVERTEXELEMENT9*) fs->pointer();
; 194  : 			u32					buffer_size = (MAXD3DDECLLENGTH+1)*sizeof(D3DVERTEXELEMENT9);
; 195  : 			D3DVERTEXELEMENT9	*dcl = (D3DVERTEXELEMENT9*)_alloca(buffer_size);

	mov	eax, 520				; 00000208H
	call	__alloca_probe_16

; 196  : 			fs->r				(dcl,buffer_size);

	mov	ecx, DWORD PTR _fs$1$[ebp]
	mov	edi, esp
	push	520					; 00000208H
	push	edi
	call	DWORD PTR __imp_?r@CStreamReader@@QAEXPAXI@Z

; 197  : 			fs->advance			(-(int)buffer_size);

	mov	ecx, DWORD PTR _fs$1$[ebp]
	lea	eax, DWORD PTR $T5[ebp]
	push	eax
	mov	DWORD PTR $T5[ebp], -520		; fffffdf8H
	call	DWORD PTR __imp_?advance@CStreamReader@@QAEXABH@Z

; 198  : 
; 199  : 			u32 dcl_len			= D3DXGetDeclLength		(dcl)+1;

	push	edi
	call	DWORD PTR __imp__D3DXGetDeclLength@4

; 200  : 
; 201  : 			DCL[i].resize		(dcl_len);

	mov	edx, DWORD PTR _this$1$[ebp]
	inc	eax
	mov	ecx, DWORD PTR [edx+908]
	mov	DWORD PTR [ecx+esi+520], eax

; 202  : 			fs->r				(DCL[i].begin(),dcl_len*sizeof(D3DVERTEXELEMENT9));

	mov	ecx, DWORD PTR _fs$1$[ebp]
	shl	eax, 3
	push	eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 119  :         _Ptr += _Off;

	mov	eax, DWORD PTR [edx+908]
	add	eax, esi
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender_Loader.cpp

; 202  : 			fs->r				(DCL[i].begin(),dcl_len*sizeof(D3DVERTEXELEMENT9));

	push	eax
	call	DWORD PTR __imp_?r@CStreamReader@@QAEXPAXI@Z

; 203  : 			//.????????? remove T&B from DCL[]
; 204  : 
; 205  : 			// count, size
; 206  : 			u32 vCount			= fs->r_u32	();

	mov	ecx, DWORD PTR _fs$1$[ebp]
	call	DWORD PTR __imp_?r_u32@?$IReaderBase@VCStreamReader@@@@QAEIXZ

; 207  : 			u32 vSize			= D3DXGetDeclVertexSize	(dcl,0);

	push	0
	push	edi
	mov	esi, eax
	call	DWORD PTR __imp__D3DXGetDeclVertexSize@8

; 208  : 			Msg	("* [Loading VB] %d verts, %d Kb",vCount,(vCount*vSize)/1024);

	imul	eax, esi
	mov	ecx, eax
	mov	DWORD PTR tv1437[ebp], eax
	shr	ecx, 10					; 0000000aH
	push	ecx
	push	esi
	push	OFFSET ??_C@_0BP@KGJDKDMF@?$CK?5?$FLLoading?5VB?$FN?5?$CFd?5verts?0?5?$CFd?5Kb@
	call	DWORD PTR __imp_?Msg@@YAXPBDZZ

; 212  : 			R_CHK				(HW.pDevice->CreateVertexBuffer(vCount*vSize,dwUsage,0,D3DPOOL_MANAGED,&VB[i],0));

	mov	ecx, DWORD PTR __imp_?HW@@3VCHW@@A
	add	esp, 12					; 0000000cH
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 303  :         _Vector_iterator _Tmp = *this;

	mov	edi, DWORD PTR _this$1$[ebp]
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender_Loader.cpp

; 211  : 			BYTE*	pData		= 0;

	mov	DWORD PTR _pData$6[ebp], 0

; 212  : 			R_CHK				(HW.pDevice->CreateVertexBuffer(vCount*vSize,dwUsage,0,D3DPOOL_MANAGED,&VB[i],0));

	mov	edx, DWORD PTR [ecx+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 119  :         _Ptr += _Off;

	mov	ecx, DWORD PTR _i$1$[ebp]

; 303  :         _Vector_iterator _Tmp = *this;

	mov	eax, DWORD PTR [edi+920]
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender_Loader.cpp

; 212  : 			R_CHK				(HW.pDevice->CreateVertexBuffer(vCount*vSize,dwUsage,0,D3DPOOL_MANAGED,&VB[i],0));

	push	0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 119  :         _Ptr += _Off;

	lea	esi, DWORD PTR [ecx*4]
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender_Loader.cpp

; 212  : 			R_CHK				(HW.pDevice->CreateVertexBuffer(vCount*vSize,dwUsage,0,D3DPOOL_MANAGED,&VB[i],0));

	mov	ecx, DWORD PTR [edx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 119  :         _Ptr += _Off;

	add	eax, esi
	mov	DWORD PTR tv1430[ebp], esi
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender_Loader.cpp

; 212  : 			R_CHK				(HW.pDevice->CreateVertexBuffer(vCount*vSize,dwUsage,0,D3DPOOL_MANAGED,&VB[i],0));

	push	eax
	push	1
	push	0
	push	DWORD PTR _dwUsage$1$[ebp]
	push	DWORD PTR tv1437[ebp]
	push	edx
	call	DWORD PTR [ecx+104]
	cmp	BYTE PTR ?ignore_always@?8??LoadBuffers@CRender@@AAEXPAVCStreamReader@@@Z@4_NA, 0
	mov	esi, DWORD PTR __imp_?error@xrDebug@@QAEXJPBD0H0AA_N@Z
	jne	SHORT $LN5@LoadBuffer
	test	eax, eax
	jns	SHORT $LN5@LoadBuffer
	mov	ecx, DWORD PTR __imp_?Debug@@3VxrDebug@@A
	push	OFFSET ?ignore_always@?8??LoadBuffers@CRender@@AAEXPAVCStreamReader@@@Z@4_NA
	push	OFFSET ??_C@_0BF@KHLLPJCI@CRender?3?3LoadBuffers@
	push	212					; 000000d4H
	push	OFFSET ??_C@_0EJ@JMNAGDJL@I?3?2Vitalya?2mine?2NSProjectX?2laye@
	push	OFFSET ??_C@_0FA@HIPOJFBP@HW?4pDevice?9?$DOCreateVertexBuffer?$CI@
	push	eax
	call	esi
$LN5@LoadBuffer:

; 213  : 			R_CHK				(VB[i]->Lock(0,0,(void**)&pData,0));

	mov	eax, DWORD PTR [edi+920]
	lea	edx, DWORD PTR _pData$6[ebp]
	mov	ecx, DWORD PTR tv1430[ebp]
	push	0
	push	edx
	push	0
	mov	eax, DWORD PTR [ecx+eax]
	push	0
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+44]
	cmp	BYTE PTR ?ignore_always@?N@??LoadBuffers@CRender@@AAEXPAVCStreamReader@@@Z@4_NA, 0
	jne	SHORT $LN8@LoadBuffer
	test	eax, eax
	jns	SHORT $LN8@LoadBuffer
	mov	ecx, DWORD PTR __imp_?Debug@@3VxrDebug@@A
	push	OFFSET ?ignore_always@?N@??LoadBuffers@CRender@@AAEXPAVCStreamReader@@@Z@4_NA
	push	OFFSET ??_C@_0BF@KHLLPJCI@CRender?3?3LoadBuffers@
	push	213					; 000000d5H
	push	OFFSET ??_C@_0EJ@JMNAGDJL@I?3?2Vitalya?2mine?2NSProjectX?2laye@
	push	OFFSET ??_C@_0CC@CMHIHIBA@VB?$FLi?$FN?9?$DOLock?$CI0?00?0?$CIvoid?$CK?$CK?$CJ?$CGpData?0@
	push	eax
	call	esi
$LN8@LoadBuffer:

; 214  : 			fs->r				(pData,vCount*vSize);

	push	DWORD PTR tv1437[ebp]
	mov	ecx, DWORD PTR _fs$1$[ebp]
	push	DWORD PTR _pData$6[ebp]
	call	DWORD PTR __imp_?r@CStreamReader@@QAEXPAXI@Z

; 215  : //			CopyMemory			(pData,fs->pointer(),vCount*vSize);	//.???? copy while skip T&B
; 216  : 			VB[i]->Unlock		();

	mov	eax, DWORD PTR [edi+920]
	mov	ecx, DWORD PTR tv1430[ebp]
	mov	eax, DWORD PTR [ecx+eax]
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+48]
	mov	eax, DWORD PTR _i$1$[ebp]
	mov	esi, DWORD PTR tv1416[ebp]
	inc	eax
	add	esi, 524				; 0000020cH
	mov	DWORD PTR _i$1$[ebp], eax
	mov	DWORD PTR tv1416[ebp], esi
	cmp	eax, ebx
	jb	$LL4@LoadBuffer
$LN3@LoadBuffer:

; 217  : 
; 218  : //			fs->advance			(vCount*vSize);
; 219  : 		}
; 220  : 		fs->close				();

	mov	ecx, DWORD PTR _fs$1$[ebp]
	call	DWORD PTR __imp_?close@CStreamReader@@QAEXXZ

; 221  : 	} else {

	mov	ebx, DWORD PTR __imp_?error@xrDebug@@QAEXJPBD0H0AA_N@Z
	mov	esi, DWORD PTR _base_fs$[ebp]
	mov	edi, DWORD PTR _this$1$[ebp]
	jmp	SHORT $LN21@LoadBuffer
$LN20@LoadBuffer:

; 222  : 		FATAL					("DX7-style FVFs unsupported");

	push	OFFSET ??_C@_0BL@HKGNKNNH@DX7?9style?5FVFs?5unsupported@
	push	OFFSET ??_C@_0BF@KHLLPJCI@CRender?3?3LoadBuffers@
	push	222					; 000000deH
	push	OFFSET ??_C@_0EJ@JMNAGDJL@I?3?2Vitalya?2mine?2NSProjectX?2laye@
	push	DWORD PTR __imp_?Debug@@3VxrDebug@@A
	call	DWORD PTR __imp_?fatal@xrDebug@@QAAXPBDH00ZZ
	add	esp, 20					; 00000014H
$LN21@LoadBuffer:

; 223  : 	}
; 224  : 
; 225  : 	// Index buffers
; 226  : 	if (base_fs->find_chunk(fsL_IB))

	push	0
	push	10					; 0000000aH
	mov	ecx, esi
	call	DWORD PTR __imp_?find_chunk@?$IReaderBase@VCStreamReader@@@@QAEIIPAH@Z
	test	eax, eax
	je	$LN24@LoadBuffer

; 227  : 	{
; 228  : 		CStreamReader			*fs	= base_fs->open_chunk(fsL_IB);

	lea	eax, DWORD PTR $T1[ebp]
	mov	DWORD PTR $T1[ebp], 10			; 0000000aH
	push	eax
	mov	ecx, esi
	call	DWORD PTR __imp_?open_chunk@CStreamReader@@QAEPAV1@ABI@Z

; 229  : 		u32 count				= fs->r_u32();

	mov	ecx, eax
	mov	DWORD PTR _fs$1$[ebp], eax
	call	DWORD PTR __imp_?r_u32@?$IReaderBase@VCStreamReader@@@@QAEIXZ
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1250 :         const auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);

	mov	edx, DWORD PTR [edi+932]
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender_Loader.cpp

; 230  : 		IB.resize				(count);

	add	edi, 932				; 000003a4H
	mov	esi, eax
	mov	DWORD PTR _count$1$[ebp], esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1250 :         const auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);

	mov	eax, DWORD PTR [edi+4]
	mov	ecx, eax
	sub	ecx, edx
	mov	DWORD PTR __Oldlast$1$[ebp], eax
	sar	ecx, 2

; 1251 :         if (_Newsize < _Oldsize) { // trim

	cmp	esi, ecx
	jae	SHORT $LN147@LoadBuffer

; 1252 :             const pointer _Newlast = _Myfirst + _Newsize;

	lea	eax, DWORD PTR [edx+esi*4]

; 1253 :             _Orphan_range(_Newlast, _Mylast);
; 1254 :             _Destroy(_Newlast, _Mylast);
; 1255 :             _Mylast = _Newlast;
; 1256 :             return;

	jmp	SHORT $LN231@LoadBuffer
$LN147@LoadBuffer:

; 1257 :         }
; 1258 : 
; 1259 :         if (_Newsize > _Oldsize) { // append

	jbe	SHORT $LN148@LoadBuffer

; 1260 :             const auto _Oldcapacity = static_cast<size_type>(_My_data._Myend - _Myfirst);

	mov	eax, DWORD PTR [edi+8]
	sub	eax, edx
	sar	eax, 2

; 1261 :             if (_Newsize > _Oldcapacity) { // reallocate

	cmp	esi, eax
	jbe	SHORT $LN149@LoadBuffer

; 1262 :                 _Resize_reallocate(_Newsize, _Val);

	push	ecx
	push	esi
	mov	ecx, edi
	call	??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@PAUIDirect3DIndexBuffer9@@V?$xalloc@PAUIDirect3DIndexBuffer9@@@@@std@@AAEXIABU_Value_init_tag@1@@Z ; std::vector<IDirect3DIndexBuffer9 *,xalloc<IDirect3DIndexBuffer9 *> >::_Resize_reallocate<std::_Value_init_tag>

; 1263 :                 return;

	jmp	SHORT $LN148@LoadBuffer
$LN149@LoadBuffer:

; 1264 :             }
; 1265 : 
; 1266 :             const pointer _Oldlast = _Mylast;
; 1267 :             _Mylast                = _Ufill(_Oldlast, _Newsize - _Oldsize, _Val);

	mov	eax, esi
	sub	eax, ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1807 :             _Zero_range(_PFirst, _PFirst + _Count);

	lea	esi, DWORD PTR [eax*4]

; 1792 :     _CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

	push	esi
	push	0
	push	DWORD PTR __Oldlast$1$[ebp]
	call	_memset

; 1808 :             return _First + _Count;

	mov	eax, DWORD PTR __Oldlast$1$[ebp]

; 1792 :     _CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

	add	esp, 12					; 0000000cH

; 1808 :             return _First + _Count;

	add	eax, esi
$LN231@LoadBuffer:
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender_Loader.cpp

; 231  : 		for (u32 i=0; i<count; i++)

	mov	DWORD PTR [edi+4], eax
$LN148@LoadBuffer:
	xor	esi, esi
	cmp	DWORD PTR _count$1$[ebp], esi
	jbe	$LN12@LoadBuffer
	npad	5
$LL13@LoadBuffer:

; 232  : 		{
; 233  : 			u32 iCount		= fs->r_u32	();

	mov	ecx, DWORD PTR _fs$1$[ebp]
	call	DWORD PTR __imp_?r_u32@?$IReaderBase@VCStreamReader@@@@QAEIXZ

; 234  : 			Msg("* [Loading IB] %d indices, %d Kb",iCount,(iCount*2)/1024);

	lea	ecx, DWORD PTR [eax+eax]
	mov	DWORD PTR tv1438[ebp], ecx
	shr	ecx, 10					; 0000000aH
	push	ecx
	push	eax
	push	OFFSET ??_C@_0CB@HEHANKGG@?$CK?5?$FLLoading?5IB?$FN?5?$CFd?5indices?0?5?$CFd?5K@
	call	DWORD PTR __imp_?Msg@@YAXPBDZZ
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	eax, DWORD PTR [edi]
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender_Loader.cpp

; 234  : 			Msg("* [Loading IB] %d indices, %d Kb",iCount,(iCount*2)/1024);

	add	esp, 12					; 0000000cH

; 238  : 			R_CHK				(HW.pDevice->CreateIndexBuffer(iCount*2,dwUsage,D3DFMT_INDEX16,D3DPOOL_MANAGED,&IB[i],0));

	mov	ecx, DWORD PTR __imp_?HW@@3VCHW@@A
	mov	DWORD PTR _pData$4[ebp], 0
	push	0
	mov	edx, DWORD PTR [ecx+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 119  :         _Ptr += _Off;

	lea	eax, DWORD PTR [eax+esi*4]
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender_Loader.cpp

; 238  : 			R_CHK				(HW.pDevice->CreateIndexBuffer(iCount*2,dwUsage,D3DFMT_INDEX16,D3DPOOL_MANAGED,&IB[i],0));

	push	eax
	push	1
	push	101					; 00000065H
	push	DWORD PTR _dwUsage$1$[ebp]
	mov	ecx, DWORD PTR [edx]
	push	DWORD PTR tv1438[ebp]
	push	edx
	call	DWORD PTR [ecx+108]
	cmp	BYTE PTR ?ignore_always@?BI@??LoadBuffers@CRender@@AAEXPAVCStreamReader@@@Z@4_NA, 0
	jne	SHORT $LN14@LoadBuffer
	test	eax, eax
	jns	SHORT $LN14@LoadBuffer
	mov	ecx, DWORD PTR __imp_?Debug@@3VxrDebug@@A
	push	OFFSET ?ignore_always@?BI@??LoadBuffers@CRender@@AAEXPAVCStreamReader@@@Z@4_NA
	push	OFFSET ??_C@_0BF@KHLLPJCI@CRender?3?3LoadBuffers@
	push	238					; 000000eeH
	push	OFFSET ??_C@_0EJ@JMNAGDJL@I?3?2Vitalya?2mine?2NSProjectX?2laye@
	push	OFFSET ??_C@_0FI@FNGBGCHL@HW?4pDevice?9?$DOCreateIndexBuffer?$CIi@
	push	eax
	call	ebx
$LN14@LoadBuffer:

; 239  : 			R_CHK				(IB[i]->Lock(0,0,(void**)&pData,0));

	mov	eax, DWORD PTR [edi]
	lea	edx, DWORD PTR _pData$4[ebp]
	push	0
	push	edx
	push	0
	mov	eax, DWORD PTR [eax+esi*4]
	push	0
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+44]
	cmp	BYTE PTR ?ignore_always@?BM@??LoadBuffers@CRender@@AAEXPAVCStreamReader@@@Z@4_NA, 0
	jne	SHORT $LN17@LoadBuffer
	test	eax, eax
	jns	SHORT $LN17@LoadBuffer
	mov	ecx, DWORD PTR __imp_?Debug@@3VxrDebug@@A
	push	OFFSET ?ignore_always@?BM@??LoadBuffers@CRender@@AAEXPAVCStreamReader@@@Z@4_NA
	push	OFFSET ??_C@_0BF@KHLLPJCI@CRender?3?3LoadBuffers@
	push	239					; 000000efH
	push	OFFSET ??_C@_0EJ@JMNAGDJL@I?3?2Vitalya?2mine?2NSProjectX?2laye@
	push	OFFSET ??_C@_0CC@JCCFJMA@IB?$FLi?$FN?9?$DOLock?$CI0?00?0?$CIvoid?$CK?$CK?$CJ?$CGpData?0@
	push	eax
	call	ebx
$LN17@LoadBuffer:

; 240  : //			CopyMemory			(pData,fs->pointer(),iCount*2);
; 241  : 			fs->r				(pData,iCount*2);

	push	DWORD PTR tv1438[ebp]
	mov	ecx, DWORD PTR _fs$1$[ebp]
	push	DWORD PTR _pData$4[ebp]
	call	DWORD PTR __imp_?r@CStreamReader@@QAEXPAXI@Z

; 242  : 			IB[i]->Unlock		();

	mov	eax, DWORD PTR [edi]
	mov	eax, DWORD PTR [eax+esi*4]
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+48]
	inc	esi
	cmp	esi, DWORD PTR _count$1$[ebp]
	jb	$LL13@LoadBuffer
$LN12@LoadBuffer:

; 243  : 
; 244  : //			fs->advance			(iCount*2);
; 245  : 		}
; 246  : 		fs->close				();

	mov	ecx, DWORD PTR _fs$1$[ebp]
	call	DWORD PTR __imp_?close@CStreamReader@@QAEXXZ
$LN24@LoadBuffer:

; 247  : 	}
; 248  : }

	lea	esp, DWORD PTR [ebp-48]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?LoadBuffers@CRender@@AAEXPAVCStreamReader@@@Z ENDP	; CRender::LoadBuffers
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender_Loader.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender_Loader.cpp
_TEXT	SEGMENT
_V$ = -48						; size = 4
_H$ = -44						; size = 44
_fs$ = 8						; size = 4
?LoadVisuals@CRender@@AAEXPAVIReader@@@Z PROC		; CRender::LoadVisuals
; _this$ = ecx

; 251  : {

	sub	esp, 48					; 00000030H
	push	ebp
	push	esi
	push	edi
	mov	esi, ecx

; 252  : 	IReader*		chunk	= 0;
; 253  : 	u32				index	= 0;

	xor	ebp, ebp

; 254  : 	IRender_Visual*	V		= 0;
; 255  : 	ogf_header		H;
; 256  : 
; 257  : 	while ((chunk=fs->open_chunk(index))!=0)

	mov	ecx, DWORD PTR _fs$[esp+56]
	push	ebp
	call	DWORD PTR __imp_?open_chunk@IReader@@QAEPAV1@I@Z
	mov	edi, eax
	test	edi, edi
	je	SHORT $LN3@LoadVisual
	push	ebx
	npad	4
$LL2@LoadVisual:

; 258  : 	{
; 259  : 		chunk->r_chunk_safe			(OGF_HEADER,&H,sizeof(H));

	push	44					; 0000002cH
	lea	eax, DWORD PTR _H$[esp+68]
	mov	ecx, edi
	push	eax
	push	1
	call	DWORD PTR __imp_?r_chunk_safe@?$IReaderBase@VIReader@@@@QAEHIPAXI@Z

; 260  : 		V = Models->Instance_Create	(H.type);

	movzx	eax, BYTE PTR _H$[esp+65]
	push	eax
	call	?Instance_Create@CModelPool@@QAEPAVIRender_Visual@@I@Z ; CModelPool::Instance_Create
	mov	ebx, eax

; 261  : 		V->Load						(0,chunk,0);

	push	0
	push	edi
	push	0
	mov	edx, DWORD PTR [ebx]
	mov	ecx, ebx
	mov	DWORD PTR _V$[esp+76], ebx
	call	DWORD PTR [edx+4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 730  :         if (_Mylast != _My_data._Myend) {

	mov	ecx, DWORD PTR [esi+948]
	cmp	ecx, DWORD PTR [esi+952]
	je	SHORT $LN8@LoadVisual

; 713  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

	mov	DWORD PTR [ecx], ebx

; 714  :         _Orphan_range(_Mylast, _Mylast);
; 715  :         _Ty& _Result = *_Mylast;
; 716  :         ++_Mylast;

	add	DWORD PTR [esi+948], 4

; 731  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

	jmp	SHORT $LN7@LoadVisual
$LN8@LoadVisual:

; 732  :         }
; 733  : 
; 734  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	lea	eax, DWORD PTR _V$[esp+64]
	push	eax
	push	ecx
	lea	ecx, DWORD PTR [esi+944]
	call	??$_Emplace_reallocate@ABQAVIRender_Visual@@@?$vector@PAVIRender_Visual@@V?$xalloc@PAVIRender_Visual@@@@@std@@QAEPAPAVIRender_Visual@@QAPAV2@ABQAV2@@Z ; std::vector<IRender_Visual *,xalloc<IRender_Visual *> >::_Emplace_reallocate<IRender_Visual * const &>
$LN7@LoadVisual:
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender_Loader.cpp

; 264  : 		chunk->close();

	mov	ecx, edi
	call	DWORD PTR __imp_?close@IReader@@QAEXXZ
	mov	ecx, DWORD PTR _fs$[esp+60]

; 265  : 		index++;

	inc	ebp
	push	ebp
	call	DWORD PTR __imp_?open_chunk@IReader@@QAEPAV1@I@Z
	mov	edi, eax
	test	edi, edi
	jne	SHORT $LL2@LoadVisual
	pop	ebx
$LN3@LoadVisual:
	pop	edi

; 266  : 	}
; 267  : }

	pop	esi
	pop	ebp
	add	esp, 48					; 00000030H
	ret	4
?LoadVisuals@CRender@@AAEXPAVIReader@@@Z ENDP		; CRender::LoadVisuals
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender_Loader.cpp
_TEXT	SEGMENT
_fs$ = 8						; size = 4
?LoadLights@CRender@@AAEXPAVIReader@@@Z PROC		; CRender::LoadLights
; _this$ = ecx

; 270  : {

	push	esi

; 271  : 	// lights
; 272  : 	L_DB->Load		(fs);

	mov	esi, DWORD PTR _fs$[esp]
	push	edi
	mov	edi, ecx
	push	esi
	mov	ecx, DWORD PTR [edi+980]
	call	?Load@CLight_DB@@QAEXPAVIReader@@@Z	; CLight_DB::Load

; 273  : 
; 274  : 	// glows
; 275  : 	IReader			*chunk = fs->open_chunk(fsL_GLOWS);

	push	7
	mov	ecx, esi
	call	DWORD PTR __imp_?open_chunk@IReader@@QAEPAV1@I@Z

; 276  : 	R_ASSERT		(chunk && "Can't find glows");

	cmp	BYTE PTR ?ignore_always@?3??LoadLights@CRender@@AAEXPAVIReader@@@Z@4_NA, 0
	mov	esi, eax
	jne	SHORT $LN2@LoadLights
	test	esi, esi
	jne	SHORT $LN2@LoadLights
	mov	ecx, DWORD PTR __imp_?Debug@@3VxrDebug@@A
	push	OFFSET ?ignore_always@?3??LoadLights@CRender@@AAEXPAVIReader@@@Z@4_NA
	push	OFFSET ??_C@_0BE@OILIHGFK@CRender?3?3LoadLights@
	push	276					; 00000114H
	push	OFFSET ??_C@_0EJ@JMNAGDJL@I?3?2Vitalya?2mine?2NSProjectX?2laye@
	push	OFFSET ??_C@_0BM@BIODNPP@chunk?5?$CG?$CG?5?$CCCan?8t?5find?5glows?$CC@
	call	DWORD PTR __imp_?fail@xrDebug@@QAEXPBD0H0AA_N@Z
$LN2@LoadLights:

; 277  : 	L_Glows->Load	(chunk);

	mov	ecx, DWORD PTR [edi+996]
	push	esi
	call	?Load@CGlowManager@@QAEXPAVIReader@@@Z	; CGlowManager::Load

; 278  : 	chunk->close	();

	mov	ecx, esi
	call	DWORD PTR __imp_?close@IReader@@QAEXXZ
	pop	edi
	pop	esi

; 279  : }

	ret	4
?LoadLights@CRender@@AAEXPAVIReader@@@Z ENDP		; CRender::LoadLights
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender_Loader.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender_Loader.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender_Loader.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender_Loader.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender_Loader.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__sector.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\FixedVector.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender_Loader.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__sector.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__sector.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__sector.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__sector.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__sector.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__sector.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__sector.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__sector.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__sector.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__sector.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender_Loader.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender_Loader.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender_Loader.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\FixedVector.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender_Loader.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\FixedVector.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender_Loader.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender_Loader.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender_Loader.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender_Loader.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender_Loader.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender_Loader.cpp
_TEXT	SEGMENT
_this$1$ = -180						; size = 4
tv1331 = -180						; size = 4
_this$1$ = -176						; size = 4
$T1 = -172						; size = 4
$T2 = -172						; size = 4
tv1337 = -168						; size = 4
_i$1$ = -164						; size = 4
tv1335 = -160						; size = 4
_S$1$ = -156						; size = 4
_count$1$ = -152					; size = 4
_P$3 = -148						; size = 4
tv1336 = -144						; size = 4
_CL$4 = -140						; size = 24
_v3$5 = -116						; size = 12
_v2$6 = -104						; size = 12
_v1$7 = -92						; size = 12
_P$8 = -80						; size = 80
_fs$ = 8						; size = 4
?LoadSectors@CRender@@AAEXPAVIReader@@@Z PROC		; CRender::LoadSectors
; _this$ = ecx

; 289  : {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	sub	esp, 180				; 000000b4H
	push	ebx
	push	esi
	push	edi
	mov	edi, ecx

; 290  : 	// allocate memory for portals
; 291  : 	u32 size = fs->find_chunk(fsL_PORTALS); 

	mov	ecx, DWORD PTR _fs$[ebp]
	push	0
	push	4
	mov	DWORD PTR _this$1$[esp+200], edi
	call	DWORD PTR __imp_?find_chunk@?$IReaderBase@VIReader@@@@QAEIIPAH@Z

; 292  : 	R_ASSERT(0==size%sizeof(b_portal));

	cmp	BYTE PTR ?ignore_always@?3??LoadSectors@CRender@@AAEXPAVIReader@@@Z@4_NA, 0
	mov	esi, eax
	mov	ebx, DWORD PTR __imp_?fail@xrDebug@@QAEXPBD0H0AA_N@Z
	mov	DWORD PTR tv1337[esp+192], ebx
	jne	SHORT $LN2@LoadSector
	mov	eax, -858993459				; cccccccdH
	mul	esi
	mov	eax, esi
	shr	edx, 6
	lea	ecx, DWORD PTR [edx+edx*4]
	shl	ecx, 4
	sub	eax, ecx
	je	SHORT $LN2@LoadSector
	mov	ecx, DWORD PTR __imp_?Debug@@3VxrDebug@@A
	push	OFFSET ?ignore_always@?3??LoadSectors@CRender@@AAEXPAVIReader@@@Z@4_NA
	push	OFFSET ??_C@_0BF@FFCEOBGG@CRender?3?3LoadSectors@
	push	292					; 00000124H
	push	OFFSET ??_C@_0EJ@JMNAGDJL@I?3?2Vitalya?2mine?2NSProjectX?2laye@
	push	OFFSET ??_C@_0BJ@KPNNAFFO@0?$DN?$DNsize?$CFsizeof?$CIb_portal?$CJ@
	call	ebx
$LN2@LoadSector:

; 293  : 	u32 count = size/sizeof(b_portal);

	mov	eax, -858993459				; cccccccdH
	mul	esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1250 :         const auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);

	mov	esi, DWORD PTR [edi+660]
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender_Loader.cpp

; 293  : 	u32 count = size/sizeof(b_portal);

	mov	ebx, edx

; 294  : 	Portals.resize	(count);

	lea	edx, DWORD PTR [edi+660]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1250 :         const auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);

	mov	edi, DWORD PTR [edx+4]
	mov	ecx, edi
	sub	ecx, esi
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender_Loader.cpp

; 293  : 	u32 count = size/sizeof(b_portal);

	shr	ebx, 6
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1250 :         const auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);

	sar	ecx, 2
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender_Loader.cpp

; 293  : 	u32 count = size/sizeof(b_portal);

	mov	DWORD PTR _count$1$[esp+192], ebx

; 294  : 	Portals.resize	(count);

	mov	DWORD PTR _this$1$[esp+192], edx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1251 :         if (_Newsize < _Oldsize) { // trim

	cmp	ebx, ecx
	jae	$LN26@LoadSector

; 1252 :             const pointer _Newlast = _Myfirst + _Newsize;

	lea	eax, DWORD PTR [esi+ebx*4]

; 1253 :             _Orphan_range(_Newlast, _Mylast);
; 1254 :             _Destroy(_Newlast, _Mylast);
; 1255 :             _Mylast = _Newlast;

	mov	DWORD PTR [edx+4], eax
$LN250@LoadSector:
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender_Loader.cpp

; 295  : 	for (u32 c=0; c<count; c++)

	mov	edi, edx
$LN27@LoadSector:
	mov	eax, DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
	xor	esi, esi
	mov	DWORD PTR tv1331[esp+192], eax
	test	ebx, ebx
	je	SHORT $LN6@LoadSector
	npad	9
$LL7@LoadSector:
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h

; 68   : 	T* ptr	= (T*)Memory.mem_alloc(sizeof(T));

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	152					; 00000098H
	call	eax
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__sector.cpp

; 16   : {

	mov	DWORD PTR [eax], OFFSET ??_7CPortal@@6B@
; File I:\Vitalya\mine\NSProjectX\xrCore\FixedVector.h

; 21   : 	svector() : count(0) 

	mov	DWORD PTR [eax+100], 0
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender_Loader.cpp

; 296  : 		Portals[c]	= xr_new<CPortal> ();

	mov	ecx, DWORD PTR [edi]
	mov	DWORD PTR [ecx+esi*4], eax
	inc	esi
	mov	eax, DWORD PTR tv1331[esp+192]
	cmp	esi, ebx
	jb	SHORT $LL7@LoadSector
$LN6@LoadSector:

; 297  : 
; 298  : 	// load sectors
; 299  : 	IReader* S = fs->open_chunk(fsL_SECTORS);

	mov	ebx, DWORD PTR __imp_?open_chunk@IReader@@QAEPAV1@I@Z
	mov	ecx, DWORD PTR _fs$[ebp]
	push	8
	mov	DWORD PTR tv1336[esp+196], ebx
	call	ebx

; 300  : 	for (u32 i=0; ; i++)
; 301  : 	{
; 302  : 		IReader* P = S->open_chunk(i);

	push	0
	mov	ecx, eax
	mov	DWORD PTR _S$1$[esp+196], eax
	mov	DWORD PTR _i$1$[esp+196], 0
	call	ebx
	mov	ebx, eax

; 303  : 		if (0==P) break;

	mov	eax, DWORD PTR __imp_?close@IReader@@QAEXXZ
	mov	DWORD PTR tv1335[esp+192], eax
	test	ebx, ebx
	je	$LN249@LoadSector
	npad	2
$LL10@LoadSector:
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h

; 68   : 	T* ptr	= (T*)Memory.mem_alloc(sizeof(T));

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	68					; 00000044H
	call	DWORD PTR tv1331[esp+196]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__sector.cpp

; 244  : 	u32 size			= fs.find_chunk(fsP_Portals); R_ASSERT(0==(size&1));

	push	0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [eax+8], 0
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__sector.cpp

; 244  : 	u32 size			= fs.find_chunk(fsP_Portals); R_ASSERT(0==(size&1));

	mov	ecx, ebx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [eax+12], 0
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__sector.h

; 67   : 	CSector							()				{ m_root = NULL;	}

	lea	esi, DWORD PTR [eax+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [eax+20], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [eax+24], 0
	mov	DWORD PTR [eax+28], 0
	mov	DWORD PTR [eax+32], 0
	mov	DWORD PTR [eax+36], 0
	mov	DWORD PTR [eax+40], 0
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__sector.cpp

; 244  : 	u32 size			= fs.find_chunk(fsP_Portals); R_ASSERT(0==(size&1));

	push	1
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h

; 69   : 	return new (ptr) T();

	mov	DWORD PTR $T1[esp+200], eax
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__sector.h

; 67   : 	CSector							()				{ m_root = NULL;	}

	mov	DWORD PTR [eax], OFFSET ??_7CSector@@6B@
	mov	DWORD PTR [eax+4], 0
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__sector.cpp

; 244  : 	u32 size			= fs.find_chunk(fsP_Portals); R_ASSERT(0==(size&1));

	call	DWORD PTR __imp_?find_chunk@?$IReaderBase@VIReader@@@@QAEIIPAH@Z
	cmp	BYTE PTR ?ignore_always@?3??load@CSector@@QAEXAAVIReader@@@Z@4_NA, 0
	mov	edi, eax
	jne	SHORT $LN103@LoadSector
	test	edi, 1
	je	SHORT $LN103@LoadSector
	mov	ecx, DWORD PTR __imp_?Debug@@3VxrDebug@@A
	push	OFFSET ?ignore_always@?3??load@CSector@@QAEXAAVIReader@@@Z@4_NA
	push	OFFSET ??_C@_0O@JCOHLFIM@CSector?3?3load@
	push	244					; 000000f4H
	push	OFFSET ??_C@_0DJ@FDLNFKJF@I?3?2Vitalya?2mine?2NSProjectX?2laye@
	push	OFFSET ??_C@_0M@PEPFIJMN@0?$DN?$DN?$CIsize?$CG1?$CJ@
	call	DWORD PTR tv1337[esp+212]
$LN103@LoadSector:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1546 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	eax, DWORD PTR [esi+8]
	sub	eax, DWORD PTR [esi]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__sector.cpp

; 245  : 	u32 count			= size/2;

	shr	edi, 1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1546 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	sar	eax, 2

; 1358 :         if (_Newcapacity > capacity()) { // something to do (reserve() never shrinks)

	cmp	edi, eax
	jbe	SHORT $LN231@LoadSector

; 1359 :             if (_Newcapacity > max_size()) {

	cmp	edi, 1073741823				; 3fffffffH
	ja	$LN233@LoadSector

; 1361 :             }
; 1362 : 
; 1363 :             _Reallocate_exactly(_Newcapacity);

	push	edi
	mov	ecx, esi
	call	?_Reallocate_exactly@?$vector@PAVCPortal@@V?$xalloc@PAVCPortal@@@@@std@@AAEXI@Z ; std::vector<CPortal *,xalloc<CPortal *> >::_Reallocate_exactly
$LN231@LoadSector:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__sector.cpp

; 247  : 	while (count) {

	test	edi, edi
	je	$LN107@LoadSector
	npad	5
$LL106@LoadSector:

; 248  : 		u16 ID		= fs.r_u16();

	mov	ecx, ebx
	call	DWORD PTR __imp_?r_u16@?$IReaderBase@VIReader@@@@QAEGXZ
	movzx	ecx, ax

; 249  : 		CPortal* P	= (CPortal*)RImplementation.getPortal	(ID);

	mov	eax, DWORD PTR ?RImplementation@@3VCRender@@A+660
	mov	ecx, DWORD PTR [eax+ecx*4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 730  :         if (_Mylast != _My_data._Myend) {

	mov	eax, DWORD PTR [esi+4]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__sector.cpp

; 249  : 		CPortal* P	= (CPortal*)RImplementation.getPortal	(ID);

	mov	DWORD PTR _P$3[esp+192], ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 730  :         if (_Mylast != _My_data._Myend) {

	cmp	eax, DWORD PTR [esi+8]
	je	SHORT $LN148@LoadSector

; 713  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

	mov	DWORD PTR [eax], ecx

; 714  :         _Orphan_range(_Mylast, _Mylast);
; 715  :         _Ty& _Result = *_Mylast;
; 716  :         ++_Mylast;

	add	DWORD PTR [esi+4], 4

; 731  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

	jmp	SHORT $LN147@LoadSector
$LN26@LoadSector:

; 1259 :         if (_Newsize > _Oldsize) { // append

	jbe	$LN250@LoadSector

; 1260 :             const auto _Oldcapacity = static_cast<size_type>(_My_data._Myend - _Myfirst);

	mov	eax, DWORD PTR [edx+8]
	sub	eax, esi
	sar	eax, 2

; 1261 :             if (_Newsize > _Oldcapacity) { // reallocate

	cmp	ebx, eax
	jbe	SHORT $LN28@LoadSector

; 1262 :                 _Resize_reallocate(_Newsize, _Val);

	push	ecx
	push	ebx
	mov	ecx, edx
	call	??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@PAVIRender_Portal@@V?$xalloc@PAVIRender_Portal@@@@@std@@AAEXIABU_Value_init_tag@1@@Z ; std::vector<IRender_Portal *,xalloc<IRender_Portal *> >::_Resize_reallocate<std::_Value_init_tag>

; 1263 :                 return;

	mov	edi, DWORD PTR _this$1$[esp+192]
	jmp	$LN27@LoadSector
$LN28@LoadSector:

; 1267 :             _Mylast                = _Ufill(_Oldlast, _Newsize - _Oldsize, _Val);

	mov	eax, ebx
	sub	eax, ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1807 :             _Zero_range(_PFirst, _PFirst + _Count);

	lea	esi, DWORD PTR [eax*4]

; 1792 :     _CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

	push	esi
	push	0
	push	edi
	call	_memset

; 1808 :             return _First + _Count;

	lea	eax, DWORD PTR [esi+edi]

; 1792 :     _CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

	add	esp, 12					; 0000000cH
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1267 :             _Mylast                = _Ufill(_Oldlast, _Newsize - _Oldsize, _Val);

	mov	edi, DWORD PTR _this$1$[esp+192]
	mov	DWORD PTR [edi+4], eax
	jmp	$LN27@LoadSector
$LN148@LoadSector:

; 734  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	lea	ecx, DWORD PTR _P$3[esp+192]
	push	ecx
	push	eax
	mov	ecx, esi
	call	??$_Emplace_reallocate@ABQAVCPortal@@@?$vector@PAVCPortal@@V?$xalloc@PAVCPortal@@@@@std@@QAEPAPAVCPortal@@QAPAV2@ABQAV2@@Z ; std::vector<CPortal *,xalloc<CPortal *> >::_Emplace_reallocate<CPortal * const &>
$LN147@LoadSector:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__sector.cpp

; 251  : 		count--;

	sub	edi, 1
	jne	$LL106@LoadSector
$LN107@LoadSector:

; 252  : 	}
; 253  : 
; 254  : 	if	(g_dedicated_server)	m_root	= 0;

	mov	eax, DWORD PTR __imp_?g_dedicated_server@@3_NA
	cmp	BYTE PTR [eax], 0
	je	SHORT $LN112@LoadSector
	xor	eax, eax
	jmp	SHORT $LN113@LoadSector
$LN112@LoadSector:

; 255  : 	else {
; 256  : 		// Assign visual
; 257  : 		size	= fs.find_chunk(fsP_Root);	R_ASSERT(size==4);

	push	0
	push	2
	mov	ecx, ebx
	call	DWORD PTR __imp_?find_chunk@?$IReaderBase@VIReader@@@@QAEIIPAH@Z
	cmp	BYTE PTR ?ignore_always@?O@??load@CSector@@QAEXAAVIReader@@@Z@4_NA, 0
	jne	SHORT $LN108@LoadSector
	cmp	eax, 4
	je	SHORT $LN108@LoadSector
	mov	ecx, DWORD PTR __imp_?Debug@@3VxrDebug@@A
	push	OFFSET ?ignore_always@?O@??load@CSector@@QAEXAAVIReader@@@Z@4_NA
	push	OFFSET ??_C@_0O@JCOHLFIM@CSector?3?3load@
	push	257					; 00000101H
	push	OFFSET ??_C@_0DJ@FDLNFKJF@I?3?2Vitalya?2mine?2NSProjectX?2laye@
	push	OFFSET ??_C@_07MIJPMMAB@size?$DN?$DN4@
	call	DWORD PTR tv1337[esp+212]
$LN108@LoadSector:

; 258  : 		m_root	= RImplementation.getVisual	(fs.r_u32());

	mov	ecx, ebx
	call	DWORD PTR __imp_?r_u32@?$IReaderBase@VIReader@@@@QAEIXZ
	mov	ecx, DWORD PTR ?RImplementation@@3VCRender@@A+944
	mov	eax, DWORD PTR [ecx+eax*4]
$LN113@LoadSector:
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender_Loader.cpp

; 307  : 		Sectors.push_back	(__S);

	mov	edx, DWORD PTR $T1[esp+192]
	mov	edi, DWORD PTR _this$1$[esp+192]
	lea	ecx, DWORD PTR [edi+672]
	mov	DWORD PTR [edx+4], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 730  :         if (_Mylast != _My_data._Myend) {

	mov	eax, DWORD PTR [ecx+4]
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender_Loader.cpp

; 307  : 		Sectors.push_back	(__S);

	mov	DWORD PTR $T2[esp+192], edx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 730  :         if (_Mylast != _My_data._Myend) {

	cmp	eax, DWORD PTR [ecx+8]
	je	SHORT $LN178@LoadSector

; 713  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

	mov	DWORD PTR [eax], edx

; 714  :         _Orphan_range(_Mylast, _Mylast);
; 715  :         _Ty& _Result = *_Mylast;
; 716  :         ++_Mylast;

	add	DWORD PTR [ecx+4], 4

; 731  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

	jmp	SHORT $LN177@LoadSector
$LN178@LoadSector:

; 732  :         }
; 733  : 
; 734  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	lea	edx, DWORD PTR $T2[esp+192]
	push	edx
	push	eax
	call	??$_Emplace_reallocate@PAVIRender_Sector@@@?$vector@PAVIRender_Sector@@V?$xalloc@PAVIRender_Sector@@@@@std@@QAEPAPAVIRender_Sector@@QAPAV2@$$QAPAV2@@Z ; std::vector<IRender_Sector *,xalloc<IRender_Sector *> >::_Emplace_reallocate<IRender_Sector *>
$LN177@LoadSector:
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender_Loader.cpp

; 309  : 		P->close();

	mov	ecx, ebx
	call	DWORD PTR tv1335[esp+192]
	mov	eax, DWORD PTR _i$1$[esp+192]
	mov	ecx, DWORD PTR _S$1$[esp+192]
	inc	eax
	push	eax
	mov	DWORD PTR _i$1$[esp+196], eax
	call	DWORD PTR tv1336[esp+196]
	mov	ebx, eax
	test	ebx, ebx
	jne	$LL10@LoadSector

; 303  : 		if (0==P) break;

	mov	eax, DWORD PTR tv1335[esp+192]
$LN232@LoadSector:

; 310  : 	}
; 311  : 	S->close();

	mov	ecx, DWORD PTR _S$1$[esp+192]
	call	eax

; 312  : 
; 313  : 	// load portals
; 314  : 	if (count) 

	mov	esi, DWORD PTR _count$1$[esp+192]
	test	esi, esi
	je	$LN19@LoadSector

; 315  : 	{
; 316  : 		u32	i;
; 317  : 		CDB::Collector	CL;

	lea	ecx, DWORD PTR _CL$4[esp+192]
	call	DWORD PTR __imp_??0Collector@CDB@@QAE@XZ

; 318  : 		fs->find_chunk	(fsL_PORTALS);

	mov	ecx, DWORD PTR _fs$[ebp]
	push	0
	push	4
	call	DWORD PTR __imp_?find_chunk@?$IReaderBase@VIReader@@@@QAEIIPAH@Z
	xor	ebx, ebx

; 319  : 		for (i=0; i<count; i++)

	test	esi, esi
	je	$LN12@LoadSector
	npad	4
$LL13@LoadSector:

; 322  : 			fs->r		(&P,sizeof(P));

	mov	ecx, DWORD PTR _fs$[ebp]
	lea	eax, DWORD PTR _P$8[esp+192]
	push	80					; 00000050H
	push	eax
; File I:\Vitalya\mine\NSProjectX\xrCore\FixedVector.h

; 21   : 	svector() : count(0) 

	mov	DWORD PTR _P$8[esp+276], 0
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender_Loader.cpp

; 322  : 			fs->r		(&P,sizeof(P));

	call	DWORD PTR __imp_?r@IReader@@QAEXPAXH@Z

; 323  : 			CPortal*	__P	= (CPortal*)Portals[i];

	mov	eax, DWORD PTR [edi+660]

; 324  : 			__P->Setup	(P.vertices.begin(),P.vertices.size(),

	mov	ecx, edi
	mov	edx, DWORD PTR [edi]
	mov	esi, DWORD PTR [eax+ebx*4]
	movzx	eax, WORD PTR _P$8[esp+194]
	push	eax
	call	DWORD PTR [edx+48]
	mov	edx, DWORD PTR [edi]
	mov	ecx, edi
	push	eax
	movzx	eax, WORD PTR _P$8[esp+196]
	push	eax
	call	DWORD PTR [edx+48]
	push	eax
	push	DWORD PTR _P$8[esp+276]
	lea	eax, DWORD PTR _P$8[esp+208]
	mov	ecx, esi
	push	eax
	call	?Setup@CPortal@@QAEXPAU?$_vector3@M@@HPAVCSector@@1@Z ; CPortal::Setup

; 325  : 				(CSector*)getSector(P.sector_front),
; 326  : 				(CSector*)getSector(P.sector_back));
; 327  : 			for (u32 j=2; j<P.vertices.size(); j++)

	mov	edi, 2
	cmp	DWORD PTR _P$8[esp+268], edi
	jbe	SHORT $LN11@LoadSector
; File I:\Vitalya\mine\NSProjectX\xrCore\FixedVector.h

; 21   : 	svector() : count(0) 

	lea	esi, DWORD PTR _P$8[esp+220]
	npad	5
$LL16@LoadSector:
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender_Loader.cpp

; 328  : 				CL.add_face_packed_D	( P.vertices[0],P.vertices[j-1],P.vertices[j], u32(i) );

	fld	DWORD PTR __real@3727c5ac
	lea	eax, DWORD PTR [esi-12]
	push	ecx
	fstp	DWORD PTR [esp]
	push	ebx
	push	esi
	push	eax
	lea	eax, DWORD PTR _P$8[esp+212]
	push	eax
	lea	ecx, DWORD PTR _CL$4[esp+212]
	call	DWORD PTR __imp_?add_face_packed_D@Collector@CDB@@QAEXABU?$_vector3@M@@00IM@Z
	inc	edi
	add	esi, 12					; 0000000cH
	cmp	edi, DWORD PTR _P$8[esp+268]
	jb	SHORT $LL16@LoadSector
$LN11@LoadSector:

; 319  : 		for (i=0; i<count; i++)

	mov	edi, DWORD PTR _this$1$[esp+192]
	inc	ebx
	cmp	ebx, DWORD PTR _count$1$[esp+192]
	jb	$LL13@LoadSector
$LN12@LoadSector:

; 329  : 		}
; 330  : 		if (CL.getTS()<2)

	lea	ecx, DWORD PTR _CL$4[esp+192]
	call	DWORD PTR __imp_?getTS@Collector@CDB@@QAEIXZ
	cmp	eax, 2
	jae	SHORT $LN21@LoadSector

; 336  : 			CL.add_face_packed_D		( v1,v2,v3, 0 );

	fld	DWORD PTR __real@3727c5ac
	lea	eax, DWORD PTR _v3$5[esp+192]
	push	ecx
	fstp	DWORD PTR [esp]
	push	0
	push	eax
	lea	eax, DWORD PTR _v2$6[esp+204]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 23   : 	ICF	SelfRef	set(T _x, T _y, T _z)					{ x = _x;		y = _y;		z = _z;		return *this;	};

	mov	DWORD PTR _v1$7[esp+204], -962838528	; c69c4000H
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender_Loader.cpp

; 336  : 			CL.add_face_packed_D		( v1,v2,v3, 0 );

	push	eax
	lea	eax, DWORD PTR _v1$7[esp+208]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 23   : 	ICF	SelfRef	set(T _x, T _y, T _z)					{ x = _x;		y = _y;		z = _z;		return *this;	};

	mov	DWORD PTR _v1$7[esp+212], -962838528	; c69c4000H
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender_Loader.cpp

; 336  : 			CL.add_face_packed_D		( v1,v2,v3, 0 );

	push	eax
	lea	ecx, DWORD PTR _CL$4[esp+212]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 23   : 	ICF	SelfRef	set(T _x, T _y, T _z)					{ x = _x;		y = _y;		z = _z;		return *this;	};

	mov	DWORD PTR _v1$7[esp+220], -962838528	; c69c4000H
	mov	DWORD PTR _v2$6[esp+212], -962838016	; c69c4200H
	mov	DWORD PTR _v2$6[esp+216], -962838016	; c69c4200H
	mov	DWORD PTR _v2$6[esp+220], -962838016	; c69c4200H
	mov	DWORD PTR _v3$5[esp+212], -962837504	; c69c4400H
	mov	DWORD PTR _v3$5[esp+216], -962837504	; c69c4400H
	mov	DWORD PTR _v3$5[esp+220], -962837504	; c69c4400H
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender_Loader.cpp

; 336  : 			CL.add_face_packed_D		( v1,v2,v3, 0 );

	call	DWORD PTR __imp_?add_face_packed_D@Collector@CDB@@QAEXABU?$_vector3@M@@00IM@Z
$LN21@LoadSector:
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h

; 68   : 	T* ptr	= (T*)Memory.mem_alloc(sizeof(T));

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	28					; 0000001cH
	call	DWORD PTR tv1331[esp+196]

; 69   : 	return new (ptr) T();

	mov	ecx, eax
	call	DWORD PTR __imp_??0MODEL@CDB@@QAE@XZ
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender_Loader.cpp

; 340  : 		rmPortals = xr_new	<CDB::MODEL> ();

	mov	edi, DWORD PTR _this$1$[esp+192]

; 341  : 		rmPortals->build	(CL.getV(),int(CL.getVS()),CL.getT(),int(CL.getTS()));

	lea	ecx, DWORD PTR _CL$4[esp+192]
	push	0
	push	0
	mov	DWORD PTR [edi+708], eax
	call	DWORD PTR __imp_?getTS@Collector@CDB@@QAEIXZ
	push	eax
	lea	ecx, DWORD PTR _CL$4[esp+204]
	call	DWORD PTR __imp_?getT@Collector@CDB@@QAEPAVTRI@2@XZ
	push	eax
	lea	ecx, DWORD PTR _CL$4[esp+208]
	call	DWORD PTR __imp_?getVS@Collector@CDB@@QAEIXZ
	push	eax
	lea	ecx, DWORD PTR _CL$4[esp+212]
	call	DWORD PTR __imp_?getV@Collector@CDB@@QAEPAU?$_vector3@M@@XZ
	mov	ecx, DWORD PTR [edi+708]
	push	eax
	call	DWORD PTR __imp_?build@MODEL@CDB@@QAEXPAU?$_vector3@M@@HPAVTRI@2@HP6GX0H1HPAX@Z2@Z

; 342  : 	} else {

	lea	ecx, DWORD PTR _CL$4[esp+192]
	call	DWORD PTR __imp_??1Collector@CDB@@QAE@XZ

; 344  : 	}
; 345  : 
; 346  : 	// debug
; 347  : 	//	for (int d=0; d<Sectors.size(); d++)
; 348  : 	//		Sectors[d]->DebugDump	();
; 349  : 
; 350  : 	pLastSector = 0;

	mov	DWORD PTR [edi+640], 0

; 351  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
$LN249@LoadSector:

; 303  : 		if (0==P) break;

	mov	edi, DWORD PTR _this$1$[esp+192]
	jmp	$LN232@LoadSector
$LN19@LoadSector:

; 343  : 		rmPortals = 0;

	mov	DWORD PTR [edi+708], 0

; 344  : 	}
; 345  : 
; 346  : 	// debug
; 347  : 	//	for (int d=0; d<Sectors.size(); d++)
; 348  : 	//		Sectors[d]->DebugDump	();
; 349  : 
; 350  : 	pLastSector = 0;

	mov	DWORD PTR [edi+640], 0

; 351  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
$LN233@LoadSector:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1360 :                 _Xlength();

	call	?_Xlength@?$vector@PAVCPortal@@V?$xalloc@PAVCPortal@@@@@std@@CAXXZ ; std::vector<CPortal *,xalloc<CPortal *> >::_Xlength
$LN252@LoadSector:
	int	3
?LoadSectors@CRender@@AAEXPAVIReader@@@Z ENDP		; CRender::LoadSectors
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\FixedVector.h
;	COMDAT ??0b_portal@@QAE@XZ
_TEXT	SEGMENT
??0b_portal@@QAE@XZ PROC				; b_portal::b_portal, COMDAT
; _this$ = ecx

; 21   : 	svector() : count(0) 

	mov	DWORD PTR [ecx+76], 0
	mov	eax, ecx
	ret	0
??0b_portal@@QAE@XZ ENDP				; b_portal::b_portal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender_Loader.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender_Loader.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender_Loader.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrEngine\Fmesh.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender_Loader.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender_Loader.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender_Loader.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender_Loader.cpp
_TEXT	SEGMENT
_fs$1$ = -8						; size = 4
$T2 = -4						; size = 4
tv768 = 8						; size = 4
$T3 = 8							; size = 1
_base_fs$ = 8						; size = 4
?LoadSWIs@CRender@@AAEXPAVCStreamReader@@@Z PROC	; CRender::LoadSWIs
; _this$ = ecx

; 354  : {

	sub	esp, 8
	push	esi

; 355  : 	// allocate memory for portals
; 356  : 	if (base_fs->find_chunk(fsL_SWIS)){

	mov	esi, DWORD PTR _base_fs$[esp+8]
	push	edi
	push	0
	mov	edi, ecx
	mov	ecx, esi
	push	11					; 0000000bH
	call	DWORD PTR __imp_?find_chunk@?$IReaderBase@VCStreamReader@@@@QAEIIPAH@Z
	test	eax, eax
	je	$LN11@LoadSWIs

; 357  : 		CStreamReader		*fs = base_fs->open_chunk(fsL_SWIS);

	push	ebx
	push	ebp
	lea	eax, DWORD PTR $T2[esp+24]
	mov	DWORD PTR $T2[esp+24], 11		; 0000000bH
	push	eax
	mov	ecx, esi
	call	DWORD PTR __imp_?open_chunk@CStreamReader@@QAEPAV1@ABI@Z

; 358  : 		u32 item_count		= fs->r_u32();	

	mov	ecx, eax
	mov	DWORD PTR _fs$1$[esp+24], eax
	call	DWORD PTR __imp_?r_u32@?$IReaderBase@VCStreamReader@@@@QAEIXZ
	mov	esi, DWORD PTR [edi+884]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1463 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));

	lea	ebp, DWORD PTR [edi+884]

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	edi, DWORD PTR [edi+888]
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender_Loader.cpp

; 358  : 		u32 item_count		= fs->r_u32();	

	mov	ebx, eax

; 363  : 		for(;it!=it_e;++it)

	cmp	esi, edi
	je	SHORT $LN3@LoadSWIs
	npad	6
$LL4@LoadSWIs:
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN2@LoadSWIs
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
	mov	DWORD PTR [esi], 0
$LN2@LoadSWIs:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 74   :         ++_Ptr;

	add	esi, 24					; 00000018H
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender_Loader.cpp

; 363  : 		for(;it!=it_e;++it)

	cmp	esi, edi
	jne	SHORT $LL4@LoadSWIs
$LN3@LoadSWIs:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1414 :         const pointer _Firstptr = _First._Ptr;

	mov	edi, DWORD PTR [ebp]

; 1415 :         const pointer _Lastptr  = _Last._Ptr;

	mov	eax, DWORD PTR [ebp+4]

; 1416 :         auto& _My_data          = _Mypair._Myval2;
; 1417 :         pointer& _Mylast        = _My_data._Mylast;
; 1418 : 
; 1419 : #if _ITERATOR_DEBUG_LEVEL == 2
; 1420 :         _STL_VERIFY(_First._Getcont() == _STD addressof(_My_data) && _Last._Getcont() == _STD addressof(_My_data)
; 1421 :                         && _Firstptr >= _My_data._Myfirst && _Lastptr >= _Firstptr && _Mylast >= _Lastptr,
; 1422 :             "vector erase iterator outside range");
; 1423 : #endif // _ITERATOR_DEBUG_LEVEL == 2
; 1424 : 
; 1425 :         if (_Firstptr != _Lastptr) { // something to do, invalidate iterators

	cmp	edi, eax
	je	SHORT $LN51@LoadSWIs
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility

; 4065 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	mov	esi, eax
	sub	esi, eax

; 4066 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	push	esi
	push	eax
	push	edi
	call	_memmove

; 4067 :     if constexpr (is_pointer_v<_OutCtgIt>) {
; 4068 :         return reinterpret_cast<_OutCtgIt>(_Dest_ch + _Count);

	lea	eax, DWORD PTR [esi+edi]
	add	esp, 12					; 0000000cH
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1430 :             _Mylast = _Newlast;

	mov	DWORD PTR [ebp+4], eax
$LN51@LoadSWIs:

; 1250 :         const auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);

	mov	esi, DWORD PTR [ebp]
	mov	ecx, eax
	sub	ecx, esi
	sar	ecx, 3
	imul	edx, ecx, -1431655765

; 1251 :         if (_Newsize < _Oldsize) { // trim

	cmp	ebx, edx
	jae	SHORT $LN67@LoadSWIs

; 1252 :             const pointer _Newlast = _Myfirst + _Newsize;

	lea	eax, DWORD PTR [ebx+ebx*2]
	lea	eax, DWORD PTR [esi+eax*8]

; 1253 :             _Orphan_range(_Newlast, _Mylast);
; 1254 :             _Destroy(_Newlast, _Mylast);
; 1255 :             _Mylast = _Newlast;
; 1256 :             return;

	jmp	SHORT $LN75@LoadSWIs
$LN67@LoadSWIs:

; 1257 :         }
; 1258 : 
; 1259 :         if (_Newsize > _Oldsize) { // append

	jbe	SHORT $LN68@LoadSWIs

; 1260 :             const auto _Oldcapacity = static_cast<size_type>(_My_data._Myend - _Myfirst);

	mov	ecx, DWORD PTR [ebp+8]
	sub	ecx, esi
	sar	ecx, 3
	imul	ecx, ecx, -1431655765

; 1261 :             if (_Newsize > _Oldcapacity) { // reallocate

	cmp	ebx, ecx
	jbe	SHORT $LN69@LoadSWIs

; 1262 :                 _Resize_reallocate(_Newsize, _Val);

	lea	eax, DWORD PTR $T3[esp+20]
	mov	ecx, ebp
	push	eax
	push	ebx
	call	??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UFSlideWindowItem@@V?$xalloc@UFSlideWindowItem@@@@@std@@AAEXIABU_Value_init_tag@1@@Z ; std::vector<FSlideWindowItem,xalloc<FSlideWindowItem> >::_Resize_reallocate<std::_Value_init_tag>

; 1263 :                 return;

	jmp	SHORT $LN68@LoadSWIs
$LN69@LoadSWIs:

; 1264 :             }
; 1265 : 
; 1266 :             const pointer _Oldlast = _Mylast;
; 1267 :             _Mylast                = _Ufill(_Oldlast, _Newsize - _Oldsize, _Val);

	mov	ecx, ebx
	sub	ecx, edx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1813 :     for (; 0 < _Count; --_Count) {

	je	SHORT $LN75@LoadSWIs
	npad	12
$LL76@LoadSWIs:
; File I:\Vitalya\mine\NSProjectX\xrEngine\Fmesh.h

; 105  : 	FSlideWindowItem() : sw(0), count(0) {};

	mov	DWORD PTR [eax], 0
	mov	DWORD PTR [eax+4], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1621 :         ++_Last;

	add	eax, 24					; 00000018H

; 1813 :     for (; 0 < _Count; --_Count) {

	sub	ecx, 1
	jne	SHORT $LL76@LoadSWIs
$LN75@LoadSWIs:
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender_Loader.cpp

; 369  : 		for (u32 c=0; c<item_count; c++){

	mov	DWORD PTR [ebp+4], eax
$LN68@LoadSWIs:
	mov	edi, DWORD PTR _fs$1$[esp+24]
	test	ebx, ebx
	je	SHORT $LN6@LoadSWIs
	xor	eax, eax
	mov	DWORD PTR tv768[esp+20], eax
$LL7@LoadSWIs:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 119  :         _Ptr += _Off;

	mov	esi, DWORD PTR [ebp]
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender_Loader.cpp

; 371  : 			swi.reserved[0]	= fs->r_u32();	

	mov	ecx, edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 119  :         _Ptr += _Off;

	add	esi, eax
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender_Loader.cpp

; 371  : 			swi.reserved[0]	= fs->r_u32();	

	call	DWORD PTR __imp_?r_u32@?$IReaderBase@VCStreamReader@@@@QAEIXZ

; 372  : 			swi.reserved[1]	= fs->r_u32();	

	mov	ecx, edi
	mov	DWORD PTR [esi+8], eax
	call	DWORD PTR __imp_?r_u32@?$IReaderBase@VCStreamReader@@@@QAEIXZ

; 373  : 			swi.reserved[2]	= fs->r_u32();	

	mov	ecx, edi
	mov	DWORD PTR [esi+12], eax
	call	DWORD PTR __imp_?r_u32@?$IReaderBase@VCStreamReader@@@@QAEIXZ

; 374  : 			swi.reserved[3]	= fs->r_u32();	

	mov	ecx, edi
	mov	DWORD PTR [esi+16], eax
	call	DWORD PTR __imp_?r_u32@?$IReaderBase@VCStreamReader@@@@QAEIXZ

; 375  : 			swi.count		= fs->r_u32();	

	mov	ecx, edi
	mov	DWORD PTR [esi+20], eax
	call	DWORD PTR __imp_?r_u32@?$IReaderBase@VCStreamReader@@@@QAEIXZ
	mov	DWORD PTR [esi+4], eax
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	shl	eax, 3
	push	eax
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender_Loader.cpp

; 378  : 			fs->r			(swi.sw,sizeof(FSlideWindow)*swi.count);

	mov	ecx, DWORD PTR [esi+4]
	shl	ecx, 3
	push	ecx
	push	eax
	mov	ecx, edi
	mov	DWORD PTR [esi], eax
	call	DWORD PTR __imp_?r@CStreamReader@@QAEXPAXI@Z
	mov	eax, DWORD PTR tv768[esp+20]
	add	eax, 24					; 00000018H
	mov	DWORD PTR tv768[esp+20], eax
	sub	ebx, 1
	jne	SHORT $LL7@LoadSWIs
$LN6@LoadSWIs:

; 379  : 		}
; 380  : 
; 381  : 		fs->close			();

	mov	ecx, edi
	call	DWORD PTR __imp_?close@CStreamReader@@QAEXXZ
	pop	ebp
	pop	ebx
$LN11@LoadSWIs:

; 382  : 	}
; 383  : }

	pop	edi
	pop	esi
	add	esp, 8
	ret	4
?LoadSWIs@CRender@@AAEXPAVCStreamReader@@@Z ENDP	; CRender::LoadSWIs
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UFSlideWindowItem@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UFSlideWindowItem@@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<FSlideWindowItem> > >::operator++, COMDAT
; _this$ = ecx

; 74   :         ++_Ptr;

	add	DWORD PTR [ecx], 24			; 00000018H

; 276  :         _Mybase::operator++();
; 277  :         return *this;

	mov	eax, ecx

; 278  :     }

	ret	0
??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UFSlideWindowItem@@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<FSlideWindowItem> > >::operator++
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UFSlideWindowItem@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UFSlideWindowItem@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<FSlideWindowItem> > >::operator!=, COMDAT
; _this$ = ecx

; 160  :         return !(*this == _Right);

	mov	eax, DWORD PTR __Right$[esp-4]
	mov	ecx, DWORD PTR [ecx]
	cmp	ecx, DWORD PTR [eax]
	setne	al

; 161  :     }

	ret	4
??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UFSlideWindowItem@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<FSlideWindowItem> > >::operator!=
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\FixedVector.h
;	COMDAT ??A?$svector@U?$_vector3@M@@$05@@QAEAAU?$_vector3@M@@I@Z
_TEXT	SEGMENT
_id$ = 8						; size = 4
??A?$svector@U?$_vector3@M@@$05@@QAEAAU?$_vector3@M@@I@Z PROC ; svector<_vector3<float>,6>::operator[], COMDAT
; _this$ = ecx

; 38   : 	IC reference		operator[] (u32 id)			{ VERIFY(id<count); return array[id];	}

	mov	eax, DWORD PTR _id$[esp-4]
	lea	eax, DWORD PTR [eax+eax*2]
	lea	eax, DWORD PTR [ecx+eax*4]
	ret	4
??A?$svector@U?$_vector3@M@@$05@@QAEAAU?$_vector3@M@@I@Z ENDP ; svector<_vector3<float>,6>::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\FixedVector.h
;	COMDAT ?size@?$svector@U?$_vector3@M@@$05@@QBEIXZ
_TEXT	SEGMENT
?size@?$svector@U?$_vector3@M@@$05@@QBEIXZ PROC		; svector<_vector3<float>,6>::size, COMDAT
; _this$ = ecx

; 30   : 	IC u32		size()		const			{ return count;							}

	mov	eax, DWORD PTR [ecx+72]
	ret	0
?size@?$svector@U?$_vector3@M@@$05@@QBEIXZ ENDP		; svector<_vector3<float>,6>::size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\FixedVector.h
;	COMDAT ?begin@?$svector@U?$_vector3@M@@$05@@QAEPAU?$_vector3@M@@XZ
_TEXT	SEGMENT
?begin@?$svector@U?$_vector3@M@@$05@@QAEPAU?$_vector3@M@@XZ PROC ; svector<_vector3<float>,6>::begin, COMDAT
; _this$ = ecx

; 26   : 	IC iterator	begin()						{ return array;							}

	mov	eax, ecx
	ret	0
?begin@?$svector@U?$_vector3@M@@$05@@QAEPAU?$_vector3@M@@XZ ENDP ; svector<_vector3<float>,6>::begin
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\FixedVector.h
;	COMDAT ??0?$svector@U?$_vector3@M@@$05@@QAE@XZ
_TEXT	SEGMENT
??0?$svector@U?$_vector3@M@@$05@@QAE@XZ PROC		; svector<_vector3<float>,6>::svector<_vector3<float>,6>, COMDAT
; _this$ = ecx

; 21   : 	svector() : count(0) 

	mov	DWORD PTR [ecx+72], 0

; 22   : 	{}

	mov	eax, ecx
	ret	0
??0?$svector@U?$_vector3@M@@$05@@QAE@XZ ENDP		; svector<_vector3<float>,6>::svector<_vector3<float>,6>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\FixedVector.h
;	COMDAT ?resize@?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@QAEXH@Z
_TEXT	SEGMENT
_c$ = 8							; size = 4
?resize@?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@QAEXH@Z PROC ; svector<_D3DVERTEXELEMENT9,65>::resize, COMDAT
; _this$ = ecx

; 32   : 	IC void		resize(int c)				{ VERIFY(c<=dim); count=c;				}

	mov	eax, DWORD PTR _c$[esp-4]
	mov	DWORD PTR [ecx+520], eax
	ret	4
?resize@?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@QAEXH@Z ENDP ; svector<_D3DVERTEXELEMENT9,65>::resize
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?clear_and_free@?$xr_vector@PAUIDirect3DIndexBuffer9@@V?$xalloc@PAUIDirect3DIndexBuffer9@@@@@@QAEXXZ
_TEXT	SEGMENT
?clear_and_free@?$xr_vector@PAUIDirect3DIndexBuffer9@@V?$xalloc@PAUIDirect3DIndexBuffer9@@@@@@QAEXXZ PROC ; xr_vector<IDirect3DIndexBuffer9 *,xalloc<IDirect3DIndexBuffer9 *> >::clear_and_free, COMDAT
; _this$ = ecx

; 127  : 	void	clear_and_free		()									{ inherited::clear();			}

	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [ecx+4], eax
	ret	0
?clear_and_free@?$xr_vector@PAUIDirect3DIndexBuffer9@@V?$xalloc@PAUIDirect3DIndexBuffer9@@@@@@QAEXXZ ENDP ; xr_vector<IDirect3DIndexBuffer9 *,xalloc<IDirect3DIndexBuffer9 *> >::clear_and_free
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?size@?$xr_vector@PAUIDirect3DIndexBuffer9@@V?$xalloc@PAUIDirect3DIndexBuffer9@@@@@@QBEIXZ
_TEXT	SEGMENT
?size@?$xr_vector@PAUIDirect3DIndexBuffer9@@V?$xalloc@PAUIDirect3DIndexBuffer9@@@@@@QBEIXZ PROC ; xr_vector<IDirect3DIndexBuffer9 *,xalloc<IDirect3DIndexBuffer9 *> >::size, COMDAT
; _this$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	eax, DWORD PTR [ecx+4]
	sub	eax, DWORD PTR [ecx]
	sar	eax, 2
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 125  : 	u32		size				() const							{ return (u32)inherited::size();} 

	ret	0
?size@?$xr_vector@PAUIDirect3DIndexBuffer9@@V?$xalloc@PAUIDirect3DIndexBuffer9@@@@@@QBEIXZ ENDP ; xr_vector<IDirect3DIndexBuffer9 *,xalloc<IDirect3DIndexBuffer9 *> >::size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?resize@?$vector@PAUIDirect3DIndexBuffer9@@V?$xalloc@PAUIDirect3DIndexBuffer9@@@@@std@@QAEXI@Z
_TEXT	SEGMENT
__Newsize$ = 8						; size = 4
?resize@?$vector@PAUIDirect3DIndexBuffer9@@V?$xalloc@PAUIDirect3DIndexBuffer9@@@@@std@@QAEXI@Z PROC ; std::vector<IDirect3DIndexBuffer9 *,xalloc<IDirect3DIndexBuffer9 *> >::resize, COMDAT
; _this$ = ecx

; 1275 :     _CONSTEXPR20_CONTAINER void resize(_CRT_GUARDOVERFLOW const size_type _Newsize) {

	push	ebx
	push	esi

; 1251 :         if (_Newsize < _Oldsize) { // trim

	mov	esi, DWORD PTR __Newsize$[esp+4]

; 1275 :     _CONSTEXPR20_CONTAINER void resize(_CRT_GUARDOVERFLOW const size_type _Newsize) {

	push	edi
	mov	edi, ecx

; 1250 :         const auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);

	mov	ebx, DWORD PTR [edi+4]
	mov	ecx, ebx
	mov	edx, DWORD PTR [edi]
	sub	ecx, edx
	sar	ecx, 2

; 1251 :         if (_Newsize < _Oldsize) { // trim

	cmp	esi, ecx
	jae	SHORT $LN4@resize

; 1252 :             const pointer _Newlast = _Myfirst + _Newsize;

	lea	eax, DWORD PTR [edx+esi*4]

; 1278 :     }

	mov	DWORD PTR [edi+4], eax
	pop	edi
	pop	esi
	pop	ebx
	ret	4
$LN4@resize:

; 1259 :         if (_Newsize > _Oldsize) { // append

	jbe	SHORT $LN5@resize

; 1260 :             const auto _Oldcapacity = static_cast<size_type>(_My_data._Myend - _Myfirst);

	mov	eax, DWORD PTR [edi+8]
	sub	eax, edx
	sar	eax, 2

; 1261 :             if (_Newsize > _Oldcapacity) { // reallocate

	cmp	esi, eax
	jbe	SHORT $LN6@resize

; 1262 :                 _Resize_reallocate(_Newsize, _Val);

	push	ecx
	push	esi
	mov	ecx, edi
	call	??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@PAUIDirect3DIndexBuffer9@@V?$xalloc@PAUIDirect3DIndexBuffer9@@@@@std@@AAEXIABU_Value_init_tag@1@@Z ; std::vector<IDirect3DIndexBuffer9 *,xalloc<IDirect3DIndexBuffer9 *> >::_Resize_reallocate<std::_Value_init_tag>
	pop	edi

; 1278 :     }

	pop	esi
	pop	ebx
	ret	4
$LN6@resize:

; 1267 :             _Mylast                = _Ufill(_Oldlast, _Newsize - _Oldsize, _Val);

	sub	esi, ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1807 :             _Zero_range(_PFirst, _PFirst + _Count);

	shl	esi, 2

; 1792 :     _CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

	push	esi
	push	0
	push	ebx
	call	_memset

; 1808 :             return _First + _Count;

	lea	eax, DWORD PTR [esi+ebx]

; 1792 :     _CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

	add	esp, 12					; 0000000cH
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1278 :     }

	mov	DWORD PTR [edi+4], eax
$LN5@resize:
	pop	edi
	pop	esi
	pop	ebx
	ret	4
?resize@?$vector@PAUIDirect3DIndexBuffer9@@V?$xalloc@PAUIDirect3DIndexBuffer9@@@@@std@@QAEXI@Z ENDP ; std::vector<IDirect3DIndexBuffer9 *,xalloc<IDirect3DIndexBuffer9 *> >::resize
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?clear_and_free@?$xr_vector@PAUIDirect3DVertexBuffer9@@V?$xalloc@PAUIDirect3DVertexBuffer9@@@@@@QAEXXZ
_TEXT	SEGMENT
?clear_and_free@?$xr_vector@PAUIDirect3DVertexBuffer9@@V?$xalloc@PAUIDirect3DVertexBuffer9@@@@@@QAEXXZ PROC ; xr_vector<IDirect3DVertexBuffer9 *,xalloc<IDirect3DVertexBuffer9 *> >::clear_and_free, COMDAT
; _this$ = ecx

; 127  : 	void	clear_and_free		()									{ inherited::clear();			}

	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [ecx+4], eax
	ret	0
?clear_and_free@?$xr_vector@PAUIDirect3DVertexBuffer9@@V?$xalloc@PAUIDirect3DVertexBuffer9@@@@@@QAEXXZ ENDP ; xr_vector<IDirect3DVertexBuffer9 *,xalloc<IDirect3DVertexBuffer9 *> >::clear_and_free
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?size@?$xr_vector@PAUIDirect3DVertexBuffer9@@V?$xalloc@PAUIDirect3DVertexBuffer9@@@@@@QBEIXZ
_TEXT	SEGMENT
?size@?$xr_vector@PAUIDirect3DVertexBuffer9@@V?$xalloc@PAUIDirect3DVertexBuffer9@@@@@@QBEIXZ PROC ; xr_vector<IDirect3DVertexBuffer9 *,xalloc<IDirect3DVertexBuffer9 *> >::size, COMDAT
; _this$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	eax, DWORD PTR [ecx+4]
	sub	eax, DWORD PTR [ecx]
	sar	eax, 2
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 125  : 	u32		size				() const							{ return (u32)inherited::size();} 

	ret	0
?size@?$xr_vector@PAUIDirect3DVertexBuffer9@@V?$xalloc@PAUIDirect3DVertexBuffer9@@@@@@QBEIXZ ENDP ; xr_vector<IDirect3DVertexBuffer9 *,xalloc<IDirect3DVertexBuffer9 *> >::size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?resize@?$vector@PAUIDirect3DVertexBuffer9@@V?$xalloc@PAUIDirect3DVertexBuffer9@@@@@std@@QAEXI@Z
_TEXT	SEGMENT
__Newsize$ = 8						; size = 4
?resize@?$vector@PAUIDirect3DVertexBuffer9@@V?$xalloc@PAUIDirect3DVertexBuffer9@@@@@std@@QAEXI@Z PROC ; std::vector<IDirect3DVertexBuffer9 *,xalloc<IDirect3DVertexBuffer9 *> >::resize, COMDAT
; _this$ = ecx

; 1275 :     _CONSTEXPR20_CONTAINER void resize(_CRT_GUARDOVERFLOW const size_type _Newsize) {

	push	ebx
	push	esi

; 1251 :         if (_Newsize < _Oldsize) { // trim

	mov	esi, DWORD PTR __Newsize$[esp+4]

; 1275 :     _CONSTEXPR20_CONTAINER void resize(_CRT_GUARDOVERFLOW const size_type _Newsize) {

	push	edi
	mov	edi, ecx

; 1250 :         const auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);

	mov	ebx, DWORD PTR [edi+4]
	mov	ecx, ebx
	mov	edx, DWORD PTR [edi]
	sub	ecx, edx
	sar	ecx, 2

; 1251 :         if (_Newsize < _Oldsize) { // trim

	cmp	esi, ecx
	jae	SHORT $LN4@resize

; 1252 :             const pointer _Newlast = _Myfirst + _Newsize;

	lea	eax, DWORD PTR [edx+esi*4]

; 1278 :     }

	mov	DWORD PTR [edi+4], eax
	pop	edi
	pop	esi
	pop	ebx
	ret	4
$LN4@resize:

; 1259 :         if (_Newsize > _Oldsize) { // append

	jbe	SHORT $LN5@resize

; 1260 :             const auto _Oldcapacity = static_cast<size_type>(_My_data._Myend - _Myfirst);

	mov	eax, DWORD PTR [edi+8]
	sub	eax, edx
	sar	eax, 2

; 1261 :             if (_Newsize > _Oldcapacity) { // reallocate

	cmp	esi, eax
	jbe	SHORT $LN6@resize

; 1262 :                 _Resize_reallocate(_Newsize, _Val);

	push	ecx
	push	esi
	mov	ecx, edi
	call	??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@PAUIDirect3DVertexBuffer9@@V?$xalloc@PAUIDirect3DVertexBuffer9@@@@@std@@AAEXIABU_Value_init_tag@1@@Z ; std::vector<IDirect3DVertexBuffer9 *,xalloc<IDirect3DVertexBuffer9 *> >::_Resize_reallocate<std::_Value_init_tag>
	pop	edi

; 1278 :     }

	pop	esi
	pop	ebx
	ret	4
$LN6@resize:

; 1267 :             _Mylast                = _Ufill(_Oldlast, _Newsize - _Oldsize, _Val);

	sub	esi, ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1807 :             _Zero_range(_PFirst, _PFirst + _Count);

	shl	esi, 2

; 1792 :     _CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

	push	esi
	push	0
	push	ebx
	call	_memset

; 1808 :             return _First + _Count;

	lea	eax, DWORD PTR [esi+ebx]

; 1792 :     _CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

	add	esp, 12					; 0000000cH
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1278 :     }

	mov	DWORD PTR [edi+4], eax
$LN5@resize:
	pop	edi
	pop	esi
	pop	ebx
	ret	4
?resize@?$vector@PAUIDirect3DVertexBuffer9@@V?$xalloc@PAUIDirect3DVertexBuffer9@@@@@std@@QAEXI@Z ENDP ; std::vector<IDirect3DVertexBuffer9 *,xalloc<IDirect3DVertexBuffer9 *> >::resize
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?clear_and_free@?$xr_vector@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@V?$xalloc@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@@@@QAEXXZ
_TEXT	SEGMENT
?clear_and_free@?$xr_vector@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@V?$xalloc@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@@@@QAEXXZ PROC ; xr_vector<svector<_D3DVERTEXELEMENT9,65>,xalloc<svector<_D3DVERTEXELEMENT9,65> > >::clear_and_free, COMDAT
; _this$ = ecx

; 127  : 	void	clear_and_free		()									{ inherited::clear();			}

	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [ecx+4], eax
	ret	0
?clear_and_free@?$xr_vector@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@V?$xalloc@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@@@@QAEXXZ ENDP ; xr_vector<svector<_D3DVERTEXELEMENT9,65>,xalloc<svector<_D3DVERTEXELEMENT9,65> > >::clear_and_free
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?resize@?$vector@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@V?$xalloc@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@@@std@@QAEXI@Z
_TEXT	SEGMENT
$T1 = 8							; size = 1
__Newsize$ = 8						; size = 4
?resize@?$vector@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@V?$xalloc@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@@@std@@QAEXI@Z PROC ; std::vector<svector<_D3DVERTEXELEMENT9,65>,xalloc<svector<_D3DVERTEXELEMENT9,65> > >::resize, COMDAT
; _this$ = ecx

; 1275 :     _CONSTEXPR20_CONTAINER void resize(_CRT_GUARDOVERFLOW const size_type _Newsize) {

	push	ebx
	push	ebp
	push	esi

; 1251 :         if (_Newsize < _Oldsize) { // trim

	mov	esi, DWORD PTR __Newsize$[esp+8]
	mov	eax, 1049152317				; 3e88cb3dH

; 1275 :     _CONSTEXPR20_CONTAINER void resize(_CRT_GUARDOVERFLOW const size_type _Newsize) {

	push	edi
	mov	edi, ecx

; 1250 :         const auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);

	mov	edx, DWORD PTR [edi+4]
	mov	ebp, DWORD PTR [edi]
	sub	edx, ebp
	imul	edx
	sar	edx, 7
	mov	ebx, edx
	shr	ebx, 31					; 0000001fH
	add	ebx, edx

; 1251 :         if (_Newsize < _Oldsize) { // trim

	cmp	esi, ebx
	jae	SHORT $LN4@resize

; 1252 :             const pointer _Newlast = _Myfirst + _Newsize;

	imul	eax, esi, 524
	add	eax, ebp

; 1276 :         // trim or append value-initialized elements, provide strong guarantee
; 1277 :         _Resize(_Newsize, _Value_init_tag{});
; 1278 :     }

	mov	DWORD PTR [edi+4], eax
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	ret	4
$LN4@resize:

; 1259 :         if (_Newsize > _Oldsize) { // append

	jbe	SHORT $LN5@resize

; 1260 :             const auto _Oldcapacity = static_cast<size_type>(_My_data._Myend - _Myfirst);

	mov	ecx, DWORD PTR [edi+8]
	mov	eax, 1049152317				; 3e88cb3dH
	sub	ecx, ebp
	imul	ecx
	sar	edx, 7
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx

; 1261 :             if (_Newsize > _Oldcapacity) { // reallocate

	cmp	esi, eax
	jbe	SHORT $LN6@resize

; 1262 :                 _Resize_reallocate(_Newsize, _Val);

	lea	eax, DWORD PTR $T1[esp+12]
	mov	ecx, edi
	push	eax
	push	esi
	call	??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@V?$xalloc@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@@@std@@AAEXIABU_Value_init_tag@1@@Z ; std::vector<svector<_D3DVERTEXELEMENT9,65>,xalloc<svector<_D3DVERTEXELEMENT9,65> > >::_Resize_reallocate<std::_Value_init_tag>
	pop	edi

; 1276 :         // trim or append value-initialized elements, provide strong guarantee
; 1277 :         _Resize(_Newsize, _Value_init_tag{});
; 1278 :     }

	pop	esi
	pop	ebp
	pop	ebx
	ret	4
$LN6@resize:

; 1267 :             _Mylast                = _Ufill(_Oldlast, _Newsize - _Oldsize, _Val);

	push	DWORD PTR $T1[esp+12]
	sub	esi, ebx
	push	esi
	push	DWORD PTR [edi+4]
	call	?_Ufill@?$vector@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@V?$xalloc@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@@@std@@AAEPAV?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@PAV3@IU_Value_init_tag@2@@Z ; std::vector<svector<_D3DVERTEXELEMENT9,65>,xalloc<svector<_D3DVERTEXELEMENT9,65> > >::_Ufill

; 1276 :         // trim or append value-initialized elements, provide strong guarantee
; 1277 :         _Resize(_Newsize, _Value_init_tag{});
; 1278 :     }

	mov	DWORD PTR [edi+4], eax
$LN5@resize:
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	ret	4
?resize@?$vector@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@V?$xalloc@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@@@std@@QAEXI@Z ENDP ; std::vector<svector<_D3DVERTEXELEMENT9,65>,xalloc<svector<_D3DVERTEXELEMENT9,65> > >::resize
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?clear_and_free@?$xr_vector@V?$resptr_core@UShader@@Uresptrcode_shader@@@@V?$xalloc@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@@@@QAEXXZ
_TEXT	SEGMENT
?clear_and_free@?$xr_vector@V?$resptr_core@UShader@@Uresptrcode_shader@@@@V?$xalloc@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@@@@QAEXXZ PROC ; xr_vector<resptr_core<Shader,resptrcode_shader>,xalloc<resptr_core<Shader,resptrcode_shader> > >::clear_and_free, COMDAT
; _this$ = ecx

; 127  : 	void	clear_and_free		()									{ inherited::clear();			}

	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [ecx+4], eax
	ret	0
?clear_and_free@?$xr_vector@V?$resptr_core@UShader@@Uresptrcode_shader@@@@V?$xalloc@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@@@@QAEXXZ ENDP ; xr_vector<resptr_core<Shader,resptrcode_shader>,xalloc<resptr_core<Shader,resptrcode_shader> > >::clear_and_free
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?resize@?$vector@V?$resptr_core@UShader@@Uresptrcode_shader@@@@V?$xalloc@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@@@std@@QAEXI@Z
_TEXT	SEGMENT
__Newsize$ = 8						; size = 4
?resize@?$vector@V?$resptr_core@UShader@@Uresptrcode_shader@@@@V?$xalloc@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@@@std@@QAEXI@Z PROC ; std::vector<resptr_core<Shader,resptrcode_shader>,xalloc<resptr_core<Shader,resptrcode_shader> > >::resize, COMDAT
; _this$ = ecx

; 1251 :         if (_Newsize < _Oldsize) { // trim

	mov	edx, DWORD PTR __Newsize$[esp-4]

; 1275 :     _CONSTEXPR20_CONTAINER void resize(_CRT_GUARDOVERFLOW const size_type _Newsize) {

	push	ebx
	push	esi
	mov	esi, ecx
	push	edi

; 1250 :         const auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);

	mov	ebx, DWORD PTR [esi+4]
	mov	ecx, ebx
	mov	edi, DWORD PTR [esi]
	sub	ecx, edi
	sar	ecx, 2

; 1251 :         if (_Newsize < _Oldsize) { // trim

	cmp	edx, ecx
	jae	SHORT $LN4@resize

; 1252 :             const pointer _Newlast = _Myfirst + _Newsize;

	lea	eax, DWORD PTR [edi+edx*4]
	pop	edi

; 1253 :             _Orphan_range(_Newlast, _Mylast);
; 1254 :             _Destroy(_Newlast, _Mylast);
; 1255 :             _Mylast = _Newlast;

	mov	DWORD PTR [esi+4], eax

; 1276 :         // trim or append value-initialized elements, provide strong guarantee
; 1277 :         _Resize(_Newsize, _Value_init_tag{});
; 1278 :     }

	pop	esi
	pop	ebx
	ret	4
$LN4@resize:

; 1259 :         if (_Newsize > _Oldsize) { // append

	jbe	SHORT $LN5@resize

; 1260 :             const auto _Oldcapacity = static_cast<size_type>(_My_data._Myend - _Myfirst);

	mov	eax, DWORD PTR [esi+8]
	sub	eax, edi
	sar	eax, 2

; 1261 :             if (_Newsize > _Oldcapacity) { // reallocate

	cmp	edx, eax
	jbe	SHORT $LN6@resize

; 1262 :                 _Resize_reallocate(_Newsize, _Val);

	push	ecx
	push	edx
	mov	ecx, esi
	call	??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@V?$resptr_core@UShader@@Uresptrcode_shader@@@@V?$xalloc@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@@@std@@AAEXIABU_Value_init_tag@1@@Z ; std::vector<resptr_core<Shader,resptrcode_shader>,xalloc<resptr_core<Shader,resptrcode_shader> > >::_Resize_reallocate<std::_Value_init_tag>
	pop	edi

; 1276 :         // trim or append value-initialized elements, provide strong guarantee
; 1277 :         _Resize(_Newsize, _Value_init_tag{});
; 1278 :     }

	pop	esi
	pop	ebx
	ret	4
$LN6@resize:

; 1267 :             _Mylast                = _Ufill(_Oldlast, _Newsize - _Oldsize, _Val);

	sub	edx, ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1813 :     for (; 0 < _Count; --_Count) {

	je	SHORT $LN13@resize
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1267 :             _Mylast                = _Ufill(_Oldlast, _Newsize - _Oldsize, _Val);

	mov	edi, ebx
	mov	ecx, edx
	xor	eax, eax
	lea	ebx, DWORD PTR [ebx+edx*4]
	rep stosd
$LN13@resize:
	mov	DWORD PTR [esi+4], ebx
$LN5@resize:
	pop	edi

; 1276 :         // trim or append value-initialized elements, provide strong guarantee
; 1277 :         _Resize(_Newsize, _Value_init_tag{});
; 1278 :     }

	pop	esi
	pop	ebx
	ret	4
?resize@?$vector@V?$resptr_core@UShader@@Uresptrcode_shader@@@@V?$xalloc@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@@@std@@QAEXI@Z ENDP ; std::vector<resptr_core<Shader,resptrcode_shader>,xalloc<resptr_core<Shader,resptrcode_shader> > >::resize
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?clear@?$xr_vector@UFSlideWindowItem@@V?$xalloc@UFSlideWindowItem@@@@@@QAEXXZ
_TEXT	SEGMENT
?clear@?$xr_vector@UFSlideWindowItem@@V?$xalloc@UFSlideWindowItem@@@@@@QAEXXZ PROC ; xr_vector<FSlideWindowItem,xalloc<FSlideWindowItem> >::clear, COMDAT
; _this$ = ecx

; 132  : 	void	clear				()									{ clear_and_free	();			}

	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [ecx+4], eax
	ret	0
?clear@?$xr_vector@UFSlideWindowItem@@V?$xalloc@UFSlideWindowItem@@@@@@QAEXXZ ENDP ; xr_vector<FSlideWindowItem,xalloc<FSlideWindowItem> >::clear
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?clear_not_free@?$xr_vector@UFSlideWindowItem@@V?$xalloc@UFSlideWindowItem@@@@@@QAEXXZ
_TEXT	SEGMENT
?clear_not_free@?$xr_vector@UFSlideWindowItem@@V?$xalloc@UFSlideWindowItem@@@@@@QAEXXZ PROC ; xr_vector<FSlideWindowItem,xalloc<FSlideWindowItem> >::clear_not_free, COMDAT
; _this$ = ecx

; 128  : 	void	clear_not_free		()									{ erase(begin(),end());			}

	push	ebx
	push	edi
	mov	edi, ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1414 :         const pointer _Firstptr = _First._Ptr;

	mov	ebx, DWORD PTR [edi]

; 1415 :         const pointer _Lastptr  = _Last._Ptr;

	mov	eax, DWORD PTR [edi+4]

; 1416 :         auto& _My_data          = _Mypair._Myval2;
; 1417 :         pointer& _Mylast        = _My_data._Mylast;
; 1418 : 
; 1419 : #if _ITERATOR_DEBUG_LEVEL == 2
; 1420 :         _STL_VERIFY(_First._Getcont() == _STD addressof(_My_data) && _Last._Getcont() == _STD addressof(_My_data)
; 1421 :                         && _Firstptr >= _My_data._Myfirst && _Lastptr >= _Firstptr && _Mylast >= _Lastptr,
; 1422 :             "vector erase iterator outside range");
; 1423 : #endif // _ITERATOR_DEBUG_LEVEL == 2
; 1424 : 
; 1425 :         if (_Firstptr != _Lastptr) { // something to do, invalidate iterators

	cmp	ebx, eax
	je	SHORT $LN16@clear_not_
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility

; 4065 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	push	esi
	mov	esi, eax
	sub	esi, eax

; 4066 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	push	esi
	push	eax
	push	ebx
	call	_memmove
	add	esp, 12					; 0000000cH

; 4067 :     if constexpr (is_pointer_v<_OutCtgIt>) {
; 4068 :         return reinterpret_cast<_OutCtgIt>(_Dest_ch + _Count);

	lea	eax, DWORD PTR [esi+ebx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1430 :             _Mylast = _Newlast;

	mov	DWORD PTR [edi+4], eax
	pop	esi
$LN16@clear_not_:
	pop	edi
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 128  : 	void	clear_not_free		()									{ erase(begin(),end());			}

	pop	ebx
	ret	0
?clear_not_free@?$xr_vector@UFSlideWindowItem@@V?$xalloc@UFSlideWindowItem@@@@@@QAEXXZ ENDP ; xr_vector<FSlideWindowItem,xalloc<FSlideWindowItem> >::clear_not_free
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?size@?$xr_vector@UFSlideWindowItem@@V?$xalloc@UFSlideWindowItem@@@@@@QBEIXZ
_TEXT	SEGMENT
?size@?$xr_vector@UFSlideWindowItem@@V?$xalloc@UFSlideWindowItem@@@@@@QBEIXZ PROC ; xr_vector<FSlideWindowItem,xalloc<FSlideWindowItem> >::size, COMDAT
; _this$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	eax, DWORD PTR [ecx+4]
	sub	eax, DWORD PTR [ecx]
	sar	eax, 3
	imul	eax, eax, -1431655765
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 125  : 	u32		size				() const							{ return (u32)inherited::size();} 

	ret	0
?size@?$xr_vector@UFSlideWindowItem@@V?$xalloc@UFSlideWindowItem@@@@@@QBEIXZ ENDP ; xr_vector<FSlideWindowItem,xalloc<FSlideWindowItem> >::size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?end@?$vector@UFSlideWindowItem@@V?$xalloc@UFSlideWindowItem@@@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UFSlideWindowItem@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@UFSlideWindowItem@@V?$xalloc@UFSlideWindowItem@@@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UFSlideWindowItem@@@std@@@std@@@2@XZ PROC ; std::vector<FSlideWindowItem,xalloc<FSlideWindowItem> >::end, COMDAT
; _this$ = ecx

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	ecx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax], ecx

; 1472 :         auto& _My_data = _Mypair._Myval2;
; 1473 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));
; 1474 :     }

	ret	4
?end@?$vector@UFSlideWindowItem@@V?$xalloc@UFSlideWindowItem@@@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UFSlideWindowItem@@@std@@@std@@@2@XZ ENDP ; std::vector<FSlideWindowItem,xalloc<FSlideWindowItem> >::end
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?resize@?$vector@UFSlideWindowItem@@V?$xalloc@UFSlideWindowItem@@@@@std@@QAEXI@Z
_TEXT	SEGMENT
$T1 = 8							; size = 1
__Newsize$ = 8						; size = 4
?resize@?$vector@UFSlideWindowItem@@V?$xalloc@UFSlideWindowItem@@@@@std@@QAEXI@Z PROC ; std::vector<FSlideWindowItem,xalloc<FSlideWindowItem> >::resize, COMDAT
; _this$ = ecx

; 1275 :     _CONSTEXPR20_CONTAINER void resize(_CRT_GUARDOVERFLOW const size_type _Newsize) {

	mov	edx, ecx

; 1251 :         if (_Newsize < _Oldsize) { // trim

	mov	ecx, DWORD PTR __Newsize$[esp-4]

; 1275 :     _CONSTEXPR20_CONTAINER void resize(_CRT_GUARDOVERFLOW const size_type _Newsize) {

	push	esi
	push	edi

; 1250 :         const auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);

	mov	eax, DWORD PTR [edx+4]
	mov	edi, DWORD PTR [edx]
	sub	eax, edi
	sar	eax, 3
	imul	esi, eax, -1431655765

; 1251 :         if (_Newsize < _Oldsize) { // trim

	cmp	ecx, esi
	jae	SHORT $LN4@resize

; 1252 :             const pointer _Newlast = _Myfirst + _Newsize;

	lea	eax, DWORD PTR [ecx+ecx*2]
	lea	eax, DWORD PTR [edi+eax*8]
	pop	edi

; 1276 :         // trim or append value-initialized elements, provide strong guarantee
; 1277 :         _Resize(_Newsize, _Value_init_tag{});
; 1278 :     }

	mov	DWORD PTR [edx+4], eax
	pop	esi
	ret	4
$LN4@resize:

; 1259 :         if (_Newsize > _Oldsize) { // append

	jbe	SHORT $LN5@resize

; 1260 :             const auto _Oldcapacity = static_cast<size_type>(_My_data._Myend - _Myfirst);

	mov	eax, DWORD PTR [edx+8]
	sub	eax, edi
	sar	eax, 3
	imul	eax, eax, -1431655765

; 1261 :             if (_Newsize > _Oldcapacity) { // reallocate

	cmp	ecx, eax
	jbe	SHORT $LN6@resize

; 1262 :                 _Resize_reallocate(_Newsize, _Val);

	lea	eax, DWORD PTR $T1[esp+4]
	push	eax
	push	ecx
	mov	ecx, edx
	call	??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UFSlideWindowItem@@V?$xalloc@UFSlideWindowItem@@@@@std@@AAEXIABU_Value_init_tag@1@@Z ; std::vector<FSlideWindowItem,xalloc<FSlideWindowItem> >::_Resize_reallocate<std::_Value_init_tag>
	pop	edi

; 1276 :         // trim or append value-initialized elements, provide strong guarantee
; 1277 :         _Resize(_Newsize, _Value_init_tag{});
; 1278 :     }

	pop	esi
	ret	4
$LN6@resize:

; 1267 :             _Mylast                = _Ufill(_Oldlast, _Newsize - _Oldsize, _Val);

	push	DWORD PTR $T1[esp+4]
	sub	ecx, esi
	push	ecx
	push	DWORD PTR [edx+4]
	call	?_Ufill@?$vector@UFSlideWindowItem@@V?$xalloc@UFSlideWindowItem@@@@@std@@AAEPAUFSlideWindowItem@@PAU3@IU_Value_init_tag@2@@Z ; std::vector<FSlideWindowItem,xalloc<FSlideWindowItem> >::_Ufill

; 1276 :         // trim or append value-initialized elements, provide strong guarantee
; 1277 :         _Resize(_Newsize, _Value_init_tag{});
; 1278 :     }

	mov	DWORD PTR [edx+4], eax
$LN5@resize:
	pop	edi
	pop	esi
	ret	4
?resize@?$vector@UFSlideWindowItem@@V?$xalloc@UFSlideWindowItem@@@@@std@@QAEXI@Z ENDP ; std::vector<FSlideWindowItem,xalloc<FSlideWindowItem> >::resize
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?clear_and_free@?$xr_vector@PAVIRender_Portal@@V?$xalloc@PAVIRender_Portal@@@@@@QAEXXZ
_TEXT	SEGMENT
?clear_and_free@?$xr_vector@PAVIRender_Portal@@V?$xalloc@PAVIRender_Portal@@@@@@QAEXXZ PROC ; xr_vector<IRender_Portal *,xalloc<IRender_Portal *> >::clear_and_free, COMDAT
; _this$ = ecx

; 127  : 	void	clear_and_free		()									{ inherited::clear();			}

	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [ecx+4], eax
	ret	0
?clear_and_free@?$xr_vector@PAVIRender_Portal@@V?$xalloc@PAVIRender_Portal@@@@@@QAEXXZ ENDP ; xr_vector<IRender_Portal *,xalloc<IRender_Portal *> >::clear_and_free
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?size@?$xr_vector@PAVIRender_Portal@@V?$xalloc@PAVIRender_Portal@@@@@@QBEIXZ
_TEXT	SEGMENT
?size@?$xr_vector@PAVIRender_Portal@@V?$xalloc@PAVIRender_Portal@@@@@@QBEIXZ PROC ; xr_vector<IRender_Portal *,xalloc<IRender_Portal *> >::size, COMDAT
; _this$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	eax, DWORD PTR [ecx+4]
	sub	eax, DWORD PTR [ecx]
	sar	eax, 2
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 125  : 	u32		size				() const							{ return (u32)inherited::size();} 

	ret	0
?size@?$xr_vector@PAVIRender_Portal@@V?$xalloc@PAVIRender_Portal@@@@@@QBEIXZ ENDP ; xr_vector<IRender_Portal *,xalloc<IRender_Portal *> >::size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?resize@?$vector@PAVIRender_Portal@@V?$xalloc@PAVIRender_Portal@@@@@std@@QAEXI@Z
_TEXT	SEGMENT
__Newsize$ = 8						; size = 4
?resize@?$vector@PAVIRender_Portal@@V?$xalloc@PAVIRender_Portal@@@@@std@@QAEXI@Z PROC ; std::vector<IRender_Portal *,xalloc<IRender_Portal *> >::resize, COMDAT
; _this$ = ecx

; 1275 :     _CONSTEXPR20_CONTAINER void resize(_CRT_GUARDOVERFLOW const size_type _Newsize) {

	push	ebx
	push	esi

; 1251 :         if (_Newsize < _Oldsize) { // trim

	mov	esi, DWORD PTR __Newsize$[esp+4]

; 1275 :     _CONSTEXPR20_CONTAINER void resize(_CRT_GUARDOVERFLOW const size_type _Newsize) {

	push	edi
	mov	edi, ecx

; 1250 :         const auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);

	mov	ebx, DWORD PTR [edi+4]
	mov	ecx, ebx
	mov	edx, DWORD PTR [edi]
	sub	ecx, edx
	sar	ecx, 2

; 1251 :         if (_Newsize < _Oldsize) { // trim

	cmp	esi, ecx
	jae	SHORT $LN4@resize

; 1252 :             const pointer _Newlast = _Myfirst + _Newsize;

	lea	eax, DWORD PTR [edx+esi*4]

; 1278 :     }

	mov	DWORD PTR [edi+4], eax
	pop	edi
	pop	esi
	pop	ebx
	ret	4
$LN4@resize:

; 1259 :         if (_Newsize > _Oldsize) { // append

	jbe	SHORT $LN5@resize

; 1260 :             const auto _Oldcapacity = static_cast<size_type>(_My_data._Myend - _Myfirst);

	mov	eax, DWORD PTR [edi+8]
	sub	eax, edx
	sar	eax, 2

; 1261 :             if (_Newsize > _Oldcapacity) { // reallocate

	cmp	esi, eax
	jbe	SHORT $LN6@resize

; 1262 :                 _Resize_reallocate(_Newsize, _Val);

	push	ecx
	push	esi
	mov	ecx, edi
	call	??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@PAVIRender_Portal@@V?$xalloc@PAVIRender_Portal@@@@@std@@AAEXIABU_Value_init_tag@1@@Z ; std::vector<IRender_Portal *,xalloc<IRender_Portal *> >::_Resize_reallocate<std::_Value_init_tag>
	pop	edi

; 1278 :     }

	pop	esi
	pop	ebx
	ret	4
$LN6@resize:

; 1267 :             _Mylast                = _Ufill(_Oldlast, _Newsize - _Oldsize, _Val);

	sub	esi, ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1807 :             _Zero_range(_PFirst, _PFirst + _Count);

	shl	esi, 2

; 1792 :     _CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

	push	esi
	push	0
	push	ebx
	call	_memset

; 1808 :             return _First + _Count;

	lea	eax, DWORD PTR [esi+ebx]

; 1792 :     _CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

	add	esp, 12					; 0000000cH
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1278 :     }

	mov	DWORD PTR [edi+4], eax
$LN5@resize:
	pop	edi
	pop	esi
	pop	ebx
	ret	4
?resize@?$vector@PAVIRender_Portal@@V?$xalloc@PAVIRender_Portal@@@@@std@@QAEXI@Z ENDP ; std::vector<IRender_Portal *,xalloc<IRender_Portal *> >::resize
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UFSlideWindowItem@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UFSlideWindowItem@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<FSlideWindowItem> > >::operator==, COMDAT
; _this$ = ecx

; 149  :         _Compat(_Right);
; 150  :         return _Ptr == _Right._Ptr;

	mov	eax, DWORD PTR __Right$[esp-4]
	mov	ecx, DWORD PTR [ecx]
	cmp	ecx, DWORD PTR [eax]
	sete	al

; 151  :     }

	ret	4
??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UFSlideWindowItem@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<FSlideWindowItem> > >::operator==
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UFSlideWindowItem@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UFSlideWindowItem@@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<FSlideWindowItem> > >::operator++, COMDAT
; _this$ = ecx

; 68   : #if _ITERATOR_DEBUG_LEVEL != 0
; 69   :         const auto _Mycont = static_cast<const _Myvec*>(this->_Getcont());
; 70   :         _STL_VERIFY(_Ptr, "can't increment value-initialized vector iterator");
; 71   :         _STL_VERIFY(_Ptr < _Mycont->_Mylast, "can't increment vector iterator past end");
; 72   : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 73   : 
; 74   :         ++_Ptr;

	add	DWORD PTR [ecx], 24			; 00000018H

; 75   :         return *this;

	mov	eax, ecx

; 76   :     }

	ret	0
??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UFSlideWindowItem@@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<FSlideWindowItem> > >::operator++
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?size@?$vector@PAUIDirect3DIndexBuffer9@@V?$xalloc@PAUIDirect3DIndexBuffer9@@@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@PAUIDirect3DIndexBuffer9@@V?$xalloc@PAUIDirect3DIndexBuffer9@@@@@std@@QBEIXZ PROC ; std::vector<IDirect3DIndexBuffer9 *,xalloc<IDirect3DIndexBuffer9 *> >::size, COMDAT
; _this$ = ecx

; 1535 :         auto& _My_data = _Mypair._Myval2;
; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	eax, DWORD PTR [ecx+4]
	sub	eax, DWORD PTR [ecx]
	sar	eax, 2

; 1537 :     }

	ret	0
?size@?$vector@PAUIDirect3DIndexBuffer9@@V?$xalloc@PAUIDirect3DIndexBuffer9@@@@@std@@QBEIXZ ENDP ; std::vector<IDirect3DIndexBuffer9 *,xalloc<IDirect3DIndexBuffer9 *> >::size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?clear@?$vector@PAUIDirect3DIndexBuffer9@@V?$xalloc@PAUIDirect3DIndexBuffer9@@@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$vector@PAUIDirect3DIndexBuffer9@@V?$xalloc@PAUIDirect3DIndexBuffer9@@@@@std@@QAEXXZ PROC ; std::vector<IDirect3DIndexBuffer9 *,xalloc<IDirect3DIndexBuffer9 *> >::clear, COMDAT
; _this$ = ecx

; 1437 :         auto& _My_data    = _Mypair._Myval2;
; 1438 :         pointer& _Myfirst = _My_data._Myfirst;
; 1439 :         pointer& _Mylast  = _My_data._Mylast;
; 1440 : 
; 1441 :         _My_data._Orphan_all();
; 1442 :         _Destroy(_Myfirst, _Mylast);
; 1443 :         _Mylast = _Myfirst;

	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [ecx+4], eax

; 1444 :     }

	ret	0
?clear@?$vector@PAUIDirect3DIndexBuffer9@@V?$xalloc@PAUIDirect3DIndexBuffer9@@@@@std@@QAEXXZ ENDP ; std::vector<IDirect3DIndexBuffer9 *,xalloc<IDirect3DIndexBuffer9 *> >::clear
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?size@?$vector@PAUIDirect3DVertexBuffer9@@V?$xalloc@PAUIDirect3DVertexBuffer9@@@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@PAUIDirect3DVertexBuffer9@@V?$xalloc@PAUIDirect3DVertexBuffer9@@@@@std@@QBEIXZ PROC ; std::vector<IDirect3DVertexBuffer9 *,xalloc<IDirect3DVertexBuffer9 *> >::size, COMDAT
; _this$ = ecx

; 1535 :         auto& _My_data = _Mypair._Myval2;
; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	eax, DWORD PTR [ecx+4]
	sub	eax, DWORD PTR [ecx]
	sar	eax, 2

; 1537 :     }

	ret	0
?size@?$vector@PAUIDirect3DVertexBuffer9@@V?$xalloc@PAUIDirect3DVertexBuffer9@@@@@std@@QBEIXZ ENDP ; std::vector<IDirect3DVertexBuffer9 *,xalloc<IDirect3DVertexBuffer9 *> >::size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?clear@?$vector@PAUIDirect3DVertexBuffer9@@V?$xalloc@PAUIDirect3DVertexBuffer9@@@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$vector@PAUIDirect3DVertexBuffer9@@V?$xalloc@PAUIDirect3DVertexBuffer9@@@@@std@@QAEXXZ PROC ; std::vector<IDirect3DVertexBuffer9 *,xalloc<IDirect3DVertexBuffer9 *> >::clear, COMDAT
; _this$ = ecx

; 1437 :         auto& _My_data    = _Mypair._Myval2;
; 1438 :         pointer& _Myfirst = _My_data._Myfirst;
; 1439 :         pointer& _Mylast  = _My_data._Mylast;
; 1440 : 
; 1441 :         _My_data._Orphan_all();
; 1442 :         _Destroy(_Myfirst, _Mylast);
; 1443 :         _Mylast = _Myfirst;

	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [ecx+4], eax

; 1444 :     }

	ret	0
?clear@?$vector@PAUIDirect3DVertexBuffer9@@V?$xalloc@PAUIDirect3DVertexBuffer9@@@@@std@@QAEXXZ ENDP ; std::vector<IDirect3DVertexBuffer9 *,xalloc<IDirect3DVertexBuffer9 *> >::clear
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?clear@?$vector@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@V?$xalloc@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$vector@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@V?$xalloc@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@@@std@@QAEXXZ PROC ; std::vector<svector<_D3DVERTEXELEMENT9,65>,xalloc<svector<_D3DVERTEXELEMENT9,65> > >::clear, COMDAT
; _this$ = ecx

; 1437 :         auto& _My_data    = _Mypair._Myval2;
; 1438 :         pointer& _Myfirst = _My_data._Myfirst;
; 1439 :         pointer& _Mylast  = _My_data._Mylast;
; 1440 : 
; 1441 :         _My_data._Orphan_all();
; 1442 :         _Destroy(_Myfirst, _Mylast);
; 1443 :         _Mylast = _Myfirst;

	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [ecx+4], eax

; 1444 :     }

	ret	0
?clear@?$vector@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@V?$xalloc@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@@@std@@QAEXXZ ENDP ; std::vector<svector<_D3DVERTEXELEMENT9,65>,xalloc<svector<_D3DVERTEXELEMENT9,65> > >::clear
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?clear@?$vector@V?$resptr_core@UShader@@Uresptrcode_shader@@@@V?$xalloc@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$vector@V?$resptr_core@UShader@@Uresptrcode_shader@@@@V?$xalloc@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@@@std@@QAEXXZ PROC ; std::vector<resptr_core<Shader,resptrcode_shader>,xalloc<resptr_core<Shader,resptrcode_shader> > >::clear, COMDAT
; _this$ = ecx

; 1437 :         auto& _My_data    = _Mypair._Myval2;
; 1438 :         pointer& _Myfirst = _My_data._Myfirst;
; 1439 :         pointer& _Mylast  = _My_data._Mylast;
; 1440 : 
; 1441 :         _My_data._Orphan_all();
; 1442 :         _Destroy(_Myfirst, _Mylast);
; 1443 :         _Mylast = _Myfirst;

	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [ecx+4], eax

; 1444 :     }

	ret	0
?clear@?$vector@V?$resptr_core@UShader@@Uresptrcode_shader@@@@V?$xalloc@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@@@std@@QAEXXZ ENDP ; std::vector<resptr_core<Shader,resptrcode_shader>,xalloc<resptr_core<Shader,resptrcode_shader> > >::clear
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?clear_and_free@?$xr_vector@UFSlideWindowItem@@V?$xalloc@UFSlideWindowItem@@@@@@QAEXXZ
_TEXT	SEGMENT
?clear_and_free@?$xr_vector@UFSlideWindowItem@@V?$xalloc@UFSlideWindowItem@@@@@@QAEXXZ PROC ; xr_vector<FSlideWindowItem,xalloc<FSlideWindowItem> >::clear_and_free, COMDAT
; _this$ = ecx

; 127  : 	void	clear_and_free		()									{ inherited::clear();			}

	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [ecx+4], eax
	ret	0
?clear_and_free@?$xr_vector@UFSlideWindowItem@@V?$xalloc@UFSlideWindowItem@@@@@@QAEXXZ ENDP ; xr_vector<FSlideWindowItem,xalloc<FSlideWindowItem> >::clear_and_free
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?size@?$vector@UFSlideWindowItem@@V?$xalloc@UFSlideWindowItem@@@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@UFSlideWindowItem@@V?$xalloc@UFSlideWindowItem@@@@@std@@QBEIXZ PROC ; std::vector<FSlideWindowItem,xalloc<FSlideWindowItem> >::size, COMDAT
; _this$ = ecx

; 1535 :         auto& _My_data = _Mypair._Myval2;
; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	eax, DWORD PTR [ecx+4]
	sub	eax, DWORD PTR [ecx]
	sar	eax, 3
	imul	eax, eax, -1431655765

; 1537 :     }

	ret	0
?size@?$vector@UFSlideWindowItem@@V?$xalloc@UFSlideWindowItem@@@@@std@@QBEIXZ ENDP ; std::vector<FSlideWindowItem,xalloc<FSlideWindowItem> >::size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?erase@?$vector@UFSlideWindowItem@@V?$xalloc@UFSlideWindowItem@@@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UFSlideWindowItem@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UFSlideWindowItem@@@std@@@std@@@2@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
?erase@?$vector@UFSlideWindowItem@@V?$xalloc@UFSlideWindowItem@@@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UFSlideWindowItem@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UFSlideWindowItem@@@std@@@std@@@2@0@Z PROC ; std::vector<FSlideWindowItem,xalloc<FSlideWindowItem> >::erase, COMDAT
; _this$ = ecx

; 1414 :         const pointer _Firstptr = _First._Ptr;
; 1415 :         const pointer _Lastptr  = _Last._Ptr;
; 1416 :         auto& _My_data          = _Mypair._Myval2;
; 1417 :         pointer& _Mylast        = _My_data._Mylast;

	mov	eax, DWORD PTR __Last$[esp-4]
	push	ebx
	push	edi
	mov	edi, DWORD PTR __First$[esp+4]
	mov	ebx, ecx
	cmp	edi, eax

; 1418 : 
; 1419 : #if _ITERATOR_DEBUG_LEVEL == 2
; 1420 :         _STL_VERIFY(_First._Getcont() == _STD addressof(_My_data) && _Last._Getcont() == _STD addressof(_My_data)
; 1421 :                         && _Firstptr >= _My_data._Myfirst && _Lastptr >= _Firstptr && _Mylast >= _Lastptr,
; 1422 :             "vector erase iterator outside range");
; 1423 : #endif // _ITERATOR_DEBUG_LEVEL == 2
; 1424 : 
; 1425 :         if (_Firstptr != _Lastptr) { // something to do, invalidate iterators

	je	SHORT $LN15@erase
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility

; 4065 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	push	esi
	mov	esi, DWORD PTR [ebx+4]
	sub	esi, eax

; 4066 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	push	esi
	push	eax
	push	edi
	call	_memmove
	add	esp, 12					; 0000000cH

; 4067 :     if constexpr (is_pointer_v<_OutCtgIt>) {
; 4068 :         return reinterpret_cast<_OutCtgIt>(_Dest_ch + _Count);

	lea	eax, DWORD PTR [edi+esi]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1430 :             _Mylast = _Newlast;

	mov	DWORD PTR [ebx+4], eax

; 1431 :         }
; 1432 : 
; 1433 :         return iterator(_Firstptr, _STD addressof(_My_data));

	pop	esi
$LN15@erase:

; 1434 :     }

	mov	eax, DWORD PTR ___$ReturnUdt$[esp+4]
	mov	DWORD PTR [eax], edi
	pop	edi
	pop	ebx
	ret	12					; 0000000cH
?erase@?$vector@UFSlideWindowItem@@V?$xalloc@UFSlideWindowItem@@@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UFSlideWindowItem@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UFSlideWindowItem@@@std@@@std@@@2@0@Z ENDP ; std::vector<FSlideWindowItem,xalloc<FSlideWindowItem> >::erase
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?size@?$vector@PAVIRender_Portal@@V?$xalloc@PAVIRender_Portal@@@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@PAVIRender_Portal@@V?$xalloc@PAVIRender_Portal@@@@@std@@QBEIXZ PROC ; std::vector<IRender_Portal *,xalloc<IRender_Portal *> >::size, COMDAT
; _this$ = ecx

; 1535 :         auto& _My_data = _Mypair._Myval2;
; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	eax, DWORD PTR [ecx+4]
	sub	eax, DWORD PTR [ecx]
	sar	eax, 2

; 1537 :     }

	ret	0
?size@?$vector@PAVIRender_Portal@@V?$xalloc@PAVIRender_Portal@@@@@std@@QBEIXZ ENDP ; std::vector<IRender_Portal *,xalloc<IRender_Portal *> >::size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?clear@?$vector@PAVIRender_Portal@@V?$xalloc@PAVIRender_Portal@@@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$vector@PAVIRender_Portal@@V?$xalloc@PAVIRender_Portal@@@@@std@@QAEXXZ PROC ; std::vector<IRender_Portal *,xalloc<IRender_Portal *> >::clear, COMDAT
; _this$ = ecx

; 1437 :         auto& _My_data    = _Mypair._Myval2;
; 1438 :         pointer& _Myfirst = _My_data._Myfirst;
; 1439 :         pointer& _Mylast  = _My_data._Mylast;
; 1440 : 
; 1441 :         _My_data._Orphan_all();
; 1442 :         _Destroy(_Myfirst, _Mylast);
; 1443 :         _Mylast = _Myfirst;

	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [ecx+4], eax

; 1444 :     }

	ret	0
?clear@?$vector@PAVIRender_Portal@@V?$xalloc@PAVIRender_Portal@@@@@std@@QAEXXZ ENDP ; std::vector<IRender_Portal *,xalloc<IRender_Portal *> >::clear
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UFSlideWindowItem@@@std@@@std@@@std@@QBEXABV12@@Z
_TEXT	SEGMENT
__Right$dead$ = 8					; size = 4
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UFSlideWindowItem@@@std@@@std@@@std@@QBEXABV12@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<FSlideWindowItem> > >::_Compat, COMDAT
; _this$dead$ = ecx

; 182  :         // test for compatible iterator pair
; 183  : #if _ITERATOR_DEBUG_LEVEL == 0
; 184  :         (void) _Right;
; 185  : #else // ^^^ _ITERATOR_DEBUG_LEVEL == 0 ^^^ // vvv _ITERATOR_DEBUG_LEVEL != 0 vvv
; 186  :         _STL_VERIFY(this->_Getcont() == _Right._Getcont(), "vector iterators incompatible");
; 187  : #endif // _ITERATOR_DEBUG_LEVEL == 0
; 188  :     }

	ret	4
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UFSlideWindowItem@@@std@@@std@@@std@@QBEXABV12@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<FSlideWindowItem> > >::_Compat
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Orphan_range@?$vector@UFSlideWindowItem@@V?$xalloc@UFSlideWindowItem@@@@@std@@ABEXPAUFSlideWindowItem@@0@Z
_TEXT	SEGMENT
___formal$dead$ = 8					; size = 4
___formal$dead$ = 12					; size = 4
?_Orphan_range@?$vector@UFSlideWindowItem@@V?$xalloc@UFSlideWindowItem@@@@@std@@ABEXPAUFSlideWindowItem@@0@Z PROC ; std::vector<FSlideWindowItem,xalloc<FSlideWindowItem> >::_Orphan_range, COMDAT
; _this$dead$ = ecx

; 1801 :     _CONSTEXPR20_CONTAINER void _Orphan_range(pointer, pointer) const {}

	ret	8
?_Orphan_range@?$vector@UFSlideWindowItem@@V?$xalloc@UFSlideWindowItem@@@@@std@@ABEXPAUFSlideWindowItem@@0@Z ENDP ; std::vector<FSlideWindowItem,xalloc<FSlideWindowItem> >::_Orphan_range
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?clear@?$vector@UFSlideWindowItem@@V?$xalloc@UFSlideWindowItem@@@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$vector@UFSlideWindowItem@@V?$xalloc@UFSlideWindowItem@@@@@std@@QAEXXZ PROC ; std::vector<FSlideWindowItem,xalloc<FSlideWindowItem> >::clear, COMDAT
; _this$ = ecx

; 1437 :         auto& _My_data    = _Mypair._Myval2;
; 1438 :         pointer& _Myfirst = _My_data._Myfirst;
; 1439 :         pointer& _Mylast  = _My_data._Mylast;
; 1440 : 
; 1441 :         _My_data._Orphan_all();
; 1442 :         _Destroy(_Myfirst, _Mylast);
; 1443 :         _Mylast = _Myfirst;

	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [ecx+4], eax

; 1444 :     }

	ret	0
?clear@?$vector@UFSlideWindowItem@@V?$xalloc@UFSlideWindowItem@@@@@std@@QAEXXZ ENDP ; std::vector<FSlideWindowItem,xalloc<FSlideWindowItem> >::clear
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
;	COMDAT ??$xr_new@VCLightShadows@@@@YAPAVCLightShadows@@XZ
_TEXT	SEGMENT
??$xr_new@VCLightShadows@@@@YAPAVCLightShadows@@XZ PROC	; xr_new<CLightShadows>, COMDAT

; 68   : 	T* ptr	= (T*)Memory.mem_alloc(sizeof(T));

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	124					; 0000007cH
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z

; 69   : 	return new (ptr) T();

	mov	ecx, eax
	jmp	??0CLightShadows@@QAE@XZ		; CLightShadows::CLightShadows
??$xr_new@VCLightShadows@@@@YAPAVCLightShadows@@XZ ENDP	; xr_new<CLightShadows>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
;	COMDAT ??$xr_new@VCLightProjector@@@@YAPAVCLightProjector@@XZ
_TEXT	SEGMENT
??$xr_new@VCLightProjector@@@@YAPAVCLightProjector@@XZ PROC ; xr_new<CLightProjector>, COMDAT

; 68   : 	T* ptr	= (T*)Memory.mem_alloc(sizeof(T));

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	60					; 0000003cH
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z

; 69   : 	return new (ptr) T();

	mov	ecx, eax
	jmp	??0CLightProjector@@QAE@XZ		; CLightProjector::CLightProjector
??$xr_new@VCLightProjector@@@@YAPAVCLightProjector@@XZ ENDP ; xr_new<CLightProjector>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
;	COMDAT ??$xr_new@VCLight_DB@@@@YAPAVCLight_DB@@XZ
_TEXT	SEGMENT
??$xr_new@VCLight_DB@@@@YAPAVCLight_DB@@XZ PROC		; xr_new<CLight_DB>, COMDAT

; 68   : 	T* ptr	= (T*)Memory.mem_alloc(sizeof(T));

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	56					; 00000038H
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [eax], 0
	mov	DWORD PTR [eax+4], 0
	mov	DWORD PTR [eax+8], 0
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 61   : 						resptr_core		()												{	p_ = 0;						}

	mov	DWORD PTR [eax+12], 0
	mov	DWORD PTR [eax+16], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [eax+20], 0
	mov	DWORD PTR [eax+24], 0
	mov	DWORD PTR [eax+28], 0
	mov	DWORD PTR [eax+32], 0
	mov	DWORD PTR [eax+36], 0
	mov	DWORD PTR [eax+40], 0
	mov	DWORD PTR [eax+44], 0
	mov	DWORD PTR [eax+48], 0
	mov	DWORD PTR [eax+52], 0
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h

; 70   : }

	ret	0
??$xr_new@VCLight_DB@@@@YAPAVCLight_DB@@XZ ENDP		; xr_new<CLight_DB>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
;	COMDAT ??$xr_new@VCGlowManager@@@@YAPAVCGlowManager@@XZ
_TEXT	SEGMENT
??$xr_new@VCGlowManager@@@@YAPAVCGlowManager@@XZ PROC	; xr_new<CGlowManager>, COMDAT

; 68   : 	T* ptr	= (T*)Memory.mem_alloc(sizeof(T));

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	72					; 00000048H
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [eax], 0
	mov	DWORD PTR [eax+4], 0
	mov	DWORD PTR [eax+8], 0
	mov	DWORD PTR [eax+12], 0
	mov	DWORD PTR [eax+16], 0
	mov	DWORD PTR [eax+20], 0
	mov	DWORD PTR [eax+24], 0
	mov	DWORD PTR [eax+28], 0
	mov	DWORD PTR [eax+32], 0
	mov	DWORD PTR [eax+36], 0
	mov	DWORD PTR [eax+40], 0
	mov	DWORD PTR [eax+44], 0
	mov	DWORD PTR [eax+48], 0
	mov	DWORD PTR [eax+52], 0
	mov	DWORD PTR [eax+56], 0
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 61   : 						resptr_core		()												{	p_ = 0;						}

	mov	DWORD PTR [eax+60], 0
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h

; 70   : }

	ret	0
??$xr_new@VCGlowManager@@@@YAPAVCGlowManager@@XZ ENDP	; xr_new<CGlowManager>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File I:\Vitalya\mine\NSProjectX\xrCore\FixedVector.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
;	COMDAT ??$xr_new@VCWallmarksEngine@@@@YAPAVCWallmarksEngine@@XZ
_TEXT	SEGMENT
??$xr_new@VCWallmarksEngine@@@@YAPAVCWallmarksEngine@@XZ PROC ; xr_new<CWallmarksEngine>, COMDAT

; 68   : 	T* ptr	= (T*)Memory.mem_alloc(sizeof(T));

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	ebx
	push	esi
	push	edi
	push	1508					; 000005e4H
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z

; 69   : 	return new (ptr) T();

	mov	esi, eax
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp

; 53   : {

	lea	ecx, DWORD PTR [esi+1444]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [esi], 0
	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	mov	DWORD PTR [esi+16], 0
	mov	DWORD PTR [esi+20], 0
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 61   : 						resptr_core		()												{	p_ = 0;						}

	mov	DWORD PTR [esi+24], 0
; File I:\Vitalya\mine\NSProjectX\xrCore\FixedVector.h

; 21   : 	svector() : count(0) 

	mov	DWORD PTR [esi+860], 0
	mov	DWORD PTR [esi+1440], 0
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp

; 53   : {

	call	DWORD PTR __imp_??0xrXRC@@QAE@XZ
	lea	ecx, DWORD PTR [esi+1468]
	call	DWORD PTR __imp_??0Collector@CDB@@QAE@XZ
	lea	ecx, DWORD PTR [esi+1504]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [esi+1492], 0
	mov	DWORD PTR [esi+1496], 0
	mov	DWORD PTR [esi+1500], 0
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp

; 53   : {

	call	DWORD PTR __imp_??0xrCriticalSection@@QAE@XZ
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1546 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	eax, DWORD PTR [esi+8]
	sub	eax, DWORD PTR [esi]
	sar	eax, 2

; 1358 :         if (_Newcapacity > capacity()) { // something to do (reserve() never shrinks)

	cmp	eax, 256				; 00000100H
	jae	SHORT $LN36@xr_new

; 1359 :             if (_Newcapacity > max_size()) {
; 1360 :                 _Xlength();
; 1361 :             }
; 1362 : 
; 1363 :             _Reallocate_exactly(_Newcapacity);

	push	ecx
	mov	ecx, esi
	call	?_Reallocate_exactly@?$vector@PAUstatic_wallmark@CWallmarksEngine@@V?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@@std@@AAEXI@Z ; std::vector<CWallmarksEngine::static_wallmark *,xalloc<CWallmarksEngine::static_wallmark *> >::_Reallocate_exactly
$LN36@xr_new:

; 1546 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	eax, DWORD PTR [esi+20]
	sub	eax, DWORD PTR [esi+12]
	sar	eax, 2

; 1358 :         if (_Newcapacity > capacity()) { // something to do (reserve() never shrinks)

	cmp	eax, 256				; 00000100H
	jae	SHORT $LN43@xr_new

; 1359 :             if (_Newcapacity > max_size()) {
; 1360 :                 _Xlength();
; 1361 :             }
; 1362 : 
; 1363 :             _Reallocate_exactly(_Newcapacity);

	push	ecx
	lea	ecx, DWORD PTR [esi+12]
	call	?_Reallocate_exactly@?$vector@PAUwm_slot@WallmarksEngine@@V?$xalloc@PAUwm_slot@WallmarksEngine@@@@@std@@AAEXI@Z ; std::vector<WallmarksEngine::wm_slot *,xalloc<WallmarksEngine::wm_slot *> >::_Reallocate_exactly
$LN43@xr_new:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp

; 56   : 	hGeom.create			(FVF::F_LIT, RCache.Vertex.Buffer(), NULL);

	mov	eax, DWORD PTR __imp_?RCache@@3VCBackend@@A
	lea	ecx, DWORD PTR [esi+24]
	push	0
	push	DWORD PTR [eax]
	push	322					; 00000142H
	call	DWORD PTR __imp_?create@resptrcode_geom@@QAEXIPAUIDirect3DVertexBuffer9@@PAUIDirect3DIndexBuffer9@@@Z
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h

; 69   : 	return new (ptr) T();

	pop	edi
	mov	eax, esi
	pop	esi
	pop	ebx

; 70   : }

	ret	0
??$xr_new@VCWallmarksEngine@@@@YAPAVCWallmarksEngine@@XZ ENDP ; xr_new<CWallmarksEngine>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\FixedVector.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\detailmanager.h
; File I:\Vitalya\mine\NSProjectX\xrCore\FixedVector.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\detailmanager.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrPool.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
;	COMDAT ??$xr_new@VCDetailManager@@@@YAPAVCDetailManager@@XZ
_TEXT	SEGMENT
$T1 = -8						; size = 4
$T2 = -4						; size = 4
??$xr_new@VCDetailManager@@@@YAPAVCDetailManager@@XZ PROC ; xr_new<CDetailManager>, COMDAT

; 68   : 	T* ptr	= (T*)Memory.mem_alloc(sizeof(T));

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	sub	esp, 8
	push	ebx
	push	esi
	push	edi
	push	701284					; 000ab364H
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z

; 69   : 	return new (ptr) T();

	mov	ebx, eax
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager.cpp

; 76   : {

	mov	DWORD PTR [ebx], OFFSET ??_7CDetailManager@@6B@
	lea	ecx, DWORD PTR [ebx+1432]
; File I:\Vitalya\mine\NSProjectX\xrCore\FixedVector.h

; 21   : 	svector() : count(0) 

	mov	DWORD PTR [ebx+1392], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ebx+1396], 0
	mov	DWORD PTR [ebx+1408], 0
	mov	DWORD PTR [ebx+1400], 0
	mov	DWORD PTR [ebx+1404], 0
	mov	DWORD PTR [ebx+1412], 0
	mov	DWORD PTR [ebx+1416], 0
	mov	DWORD PTR [ebx+1420], 0
	mov	DWORD PTR [ebx+1424], 0
	mov	DWORD PTR [ebx+1428], 0
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager.cpp

; 76   : {

	call	DWORD PTR __imp_??0xrXRC@@QAE@XZ
	lea	eax, DWORD PTR [ebx+1456]
	mov	edx, 144				; 00000090H
	npad	6
$LL20@xr_new:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\detailmanager.h

; 73   : 		CacheSlot1()				{empty=1; vis.clear();}

	lea	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [eax], 1
	call	?clear@vis_data@@QAEXXZ			; vis_data::clear
	lea	eax, DWORD PTR [eax+124]
	sub	edx, 1
	jne	SHORT $LL20@xr_new
; File I:\Vitalya\mine\NSProjectX\xrCore\FixedVector.h

; 21   : 	svector() : count(0) 

	mov	DWORD PTR [ebx+38520], edx
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager.cpp

; 76   : {

	lea	esi, DWORD PTR [ebx+38524]
	mov	edi, 2401				; 00000961H
$LL28@xr_new:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\detailmanager.h

; 67   : 									Slot()				{ frame=0;empty=1; type=stReady; sx=sz=0; vis.clear(); }

	push	OFFSET ??0SlotPart@CDetailManager@@QAE@XZ
	push	4
	push	52					; 00000034H
	lea	eax, DWORD PTR [esi+68]
	push	eax
	call	??_H@YGXPAXIIP6EPAX0@Z@Z
	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR [esi], 1
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+4], 0
	call	?clear@vis_data@@QAEXXZ			; vis_data::clear
	lea	esi, DWORD PTR [esi+276]
	sub	edi, 1
	jne	SHORT $LL28@xr_new
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager.cpp

; 76   : {

	lea	ecx, DWORD PTR [ebx+701272]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ebx+701212], edi
	mov	DWORD PTR [ebx+701216], edi
	mov	DWORD PTR [ebx+701220], edi
; File I:\Vitalya\mine\NSProjectX\xrCore\xrPool.h

; 31   : 		list				= 0;

	mov	DWORD PTR [ebx+701208], edi
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 61   : 						resptr_core		()												{	p_ = 0;						}

	mov	DWORD PTR [ebx+701224], edi
	mov	DWORD PTR [ebx+701228], edi
	mov	DWORD PTR [ebx+701244], edi
	mov	DWORD PTR [ebx+701248], edi
	mov	DWORD PTR [ebx+701252], edi
	mov	DWORD PTR [ebx+701256], edi
	mov	DWORD PTR [ebx+701260], edi
	mov	DWORD PTR [ebx+701264], edi
	mov	DWORD PTR [ebx+701268], edi
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager.cpp

; 76   : {

	call	DWORD PTR __imp_??0xrCriticalSection@@QAE@XZ
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 46   : 	ICF		void		_set	(T * rhs) 							{	if (0!=rhs) rhs->dwReference++;	_dec(); p_ = rhs;											}

	lea	ecx, DWORD PTR [ebx+701224]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager.cpp

; 77   : 	dtFS 		= 0;

	mov	DWORD PTR [ebx+1088], edi

; 78   : 	dtSlots		= 0;

	mov	DWORD PTR [ebx+1116], edi
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 62   : 						resptr_core		(T * p, bool add_ref = true) 					{	p_ = p;	if(add_ref)	_inc(); }

	mov	DWORD PTR $T1[esp+20], edi

; 46   : 	ICF		void		_set	(T * rhs) 							{	if (0!=rhs) rhs->dwReference++;	_dec(); p_ = rhs;											}

	call	DWORD PTR __imp_?_dec@?$resptr_base@USGeometry@@@@IAEXXZ

; 64   : 						~resptr_core	()												{	_dec();						}

	lea	ecx, DWORD PTR $T1[esp+20]

; 46   : 	ICF		void		_set	(T * rhs) 							{	if (0!=rhs) rhs->dwReference++;	_dec(); p_ = rhs;											}

	mov	DWORD PTR [ebx+701224], edi

; 64   : 						~resptr_core	()												{	_dec();						}

	call	DWORD PTR __imp_?_dec@?$resptr_base@USGeometry@@@@IAEXXZ

; 46   : 	ICF		void		_set	(T * rhs) 							{	if (0!=rhs) rhs->dwReference++;	_dec(); p_ = rhs;											}

	lea	ecx, DWORD PTR [ebx+701228]

; 62   : 						resptr_core		(T * p, bool add_ref = true) 					{	p_ = p;	if(add_ref)	_inc(); }

	mov	DWORD PTR $T2[esp+20], edi

; 46   : 	ICF		void		_set	(T * rhs) 							{	if (0!=rhs) rhs->dwReference++;	_dec(); p_ = rhs;											}

	call	DWORD PTR __imp_?_dec@?$resptr_base@USGeometry@@@@IAEXXZ

; 64   : 						~resptr_core	()												{	_dec();						}

	lea	ecx, DWORD PTR $T2[esp+20]

; 46   : 	ICF		void		_set	(T * rhs) 							{	if (0!=rhs) rhs->dwReference++;	_dec(); p_ = rhs;											}

	mov	DWORD PTR [ebx+701228], edi

; 64   : 						~resptr_core	()												{	_dec();						}

	call	DWORD PTR __imp_?_dec@?$resptr_base@USGeometry@@@@IAEXXZ
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager.cpp

; 81   : 	hw_BatchSize= 0;

	mov	DWORD PTR [ebx+701232], edi
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h

; 69   : 	return new (ptr) T();

	mov	eax, ebx
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager.cpp

; 82   : 	hw_VB		= 0;

	mov	DWORD PTR [ebx+701236], edi

; 83   : 	hw_IB		= 0;

	mov	DWORD PTR [ebx+701240], edi
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h

; 69   : 	return new (ptr) T();

	pop	edi
	pop	esi
	pop	ebx

; 70   : }

	add	esp, 8
	ret	0
??$xr_new@VCDetailManager@@@@YAPAVCDetailManager@@XZ ENDP ; xr_new<CDetailManager>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
;	COMDAT ??$xr_delete@VIRender_Sector@@@@YAXAAPAVIRender_Sector@@@Z
_TEXT	SEGMENT
??$xr_delete@VIRender_Sector@@@@YAXAAPAVIRender_Sector@@@Z PROC ; xr_delete<IRender_Sector>, COMDAT
; _ptr$ = ecx

; 150  : {

	push	edi
	mov	edi, ecx

; 151  : 	if (ptr) 

	mov	eax, DWORD PTR [edi]
	test	eax, eax
	je	SHORT $LN2@xr_delete

; 132  : 		void*	_real_ptr	= dynamic_cast<void*>(ptr);

	push	esi
	push	eax
	call	___RTCastToVoid

; 133  : 		ptr->~T			();

	mov	ecx, DWORD PTR [edi]
	add	esp, 4
	mov	esi, eax
	mov	edx, DWORD PTR [ecx]
	push	0
	call	DWORD PTR [edx]

; 134  : 		Memory.mem_free	(_real_ptr);

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	esi
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z

; 152  : 	{
; 153  : 		xr_special_free<is_polymorphic<T>::result,T>()(ptr);
; 154  : 		ptr = nullptr;

	mov	DWORD PTR [edi], 0
	pop	esi
$LN2@xr_delete:

; 155  : 	}
; 156  : }

	pop	edi
	ret	0
??$xr_delete@VIRender_Sector@@@@YAXAAPAVIRender_Sector@@@Z ENDP ; xr_delete<IRender_Sector>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
;	COMDAT ??$xr_delete@VIRender_Portal@@@@YAXAAPAVIRender_Portal@@@Z
_TEXT	SEGMENT
??$xr_delete@VIRender_Portal@@@@YAXAAPAVIRender_Portal@@@Z PROC ; xr_delete<IRender_Portal>, COMDAT
; _ptr$ = ecx

; 150  : {

	push	edi
	mov	edi, ecx

; 151  : 	if (ptr) 

	mov	eax, DWORD PTR [edi]
	test	eax, eax
	je	SHORT $LN2@xr_delete

; 132  : 		void*	_real_ptr	= dynamic_cast<void*>(ptr);

	push	esi
	push	eax
	call	___RTCastToVoid

; 133  : 		ptr->~T			();

	mov	ecx, DWORD PTR [edi]
	add	esp, 4
	mov	esi, eax
	mov	edx, DWORD PTR [ecx]
	push	0
	call	DWORD PTR [edx]

; 134  : 		Memory.mem_free	(_real_ptr);

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	esi
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z

; 152  : 	{
; 153  : 		xr_special_free<is_polymorphic<T>::result,T>()(ptr);
; 154  : 		ptr = nullptr;

	mov	DWORD PTR [edi], 0
	pop	esi
$LN2@xr_delete:

; 155  : 	}
; 156  : }

	pop	edi
	ret	0
??$xr_delete@VIRender_Portal@@@@YAXAAPAVIRender_Portal@@@Z ENDP ; xr_delete<IRender_Portal>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
;	COMDAT ??$xr_delete@VCDetailManager@@@@YAXAAPAVCDetailManager@@@Z
_TEXT	SEGMENT
??$xr_delete@VCDetailManager@@@@YAXAAPAVCDetailManager@@@Z PROC ; xr_delete<CDetailManager>, COMDAT
; _ptr$ = ecx

; 150  : {

	push	edi
	mov	edi, ecx

; 151  : 	if (ptr) 

	mov	eax, DWORD PTR [edi]
	test	eax, eax
	je	SHORT $LN2@xr_delete

; 132  : 		void*	_real_ptr	= dynamic_cast<void*>(ptr);

	push	esi
	push	eax
	call	___RTCastToVoid

; 133  : 		ptr->~T			();

	mov	ecx, DWORD PTR [edi]
	add	esp, 4
	mov	esi, eax
	mov	edx, DWORD PTR [ecx]
	push	0
	call	DWORD PTR [edx]

; 134  : 		Memory.mem_free	(_real_ptr);

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	esi
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z

; 152  : 	{
; 153  : 		xr_special_free<is_polymorphic<T>::result,T>()(ptr);
; 154  : 		ptr = nullptr;

	mov	DWORD PTR [edi], 0
	pop	esi
$LN2@xr_delete:

; 155  : 	}
; 156  : }

	pop	edi
	ret	0
??$xr_delete@VCDetailManager@@@@YAXAAPAVCDetailManager@@@Z ENDP ; xr_delete<CDetailManager>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
;	COMDAT ??$xr_delete@VCWallmarksEngine@@@@YAXAAPAVCWallmarksEngine@@@Z
_TEXT	SEGMENT
??$xr_delete@VCWallmarksEngine@@@@YAXAAPAVCWallmarksEngine@@@Z PROC ; xr_delete<CWallmarksEngine>, COMDAT
; _ptr$ = ecx

; 150  : {

	push	esi
	push	edi
	mov	edi, ecx

; 151  : 	if (ptr) 

	mov	esi, DWORD PTR [edi]
	test	esi, esi
	je	$LN2@xr_delete
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp

; 61   : 	clear			();

	push	ebx
	push	ebp
	mov	ecx, esi
	call	?clear@CWallmarksEngine@@QAEXXZ		; CWallmarksEngine::clear
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 46   : 	ICF		void		_set	(T * rhs) 							{	if (0!=rhs) rhs->dwReference++;	_dec(); p_ = rhs;											}

	lea	ecx, DWORD PTR [esi+24]
	call	DWORD PTR __imp_?_dec@?$resptr_base@USGeometry@@@@IAEXXZ
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp

; 63   : }

	lea	ecx, DWORD PTR [esi+1504]
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 46   : 	ICF		void		_set	(T * rhs) 							{	if (0!=rhs) rhs->dwReference++;	_dec(); p_ = rhs;											}

	mov	DWORD PTR [esi+24], 0
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp

; 63   : }

	call	DWORD PTR __imp_??1xrCriticalSection@@QAE@XZ
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [esi+1492]
	mov	ebx, DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
	test	eax, eax
	je	SHORT $LN21@xr_delete
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	ebx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi+1492], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+1496], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+1500], 0
$LN21@xr_delete:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp

; 63   : }

	lea	ecx, DWORD PTR [esi+1468]
	call	DWORD PTR __imp_??1Collector@CDB@@QAE@XZ
	lea	ecx, DWORD PTR [esi+1444]
	call	DWORD PTR __imp_??1xrXRC@@QAE@XZ
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 64   : 						~resptr_core	()												{	_dec();						}

	lea	ecx, DWORD PTR [esi+24]
	call	DWORD PTR __imp_?_dec@?$resptr_base@USGeometry@@@@IAEXXZ
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [esi+12]
	test	eax, eax
	je	SHORT $LN35@xr_delete
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	ebx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi+12], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+16], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+20], 0
$LN35@xr_delete:

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN47@xr_delete
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	ebx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+4], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+8], 0
$LN47@xr_delete:
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h

; 144  : 		Memory.mem_free	(ptr);

	push	DWORD PTR [edi]
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	ebx

; 152  : 	{
; 153  : 		xr_special_free<is_polymorphic<T>::result,T>()(ptr);
; 154  : 		ptr = nullptr;

	pop	ebp
	mov	DWORD PTR [edi], 0
	pop	ebx
$LN2@xr_delete:

; 155  : 	}
; 156  : }

	pop	edi
	pop	esi
	ret	0
??$xr_delete@VCWallmarksEngine@@@@YAXAAPAVCWallmarksEngine@@@Z ENDP ; xr_delete<CWallmarksEngine>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
;	COMDAT ??$xr_delete@VCGlowManager@@@@YAXAAPAVCGlowManager@@@Z
_TEXT	SEGMENT
??$xr_delete@VCGlowManager@@@@YAXAAPAVCGlowManager@@@Z PROC ; xr_delete<CGlowManager>, COMDAT
; _ptr$ = ecx

; 150  : {

	push	ebx
	mov	ebx, ecx
	push	esi

; 151  : 	if (ptr) 

	mov	esi, DWORD PTR [ebx]
	test	esi, esi
	je	$LN2@xr_delete
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp

; 92   : }

	push	edi
	lea	ecx, DWORD PTR [esi+60]
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 64   : 						~resptr_core	()												{	_dec();						}

	call	DWORD PTR __imp_?_dec@?$resptr_base@USGeometry@@@@IAEXXZ
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [esi+48]
	mov	edi, DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
	test	eax, eax
	je	SHORT $LN18@xr_delete
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi+48], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+52], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+56], 0
$LN18@xr_delete:

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [esi+36]
	test	eax, eax
	je	SHORT $LN30@xr_delete
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi+36], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+40], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+44], 0
$LN30@xr_delete:

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [esi+24]
	test	eax, eax
	je	SHORT $LN42@xr_delete
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi+24], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+28], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+32], 0
$LN42@xr_delete:

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [esi+12]
	test	eax, eax
	je	SHORT $LN54@xr_delete
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi+12], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+16], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+20], 0
$LN54@xr_delete:

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN66@xr_delete
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+4], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+8], 0
$LN66@xr_delete:
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h

; 144  : 		Memory.mem_free	(ptr);

	push	DWORD PTR [ebx]
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	edi

; 152  : 	{
; 153  : 		xr_special_free<is_polymorphic<T>::result,T>()(ptr);
; 154  : 		ptr = nullptr;

	mov	DWORD PTR [ebx], 0
	pop	edi
$LN2@xr_delete:

; 155  : 	}
; 156  : }

	pop	esi
	pop	ebx
	ret	0
??$xr_delete@VCGlowManager@@@@YAXAAPAVCGlowManager@@@Z ENDP ; xr_delete<CGlowManager>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\Light_DB.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\Light_DB.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
;	COMDAT ??$xr_delete@VCLight_DB@@@@YAXAAPAVCLight_DB@@@Z
_TEXT	SEGMENT
??$xr_delete@VCLight_DB@@@@YAXAAPAVCLight_DB@@@Z PROC	; xr_delete<CLight_DB>, COMDAT
; _ptr$ = ecx

; 150  : {

	push	esi
	push	edi
	mov	edi, ecx

; 151  : 	if (ptr) 

	mov	esi, DWORD PTR [edi]
	test	esi, esi
	je	SHORT $LN2@xr_delete
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\Light_DB.cpp

; 14   : }

	lea	ecx, DWORD PTR [esi+20]
	call	??1light_Package@@QAE@XZ
	lea	ecx, DWORD PTR [esi+16]
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 64   : 						~resptr_core	()												{	_dec();						}

	call	DWORD PTR __imp_?_dec@?$resptr_base@VIRender_Light@@@@IAEXXZ
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\Light_DB.cpp

; 14   : }

	lea	ecx, DWORD PTR [esi+12]
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 64   : 						~resptr_core	()												{	_dec();						}

	call	DWORD PTR __imp_?_dec@?$resptr_base@VIRender_Light@@@@IAEXXZ
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN20@xr_delete
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+4], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+8], 0
$LN20@xr_delete:
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h

; 144  : 		Memory.mem_free	(ptr);

	push	DWORD PTR [edi]
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z

; 152  : 	{
; 153  : 		xr_special_free<is_polymorphic<T>::result,T>()(ptr);
; 154  : 		ptr = nullptr;

	mov	DWORD PTR [edi], 0
$LN2@xr_delete:

; 155  : 	}
; 156  : }

	pop	edi
	pop	esi
	ret	0
??$xr_delete@VCLight_DB@@@@YAXAAPAVCLight_DB@@@Z ENDP	; xr_delete<CLight_DB>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
;	COMDAT ??$xr_delete@VCLightProjector@@@@YAXAAPAVCLightProjector@@@Z
_TEXT	SEGMENT
??$xr_delete@VCLightProjector@@@@YAXAAPAVCLightProjector@@@Z PROC ; xr_delete<CLightProjector>, COMDAT
; _ptr$ = ecx

; 150  : {

	push	edi
	mov	edi, ecx

; 151  : 	if (ptr) 

	mov	eax, DWORD PTR [edi]
	test	eax, eax
	je	SHORT $LN2@xr_delete

; 132  : 		void*	_real_ptr	= dynamic_cast<void*>(ptr);

	push	esi
	push	eax
	call	___RTCastToVoid
	mov	ecx, DWORD PTR [edi]
	add	esp, 4
	mov	esi, eax
	call	??1CLightProjector@@QAE@XZ		; CLightProjector::~CLightProjector

; 133  : 		ptr->~T			();
; 134  : 		Memory.mem_free	(_real_ptr);

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	esi
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z

; 152  : 	{
; 153  : 		xr_special_free<is_polymorphic<T>::result,T>()(ptr);
; 154  : 		ptr = nullptr;

	mov	DWORD PTR [edi], 0
	pop	esi
$LN2@xr_delete:

; 155  : 	}
; 156  : }

	pop	edi
	ret	0
??$xr_delete@VCLightProjector@@@@YAXAAPAVCLightProjector@@@Z ENDP ; xr_delete<CLightProjector>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
;	COMDAT ??$xr_delete@VCLightShadows@@@@YAXAAPAVCLightShadows@@@Z
_TEXT	SEGMENT
??$xr_delete@VCLightShadows@@@@YAXAAPAVCLightShadows@@@Z PROC ; xr_delete<CLightShadows>, COMDAT
; _ptr$ = ecx

; 150  : {

	push	esi
	mov	esi, ecx

; 151  : 	if (ptr) 

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN2@xr_delete
	call	??1CLightShadows@@QAE@XZ		; CLightShadows::~CLightShadows

; 144  : 		Memory.mem_free	(ptr);

	push	DWORD PTR [esi]
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z

; 152  : 	{
; 153  : 		xr_special_free<is_polymorphic<T>::result,T>()(ptr);
; 154  : 		ptr = nullptr;

	mov	DWORD PTR [esi], 0
$LN2@xr_delete:

; 155  : 	}
; 156  : }

	pop	esi
	ret	0
??$xr_delete@VCLightShadows@@@@YAXAAPAVCLightShadows@@@Z ENDP ; xr_delete<CLightShadows>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__sector.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\FixedVector.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
;	COMDAT ??$xr_new@VCPortal@@@@YAPAVCPortal@@XZ
_TEXT	SEGMENT
??$xr_new@VCPortal@@@@YAPAVCPortal@@XZ PROC		; xr_new<CPortal>, COMDAT

; 68   : 	T* ptr	= (T*)Memory.mem_alloc(sizeof(T));

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	152					; 00000098H
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__sector.cpp

; 16   : {

	mov	DWORD PTR [eax], OFFSET ??_7CPortal@@6B@
; File I:\Vitalya\mine\NSProjectX\xrCore\FixedVector.h

; 21   : 	svector() : count(0) 

	mov	DWORD PTR [eax+100], 0
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h

; 70   : }

	ret	0
??$xr_new@VCPortal@@@@YAPAVCPortal@@XZ ENDP		; xr_new<CPortal>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__sector.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__sector.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
;	COMDAT ??$xr_new@VCSector@@@@YAPAVCSector@@XZ
_TEXT	SEGMENT
??$xr_new@VCSector@@@@YAPAVCSector@@XZ PROC		; xr_new<CSector>, COMDAT

; 68   : 	T* ptr	= (T*)Memory.mem_alloc(sizeof(T));

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	68					; 00000044H
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__sector.h

; 67   : 	CSector							()				{ m_root = NULL;	}

	mov	DWORD PTR [eax], OFFSET ??_7CSector@@6B@
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [eax+8], 0
	mov	DWORD PTR [eax+12], 0
	mov	DWORD PTR [eax+16], 0
	mov	DWORD PTR [eax+20], 0
	mov	DWORD PTR [eax+24], 0
	mov	DWORD PTR [eax+28], 0
	mov	DWORD PTR [eax+32], 0
	mov	DWORD PTR [eax+36], 0
	mov	DWORD PTR [eax+40], 0
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__sector.h

; 67   : 	CSector							()				{ m_root = NULL;	}

	mov	DWORD PTR [eax+4], 0
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h

; 70   : }

	ret	0
??$xr_new@VCSector@@@@YAPAVCSector@@XZ ENDP		; xr_new<CSector>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??$_Resize@U_Value_init_tag@std@@@?$vector@PAUIDirect3DIndexBuffer9@@V?$xalloc@PAUIDirect3DIndexBuffer9@@@@@std@@AAEXIABU_Value_init_tag@1@@Z
_TEXT	SEGMENT
__Newsize$ = 8						; size = 4
__Val$dead$ = 12					; size = 4
??$_Resize@U_Value_init_tag@std@@@?$vector@PAUIDirect3DIndexBuffer9@@V?$xalloc@PAUIDirect3DIndexBuffer9@@@@@std@@AAEXIABU_Value_init_tag@1@@Z PROC ; std::vector<IDirect3DIndexBuffer9 *,xalloc<IDirect3DIndexBuffer9 *> >::_Resize<std::_Value_init_tag>, COMDAT
; _this$ = ecx

; 1245 :     _CONSTEXPR20_CONTAINER void _Resize(const size_type _Newsize, const _Ty2& _Val) {

	push	ebx
	push	esi

; 1246 :         // trim or append elements, provide strong guarantee
; 1247 :         auto& _My_data      = _Mypair._Myval2;
; 1248 :         pointer& _Myfirst   = _My_data._Myfirst;
; 1249 :         pointer& _Mylast    = _My_data._Mylast;
; 1250 :         const auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);
; 1251 :         if (_Newsize < _Oldsize) { // trim

	mov	esi, DWORD PTR __Newsize$[esp+4]
	push	edi
	mov	edi, ecx
	mov	ebx, DWORD PTR [edi+4]
	mov	ecx, ebx
	mov	edx, DWORD PTR [edi]
	sub	ecx, edx
	sar	ecx, 2
	cmp	esi, ecx
	jae	SHORT $LN2@Resize

; 1252 :             const pointer _Newlast = _Myfirst + _Newsize;

	lea	eax, DWORD PTR [edx+esi*4]

; 1272 :     }

	mov	DWORD PTR [edi+4], eax
	pop	edi
	pop	esi
	pop	ebx
	ret	8
$LN2@Resize:

; 1253 :             _Orphan_range(_Newlast, _Mylast);
; 1254 :             _Destroy(_Newlast, _Mylast);
; 1255 :             _Mylast = _Newlast;
; 1256 :             return;
; 1257 :         }
; 1258 : 
; 1259 :         if (_Newsize > _Oldsize) { // append

	jbe	SHORT $LN3@Resize

; 1260 :             const auto _Oldcapacity = static_cast<size_type>(_My_data._Myend - _Myfirst);

	mov	eax, DWORD PTR [edi+8]
	sub	eax, edx
	sar	eax, 2

; 1261 :             if (_Newsize > _Oldcapacity) { // reallocate

	cmp	esi, eax
	jbe	SHORT $LN4@Resize

; 1262 :                 _Resize_reallocate(_Newsize, _Val);

	push	ecx
	push	esi
	mov	ecx, edi
	call	??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@PAUIDirect3DIndexBuffer9@@V?$xalloc@PAUIDirect3DIndexBuffer9@@@@@std@@AAEXIABU_Value_init_tag@1@@Z ; std::vector<IDirect3DIndexBuffer9 *,xalloc<IDirect3DIndexBuffer9 *> >::_Resize_reallocate<std::_Value_init_tag>
	pop	edi

; 1272 :     }

	pop	esi
	pop	ebx
	ret	8
$LN4@Resize:

; 1263 :                 return;
; 1264 :             }
; 1265 : 
; 1266 :             const pointer _Oldlast = _Mylast;
; 1267 :             _Mylast                = _Ufill(_Oldlast, _Newsize - _Oldsize, _Val);

	sub	esi, ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1807 :             _Zero_range(_PFirst, _PFirst + _Count);

	shl	esi, 2

; 1792 :     _CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

	push	esi
	push	0
	push	ebx
	call	_memset

; 1808 :             return _First + _Count;

	lea	eax, DWORD PTR [esi+ebx]

; 1792 :     _CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

	add	esp, 12					; 0000000cH
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1272 :     }

	mov	DWORD PTR [edi+4], eax
$LN3@Resize:
	pop	edi
	pop	esi
	pop	ebx
	ret	8
??$_Resize@U_Value_init_tag@std@@@?$vector@PAUIDirect3DIndexBuffer9@@V?$xalloc@PAUIDirect3DIndexBuffer9@@@@@std@@AAEXIABU_Value_init_tag@1@@Z ENDP ; std::vector<IDirect3DIndexBuffer9 *,xalloc<IDirect3DIndexBuffer9 *> >::_Resize<std::_Value_init_tag>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??$_Resize@U_Value_init_tag@std@@@?$vector@PAUIDirect3DVertexBuffer9@@V?$xalloc@PAUIDirect3DVertexBuffer9@@@@@std@@AAEXIABU_Value_init_tag@1@@Z
_TEXT	SEGMENT
__Newsize$ = 8						; size = 4
__Val$dead$ = 12					; size = 4
??$_Resize@U_Value_init_tag@std@@@?$vector@PAUIDirect3DVertexBuffer9@@V?$xalloc@PAUIDirect3DVertexBuffer9@@@@@std@@AAEXIABU_Value_init_tag@1@@Z PROC ; std::vector<IDirect3DVertexBuffer9 *,xalloc<IDirect3DVertexBuffer9 *> >::_Resize<std::_Value_init_tag>, COMDAT
; _this$ = ecx

; 1245 :     _CONSTEXPR20_CONTAINER void _Resize(const size_type _Newsize, const _Ty2& _Val) {

	push	ebx
	push	esi

; 1246 :         // trim or append elements, provide strong guarantee
; 1247 :         auto& _My_data      = _Mypair._Myval2;
; 1248 :         pointer& _Myfirst   = _My_data._Myfirst;
; 1249 :         pointer& _Mylast    = _My_data._Mylast;
; 1250 :         const auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);
; 1251 :         if (_Newsize < _Oldsize) { // trim

	mov	esi, DWORD PTR __Newsize$[esp+4]
	push	edi
	mov	edi, ecx
	mov	ebx, DWORD PTR [edi+4]
	mov	ecx, ebx
	mov	edx, DWORD PTR [edi]
	sub	ecx, edx
	sar	ecx, 2
	cmp	esi, ecx
	jae	SHORT $LN2@Resize

; 1252 :             const pointer _Newlast = _Myfirst + _Newsize;

	lea	eax, DWORD PTR [edx+esi*4]

; 1272 :     }

	mov	DWORD PTR [edi+4], eax
	pop	edi
	pop	esi
	pop	ebx
	ret	8
$LN2@Resize:

; 1253 :             _Orphan_range(_Newlast, _Mylast);
; 1254 :             _Destroy(_Newlast, _Mylast);
; 1255 :             _Mylast = _Newlast;
; 1256 :             return;
; 1257 :         }
; 1258 : 
; 1259 :         if (_Newsize > _Oldsize) { // append

	jbe	SHORT $LN3@Resize

; 1260 :             const auto _Oldcapacity = static_cast<size_type>(_My_data._Myend - _Myfirst);

	mov	eax, DWORD PTR [edi+8]
	sub	eax, edx
	sar	eax, 2

; 1261 :             if (_Newsize > _Oldcapacity) { // reallocate

	cmp	esi, eax
	jbe	SHORT $LN4@Resize

; 1262 :                 _Resize_reallocate(_Newsize, _Val);

	push	ecx
	push	esi
	mov	ecx, edi
	call	??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@PAUIDirect3DVertexBuffer9@@V?$xalloc@PAUIDirect3DVertexBuffer9@@@@@std@@AAEXIABU_Value_init_tag@1@@Z ; std::vector<IDirect3DVertexBuffer9 *,xalloc<IDirect3DVertexBuffer9 *> >::_Resize_reallocate<std::_Value_init_tag>
	pop	edi

; 1272 :     }

	pop	esi
	pop	ebx
	ret	8
$LN4@Resize:

; 1263 :                 return;
; 1264 :             }
; 1265 : 
; 1266 :             const pointer _Oldlast = _Mylast;
; 1267 :             _Mylast                = _Ufill(_Oldlast, _Newsize - _Oldsize, _Val);

	sub	esi, ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1807 :             _Zero_range(_PFirst, _PFirst + _Count);

	shl	esi, 2

; 1792 :     _CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

	push	esi
	push	0
	push	ebx
	call	_memset

; 1808 :             return _First + _Count;

	lea	eax, DWORD PTR [esi+ebx]

; 1792 :     _CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

	add	esp, 12					; 0000000cH
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1272 :     }

	mov	DWORD PTR [edi+4], eax
$LN3@Resize:
	pop	edi
	pop	esi
	pop	ebx
	ret	8
??$_Resize@U_Value_init_tag@std@@@?$vector@PAUIDirect3DVertexBuffer9@@V?$xalloc@PAUIDirect3DVertexBuffer9@@@@@std@@AAEXIABU_Value_init_tag@1@@Z ENDP ; std::vector<IDirect3DVertexBuffer9 *,xalloc<IDirect3DVertexBuffer9 *> >::_Resize<std::_Value_init_tag>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??$_Resize@U_Value_init_tag@std@@@?$vector@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@V?$xalloc@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@@@std@@AAEXIABU_Value_init_tag@1@@Z
_TEXT	SEGMENT
__Newsize$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Resize@U_Value_init_tag@std@@@?$vector@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@V?$xalloc@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@@@std@@AAEXIABU_Value_init_tag@1@@Z PROC ; std::vector<svector<_D3DVERTEXELEMENT9,65>,xalloc<svector<_D3DVERTEXELEMENT9,65> > >::_Resize<std::_Value_init_tag>, COMDAT
; _this$ = ecx

; 1245 :     _CONSTEXPR20_CONTAINER void _Resize(const size_type _Newsize, const _Ty2& _Val) {

	push	ebx
	push	ebp
	push	esi

; 1246 :         // trim or append elements, provide strong guarantee
; 1247 :         auto& _My_data      = _Mypair._Myval2;
; 1248 :         pointer& _Myfirst   = _My_data._Myfirst;
; 1249 :         pointer& _Mylast    = _My_data._Mylast;
; 1250 :         const auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);
; 1251 :         if (_Newsize < _Oldsize) { // trim

	mov	esi, DWORD PTR __Newsize$[esp+8]
	mov	eax, 1049152317				; 3e88cb3dH
	push	edi
	mov	edi, ecx
	mov	edx, DWORD PTR [edi+4]
	mov	ebp, DWORD PTR [edi]
	sub	edx, ebp
	imul	edx
	sar	edx, 7
	mov	ebx, edx
	shr	ebx, 31					; 0000001fH
	add	ebx, edx
	cmp	esi, ebx
	jae	SHORT $LN2@Resize

; 1252 :             const pointer _Newlast = _Myfirst + _Newsize;

	imul	eax, esi, 524
	add	eax, ebp

; 1268 :             _Orphan_range(_Oldlast, _Oldlast);
; 1269 :         }
; 1270 : 
; 1271 :         // if _Newsize == _Oldsize, do nothing; avoid invalidating iterators
; 1272 :     }

	mov	DWORD PTR [edi+4], eax
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	ret	8
$LN2@Resize:

; 1253 :             _Orphan_range(_Newlast, _Mylast);
; 1254 :             _Destroy(_Newlast, _Mylast);
; 1255 :             _Mylast = _Newlast;
; 1256 :             return;
; 1257 :         }
; 1258 : 
; 1259 :         if (_Newsize > _Oldsize) { // append

	jbe	SHORT $LN3@Resize

; 1260 :             const auto _Oldcapacity = static_cast<size_type>(_My_data._Myend - _Myfirst);

	mov	ecx, DWORD PTR [edi+8]
	mov	eax, 1049152317				; 3e88cb3dH
	sub	ecx, ebp
	imul	ecx
	sar	edx, 7
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx

; 1261 :             if (_Newsize > _Oldcapacity) { // reallocate

	cmp	esi, eax
	jbe	SHORT $LN4@Resize

; 1262 :                 _Resize_reallocate(_Newsize, _Val);

	push	DWORD PTR __Val$[esp+12]
	mov	ecx, edi
	push	esi
	call	??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@V?$xalloc@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@@@std@@AAEXIABU_Value_init_tag@1@@Z ; std::vector<svector<_D3DVERTEXELEMENT9,65>,xalloc<svector<_D3DVERTEXELEMENT9,65> > >::_Resize_reallocate<std::_Value_init_tag>
	pop	edi

; 1268 :             _Orphan_range(_Oldlast, _Oldlast);
; 1269 :         }
; 1270 : 
; 1271 :         // if _Newsize == _Oldsize, do nothing; avoid invalidating iterators
; 1272 :     }

	pop	esi
	pop	ebp
	pop	ebx
	ret	8
$LN4@Resize:

; 1263 :                 return;
; 1264 :             }
; 1265 : 
; 1266 :             const pointer _Oldlast = _Mylast;
; 1267 :             _Mylast                = _Ufill(_Oldlast, _Newsize - _Oldsize, _Val);

	mov	eax, DWORD PTR __Val$[esp+12]
	sub	esi, ebx
	movzx	eax, BYTE PTR [eax]
	push	eax
	push	esi
	push	DWORD PTR [edi+4]
	call	?_Ufill@?$vector@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@V?$xalloc@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@@@std@@AAEPAV?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@PAV3@IU_Value_init_tag@2@@Z ; std::vector<svector<_D3DVERTEXELEMENT9,65>,xalloc<svector<_D3DVERTEXELEMENT9,65> > >::_Ufill

; 1268 :             _Orphan_range(_Oldlast, _Oldlast);
; 1269 :         }
; 1270 : 
; 1271 :         // if _Newsize == _Oldsize, do nothing; avoid invalidating iterators
; 1272 :     }

	mov	DWORD PTR [edi+4], eax
$LN3@Resize:
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	ret	8
??$_Resize@U_Value_init_tag@std@@@?$vector@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@V?$xalloc@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@@@std@@AAEXIABU_Value_init_tag@1@@Z ENDP ; std::vector<svector<_D3DVERTEXELEMENT9,65>,xalloc<svector<_D3DVERTEXELEMENT9,65> > >::_Resize<std::_Value_init_tag>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??$_Resize@U_Value_init_tag@std@@@?$vector@V?$resptr_core@UShader@@Uresptrcode_shader@@@@V?$xalloc@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@@@std@@AAEXIABU_Value_init_tag@1@@Z
_TEXT	SEGMENT
__Newsize$ = 8						; size = 4
__Val$dead$ = 12					; size = 4
??$_Resize@U_Value_init_tag@std@@@?$vector@V?$resptr_core@UShader@@Uresptrcode_shader@@@@V?$xalloc@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@@@std@@AAEXIABU_Value_init_tag@1@@Z PROC ; std::vector<resptr_core<Shader,resptrcode_shader>,xalloc<resptr_core<Shader,resptrcode_shader> > >::_Resize<std::_Value_init_tag>, COMDAT
; _this$ = ecx

; 1246 :         // trim or append elements, provide strong guarantee
; 1247 :         auto& _My_data      = _Mypair._Myval2;
; 1248 :         pointer& _Myfirst   = _My_data._Myfirst;
; 1249 :         pointer& _Mylast    = _My_data._Mylast;
; 1250 :         const auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);
; 1251 :         if (_Newsize < _Oldsize) { // trim

	mov	edx, DWORD PTR __Newsize$[esp-4]
	push	ebx
	push	esi
	mov	esi, ecx
	push	edi
	mov	ebx, DWORD PTR [esi+4]
	mov	ecx, ebx
	mov	edi, DWORD PTR [esi]
	sub	ecx, edi
	sar	ecx, 2
	cmp	edx, ecx
	jae	SHORT $LN2@Resize

; 1252 :             const pointer _Newlast = _Myfirst + _Newsize;

	lea	eax, DWORD PTR [edi+edx*4]
	pop	edi

; 1253 :             _Orphan_range(_Newlast, _Mylast);
; 1254 :             _Destroy(_Newlast, _Mylast);
; 1255 :             _Mylast = _Newlast;

	mov	DWORD PTR [esi+4], eax

; 1268 :             _Orphan_range(_Oldlast, _Oldlast);
; 1269 :         }
; 1270 : 
; 1271 :         // if _Newsize == _Oldsize, do nothing; avoid invalidating iterators
; 1272 :     }

	pop	esi
	pop	ebx
	ret	8
$LN2@Resize:

; 1256 :             return;
; 1257 :         }
; 1258 : 
; 1259 :         if (_Newsize > _Oldsize) { // append

	jbe	SHORT $LN3@Resize

; 1260 :             const auto _Oldcapacity = static_cast<size_type>(_My_data._Myend - _Myfirst);

	mov	eax, DWORD PTR [esi+8]
	sub	eax, edi
	sar	eax, 2

; 1261 :             if (_Newsize > _Oldcapacity) { // reallocate

	cmp	edx, eax
	jbe	SHORT $LN4@Resize

; 1262 :                 _Resize_reallocate(_Newsize, _Val);

	push	ecx
	push	edx
	mov	ecx, esi
	call	??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@V?$resptr_core@UShader@@Uresptrcode_shader@@@@V?$xalloc@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@@@std@@AAEXIABU_Value_init_tag@1@@Z ; std::vector<resptr_core<Shader,resptrcode_shader>,xalloc<resptr_core<Shader,resptrcode_shader> > >::_Resize_reallocate<std::_Value_init_tag>
	pop	edi

; 1268 :             _Orphan_range(_Oldlast, _Oldlast);
; 1269 :         }
; 1270 : 
; 1271 :         // if _Newsize == _Oldsize, do nothing; avoid invalidating iterators
; 1272 :     }

	pop	esi
	pop	ebx
	ret	8
$LN4@Resize:

; 1267 :             _Mylast                = _Ufill(_Oldlast, _Newsize - _Oldsize, _Val);

	sub	edx, ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1813 :     for (; 0 < _Count; --_Count) {

	je	SHORT $LN11@Resize
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1267 :             _Mylast                = _Ufill(_Oldlast, _Newsize - _Oldsize, _Val);

	mov	edi, ebx
	mov	ecx, edx
	xor	eax, eax
	lea	ebx, DWORD PTR [ebx+edx*4]
	rep stosd
$LN11@Resize:
	mov	DWORD PTR [esi+4], ebx
$LN3@Resize:
	pop	edi

; 1268 :             _Orphan_range(_Oldlast, _Oldlast);
; 1269 :         }
; 1270 : 
; 1271 :         // if _Newsize == _Oldsize, do nothing; avoid invalidating iterators
; 1272 :     }

	pop	esi
	pop	ebx
	ret	8
??$_Resize@U_Value_init_tag@std@@@?$vector@V?$resptr_core@UShader@@Uresptrcode_shader@@@@V?$xalloc@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@@@std@@AAEXIABU_Value_init_tag@1@@Z ENDP ; std::vector<resptr_core<Shader,resptrcode_shader>,xalloc<resptr_core<Shader,resptrcode_shader> > >::_Resize<std::_Value_init_tag>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??$_Resize@U_Value_init_tag@std@@@?$vector@UFSlideWindowItem@@V?$xalloc@UFSlideWindowItem@@@@@std@@AAEXIABU_Value_init_tag@1@@Z
_TEXT	SEGMENT
__Newsize$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Resize@U_Value_init_tag@std@@@?$vector@UFSlideWindowItem@@V?$xalloc@UFSlideWindowItem@@@@@std@@AAEXIABU_Value_init_tag@1@@Z PROC ; std::vector<FSlideWindowItem,xalloc<FSlideWindowItem> >::_Resize<std::_Value_init_tag>, COMDAT
; _this$ = ecx

; 1245 :     _CONSTEXPR20_CONTAINER void _Resize(const size_type _Newsize, const _Ty2& _Val) {

	mov	edx, ecx

; 1246 :         // trim or append elements, provide strong guarantee
; 1247 :         auto& _My_data      = _Mypair._Myval2;
; 1248 :         pointer& _Myfirst   = _My_data._Myfirst;
; 1249 :         pointer& _Mylast    = _My_data._Mylast;
; 1250 :         const auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);
; 1251 :         if (_Newsize < _Oldsize) { // trim

	mov	ecx, DWORD PTR __Newsize$[esp-4]
	push	esi
	push	edi
	mov	eax, DWORD PTR [edx+4]
	mov	edi, DWORD PTR [edx]
	sub	eax, edi
	sar	eax, 3
	imul	esi, eax, -1431655765
	cmp	ecx, esi
	jae	SHORT $LN2@Resize

; 1252 :             const pointer _Newlast = _Myfirst + _Newsize;

	lea	eax, DWORD PTR [ecx+ecx*2]
	lea	eax, DWORD PTR [edi+eax*8]
	pop	edi

; 1268 :             _Orphan_range(_Oldlast, _Oldlast);
; 1269 :         }
; 1270 : 
; 1271 :         // if _Newsize == _Oldsize, do nothing; avoid invalidating iterators
; 1272 :     }

	mov	DWORD PTR [edx+4], eax
	pop	esi
	ret	8
$LN2@Resize:

; 1253 :             _Orphan_range(_Newlast, _Mylast);
; 1254 :             _Destroy(_Newlast, _Mylast);
; 1255 :             _Mylast = _Newlast;
; 1256 :             return;
; 1257 :         }
; 1258 : 
; 1259 :         if (_Newsize > _Oldsize) { // append

	jbe	SHORT $LN3@Resize

; 1260 :             const auto _Oldcapacity = static_cast<size_type>(_My_data._Myend - _Myfirst);

	mov	eax, DWORD PTR [edx+8]
	sub	eax, edi
	sar	eax, 3
	imul	eax, eax, -1431655765

; 1261 :             if (_Newsize > _Oldcapacity) { // reallocate

	cmp	ecx, eax
	jbe	SHORT $LN4@Resize

; 1268 :             _Orphan_range(_Oldlast, _Oldlast);
; 1269 :         }
; 1270 : 
; 1271 :         // if _Newsize == _Oldsize, do nothing; avoid invalidating iterators
; 1272 :     }

	pop	edi
	pop	esi

; 1262 :                 _Resize_reallocate(_Newsize, _Val);

	mov	DWORD PTR __Newsize$[esp-4], ecx
	mov	ecx, edx
	jmp	??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UFSlideWindowItem@@V?$xalloc@UFSlideWindowItem@@@@@std@@AAEXIABU_Value_init_tag@1@@Z ; std::vector<FSlideWindowItem,xalloc<FSlideWindowItem> >::_Resize_reallocate<std::_Value_init_tag>
$LN4@Resize:

; 1263 :                 return;
; 1264 :             }
; 1265 : 
; 1266 :             const pointer _Oldlast = _Mylast;
; 1267 :             _Mylast                = _Ufill(_Oldlast, _Newsize - _Oldsize, _Val);

	mov	eax, DWORD PTR __Val$[esp+4]
	sub	ecx, esi
	movzx	eax, BYTE PTR [eax]
	push	eax
	push	ecx
	push	DWORD PTR [edx+4]
	call	?_Ufill@?$vector@UFSlideWindowItem@@V?$xalloc@UFSlideWindowItem@@@@@std@@AAEPAUFSlideWindowItem@@PAU3@IU_Value_init_tag@2@@Z ; std::vector<FSlideWindowItem,xalloc<FSlideWindowItem> >::_Ufill

; 1268 :             _Orphan_range(_Oldlast, _Oldlast);
; 1269 :         }
; 1270 : 
; 1271 :         // if _Newsize == _Oldsize, do nothing; avoid invalidating iterators
; 1272 :     }

	mov	DWORD PTR [edx+4], eax
$LN3@Resize:
	pop	edi
	pop	esi
	ret	8
??$_Resize@U_Value_init_tag@std@@@?$vector@UFSlideWindowItem@@V?$xalloc@UFSlideWindowItem@@@@@std@@AAEXIABU_Value_init_tag@1@@Z ENDP ; std::vector<FSlideWindowItem,xalloc<FSlideWindowItem> >::_Resize<std::_Value_init_tag>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??$_Resize@U_Value_init_tag@std@@@?$vector@PAVIRender_Portal@@V?$xalloc@PAVIRender_Portal@@@@@std@@AAEXIABU_Value_init_tag@1@@Z
_TEXT	SEGMENT
__Newsize$ = 8						; size = 4
__Val$dead$ = 12					; size = 4
??$_Resize@U_Value_init_tag@std@@@?$vector@PAVIRender_Portal@@V?$xalloc@PAVIRender_Portal@@@@@std@@AAEXIABU_Value_init_tag@1@@Z PROC ; std::vector<IRender_Portal *,xalloc<IRender_Portal *> >::_Resize<std::_Value_init_tag>, COMDAT
; _this$ = ecx

; 1245 :     _CONSTEXPR20_CONTAINER void _Resize(const size_type _Newsize, const _Ty2& _Val) {

	push	ebx
	push	esi

; 1246 :         // trim or append elements, provide strong guarantee
; 1247 :         auto& _My_data      = _Mypair._Myval2;
; 1248 :         pointer& _Myfirst   = _My_data._Myfirst;
; 1249 :         pointer& _Mylast    = _My_data._Mylast;
; 1250 :         const auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);
; 1251 :         if (_Newsize < _Oldsize) { // trim

	mov	esi, DWORD PTR __Newsize$[esp+4]
	push	edi
	mov	edi, ecx
	mov	ebx, DWORD PTR [edi+4]
	mov	ecx, ebx
	mov	edx, DWORD PTR [edi]
	sub	ecx, edx
	sar	ecx, 2
	cmp	esi, ecx
	jae	SHORT $LN2@Resize

; 1252 :             const pointer _Newlast = _Myfirst + _Newsize;

	lea	eax, DWORD PTR [edx+esi*4]

; 1272 :     }

	mov	DWORD PTR [edi+4], eax
	pop	edi
	pop	esi
	pop	ebx
	ret	8
$LN2@Resize:

; 1253 :             _Orphan_range(_Newlast, _Mylast);
; 1254 :             _Destroy(_Newlast, _Mylast);
; 1255 :             _Mylast = _Newlast;
; 1256 :             return;
; 1257 :         }
; 1258 : 
; 1259 :         if (_Newsize > _Oldsize) { // append

	jbe	SHORT $LN3@Resize

; 1260 :             const auto _Oldcapacity = static_cast<size_type>(_My_data._Myend - _Myfirst);

	mov	eax, DWORD PTR [edi+8]
	sub	eax, edx
	sar	eax, 2

; 1261 :             if (_Newsize > _Oldcapacity) { // reallocate

	cmp	esi, eax
	jbe	SHORT $LN4@Resize

; 1262 :                 _Resize_reallocate(_Newsize, _Val);

	push	ecx
	push	esi
	mov	ecx, edi
	call	??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@PAVIRender_Portal@@V?$xalloc@PAVIRender_Portal@@@@@std@@AAEXIABU_Value_init_tag@1@@Z ; std::vector<IRender_Portal *,xalloc<IRender_Portal *> >::_Resize_reallocate<std::_Value_init_tag>
	pop	edi

; 1272 :     }

	pop	esi
	pop	ebx
	ret	8
$LN4@Resize:

; 1263 :                 return;
; 1264 :             }
; 1265 : 
; 1266 :             const pointer _Oldlast = _Mylast;
; 1267 :             _Mylast                = _Ufill(_Oldlast, _Newsize - _Oldsize, _Val);

	sub	esi, ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1807 :             _Zero_range(_PFirst, _PFirst + _Count);

	shl	esi, 2

; 1792 :     _CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

	push	esi
	push	0
	push	ebx
	call	_memset

; 1808 :             return _First + _Count;

	lea	eax, DWORD PTR [esi+ebx]

; 1792 :     _CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

	add	esp, 12					; 0000000cH
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1272 :     }

	mov	DWORD PTR [edi+4], eax
$LN3@Resize:
	pop	edi
	pop	esi
	pop	ebx
	ret	8
??$_Resize@U_Value_init_tag@std@@@?$vector@PAVIRender_Portal@@V?$xalloc@PAVIRender_Portal@@@@@std@@AAEXIABU_Value_init_tag@1@@Z ENDP ; std::vector<IRender_Portal *,xalloc<IRender_Portal *> >::_Resize<std::_Value_init_tag>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_Move_unchecked@PAUFSlideWindowItem@@PAU1@@std@@YAPAUFSlideWindowItem@@PAU1@00@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
??$_Move_unchecked@PAUFSlideWindowItem@@PAU1@@std@@YAPAUFSlideWindowItem@@PAU1@00@Z PROC ; std::_Move_unchecked<FSlideWindowItem *,FSlideWindowItem *>, COMDAT
; __First$ = ecx
; __Last$ = edx

; 4308 : _CONSTEXPR20 _OutIt _Move_unchecked(_InIt _First, _InIt _Last, _OutIt _Dest) {

	push	esi

; 4066 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	esi, DWORD PTR __Dest$[esp]

; 4308 : _CONSTEXPR20 _OutIt _Move_unchecked(_InIt _First, _InIt _Last, _OutIt _Dest) {

	push	edi
	mov	edi, edx

; 4065 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	sub	edi, ecx

; 4066 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	push	edi
	push	ecx
	push	esi
	call	_memmove
	add	esp, 12					; 0000000cH

; 4067 :     if constexpr (is_pointer_v<_OutCtgIt>) {
; 4068 :         return reinterpret_cast<_OutCtgIt>(_Dest_ch + _Count);

	lea	eax, DWORD PTR [edi+esi]

; 4309 :     // move [_First, _Last) to [_Dest, ...)
; 4310 :     // note: _Move_unchecked has callers other than the move family
; 4311 :     if constexpr (_Ptr_move_cat<_InIt, _OutIt>::_Trivially_copyable) {
; 4312 : #ifdef __cpp_lib_is_constant_evaluated
; 4313 :         if (!_STD is_constant_evaluated())
; 4314 : #endif // __cpp_lib_is_constant_evaluated
; 4315 :         {
; 4316 :             return _Copy_memmove(_First, _Last, _Dest);

	pop	edi
	pop	esi

; 4317 :         }
; 4318 :     }
; 4319 : 
; 4320 :     for (; _First != _Last; ++_Dest, (void) ++_First) {
; 4321 :         *_Dest = _STD move(*_First);
; 4322 :     }
; 4323 : 
; 4324 :     return _Dest;
; 4325 : }

	ret	0
??$_Move_unchecked@PAUFSlideWindowItem@@PAU1@@std@@YAPAUFSlideWindowItem@@PAU1@00@Z ENDP ; std::_Move_unchecked<FSlideWindowItem *,FSlideWindowItem *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
;	COMDAT ??R?$xr_special_free@$0A@VCLightShadows@@@@QAEXAAPAVCLightShadows@@@Z
_TEXT	SEGMENT
_ptr$ = 8						; size = 4
??R?$xr_special_free@$0A@VCLightShadows@@@@QAEXAAPAVCLightShadows@@@Z PROC ; xr_special_free<0,CLightShadows>::operator(), COMDAT
; _this$dead$ = ecx

; 142  : 	{

	push	esi

; 143  : 		ptr->~T			();

	mov	esi, DWORD PTR _ptr$[esp]
	mov	ecx, DWORD PTR [esi]
	call	??1CLightShadows@@QAE@XZ		; CLightShadows::~CLightShadows

; 144  : 		Memory.mem_free	(ptr);

	push	DWORD PTR [esi]
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
	pop	esi

; 145  : 	}

	ret	4
??R?$xr_special_free@$0A@VCLightShadows@@@@QAEXAAPAVCLightShadows@@@Z ENDP ; xr_special_free<0,CLightShadows>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
;	COMDAT ??R?$xr_special_free@$00VCLightProjector@@@@QAEXAAPAVCLightProjector@@@Z
_TEXT	SEGMENT
_ptr$ = 8						; size = 4
??R?$xr_special_free@$00VCLightProjector@@@@QAEXAAPAVCLightProjector@@@Z PROC ; xr_special_free<1,CLightProjector>::operator(), COMDAT
; _this$dead$ = ecx

; 131  : 	{

	push	esi
	push	edi

; 132  : 		void*	_real_ptr	= dynamic_cast<void*>(ptr);

	mov	edi, DWORD PTR _ptr$[esp+4]
	push	DWORD PTR [edi]
	call	___RTCastToVoid
	mov	ecx, DWORD PTR [edi]
	add	esp, 4
	mov	esi, eax
	call	??1CLightProjector@@QAE@XZ		; CLightProjector::~CLightProjector

; 133  : 		ptr->~T			();
; 134  : 		Memory.mem_free	(_real_ptr);

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	esi
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
	pop	edi
	pop	esi

; 135  : 	}

	ret	4
??R?$xr_special_free@$00VCLightProjector@@@@QAEXAAPAVCLightProjector@@@Z ENDP ; xr_special_free<1,CLightProjector>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\Light_DB.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\Light_DB.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
;	COMDAT ??R?$xr_special_free@$0A@VCLight_DB@@@@QAEXAAPAVCLight_DB@@@Z
_TEXT	SEGMENT
_ptr$ = 8						; size = 4
??R?$xr_special_free@$0A@VCLight_DB@@@@QAEXAAPAVCLight_DB@@@Z PROC ; xr_special_free<0,CLight_DB>::operator(), COMDAT
; _this$dead$ = ecx

; 142  : 	{

	push	ebx

; 143  : 		ptr->~T			();

	mov	ebx, DWORD PTR _ptr$[esp]
	push	esi
	mov	esi, DWORD PTR [ebx]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\Light_DB.cpp

; 14   : }

	lea	ecx, DWORD PTR [esi+20]
	call	??1light_Package@@QAE@XZ
	lea	ecx, DWORD PTR [esi+16]
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 64   : 						~resptr_core	()												{	_dec();						}

	call	DWORD PTR __imp_?_dec@?$resptr_base@VIRender_Light@@@@IAEXXZ
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\Light_DB.cpp

; 14   : }

	lea	ecx, DWORD PTR [esi+12]
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 64   : 						~resptr_core	()												{	_dec();						}

	call	DWORD PTR __imp_?_dec@?$resptr_base@VIRender_Light@@@@IAEXXZ
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN17@operator
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+4], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+8], 0
$LN17@operator:
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h

; 144  : 		Memory.mem_free	(ptr);

	push	DWORD PTR [ebx]
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
	pop	esi
	pop	ebx

; 145  : 	}

	ret	4
??R?$xr_special_free@$0A@VCLight_DB@@@@QAEXAAPAVCLight_DB@@@Z ENDP ; xr_special_free<0,CLight_DB>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
;	COMDAT ??R?$xr_special_free@$0A@VCGlowManager@@@@QAEXAAPAVCGlowManager@@@Z
_TEXT	SEGMENT
_ptr$ = 8						; size = 4
??R?$xr_special_free@$0A@VCGlowManager@@@@QAEXAAPAVCGlowManager@@@Z PROC ; xr_special_free<0,CGlowManager>::operator(), COMDAT
; _this$dead$ = ecx

; 142  : 	{

	push	ebx

; 143  : 		ptr->~T			();

	mov	ebx, DWORD PTR _ptr$[esp]
	push	esi
	push	edi
	mov	esi, DWORD PTR [ebx]
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp

; 92   : }

	lea	ecx, DWORD PTR [esi+60]
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 64   : 						~resptr_core	()												{	_dec();						}

	call	DWORD PTR __imp_?_dec@?$resptr_base@USGeometry@@@@IAEXXZ
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [esi+48]
	mov	edi, DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
	test	eax, eax
	je	SHORT $LN15@operator
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi+48], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+52], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+56], 0
$LN15@operator:

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [esi+36]
	test	eax, eax
	je	SHORT $LN27@operator
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi+36], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+40], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+44], 0
$LN27@operator:

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [esi+24]
	test	eax, eax
	je	SHORT $LN39@operator
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi+24], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+28], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+32], 0
$LN39@operator:

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [esi+12]
	test	eax, eax
	je	SHORT $LN51@operator
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi+12], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+16], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+20], 0
$LN51@operator:

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN63@operator
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+4], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+8], 0
$LN63@operator:
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h

; 144  : 		Memory.mem_free	(ptr);

	push	DWORD PTR [ebx]
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	edi
	pop	edi
	pop	esi
	pop	ebx

; 145  : 	}

	ret	4
??R?$xr_special_free@$0A@VCGlowManager@@@@QAEXAAPAVCGlowManager@@@Z ENDP ; xr_special_free<0,CGlowManager>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
;	COMDAT ??R?$xr_special_free@$0A@VCWallmarksEngine@@@@QAEXAAPAVCWallmarksEngine@@@Z
_TEXT	SEGMENT
_ptr$ = 8						; size = 4
??R?$xr_special_free@$0A@VCWallmarksEngine@@@@QAEXAAPAVCWallmarksEngine@@@Z PROC ; xr_special_free<0,CWallmarksEngine>::operator(), COMDAT
; _this$dead$ = ecx

; 142  : 	{

	push	ebx

; 143  : 		ptr->~T			();

	mov	ebx, DWORD PTR _ptr$[esp]
	push	ebp
	push	esi
	push	edi
	mov	esi, DWORD PTR [ebx]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp

; 61   : 	clear			();

	mov	ecx, esi
	call	?clear@CWallmarksEngine@@QAEXXZ		; CWallmarksEngine::clear
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 46   : 	ICF		void		_set	(T * rhs) 							{	if (0!=rhs) rhs->dwReference++;	_dec(); p_ = rhs;											}

	lea	ecx, DWORD PTR [esi+24]
	call	DWORD PTR __imp_?_dec@?$resptr_base@USGeometry@@@@IAEXXZ
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp

; 63   : }

	lea	ecx, DWORD PTR [esi+1504]
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 46   : 	ICF		void		_set	(T * rhs) 							{	if (0!=rhs) rhs->dwReference++;	_dec(); p_ = rhs;											}

	mov	DWORD PTR [esi+24], 0
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp

; 63   : }

	call	DWORD PTR __imp_??1xrCriticalSection@@QAE@XZ
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [esi+1492]
	mov	edi, DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
	test	eax, eax
	je	SHORT $LN18@operator
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi+1492], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+1496], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+1500], 0
$LN18@operator:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp

; 63   : }

	lea	ecx, DWORD PTR [esi+1468]
	call	DWORD PTR __imp_??1Collector@CDB@@QAE@XZ
	lea	ecx, DWORD PTR [esi+1444]
	call	DWORD PTR __imp_??1xrXRC@@QAE@XZ
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 64   : 						~resptr_core	()												{	_dec();						}

	lea	ecx, DWORD PTR [esi+24]
	call	DWORD PTR __imp_?_dec@?$resptr_base@USGeometry@@@@IAEXXZ
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [esi+12]
	test	eax, eax
	je	SHORT $LN32@operator
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi+12], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+16], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+20], 0
$LN32@operator:

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN44@operator
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+4], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+8], 0
$LN44@operator:
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h

; 144  : 		Memory.mem_free	(ptr);

	push	DWORD PTR [ebx]
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	edi
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 145  : 	}

	ret	4
??R?$xr_special_free@$0A@VCWallmarksEngine@@@@QAEXAAPAVCWallmarksEngine@@@Z ENDP ; xr_special_free<0,CWallmarksEngine>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
;	COMDAT ??R?$xr_special_free@$00VCDetailManager@@@@QAEXAAPAVCDetailManager@@@Z
_TEXT	SEGMENT
_ptr$ = 8						; size = 4
??R?$xr_special_free@$00VCDetailManager@@@@QAEXAAPAVCDetailManager@@@Z PROC ; xr_special_free<1,CDetailManager>::operator(), COMDAT
; _this$dead$ = ecx

; 131  : 	{

	push	esi

; 132  : 		void*	_real_ptr	= dynamic_cast<void*>(ptr);

	mov	esi, DWORD PTR _ptr$[esp]
	push	edi
	push	DWORD PTR [esi]
	call	___RTCastToVoid

; 133  : 		ptr->~T			();

	mov	ecx, DWORD PTR [esi]
	add	esp, 4
	mov	edi, eax
	mov	edx, DWORD PTR [ecx]
	push	0
	call	DWORD PTR [edx]

; 134  : 		Memory.mem_free	(_real_ptr);

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	edi
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
	pop	edi
	pop	esi

; 135  : 	}

	ret	4
??R?$xr_special_free@$00VCDetailManager@@@@QAEXAAPAVCDetailManager@@@Z ENDP ; xr_special_free<1,CDetailManager>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
;	COMDAT ??R?$xr_special_free@$00VIRender_Portal@@@@QAEXAAPAVIRender_Portal@@@Z
_TEXT	SEGMENT
_ptr$ = 8						; size = 4
??R?$xr_special_free@$00VIRender_Portal@@@@QAEXAAPAVIRender_Portal@@@Z PROC ; xr_special_free<1,IRender_Portal>::operator(), COMDAT
; _this$dead$ = ecx

; 131  : 	{

	push	esi

; 132  : 		void*	_real_ptr	= dynamic_cast<void*>(ptr);

	mov	esi, DWORD PTR _ptr$[esp]
	push	edi
	push	DWORD PTR [esi]
	call	___RTCastToVoid

; 133  : 		ptr->~T			();

	mov	ecx, DWORD PTR [esi]
	add	esp, 4
	mov	edi, eax
	mov	edx, DWORD PTR [ecx]
	push	0
	call	DWORD PTR [edx]

; 134  : 		Memory.mem_free	(_real_ptr);

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	edi
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
	pop	edi
	pop	esi

; 135  : 	}

	ret	4
??R?$xr_special_free@$00VIRender_Portal@@@@QAEXAAPAVIRender_Portal@@@Z ENDP ; xr_special_free<1,IRender_Portal>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
;	COMDAT ??R?$xr_special_free@$00VIRender_Sector@@@@QAEXAAPAVIRender_Sector@@@Z
_TEXT	SEGMENT
_ptr$ = 8						; size = 4
??R?$xr_special_free@$00VIRender_Sector@@@@QAEXAAPAVIRender_Sector@@@Z PROC ; xr_special_free<1,IRender_Sector>::operator(), COMDAT
; _this$dead$ = ecx

; 131  : 	{

	push	esi

; 132  : 		void*	_real_ptr	= dynamic_cast<void*>(ptr);

	mov	esi, DWORD PTR _ptr$[esp]
	push	edi
	push	DWORD PTR [esi]
	call	___RTCastToVoid

; 133  : 		ptr->~T			();

	mov	ecx, DWORD PTR [esi]
	add	esp, 4
	mov	edi, eax
	mov	edx, DWORD PTR [ecx]
	push	0
	call	DWORD PTR [edx]

; 134  : 		Memory.mem_free	(_real_ptr);

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	edi
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
	pop	edi
	pop	esi

; 135  : 	}

	ret	4
??R?$xr_special_free@$00VIRender_Sector@@@@QAEXAAPAVIRender_Sector@@@Z ENDP ; xr_special_free<1,IRender_Sector>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Orphan_range@?$vector@PAUIDirect3DIndexBuffer9@@V?$xalloc@PAUIDirect3DIndexBuffer9@@@@@std@@ABEXPAPAUIDirect3DIndexBuffer9@@0@Z
_TEXT	SEGMENT
___formal$dead$ = 8					; size = 4
___formal$dead$ = 12					; size = 4
?_Orphan_range@?$vector@PAUIDirect3DIndexBuffer9@@V?$xalloc@PAUIDirect3DIndexBuffer9@@@@@std@@ABEXPAPAUIDirect3DIndexBuffer9@@0@Z PROC ; std::vector<IDirect3DIndexBuffer9 *,xalloc<IDirect3DIndexBuffer9 *> >::_Orphan_range, COMDAT
; _this$dead$ = ecx

; 1801 :     _CONSTEXPR20_CONTAINER void _Orphan_range(pointer, pointer) const {}

	ret	8
?_Orphan_range@?$vector@PAUIDirect3DIndexBuffer9@@V?$xalloc@PAUIDirect3DIndexBuffer9@@@@@std@@ABEXPAPAUIDirect3DIndexBuffer9@@0@Z ENDP ; std::vector<IDirect3DIndexBuffer9 *,xalloc<IDirect3DIndexBuffer9 *> >::_Orphan_range
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Ufill@?$vector@PAUIDirect3DIndexBuffer9@@V?$xalloc@PAUIDirect3DIndexBuffer9@@@@@std@@AAEPAPAUIDirect3DIndexBuffer9@@PAPAU3@IU_Value_init_tag@2@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Count$ = 12						; size = 4
___formal$ = 16						; size = 1
?_Ufill@?$vector@PAUIDirect3DIndexBuffer9@@V?$xalloc@PAUIDirect3DIndexBuffer9@@@@@std@@AAEPAPAUIDirect3DIndexBuffer9@@PAPAU3@IU_Value_init_tag@2@@Z PROC ; std::vector<IDirect3DIndexBuffer9 *,xalloc<IDirect3DIndexBuffer9 *> >::_Ufill, COMDAT
; _this$dead$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1807 :             _Zero_range(_PFirst, _PFirst + _Count);

	mov	eax, DWORD PTR __Count$[esp-4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1633 :     _CONSTEXPR20_CONTAINER pointer _Ufill(pointer _Dest, const size_type _Count, _Value_init_tag) {

	push	esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1792 :     _CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

	mov	esi, DWORD PTR __Dest$[esp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1633 :     _CONSTEXPR20_CONTAINER pointer _Ufill(pointer _Dest, const size_type _Count, _Value_init_tag) {

	push	edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1807 :             _Zero_range(_PFirst, _PFirst + _Count);

	lea	edi, DWORD PTR [eax*4]

; 1792 :     _CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

	push	edi
	push	0
	push	esi
	call	_memset
	add	esp, 12					; 0000000cH

; 1808 :             return _First + _Count;

	lea	eax, DWORD PTR [edi+esi]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1635 :         return _Uninitialized_value_construct_n(_Dest, _Count, _Getal());

	pop	edi
	pop	esi

; 1636 :     }

	ret	12					; 0000000cH
?_Ufill@?$vector@PAUIDirect3DIndexBuffer9@@V?$xalloc@PAUIDirect3DIndexBuffer9@@@@@std@@AAEPAPAUIDirect3DIndexBuffer9@@PAPAU3@IU_Value_init_tag@2@@Z ENDP ; std::vector<IDirect3DIndexBuffer9 *,xalloc<IDirect3DIndexBuffer9 *> >::_Ufill
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Orphan_range@?$vector@PAUIDirect3DVertexBuffer9@@V?$xalloc@PAUIDirect3DVertexBuffer9@@@@@std@@ABEXPAPAUIDirect3DVertexBuffer9@@0@Z
_TEXT	SEGMENT
___formal$dead$ = 8					; size = 4
___formal$dead$ = 12					; size = 4
?_Orphan_range@?$vector@PAUIDirect3DVertexBuffer9@@V?$xalloc@PAUIDirect3DVertexBuffer9@@@@@std@@ABEXPAPAUIDirect3DVertexBuffer9@@0@Z PROC ; std::vector<IDirect3DVertexBuffer9 *,xalloc<IDirect3DVertexBuffer9 *> >::_Orphan_range, COMDAT
; _this$dead$ = ecx

; 1801 :     _CONSTEXPR20_CONTAINER void _Orphan_range(pointer, pointer) const {}

	ret	8
?_Orphan_range@?$vector@PAUIDirect3DVertexBuffer9@@V?$xalloc@PAUIDirect3DVertexBuffer9@@@@@std@@ABEXPAPAUIDirect3DVertexBuffer9@@0@Z ENDP ; std::vector<IDirect3DVertexBuffer9 *,xalloc<IDirect3DVertexBuffer9 *> >::_Orphan_range
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Ufill@?$vector@PAUIDirect3DVertexBuffer9@@V?$xalloc@PAUIDirect3DVertexBuffer9@@@@@std@@AAEPAPAUIDirect3DVertexBuffer9@@PAPAU3@IU_Value_init_tag@2@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Count$ = 12						; size = 4
___formal$ = 16						; size = 1
?_Ufill@?$vector@PAUIDirect3DVertexBuffer9@@V?$xalloc@PAUIDirect3DVertexBuffer9@@@@@std@@AAEPAPAUIDirect3DVertexBuffer9@@PAPAU3@IU_Value_init_tag@2@@Z PROC ; std::vector<IDirect3DVertexBuffer9 *,xalloc<IDirect3DVertexBuffer9 *> >::_Ufill, COMDAT
; _this$dead$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1807 :             _Zero_range(_PFirst, _PFirst + _Count);

	mov	eax, DWORD PTR __Count$[esp-4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1633 :     _CONSTEXPR20_CONTAINER pointer _Ufill(pointer _Dest, const size_type _Count, _Value_init_tag) {

	push	esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1792 :     _CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

	mov	esi, DWORD PTR __Dest$[esp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1633 :     _CONSTEXPR20_CONTAINER pointer _Ufill(pointer _Dest, const size_type _Count, _Value_init_tag) {

	push	edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1807 :             _Zero_range(_PFirst, _PFirst + _Count);

	lea	edi, DWORD PTR [eax*4]

; 1792 :     _CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

	push	edi
	push	0
	push	esi
	call	_memset
	add	esp, 12					; 0000000cH

; 1808 :             return _First + _Count;

	lea	eax, DWORD PTR [edi+esi]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1635 :         return _Uninitialized_value_construct_n(_Dest, _Count, _Getal());

	pop	edi
	pop	esi

; 1636 :     }

	ret	12					; 0000000cH
?_Ufill@?$vector@PAUIDirect3DVertexBuffer9@@V?$xalloc@PAUIDirect3DVertexBuffer9@@@@@std@@AAEPAPAUIDirect3DVertexBuffer9@@PAPAU3@IU_Value_init_tag@2@@Z ENDP ; std::vector<IDirect3DVertexBuffer9 *,xalloc<IDirect3DVertexBuffer9 *> >::_Ufill
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Orphan_range@?$vector@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@V?$xalloc@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@@@std@@ABEXPAV?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@0@Z
_TEXT	SEGMENT
___formal$dead$ = 8					; size = 4
___formal$dead$ = 12					; size = 4
?_Orphan_range@?$vector@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@V?$xalloc@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@@@std@@ABEXPAV?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@0@Z PROC ; std::vector<svector<_D3DVERTEXELEMENT9,65>,xalloc<svector<_D3DVERTEXELEMENT9,65> > >::_Orphan_range, COMDAT
; _this$dead$ = ecx

; 1801 :     _CONSTEXPR20_CONTAINER void _Orphan_range(pointer, pointer) const {}

	ret	8
?_Orphan_range@?$vector@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@V?$xalloc@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@@@std@@ABEXPAV?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@0@Z ENDP ; std::vector<svector<_D3DVERTEXELEMENT9,65>,xalloc<svector<_D3DVERTEXELEMENT9,65> > >::_Orphan_range
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Ufill@?$vector@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@V?$xalloc@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@@@std@@AAEPAV?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@PAV3@IU_Value_init_tag@2@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Count$ = 12						; size = 4
___formal$ = 16						; size = 1
?_Ufill@?$vector@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@V?$xalloc@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@@@std@@AAEPAV?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@PAV3@IU_Value_init_tag@2@@Z PROC ; std::vector<svector<_D3DVERTEXELEMENT9,65>,xalloc<svector<_D3DVERTEXELEMENT9,65> > >::_Ufill, COMDAT
; _this$dead$ = ecx

; 1634 :         // fill raw _Dest with _Count value-initialized objects, using allocator
; 1635 :         return _Uninitialized_value_construct_n(_Dest, _Count, _Getal());

	mov	ecx, DWORD PTR __Count$[esp-4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	eax, DWORD PTR __Dest$[esp-4]

; 1813 :     for (; 0 < _Count; --_Count) {

	test	ecx, ecx
	je	SHORT $LN5@Ufill
	npad	4
$LL6@Ufill:

; 1620 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

	mov	DWORD PTR [eax+520], 0

; 1621 :         ++_Last;

	add	eax, 524				; 0000020cH

; 1813 :     for (; 0 < _Count; --_Count) {

	sub	ecx, 1
	jne	SHORT $LL6@Ufill
$LN5@Ufill:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1636 :     }

	ret	12					; 0000000cH
?_Ufill@?$vector@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@V?$xalloc@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@@@std@@AAEPAV?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@PAV3@IU_Value_init_tag@2@@Z ENDP ; std::vector<svector<_D3DVERTEXELEMENT9,65>,xalloc<svector<_D3DVERTEXELEMENT9,65> > >::_Ufill
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Orphan_range@?$vector@V?$resptr_core@UShader@@Uresptrcode_shader@@@@V?$xalloc@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@@@std@@ABEXPAV?$resptr_core@UShader@@Uresptrcode_shader@@@@0@Z
_TEXT	SEGMENT
___formal$dead$ = 8					; size = 4
___formal$dead$ = 12					; size = 4
?_Orphan_range@?$vector@V?$resptr_core@UShader@@Uresptrcode_shader@@@@V?$xalloc@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@@@std@@ABEXPAV?$resptr_core@UShader@@Uresptrcode_shader@@@@0@Z PROC ; std::vector<resptr_core<Shader,resptrcode_shader>,xalloc<resptr_core<Shader,resptrcode_shader> > >::_Orphan_range, COMDAT
; _this$dead$ = ecx

; 1801 :     _CONSTEXPR20_CONTAINER void _Orphan_range(pointer, pointer) const {}

	ret	8
?_Orphan_range@?$vector@V?$resptr_core@UShader@@Uresptrcode_shader@@@@V?$xalloc@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@@@std@@ABEXPAV?$resptr_core@UShader@@Uresptrcode_shader@@@@0@Z ENDP ; std::vector<resptr_core<Shader,resptrcode_shader>,xalloc<resptr_core<Shader,resptrcode_shader> > >::_Orphan_range
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Ufill@?$vector@V?$resptr_core@UShader@@Uresptrcode_shader@@@@V?$xalloc@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@@@std@@AAEPAV?$resptr_core@UShader@@Uresptrcode_shader@@@@PAV3@IU_Value_init_tag@2@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Count$ = 12						; size = 4
___formal$ = 16						; size = 1
?_Ufill@?$vector@V?$resptr_core@UShader@@Uresptrcode_shader@@@@V?$xalloc@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@@@std@@AAEPAV?$resptr_core@UShader@@Uresptrcode_shader@@@@PAV3@IU_Value_init_tag@2@@Z PROC ; std::vector<resptr_core<Shader,resptrcode_shader>,xalloc<resptr_core<Shader,resptrcode_shader> > >::_Ufill, COMDAT
; _this$dead$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	edx, DWORD PTR __Dest$[esp-4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1633 :     _CONSTEXPR20_CONTAINER pointer _Ufill(pointer _Dest, const size_type _Count, _Value_init_tag) {

	push	esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1813 :     for (; 0 < _Count; --_Count) {

	mov	esi, DWORD PTR __Count$[esp]
	test	esi, esi
	je	SHORT $LN18@Ufill

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	push	edi
	mov	ecx, esi
	xor	eax, eax
	mov	edi, edx
	rep stosd
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1635 :         return _Uninitialized_value_construct_n(_Dest, _Count, _Getal());

	pop	edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	lea	eax, DWORD PTR [edx+esi*4]
	pop	esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1636 :     }

	ret	12					; 0000000cH
$LN18@Ufill:

; 1635 :         return _Uninitialized_value_construct_n(_Dest, _Count, _Getal());

	mov	eax, edx
	pop	esi

; 1636 :     }

	ret	12					; 0000000cH
?_Ufill@?$vector@V?$resptr_core@UShader@@Uresptrcode_shader@@@@V?$xalloc@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@@@std@@AAEPAV?$resptr_core@UShader@@Uresptrcode_shader@@@@PAV3@IU_Value_init_tag@2@@Z ENDP ; std::vector<resptr_core<Shader,resptrcode_shader>,xalloc<resptr_core<Shader,resptrcode_shader> > >::_Ufill
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrEngine\Fmesh.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Ufill@?$vector@UFSlideWindowItem@@V?$xalloc@UFSlideWindowItem@@@@@std@@AAEPAUFSlideWindowItem@@PAU3@IU_Value_init_tag@2@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Count$ = 12						; size = 4
___formal$ = 16						; size = 1
?_Ufill@?$vector@UFSlideWindowItem@@V?$xalloc@UFSlideWindowItem@@@@@std@@AAEPAUFSlideWindowItem@@PAU3@IU_Value_init_tag@2@@Z PROC ; std::vector<FSlideWindowItem,xalloc<FSlideWindowItem> >::_Ufill, COMDAT
; _this$dead$ = ecx

; 1634 :         // fill raw _Dest with _Count value-initialized objects, using allocator
; 1635 :         return _Uninitialized_value_construct_n(_Dest, _Count, _Getal());

	mov	ecx, DWORD PTR __Count$[esp-4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	eax, DWORD PTR __Dest$[esp-4]

; 1813 :     for (; 0 < _Count; --_Count) {

	test	ecx, ecx
	je	SHORT $LN5@Ufill
	npad	4
$LL6@Ufill:
; File I:\Vitalya\mine\NSProjectX\xrEngine\Fmesh.h

; 105  : 	FSlideWindowItem() : sw(0), count(0) {};

	mov	DWORD PTR [eax], 0
	mov	DWORD PTR [eax+4], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1621 :         ++_Last;

	add	eax, 24					; 00000018H

; 1813 :     for (; 0 < _Count; --_Count) {

	sub	ecx, 1
	jne	SHORT $LL6@Ufill
$LN5@Ufill:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1636 :     }

	ret	12					; 0000000cH
?_Ufill@?$vector@UFSlideWindowItem@@V?$xalloc@UFSlideWindowItem@@@@@std@@AAEPAUFSlideWindowItem@@PAU3@IU_Value_init_tag@2@@Z ENDP ; std::vector<FSlideWindowItem,xalloc<FSlideWindowItem> >::_Ufill
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Orphan_range@?$vector@PAVIRender_Portal@@V?$xalloc@PAVIRender_Portal@@@@@std@@ABEXPAPAVIRender_Portal@@0@Z
_TEXT	SEGMENT
___formal$dead$ = 8					; size = 4
___formal$dead$ = 12					; size = 4
?_Orphan_range@?$vector@PAVIRender_Portal@@V?$xalloc@PAVIRender_Portal@@@@@std@@ABEXPAPAVIRender_Portal@@0@Z PROC ; std::vector<IRender_Portal *,xalloc<IRender_Portal *> >::_Orphan_range, COMDAT
; _this$dead$ = ecx

; 1801 :     _CONSTEXPR20_CONTAINER void _Orphan_range(pointer, pointer) const {}

	ret	8
?_Orphan_range@?$vector@PAVIRender_Portal@@V?$xalloc@PAVIRender_Portal@@@@@std@@ABEXPAPAVIRender_Portal@@0@Z ENDP ; std::vector<IRender_Portal *,xalloc<IRender_Portal *> >::_Orphan_range
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Ufill@?$vector@PAVIRender_Portal@@V?$xalloc@PAVIRender_Portal@@@@@std@@AAEPAPAVIRender_Portal@@PAPAV3@IU_Value_init_tag@2@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Count$ = 12						; size = 4
___formal$ = 16						; size = 1
?_Ufill@?$vector@PAVIRender_Portal@@V?$xalloc@PAVIRender_Portal@@@@@std@@AAEPAPAVIRender_Portal@@PAPAV3@IU_Value_init_tag@2@@Z PROC ; std::vector<IRender_Portal *,xalloc<IRender_Portal *> >::_Ufill, COMDAT
; _this$dead$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1807 :             _Zero_range(_PFirst, _PFirst + _Count);

	mov	eax, DWORD PTR __Count$[esp-4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1633 :     _CONSTEXPR20_CONTAINER pointer _Ufill(pointer _Dest, const size_type _Count, _Value_init_tag) {

	push	esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1792 :     _CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

	mov	esi, DWORD PTR __Dest$[esp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1633 :     _CONSTEXPR20_CONTAINER pointer _Ufill(pointer _Dest, const size_type _Count, _Value_init_tag) {

	push	edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1807 :             _Zero_range(_PFirst, _PFirst + _Count);

	lea	edi, DWORD PTR [eax*4]

; 1792 :     _CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

	push	edi
	push	0
	push	esi
	call	_memset
	add	esp, 12					; 0000000cH

; 1808 :             return _First + _Count;

	lea	eax, DWORD PTR [edi+esi]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1635 :         return _Uninitialized_value_construct_n(_Dest, _Count, _Getal());

	pop	edi
	pop	esi

; 1636 :     }

	ret	12					; 0000000cH
?_Ufill@?$vector@PAVIRender_Portal@@V?$xalloc@PAVIRender_Portal@@@@@std@@AAEPAPAVIRender_Portal@@PAPAV3@IU_Value_init_tag@2@@Z ENDP ; std::vector<IRender_Portal *,xalloc<IRender_Portal *> >::_Ufill
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ??_GCLightShadows@@QAEPAXI@Z
_TEXT	SEGMENT
___flags$dead$ = 8					; size = 4
??_GCLightShadows@@QAEPAXI@Z PROC			; CLightShadows::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	call	??1CLightShadows@@QAE@XZ		; CLightShadows::~CLightShadows
	mov	eax, esi
	pop	esi
	ret	4
??_GCLightShadows@@QAEPAXI@Z ENDP			; CLightShadows::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ??_GCLightProjector@@QAEPAXI@Z
_TEXT	SEGMENT
___flags$dead$ = 8					; size = 4
??_GCLightProjector@@QAEPAXI@Z PROC			; CLightProjector::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	call	??1CLightProjector@@QAE@XZ		; CLightProjector::~CLightProjector
	mov	eax, esi
	pop	esi
	ret	4
??_GCLightProjector@@QAEPAXI@Z ENDP			; CLightProjector::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\Light_DB.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\Light_DB.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??_GCLight_DB@@QAEPAXI@Z
_TEXT	SEGMENT
___flags$dead$ = 8					; size = 4
??_GCLight_DB@@QAEPAXI@Z PROC				; CLight_DB::`scalar deleting destructor', COMDAT
; _this$ = ecx
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\Light_DB.cpp

; 14   : }

	push	esi
	mov	esi, ecx
	lea	ecx, DWORD PTR [esi+20]
	call	??1light_Package@@QAE@XZ
	lea	ecx, DWORD PTR [esi+16]
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 64   : 						~resptr_core	()												{	_dec();						}

	call	DWORD PTR __imp_?_dec@?$resptr_base@VIRender_Light@@@@IAEXXZ
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\Light_DB.cpp

; 14   : }

	lea	ecx, DWORD PTR [esi+12]
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 64   : 						~resptr_core	()												{	_dec();						}

	call	DWORD PTR __imp_?_dec@?$resptr_base@VIRender_Light@@@@IAEXXZ
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN22@scalar
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+4], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+8], 0
$LN22@scalar:
	mov	eax, esi
	pop	esi
	ret	4
??_GCLight_DB@@QAEPAXI@Z ENDP				; CLight_DB::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??_GCGlowManager@@QAEPAXI@Z
_TEXT	SEGMENT
___flags$dead$ = 8					; size = 4
??_GCGlowManager@@QAEPAXI@Z PROC			; CGlowManager::`scalar deleting destructor', COMDAT
; _this$ = ecx
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp

; 92   : }

	push	esi
	mov	esi, ecx
	push	edi
	lea	ecx, DWORD PTR [esi+60]
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 64   : 						~resptr_core	()												{	_dec();						}

	call	DWORD PTR __imp_?_dec@?$resptr_base@USGeometry@@@@IAEXXZ
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [esi+48]
	mov	edi, DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
	test	eax, eax
	je	SHORT $LN13@scalar
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi+48], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+52], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+56], 0
$LN13@scalar:

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [esi+36]
	test	eax, eax
	je	SHORT $LN25@scalar
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi+36], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+40], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+44], 0
$LN25@scalar:

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [esi+24]
	test	eax, eax
	je	SHORT $LN37@scalar
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi+24], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+28], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+32], 0
$LN37@scalar:

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [esi+12]
	test	eax, eax
	je	SHORT $LN49@scalar
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi+12], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+16], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+20], 0
$LN49@scalar:

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN68@scalar
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+4], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+8], 0
$LN68@scalar:
	pop	edi
	mov	eax, esi
	pop	esi
	ret	4
??_GCGlowManager@@QAEPAXI@Z ENDP			; CGlowManager::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??_GCWallmarksEngine@@QAEPAXI@Z
_TEXT	SEGMENT
___flags$dead$ = 8					; size = 4
??_GCWallmarksEngine@@QAEPAXI@Z PROC			; CWallmarksEngine::`scalar deleting destructor', COMDAT
; _this$ = ecx
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp

; 61   : 	clear			();

	push	ebx
	push	esi
	push	edi
	mov	esi, ecx
	call	?clear@CWallmarksEngine@@QAEXXZ		; CWallmarksEngine::clear
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 46   : 	ICF		void		_set	(T * rhs) 							{	if (0!=rhs) rhs->dwReference++;	_dec(); p_ = rhs;											}

	lea	ecx, DWORD PTR [esi+24]
	call	DWORD PTR __imp_?_dec@?$resptr_base@USGeometry@@@@IAEXXZ
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp

; 63   : }

	lea	ecx, DWORD PTR [esi+1504]
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 46   : 	ICF		void		_set	(T * rhs) 							{	if (0!=rhs) rhs->dwReference++;	_dec(); p_ = rhs;											}

	mov	DWORD PTR [esi+24], 0
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp

; 63   : }

	call	DWORD PTR __imp_??1xrCriticalSection@@QAE@XZ
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [esi+1492]
	mov	edi, DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
	test	eax, eax
	je	SHORT $LN16@scalar
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi+1492], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+1496], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+1500], 0
$LN16@scalar:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp

; 63   : }

	lea	ecx, DWORD PTR [esi+1468]
	call	DWORD PTR __imp_??1Collector@CDB@@QAE@XZ
	lea	ecx, DWORD PTR [esi+1444]
	call	DWORD PTR __imp_??1xrXRC@@QAE@XZ
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 64   : 						~resptr_core	()												{	_dec();						}

	lea	ecx, DWORD PTR [esi+24]
	call	DWORD PTR __imp_?_dec@?$resptr_base@USGeometry@@@@IAEXXZ
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [esi+12]
	test	eax, eax
	je	SHORT $LN30@scalar
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi+12], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+16], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+20], 0
$LN30@scalar:

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN49@scalar
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+4], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+8], 0
$LN49@scalar:
	pop	edi
	mov	eax, esi
	pop	esi
	pop	ebx
	ret	4
??_GCWallmarksEngine@@QAEPAXI@Z ENDP			; CWallmarksEngine::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@PAUIDirect3DIndexBuffer9@@V?$xalloc@PAUIDirect3DIndexBuffer9@@@@@std@@AAEXIABU_Value_init_tag@1@@Z
_TEXT	SEGMENT
__Backout$2 = -40					; size = 12
__Newvec$ = -28						; size = 4
__UFirst$3 = -24					; size = 4
__Newcapacity$1$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Newsize$ = 8						; size = 4
__Val$dead$ = 12					; size = 4
??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@PAUIDirect3DIndexBuffer9@@V?$xalloc@PAUIDirect3DIndexBuffer9@@@@@std@@AAEXIABU_Value_init_tag@1@@Z PROC ; std::vector<IDirect3DIndexBuffer9 *,xalloc<IDirect3DIndexBuffer9 *> >::_Resize_reallocate<std::_Value_init_tag>, COMDAT
; _this$ = ecx

; 1216 :     _CONSTEXPR20_CONTAINER void _Resize_reallocate(const size_type _Newsize, const _Ty2& _Val) {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@PAUIDirect3DIndexBuffer9@@V?$xalloc@PAUIDirect3DIndexBuffer9@@@@@std@@AAEXIABU_Value_init_tag@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 28					; 0000001cH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	esi, ecx

; 1217 :         if (_Newsize > max_size()) {

	mov	edx, DWORD PTR __Newsize$[ebp]
	cmp	edx, 1073741823				; 3fffffffH
	ja	$LN66@Resize_rea

; 1219 :         }
; 1220 : 
; 1221 :         auto& _My_data    = _Mypair._Myval2;
; 1222 :         pointer& _Myfirst = _My_data._Myfirst;
; 1223 :         pointer& _Mylast  = _My_data._Mylast;
; 1224 : 
; 1225 :         const auto _Oldsize          = static_cast<size_type>(_Mylast - _Myfirst);

	mov	edi, DWORD PTR [esi+4]
	sub	edi, DWORD PTR [esi]
	sar	edi, 2

; 1546 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	ecx, DWORD PTR [esi+8]
	sub	ecx, DWORD PTR [esi]
	sar	ecx, 2

; 1675 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	ebx, ecx
	shr	ebx, 1
	mov	eax, 1073741823				; 3fffffffH
	sub	eax, ebx
	cmp	ecx, eax
	jbe	SHORT $LN10@Resize_rea

; 1676 :             return _Max; // geometric growth would overflow

	mov	eax, 1073741823				; 3fffffffH
	jmp	SHORT $LN64@Resize_rea
$LN10@Resize_rea:

; 1677 :         }
; 1678 : 
; 1679 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	lea	eax, DWORD PTR [ebx+ecx]

; 1680 : 
; 1681 :         if (_Geometric < _Newsize) {

	cmp	eax, edx
	cmovb	eax, edx
$LN64@Resize_rea:
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	mov	DWORD PTR __Newcapacity$1$[ebp], eax
	shl	eax, 2
	push	eax
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1228 :         const pointer _Newvec         = _Getal().allocate(_Newcapacity);

	mov	ebx, eax
	mov	DWORD PTR __Newvec$[ebp], ebx

; 1229 :         const pointer _Appended_first = _Newvec + _Oldsize;

	lea	ecx, DWORD PTR [ebx+edi*4]

; 1230 :         pointer _Appended_last        = _Appended_first;
; 1231 : 
; 1232 :         _TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 1233 :         _Appended_last = _Ufill(_Appended_first, _Newsize - _Oldsize, _Val);

	mov	eax, DWORD PTR __Newsize$[ebp]
	sub	eax, edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1807 :             _Zero_range(_PFirst, _PFirst + _Count);

	shl	eax, 2

; 1792 :     _CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

	push	eax
	push	0
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1234 :         _Umove_if_noexcept(_Myfirst, _Mylast, _Newvec);

	mov	edi, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1703 :     auto _UFirst      = _Get_unwrapped(_First);

	mov	DWORD PTR __UFirst$3[ebp], ecx

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	DWORD PTR __Backout$2[ebp], ebx
	mov	edx, ebx
	mov	DWORD PTR __Backout$2[ebp+4], edx
	mov	DWORD PTR __Backout$2[ebp+8], esi
	npad	7
$LL43@Resize_rea:

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	ecx, edi
	je	SHORT $LN42@Resize_rea

; 1620 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax

; 1621 :         ++_Last;

	add	edx, 4
	mov	DWORD PTR __Backout$2[ebp+4], edx

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	add	ecx, 4
	mov	DWORD PTR __UFirst$3[ebp], ecx
	jmp	SHORT $LL43@Resize_rea
$LN42@Resize_rea:

; 1625 :         _First = _Last;

	mov	DWORD PTR __Backout$2[ebp], edx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
	mov	DWORD PTR __$EHRec$[ebp+12], -1

; 1732 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN57@Resize_rea
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	push	eax
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN57@Resize_rea:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1737 :         _Myfirst = _Newvec;

	mov	DWORD PTR [esi], ebx

; 1738 :         _Mylast  = _Newvec + _Newsize;

	mov	eax, DWORD PTR __Newsize$[ebp]
	lea	eax, DWORD PTR [ebx+eax*4]
	mov	DWORD PTR [esi+4], eax

; 1739 :         _Myend   = _Newvec + _Newcapacity;

	mov	eax, DWORD PTR __Newcapacity$1$[ebp]
	lea	eax, DWORD PTR [ebx+eax*4]
	mov	DWORD PTR [esi+8], eax

; 1239 :         _CATCH_END
; 1240 : 
; 1241 :         _Change_array(_Newvec, _Newsize, _Newcapacity);
; 1242 :     }

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
__catch$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@PAUIDirect3DIndexBuffer9@@V?$xalloc@PAUIDirect3DIndexBuffer9@@@@@std@@AAEXIABU_Value_init_tag@1@@Z$0:

; 1235 :         _CATCH_ALL
; 1236 :         _Destroy(_Appended_first, _Appended_last);
; 1237 :         _Getal().deallocate(_Newvec, _Newcapacity);

	push	ecx
	push	DWORD PTR __Newvec$[ebp]
	call	?deallocate@?$xalloc@PAUIDirect3DIndexBuffer9@@@@QBEXPAPAUIDirect3DIndexBuffer9@@I@Z ; xalloc<IDirect3DIndexBuffer9 *>::deallocate

; 1238 :         _RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$LN66@Resize_rea:

; 1218 :             _Xlength();

	call	?_Xlength@?$vector@PAUIDirect3DIndexBuffer9@@V?$xalloc@PAUIDirect3DIndexBuffer9@@@@@std@@CAXXZ ; std::vector<IDirect3DIndexBuffer9 *,xalloc<IDirect3DIndexBuffer9 *> >::_Xlength
$LN63@Resize_rea:
	int	3
	int	3
	int	3
	int	3
	int	3
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@PAUIDirect3DIndexBuffer9@@V?$xalloc@PAUIDirect3DIndexBuffer9@@@@@std@@AAEXIABU_Value_init_tag@1@@Z:
	npad	1
	npad	1
	mov	eax, OFFSET __ehfuncinfo$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@PAUIDirect3DIndexBuffer9@@V?$xalloc@PAUIDirect3DIndexBuffer9@@@@@std@@AAEXIABU_Value_init_tag@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@PAUIDirect3DIndexBuffer9@@V?$xalloc@PAUIDirect3DIndexBuffer9@@@@@std@@AAEXIABU_Value_init_tag@1@@Z ENDP ; std::vector<IDirect3DIndexBuffer9 *,xalloc<IDirect3DIndexBuffer9 *> >::_Resize_reallocate<std::_Value_init_tag>
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@PAUIDirect3DVertexBuffer9@@V?$xalloc@PAUIDirect3DVertexBuffer9@@@@@std@@AAEXIABU_Value_init_tag@1@@Z
_TEXT	SEGMENT
__Backout$2 = -40					; size = 12
__Newvec$ = -28						; size = 4
__UFirst$3 = -24					; size = 4
__Newcapacity$1$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Newsize$ = 8						; size = 4
__Val$dead$ = 12					; size = 4
??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@PAUIDirect3DVertexBuffer9@@V?$xalloc@PAUIDirect3DVertexBuffer9@@@@@std@@AAEXIABU_Value_init_tag@1@@Z PROC ; std::vector<IDirect3DVertexBuffer9 *,xalloc<IDirect3DVertexBuffer9 *> >::_Resize_reallocate<std::_Value_init_tag>, COMDAT
; _this$ = ecx

; 1216 :     _CONSTEXPR20_CONTAINER void _Resize_reallocate(const size_type _Newsize, const _Ty2& _Val) {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@PAUIDirect3DVertexBuffer9@@V?$xalloc@PAUIDirect3DVertexBuffer9@@@@@std@@AAEXIABU_Value_init_tag@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 28					; 0000001cH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	esi, ecx

; 1217 :         if (_Newsize > max_size()) {

	mov	edx, DWORD PTR __Newsize$[ebp]
	cmp	edx, 1073741823				; 3fffffffH
	ja	$LN66@Resize_rea

; 1219 :         }
; 1220 : 
; 1221 :         auto& _My_data    = _Mypair._Myval2;
; 1222 :         pointer& _Myfirst = _My_data._Myfirst;
; 1223 :         pointer& _Mylast  = _My_data._Mylast;
; 1224 : 
; 1225 :         const auto _Oldsize          = static_cast<size_type>(_Mylast - _Myfirst);

	mov	edi, DWORD PTR [esi+4]
	sub	edi, DWORD PTR [esi]
	sar	edi, 2

; 1546 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	ecx, DWORD PTR [esi+8]
	sub	ecx, DWORD PTR [esi]
	sar	ecx, 2

; 1675 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	ebx, ecx
	shr	ebx, 1
	mov	eax, 1073741823				; 3fffffffH
	sub	eax, ebx
	cmp	ecx, eax
	jbe	SHORT $LN10@Resize_rea

; 1676 :             return _Max; // geometric growth would overflow

	mov	eax, 1073741823				; 3fffffffH
	jmp	SHORT $LN64@Resize_rea
$LN10@Resize_rea:

; 1677 :         }
; 1678 : 
; 1679 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	lea	eax, DWORD PTR [ebx+ecx]

; 1680 : 
; 1681 :         if (_Geometric < _Newsize) {

	cmp	eax, edx
	cmovb	eax, edx
$LN64@Resize_rea:
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	mov	DWORD PTR __Newcapacity$1$[ebp], eax
	shl	eax, 2
	push	eax
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1228 :         const pointer _Newvec         = _Getal().allocate(_Newcapacity);

	mov	ebx, eax
	mov	DWORD PTR __Newvec$[ebp], ebx

; 1229 :         const pointer _Appended_first = _Newvec + _Oldsize;

	lea	ecx, DWORD PTR [ebx+edi*4]

; 1230 :         pointer _Appended_last        = _Appended_first;
; 1231 : 
; 1232 :         _TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 1233 :         _Appended_last = _Ufill(_Appended_first, _Newsize - _Oldsize, _Val);

	mov	eax, DWORD PTR __Newsize$[ebp]
	sub	eax, edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1807 :             _Zero_range(_PFirst, _PFirst + _Count);

	shl	eax, 2

; 1792 :     _CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

	push	eax
	push	0
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1234 :         _Umove_if_noexcept(_Myfirst, _Mylast, _Newvec);

	mov	edi, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1703 :     auto _UFirst      = _Get_unwrapped(_First);

	mov	DWORD PTR __UFirst$3[ebp], ecx

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	DWORD PTR __Backout$2[ebp], ebx
	mov	edx, ebx
	mov	DWORD PTR __Backout$2[ebp+4], edx
	mov	DWORD PTR __Backout$2[ebp+8], esi
	npad	7
$LL43@Resize_rea:

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	ecx, edi
	je	SHORT $LN42@Resize_rea

; 1620 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax

; 1621 :         ++_Last;

	add	edx, 4
	mov	DWORD PTR __Backout$2[ebp+4], edx

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	add	ecx, 4
	mov	DWORD PTR __UFirst$3[ebp], ecx
	jmp	SHORT $LL43@Resize_rea
$LN42@Resize_rea:

; 1625 :         _First = _Last;

	mov	DWORD PTR __Backout$2[ebp], edx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
	mov	DWORD PTR __$EHRec$[ebp+12], -1

; 1732 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN57@Resize_rea
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	push	eax
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN57@Resize_rea:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1737 :         _Myfirst = _Newvec;

	mov	DWORD PTR [esi], ebx

; 1738 :         _Mylast  = _Newvec + _Newsize;

	mov	eax, DWORD PTR __Newsize$[ebp]
	lea	eax, DWORD PTR [ebx+eax*4]
	mov	DWORD PTR [esi+4], eax

; 1739 :         _Myend   = _Newvec + _Newcapacity;

	mov	eax, DWORD PTR __Newcapacity$1$[ebp]
	lea	eax, DWORD PTR [ebx+eax*4]
	mov	DWORD PTR [esi+8], eax

; 1239 :         _CATCH_END
; 1240 : 
; 1241 :         _Change_array(_Newvec, _Newsize, _Newcapacity);
; 1242 :     }

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
__catch$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@PAUIDirect3DVertexBuffer9@@V?$xalloc@PAUIDirect3DVertexBuffer9@@@@@std@@AAEXIABU_Value_init_tag@1@@Z$0:

; 1235 :         _CATCH_ALL
; 1236 :         _Destroy(_Appended_first, _Appended_last);
; 1237 :         _Getal().deallocate(_Newvec, _Newcapacity);

	push	ecx
	push	DWORD PTR __Newvec$[ebp]
	call	?deallocate@?$xalloc@PAUIDirect3DVertexBuffer9@@@@QBEXPAPAUIDirect3DVertexBuffer9@@I@Z ; xalloc<IDirect3DVertexBuffer9 *>::deallocate

; 1238 :         _RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$LN66@Resize_rea:

; 1218 :             _Xlength();

	call	?_Xlength@?$vector@PAUIDirect3DVertexBuffer9@@V?$xalloc@PAUIDirect3DVertexBuffer9@@@@@std@@CAXXZ ; std::vector<IDirect3DVertexBuffer9 *,xalloc<IDirect3DVertexBuffer9 *> >::_Xlength
$LN63@Resize_rea:
	int	3
	int	3
	int	3
	int	3
	int	3
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@PAUIDirect3DVertexBuffer9@@V?$xalloc@PAUIDirect3DVertexBuffer9@@@@@std@@AAEXIABU_Value_init_tag@1@@Z:
	npad	1
	npad	1
	mov	eax, OFFSET __ehfuncinfo$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@PAUIDirect3DVertexBuffer9@@V?$xalloc@PAUIDirect3DVertexBuffer9@@@@@std@@AAEXIABU_Value_init_tag@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@PAUIDirect3DVertexBuffer9@@V?$xalloc@PAUIDirect3DVertexBuffer9@@@@@std@@AAEXIABU_Value_init_tag@1@@Z ENDP ; std::vector<IDirect3DVertexBuffer9 *,xalloc<IDirect3DVertexBuffer9 *> >::_Resize_reallocate<std::_Value_init_tag>
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@V?$xalloc@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@@@std@@AAEXIABU_Value_init_tag@1@@Z
_TEXT	SEGMENT
__Backout$2 = -44					; size = 12
__UFirst$3 = -32					; size = 4
__Oldsize$1$ = -28					; size = 4
__Newvec$ = -24						; size = 4
__Newcapacity$1$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Newsize$ = 8						; size = 4
__ULast$1$ = 12						; size = 4
__Val$ = 12						; size = 4
??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@V?$xalloc@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@@@std@@AAEXIABU_Value_init_tag@1@@Z PROC ; std::vector<svector<_D3DVERTEXELEMENT9,65>,xalloc<svector<_D3DVERTEXELEMENT9,65> > >::_Resize_reallocate<std::_Value_init_tag>, COMDAT
; _this$ = ecx

; 1216 :     _CONSTEXPR20_CONTAINER void _Resize_reallocate(const size_type _Newsize, const _Ty2& _Val) {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@V?$xalloc@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@@@std@@AAEXIABU_Value_init_tag@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 32					; 00000020H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	ebx, ecx

; 1217 :         if (_Newsize > max_size()) {

	cmp	DWORD PTR __Newsize$[ebp], 8196502	; 007d1196H
	ja	$LN53@Resize_rea

; 1219 :         }
; 1220 : 
; 1221 :         auto& _My_data    = _Mypair._Myval2;
; 1222 :         pointer& _Myfirst = _My_data._Myfirst;
; 1223 :         pointer& _Mylast  = _My_data._Mylast;
; 1224 : 
; 1225 :         const auto _Oldsize          = static_cast<size_type>(_Mylast - _Myfirst);

	mov	ecx, DWORD PTR [ebx+4]
	sub	ecx, DWORD PTR [ebx]
	mov	eax, 1049152317				; 3e88cb3dH
	imul	ecx
	sar	edx, 7
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	mov	DWORD PTR __Oldsize$1$[ebp], eax

; 1546 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	ecx, DWORD PTR [ebx+8]
	sub	ecx, DWORD PTR [ebx]
	mov	eax, 1049152317				; 3e88cb3dH
	imul	ecx
	sar	edx, 7
	mov	ecx, edx
	shr	ecx, 31					; 0000001fH
	add	ecx, edx

; 1675 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	edx, ecx
	shr	edx, 1
	mov	eax, 8196502				; 007d1196H
	sub	eax, edx
	cmp	ecx, eax
	jbe	SHORT $LN10@Resize_rea

; 1676 :             return _Max; // geometric growth would overflow

	mov	edi, 8196502				; 007d1196H
	jmp	SHORT $LN51@Resize_rea
$LN10@Resize_rea:

; 1677 :         }
; 1678 : 
; 1679 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	lea	edi, DWORD PTR [edx+ecx]

; 1680 : 
; 1681 :         if (_Geometric < _Newsize) {

	cmp	edi, DWORD PTR __Newsize$[ebp]
	cmovb	edi, DWORD PTR __Newsize$[ebp]
$LN51@Resize_rea:
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	mov	DWORD PTR __Newcapacity$1$[ebp], edi
	imul	eax, edi, 524
	push	eax
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1228 :         const pointer _Newvec         = _Getal().allocate(_Newcapacity);

	mov	esi, eax
	mov	DWORD PTR __Newvec$[ebp], esi

; 1229 :         const pointer _Appended_first = _Newvec + _Oldsize;

	mov	edx, DWORD PTR __Oldsize$1$[ebp]
	imul	ecx, edx, 524
	add	ecx, esi

; 1230 :         pointer _Appended_last        = _Appended_first;
; 1231 : 
; 1232 :         _TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 1233 :         _Appended_last = _Ufill(_Appended_first, _Newsize - _Oldsize, _Val);

	mov	eax, DWORD PTR __Val$[ebp]
	movzx	eax, BYTE PTR [eax]
	push	eax
	mov	eax, DWORD PTR __Newsize$[ebp]
	sub	eax, edx
	push	eax
	push	ecx
	call	?_Ufill@?$vector@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@V?$xalloc@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@@@std@@AAEPAV?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@PAV3@IU_Value_init_tag@2@@Z ; std::vector<svector<_D3DVERTEXELEMENT9,65>,xalloc<svector<_D3DVERTEXELEMENT9,65> > >::_Ufill

; 1234 :         _Umove_if_noexcept(_Myfirst, _Mylast, _Newvec);

	mov	ecx, DWORD PTR [ebx+4]
	mov	DWORD PTR __ULast$1$[ebp], ecx
	mov	eax, DWORD PTR [ebx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1703 :     auto _UFirst      = _Get_unwrapped(_First);

	mov	DWORD PTR __UFirst$3[ebp], eax

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	DWORD PTR __Backout$2[ebp], esi
	mov	edx, esi
	mov	DWORD PTR __Backout$2[ebp+4], edx
	mov	DWORD PTR __Backout$2[ebp+8], ebx
$LL26@Resize_rea:

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	eax, ecx
	je	SHORT $LN25@Resize_rea
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	ecx, 131				; 00000083H
	mov	esi, eax
	mov	edi, edx
	rep movsd
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1621 :         ++_Last;

	add	edx, 524				; 0000020cH
	mov	DWORD PTR __Backout$2[ebp+4], edx

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	add	eax, 524				; 0000020cH
	mov	DWORD PTR __UFirst$3[ebp], eax
	mov	ecx, DWORD PTR __ULast$1$[ebp]
	jmp	SHORT $LL26@Resize_rea
$LN25@Resize_rea:

; 1625 :         _First = _Last;

	mov	DWORD PTR __Backout$2[ebp], edx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
	mov	DWORD PTR __$EHRec$[ebp+12], -1

; 1732 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [ebx]
	test	eax, eax
	je	SHORT $LN44@Resize_rea
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	push	eax
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN44@Resize_rea:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1737 :         _Myfirst = _Newvec;

	mov	ecx, DWORD PTR __Newvec$[ebp]
	mov	DWORD PTR [ebx], ecx

; 1738 :         _Mylast  = _Newvec + _Newsize;

	imul	eax, DWORD PTR __Newsize$[ebp], 524
	add	eax, ecx
	mov	DWORD PTR [ebx+4], eax

; 1739 :         _Myend   = _Newvec + _Newcapacity;

	imul	eax, DWORD PTR __Newcapacity$1$[ebp], 524
	add	eax, ecx
	mov	DWORD PTR [ebx+8], eax

; 1239 :         _CATCH_END
; 1240 : 
; 1241 :         _Change_array(_Newvec, _Newsize, _Newcapacity);
; 1242 :     }

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
__catch$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@V?$xalloc@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@@@std@@AAEXIABU_Value_init_tag@1@@Z$0:

; 1235 :         _CATCH_ALL
; 1236 :         _Destroy(_Appended_first, _Appended_last);
; 1237 :         _Getal().deallocate(_Newvec, _Newcapacity);

	push	ecx
	push	DWORD PTR __Newvec$[ebp]
	call	?deallocate@?$xalloc@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@@QBEXPAV?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@I@Z ; xalloc<svector<_D3DVERTEXELEMENT9,65> >::deallocate

; 1238 :         _RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$LN53@Resize_rea:

; 1218 :             _Xlength();

	call	?_Xlength@?$vector@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@V?$xalloc@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@@@std@@CAXXZ ; std::vector<svector<_D3DVERTEXELEMENT9,65>,xalloc<svector<_D3DVERTEXELEMENT9,65> > >::_Xlength
$LN50@Resize_rea:
	int	3
	int	3
	int	3
	int	3
	int	3
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@V?$xalloc@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@@@std@@AAEXIABU_Value_init_tag@1@@Z:
	npad	1
	npad	1
	mov	eax, OFFSET __ehfuncinfo$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@V?$xalloc@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@@@std@@AAEXIABU_Value_init_tag@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@V?$xalloc@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@@@std@@AAEXIABU_Value_init_tag@1@@Z ENDP ; std::vector<svector<_D3DVERTEXELEMENT9,65>,xalloc<svector<_D3DVERTEXELEMENT9,65> > >::_Resize_reallocate<std::_Value_init_tag>
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@V?$resptr_core@UShader@@Uresptrcode_shader@@@@V?$xalloc@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@@@std@@AAEXIABU_Value_init_tag@1@@Z
_TEXT	SEGMENT
__Backout$2 = -56					; size = 12
__Backout$3 = -44					; size = 12
__Newvec$ = -32						; size = 4
__UFirst$4 = -28					; size = 4
__Count$ = -24						; size = 4
__Newcapacity$1$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Newsize$ = 8						; size = 4
__Val$dead$ = 12					; size = 4
??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@V?$resptr_core@UShader@@Uresptrcode_shader@@@@V?$xalloc@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@@@std@@AAEXIABU_Value_init_tag@1@@Z PROC ; std::vector<resptr_core<Shader,resptrcode_shader>,xalloc<resptr_core<Shader,resptrcode_shader> > >::_Resize_reallocate<std::_Value_init_tag>, COMDAT
; _this$ = ecx

; 1216 :     _CONSTEXPR20_CONTAINER void _Resize_reallocate(const size_type _Newsize, const _Ty2& _Val) {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@V?$resptr_core@UShader@@Uresptrcode_shader@@@@V?$xalloc@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@@@std@@AAEXIABU_Value_init_tag@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 44					; 0000002cH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	esi, ecx

; 1217 :         if (_Newsize > max_size()) {

	mov	ebx, DWORD PTR __Newsize$[ebp]
	cmp	ebx, 1073741823				; 3fffffffH
	ja	$LN74@Resize_rea

; 1219 :         }
; 1220 : 
; 1221 :         auto& _My_data    = _Mypair._Myval2;
; 1222 :         pointer& _Myfirst = _My_data._Myfirst;
; 1223 :         pointer& _Mylast  = _My_data._Mylast;
; 1224 : 
; 1225 :         const auto _Oldsize          = static_cast<size_type>(_Mylast - _Myfirst);

	mov	edi, DWORD PTR [esi+4]
	sub	edi, DWORD PTR [esi]
	sar	edi, 2

; 1546 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	ecx, DWORD PTR [esi+8]
	sub	ecx, DWORD PTR [esi]
	sar	ecx, 2

; 1675 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	edx, ecx
	shr	edx, 1
	mov	eax, 1073741823				; 3fffffffH
	sub	eax, edx
	cmp	ecx, eax
	jbe	SHORT $LN10@Resize_rea

; 1676 :             return _Max; // geometric growth would overflow

	mov	eax, 1073741823				; 3fffffffH
	jmp	SHORT $LN72@Resize_rea
$LN10@Resize_rea:

; 1677 :         }
; 1678 : 
; 1679 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	lea	eax, DWORD PTR [edx+ecx]

; 1680 : 
; 1681 :         if (_Geometric < _Newsize) {

	cmp	eax, ebx
	cmovb	eax, ebx
$LN72@Resize_rea:
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	mov	DWORD PTR __Newcapacity$1$[ebp], eax
	shl	eax, 2
	push	eax
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1228 :         const pointer _Newvec         = _Getal().allocate(_Newcapacity);

	mov	ebx, eax
	mov	DWORD PTR __Newvec$[ebp], ebx

; 1229 :         const pointer _Appended_first = _Newvec + _Oldsize;

	lea	ecx, DWORD PTR [ebx+edi*4]

; 1230 :         pointer _Appended_last        = _Appended_first;
; 1231 : 
; 1232 :         _TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 1233 :         _Appended_last = _Ufill(_Appended_first, _Newsize - _Oldsize, _Val);

	mov	eax, DWORD PTR __Newsize$[ebp]
	sub	eax, edi

; 1635 :         return _Uninitialized_value_construct_n(_Dest, _Count, _Getal());

	mov	DWORD PTR __Count$[ebp], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	DWORD PTR __Backout$3[ebp], ecx
	mov	DWORD PTR __Backout$3[ebp+4], ecx
	mov	DWORD PTR __Backout$3[ebp+8], esi
$LL24@Resize_rea:

; 1813 :     for (; 0 < _Count; --_Count) {

	test	eax, eax
	je	SHORT $LN23@Resize_rea

; 1620 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

	mov	DWORD PTR [ecx], 0

; 1621 :         ++_Last;

	add	ecx, 4
	mov	DWORD PTR __Backout$3[ebp+4], ecx

; 1813 :     for (; 0 < _Count; --_Count) {

	dec	eax
	mov	DWORD PTR __Count$[ebp], eax
	jmp	SHORT $LL24@Resize_rea
$LN23@Resize_rea:

; 1625 :         _First = _Last;

	mov	DWORD PTR __Backout$3[ebp], ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1234 :         _Umove_if_noexcept(_Myfirst, _Mylast, _Newvec);

	mov	edi, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1642 :     auto _UFirst      = _Get_unwrapped(_First);

	mov	DWORD PTR __UFirst$4[ebp], ecx

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	DWORD PTR __Backout$2[ebp], ebx
	mov	eax, ebx
	mov	DWORD PTR __Backout$2[ebp+4], eax
	mov	DWORD PTR __Backout$2[ebp+8], esi

; 1658 :     for (; _UFirst != _ULast; ++_UFirst) {

	mov	edx, ebx
$LL39@Resize_rea:
	cmp	ecx, edi
	je	SHORT $LN38@Resize_rea
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 63   : 						resptr_core		(const self & rhs)								{	p_ = rhs.p_; _inc();		}

	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax

; 43   : 	void				_inc	()									{	if (0==p_) return;	p_->dwReference++;														}

	test	eax, eax
	je	SHORT $LN51@Resize_rea
	inc	DWORD PTR [eax]
$LN51@Resize_rea:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1621 :         ++_Last;

	lea	eax, DWORD PTR [edx+4]
	mov	DWORD PTR __Backout$2[ebp+4], eax

; 1658 :     for (; _UFirst != _ULast; ++_UFirst) {

	add	ecx, 4
	mov	DWORD PTR __UFirst$4[ebp], ecx
	mov	edx, eax
	jmp	SHORT $LL39@Resize_rea
$LN38@Resize_rea:

; 1625 :         _First = _Last;

	mov	DWORD PTR __Backout$2[ebp], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
	mov	DWORD PTR __$EHRec$[ebp+12], -1

; 1732 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN62@Resize_rea
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	push	eax
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN62@Resize_rea:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1737 :         _Myfirst = _Newvec;

	mov	DWORD PTR [esi], ebx

; 1738 :         _Mylast  = _Newvec + _Newsize;

	mov	eax, DWORD PTR __Newsize$[ebp]
	lea	eax, DWORD PTR [ebx+eax*4]
	mov	DWORD PTR [esi+4], eax

; 1739 :         _Myend   = _Newvec + _Newcapacity;

	mov	eax, DWORD PTR __Newcapacity$1$[ebp]
	lea	eax, DWORD PTR [ebx+eax*4]
	mov	DWORD PTR [esi+8], eax

; 1239 :         _CATCH_END
; 1240 : 
; 1241 :         _Change_array(_Newvec, _Newsize, _Newcapacity);
; 1242 :     }

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
__catch$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@V?$resptr_core@UShader@@Uresptrcode_shader@@@@V?$xalloc@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@@@std@@AAEXIABU_Value_init_tag@1@@Z$0:

; 1235 :         _CATCH_ALL
; 1236 :         _Destroy(_Appended_first, _Appended_last);
; 1237 :         _Getal().deallocate(_Newvec, _Newcapacity);

	push	ecx
	push	DWORD PTR __Newvec$[ebp]
	call	?deallocate@?$xalloc@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@@QBEXPAV?$resptr_core@UShader@@Uresptrcode_shader@@@@I@Z ; xalloc<resptr_core<Shader,resptrcode_shader> >::deallocate

; 1238 :         _RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$LN74@Resize_rea:

; 1218 :             _Xlength();

	call	?_Xlength@?$vector@V?$resptr_core@UShader@@Uresptrcode_shader@@@@V?$xalloc@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@@@std@@CAXXZ ; std::vector<resptr_core<Shader,resptrcode_shader>,xalloc<resptr_core<Shader,resptrcode_shader> > >::_Xlength
$LN71@Resize_rea:
	int	3
	int	3
	int	3
	int	3
	int	3
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@V?$resptr_core@UShader@@Uresptrcode_shader@@@@V?$xalloc@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@@@std@@AAEXIABU_Value_init_tag@1@@Z:
	npad	1
	npad	1
	mov	eax, OFFSET __ehfuncinfo$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@V?$resptr_core@UShader@@Uresptrcode_shader@@@@V?$xalloc@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@@@std@@AAEXIABU_Value_init_tag@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@V?$resptr_core@UShader@@Uresptrcode_shader@@@@V?$xalloc@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@@@std@@AAEXIABU_Value_init_tag@1@@Z ENDP ; std::vector<resptr_core<Shader,resptrcode_shader>,xalloc<resptr_core<Shader,resptrcode_shader> > >::_Resize_reallocate<std::_Value_init_tag>
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UFSlideWindowItem@@V?$xalloc@UFSlideWindowItem@@@@@std@@AAEXIABU_Value_init_tag@1@@Z
_TEXT	SEGMENT
__Backout$2 = -36					; size = 12
__UFirst$3 = -24					; size = 4
__Newvec$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__ULast$1$ = 8						; size = 4
__Oldsize$1$ = 8					; size = 4
__Newsize$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UFSlideWindowItem@@V?$xalloc@UFSlideWindowItem@@@@@std@@AAEXIABU_Value_init_tag@1@@Z PROC ; std::vector<FSlideWindowItem,xalloc<FSlideWindowItem> >::_Resize_reallocate<std::_Value_init_tag>, COMDAT
; _this$ = ecx

; 1216 :     _CONSTEXPR20_CONTAINER void _Resize_reallocate(const size_type _Newsize, const _Ty2& _Val) {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UFSlideWindowItem@@V?$xalloc@UFSlideWindowItem@@@@@std@@AAEXIABU_Value_init_tag@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 24					; 00000018H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	edi, ecx

; 1217 :         if (_Newsize > max_size()) {

	mov	ebx, DWORD PTR __Newsize$[ebp]
	cmp	ebx, 178956970				; 0aaaaaaaH
	ja	$LN52@Resize_rea

; 1219 :         }
; 1220 : 
; 1221 :         auto& _My_data    = _Mypair._Myval2;
; 1222 :         pointer& _Myfirst = _My_data._Myfirst;
; 1223 :         pointer& _Mylast  = _My_data._Mylast;
; 1224 : 
; 1225 :         const auto _Oldsize          = static_cast<size_type>(_Mylast - _Myfirst);

	mov	eax, DWORD PTR [edi+4]
	sub	eax, DWORD PTR [edi]
	sar	eax, 3
	imul	eax, eax, -1431655765
	mov	DWORD PTR __Oldsize$1$[ebp], eax

; 1546 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	eax, DWORD PTR [edi+8]
	sub	eax, DWORD PTR [edi]
	sar	eax, 3
	imul	edx, eax, -1431655765

; 1675 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	ecx, edx
	shr	ecx, 1
	mov	eax, 178956970				; 0aaaaaaaH
	sub	eax, ecx
	cmp	edx, eax
	jbe	SHORT $LN10@Resize_rea

; 1676 :             return _Max; // geometric growth would overflow

	mov	esi, 178956970				; 0aaaaaaaH
	jmp	SHORT $LN11@Resize_rea
$LN10@Resize_rea:

; 1677 :         }
; 1678 : 
; 1679 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	lea	esi, DWORD PTR [ecx+edx]

; 1680 : 
; 1681 :         if (_Geometric < _Newsize) {

	cmp	esi, ebx
	cmovb	esi, ebx
$LN11@Resize_rea:
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	lea	eax, DWORD PTR [esi+esi*2]
	shl	eax, 3
	push	eax
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1228 :         const pointer _Newvec         = _Getal().allocate(_Newcapacity);

	mov	edx, eax
	mov	DWORD PTR __Newvec$[ebp], edx

; 1229 :         const pointer _Appended_first = _Newvec + _Oldsize;

	mov	eax, DWORD PTR __Oldsize$1$[ebp]
	lea	ecx, DWORD PTR [eax+eax*2]
	lea	ecx, DWORD PTR [edx+ecx*8]

; 1230 :         pointer _Appended_last        = _Appended_first;
; 1231 : 
; 1232 :         _TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 1233 :         _Appended_last = _Ufill(_Appended_first, _Newsize - _Oldsize, _Val);

	mov	eax, DWORD PTR __Val$[ebp]
	movzx	eax, BYTE PTR [eax]
	push	eax
	mov	eax, ebx
	sub	eax, DWORD PTR __Oldsize$1$[ebp]
	push	eax
	push	ecx
	call	?_Ufill@?$vector@UFSlideWindowItem@@V?$xalloc@UFSlideWindowItem@@@@@std@@AAEPAUFSlideWindowItem@@PAU3@IU_Value_init_tag@2@@Z ; std::vector<FSlideWindowItem,xalloc<FSlideWindowItem> >::_Ufill

; 1234 :         _Umove_if_noexcept(_Myfirst, _Mylast, _Newvec);

	mov	eax, DWORD PTR [edi+4]
	mov	DWORD PTR __ULast$1$[ebp], eax
	mov	ecx, DWORD PTR [edi]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1703 :     auto _UFirst      = _Get_unwrapped(_First);

	mov	DWORD PTR __UFirst$3[ebp], ecx

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	DWORD PTR __Backout$2[ebp], edx
	mov	DWORD PTR __Backout$2[ebp+4], edx
	mov	DWORD PTR __Backout$2[ebp+8], edi
	npad	2
$LL26@Resize_rea:

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	ecx, eax
	je	SHORT $LN25@Resize_rea
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], eax
	mov	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+8], eax
	mov	eax, DWORD PTR [ecx+12]
	mov	DWORD PTR [edx+12], eax
	mov	eax, DWORD PTR [ecx+16]
	mov	DWORD PTR [edx+16], eax
	mov	eax, DWORD PTR [ecx+20]
	mov	DWORD PTR [edx+20], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1621 :         ++_Last;

	add	edx, 24					; 00000018H
	mov	DWORD PTR __Backout$2[ebp+4], edx

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	add	ecx, 24					; 00000018H
	mov	DWORD PTR __UFirst$3[ebp], ecx
	mov	eax, DWORD PTR __ULast$1$[ebp]
	jmp	SHORT $LL26@Resize_rea
$LN25@Resize_rea:

; 1625 :         _First = _Last;

	mov	DWORD PTR __Backout$2[ebp], edx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
	mov	DWORD PTR __$EHRec$[ebp+12], -1

; 1732 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [edi]
	test	eax, eax
	je	SHORT $LN44@Resize_rea
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	push	eax
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN44@Resize_rea:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1737 :         _Myfirst = _Newvec;

	mov	ecx, DWORD PTR __Newvec$[ebp]
	mov	DWORD PTR [edi], ecx

; 1738 :         _Mylast  = _Newvec + _Newsize;

	lea	eax, DWORD PTR [ebx+ebx*2]
	lea	eax, DWORD PTR [ecx+eax*8]
	mov	DWORD PTR [edi+4], eax

; 1739 :         _Myend   = _Newvec + _Newcapacity;

	lea	eax, DWORD PTR [esi+esi*2]
	lea	eax, DWORD PTR [ecx+eax*8]
	mov	DWORD PTR [edi+8], eax

; 1239 :         _CATCH_END
; 1240 : 
; 1241 :         _Change_array(_Newvec, _Newsize, _Newcapacity);
; 1242 :     }

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
__catch$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UFSlideWindowItem@@V?$xalloc@UFSlideWindowItem@@@@@std@@AAEXIABU_Value_init_tag@1@@Z$0:

; 1235 :         _CATCH_ALL
; 1236 :         _Destroy(_Appended_first, _Appended_last);
; 1237 :         _Getal().deallocate(_Newvec, _Newcapacity);

	push	ecx
	push	DWORD PTR __Newvec$[ebp]
	call	?deallocate@?$xalloc@UFSlideWindowItem@@@@QBEXPAUFSlideWindowItem@@I@Z ; xalloc<FSlideWindowItem>::deallocate

; 1238 :         _RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$LN52@Resize_rea:

; 1218 :             _Xlength();

	call	?_Xlength@?$vector@UFSlideWindowItem@@V?$xalloc@UFSlideWindowItem@@@@@std@@CAXXZ ; std::vector<FSlideWindowItem,xalloc<FSlideWindowItem> >::_Xlength
$LN50@Resize_rea:
	int	3
	int	3
	int	3
	int	3
	int	3
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UFSlideWindowItem@@V?$xalloc@UFSlideWindowItem@@@@@std@@AAEXIABU_Value_init_tag@1@@Z:
	npad	1
	npad	1
	mov	eax, OFFSET __ehfuncinfo$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UFSlideWindowItem@@V?$xalloc@UFSlideWindowItem@@@@@std@@AAEXIABU_Value_init_tag@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UFSlideWindowItem@@V?$xalloc@UFSlideWindowItem@@@@@std@@AAEXIABU_Value_init_tag@1@@Z ENDP ; std::vector<FSlideWindowItem,xalloc<FSlideWindowItem> >::_Resize_reallocate<std::_Value_init_tag>
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@PAVIRender_Portal@@V?$xalloc@PAVIRender_Portal@@@@@std@@AAEXIABU_Value_init_tag@1@@Z
_TEXT	SEGMENT
__Backout$2 = -40					; size = 12
__Newvec$ = -28						; size = 4
__UFirst$3 = -24					; size = 4
__Newcapacity$1$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Newsize$ = 8						; size = 4
__Val$dead$ = 12					; size = 4
??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@PAVIRender_Portal@@V?$xalloc@PAVIRender_Portal@@@@@std@@AAEXIABU_Value_init_tag@1@@Z PROC ; std::vector<IRender_Portal *,xalloc<IRender_Portal *> >::_Resize_reallocate<std::_Value_init_tag>, COMDAT
; _this$ = ecx

; 1216 :     _CONSTEXPR20_CONTAINER void _Resize_reallocate(const size_type _Newsize, const _Ty2& _Val) {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@PAVIRender_Portal@@V?$xalloc@PAVIRender_Portal@@@@@std@@AAEXIABU_Value_init_tag@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 28					; 0000001cH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	esi, ecx

; 1217 :         if (_Newsize > max_size()) {

	mov	edx, DWORD PTR __Newsize$[ebp]
	cmp	edx, 1073741823				; 3fffffffH
	ja	$LN66@Resize_rea

; 1219 :         }
; 1220 : 
; 1221 :         auto& _My_data    = _Mypair._Myval2;
; 1222 :         pointer& _Myfirst = _My_data._Myfirst;
; 1223 :         pointer& _Mylast  = _My_data._Mylast;
; 1224 : 
; 1225 :         const auto _Oldsize          = static_cast<size_type>(_Mylast - _Myfirst);

	mov	edi, DWORD PTR [esi+4]
	sub	edi, DWORD PTR [esi]
	sar	edi, 2

; 1546 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	ecx, DWORD PTR [esi+8]
	sub	ecx, DWORD PTR [esi]
	sar	ecx, 2

; 1675 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	ebx, ecx
	shr	ebx, 1
	mov	eax, 1073741823				; 3fffffffH
	sub	eax, ebx
	cmp	ecx, eax
	jbe	SHORT $LN10@Resize_rea

; 1676 :             return _Max; // geometric growth would overflow

	mov	eax, 1073741823				; 3fffffffH
	jmp	SHORT $LN64@Resize_rea
$LN10@Resize_rea:

; 1677 :         }
; 1678 : 
; 1679 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	lea	eax, DWORD PTR [ebx+ecx]

; 1680 : 
; 1681 :         if (_Geometric < _Newsize) {

	cmp	eax, edx
	cmovb	eax, edx
$LN64@Resize_rea:
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	mov	DWORD PTR __Newcapacity$1$[ebp], eax
	shl	eax, 2
	push	eax
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1228 :         const pointer _Newvec         = _Getal().allocate(_Newcapacity);

	mov	ebx, eax
	mov	DWORD PTR __Newvec$[ebp], ebx

; 1229 :         const pointer _Appended_first = _Newvec + _Oldsize;

	lea	ecx, DWORD PTR [ebx+edi*4]

; 1230 :         pointer _Appended_last        = _Appended_first;
; 1231 : 
; 1232 :         _TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 1233 :         _Appended_last = _Ufill(_Appended_first, _Newsize - _Oldsize, _Val);

	mov	eax, DWORD PTR __Newsize$[ebp]
	sub	eax, edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1807 :             _Zero_range(_PFirst, _PFirst + _Count);

	shl	eax, 2

; 1792 :     _CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

	push	eax
	push	0
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1234 :         _Umove_if_noexcept(_Myfirst, _Mylast, _Newvec);

	mov	edi, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1703 :     auto _UFirst      = _Get_unwrapped(_First);

	mov	DWORD PTR __UFirst$3[ebp], ecx

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	DWORD PTR __Backout$2[ebp], ebx
	mov	edx, ebx
	mov	DWORD PTR __Backout$2[ebp+4], edx
	mov	DWORD PTR __Backout$2[ebp+8], esi
	npad	7
$LL43@Resize_rea:

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	ecx, edi
	je	SHORT $LN42@Resize_rea

; 1620 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax

; 1621 :         ++_Last;

	add	edx, 4
	mov	DWORD PTR __Backout$2[ebp+4], edx

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	add	ecx, 4
	mov	DWORD PTR __UFirst$3[ebp], ecx
	jmp	SHORT $LL43@Resize_rea
$LN42@Resize_rea:

; 1625 :         _First = _Last;

	mov	DWORD PTR __Backout$2[ebp], edx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
	mov	DWORD PTR __$EHRec$[ebp+12], -1

; 1732 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN57@Resize_rea
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	push	eax
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN57@Resize_rea:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1737 :         _Myfirst = _Newvec;

	mov	DWORD PTR [esi], ebx

; 1738 :         _Mylast  = _Newvec + _Newsize;

	mov	eax, DWORD PTR __Newsize$[ebp]
	lea	eax, DWORD PTR [ebx+eax*4]
	mov	DWORD PTR [esi+4], eax

; 1739 :         _Myend   = _Newvec + _Newcapacity;

	mov	eax, DWORD PTR __Newcapacity$1$[ebp]
	lea	eax, DWORD PTR [ebx+eax*4]
	mov	DWORD PTR [esi+8], eax

; 1239 :         _CATCH_END
; 1240 : 
; 1241 :         _Change_array(_Newvec, _Newsize, _Newcapacity);
; 1242 :     }

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
__catch$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@PAVIRender_Portal@@V?$xalloc@PAVIRender_Portal@@@@@std@@AAEXIABU_Value_init_tag@1@@Z$0:

; 1235 :         _CATCH_ALL
; 1236 :         _Destroy(_Appended_first, _Appended_last);
; 1237 :         _Getal().deallocate(_Newvec, _Newcapacity);

	push	ecx
	push	DWORD PTR __Newvec$[ebp]
	call	?deallocate@?$xalloc@PAVIRender_Portal@@@@QBEXPAPAVIRender_Portal@@I@Z ; xalloc<IRender_Portal *>::deallocate

; 1238 :         _RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$LN66@Resize_rea:

; 1218 :             _Xlength();

	call	?_Xlength@?$vector@PAVIRender_Portal@@V?$xalloc@PAVIRender_Portal@@@@@std@@CAXXZ ; std::vector<IRender_Portal *,xalloc<IRender_Portal *> >::_Xlength
$LN63@Resize_rea:
	int	3
	int	3
	int	3
	int	3
	int	3
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@PAVIRender_Portal@@V?$xalloc@PAVIRender_Portal@@@@@std@@AAEXIABU_Value_init_tag@1@@Z:
	npad	1
	npad	1
	mov	eax, OFFSET __ehfuncinfo$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@PAVIRender_Portal@@V?$xalloc@PAVIRender_Portal@@@@@std@@AAEXIABU_Value_init_tag@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@PAVIRender_Portal@@V?$xalloc@PAVIRender_Portal@@@@@std@@AAEXIABU_Value_init_tag@1@@Z ENDP ; std::vector<IRender_Portal *,xalloc<IRender_Portal *> >::_Resize_reallocate<std::_Value_init_tag>
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_Copy_memmove@PAUFSlideWindowItem@@PAU1@@std@@YAPAUFSlideWindowItem@@PAU1@00@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
??$_Copy_memmove@PAUFSlideWindowItem@@PAU1@@std@@YAPAUFSlideWindowItem@@PAU1@00@Z PROC ; std::_Copy_memmove<FSlideWindowItem *,FSlideWindowItem *>, COMDAT
; __First$ = ecx
; __Last$ = edx

; 4058 : _OutCtgIt _Copy_memmove(_CtgIt _First, _CtgIt _Last, _OutCtgIt _Dest) {

	push	esi

; 4059 :     auto _FirstPtr              = _To_address(_First);
; 4060 :     auto _LastPtr               = _To_address(_Last);
; 4061 :     auto _DestPtr               = _To_address(_Dest);
; 4062 :     const char* const _First_ch = const_cast<const char*>(reinterpret_cast<const volatile char*>(_FirstPtr));
; 4063 :     const char* const _Last_ch  = const_cast<const char*>(reinterpret_cast<const volatile char*>(_LastPtr));
; 4064 :     char* const _Dest_ch        = const_cast<char*>(reinterpret_cast<const volatile char*>(_DestPtr));
; 4065 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);
; 4066 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	esi, DWORD PTR __Dest$[esp]
	push	edi
	mov	edi, edx
	sub	edi, ecx
	push	edi
	push	ecx
	push	esi
	call	_memmove
	add	esp, 12					; 0000000cH

; 4067 :     if constexpr (is_pointer_v<_OutCtgIt>) {
; 4068 :         return reinterpret_cast<_OutCtgIt>(_Dest_ch + _Count);

	lea	eax, DWORD PTR [edi+esi]
	pop	edi
	pop	esi

; 4069 :     } else {
; 4070 :         return _Dest + (_LastPtr - _FirstPtr);
; 4071 :     }
; 4072 : }

	ret	0
??$_Copy_memmove@PAUFSlideWindowItem@@PAU1@@std@@YAPAUFSlideWindowItem@@PAU1@00@Z ENDP ; std::_Copy_memmove<FSlideWindowItem *,FSlideWindowItem *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_To_address@PAUFSlideWindowItem@@@std@@YA?A_PABQAUFSlideWindowItem@@@Z
_TEXT	SEGMENT
??$_To_address@PAUFSlideWindowItem@@@std@@YA?A_PABQAUFSlideWindowItem@@@Z PROC ; std::_To_address<FSlideWindowItem *>, COMDAT
; __Val$ = ecx

; 3981 :     _STL_INTERNAL_STATIC_ASSERT(is_pointer_v<_Iter>);
; 3982 :     return _Val;

	mov	eax, DWORD PTR [ecx]

; 3983 : }

	ret	0
??$_To_address@PAUFSlideWindowItem@@@std@@YA?A_PABQAUFSlideWindowItem@@@Z ENDP ; std::_To_address<FSlideWindowItem *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\type_traits
;	COMDAT ??$move@AAUFSlideWindowItem@@@std@@YA$$QAUFSlideWindowItem@@AAU1@@Z
_TEXT	SEGMENT
??$move@AAUFSlideWindowItem@@@std@@YA$$QAUFSlideWindowItem@@AAU1@@Z PROC ; std::move<FSlideWindowItem &>, COMDAT
; __Arg$ = ecx

; 1397 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

	mov	eax, ecx

; 1398 : }

	ret	0
??$move@AAUFSlideWindowItem@@@std@@YA$$QAUFSlideWindowItem@@AAU1@@Z ENDP ; std::move<FSlideWindowItem &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Uninitialized_value_construct_n@V?$xalloc@PAUIDirect3DIndexBuffer9@@@@@std@@YAPAPAUIDirect3DIndexBuffer9@@PAPAU1@IAAV?$xalloc@PAUIDirect3DIndexBuffer9@@@@@Z
_TEXT	SEGMENT
__Al$dead$ = 8						; size = 4
??$_Uninitialized_value_construct_n@V?$xalloc@PAUIDirect3DIndexBuffer9@@@@@std@@YAPAPAUIDirect3DIndexBuffer9@@PAPAU1@IAAV?$xalloc@PAUIDirect3DIndexBuffer9@@@@@Z PROC ; std::_Uninitialized_value_construct_n<xalloc<IDirect3DIndexBuffer9 *> >, COMDAT
; __First$ = ecx
; __Count$ = edx

; 1798 :     _Alloc_ptr_t<_Alloc> _First, _Alloc_size_t<_Alloc> _Count, _Alloc& _Al) {

	push	esi
	push	edi

; 1799 :     // value-initialize _Count objects to raw _First, using _Al
; 1800 :     using _Ptrty = typename _Alloc::value_type*;
; 1801 :     if constexpr (_Use_memset_value_construct_v<_Ptrty> && _Uses_default_construct<_Alloc, _Ptrty>::value) {
; 1802 : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 1803 :         if (!_STD is_constant_evaluated())
; 1804 : #endif // __cpp_lib_constexpr_dynamic_alloc
; 1805 :         {
; 1806 :             auto _PFirst = _Unfancy(_First);
; 1807 :             _Zero_range(_PFirst, _PFirst + _Count);

	lea	esi, DWORD PTR [edx*4]
	mov	edi, ecx

; 1792 :     _CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

	push	esi
	push	0
	push	edi
	call	_memset
	add	esp, 12					; 0000000cH

; 1808 :             return _First + _Count;

	lea	eax, DWORD PTR [esi+edi]
	pop	edi
	pop	esi

; 1809 :         }
; 1810 :     }
; 1811 : 
; 1812 :     _Uninitialized_backout_al<_Alloc> _Backout{_First, _Al};
; 1813 :     for (; 0 < _Count; --_Count) {
; 1814 :         _Backout._Emplace_back();
; 1815 :     }
; 1816 : 
; 1817 :     return _Backout._Release();
; 1818 : }

	ret	0
??$_Uninitialized_value_construct_n@V?$xalloc@PAUIDirect3DIndexBuffer9@@@@@std@@YAPAPAUIDirect3DIndexBuffer9@@PAPAU1@IAAV?$xalloc@PAUIDirect3DIndexBuffer9@@@@@Z ENDP ; std::_Uninitialized_value_construct_n<xalloc<IDirect3DIndexBuffer9 *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Uninitialized_value_construct_n@V?$xalloc@PAUIDirect3DVertexBuffer9@@@@@std@@YAPAPAUIDirect3DVertexBuffer9@@PAPAU1@IAAV?$xalloc@PAUIDirect3DVertexBuffer9@@@@@Z
_TEXT	SEGMENT
__Al$dead$ = 8						; size = 4
??$_Uninitialized_value_construct_n@V?$xalloc@PAUIDirect3DVertexBuffer9@@@@@std@@YAPAPAUIDirect3DVertexBuffer9@@PAPAU1@IAAV?$xalloc@PAUIDirect3DVertexBuffer9@@@@@Z PROC ; std::_Uninitialized_value_construct_n<xalloc<IDirect3DVertexBuffer9 *> >, COMDAT
; __First$ = ecx
; __Count$ = edx

; 1798 :     _Alloc_ptr_t<_Alloc> _First, _Alloc_size_t<_Alloc> _Count, _Alloc& _Al) {

	push	esi
	push	edi

; 1799 :     // value-initialize _Count objects to raw _First, using _Al
; 1800 :     using _Ptrty = typename _Alloc::value_type*;
; 1801 :     if constexpr (_Use_memset_value_construct_v<_Ptrty> && _Uses_default_construct<_Alloc, _Ptrty>::value) {
; 1802 : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 1803 :         if (!_STD is_constant_evaluated())
; 1804 : #endif // __cpp_lib_constexpr_dynamic_alloc
; 1805 :         {
; 1806 :             auto _PFirst = _Unfancy(_First);
; 1807 :             _Zero_range(_PFirst, _PFirst + _Count);

	lea	esi, DWORD PTR [edx*4]
	mov	edi, ecx

; 1792 :     _CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

	push	esi
	push	0
	push	edi
	call	_memset
	add	esp, 12					; 0000000cH

; 1808 :             return _First + _Count;

	lea	eax, DWORD PTR [esi+edi]
	pop	edi
	pop	esi

; 1809 :         }
; 1810 :     }
; 1811 : 
; 1812 :     _Uninitialized_backout_al<_Alloc> _Backout{_First, _Al};
; 1813 :     for (; 0 < _Count; --_Count) {
; 1814 :         _Backout._Emplace_back();
; 1815 :     }
; 1816 : 
; 1817 :     return _Backout._Release();
; 1818 : }

	ret	0
??$_Uninitialized_value_construct_n@V?$xalloc@PAUIDirect3DVertexBuffer9@@@@@std@@YAPAPAUIDirect3DVertexBuffer9@@PAPAU1@IAAV?$xalloc@PAUIDirect3DVertexBuffer9@@@@@Z ENDP ; std::_Uninitialized_value_construct_n<xalloc<IDirect3DVertexBuffer9 *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Uninitialized_value_construct_n@V?$xalloc@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@@@std@@YAPAV?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@PAV1@IAAV?$xalloc@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@@@Z
_TEXT	SEGMENT
__Al$dead$ = 8						; size = 4
??$_Uninitialized_value_construct_n@V?$xalloc@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@@@std@@YAPAV?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@PAV1@IAAV?$xalloc@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@@@Z PROC ; std::_Uninitialized_value_construct_n<xalloc<svector<_D3DVERTEXELEMENT9,65> > >, COMDAT
; __First$ = ecx
; __Count$ = edx

; 1799 :     // value-initialize _Count objects to raw _First, using _Al
; 1800 :     using _Ptrty = typename _Alloc::value_type*;
; 1801 :     if constexpr (_Use_memset_value_construct_v<_Ptrty> && _Uses_default_construct<_Alloc, _Ptrty>::value) {
; 1802 : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 1803 :         if (!_STD is_constant_evaluated())
; 1804 : #endif // __cpp_lib_constexpr_dynamic_alloc
; 1805 :         {
; 1806 :             auto _PFirst = _Unfancy(_First);
; 1807 :             _Zero_range(_PFirst, _PFirst + _Count);
; 1808 :             return _First + _Count;
; 1809 :         }
; 1810 :     }
; 1811 : 
; 1812 :     _Uninitialized_backout_al<_Alloc> _Backout{_First, _Al};
; 1813 :     for (; 0 < _Count; --_Count) {

	test	edx, edx
	je	SHORT $LN16@Uninitiali
	npad	12
$LL4@Uninitiali:

; 1620 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

	mov	DWORD PTR [ecx+520], 0

; 1621 :         ++_Last;

	add	ecx, 524				; 0000020cH

; 1799 :     // value-initialize _Count objects to raw _First, using _Al
; 1800 :     using _Ptrty = typename _Alloc::value_type*;
; 1801 :     if constexpr (_Use_memset_value_construct_v<_Ptrty> && _Uses_default_construct<_Alloc, _Ptrty>::value) {
; 1802 : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 1803 :         if (!_STD is_constant_evaluated())
; 1804 : #endif // __cpp_lib_constexpr_dynamic_alloc
; 1805 :         {
; 1806 :             auto _PFirst = _Unfancy(_First);
; 1807 :             _Zero_range(_PFirst, _PFirst + _Count);
; 1808 :             return _First + _Count;
; 1809 :         }
; 1810 :     }
; 1811 : 
; 1812 :     _Uninitialized_backout_al<_Alloc> _Backout{_First, _Al};
; 1813 :     for (; 0 < _Count; --_Count) {

	sub	edx, 1
	jne	SHORT $LL4@Uninitiali
$LN16@Uninitiali:

; 1814 :         _Backout._Emplace_back();
; 1815 :     }
; 1816 : 
; 1817 :     return _Backout._Release();
; 1818 : }

	mov	eax, ecx
	ret	0
??$_Uninitialized_value_construct_n@V?$xalloc@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@@@std@@YAPAV?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@PAV1@IAAV?$xalloc@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@@@Z ENDP ; std::_Uninitialized_value_construct_n<xalloc<svector<_D3DVERTEXELEMENT9,65> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Uninitialized_value_construct_n@V?$xalloc@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@@@std@@YAPAV?$resptr_core@UShader@@Uresptrcode_shader@@@@PAV1@IAAV?$xalloc@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@@@Z
_TEXT	SEGMENT
__Al$dead$ = 8						; size = 4
??$_Uninitialized_value_construct_n@V?$xalloc@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@@@std@@YAPAV?$resptr_core@UShader@@Uresptrcode_shader@@@@PAV1@IAAV?$xalloc@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@@@Z PROC ; std::_Uninitialized_value_construct_n<xalloc<resptr_core<Shader,resptrcode_shader> > >, COMDAT
; __First$ = ecx
; __Count$ = edx

; 1798 :     _Alloc_ptr_t<_Alloc> _First, _Alloc_size_t<_Alloc> _Count, _Alloc& _Al) {

	push	esi
	mov	esi, ecx

; 1799 :     // value-initialize _Count objects to raw _First, using _Al
; 1800 :     using _Ptrty = typename _Alloc::value_type*;
; 1801 :     if constexpr (_Use_memset_value_construct_v<_Ptrty> && _Uses_default_construct<_Alloc, _Ptrty>::value) {
; 1802 : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 1803 :         if (!_STD is_constant_evaluated())
; 1804 : #endif // __cpp_lib_constexpr_dynamic_alloc
; 1805 :         {
; 1806 :             auto _PFirst = _Unfancy(_First);
; 1807 :             _Zero_range(_PFirst, _PFirst + _Count);
; 1808 :             return _First + _Count;
; 1809 :         }
; 1810 :     }
; 1811 : 
; 1812 :     _Uninitialized_backout_al<_Alloc> _Backout{_First, _Al};
; 1813 :     for (; 0 < _Count; --_Count) {

	test	edx, edx
	je	SHORT $LN16@Uninitiali
	push	edi
	xor	eax, eax
	mov	edi, esi
	mov	ecx, edx
	rep stosd

; 1814 :         _Backout._Emplace_back();
; 1815 :     }
; 1816 : 
; 1817 :     return _Backout._Release();

	pop	edi
	lea	eax, DWORD PTR [esi+edx*4]
	pop	esi

; 1818 : }

	ret	0
$LN16@Uninitiali:

; 1814 :         _Backout._Emplace_back();
; 1815 :     }
; 1816 : 
; 1817 :     return _Backout._Release();

	mov	eax, esi
	pop	esi

; 1818 : }

	ret	0
??$_Uninitialized_value_construct_n@V?$xalloc@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@@@std@@YAPAV?$resptr_core@UShader@@Uresptrcode_shader@@@@PAV1@IAAV?$xalloc@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@@@Z ENDP ; std::_Uninitialized_value_construct_n<xalloc<resptr_core<Shader,resptrcode_shader> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrEngine\Fmesh.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Uninitialized_value_construct_n@V?$xalloc@UFSlideWindowItem@@@@@std@@YAPAUFSlideWindowItem@@PAU1@IAAV?$xalloc@UFSlideWindowItem@@@@@Z
_TEXT	SEGMENT
__Al$dead$ = 8						; size = 4
??$_Uninitialized_value_construct_n@V?$xalloc@UFSlideWindowItem@@@@@std@@YAPAUFSlideWindowItem@@PAU1@IAAV?$xalloc@UFSlideWindowItem@@@@@Z PROC ; std::_Uninitialized_value_construct_n<xalloc<FSlideWindowItem> >, COMDAT
; __First$ = ecx
; __Count$ = edx

; 1799 :     // value-initialize _Count objects to raw _First, using _Al
; 1800 :     using _Ptrty = typename _Alloc::value_type*;
; 1801 :     if constexpr (_Use_memset_value_construct_v<_Ptrty> && _Uses_default_construct<_Alloc, _Ptrty>::value) {
; 1802 : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 1803 :         if (!_STD is_constant_evaluated())
; 1804 : #endif // __cpp_lib_constexpr_dynamic_alloc
; 1805 :         {
; 1806 :             auto _PFirst = _Unfancy(_First);
; 1807 :             _Zero_range(_PFirst, _PFirst + _Count);
; 1808 :             return _First + _Count;
; 1809 :         }
; 1810 :     }
; 1811 : 
; 1812 :     _Uninitialized_backout_al<_Alloc> _Backout{_First, _Al};
; 1813 :     for (; 0 < _Count; --_Count) {

	test	edx, edx
	je	SHORT $LN20@Uninitiali
	npad	12
$LL4@Uninitiali:
; File I:\Vitalya\mine\NSProjectX\xrEngine\Fmesh.h

; 105  : 	FSlideWindowItem() : sw(0), count(0) {};

	mov	DWORD PTR [ecx], 0
	mov	DWORD PTR [ecx+4], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1621 :         ++_Last;

	add	ecx, 24					; 00000018H

; 1799 :     // value-initialize _Count objects to raw _First, using _Al
; 1800 :     using _Ptrty = typename _Alloc::value_type*;
; 1801 :     if constexpr (_Use_memset_value_construct_v<_Ptrty> && _Uses_default_construct<_Alloc, _Ptrty>::value) {
; 1802 : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 1803 :         if (!_STD is_constant_evaluated())
; 1804 : #endif // __cpp_lib_constexpr_dynamic_alloc
; 1805 :         {
; 1806 :             auto _PFirst = _Unfancy(_First);
; 1807 :             _Zero_range(_PFirst, _PFirst + _Count);
; 1808 :             return _First + _Count;
; 1809 :         }
; 1810 :     }
; 1811 : 
; 1812 :     _Uninitialized_backout_al<_Alloc> _Backout{_First, _Al};
; 1813 :     for (; 0 < _Count; --_Count) {

	sub	edx, 1
	jne	SHORT $LL4@Uninitiali
$LN20@Uninitiali:

; 1814 :         _Backout._Emplace_back();
; 1815 :     }
; 1816 : 
; 1817 :     return _Backout._Release();
; 1818 : }

	mov	eax, ecx
	ret	0
??$_Uninitialized_value_construct_n@V?$xalloc@UFSlideWindowItem@@@@@std@@YAPAUFSlideWindowItem@@PAU1@IAAV?$xalloc@UFSlideWindowItem@@@@@Z ENDP ; std::_Uninitialized_value_construct_n<xalloc<FSlideWindowItem> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Uninitialized_value_construct_n@V?$xalloc@PAVIRender_Portal@@@@@std@@YAPAPAVIRender_Portal@@PAPAV1@IAAV?$xalloc@PAVIRender_Portal@@@@@Z
_TEXT	SEGMENT
__Al$dead$ = 8						; size = 4
??$_Uninitialized_value_construct_n@V?$xalloc@PAVIRender_Portal@@@@@std@@YAPAPAVIRender_Portal@@PAPAV1@IAAV?$xalloc@PAVIRender_Portal@@@@@Z PROC ; std::_Uninitialized_value_construct_n<xalloc<IRender_Portal *> >, COMDAT
; __First$ = ecx
; __Count$ = edx

; 1798 :     _Alloc_ptr_t<_Alloc> _First, _Alloc_size_t<_Alloc> _Count, _Alloc& _Al) {

	push	esi
	push	edi

; 1799 :     // value-initialize _Count objects to raw _First, using _Al
; 1800 :     using _Ptrty = typename _Alloc::value_type*;
; 1801 :     if constexpr (_Use_memset_value_construct_v<_Ptrty> && _Uses_default_construct<_Alloc, _Ptrty>::value) {
; 1802 : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 1803 :         if (!_STD is_constant_evaluated())
; 1804 : #endif // __cpp_lib_constexpr_dynamic_alloc
; 1805 :         {
; 1806 :             auto _PFirst = _Unfancy(_First);
; 1807 :             _Zero_range(_PFirst, _PFirst + _Count);

	lea	esi, DWORD PTR [edx*4]
	mov	edi, ecx

; 1792 :     _CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

	push	esi
	push	0
	push	edi
	call	_memset
	add	esp, 12					; 0000000cH

; 1808 :             return _First + _Count;

	lea	eax, DWORD PTR [esi+edi]
	pop	edi
	pop	esi

; 1809 :         }
; 1810 :     }
; 1811 : 
; 1812 :     _Uninitialized_backout_al<_Alloc> _Backout{_First, _Al};
; 1813 :     for (; 0 < _Count; --_Count) {
; 1814 :         _Backout._Emplace_back();
; 1815 :     }
; 1816 : 
; 1817 :     return _Backout._Release();
; 1818 : }

	ret	0
??$_Uninitialized_value_construct_n@V?$xalloc@PAVIRender_Portal@@@@@std@@YAPAPAVIRender_Portal@@PAPAV1@IAAV?$xalloc@PAVIRender_Portal@@@@@Z ENDP ; std::_Uninitialized_value_construct_n<xalloc<IRender_Portal *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Release@?$_Uninitialized_backout_al@V?$xalloc@PAVIRender_Portal@@@@@std@@QAEPAPAVIRender_Portal@@XZ
_TEXT	SEGMENT
?_Release@?$_Uninitialized_backout_al@V?$xalloc@PAVIRender_Portal@@@@@std@@QAEPAPAVIRender_Portal@@XZ PROC ; std::_Uninitialized_backout_al<xalloc<IRender_Portal *> >::_Release, COMDAT
; _this$ = ecx

; 1625 :         _First = _Last;

	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [ecx], eax

; 1626 :         return _Last;
; 1627 :     }

	ret	0
?_Release@?$_Uninitialized_backout_al@V?$xalloc@PAVIRender_Portal@@@@@std@@QAEPAPAVIRender_Portal@@XZ ENDP ; std::_Uninitialized_backout_al<xalloc<IRender_Portal *> >::_Release
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??1?$_Uninitialized_backout_al@V?$xalloc@PAVIRender_Portal@@@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Uninitialized_backout_al@V?$xalloc@PAVIRender_Portal@@@@@std@@QAE@XZ PROC ; std::_Uninitialized_backout_al<xalloc<IRender_Portal *> >::~_Uninitialized_backout_al<xalloc<IRender_Portal *> >, COMDAT
; _this$ = ecx

; 1615 :         _Destroy_range(_First, _Last, _Al);
; 1616 :     }

	ret	0
??1?$_Uninitialized_backout_al@V?$xalloc@PAVIRender_Portal@@@@@std@@QAE@XZ ENDP ; std::_Uninitialized_backout_al<xalloc<IRender_Portal *> >::~_Uninitialized_backout_al<xalloc<IRender_Portal *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??0?$_Uninitialized_backout_al@V?$xalloc@PAVIRender_Portal@@@@@std@@QAE@PAPAVIRender_Portal@@AAV?$xalloc@PAVIRender_Portal@@@@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Al_$ = 12						; size = 4
??0?$_Uninitialized_backout_al@V?$xalloc@PAVIRender_Portal@@@@@std@@QAE@PAPAVIRender_Portal@@AAV?$xalloc@PAVIRender_Portal@@@@@Z PROC ; std::_Uninitialized_backout_al<xalloc<IRender_Portal *> >::_Uninitialized_backout_al<xalloc<IRender_Portal *> >, COMDAT
; _this$ = ecx

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	eax, DWORD PTR __Dest$[esp-4]
	mov	DWORD PTR [ecx], eax
	mov	DWORD PTR [ecx+4], eax
	mov	eax, DWORD PTR __Al_$[esp-4]
	mov	DWORD PTR [ecx+8], eax
	mov	eax, ecx
	ret	8
??0?$_Uninitialized_backout_al@V?$xalloc@PAVIRender_Portal@@@@@std@@QAE@PAPAVIRender_Portal@@AAV?$xalloc@PAVIRender_Portal@@@@@Z ENDP ; std::_Uninitialized_backout_al<xalloc<IRender_Portal *> >::_Uninitialized_backout_al<xalloc<IRender_Portal *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Release@?$_Uninitialized_backout_al@V?$xalloc@UFSlideWindowItem@@@@@std@@QAEPAUFSlideWindowItem@@XZ
_TEXT	SEGMENT
?_Release@?$_Uninitialized_backout_al@V?$xalloc@UFSlideWindowItem@@@@@std@@QAEPAUFSlideWindowItem@@XZ PROC ; std::_Uninitialized_backout_al<xalloc<FSlideWindowItem> >::_Release, COMDAT
; _this$ = ecx

; 1625 :         _First = _Last;

	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [ecx], eax

; 1626 :         return _Last;
; 1627 :     }

	ret	0
?_Release@?$_Uninitialized_backout_al@V?$xalloc@UFSlideWindowItem@@@@@std@@QAEPAUFSlideWindowItem@@XZ ENDP ; std::_Uninitialized_backout_al<xalloc<FSlideWindowItem> >::_Release
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??1?$_Uninitialized_backout_al@V?$xalloc@UFSlideWindowItem@@@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Uninitialized_backout_al@V?$xalloc@UFSlideWindowItem@@@@@std@@QAE@XZ PROC ; std::_Uninitialized_backout_al<xalloc<FSlideWindowItem> >::~_Uninitialized_backout_al<xalloc<FSlideWindowItem> >, COMDAT
; _this$ = ecx

; 1615 :         _Destroy_range(_First, _Last, _Al);
; 1616 :     }

	ret	0
??1?$_Uninitialized_backout_al@V?$xalloc@UFSlideWindowItem@@@@@std@@QAE@XZ ENDP ; std::_Uninitialized_backout_al<xalloc<FSlideWindowItem> >::~_Uninitialized_backout_al<xalloc<FSlideWindowItem> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??0?$_Uninitialized_backout_al@V?$xalloc@UFSlideWindowItem@@@@@std@@QAE@PAUFSlideWindowItem@@AAV?$xalloc@UFSlideWindowItem@@@@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Al_$ = 12						; size = 4
??0?$_Uninitialized_backout_al@V?$xalloc@UFSlideWindowItem@@@@@std@@QAE@PAUFSlideWindowItem@@AAV?$xalloc@UFSlideWindowItem@@@@@Z PROC ; std::_Uninitialized_backout_al<xalloc<FSlideWindowItem> >::_Uninitialized_backout_al<xalloc<FSlideWindowItem> >, COMDAT
; _this$ = ecx

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	eax, DWORD PTR __Dest$[esp-4]
	mov	DWORD PTR [ecx], eax
	mov	DWORD PTR [ecx+4], eax
	mov	eax, DWORD PTR __Al_$[esp-4]
	mov	DWORD PTR [ecx+8], eax
	mov	eax, ecx
	ret	8
??0?$_Uninitialized_backout_al@V?$xalloc@UFSlideWindowItem@@@@@std@@QAE@PAUFSlideWindowItem@@AAV?$xalloc@UFSlideWindowItem@@@@@Z ENDP ; std::_Uninitialized_backout_al<xalloc<FSlideWindowItem> >::_Uninitialized_backout_al<xalloc<FSlideWindowItem> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Release@?$_Uninitialized_backout_al@V?$xalloc@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@@@std@@QAEPAV?$resptr_core@UShader@@Uresptrcode_shader@@@@XZ
_TEXT	SEGMENT
?_Release@?$_Uninitialized_backout_al@V?$xalloc@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@@@std@@QAEPAV?$resptr_core@UShader@@Uresptrcode_shader@@@@XZ PROC ; std::_Uninitialized_backout_al<xalloc<resptr_core<Shader,resptrcode_shader> > >::_Release, COMDAT
; _this$ = ecx

; 1625 :         _First = _Last;

	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [ecx], eax

; 1626 :         return _Last;
; 1627 :     }

	ret	0
?_Release@?$_Uninitialized_backout_al@V?$xalloc@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@@@std@@QAEPAV?$resptr_core@UShader@@Uresptrcode_shader@@@@XZ ENDP ; std::_Uninitialized_backout_al<xalloc<resptr_core<Shader,resptrcode_shader> > >::_Release
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??1?$_Uninitialized_backout_al@V?$xalloc@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Uninitialized_backout_al@V?$xalloc@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@@@std@@QAE@XZ PROC ; std::_Uninitialized_backout_al<xalloc<resptr_core<Shader,resptrcode_shader> > >::~_Uninitialized_backout_al<xalloc<resptr_core<Shader,resptrcode_shader> > >, COMDAT
; _this$ = ecx

; 1615 :         _Destroy_range(_First, _Last, _Al);
; 1616 :     }

	ret	0
??1?$_Uninitialized_backout_al@V?$xalloc@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@@@std@@QAE@XZ ENDP ; std::_Uninitialized_backout_al<xalloc<resptr_core<Shader,resptrcode_shader> > >::~_Uninitialized_backout_al<xalloc<resptr_core<Shader,resptrcode_shader> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??0?$_Uninitialized_backout_al@V?$xalloc@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@@@std@@QAE@PAV?$resptr_core@UShader@@Uresptrcode_shader@@@@AAV?$xalloc@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Al_$ = 12						; size = 4
??0?$_Uninitialized_backout_al@V?$xalloc@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@@@std@@QAE@PAV?$resptr_core@UShader@@Uresptrcode_shader@@@@AAV?$xalloc@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@@@Z PROC ; std::_Uninitialized_backout_al<xalloc<resptr_core<Shader,resptrcode_shader> > >::_Uninitialized_backout_al<xalloc<resptr_core<Shader,resptrcode_shader> > >, COMDAT
; _this$ = ecx

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	eax, DWORD PTR __Dest$[esp-4]
	mov	DWORD PTR [ecx], eax
	mov	DWORD PTR [ecx+4], eax
	mov	eax, DWORD PTR __Al_$[esp-4]
	mov	DWORD PTR [ecx+8], eax
	mov	eax, ecx
	ret	8
??0?$_Uninitialized_backout_al@V?$xalloc@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@@@std@@QAE@PAV?$resptr_core@UShader@@Uresptrcode_shader@@@@AAV?$xalloc@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@@@Z ENDP ; std::_Uninitialized_backout_al<xalloc<resptr_core<Shader,resptrcode_shader> > >::_Uninitialized_backout_al<xalloc<resptr_core<Shader,resptrcode_shader> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Release@?$_Uninitialized_backout_al@V?$xalloc@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@@@std@@QAEPAV?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@XZ
_TEXT	SEGMENT
?_Release@?$_Uninitialized_backout_al@V?$xalloc@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@@@std@@QAEPAV?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@XZ PROC ; std::_Uninitialized_backout_al<xalloc<svector<_D3DVERTEXELEMENT9,65> > >::_Release, COMDAT
; _this$ = ecx

; 1625 :         _First = _Last;

	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [ecx], eax

; 1626 :         return _Last;
; 1627 :     }

	ret	0
?_Release@?$_Uninitialized_backout_al@V?$xalloc@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@@@std@@QAEPAV?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@XZ ENDP ; std::_Uninitialized_backout_al<xalloc<svector<_D3DVERTEXELEMENT9,65> > >::_Release
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??1?$_Uninitialized_backout_al@V?$xalloc@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Uninitialized_backout_al@V?$xalloc@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@@@std@@QAE@XZ PROC ; std::_Uninitialized_backout_al<xalloc<svector<_D3DVERTEXELEMENT9,65> > >::~_Uninitialized_backout_al<xalloc<svector<_D3DVERTEXELEMENT9,65> > >, COMDAT
; _this$ = ecx

; 1615 :         _Destroy_range(_First, _Last, _Al);
; 1616 :     }

	ret	0
??1?$_Uninitialized_backout_al@V?$xalloc@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@@@std@@QAE@XZ ENDP ; std::_Uninitialized_backout_al<xalloc<svector<_D3DVERTEXELEMENT9,65> > >::~_Uninitialized_backout_al<xalloc<svector<_D3DVERTEXELEMENT9,65> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??0?$_Uninitialized_backout_al@V?$xalloc@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@@@std@@QAE@PAV?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@AAV?$xalloc@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Al_$ = 12						; size = 4
??0?$_Uninitialized_backout_al@V?$xalloc@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@@@std@@QAE@PAV?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@AAV?$xalloc@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@@@Z PROC ; std::_Uninitialized_backout_al<xalloc<svector<_D3DVERTEXELEMENT9,65> > >::_Uninitialized_backout_al<xalloc<svector<_D3DVERTEXELEMENT9,65> > >, COMDAT
; _this$ = ecx

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	eax, DWORD PTR __Dest$[esp-4]
	mov	DWORD PTR [ecx], eax
	mov	DWORD PTR [ecx+4], eax
	mov	eax, DWORD PTR __Al_$[esp-4]
	mov	DWORD PTR [ecx+8], eax
	mov	eax, ecx
	ret	8
??0?$_Uninitialized_backout_al@V?$xalloc@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@@@std@@QAE@PAV?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@AAV?$xalloc@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@@@Z ENDP ; std::_Uninitialized_backout_al<xalloc<svector<_D3DVERTEXELEMENT9,65> > >::_Uninitialized_backout_al<xalloc<svector<_D3DVERTEXELEMENT9,65> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Release@?$_Uninitialized_backout_al@V?$xalloc@PAUIDirect3DVertexBuffer9@@@@@std@@QAEPAPAUIDirect3DVertexBuffer9@@XZ
_TEXT	SEGMENT
?_Release@?$_Uninitialized_backout_al@V?$xalloc@PAUIDirect3DVertexBuffer9@@@@@std@@QAEPAPAUIDirect3DVertexBuffer9@@XZ PROC ; std::_Uninitialized_backout_al<xalloc<IDirect3DVertexBuffer9 *> >::_Release, COMDAT
; _this$ = ecx

; 1625 :         _First = _Last;

	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [ecx], eax

; 1626 :         return _Last;
; 1627 :     }

	ret	0
?_Release@?$_Uninitialized_backout_al@V?$xalloc@PAUIDirect3DVertexBuffer9@@@@@std@@QAEPAPAUIDirect3DVertexBuffer9@@XZ ENDP ; std::_Uninitialized_backout_al<xalloc<IDirect3DVertexBuffer9 *> >::_Release
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??1?$_Uninitialized_backout_al@V?$xalloc@PAUIDirect3DVertexBuffer9@@@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Uninitialized_backout_al@V?$xalloc@PAUIDirect3DVertexBuffer9@@@@@std@@QAE@XZ PROC ; std::_Uninitialized_backout_al<xalloc<IDirect3DVertexBuffer9 *> >::~_Uninitialized_backout_al<xalloc<IDirect3DVertexBuffer9 *> >, COMDAT
; _this$ = ecx

; 1615 :         _Destroy_range(_First, _Last, _Al);
; 1616 :     }

	ret	0
??1?$_Uninitialized_backout_al@V?$xalloc@PAUIDirect3DVertexBuffer9@@@@@std@@QAE@XZ ENDP ; std::_Uninitialized_backout_al<xalloc<IDirect3DVertexBuffer9 *> >::~_Uninitialized_backout_al<xalloc<IDirect3DVertexBuffer9 *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??0?$_Uninitialized_backout_al@V?$xalloc@PAUIDirect3DVertexBuffer9@@@@@std@@QAE@PAPAUIDirect3DVertexBuffer9@@AAV?$xalloc@PAUIDirect3DVertexBuffer9@@@@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Al_$ = 12						; size = 4
??0?$_Uninitialized_backout_al@V?$xalloc@PAUIDirect3DVertexBuffer9@@@@@std@@QAE@PAPAUIDirect3DVertexBuffer9@@AAV?$xalloc@PAUIDirect3DVertexBuffer9@@@@@Z PROC ; std::_Uninitialized_backout_al<xalloc<IDirect3DVertexBuffer9 *> >::_Uninitialized_backout_al<xalloc<IDirect3DVertexBuffer9 *> >, COMDAT
; _this$ = ecx

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	eax, DWORD PTR __Dest$[esp-4]
	mov	DWORD PTR [ecx], eax
	mov	DWORD PTR [ecx+4], eax
	mov	eax, DWORD PTR __Al_$[esp-4]
	mov	DWORD PTR [ecx+8], eax
	mov	eax, ecx
	ret	8
??0?$_Uninitialized_backout_al@V?$xalloc@PAUIDirect3DVertexBuffer9@@@@@std@@QAE@PAPAUIDirect3DVertexBuffer9@@AAV?$xalloc@PAUIDirect3DVertexBuffer9@@@@@Z ENDP ; std::_Uninitialized_backout_al<xalloc<IDirect3DVertexBuffer9 *> >::_Uninitialized_backout_al<xalloc<IDirect3DVertexBuffer9 *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Release@?$_Uninitialized_backout_al@V?$xalloc@PAUIDirect3DIndexBuffer9@@@@@std@@QAEPAPAUIDirect3DIndexBuffer9@@XZ
_TEXT	SEGMENT
?_Release@?$_Uninitialized_backout_al@V?$xalloc@PAUIDirect3DIndexBuffer9@@@@@std@@QAEPAPAUIDirect3DIndexBuffer9@@XZ PROC ; std::_Uninitialized_backout_al<xalloc<IDirect3DIndexBuffer9 *> >::_Release, COMDAT
; _this$ = ecx

; 1625 :         _First = _Last;

	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [ecx], eax

; 1626 :         return _Last;
; 1627 :     }

	ret	0
?_Release@?$_Uninitialized_backout_al@V?$xalloc@PAUIDirect3DIndexBuffer9@@@@@std@@QAEPAPAUIDirect3DIndexBuffer9@@XZ ENDP ; std::_Uninitialized_backout_al<xalloc<IDirect3DIndexBuffer9 *> >::_Release
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??1?$_Uninitialized_backout_al@V?$xalloc@PAUIDirect3DIndexBuffer9@@@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Uninitialized_backout_al@V?$xalloc@PAUIDirect3DIndexBuffer9@@@@@std@@QAE@XZ PROC ; std::_Uninitialized_backout_al<xalloc<IDirect3DIndexBuffer9 *> >::~_Uninitialized_backout_al<xalloc<IDirect3DIndexBuffer9 *> >, COMDAT
; _this$ = ecx

; 1615 :         _Destroy_range(_First, _Last, _Al);
; 1616 :     }

	ret	0
??1?$_Uninitialized_backout_al@V?$xalloc@PAUIDirect3DIndexBuffer9@@@@@std@@QAE@XZ ENDP ; std::_Uninitialized_backout_al<xalloc<IDirect3DIndexBuffer9 *> >::~_Uninitialized_backout_al<xalloc<IDirect3DIndexBuffer9 *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??0?$_Uninitialized_backout_al@V?$xalloc@PAUIDirect3DIndexBuffer9@@@@@std@@QAE@PAPAUIDirect3DIndexBuffer9@@AAV?$xalloc@PAUIDirect3DIndexBuffer9@@@@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Al_$ = 12						; size = 4
??0?$_Uninitialized_backout_al@V?$xalloc@PAUIDirect3DIndexBuffer9@@@@@std@@QAE@PAPAUIDirect3DIndexBuffer9@@AAV?$xalloc@PAUIDirect3DIndexBuffer9@@@@@Z PROC ; std::_Uninitialized_backout_al<xalloc<IDirect3DIndexBuffer9 *> >::_Uninitialized_backout_al<xalloc<IDirect3DIndexBuffer9 *> >, COMDAT
; _this$ = ecx

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	eax, DWORD PTR __Dest$[esp-4]
	mov	DWORD PTR [ecx], eax
	mov	DWORD PTR [ecx+4], eax
	mov	eax, DWORD PTR __Al_$[esp-4]
	mov	DWORD PTR [ecx+8], eax
	mov	eax, ecx
	ret	8
??0?$_Uninitialized_backout_al@V?$xalloc@PAUIDirect3DIndexBuffer9@@@@@std@@QAE@PAPAUIDirect3DIndexBuffer9@@AAV?$xalloc@PAUIDirect3DIndexBuffer9@@@@@Z ENDP ; std::_Uninitialized_backout_al<xalloc<IDirect3DIndexBuffer9 *> >::_Uninitialized_backout_al<xalloc<IDirect3DIndexBuffer9 *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Xlength@?$vector@PAUIDirect3DIndexBuffer9@@V?$xalloc@PAUIDirect3DIndexBuffer9@@@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@PAUIDirect3DIndexBuffer9@@V?$xalloc@PAUIDirect3DIndexBuffer9@@@@@std@@CAXXZ PROC ; std::vector<IDirect3DIndexBuffer9 *,xalloc<IDirect3DIndexBuffer9 *> >::_Xlength, COMDAT

; 1761 :         _Xlength_error("vector too long");

	push	OFFSET ??_C@_0BA@FOIKENOD@vector?5too?5long@
	call	DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN3@Xlength:
	int	3
?_Xlength@?$vector@PAUIDirect3DIndexBuffer9@@V?$xalloc@PAUIDirect3DIndexBuffer9@@@@@std@@CAXXZ ENDP ; std::vector<IDirect3DIndexBuffer9 *,xalloc<IDirect3DIndexBuffer9 *> >::_Xlength
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Change_array@?$vector@PAUIDirect3DIndexBuffer9@@V?$xalloc@PAUIDirect3DIndexBuffer9@@@@@std@@AAEXQAPAUIDirect3DIndexBuffer9@@II@Z
_TEXT	SEGMENT
__Newvec$ = 8						; size = 4
__Newsize$ = 12						; size = 4
__Newcapacity$ = 16					; size = 4
?_Change_array@?$vector@PAUIDirect3DIndexBuffer9@@V?$xalloc@PAUIDirect3DIndexBuffer9@@@@@std@@AAEXQAPAUIDirect3DIndexBuffer9@@II@Z PROC ; std::vector<IDirect3DIndexBuffer9 *,xalloc<IDirect3DIndexBuffer9 *> >::_Change_array, COMDAT
; _this$ = ecx

; 1723 :         const pointer _Newvec, const size_type _Newsize, const size_type _Newcapacity) {

	push	esi
	mov	esi, ecx

; 1724 :         // orphan all iterators, discard old array, acquire new array
; 1725 :         auto& _My_data    = _Mypair._Myval2;
; 1726 :         pointer& _Myfirst = _My_data._Myfirst;
; 1727 :         pointer& _Mylast  = _My_data._Mylast;
; 1728 :         pointer& _Myend   = _My_data._Myend;
; 1729 : 
; 1730 :         _My_data._Orphan_all();
; 1731 : 
; 1732 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN7@Change_arr
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN7@Change_arr:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1737 :         _Myfirst = _Newvec;

	mov	ecx, DWORD PTR __Newvec$[esp]

; 1738 :         _Mylast  = _Newvec + _Newsize;

	mov	eax, DWORD PTR __Newsize$[esp]
	mov	DWORD PTR [esi], ecx
	lea	eax, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR [esi+4], eax

; 1739 :         _Myend   = _Newvec + _Newcapacity;

	mov	eax, DWORD PTR __Newcapacity$[esp]
	lea	eax, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR [esi+8], eax
	pop	esi

; 1740 :     }

	ret	12					; 0000000cH
?_Change_array@?$vector@PAUIDirect3DIndexBuffer9@@V?$xalloc@PAUIDirect3DIndexBuffer9@@@@@std@@AAEXQAPAUIDirect3DIndexBuffer9@@II@Z ENDP ; std::vector<IDirect3DIndexBuffer9 *,xalloc<IDirect3DIndexBuffer9 *> >::_Change_array
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Calculate_growth@?$vector@PAUIDirect3DIndexBuffer9@@V?$xalloc@PAUIDirect3DIndexBuffer9@@@@@std@@ABEII@Z
_TEXT	SEGMENT
__Newsize$ = 8						; size = 4
?_Calculate_growth@?$vector@PAUIDirect3DIndexBuffer9@@V?$xalloc@PAUIDirect3DIndexBuffer9@@@@@std@@ABEII@Z PROC ; std::vector<IDirect3DIndexBuffer9 *,xalloc<IDirect3DIndexBuffer9 *> >::_Calculate_growth, COMDAT
; _this$ = ecx

; 1546 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	edx, DWORD PTR [ecx+8]
	sub	edx, DWORD PTR [ecx]

; 1671 :         // given _Oldcapacity and _Newsize, calculate geometric growth
; 1672 :         const size_type _Oldcapacity = capacity();
; 1673 :         const auto _Max              = max_size();
; 1674 : 
; 1675 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	ecx, 1073741823				; 3fffffffH

; 1546 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	sar	edx, 2

; 1670 :     _CONSTEXPR20_CONTAINER size_type _Calculate_growth(const size_type _Newsize) const {

	push	esi

; 1671 :         // given _Oldcapacity and _Newsize, calculate geometric growth
; 1672 :         const size_type _Oldcapacity = capacity();
; 1673 :         const auto _Max              = max_size();
; 1674 : 
; 1675 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	esi, edx
	shr	esi, 1
	sub	ecx, esi
	cmp	edx, ecx
	jbe	SHORT $LN2@Calculate_

; 1676 :             return _Max; // geometric growth would overflow

	mov	eax, 1073741823				; 3fffffffH
	pop	esi

; 1682 :             return _Newsize; // geometric growth would be insufficient
; 1683 :         }
; 1684 : 
; 1685 :         return _Geometric; // geometric growth is sufficient
; 1686 :     }

	ret	4
$LN2@Calculate_:

; 1677 :         }
; 1678 : 
; 1679 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	lea	eax, DWORD PTR [esi+edx]

; 1680 : 
; 1681 :         if (_Geometric < _Newsize) {

	cmp	eax, DWORD PTR __Newsize$[esp]
	pop	esi
	cmovb	eax, DWORD PTR __Newsize$[esp-4]

; 1682 :             return _Newsize; // geometric growth would be insufficient
; 1683 :         }
; 1684 : 
; 1685 :         return _Geometric; // geometric growth is sufficient
; 1686 :     }

	ret	4
?_Calculate_growth@?$vector@PAUIDirect3DIndexBuffer9@@V?$xalloc@PAUIDirect3DIndexBuffer9@@@@@std@@ABEII@Z ENDP ; std::vector<IDirect3DIndexBuffer9 *,xalloc<IDirect3DIndexBuffer9 *> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Umove_if_noexcept@?$vector@PAUIDirect3DIndexBuffer9@@V?$xalloc@PAUIDirect3DIndexBuffer9@@@@@std@@AAEXPAPAUIDirect3DIndexBuffer9@@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
?_Umove_if_noexcept@?$vector@PAUIDirect3DIndexBuffer9@@V?$xalloc@PAUIDirect3DIndexBuffer9@@@@@std@@AAEXPAPAUIDirect3DIndexBuffer9@@00@Z PROC ; std::vector<IDirect3DIndexBuffer9 *,xalloc<IDirect3DIndexBuffer9 *> >::_Umove_if_noexcept, COMDAT
; _this$dead$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1703 :     auto _UFirst      = _Get_unwrapped(_First);

	mov	eax, DWORD PTR __First$[esp-4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1659 :     _CONSTEXPR20_CONTAINER void _Umove_if_noexcept(pointer _First, pointer _Last, pointer _Dest) {

	push	esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	mov	esi, DWORD PTR __Last$[esp]
	cmp	eax, esi
	je	SHORT $LN7@Umove_if_n

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	edx, DWORD PTR __Dest$[esp]
	sub	edx, eax
$LL8@Umove_if_n:

; 1620 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx+eax], ecx

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	add	eax, 4
	cmp	eax, esi
	jne	SHORT $LL8@Umove_if_n
$LN7@Umove_if_n:
	pop	esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1663 :     }

	ret	12					; 0000000cH
?_Umove_if_noexcept@?$vector@PAUIDirect3DIndexBuffer9@@V?$xalloc@PAUIDirect3DIndexBuffer9@@@@@std@@AAEXPAPAUIDirect3DIndexBuffer9@@00@Z ENDP ; std::vector<IDirect3DIndexBuffer9 *,xalloc<IDirect3DIndexBuffer9 *> >::_Umove_if_noexcept
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?max_size@?$vector@PAUIDirect3DIndexBuffer9@@V?$xalloc@PAUIDirect3DIndexBuffer9@@@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@PAUIDirect3DIndexBuffer9@@V?$xalloc@PAUIDirect3DIndexBuffer9@@@@@std@@QBEIXZ PROC ; std::vector<IDirect3DIndexBuffer9 *,xalloc<IDirect3DIndexBuffer9 *> >::max_size, COMDAT
; _this$dead$ = ecx

; 1540 :         return (_STD min)(

	mov	eax, 1073741823				; 3fffffffH

; 1541 :             static_cast<size_type>((numeric_limits<difference_type>::max)()), _Alty_traits::max_size(_Getal()));
; 1542 :     }

	ret	0
?max_size@?$vector@PAUIDirect3DIndexBuffer9@@V?$xalloc@PAUIDirect3DIndexBuffer9@@@@@std@@QBEIXZ ENDP ; std::vector<IDirect3DIndexBuffer9 *,xalloc<IDirect3DIndexBuffer9 *> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?allocate@?$xalloc@PAUIDirect3DIndexBuffer9@@@@QBEPAPAUIDirect3DIndexBuffer9@@IPBX@Z
_TEXT	SEGMENT
_n$ = 8							; size = 4
_p$dead$ = 12						; size = 4
?allocate@?$xalloc@PAUIDirect3DIndexBuffer9@@@@QBEPAPAUIDirect3DIndexBuffer9@@IPBX@Z PROC ; xalloc<IDirect3DIndexBuffer9 *>::allocate, COMDAT
; _this$dead$ = ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	mov	eax, DWORD PTR _n$[esp-4]
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	shl	eax, 2
	push	eax
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 80   : 							pointer					allocate		(size_type n, const void* p=0) const	{	return xr_alloc<T>((u32)n);	}

	ret	8
?allocate@?$xalloc@PAUIDirect3DIndexBuffer9@@@@QBEPAPAUIDirect3DIndexBuffer9@@IPBX@Z ENDP ; xalloc<IDirect3DIndexBuffer9 *>::allocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Xlength@?$vector@PAUIDirect3DVertexBuffer9@@V?$xalloc@PAUIDirect3DVertexBuffer9@@@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@PAUIDirect3DVertexBuffer9@@V?$xalloc@PAUIDirect3DVertexBuffer9@@@@@std@@CAXXZ PROC ; std::vector<IDirect3DVertexBuffer9 *,xalloc<IDirect3DVertexBuffer9 *> >::_Xlength, COMDAT

; 1761 :         _Xlength_error("vector too long");

	push	OFFSET ??_C@_0BA@FOIKENOD@vector?5too?5long@
	call	DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN3@Xlength:
	int	3
?_Xlength@?$vector@PAUIDirect3DVertexBuffer9@@V?$xalloc@PAUIDirect3DVertexBuffer9@@@@@std@@CAXXZ ENDP ; std::vector<IDirect3DVertexBuffer9 *,xalloc<IDirect3DVertexBuffer9 *> >::_Xlength
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Change_array@?$vector@PAUIDirect3DVertexBuffer9@@V?$xalloc@PAUIDirect3DVertexBuffer9@@@@@std@@AAEXQAPAUIDirect3DVertexBuffer9@@II@Z
_TEXT	SEGMENT
__Newvec$ = 8						; size = 4
__Newsize$ = 12						; size = 4
__Newcapacity$ = 16					; size = 4
?_Change_array@?$vector@PAUIDirect3DVertexBuffer9@@V?$xalloc@PAUIDirect3DVertexBuffer9@@@@@std@@AAEXQAPAUIDirect3DVertexBuffer9@@II@Z PROC ; std::vector<IDirect3DVertexBuffer9 *,xalloc<IDirect3DVertexBuffer9 *> >::_Change_array, COMDAT
; _this$ = ecx

; 1723 :         const pointer _Newvec, const size_type _Newsize, const size_type _Newcapacity) {

	push	esi
	mov	esi, ecx

; 1724 :         // orphan all iterators, discard old array, acquire new array
; 1725 :         auto& _My_data    = _Mypair._Myval2;
; 1726 :         pointer& _Myfirst = _My_data._Myfirst;
; 1727 :         pointer& _Mylast  = _My_data._Mylast;
; 1728 :         pointer& _Myend   = _My_data._Myend;
; 1729 : 
; 1730 :         _My_data._Orphan_all();
; 1731 : 
; 1732 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN7@Change_arr
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN7@Change_arr:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1737 :         _Myfirst = _Newvec;

	mov	ecx, DWORD PTR __Newvec$[esp]

; 1738 :         _Mylast  = _Newvec + _Newsize;

	mov	eax, DWORD PTR __Newsize$[esp]
	mov	DWORD PTR [esi], ecx
	lea	eax, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR [esi+4], eax

; 1739 :         _Myend   = _Newvec + _Newcapacity;

	mov	eax, DWORD PTR __Newcapacity$[esp]
	lea	eax, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR [esi+8], eax
	pop	esi

; 1740 :     }

	ret	12					; 0000000cH
?_Change_array@?$vector@PAUIDirect3DVertexBuffer9@@V?$xalloc@PAUIDirect3DVertexBuffer9@@@@@std@@AAEXQAPAUIDirect3DVertexBuffer9@@II@Z ENDP ; std::vector<IDirect3DVertexBuffer9 *,xalloc<IDirect3DVertexBuffer9 *> >::_Change_array
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Calculate_growth@?$vector@PAUIDirect3DVertexBuffer9@@V?$xalloc@PAUIDirect3DVertexBuffer9@@@@@std@@ABEII@Z
_TEXT	SEGMENT
__Newsize$ = 8						; size = 4
?_Calculate_growth@?$vector@PAUIDirect3DVertexBuffer9@@V?$xalloc@PAUIDirect3DVertexBuffer9@@@@@std@@ABEII@Z PROC ; std::vector<IDirect3DVertexBuffer9 *,xalloc<IDirect3DVertexBuffer9 *> >::_Calculate_growth, COMDAT
; _this$ = ecx

; 1546 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	edx, DWORD PTR [ecx+8]
	sub	edx, DWORD PTR [ecx]

; 1671 :         // given _Oldcapacity and _Newsize, calculate geometric growth
; 1672 :         const size_type _Oldcapacity = capacity();
; 1673 :         const auto _Max              = max_size();
; 1674 : 
; 1675 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	ecx, 1073741823				; 3fffffffH

; 1546 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	sar	edx, 2

; 1670 :     _CONSTEXPR20_CONTAINER size_type _Calculate_growth(const size_type _Newsize) const {

	push	esi

; 1671 :         // given _Oldcapacity and _Newsize, calculate geometric growth
; 1672 :         const size_type _Oldcapacity = capacity();
; 1673 :         const auto _Max              = max_size();
; 1674 : 
; 1675 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	esi, edx
	shr	esi, 1
	sub	ecx, esi
	cmp	edx, ecx
	jbe	SHORT $LN2@Calculate_

; 1676 :             return _Max; // geometric growth would overflow

	mov	eax, 1073741823				; 3fffffffH
	pop	esi

; 1682 :             return _Newsize; // geometric growth would be insufficient
; 1683 :         }
; 1684 : 
; 1685 :         return _Geometric; // geometric growth is sufficient
; 1686 :     }

	ret	4
$LN2@Calculate_:

; 1677 :         }
; 1678 : 
; 1679 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	lea	eax, DWORD PTR [esi+edx]

; 1680 : 
; 1681 :         if (_Geometric < _Newsize) {

	cmp	eax, DWORD PTR __Newsize$[esp]
	pop	esi
	cmovb	eax, DWORD PTR __Newsize$[esp-4]

; 1682 :             return _Newsize; // geometric growth would be insufficient
; 1683 :         }
; 1684 : 
; 1685 :         return _Geometric; // geometric growth is sufficient
; 1686 :     }

	ret	4
?_Calculate_growth@?$vector@PAUIDirect3DVertexBuffer9@@V?$xalloc@PAUIDirect3DVertexBuffer9@@@@@std@@ABEII@Z ENDP ; std::vector<IDirect3DVertexBuffer9 *,xalloc<IDirect3DVertexBuffer9 *> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Umove_if_noexcept@?$vector@PAUIDirect3DVertexBuffer9@@V?$xalloc@PAUIDirect3DVertexBuffer9@@@@@std@@AAEXPAPAUIDirect3DVertexBuffer9@@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
?_Umove_if_noexcept@?$vector@PAUIDirect3DVertexBuffer9@@V?$xalloc@PAUIDirect3DVertexBuffer9@@@@@std@@AAEXPAPAUIDirect3DVertexBuffer9@@00@Z PROC ; std::vector<IDirect3DVertexBuffer9 *,xalloc<IDirect3DVertexBuffer9 *> >::_Umove_if_noexcept, COMDAT
; _this$dead$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1703 :     auto _UFirst      = _Get_unwrapped(_First);

	mov	eax, DWORD PTR __First$[esp-4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1659 :     _CONSTEXPR20_CONTAINER void _Umove_if_noexcept(pointer _First, pointer _Last, pointer _Dest) {

	push	esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	mov	esi, DWORD PTR __Last$[esp]
	cmp	eax, esi
	je	SHORT $LN7@Umove_if_n

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	edx, DWORD PTR __Dest$[esp]
	sub	edx, eax
$LL8@Umove_if_n:

; 1620 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx+eax], ecx

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	add	eax, 4
	cmp	eax, esi
	jne	SHORT $LL8@Umove_if_n
$LN7@Umove_if_n:
	pop	esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1663 :     }

	ret	12					; 0000000cH
?_Umove_if_noexcept@?$vector@PAUIDirect3DVertexBuffer9@@V?$xalloc@PAUIDirect3DVertexBuffer9@@@@@std@@AAEXPAPAUIDirect3DVertexBuffer9@@00@Z ENDP ; std::vector<IDirect3DVertexBuffer9 *,xalloc<IDirect3DVertexBuffer9 *> >::_Umove_if_noexcept
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?max_size@?$vector@PAUIDirect3DVertexBuffer9@@V?$xalloc@PAUIDirect3DVertexBuffer9@@@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@PAUIDirect3DVertexBuffer9@@V?$xalloc@PAUIDirect3DVertexBuffer9@@@@@std@@QBEIXZ PROC ; std::vector<IDirect3DVertexBuffer9 *,xalloc<IDirect3DVertexBuffer9 *> >::max_size, COMDAT
; _this$dead$ = ecx

; 1540 :         return (_STD min)(

	mov	eax, 1073741823				; 3fffffffH

; 1541 :             static_cast<size_type>((numeric_limits<difference_type>::max)()), _Alty_traits::max_size(_Getal()));
; 1542 :     }

	ret	0
?max_size@?$vector@PAUIDirect3DVertexBuffer9@@V?$xalloc@PAUIDirect3DVertexBuffer9@@@@@std@@QBEIXZ ENDP ; std::vector<IDirect3DVertexBuffer9 *,xalloc<IDirect3DVertexBuffer9 *> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?allocate@?$xalloc@PAUIDirect3DVertexBuffer9@@@@QBEPAPAUIDirect3DVertexBuffer9@@IPBX@Z
_TEXT	SEGMENT
_n$ = 8							; size = 4
_p$dead$ = 12						; size = 4
?allocate@?$xalloc@PAUIDirect3DVertexBuffer9@@@@QBEPAPAUIDirect3DVertexBuffer9@@IPBX@Z PROC ; xalloc<IDirect3DVertexBuffer9 *>::allocate, COMDAT
; _this$dead$ = ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	mov	eax, DWORD PTR _n$[esp-4]
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	shl	eax, 2
	push	eax
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 80   : 							pointer					allocate		(size_type n, const void* p=0) const	{	return xr_alloc<T>((u32)n);	}

	ret	8
?allocate@?$xalloc@PAUIDirect3DVertexBuffer9@@@@QBEPAPAUIDirect3DVertexBuffer9@@IPBX@Z ENDP ; xalloc<IDirect3DVertexBuffer9 *>::allocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Xlength@?$vector@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@V?$xalloc@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@V?$xalloc@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@@@std@@CAXXZ PROC ; std::vector<svector<_D3DVERTEXELEMENT9,65>,xalloc<svector<_D3DVERTEXELEMENT9,65> > >::_Xlength, COMDAT

; 1761 :         _Xlength_error("vector too long");

	push	OFFSET ??_C@_0BA@FOIKENOD@vector?5too?5long@
	call	DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN3@Xlength:
	int	3
?_Xlength@?$vector@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@V?$xalloc@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@@@std@@CAXXZ ENDP ; std::vector<svector<_D3DVERTEXELEMENT9,65>,xalloc<svector<_D3DVERTEXELEMENT9,65> > >::_Xlength
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Change_array@?$vector@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@V?$xalloc@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@@@std@@AAEXQAV?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@II@Z
_TEXT	SEGMENT
__Newvec$ = 8						; size = 4
__Newsize$ = 12						; size = 4
__Newcapacity$ = 16					; size = 4
?_Change_array@?$vector@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@V?$xalloc@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@@@std@@AAEXQAV?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@II@Z PROC ; std::vector<svector<_D3DVERTEXELEMENT9,65>,xalloc<svector<_D3DVERTEXELEMENT9,65> > >::_Change_array, COMDAT
; _this$ = ecx

; 1723 :         const pointer _Newvec, const size_type _Newsize, const size_type _Newcapacity) {

	push	esi
	mov	esi, ecx

; 1724 :         // orphan all iterators, discard old array, acquire new array
; 1725 :         auto& _My_data    = _Mypair._Myval2;
; 1726 :         pointer& _Myfirst = _My_data._Myfirst;
; 1727 :         pointer& _Mylast  = _My_data._Mylast;
; 1728 :         pointer& _Myend   = _My_data._Myend;
; 1729 : 
; 1730 :         _My_data._Orphan_all();
; 1731 : 
; 1732 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN7@Change_arr
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN7@Change_arr:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1738 :         _Mylast  = _Newvec + _Newsize;

	imul	eax, DWORD PTR __Newsize$[esp], 524
	mov	ecx, DWORD PTR __Newvec$[esp]
	mov	DWORD PTR [esi], ecx
	add	eax, ecx
	mov	DWORD PTR [esi+4], eax

; 1739 :         _Myend   = _Newvec + _Newcapacity;

	imul	eax, DWORD PTR __Newcapacity$[esp], 524
	add	eax, ecx
	mov	DWORD PTR [esi+8], eax
	pop	esi

; 1740 :     }

	ret	12					; 0000000cH
?_Change_array@?$vector@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@V?$xalloc@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@@@std@@AAEXQAV?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@II@Z ENDP ; std::vector<svector<_D3DVERTEXELEMENT9,65>,xalloc<svector<_D3DVERTEXELEMENT9,65> > >::_Change_array
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Calculate_growth@?$vector@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@V?$xalloc@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@@@std@@ABEII@Z
_TEXT	SEGMENT
__Newsize$ = 8						; size = 4
?_Calculate_growth@?$vector@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@V?$xalloc@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@@@std@@ABEII@Z PROC ; std::vector<svector<_D3DVERTEXELEMENT9,65>,xalloc<svector<_D3DVERTEXELEMENT9,65> > >::_Calculate_growth, COMDAT
; _this$ = ecx

; 1546 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	edx, DWORD PTR [ecx+8]
	mov	eax, 1049152317				; 3e88cb3dH
	sub	edx, DWORD PTR [ecx]

; 1671 :         // given _Oldcapacity and _Newsize, calculate geometric growth
; 1672 :         const size_type _Oldcapacity = capacity();
; 1673 :         const auto _Max              = max_size();
; 1674 : 
; 1675 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	ecx, 8196502				; 007d1196H

; 1546 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	imul	edx

; 1670 :     _CONSTEXPR20_CONTAINER size_type _Calculate_growth(const size_type _Newsize) const {

	push	esi

; 1546 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	sar	edx, 7
	mov	esi, edx
	shr	esi, 31					; 0000001fH
	add	esi, edx

; 1671 :         // given _Oldcapacity and _Newsize, calculate geometric growth
; 1672 :         const size_type _Oldcapacity = capacity();
; 1673 :         const auto _Max              = max_size();
; 1674 : 
; 1675 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	edx, esi
	shr	edx, 1
	sub	ecx, edx
	cmp	esi, ecx
	jbe	SHORT $LN2@Calculate_

; 1676 :             return _Max; // geometric growth would overflow

	mov	eax, 8196502				; 007d1196H
	pop	esi

; 1682 :             return _Newsize; // geometric growth would be insufficient
; 1683 :         }
; 1684 : 
; 1685 :         return _Geometric; // geometric growth is sufficient
; 1686 :     }

	ret	4
$LN2@Calculate_:

; 1677 :         }
; 1678 : 
; 1679 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	lea	eax, DWORD PTR [edx+esi]

; 1680 : 
; 1681 :         if (_Geometric < _Newsize) {

	cmp	eax, DWORD PTR __Newsize$[esp]
	pop	esi
	cmovb	eax, DWORD PTR __Newsize$[esp-4]

; 1682 :             return _Newsize; // geometric growth would be insufficient
; 1683 :         }
; 1684 : 
; 1685 :         return _Geometric; // geometric growth is sufficient
; 1686 :     }

	ret	4
?_Calculate_growth@?$vector@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@V?$xalloc@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@@@std@@ABEII@Z ENDP ; std::vector<svector<_D3DVERTEXELEMENT9,65>,xalloc<svector<_D3DVERTEXELEMENT9,65> > >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Umove_if_noexcept@?$vector@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@V?$xalloc@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@@@std@@AAEXPAV?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
?_Umove_if_noexcept@?$vector@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@V?$xalloc@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@@@std@@AAEXPAV?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@00@Z PROC ; std::vector<svector<_D3DVERTEXELEMENT9,65>,xalloc<svector<_D3DVERTEXELEMENT9,65> > >::_Umove_if_noexcept, COMDAT
; _this$dead$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1703 :     auto _UFirst      = _Get_unwrapped(_First);

	mov	eax, DWORD PTR __First$[esp-4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1659 :     _CONSTEXPR20_CONTAINER void _Umove_if_noexcept(pointer _First, pointer _Last, pointer _Dest) {

	push	ebx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	mov	ebx, DWORD PTR __Last$[esp]
	cmp	eax, ebx
	je	SHORT $LN7@Umove_if_n

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	edx, DWORD PTR __Dest$[esp]
	push	esi
	sub	edx, eax
	push	edi
$LL8@Umove_if_n:
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	lea	edi, DWORD PTR [edx+eax]
	mov	esi, eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	add	eax, 524				; 0000020cH
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	ecx, 131				; 00000083H
	rep movsd
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	eax, ebx
	jne	SHORT $LL8@Umove_if_n
	pop	edi
	pop	esi
$LN7@Umove_if_n:
	pop	ebx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1663 :     }

	ret	12					; 0000000cH
?_Umove_if_noexcept@?$vector@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@V?$xalloc@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@@@std@@AAEXPAV?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@00@Z ENDP ; std::vector<svector<_D3DVERTEXELEMENT9,65>,xalloc<svector<_D3DVERTEXELEMENT9,65> > >::_Umove_if_noexcept
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?max_size@?$vector@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@V?$xalloc@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@V?$xalloc@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@@@std@@QBEIXZ PROC ; std::vector<svector<_D3DVERTEXELEMENT9,65>,xalloc<svector<_D3DVERTEXELEMENT9,65> > >::max_size, COMDAT
; _this$dead$ = ecx

; 1540 :         return (_STD min)(

	mov	eax, 8196502				; 007d1196H

; 1541 :             static_cast<size_type>((numeric_limits<difference_type>::max)()), _Alty_traits::max_size(_Getal()));
; 1542 :     }

	ret	0
?max_size@?$vector@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@V?$xalloc@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@@@std@@QBEIXZ ENDP ; std::vector<svector<_D3DVERTEXELEMENT9,65>,xalloc<svector<_D3DVERTEXELEMENT9,65> > >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?allocate@?$xalloc@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@@QBEPAV?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@IPBX@Z
_TEXT	SEGMENT
_n$ = 8							; size = 4
_p$dead$ = 12						; size = 4
?allocate@?$xalloc@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@@QBEPAV?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@IPBX@Z PROC ; xalloc<svector<_D3DVERTEXELEMENT9,65> >::allocate, COMDAT
; _this$dead$ = ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	imul	eax, DWORD PTR _n$[esp-4], 524
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 80   : 							pointer					allocate		(size_type n, const void* p=0) const	{	return xr_alloc<T>((u32)n);	}

	ret	8
?allocate@?$xalloc@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@@QBEPAV?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@IPBX@Z ENDP ; xalloc<svector<_D3DVERTEXELEMENT9,65> >::allocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Xlength@?$vector@V?$resptr_core@UShader@@Uresptrcode_shader@@@@V?$xalloc@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@V?$resptr_core@UShader@@Uresptrcode_shader@@@@V?$xalloc@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@@@std@@CAXXZ PROC ; std::vector<resptr_core<Shader,resptrcode_shader>,xalloc<resptr_core<Shader,resptrcode_shader> > >::_Xlength, COMDAT

; 1761 :         _Xlength_error("vector too long");

	push	OFFSET ??_C@_0BA@FOIKENOD@vector?5too?5long@
	call	DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN3@Xlength:
	int	3
?_Xlength@?$vector@V?$resptr_core@UShader@@Uresptrcode_shader@@@@V?$xalloc@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@@@std@@CAXXZ ENDP ; std::vector<resptr_core<Shader,resptrcode_shader>,xalloc<resptr_core<Shader,resptrcode_shader> > >::_Xlength
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Change_array@?$vector@V?$resptr_core@UShader@@Uresptrcode_shader@@@@V?$xalloc@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@@@std@@AAEXQAV?$resptr_core@UShader@@Uresptrcode_shader@@@@II@Z
_TEXT	SEGMENT
__Newvec$ = 8						; size = 4
__Newsize$ = 12						; size = 4
__Newcapacity$ = 16					; size = 4
?_Change_array@?$vector@V?$resptr_core@UShader@@Uresptrcode_shader@@@@V?$xalloc@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@@@std@@AAEXQAV?$resptr_core@UShader@@Uresptrcode_shader@@@@II@Z PROC ; std::vector<resptr_core<Shader,resptrcode_shader>,xalloc<resptr_core<Shader,resptrcode_shader> > >::_Change_array, COMDAT
; _this$ = ecx

; 1723 :         const pointer _Newvec, const size_type _Newsize, const size_type _Newcapacity) {

	push	esi
	mov	esi, ecx

; 1724 :         // orphan all iterators, discard old array, acquire new array
; 1725 :         auto& _My_data    = _Mypair._Myval2;
; 1726 :         pointer& _Myfirst = _My_data._Myfirst;
; 1727 :         pointer& _Mylast  = _My_data._Mylast;
; 1728 :         pointer& _Myend   = _My_data._Myend;
; 1729 : 
; 1730 :         _My_data._Orphan_all();
; 1731 : 
; 1732 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN7@Change_arr
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN7@Change_arr:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1737 :         _Myfirst = _Newvec;

	mov	ecx, DWORD PTR __Newvec$[esp]

; 1738 :         _Mylast  = _Newvec + _Newsize;

	mov	eax, DWORD PTR __Newsize$[esp]
	mov	DWORD PTR [esi], ecx
	lea	eax, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR [esi+4], eax

; 1739 :         _Myend   = _Newvec + _Newcapacity;

	mov	eax, DWORD PTR __Newcapacity$[esp]
	lea	eax, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR [esi+8], eax
	pop	esi

; 1740 :     }

	ret	12					; 0000000cH
?_Change_array@?$vector@V?$resptr_core@UShader@@Uresptrcode_shader@@@@V?$xalloc@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@@@std@@AAEXQAV?$resptr_core@UShader@@Uresptrcode_shader@@@@II@Z ENDP ; std::vector<resptr_core<Shader,resptrcode_shader>,xalloc<resptr_core<Shader,resptrcode_shader> > >::_Change_array
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Calculate_growth@?$vector@V?$resptr_core@UShader@@Uresptrcode_shader@@@@V?$xalloc@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@@@std@@ABEII@Z
_TEXT	SEGMENT
__Newsize$ = 8						; size = 4
?_Calculate_growth@?$vector@V?$resptr_core@UShader@@Uresptrcode_shader@@@@V?$xalloc@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@@@std@@ABEII@Z PROC ; std::vector<resptr_core<Shader,resptrcode_shader>,xalloc<resptr_core<Shader,resptrcode_shader> > >::_Calculate_growth, COMDAT
; _this$ = ecx

; 1546 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	edx, DWORD PTR [ecx+8]
	sub	edx, DWORD PTR [ecx]

; 1671 :         // given _Oldcapacity and _Newsize, calculate geometric growth
; 1672 :         const size_type _Oldcapacity = capacity();
; 1673 :         const auto _Max              = max_size();
; 1674 : 
; 1675 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	ecx, 1073741823				; 3fffffffH

; 1546 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	sar	edx, 2

; 1670 :     _CONSTEXPR20_CONTAINER size_type _Calculate_growth(const size_type _Newsize) const {

	push	esi

; 1671 :         // given _Oldcapacity and _Newsize, calculate geometric growth
; 1672 :         const size_type _Oldcapacity = capacity();
; 1673 :         const auto _Max              = max_size();
; 1674 : 
; 1675 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	esi, edx
	shr	esi, 1
	sub	ecx, esi
	cmp	edx, ecx
	jbe	SHORT $LN2@Calculate_

; 1676 :             return _Max; // geometric growth would overflow

	mov	eax, 1073741823				; 3fffffffH
	pop	esi

; 1682 :             return _Newsize; // geometric growth would be insufficient
; 1683 :         }
; 1684 : 
; 1685 :         return _Geometric; // geometric growth is sufficient
; 1686 :     }

	ret	4
$LN2@Calculate_:

; 1677 :         }
; 1678 : 
; 1679 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	lea	eax, DWORD PTR [esi+edx]

; 1680 : 
; 1681 :         if (_Geometric < _Newsize) {

	cmp	eax, DWORD PTR __Newsize$[esp]
	pop	esi
	cmovb	eax, DWORD PTR __Newsize$[esp-4]

; 1682 :             return _Newsize; // geometric growth would be insufficient
; 1683 :         }
; 1684 : 
; 1685 :         return _Geometric; // geometric growth is sufficient
; 1686 :     }

	ret	4
?_Calculate_growth@?$vector@V?$resptr_core@UShader@@Uresptrcode_shader@@@@V?$xalloc@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@@@std@@ABEII@Z ENDP ; std::vector<resptr_core<Shader,resptrcode_shader>,xalloc<resptr_core<Shader,resptrcode_shader> > >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Umove_if_noexcept@?$vector@V?$resptr_core@UShader@@Uresptrcode_shader@@@@V?$xalloc@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@@@std@@AAEXPAV?$resptr_core@UShader@@Uresptrcode_shader@@@@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
?_Umove_if_noexcept@?$vector@V?$resptr_core@UShader@@Uresptrcode_shader@@@@V?$xalloc@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@@@std@@AAEXPAV?$resptr_core@UShader@@Uresptrcode_shader@@@@00@Z PROC ; std::vector<resptr_core<Shader,resptrcode_shader>,xalloc<resptr_core<Shader,resptrcode_shader> > >::_Umove_if_noexcept, COMDAT
; _this$dead$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1642 :     auto _UFirst      = _Get_unwrapped(_First);

	mov	eax, DWORD PTR __First$[esp-4]

; 1658 :     for (; _UFirst != _ULast; ++_UFirst) {

	mov	edx, DWORD PTR __Last$[esp-4]
	cmp	eax, edx
	je	SHORT $LN7@Umove_if_n

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	push	esi
	mov	esi, DWORD PTR __Dest$[esp]
	sub	esi, eax
$LL8@Umove_if_n:
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 63   : 						resptr_core		(const self & rhs)								{	p_ = rhs.p_; _inc();		}

	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [esi+eax], ecx

; 43   : 	void				_inc	()									{	if (0==p_) return;	p_->dwReference++;														}

	test	ecx, ecx
	je	SHORT $LN20@Umove_if_n
	inc	DWORD PTR [ecx]
$LN20@Umove_if_n:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1658 :     for (; _UFirst != _ULast; ++_UFirst) {

	add	eax, 4
	cmp	eax, edx
	jne	SHORT $LL8@Umove_if_n
	pop	esi
$LN7@Umove_if_n:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1663 :     }

	ret	12					; 0000000cH
?_Umove_if_noexcept@?$vector@V?$resptr_core@UShader@@Uresptrcode_shader@@@@V?$xalloc@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@@@std@@AAEXPAV?$resptr_core@UShader@@Uresptrcode_shader@@@@00@Z ENDP ; std::vector<resptr_core<Shader,resptrcode_shader>,xalloc<resptr_core<Shader,resptrcode_shader> > >::_Umove_if_noexcept
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?max_size@?$vector@V?$resptr_core@UShader@@Uresptrcode_shader@@@@V?$xalloc@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@V?$resptr_core@UShader@@Uresptrcode_shader@@@@V?$xalloc@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@@@std@@QBEIXZ PROC ; std::vector<resptr_core<Shader,resptrcode_shader>,xalloc<resptr_core<Shader,resptrcode_shader> > >::max_size, COMDAT
; _this$dead$ = ecx

; 1540 :         return (_STD min)(

	mov	eax, 1073741823				; 3fffffffH

; 1541 :             static_cast<size_type>((numeric_limits<difference_type>::max)()), _Alty_traits::max_size(_Getal()));
; 1542 :     }

	ret	0
?max_size@?$vector@V?$resptr_core@UShader@@Uresptrcode_shader@@@@V?$xalloc@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@@@std@@QBEIXZ ENDP ; std::vector<resptr_core<Shader,resptrcode_shader>,xalloc<resptr_core<Shader,resptrcode_shader> > >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?allocate@?$xalloc@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@@QBEPAV?$resptr_core@UShader@@Uresptrcode_shader@@@@IPBX@Z
_TEXT	SEGMENT
_n$ = 8							; size = 4
_p$dead$ = 12						; size = 4
?allocate@?$xalloc@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@@QBEPAV?$resptr_core@UShader@@Uresptrcode_shader@@@@IPBX@Z PROC ; xalloc<resptr_core<Shader,resptrcode_shader> >::allocate, COMDAT
; _this$dead$ = ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	mov	eax, DWORD PTR _n$[esp-4]
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	shl	eax, 2
	push	eax
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 80   : 							pointer					allocate		(size_type n, const void* p=0) const	{	return xr_alloc<T>((u32)n);	}

	ret	8
?allocate@?$xalloc@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@@QBEPAV?$resptr_core@UShader@@Uresptrcode_shader@@@@IPBX@Z ENDP ; xalloc<resptr_core<Shader,resptrcode_shader> >::allocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Xlength@?$vector@UFSlideWindowItem@@V?$xalloc@UFSlideWindowItem@@@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@UFSlideWindowItem@@V?$xalloc@UFSlideWindowItem@@@@@std@@CAXXZ PROC ; std::vector<FSlideWindowItem,xalloc<FSlideWindowItem> >::_Xlength, COMDAT

; 1761 :         _Xlength_error("vector too long");

	push	OFFSET ??_C@_0BA@FOIKENOD@vector?5too?5long@
	call	DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN3@Xlength:
	int	3
?_Xlength@?$vector@UFSlideWindowItem@@V?$xalloc@UFSlideWindowItem@@@@@std@@CAXXZ ENDP ; std::vector<FSlideWindowItem,xalloc<FSlideWindowItem> >::_Xlength
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Change_array@?$vector@UFSlideWindowItem@@V?$xalloc@UFSlideWindowItem@@@@@std@@AAEXQAUFSlideWindowItem@@II@Z
_TEXT	SEGMENT
__Newvec$ = 8						; size = 4
__Newsize$ = 12						; size = 4
__Newcapacity$ = 16					; size = 4
?_Change_array@?$vector@UFSlideWindowItem@@V?$xalloc@UFSlideWindowItem@@@@@std@@AAEXQAUFSlideWindowItem@@II@Z PROC ; std::vector<FSlideWindowItem,xalloc<FSlideWindowItem> >::_Change_array, COMDAT
; _this$ = ecx

; 1723 :         const pointer _Newvec, const size_type _Newsize, const size_type _Newcapacity) {

	push	esi
	mov	esi, ecx

; 1724 :         // orphan all iterators, discard old array, acquire new array
; 1725 :         auto& _My_data    = _Mypair._Myval2;
; 1726 :         pointer& _Myfirst = _My_data._Myfirst;
; 1727 :         pointer& _Mylast  = _My_data._Mylast;
; 1728 :         pointer& _Myend   = _My_data._Myend;
; 1729 : 
; 1730 :         _My_data._Orphan_all();
; 1731 : 
; 1732 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN7@Change_arr
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN7@Change_arr:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1737 :         _Myfirst = _Newvec;

	mov	ecx, DWORD PTR __Newvec$[esp]

; 1738 :         _Mylast  = _Newvec + _Newsize;

	mov	eax, DWORD PTR __Newsize$[esp]
	mov	DWORD PTR [esi], ecx
	lea	eax, DWORD PTR [eax+eax*2]
	lea	eax, DWORD PTR [ecx+eax*8]
	mov	DWORD PTR [esi+4], eax

; 1739 :         _Myend   = _Newvec + _Newcapacity;

	mov	eax, DWORD PTR __Newcapacity$[esp]
	lea	eax, DWORD PTR [eax+eax*2]
	lea	eax, DWORD PTR [ecx+eax*8]
	mov	DWORD PTR [esi+8], eax
	pop	esi

; 1740 :     }

	ret	12					; 0000000cH
?_Change_array@?$vector@UFSlideWindowItem@@V?$xalloc@UFSlideWindowItem@@@@@std@@AAEXQAUFSlideWindowItem@@II@Z ENDP ; std::vector<FSlideWindowItem,xalloc<FSlideWindowItem> >::_Change_array
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Calculate_growth@?$vector@UFSlideWindowItem@@V?$xalloc@UFSlideWindowItem@@@@@std@@ABEII@Z
_TEXT	SEGMENT
__Newsize$ = 8						; size = 4
?_Calculate_growth@?$vector@UFSlideWindowItem@@V?$xalloc@UFSlideWindowItem@@@@@std@@ABEII@Z PROC ; std::vector<FSlideWindowItem,xalloc<FSlideWindowItem> >::_Calculate_growth, COMDAT
; _this$ = ecx

; 1546 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx]

; 1671 :         // given _Oldcapacity and _Newsize, calculate geometric growth
; 1672 :         const size_type _Oldcapacity = capacity();
; 1673 :         const auto _Max              = max_size();
; 1674 : 
; 1675 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	ecx, 178956970				; 0aaaaaaaH

; 1546 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	sar	eax, 3

; 1670 :     _CONSTEXPR20_CONTAINER size_type _Calculate_growth(const size_type _Newsize) const {

	push	esi

; 1546 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	imul	esi, eax, -1431655765

; 1671 :         // given _Oldcapacity and _Newsize, calculate geometric growth
; 1672 :         const size_type _Oldcapacity = capacity();
; 1673 :         const auto _Max              = max_size();
; 1674 : 
; 1675 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	edx, esi
	shr	edx, 1
	sub	ecx, edx
	cmp	esi, ecx
	jbe	SHORT $LN2@Calculate_

; 1676 :             return _Max; // geometric growth would overflow

	mov	eax, 178956970				; 0aaaaaaaH
	pop	esi

; 1682 :             return _Newsize; // geometric growth would be insufficient
; 1683 :         }
; 1684 : 
; 1685 :         return _Geometric; // geometric growth is sufficient
; 1686 :     }

	ret	4
$LN2@Calculate_:

; 1677 :         }
; 1678 : 
; 1679 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	lea	eax, DWORD PTR [edx+esi]

; 1680 : 
; 1681 :         if (_Geometric < _Newsize) {

	cmp	eax, DWORD PTR __Newsize$[esp]
	pop	esi
	cmovb	eax, DWORD PTR __Newsize$[esp-4]

; 1682 :             return _Newsize; // geometric growth would be insufficient
; 1683 :         }
; 1684 : 
; 1685 :         return _Geometric; // geometric growth is sufficient
; 1686 :     }

	ret	4
?_Calculate_growth@?$vector@UFSlideWindowItem@@V?$xalloc@UFSlideWindowItem@@@@@std@@ABEII@Z ENDP ; std::vector<FSlideWindowItem,xalloc<FSlideWindowItem> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Umove_if_noexcept@?$vector@UFSlideWindowItem@@V?$xalloc@UFSlideWindowItem@@@@@std@@AAEXPAUFSlideWindowItem@@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
?_Umove_if_noexcept@?$vector@UFSlideWindowItem@@V?$xalloc@UFSlideWindowItem@@@@@std@@AAEXPAUFSlideWindowItem@@00@Z PROC ; std::vector<FSlideWindowItem,xalloc<FSlideWindowItem> >::_Umove_if_noexcept, COMDAT
; _this$dead$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1703 :     auto _UFirst      = _Get_unwrapped(_First);

	mov	eax, DWORD PTR __First$[esp-4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1659 :     _CONSTEXPR20_CONTAINER void _Umove_if_noexcept(pointer _First, pointer _Last, pointer _Dest) {

	push	esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	mov	esi, DWORD PTR __Last$[esp]
	cmp	eax, esi
	je	SHORT $LN7@Umove_if_n

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	edx, DWORD PTR __Dest$[esp]
	sub	edx, eax
$LL8@Umove_if_n:
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx+eax], ecx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+eax+4], ecx
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR [edx+eax+8], ecx
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR [edx+eax+12], ecx
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR [edx+eax+16], ecx
	mov	ecx, DWORD PTR [eax+20]
	mov	DWORD PTR [edx+eax+20], ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	add	eax, 24					; 00000018H
	cmp	eax, esi
	jne	SHORT $LL8@Umove_if_n
$LN7@Umove_if_n:
	pop	esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1663 :     }

	ret	12					; 0000000cH
?_Umove_if_noexcept@?$vector@UFSlideWindowItem@@V?$xalloc@UFSlideWindowItem@@@@@std@@AAEXPAUFSlideWindowItem@@00@Z ENDP ; std::vector<FSlideWindowItem,xalloc<FSlideWindowItem> >::_Umove_if_noexcept
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?max_size@?$vector@UFSlideWindowItem@@V?$xalloc@UFSlideWindowItem@@@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@UFSlideWindowItem@@V?$xalloc@UFSlideWindowItem@@@@@std@@QBEIXZ PROC ; std::vector<FSlideWindowItem,xalloc<FSlideWindowItem> >::max_size, COMDAT
; _this$dead$ = ecx

; 1540 :         return (_STD min)(

	mov	eax, 178956970				; 0aaaaaaaH

; 1541 :             static_cast<size_type>((numeric_limits<difference_type>::max)()), _Alty_traits::max_size(_Getal()));
; 1542 :     }

	ret	0
?max_size@?$vector@UFSlideWindowItem@@V?$xalloc@UFSlideWindowItem@@@@@std@@QBEIXZ ENDP ; std::vector<FSlideWindowItem,xalloc<FSlideWindowItem> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?allocate@?$xalloc@UFSlideWindowItem@@@@QBEPAUFSlideWindowItem@@IPBX@Z
_TEXT	SEGMENT
_n$ = 8							; size = 4
_p$dead$ = 12						; size = 4
?allocate@?$xalloc@UFSlideWindowItem@@@@QBEPAUFSlideWindowItem@@IPBX@Z PROC ; xalloc<FSlideWindowItem>::allocate, COMDAT
; _this$dead$ = ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	mov	eax, DWORD PTR _n$[esp-4]
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	lea	eax, DWORD PTR [eax+eax*2]
	shl	eax, 3
	push	eax
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 80   : 							pointer					allocate		(size_type n, const void* p=0) const	{	return xr_alloc<T>((u32)n);	}

	ret	8
?allocate@?$xalloc@UFSlideWindowItem@@@@QBEPAUFSlideWindowItem@@IPBX@Z ENDP ; xalloc<FSlideWindowItem>::allocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Xlength@?$vector@PAVIRender_Portal@@V?$xalloc@PAVIRender_Portal@@@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@PAVIRender_Portal@@V?$xalloc@PAVIRender_Portal@@@@@std@@CAXXZ PROC ; std::vector<IRender_Portal *,xalloc<IRender_Portal *> >::_Xlength, COMDAT

; 1761 :         _Xlength_error("vector too long");

	push	OFFSET ??_C@_0BA@FOIKENOD@vector?5too?5long@
	call	DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN3@Xlength:
	int	3
?_Xlength@?$vector@PAVIRender_Portal@@V?$xalloc@PAVIRender_Portal@@@@@std@@CAXXZ ENDP ; std::vector<IRender_Portal *,xalloc<IRender_Portal *> >::_Xlength
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Change_array@?$vector@PAVIRender_Portal@@V?$xalloc@PAVIRender_Portal@@@@@std@@AAEXQAPAVIRender_Portal@@II@Z
_TEXT	SEGMENT
__Newvec$ = 8						; size = 4
__Newsize$ = 12						; size = 4
__Newcapacity$ = 16					; size = 4
?_Change_array@?$vector@PAVIRender_Portal@@V?$xalloc@PAVIRender_Portal@@@@@std@@AAEXQAPAVIRender_Portal@@II@Z PROC ; std::vector<IRender_Portal *,xalloc<IRender_Portal *> >::_Change_array, COMDAT
; _this$ = ecx

; 1723 :         const pointer _Newvec, const size_type _Newsize, const size_type _Newcapacity) {

	push	esi
	mov	esi, ecx

; 1724 :         // orphan all iterators, discard old array, acquire new array
; 1725 :         auto& _My_data    = _Mypair._Myval2;
; 1726 :         pointer& _Myfirst = _My_data._Myfirst;
; 1727 :         pointer& _Mylast  = _My_data._Mylast;
; 1728 :         pointer& _Myend   = _My_data._Myend;
; 1729 : 
; 1730 :         _My_data._Orphan_all();
; 1731 : 
; 1732 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN7@Change_arr
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN7@Change_arr:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1737 :         _Myfirst = _Newvec;

	mov	ecx, DWORD PTR __Newvec$[esp]

; 1738 :         _Mylast  = _Newvec + _Newsize;

	mov	eax, DWORD PTR __Newsize$[esp]
	mov	DWORD PTR [esi], ecx
	lea	eax, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR [esi+4], eax

; 1739 :         _Myend   = _Newvec + _Newcapacity;

	mov	eax, DWORD PTR __Newcapacity$[esp]
	lea	eax, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR [esi+8], eax
	pop	esi

; 1740 :     }

	ret	12					; 0000000cH
?_Change_array@?$vector@PAVIRender_Portal@@V?$xalloc@PAVIRender_Portal@@@@@std@@AAEXQAPAVIRender_Portal@@II@Z ENDP ; std::vector<IRender_Portal *,xalloc<IRender_Portal *> >::_Change_array
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Calculate_growth@?$vector@PAVIRender_Portal@@V?$xalloc@PAVIRender_Portal@@@@@std@@ABEII@Z
_TEXT	SEGMENT
__Newsize$ = 8						; size = 4
?_Calculate_growth@?$vector@PAVIRender_Portal@@V?$xalloc@PAVIRender_Portal@@@@@std@@ABEII@Z PROC ; std::vector<IRender_Portal *,xalloc<IRender_Portal *> >::_Calculate_growth, COMDAT
; _this$ = ecx

; 1546 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	edx, DWORD PTR [ecx+8]
	sub	edx, DWORD PTR [ecx]

; 1671 :         // given _Oldcapacity and _Newsize, calculate geometric growth
; 1672 :         const size_type _Oldcapacity = capacity();
; 1673 :         const auto _Max              = max_size();
; 1674 : 
; 1675 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	ecx, 1073741823				; 3fffffffH

; 1546 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	sar	edx, 2

; 1670 :     _CONSTEXPR20_CONTAINER size_type _Calculate_growth(const size_type _Newsize) const {

	push	esi

; 1671 :         // given _Oldcapacity and _Newsize, calculate geometric growth
; 1672 :         const size_type _Oldcapacity = capacity();
; 1673 :         const auto _Max              = max_size();
; 1674 : 
; 1675 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	esi, edx
	shr	esi, 1
	sub	ecx, esi
	cmp	edx, ecx
	jbe	SHORT $LN2@Calculate_

; 1676 :             return _Max; // geometric growth would overflow

	mov	eax, 1073741823				; 3fffffffH
	pop	esi

; 1682 :             return _Newsize; // geometric growth would be insufficient
; 1683 :         }
; 1684 : 
; 1685 :         return _Geometric; // geometric growth is sufficient
; 1686 :     }

	ret	4
$LN2@Calculate_:

; 1677 :         }
; 1678 : 
; 1679 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	lea	eax, DWORD PTR [esi+edx]

; 1680 : 
; 1681 :         if (_Geometric < _Newsize) {

	cmp	eax, DWORD PTR __Newsize$[esp]
	pop	esi
	cmovb	eax, DWORD PTR __Newsize$[esp-4]

; 1682 :             return _Newsize; // geometric growth would be insufficient
; 1683 :         }
; 1684 : 
; 1685 :         return _Geometric; // geometric growth is sufficient
; 1686 :     }

	ret	4
?_Calculate_growth@?$vector@PAVIRender_Portal@@V?$xalloc@PAVIRender_Portal@@@@@std@@ABEII@Z ENDP ; std::vector<IRender_Portal *,xalloc<IRender_Portal *> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Umove_if_noexcept@?$vector@PAVIRender_Portal@@V?$xalloc@PAVIRender_Portal@@@@@std@@AAEXPAPAVIRender_Portal@@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
?_Umove_if_noexcept@?$vector@PAVIRender_Portal@@V?$xalloc@PAVIRender_Portal@@@@@std@@AAEXPAPAVIRender_Portal@@00@Z PROC ; std::vector<IRender_Portal *,xalloc<IRender_Portal *> >::_Umove_if_noexcept, COMDAT
; _this$dead$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1703 :     auto _UFirst      = _Get_unwrapped(_First);

	mov	eax, DWORD PTR __First$[esp-4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1659 :     _CONSTEXPR20_CONTAINER void _Umove_if_noexcept(pointer _First, pointer _Last, pointer _Dest) {

	push	esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	mov	esi, DWORD PTR __Last$[esp]
	cmp	eax, esi
	je	SHORT $LN7@Umove_if_n

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	edx, DWORD PTR __Dest$[esp]
	sub	edx, eax
$LL8@Umove_if_n:

; 1620 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx+eax], ecx

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	add	eax, 4
	cmp	eax, esi
	jne	SHORT $LL8@Umove_if_n
$LN7@Umove_if_n:
	pop	esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1663 :     }

	ret	12					; 0000000cH
?_Umove_if_noexcept@?$vector@PAVIRender_Portal@@V?$xalloc@PAVIRender_Portal@@@@@std@@AAEXPAPAVIRender_Portal@@00@Z ENDP ; std::vector<IRender_Portal *,xalloc<IRender_Portal *> >::_Umove_if_noexcept
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?max_size@?$vector@PAVIRender_Portal@@V?$xalloc@PAVIRender_Portal@@@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@PAVIRender_Portal@@V?$xalloc@PAVIRender_Portal@@@@@std@@QBEIXZ PROC ; std::vector<IRender_Portal *,xalloc<IRender_Portal *> >::max_size, COMDAT
; _this$dead$ = ecx

; 1540 :         return (_STD min)(

	mov	eax, 1073741823				; 3fffffffH

; 1541 :             static_cast<size_type>((numeric_limits<difference_type>::max)()), _Alty_traits::max_size(_Getal()));
; 1542 :     }

	ret	0
?max_size@?$vector@PAVIRender_Portal@@V?$xalloc@PAVIRender_Portal@@@@@std@@QBEIXZ ENDP ; std::vector<IRender_Portal *,xalloc<IRender_Portal *> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?allocate@?$xalloc@PAVIRender_Portal@@@@QBEPAPAVIRender_Portal@@IPBX@Z
_TEXT	SEGMENT
_n$ = 8							; size = 4
_p$dead$ = 12						; size = 4
?allocate@?$xalloc@PAVIRender_Portal@@@@QBEPAPAVIRender_Portal@@IPBX@Z PROC ; xalloc<IRender_Portal *>::allocate, COMDAT
; _this$dead$ = ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	mov	eax, DWORD PTR _n$[esp-4]
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	shl	eax, 2
	push	eax
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 80   : 							pointer					allocate		(size_type n, const void* p=0) const	{	return xr_alloc<T>((u32)n);	}

	ret	8
?allocate@?$xalloc@PAVIRender_Portal@@@@QBEPAPAVIRender_Portal@@IPBX@Z ENDP ; xalloc<IRender_Portal *>::allocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Getal@?$vector@PAUIDirect3DIndexBuffer9@@V?$xalloc@PAUIDirect3DIndexBuffer9@@@@@std@@ABEABV?$xalloc@PAUIDirect3DIndexBuffer9@@@@XZ
_TEXT	SEGMENT
?_Getal@?$vector@PAUIDirect3DIndexBuffer9@@V?$xalloc@PAUIDirect3DIndexBuffer9@@@@@std@@ABEABV?$xalloc@PAUIDirect3DIndexBuffer9@@@@XZ PROC ; std::vector<IDirect3DIndexBuffer9 *,xalloc<IDirect3DIndexBuffer9 *> >::_Getal, COMDAT
; _this$ = ecx

; 1809 :         return _Mypair._Get_first();

	mov	eax, ecx

; 1810 :     }

	ret	0
?_Getal@?$vector@PAUIDirect3DIndexBuffer9@@V?$xalloc@PAUIDirect3DIndexBuffer9@@@@@std@@ABEABV?$xalloc@PAUIDirect3DIndexBuffer9@@@@XZ ENDP ; std::vector<IDirect3DIndexBuffer9 *,xalloc<IDirect3DIndexBuffer9 *> >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Umove_if_noexcept1@?$vector@PAUIDirect3DIndexBuffer9@@V?$xalloc@PAUIDirect3DIndexBuffer9@@@@@std@@AAEXPAPAUIDirect3DIndexBuffer9@@00U?$integral_constant@_N$00@2@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
?_Umove_if_noexcept1@?$vector@PAUIDirect3DIndexBuffer9@@V?$xalloc@PAUIDirect3DIndexBuffer9@@@@@std@@AAEXPAPAUIDirect3DIndexBuffer9@@00U?$integral_constant@_N$00@2@@Z PROC ; std::vector<IDirect3DIndexBuffer9 *,xalloc<IDirect3DIndexBuffer9 *> >::_Umove_if_noexcept1, COMDAT
; _this$dead$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1703 :     auto _UFirst      = _Get_unwrapped(_First);

	mov	eax, DWORD PTR __First$[esp-4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1649 :     _CONSTEXPR20_CONTAINER void _Umove_if_noexcept1(pointer _First, pointer _Last, pointer _Dest, true_type) {

	push	esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	mov	esi, DWORD PTR __Last$[esp]
	cmp	eax, esi
	je	SHORT $LN5@Umove_if_n

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	edx, DWORD PTR __Dest$[esp]
	sub	edx, eax
$LL6@Umove_if_n:

; 1620 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx+eax], ecx

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	add	eax, 4
	cmp	eax, esi
	jne	SHORT $LL6@Umove_if_n
$LN5@Umove_if_n:
	pop	esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1652 :     }

	ret	16					; 00000010H
?_Umove_if_noexcept1@?$vector@PAUIDirect3DIndexBuffer9@@V?$xalloc@PAUIDirect3DIndexBuffer9@@@@@std@@AAEXPAPAUIDirect3DIndexBuffer9@@00U?$integral_constant@_N$00@2@@Z ENDP ; std::vector<IDirect3DIndexBuffer9 *,xalloc<IDirect3DIndexBuffer9 *> >::_Umove_if_noexcept1
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?capacity@?$vector@PAUIDirect3DIndexBuffer9@@V?$xalloc@PAUIDirect3DIndexBuffer9@@@@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@PAUIDirect3DIndexBuffer9@@V?$xalloc@PAUIDirect3DIndexBuffer9@@@@@std@@QBEIXZ PROC ; std::vector<IDirect3DIndexBuffer9 *,xalloc<IDirect3DIndexBuffer9 *> >::capacity, COMDAT
; _this$ = ecx

; 1545 :         auto& _My_data = _Mypair._Myval2;
; 1546 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx]
	sar	eax, 2

; 1547 :     }

	ret	0
?capacity@?$vector@PAUIDirect3DIndexBuffer9@@V?$xalloc@PAUIDirect3DIndexBuffer9@@@@@std@@QBEIXZ ENDP ; std::vector<IDirect3DIndexBuffer9 *,xalloc<IDirect3DIndexBuffer9 *> >::capacity
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?max_size@?$_Normal_allocator_traits@V?$xalloc@PAUIDirect3DIndexBuffer9@@@@@std@@SAIABV?$xalloc@PAUIDirect3DIndexBuffer9@@@@@Z
_TEXT	SEGMENT
?max_size@?$_Normal_allocator_traits@V?$xalloc@PAUIDirect3DIndexBuffer9@@@@@std@@SAIABV?$xalloc@PAUIDirect3DIndexBuffer9@@@@@Z PROC ; std::_Normal_allocator_traits<xalloc<IDirect3DIndexBuffer9 *> >::max_size, COMDAT
; __Al$dead$ = ecx

; 591  :         if constexpr (_Has_max_size<_Alloc>::value) {
; 592  :             return _Al.max_size();

	mov	eax, 1073741823				; 3fffffffH

; 593  :         } else {
; 594  :             return (numeric_limits<size_type>::max)() / sizeof(value_type);
; 595  :         }
; 596  :     }

	ret	0
?max_size@?$_Normal_allocator_traits@V?$xalloc@PAUIDirect3DIndexBuffer9@@@@@std@@SAIABV?$xalloc@PAUIDirect3DIndexBuffer9@@@@@Z ENDP ; std::_Normal_allocator_traits<xalloc<IDirect3DIndexBuffer9 *> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Getal@?$vector@PAUIDirect3DVertexBuffer9@@V?$xalloc@PAUIDirect3DVertexBuffer9@@@@@std@@ABEABV?$xalloc@PAUIDirect3DVertexBuffer9@@@@XZ
_TEXT	SEGMENT
?_Getal@?$vector@PAUIDirect3DVertexBuffer9@@V?$xalloc@PAUIDirect3DVertexBuffer9@@@@@std@@ABEABV?$xalloc@PAUIDirect3DVertexBuffer9@@@@XZ PROC ; std::vector<IDirect3DVertexBuffer9 *,xalloc<IDirect3DVertexBuffer9 *> >::_Getal, COMDAT
; _this$ = ecx

; 1809 :         return _Mypair._Get_first();

	mov	eax, ecx

; 1810 :     }

	ret	0
?_Getal@?$vector@PAUIDirect3DVertexBuffer9@@V?$xalloc@PAUIDirect3DVertexBuffer9@@@@@std@@ABEABV?$xalloc@PAUIDirect3DVertexBuffer9@@@@XZ ENDP ; std::vector<IDirect3DVertexBuffer9 *,xalloc<IDirect3DVertexBuffer9 *> >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Umove_if_noexcept1@?$vector@PAUIDirect3DVertexBuffer9@@V?$xalloc@PAUIDirect3DVertexBuffer9@@@@@std@@AAEXPAPAUIDirect3DVertexBuffer9@@00U?$integral_constant@_N$00@2@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
?_Umove_if_noexcept1@?$vector@PAUIDirect3DVertexBuffer9@@V?$xalloc@PAUIDirect3DVertexBuffer9@@@@@std@@AAEXPAPAUIDirect3DVertexBuffer9@@00U?$integral_constant@_N$00@2@@Z PROC ; std::vector<IDirect3DVertexBuffer9 *,xalloc<IDirect3DVertexBuffer9 *> >::_Umove_if_noexcept1, COMDAT
; _this$dead$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1703 :     auto _UFirst      = _Get_unwrapped(_First);

	mov	eax, DWORD PTR __First$[esp-4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1649 :     _CONSTEXPR20_CONTAINER void _Umove_if_noexcept1(pointer _First, pointer _Last, pointer _Dest, true_type) {

	push	esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	mov	esi, DWORD PTR __Last$[esp]
	cmp	eax, esi
	je	SHORT $LN5@Umove_if_n

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	edx, DWORD PTR __Dest$[esp]
	sub	edx, eax
$LL6@Umove_if_n:

; 1620 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx+eax], ecx

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	add	eax, 4
	cmp	eax, esi
	jne	SHORT $LL6@Umove_if_n
$LN5@Umove_if_n:
	pop	esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1652 :     }

	ret	16					; 00000010H
?_Umove_if_noexcept1@?$vector@PAUIDirect3DVertexBuffer9@@V?$xalloc@PAUIDirect3DVertexBuffer9@@@@@std@@AAEXPAPAUIDirect3DVertexBuffer9@@00U?$integral_constant@_N$00@2@@Z ENDP ; std::vector<IDirect3DVertexBuffer9 *,xalloc<IDirect3DVertexBuffer9 *> >::_Umove_if_noexcept1
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?capacity@?$vector@PAUIDirect3DVertexBuffer9@@V?$xalloc@PAUIDirect3DVertexBuffer9@@@@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@PAUIDirect3DVertexBuffer9@@V?$xalloc@PAUIDirect3DVertexBuffer9@@@@@std@@QBEIXZ PROC ; std::vector<IDirect3DVertexBuffer9 *,xalloc<IDirect3DVertexBuffer9 *> >::capacity, COMDAT
; _this$ = ecx

; 1545 :         auto& _My_data = _Mypair._Myval2;
; 1546 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx]
	sar	eax, 2

; 1547 :     }

	ret	0
?capacity@?$vector@PAUIDirect3DVertexBuffer9@@V?$xalloc@PAUIDirect3DVertexBuffer9@@@@@std@@QBEIXZ ENDP ; std::vector<IDirect3DVertexBuffer9 *,xalloc<IDirect3DVertexBuffer9 *> >::capacity
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?max_size@?$_Normal_allocator_traits@V?$xalloc@PAUIDirect3DVertexBuffer9@@@@@std@@SAIABV?$xalloc@PAUIDirect3DVertexBuffer9@@@@@Z
_TEXT	SEGMENT
?max_size@?$_Normal_allocator_traits@V?$xalloc@PAUIDirect3DVertexBuffer9@@@@@std@@SAIABV?$xalloc@PAUIDirect3DVertexBuffer9@@@@@Z PROC ; std::_Normal_allocator_traits<xalloc<IDirect3DVertexBuffer9 *> >::max_size, COMDAT
; __Al$dead$ = ecx

; 591  :         if constexpr (_Has_max_size<_Alloc>::value) {
; 592  :             return _Al.max_size();

	mov	eax, 1073741823				; 3fffffffH

; 593  :         } else {
; 594  :             return (numeric_limits<size_type>::max)() / sizeof(value_type);
; 595  :         }
; 596  :     }

	ret	0
?max_size@?$_Normal_allocator_traits@V?$xalloc@PAUIDirect3DVertexBuffer9@@@@@std@@SAIABV?$xalloc@PAUIDirect3DVertexBuffer9@@@@@Z ENDP ; std::_Normal_allocator_traits<xalloc<IDirect3DVertexBuffer9 *> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Getal@?$vector@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@V?$xalloc@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@@@std@@ABEABV?$xalloc@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@@XZ
_TEXT	SEGMENT
?_Getal@?$vector@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@V?$xalloc@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@@@std@@ABEABV?$xalloc@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@@XZ PROC ; std::vector<svector<_D3DVERTEXELEMENT9,65>,xalloc<svector<_D3DVERTEXELEMENT9,65> > >::_Getal, COMDAT
; _this$ = ecx

; 1809 :         return _Mypair._Get_first();

	mov	eax, ecx

; 1810 :     }

	ret	0
?_Getal@?$vector@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@V?$xalloc@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@@@std@@ABEABV?$xalloc@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@@XZ ENDP ; std::vector<svector<_D3DVERTEXELEMENT9,65>,xalloc<svector<_D3DVERTEXELEMENT9,65> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Umove_if_noexcept1@?$vector@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@V?$xalloc@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@@@std@@AAEXPAV?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@00U?$integral_constant@_N$00@2@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
?_Umove_if_noexcept1@?$vector@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@V?$xalloc@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@@@std@@AAEXPAV?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@00U?$integral_constant@_N$00@2@@Z PROC ; std::vector<svector<_D3DVERTEXELEMENT9,65>,xalloc<svector<_D3DVERTEXELEMENT9,65> > >::_Umove_if_noexcept1, COMDAT
; _this$dead$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1703 :     auto _UFirst      = _Get_unwrapped(_First);

	mov	eax, DWORD PTR __First$[esp-4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1649 :     _CONSTEXPR20_CONTAINER void _Umove_if_noexcept1(pointer _First, pointer _Last, pointer _Dest, true_type) {

	push	ebx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	mov	ebx, DWORD PTR __Last$[esp]
	cmp	eax, ebx
	je	SHORT $LN5@Umove_if_n

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	edx, DWORD PTR __Dest$[esp]
	push	esi
	sub	edx, eax
	push	edi
$LL6@Umove_if_n:
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	lea	edi, DWORD PTR [edx+eax]
	mov	esi, eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	add	eax, 524				; 0000020cH
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	ecx, 131				; 00000083H
	rep movsd
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	eax, ebx
	jne	SHORT $LL6@Umove_if_n
	pop	edi
	pop	esi
$LN5@Umove_if_n:
	pop	ebx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1652 :     }

	ret	16					; 00000010H
?_Umove_if_noexcept1@?$vector@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@V?$xalloc@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@@@std@@AAEXPAV?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@00U?$integral_constant@_N$00@2@@Z ENDP ; std::vector<svector<_D3DVERTEXELEMENT9,65>,xalloc<svector<_D3DVERTEXELEMENT9,65> > >::_Umove_if_noexcept1
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?capacity@?$vector@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@V?$xalloc@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@V?$xalloc@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@@@std@@QBEIXZ PROC ; std::vector<svector<_D3DVERTEXELEMENT9,65>,xalloc<svector<_D3DVERTEXELEMENT9,65> > >::capacity, COMDAT
; _this$ = ecx

; 1545 :         auto& _My_data = _Mypair._Myval2;
; 1546 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	edx, DWORD PTR [ecx+8]
	mov	eax, 1049152317				; 3e88cb3dH
	sub	edx, DWORD PTR [ecx]
	imul	edx
	sar	edx, 7
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx

; 1547 :     }

	ret	0
?capacity@?$vector@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@V?$xalloc@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@@@std@@QBEIXZ ENDP ; std::vector<svector<_D3DVERTEXELEMENT9,65>,xalloc<svector<_D3DVERTEXELEMENT9,65> > >::capacity
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?max_size@?$_Normal_allocator_traits@V?$xalloc@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@@@std@@SAIABV?$xalloc@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@@@Z
_TEXT	SEGMENT
?max_size@?$_Normal_allocator_traits@V?$xalloc@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@@@std@@SAIABV?$xalloc@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@@@Z PROC ; std::_Normal_allocator_traits<xalloc<svector<_D3DVERTEXELEMENT9,65> > >::max_size, COMDAT
; __Al$dead$ = ecx

; 591  :         if constexpr (_Has_max_size<_Alloc>::value) {
; 592  :             return _Al.max_size();

	mov	eax, 8196502				; 007d1196H

; 593  :         } else {
; 594  :             return (numeric_limits<size_type>::max)() / sizeof(value_type);
; 595  :         }
; 596  :     }

	ret	0
?max_size@?$_Normal_allocator_traits@V?$xalloc@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@@@std@@SAIABV?$xalloc@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@@@Z ENDP ; std::_Normal_allocator_traits<xalloc<svector<_D3DVERTEXELEMENT9,65> > >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Getal@?$vector@V?$resptr_core@UShader@@Uresptrcode_shader@@@@V?$xalloc@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@@@std@@ABEABV?$xalloc@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@@XZ
_TEXT	SEGMENT
?_Getal@?$vector@V?$resptr_core@UShader@@Uresptrcode_shader@@@@V?$xalloc@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@@@std@@ABEABV?$xalloc@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@@XZ PROC ; std::vector<resptr_core<Shader,resptrcode_shader>,xalloc<resptr_core<Shader,resptrcode_shader> > >::_Getal, COMDAT
; _this$ = ecx

; 1809 :         return _Mypair._Get_first();

	mov	eax, ecx

; 1810 :     }

	ret	0
?_Getal@?$vector@V?$resptr_core@UShader@@Uresptrcode_shader@@@@V?$xalloc@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@@@std@@ABEABV?$xalloc@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@@XZ ENDP ; std::vector<resptr_core<Shader,resptrcode_shader>,xalloc<resptr_core<Shader,resptrcode_shader> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Umove_if_noexcept1@?$vector@V?$resptr_core@UShader@@Uresptrcode_shader@@@@V?$xalloc@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@@@std@@AAEXPAV?$resptr_core@UShader@@Uresptrcode_shader@@@@00U?$integral_constant@_N$0A@@2@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
?_Umove_if_noexcept1@?$vector@V?$resptr_core@UShader@@Uresptrcode_shader@@@@V?$xalloc@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@@@std@@AAEXPAV?$resptr_core@UShader@@Uresptrcode_shader@@@@00U?$integral_constant@_N$0A@@2@@Z PROC ; std::vector<resptr_core<Shader,resptrcode_shader>,xalloc<resptr_core<Shader,resptrcode_shader> > >::_Umove_if_noexcept1, COMDAT
; _this$dead$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1642 :     auto _UFirst      = _Get_unwrapped(_First);

	mov	eax, DWORD PTR __First$[esp-4]

; 1658 :     for (; _UFirst != _ULast; ++_UFirst) {

	mov	edx, DWORD PTR __Last$[esp-4]
	cmp	eax, edx
	je	SHORT $LN5@Umove_if_n

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	push	esi
	mov	esi, DWORD PTR __Dest$[esp]
	sub	esi, eax
$LL6@Umove_if_n:
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 63   : 						resptr_core		(const self & rhs)								{	p_ = rhs.p_; _inc();		}

	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [esi+eax], ecx

; 43   : 	void				_inc	()									{	if (0==p_) return;	p_->dwReference++;														}

	test	ecx, ecx
	je	SHORT $LN18@Umove_if_n
	inc	DWORD PTR [ecx]
$LN18@Umove_if_n:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1658 :     for (; _UFirst != _ULast; ++_UFirst) {

	add	eax, 4
	cmp	eax, edx
	jne	SHORT $LL6@Umove_if_n
	pop	esi
$LN5@Umove_if_n:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1657 :     }

	ret	16					; 00000010H
?_Umove_if_noexcept1@?$vector@V?$resptr_core@UShader@@Uresptrcode_shader@@@@V?$xalloc@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@@@std@@AAEXPAV?$resptr_core@UShader@@Uresptrcode_shader@@@@00U?$integral_constant@_N$0A@@2@@Z ENDP ; std::vector<resptr_core<Shader,resptrcode_shader>,xalloc<resptr_core<Shader,resptrcode_shader> > >::_Umove_if_noexcept1
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?capacity@?$vector@V?$resptr_core@UShader@@Uresptrcode_shader@@@@V?$xalloc@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@V?$resptr_core@UShader@@Uresptrcode_shader@@@@V?$xalloc@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@@@std@@QBEIXZ PROC ; std::vector<resptr_core<Shader,resptrcode_shader>,xalloc<resptr_core<Shader,resptrcode_shader> > >::capacity, COMDAT
; _this$ = ecx

; 1545 :         auto& _My_data = _Mypair._Myval2;
; 1546 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx]
	sar	eax, 2

; 1547 :     }

	ret	0
?capacity@?$vector@V?$resptr_core@UShader@@Uresptrcode_shader@@@@V?$xalloc@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@@@std@@QBEIXZ ENDP ; std::vector<resptr_core<Shader,resptrcode_shader>,xalloc<resptr_core<Shader,resptrcode_shader> > >::capacity
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?max_size@?$_Normal_allocator_traits@V?$xalloc@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@@@std@@SAIABV?$xalloc@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@@@Z
_TEXT	SEGMENT
?max_size@?$_Normal_allocator_traits@V?$xalloc@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@@@std@@SAIABV?$xalloc@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@@@Z PROC ; std::_Normal_allocator_traits<xalloc<resptr_core<Shader,resptrcode_shader> > >::max_size, COMDAT
; __Al$dead$ = ecx

; 591  :         if constexpr (_Has_max_size<_Alloc>::value) {
; 592  :             return _Al.max_size();

	mov	eax, 1073741823				; 3fffffffH

; 593  :         } else {
; 594  :             return (numeric_limits<size_type>::max)() / sizeof(value_type);
; 595  :         }
; 596  :     }

	ret	0
?max_size@?$_Normal_allocator_traits@V?$xalloc@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@@@std@@SAIABV?$xalloc@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@@@Z ENDP ; std::_Normal_allocator_traits<xalloc<resptr_core<Shader,resptrcode_shader> > >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Getal@?$vector@UFSlideWindowItem@@V?$xalloc@UFSlideWindowItem@@@@@std@@ABEABV?$xalloc@UFSlideWindowItem@@@@XZ
_TEXT	SEGMENT
?_Getal@?$vector@UFSlideWindowItem@@V?$xalloc@UFSlideWindowItem@@@@@std@@ABEABV?$xalloc@UFSlideWindowItem@@@@XZ PROC ; std::vector<FSlideWindowItem,xalloc<FSlideWindowItem> >::_Getal, COMDAT
; _this$ = ecx

; 1809 :         return _Mypair._Get_first();

	mov	eax, ecx

; 1810 :     }

	ret	0
?_Getal@?$vector@UFSlideWindowItem@@V?$xalloc@UFSlideWindowItem@@@@@std@@ABEABV?$xalloc@UFSlideWindowItem@@@@XZ ENDP ; std::vector<FSlideWindowItem,xalloc<FSlideWindowItem> >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Umove_if_noexcept1@?$vector@UFSlideWindowItem@@V?$xalloc@UFSlideWindowItem@@@@@std@@AAEXPAUFSlideWindowItem@@00U?$integral_constant@_N$00@2@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
?_Umove_if_noexcept1@?$vector@UFSlideWindowItem@@V?$xalloc@UFSlideWindowItem@@@@@std@@AAEXPAUFSlideWindowItem@@00U?$integral_constant@_N$00@2@@Z PROC ; std::vector<FSlideWindowItem,xalloc<FSlideWindowItem> >::_Umove_if_noexcept1, COMDAT
; _this$dead$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1703 :     auto _UFirst      = _Get_unwrapped(_First);

	mov	eax, DWORD PTR __First$[esp-4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1649 :     _CONSTEXPR20_CONTAINER void _Umove_if_noexcept1(pointer _First, pointer _Last, pointer _Dest, true_type) {

	push	esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	mov	esi, DWORD PTR __Last$[esp]
	cmp	eax, esi
	je	SHORT $LN5@Umove_if_n

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	edx, DWORD PTR __Dest$[esp]
	sub	edx, eax
$LL6@Umove_if_n:
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx+eax], ecx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+eax+4], ecx
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR [edx+eax+8], ecx
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR [edx+eax+12], ecx
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR [edx+eax+16], ecx
	mov	ecx, DWORD PTR [eax+20]
	mov	DWORD PTR [edx+eax+20], ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	add	eax, 24					; 00000018H
	cmp	eax, esi
	jne	SHORT $LL6@Umove_if_n
$LN5@Umove_if_n:
	pop	esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1652 :     }

	ret	16					; 00000010H
?_Umove_if_noexcept1@?$vector@UFSlideWindowItem@@V?$xalloc@UFSlideWindowItem@@@@@std@@AAEXPAUFSlideWindowItem@@00U?$integral_constant@_N$00@2@@Z ENDP ; std::vector<FSlideWindowItem,xalloc<FSlideWindowItem> >::_Umove_if_noexcept1
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?capacity@?$vector@UFSlideWindowItem@@V?$xalloc@UFSlideWindowItem@@@@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@UFSlideWindowItem@@V?$xalloc@UFSlideWindowItem@@@@@std@@QBEIXZ PROC ; std::vector<FSlideWindowItem,xalloc<FSlideWindowItem> >::capacity, COMDAT
; _this$ = ecx

; 1545 :         auto& _My_data = _Mypair._Myval2;
; 1546 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx]
	sar	eax, 3
	imul	eax, eax, -1431655765

; 1547 :     }

	ret	0
?capacity@?$vector@UFSlideWindowItem@@V?$xalloc@UFSlideWindowItem@@@@@std@@QBEIXZ ENDP ; std::vector<FSlideWindowItem,xalloc<FSlideWindowItem> >::capacity
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?max_size@?$_Normal_allocator_traits@V?$xalloc@UFSlideWindowItem@@@@@std@@SAIABV?$xalloc@UFSlideWindowItem@@@@@Z
_TEXT	SEGMENT
?max_size@?$_Normal_allocator_traits@V?$xalloc@UFSlideWindowItem@@@@@std@@SAIABV?$xalloc@UFSlideWindowItem@@@@@Z PROC ; std::_Normal_allocator_traits<xalloc<FSlideWindowItem> >::max_size, COMDAT
; __Al$dead$ = ecx

; 591  :         if constexpr (_Has_max_size<_Alloc>::value) {
; 592  :             return _Al.max_size();

	mov	eax, 178956970				; 0aaaaaaaH

; 593  :         } else {
; 594  :             return (numeric_limits<size_type>::max)() / sizeof(value_type);
; 595  :         }
; 596  :     }

	ret	0
?max_size@?$_Normal_allocator_traits@V?$xalloc@UFSlideWindowItem@@@@@std@@SAIABV?$xalloc@UFSlideWindowItem@@@@@Z ENDP ; std::_Normal_allocator_traits<xalloc<FSlideWindowItem> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Getal@?$vector@PAVIRender_Portal@@V?$xalloc@PAVIRender_Portal@@@@@std@@ABEABV?$xalloc@PAVIRender_Portal@@@@XZ
_TEXT	SEGMENT
?_Getal@?$vector@PAVIRender_Portal@@V?$xalloc@PAVIRender_Portal@@@@@std@@ABEABV?$xalloc@PAVIRender_Portal@@@@XZ PROC ; std::vector<IRender_Portal *,xalloc<IRender_Portal *> >::_Getal, COMDAT
; _this$ = ecx

; 1809 :         return _Mypair._Get_first();

	mov	eax, ecx

; 1810 :     }

	ret	0
?_Getal@?$vector@PAVIRender_Portal@@V?$xalloc@PAVIRender_Portal@@@@@std@@ABEABV?$xalloc@PAVIRender_Portal@@@@XZ ENDP ; std::vector<IRender_Portal *,xalloc<IRender_Portal *> >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Umove_if_noexcept1@?$vector@PAVIRender_Portal@@V?$xalloc@PAVIRender_Portal@@@@@std@@AAEXPAPAVIRender_Portal@@00U?$integral_constant@_N$00@2@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
?_Umove_if_noexcept1@?$vector@PAVIRender_Portal@@V?$xalloc@PAVIRender_Portal@@@@@std@@AAEXPAPAVIRender_Portal@@00U?$integral_constant@_N$00@2@@Z PROC ; std::vector<IRender_Portal *,xalloc<IRender_Portal *> >::_Umove_if_noexcept1, COMDAT
; _this$dead$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1703 :     auto _UFirst      = _Get_unwrapped(_First);

	mov	eax, DWORD PTR __First$[esp-4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1649 :     _CONSTEXPR20_CONTAINER void _Umove_if_noexcept1(pointer _First, pointer _Last, pointer _Dest, true_type) {

	push	esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	mov	esi, DWORD PTR __Last$[esp]
	cmp	eax, esi
	je	SHORT $LN5@Umove_if_n

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	edx, DWORD PTR __Dest$[esp]
	sub	edx, eax
$LL6@Umove_if_n:

; 1620 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx+eax], ecx

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	add	eax, 4
	cmp	eax, esi
	jne	SHORT $LL6@Umove_if_n
$LN5@Umove_if_n:
	pop	esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1652 :     }

	ret	16					; 00000010H
?_Umove_if_noexcept1@?$vector@PAVIRender_Portal@@V?$xalloc@PAVIRender_Portal@@@@@std@@AAEXPAPAVIRender_Portal@@00U?$integral_constant@_N$00@2@@Z ENDP ; std::vector<IRender_Portal *,xalloc<IRender_Portal *> >::_Umove_if_noexcept1
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?capacity@?$vector@PAVIRender_Portal@@V?$xalloc@PAVIRender_Portal@@@@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@PAVIRender_Portal@@V?$xalloc@PAVIRender_Portal@@@@@std@@QBEIXZ PROC ; std::vector<IRender_Portal *,xalloc<IRender_Portal *> >::capacity, COMDAT
; _this$ = ecx

; 1545 :         auto& _My_data = _Mypair._Myval2;
; 1546 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx]
	sar	eax, 2

; 1547 :     }

	ret	0
?capacity@?$vector@PAVIRender_Portal@@V?$xalloc@PAVIRender_Portal@@@@@std@@QBEIXZ ENDP ; std::vector<IRender_Portal *,xalloc<IRender_Portal *> >::capacity
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?max_size@?$_Normal_allocator_traits@V?$xalloc@PAVIRender_Portal@@@@@std@@SAIABV?$xalloc@PAVIRender_Portal@@@@@Z
_TEXT	SEGMENT
?max_size@?$_Normal_allocator_traits@V?$xalloc@PAVIRender_Portal@@@@@std@@SAIABV?$xalloc@PAVIRender_Portal@@@@@Z PROC ; std::_Normal_allocator_traits<xalloc<IRender_Portal *> >::max_size, COMDAT
; __Al$dead$ = ecx

; 591  :         if constexpr (_Has_max_size<_Alloc>::value) {
; 592  :             return _Al.max_size();

	mov	eax, 1073741823				; 3fffffffH

; 593  :         } else {
; 594  :             return (numeric_limits<size_type>::max)() / sizeof(value_type);
; 595  :         }
; 596  :     }

	ret	0
?max_size@?$_Normal_allocator_traits@V?$xalloc@PAVIRender_Portal@@@@@std@@SAIABV?$xalloc@PAVIRender_Portal@@@@@Z ENDP ; std::_Normal_allocator_traits<xalloc<IRender_Portal *> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$xalloc@PAUIDirect3DIndexBuffer9@@@@V?$_Vector_val@U?$_Simple_types@PAUIDirect3DIndexBuffer9@@@std@@@std@@$00@std@@QBEABV?$xalloc@PAUIDirect3DIndexBuffer9@@@@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@V?$xalloc@PAUIDirect3DIndexBuffer9@@@@V?$_Vector_val@U?$_Simple_types@PAUIDirect3DIndexBuffer9@@@std@@@std@@$00@std@@QBEABV?$xalloc@PAUIDirect3DIndexBuffer9@@@@XZ PROC ; std::_Compressed_pair<xalloc<IDirect3DIndexBuffer9 *>,std::_Vector_val<std::_Simple_types<IDirect3DIndexBuffer9 *> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 1343 :         return *this;

	mov	eax, ecx

; 1344 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$xalloc@PAUIDirect3DIndexBuffer9@@@@V?$_Vector_val@U?$_Simple_types@PAUIDirect3DIndexBuffer9@@@std@@@std@@$00@std@@QBEABV?$xalloc@PAUIDirect3DIndexBuffer9@@@@XZ ENDP ; std::_Compressed_pair<xalloc<IDirect3DIndexBuffer9 *>,std::_Vector_val<std::_Simple_types<IDirect3DIndexBuffer9 *> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?max_size@?$xalloc@PAUIDirect3DIndexBuffer9@@@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$xalloc@PAUIDirect3DIndexBuffer9@@@@QBEIXZ PROC ; xalloc<IDirect3DIndexBuffer9 *>::max_size, COMDAT
; _this$dead$ = ecx

; 86   : 							size_type				max_size		() const								{	size_type _Count = (size_type)(-1) / sizeof (T);	return (0 < _Count ? _Count : 1);	}

	mov	eax, 1073741823				; 3fffffffH
	ret	0
?max_size@?$xalloc@PAUIDirect3DIndexBuffer9@@@@QBEIXZ ENDP ; xalloc<IDirect3DIndexBuffer9 *>::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$xalloc@PAUIDirect3DVertexBuffer9@@@@V?$_Vector_val@U?$_Simple_types@PAUIDirect3DVertexBuffer9@@@std@@@std@@$00@std@@QBEABV?$xalloc@PAUIDirect3DVertexBuffer9@@@@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@V?$xalloc@PAUIDirect3DVertexBuffer9@@@@V?$_Vector_val@U?$_Simple_types@PAUIDirect3DVertexBuffer9@@@std@@@std@@$00@std@@QBEABV?$xalloc@PAUIDirect3DVertexBuffer9@@@@XZ PROC ; std::_Compressed_pair<xalloc<IDirect3DVertexBuffer9 *>,std::_Vector_val<std::_Simple_types<IDirect3DVertexBuffer9 *> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 1343 :         return *this;

	mov	eax, ecx

; 1344 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$xalloc@PAUIDirect3DVertexBuffer9@@@@V?$_Vector_val@U?$_Simple_types@PAUIDirect3DVertexBuffer9@@@std@@@std@@$00@std@@QBEABV?$xalloc@PAUIDirect3DVertexBuffer9@@@@XZ ENDP ; std::_Compressed_pair<xalloc<IDirect3DVertexBuffer9 *>,std::_Vector_val<std::_Simple_types<IDirect3DVertexBuffer9 *> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?max_size@?$xalloc@PAUIDirect3DVertexBuffer9@@@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$xalloc@PAUIDirect3DVertexBuffer9@@@@QBEIXZ PROC ; xalloc<IDirect3DVertexBuffer9 *>::max_size, COMDAT
; _this$dead$ = ecx

; 86   : 							size_type				max_size		() const								{	size_type _Count = (size_type)(-1) / sizeof (T);	return (0 < _Count ? _Count : 1);	}

	mov	eax, 1073741823				; 3fffffffH
	ret	0
?max_size@?$xalloc@PAUIDirect3DVertexBuffer9@@@@QBEIXZ ENDP ; xalloc<IDirect3DVertexBuffer9 *>::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$xalloc@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@@V?$_Vector_val@U?$_Simple_types@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@std@@@std@@$00@std@@QBEABV?$xalloc@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@V?$xalloc@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@@V?$_Vector_val@U?$_Simple_types@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@std@@@std@@$00@std@@QBEABV?$xalloc@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@@XZ PROC ; std::_Compressed_pair<xalloc<svector<_D3DVERTEXELEMENT9,65> >,std::_Vector_val<std::_Simple_types<svector<_D3DVERTEXELEMENT9,65> > >,1>::_Get_first, COMDAT
; _this$ = ecx

; 1343 :         return *this;

	mov	eax, ecx

; 1344 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$xalloc@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@@V?$_Vector_val@U?$_Simple_types@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@std@@@std@@$00@std@@QBEABV?$xalloc@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@@XZ ENDP ; std::_Compressed_pair<xalloc<svector<_D3DVERTEXELEMENT9,65> >,std::_Vector_val<std::_Simple_types<svector<_D3DVERTEXELEMENT9,65> > >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?max_size@?$xalloc@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$xalloc@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@@QBEIXZ PROC ; xalloc<svector<_D3DVERTEXELEMENT9,65> >::max_size, COMDAT
; _this$dead$ = ecx

; 86   : 							size_type				max_size		() const								{	size_type _Count = (size_type)(-1) / sizeof (T);	return (0 < _Count ? _Count : 1);	}

	mov	eax, 8196502				; 007d1196H
	ret	0
?max_size@?$xalloc@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@@QBEIXZ ENDP ; xalloc<svector<_D3DVERTEXELEMENT9,65> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$xalloc@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@@V?$_Vector_val@U?$_Simple_types@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@std@@@std@@$00@std@@QBEABV?$xalloc@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@V?$xalloc@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@@V?$_Vector_val@U?$_Simple_types@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@std@@@std@@$00@std@@QBEABV?$xalloc@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@@XZ PROC ; std::_Compressed_pair<xalloc<resptr_core<Shader,resptrcode_shader> >,std::_Vector_val<std::_Simple_types<resptr_core<Shader,resptrcode_shader> > >,1>::_Get_first, COMDAT
; _this$ = ecx

; 1343 :         return *this;

	mov	eax, ecx

; 1344 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$xalloc@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@@V?$_Vector_val@U?$_Simple_types@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@std@@@std@@$00@std@@QBEABV?$xalloc@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@@XZ ENDP ; std::_Compressed_pair<xalloc<resptr_core<Shader,resptrcode_shader> >,std::_Vector_val<std::_Simple_types<resptr_core<Shader,resptrcode_shader> > >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?max_size@?$xalloc@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$xalloc@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@@QBEIXZ PROC ; xalloc<resptr_core<Shader,resptrcode_shader> >::max_size, COMDAT
; _this$dead$ = ecx

; 86   : 							size_type				max_size		() const								{	size_type _Count = (size_type)(-1) / sizeof (T);	return (0 < _Count ? _Count : 1);	}

	mov	eax, 1073741823				; 3fffffffH
	ret	0
?max_size@?$xalloc@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@@QBEIXZ ENDP ; xalloc<resptr_core<Shader,resptrcode_shader> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$xalloc@UFSlideWindowItem@@@@V?$_Vector_val@U?$_Simple_types@UFSlideWindowItem@@@std@@@std@@$00@std@@QBEABV?$xalloc@UFSlideWindowItem@@@@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@V?$xalloc@UFSlideWindowItem@@@@V?$_Vector_val@U?$_Simple_types@UFSlideWindowItem@@@std@@@std@@$00@std@@QBEABV?$xalloc@UFSlideWindowItem@@@@XZ PROC ; std::_Compressed_pair<xalloc<FSlideWindowItem>,std::_Vector_val<std::_Simple_types<FSlideWindowItem> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 1343 :         return *this;

	mov	eax, ecx

; 1344 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$xalloc@UFSlideWindowItem@@@@V?$_Vector_val@U?$_Simple_types@UFSlideWindowItem@@@std@@@std@@$00@std@@QBEABV?$xalloc@UFSlideWindowItem@@@@XZ ENDP ; std::_Compressed_pair<xalloc<FSlideWindowItem>,std::_Vector_val<std::_Simple_types<FSlideWindowItem> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?max_size@?$xalloc@UFSlideWindowItem@@@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$xalloc@UFSlideWindowItem@@@@QBEIXZ PROC	; xalloc<FSlideWindowItem>::max_size, COMDAT
; _this$dead$ = ecx

; 86   : 							size_type				max_size		() const								{	size_type _Count = (size_type)(-1) / sizeof (T);	return (0 < _Count ? _Count : 1);	}

	mov	eax, 178956970				; 0aaaaaaaH
	ret	0
?max_size@?$xalloc@UFSlideWindowItem@@@@QBEIXZ ENDP	; xalloc<FSlideWindowItem>::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$xalloc@PAVIRender_Portal@@@@V?$_Vector_val@U?$_Simple_types@PAVIRender_Portal@@@std@@@std@@$00@std@@QBEABV?$xalloc@PAVIRender_Portal@@@@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@V?$xalloc@PAVIRender_Portal@@@@V?$_Vector_val@U?$_Simple_types@PAVIRender_Portal@@@std@@@std@@$00@std@@QBEABV?$xalloc@PAVIRender_Portal@@@@XZ PROC ; std::_Compressed_pair<xalloc<IRender_Portal *>,std::_Vector_val<std::_Simple_types<IRender_Portal *> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 1343 :         return *this;

	mov	eax, ecx

; 1344 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$xalloc@PAVIRender_Portal@@@@V?$_Vector_val@U?$_Simple_types@PAVIRender_Portal@@@std@@@std@@$00@std@@QBEABV?$xalloc@PAVIRender_Portal@@@@XZ ENDP ; std::_Compressed_pair<xalloc<IRender_Portal *>,std::_Vector_val<std::_Simple_types<IRender_Portal *> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?max_size@?$xalloc@PAVIRender_Portal@@@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$xalloc@PAVIRender_Portal@@@@QBEIXZ PROC	; xalloc<IRender_Portal *>::max_size, COMDAT
; _this$dead$ = ecx

; 86   : 							size_type				max_size		() const								{	size_type _Count = (size_type)(-1) / sizeof (T);	return (0 < _Count ? _Count : 1);	}

	mov	eax, 1073741823				; 3fffffffH
	ret	0
?max_size@?$xalloc@PAVIRender_Portal@@@@QBEIXZ ENDP	; xalloc<IRender_Portal *>::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Zero_range@PAPAUIDirect3DIndexBuffer9@@@std@@YAPAPAUIDirect3DIndexBuffer9@@QAPAU1@0@Z
_TEXT	SEGMENT
??$_Zero_range@PAPAUIDirect3DIndexBuffer9@@@std@@YAPAPAUIDirect3DIndexBuffer9@@QAPAU1@0@Z PROC ; std::_Zero_range<IDirect3DIndexBuffer9 * *>, COMDAT
; __First$ = ecx
; __Last$ = edx

; 1789 : _Ptr _Zero_range(const _Ptr _First, const _Ptr _Last) { // fill [_First, _Last) with zeroes

	push	esi
	mov	esi, edx

; 1790 :     char* const _First_ch = reinterpret_cast<char*>(_To_address(_First));
; 1791 :     char* const _Last_ch  = reinterpret_cast<char*>(_To_address(_Last));
; 1792 :     _CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

	mov	eax, esi
	sub	eax, ecx
	push	eax
	push	0
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 1793 :     return _Last;

	mov	eax, esi
	pop	esi

; 1794 : }

	ret	0
??$_Zero_range@PAPAUIDirect3DIndexBuffer9@@@std@@YAPAPAUIDirect3DIndexBuffer9@@QAPAU1@0@Z ENDP ; std::_Zero_range<IDirect3DIndexBuffer9 * *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_To_address@PAPAUIDirect3DIndexBuffer9@@@std@@YA?A_PABQAPAUIDirect3DIndexBuffer9@@@Z
_TEXT	SEGMENT
??$_To_address@PAPAUIDirect3DIndexBuffer9@@@std@@YA?A_PABQAPAUIDirect3DIndexBuffer9@@@Z PROC ; std::_To_address<IDirect3DIndexBuffer9 * *>, COMDAT
; __Val$ = ecx

; 3981 :     _STL_INTERNAL_STATIC_ASSERT(is_pointer_v<_Iter>);
; 3982 :     return _Val;

	mov	eax, DWORD PTR [ecx]

; 3983 : }

	ret	0
??$_To_address@PAPAUIDirect3DIndexBuffer9@@@std@@YA?A_PABQAPAUIDirect3DIndexBuffer9@@@Z ENDP ; std::_To_address<IDirect3DIndexBuffer9 * *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Emplace_back@$$V@?$_Uninitialized_backout_al@V?$xalloc@PAUIDirect3DIndexBuffer9@@@@@std@@QAEXXZ
_TEXT	SEGMENT
??$_Emplace_back@$$V@?$_Uninitialized_backout_al@V?$xalloc@PAUIDirect3DIndexBuffer9@@@@@std@@QAEXXZ PROC ; std::_Uninitialized_backout_al<xalloc<IDirect3DIndexBuffer9 *> >::_Emplace_back<>, COMDAT
; _this$ = ecx

; 570  :             ::new (static_cast<void*>(_Ptr)) _Ty(_STD forward<_Types>(_Args)...);

	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax], 0

; 1620 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);
; 1621 :         ++_Last;

	add	DWORD PTR [ecx+4], 4

; 1622 :     }

	ret	0
??$_Emplace_back@$$V@?$_Uninitialized_backout_al@V?$xalloc@PAUIDirect3DIndexBuffer9@@@@@std@@QAEXXZ ENDP ; std::_Uninitialized_backout_al<xalloc<IDirect3DIndexBuffer9 *> >::_Emplace_back<>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Zero_range@PAPAUIDirect3DVertexBuffer9@@@std@@YAPAPAUIDirect3DVertexBuffer9@@QAPAU1@0@Z
_TEXT	SEGMENT
??$_Zero_range@PAPAUIDirect3DVertexBuffer9@@@std@@YAPAPAUIDirect3DVertexBuffer9@@QAPAU1@0@Z PROC ; std::_Zero_range<IDirect3DVertexBuffer9 * *>, COMDAT
; __First$ = ecx
; __Last$ = edx

; 1789 : _Ptr _Zero_range(const _Ptr _First, const _Ptr _Last) { // fill [_First, _Last) with zeroes

	push	esi
	mov	esi, edx

; 1790 :     char* const _First_ch = reinterpret_cast<char*>(_To_address(_First));
; 1791 :     char* const _Last_ch  = reinterpret_cast<char*>(_To_address(_Last));
; 1792 :     _CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

	mov	eax, esi
	sub	eax, ecx
	push	eax
	push	0
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 1793 :     return _Last;

	mov	eax, esi
	pop	esi

; 1794 : }

	ret	0
??$_Zero_range@PAPAUIDirect3DVertexBuffer9@@@std@@YAPAPAUIDirect3DVertexBuffer9@@QAPAU1@0@Z ENDP ; std::_Zero_range<IDirect3DVertexBuffer9 * *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_To_address@PAPAUIDirect3DVertexBuffer9@@@std@@YA?A_PABQAPAUIDirect3DVertexBuffer9@@@Z
_TEXT	SEGMENT
??$_To_address@PAPAUIDirect3DVertexBuffer9@@@std@@YA?A_PABQAPAUIDirect3DVertexBuffer9@@@Z PROC ; std::_To_address<IDirect3DVertexBuffer9 * *>, COMDAT
; __Val$ = ecx

; 3981 :     _STL_INTERNAL_STATIC_ASSERT(is_pointer_v<_Iter>);
; 3982 :     return _Val;

	mov	eax, DWORD PTR [ecx]

; 3983 : }

	ret	0
??$_To_address@PAPAUIDirect3DVertexBuffer9@@@std@@YA?A_PABQAPAUIDirect3DVertexBuffer9@@@Z ENDP ; std::_To_address<IDirect3DVertexBuffer9 * *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Emplace_back@$$V@?$_Uninitialized_backout_al@V?$xalloc@PAUIDirect3DVertexBuffer9@@@@@std@@QAEXXZ
_TEXT	SEGMENT
??$_Emplace_back@$$V@?$_Uninitialized_backout_al@V?$xalloc@PAUIDirect3DVertexBuffer9@@@@@std@@QAEXXZ PROC ; std::_Uninitialized_backout_al<xalloc<IDirect3DVertexBuffer9 *> >::_Emplace_back<>, COMDAT
; _this$ = ecx

; 570  :             ::new (static_cast<void*>(_Ptr)) _Ty(_STD forward<_Types>(_Args)...);

	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax], 0

; 1620 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);
; 1621 :         ++_Last;

	add	DWORD PTR [ecx+4], 4

; 1622 :     }

	ret	0
??$_Emplace_back@$$V@?$_Uninitialized_backout_al@V?$xalloc@PAUIDirect3DVertexBuffer9@@@@@std@@QAEXXZ ENDP ; std::_Uninitialized_backout_al<xalloc<IDirect3DVertexBuffer9 *> >::_Emplace_back<>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Emplace_back@$$V@?$_Uninitialized_backout_al@V?$xalloc@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@@@std@@QAEXXZ
_TEXT	SEGMENT
??$_Emplace_back@$$V@?$_Uninitialized_backout_al@V?$xalloc@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@@@std@@QAEXXZ PROC ; std::_Uninitialized_backout_al<xalloc<svector<_D3DVERTEXELEMENT9,65> > >::_Emplace_back<>, COMDAT
; _this$ = ecx

; 1620 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+520], 0

; 1621 :         ++_Last;

	add	DWORD PTR [ecx+4], 524			; 0000020cH

; 1622 :     }

	ret	0
??$_Emplace_back@$$V@?$_Uninitialized_backout_al@V?$xalloc@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@@@std@@QAEXXZ ENDP ; std::_Uninitialized_backout_al<xalloc<svector<_D3DVERTEXELEMENT9,65> > >::_Emplace_back<>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Emplace_back@$$V@?$_Uninitialized_backout_al@V?$xalloc@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@@@std@@QAEXXZ
_TEXT	SEGMENT
??$_Emplace_back@$$V@?$_Uninitialized_backout_al@V?$xalloc@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@@@std@@QAEXXZ PROC ; std::_Uninitialized_backout_al<xalloc<resptr_core<Shader,resptrcode_shader> > >::_Emplace_back<>, COMDAT
; _this$ = ecx

; 1620 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax], 0

; 1621 :         ++_Last;

	add	DWORD PTR [ecx+4], 4

; 1622 :     }

	ret	0
??$_Emplace_back@$$V@?$_Uninitialized_backout_al@V?$xalloc@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@@@std@@QAEXXZ ENDP ; std::_Uninitialized_backout_al<xalloc<resptr_core<Shader,resptrcode_shader> > >::_Emplace_back<>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrEngine\Fmesh.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Emplace_back@$$V@?$_Uninitialized_backout_al@V?$xalloc@UFSlideWindowItem@@@@@std@@QAEXXZ
_TEXT	SEGMENT
??$_Emplace_back@$$V@?$_Uninitialized_backout_al@V?$xalloc@UFSlideWindowItem@@@@@std@@QAEXXZ PROC ; std::_Uninitialized_backout_al<xalloc<FSlideWindowItem> >::_Emplace_back<>, COMDAT
; _this$ = ecx

; 570  :             ::new (static_cast<void*>(_Ptr)) _Ty(_STD forward<_Types>(_Args)...);

	mov	eax, DWORD PTR [ecx+4]
; File I:\Vitalya\mine\NSProjectX\xrEngine\Fmesh.h

; 105  : 	FSlideWindowItem() : sw(0), count(0) {};

	mov	DWORD PTR [eax], 0
	mov	DWORD PTR [eax+4], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1621 :         ++_Last;

	add	DWORD PTR [ecx+4], 24			; 00000018H

; 1622 :     }

	ret	0
??$_Emplace_back@$$V@?$_Uninitialized_backout_al@V?$xalloc@UFSlideWindowItem@@@@@std@@QAEXXZ ENDP ; std::_Uninitialized_backout_al<xalloc<FSlideWindowItem> >::_Emplace_back<>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Zero_range@PAPAVIRender_Portal@@@std@@YAPAPAVIRender_Portal@@QAPAV1@0@Z
_TEXT	SEGMENT
??$_Zero_range@PAPAVIRender_Portal@@@std@@YAPAPAVIRender_Portal@@QAPAV1@0@Z PROC ; std::_Zero_range<IRender_Portal * *>, COMDAT
; __First$ = ecx
; __Last$ = edx

; 1789 : _Ptr _Zero_range(const _Ptr _First, const _Ptr _Last) { // fill [_First, _Last) with zeroes

	push	esi
	mov	esi, edx

; 1790 :     char* const _First_ch = reinterpret_cast<char*>(_To_address(_First));
; 1791 :     char* const _Last_ch  = reinterpret_cast<char*>(_To_address(_Last));
; 1792 :     _CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

	mov	eax, esi
	sub	eax, ecx
	push	eax
	push	0
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 1793 :     return _Last;

	mov	eax, esi
	pop	esi

; 1794 : }

	ret	0
??$_Zero_range@PAPAVIRender_Portal@@@std@@YAPAPAVIRender_Portal@@QAPAV1@0@Z ENDP ; std::_Zero_range<IRender_Portal * *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_To_address@PAPAVIRender_Portal@@@std@@YA?A_PABQAPAVIRender_Portal@@@Z
_TEXT	SEGMENT
??$_To_address@PAPAVIRender_Portal@@@std@@YA?A_PABQAPAVIRender_Portal@@@Z PROC ; std::_To_address<IRender_Portal * *>, COMDAT
; __Val$ = ecx

; 3981 :     _STL_INTERNAL_STATIC_ASSERT(is_pointer_v<_Iter>);
; 3982 :     return _Val;

	mov	eax, DWORD PTR [ecx]

; 3983 : }

	ret	0
??$_To_address@PAPAVIRender_Portal@@@std@@YA?A_PABQAPAVIRender_Portal@@@Z ENDP ; std::_To_address<IRender_Portal * *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Emplace_back@$$V@?$_Uninitialized_backout_al@V?$xalloc@PAVIRender_Portal@@@@@std@@QAEXXZ
_TEXT	SEGMENT
??$_Emplace_back@$$V@?$_Uninitialized_backout_al@V?$xalloc@PAVIRender_Portal@@@@@std@@QAEXXZ PROC ; std::_Uninitialized_backout_al<xalloc<IRender_Portal *> >::_Emplace_back<>, COMDAT
; _this$ = ecx

; 570  :             ::new (static_cast<void*>(_Ptr)) _Ty(_STD forward<_Types>(_Args)...);

	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax], 0

; 1620 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);
; 1621 :         ++_Last;

	add	DWORD PTR [ecx+4], 4

; 1622 :     }

	ret	0
??$_Emplace_back@$$V@?$_Uninitialized_backout_al@V?$xalloc@PAVIRender_Portal@@@@@std@@QAEXXZ ENDP ; std::_Uninitialized_backout_al<xalloc<IRender_Portal *> >::_Emplace_back<>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
;	COMDAT ??$xr_alloc@PAUIDirect3DIndexBuffer9@@@@YAPAPAUIDirect3DIndexBuffer9@@I@Z
_TEXT	SEGMENT
??$xr_alloc@PAUIDirect3DIndexBuffer9@@@@YAPAPAUIDirect3DIndexBuffer9@@I@Z PROC ; xr_alloc<IDirect3DIndexBuffer9 *>, COMDAT
; _count$ = ecx

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	lea	eax, DWORD PTR [ecx*4]
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
	ret	0
??$xr_alloc@PAUIDirect3DIndexBuffer9@@@@YAPAPAUIDirect3DIndexBuffer9@@I@Z ENDP ; xr_alloc<IDirect3DIndexBuffer9 *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
;	COMDAT ??$xr_alloc@PAUIDirect3DVertexBuffer9@@@@YAPAPAUIDirect3DVertexBuffer9@@I@Z
_TEXT	SEGMENT
??$xr_alloc@PAUIDirect3DVertexBuffer9@@@@YAPAPAUIDirect3DVertexBuffer9@@I@Z PROC ; xr_alloc<IDirect3DVertexBuffer9 *>, COMDAT
; _count$ = ecx

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	lea	eax, DWORD PTR [ecx*4]
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
	ret	0
??$xr_alloc@PAUIDirect3DVertexBuffer9@@@@YAPAPAUIDirect3DVertexBuffer9@@I@Z ENDP ; xr_alloc<IDirect3DVertexBuffer9 *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
;	COMDAT ??$xr_alloc@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@@YAPAV?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@I@Z
_TEXT	SEGMENT
??$xr_alloc@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@@YAPAV?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@I@Z PROC ; xr_alloc<svector<_D3DVERTEXELEMENT9,65> >, COMDAT
; _count$ = ecx

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	imul	eax, ecx, 524
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
	ret	0
??$xr_alloc@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@@YAPAV?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@I@Z ENDP ; xr_alloc<svector<_D3DVERTEXELEMENT9,65> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
;	COMDAT ??$xr_alloc@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@@YAPAV?$resptr_core@UShader@@Uresptrcode_shader@@@@I@Z
_TEXT	SEGMENT
??$xr_alloc@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@@YAPAV?$resptr_core@UShader@@Uresptrcode_shader@@@@I@Z PROC ; xr_alloc<resptr_core<Shader,resptrcode_shader> >, COMDAT
; _count$ = ecx

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	lea	eax, DWORD PTR [ecx*4]
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
	ret	0
??$xr_alloc@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@@YAPAV?$resptr_core@UShader@@Uresptrcode_shader@@@@I@Z ENDP ; xr_alloc<resptr_core<Shader,resptrcode_shader> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
;	COMDAT ??$xr_alloc@UFSlideWindowItem@@@@YAPAUFSlideWindowItem@@I@Z
_TEXT	SEGMENT
??$xr_alloc@UFSlideWindowItem@@@@YAPAUFSlideWindowItem@@I@Z PROC ; xr_alloc<FSlideWindowItem>, COMDAT
; _count$ = ecx

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	lea	eax, DWORD PTR [ecx+ecx*2]
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	shl	eax, 3
	push	eax
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
	ret	0
??$xr_alloc@UFSlideWindowItem@@@@YAPAUFSlideWindowItem@@I@Z ENDP ; xr_alloc<FSlideWindowItem>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
;	COMDAT ??$xr_alloc@PAVIRender_Portal@@@@YAPAPAVIRender_Portal@@I@Z
_TEXT	SEGMENT
??$xr_alloc@PAVIRender_Portal@@@@YAPAPAVIRender_Portal@@I@Z PROC ; xr_alloc<IRender_Portal *>, COMDAT
; _count$ = ecx

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	lea	eax, DWORD PTR [ecx*4]
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
	ret	0
??$xr_alloc@PAVIRender_Portal@@@@YAPAPAVIRender_Portal@@I@Z ENDP ; xr_alloc<IRender_Portal *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Uninitialized_move@PAPAUIDirect3DIndexBuffer9@@V?$xalloc@PAUIDirect3DIndexBuffer9@@@@@std@@YAPAPAUIDirect3DIndexBuffer9@@QAPAU1@0PAPAU1@AAV?$xalloc@PAUIDirect3DIndexBuffer9@@@@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Al$dead$ = 12						; size = 4
??$_Uninitialized_move@PAPAUIDirect3DIndexBuffer9@@V?$xalloc@PAUIDirect3DIndexBuffer9@@@@@std@@YAPAPAUIDirect3DIndexBuffer9@@QAPAU1@0PAPAU1@AAV?$xalloc@PAUIDirect3DIndexBuffer9@@@@@Z PROC ; std::_Uninitialized_move<IDirect3DIndexBuffer9 * *,xalloc<IDirect3DIndexBuffer9 *> >, COMDAT
; __First$ = ecx
; __Last$ = edx

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	eax, DWORD PTR __Dest$[esp-4]

; 1699 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

	push	esi
	mov	esi, edx

; 1700 :     // move [_First, _Last) to raw _Dest, using _Al
; 1701 :     // note: only called internally from elsewhere in the STL
; 1702 :     using _Ptrval     = typename _Alloc::value_type*;
; 1703 :     auto _UFirst      = _Get_unwrapped(_First);
; 1704 :     const auto _ULast = _Get_unwrapped(_Last);
; 1705 :     if constexpr (conjunction_v<bool_constant<_Ptr_move_cat<decltype(_UFirst), _Ptrval>::_Really_trivial>,
; 1706 :                       _Uses_default_construct<_Alloc, _Ptrval, decltype(_STD move(*_UFirst))>>) {
; 1707 : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 1708 :         if (!_STD is_constant_evaluated())
; 1709 : #endif // __cpp_lib_constexpr_dynamic_alloc
; 1710 :         {
; 1711 :             _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));
; 1712 :             return _Dest + (_ULast - _UFirst);
; 1713 :         }
; 1714 :     }
; 1715 : 
; 1716 :     _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	ecx, esi
	je	SHORT $LN3@Uninitiali
	npad	5
$LL4@Uninitiali:

; 1620 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

	mov	edx, DWORD PTR [ecx]

; 1621 :         ++_Last;

	add	ecx, 4
	mov	DWORD PTR [eax], edx
	add	eax, 4

; 1700 :     // move [_First, _Last) to raw _Dest, using _Al
; 1701 :     // note: only called internally from elsewhere in the STL
; 1702 :     using _Ptrval     = typename _Alloc::value_type*;
; 1703 :     auto _UFirst      = _Get_unwrapped(_First);
; 1704 :     const auto _ULast = _Get_unwrapped(_Last);
; 1705 :     if constexpr (conjunction_v<bool_constant<_Ptr_move_cat<decltype(_UFirst), _Ptrval>::_Really_trivial>,
; 1706 :                       _Uses_default_construct<_Alloc, _Ptrval, decltype(_STD move(*_UFirst))>>) {
; 1707 : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 1708 :         if (!_STD is_constant_evaluated())
; 1709 : #endif // __cpp_lib_constexpr_dynamic_alloc
; 1710 :         {
; 1711 :             _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));
; 1712 :             return _Dest + (_ULast - _UFirst);
; 1713 :         }
; 1714 :     }
; 1715 : 
; 1716 :     _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	ecx, esi
	jne	SHORT $LL4@Uninitiali
$LN3@Uninitiali:
	pop	esi

; 1718 :         _Backout._Emplace_back(_STD move(*_UFirst));
; 1719 :     }
; 1720 : 
; 1721 :     return _Backout._Release();
; 1722 : }

	ret	0
??$_Uninitialized_move@PAPAUIDirect3DIndexBuffer9@@V?$xalloc@PAUIDirect3DIndexBuffer9@@@@@std@@YAPAPAUIDirect3DIndexBuffer9@@QAPAU1@0PAPAU1@AAV?$xalloc@PAUIDirect3DIndexBuffer9@@@@@Z ENDP ; std::_Uninitialized_move<IDirect3DIndexBuffer9 * *,xalloc<IDirect3DIndexBuffer9 *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_Get_unwrapped@ABQAPAUIDirect3DIndexBuffer9@@@std@@YA?A_TABQAPAUIDirect3DIndexBuffer9@@@Z
_TEXT	SEGMENT
??$_Get_unwrapped@ABQAPAUIDirect3DIndexBuffer9@@@std@@YA?A_TABQAPAUIDirect3DIndexBuffer9@@@Z PROC ; std::_Get_unwrapped<IDirect3DIndexBuffer9 * * const &>, COMDAT
; __It$ = ecx

; 1275 :     // unwrap an iterator previously subjected to _Adl_verify_range or otherwise validated
; 1276 :     if constexpr (is_pointer_v<decay_t<_Iter>>) { // special-case pointers and arrays
; 1277 :         return _It + 0;

	mov	eax, DWORD PTR [ecx]

; 1278 :     } else if constexpr (_Unwrappable_v<_Iter>) {
; 1279 :         return static_cast<_Iter&&>(_It)._Unwrapped();
; 1280 :     } else {
; 1281 :         return static_cast<_Iter&&>(_It);
; 1282 :     }
; 1283 : }

	ret	0
??$_Get_unwrapped@ABQAPAUIDirect3DIndexBuffer9@@@std@@YA?A_TABQAPAUIDirect3DIndexBuffer9@@@Z ENDP ; std::_Get_unwrapped<IDirect3DIndexBuffer9 * * const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Uninitialized_move@PAPAUIDirect3DVertexBuffer9@@V?$xalloc@PAUIDirect3DVertexBuffer9@@@@@std@@YAPAPAUIDirect3DVertexBuffer9@@QAPAU1@0PAPAU1@AAV?$xalloc@PAUIDirect3DVertexBuffer9@@@@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Al$dead$ = 12						; size = 4
??$_Uninitialized_move@PAPAUIDirect3DVertexBuffer9@@V?$xalloc@PAUIDirect3DVertexBuffer9@@@@@std@@YAPAPAUIDirect3DVertexBuffer9@@QAPAU1@0PAPAU1@AAV?$xalloc@PAUIDirect3DVertexBuffer9@@@@@Z PROC ; std::_Uninitialized_move<IDirect3DVertexBuffer9 * *,xalloc<IDirect3DVertexBuffer9 *> >, COMDAT
; __First$ = ecx
; __Last$ = edx

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	eax, DWORD PTR __Dest$[esp-4]

; 1699 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

	push	esi
	mov	esi, edx

; 1700 :     // move [_First, _Last) to raw _Dest, using _Al
; 1701 :     // note: only called internally from elsewhere in the STL
; 1702 :     using _Ptrval     = typename _Alloc::value_type*;
; 1703 :     auto _UFirst      = _Get_unwrapped(_First);
; 1704 :     const auto _ULast = _Get_unwrapped(_Last);
; 1705 :     if constexpr (conjunction_v<bool_constant<_Ptr_move_cat<decltype(_UFirst), _Ptrval>::_Really_trivial>,
; 1706 :                       _Uses_default_construct<_Alloc, _Ptrval, decltype(_STD move(*_UFirst))>>) {
; 1707 : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 1708 :         if (!_STD is_constant_evaluated())
; 1709 : #endif // __cpp_lib_constexpr_dynamic_alloc
; 1710 :         {
; 1711 :             _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));
; 1712 :             return _Dest + (_ULast - _UFirst);
; 1713 :         }
; 1714 :     }
; 1715 : 
; 1716 :     _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	ecx, esi
	je	SHORT $LN3@Uninitiali
	npad	5
$LL4@Uninitiali:

; 1620 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

	mov	edx, DWORD PTR [ecx]

; 1621 :         ++_Last;

	add	ecx, 4
	mov	DWORD PTR [eax], edx
	add	eax, 4

; 1700 :     // move [_First, _Last) to raw _Dest, using _Al
; 1701 :     // note: only called internally from elsewhere in the STL
; 1702 :     using _Ptrval     = typename _Alloc::value_type*;
; 1703 :     auto _UFirst      = _Get_unwrapped(_First);
; 1704 :     const auto _ULast = _Get_unwrapped(_Last);
; 1705 :     if constexpr (conjunction_v<bool_constant<_Ptr_move_cat<decltype(_UFirst), _Ptrval>::_Really_trivial>,
; 1706 :                       _Uses_default_construct<_Alloc, _Ptrval, decltype(_STD move(*_UFirst))>>) {
; 1707 : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 1708 :         if (!_STD is_constant_evaluated())
; 1709 : #endif // __cpp_lib_constexpr_dynamic_alloc
; 1710 :         {
; 1711 :             _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));
; 1712 :             return _Dest + (_ULast - _UFirst);
; 1713 :         }
; 1714 :     }
; 1715 : 
; 1716 :     _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	ecx, esi
	jne	SHORT $LL4@Uninitiali
$LN3@Uninitiali:
	pop	esi

; 1718 :         _Backout._Emplace_back(_STD move(*_UFirst));
; 1719 :     }
; 1720 : 
; 1721 :     return _Backout._Release();
; 1722 : }

	ret	0
??$_Uninitialized_move@PAPAUIDirect3DVertexBuffer9@@V?$xalloc@PAUIDirect3DVertexBuffer9@@@@@std@@YAPAPAUIDirect3DVertexBuffer9@@QAPAU1@0PAPAU1@AAV?$xalloc@PAUIDirect3DVertexBuffer9@@@@@Z ENDP ; std::_Uninitialized_move<IDirect3DVertexBuffer9 * *,xalloc<IDirect3DVertexBuffer9 *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_Get_unwrapped@ABQAPAUIDirect3DVertexBuffer9@@@std@@YA?A_TABQAPAUIDirect3DVertexBuffer9@@@Z
_TEXT	SEGMENT
??$_Get_unwrapped@ABQAPAUIDirect3DVertexBuffer9@@@std@@YA?A_TABQAPAUIDirect3DVertexBuffer9@@@Z PROC ; std::_Get_unwrapped<IDirect3DVertexBuffer9 * * const &>, COMDAT
; __It$ = ecx

; 1275 :     // unwrap an iterator previously subjected to _Adl_verify_range or otherwise validated
; 1276 :     if constexpr (is_pointer_v<decay_t<_Iter>>) { // special-case pointers and arrays
; 1277 :         return _It + 0;

	mov	eax, DWORD PTR [ecx]

; 1278 :     } else if constexpr (_Unwrappable_v<_Iter>) {
; 1279 :         return static_cast<_Iter&&>(_It)._Unwrapped();
; 1280 :     } else {
; 1281 :         return static_cast<_Iter&&>(_It);
; 1282 :     }
; 1283 : }

	ret	0
??$_Get_unwrapped@ABQAPAUIDirect3DVertexBuffer9@@@std@@YA?A_TABQAPAUIDirect3DVertexBuffer9@@@Z ENDP ; std::_Get_unwrapped<IDirect3DVertexBuffer9 * * const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Uninitialized_move@PAV?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@V?$xalloc@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@@@std@@YAPAV?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@QAV1@0PAV1@AAV?$xalloc@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Al$dead$ = 12						; size = 4
??$_Uninitialized_move@PAV?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@V?$xalloc@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@@@std@@YAPAV?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@QAV1@0PAV1@AAV?$xalloc@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@@@Z PROC ; std::_Uninitialized_move<svector<_D3DVERTEXELEMENT9,65> *,xalloc<svector<_D3DVERTEXELEMENT9,65> > >, COMDAT
; __First$ = ecx
; __Last$ = edx

; 1699 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

	push	ebx
	mov	ebx, edx
	mov	eax, ecx

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	edx, DWORD PTR __Dest$[esp]

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	eax, ebx
	je	SHORT $LN20@Uninitiali
	push	esi
	push	edi
	npad	1
$LL4@Uninitiali:
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	esi, eax
	mov	edi, edx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1621 :         ++_Last;

	add	eax, 524				; 0000020cH
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	ecx, 131				; 00000083H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1621 :         ++_Last;

	add	edx, 524				; 0000020cH
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	rep movsd
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	eax, ebx
	jne	SHORT $LL4@Uninitiali

; 1718 :         _Backout._Emplace_back(_STD move(*_UFirst));
; 1719 :     }
; 1720 : 
; 1721 :     return _Backout._Release();

	pop	edi
	pop	esi
$LN20@Uninitiali:

; 1722 : }

	mov	eax, edx
	pop	ebx
	ret	0
??$_Uninitialized_move@PAV?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@V?$xalloc@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@@@std@@YAPAV?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@QAV1@0PAV1@AAV?$xalloc@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@@@Z ENDP ; std::_Uninitialized_move<svector<_D3DVERTEXELEMENT9,65> *,xalloc<svector<_D3DVERTEXELEMENT9,65> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_Get_unwrapped@ABQAV?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@std@@YA?A_TABQAV?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@Z
_TEXT	SEGMENT
??$_Get_unwrapped@ABQAV?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@std@@YA?A_TABQAV?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@Z PROC ; std::_Get_unwrapped<svector<_D3DVERTEXELEMENT9,65> * const &>, COMDAT
; __It$ = ecx

; 1275 :     // unwrap an iterator previously subjected to _Adl_verify_range or otherwise validated
; 1276 :     if constexpr (is_pointer_v<decay_t<_Iter>>) { // special-case pointers and arrays
; 1277 :         return _It + 0;

	mov	eax, DWORD PTR [ecx]

; 1278 :     } else if constexpr (_Unwrappable_v<_Iter>) {
; 1279 :         return static_cast<_Iter&&>(_It)._Unwrapped();
; 1280 :     } else {
; 1281 :         return static_cast<_Iter&&>(_It);
; 1282 :     }
; 1283 : }

	ret	0
??$_Get_unwrapped@ABQAV?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@std@@YA?A_TABQAV?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@Z ENDP ; std::_Get_unwrapped<svector<_D3DVERTEXELEMENT9,65> * const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Uninitialized_copy@PAV?$resptr_core@UShader@@Uresptrcode_shader@@@@V?$xalloc@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@@@std@@YAPAV?$resptr_core@UShader@@Uresptrcode_shader@@@@QAV1@0PAV1@AAV?$xalloc@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Al$dead$ = 12						; size = 4
??$_Uninitialized_copy@PAV?$resptr_core@UShader@@Uresptrcode_shader@@@@V?$xalloc@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@@@std@@YAPAV?$resptr_core@UShader@@Uresptrcode_shader@@@@QAV1@0PAV1@AAV?$xalloc@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@@@Z PROC ; std::_Uninitialized_copy<resptr_core<Shader,resptrcode_shader> *,xalloc<resptr_core<Shader,resptrcode_shader> > >, COMDAT
; __First$ = ecx
; __Last$ = edx

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	eax, DWORD PTR __Dest$[esp-4]

; 1637 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

	push	esi
	mov	esi, edx

; 1638 :     // copy [_First, _Last) to raw _Dest, using _Al
; 1639 :     // note: only called internally from elsewhere in the STL
; 1640 :     using _Ptrval = typename _Alloc::value_type*;
; 1641 : 
; 1642 :     auto _UFirst      = _Get_unwrapped(_First);
; 1643 :     const auto _ULast = _Get_unwrapped(_Last);
; 1644 : 
; 1645 :     if constexpr (conjunction_v<bool_constant<_Ptr_copy_cat<decltype(_UFirst), _Ptrval>::_Really_trivial>,
; 1646 :                       _Uses_default_construct<_Alloc, _Ptrval, decltype(*_UFirst)>>) {
; 1647 : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 1648 :         if (!_STD is_constant_evaluated())
; 1649 : #endif // __cpp_lib_constexpr_dynamic_alloc
; 1650 :         {
; 1651 :             _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));
; 1652 :             _Dest += _ULast - _UFirst;
; 1653 :             return _Dest;
; 1654 :         }
; 1655 :     }
; 1656 : 
; 1657 :     _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1658 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	ecx, esi
	je	SHORT $LN3@Uninitiali
	npad	5
$LL4@Uninitiali:
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 63   : 						resptr_core		(const self & rhs)								{	p_ = rhs.p_; _inc();		}

	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx

; 43   : 	void				_inc	()									{	if (0==p_) return;	p_->dwReference++;														}

	test	edx, edx
	je	SHORT $LN16@Uninitiali
	inc	DWORD PTR [edx]
$LN16@Uninitiali:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1621 :         ++_Last;

	add	ecx, 4
	add	eax, 4

; 1638 :     // copy [_First, _Last) to raw _Dest, using _Al
; 1639 :     // note: only called internally from elsewhere in the STL
; 1640 :     using _Ptrval = typename _Alloc::value_type*;
; 1641 : 
; 1642 :     auto _UFirst      = _Get_unwrapped(_First);
; 1643 :     const auto _ULast = _Get_unwrapped(_Last);
; 1644 : 
; 1645 :     if constexpr (conjunction_v<bool_constant<_Ptr_copy_cat<decltype(_UFirst), _Ptrval>::_Really_trivial>,
; 1646 :                       _Uses_default_construct<_Alloc, _Ptrval, decltype(*_UFirst)>>) {
; 1647 : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 1648 :         if (!_STD is_constant_evaluated())
; 1649 : #endif // __cpp_lib_constexpr_dynamic_alloc
; 1650 :         {
; 1651 :             _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));
; 1652 :             _Dest += _ULast - _UFirst;
; 1653 :             return _Dest;
; 1654 :         }
; 1655 :     }
; 1656 : 
; 1657 :     _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1658 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	ecx, esi
	jne	SHORT $LL4@Uninitiali
$LN3@Uninitiali:
	pop	esi

; 1659 :         _Backout._Emplace_back(*_UFirst);
; 1660 :     }
; 1661 : 
; 1662 :     return _Backout._Release();
; 1663 : }

	ret	0
??$_Uninitialized_copy@PAV?$resptr_core@UShader@@Uresptrcode_shader@@@@V?$xalloc@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@@@std@@YAPAV?$resptr_core@UShader@@Uresptrcode_shader@@@@QAV1@0PAV1@AAV?$xalloc@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@@@Z ENDP ; std::_Uninitialized_copy<resptr_core<Shader,resptrcode_shader> *,xalloc<resptr_core<Shader,resptrcode_shader> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_Get_unwrapped@ABQAV?$resptr_core@UShader@@Uresptrcode_shader@@@@@std@@YA?A_TABQAV?$resptr_core@UShader@@Uresptrcode_shader@@@@@Z
_TEXT	SEGMENT
??$_Get_unwrapped@ABQAV?$resptr_core@UShader@@Uresptrcode_shader@@@@@std@@YA?A_TABQAV?$resptr_core@UShader@@Uresptrcode_shader@@@@@Z PROC ; std::_Get_unwrapped<resptr_core<Shader,resptrcode_shader> * const &>, COMDAT
; __It$ = ecx

; 1275 :     // unwrap an iterator previously subjected to _Adl_verify_range or otherwise validated
; 1276 :     if constexpr (is_pointer_v<decay_t<_Iter>>) { // special-case pointers and arrays
; 1277 :         return _It + 0;

	mov	eax, DWORD PTR [ecx]

; 1278 :     } else if constexpr (_Unwrappable_v<_Iter>) {
; 1279 :         return static_cast<_Iter&&>(_It)._Unwrapped();
; 1280 :     } else {
; 1281 :         return static_cast<_Iter&&>(_It);
; 1282 :     }
; 1283 : }

	ret	0
??$_Get_unwrapped@ABQAV?$resptr_core@UShader@@Uresptrcode_shader@@@@@std@@YA?A_TABQAV?$resptr_core@UShader@@Uresptrcode_shader@@@@@Z ENDP ; std::_Get_unwrapped<resptr_core<Shader,resptrcode_shader> * const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Uninitialized_move@PAUFSlideWindowItem@@V?$xalloc@UFSlideWindowItem@@@@@std@@YAPAUFSlideWindowItem@@QAU1@0PAU1@AAV?$xalloc@UFSlideWindowItem@@@@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Al$dead$ = 12						; size = 4
??$_Uninitialized_move@PAUFSlideWindowItem@@V?$xalloc@UFSlideWindowItem@@@@@std@@YAPAUFSlideWindowItem@@QAU1@0PAU1@AAV?$xalloc@UFSlideWindowItem@@@@@Z PROC ; std::_Uninitialized_move<FSlideWindowItem *,xalloc<FSlideWindowItem> >, COMDAT
; __First$ = ecx
; __Last$ = edx

; 1699 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

	push	esi

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	esi, DWORD PTR __Dest$[esp]

; 1699 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

	push	edi
	mov	edi, edx

; 1700 :     // move [_First, _Last) to raw _Dest, using _Al
; 1701 :     // note: only called internally from elsewhere in the STL
; 1702 :     using _Ptrval     = typename _Alloc::value_type*;
; 1703 :     auto _UFirst      = _Get_unwrapped(_First);
; 1704 :     const auto _ULast = _Get_unwrapped(_Last);
; 1705 :     if constexpr (conjunction_v<bool_constant<_Ptr_move_cat<decltype(_UFirst), _Ptrval>::_Really_trivial>,
; 1706 :                       _Uses_default_construct<_Alloc, _Ptrval, decltype(_STD move(*_UFirst))>>) {
; 1707 : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 1708 :         if (!_STD is_constant_evaluated())
; 1709 : #endif // __cpp_lib_constexpr_dynamic_alloc
; 1710 :         {
; 1711 :             _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));
; 1712 :             return _Dest + (_ULast - _UFirst);
; 1713 :         }
; 1714 :     }
; 1715 : 
; 1716 :     _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	ecx, edi
	je	SHORT $LN20@Uninitiali
	npad	4
$LL4@Uninitiali:
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [esi], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [esi+4], eax
	mov	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR [esi+8], eax
	mov	eax, DWORD PTR [ecx+12]
	mov	DWORD PTR [esi+12], eax
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR [esi+16], edx
	mov	edx, DWORD PTR [ecx+20]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1621 :         ++_Last;

	add	ecx, 24					; 00000018H
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	DWORD PTR [esi+20], edx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1621 :         ++_Last;

	add	esi, 24					; 00000018H

; 1700 :     // move [_First, _Last) to raw _Dest, using _Al
; 1701 :     // note: only called internally from elsewhere in the STL
; 1702 :     using _Ptrval     = typename _Alloc::value_type*;
; 1703 :     auto _UFirst      = _Get_unwrapped(_First);
; 1704 :     const auto _ULast = _Get_unwrapped(_Last);
; 1705 :     if constexpr (conjunction_v<bool_constant<_Ptr_move_cat<decltype(_UFirst), _Ptrval>::_Really_trivial>,
; 1706 :                       _Uses_default_construct<_Alloc, _Ptrval, decltype(_STD move(*_UFirst))>>) {
; 1707 : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 1708 :         if (!_STD is_constant_evaluated())
; 1709 : #endif // __cpp_lib_constexpr_dynamic_alloc
; 1710 :         {
; 1711 :             _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));
; 1712 :             return _Dest + (_ULast - _UFirst);
; 1713 :         }
; 1714 :     }
; 1715 : 
; 1716 :     _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	ecx, edi
	jne	SHORT $LL4@Uninitiali
$LN20@Uninitiali:
	pop	edi

; 1718 :         _Backout._Emplace_back(_STD move(*_UFirst));
; 1719 :     }
; 1720 : 
; 1721 :     return _Backout._Release();
; 1722 : }

	mov	eax, esi
	pop	esi
	ret	0
??$_Uninitialized_move@PAUFSlideWindowItem@@V?$xalloc@UFSlideWindowItem@@@@@std@@YAPAUFSlideWindowItem@@QAU1@0PAU1@AAV?$xalloc@UFSlideWindowItem@@@@@Z ENDP ; std::_Uninitialized_move<FSlideWindowItem *,xalloc<FSlideWindowItem> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_Get_unwrapped@ABQAUFSlideWindowItem@@@std@@YA?A_TABQAUFSlideWindowItem@@@Z
_TEXT	SEGMENT
??$_Get_unwrapped@ABQAUFSlideWindowItem@@@std@@YA?A_TABQAUFSlideWindowItem@@@Z PROC ; std::_Get_unwrapped<FSlideWindowItem * const &>, COMDAT
; __It$ = ecx

; 1275 :     // unwrap an iterator previously subjected to _Adl_verify_range or otherwise validated
; 1276 :     if constexpr (is_pointer_v<decay_t<_Iter>>) { // special-case pointers and arrays
; 1277 :         return _It + 0;

	mov	eax, DWORD PTR [ecx]

; 1278 :     } else if constexpr (_Unwrappable_v<_Iter>) {
; 1279 :         return static_cast<_Iter&&>(_It)._Unwrapped();
; 1280 :     } else {
; 1281 :         return static_cast<_Iter&&>(_It);
; 1282 :     }
; 1283 : }

	ret	0
??$_Get_unwrapped@ABQAUFSlideWindowItem@@@std@@YA?A_TABQAUFSlideWindowItem@@@Z ENDP ; std::_Get_unwrapped<FSlideWindowItem * const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Uninitialized_move@PAPAVIRender_Portal@@V?$xalloc@PAVIRender_Portal@@@@@std@@YAPAPAVIRender_Portal@@QAPAV1@0PAPAV1@AAV?$xalloc@PAVIRender_Portal@@@@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Al$dead$ = 12						; size = 4
??$_Uninitialized_move@PAPAVIRender_Portal@@V?$xalloc@PAVIRender_Portal@@@@@std@@YAPAPAVIRender_Portal@@QAPAV1@0PAPAV1@AAV?$xalloc@PAVIRender_Portal@@@@@Z PROC ; std::_Uninitialized_move<IRender_Portal * *,xalloc<IRender_Portal *> >, COMDAT
; __First$ = ecx
; __Last$ = edx

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	eax, DWORD PTR __Dest$[esp-4]

; 1699 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

	push	esi
	mov	esi, edx

; 1700 :     // move [_First, _Last) to raw _Dest, using _Al
; 1701 :     // note: only called internally from elsewhere in the STL
; 1702 :     using _Ptrval     = typename _Alloc::value_type*;
; 1703 :     auto _UFirst      = _Get_unwrapped(_First);
; 1704 :     const auto _ULast = _Get_unwrapped(_Last);
; 1705 :     if constexpr (conjunction_v<bool_constant<_Ptr_move_cat<decltype(_UFirst), _Ptrval>::_Really_trivial>,
; 1706 :                       _Uses_default_construct<_Alloc, _Ptrval, decltype(_STD move(*_UFirst))>>) {
; 1707 : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 1708 :         if (!_STD is_constant_evaluated())
; 1709 : #endif // __cpp_lib_constexpr_dynamic_alloc
; 1710 :         {
; 1711 :             _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));
; 1712 :             return _Dest + (_ULast - _UFirst);
; 1713 :         }
; 1714 :     }
; 1715 : 
; 1716 :     _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	ecx, esi
	je	SHORT $LN3@Uninitiali
	npad	5
$LL4@Uninitiali:

; 1620 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

	mov	edx, DWORD PTR [ecx]

; 1621 :         ++_Last;

	add	ecx, 4
	mov	DWORD PTR [eax], edx
	add	eax, 4

; 1700 :     // move [_First, _Last) to raw _Dest, using _Al
; 1701 :     // note: only called internally from elsewhere in the STL
; 1702 :     using _Ptrval     = typename _Alloc::value_type*;
; 1703 :     auto _UFirst      = _Get_unwrapped(_First);
; 1704 :     const auto _ULast = _Get_unwrapped(_Last);
; 1705 :     if constexpr (conjunction_v<bool_constant<_Ptr_move_cat<decltype(_UFirst), _Ptrval>::_Really_trivial>,
; 1706 :                       _Uses_default_construct<_Alloc, _Ptrval, decltype(_STD move(*_UFirst))>>) {
; 1707 : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 1708 :         if (!_STD is_constant_evaluated())
; 1709 : #endif // __cpp_lib_constexpr_dynamic_alloc
; 1710 :         {
; 1711 :             _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));
; 1712 :             return _Dest + (_ULast - _UFirst);
; 1713 :         }
; 1714 :     }
; 1715 : 
; 1716 :     _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	ecx, esi
	jne	SHORT $LL4@Uninitiali
$LN3@Uninitiali:
	pop	esi

; 1718 :         _Backout._Emplace_back(_STD move(*_UFirst));
; 1719 :     }
; 1720 : 
; 1721 :     return _Backout._Release();
; 1722 : }

	ret	0
??$_Uninitialized_move@PAPAVIRender_Portal@@V?$xalloc@PAVIRender_Portal@@@@@std@@YAPAPAVIRender_Portal@@QAPAV1@0PAPAV1@AAV?$xalloc@PAVIRender_Portal@@@@@Z ENDP ; std::_Uninitialized_move<IRender_Portal * *,xalloc<IRender_Portal *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_Get_unwrapped@ABQAPAVIRender_Portal@@@std@@YA?A_TABQAPAVIRender_Portal@@@Z
_TEXT	SEGMENT
??$_Get_unwrapped@ABQAPAVIRender_Portal@@@std@@YA?A_TABQAPAVIRender_Portal@@@Z PROC ; std::_Get_unwrapped<IRender_Portal * * const &>, COMDAT
; __It$ = ecx

; 1275 :     // unwrap an iterator previously subjected to _Adl_verify_range or otherwise validated
; 1276 :     if constexpr (is_pointer_v<decay_t<_Iter>>) { // special-case pointers and arrays
; 1277 :         return _It + 0;

	mov	eax, DWORD PTR [ecx]

; 1278 :     } else if constexpr (_Unwrappable_v<_Iter>) {
; 1279 :         return static_cast<_Iter&&>(_It)._Unwrapped();
; 1280 :     } else {
; 1281 :         return static_cast<_Iter&&>(_It);
; 1282 :     }
; 1283 : }

	ret	0
??$_Get_unwrapped@ABQAPAVIRender_Portal@@@std@@YA?A_TABQAPAVIRender_Portal@@@Z ENDP ; std::_Get_unwrapped<IRender_Portal * * const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$construct@PAUIDirect3DIndexBuffer9@@$$V@?$_Normal_allocator_traits@V?$xalloc@PAUIDirect3DIndexBuffer9@@@@@std@@SAXAAV?$xalloc@PAUIDirect3DIndexBuffer9@@@@PAPAUIDirect3DIndexBuffer9@@@Z
_TEXT	SEGMENT
??$construct@PAUIDirect3DIndexBuffer9@@$$V@?$_Normal_allocator_traits@V?$xalloc@PAUIDirect3DIndexBuffer9@@@@@std@@SAXAAV?$xalloc@PAUIDirect3DIndexBuffer9@@@@PAPAUIDirect3DIndexBuffer9@@@Z PROC ; std::_Normal_allocator_traits<xalloc<IDirect3DIndexBuffer9 *> >::construct<IDirect3DIndexBuffer9 *>, COMDAT
; __Al$dead$ = ecx
; __Ptr$ = edx

; 565  :         if constexpr (_Uses_default_construct<_Alloc, _Ty*, _Types...>::value) {
; 566  :             (void) _Al; // TRANSITION, DevCom-1004719
; 567  : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 568  :             _STD construct_at(_Ptr, _STD forward<_Types>(_Args)...);
; 569  : #else // __cpp_lib_constexpr_dynamic_alloc
; 570  :             ::new (static_cast<void*>(_Ptr)) _Ty(_STD forward<_Types>(_Args)...);

	mov	DWORD PTR [edx], 0

; 571  : #endif // __cpp_lib_constexpr_dynamic_alloc
; 572  :         } else {
; 573  :             _Al.construct(_Ptr, _STD forward<_Types>(_Args)...);
; 574  :         }
; 575  :     }

	ret	0
??$construct@PAUIDirect3DIndexBuffer9@@$$V@?$_Normal_allocator_traits@V?$xalloc@PAUIDirect3DIndexBuffer9@@@@@std@@SAXAAV?$xalloc@PAUIDirect3DIndexBuffer9@@@@PAPAUIDirect3DIndexBuffer9@@@Z ENDP ; std::_Normal_allocator_traits<xalloc<IDirect3DIndexBuffer9 *> >::construct<IDirect3DIndexBuffer9 *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$construct@PAUIDirect3DVertexBuffer9@@$$V@?$_Normal_allocator_traits@V?$xalloc@PAUIDirect3DVertexBuffer9@@@@@std@@SAXAAV?$xalloc@PAUIDirect3DVertexBuffer9@@@@PAPAUIDirect3DVertexBuffer9@@@Z
_TEXT	SEGMENT
??$construct@PAUIDirect3DVertexBuffer9@@$$V@?$_Normal_allocator_traits@V?$xalloc@PAUIDirect3DVertexBuffer9@@@@@std@@SAXAAV?$xalloc@PAUIDirect3DVertexBuffer9@@@@PAPAUIDirect3DVertexBuffer9@@@Z PROC ; std::_Normal_allocator_traits<xalloc<IDirect3DVertexBuffer9 *> >::construct<IDirect3DVertexBuffer9 *>, COMDAT
; __Al$dead$ = ecx
; __Ptr$ = edx

; 565  :         if constexpr (_Uses_default_construct<_Alloc, _Ty*, _Types...>::value) {
; 566  :             (void) _Al; // TRANSITION, DevCom-1004719
; 567  : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 568  :             _STD construct_at(_Ptr, _STD forward<_Types>(_Args)...);
; 569  : #else // __cpp_lib_constexpr_dynamic_alloc
; 570  :             ::new (static_cast<void*>(_Ptr)) _Ty(_STD forward<_Types>(_Args)...);

	mov	DWORD PTR [edx], 0

; 571  : #endif // __cpp_lib_constexpr_dynamic_alloc
; 572  :         } else {
; 573  :             _Al.construct(_Ptr, _STD forward<_Types>(_Args)...);
; 574  :         }
; 575  :     }

	ret	0
??$construct@PAUIDirect3DVertexBuffer9@@$$V@?$_Normal_allocator_traits@V?$xalloc@PAUIDirect3DVertexBuffer9@@@@@std@@SAXAAV?$xalloc@PAUIDirect3DVertexBuffer9@@@@PAPAUIDirect3DVertexBuffer9@@@Z ENDP ; std::_Normal_allocator_traits<xalloc<IDirect3DVertexBuffer9 *> >::construct<IDirect3DVertexBuffer9 *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\FixedVector.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$construct@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@$$V@?$_Normal_allocator_traits@V?$xalloc@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@@@std@@SAXAAV?$xalloc@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@@PAV?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@Z
_TEXT	SEGMENT
??$construct@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@$$V@?$_Normal_allocator_traits@V?$xalloc@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@@@std@@SAXAAV?$xalloc@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@@PAV?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@Z PROC ; std::_Normal_allocator_traits<xalloc<svector<_D3DVERTEXELEMENT9,65> > >::construct<svector<_D3DVERTEXELEMENT9,65> >, COMDAT
; __Al$dead$ = ecx
; __Ptr$ = edx
; File I:\Vitalya\mine\NSProjectX\xrCore\FixedVector.h

; 21   : 	svector() : count(0) 

	mov	DWORD PTR [edx+520], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 575  :     }

	ret	0
??$construct@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@$$V@?$_Normal_allocator_traits@V?$xalloc@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@@@std@@SAXAAV?$xalloc@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@@PAV?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@Z ENDP ; std::_Normal_allocator_traits<xalloc<svector<_D3DVERTEXELEMENT9,65> > >::construct<svector<_D3DVERTEXELEMENT9,65> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$construct@V?$resptr_core@UShader@@Uresptrcode_shader@@@@$$V@?$_Normal_allocator_traits@V?$xalloc@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@@@std@@SAXAAV?$xalloc@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@@PAV?$resptr_core@UShader@@Uresptrcode_shader@@@@@Z
_TEXT	SEGMENT
??$construct@V?$resptr_core@UShader@@Uresptrcode_shader@@@@$$V@?$_Normal_allocator_traits@V?$xalloc@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@@@std@@SAXAAV?$xalloc@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@@PAV?$resptr_core@UShader@@Uresptrcode_shader@@@@@Z PROC ; std::_Normal_allocator_traits<xalloc<resptr_core<Shader,resptrcode_shader> > >::construct<resptr_core<Shader,resptrcode_shader> >, COMDAT
; __Al$dead$ = ecx
; __Ptr$ = edx
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 61   : 						resptr_core		()												{	p_ = 0;						}

	mov	DWORD PTR [edx], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 575  :     }

	ret	0
??$construct@V?$resptr_core@UShader@@Uresptrcode_shader@@@@$$V@?$_Normal_allocator_traits@V?$xalloc@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@@@std@@SAXAAV?$xalloc@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@@PAV?$resptr_core@UShader@@Uresptrcode_shader@@@@@Z ENDP ; std::_Normal_allocator_traits<xalloc<resptr_core<Shader,resptrcode_shader> > >::construct<resptr_core<Shader,resptrcode_shader> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrEngine\Fmesh.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$construct@UFSlideWindowItem@@$$V@?$_Normal_allocator_traits@V?$xalloc@UFSlideWindowItem@@@@@std@@SAXAAV?$xalloc@UFSlideWindowItem@@@@PAUFSlideWindowItem@@@Z
_TEXT	SEGMENT
??$construct@UFSlideWindowItem@@$$V@?$_Normal_allocator_traits@V?$xalloc@UFSlideWindowItem@@@@@std@@SAXAAV?$xalloc@UFSlideWindowItem@@@@PAUFSlideWindowItem@@@Z PROC ; std::_Normal_allocator_traits<xalloc<FSlideWindowItem> >::construct<FSlideWindowItem>, COMDAT
; __Al$dead$ = ecx
; __Ptr$ = edx
; File I:\Vitalya\mine\NSProjectX\xrEngine\Fmesh.h

; 105  : 	FSlideWindowItem() : sw(0), count(0) {};

	mov	DWORD PTR [edx], 0
	mov	DWORD PTR [edx+4], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 575  :     }

	ret	0
??$construct@UFSlideWindowItem@@$$V@?$_Normal_allocator_traits@V?$xalloc@UFSlideWindowItem@@@@@std@@SAXAAV?$xalloc@UFSlideWindowItem@@@@PAUFSlideWindowItem@@@Z ENDP ; std::_Normal_allocator_traits<xalloc<FSlideWindowItem> >::construct<FSlideWindowItem>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$construct@PAVIRender_Portal@@$$V@?$_Normal_allocator_traits@V?$xalloc@PAVIRender_Portal@@@@@std@@SAXAAV?$xalloc@PAVIRender_Portal@@@@PAPAVIRender_Portal@@@Z
_TEXT	SEGMENT
??$construct@PAVIRender_Portal@@$$V@?$_Normal_allocator_traits@V?$xalloc@PAVIRender_Portal@@@@@std@@SAXAAV?$xalloc@PAVIRender_Portal@@@@PAPAVIRender_Portal@@@Z PROC ; std::_Normal_allocator_traits<xalloc<IRender_Portal *> >::construct<IRender_Portal *>, COMDAT
; __Al$dead$ = ecx
; __Ptr$ = edx

; 565  :         if constexpr (_Uses_default_construct<_Alloc, _Ty*, _Types...>::value) {
; 566  :             (void) _Al; // TRANSITION, DevCom-1004719
; 567  : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 568  :             _STD construct_at(_Ptr, _STD forward<_Types>(_Args)...);
; 569  : #else // __cpp_lib_constexpr_dynamic_alloc
; 570  :             ::new (static_cast<void*>(_Ptr)) _Ty(_STD forward<_Types>(_Args)...);

	mov	DWORD PTR [edx], 0

; 571  : #endif // __cpp_lib_constexpr_dynamic_alloc
; 572  :         } else {
; 573  :             _Al.construct(_Ptr, _STD forward<_Types>(_Args)...);
; 574  :         }
; 575  :     }

	ret	0
??$construct@PAVIRender_Portal@@$$V@?$_Normal_allocator_traits@V?$xalloc@PAVIRender_Portal@@@@@std@@SAXAAV?$xalloc@PAVIRender_Portal@@@@PAPAVIRender_Portal@@@Z ENDP ; std::_Normal_allocator_traits<xalloc<IRender_Portal *> >::construct<IRender_Portal *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\type_traits
;	COMDAT ??$move@AAPAUIDirect3DIndexBuffer9@@@std@@YA$$QAPAUIDirect3DIndexBuffer9@@AAPAU1@@Z
_TEXT	SEGMENT
??$move@AAPAUIDirect3DIndexBuffer9@@@std@@YA$$QAPAUIDirect3DIndexBuffer9@@AAPAU1@@Z PROC ; std::move<IDirect3DIndexBuffer9 * &>, COMDAT
; __Arg$ = ecx

; 1397 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

	mov	eax, ecx

; 1398 : }

	ret	0
??$move@AAPAUIDirect3DIndexBuffer9@@@std@@YA$$QAPAUIDirect3DIndexBuffer9@@AAPAU1@@Z ENDP ; std::move<IDirect3DIndexBuffer9 * &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Emplace_back@PAUIDirect3DIndexBuffer9@@@?$_Uninitialized_backout_al@V?$xalloc@PAUIDirect3DIndexBuffer9@@@@@std@@QAEX$$QAPAUIDirect3DIndexBuffer9@@@Z
_TEXT	SEGMENT
_<_Vals_0>$ = 8						; size = 4
??$_Emplace_back@PAUIDirect3DIndexBuffer9@@@?$_Uninitialized_backout_al@V?$xalloc@PAUIDirect3DIndexBuffer9@@@@@std@@QAEX$$QAPAUIDirect3DIndexBuffer9@@@Z PROC ; std::_Uninitialized_backout_al<xalloc<IDirect3DIndexBuffer9 *> >::_Emplace_back<IDirect3DIndexBuffer9 *>, COMDAT
; _this$ = ecx

; 1620 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _<_Vals_0>$[esp-4]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edx], eax

; 1621 :         ++_Last;

	add	DWORD PTR [ecx+4], 4

; 1622 :     }

	ret	4
??$_Emplace_back@PAUIDirect3DIndexBuffer9@@@?$_Uninitialized_backout_al@V?$xalloc@PAUIDirect3DIndexBuffer9@@@@@std@@QAEX$$QAPAUIDirect3DIndexBuffer9@@@Z ENDP ; std::_Uninitialized_backout_al<xalloc<IDirect3DIndexBuffer9 *> >::_Emplace_back<IDirect3DIndexBuffer9 *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\type_traits
;	COMDAT ??$move@AAPAUIDirect3DVertexBuffer9@@@std@@YA$$QAPAUIDirect3DVertexBuffer9@@AAPAU1@@Z
_TEXT	SEGMENT
??$move@AAPAUIDirect3DVertexBuffer9@@@std@@YA$$QAPAUIDirect3DVertexBuffer9@@AAPAU1@@Z PROC ; std::move<IDirect3DVertexBuffer9 * &>, COMDAT
; __Arg$ = ecx

; 1397 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

	mov	eax, ecx

; 1398 : }

	ret	0
??$move@AAPAUIDirect3DVertexBuffer9@@@std@@YA$$QAPAUIDirect3DVertexBuffer9@@AAPAU1@@Z ENDP ; std::move<IDirect3DVertexBuffer9 * &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Emplace_back@PAUIDirect3DVertexBuffer9@@@?$_Uninitialized_backout_al@V?$xalloc@PAUIDirect3DVertexBuffer9@@@@@std@@QAEX$$QAPAUIDirect3DVertexBuffer9@@@Z
_TEXT	SEGMENT
_<_Vals_0>$ = 8						; size = 4
??$_Emplace_back@PAUIDirect3DVertexBuffer9@@@?$_Uninitialized_backout_al@V?$xalloc@PAUIDirect3DVertexBuffer9@@@@@std@@QAEX$$QAPAUIDirect3DVertexBuffer9@@@Z PROC ; std::_Uninitialized_backout_al<xalloc<IDirect3DVertexBuffer9 *> >::_Emplace_back<IDirect3DVertexBuffer9 *>, COMDAT
; _this$ = ecx

; 1620 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _<_Vals_0>$[esp-4]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edx], eax

; 1621 :         ++_Last;

	add	DWORD PTR [ecx+4], 4

; 1622 :     }

	ret	4
??$_Emplace_back@PAUIDirect3DVertexBuffer9@@@?$_Uninitialized_backout_al@V?$xalloc@PAUIDirect3DVertexBuffer9@@@@@std@@QAEX$$QAPAUIDirect3DVertexBuffer9@@@Z ENDP ; std::_Uninitialized_backout_al<xalloc<IDirect3DVertexBuffer9 *> >::_Emplace_back<IDirect3DVertexBuffer9 *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\type_traits
;	COMDAT ??$move@AAV?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@std@@YA$$QAV?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@AAV1@@Z
_TEXT	SEGMENT
??$move@AAV?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@std@@YA$$QAV?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@AAV1@@Z PROC ; std::move<svector<_D3DVERTEXELEMENT9,65> &>, COMDAT
; __Arg$ = ecx

; 1397 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

	mov	eax, ecx

; 1398 : }

	ret	0
??$move@AAV?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@std@@YA$$QAV?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@AAV1@@Z ENDP ; std::move<svector<_D3DVERTEXELEMENT9,65> &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Emplace_back@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@?$_Uninitialized_backout_al@V?$xalloc@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@@@std@@QAEX$$QAV?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@Z
_TEXT	SEGMENT
_<_Vals_0>$ = 8						; size = 4
??$_Emplace_back@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@?$_Uninitialized_backout_al@V?$xalloc@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@@@std@@QAEX$$QAV?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@Z PROC ; std::_Uninitialized_backout_al<xalloc<svector<_D3DVERTEXELEMENT9,65> > >::_Emplace_back<svector<_D3DVERTEXELEMENT9,65> >, COMDAT
; _this$ = ecx

; 1619 :     _CONSTEXPR20_DYNALLOC void _Emplace_back(_Types&&... _Vals) { // construct a new element at *_Last and increment

	mov	eax, ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	ecx, 131				; 00000083H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1619 :     _CONSTEXPR20_DYNALLOC void _Emplace_back(_Types&&... _Vals) { // construct a new element at *_Last and increment

	push	esi
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	esi, DWORD PTR _<_Vals_0>$[esp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1619 :     _CONSTEXPR20_DYNALLOC void _Emplace_back(_Types&&... _Vals) { // construct a new element at *_Last and increment

	push	edi
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	edi, DWORD PTR [eax+4]
	rep movsd
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1621 :         ++_Last;

	add	DWORD PTR [eax+4], 524			; 0000020cH
	pop	edi
	pop	esi

; 1622 :     }

	ret	4
??$_Emplace_back@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@?$_Uninitialized_backout_al@V?$xalloc@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@@@std@@QAEX$$QAV?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@Z ENDP ; std::_Uninitialized_backout_al<xalloc<svector<_D3DVERTEXELEMENT9,65> > >::_Emplace_back<svector<_D3DVERTEXELEMENT9,65> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Emplace_back@AAV?$resptr_core@UShader@@Uresptrcode_shader@@@@@?$_Uninitialized_backout_al@V?$xalloc@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@@@std@@QAEXAAV?$resptr_core@UShader@@Uresptrcode_shader@@@@@Z
_TEXT	SEGMENT
_<_Vals_0>$ = 8						; size = 4
??$_Emplace_back@AAV?$resptr_core@UShader@@Uresptrcode_shader@@@@@?$_Uninitialized_backout_al@V?$xalloc@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@@@std@@QAEXAAV?$resptr_core@UShader@@Uresptrcode_shader@@@@@Z PROC ; std::_Uninitialized_backout_al<xalloc<resptr_core<Shader,resptrcode_shader> > >::_Emplace_back<resptr_core<Shader,resptrcode_shader> &>, COMDAT
; _this$ = ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 63   : 						resptr_core		(const self & rhs)								{	p_ = rhs.p_; _inc();		}

	mov	eax, DWORD PTR _<_Vals_0>$[esp-4]
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	edx, DWORD PTR [ecx+4]
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 63   : 						resptr_core		(const self & rhs)								{	p_ = rhs.p_; _inc();		}

	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edx], eax

; 43   : 	void				_inc	()									{	if (0==p_) return;	p_->dwReference++;														}

	test	eax, eax
	je	SHORT $LN12@Emplace_ba
	inc	DWORD PTR [eax]
$LN12@Emplace_ba:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1622 :     }

	add	DWORD PTR [ecx+4], 4
	ret	4
??$_Emplace_back@AAV?$resptr_core@UShader@@Uresptrcode_shader@@@@@?$_Uninitialized_backout_al@V?$xalloc@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@@@std@@QAEXAAV?$resptr_core@UShader@@Uresptrcode_shader@@@@@Z ENDP ; std::_Uninitialized_backout_al<xalloc<resptr_core<Shader,resptrcode_shader> > >::_Emplace_back<resptr_core<Shader,resptrcode_shader> &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Emplace_back@UFSlideWindowItem@@@?$_Uninitialized_backout_al@V?$xalloc@UFSlideWindowItem@@@@@std@@QAEX$$QAUFSlideWindowItem@@@Z
_TEXT	SEGMENT
_<_Vals_0>$ = 8						; size = 4
??$_Emplace_back@UFSlideWindowItem@@@?$_Uninitialized_backout_al@V?$xalloc@UFSlideWindowItem@@@@@std@@QAEX$$QAUFSlideWindowItem@@@Z PROC ; std::_Uninitialized_backout_al<xalloc<FSlideWindowItem> >::_Emplace_back<FSlideWindowItem>, COMDAT
; _this$ = ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	edx, DWORD PTR _<_Vals_0>$[esp-4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1619 :     _CONSTEXPR20_DYNALLOC void _Emplace_back(_Types&&... _Vals) { // construct a new element at *_Last and increment

	push	esi
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	esi, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [esi], eax
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [esi+4], eax
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR [esi+8], eax
	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR [esi+12], eax
	mov	eax, DWORD PTR [edx+16]
	mov	DWORD PTR [esi+16], eax
	mov	eax, DWORD PTR [edx+20]
	mov	DWORD PTR [esi+20], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1621 :         ++_Last;

	add	DWORD PTR [ecx+4], 24			; 00000018H
	pop	esi

; 1622 :     }

	ret	4
??$_Emplace_back@UFSlideWindowItem@@@?$_Uninitialized_backout_al@V?$xalloc@UFSlideWindowItem@@@@@std@@QAEX$$QAUFSlideWindowItem@@@Z ENDP ; std::_Uninitialized_backout_al<xalloc<FSlideWindowItem> >::_Emplace_back<FSlideWindowItem>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\type_traits
;	COMDAT ??$move@AAPAVIRender_Portal@@@std@@YA$$QAPAVIRender_Portal@@AAPAV1@@Z
_TEXT	SEGMENT
??$move@AAPAVIRender_Portal@@@std@@YA$$QAPAVIRender_Portal@@AAPAV1@@Z PROC ; std::move<IRender_Portal * &>, COMDAT
; __Arg$ = ecx

; 1397 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

	mov	eax, ecx

; 1398 : }

	ret	0
??$move@AAPAVIRender_Portal@@@std@@YA$$QAPAVIRender_Portal@@AAPAV1@@Z ENDP ; std::move<IRender_Portal * &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Emplace_back@PAVIRender_Portal@@@?$_Uninitialized_backout_al@V?$xalloc@PAVIRender_Portal@@@@@std@@QAEX$$QAPAVIRender_Portal@@@Z
_TEXT	SEGMENT
_<_Vals_0>$ = 8						; size = 4
??$_Emplace_back@PAVIRender_Portal@@@?$_Uninitialized_backout_al@V?$xalloc@PAVIRender_Portal@@@@@std@@QAEX$$QAPAVIRender_Portal@@@Z PROC ; std::_Uninitialized_backout_al<xalloc<IRender_Portal *> >::_Emplace_back<IRender_Portal *>, COMDAT
; _this$ = ecx

; 1620 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _<_Vals_0>$[esp-4]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edx], eax

; 1621 :         ++_Last;

	add	DWORD PTR [ecx+4], 4

; 1622 :     }

	ret	4
??$_Emplace_back@PAVIRender_Portal@@@?$_Uninitialized_backout_al@V?$xalloc@PAVIRender_Portal@@@@@std@@QAEX$$QAPAVIRender_Portal@@@Z ENDP ; std::_Uninitialized_backout_al<xalloc<IRender_Portal *> >::_Emplace_back<IRender_Portal *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\FixedVector.h
;	COMDAT ??0?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@QAE@XZ
_TEXT	SEGMENT
??0?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@QAE@XZ PROC	; svector<_D3DVERTEXELEMENT9,65>::svector<_D3DVERTEXELEMENT9,65>, COMDAT
; _this$ = ecx

; 21   : 	svector() : count(0) 

	mov	DWORD PTR [ecx+520], 0

; 22   : 	{}

	mov	eax, ecx
	ret	0
??0?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@QAE@XZ ENDP	; svector<_D3DVERTEXELEMENT9,65>::svector<_D3DVERTEXELEMENT9,65>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\type_traits
;	COMDAT ??$forward@PAUIDirect3DIndexBuffer9@@@std@@YA$$QAPAUIDirect3DIndexBuffer9@@AAPAU1@@Z
_TEXT	SEGMENT
??$forward@PAUIDirect3DIndexBuffer9@@@std@@YA$$QAPAUIDirect3DIndexBuffer9@@AAPAU1@@Z PROC ; std::forward<IDirect3DIndexBuffer9 *>, COMDAT
; __Arg$ = ecx

; 1386 :     return static_cast<_Ty&&>(_Arg);

	mov	eax, ecx

; 1387 : }

	ret	0
??$forward@PAUIDirect3DIndexBuffer9@@@std@@YA$$QAPAUIDirect3DIndexBuffer9@@AAPAU1@@Z ENDP ; std::forward<IDirect3DIndexBuffer9 *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$construct@PAUIDirect3DIndexBuffer9@@PAU1@@?$_Normal_allocator_traits@V?$xalloc@PAUIDirect3DIndexBuffer9@@@@@std@@SAXAAV?$xalloc@PAUIDirect3DIndexBuffer9@@@@PAPAUIDirect3DIndexBuffer9@@$$QAPAU3@@Z
_TEXT	SEGMENT
_<_Args_0>$ = 8						; size = 4
??$construct@PAUIDirect3DIndexBuffer9@@PAU1@@?$_Normal_allocator_traits@V?$xalloc@PAUIDirect3DIndexBuffer9@@@@@std@@SAXAAV?$xalloc@PAUIDirect3DIndexBuffer9@@@@PAPAUIDirect3DIndexBuffer9@@$$QAPAU3@@Z PROC ; std::_Normal_allocator_traits<xalloc<IDirect3DIndexBuffer9 *> >::construct<IDirect3DIndexBuffer9 *,IDirect3DIndexBuffer9 *>, COMDAT
; __Al$dead$ = ecx
; __Ptr$ = edx

; 565  :         if constexpr (_Uses_default_construct<_Alloc, _Ty*, _Types...>::value) {
; 566  :             (void) _Al; // TRANSITION, DevCom-1004719
; 567  : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 568  :             _STD construct_at(_Ptr, _STD forward<_Types>(_Args)...);
; 569  : #else // __cpp_lib_constexpr_dynamic_alloc
; 570  :             ::new (static_cast<void*>(_Ptr)) _Ty(_STD forward<_Types>(_Args)...);
; 571  : #endif // __cpp_lib_constexpr_dynamic_alloc
; 572  :         } else {
; 573  :             _Al.construct(_Ptr, _STD forward<_Types>(_Args)...);

	mov	eax, DWORD PTR _<_Args_0>$[esp-4]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edx], eax

; 574  :         }
; 575  :     }

	ret	0
??$construct@PAUIDirect3DIndexBuffer9@@PAU1@@?$_Normal_allocator_traits@V?$xalloc@PAUIDirect3DIndexBuffer9@@@@@std@@SAXAAV?$xalloc@PAUIDirect3DIndexBuffer9@@@@PAPAUIDirect3DIndexBuffer9@@$$QAPAU3@@Z ENDP ; std::_Normal_allocator_traits<xalloc<IDirect3DIndexBuffer9 *> >::construct<IDirect3DIndexBuffer9 *,IDirect3DIndexBuffer9 *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\type_traits
;	COMDAT ??$forward@PAUIDirect3DVertexBuffer9@@@std@@YA$$QAPAUIDirect3DVertexBuffer9@@AAPAU1@@Z
_TEXT	SEGMENT
??$forward@PAUIDirect3DVertexBuffer9@@@std@@YA$$QAPAUIDirect3DVertexBuffer9@@AAPAU1@@Z PROC ; std::forward<IDirect3DVertexBuffer9 *>, COMDAT
; __Arg$ = ecx

; 1386 :     return static_cast<_Ty&&>(_Arg);

	mov	eax, ecx

; 1387 : }

	ret	0
??$forward@PAUIDirect3DVertexBuffer9@@@std@@YA$$QAPAUIDirect3DVertexBuffer9@@AAPAU1@@Z ENDP ; std::forward<IDirect3DVertexBuffer9 *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$construct@PAUIDirect3DVertexBuffer9@@PAU1@@?$_Normal_allocator_traits@V?$xalloc@PAUIDirect3DVertexBuffer9@@@@@std@@SAXAAV?$xalloc@PAUIDirect3DVertexBuffer9@@@@PAPAUIDirect3DVertexBuffer9@@$$QAPAU3@@Z
_TEXT	SEGMENT
_<_Args_0>$ = 8						; size = 4
??$construct@PAUIDirect3DVertexBuffer9@@PAU1@@?$_Normal_allocator_traits@V?$xalloc@PAUIDirect3DVertexBuffer9@@@@@std@@SAXAAV?$xalloc@PAUIDirect3DVertexBuffer9@@@@PAPAUIDirect3DVertexBuffer9@@$$QAPAU3@@Z PROC ; std::_Normal_allocator_traits<xalloc<IDirect3DVertexBuffer9 *> >::construct<IDirect3DVertexBuffer9 *,IDirect3DVertexBuffer9 *>, COMDAT
; __Al$dead$ = ecx
; __Ptr$ = edx

; 565  :         if constexpr (_Uses_default_construct<_Alloc, _Ty*, _Types...>::value) {
; 566  :             (void) _Al; // TRANSITION, DevCom-1004719
; 567  : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 568  :             _STD construct_at(_Ptr, _STD forward<_Types>(_Args)...);
; 569  : #else // __cpp_lib_constexpr_dynamic_alloc
; 570  :             ::new (static_cast<void*>(_Ptr)) _Ty(_STD forward<_Types>(_Args)...);
; 571  : #endif // __cpp_lib_constexpr_dynamic_alloc
; 572  :         } else {
; 573  :             _Al.construct(_Ptr, _STD forward<_Types>(_Args)...);

	mov	eax, DWORD PTR _<_Args_0>$[esp-4]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edx], eax

; 574  :         }
; 575  :     }

	ret	0
??$construct@PAUIDirect3DVertexBuffer9@@PAU1@@?$_Normal_allocator_traits@V?$xalloc@PAUIDirect3DVertexBuffer9@@@@@std@@SAXAAV?$xalloc@PAUIDirect3DVertexBuffer9@@@@PAPAUIDirect3DVertexBuffer9@@$$QAPAU3@@Z ENDP ; std::_Normal_allocator_traits<xalloc<IDirect3DVertexBuffer9 *> >::construct<IDirect3DVertexBuffer9 *,IDirect3DVertexBuffer9 *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\type_traits
;	COMDAT ??$forward@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@std@@YA$$QAV?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@AAV1@@Z
_TEXT	SEGMENT
??$forward@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@std@@YA$$QAV?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@AAV1@@Z PROC ; std::forward<svector<_D3DVERTEXELEMENT9,65> >, COMDAT
; __Arg$ = ecx

; 1386 :     return static_cast<_Ty&&>(_Arg);

	mov	eax, ecx

; 1387 : }

	ret	0
??$forward@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@std@@YA$$QAV?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@AAV1@@Z ENDP ; std::forward<svector<_D3DVERTEXELEMENT9,65> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$construct@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@V1@@?$_Normal_allocator_traits@V?$xalloc@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@@@std@@SAXAAV?$xalloc@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@@PAV?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@$$QAV3@@Z
_TEXT	SEGMENT
_<_Args_0>$ = 8						; size = 4
??$construct@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@V1@@?$_Normal_allocator_traits@V?$xalloc@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@@@std@@SAXAAV?$xalloc@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@@PAV?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@$$QAV3@@Z PROC ; std::_Normal_allocator_traits<xalloc<svector<_D3DVERTEXELEMENT9,65> > >::construct<svector<_D3DVERTEXELEMENT9,65>,svector<_D3DVERTEXELEMENT9,65> >, COMDAT
; __Al$dead$ = ecx
; __Ptr$ = edx

; 564  :     static _CONSTEXPR20_DYNALLOC void construct(_Alloc& _Al, _Ty* _Ptr, _Types&&... _Args) {

	push	esi
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	esi, DWORD PTR _<_Args_0>$[esp]
	mov	ecx, 131				; 00000083H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 564  :     static _CONSTEXPR20_DYNALLOC void construct(_Alloc& _Al, _Ty* _Ptr, _Types&&... _Args) {

	push	edi
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	edi, edx
	rep movsd
	pop	edi
	pop	esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 575  :     }

	ret	0
??$construct@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@V1@@?$_Normal_allocator_traits@V?$xalloc@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@@@std@@SAXAAV?$xalloc@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@@PAV?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@$$QAV3@@Z ENDP ; std::_Normal_allocator_traits<xalloc<svector<_D3DVERTEXELEMENT9,65> > >::construct<svector<_D3DVERTEXELEMENT9,65>,svector<_D3DVERTEXELEMENT9,65> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\type_traits
;	COMDAT ??$forward@AAV?$resptr_core@UShader@@Uresptrcode_shader@@@@@std@@YAAAV?$resptr_core@UShader@@Uresptrcode_shader@@@@AAV1@@Z
_TEXT	SEGMENT
??$forward@AAV?$resptr_core@UShader@@Uresptrcode_shader@@@@@std@@YAAAV?$resptr_core@UShader@@Uresptrcode_shader@@@@AAV1@@Z PROC ; std::forward<resptr_core<Shader,resptrcode_shader> &>, COMDAT
; __Arg$ = ecx

; 1386 :     return static_cast<_Ty&&>(_Arg);

	mov	eax, ecx

; 1387 : }

	ret	0
??$forward@AAV?$resptr_core@UShader@@Uresptrcode_shader@@@@@std@@YAAAV?$resptr_core@UShader@@Uresptrcode_shader@@@@AAV1@@Z ENDP ; std::forward<resptr_core<Shader,resptrcode_shader> &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$construct@V?$resptr_core@UShader@@Uresptrcode_shader@@@@AAV1@@?$_Normal_allocator_traits@V?$xalloc@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@@@std@@SAXAAV?$xalloc@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@@PAV?$resptr_core@UShader@@Uresptrcode_shader@@@@AAV3@@Z
_TEXT	SEGMENT
_<_Args_0>$ = 8						; size = 4
??$construct@V?$resptr_core@UShader@@Uresptrcode_shader@@@@AAV1@@?$_Normal_allocator_traits@V?$xalloc@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@@@std@@SAXAAV?$xalloc@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@@PAV?$resptr_core@UShader@@Uresptrcode_shader@@@@AAV3@@Z PROC ; std::_Normal_allocator_traits<xalloc<resptr_core<Shader,resptrcode_shader> > >::construct<resptr_core<Shader,resptrcode_shader>,resptr_core<Shader,resptrcode_shader> &>, COMDAT
; __Al$dead$ = ecx
; __Ptr$ = edx
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 63   : 						resptr_core		(const self & rhs)								{	p_ = rhs.p_; _inc();		}

	mov	eax, DWORD PTR _<_Args_0>$[esp-4]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edx], eax

; 43   : 	void				_inc	()									{	if (0==p_) return;	p_->dwReference++;														}

	test	eax, eax
	je	SHORT $LN7@construct
	inc	DWORD PTR [eax]
$LN7@construct:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 575  :     }

	ret	0
??$construct@V?$resptr_core@UShader@@Uresptrcode_shader@@@@AAV1@@?$_Normal_allocator_traits@V?$xalloc@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@@@std@@SAXAAV?$xalloc@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@@PAV?$resptr_core@UShader@@Uresptrcode_shader@@@@AAV3@@Z ENDP ; std::_Normal_allocator_traits<xalloc<resptr_core<Shader,resptrcode_shader> > >::construct<resptr_core<Shader,resptrcode_shader>,resptr_core<Shader,resptrcode_shader> &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\type_traits
;	COMDAT ??$forward@UFSlideWindowItem@@@std@@YA$$QAUFSlideWindowItem@@AAU1@@Z
_TEXT	SEGMENT
??$forward@UFSlideWindowItem@@@std@@YA$$QAUFSlideWindowItem@@AAU1@@Z PROC ; std::forward<FSlideWindowItem>, COMDAT
; __Arg$ = ecx

; 1386 :     return static_cast<_Ty&&>(_Arg);

	mov	eax, ecx

; 1387 : }

	ret	0
??$forward@UFSlideWindowItem@@@std@@YA$$QAUFSlideWindowItem@@AAU1@@Z ENDP ; std::forward<FSlideWindowItem>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$construct@UFSlideWindowItem@@U1@@?$_Normal_allocator_traits@V?$xalloc@UFSlideWindowItem@@@@@std@@SAXAAV?$xalloc@UFSlideWindowItem@@@@PAUFSlideWindowItem@@$$QAU3@@Z
_TEXT	SEGMENT
_<_Args_0>$ = 8						; size = 4
??$construct@UFSlideWindowItem@@U1@@?$_Normal_allocator_traits@V?$xalloc@UFSlideWindowItem@@@@@std@@SAXAAV?$xalloc@UFSlideWindowItem@@@@PAUFSlideWindowItem@@$$QAU3@@Z PROC ; std::_Normal_allocator_traits<xalloc<FSlideWindowItem> >::construct<FSlideWindowItem,FSlideWindowItem>, COMDAT
; __Al$dead$ = ecx
; __Ptr$ = edx
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	ecx, DWORD PTR _<_Args_0>$[esp-4]
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], eax
	mov	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+8], eax
	mov	eax, DWORD PTR [ecx+12]
	mov	DWORD PTR [edx+12], eax
	mov	eax, DWORD PTR [ecx+16]
	mov	DWORD PTR [edx+16], eax
	mov	eax, DWORD PTR [ecx+20]
	mov	DWORD PTR [edx+20], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 575  :     }

	ret	0
??$construct@UFSlideWindowItem@@U1@@?$_Normal_allocator_traits@V?$xalloc@UFSlideWindowItem@@@@@std@@SAXAAV?$xalloc@UFSlideWindowItem@@@@PAUFSlideWindowItem@@$$QAU3@@Z ENDP ; std::_Normal_allocator_traits<xalloc<FSlideWindowItem> >::construct<FSlideWindowItem,FSlideWindowItem>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\type_traits
;	COMDAT ??$forward@PAVIRender_Portal@@@std@@YA$$QAPAVIRender_Portal@@AAPAV1@@Z
_TEXT	SEGMENT
??$forward@PAVIRender_Portal@@@std@@YA$$QAPAVIRender_Portal@@AAPAV1@@Z PROC ; std::forward<IRender_Portal *>, COMDAT
; __Arg$ = ecx

; 1386 :     return static_cast<_Ty&&>(_Arg);

	mov	eax, ecx

; 1387 : }

	ret	0
??$forward@PAVIRender_Portal@@@std@@YA$$QAPAVIRender_Portal@@AAPAV1@@Z ENDP ; std::forward<IRender_Portal *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$construct@PAVIRender_Portal@@PAV1@@?$_Normal_allocator_traits@V?$xalloc@PAVIRender_Portal@@@@@std@@SAXAAV?$xalloc@PAVIRender_Portal@@@@PAPAVIRender_Portal@@$$QAPAV3@@Z
_TEXT	SEGMENT
_<_Args_0>$ = 8						; size = 4
??$construct@PAVIRender_Portal@@PAV1@@?$_Normal_allocator_traits@V?$xalloc@PAVIRender_Portal@@@@@std@@SAXAAV?$xalloc@PAVIRender_Portal@@@@PAPAVIRender_Portal@@$$QAPAV3@@Z PROC ; std::_Normal_allocator_traits<xalloc<IRender_Portal *> >::construct<IRender_Portal *,IRender_Portal *>, COMDAT
; __Al$dead$ = ecx
; __Ptr$ = edx

; 565  :         if constexpr (_Uses_default_construct<_Alloc, _Ty*, _Types...>::value) {
; 566  :             (void) _Al; // TRANSITION, DevCom-1004719
; 567  : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 568  :             _STD construct_at(_Ptr, _STD forward<_Types>(_Args)...);
; 569  : #else // __cpp_lib_constexpr_dynamic_alloc
; 570  :             ::new (static_cast<void*>(_Ptr)) _Ty(_STD forward<_Types>(_Args)...);
; 571  : #endif // __cpp_lib_constexpr_dynamic_alloc
; 572  :         } else {
; 573  :             _Al.construct(_Ptr, _STD forward<_Types>(_Args)...);

	mov	eax, DWORD PTR _<_Args_0>$[esp-4]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edx], eax

; 574  :         }
; 575  :     }

	ret	0
??$construct@PAVIRender_Portal@@PAV1@@?$_Normal_allocator_traits@V?$xalloc@PAVIRender_Portal@@@@@std@@SAXAAV?$xalloc@PAVIRender_Portal@@@@PAPAVIRender_Portal@@$$QAPAV3@@Z ENDP ; std::_Normal_allocator_traits<xalloc<IRender_Portal *> >::construct<IRender_Portal *,IRender_Portal *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?construct@?$xalloc@PAUIDirect3DIndexBuffer9@@@@QAEXPAPAUIDirect3DIndexBuffer9@@ABQAU2@@Z
_TEXT	SEGMENT
_p$ = 8							; size = 4
__Val$ = 12						; size = 4
?construct@?$xalloc@PAUIDirect3DIndexBuffer9@@@@QAEXPAPAUIDirect3DIndexBuffer9@@ABQAU2@@Z PROC ; xalloc<IDirect3DIndexBuffer9 *>::construct, COMDAT
; _this$dead$ = ecx

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	eax, DWORD PTR __Val$[esp-4]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR _p$[esp-4]
	mov	DWORD PTR [eax], ecx
	ret	8
?construct@?$xalloc@PAUIDirect3DIndexBuffer9@@@@QAEXPAPAUIDirect3DIndexBuffer9@@ABQAU2@@Z ENDP ; xalloc<IDirect3DIndexBuffer9 *>::construct
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?construct@?$xalloc@PAUIDirect3DVertexBuffer9@@@@QAEXPAPAUIDirect3DVertexBuffer9@@ABQAU2@@Z
_TEXT	SEGMENT
_p$ = 8							; size = 4
__Val$ = 12						; size = 4
?construct@?$xalloc@PAUIDirect3DVertexBuffer9@@@@QAEXPAPAUIDirect3DVertexBuffer9@@ABQAU2@@Z PROC ; xalloc<IDirect3DVertexBuffer9 *>::construct, COMDAT
; _this$dead$ = ecx

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	eax, DWORD PTR __Val$[esp-4]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR _p$[esp-4]
	mov	DWORD PTR [eax], ecx
	ret	8
?construct@?$xalloc@PAUIDirect3DVertexBuffer9@@@@QAEXPAPAUIDirect3DVertexBuffer9@@ABQAU2@@Z ENDP ; xalloc<IDirect3DVertexBuffer9 *>::construct
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?construct@?$xalloc@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@@QAEXPAV?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@ABV2@@Z
_TEXT	SEGMENT
_p$ = 8							; size = 4
__Val$ = 12						; size = 4
?construct@?$xalloc@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@@QAEXPAV?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@ABV2@@Z PROC ; xalloc<svector<_D3DVERTEXELEMENT9,65> >::construct, COMDAT
; _this$dead$ = ecx

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	push	esi
	mov	esi, DWORD PTR __Val$[esp]
	mov	ecx, 131				; 00000083H
	push	edi
	mov	edi, DWORD PTR _p$[esp+4]
	rep movsd
	pop	edi
	pop	esi
	ret	8
?construct@?$xalloc@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@@QAEXPAV?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@ABV2@@Z ENDP ; xalloc<svector<_D3DVERTEXELEMENT9,65> >::construct
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?construct@?$xalloc@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@@QAEXPAV?$resptr_core@UShader@@Uresptrcode_shader@@@@ABV2@@Z
_TEXT	SEGMENT
_p$ = 8							; size = 4
__Val$ = 12						; size = 4
?construct@?$xalloc@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@@QAEXPAV?$resptr_core@UShader@@Uresptrcode_shader@@@@ABV2@@Z PROC ; xalloc<resptr_core<Shader,resptrcode_shader> >::construct, COMDAT
; _this$dead$ = ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 63   : 						resptr_core		(const self & rhs)								{	p_ = rhs.p_; _inc();		}

	mov	eax, DWORD PTR __Val$[esp-4]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR _p$[esp-4]
	mov	DWORD PTR [eax], ecx

; 43   : 	void				_inc	()									{	if (0==p_) return;	p_->dwReference++;														}

	test	ecx, ecx
	je	SHORT $LN5@construct
	inc	DWORD PTR [ecx]
$LN5@construct:
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	ret	8
?construct@?$xalloc@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@@QAEXPAV?$resptr_core@UShader@@Uresptrcode_shader@@@@ABV2@@Z ENDP ; xalloc<resptr_core<Shader,resptrcode_shader> >::construct
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?construct@?$xalloc@UFSlideWindowItem@@@@QAEXPAUFSlideWindowItem@@ABU2@@Z
_TEXT	SEGMENT
_p$ = 8							; size = 4
__Val$ = 12						; size = 4
?construct@?$xalloc@UFSlideWindowItem@@@@QAEXPAUFSlideWindowItem@@ABU2@@Z PROC ; xalloc<FSlideWindowItem>::construct, COMDAT
; _this$dead$ = ecx

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	edx, DWORD PTR __Val$[esp-4]
	mov	ecx, DWORD PTR _p$[esp-4]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+4], eax
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR [ecx+8], eax
	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR [ecx+12], eax
	mov	eax, DWORD PTR [edx+16]
	mov	DWORD PTR [ecx+16], eax
	mov	eax, DWORD PTR [edx+20]
	mov	DWORD PTR [ecx+20], eax
	ret	8
?construct@?$xalloc@UFSlideWindowItem@@@@QAEXPAUFSlideWindowItem@@ABU2@@Z ENDP ; xalloc<FSlideWindowItem>::construct
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?construct@?$xalloc@PAVIRender_Portal@@@@QAEXPAPAVIRender_Portal@@ABQAV2@@Z
_TEXT	SEGMENT
_p$ = 8							; size = 4
__Val$ = 12						; size = 4
?construct@?$xalloc@PAVIRender_Portal@@@@QAEXPAPAVIRender_Portal@@ABQAV2@@Z PROC ; xalloc<IRender_Portal *>::construct, COMDAT
; _this$dead$ = ecx

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	eax, DWORD PTR __Val$[esp-4]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR _p$[esp-4]
	mov	DWORD PTR [eax], ecx
	ret	8
?construct@?$xalloc@PAVIRender_Portal@@@@QAEXPAPAVIRender_Portal@@ABQAV2@@Z ENDP ; xalloc<IRender_Portal *>::construct
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ??0?$xalloc@PAVCPortal@@@@QAE@XZ
_TEXT	SEGMENT
??0?$xalloc@PAVCPortal@@@@QAE@XZ PROC			; xalloc<CPortal *>::xalloc<CPortal *>, COMDAT
; _this$ = ecx

; 76   : 													xalloc			()										{	}

	mov	eax, ecx
	ret	0
??0?$xalloc@PAVCPortal@@@@QAE@XZ ENDP			; xalloc<CPortal *>::xalloc<CPortal *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@PAVCPortal@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Vector_val@U?$_Simple_types@PAVCPortal@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<std::_Simple_types<CPortal *> >::_Vector_val<std::_Simple_types<CPortal *> >, COMDAT
; _this$ = ecx

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx], 0
	mov	eax, ecx
	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0
	ret	0
??0?$_Vector_val@U?$_Simple_types@PAVCPortal@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<std::_Simple_types<CPortal *> >::_Vector_val<std::_Simple_types<CPortal *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$?0$$V@?$_Compressed_pair@V?$xalloc@PAVCPortal@@@@V?$_Vector_val@U?$_Simple_types@PAVCPortal@@@std@@@std@@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$?0$$V@?$_Compressed_pair@V?$xalloc@PAVCPortal@@@@V?$_Vector_val@U?$_Simple_types@PAVCPortal@@@std@@@std@@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<xalloc<CPortal *>,std::_Vector_val<std::_Simple_types<CPortal *> >,1>::_Compressed_pair<xalloc<CPortal *>,std::_Vector_val<std::_Simple_types<CPortal *> >,1><>, COMDAT
; _this$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1331 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	eax, ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1331 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	ret	4
??$?0$$V@?$_Compressed_pair@V?$xalloc@PAVCPortal@@@@V?$_Vector_val@U?$_Simple_types@PAVCPortal@@@std@@@std@@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<xalloc<CPortal *>,std::_Vector_val<std::_Simple_types<CPortal *> >,1>::_Compressed_pair<xalloc<CPortal *>,std::_Vector_val<std::_Simple_types<CPortal *> >,1><>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0?$vector@PAVCPortal@@V?$xalloc@PAVCPortal@@@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@PAVCPortal@@V?$xalloc@PAVCPortal@@@@@std@@QAE@XZ PROC ; std::vector<CPortal *,xalloc<CPortal *> >::vector<CPortal *,xalloc<CPortal *> >, COMDAT
; _this$ = ecx

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx], 0

; 464  :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 465  :     }

	mov	eax, ecx

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0

; 464  :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 465  :     }

	ret	0
??0?$vector@PAVCPortal@@V?$xalloc@PAVCPortal@@@@@std@@QAE@XZ ENDP ; std::vector<CPortal *,xalloc<CPortal *> >::vector<CPortal *,xalloc<CPortal *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ??0?$xr_vector@PAVCPortal@@V?$xalloc@PAVCPortal@@@@@@QAE@XZ
_TEXT	SEGMENT
??0?$xr_vector@PAVCPortal@@V?$xalloc@PAVCPortal@@@@@@QAE@XZ PROC ; xr_vector<CPortal *,xalloc<CPortal *> >::xr_vector<CPortal *,xalloc<CPortal *> >, COMDAT
; _this$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx], 0
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 122  : 			xr_vector			()									: inherited	()					{}

	mov	eax, ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 122  : 			xr_vector			()									: inherited	()					{}

	ret	0
??0?$xr_vector@PAVCPortal@@V?$xalloc@PAVCPortal@@@@@@QAE@XZ ENDP ; xr_vector<CPortal *,xalloc<CPortal *> >::xr_vector<CPortal *,xalloc<CPortal *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ??0?$xalloc@VCFrustum@@@@QAE@XZ
_TEXT	SEGMENT
??0?$xalloc@VCFrustum@@@@QAE@XZ PROC			; xalloc<CFrustum>::xalloc<CFrustum>, COMDAT
; _this$ = ecx

; 76   : 													xalloc			()										{	}

	mov	eax, ecx
	ret	0
??0?$xalloc@VCFrustum@@@@QAE@XZ ENDP			; xalloc<CFrustum>::xalloc<CFrustum>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@VCFrustum@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Vector_val@U?$_Simple_types@VCFrustum@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<std::_Simple_types<CFrustum> >::_Vector_val<std::_Simple_types<CFrustum> >, COMDAT
; _this$ = ecx

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx], 0
	mov	eax, ecx
	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0
	ret	0
??0?$_Vector_val@U?$_Simple_types@VCFrustum@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<std::_Simple_types<CFrustum> >::_Vector_val<std::_Simple_types<CFrustum> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$?0$$V@?$_Compressed_pair@V?$xalloc@VCFrustum@@@@V?$_Vector_val@U?$_Simple_types@VCFrustum@@@std@@@std@@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$?0$$V@?$_Compressed_pair@V?$xalloc@VCFrustum@@@@V?$_Vector_val@U?$_Simple_types@VCFrustum@@@std@@@std@@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<xalloc<CFrustum>,std::_Vector_val<std::_Simple_types<CFrustum> >,1>::_Compressed_pair<xalloc<CFrustum>,std::_Vector_val<std::_Simple_types<CFrustum> >,1><>, COMDAT
; _this$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1331 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	eax, ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1331 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	ret	4
??$?0$$V@?$_Compressed_pair@V?$xalloc@VCFrustum@@@@V?$_Vector_val@U?$_Simple_types@VCFrustum@@@std@@@std@@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<xalloc<CFrustum>,std::_Vector_val<std::_Simple_types<CFrustum> >,1>::_Compressed_pair<xalloc<CFrustum>,std::_Vector_val<std::_Simple_types<CFrustum> >,1><>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0?$vector@VCFrustum@@V?$xalloc@VCFrustum@@@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@VCFrustum@@V?$xalloc@VCFrustum@@@@@std@@QAE@XZ PROC ; std::vector<CFrustum,xalloc<CFrustum> >::vector<CFrustum,xalloc<CFrustum> >, COMDAT
; _this$ = ecx

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx], 0

; 464  :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 465  :     }

	mov	eax, ecx

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0

; 464  :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 465  :     }

	ret	0
??0?$vector@VCFrustum@@V?$xalloc@VCFrustum@@@@@std@@QAE@XZ ENDP ; std::vector<CFrustum,xalloc<CFrustum> >::vector<CFrustum,xalloc<CFrustum> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ??0?$xr_vector@VCFrustum@@V?$xalloc@VCFrustum@@@@@@QAE@XZ
_TEXT	SEGMENT
??0?$xr_vector@VCFrustum@@V?$xalloc@VCFrustum@@@@@@QAE@XZ PROC ; xr_vector<CFrustum,xalloc<CFrustum> >::xr_vector<CFrustum,xalloc<CFrustum> >, COMDAT
; _this$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx], 0
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 122  : 			xr_vector			()									: inherited	()					{}

	mov	eax, ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 122  : 			xr_vector			()									: inherited	()					{}

	ret	0
??0?$xr_vector@VCFrustum@@V?$xalloc@VCFrustum@@@@@@QAE@XZ ENDP ; xr_vector<CFrustum,xalloc<CFrustum> >::xr_vector<CFrustum,xalloc<CFrustum> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ??0?$xalloc@U_scissor@@@@QAE@XZ
_TEXT	SEGMENT
??0?$xalloc@U_scissor@@@@QAE@XZ PROC			; xalloc<_scissor>::xalloc<_scissor>, COMDAT
; _this$ = ecx

; 76   : 													xalloc			()										{	}

	mov	eax, ecx
	ret	0
??0?$xalloc@U_scissor@@@@QAE@XZ ENDP			; xalloc<_scissor>::xalloc<_scissor>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@U_scissor@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Vector_val@U?$_Simple_types@U_scissor@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<std::_Simple_types<_scissor> >::_Vector_val<std::_Simple_types<_scissor> >, COMDAT
; _this$ = ecx

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx], 0
	mov	eax, ecx
	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0
	ret	0
??0?$_Vector_val@U?$_Simple_types@U_scissor@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<std::_Simple_types<_scissor> >::_Vector_val<std::_Simple_types<_scissor> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$?0$$V@?$_Compressed_pair@V?$xalloc@U_scissor@@@@V?$_Vector_val@U?$_Simple_types@U_scissor@@@std@@@std@@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$?0$$V@?$_Compressed_pair@V?$xalloc@U_scissor@@@@V?$_Vector_val@U?$_Simple_types@U_scissor@@@std@@@std@@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<xalloc<_scissor>,std::_Vector_val<std::_Simple_types<_scissor> >,1>::_Compressed_pair<xalloc<_scissor>,std::_Vector_val<std::_Simple_types<_scissor> >,1><>, COMDAT
; _this$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1331 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	eax, ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1331 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	ret	4
??$?0$$V@?$_Compressed_pair@V?$xalloc@U_scissor@@@@V?$_Vector_val@U?$_Simple_types@U_scissor@@@std@@@std@@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<xalloc<_scissor>,std::_Vector_val<std::_Simple_types<_scissor> >,1>::_Compressed_pair<xalloc<_scissor>,std::_Vector_val<std::_Simple_types<_scissor> >,1><>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0?$vector@U_scissor@@V?$xalloc@U_scissor@@@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@U_scissor@@V?$xalloc@U_scissor@@@@@std@@QAE@XZ PROC ; std::vector<_scissor,xalloc<_scissor> >::vector<_scissor,xalloc<_scissor> >, COMDAT
; _this$ = ecx

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx], 0

; 464  :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 465  :     }

	mov	eax, ecx

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0

; 464  :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 465  :     }

	ret	0
??0?$vector@U_scissor@@V?$xalloc@U_scissor@@@@@std@@QAE@XZ ENDP ; std::vector<_scissor,xalloc<_scissor> >::vector<_scissor,xalloc<_scissor> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ??0?$xr_vector@U_scissor@@V?$xalloc@U_scissor@@@@@@QAE@XZ
_TEXT	SEGMENT
??0?$xr_vector@U_scissor@@V?$xalloc@U_scissor@@@@@@QAE@XZ PROC ; xr_vector<_scissor,xalloc<_scissor> >::xr_vector<_scissor,xalloc<_scissor> >, COMDAT
; _this$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx], 0
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 122  : 			xr_vector			()									: inherited	()					{}

	mov	eax, ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 122  : 			xr_vector			()									: inherited	()					{}

	ret	0
??0?$xr_vector@U_scissor@@V?$xalloc@U_scissor@@@@@@QAE@XZ ENDP ; xr_vector<_scissor,xalloc<_scissor> >::xr_vector<_scissor,xalloc<_scissor> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__sector.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__sector.h
;	COMDAT ??0CSector@@QAE@XZ
_TEXT	SEGMENT
??0CSector@@QAE@XZ PROC					; CSector::CSector, COMDAT
; _this$ = ecx

; 67   : 	CSector							()				{ m_root = NULL;	}

	mov	DWORD PTR [ecx], OFFSET ??_7CSector@@6B@
	mov	eax, ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx+8], 0
	mov	DWORD PTR [ecx+12], 0
	mov	DWORD PTR [ecx+16], 0
	mov	DWORD PTR [ecx+20], 0
	mov	DWORD PTR [ecx+24], 0
	mov	DWORD PTR [ecx+28], 0
	mov	DWORD PTR [ecx+32], 0
	mov	DWORD PTR [ecx+36], 0
	mov	DWORD PTR [ecx+40], 0
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__sector.h

; 67   : 	CSector							()				{ m_root = NULL;	}

	mov	DWORD PTR [ecx+4], 0
	ret	0
??0CSector@@QAE@XZ ENDP					; CSector::CSector
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\string.h
;	COMDAT ?strchr@@YAPADQADH@Z
_TEXT	SEGMENT
?strchr@@YAPADQADH@Z PROC				; strchr, COMDAT
; __String$ = ecx
; __Ch$dead$ = edx

; 502  :         return const_cast<char*>(strchr(static_cast<char const*>(_String), _Ch));

	push	47					; 0000002fH
	push	ecx
	call	DWORD PTR __imp__strchr
	add	esp, 8

; 503  :     }

	ret	0
?strchr@@YAPADQADH@Z ENDP				; strchr
_TEXT	ENDS
END
