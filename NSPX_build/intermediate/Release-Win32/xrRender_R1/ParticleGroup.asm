; Listing generated by Microsoft (R) Optimizing Compiler Version 19.29.30146.0 

	TITLE	i:\vitalya\mine\nsprojectx\nspx_build\intermediate\release-win32\xrrender_r1\particlegroup.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	??_C@_0BB@EIBCOMD@PS?3?3CPGDef?3?3Load@		; `string'
PUBLIC	??_C@_0DN@BMEFJHKE@I?3?2Vitalya?2mine?2NSProjectX?2laye@ ; `string'
PUBLIC	??_C@_0CA@IGANCBFL@F?4find_chunk?$CIPGD_CHUNK_VERSION?$CJ@ ; `string'
PUBLIC	??_C@_0CG@FMBFHEJN@?$CBUnsupported?5PG?5version?4?5Load?5f@ ; `string'
PUBLIC	??_C@_0BN@CKGJAGHC@F?4find_chunk?$CIPGD_CHUNK_NAME?$CJ@ ; `string'
PUBLIC	??_C@_0CB@LFDJMMJL@F?4find_chunk?$CIPGD_CHUNK_EFFECTS2@ ; `string'
PUBLIC	??_C@_0DM@JNADIGEF@Can?8t?5use?5looped?5effect?5?8?$CFs?8?5as@ ; `string'
PUBLIC	??_C@_0CK@MIIKJOJA@PS?3?3CParticleGroup?3?3SItem?3?3Star@ ; `string'
PUBLIC	??_R2CParticleGroup@PS@@8			; PS::CParticleGroup::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CParticleGroup@PS@@8		; PS::CParticleGroup::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R3CParticleGroup@PS@@8			; PS::CParticleGroup::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R0?AVCParticleGroup@PS@@@8			; PS::CParticleGroup `RTTI Type Descriptor'
PUBLIC	??_C@_0BJ@DIJHBDKI@PS?3?3CParticleGroup?3?3Copy@ ; `string'
PUBLIC	??_C@_0DL@JMPOGBPO@I?3?2Vitalya?2mine?2NSProjectX?2laye@ ; `string'
PUBLIC	??_R4CParticleGroup@PS@@6B@			; PS::CParticleGroup::`RTTI Complete Object Locator'
PUBLIC	??_7CParticleGroup@PS@@6B@			; PS::CParticleGroup::`vftable'
;	COMDAT ?ignore_always@?BG@??Load@CPGDef@PS@@QAEHAAVIReader@@@Z@4_NA
_BSS	SEGMENT
?ignore_always@?BG@??Load@CPGDef@PS@@QAEHAAVIReader@@@Z@4_NA DB 01H DUP (?) ; `PS::CPGDef::Load'::`22'::ignore_always
_BSS	ENDS
;	COMDAT ?ignore_always@?L@??Load@CPGDef@PS@@QAEHAAVIReader@@@Z@4_NA
_BSS	SEGMENT
?ignore_always@?L@??Load@CPGDef@PS@@QAEHAAVIReader@@@Z@4_NA DB 01H DUP (?) ; `PS::CPGDef::Load'::`11'::ignore_always
_BSS	ENDS
;	COMDAT ?ignore_always@?3??Load@CPGDef@PS@@QAEHAAVIReader@@@Z@4_NA
_BSS	SEGMENT
?ignore_always@?3??Load@CPGDef@PS@@QAEHAAVIReader@@@Z@4_NA DB 01H DUP (?) ; `PS::CPGDef::Load'::`4'::ignore_always
_BSS	ENDS
;	COMDAT ??_7CParticleGroup@PS@@6B@
CONST	SEGMENT
??_7CParticleGroup@PS@@6B@ DD FLAT:??_R4CParticleGroup@PS@@6B@ ; PS::CParticleGroup::`vftable'
	DD	FLAT:?Render@IRender_Visual@@UAEXM@Z
	DD	FLAT:?Load@IRender_Visual@@UAEXPBDPAVIReader@@I@Z
	DD	FLAT:?Release@IRender_Visual@@UAEXXZ
	DD	FLAT:?Copy@CParticleGroup@PS@@UAEXPAVIRender_Visual@@@Z
	DD	FLAT:?Spawn@IRender_Visual@@UAEXXZ
	DD	FLAT:?Depart@IRender_Visual@@UAEXXZ
	DD	FLAT:?dcast_PKinematics@IRender_Visual@@UAEPAVCKinematics@@XZ
	DD	FLAT:?dcast_PKinematicsAnimated@IRender_Visual@@UAEPAVCKinematicsAnimated@@XZ
	DD	FLAT:?dcast_ParticleCustom@IParticleCustom@@UAEPAV1@XZ
	DD	FLAT:??_ECParticleGroup@PS@@UAEPAXI@Z
	DD	FLAT:?OnDeviceCreate@CParticleGroup@PS@@UAEXXZ
	DD	FLAT:?OnDeviceDestroy@CParticleGroup@PS@@UAEXXZ
	DD	FLAT:?UpdateParent@CParticleGroup@PS@@UAEXABU?$_matrix@M@@ABU?$_vector3@M@@H@Z
	DD	FLAT:?OnFrame@CParticleGroup@PS@@UAEXI@Z
	DD	FLAT:?Play@CParticleGroup@PS@@UAEXXZ
	DD	FLAT:?Stop@CParticleGroup@PS@@UAEXH@Z
	DD	FLAT:?IsPlaying@CParticleGroup@PS@@UAEHXZ
	DD	FLAT:?ParticlesCount@CParticleGroup@PS@@UAEIXZ
	DD	FLAT:?GetTimeLimit@CParticleGroup@PS@@UAEMXZ
	DD	FLAT:?IsLooped@IParticleCustom@@UAEHXZ
	DD	FLAT:?Name@CParticleGroup@PS@@UAE?BVshared_str@@XZ
CONST	ENDS
;	COMDAT ??_R4CParticleGroup@PS@@6B@
rdata$r	SEGMENT
??_R4CParticleGroup@PS@@6B@ DD 00H			; PS::CParticleGroup::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCParticleGroup@PS@@@8
	DD	FLAT:??_R3CParticleGroup@PS@@8
rdata$r	ENDS
;	COMDAT ??_C@_0DL@JMPOGBPO@I?3?2Vitalya?2mine?2NSProjectX?2laye@
CONST	SEGMENT
??_C@_0DL@JMPOGBPO@I?3?2Vitalya?2mine?2NSProjectX?2laye@ DB 'I:\Vitalya\m'
	DB	'ine\NSProjectX\layers\xrRender\ParticleGroup.h', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@DIJHBDKI@PS?3?3CParticleGroup?3?3Copy@
CONST	SEGMENT
??_C@_0BJ@DIJHBDKI@PS?3?3CParticleGroup?3?3Copy@ DB 'PS::CParticleGroup::'
	DB	'Copy', 00H					; `string'
CONST	ENDS
;	COMDAT ??_R0?AVCParticleGroup@PS@@@8
data$rs	SEGMENT
??_R0?AVCParticleGroup@PS@@@8 DD FLAT:??_7type_info@@6B@ ; PS::CParticleGroup `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCParticleGroup@PS@@', 00H
data$rs	ENDS
;	COMDAT ??_R3CParticleGroup@PS@@8
rdata$r	SEGMENT
??_R3CParticleGroup@PS@@8 DD 00H			; PS::CParticleGroup::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2CParticleGroup@PS@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@CParticleGroup@PS@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CParticleGroup@PS@@8 DD FLAT:??_R0?AVCParticleGroup@PS@@@8 ; PS::CParticleGroup::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CParticleGroup@PS@@8
rdata$r	ENDS
;	COMDAT ??_R2CParticleGroup@PS@@8
rdata$r	SEGMENT
??_R2CParticleGroup@PS@@8 DD FLAT:??_R1A@?0A@EA@CParticleGroup@PS@@8 ; PS::CParticleGroup::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@IParticleCustom@@8
	DD	FLAT:??_R1A@?0A@EA@IRender_Visual@@8
rdata$r	ENDS
;	COMDAT ??_C@_0CK@MIIKJOJA@PS?3?3CParticleGroup?3?3SItem?3?3Star@
CONST	SEGMENT
??_C@_0CK@MIIKJOJA@PS?3?3CParticleGroup?3?3SItem?3?3Star@ DB 'PS::CPartic'
	DB	'leGroup::SItem::StartFreeChild', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DM@JNADIGEF@Can?8t?5use?5looped?5effect?5?8?$CFs?8?5as@
CONST	SEGMENT
??_C@_0DM@JNADIGEF@Can?8t?5use?5looped?5effect?5?8?$CFs?8?5as@ DB 'Can''t'
	DB	' use looped effect ''%s'' as ''On Birth'' child for group.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@LFDJMMJL@F?4find_chunk?$CIPGD_CHUNK_EFFECTS2@
CONST	SEGMENT
??_C@_0CB@LFDJMMJL@F?4find_chunk?$CIPGD_CHUNK_EFFECTS2@ DB 'F.find_chunk('
	DB	'PGD_CHUNK_EFFECTS2)', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@CKGJAGHC@F?4find_chunk?$CIPGD_CHUNK_NAME?$CJ@
CONST	SEGMENT
??_C@_0BN@CKGJAGHC@F?4find_chunk?$CIPGD_CHUNK_NAME?$CJ@ DB 'F.find_chunk('
	DB	'PGD_CHUNK_NAME)', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@FMBFHEJN@?$CBUnsupported?5PG?5version?4?5Load?5f@
CONST	SEGMENT
??_C@_0CG@FMBFHEJN@?$CBUnsupported?5PG?5version?4?5Load?5f@ DB '!Unsuppor'
	DB	'ted PG version. Load failed.', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@IGANCBFL@F?4find_chunk?$CIPGD_CHUNK_VERSION?$CJ@
CONST	SEGMENT
??_C@_0CA@IGANCBFL@F?4find_chunk?$CIPGD_CHUNK_VERSION?$CJ@ DB 'F.find_chu'
	DB	'nk(PGD_CHUNK_VERSION)', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DN@BMEFJHKE@I?3?2Vitalya?2mine?2NSProjectX?2laye@
CONST	SEGMENT
??_C@_0DN@BMEFJHKE@I?3?2Vitalya?2mine?2NSProjectX?2laye@ DB 'I:\Vitalya\m'
	DB	'ine\NSProjectX\layers\xrRender\ParticleGroup.cpp', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@EIBCOMD@PS?3?3CPGDef?3?3Load@
CONST	SEGMENT
??_C@_0BB@EIBCOMD@PS?3?3CPGDef?3?3Load@ DB 'PS::CPGDef::Load', 00H ; `string'
?_Fake_alloc@std@@3U_Fake_allocator@1@B	ORG $+1		; std::_Fake_alloc
PUBLIC	?size@shared_str@@QBEIXZ			; shared_str::size
PUBLIC	?GetVisuals@SItem@CParticleGroup@PS@@QAEIAAV?$xr_vector@PAVIRender_Visual@@V?$xalloc@PAVIRender_Visual@@@@@@@Z ; PS::CParticleGroup::SItem::GetVisuals
PUBLIC	?end@?$vector@PAVIRender_Visual@@V?$xalloc@PAVIRender_Visual@@@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVIRender_Visual@@@std@@@std@@@2@XZ ; std::vector<IRender_Visual *,xalloc<IRender_Visual *> >::end
PUBLIC	??$insert@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVIRender_Visual@@@std@@@std@@@std@@$0A@@?$vector@PAVIRender_Visual@@V?$xalloc@PAVIRender_Visual@@@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVIRender_Visual@@@std@@@std@@@1@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVIRender_Visual@@@std@@@std@@@1@V21@1@Z ; std::vector<IRender_Visual *,xalloc<IRender_Visual *> >::insert<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<IRender_Visual *> > >,0>
PUBLIC	?_Make_iterator_offset@?$vector@PAVIRender_Visual@@V?$xalloc@PAVIRender_Visual@@@@@std@@AAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVIRender_Visual@@@std@@@std@@@2@I@Z ; std::vector<IRender_Visual *,xalloc<IRender_Visual *> >::_Make_iterator_offset
PUBLIC	??$_Get_unwrapped@AAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVIRender_Visual@@@std@@@std@@@std@@@std@@YA?A_TAAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVIRender_Visual@@@std@@@std@@@0@@Z ; std::_Get_unwrapped<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<IRender_Visual *> > > &>
PUBLIC	?_Unwrapped@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVIRender_Visual@@@std@@@std@@@std@@QBEPAPAVIRender_Visual@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<IRender_Visual *> > >::_Unwrapped
PUBLIC	??$_Insert_range@PAPAVIRender_Visual@@@?$vector@PAVIRender_Visual@@V?$xalloc@PAVIRender_Visual@@@@@std@@AAEXV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVIRender_Visual@@@std@@@std@@@1@PAPAVIRender_Visual@@1Uforward_iterator_tag@1@@Z ; std::vector<IRender_Visual *,xalloc<IRender_Visual *> >::_Insert_range<IRender_Visual * *>
PUBLIC	??$_Ucopy@PAPAVIRender_Visual@@@?$vector@PAVIRender_Visual@@V?$xalloc@PAVIRender_Visual@@@@@std@@AAEPAPAVIRender_Visual@@PAPAV2@00@Z ; std::vector<IRender_Visual *,xalloc<IRender_Visual *> >::_Ucopy<IRender_Visual * *>
PUBLIC	??$_Uninitialized_copy@PAPAVIRender_Visual@@V?$xalloc@PAVIRender_Visual@@@@@std@@YAPAPAVIRender_Visual@@QAPAV1@0PAPAV1@AAV?$xalloc@PAVIRender_Visual@@@@@Z ; std::_Uninitialized_copy<IRender_Visual * *,xalloc<IRender_Visual *> >
PUBLIC	??$_Emplace_back@AAPAVIRender_Visual@@@?$_Uninitialized_backout_al@V?$xalloc@PAVIRender_Visual@@@@@std@@QAEXAAPAVIRender_Visual@@@Z ; std::_Uninitialized_backout_al<xalloc<IRender_Visual *> >::_Emplace_back<IRender_Visual * &>
PUBLIC	??$construct@PAVIRender_Visual@@AAPAV1@@?$_Normal_allocator_traits@V?$xalloc@PAVIRender_Visual@@@@@std@@SAXAAV?$xalloc@PAVIRender_Visual@@@@PAPAVIRender_Visual@@AAPAV3@@Z ; std::_Normal_allocator_traits<xalloc<IRender_Visual *> >::construct<IRender_Visual *,IRender_Visual * &>
PUBLIC	??$_Move_unchecked@PAPAVIRender_Visual@@PAPAV1@@std@@YAPAPAVIRender_Visual@@PAPAV1@00@Z ; std::_Move_unchecked<IRender_Visual * *,IRender_Visual * *>
PUBLIC	??$_Copy_memmove@PAPAVIRender_Visual@@PAPAV1@@std@@YAPAPAVIRender_Visual@@PAPAV1@00@Z ; std::_Copy_memmove<IRender_Visual * *,IRender_Visual * *>
PUBLIC	??$_To_address@PAPAVIRender_Visual@@@std@@YA?A_PABQAPAVIRender_Visual@@@Z ; std::_To_address<IRender_Visual * *>
PUBLIC	??$_Move_backward_unchecked@PAPAVIRender_Visual@@PAPAV1@@std@@YAPAPAVIRender_Visual@@PAPAV1@00@Z ; std::_Move_backward_unchecked<IRender_Visual * *,IRender_Visual * *>
PUBLIC	??$_Copy_backward_memmove@PAPAVIRender_Visual@@PAPAV1@@std@@YAPAPAVIRender_Visual@@PAPAV1@00@Z ; std::_Copy_backward_memmove<IRender_Visual * *,IRender_Visual * *>
PUBLIC	??$distance@PAPAVIRender_Visual@@@std@@YAHPAPAVIRender_Visual@@0@Z ; std::distance<IRender_Visual * *>
PUBLIC	??$_Adl_verify_range@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVIRender_Visual@@@std@@@std@@@std@@V12@@std@@YAXABV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVIRender_Visual@@@std@@@std@@@0@0@Z ; std::_Adl_verify_range<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<IRender_Visual *> > >,std::_Vector_iterator<std::_Vector_val<std::_Simple_types<IRender_Visual *> > > >
PUBLIC	?reserve@?$vector@PAVIRender_Visual@@V?$xalloc@PAVIRender_Visual@@@@@std@@QAEXI@Z ; std::vector<IRender_Visual *,xalloc<IRender_Visual *> >::reserve
PUBLIC	?_Reallocate_exactly@?$vector@PAVIRender_Visual@@V?$xalloc@PAVIRender_Visual@@@@@std@@AAEXI@Z ; std::vector<IRender_Visual *,xalloc<IRender_Visual *> >::_Reallocate_exactly
PUBLIC	?GetDefinition@CParticleGroup@PS@@QAEPBVCPGDef@2@XZ ; PS::CParticleGroup::GetDefinition
PUBLIC	?GetHandleEffect@CParticleEffect@PS@@QAEHXZ	; PS::CParticleEffect::GetHandleEffect
PUBLIC	?translate@?$_matrix@M@@QAEAAU1@ABU?$_vector3@M@@@Z ; _matrix<float>::translate
PUBLIC	??0SEffect@CPGDef@PS@@QAE@XZ			; PS::CPGDef::SEffect::SEffect
PUBLIC	?Copy@CParticleGroup@PS@@UAEXPAVIRender_Visual@@@Z ; PS::CParticleGroup::Copy
PUBLIC	?IsPlaying@CParticleGroup@PS@@UAEHXZ		; PS::CParticleGroup::IsPlaying
PUBLIC	?GetTimeLimit@CParticleGroup@PS@@UAEMXZ		; PS::CParticleGroup::GetTimeLimit
PUBLIC	?Name@CParticleGroup@PS@@UAE?BVshared_str@@XZ	; PS::CParticleGroup::Name
PUBLIC	??$forward@V?$xalloc@PAVIRender_Visual@@@@@std@@YA$$QAV?$xalloc@PAVIRender_Visual@@@@AAV1@@Z ; std::forward<xalloc<IRender_Visual *> >
PUBLIC	??$?0V?$xalloc@PAVIRender_Visual@@@@$$V@?$_Compressed_pair@V?$xalloc@PAVIRender_Visual@@@@V?$_Vector_val@U?$_Simple_types@PAVIRender_Visual@@@std@@@std@@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAV?$xalloc@PAVIRender_Visual@@@@@Z ; std::_Compressed_pair<xalloc<IRender_Visual *>,std::_Vector_val<std::_Simple_types<IRender_Visual *> >,1>::_Compressed_pair<xalloc<IRender_Visual *>,std::_Vector_val<std::_Simple_types<IRender_Visual *> >,1><xalloc<IRender_Visual *> >
PUBLIC	??0?$xalloc@PAVIRender_Visual@@@@QAE@ABV0@@Z	; xalloc<IRender_Visual *>::xalloc<IRender_Visual *>
PUBLIC	?select_on_container_copy_construction@?$_Normal_allocator_traits@V?$xalloc@PAVIRender_Visual@@@@@std@@SA?AV?$xalloc@PAVIRender_Visual@@@@ABV3@@Z ; std::_Normal_allocator_traits<xalloc<IRender_Visual *> >::select_on_container_copy_construction
PUBLIC	?_Buy_raw@?$vector@PAVIRender_Visual@@V?$xalloc@PAVIRender_Visual@@@@@std@@AAEXI@Z ; std::vector<IRender_Visual *,xalloc<IRender_Visual *> >::_Buy_raw
PUBLIC	??1?$_Tidy_guard@V?$vector@PAVIRender_Visual@@V?$xalloc@PAVIRender_Visual@@@@@std@@@std@@QAE@XZ ; std::_Tidy_guard<std::vector<IRender_Visual *,xalloc<IRender_Visual *> > >::~_Tidy_guard<std::vector<IRender_Visual *,xalloc<IRender_Visual *> > >
PUBLIC	??0?$vector@PAVIRender_Visual@@V?$xalloc@PAVIRender_Visual@@@@@std@@QAE@ABV01@@Z ; std::vector<IRender_Visual *,xalloc<IRender_Visual *> >::vector<IRender_Visual *,xalloc<IRender_Visual *> >
PUBLIC	??0?$xr_vector@PAVIRender_Visual@@V?$xalloc@PAVIRender_Visual@@@@@@QAE@ABV0@@Z ; xr_vector<IRender_Visual *,xalloc<IRender_Visual *> >::xr_vector<IRender_Visual *,xalloc<IRender_Visual *> >
PUBLIC	??0SItem@CParticleGroup@PS@@QAE@ABU012@@Z	; PS::CParticleGroup::SItem::SItem
PUBLIC	?construct@?$xalloc@PAUSEffect@CPGDef@PS@@@@QAEXPAPAUSEffect@CPGDef@PS@@ABQAU234@@Z ; xalloc<PS::CPGDef::SEffect *>::construct
PUBLIC	?construct@?$xalloc@USItem@CParticleGroup@PS@@@@QAEXPAUSItem@CParticleGroup@PS@@ABU234@@Z ; xalloc<PS::CParticleGroup::SItem>::construct
PUBLIC	??$construct@PAUSEffect@CPGDef@PS@@PAU123@@?$_Normal_allocator_traits@V?$xalloc@PAUSEffect@CPGDef@PS@@@@@std@@SAXAAV?$xalloc@PAUSEffect@CPGDef@PS@@@@PAPAUSEffect@CPGDef@PS@@$$QAPAU345@@Z ; std::_Normal_allocator_traits<xalloc<PS::CPGDef::SEffect *> >::construct<PS::CPGDef::SEffect *,PS::CPGDef::SEffect *>
PUBLIC	??$forward@PAUSEffect@CPGDef@PS@@@std@@YA$$QAPAUSEffect@CPGDef@PS@@AAPAU123@@Z ; std::forward<PS::CPGDef::SEffect *>
PUBLIC	??$construct@USItem@CParticleGroup@PS@@U123@@?$_Normal_allocator_traits@V?$xalloc@USItem@CParticleGroup@PS@@@@@std@@SAXAAV?$xalloc@USItem@CParticleGroup@PS@@@@PAUSItem@CParticleGroup@PS@@$$QAU345@@Z ; std::_Normal_allocator_traits<xalloc<PS::CParticleGroup::SItem> >::construct<PS::CParticleGroup::SItem,PS::CParticleGroup::SItem>
PUBLIC	??$forward@USItem@CParticleGroup@PS@@@std@@YA$$QAUSItem@CParticleGroup@PS@@AAU123@@Z ; std::forward<PS::CParticleGroup::SItem>
PUBLIC	??0SItem@CParticleGroup@PS@@QAE@XZ		; PS::CParticleGroup::SItem::SItem
PUBLIC	??$_Emplace_back@PAUSEffect@CPGDef@PS@@@?$_Uninitialized_backout_al@V?$xalloc@PAUSEffect@CPGDef@PS@@@@@std@@QAEX$$QAPAUSEffect@CPGDef@PS@@@Z ; std::_Uninitialized_backout_al<xalloc<PS::CPGDef::SEffect *> >::_Emplace_back<PS::CPGDef::SEffect *>
PUBLIC	??$move@AAPAUSEffect@CPGDef@PS@@@std@@YA$$QAPAUSEffect@CPGDef@PS@@AAPAU123@@Z ; std::move<PS::CPGDef::SEffect * &>
PUBLIC	??$_Emplace_back@USItem@CParticleGroup@PS@@@?$_Uninitialized_backout_al@V?$xalloc@USItem@CParticleGroup@PS@@@@@std@@QAEX$$QAUSItem@CParticleGroup@PS@@@Z ; std::_Uninitialized_backout_al<xalloc<PS::CParticleGroup::SItem> >::_Emplace_back<PS::CParticleGroup::SItem>
PUBLIC	??$move@AAUSItem@CParticleGroup@PS@@@std@@YA$$QAUSItem@CParticleGroup@PS@@AAU123@@Z ; std::move<PS::CParticleGroup::SItem &>
PUBLIC	??$construct@PAUSEffect@CPGDef@PS@@$$V@?$_Normal_allocator_traits@V?$xalloc@PAUSEffect@CPGDef@PS@@@@@std@@SAXAAV?$xalloc@PAUSEffect@CPGDef@PS@@@@PAPAUSEffect@CPGDef@PS@@@Z ; std::_Normal_allocator_traits<xalloc<PS::CPGDef::SEffect *> >::construct<PS::CPGDef::SEffect *>
PUBLIC	??$construct@USItem@CParticleGroup@PS@@$$V@?$_Normal_allocator_traits@V?$xalloc@USItem@CParticleGroup@PS@@@@@std@@SAXAAV?$xalloc@USItem@CParticleGroup@PS@@@@PAUSItem@CParticleGroup@PS@@@Z ; std::_Normal_allocator_traits<xalloc<PS::CParticleGroup::SItem> >::construct<PS::CParticleGroup::SItem>
PUBLIC	??$_Get_unwrapped@ABQAPAUSEffect@CPGDef@PS@@@std@@YA?A_TABQAPAUSEffect@CPGDef@PS@@@Z ; std::_Get_unwrapped<PS::CPGDef::SEffect * * const &>
PUBLIC	??$_Uninitialized_move@PAPAUSEffect@CPGDef@PS@@V?$xalloc@PAUSEffect@CPGDef@PS@@@@@std@@YAPAPAUSEffect@CPGDef@PS@@QAPAU123@0PAPAU123@AAV?$xalloc@PAUSEffect@CPGDef@PS@@@@@Z ; std::_Uninitialized_move<PS::CPGDef::SEffect * *,xalloc<PS::CPGDef::SEffect *> >
PUBLIC	??$_Get_unwrapped@ABQAUSItem@CParticleGroup@PS@@@std@@YA?A_TABQAUSItem@CParticleGroup@PS@@@Z ; std::_Get_unwrapped<PS::CParticleGroup::SItem * const &>
PUBLIC	??$_Uninitialized_move@PAUSItem@CParticleGroup@PS@@V?$xalloc@USItem@CParticleGroup@PS@@@@@std@@YAPAUSItem@CParticleGroup@PS@@QAU123@0PAU123@AAV?$xalloc@USItem@CParticleGroup@PS@@@@@Z ; std::_Uninitialized_move<PS::CParticleGroup::SItem *,xalloc<PS::CParticleGroup::SItem> >
PUBLIC	??$xr_alloc@PAUSEffect@CPGDef@PS@@@@YAPAPAUSEffect@CPGDef@PS@@I@Z ; xr_alloc<PS::CPGDef::SEffect *>
PUBLIC	??$_Destroy_in_place@PAPAUSEffect@CPGDef@PS@@@std@@YAXAAPAPAUSEffect@CPGDef@PS@@@Z ; std::_Destroy_in_place<PS::CPGDef::SEffect * *>
PUBLIC	??$xr_alloc@USItem@CParticleGroup@PS@@@@YAPAUSItem@CParticleGroup@PS@@I@Z ; xr_alloc<PS::CParticleGroup::SItem>
PUBLIC	??$_Destroy_in_place@PAUSItem@CParticleGroup@PS@@@std@@YAXAAPAUSItem@CParticleGroup@PS@@@Z ; std::_Destroy_in_place<PS::CParticleGroup::SItem *>
PUBLIC	??$_Refancy@PAPAVIRender_Visual@@$0A@@std@@YAPAPAVIRender_Visual@@PAPAV1@@Z ; std::_Refancy<IRender_Visual * *,0>
PUBLIC	??$_Emplace_back@$$V@?$_Uninitialized_backout_al@V?$xalloc@PAUSEffect@CPGDef@PS@@@@@std@@QAEXXZ ; std::_Uninitialized_backout_al<xalloc<PS::CPGDef::SEffect *> >::_Emplace_back<>
PUBLIC	??$_To_address@PAPAUSEffect@CPGDef@PS@@@std@@YA?A_PABQAPAUSEffect@CPGDef@PS@@@Z ; std::_To_address<PS::CPGDef::SEffect * *>
PUBLIC	??$_Zero_range@PAPAUSEffect@CPGDef@PS@@@std@@YAPAPAUSEffect@CPGDef@PS@@QAPAU123@0@Z ; std::_Zero_range<PS::CPGDef::SEffect * *>
PUBLIC	??$_Emplace_back@$$V@?$_Uninitialized_backout_al@V?$xalloc@USItem@CParticleGroup@PS@@@@@std@@QAEXXZ ; std::_Uninitialized_backout_al<xalloc<PS::CParticleGroup::SItem> >::_Emplace_back<>
PUBLIC	??$forward@AAPAPAVIRender_Visual@@@std@@YAAAPAPAVIRender_Visual@@AAPAPAV1@@Z ; std::forward<IRender_Visual * * &>
PUBLIC	??$_Seek_wrapped@PAPAVIRender_Visual@@AAPAPAV1@@std@@YAXAAPAPAVIRender_Visual@@0@Z ; std::_Seek_wrapped<IRender_Visual * *,IRender_Visual * * &>
PUBLIC	??$_Adl_verify_range@PAPAVIRender_Visual@@PAPAV1@@std@@YAXABQAPAVIRender_Visual@@0@Z ; std::_Adl_verify_range<IRender_Visual * *,IRender_Visual * *>
PUBLIC	?max_size@?$xalloc@PAUSEffect@CPGDef@PS@@@@QBEIXZ ; xalloc<PS::CPGDef::SEffect *>::max_size
PUBLIC	?_Get_first@?$_Compressed_pair@V?$xalloc@PAUSEffect@CPGDef@PS@@@@V?$_Vector_val@U?$_Simple_types@PAUSEffect@CPGDef@PS@@@std@@@std@@$00@std@@QBEABV?$xalloc@PAUSEffect@CPGDef@PS@@@@XZ ; std::_Compressed_pair<xalloc<PS::CPGDef::SEffect *>,std::_Vector_val<std::_Simple_types<PS::CPGDef::SEffect *> >,1>::_Get_first
PUBLIC	?max_size@?$xalloc@USItem@CParticleGroup@PS@@@@QBEIXZ ; xalloc<PS::CParticleGroup::SItem>::max_size
PUBLIC	?_Get_first@?$_Compressed_pair@V?$xalloc@USItem@CParticleGroup@PS@@@@V?$_Vector_val@U?$_Simple_types@USItem@CParticleGroup@PS@@@std@@@std@@$00@std@@QBEABV?$xalloc@USItem@CParticleGroup@PS@@@@XZ ; std::_Compressed_pair<xalloc<PS::CParticleGroup::SItem>,std::_Vector_val<std::_Simple_types<PS::CParticleGroup::SItem> >,1>::_Get_first
PUBLIC	?max_size@?$_Normal_allocator_traits@V?$xalloc@PAUSEffect@CPGDef@PS@@@@@std@@SAIABV?$xalloc@PAUSEffect@CPGDef@PS@@@@@Z ; std::_Normal_allocator_traits<xalloc<PS::CPGDef::SEffect *> >::max_size
PUBLIC	?capacity@?$vector@PAUSEffect@CPGDef@PS@@V?$xalloc@PAUSEffect@CPGDef@PS@@@@@std@@QBEIXZ ; std::vector<PS::CPGDef::SEffect *,xalloc<PS::CPGDef::SEffect *> >::capacity
PUBLIC	?_Umove_if_noexcept1@?$vector@PAUSEffect@CPGDef@PS@@V?$xalloc@PAUSEffect@CPGDef@PS@@@@@std@@AAEXPAPAUSEffect@CPGDef@PS@@00U?$integral_constant@_N$00@2@@Z ; std::vector<PS::CPGDef::SEffect *,xalloc<PS::CPGDef::SEffect *> >::_Umove_if_noexcept1
PUBLIC	?_Getal@?$vector@PAUSEffect@CPGDef@PS@@V?$xalloc@PAUSEffect@CPGDef@PS@@@@@std@@ABEABV?$xalloc@PAUSEffect@CPGDef@PS@@@@XZ ; std::vector<PS::CPGDef::SEffect *,xalloc<PS::CPGDef::SEffect *> >::_Getal
PUBLIC	?max_size@?$_Normal_allocator_traits@V?$xalloc@USItem@CParticleGroup@PS@@@@@std@@SAIABV?$xalloc@USItem@CParticleGroup@PS@@@@@Z ; std::_Normal_allocator_traits<xalloc<PS::CParticleGroup::SItem> >::max_size
PUBLIC	?capacity@?$vector@USItem@CParticleGroup@PS@@V?$xalloc@USItem@CParticleGroup@PS@@@@@std@@QBEIXZ ; std::vector<PS::CParticleGroup::SItem,xalloc<PS::CParticleGroup::SItem> >::capacity
PUBLIC	?_Umove_if_noexcept1@?$vector@USItem@CParticleGroup@PS@@V?$xalloc@USItem@CParticleGroup@PS@@@@@std@@AAEXPAUSItem@CParticleGroup@PS@@00U?$integral_constant@_N$00@2@@Z ; std::vector<PS::CParticleGroup::SItem,xalloc<PS::CParticleGroup::SItem> >::_Umove_if_noexcept1
PUBLIC	?_Getal@?$vector@USItem@CParticleGroup@PS@@V?$xalloc@USItem@CParticleGroup@PS@@@@@std@@ABEABV?$xalloc@USItem@CParticleGroup@PS@@@@XZ ; std::vector<PS::CParticleGroup::SItem,xalloc<PS::CParticleGroup::SItem> >::_Getal
PUBLIC	?allocate@?$xalloc@PAUSEffect@CPGDef@PS@@@@QBEPAPAUSEffect@CPGDef@PS@@IPBX@Z ; xalloc<PS::CPGDef::SEffect *>::allocate
PUBLIC	?destroy@?$xalloc@PAUSEffect@CPGDef@PS@@@@QAEXPAPAUSEffect@CPGDef@PS@@@Z ; xalloc<PS::CPGDef::SEffect *>::destroy
PUBLIC	?max_size@?$vector@PAUSEffect@CPGDef@PS@@V?$xalloc@PAUSEffect@CPGDef@PS@@@@@std@@QBEIXZ ; std::vector<PS::CPGDef::SEffect *,xalloc<PS::CPGDef::SEffect *> >::max_size
PUBLIC	?_Umove_if_noexcept@?$vector@PAUSEffect@CPGDef@PS@@V?$xalloc@PAUSEffect@CPGDef@PS@@@@@std@@AAEXPAPAUSEffect@CPGDef@PS@@00@Z ; std::vector<PS::CPGDef::SEffect *,xalloc<PS::CPGDef::SEffect *> >::_Umove_if_noexcept
PUBLIC	?_Calculate_growth@?$vector@PAUSEffect@CPGDef@PS@@V?$xalloc@PAUSEffect@CPGDef@PS@@@@@std@@ABEII@Z ; std::vector<PS::CPGDef::SEffect *,xalloc<PS::CPGDef::SEffect *> >::_Calculate_growth
PUBLIC	?_Change_array@?$vector@PAUSEffect@CPGDef@PS@@V?$xalloc@PAUSEffect@CPGDef@PS@@@@@std@@AAEXQAPAUSEffect@CPGDef@PS@@II@Z ; std::vector<PS::CPGDef::SEffect *,xalloc<PS::CPGDef::SEffect *> >::_Change_array
PUBLIC	?_Xlength@?$vector@PAUSEffect@CPGDef@PS@@V?$xalloc@PAUSEffect@CPGDef@PS@@@@@std@@CAXXZ ; std::vector<PS::CPGDef::SEffect *,xalloc<PS::CPGDef::SEffect *> >::_Xlength
PUBLIC	?allocate@?$xalloc@USItem@CParticleGroup@PS@@@@QBEPAUSItem@CParticleGroup@PS@@IPBX@Z ; xalloc<PS::CParticleGroup::SItem>::allocate
PUBLIC	?destroy@?$xalloc@USItem@CParticleGroup@PS@@@@QAEXPAUSItem@CParticleGroup@PS@@@Z ; xalloc<PS::CParticleGroup::SItem>::destroy
PUBLIC	?max_size@?$vector@USItem@CParticleGroup@PS@@V?$xalloc@USItem@CParticleGroup@PS@@@@@std@@QBEIXZ ; std::vector<PS::CParticleGroup::SItem,xalloc<PS::CParticleGroup::SItem> >::max_size
PUBLIC	?_Umove_if_noexcept@?$vector@USItem@CParticleGroup@PS@@V?$xalloc@USItem@CParticleGroup@PS@@@@@std@@AAEXPAUSItem@CParticleGroup@PS@@00@Z ; std::vector<PS::CParticleGroup::SItem,xalloc<PS::CParticleGroup::SItem> >::_Umove_if_noexcept
PUBLIC	?_Calculate_growth@?$vector@USItem@CParticleGroup@PS@@V?$xalloc@USItem@CParticleGroup@PS@@@@@std@@ABEII@Z ; std::vector<PS::CParticleGroup::SItem,xalloc<PS::CParticleGroup::SItem> >::_Calculate_growth
PUBLIC	?_Change_array@?$vector@USItem@CParticleGroup@PS@@V?$xalloc@USItem@CParticleGroup@PS@@@@@std@@AAEXQAUSItem@CParticleGroup@PS@@II@Z ; std::vector<PS::CParticleGroup::SItem,xalloc<PS::CParticleGroup::SItem> >::_Change_array
PUBLIC	?_Xlength@?$vector@USItem@CParticleGroup@PS@@V?$xalloc@USItem@CParticleGroup@PS@@@@@std@@CAXXZ ; std::vector<PS::CParticleGroup::SItem,xalloc<PS::CParticleGroup::SItem> >::_Xlength
PUBLIC	?_Seek_to@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVIRender_Visual@@@std@@@std@@@std@@QAEXPBQAVIRender_Visual@@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<IRender_Visual *> > >::_Seek_to
PUBLIC	??0?$_Uninitialized_backout_al@V?$xalloc@USItem@CParticleGroup@PS@@@@@std@@QAE@PAUSItem@CParticleGroup@PS@@AAV?$xalloc@USItem@CParticleGroup@PS@@@@@Z ; std::_Uninitialized_backout_al<xalloc<PS::CParticleGroup::SItem> >::_Uninitialized_backout_al<xalloc<PS::CParticleGroup::SItem> >
PUBLIC	??1?$_Uninitialized_backout_al@V?$xalloc@USItem@CParticleGroup@PS@@@@@std@@QAE@XZ ; std::_Uninitialized_backout_al<xalloc<PS::CParticleGroup::SItem> >::~_Uninitialized_backout_al<xalloc<PS::CParticleGroup::SItem> >
PUBLIC	?_Release@?$_Uninitialized_backout_al@V?$xalloc@USItem@CParticleGroup@PS@@@@@std@@QAEPAUSItem@CParticleGroup@PS@@XZ ; std::_Uninitialized_backout_al<xalloc<PS::CParticleGroup::SItem> >::_Release
PUBLIC	??0?$_Uninitialized_backout_al@V?$xalloc@PAUSEffect@CPGDef@PS@@@@@std@@QAE@PAPAUSEffect@CPGDef@PS@@AAV?$xalloc@PAUSEffect@CPGDef@PS@@@@@Z ; std::_Uninitialized_backout_al<xalloc<PS::CPGDef::SEffect *> >::_Uninitialized_backout_al<xalloc<PS::CPGDef::SEffect *> >
PUBLIC	??1?$_Uninitialized_backout_al@V?$xalloc@PAUSEffect@CPGDef@PS@@@@@std@@QAE@XZ ; std::_Uninitialized_backout_al<xalloc<PS::CPGDef::SEffect *> >::~_Uninitialized_backout_al<xalloc<PS::CPGDef::SEffect *> >
PUBLIC	?_Release@?$_Uninitialized_backout_al@V?$xalloc@PAUSEffect@CPGDef@PS@@@@@std@@QAEPAPAUSEffect@CPGDef@PS@@XZ ; std::_Uninitialized_backout_al<xalloc<PS::CPGDef::SEffect *> >::_Release
PUBLIC	??$_Uninitialized_value_construct_n@V?$xalloc@PAUSEffect@CPGDef@PS@@@@@std@@YAPAPAUSEffect@CPGDef@PS@@PAPAU123@IAAV?$xalloc@PAUSEffect@CPGDef@PS@@@@@Z ; std::_Uninitialized_value_construct_n<xalloc<PS::CPGDef::SEffect *> >
PUBLIC	??$_Uninitialized_value_construct_n@V?$xalloc@USItem@CParticleGroup@PS@@@@@std@@YAPAUSItem@CParticleGroup@PS@@PAU123@IAAV?$xalloc@USItem@CParticleGroup@PS@@@@@Z ; std::_Uninitialized_value_construct_n<xalloc<PS::CParticleGroup::SItem> >
PUBLIC	??$destroy@PAUSEffect@CPGDef@PS@@@?$_Normal_allocator_traits@V?$xalloc@PAUSEffect@CPGDef@PS@@@@@std@@SAXAAV?$xalloc@PAUSEffect@CPGDef@PS@@@@PAPAUSEffect@CPGDef@PS@@@Z ; std::_Normal_allocator_traits<xalloc<PS::CPGDef::SEffect *> >::destroy<PS::CPGDef::SEffect *>
PUBLIC	??$_Unfancy@PAUSEffect@CPGDef@PS@@@std@@YAPAPAUSEffect@CPGDef@PS@@PAPAU123@@Z ; std::_Unfancy<PS::CPGDef::SEffect *>
PUBLIC	??$destroy@USItem@CParticleGroup@PS@@@?$_Normal_allocator_traits@V?$xalloc@USItem@CParticleGroup@PS@@@@@std@@SAXAAV?$xalloc@USItem@CParticleGroup@PS@@@@PAUSItem@CParticleGroup@PS@@@Z ; std::_Normal_allocator_traits<xalloc<PS::CParticleGroup::SItem> >::destroy<PS::CParticleGroup::SItem>
PUBLIC	??$_Unfancy@USItem@CParticleGroup@PS@@@std@@YAPAUSItem@CParticleGroup@PS@@PAU123@@Z ; std::_Unfancy<PS::CParticleGroup::SItem>
PUBLIC	??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@PAUSEffect@CPGDef@PS@@V?$xalloc@PAUSEffect@CPGDef@PS@@@@@std@@AAEXIABU_Value_init_tag@1@@Z ; std::vector<PS::CPGDef::SEffect *,xalloc<PS::CPGDef::SEffect *> >::_Resize_reallocate<std::_Value_init_tag>
PUBLIC	??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@USItem@CParticleGroup@PS@@V?$xalloc@USItem@CParticleGroup@PS@@@@@std@@AAEXIABU_Value_init_tag@1@@Z ; std::vector<PS::CParticleGroup::SItem,xalloc<PS::CParticleGroup::SItem> >::_Resize_reallocate<std::_Value_init_tag>
PUBLIC	??$_Seek_wrapped@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVIRender_Visual@@@std@@@std@@@std@@AAPAPAVIRender_Visual@@@std@@YAXAAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVIRender_Visual@@@std@@@std@@@0@AAPAPAVIRender_Visual@@@Z ; std::_Seek_wrapped<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<IRender_Visual *> > >,IRender_Visual * * &>
PUBLIC	??$_Get_unwrapped@AAPAPAVIRender_Visual@@@std@@YA?A_TAAPAPAVIRender_Visual@@@Z ; std::_Get_unwrapped<IRender_Visual * * &>
PUBLIC	??$find_if@PAPAVIRender_Visual@@Uzero_vis_pred@@@std@@YAPAPAVIRender_Visual@@PAPAV1@QAPAV1@Uzero_vis_pred@@@Z ; std::find_if<IRender_Visual * *,zero_vis_pred>
PUBLIC	??$_Pass_fn@Uzero_vis_pred@@$0A@@std@@YA?AUzero_vis_pred@@U1@@Z ; std::_Pass_fn<zero_vis_pred,0>
PUBLIC	??1SEffect@CPGDef@PS@@QAE@XZ			; PS::CPGDef::SEffect::~SEffect
PUBLIC	??_GSEffect@CPGDef@PS@@QAEPAXI@Z		; PS::CPGDef::SEffect::`scalar deleting destructor'
PUBLIC	??0?$xalloc@PAUSEffect@CPGDef@PS@@@@QAE@XZ	; xalloc<PS::CPGDef::SEffect *>::xalloc<PS::CPGDef::SEffect *>
PUBLIC	?_Ufill@?$vector@PAUSEffect@CPGDef@PS@@V?$xalloc@PAUSEffect@CPGDef@PS@@@@@std@@AAEPAPAUSEffect@CPGDef@PS@@PAPAU345@IU_Value_init_tag@2@@Z ; std::vector<PS::CPGDef::SEffect *,xalloc<PS::CPGDef::SEffect *> >::_Ufill
PUBLIC	?_Orphan_range@?$vector@PAUSEffect@CPGDef@PS@@V?$xalloc@PAUSEffect@CPGDef@PS@@@@@std@@ABEXPAPAUSEffect@CPGDef@PS@@0@Z ; std::vector<PS::CPGDef::SEffect *,xalloc<PS::CPGDef::SEffect *> >::_Orphan_range
PUBLIC	??0?$_Vector_val@U?$_Simple_types@PAUSEffect@CPGDef@PS@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<PS::CPGDef::SEffect *> >::_Vector_val<std::_Simple_types<PS::CPGDef::SEffect *> >
PUBLIC	??0?$xalloc@USItem@CParticleGroup@PS@@@@QAE@XZ	; xalloc<PS::CParticleGroup::SItem>::xalloc<PS::CParticleGroup::SItem>
PUBLIC	?_Ufill@?$vector@USItem@CParticleGroup@PS@@V?$xalloc@USItem@CParticleGroup@PS@@@@@std@@AAEPAUSItem@CParticleGroup@PS@@PAU345@IU_Value_init_tag@2@@Z ; std::vector<PS::CParticleGroup::SItem,xalloc<PS::CParticleGroup::SItem> >::_Ufill
PUBLIC	?_Orphan_range@?$vector@USItem@CParticleGroup@PS@@V?$xalloc@USItem@CParticleGroup@PS@@@@@std@@ABEXPAUSItem@CParticleGroup@PS@@0@Z ; std::vector<PS::CParticleGroup::SItem,xalloc<PS::CParticleGroup::SItem> >::_Orphan_range
PUBLIC	??0?$_Vector_val@U?$_Simple_types@USItem@CParticleGroup@PS@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<PS::CParticleGroup::SItem> >::_Vector_val<std::_Simple_types<PS::CParticleGroup::SItem> >
PUBLIC	??R?$xr_special_free@$0A@USEffect@CPGDef@PS@@@@QAEXAAPAUSEffect@CPGDef@PS@@@Z ; xr_special_free<0,PS::CPGDef::SEffect>::operator()
PUBLIC	??$xr_free@PAUSEffect@CPGDef@PS@@@@YAXAAPAPAUSEffect@CPGDef@PS@@@Z ; xr_free<PS::CPGDef::SEffect *>
PUBLIC	??$_Destroy_range@V?$xalloc@PAUSEffect@CPGDef@PS@@@@@std@@YAXPAPAUSEffect@CPGDef@PS@@QAPAU123@AAV?$xalloc@PAUSEffect@CPGDef@PS@@@@@Z ; std::_Destroy_range<xalloc<PS::CPGDef::SEffect *> >
PUBLIC	??$xr_free@USItem@CParticleGroup@PS@@@@YAXAAPAUSItem@CParticleGroup@PS@@@Z ; xr_free<PS::CParticleGroup::SItem>
PUBLIC	??$_Destroy_range@V?$xalloc@USItem@CParticleGroup@PS@@@@@std@@YAXPAUSItem@CParticleGroup@PS@@QAU123@AAV?$xalloc@USItem@CParticleGroup@PS@@@@@Z ; std::_Destroy_range<xalloc<PS::CParticleGroup::SItem> >
PUBLIC	??$?0$$V@?$_Compressed_pair@V?$xalloc@PAUSEffect@CPGDef@PS@@@@V?$_Vector_val@U?$_Simple_types@PAUSEffect@CPGDef@PS@@@std@@@std@@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<xalloc<PS::CPGDef::SEffect *>,std::_Vector_val<std::_Simple_types<PS::CPGDef::SEffect *> >,1>::_Compressed_pair<xalloc<PS::CPGDef::SEffect *>,std::_Vector_val<std::_Simple_types<PS::CPGDef::SEffect *> >,1><>
PUBLIC	??$?0$$V@?$_Compressed_pair@V?$xalloc@USItem@CParticleGroup@PS@@@@V?$_Vector_val@U?$_Simple_types@USItem@CParticleGroup@PS@@@std@@@std@@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<xalloc<PS::CParticleGroup::SItem>,std::_Vector_val<std::_Simple_types<PS::CParticleGroup::SItem> >,1>::_Compressed_pair<xalloc<PS::CParticleGroup::SItem>,std::_Vector_val<std::_Simple_types<PS::CParticleGroup::SItem> >,1><>
PUBLIC	??$_Resize@U_Value_init_tag@std@@@?$vector@PAUSEffect@CPGDef@PS@@V?$xalloc@PAUSEffect@CPGDef@PS@@@@@std@@AAEXIABU_Value_init_tag@1@@Z ; std::vector<PS::CPGDef::SEffect *,xalloc<PS::CPGDef::SEffect *> >::_Resize<std::_Value_init_tag>
PUBLIC	??$addressof@V?$_Vector_val@U?$_Simple_types@PAUSEffect@CPGDef@PS@@@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@PAUSEffect@CPGDef@PS@@@std@@@0@AAV10@@Z ; std::addressof<std::_Vector_val<std::_Simple_types<PS::CPGDef::SEffect *> > >
PUBLIC	??$addressof@$$CBV?$_Vector_val@U?$_Simple_types@PAUSEffect@CPGDef@PS@@@std@@@std@@@std@@YAPBV?$_Vector_val@U?$_Simple_types@PAUSEffect@CPGDef@PS@@@std@@@0@ABV10@@Z ; std::addressof<std::_Vector_val<std::_Simple_types<PS::CPGDef::SEffect *> > const >
PUBLIC	??$_Emplace_reallocate@PAVIRender_Visual@@@?$vector@PAVIRender_Visual@@V?$xalloc@PAVIRender_Visual@@@@@std@@QAEPAPAVIRender_Visual@@QAPAV2@$$QAPAV2@@Z ; std::vector<IRender_Visual *,xalloc<IRender_Visual *> >::_Emplace_reallocate<IRender_Visual *>
PUBLIC	??$_Resize@U_Value_init_tag@std@@@?$vector@USItem@CParticleGroup@PS@@V?$xalloc@USItem@CParticleGroup@PS@@@@@std@@AAEXIABU_Value_init_tag@1@@Z ; std::vector<PS::CParticleGroup::SItem,xalloc<PS::CParticleGroup::SItem> >::_Resize<std::_Value_init_tag>
PUBLIC	??$addressof@V?$_Vector_val@U?$_Simple_types@USItem@CParticleGroup@PS@@@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@USItem@CParticleGroup@PS@@@std@@@0@AAV10@@Z ; std::addressof<std::_Vector_val<std::_Simple_types<PS::CParticleGroup::SItem> > >
PUBLIC	??$_Get_unwrapped@ABV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVIRender_Visual@@@std@@@std@@@std@@@std@@YA?A_TABV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVIRender_Visual@@@std@@@std@@@0@@Z ; std::_Get_unwrapped<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<IRender_Visual *> > > const &>
PUBLIC	??$remove_if@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVIRender_Visual@@@std@@@std@@@std@@Uzero_vis_pred@@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVIRender_Visual@@@std@@@std@@@0@V10@V10@Uzero_vis_pred@@@Z ; std::remove_if<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<IRender_Visual *> > >,zero_vis_pred>
PUBLIC	??$xr_new@USEffect@CPGDef@PS@@@@YAPAUSEffect@CPGDef@PS@@XZ ; xr_new<PS::CPGDef::SEffect>
PUBLIC	??$xr_delete@USEffect@CPGDef@PS@@@@YAXAAPAUSEffect@CPGDef@PS@@@Z ; xr_delete<PS::CPGDef::SEffect>
PUBLIC	?_Verify_offset@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@USItem@CParticleGroup@PS@@@std@@@std@@@std@@QBEXH@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<PS::CParticleGroup::SItem> > >::_Verify_offset
PUBLIC	?_Get_first@?$_Compressed_pair@V?$xalloc@PAUSEffect@CPGDef@PS@@@@V?$_Vector_val@U?$_Simple_types@PAUSEffect@CPGDef@PS@@@std@@@std@@$00@std@@QAEAAV?$xalloc@PAUSEffect@CPGDef@PS@@@@XZ ; std::_Compressed_pair<xalloc<PS::CPGDef::SEffect *>,std::_Vector_val<std::_Simple_types<PS::CPGDef::SEffect *> >,1>::_Get_first
PUBLIC	?_Get_first@?$_Compressed_pair@V?$xalloc@USItem@CParticleGroup@PS@@@@V?$_Vector_val@U?$_Simple_types@USItem@CParticleGroup@PS@@@std@@@std@@$00@std@@QAEAAV?$xalloc@USItem@CParticleGroup@PS@@@@XZ ; std::_Compressed_pair<xalloc<PS::CParticleGroup::SItem>,std::_Vector_val<std::_Simple_types<PS::CParticleGroup::SItem> >,1>::_Get_first
PUBLIC	?_Verify_offset@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUSEffect@CPGDef@PS@@@std@@@std@@@std@@QBEXH@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<PS::CPGDef::SEffect *> > >::_Verify_offset
PUBLIC	??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@USItem@CParticleGroup@PS@@@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<PS::CParticleGroup::SItem> > >::operator+=
PUBLIC	?deallocate@?$xalloc@PAUSEffect@CPGDef@PS@@@@QBEXPAPAUSEffect@CPGDef@PS@@I@Z ; xalloc<PS::CPGDef::SEffect *>::deallocate
PUBLIC	?clear@?$vector@PAUSEffect@CPGDef@PS@@V?$xalloc@PAUSEffect@CPGDef@PS@@@@@std@@QAEXXZ ; std::vector<PS::CPGDef::SEffect *,xalloc<PS::CPGDef::SEffect *> >::clear
PUBLIC	?_Destroy@?$vector@PAUSEffect@CPGDef@PS@@V?$xalloc@PAUSEffect@CPGDef@PS@@@@@std@@AAEXPAPAUSEffect@CPGDef@PS@@0@Z ; std::vector<PS::CPGDef::SEffect *,xalloc<PS::CPGDef::SEffect *> >::_Destroy
PUBLIC	?_Getal@?$vector@PAUSEffect@CPGDef@PS@@V?$xalloc@PAUSEffect@CPGDef@PS@@@@@std@@AAEAAV?$xalloc@PAUSEffect@CPGDef@PS@@@@XZ ; std::vector<PS::CPGDef::SEffect *,xalloc<PS::CPGDef::SEffect *> >::_Getal
PUBLIC	?deallocate@?$xalloc@USItem@CParticleGroup@PS@@@@QBEXPAUSItem@CParticleGroup@PS@@I@Z ; xalloc<PS::CParticleGroup::SItem>::deallocate
PUBLIC	?clear@?$vector@USItem@CParticleGroup@PS@@V?$xalloc@USItem@CParticleGroup@PS@@@@@std@@QAEXXZ ; std::vector<PS::CParticleGroup::SItem,xalloc<PS::CParticleGroup::SItem> >::clear
PUBLIC	?_Destroy@?$vector@USItem@CParticleGroup@PS@@V?$xalloc@USItem@CParticleGroup@PS@@@@@std@@AAEXPAUSItem@CParticleGroup@PS@@0@Z ; std::vector<PS::CParticleGroup::SItem,xalloc<PS::CParticleGroup::SItem> >::_Destroy
PUBLIC	?_Getal@?$vector@USItem@CParticleGroup@PS@@V?$xalloc@USItem@CParticleGroup@PS@@@@@std@@AAEAAV?$xalloc@USItem@CParticleGroup@PS@@@@XZ ; std::vector<PS::CParticleGroup::SItem,xalloc<PS::CParticleGroup::SItem> >::_Getal
PUBLIC	?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVIRender_Visual@@@std@@@std@@@std@@QBEXABV12@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<IRender_Visual *> > >::_Compat
PUBLIC	??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUSEffect@CPGDef@PS@@@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<PS::CPGDef::SEffect *> > >::operator+=
PUBLIC	??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@USItem@CParticleGroup@PS@@@std@@@std@@@std@@QBEABUSItem@CParticleGroup@PS@@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<PS::CParticleGroup::SItem> > >::operator*
PUBLIC	??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USItem@CParticleGroup@PS@@@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<PS::CParticleGroup::SItem> > >::operator+=
PUBLIC	??0?$vector@PAUSEffect@CPGDef@PS@@V?$xalloc@PAUSEffect@CPGDef@PS@@@@@std@@QAE@XZ ; std::vector<PS::CPGDef::SEffect *,xalloc<PS::CPGDef::SEffect *> >::vector<PS::CPGDef::SEffect *,xalloc<PS::CPGDef::SEffect *> >
PUBLIC	?size@?$vector@PAUSEffect@CPGDef@PS@@V?$xalloc@PAUSEffect@CPGDef@PS@@@@@std@@QBEIXZ ; std::vector<PS::CPGDef::SEffect *,xalloc<PS::CPGDef::SEffect *> >::size
PUBLIC	?_Tidy@?$vector@PAUSEffect@CPGDef@PS@@V?$xalloc@PAUSEffect@CPGDef@PS@@@@@std@@AAEXXZ ; std::vector<PS::CPGDef::SEffect *,xalloc<PS::CPGDef::SEffect *> >::_Tidy
PUBLIC	?clear_and_free@?$xr_vector@PAUSEffect@CPGDef@PS@@V?$xalloc@PAUSEffect@CPGDef@PS@@@@@@QAEXXZ ; xr_vector<PS::CPGDef::SEffect *,xalloc<PS::CPGDef::SEffect *> >::clear_and_free
PUBLIC	??0?$vector@USItem@CParticleGroup@PS@@V?$xalloc@USItem@CParticleGroup@PS@@@@@std@@QAE@XZ ; std::vector<PS::CParticleGroup::SItem,xalloc<PS::CParticleGroup::SItem> >::vector<PS::CParticleGroup::SItem,xalloc<PS::CParticleGroup::SItem> >
PUBLIC	?size@?$vector@USItem@CParticleGroup@PS@@V?$xalloc@USItem@CParticleGroup@PS@@@@@std@@QBEIXZ ; std::vector<PS::CParticleGroup::SItem,xalloc<PS::CParticleGroup::SItem> >::size
PUBLIC	?_Tidy@?$vector@USItem@CParticleGroup@PS@@V?$xalloc@USItem@CParticleGroup@PS@@@@@std@@AAEXXZ ; std::vector<PS::CParticleGroup::SItem,xalloc<PS::CParticleGroup::SItem> >::_Tidy
PUBLIC	?clear_and_free@?$xr_vector@USItem@CParticleGroup@PS@@V?$xalloc@USItem@CParticleGroup@PS@@@@@@QAEXXZ ; xr_vector<PS::CParticleGroup::SItem,xalloc<PS::CParticleGroup::SItem> >::clear_and_free
PUBLIC	??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVIRender_Visual@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<IRender_Visual *> > >::operator++
PUBLIC	??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVIRender_Visual@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<IRender_Visual *> > >::operator==
PUBLIC	??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUSEffect@CPGDef@PS@@@std@@@std@@@std@@QAE@PAPAUSEffect@CPGDef@PS@@PBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<PS::CPGDef::SEffect *> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<PS::CPGDef::SEffect *> > >
PUBLIC	??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUSEffect@CPGDef@PS@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<PS::CPGDef::SEffect *> > >::operator++
PUBLIC	??H?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUSEffect@CPGDef@PS@@@std@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<PS::CPGDef::SEffect *> > >::operator+
PUBLIC	??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUSEffect@CPGDef@PS@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<PS::CPGDef::SEffect *> > >::operator==
PUBLIC	?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUSEffect@CPGDef@PS@@@std@@@std@@@std@@QBEXABV12@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<PS::CPGDef::SEffect *> > >::_Compat
PUBLIC	??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@USItem@CParticleGroup@PS@@@std@@@std@@@std@@QAE@PAUSItem@CParticleGroup@PS@@PBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<PS::CParticleGroup::SItem> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<PS::CParticleGroup::SItem> > >
PUBLIC	??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@USItem@CParticleGroup@PS@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<PS::CParticleGroup::SItem> > >::operator++
PUBLIC	??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@USItem@CParticleGroup@PS@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<PS::CParticleGroup::SItem> > >::operator==
PUBLIC	?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@USItem@CParticleGroup@PS@@@std@@@std@@@std@@QBEXABV12@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<PS::CParticleGroup::SItem> > >::_Compat
PUBLIC	??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USItem@CParticleGroup@PS@@@std@@@std@@@std@@QBEAAUSItem@CParticleGroup@PS@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<PS::CParticleGroup::SItem> > >::operator*
PUBLIC	??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USItem@CParticleGroup@PS@@@std@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<PS::CParticleGroup::SItem> > >::operator+
PUBLIC	??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUSEffect@CPGDef@PS@@@std@@@std@@@std@@QAE@PAPAUSEffect@CPGDef@PS@@PBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<PS::CPGDef::SEffect *> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<PS::CPGDef::SEffect *> > >
PUBLIC	??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USItem@CParticleGroup@PS@@@std@@@std@@@std@@QAE@PAUSItem@CParticleGroup@PS@@PBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<PS::CParticleGroup::SItem> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<PS::CParticleGroup::SItem> > >
PUBLIC	?transform_dir@?$_matrix@M@@QBEXAAU?$_vector3@M@@@Z ; _matrix<float>::transform_dir
PUBLIC	?is_valid@?$_box3@M@@QAEHXZ			; _box3<float>::is_valid
PUBLIC	??1?$vector@PAUSEffect@CPGDef@PS@@V?$xalloc@PAUSEffect@CPGDef@PS@@@@@std@@QAE@XZ ; std::vector<PS::CPGDef::SEffect *,xalloc<PS::CPGDef::SEffect *> >::~vector<PS::CPGDef::SEffect *,xalloc<PS::CPGDef::SEffect *> >
PUBLIC	?resize@?$vector@PAUSEffect@CPGDef@PS@@V?$xalloc@PAUSEffect@CPGDef@PS@@@@@std@@QAEXI@Z ; std::vector<PS::CPGDef::SEffect *,xalloc<PS::CPGDef::SEffect *> >::resize
PUBLIC	?begin@?$vector@PAUSEffect@CPGDef@PS@@V?$xalloc@PAUSEffect@CPGDef@PS@@@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUSEffect@CPGDef@PS@@@std@@@std@@@2@XZ ; std::vector<PS::CPGDef::SEffect *,xalloc<PS::CPGDef::SEffect *> >::begin
PUBLIC	?begin@?$vector@PAUSEffect@CPGDef@PS@@V?$xalloc@PAUSEffect@CPGDef@PS@@@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUSEffect@CPGDef@PS@@@std@@@std@@@2@XZ ; std::vector<PS::CPGDef::SEffect *,xalloc<PS::CPGDef::SEffect *> >::begin
PUBLIC	?end@?$vector@PAUSEffect@CPGDef@PS@@V?$xalloc@PAUSEffect@CPGDef@PS@@@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUSEffect@CPGDef@PS@@@std@@@std@@@2@XZ ; std::vector<PS::CPGDef::SEffect *,xalloc<PS::CPGDef::SEffect *> >::end
PUBLIC	?end@?$vector@PAUSEffect@CPGDef@PS@@V?$xalloc@PAUSEffect@CPGDef@PS@@@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUSEffect@CPGDef@PS@@@std@@@std@@@2@XZ ; std::vector<PS::CPGDef::SEffect *,xalloc<PS::CPGDef::SEffect *> >::end
PUBLIC	??0?$xr_vector@PAUSEffect@CPGDef@PS@@V?$xalloc@PAUSEffect@CPGDef@PS@@@@@@QAE@XZ ; xr_vector<PS::CPGDef::SEffect *,xalloc<PS::CPGDef::SEffect *> >::xr_vector<PS::CPGDef::SEffect *,xalloc<PS::CPGDef::SEffect *> >
PUBLIC	?size@?$xr_vector@PAUSEffect@CPGDef@PS@@V?$xalloc@PAUSEffect@CPGDef@PS@@@@@@QBEIXZ ; xr_vector<PS::CPGDef::SEffect *,xalloc<PS::CPGDef::SEffect *> >::size
PUBLIC	?clear@?$xr_vector@PAUSEffect@CPGDef@PS@@V?$xalloc@PAUSEffect@CPGDef@PS@@@@@@QAEXXZ ; xr_vector<PS::CPGDef::SEffect *,xalloc<PS::CPGDef::SEffect *> >::clear
PUBLIC	??A?$xr_vector@PAUSEffect@CPGDef@PS@@V?$xalloc@PAUSEffect@CPGDef@PS@@@@@@QBEABQAUSEffect@CPGDef@PS@@I@Z ; xr_vector<PS::CPGDef::SEffect *,xalloc<PS::CPGDef::SEffect *> >::operator[]
PUBLIC	??$_Emplace_back_with_unused_capacity@PAVIRender_Visual@@@?$vector@PAVIRender_Visual@@V?$xalloc@PAVIRender_Visual@@@@@std@@AAE?A_T$$QAPAVIRender_Visual@@@Z ; std::vector<IRender_Visual *,xalloc<IRender_Visual *> >::_Emplace_back_with_unused_capacity<IRender_Visual *>
PUBLIC	??$emplace_back@PAVIRender_Visual@@@?$vector@PAVIRender_Visual@@V?$xalloc@PAVIRender_Visual@@@@@std@@QAE?A_T$$QAPAVIRender_Visual@@@Z ; std::vector<IRender_Visual *,xalloc<IRender_Visual *> >::emplace_back<IRender_Visual *>
PUBLIC	?push_back@?$vector@PAVIRender_Visual@@V?$xalloc@PAVIRender_Visual@@@@@std@@QAEX$$QAPAVIRender_Visual@@@Z ; std::vector<IRender_Visual *,xalloc<IRender_Visual *> >::push_back
PUBLIC	?pop_back@?$vector@PAVIRender_Visual@@V?$xalloc@PAVIRender_Visual@@@@@std@@QAEXXZ ; std::vector<IRender_Visual *,xalloc<IRender_Visual *> >::pop_back
PUBLIC	?erase@?$vector@PAVIRender_Visual@@V?$xalloc@PAVIRender_Visual@@@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVIRender_Visual@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVIRender_Visual@@@std@@@std@@@2@0@Z ; std::vector<IRender_Visual *,xalloc<IRender_Visual *> >::erase
PUBLIC	?empty@?$vector@PAVIRender_Visual@@V?$xalloc@PAVIRender_Visual@@@@@std@@QBE_NXZ ; std::vector<IRender_Visual *,xalloc<IRender_Visual *> >::empty
PUBLIC	?back@?$vector@PAVIRender_Visual@@V?$xalloc@PAVIRender_Visual@@@@@std@@QAEAAPAVIRender_Visual@@XZ ; std::vector<IRender_Visual *,xalloc<IRender_Visual *> >::back
PUBLIC	??1?$vector@USItem@CParticleGroup@PS@@V?$xalloc@USItem@CParticleGroup@PS@@@@@std@@QAE@XZ ; std::vector<PS::CParticleGroup::SItem,xalloc<PS::CParticleGroup::SItem> >::~vector<PS::CParticleGroup::SItem,xalloc<PS::CParticleGroup::SItem> >
PUBLIC	?resize@?$vector@USItem@CParticleGroup@PS@@V?$xalloc@USItem@CParticleGroup@PS@@@@@std@@QAEXI@Z ; std::vector<PS::CParticleGroup::SItem,xalloc<PS::CParticleGroup::SItem> >::resize
PUBLIC	?begin@?$vector@USItem@CParticleGroup@PS@@V?$xalloc@USItem@CParticleGroup@PS@@@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USItem@CParticleGroup@PS@@@std@@@std@@@2@XZ ; std::vector<PS::CParticleGroup::SItem,xalloc<PS::CParticleGroup::SItem> >::begin
PUBLIC	?end@?$vector@USItem@CParticleGroup@PS@@V?$xalloc@USItem@CParticleGroup@PS@@@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USItem@CParticleGroup@PS@@@std@@@std@@@2@XZ ; std::vector<PS::CParticleGroup::SItem,xalloc<PS::CParticleGroup::SItem> >::end
PUBLIC	??0?$xr_vector@USItem@CParticleGroup@PS@@V?$xalloc@USItem@CParticleGroup@PS@@@@@@QAE@XZ ; xr_vector<PS::CParticleGroup::SItem,xalloc<PS::CParticleGroup::SItem> >::xr_vector<PS::CParticleGroup::SItem,xalloc<PS::CParticleGroup::SItem> >
PUBLIC	?size@?$xr_vector@USItem@CParticleGroup@PS@@V?$xalloc@USItem@CParticleGroup@PS@@@@@@QBEIXZ ; xr_vector<PS::CParticleGroup::SItem,xalloc<PS::CParticleGroup::SItem> >::size
PUBLIC	?clear@?$xr_vector@USItem@CParticleGroup@PS@@V?$xalloc@USItem@CParticleGroup@PS@@@@@@QAEXXZ ; xr_vector<PS::CParticleGroup::SItem,xalloc<PS::CParticleGroup::SItem> >::clear
PUBLIC	??A?$xr_vector@USItem@CParticleGroup@PS@@V?$xalloc@USItem@CParticleGroup@PS@@@@@@QAEAAUSItem@CParticleGroup@PS@@I@Z ; xr_vector<PS::CParticleGroup::SItem,xalloc<PS::CParticleGroup::SItem> >::operator[]
PUBLIC	??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVIRender_Visual@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<IRender_Visual *> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<IRender_Visual *> > >
PUBLIC	??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVIRender_Visual@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<IRender_Visual *> > >::operator!=
PUBLIC	??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVIRender_Visual@@@std@@@std@@@std@@QAE?AV01@H@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<IRender_Visual *> > >::operator++
PUBLIC	??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUSEffect@CPGDef@PS@@@std@@@std@@@std@@QBEABQAUSEffect@CPGDef@PS@@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<PS::CPGDef::SEffect *> > >::operator*
PUBLIC	??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUSEffect@CPGDef@PS@@@std@@@std@@@std@@QAE?AV01@H@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<PS::CPGDef::SEffect *> > >::operator++
PUBLIC	??G?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUSEffect@CPGDef@PS@@@std@@@std@@@std@@QBEHABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<PS::CPGDef::SEffect *> > >::operator-
PUBLIC	??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUSEffect@CPGDef@PS@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<PS::CPGDef::SEffect *> > >::operator!=
PUBLIC	??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUSEffect@CPGDef@PS@@@std@@@std@@@std@@QBEAAPAUSEffect@CPGDef@PS@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<PS::CPGDef::SEffect *> > >::operator*
PUBLIC	??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUSEffect@CPGDef@PS@@@std@@@std@@@std@@QAE?AV01@H@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<PS::CPGDef::SEffect *> > >::operator++
PUBLIC	??G?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@USItem@CParticleGroup@PS@@@std@@@std@@@std@@QBEHABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<PS::CParticleGroup::SItem> > >::operator-
PUBLIC	??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@USItem@CParticleGroup@PS@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<PS::CParticleGroup::SItem> > >::operator!=
PUBLIC	??C?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USItem@CParticleGroup@PS@@@std@@@std@@@std@@QBEPAUSItem@CParticleGroup@PS@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<PS::CParticleGroup::SItem> > >::operator->
PUBLIC	??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USItem@CParticleGroup@PS@@@std@@@std@@@std@@QAE?AV01@H@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<PS::CParticleGroup::SItem> > >::operator++
PUBLIC	?ParticlesCount@CParticleGroup@PS@@UAEIXZ	; PS::CParticleGroup::ParticlesCount
PUBLIC	?OnDeviceDestroy@CParticleGroup@PS@@UAEXXZ	; PS::CParticleGroup::OnDeviceDestroy
PUBLIC	?OnDeviceCreate@CParticleGroup@PS@@UAEXXZ	; PS::CParticleGroup::OnDeviceCreate
PUBLIC	?Stop@CParticleGroup@PS@@UAEXH@Z		; PS::CParticleGroup::Stop
PUBLIC	?Play@CParticleGroup@PS@@UAEXXZ			; PS::CParticleGroup::Play
PUBLIC	?UpdateParent@CParticleGroup@PS@@UAEXABU?$_matrix@M@@ABU?$_vector3@M@@H@Z ; PS::CParticleGroup::UpdateParent
PUBLIC	?OnFrame@CParticleGroup@PS@@UAEXI@Z		; PS::CParticleGroup::OnFrame
PUBLIC	??1CParticleGroup@PS@@UAE@XZ			; PS::CParticleGroup::~CParticleGroup
PUBLIC	??1?$xr_vector@USItem@CParticleGroup@PS@@V?$xalloc@USItem@CParticleGroup@PS@@@@@@QAE@XZ ; xr_vector<PS::CParticleGroup::SItem,xalloc<PS::CParticleGroup::SItem> >::~xr_vector<PS::CParticleGroup::SItem,xalloc<PS::CParticleGroup::SItem> >
PUBLIC	??_GCParticleGroup@PS@@UAEPAXI@Z		; PS::CParticleGroup::`scalar deleting destructor'
PUBLIC	?ParticlesCount@SItem@CParticleGroup@PS@@QAEIXZ	; PS::CParticleGroup::SItem::ParticlesCount
PUBLIC	?OnDeviceDestroy@SItem@CParticleGroup@PS@@QAEXXZ ; PS::CParticleGroup::SItem::OnDeviceDestroy
PUBLIC	?OnDeviceCreate@SItem@CParticleGroup@PS@@QAEXXZ	; PS::CParticleGroup::SItem::OnDeviceCreate
PUBLIC	?OnFrame@SItem@CParticleGroup@PS@@QAEXIABUSEffect@CPGDef@3@AAV?$_box3@M@@AA_N@Z ; PS::CParticleGroup::SItem::OnFrame
PUBLIC	??Rzero_vis_pred@@QAE_NPBVIRender_Visual@@@Z	; zero_vis_pred::operator()
PUBLIC	?OnGroupParticleDead@@YAXPAXIAAUParticle@PAPI@@I@Z ; OnGroupParticleDead
PUBLIC	?OnGroupParticleBirth@@YAXPAXIAAUParticle@PAPI@@I@Z ; OnGroupParticleBirth
PUBLIC	?UpdateParent@SItem@CParticleGroup@PS@@QAEXABU?$_matrix@M@@ABU?$_vector3@M@@H@Z ; PS::CParticleGroup::SItem::UpdateParent
PUBLIC	?IsPlaying@SItem@CParticleGroup@PS@@QAEHXZ	; PS::CParticleGroup::SItem::IsPlaying
PUBLIC	??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVIRender_Visual@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<IRender_Visual *> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<IRender_Visual *> > >
PUBLIC	?Stop@SItem@CParticleGroup@PS@@QAEXH@Z		; PS::CParticleGroup::SItem::Stop
PUBLIC	?Play@SItem@CParticleGroup@PS@@QAEXXZ		; PS::CParticleGroup::SItem::Play
PUBLIC	?StartFreeChild@SItem@CParticleGroup@PS@@QAEXPAVCParticleEffect@3@PBDAAUParticle@PAPI@@@Z ; PS::CParticleGroup::SItem::StartFreeChild
PUBLIC	?StopRelatedChild@SItem@CParticleGroup@PS@@QAEXI@Z ; PS::CParticleGroup::SItem::StopRelatedChild
PUBLIC	?StartRelatedChild@SItem@CParticleGroup@PS@@QAEXPAVCParticleEffect@3@PBDAAUParticle@PAPI@@@Z ; PS::CParticleGroup::SItem::StartRelatedChild
PUBLIC	?Clear@SItem@CParticleGroup@PS@@QAEXXZ		; PS::CParticleGroup::SItem::Clear
PUBLIC	?Set@SItem@CParticleGroup@PS@@QAEXPAVIRender_Visual@@@Z ; PS::CParticleGroup::SItem::Set
PUBLIC	?Load@CPGDef@PS@@QAEHAAVIReader@@@Z		; PS::CPGDef::Load
PUBLIC	??1CPGDef@PS@@QAE@XZ				; PS::CPGDef::~CPGDef
PUBLIC	??1?$xr_vector@PAUSEffect@CPGDef@PS@@V?$xalloc@PAUSEffect@CPGDef@PS@@@@@@QAE@XZ ; xr_vector<PS::CPGDef::SEffect *,xalloc<PS::CPGDef::SEffect *> >::~xr_vector<PS::CPGDef::SEffect *,xalloc<PS::CPGDef::SEffect *> >
PUBLIC	??0CPGDef@PS@@QAE@XZ				; PS::CPGDef::CPGDef
PUBLIC	?Compile@CParticleGroup@PS@@QAEHPAVCPGDef@2@@Z	; PS::CParticleGroup::Compile
PUBLIC	??0CParticleGroup@PS@@QAE@XZ			; PS::CParticleGroup::CParticleGroup
EXTRN	??_ECParticleGroup@PS@@UAEPAXI@Z:PROC		; PS::CParticleGroup::`vector deleting destructor'
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$_Emplace_reallocate@PAVIRender_Visual@@@?$vector@PAVIRender_Visual@@V?$xalloc@PAVIRender_Visual@@@@@std@@QAEPAPAVIRender_Visual@@QAPAV2@$$QAPAV2@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Emplace_reallocate@PAVIRender_Visual@@@?$vector@PAVIRender_Visual@@V?$xalloc@PAVIRender_Visual@@@@@std@@QAEPAPAVIRender_Visual@@QAPAV2@$$QAPAV2@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Emplace_reallocate@PAVIRender_Visual@@@?$vector@PAVIRender_Visual@@V?$xalloc@PAVIRender_Visual@@@@@std@@QAEPAPAVIRender_Visual@@QAPAV2@$$QAPAV2@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
__unwindtable$??$_Emplace_reallocate@PAVIRender_Visual@@@?$vector@PAVIRender_Visual@@V?$xalloc@PAVIRender_Visual@@@@@std@@QAEPAPAVIRender_Visual@@QAPAV2@$$QAPAV2@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Emplace_reallocate@PAVIRender_Visual@@@?$vector@PAVIRender_Visual@@V?$xalloc@PAVIRender_Visual@@@@@std@@QAEPAPAVIRender_Visual@@QAPAV2@$$QAPAV2@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Emplace_reallocate@PAVIRender_Visual@@@?$vector@PAVIRender_Visual@@V?$xalloc@PAVIRender_Visual@@@@@std@@QAEPAPAVIRender_Visual@@QAPAV2@$$QAPAV2@@Z$2
__catchsym$??$_Emplace_reallocate@PAVIRender_Visual@@@?$vector@PAVIRender_Visual@@V?$xalloc@PAVIRender_Visual@@@@@std@@QAEPAPAVIRender_Visual@@QAPAV2@$$QAPAV2@@Z$2 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Emplace_reallocate@PAVIRender_Visual@@@?$vector@PAVIRender_Visual@@V?$xalloc@PAVIRender_Visual@@@@@std@@QAEPAPAVIRender_Visual@@QAPAV2@$$QAPAV2@@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@USItem@CParticleGroup@PS@@V?$xalloc@USItem@CParticleGroup@PS@@@@@std@@AAEXIABU_Value_init_tag@1@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@USItem@CParticleGroup@PS@@V?$xalloc@USItem@CParticleGroup@PS@@@@@std@@AAEXIABU_Value_init_tag@1@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@USItem@CParticleGroup@PS@@V?$xalloc@USItem@CParticleGroup@PS@@@@@std@@AAEXIABU_Value_init_tag@1@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
__unwindtable$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@USItem@CParticleGroup@PS@@V?$xalloc@USItem@CParticleGroup@PS@@@@@std@@AAEXIABU_Value_init_tag@1@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@USItem@CParticleGroup@PS@@V?$xalloc@USItem@CParticleGroup@PS@@@@@std@@AAEXIABU_Value_init_tag@1@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@USItem@CParticleGroup@PS@@V?$xalloc@USItem@CParticleGroup@PS@@@@@std@@AAEXIABU_Value_init_tag@1@@Z$2
__catchsym$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@USItem@CParticleGroup@PS@@V?$xalloc@USItem@CParticleGroup@PS@@@@@std@@AAEXIABU_Value_init_tag@1@@Z$2 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@USItem@CParticleGroup@PS@@V?$xalloc@USItem@CParticleGroup@PS@@@@@std@@AAEXIABU_Value_init_tag@1@@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@PAUSEffect@CPGDef@PS@@V?$xalloc@PAUSEffect@CPGDef@PS@@@@@std@@AAEXIABU_Value_init_tag@1@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@PAUSEffect@CPGDef@PS@@V?$xalloc@PAUSEffect@CPGDef@PS@@@@@std@@AAEXIABU_Value_init_tag@1@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@PAUSEffect@CPGDef@PS@@V?$xalloc@PAUSEffect@CPGDef@PS@@@@@std@@AAEXIABU_Value_init_tag@1@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
__unwindtable$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@PAUSEffect@CPGDef@PS@@V?$xalloc@PAUSEffect@CPGDef@PS@@@@@std@@AAEXIABU_Value_init_tag@1@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@PAUSEffect@CPGDef@PS@@V?$xalloc@PAUSEffect@CPGDef@PS@@@@@std@@AAEXIABU_Value_init_tag@1@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@PAUSEffect@CPGDef@PS@@V?$xalloc@PAUSEffect@CPGDef@PS@@@@@std@@AAEXIABU_Value_init_tag@1@@Z$2
__catchsym$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@PAUSEffect@CPGDef@PS@@V?$xalloc@PAUSEffect@CPGDef@PS@@@@@std@@AAEXIABU_Value_init_tag@1@@Z$2 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@PAUSEffect@CPGDef@PS@@V?$xalloc@PAUSEffect@CPGDef@PS@@@@@std@@AAEXIABU_Value_init_tag@1@@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?_Reallocate_exactly@?$vector@PAVIRender_Visual@@V?$xalloc@PAVIRender_Visual@@@@@std@@AAEXI@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Reallocate_exactly@?$vector@PAVIRender_Visual@@V?$xalloc@PAVIRender_Visual@@@@@std@@AAEXI@Z
	DD	01H
	DD	FLAT:__tryblocktable$?_Reallocate_exactly@?$vector@PAVIRender_Visual@@V?$xalloc@PAVIRender_Visual@@@@@std@@AAEXI@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
__unwindtable$?_Reallocate_exactly@?$vector@PAVIRender_Visual@@V?$xalloc@PAVIRender_Visual@@@@@std@@AAEXI@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?_Reallocate_exactly@?$vector@PAVIRender_Visual@@V?$xalloc@PAVIRender_Visual@@@@@std@@AAEXI@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Reallocate_exactly@?$vector@PAVIRender_Visual@@V?$xalloc@PAVIRender_Visual@@@@@std@@AAEXI@Z$2
__catchsym$?_Reallocate_exactly@?$vector@PAVIRender_Visual@@V?$xalloc@PAVIRender_Visual@@@@@std@@AAEXI@Z$2 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Reallocate_exactly@?$vector@PAVIRender_Visual@@V?$xalloc@PAVIRender_Visual@@@@@std@@AAEXI@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$_Insert_range@PAPAVIRender_Visual@@@?$vector@PAVIRender_Visual@@V?$xalloc@PAVIRender_Visual@@@@@std@@AAEXV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVIRender_Visual@@@std@@@std@@@1@PAPAVIRender_Visual@@1Uforward_iterator_tag@1@@Z DD 019930522H
	DD	0aH
	DD	FLAT:__unwindtable$??$_Insert_range@PAPAVIRender_Visual@@@?$vector@PAVIRender_Visual@@V?$xalloc@PAVIRender_Visual@@@@@std@@AAEXV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVIRender_Visual@@@std@@@std@@@1@PAPAVIRender_Visual@@1Uforward_iterator_tag@1@@Z
	DD	05H
	DD	FLAT:__tryblocktable$??$_Insert_range@PAPAVIRender_Visual@@@?$vector@PAVIRender_Visual@@V?$xalloc@PAVIRender_Visual@@@@@std@@AAEXV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVIRender_Visual@@@std@@@std@@@1@PAPAVIRender_Visual@@1Uforward_iterator_tag@1@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
	ORG $+4
__unwindtable$??$_Insert_range@PAPAVIRender_Visual@@@?$vector@PAVIRender_Visual@@V?$xalloc@PAVIRender_Visual@@@@@std@@AAEXV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVIRender_Visual@@@std@@@std@@@1@PAPAVIRender_Visual@@1Uforward_iterator_tag@1@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	03H
	DD	00H
	DD	03H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	07H
	DD	00H
	DD	07H
	DD	00H
__tryblocktable$??$_Insert_range@PAPAVIRender_Visual@@@?$vector@PAVIRender_Visual@@V?$xalloc@PAVIRender_Visual@@@@@std@@AAEXV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVIRender_Visual@@@std@@@std@@@1@PAPAVIRender_Visual@@1Uforward_iterator_tag@1@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Insert_range@PAPAVIRender_Visual@@@?$vector@PAVIRender_Visual@@V?$xalloc@PAVIRender_Visual@@@@@std@@AAEXV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVIRender_Visual@@@std@@@std@@@1@PAPAVIRender_Visual@@1Uforward_iterator_tag@1@@Z$10
	DD	04H
	DD	04H
	DD	05H
	DD	01H
	DD	FLAT:__catchsym$??$_Insert_range@PAPAVIRender_Visual@@@?$vector@PAVIRender_Visual@@V?$xalloc@PAVIRender_Visual@@@@@std@@AAEXV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVIRender_Visual@@@std@@@std@@@1@PAPAVIRender_Visual@@1Uforward_iterator_tag@1@@Z$11
	DD	02H
	DD	02H
	DD	05H
	DD	01H
	DD	FLAT:__catchsym$??$_Insert_range@PAPAVIRender_Visual@@@?$vector@PAVIRender_Visual@@V?$xalloc@PAVIRender_Visual@@@@@std@@AAEXV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVIRender_Visual@@@std@@@std@@@1@PAPAVIRender_Visual@@1Uforward_iterator_tag@1@@Z$12
	DD	08H
	DD	08H
	DD	09H
	DD	01H
	DD	FLAT:__catchsym$??$_Insert_range@PAPAVIRender_Visual@@@?$vector@PAVIRender_Visual@@V?$xalloc@PAVIRender_Visual@@@@@std@@AAEXV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVIRender_Visual@@@std@@@std@@@1@PAPAVIRender_Visual@@1Uforward_iterator_tag@1@@Z$13
	DD	06H
	DD	06H
	DD	09H
	DD	01H
	DD	FLAT:__catchsym$??$_Insert_range@PAPAVIRender_Visual@@@?$vector@PAVIRender_Visual@@V?$xalloc@PAVIRender_Visual@@@@@std@@AAEXV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVIRender_Visual@@@std@@@std@@@1@PAPAVIRender_Visual@@1Uforward_iterator_tag@1@@Z$14
__catchsym$??$_Insert_range@PAPAVIRender_Visual@@@?$vector@PAVIRender_Visual@@V?$xalloc@PAVIRender_Visual@@@@@std@@AAEXV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVIRender_Visual@@@std@@@std@@@1@PAPAVIRender_Visual@@1Uforward_iterator_tag@1@@Z$10 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Insert_range@PAPAVIRender_Visual@@@?$vector@PAVIRender_Visual@@V?$xalloc@PAVIRender_Visual@@@@@std@@AAEXV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVIRender_Visual@@@std@@@std@@@1@PAPAVIRender_Visual@@1Uforward_iterator_tag@1@@Z$0
__catchsym$??$_Insert_range@PAPAVIRender_Visual@@@?$vector@PAVIRender_Visual@@V?$xalloc@PAVIRender_Visual@@@@@std@@AAEXV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVIRender_Visual@@@std@@@std@@@1@PAPAVIRender_Visual@@1Uforward_iterator_tag@1@@Z$11 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Insert_range@PAPAVIRender_Visual@@@?$vector@PAVIRender_Visual@@V?$xalloc@PAVIRender_Visual@@@@@std@@AAEXV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVIRender_Visual@@@std@@@std@@@1@PAPAVIRender_Visual@@1Uforward_iterator_tag@1@@Z$3
__catchsym$??$_Insert_range@PAPAVIRender_Visual@@@?$vector@PAVIRender_Visual@@V?$xalloc@PAVIRender_Visual@@@@@std@@AAEXV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVIRender_Visual@@@std@@@std@@@1@PAPAVIRender_Visual@@1Uforward_iterator_tag@1@@Z$12 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Insert_range@PAPAVIRender_Visual@@@?$vector@PAVIRender_Visual@@V?$xalloc@PAVIRender_Visual@@@@@std@@AAEXV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVIRender_Visual@@@std@@@std@@@1@PAPAVIRender_Visual@@1Uforward_iterator_tag@1@@Z$2
__catchsym$??$_Insert_range@PAPAVIRender_Visual@@@?$vector@PAVIRender_Visual@@V?$xalloc@PAVIRender_Visual@@@@@std@@AAEXV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVIRender_Visual@@@std@@@std@@@1@PAPAVIRender_Visual@@1Uforward_iterator_tag@1@@Z$13 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Insert_range@PAPAVIRender_Visual@@@?$vector@PAVIRender_Visual@@V?$xalloc@PAVIRender_Visual@@@@@std@@AAEXV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVIRender_Visual@@@std@@@std@@@1@PAPAVIRender_Visual@@1Uforward_iterator_tag@1@@Z$7
__catchsym$??$_Insert_range@PAPAVIRender_Visual@@@?$vector@PAVIRender_Visual@@V?$xalloc@PAVIRender_Visual@@@@@std@@AAEXV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVIRender_Visual@@@std@@@std@@@1@PAPAVIRender_Visual@@1Uforward_iterator_tag@1@@Z$14 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Insert_range@PAPAVIRender_Visual@@@?$vector@PAVIRender_Visual@@V?$xalloc@PAVIRender_Visual@@@@@std@@AAEXV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVIRender_Visual@@@std@@@std@@@1@PAPAVIRender_Visual@@1Uforward_iterator_tag@1@@Z$6
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_flags.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp
_TEXT	SEGMENT
??0CParticleGroup@PS@@QAE@XZ PROC			; PS::CParticleGroup::CParticleGroup
; _this$ = ecx

; 367  : {

	push	esi
	mov	esi, ecx
	call	DWORD PTR __imp_??0IParticleCustom@@QAE@XZ
	mov	DWORD PTR [esi], OFFSET ??_7CParticleGroup@PS@@6B@

; 370  : }

	mov	eax, esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [esi+92], 0
	mov	DWORD PTR [esi+96], 0
	mov	DWORD PTR [esi+100], 0
; File I:\Vitalya\mine\NSProjectX\xrCore\_flags.h

; 15   :     IC	SelfRef	zero	()											{ flags=T(0);	return *this;	}

	mov	BYTE PTR [esi+104], 0
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 23   : 	ICF	SelfRef	set(T _x, T _y, T _z)					{ x = _x;		y = _y;		z = _z;		return *this;	};

	mov	DWORD PTR [esi+80], 0
	mov	DWORD PTR [esi+84], 0
	mov	DWORD PTR [esi+88], 0
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp

; 370  : }

	pop	esi
	ret	0
??0CParticleGroup@PS@@QAE@XZ ENDP			; PS::CParticleGroup::CParticleGroup
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xrstring.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\PSLibrary.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xrstring.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\PSLibrary.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\PSLibrary.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleEffect.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp
_TEXT	SEGMENT
$T1 = -4						; size = 1
_it$2 = -4						; size = 4
_def$ = 8						; size = 4
?Compile@CParticleGroup@PS@@QAEHPAVCPGDef@2@@Z PROC	; PS::CParticleGroup::Compile
; _this$ = ecx

; 429  : {

	push	ecx

; 430  : 	m_Def 						= def;

	mov	eax, DWORD PTR _def$[esp]
	push	ebx
	push	ebp
	mov	ebp, ecx
	push	esi
	mov	DWORD PTR [ebp+72], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	esi, DWORD PTR [ebp+92]

; 150  :         return _Ptr == _Right._Ptr;

	cmp	esi, DWORD PTR [ebp+96]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp

; 432  :     for (SItemVecIt i_it=items.begin(); i_it!=items.end(); i_it++) 

	je	SHORT $LN3@Compile
$LL4@Compile:

; 433  :     	i_it->Clear();

	mov	ecx, esi
	call	?Clear@SItem@CParticleGroup@PS@@QAEXXZ	; PS::CParticleGroup::SItem::Clear
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 74   :         ++_Ptr;

	add	esi, 28					; 0000001cH

; 150  :         return _Ptr == _Right._Ptr;

	cmp	esi, DWORD PTR [ebp+96]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp

; 432  :     for (SItemVecIt i_it=items.begin(); i_it!=items.end(); i_it++) 

	jne	SHORT $LL4@Compile
	mov	esi, DWORD PTR [ebp+92]
$LN3@Compile:

; 434  :     items.clear();

	mov	DWORD PTR [ebp+96], esi

; 435  :     // create new
; 436  :     if (m_Def){

	mov	eax, DWORD PTR [ebp+72]
	test	eax, eax
	je	$LN121@Compile
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	ecx, DWORD PTR [eax+16]
	sub	ecx, DWORD PTR [eax+12]
	sar	ecx, 2

; 1259 :         if (_Newsize > _Oldsize) { // append

	test	ecx, ecx
	je	SHORT $LN38@Compile

; 1260 :             const auto _Oldcapacity = static_cast<size_type>(_My_data._Myend - _Myfirst);

	mov	eax, DWORD PTR [ebp+100]
	sub	eax, esi
	sar	eax, 2
	imul	eax, eax, -1227133513

; 1261 :             if (_Newsize > _Oldcapacity) { // reallocate

	cmp	ecx, eax
	jbe	SHORT $LN39@Compile

; 1262 :                 _Resize_reallocate(_Newsize, _Val);

	lea	eax, DWORD PTR $T1[esp+16]
	push	eax
	push	ecx
	lea	ecx, DWORD PTR [ebp+92]
	call	??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@USItem@CParticleGroup@PS@@V?$xalloc@USItem@CParticleGroup@PS@@@@@std@@AAEXIABU_Value_init_tag@1@@Z ; std::vector<PS::CParticleGroup::SItem,xalloc<PS::CParticleGroup::SItem> >::_Resize_reallocate<std::_Value_init_tag>

; 1263 :                 return;

	jmp	SHORT $LN38@Compile
$LN39@Compile:

; 1264 :             }
; 1265 : 
; 1266 :             const pointer _Oldlast = _Mylast;
; 1267 :             _Mylast                = _Ufill(_Oldlast, _Newsize - _Oldsize, _Val);

	push	DWORD PTR $T1[esp+16]
	push	ecx
	push	esi
	call	?_Ufill@?$vector@USItem@CParticleGroup@PS@@V?$xalloc@USItem@CParticleGroup@PS@@@@@std@@AAEPAUSItem@CParticleGroup@PS@@PAU345@IU_Value_init_tag@2@@Z ; std::vector<PS::CParticleGroup::SItem,xalloc<PS::CParticleGroup::SItem> >::_Ufill
	mov	DWORD PTR [ebp+96], eax
$LN38@Compile:

; 1468 :         return const_iterator(_My_data._Myfirst, _STD addressof(_My_data));

	mov	eax, DWORD PTR [ebp+72]

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	esi, DWORD PTR [eax+12]

; 150  :         return _Ptr == _Right._Ptr;

	cmp	esi, DWORD PTR [eax+16]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp

; 438  :         for (CPGDef::EffectVec::const_iterator e_it=m_Def->m_Effects.begin(); e_it!=m_Def->m_Effects.end(); e_it++){

	je	$LN121@Compile
	push	edi
$LL7@Compile:
; File I:\Vitalya\mine\NSProjectX\xrCore\xrstring.h

; 65   : 	str_c				operator*	() const						{	return p_?p_->value:0;							}

	mov	edi, DWORD PTR [esi]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\PSLibrary.cpp

; 61   : 	PS::PEDIt it = FindPEDIt(Name);

	mov	ecx, OFFSET ?RImplementation@@3VCRender@@A+956
; File I:\Vitalya\mine\NSProjectX\xrCore\xrstring.h

; 65   : 	str_c				operator*	() const						{	return p_?p_->value:0;							}

	mov	edi, DWORD PTR [edi+4]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\PSLibrary.cpp

; 61   : 	PS::PEDIt it = FindPEDIt(Name);

	lea	eax, DWORD PTR [edi+12]
	neg	edi
	sbb	edi, edi
	and	edi, eax
	lea	eax, DWORD PTR _it$2[esp+20]
	push	edi
	push	eax
	call	?FindPEDIt@CPSLibrary@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPEDef@PS@@@std@@@std@@@std@@PBD@Z ; CPSLibrary::FindPEDIt
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 150  :         return _Ptr == _Right._Ptr;

	mov	eax, DWORD PTR _it$2[esp+20]
	cmp	eax, DWORD PTR ?RImplementation@@3VCRender@@A+960
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\PSLibrary.cpp

; 62   :     return (it==m_PEDs.end())?0:*it;

	jne	SHORT $LN69@Compile
	xor	ebx, ebx
	jmp	SHORT $LN70@Compile
$LN69@Compile:
	mov	ebx, DWORD PTR [eax]
$LN70@Compile:
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp

; 156  : 	PS::CPEDef*	SE		= PSLibrary.FindPED	(name);		R_ASSERT3(SE,"Particle effect doesn't exist",name);

	cmp	BYTE PTR ?ignore_always@?3??model_CreatePE@CRender@@QAEPAVIRender_Visual@@PBD@Z@4_NA, 0
	jne	SHORT $LN62@Compile
	test	ebx, ebx
	jne	SHORT $LN62@Compile
	mov	ecx, DWORD PTR __imp_?Debug@@3VxrDebug@@A
	push	OFFSET ?ignore_always@?3??model_CreatePE@CRender@@QAEPAVIRender_Visual@@PBD@Z@4_NA
	push	OFFSET ??_C@_0BI@HOANMMBE@CRender?3?3model_CreatePE@
	push	156					; 0000009cH
	push	OFFSET ??_C@_0EC@GAKMNDAB@I?3?2Vitalya?2mine?2NSProjectX?2laye@
	push	edi
	push	OFFSET ??_C@_0BO@PKGKJKHO@Particle?5effect?5doesn?8t?5exist@
	push	OFFSET ??_C@_02ODEKANEE@SE@
	call	DWORD PTR __imp_?fail@xrDebug@@QAEXPBD000H0AA_N@Z
$LN62@Compile:

; 157  : 	return				Models->CreatePE	(SE);

	push	ebx
	call	?CreatePE@CModelPool@@QAEPAVIRender_Visual@@PAVCPEDef@PS@@@Z ; CModelPool::CreatePE
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 141  :         return _Ptr - _Right._Ptr;

	mov	ecx, DWORD PTR [ebp+72]
	mov	edi, esi
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp

; 439  :         	CParticleEffect* eff = (CParticleEffect*)RImplementation.model_CreatePE(*(*e_it)->m_EffectName);

	mov	ebx, eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 141  :         return _Ptr - _Right._Ptr;

	sub	edi, DWORD PTR [ecx+12]
	sar	edi, 2
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleEffect.cpp

; 187  :     ParticleManager()->SetCallback		(m_HandleEffect,bc,dc,owner,p);

	call	DWORD PTR __imp_?ParticleManager@PAPI@@YAPAVIParticleManager@1@XZ
	push	edi
	push	ebp
	push	OFFSET ?OnGroupParticleDead@@YAXPAXIAAUParticle@PAPI@@I@Z ; OnGroupParticleDead
	mov	edx, DWORD PTR [eax]
	mov	ecx, eax
	push	OFFSET ?OnGroupParticleBirth@@YAXPAXIAAUParticle@PAPI@@I@Z ; OnGroupParticleBirth
	push	DWORD PTR [ebx+80]
	call	DWORD PTR [edx+48]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 141  :         return _Ptr - _Right._Ptr;

	mov	ecx, DWORD PTR _def$[esp+16]
	mov	eax, esi

; 74   :         ++_Ptr;

	add	esi, 4

; 141  :         return _Ptr - _Right._Ptr;

	sub	eax, DWORD PTR [ecx+12]
	sar	eax, 2

; 119  :         _Ptr += _Off;

	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp

; 441  : 			items[e_it-def->m_Effects.begin()].Set(eff);

	mov	eax, DWORD PTR [ebp+92]
	mov	DWORD PTR [eax+ecx*4], ebx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 150  :         return _Ptr == _Right._Ptr;

	mov	eax, DWORD PTR [ebp+72]
	cmp	esi, DWORD PTR [eax+16]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp

; 438  :         for (CPGDef::EffectVec::const_iterator e_it=m_Def->m_Effects.begin(); e_it!=m_Def->m_Effects.end(); e_it++){

	jne	$LL7@Compile

; 442  :         }
; 443  :     }
; 444  :     return TRUE;

	pop	edi
$LN121@Compile:
	pop	esi

; 445  : }

	pop	ebp
	mov	eax, 1
	pop	ebx
	pop	ecx
	ret	4
?Compile@CParticleGroup@PS@@QAEHPAVCPGDef@2@@Z ENDP	; PS::CParticleGroup::Compile
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xrstring.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_flags.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp
_TEXT	SEGMENT
??0CPGDef@PS@@QAE@XZ PROC				; PS::CPGDef::CPGDef
; _this$ = ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\xrstring.h

; 57   : 						shared_str	()								{	p_ = 0;											}

	mov	DWORD PTR [ecx], 0
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp

; 16   : }

	mov	eax, ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx+12], 0
	mov	DWORD PTR [ecx+16], 0
	mov	DWORD PTR [ecx+20], 0
; File I:\Vitalya\mine\NSProjectX\xrCore\_flags.h

; 15   :     IC	SelfRef	zero	()											{ flags=T(0);	return *this;	}

	mov	DWORD PTR [ecx+4], 0
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp

; 15   :     m_fTimeLimit	= 0.f;

	mov	DWORD PTR [ecx+8], 0

; 16   : }

	ret	0
??0CPGDef@PS@@QAE@XZ ENDP				; PS::CPGDef::CPGDef
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??1?$xr_vector@PAUSEffect@CPGDef@PS@@V?$xalloc@PAUSEffect@CPGDef@PS@@@@@@QAE@XZ
_TEXT	SEGMENT
??1?$xr_vector@PAUSEffect@CPGDef@PS@@V?$xalloc@PAUSEffect@CPGDef@PS@@@@@@QAE@XZ PROC ; xr_vector<PS::CPGDef::SEffect *,xalloc<PS::CPGDef::SEffect *> >::~xr_vector<PS::CPGDef::SEffect *,xalloc<PS::CPGDef::SEffect *> >, COMDAT
; _this$ = ecx

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	push	esi
	mov	esi, ecx
	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN6@xr_vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+4], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+8], 0
$LN6@xr_vector:
	pop	esi
	ret	0
??1?$xr_vector@PAUSEffect@CPGDef@PS@@V?$xalloc@PAUSEffect@CPGDef@PS@@@@@@QAE@XZ ENDP ; xr_vector<PS::CPGDef::SEffect *,xalloc<PS::CPGDef::SEffect *> >::~xr_vector<PS::CPGDef::SEffect *,xalloc<PS::CPGDef::SEffect *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xrstring.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrstring.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp
_TEXT	SEGMENT
??1CPGDef@PS@@QAE@XZ PROC				; PS::CPGDef::~CPGDef
; _this$ = ecx

; 19   : {

	push	ebx

; 20   :     for (EffectIt it=m_Effects.begin(); it!=m_Effects.end(); it++)

	mov	ebx, DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
	push	esi
	push	edi
	mov	edi, ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	esi, DWORD PTR [edi+12]

; 150  :         return _Ptr == _Right._Ptr;

	cmp	esi, DWORD PTR [edi+16]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp

; 20   :     for (EffectIt it=m_Effects.begin(); it!=m_Effects.end(); it++)

	je	$LN3@CPGDef
$LL4@CPGDef:
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h

; 151  : 	if (ptr) 

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN2@CPGDef
; File I:\Vitalya\mine\NSProjectX\xrCore\xrstring.h

; 50   : 	void				_dec		()								{	if (0==p_) return;	p_->dwReference--; 	if (0==p_->dwReference)	p_=0;						}

	mov	ecx, DWORD PTR [eax+16]
	test	ecx, ecx
	je	SHORT $LN40@CPGDef
	dec	DWORD PTR [ecx]
	mov	ecx, DWORD PTR [eax+16]
	cmp	DWORD PTR [ecx], 0
	jne	SHORT $LN40@CPGDef
	mov	DWORD PTR [eax+16], 0
$LN40@CPGDef:
	mov	ecx, DWORD PTR [eax+12]
	test	ecx, ecx
	je	SHORT $LN46@CPGDef
	dec	DWORD PTR [ecx]
	mov	ecx, DWORD PTR [eax+12]
	cmp	DWORD PTR [ecx], 0
	jne	SHORT $LN46@CPGDef
	mov	DWORD PTR [eax+12], 0
$LN46@CPGDef:
	mov	ecx, DWORD PTR [eax+8]
	test	ecx, ecx
	je	SHORT $LN52@CPGDef
	dec	DWORD PTR [ecx]
	mov	ecx, DWORD PTR [eax+8]
	cmp	DWORD PTR [ecx], 0
	jne	SHORT $LN52@CPGDef
	mov	DWORD PTR [eax+8], 0
$LN52@CPGDef:
	mov	ecx, DWORD PTR [eax+4]
	test	ecx, ecx
	je	SHORT $LN58@CPGDef
	dec	DWORD PTR [ecx]
	mov	ecx, DWORD PTR [eax+4]
	cmp	DWORD PTR [ecx], 0
	jne	SHORT $LN58@CPGDef
	mov	DWORD PTR [eax+4], 0
$LN58@CPGDef:
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h

; 144  : 		Memory.mem_free	(ptr);

	push	DWORD PTR [esi]
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	ebx

; 154  : 		ptr = nullptr;

	mov	DWORD PTR [esi], 0
$LN2@CPGDef:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 74   :         ++_Ptr;

	add	esi, 4

; 150  :         return _Ptr == _Right._Ptr;

	cmp	esi, DWORD PTR [edi+16]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp

; 20   :     for (EffectIt it=m_Effects.begin(); it!=m_Effects.end(); it++)

	jne	SHORT $LL4@CPGDef
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h

; 154  : 		ptr = nullptr;

	mov	esi, DWORD PTR [edi+12]
$LN3@CPGDef:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp

; 22   :     m_Effects.clear	();

	mov	DWORD PTR [edi+16], esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	test	esi, esi
	je	SHORT $LN65@CPGDef
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	esi
	call	ebx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [edi+12], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [edi+16], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [edi+20], 0
$LN65@CPGDef:
; File I:\Vitalya\mine\NSProjectX\xrCore\xrstring.h

; 50   : 	void				_dec		()								{	if (0==p_) return;	p_->dwReference--; 	if (0==p_->dwReference)	p_=0;						}

	mov	eax, DWORD PTR [edi]
	test	eax, eax
	je	SHORT $LN76@CPGDef
	dec	DWORD PTR [eax]
	mov	eax, DWORD PTR [edi]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN76@CPGDef
	mov	DWORD PTR [edi], 0
$LN76@CPGDef:
	pop	edi
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp

; 23   : }

	pop	esi
	pop	ebx
	ret	0
??1CPGDef@PS@@QAE@XZ ENDP				; PS::CPGDef::~CPGDef
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xrstring.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xrstring.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xrstring.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_flags.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_flags.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_flags.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xrstring.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xrstring.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xrstring.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_flags.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_flags.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_flags.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp
_TEXT	SEGMENT
_F$ = 8							; size = 4
?Load@CPGDef@PS@@QAEHAAVIReader@@@Z PROC		; PS::CPGDef::Load
; _this$ = ecx

; 52   : 	R_ASSERT		(F.find_chunk(PGD_CHUNK_VERSION));

	cmp	BYTE PTR ?ignore_always@?3??Load@CPGDef@PS@@QAEHAAVIReader@@@Z@4_NA, 0
	push	ebx
	push	esi
	mov	esi, DWORD PTR __imp_?fail@xrDebug@@QAEXPBD0H0AA_N@Z
	mov	ebx, ecx
	push	edi
	mov	edi, DWORD PTR _F$[esp+8]
	jne	SHORT $LN2@Load
	push	0
	push	1
	mov	ecx, edi
	call	DWORD PTR __imp_?find_chunk@?$IReaderBase@VIReader@@@@QAEIIPAH@Z
	test	eax, eax
	jne	SHORT $LN2@Load
	mov	ecx, DWORD PTR __imp_?Debug@@3VxrDebug@@A
	push	OFFSET ?ignore_always@?3??Load@CPGDef@PS@@QAEHAAVIReader@@@Z@4_NA
	push	OFFSET ??_C@_0BB@EIBCOMD@PS?3?3CPGDef?3?3Load@
	push	52					; 00000034H
	push	OFFSET ??_C@_0DN@BMEFJHKE@I?3?2Vitalya?2mine?2NSProjectX?2laye@
	push	OFFSET ??_C@_0CA@IGANCBFL@F?4find_chunk?$CIPGD_CHUNK_VERSION?$CJ@
	call	esi
$LN2@Load:

; 53   : 	u16 version		= F.r_u16();

	mov	ecx, edi
	call	DWORD PTR __imp_?r_u16@?$IReaderBase@VIReader@@@@QAEGXZ

; 54   : 
; 55   :     if (version!=PGD_VERSION){

	cmp	ax, 3
	je	SHORT $LN7@Load

; 56   : 		Log			("!Unsupported PG version. Load failed.");

	push	OFFSET ??_C@_0CG@FMBFHEJN@?$CBUnsupported?5PG?5version?4?5Load?5f@
	call	DWORD PTR __imp_?Log@@YAXPBD@Z
	add	esp, 4

; 57   :     	return FALSE;

	xor	eax, eax
	pop	edi

; 92   :     }
; 93   : 
; 94   : #ifdef _EDITOR
; 95   :     if (F.find_chunk(PGD_CHUNK_OWNER)){
; 96   : 	    F.r_stringZ	(m_OwnerName);
; 97   : 	    F.r_stringZ	(m_ModifName);
; 98   :         F.r			(&m_CreateTime,sizeof(m_CreateTime));
; 99   :         F.r			(&m_ModifTime,sizeof(m_ModifTime));
; 100  :     }
; 101  : #endif
; 102  :     
; 103  :     return TRUE;
; 104  : }                   

	pop	esi
	pop	ebx
	ret	4
$LN7@Load:

; 58   :     }
; 59   : 
; 60   : 	R_ASSERT		(F.find_chunk(PGD_CHUNK_NAME));

	cmp	BYTE PTR ?ignore_always@?L@??Load@CPGDef@PS@@QAEHAAVIReader@@@Z@4_NA, 0
	jne	SHORT $LN5@Load
	push	0
	push	2
	mov	ecx, edi
	call	DWORD PTR __imp_?find_chunk@?$IReaderBase@VIReader@@@@QAEIIPAH@Z
	test	eax, eax
	jne	SHORT $LN5@Load
	mov	ecx, DWORD PTR __imp_?Debug@@3VxrDebug@@A
	push	OFFSET ?ignore_always@?L@??Load@CPGDef@PS@@QAEHAAVIReader@@@Z@4_NA
	push	OFFSET ??_C@_0BB@EIBCOMD@PS?3?3CPGDef?3?3Load@
	push	60					; 0000003cH
	push	OFFSET ??_C@_0DN@BMEFJHKE@I?3?2Vitalya?2mine?2NSProjectX?2laye@
	push	OFFSET ??_C@_0BN@CKGJAGHC@F?4find_chunk?$CIPGD_CHUNK_NAME?$CJ@
	call	esi
$LN5@Load:

; 61   : 	F.r_stringZ		(m_Name);

	push	ebp
	mov	ebp, DWORD PTR __imp_?r_stringZ@IReader@@QAEXAAVshared_str@@@Z
	mov	ecx, edi
	push	ebx
	call	ebp

; 62   : 
; 63   : 	F.r_chunk		(PGD_CHUNK_FLAGS,&m_Flags);

	lea	eax, DWORD PTR [ebx+4]
	mov	ecx, edi
	push	eax
	push	3
	call	DWORD PTR __imp_?r_chunk@?$IReaderBase@VIReader@@@@QAEHIPAX@Z

; 64   : 
; 65   :     if (F.find_chunk(PGD_CHUNK_EFFECTS)){

	push	0
	push	4
	mov	ecx, edi
	call	DWORD PTR __imp_?find_chunk@?$IReaderBase@VIReader@@@@QAEIIPAH@Z
	test	eax, eax
	je	$LN13@Load

; 66   :         m_Effects.resize(F.r_u32());

	mov	ecx, edi
	call	DWORD PTR __imp_?r_u32@?$IReaderBase@VIReader@@@@QAEIXZ
	push	eax
	lea	ecx, DWORD PTR [ebx+12]
	call	?resize@?$vector@PAUSEffect@CPGDef@PS@@V?$xalloc@PAUSEffect@CPGDef@PS@@@@@std@@QAEXI@Z ; std::vector<PS::CPGDef::SEffect *,xalloc<PS::CPGDef::SEffect *> >::resize
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	esi, DWORD PTR [ebx+12]

; 150  :         return _Ptr == _Right._Ptr;

	cmp	esi, DWORD PTR [ebx+16]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp

; 67   :         for (EffectIt it=m_Effects.begin(); it!=m_Effects.end(); it++){

	je	$LN15@Load
	npad	4
$LL10@Load:
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h

; 68   : 	T* ptr	= (T*)Memory.mem_alloc(sizeof(T));

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	28					; 0000001cH
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
; File I:\Vitalya\mine\NSProjectX\xrCore\xrstring.h

; 57   : 						shared_str	()								{	p_ = 0;											}

	mov	DWORD PTR [eax+4], 0
	lea	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [eax+8], 0
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp

; 69   :             F.r_stringZ		((*it)->m_EffectName);

	push	ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\xrstring.h

; 57   : 						shared_str	()								{	p_ = 0;											}

	mov	DWORD PTR [eax+12], 0
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp

; 69   :             F.r_stringZ		((*it)->m_EffectName);

	mov	ecx, edi
; File I:\Vitalya\mine\NSProjectX\xrCore\xrstring.h

; 57   : 						shared_str	()								{	p_ = 0;											}

	mov	DWORD PTR [eax+16], 0
; File I:\Vitalya\mine\NSProjectX\xrCore\_flags.h

; 15   :     IC	SelfRef	zero	()											{ flags=T(0);	return *this;	}

	mov	DWORD PTR [eax], 0
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.h

; 33   : 							SEffect				(){m_Flags.zero();/*set(flEnabled)*/m_Time0=0;m_Time1=0;}

	mov	DWORD PTR [eax+20], 0
	mov	DWORD PTR [eax+24], 0
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp

; 68   :         	*it				= xr_new<SEffect>();

	mov	DWORD PTR [esi], eax

; 69   :             F.r_stringZ		((*it)->m_EffectName);

	call	ebp

; 70   :             F.r_stringZ		((*it)->m_OnPlayChildName);

	mov	eax, DWORD PTR [esi]
	mov	ecx, edi
	add	eax, 8
	push	eax
	call	ebp

; 71   :         	F.r_stringZ		((*it)->m_OnBirthChildName);

	mov	eax, DWORD PTR [esi]
	mov	ecx, edi
	add	eax, 12					; 0000000cH
	push	eax
	call	ebp

; 72   :         	F.r_stringZ		((*it)->m_OnDeadChildName);

	mov	eax, DWORD PTR [esi]
	mov	ecx, edi
	add	eax, 16					; 00000010H
	push	eax
	call	ebp

; 73   :             (*it)->m_Time0 	= F.r_float();

	mov	ecx, edi
	call	DWORD PTR __imp_?r_float@?$IReaderBase@VIReader@@@@QAEMXZ
	mov	eax, DWORD PTR [esi]

; 74   :             (*it)->m_Time1 	= F.r_float();

	mov	ecx, edi
	fstp	DWORD PTR [eax+20]
	call	DWORD PTR __imp_?r_float@?$IReaderBase@VIReader@@@@QAEMXZ
	mov	eax, DWORD PTR [esi]

; 75   :             (*it)->m_Flags.assign	(F.r_u32());

	mov	ecx, edi
	fstp	DWORD PTR [eax+24]
	call	DWORD PTR __imp_?r_u32@?$IReaderBase@VIReader@@@@QAEIXZ
; File I:\Vitalya\mine\NSProjectX\xrCore\_flags.h

; 21   : 	IC	SelfRef	assign	(const T mask)								{ flags	=	mask;		return *this;	}

	mov	ecx, DWORD PTR [esi]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 74   :         ++_Ptr;

	add	esi, 4
; File I:\Vitalya\mine\NSProjectX\xrCore\_flags.h

; 21   : 	IC	SelfRef	assign	(const T mask)								{ flags	=	mask;		return *this;	}

	mov	DWORD PTR [ecx], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 150  :         return _Ptr == _Right._Ptr;

	cmp	esi, DWORD PTR [ebx+16]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp

; 67   :         for (EffectIt it=m_Effects.begin(); it!=m_Effects.end(); it++){

	jne	$LL10@Load

; 76   :         }
; 77   :     }else{  //.???    

	jmp	$LN15@Load
$LN13@Load:

; 78   :         R_ASSERT		(F.find_chunk(PGD_CHUNK_EFFECTS2));

	cmp	BYTE PTR ?ignore_always@?BG@??Load@CPGDef@PS@@QAEHAAVIReader@@@Z@4_NA, 0
	jne	SHORT $LN11@Load
	push	0
	push	7
	mov	ecx, edi
	call	DWORD PTR __imp_?find_chunk@?$IReaderBase@VIReader@@@@QAEIIPAH@Z
	test	eax, eax
	jne	SHORT $LN11@Load
	mov	ecx, DWORD PTR __imp_?Debug@@3VxrDebug@@A
	push	OFFSET ?ignore_always@?BG@??Load@CPGDef@PS@@QAEHAAVIReader@@@Z@4_NA
	push	OFFSET ??_C@_0BB@EIBCOMD@PS?3?3CPGDef?3?3Load@
	push	78					; 0000004eH
	push	OFFSET ??_C@_0DN@BMEFJHKE@I?3?2Vitalya?2mine?2NSProjectX?2laye@
	push	OFFSET ??_C@_0CB@LFDJMMJL@F?4find_chunk?$CIPGD_CHUNK_EFFECTS2@
	call	esi
$LN11@Load:

; 79   :         m_Effects.resize(F.r_u32());

	mov	ecx, edi
	call	DWORD PTR __imp_?r_u32@?$IReaderBase@VIReader@@@@QAEIXZ
	push	eax
	lea	ecx, DWORD PTR [ebx+12]
	call	?resize@?$vector@PAUSEffect@CPGDef@PS@@V?$xalloc@PAUSEffect@CPGDef@PS@@@@@std@@QAEXI@Z ; std::vector<PS::CPGDef::SEffect *,xalloc<PS::CPGDef::SEffect *> >::resize
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	esi, DWORD PTR [ebx+12]

; 150  :         return _Ptr == _Right._Ptr;

	cmp	esi, DWORD PTR [ebx+16]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp

; 80   :         for (EffectIt it=m_Effects.begin(); it!=m_Effects.end(); it++){

	je	$LN15@Load
$LL16@Load:
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h

; 68   : 	T* ptr	= (T*)Memory.mem_alloc(sizeof(T));

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	28					; 0000001cH
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
; File I:\Vitalya\mine\NSProjectX\xrCore\xrstring.h

; 57   : 						shared_str	()								{	p_ = 0;											}

	mov	DWORD PTR [eax+4], 0
	lea	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [eax+8], 0
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp

; 82   :             F.r_stringZ		((*it)->m_EffectName);

	push	ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\xrstring.h

; 57   : 						shared_str	()								{	p_ = 0;											}

	mov	DWORD PTR [eax+12], 0
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp

; 82   :             F.r_stringZ		((*it)->m_EffectName);

	mov	ecx, edi
; File I:\Vitalya\mine\NSProjectX\xrCore\xrstring.h

; 57   : 						shared_str	()								{	p_ = 0;											}

	mov	DWORD PTR [eax+16], 0
; File I:\Vitalya\mine\NSProjectX\xrCore\_flags.h

; 15   :     IC	SelfRef	zero	()											{ flags=T(0);	return *this;	}

	mov	DWORD PTR [eax], 0
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.h

; 33   : 							SEffect				(){m_Flags.zero();/*set(flEnabled)*/m_Time0=0;m_Time1=0;}

	mov	DWORD PTR [eax+20], 0
	mov	DWORD PTR [eax+24], 0
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp

; 81   :         	*it				= xr_new<SEffect>();

	mov	DWORD PTR [esi], eax

; 82   :             F.r_stringZ		((*it)->m_EffectName);

	call	ebp

; 83   :             F.r_stringZ		((*it)->m_OnPlayChildName);

	mov	eax, DWORD PTR [esi]
	mov	ecx, edi
	add	eax, 8
	push	eax
	call	ebp

; 84   :             (*it)->m_Time0 	= F.r_float();

	mov	ecx, edi
	call	DWORD PTR __imp_?r_float@?$IReaderBase@VIReader@@@@QAEMXZ
	mov	eax, DWORD PTR [esi]

; 85   :             (*it)->m_Time1 	= F.r_float();

	mov	ecx, edi
	fstp	DWORD PTR [eax+20]
	call	DWORD PTR __imp_?r_float@?$IReaderBase@VIReader@@@@QAEMXZ
	mov	eax, DWORD PTR [esi]

; 86   :             (*it)->m_Flags.assign	(F.r_u32());

	mov	ecx, edi
	fstp	DWORD PTR [eax+24]
	call	DWORD PTR __imp_?r_u32@?$IReaderBase@VIReader@@@@QAEIXZ
; File I:\Vitalya\mine\NSProjectX\xrCore\_flags.h

; 21   : 	IC	SelfRef	assign	(const T mask)								{ flags	=	mask;		return *this;	}

	mov	ecx, DWORD PTR [esi]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 74   :         ++_Ptr;

	add	esi, 4
; File I:\Vitalya\mine\NSProjectX\xrCore\_flags.h

; 21   : 	IC	SelfRef	assign	(const T mask)								{ flags	=	mask;		return *this;	}

	mov	DWORD PTR [ecx], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 150  :         return _Ptr == _Right._Ptr;

	cmp	esi, DWORD PTR [ebx+16]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp

; 80   :         for (EffectIt it=m_Effects.begin(); it!=m_Effects.end(); it++){

	jne	SHORT $LL16@Load
$LN15@Load:

; 87   :         }
; 88   :     }
; 89   :     
; 90   :     if (F.find_chunk(PGD_CHUNK_TIME_LIMIT)){

	push	0
	push	5
	mov	ecx, edi
	call	DWORD PTR __imp_?find_chunk@?$IReaderBase@VIReader@@@@QAEIIPAH@Z
	pop	ebp
	test	eax, eax
	je	SHORT $LN23@Load

; 91   :    		m_fTimeLimit= F.r_float();

	mov	ecx, edi
	call	DWORD PTR __imp_?r_float@?$IReaderBase@VIReader@@@@QAEMXZ
	fstp	DWORD PTR [ebx+8]
$LN23@Load:

; 92   :     }
; 93   : 
; 94   : #ifdef _EDITOR
; 95   :     if (F.find_chunk(PGD_CHUNK_OWNER)){
; 96   : 	    F.r_stringZ	(m_OwnerName);
; 97   : 	    F.r_stringZ	(m_ModifName);
; 98   :         F.r			(&m_CreateTime,sizeof(m_CreateTime));
; 99   :         F.r			(&m_ModifTime,sizeof(m_ModifTime));
; 100  :     }
; 101  : #endif
; 102  :     
; 103  :     return TRUE;
; 104  : }                   

	pop	edi
	pop	esi
	mov	eax, 1
	pop	ebx
	ret	4
?Load@CPGDef@PS@@QAEHAAVIReader@@@Z ENDP		; PS::CPGDef::Load
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp
_TEXT	SEGMENT
_e$ = 8							; size = 4
?Set@SItem@CParticleGroup@PS@@QAEXPAVIRender_Visual@@@Z PROC ; PS::CParticleGroup::SItem::Set
; _this$ = ecx

; 150  : 	_effect=e;

	mov	eax, DWORD PTR _e$[esp-4]
	mov	DWORD PTR [ecx], eax

; 151  : }

	ret	4
?Set@SItem@CParticleGroup@PS@@QAEXPAVIRender_Visual@@@Z ENDP ; PS::CParticleGroup::SItem::Set
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp
_TEXT	SEGMENT
_visuals$ = -12						; size = 12
?Clear@SItem@CParticleGroup@PS@@QAEXXZ PROC		; PS::CParticleGroup::SItem::Clear
; _this$ = ecx

; 153  : {

	sub	esp, 12					; 0000000cH
	push	esi

; 155  :     GetVisuals		(visuals);

	lea	eax, DWORD PTR _visuals$[esp+16]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR _visuals$[esp+16], 0
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp

; 155  :     GetVisuals		(visuals);

	push	eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR _visuals$[esp+24], 0
	mov	DWORD PTR _visuals$[esp+28], 0
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp

; 155  :     GetVisuals		(visuals);

	call	?GetVisuals@SItem@CParticleGroup@PS@@QAEIAAV?$xr_vector@PAVIRender_Visual@@V?$xalloc@PAVIRender_Visual@@@@@@@Z ; PS::CParticleGroup::SItem::GetVisuals
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	esi, DWORD PTR _visuals$[esp+16]
	cmp	esi, DWORD PTR _visuals$[esp+20]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp

; 156  :     for (VisualVecIt it=visuals.begin(); it!=visuals.end(); it++)

	je	SHORT $LN3@Clear
$LL4@Clear:

; 157  : 	    ::Render->model_Delete(*it);

	mov	eax, DWORD PTR __imp_?Render@@3PAVIRender_interface@@A
	push	0
	push	esi
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+172]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 74   :         ++_Ptr;

	add	esi, 4

; 150  :         return _Ptr == _Right._Ptr;

	cmp	esi, DWORD PTR _visuals$[esp+20]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp

; 156  :     for (VisualVecIt it=visuals.begin(); it!=visuals.end(); it++)

	jne	SHORT $LL4@Clear
	mov	esi, DWORD PTR _visuals$[esp+16]
$LN3@Clear:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	test	esi, esi
	je	SHORT $LN44@Clear
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	esi
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN44@Clear:
	pop	esi
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp

; 158  : }

	add	esp, 12					; 0000000cH
	ret	0
?Clear@SItem@CParticleGroup@PS@@QAEXXZ ENDP		; PS::CParticleGroup::SItem::Clear
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_flags.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp
_TEXT	SEGMENT
tv903 = -128						; size = 4
$T2 = -124						; size = 4
$T3 = -120						; size = 4
$T4 = -116						; size = 4
$T5 = -112						; size = 4
$T6 = -108						; size = 4
$T7 = -104						; size = 4
$T8 = -100						; size = 4
$T9 = -96						; size = 4
tv955 = -92						; size = 4
$T10 = -88						; size = 4
$T11 = -84						; size = 4
$T12 = -80						; size = 4
$T13 = -80						; size = 4
_vel$ = -76						; size = 12
_M$ = -64						; size = 64
_emitter$ = 8						; size = 4
_eff_name$ = 12						; size = 4
_m$ = 16						; size = 4
?StartRelatedChild@SItem@CParticleGroup@PS@@QAEXPAVCParticleEffect@3@PBDAAUParticle@PAPI@@@Z PROC ; PS::CParticleGroup::SItem::StartRelatedChild
; _this$ = ecx

; 160  : {

	sub	esp, 128				; 00000080H
	push	esi
	push	edi

; 161  :     CParticleEffect*C		= static_cast<CParticleEffect*>(RImplementation.model_CreatePE(eff_name));

	push	DWORD PTR _eff_name$[esp+132]
	mov	edi, ecx
	call	?model_CreatePE@CRender@@QAEPAVIRender_Visual@@PBD@Z ; CRender::model_CreatePE
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	xmm0, DWORD PTR __real@41f26c9b
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp

; 161  :     CParticleEffect*C		= static_cast<CParticleEffect*>(RImplementation.model_CreatePE(eff_name));

	mov	esi, eax

; 162  :     Fmatrix M; 				M.identity();
; 163  :     Fvector vel; 			vel.sub(m.pos,m.posB); vel.div(fDT_STEP);

	mov	eax, DWORD PTR _m$[esp+132]
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 72   : 		_11=1; _12=0; _13=0; _14=0;

	xorps	xmm4, xmm4
	movss	xmm2, DWORD PTR __real@3f800000
	movss	DWORD PTR $T2[esp+136], xmm2
	mov	DWORD PTR _M$[esp+136], 1065353216	; 3f800000H
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	xmm5, DWORD PTR [eax]
	movss	xmm3, DWORD PTR [eax+4]
	movaps	xmm1, xmm5
	subss	xmm1, DWORD PTR [eax+12]
	movss	xmm6, DWORD PTR [eax+8]
	movaps	xmm7, xmm3
	subss	xmm7, DWORD PTR [eax+16]
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 72   : 		_11=1; _12=0; _13=0; _14=0;

	mov	DWORD PTR _M$[esp+140], 0
	mov	DWORD PTR _M$[esp+144], 0
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	mulss	xmm1, xmm0
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 72   : 		_11=1; _12=0; _13=0; _14=0;

	mov	DWORD PTR _M$[esp+148], 0
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 45   : 	ICF SelfRef	div(T s)								{ x/=s;		y/=s;    z/=s;				return *this;	};

	mulss	xmm7, xmm0
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 73   : 		_21=0; _22=1; _23=0; _24=0;

	mov	DWORD PTR _M$[esp+152], 0
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	DWORD PTR tv903[esp+136], xmm1

; 45   : 	ICF SelfRef	div(T s)								{ x/=s;		y/=s;    z/=s;				return *this;	};

	movss	DWORD PTR _vel$[esp+136], xmm1

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movaps	xmm1, xmm6
	subss	xmm1, DWORD PTR [eax+20]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp

; 164  :     if (emitter->m_RT_Flags.is(CParticleEffect::flRT_XFORM)){

	mov	eax, DWORD PTR _emitter$[esp+132]
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 73   : 		_21=0; _22=1; _23=0; _24=0;

	mov	DWORD PTR _M$[esp+156], 1065353216	; 3f800000H
	mov	DWORD PTR _M$[esp+160], 0
	mov	DWORD PTR _M$[esp+164], 0
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp

; 164  :     if (emitter->m_RT_Flags.is(CParticleEffect::flRT_XFORM)){

	test	BYTE PTR [eax+176], 4
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 45   : 	ICF SelfRef	div(T s)								{ x/=s;		y/=s;    z/=s;				return *this;	};

	mulss	xmm1, xmm0
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 74   : 		_31=0; _32=0; _33=1; _34=0;

	mov	DWORD PTR _M$[esp+168], 0
	mov	DWORD PTR _M$[esp+172], 0
	mov	DWORD PTR _M$[esp+176], 1065353216	; 3f800000H
	mov	DWORD PTR _M$[esp+180], 0

; 75   : 		_41=0; _42=0; _43=0; _44=1;

	mov	DWORD PTR _M$[esp+196], 1065353216	; 3f800000H
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 45   : 	ICF SelfRef	div(T s)								{ x/=s;		y/=s;    z/=s;				return *this;	};

	movss	DWORD PTR _vel$[esp+140], xmm7
	movss	DWORD PTR tv955[esp+136], xmm1
	movss	DWORD PTR _vel$[esp+144], xmm1
; File I:\Vitalya\mine\NSProjectX\xrCore\_flags.h

; 23   : 	IC 	BOOL	is		(const T mask)						const	{ return mask==(flags&mask);			}

	movss	DWORD PTR $T3[esp+136], xmm4
	movss	DWORD PTR $T10[esp+136], xmm4
	movss	DWORD PTR $T4[esp+136], xmm2
	movss	DWORD PTR $T5[esp+136], xmm4
	movss	DWORD PTR $T6[esp+136], xmm4
	movss	DWORD PTR $T11[esp+136], xmm4
	movss	DWORD PTR $T7[esp+136], xmm4
	movss	DWORD PTR $T8[esp+136], xmm4
	movss	DWORD PTR $T9[esp+136], xmm2
	movss	DWORD PTR $T12[esp+136], xmm4
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp

; 164  :     if (emitter->m_RT_Flags.is(CParticleEffect::flRT_XFORM)){

	je	$LN2@StartRelat
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 24   : 	ICF SelfRef	set(const _vector3<float> &v)			{ x = T(v.x);	y = T(v.y);	z = T(v.z);	return *this;	};

	movss	xmm0, DWORD PTR [eax+104]
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 59   : 		c.set(a.c); _44_=a._44;

	movaps	xmm2, xmm7
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 24   : 	ICF SelfRef	set(const _vector3<float> &v)			{ x = T(v.x);	y = T(v.y);	z = T(v.z);	return *this;	};

	movss	DWORD PTR $T2[esp+136], xmm0
	movss	DWORD PTR _M$[esp+136], xmm0
	movss	xmm0, DWORD PTR [eax+108]
	movss	DWORD PTR $T5[esp+136], xmm0
	movss	DWORD PTR _M$[esp+140], xmm0
	movss	xmm0, DWORD PTR [eax+112]
	movss	DWORD PTR $T8[esp+136], xmm0
	movss	DWORD PTR _M$[esp+144], xmm0
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 56   : 		i.set(a.i); _14_=a._14;

	movss	xmm0, DWORD PTR [eax+116]
	movss	DWORD PTR _M$[esp+148], xmm0
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 24   : 	ICF SelfRef	set(const _vector3<float> &v)			{ x = T(v.x);	y = T(v.y);	z = T(v.z);	return *this;	};

	movss	xmm0, DWORD PTR [eax+124]
	movss	DWORD PTR $T4[esp+136], xmm0
	movss	DWORD PTR _M$[esp+156], xmm0
	movss	xmm0, DWORD PTR [eax+128]
	movss	DWORD PTR $T7[esp+136], xmm0
	movss	DWORD PTR _M$[esp+160], xmm0
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 57   : 		j.set(a.j); _24_=a._24;

	movss	xmm0, DWORD PTR [eax+132]
	movss	DWORD PTR _M$[esp+164], xmm0
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 24   : 	ICF SelfRef	set(const _vector3<float> &v)			{ x = T(v.x);	y = T(v.y);	z = T(v.z);	return *this;	};

	movss	xmm0, DWORD PTR [eax+136]
	movss	xmm4, DWORD PTR [eax+120]
	movss	DWORD PTR $T3[esp+136], xmm0
	movss	DWORD PTR _M$[esp+168], xmm0
	movss	xmm0, DWORD PTR [eax+140]
	movss	DWORD PTR $T6[esp+136], xmm0
	movss	DWORD PTR _M$[esp+172], xmm0
	movss	xmm0, DWORD PTR [eax+144]
	movss	DWORD PTR $T9[esp+136], xmm0
	movss	DWORD PTR _M$[esp+176], xmm0
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 58   : 		k.set(a.k); _34_=a._34;

	movss	xmm0, DWORD PTR [eax+148]
	movss	DWORD PTR _M$[esp+180], xmm0

; 59   : 		c.set(a.c); _44_=a._44;

	movss	xmm0, DWORD PTR [eax+164]
	movss	DWORD PTR _M$[esp+196], xmm0

; 516  : 		dest.x = v.x*_11 + v.y*_21 + v.z*_31;

	movss	xmm0, DWORD PTR $T2[esp+136]
	mulss	xmm0, DWORD PTR tv903[esp+136]

; 59   : 		c.set(a.c); _44_=a._44;

	mulss	xmm2, xmm4
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 24   : 	ICF SelfRef	set(const _vector3<float> &v)			{ x = T(v.x);	y = T(v.y);	z = T(v.z);	return *this;	};

	movss	DWORD PTR _M$[esp+152], xmm4
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 516  : 		dest.x = v.x*_11 + v.y*_21 + v.z*_31;

	addss	xmm2, xmm0
	movaps	xmm0, xmm1
	mulss	xmm0, DWORD PTR $T3[esp+136]
	movaps	xmm1, xmm7
	mulss	xmm1, DWORD PTR $T4[esp+136]

; 517  : 		dest.y = v.x*_12 + v.y*_22 + v.z*_32;

	mulss	xmm7, DWORD PTR $T7[esp+136]
	addss	xmm2, xmm0
	movss	xmm0, DWORD PTR $T5[esp+136]
	mulss	xmm0, DWORD PTR tv903[esp+136]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 24   : 	ICF SelfRef	set(const _vector3<float> &v)			{ x = T(v.x);	y = T(v.y);	z = T(v.z);	return *this;	};

	movss	DWORD PTR _vel$[esp+136], xmm2
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 517  : 		dest.y = v.x*_12 + v.y*_22 + v.z*_32;

	addss	xmm1, xmm0
	movss	xmm0, DWORD PTR tv955[esp+136]
	mulss	xmm0, DWORD PTR $T6[esp+136]
	addss	xmm1, xmm0

; 518  : 		dest.z = v.x*_13 + v.y*_23 + v.z*_33;

	movss	xmm0, DWORD PTR $T8[esp+136]
	mulss	xmm0, DWORD PTR tv903[esp+136]
	addss	xmm7, xmm0
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 24   : 	ICF SelfRef	set(const _vector3<float> &v)			{ x = T(v.x);	y = T(v.y);	z = T(v.z);	return *this;	};

	movss	DWORD PTR _vel$[esp+140], xmm1
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 518  : 		dest.z = v.x*_13 + v.y*_23 + v.z*_33;

	movss	xmm0, DWORD PTR tv955[esp+136]
	mulss	xmm0, DWORD PTR $T9[esp+136]
	addss	xmm7, xmm0
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 24   : 	ICF SelfRef	set(const _vector3<float> &v)			{ x = T(v.x);	y = T(v.y);	z = T(v.z);	return *this;	};

	movss	xmm0, DWORD PTR [eax+152]
	movss	DWORD PTR $T10[esp+136], xmm0
	movss	xmm0, DWORD PTR [eax+156]
	movss	DWORD PTR $T11[esp+136], xmm0
	movss	xmm0, DWORD PTR [eax+160]
	movss	DWORD PTR _vel$[esp+144], xmm7
	movss	DWORD PTR $T12[esp+136], xmm0
$LN2@StartRelat:
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 499  : 		dest.x = v.x*_11 + v.y*_21 + v.z*_31 + _41;

	movaps	xmm0, xmm3
	movaps	xmm2, xmm5
	mulss	xmm2, DWORD PTR $T2[esp+136]

; 500  : 		dest.y = v.x*_12 + v.y*_22 + v.z*_32 + _42;

	movaps	xmm1, xmm3
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp

; 171  :     C->Play					();

	mov	ecx, esi
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 500  : 		dest.y = v.x*_12 + v.y*_22 + v.z*_32 + _42;

	mulss	xmm1, DWORD PTR $T4[esp+136]

; 501  : 		dest.z = v.x*_13 + v.y*_23 + v.z*_33 + _43;

	mulss	xmm3, DWORD PTR $T7[esp+136]
	mulss	xmm0, xmm4
	addss	xmm2, xmm0
	movaps	xmm0, xmm6
	mulss	xmm0, DWORD PTR $T3[esp+136]
	addss	xmm2, xmm0
	movaps	xmm0, xmm5
	mulss	xmm0, DWORD PTR $T5[esp+136]
	mulss	xmm5, DWORD PTR $T8[esp+136]
	addss	xmm2, DWORD PTR $T10[esp+136]
	addss	xmm1, xmm0
	movaps	xmm0, xmm6
	mulss	xmm0, DWORD PTR $T6[esp+136]
	addss	xmm3, xmm5
	mulss	xmm6, DWORD PTR $T9[esp+136]
	addss	xmm1, xmm0
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 24   : 	ICF SelfRef	set(const _vector3<float> &v)			{ x = T(v.x);	y = T(v.y);	z = T(v.z);	return *this;	};

	movss	DWORD PTR _M$[esp+184], xmm2
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 501  : 		dest.z = v.x*_13 + v.y*_23 + v.z*_33 + _43;

	addss	xmm3, xmm6
	addss	xmm1, DWORD PTR $T11[esp+136]
	addss	xmm3, DWORD PTR $T12[esp+136]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 24   : 	ICF SelfRef	set(const _vector3<float> &v)			{ x = T(v.x);	y = T(v.y);	z = T(v.z);	return *this;	};

	movss	DWORD PTR _M$[esp+188], xmm1
	movss	DWORD PTR _M$[esp+192], xmm3
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp

; 171  :     C->Play					();

	mov	eax, DWORD PTR [esi]
	call	DWORD PTR [eax+56]

; 172  :     C->UpdateParent			(M,vel,FALSE);

	mov	eax, DWORD PTR [esi]
	lea	ecx, DWORD PTR _vel$[esp+136]
	push	0
	push	ecx
	lea	ecx, DWORD PTR _M$[esp+144]
	push	ecx
	mov	ecx, esi
	call	DWORD PTR [eax+48]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 730  :         if (_Mylast != _My_data._Myend) {

	mov	eax, DWORD PTR [edi+8]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp

; 173  :     _children_related.push_back(C);

	lea	ecx, DWORD PTR [edi+4]
	mov	DWORD PTR $T13[esp+136], esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 730  :         if (_Mylast != _My_data._Myend) {

	cmp	eax, DWORD PTR [ecx+8]
	je	SHORT $LN35@StartRelat

; 713  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

	mov	DWORD PTR [eax], esi

; 714  :         _Orphan_range(_Mylast, _Mylast);
; 715  :         _Ty& _Result = *_Mylast;
; 716  :         ++_Mylast;

	add	DWORD PTR [ecx+4], 4
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp

; 174  : }

	pop	edi
	pop	esi
	add	esp, 128				; 00000080H
	ret	12					; 0000000cH
$LN35@StartRelat:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 734  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	lea	edx, DWORD PTR $T13[esp+136]
	push	edx
	push	eax
	call	??$_Emplace_reallocate@PAVIRender_Visual@@@?$vector@PAVIRender_Visual@@V?$xalloc@PAVIRender_Visual@@@@@std@@QAEPAPAVIRender_Visual@@QAPAV2@$$QAPAV2@@Z ; std::vector<IRender_Visual *,xalloc<IRender_Visual *> >::_Emplace_reallocate<IRender_Visual *>
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp

; 174  : }

	pop	edi
	pop	esi
	add	esp, 128				; 00000080H
	ret	12					; 0000000cH
?StartRelatedChild@SItem@CParticleGroup@PS@@QAEXPAVCParticleEffect@3@PBDAAUParticle@PAPI@@@Z ENDP ; PS::CParticleGroup::SItem::StartRelatedChild
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp
_TEXT	SEGMENT
_idx$ = 8						; size = 4
?StopRelatedChild@SItem@CParticleGroup@PS@@QAEXI@Z PROC	; PS::CParticleGroup::SItem::StopRelatedChild
; _this$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 119  :         _Ptr += _Off;

	mov	eax, DWORD PTR _idx$[esp-4]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp

; 176  : {

	push	ebx
	push	esi
	mov	esi, ecx
	push	edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 119  :         _Ptr += _Off;

	lea	ebx, DWORD PTR [eax*4]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp

; 179  :     ((CParticleEffect*)V)->Stop	(TRUE);

	push	1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 119  :         _Ptr += _Off;

	mov	edi, DWORD PTR [esi+4]
	add	edi, ebx
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp

; 179  :     ((CParticleEffect*)V)->Stop	(TRUE);

	mov	ecx, DWORD PTR [edi]
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+60]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 730  :         if (_Mylast != _My_data._Myend) {

	mov	edx, DWORD PTR [esi+20]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp

; 180  :     _children_free.push_back	(V);

	lea	ecx, DWORD PTR [esi+16]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 730  :         if (_Mylast != _My_data._Myend) {

	cmp	edx, DWORD PTR [ecx+8]
	je	SHORT $LN26@StopRelate

; 713  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR [edx], eax

; 714  :         _Orphan_range(_Mylast, _Mylast);
; 715  :         _Ty& _Result = *_Mylast;
; 716  :         ++_Mylast;

	add	DWORD PTR [ecx+4], 4

; 731  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

	jmp	SHORT $LN25@StopRelate
$LN26@StopRelate:

; 732  :         }
; 733  : 
; 734  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	push	edi
	push	edx
	call	??$_Emplace_reallocate@ABQAVIRender_Visual@@@?$vector@PAVIRender_Visual@@V?$xalloc@PAVIRender_Visual@@@@@std@@QAEPAPAVIRender_Visual@@QAPAV2@ABQAV2@@Z ; std::vector<IRender_Visual *,xalloc<IRender_Visual *> >::_Emplace_reallocate<IRender_Visual * const &>
$LN25@StopRelate:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp

; 181  :     _children_related[idx]		= _children_related.back();

	mov	eax, DWORD PTR [esi+8]
	mov	ecx, DWORD PTR [esi+4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1390 :         --_Mylast;

	pop	edi
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp

; 181  :     _children_related[idx]		= _children_related.back();

	mov	eax, DWORD PTR [eax-4]
	mov	DWORD PTR [ebx+ecx], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1390 :         --_Mylast;

	add	DWORD PTR [esi+8], -4			; fffffffcH
	pop	esi
	pop	ebx
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp

; 183  : }

	ret	4
?StopRelatedChild@SItem@CParticleGroup@PS@@QAEXI@Z ENDP	; PS::CParticleGroup::SItem::StopRelatedChild
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_flags.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_flags.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_flags.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp
_TEXT	SEGMENT
tv903 = -128						; size = 4
$T3 = -124						; size = 4
$T4 = -120						; size = 4
$T5 = -116						; size = 4
$T6 = -112						; size = 4
$T7 = -108						; size = 4
$T8 = -104						; size = 4
$T9 = -100						; size = 4
$T10 = -96						; size = 4
tv955 = -92						; size = 4
$T11 = -88						; size = 4
$T12 = -84						; size = 4
$T13 = -80						; size = 4
$T14 = -80						; size = 4
_vel$15 = -76						; size = 12
_M$16 = -64						; size = 64
_emitter$ = 8						; size = 4
_nm$ = 12						; size = 4
_m$ = 16						; size = 4
?StartFreeChild@SItem@CParticleGroup@PS@@QAEXPAVCParticleEffect@3@PBDAAUParticle@PAPI@@@Z PROC ; PS::CParticleGroup::SItem::StartFreeChild
; _this$ = ecx

; 185  : {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	sub	esp, 128				; 00000080H
	push	ebx
	push	esi

; 186  :     CParticleEffect*C			= static_cast<CParticleEffect*>(RImplementation.model_CreatePE(nm));

	push	DWORD PTR _nm$[ebp]
	mov	ebx, ecx
	call	?model_CreatePE@CRender@@QAEPAVIRender_Visual@@PBD@Z ; CRender::model_CreatePE
	mov	esi, eax

; 187  :     if(!C->IsLooped()){

	mov	ecx, esi
	mov	edx, DWORD PTR [esi]
	call	DWORD PTR [edx+76]
	test	eax, eax
	jne	$LN2@StartFreeC
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	xmm0, DWORD PTR __real@41f26c9b
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 72   : 		_11=1; _12=0; _13=0; _14=0;

	xorps	xmm4, xmm4
	movss	xmm2, DWORD PTR __real@3f800000
	mov	DWORD PTR _M$16[esp+140], eax
	mov	DWORD PTR _M$16[esp+144], eax
	mov	DWORD PTR _M$16[esp+148], eax

; 73   : 		_21=0; _22=1; _23=0; _24=0;

	mov	DWORD PTR _M$16[esp+152], eax
	mov	DWORD PTR _M$16[esp+160], eax
	mov	DWORD PTR _M$16[esp+164], eax

; 74   : 		_31=0; _32=0; _33=1; _34=0;

	mov	DWORD PTR _M$16[esp+168], eax
	mov	DWORD PTR _M$16[esp+172], eax
	mov	DWORD PTR _M$16[esp+180], eax
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp

; 189  :         Fvector vel; 			vel.sub(m.pos,m.posB); vel.div(fDT_STEP);

	mov	eax, DWORD PTR _m$[ebp]
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 72   : 		_11=1; _12=0; _13=0; _14=0;

	movss	DWORD PTR $T3[esp+136], xmm2
	mov	DWORD PTR _M$16[esp+136], 1065353216	; 3f800000H

; 73   : 		_21=0; _22=1; _23=0; _24=0;

	mov	DWORD PTR _M$16[esp+156], 1065353216	; 3f800000H
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	xmm5, DWORD PTR [eax]
	movss	xmm3, DWORD PTR [eax+4]
	movaps	xmm1, xmm5
	subss	xmm1, DWORD PTR [eax+12]
	movss	xmm6, DWORD PTR [eax+8]
	movaps	xmm7, xmm3
	subss	xmm7, DWORD PTR [eax+16]
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 74   : 		_31=0; _32=0; _33=1; _34=0;

	mov	DWORD PTR _M$16[esp+176], 1065353216	; 3f800000H

; 75   : 		_41=0; _42=0; _43=0; _44=1;

	mov	DWORD PTR _M$16[esp+196], 1065353216	; 3f800000H
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	mulss	xmm1, xmm0

; 45   : 	ICF SelfRef	div(T s)								{ x/=s;		y/=s;    z/=s;				return *this;	};

	mulss	xmm7, xmm0

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	DWORD PTR tv903[esp+136], xmm1

; 45   : 	ICF SelfRef	div(T s)								{ x/=s;		y/=s;    z/=s;				return *this;	};

	movss	DWORD PTR _vel$15[esp+136], xmm1

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movaps	xmm1, xmm6
	subss	xmm1, DWORD PTR [eax+20]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp

; 190  :         if (emitter->m_RT_Flags.is(CParticleEffect::flRT_XFORM)){

	mov	eax, DWORD PTR _emitter$[ebp]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 45   : 	ICF SelfRef	div(T s)								{ x/=s;		y/=s;    z/=s;				return *this;	};

	movss	DWORD PTR _vel$15[esp+140], xmm7
; File I:\Vitalya\mine\NSProjectX\xrCore\_flags.h

; 23   : 	IC 	BOOL	is		(const T mask)						const	{ return mask==(flags&mask);			}

	movss	DWORD PTR $T4[esp+136], xmm4
	movss	DWORD PTR $T11[esp+136], xmm4
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp

; 190  :         if (emitter->m_RT_Flags.is(CParticleEffect::flRT_XFORM)){

	test	BYTE PTR [eax+176], 4
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 45   : 	ICF SelfRef	div(T s)								{ x/=s;		y/=s;    z/=s;				return *this;	};

	mulss	xmm1, xmm0
; File I:\Vitalya\mine\NSProjectX\xrCore\_flags.h

; 23   : 	IC 	BOOL	is		(const T mask)						const	{ return mask==(flags&mask);			}

	movss	DWORD PTR $T5[esp+136], xmm2
	movss	DWORD PTR $T6[esp+136], xmm4
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 45   : 	ICF SelfRef	div(T s)								{ x/=s;		y/=s;    z/=s;				return *this;	};

	movss	DWORD PTR tv955[esp+136], xmm1
	movss	DWORD PTR _vel$15[esp+144], xmm1
; File I:\Vitalya\mine\NSProjectX\xrCore\_flags.h

; 23   : 	IC 	BOOL	is		(const T mask)						const	{ return mask==(flags&mask);			}

	movss	DWORD PTR $T7[esp+136], xmm4
	movss	DWORD PTR $T12[esp+136], xmm4
	movss	DWORD PTR $T8[esp+136], xmm4
	movss	DWORD PTR $T9[esp+136], xmm4
	movss	DWORD PTR $T10[esp+136], xmm2
	movss	DWORD PTR $T13[esp+136], xmm4
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp

; 190  :         if (emitter->m_RT_Flags.is(CParticleEffect::flRT_XFORM)){

	je	$LN4@StartFreeC
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 24   : 	ICF SelfRef	set(const _vector3<float> &v)			{ x = T(v.x);	y = T(v.y);	z = T(v.z);	return *this;	};

	movss	xmm0, DWORD PTR [eax+104]
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 59   : 		c.set(a.c); _44_=a._44;

	movaps	xmm2, xmm7
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 24   : 	ICF SelfRef	set(const _vector3<float> &v)			{ x = T(v.x);	y = T(v.y);	z = T(v.z);	return *this;	};

	movss	DWORD PTR $T3[esp+136], xmm0
	movss	DWORD PTR _M$16[esp+136], xmm0
	movss	xmm0, DWORD PTR [eax+108]
	movss	DWORD PTR $T6[esp+136], xmm0
	movss	DWORD PTR _M$16[esp+140], xmm0
	movss	xmm0, DWORD PTR [eax+112]
	movss	DWORD PTR $T9[esp+136], xmm0
	movss	DWORD PTR _M$16[esp+144], xmm0
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 56   : 		i.set(a.i); _14_=a._14;

	movss	xmm0, DWORD PTR [eax+116]
	movss	DWORD PTR _M$16[esp+148], xmm0
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 24   : 	ICF SelfRef	set(const _vector3<float> &v)			{ x = T(v.x);	y = T(v.y);	z = T(v.z);	return *this;	};

	movss	xmm0, DWORD PTR [eax+124]
	movss	DWORD PTR $T5[esp+136], xmm0
	movss	DWORD PTR _M$16[esp+156], xmm0
	movss	xmm0, DWORD PTR [eax+128]
	movss	DWORD PTR $T8[esp+136], xmm0
	movss	DWORD PTR _M$16[esp+160], xmm0
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 57   : 		j.set(a.j); _24_=a._24;

	movss	xmm0, DWORD PTR [eax+132]
	movss	DWORD PTR _M$16[esp+164], xmm0
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 24   : 	ICF SelfRef	set(const _vector3<float> &v)			{ x = T(v.x);	y = T(v.y);	z = T(v.z);	return *this;	};

	movss	xmm0, DWORD PTR [eax+136]
	movss	xmm4, DWORD PTR [eax+120]
	movss	DWORD PTR $T4[esp+136], xmm0
	movss	DWORD PTR _M$16[esp+168], xmm0
	movss	xmm0, DWORD PTR [eax+140]
	movss	DWORD PTR $T7[esp+136], xmm0
	movss	DWORD PTR _M$16[esp+172], xmm0
	movss	xmm0, DWORD PTR [eax+144]
	movss	DWORD PTR $T10[esp+136], xmm0
	movss	DWORD PTR _M$16[esp+176], xmm0
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 58   : 		k.set(a.k); _34_=a._34;

	movss	xmm0, DWORD PTR [eax+148]
	movss	DWORD PTR _M$16[esp+180], xmm0

; 59   : 		c.set(a.c); _44_=a._44;

	movss	xmm0, DWORD PTR [eax+164]
	movss	DWORD PTR _M$16[esp+196], xmm0

; 516  : 		dest.x = v.x*_11 + v.y*_21 + v.z*_31;

	movss	xmm0, DWORD PTR $T3[esp+136]
	mulss	xmm0, DWORD PTR tv903[esp+136]

; 59   : 		c.set(a.c); _44_=a._44;

	mulss	xmm2, xmm4
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 24   : 	ICF SelfRef	set(const _vector3<float> &v)			{ x = T(v.x);	y = T(v.y);	z = T(v.z);	return *this;	};

	movss	DWORD PTR _M$16[esp+152], xmm4
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 516  : 		dest.x = v.x*_11 + v.y*_21 + v.z*_31;

	addss	xmm2, xmm0
	movaps	xmm0, xmm1
	mulss	xmm0, DWORD PTR $T4[esp+136]
	movaps	xmm1, xmm7
	mulss	xmm1, DWORD PTR $T5[esp+136]

; 517  : 		dest.y = v.x*_12 + v.y*_22 + v.z*_32;

	mulss	xmm7, DWORD PTR $T8[esp+136]
	addss	xmm2, xmm0
	movss	xmm0, DWORD PTR $T6[esp+136]
	mulss	xmm0, DWORD PTR tv903[esp+136]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 24   : 	ICF SelfRef	set(const _vector3<float> &v)			{ x = T(v.x);	y = T(v.y);	z = T(v.z);	return *this;	};

	movss	DWORD PTR _vel$15[esp+136], xmm2
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 517  : 		dest.y = v.x*_12 + v.y*_22 + v.z*_32;

	addss	xmm1, xmm0
	movss	xmm0, DWORD PTR tv955[esp+136]
	mulss	xmm0, DWORD PTR $T7[esp+136]
	addss	xmm1, xmm0

; 518  : 		dest.z = v.x*_13 + v.y*_23 + v.z*_33;

	movss	xmm0, DWORD PTR $T9[esp+136]
	mulss	xmm0, DWORD PTR tv903[esp+136]
	addss	xmm7, xmm0
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 24   : 	ICF SelfRef	set(const _vector3<float> &v)			{ x = T(v.x);	y = T(v.y);	z = T(v.z);	return *this;	};

	movss	DWORD PTR _vel$15[esp+140], xmm1
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 518  : 		dest.z = v.x*_13 + v.y*_23 + v.z*_33;

	movss	xmm0, DWORD PTR tv955[esp+136]
	mulss	xmm0, DWORD PTR $T10[esp+136]
	addss	xmm7, xmm0
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 24   : 	ICF SelfRef	set(const _vector3<float> &v)			{ x = T(v.x);	y = T(v.y);	z = T(v.z);	return *this;	};

	movss	xmm0, DWORD PTR [eax+152]
	movss	DWORD PTR $T11[esp+136], xmm0
	movss	xmm0, DWORD PTR [eax+156]
	movss	DWORD PTR $T12[esp+136], xmm0
	movss	xmm0, DWORD PTR [eax+160]
	movss	DWORD PTR _vel$15[esp+144], xmm7
	movss	DWORD PTR $T13[esp+136], xmm0
$LN4@StartFreeC:
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 499  : 		dest.x = v.x*_11 + v.y*_21 + v.z*_31 + _41;

	movaps	xmm2, xmm3
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp

; 197  :         C->Play					();

	mov	eax, DWORD PTR [esi]
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 499  : 		dest.x = v.x*_11 + v.y*_21 + v.z*_31 + _41;

	movaps	xmm0, xmm5
	mulss	xmm2, xmm4
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp

; 197  :         C->Play					();

	mov	ecx, esi
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 499  : 		dest.x = v.x*_11 + v.y*_21 + v.z*_31 + _41;

	mulss	xmm0, DWORD PTR $T3[esp+136]

; 500  : 		dest.y = v.x*_12 + v.y*_22 + v.z*_32 + _42;

	movaps	xmm1, xmm3
	mulss	xmm1, DWORD PTR $T5[esp+136]

; 501  : 		dest.z = v.x*_13 + v.y*_23 + v.z*_33 + _43;

	mulss	xmm3, DWORD PTR $T8[esp+136]
	addss	xmm2, xmm0
	movaps	xmm0, xmm6
	mulss	xmm0, DWORD PTR $T4[esp+136]
	addss	xmm2, xmm0
	movaps	xmm0, xmm5
	mulss	xmm0, DWORD PTR $T6[esp+136]
	mulss	xmm5, DWORD PTR $T9[esp+136]
	addss	xmm2, DWORD PTR $T11[esp+136]
	addss	xmm1, xmm0
	movaps	xmm0, xmm6
	mulss	xmm0, DWORD PTR $T7[esp+136]
	addss	xmm3, xmm5
	mulss	xmm6, DWORD PTR $T10[esp+136]
	addss	xmm1, xmm0
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 24   : 	ICF SelfRef	set(const _vector3<float> &v)			{ x = T(v.x);	y = T(v.y);	z = T(v.z);	return *this;	};

	movss	DWORD PTR _M$16[esp+184], xmm2
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 501  : 		dest.z = v.x*_13 + v.y*_23 + v.z*_33 + _43;

	addss	xmm3, xmm6
	addss	xmm1, DWORD PTR $T12[esp+136]
	addss	xmm3, DWORD PTR $T13[esp+136]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 24   : 	ICF SelfRef	set(const _vector3<float> &v)			{ x = T(v.x);	y = T(v.y);	z = T(v.z);	return *this;	};

	movss	DWORD PTR _M$16[esp+188], xmm1
	movss	DWORD PTR _M$16[esp+192], xmm3
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp

; 197  :         C->Play					();

	call	DWORD PTR [eax+56]

; 198  :         C->UpdateParent			(M,vel,FALSE);

	mov	eax, DWORD PTR [esi]
	lea	ecx, DWORD PTR _vel$15[esp+136]
	push	0
	push	ecx
	lea	ecx, DWORD PTR _M$16[esp+144]
	push	ecx
	mov	ecx, esi
	call	DWORD PTR [eax+48]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 730  :         if (_Mylast != _My_data._Myend) {

	mov	eax, DWORD PTR [ebx+20]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp

; 199  :         _children_free.push_back(C);

	lea	ecx, DWORD PTR [ebx+16]
	mov	DWORD PTR $T14[esp+136], esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 730  :         if (_Mylast != _My_data._Myend) {

	cmp	eax, DWORD PTR [ecx+8]
	je	SHORT $LN37@StartFreeC

; 713  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

	mov	DWORD PTR [eax], esi

; 714  :         _Orphan_range(_Mylast, _Mylast);
; 715  :         _Ty& _Result = *_Mylast;
; 716  :         ++_Mylast;

	add	DWORD PTR [ecx+4], 4
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp

; 207  : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$LN37@StartFreeC:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 734  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	lea	edx, DWORD PTR $T14[esp+136]
	push	edx
	push	eax
	call	??$_Emplace_reallocate@PAVIRender_Visual@@@?$vector@PAVIRender_Visual@@V?$xalloc@PAVIRender_Visual@@@@@std@@QAEPAPAVIRender_Visual@@QAPAV2@$$QAPAV2@@Z ; std::vector<IRender_Visual *,xalloc<IRender_Visual *> >::_Emplace_reallocate<IRender_Visual *>
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp

; 207  : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$LN2@StartFreeC:

; 200  :     }else{
; 201  : #ifdef _EDITOR        
; 202  :         Msg			("!Can't use looped effect '%s' as 'On Birth' child for group.",nm);
; 203  : #else
; 204  :         Debug.fatal	(DEBUG_INFO,"Can't use looped effect '%s' as 'On Birth' child for group.",nm);

	push	DWORD PTR _nm$[ebp]
	push	OFFSET ??_C@_0DM@JNADIGEF@Can?8t?5use?5looped?5effect?5?8?$CFs?8?5as@
	push	OFFSET ??_C@_0CK@MIIKJOJA@PS?3?3CParticleGroup?3?3SItem?3?3Star@
	push	204					; 000000ccH
	push	OFFSET ??_C@_0DN@BMEFJHKE@I?3?2Vitalya?2mine?2NSProjectX?2laye@
	push	DWORD PTR __imp_?Debug@@3VxrDebug@@A
	call	DWORD PTR __imp_?fatal@xrDebug@@QAAXPBDH00ZZ
	add	esp, 24					; 00000018H

; 207  : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?StartFreeChild@SItem@CParticleGroup@PS@@QAEXPAVCParticleEffect@3@PBDAAUParticle@PAPI@@@Z ENDP ; PS::CParticleGroup::SItem::StartFreeChild
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp
_TEXT	SEGMENT
?Play@SItem@CParticleGroup@PS@@QAEXXZ PROC		; PS::CParticleGroup::SItem::Play
; _this$ = ecx

; 210  :     CParticleEffect* E	= static_cast<CParticleEffect*>(_effect);

	mov	ecx, DWORD PTR [ecx]

; 211  :     if (E) E->Play();

	test	ecx, ecx
	je	SHORT $LN2@Play
	mov	eax, DWORD PTR [ecx]
	jmp	DWORD PTR [eax+56]
$LN2@Play:

; 212  : }

	ret	0
?Play@SItem@CParticleGroup@PS@@QAEXXZ ENDP		; PS::CParticleGroup::SItem::Play
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp
_TEXT	SEGMENT
_def_stop$ = 8						; size = 4
?Stop@SItem@CParticleGroup@PS@@QAEXH@Z PROC		; PS::CParticleGroup::SItem::Stop
; _this$ = ecx

; 214  : {

	push	ebx

; 215  : 	// stop all effects
; 216  :     CParticleEffect* E	= static_cast<CParticleEffect*>(_effect);
; 217  :     if (E) E->Stop(def_stop);

	mov	ebx, DWORD PTR _def_stop$[esp]
	push	esi
	push	edi
	mov	edi, ecx
	mov	ecx, DWORD PTR [edi]
	test	ecx, ecx
	je	SHORT $LN14@Stop
	mov	eax, DWORD PTR [ecx]
	push	ebx
	call	DWORD PTR [eax+60]
$LN14@Stop:

; 219  :     for (it=_children_related.begin(); it!=_children_related.end(); it++)

	mov	esi, DWORD PTR [edi+4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 150  :         return _Ptr == _Right._Ptr;

	cmp	esi, DWORD PTR [edi+8]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp

; 219  :     for (it=_children_related.begin(); it!=_children_related.end(); it++)

	je	SHORT $LN3@Stop
	npad	3
$LL4@Stop:

; 220  :         static_cast<CParticleEffect*>(*it)->Stop(def_stop);

	mov	ecx, DWORD PTR [esi]
	push	ebx
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+60]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 74   :         ++_Ptr;

	add	esi, 4

; 150  :         return _Ptr == _Right._Ptr;

	cmp	esi, DWORD PTR [edi+8]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp

; 219  :     for (it=_children_related.begin(); it!=_children_related.end(); it++)

	jne	SHORT $LL4@Stop
$LN3@Stop:

; 221  :     for (it=_children_free.begin(); it!=_children_free.end(); it++)

	mov	esi, DWORD PTR [edi+16]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 150  :         return _Ptr == _Right._Ptr;

	mov	eax, DWORD PTR [edi+20]
	cmp	esi, eax
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp

; 221  :     for (it=_children_free.begin(); it!=_children_free.end(); it++)

	je	SHORT $LN6@Stop
	npad	6
$LL7@Stop:

; 222  :         static_cast<CParticleEffect*>(*it)->Stop(def_stop);

	mov	ecx, DWORD PTR [esi]
	push	ebx
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+60]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 150  :         return _Ptr == _Right._Ptr;

	mov	eax, DWORD PTR [edi+20]

; 74   :         ++_Ptr;

	add	esi, 4

; 150  :         return _Ptr == _Right._Ptr;

	cmp	esi, eax
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp

; 221  :     for (it=_children_free.begin(); it!=_children_free.end(); it++)

	jne	SHORT $LL7@Stop
$LN6@Stop:

; 223  :     // and delete if !deffered
; 224  :     if (!def_stop){

	test	ebx, ebx
	jne	SHORT $LN15@Stop

; 225  :         for (it=_children_related.begin(); it!=_children_related.end(); it++)	::Render->model_Delete(*it);

	mov	esi, DWORD PTR [edi+4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 150  :         return _Ptr == _Right._Ptr;

	cmp	esi, DWORD PTR [edi+8]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp

; 225  :         for (it=_children_related.begin(); it!=_children_related.end(); it++)	::Render->model_Delete(*it);

	je	SHORT $LN9@Stop
	npad	2
$LL10@Stop:
	mov	eax, DWORD PTR __imp_?Render@@3PAVIRender_interface@@A
	push	0
	push	esi
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+172]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 74   :         ++_Ptr;

	add	esi, 4

; 150  :         return _Ptr == _Right._Ptr;

	cmp	esi, DWORD PTR [edi+8]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp

; 225  :         for (it=_children_related.begin(); it!=_children_related.end(); it++)	::Render->model_Delete(*it);

	jne	SHORT $LL10@Stop
	mov	eax, DWORD PTR [edi+20]
$LN9@Stop:

; 226  :         for (it=_children_free.begin(); it!=_children_free.end(); it++)			::Render->model_Delete(*it);

	mov	esi, DWORD PTR [edi+16]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 150  :         return _Ptr == _Right._Ptr;

	cmp	esi, eax
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp

; 226  :         for (it=_children_free.begin(); it!=_children_free.end(); it++)			::Render->model_Delete(*it);

	je	SHORT $LN12@Stop
$LL13@Stop:
	mov	eax, DWORD PTR __imp_?Render@@3PAVIRender_interface@@A
	push	0
	push	esi
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+172]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 74   :         ++_Ptr;

	add	esi, 4

; 150  :         return _Ptr == _Right._Ptr;

	cmp	esi, DWORD PTR [edi+20]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp

; 226  :         for (it=_children_free.begin(); it!=_children_free.end(); it++)			::Render->model_Delete(*it);

	jne	SHORT $LL13@Stop
$LN12@Stop:

; 227  :         _children_related.clear();

	mov	eax, DWORD PTR [edi+4]
	mov	DWORD PTR [edi+8], eax

; 228  :         _children_free.clear	();

	mov	eax, DWORD PTR [edi+16]
	mov	DWORD PTR [edi+20], eax
$LN15@Stop:

; 229  :     }
; 230  : }

	pop	edi
	pop	esi
	pop	ebx
	ret	4
?Stop@SItem@CParticleGroup@PS@@QAEXH@Z ENDP		; PS::CParticleGroup::SItem::Stop
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVIRender_Visual@@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVIRender_Visual@@@std@@@std@@@std@@QAE@XZ PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<IRender_Visual *> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<IRender_Visual *> > >, COMDAT
; _this$ = ecx

; 39   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator() noexcept : _Ptr() {}

	mov	DWORD PTR [ecx], 0
	mov	eax, ecx
	ret	0
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVIRender_Visual@@@std@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<IRender_Visual *> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<IRender_Visual *> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp
_TEXT	SEGMENT
?IsPlaying@SItem@CParticleGroup@PS@@QAEHXZ PROC		; PS::CParticleGroup::SItem::IsPlaying
; _this$ = ecx

; 233  :     CParticleEffect* E	= static_cast<CParticleEffect*>(_effect);

	mov	ecx, DWORD PTR [ecx]

; 234  :     return E?E->IsPlaying():FALSE;

	test	ecx, ecx
	je	SHORT $LN3@IsPlaying
	mov	eax, DWORD PTR [ecx]
	jmp	DWORD PTR [eax+64]
$LN3@IsPlaying:
	xor	eax, eax

; 235  : }

	ret	0
?IsPlaying@SItem@CParticleGroup@PS@@QAEHXZ ENDP		; PS::CParticleGroup::SItem::IsPlaying
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp
_TEXT	SEGMENT
_m$ = 8							; size = 4
_velocity$ = 12						; size = 4
_bXFORM$ = 16						; size = 4
?UpdateParent@SItem@CParticleGroup@PS@@QAEXABU?$_matrix@M@@ABU?$_vector3@M@@H@Z PROC ; PS::CParticleGroup::SItem::UpdateParent
; _this$ = ecx

; 238  :     CParticleEffect* E	= static_cast<CParticleEffect*>(_effect);

	mov	ecx, DWORD PTR [ecx]

; 239  :     if (E) E->UpdateParent(m,velocity,bXFORM);

	test	ecx, ecx
	je	SHORT $LN2@UpdatePare
	mov	eax, DWORD PTR [ecx]
	jmp	DWORD PTR [eax+48]
$LN2@UpdatePare:

; 240  : }

	ret	12					; 0000000cH
?UpdateParent@SItem@CParticleGroup@PS@@QAEXABU?$_matrix@M@@ABU?$_vector3@M@@H@Z ENDP ; PS::CParticleGroup::SItem::UpdateParent
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_flags.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xrstring.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xrstring.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp
_TEXT	SEGMENT
_PE$1$ = -4						; size = 4
_owner$ = 8						; size = 4
_param$ = 12						; size = 4
_m$ = 16						; size = 4
_idx$ = 20						; size = 4
?OnGroupParticleBirth@@YAXPAXIAAUParticle@PAPI@@I@Z PROC ; OnGroupParticleBirth

; 243  : {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	push	ecx
	push	ebx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1463 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));

	mov	ebx, DWORD PTR _owner$[ebp]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp

; 243  : {

	push	esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 119  :         _Ptr += _Off;

	mov	esi, DWORD PTR _param$[ebp]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp

; 243  : {

	push	edi

; 246  : 	PS::OnEffectParticleBirth(PE, param, m, idx);

	push	DWORD PTR _idx$[ebp]
	mov	eax, DWORD PTR [ebx+92]
	push	DWORD PTR _m$[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 119  :         _Ptr += _Off;

	lea	edi, DWORD PTR [esi*8]
	sub	edi, esi
	shl	edi, 2
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp

; 246  : 	PS::OnEffectParticleBirth(PE, param, m, idx);

	push	esi
	mov	eax, DWORD PTR [edi+eax]
	push	eax
	mov	DWORD PTR _PE$1$[esp+32], eax
	call	?OnEffectParticleBirth@PS@@YAXPAXIAAUParticle@PAPI@@I@Z ; PS::OnEffectParticleBirth

; 247  :     // if have child
; 248  :     const CPGDef* PGD			= PG->GetDefinition();					VERIFY(PGD);
; 249  :     const CPGDef::SEffect* eff	= PGD->m_Effects[param];

	mov	eax, DWORD PTR [ebx+72]
	add	esp, 16					; 00000010H
	mov	eax, DWORD PTR [eax+12]
	mov	esi, DWORD PTR [eax+esi*4]
; File I:\Vitalya\mine\NSProjectX\xrCore\_flags.h

; 23   : 	IC 	BOOL	is		(const T mask)						const	{ return mask==(flags&mask);			}

	mov	eax, DWORD PTR [esi]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp

; 250  :     if (eff->m_Flags.is(CPGDef::SEffect::flOnBirthChild))

	test	al, 32					; 00000020H
	je	SHORT $LN8@OnGroupPar
; File I:\Vitalya\mine\NSProjectX\xrCore\xrstring.h

; 65   : 	str_c				operator*	() const						{	return p_?p_->value:0;							}

	mov	ecx, DWORD PTR [esi+12]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp

; 251  :     	PG->items[param].StartFreeChild			(PE,*eff->m_OnBirthChildName,m);

	push	DWORD PTR _m$[ebp]
	lea	eax, DWORD PTR [ecx+12]
	neg	ecx
	sbb	ecx, ecx
	and	ecx, eax
	push	ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 119  :         _Ptr += _Off;

	mov	ecx, DWORD PTR [ebx+92]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp

; 251  :     	PG->items[param].StartFreeChild			(PE,*eff->m_OnBirthChildName,m);

	push	DWORD PTR _PE$1$[esp+24]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 119  :         _Ptr += _Off;

	add	ecx, edi
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp

; 251  :     	PG->items[param].StartFreeChild			(PE,*eff->m_OnBirthChildName,m);

	call	?StartFreeChild@SItem@CParticleGroup@PS@@QAEXPAVCParticleEffect@3@PBDAAUParticle@PAPI@@@Z ; PS::CParticleGroup::SItem::StartFreeChild
	mov	eax, DWORD PTR [esi]
$LN8@OnGroupPar:

; 252  :     if (eff->m_Flags.is(CPGDef::SEffect::flOnPlayChild))

	test	al, 2
	je	SHORT $LN9@OnGroupPar
; File I:\Vitalya\mine\NSProjectX\xrCore\xrstring.h

; 65   : 	str_c				operator*	() const						{	return p_?p_->value:0;							}

	mov	ecx, DWORD PTR [esi+8]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp

; 253  :     	PG->items[param].StartRelatedChild		(PE,*eff->m_OnPlayChildName,m);

	push	DWORD PTR _m$[ebp]
	lea	eax, DWORD PTR [ecx+12]
	neg	ecx
	sbb	ecx, ecx
	and	ecx, eax
	push	ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 119  :         _Ptr += _Off;

	mov	ecx, DWORD PTR [ebx+92]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp

; 253  :     	PG->items[param].StartRelatedChild		(PE,*eff->m_OnPlayChildName,m);

	push	DWORD PTR _PE$1$[esp+24]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 119  :         _Ptr += _Off;

	add	ecx, edi
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp

; 253  :     	PG->items[param].StartRelatedChild		(PE,*eff->m_OnPlayChildName,m);

	call	?StartRelatedChild@SItem@CParticleGroup@PS@@QAEXPAVCParticleEffect@3@PBDAAUParticle@PAPI@@@Z ; PS::CParticleGroup::SItem::StartRelatedChild
$LN9@OnGroupPar:

; 254  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?OnGroupParticleBirth@@YAXPAXIAAUParticle@PAPI@@I@Z ENDP ; OnGroupParticleBirth
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_flags.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xrstring.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp
_TEXT	SEGMENT
_PE$1$ = -4						; size = 4
_owner$ = 8						; size = 4
tv702 = 12						; size = 4
_param$ = 12						; size = 4
_m$ = 16						; size = 4
_idx$ = 20						; size = 4
?OnGroupParticleDead@@YAXPAXIAAUParticle@PAPI@@I@Z PROC	; OnGroupParticleDead

; 256  : {

	push	ecx

; 258  :     CParticleEffect*PE	= static_cast<CParticleEffect*>(PG->items[param]._effect);

	mov	edx, DWORD PTR _owner$[esp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 119  :         _Ptr += _Off;

	mov	ecx, DWORD PTR _param$[esp]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp

; 256  : {

	push	ebx
	push	ebp

; 259  : 	PS::OnEffectParticleDead(PE, param, m, idx);
; 260  :     // if have child
; 261  :     const CPGDef* PGD			= PG->GetDefinition();					VERIFY(PGD);
; 262  :     const CPGDef::SEffect* eff	= PGD->m_Effects[param];

	mov	eax, DWORD PTR [edx+72]
	push	esi
	mov	esi, DWORD PTR [edx+92]
	push	edi
	mov	eax, DWORD PTR [eax+12]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 119  :         _Ptr += _Off;

	lea	edi, DWORD PTR [ecx*8]
	sub	edi, ecx
	shl	edi, 2
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp

; 258  :     CParticleEffect*PE	= static_cast<CParticleEffect*>(PG->items[param]._effect);

	add	esi, edi

; 259  : 	PS::OnEffectParticleDead(PE, param, m, idx);
; 260  :     // if have child
; 261  :     const CPGDef* PGD			= PG->GetDefinition();					VERIFY(PGD);
; 262  :     const CPGDef::SEffect* eff	= PGD->m_Effects[param];

	mov	ebp, DWORD PTR [eax+ecx*4]
	mov	ebx, DWORD PTR [esi]
; File I:\Vitalya\mine\NSProjectX\xrCore\_flags.h

; 23   : 	IC 	BOOL	is		(const T mask)						const	{ return mask==(flags&mask);			}

	mov	eax, DWORD PTR [ebp]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp

; 258  :     CParticleEffect*PE	= static_cast<CParticleEffect*>(PG->items[param]._effect);

	mov	DWORD PTR _PE$1$[esp+20], ebx

; 263  :     if (eff->m_Flags.is(CPGDef::SEffect::flOnPlayChild))

	test	al, 2
	je	SHORT $LN8@OnGroupPar
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 119  :         _Ptr += _Off;

	mov	eax, DWORD PTR _idx$[esp+16]
	mov	ebx, DWORD PTR [esi+4]
	shl	eax, 2
	add	ebx, eax
	mov	DWORD PTR tv702[esp+16], eax
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp

; 179  :     ((CParticleEffect*)V)->Stop	(TRUE);

	push	1
	mov	ecx, DWORD PTR [ebx]
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+60]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 730  :         if (_Mylast != _My_data._Myend) {

	mov	edx, DWORD PTR [esi+20]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp

; 180  :     _children_free.push_back	(V);

	lea	ecx, DWORD PTR [esi+16]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 730  :         if (_Mylast != _My_data._Myend) {

	cmp	edx, DWORD PTR [ecx+8]
	je	SHORT $LN85@OnGroupPar

; 713  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

	mov	eax, DWORD PTR [ebx]
	mov	DWORD PTR [edx], eax

; 714  :         _Orphan_range(_Mylast, _Mylast);
; 715  :         _Ty& _Result = *_Mylast;
; 716  :         ++_Mylast;

	add	DWORD PTR [ecx+4], 4

; 731  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

	jmp	SHORT $LN84@OnGroupPar
$LN85@OnGroupPar:

; 732  :         }
; 733  : 
; 734  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	push	ebx
	push	edx
	call	??$_Emplace_reallocate@ABQAVIRender_Visual@@@?$vector@PAVIRender_Visual@@V?$xalloc@PAVIRender_Visual@@@@@std@@QAEPAPAVIRender_Visual@@QAPAV2@ABQAV2@@Z ; std::vector<IRender_Visual *,xalloc<IRender_Visual *> >::_Emplace_reallocate<IRender_Visual * const &>
$LN84@OnGroupPar:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp

; 181  :     _children_related[idx]		= _children_related.back();

	mov	eax, DWORD PTR [esi+8]
	mov	ecx, DWORD PTR [esi+4]
	mov	edx, DWORD PTR tv702[esp+16]
	mov	ebx, DWORD PTR _PE$1$[esp+20]
	mov	eax, DWORD PTR [eax-4]
	mov	DWORD PTR [edx+ecx], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1390 :         --_Mylast;

	add	DWORD PTR [esi+8], -4			; fffffffcH
	mov	eax, DWORD PTR [ebp]
	mov	edx, DWORD PTR _owner$[esp+16]
$LN8@OnGroupPar:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp

; 265  :     if (eff->m_Flags.is(CPGDef::SEffect::flOnDeadChild))

	test	al, 64					; 00000040H
	je	SHORT $LN9@OnGroupPar
; File I:\Vitalya\mine\NSProjectX\xrCore\xrstring.h

; 65   : 	str_c				operator*	() const						{	return p_?p_->value:0;							}

	mov	ecx, DWORD PTR [ebp+16]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp

; 266  :     	PG->items[param].StartFreeChild			(PE,*eff->m_OnDeadChildName,m);

	push	DWORD PTR _m$[esp+16]
	lea	eax, DWORD PTR [ecx+12]
	neg	ecx
	sbb	ecx, ecx
	and	ecx, eax
	push	ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 119  :         _Ptr += _Off;

	mov	ecx, DWORD PTR [edx+92]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp

; 266  :     	PG->items[param].StartFreeChild			(PE,*eff->m_OnDeadChildName,m);

	push	ebx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 119  :         _Ptr += _Off;

	add	ecx, edi
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp

; 266  :     	PG->items[param].StartFreeChild			(PE,*eff->m_OnDeadChildName,m);

	call	?StartFreeChild@SItem@CParticleGroup@PS@@QAEXPAVCParticleEffect@3@PBDAAUParticle@PAPI@@@Z ; PS::CParticleGroup::SItem::StartFreeChild
$LN9@OnGroupPar:

; 267  : }

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	pop	ecx
	ret	0
?OnGroupParticleDead@@YAXPAXIAAUParticle@PAPI@@I@Z ENDP	; OnGroupParticleDead
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp
;	COMDAT ??Rzero_vis_pred@@QAE_NPBVIRender_Visual@@@Z
_TEXT	SEGMENT
_x$ = 8							; size = 4
??Rzero_vis_pred@@QAE_NPBVIRender_Visual@@@Z PROC	; zero_vis_pred::operator(), COMDAT
; _this$dead$ = ecx

; 271  : 	bool operator()(const IRender_Visual* x){ return x==0; }

	cmp	DWORD PTR _x$[esp-4], 0
	sete	al
	ret	4
??Rzero_vis_pred@@QAE_NPBVIRender_Visual@@@Z ENDP	; zero_vis_pred::operator()
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xrstring.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_std_extensions.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_std_extensions.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_std_extensions.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_std_extensions.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_std_extensions.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_std_extensions.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_std_extensions.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_std_extensions.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_std_extensions.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_std_extensions.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_std_extensions.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_std_extensions.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_std_extensions.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_std_extensions.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_std_extensions.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_std_extensions.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_std_extensions.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_std_extensions.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_std_extensions.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_std_extensions.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_std_extensions.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_std_extensions.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_std_extensions.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_std_extensions.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp
_TEXT	SEGMENT
_particles$1 = -84					; size = 4
_vel$2 = -80						; size = 12
_M$3 = -68						; size = 64
_u_dt$ = 8						; size = 4
_rem_cnt$1$ = 12					; size = 4
_def$ = 12						; size = 4
_p_cnt$4 = 16						; size = 4
_box$ = 16						; size = 4
_bPlaying$ = 20						; size = 4
?OnFrame@SItem@CParticleGroup@PS@@QAEXIABUSEffect@CPGDef@3@AAV?$_box3@M@@AA_N@Z PROC ; PS::CParticleGroup::SItem::OnFrame
; _this$ = ecx

; 274  : {

	sub	esp, 84					; 00000054H
	push	ebx
	push	ebp
	mov	ebp, ecx

; 275  :     CParticleEffect* E		= static_cast<CParticleEffect*>(_effect);
; 276  :     if (E){

	mov	ecx, DWORD PTR _u_dt$[esp+88]
	push	esi
	push	edi
	mov	edi, DWORD PTR _box$[esp+96]
	mov	esi, DWORD PTR [ebp]
	test	esi, esi
	je	$LN6@OnFrame

; 277  :         E->OnFrame			(u_dt);

	mov	eax, DWORD PTR [esi]
	push	ecx
	mov	ecx, esi
	call	DWORD PTR [eax+52]

; 278  :         if (E->IsPlaying()){

	mov	eax, DWORD PTR [esi]
	mov	ecx, esi
	call	DWORD PTR [eax+64]
	test	eax, eax
	je	$LN332@OnFrame

; 279  :             bPlaying		= true;

	mov	eax, DWORD PTR _bPlaying$[esp+96]
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h

; 26   : 	IC	BOOL	is_valid	()											{return (x2>=x1)&&(y2>=y1)&&(z2>=z1);}

	movss	xmm0, DWORD PTR [esi+36]
	comiss	xmm0, DWORD PTR [esi+24]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp

; 279  :             bPlaying		= true;

	mov	BYTE PTR [eax], 1

; 280  :             if (E->vis.box.is_valid())     box.merge	(E->vis.box);

	lea	eax, DWORD PTR [esi+24]
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h

; 26   : 	IC	BOOL	is_valid	()											{return (x2>=x1)&&(y2>=y1)&&(z2>=z1);}

	jb	SHORT $LN16@OnFrame
	movss	xmm0, DWORD PTR [eax+16]
	comiss	xmm0, DWORD PTR [eax+4]
	jb	SHORT $LN16@OnFrame
	movss	xmm0, DWORD PTR [eax+20]
	comiss	xmm0, DWORD PTR [eax+8]
	jb	SHORT $LN16@OnFrame
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp

; 280  :             if (E->vis.box.is_valid())     box.merge	(E->vis.box);

	push	eax
	mov	ecx, edi
	call	?merge@?$_box3@M@@QAEAAV1@ABV1@@Z	; _box3<float>::merge
$LN16@OnFrame:

; 281  :             if (def.m_Flags.is(CPGDef::SEffect::flOnPlayChild)&&def.m_OnPlayChildName.size()){

	mov	eax, DWORD PTR _def$[esp+96]
	test	BYTE PTR [eax], 2
	je	$LN332@OnFrame
; File I:\Vitalya\mine\NSProjectX\xrCore\xrstring.h

; 71   : 	u32					size		()						const	{	if (0==p_) return 0; else return p_->dwLength;	}

	mov	eax, DWORD PTR [eax+8]
	test	eax, eax
	je	$LN332@OnFrame
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp

; 281  :             if (def.m_Flags.is(CPGDef::SEffect::flOnPlayChild)&&def.m_OnPlayChildName.size()){

	cmp	DWORD PTR [eax+4], 0
	je	$LN332@OnFrame

; 282  :                 PAPI::Particle* particles;
; 283  :                 u32 p_cnt;
; 284  :                 PAPI::ParticleManager()->GetParticles(E->GetHandleEffect(),particles,p_cnt);

	call	DWORD PTR __imp_?ParticleManager@PAPI@@YAPAVIParticleManager@1@XZ
	lea	ecx, DWORD PTR _p_cnt$4[esp+96]
	push	ecx
	lea	ecx, DWORD PTR _particles$1[esp+104]
	mov	edx, DWORD PTR [eax]
	push	ecx
	push	DWORD PTR [esi+80]
	mov	ecx, eax
	call	DWORD PTR [edx+52]

; 285  :                 VERIFY(p_cnt==_children_related.size());
; 286  :                 if (p_cnt){

	mov	eax, DWORD PTR _p_cnt$4[esp+96]
	test	eax, eax
	je	$LN332@OnFrame

; 287  :                     for(u32 i = 0; i < p_cnt; i++){

	xor	ebx, ebx
	test	eax, eax
	je	$LN332@OnFrame
	movss	xmm5, DWORD PTR __real@41f26c9b
	xor	esi, esi
$LL7@OnFrame:

; 288  :                         PAPI::Particle &m	= particles[i]; 

	mov	ecx, DWORD PTR _particles$1[esp+100]

; 289  :                         CParticleEffect* C 	= static_cast<CParticleEffect*>(_children_related[i]);

	mov	eax, DWORD PTR [ebp+4]

; 292  :                         C->UpdateParent		(M,vel,FALSE);

	push	0
	mov	edx, DWORD PTR [eax+ebx*4]
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 72   : 		_11=1; _12=0; _13=0; _14=0;

	mov	DWORD PTR _M$3[esp+104], 1065353216	; 3f800000H
	mov	DWORD PTR _M$3[esp+108], 0
	mov	DWORD PTR _M$3[esp+112], 0
	mov	DWORD PTR _M$3[esp+116], 0

; 73   : 		_21=0; _22=1; _23=0; _24=0;

	mov	DWORD PTR _M$3[esp+120], 0
	mov	DWORD PTR _M$3[esp+124], 1065353216	; 3f800000H
	mov	DWORD PTR _M$3[esp+128], 0
	mov	DWORD PTR _M$3[esp+132], 0

; 74   : 		_31=0; _32=0; _33=1; _34=0;

	mov	DWORD PTR _M$3[esp+136], 0
	mov	DWORD PTR _M$3[esp+140], 0
	mov	DWORD PTR _M$3[esp+144], 1065353216	; 3f800000H
	mov	DWORD PTR _M$3[esp+148], 0

; 75   : 		_41=0; _42=0; _43=0; _44=1;

	mov	DWORD PTR _M$3[esp+164], 1065353216	; 3f800000H

; 235  : 		identity();	c.set	(Loc.x,Loc.y,Loc.z);	

	movss	xmm2, DWORD PTR [esi+ecx+4]
	movss	xmm1, DWORD PTR [esi+ecx+8]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 23   : 	ICF	SelfRef	set(T _x, T _y, T _z)					{ x = _x;		y = _y;		z = _z;		return *this;	};

	movss	xmm0, DWORD PTR [esi+ecx]
	movss	DWORD PTR _M$3[esp+152], xmm0
	movss	DWORD PTR _M$3[esp+156], xmm2
	movss	DWORD PTR _M$3[esp+160], xmm1

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	xmm3, DWORD PTR [esi+ecx+4]
	movss	xmm1, DWORD PTR [esi+ecx+16]
	movss	xmm4, DWORD PTR [esi+ecx+8]
	subss	xmm3, xmm1
	movss	xmm2, DWORD PTR [esi+ecx+20]
	movss	xmm0, DWORD PTR [esi+ecx]
	subss	xmm4, xmm2
	subss	xmm0, DWORD PTR [esi+ecx+12]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp

; 292  :                         C->UpdateParent		(M,vel,FALSE);

	lea	ecx, DWORD PTR _vel$2[esp+104]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 45   : 	ICF SelfRef	div(T s)								{ x/=s;		y/=s;    z/=s;				return *this;	};

	mulss	xmm3, xmm5
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp

; 292  :                         C->UpdateParent		(M,vel,FALSE);

	push	ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 45   : 	ICF SelfRef	div(T s)								{ x/=s;		y/=s;    z/=s;				return *this;	};

	mulss	xmm4, xmm5
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp

; 292  :                         C->UpdateParent		(M,vel,FALSE);

	lea	ecx, DWORD PTR _M$3[esp+108]
	push	ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	mulss	xmm0, xmm5
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp

; 292  :                         C->UpdateParent		(M,vel,FALSE);

	mov	ecx, edx
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 45   : 	ICF SelfRef	div(T s)								{ x/=s;		y/=s;    z/=s;				return *this;	};

	movss	DWORD PTR _vel$2[esp+116], xmm3
	movss	DWORD PTR _vel$2[esp+120], xmm4
	movss	DWORD PTR _vel$2[esp+112], xmm0
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp

; 292  :                         C->UpdateParent		(M,vel,FALSE);

	mov	eax, DWORD PTR [edx]
	call	DWORD PTR [eax+48]
	movss	xmm5, DWORD PTR __real@41f26c9b
	inc	ebx
	add	esi, 72					; 00000048H
	cmp	ebx, DWORD PTR _p_cnt$4[esp+96]
	jb	$LL7@OnFrame
$LN332@OnFrame:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1531 :         return _My_data._Myfirst == _My_data._Mylast;

	mov	ecx, DWORD PTR _u_dt$[esp+96]
$LN6@OnFrame:
	mov	esi, DWORD PTR [ebp+4]
	cmp	esi, DWORD PTR [ebp+8]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp

; 299  :     if (!_children_related.empty()){

	je	$LN9@OnFrame
	npad	7
$LL10@OnFrame:

; 301  :             CParticleEffect* E	= static_cast<CParticleEffect*>(*it);

	mov	ebx, DWORD PTR [esi]

; 302  :             if (E){

	test	ebx, ebx
	je	$LN8@OnFrame

; 303  :                 E->OnFrame		(u_dt);

	mov	eax, DWORD PTR [ebx]
	push	ecx
	mov	ecx, ebx
	call	DWORD PTR [eax+52]

; 304  :                 if (E->IsPlaying()){

	mov	eax, DWORD PTR [ebx]
	mov	ecx, ebx
	call	DWORD PTR [eax+64]
	test	eax, eax
	je	$LN21@OnFrame

; 305  :                     bPlaying	= true;

	mov	eax, DWORD PTR _bPlaying$[esp+96]
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h

; 26   : 	IC	BOOL	is_valid	()											{return (x2>=x1)&&(y2>=y1)&&(z2>=z1);}

	movss	xmm1, DWORD PTR [ebx+24]
	movss	xmm0, DWORD PTR [ebx+36]
	comiss	xmm0, xmm1
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp

; 305  :                     bPlaying	= true;

	mov	BYTE PTR [eax], 1
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h

; 26   : 	IC	BOOL	is_valid	()											{return (x2>=x1)&&(y2>=y1)&&(z2>=z1);}

	jb	$LN8@OnFrame
	movss	xmm0, DWORD PTR [ebx+40]
	comiss	xmm0, DWORD PTR [ebx+28]
	jb	$LN8@OnFrame
	movss	xmm0, DWORD PTR [ebx+44]
	comiss	xmm0, DWORD PTR [ebx+32]
	jb	$LN8@OnFrame
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 53   : 	IC	SelfRef	min(const Self &v)						{ x = _min(x,v.x);	y = _min(y,v.y);	z = _min(z,v.z);			return *this;	}

	movss	xmm0, DWORD PTR [edi]
; File I:\Vitalya\mine\NSProjectX\xrCore\_std_extensions.h

; 93   : template <class T>	IC T		_min	(T a, T b)	{ return a<b?a:b;	}

	comiss	xmm1, xmm0
	ja	SHORT $LN108@OnFrame
	movaps	xmm0, xmm1
$LN108@OnFrame:
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 53   : 	IC	SelfRef	min(const Self &v)						{ x = _min(x,v.x);	y = _min(y,v.y);	z = _min(z,v.z);			return *this;	}

	movss	DWORD PTR [edi], xmm0
	movss	xmm0, DWORD PTR [edi+4]
	movss	xmm1, DWORD PTR [ebx+28]
; File I:\Vitalya\mine\NSProjectX\xrCore\_std_extensions.h

; 93   : template <class T>	IC T		_min	(T a, T b)	{ return a<b?a:b;	}

	comiss	xmm1, xmm0
	ja	SHORT $LN112@OnFrame
	movaps	xmm0, xmm1
$LN112@OnFrame:
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 53   : 	IC	SelfRef	min(const Self &v)						{ x = _min(x,v.x);	y = _min(y,v.y);	z = _min(z,v.z);			return *this;	}

	movss	DWORD PTR [edi+4], xmm0
	movss	xmm0, DWORD PTR [edi+8]
	movss	xmm1, DWORD PTR [ebx+32]
; File I:\Vitalya\mine\NSProjectX\xrCore\_std_extensions.h

; 93   : template <class T>	IC T		_min	(T a, T b)	{ return a<b?a:b;	}

	comiss	xmm1, xmm0
	ja	SHORT $LN116@OnFrame
	movaps	xmm0, xmm1
$LN116@OnFrame:
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 53   : 	IC	SelfRef	min(const Self &v)						{ x = _min(x,v.x);	y = _min(y,v.y);	z = _min(z,v.z);			return *this;	}

	movss	DWORD PTR [edi+8], xmm0

; 55   : 	IC	SelfRef	max(const Self &v)						{ x = _max(x,v.x);	y = _max(y,v.y);	z = _max(z,v.z);			return *this;	}

	movss	xmm0, DWORD PTR [edi+12]
	movss	xmm1, DWORD PTR [ebx+24]
; File I:\Vitalya\mine\NSProjectX\xrCore\_std_extensions.h

; 94   : template <class T>	IC T		_max	(T a, T b)	{ return a>b?a:b;	}

	comiss	xmm0, xmm1
	ja	SHORT $LN122@OnFrame
	movaps	xmm0, xmm1
$LN122@OnFrame:
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 55   : 	IC	SelfRef	max(const Self &v)						{ x = _max(x,v.x);	y = _max(y,v.y);	z = _max(z,v.z);			return *this;	}

	movss	DWORD PTR [edi+12], xmm0
	movss	xmm0, DWORD PTR [edi+16]
	movss	xmm1, DWORD PTR [ebx+28]
; File I:\Vitalya\mine\NSProjectX\xrCore\_std_extensions.h

; 94   : template <class T>	IC T		_max	(T a, T b)	{ return a>b?a:b;	}

	comiss	xmm0, xmm1
	ja	SHORT $LN126@OnFrame
	movaps	xmm0, xmm1
$LN126@OnFrame:
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 55   : 	IC	SelfRef	max(const Self &v)						{ x = _max(x,v.x);	y = _max(y,v.y);	z = _max(z,v.z);			return *this;	}

	movss	DWORD PTR [edi+16], xmm0
	movss	xmm0, DWORD PTR [edi+20]
	movss	xmm1, DWORD PTR [ebx+32]
; File I:\Vitalya\mine\NSProjectX\xrCore\_std_extensions.h

; 94   : template <class T>	IC T		_max	(T a, T b)	{ return a>b?a:b;	}

	comiss	xmm0, xmm1
	ja	SHORT $LN130@OnFrame
	movaps	xmm0, xmm1
$LN130@OnFrame:
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 55   : 	IC	SelfRef	max(const Self &v)						{ x = _max(x,v.x);	y = _max(y,v.y);	z = _max(z,v.z);			return *this;	}

	movss	DWORD PTR [edi+20], xmm0

; 53   : 	IC	SelfRef	min(const Self &v)						{ x = _min(x,v.x);	y = _min(y,v.y);	z = _min(z,v.z);			return *this;	}

	movss	xmm0, DWORD PTR [edi]
	movss	xmm1, DWORD PTR [ebx+36]
; File I:\Vitalya\mine\NSProjectX\xrCore\_std_extensions.h

; 93   : template <class T>	IC T		_min	(T a, T b)	{ return a<b?a:b;	}

	comiss	xmm1, xmm0
	ja	SHORT $LN138@OnFrame
	movaps	xmm0, xmm1
$LN138@OnFrame:
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 53   : 	IC	SelfRef	min(const Self &v)						{ x = _min(x,v.x);	y = _min(y,v.y);	z = _min(z,v.z);			return *this;	}

	movss	DWORD PTR [edi], xmm0
	movss	xmm0, DWORD PTR [edi+4]
	movss	xmm1, DWORD PTR [ebx+40]
; File I:\Vitalya\mine\NSProjectX\xrCore\_std_extensions.h

; 93   : template <class T>	IC T		_min	(T a, T b)	{ return a<b?a:b;	}

	comiss	xmm1, xmm0
	ja	SHORT $LN142@OnFrame
	movaps	xmm0, xmm1
$LN142@OnFrame:
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 53   : 	IC	SelfRef	min(const Self &v)						{ x = _min(x,v.x);	y = _min(y,v.y);	z = _min(z,v.z);			return *this;	}

	movss	DWORD PTR [edi+4], xmm0
	movss	xmm0, DWORD PTR [edi+8]
	movss	xmm1, DWORD PTR [ebx+44]
; File I:\Vitalya\mine\NSProjectX\xrCore\_std_extensions.h

; 93   : template <class T>	IC T		_min	(T a, T b)	{ return a<b?a:b;	}

	comiss	xmm1, xmm0
	ja	SHORT $LN146@OnFrame
	movaps	xmm0, xmm1
$LN146@OnFrame:
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 53   : 	IC	SelfRef	min(const Self &v)						{ x = _min(x,v.x);	y = _min(y,v.y);	z = _min(z,v.z);			return *this;	}

	movss	DWORD PTR [edi+8], xmm0

; 55   : 	IC	SelfRef	max(const Self &v)						{ x = _max(x,v.x);	y = _max(y,v.y);	z = _max(z,v.z);			return *this;	}

	movss	xmm0, DWORD PTR [edi+12]
	movss	xmm1, DWORD PTR [ebx+36]
; File I:\Vitalya\mine\NSProjectX\xrCore\_std_extensions.h

; 94   : template <class T>	IC T		_max	(T a, T b)	{ return a>b?a:b;	}

	comiss	xmm0, xmm1
	ja	SHORT $LN152@OnFrame
	movaps	xmm0, xmm1
$LN152@OnFrame:
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 55   : 	IC	SelfRef	max(const Self &v)						{ x = _max(x,v.x);	y = _max(y,v.y);	z = _max(z,v.z);			return *this;	}

	movss	DWORD PTR [edi+12], xmm0
	movss	xmm0, DWORD PTR [edi+16]
	movss	xmm1, DWORD PTR [ebx+40]
; File I:\Vitalya\mine\NSProjectX\xrCore\_std_extensions.h

; 94   : template <class T>	IC T		_max	(T a, T b)	{ return a>b?a:b;	}

	comiss	xmm0, xmm1
	ja	SHORT $LN156@OnFrame
	movaps	xmm0, xmm1
$LN156@OnFrame:
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 55   : 	IC	SelfRef	max(const Self &v)						{ x = _max(x,v.x);	y = _max(y,v.y);	z = _max(z,v.z);			return *this;	}

	movss	DWORD PTR [edi+16], xmm0
	movss	xmm0, DWORD PTR [edi+20]
	movss	xmm1, DWORD PTR [ebx+44]
; File I:\Vitalya\mine\NSProjectX\xrCore\_std_extensions.h

; 94   : template <class T>	IC T		_max	(T a, T b)	{ return a>b?a:b;	}

	comiss	xmm0, xmm1
	ja	SHORT $LN160@OnFrame
	movaps	xmm0, xmm1
$LN160@OnFrame:
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 55   : 	IC	SelfRef	max(const Self &v)						{ x = _max(x,v.x);	y = _max(y,v.y);	z = _max(z,v.z);			return *this;	}

	movss	DWORD PTR [edi+20], xmm0
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp

; 307  :                 }else{

	jmp	SHORT $LN8@OnFrame
$LN21@OnFrame:

; 308  :                 	if (def.m_Flags.is(CPGDef::SEffect::flOnPlayChildRewind)){

	mov	eax, DWORD PTR _def$[esp+96]
	test	BYTE PTR [eax], 16			; 00000010H
	je	SHORT $LN8@OnFrame

; 309  :                     	E->Play	();

	mov	eax, DWORD PTR [ebx]
	mov	ecx, ebx
	call	DWORD PTR [eax+56]
$LN8@OnFrame:

; 300  :         for (it=_children_related.begin(); it!=_children_related.end(); it++){

	mov	ecx, DWORD PTR _u_dt$[esp+96]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 74   :         ++_Ptr;

	add	esi, 4

; 150  :         return _Ptr == _Right._Ptr;

	cmp	esi, DWORD PTR [ebp+8]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp

; 300  :         for (it=_children_related.begin(); it!=_children_related.end(); it++){

	jne	$LL10@OnFrame
$LN9@OnFrame:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1531 :         return _My_data._Myfirst == _My_data._Mylast;

	mov	esi, DWORD PTR [ebp+16]
	cmp	esi, DWORD PTR [ebp+20]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp

; 315  :     if (!_children_free.empty()){

	je	$LN286@OnFrame

; 316  :     	u32 rem_cnt				= 0;

	mov	DWORD PTR _rem_cnt$1$[esp+96], 0
	npad	6
$LL13@OnFrame:

; 318  :             CParticleEffect* E	= static_cast<CParticleEffect*>(*it);

	mov	ebx, DWORD PTR [esi]

; 319  :             if (E){

	test	ebx, ebx
	je	$LN326@OnFrame

; 320  :                 E->OnFrame		(u_dt);

	mov	eax, DWORD PTR [ebx]
	mov	ecx, ebx
	push	DWORD PTR _u_dt$[esp+96]
	call	DWORD PTR [eax+52]

; 321  :                 if (E->IsPlaying()){ 

	mov	eax, DWORD PTR [ebx]
	mov	ecx, ebx
	call	DWORD PTR [eax+64]
	test	eax, eax
	je	$LN27@OnFrame

; 322  :                     bPlaying	= true;

	mov	eax, DWORD PTR _bPlaying$[esp+96]
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h

; 26   : 	IC	BOOL	is_valid	()											{return (x2>=x1)&&(y2>=y1)&&(z2>=z1);}

	movss	xmm1, DWORD PTR [ebx+24]
	movss	xmm0, DWORD PTR [ebx+36]
	comiss	xmm0, xmm1
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp

; 322  :                     bPlaying	= true;

	mov	BYTE PTR [eax], 1
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h

; 26   : 	IC	BOOL	is_valid	()											{return (x2>=x1)&&(y2>=y1)&&(z2>=z1);}

	jb	$LN326@OnFrame
	movss	xmm0, DWORD PTR [ebx+40]
	comiss	xmm0, DWORD PTR [ebx+28]
	jb	$LN326@OnFrame
	movss	xmm0, DWORD PTR [ebx+44]
	comiss	xmm0, DWORD PTR [ebx+32]
	jb	$LN326@OnFrame
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 53   : 	IC	SelfRef	min(const Self &v)						{ x = _min(x,v.x);	y = _min(y,v.y);	z = _min(z,v.z);			return *this;	}

	movss	xmm0, DWORD PTR [edi]
; File I:\Vitalya\mine\NSProjectX\xrCore\_std_extensions.h

; 93   : template <class T>	IC T		_min	(T a, T b)	{ return a<b?a:b;	}

	comiss	xmm1, xmm0
	ja	SHORT $LN198@OnFrame
	movaps	xmm0, xmm1
$LN198@OnFrame:
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 53   : 	IC	SelfRef	min(const Self &v)						{ x = _min(x,v.x);	y = _min(y,v.y);	z = _min(z,v.z);			return *this;	}

	movss	DWORD PTR [edi], xmm0
	movss	xmm0, DWORD PTR [edi+4]
	movss	xmm1, DWORD PTR [ebx+28]
; File I:\Vitalya\mine\NSProjectX\xrCore\_std_extensions.h

; 93   : template <class T>	IC T		_min	(T a, T b)	{ return a<b?a:b;	}

	comiss	xmm1, xmm0
	ja	SHORT $LN202@OnFrame
	movaps	xmm0, xmm1
$LN202@OnFrame:
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 53   : 	IC	SelfRef	min(const Self &v)						{ x = _min(x,v.x);	y = _min(y,v.y);	z = _min(z,v.z);			return *this;	}

	movss	DWORD PTR [edi+4], xmm0
	movss	xmm0, DWORD PTR [edi+8]
	movss	xmm1, DWORD PTR [ebx+32]
; File I:\Vitalya\mine\NSProjectX\xrCore\_std_extensions.h

; 93   : template <class T>	IC T		_min	(T a, T b)	{ return a<b?a:b;	}

	comiss	xmm1, xmm0
	ja	SHORT $LN206@OnFrame
	movaps	xmm0, xmm1
$LN206@OnFrame:
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 53   : 	IC	SelfRef	min(const Self &v)						{ x = _min(x,v.x);	y = _min(y,v.y);	z = _min(z,v.z);			return *this;	}

	movss	DWORD PTR [edi+8], xmm0

; 55   : 	IC	SelfRef	max(const Self &v)						{ x = _max(x,v.x);	y = _max(y,v.y);	z = _max(z,v.z);			return *this;	}

	movss	xmm0, DWORD PTR [edi+12]
	movss	xmm1, DWORD PTR [ebx+24]
; File I:\Vitalya\mine\NSProjectX\xrCore\_std_extensions.h

; 94   : template <class T>	IC T		_max	(T a, T b)	{ return a>b?a:b;	}

	comiss	xmm0, xmm1
	ja	SHORT $LN212@OnFrame
	movaps	xmm0, xmm1
$LN212@OnFrame:
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 55   : 	IC	SelfRef	max(const Self &v)						{ x = _max(x,v.x);	y = _max(y,v.y);	z = _max(z,v.z);			return *this;	}

	movss	DWORD PTR [edi+12], xmm0
	movss	xmm0, DWORD PTR [edi+16]
	movss	xmm1, DWORD PTR [ebx+28]
; File I:\Vitalya\mine\NSProjectX\xrCore\_std_extensions.h

; 94   : template <class T>	IC T		_max	(T a, T b)	{ return a>b?a:b;	}

	comiss	xmm0, xmm1
	ja	SHORT $LN216@OnFrame
	movaps	xmm0, xmm1
$LN216@OnFrame:
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 55   : 	IC	SelfRef	max(const Self &v)						{ x = _max(x,v.x);	y = _max(y,v.y);	z = _max(z,v.z);			return *this;	}

	movss	DWORD PTR [edi+16], xmm0
	movss	xmm0, DWORD PTR [edi+20]
	movss	xmm1, DWORD PTR [ebx+32]
; File I:\Vitalya\mine\NSProjectX\xrCore\_std_extensions.h

; 94   : template <class T>	IC T		_max	(T a, T b)	{ return a>b?a:b;	}

	comiss	xmm0, xmm1
	ja	SHORT $LN220@OnFrame
	movaps	xmm0, xmm1
$LN220@OnFrame:
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 55   : 	IC	SelfRef	max(const Self &v)						{ x = _max(x,v.x);	y = _max(y,v.y);	z = _max(z,v.z);			return *this;	}

	movss	DWORD PTR [edi+20], xmm0

; 53   : 	IC	SelfRef	min(const Self &v)						{ x = _min(x,v.x);	y = _min(y,v.y);	z = _min(z,v.z);			return *this;	}

	movss	xmm0, DWORD PTR [edi]
	movss	xmm1, DWORD PTR [ebx+36]
; File I:\Vitalya\mine\NSProjectX\xrCore\_std_extensions.h

; 93   : template <class T>	IC T		_min	(T a, T b)	{ return a<b?a:b;	}

	comiss	xmm1, xmm0
	ja	SHORT $LN228@OnFrame
	movaps	xmm0, xmm1
$LN228@OnFrame:
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 53   : 	IC	SelfRef	min(const Self &v)						{ x = _min(x,v.x);	y = _min(y,v.y);	z = _min(z,v.z);			return *this;	}

	movss	DWORD PTR [edi], xmm0
	movss	xmm0, DWORD PTR [edi+4]
	movss	xmm1, DWORD PTR [ebx+40]
; File I:\Vitalya\mine\NSProjectX\xrCore\_std_extensions.h

; 93   : template <class T>	IC T		_min	(T a, T b)	{ return a<b?a:b;	}

	comiss	xmm1, xmm0
	ja	SHORT $LN232@OnFrame
	movaps	xmm0, xmm1
$LN232@OnFrame:
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 53   : 	IC	SelfRef	min(const Self &v)						{ x = _min(x,v.x);	y = _min(y,v.y);	z = _min(z,v.z);			return *this;	}

	movss	DWORD PTR [edi+4], xmm0
	movss	xmm0, DWORD PTR [edi+8]
	movss	xmm1, DWORD PTR [ebx+44]
; File I:\Vitalya\mine\NSProjectX\xrCore\_std_extensions.h

; 93   : template <class T>	IC T		_min	(T a, T b)	{ return a<b?a:b;	}

	comiss	xmm1, xmm0
	ja	SHORT $LN236@OnFrame
	movaps	xmm0, xmm1
$LN236@OnFrame:
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 53   : 	IC	SelfRef	min(const Self &v)						{ x = _min(x,v.x);	y = _min(y,v.y);	z = _min(z,v.z);			return *this;	}

	movss	DWORD PTR [edi+8], xmm0

; 55   : 	IC	SelfRef	max(const Self &v)						{ x = _max(x,v.x);	y = _max(y,v.y);	z = _max(z,v.z);			return *this;	}

	movss	xmm0, DWORD PTR [edi+12]
	movss	xmm1, DWORD PTR [ebx+36]
; File I:\Vitalya\mine\NSProjectX\xrCore\_std_extensions.h

; 94   : template <class T>	IC T		_max	(T a, T b)	{ return a>b?a:b;	}

	comiss	xmm0, xmm1
	ja	SHORT $LN242@OnFrame
	movaps	xmm0, xmm1
$LN242@OnFrame:
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 55   : 	IC	SelfRef	max(const Self &v)						{ x = _max(x,v.x);	y = _max(y,v.y);	z = _max(z,v.z);			return *this;	}

	movss	DWORD PTR [edi+12], xmm0
	movss	xmm0, DWORD PTR [edi+16]
	movss	xmm1, DWORD PTR [ebx+40]
; File I:\Vitalya\mine\NSProjectX\xrCore\_std_extensions.h

; 94   : template <class T>	IC T		_max	(T a, T b)	{ return a>b?a:b;	}

	comiss	xmm0, xmm1
	ja	SHORT $LN246@OnFrame
	movaps	xmm0, xmm1
$LN246@OnFrame:
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 55   : 	IC	SelfRef	max(const Self &v)						{ x = _max(x,v.x);	y = _max(y,v.y);	z = _max(z,v.z);			return *this;	}

	movss	DWORD PTR [edi+16], xmm0
	movss	xmm0, DWORD PTR [edi+20]
	movss	xmm1, DWORD PTR [ebx+44]
; File I:\Vitalya\mine\NSProjectX\xrCore\_std_extensions.h

; 94   : template <class T>	IC T		_max	(T a, T b)	{ return a>b?a:b;	}

	comiss	xmm0, xmm1
	ja	SHORT $LN250@OnFrame
	movaps	xmm0, xmm1
$LN250@OnFrame:
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 55   : 	IC	SelfRef	max(const Self &v)						{ x = _max(x,v.x);	y = _max(y,v.y);	z = _max(z,v.z);			return *this;	}

	movss	DWORD PTR [edi+20], xmm0
$LN326@OnFrame:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 74   :         ++_Ptr;

	mov	ebx, DWORD PTR _rem_cnt$1$[esp+96]
$LN11@OnFrame:

; 150  :         return _Ptr == _Right._Ptr;

	mov	eax, DWORD PTR [ebp+20]

; 74   :         ++_Ptr;

	add	esi, 4

; 150  :         return _Ptr == _Right._Ptr;

	cmp	esi, eax
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp

; 317  :         for (it=_children_free.begin(); it!=_children_free.end(); it++){

	jne	$LL13@OnFrame

; 327  :                 }
; 328  :             }
; 329  :         }
; 330  :         // remove if stopped
; 331  :         if (rem_cnt){

	test	ebx, ebx
	je	SHORT $LN286@OnFrame
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility

; 5529 :     auto _UFirst      = _Get_unwrapped(_First);

	mov	edi, DWORD PTR [ebp+16]

; 5530 :     const auto _ULast = _Get_unwrapped(_Last);
; 5531 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	edi, eax
	je	SHORT $LN265@OnFrame
$LL272@OnFrame:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp

; 271  : 	bool operator()(const IRender_Visual* x){ return x==0; }

	cmp	DWORD PTR [edi], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility

; 5532 :         if (_Pred(*_UFirst)) {

	je	SHORT $LN322@OnFrame

; 5530 :     const auto _ULast = _Get_unwrapped(_Last);
; 5531 :     for (; _UFirst != _ULast; ++_UFirst) {

	add	edi, 4
	cmp	edi, eax
	jne	SHORT $LL272@OnFrame
$LN322@OnFrame:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1983 :     if (_UFirst != _ULast) {

	cmp	edi, eax
	je	SHORT $LN265@OnFrame

; 1984 :         while (++_UFirst != _ULast) {

	lea	ecx, DWORD PTR [edi+4]
	cmp	ecx, eax
	je	SHORT $LN265@OnFrame
	npad	5
$LL264@OnFrame:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp

; 271  : 	bool operator()(const IRender_Visual* x){ return x==0; }

	mov	edx, DWORD PTR [ecx]
	test	edx, edx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1985 :             if (!_Pred(*_UFirst)) {

	je	SHORT $LN267@OnFrame

; 1986 :                 *_UNext = _STD move(*_UFirst);

	mov	DWORD PTR [edi], edx

; 1987 :                 ++_UNext;

	add	edi, 4
$LN267@OnFrame:

; 1984 :         while (++_UFirst != _ULast) {

	add	ecx, 4
	cmp	ecx, eax
	jne	SHORT $LL264@OnFrame
$LN265@OnFrame:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1415 :         const pointer _Lastptr  = _Last._Ptr;

	mov	eax, DWORD PTR [ebp+20]

; 1416 :         auto& _My_data          = _Mypair._Myval2;
; 1417 :         pointer& _Mylast        = _My_data._Mylast;
; 1418 : 
; 1419 : #if _ITERATOR_DEBUG_LEVEL == 2
; 1420 :         _STL_VERIFY(_First._Getcont() == _STD addressof(_My_data) && _Last._Getcont() == _STD addressof(_My_data)
; 1421 :                         && _Firstptr >= _My_data._Myfirst && _Lastptr >= _Firstptr && _Mylast >= _Lastptr,
; 1422 :             "vector erase iterator outside range");
; 1423 : #endif // _ITERATOR_DEBUG_LEVEL == 2
; 1424 : 
; 1425 :         if (_Firstptr != _Lastptr) { // something to do, invalidate iterators

	cmp	edi, eax
	je	SHORT $LN286@OnFrame
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility

; 4065 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	mov	esi, eax
	sub	esi, eax

; 4066 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	push	esi
	push	eax
	push	edi
	call	_memmove

; 4067 :     if constexpr (is_pointer_v<_OutCtgIt>) {
; 4068 :         return reinterpret_cast<_OutCtgIt>(_Dest_ch + _Count);

	lea	eax, DWORD PTR [esi+edi]
	add	esp, 12					; 0000000cH
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1430 :             _Mylast = _Newlast;

	mov	DWORD PTR [ebp+20], eax
$LN286@OnFrame:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp

; 337  : }

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 84					; 00000054H
	ret	16					; 00000010H
$LN27@OnFrame:

; 323  :                     if (E->vis.box.is_valid()) box.merge	(E->vis.box);
; 324  :                 }else{
; 325  :                 	rem_cnt++	;
; 326  :                     ::Render->model_Delete(*it);

	mov	eax, DWORD PTR __imp_?Render@@3PAVIRender_interface@@A
	mov	ebx, DWORD PTR _rem_cnt$1$[esp+96]
	push	0
	inc	ebx
	mov	ecx, DWORD PTR [eax]
	push	esi
	mov	DWORD PTR _rem_cnt$1$[esp+104], ebx
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+172]
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h

; 26   : 	IC	BOOL	is_valid	()											{return (x2>=x1)&&(y2>=y1)&&(z2>=z1);}

	jmp	$LN11@OnFrame
?OnFrame@SItem@CParticleGroup@PS@@QAEXIABUSEffect@CPGDef@3@AAV?$_box3@M@@AA_N@Z ENDP ; PS::CParticleGroup::SItem::OnFrame
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp
_TEXT	SEGMENT
_visuals$ = -12						; size = 12
?OnDeviceCreate@SItem@CParticleGroup@PS@@QAEXXZ PROC	; PS::CParticleGroup::SItem::OnDeviceCreate
; _this$ = ecx

; 339  : {

	sub	esp, 12					; 0000000cH
	push	esi

; 341  :     GetVisuals		(visuals);

	lea	eax, DWORD PTR _visuals$[esp+16]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR _visuals$[esp+16], 0
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp

; 341  :     GetVisuals		(visuals);

	push	eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR _visuals$[esp+24], 0
	mov	DWORD PTR _visuals$[esp+28], 0
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp

; 341  :     GetVisuals		(visuals);

	call	?GetVisuals@SItem@CParticleGroup@PS@@QAEIAAV?$xr_vector@PAVIRender_Visual@@V?$xalloc@PAVIRender_Visual@@@@@@@Z ; PS::CParticleGroup::SItem::GetVisuals
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	esi, DWORD PTR _visuals$[esp+16]
	cmp	esi, DWORD PTR _visuals$[esp+20]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp

; 342  :     for (VisualVecIt it=visuals.begin(); it!=visuals.end(); it++)

	je	SHORT $LN3@OnDeviceCr
$LL4@OnDeviceCr:

; 343  : 	    static_cast<CParticleEffect*>(*it)->OnDeviceCreate();

	mov	ecx, DWORD PTR [esi]
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+40]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 74   :         ++_Ptr;

	add	esi, 4

; 150  :         return _Ptr == _Right._Ptr;

	cmp	esi, DWORD PTR _visuals$[esp+20]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp

; 342  :     for (VisualVecIt it=visuals.begin(); it!=visuals.end(); it++)

	jne	SHORT $LL4@OnDeviceCr
	mov	esi, DWORD PTR _visuals$[esp+16]
$LN3@OnDeviceCr:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	test	esi, esi
	je	SHORT $LN44@OnDeviceCr
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	esi
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN44@OnDeviceCr:
	pop	esi
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp

; 344  : }

	add	esp, 12					; 0000000cH
	ret	0
?OnDeviceCreate@SItem@CParticleGroup@PS@@QAEXXZ ENDP	; PS::CParticleGroup::SItem::OnDeviceCreate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp
_TEXT	SEGMENT
_visuals$ = -12						; size = 12
?OnDeviceDestroy@SItem@CParticleGroup@PS@@QAEXXZ PROC	; PS::CParticleGroup::SItem::OnDeviceDestroy
; _this$ = ecx

; 346  : {

	sub	esp, 12					; 0000000cH
	push	esi

; 348  :     GetVisuals		(visuals);

	lea	eax, DWORD PTR _visuals$[esp+16]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR _visuals$[esp+16], 0
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp

; 348  :     GetVisuals		(visuals);

	push	eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR _visuals$[esp+24], 0
	mov	DWORD PTR _visuals$[esp+28], 0
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp

; 348  :     GetVisuals		(visuals);

	call	?GetVisuals@SItem@CParticleGroup@PS@@QAEIAAV?$xr_vector@PAVIRender_Visual@@V?$xalloc@PAVIRender_Visual@@@@@@@Z ; PS::CParticleGroup::SItem::GetVisuals
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	esi, DWORD PTR _visuals$[esp+16]
	cmp	esi, DWORD PTR _visuals$[esp+20]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp

; 349  :     for (VisualVecIt it=visuals.begin(); it!=visuals.end(); it++)

	je	SHORT $LN3@OnDeviceDe
$LL4@OnDeviceDe:

; 350  : 	    static_cast<CParticleEffect*>(*it)->OnDeviceDestroy();

	mov	ecx, DWORD PTR [esi]
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+44]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 74   :         ++_Ptr;

	add	esi, 4

; 150  :         return _Ptr == _Right._Ptr;

	cmp	esi, DWORD PTR _visuals$[esp+20]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp

; 349  :     for (VisualVecIt it=visuals.begin(); it!=visuals.end(); it++)

	jne	SHORT $LL4@OnDeviceDe
	mov	esi, DWORD PTR _visuals$[esp+16]
$LN3@OnDeviceDe:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	test	esi, esi
	je	SHORT $LN44@OnDeviceDe
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	esi
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN44@OnDeviceDe:
	pop	esi
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp

; 351  : }

	add	esp, 12					; 0000000cH
	ret	0
?OnDeviceDestroy@SItem@CParticleGroup@PS@@QAEXXZ ENDP	; PS::CParticleGroup::SItem::OnDeviceDestroy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp
_TEXT	SEGMENT
_visuals$ = -12						; size = 12
?ParticlesCount@SItem@CParticleGroup@PS@@QAEIXZ PROC	; PS::CParticleGroup::SItem::ParticlesCount
; _this$ = ecx

; 353  : {

	sub	esp, 12					; 0000000cH
	push	esi
	push	edi

; 354  : 	u32 p_count=0;

	xor	edi, edi

; 356  :     GetVisuals		(visuals);

	lea	eax, DWORD PTR _visuals$[esp+20]
	push	eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR _visuals$[esp+24], edi
	mov	DWORD PTR _visuals$[esp+28], edi
	mov	DWORD PTR _visuals$[esp+32], edi
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp

; 356  :     GetVisuals		(visuals);

	call	?GetVisuals@SItem@CParticleGroup@PS@@QAEIAAV?$xr_vector@PAVIRender_Visual@@V?$xalloc@PAVIRender_Visual@@@@@@@Z ; PS::CParticleGroup::SItem::GetVisuals
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	esi, DWORD PTR _visuals$[esp+20]
	cmp	esi, DWORD PTR _visuals$[esp+24]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp

; 357  :     for (VisualVecIt it=visuals.begin(); it!=visuals.end(); it++)

	je	SHORT $LN3@ParticlesC
$LL4@ParticlesC:

; 358  : 	    p_count		+= static_cast<CParticleEffect*>(*it)->ParticlesCount();

	mov	ecx, DWORD PTR [esi]
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+68]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 74   :         ++_Ptr;

	add	esi, 4
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp

; 358  : 	    p_count		+= static_cast<CParticleEffect*>(*it)->ParticlesCount();

	add	edi, eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 150  :         return _Ptr == _Right._Ptr;

	cmp	esi, DWORD PTR _visuals$[esp+24]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp

; 357  :     for (VisualVecIt it=visuals.begin(); it!=visuals.end(); it++)

	jne	SHORT $LL4@ParticlesC
	mov	esi, DWORD PTR _visuals$[esp+20]
$LN3@ParticlesC:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	test	esi, esi
	je	SHORT $LN50@ParticlesC
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	esi
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN50@ParticlesC:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp

; 360  : }

	mov	eax, edi
	pop	edi
	pop	esi
	add	esp, 12					; 0000000cH
	ret	0
?ParticlesCount@SItem@CParticleGroup@PS@@QAEIXZ ENDP	; PS::CParticleGroup::SItem::ParticlesCount
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp
;	COMDAT ??_GCParticleGroup@PS@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCParticleGroup@PS@@UAEPAXI@Z PROC			; PS::CParticleGroup::`scalar deleting destructor', COMDAT
; _this$ = ecx

; 373  : {

	push	ebx
	push	esi
	mov	esi, ecx

; 375  : 	for (u32 i=0; i<items.size(); i++) items[i].Clear();

	xor	ebx, ebx
	mov	DWORD PTR [esi], OFFSET ??_7CParticleGroup@PS@@6B@
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	ecx, DWORD PTR [esi+92]
	mov	edx, ecx
	mov	eax, DWORD PTR [esi+96]
	sub	eax, ecx
	sar	eax, 2
	imul	eax, eax, -1227133513
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp

; 375  : 	for (u32 i=0; i<items.size(); i++) items[i].Clear();

	test	eax, eax
	je	SHORT $LN6@scalar
	push	edi
	xor	edi, edi
$LL7@scalar:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 119  :         _Ptr += _Off;

	mov	ecx, DWORD PTR [esi+92]
	add	ecx, edi
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp

; 375  : 	for (u32 i=0; i<items.size(); i++) items[i].Clear();

	call	?Clear@SItem@CParticleGroup@PS@@QAEXXZ	; PS::CParticleGroup::SItem::Clear
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	ecx, DWORD PTR [esi+92]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp

; 375  : 	for (u32 i=0; i<items.size(); i++) items[i].Clear();

	inc	ebx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	eax, DWORD PTR [esi+96]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp

; 375  : 	for (u32 i=0; i<items.size(); i++) items[i].Clear();

	add	edi, 28					; 0000001cH
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	sub	eax, ecx
	mov	edx, ecx
	sar	eax, 2
	imul	eax, eax, -1227133513
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp

; 375  : 	for (u32 i=0; i<items.size(); i++) items[i].Clear();

	cmp	ebx, eax
	jb	SHORT $LL7@scalar
	pop	edi
$LN6@scalar:

; 376  : 	items.clear();

	mov	DWORD PTR [esi+96], ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	test	ecx, ecx
	je	SHORT $LN35@scalar
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	test	edx, edx
	je	SHORT $LN40@scalar
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	edx
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN40@scalar:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi+92], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+96], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+100], 0
$LN35@scalar:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp

; 377  : }

	mov	ecx, esi
	call	DWORD PTR __imp_??1IParticleCustom@@UAE@XZ
	test	BYTE PTR ___flags$[esp+4], 1
	je	SHORT $LN46@scalar
	push	108					; 0000006cH
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN46@scalar:
	mov	eax, esi
	pop	esi
	pop	ebx
	ret	4
??_GCParticleGroup@PS@@UAEPAXI@Z ENDP			; PS::CParticleGroup::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??1?$xr_vector@USItem@CParticleGroup@PS@@V?$xalloc@USItem@CParticleGroup@PS@@@@@@QAE@XZ
_TEXT	SEGMENT
??1?$xr_vector@USItem@CParticleGroup@PS@@V?$xalloc@USItem@CParticleGroup@PS@@@@@@QAE@XZ PROC ; xr_vector<PS::CParticleGroup::SItem,xalloc<PS::CParticleGroup::SItem> >::~xr_vector<PS::CParticleGroup::SItem,xalloc<PS::CParticleGroup::SItem> >, COMDAT
; _this$ = ecx

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	push	esi
	mov	esi, ecx
	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN6@xr_vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+4], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+8], 0
$LN6@xr_vector:
	pop	esi
	ret	0
??1?$xr_vector@USItem@CParticleGroup@PS@@V?$xalloc@USItem@CParticleGroup@PS@@@@@@QAE@XZ ENDP ; xr_vector<PS::CParticleGroup::SItem,xalloc<PS::CParticleGroup::SItem> >::~xr_vector<PS::CParticleGroup::SItem,xalloc<PS::CParticleGroup::SItem> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp
_TEXT	SEGMENT
??1CParticleGroup@PS@@UAE@XZ PROC			; PS::CParticleGroup::~CParticleGroup
; _this$ = ecx

; 373  : {

	push	ebx
	push	esi
	mov	esi, ecx

; 375  : 	for (u32 i=0; i<items.size(); i++) items[i].Clear();

	xor	ebx, ebx
	mov	DWORD PTR [esi], OFFSET ??_7CParticleGroup@PS@@6B@
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	ecx, DWORD PTR [esi+92]
	mov	edx, ecx
	mov	eax, DWORD PTR [esi+96]
	sub	eax, ecx
	sar	eax, 2
	imul	eax, eax, -1227133513
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp

; 375  : 	for (u32 i=0; i<items.size(); i++) items[i].Clear();

	test	eax, eax
	je	SHORT $LN3@CParticleG
	push	edi
	xor	edi, edi
$LL4@CParticleG:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 119  :         _Ptr += _Off;

	mov	ecx, DWORD PTR [esi+92]
	add	ecx, edi
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp

; 375  : 	for (u32 i=0; i<items.size(); i++) items[i].Clear();

	call	?Clear@SItem@CParticleGroup@PS@@QAEXXZ	; PS::CParticleGroup::SItem::Clear
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	ecx, DWORD PTR [esi+92]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp

; 375  : 	for (u32 i=0; i<items.size(); i++) items[i].Clear();

	inc	ebx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	eax, DWORD PTR [esi+96]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp

; 375  : 	for (u32 i=0; i<items.size(); i++) items[i].Clear();

	add	edi, 28					; 0000001cH
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	sub	eax, ecx
	mov	edx, ecx
	sar	eax, 2
	imul	eax, eax, -1227133513
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp

; 375  : 	for (u32 i=0; i<items.size(); i++) items[i].Clear();

	cmp	ebx, eax
	jb	SHORT $LL4@CParticleG
	pop	edi
$LN3@CParticleG:

; 376  : 	items.clear();

	mov	DWORD PTR [esi+96], ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	test	ecx, ecx
	je	SHORT $LN32@CParticleG
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	test	edx, edx
	je	SHORT $LN37@CParticleG
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	edx
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN37@CParticleG:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi+92], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+96], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+100], 0
$LN32@CParticleG:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp

; 377  : }

	mov	ecx, esi
	pop	esi
	pop	ebx
	jmp	DWORD PTR __imp_??1IParticleCustom@@UAE@XZ
??1CParticleGroup@PS@@UAE@XZ ENDP			; PS::CParticleGroup::~CParticleGroup
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_flags.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_flags.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_flags.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_flags.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_flags.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_flags.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp
_TEXT	SEGMENT
_bPlaying$1 = -33					; size = 1
tv1778 = -32						; size = 4
_f_dt$2 = -32						; size = 4
$T3 = -28						; size = 4
_box$4 = -24						; size = 24
_u_dt$ = 8						; size = 4
?OnFrame@CParticleGroup@PS@@UAEXI@Z PROC		; PS::CParticleGroup::OnFrame
; _this$ = ecx

; 380  : {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	sub	esp, 36					; 00000024H
	push	ebx
	push	esi
	push	edi
	mov	edi, ecx

; 381  : 	if (m_Def&&m_RT_Flags.is(flRT_Playing)){

	mov	ecx, DWORD PTR [edi+72]
	test	ecx, ecx
	je	$LN11@OnFrame
; File I:\Vitalya\mine\NSProjectX\xrCore\_flags.h

; 23   : 	IC 	BOOL	is		(const T mask)						const	{ return mask==(flags&mask);			}

	mov	al, BYTE PTR [edi+104]
	test	al, 1
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp

; 381  : 	if (m_Def&&m_RT_Flags.is(flRT_Playing)){

	je	$LN11@OnFrame

; 382  :         float ct	= m_CurrentTime;

	movss	xmm1, DWORD PTR [edi+76]

; 383  :         float f_dt	= float(u_dt)/1000.f;

	mov	ebx, DWORD PTR _u_dt$[ebp]
	movss	DWORD PTR $T3[esp+48], xmm1
	fild	DWORD PTR _u_dt$[ebp]
	test	ebx, ebx
	jns	SHORT $LN202@OnFrame
	fadd	DWORD PTR __real@4f800000
$LN202@OnFrame:
	fmul	DWORD PTR __real@3a83126f
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	esi, DWORD PTR [ecx+12]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp

; 383  :         float f_dt	= float(u_dt)/1000.f;

	fstp	DWORD PTR _f_dt$2[esp+48]

; 384  :         for (CPGDef::EffectVec::const_iterator e_it=m_Def->m_Effects.begin(); e_it!=m_Def->m_Effects.end(); e_it++){	

	movss	xmm0, DWORD PTR _f_dt$2[esp+48]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 150  :         return _Ptr == _Right._Ptr;

	cmp	esi, DWORD PTR [ecx+16]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp

; 384  :         for (CPGDef::EffectVec::const_iterator e_it=m_Def->m_Effects.begin(); e_it!=m_Def->m_Effects.end(); e_it++){	

	je	$LN3@OnFrame
	npad	5
$LL4@OnFrame:
; File I:\Vitalya\mine\NSProjectX\xrCore\_flags.h

; 23   : 	IC 	BOOL	is		(const T mask)						const	{ return mask==(flags&mask);			}

	mov	eax, DWORD PTR [esi]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp

; 385  :             if ((*e_it)->m_Flags.is(CPGDef::SEffect::flEnabled)){

	test	BYTE PTR [eax], 4
	je	$LN2@OnFrame
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 141  :         return _Ptr - _Right._Ptr;

	mov	eax, esi
	sub	eax, DWORD PTR [ecx+12]
	sar	eax, 2

; 119  :         _Ptr += _Off;

	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax
	mov	eax, DWORD PTR [edi+92]
	lea	ebx, DWORD PTR [eax+ecx*4]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp

; 233  :     CParticleEffect* E	= static_cast<CParticleEffect*>(_effect);

	mov	ecx, DWORD PTR [ebx]

; 234  :     return E?E->IsPlaying():FALSE;

	test	ecx, ecx
	je	SHORT $LN200@OnFrame
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+64]

; 386  :             	VERIFY				(items.size()==m_Def->m_Effects.size());
; 387  :                 SItem& I			= items[e_it-m_Def->m_Effects.begin()];
; 388  :                 if (I.IsPlaying()){

	movss	xmm1, DWORD PTR $T3[esp+48]
	test	eax, eax
	je	SHORT $LN201@OnFrame

; 389  :                     if ((ct<=(*e_it)->m_Time1)&&(ct+f_dt>=(*e_it)->m_Time1))	

	mov	eax, DWORD PTR [esi]
	movss	xmm2, DWORD PTR [eax+24]
	comiss	xmm2, xmm1
	jb	SHORT $LN2@OnFrame
	movss	xmm0, DWORD PTR _f_dt$2[esp+48]
	addss	xmm0, xmm1
	comiss	xmm0, xmm2
	jb	SHORT $LN2@OnFrame
; File I:\Vitalya\mine\NSProjectX\xrCore\_flags.h

; 23   : 	IC 	BOOL	is		(const T mask)						const	{ return mask==(flags&mask);			}

	mov	eax, DWORD PTR [eax]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp

; 390  :                         I.Stop((*e_it)->m_Flags.is(CPGDef::SEffect::flDefferedStop));

	mov	ecx, ebx
; File I:\Vitalya\mine\NSProjectX\xrCore\_flags.h

; 23   : 	IC 	BOOL	is		(const T mask)						const	{ return mask==(flags&mask);			}

	and	eax, 1
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp

; 390  :                         I.Stop((*e_it)->m_Flags.is(CPGDef::SEffect::flDefferedStop));

	push	eax
	call	?Stop@SItem@CParticleGroup@PS@@QAEXH@Z	; PS::CParticleGroup::SItem::Stop

; 391  :                 }else{

	jmp	SHORT $LN203@OnFrame
$LN201@OnFrame:

; 386  :             	VERIFY				(items.size()==m_Def->m_Effects.size());
; 387  :                 SItem& I			= items[e_it-m_Def->m_Effects.begin()];
; 388  :                 if (I.IsPlaying()){

	movss	xmm0, DWORD PTR _f_dt$2[esp+48]
$LN200@OnFrame:

; 392  :                     if (!m_RT_Flags.is(flRT_DefferedStop))

	test	BYTE PTR [edi+104], 2
	jne	SHORT $LN2@OnFrame

; 393  :                         if ((ct<=(*e_it)->m_Time0)&&(ct+f_dt>=(*e_it)->m_Time0))	

	mov	eax, DWORD PTR [esi]
	movss	xmm2, DWORD PTR [eax+20]
	comiss	xmm2, xmm1
	jb	SHORT $LN2@OnFrame
	addss	xmm0, xmm1
	comiss	xmm0, xmm2
	jb	SHORT $LN2@OnFrame

; 210  :     CParticleEffect* E	= static_cast<CParticleEffect*>(_effect);

	mov	ecx, DWORD PTR [ebx]

; 211  :     if (E) E->Play();

	test	ecx, ecx
	je	SHORT $LN2@OnFrame
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+56]
$LN203@OnFrame:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 74   :         ++_Ptr;

	movss	xmm1, DWORD PTR $T3[esp+48]
$LN2@OnFrame:

; 1478 :         return const_iterator(_My_data._Mylast, _STD addressof(_My_data));

	mov	ecx, DWORD PTR [edi+72]

; 74   :         ++_Ptr;

	add	esi, 4
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp

; 384  :         for (CPGDef::EffectVec::const_iterator e_it=m_Def->m_Effects.begin(); e_it!=m_Def->m_Effects.end(); e_it++){	

	movss	xmm0, DWORD PTR _f_dt$2[esp+48]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 150  :         return _Ptr == _Right._Ptr;

	cmp	esi, DWORD PTR [ecx+16]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp

; 384  :         for (CPGDef::EffectVec::const_iterator e_it=m_Def->m_Effects.begin(); e_it!=m_Def->m_Effects.end(); e_it++){	

	jne	$LL4@OnFrame
	movss	xmm1, DWORD PTR [edi+76]
	mov	al, BYTE PTR [edi+104]
	mov	ebx, DWORD PTR _u_dt$[ebp]
$LN3@OnFrame:

; 394  :                             I.Play();
; 395  :                 }
; 396  :             }
; 397  :         }
; 398  :         m_CurrentTime 	+= f_dt;

	addss	xmm1, xmm0
	movss	DWORD PTR [edi+76], xmm1

; 399  :         if ((m_CurrentTime>m_Def->m_fTimeLimit)&&(m_Def->m_fTimeLimit>0.f))

	movss	xmm0, DWORD PTR [ecx+8]
	comiss	xmm1, xmm0
	jbe	SHORT $LN20@OnFrame
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN20@OnFrame

; 400  :             if (!m_RT_Flags.is(flRT_DefferedStop)) Stop(true);

	test	al, 2
	jne	SHORT $LN20@OnFrame
	mov	eax, DWORD PTR [edi]
	mov	ecx, edi
	push	1
	call	DWORD PTR [eax+60]
$LN20@OnFrame:
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 23   : 	ICF	SelfRef	set(T _x, T _y, T _z)					{ x = _x;		y = _y;		z = _z;		return *this;	};

	movss	xmm1, DWORD PTR __real@7f7fffff
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp

; 402  :         bool bPlaying = false;

	xor	cl, cl
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 23   : 	ICF	SelfRef	set(T _x, T _y, T _z)					{ x = _x;		y = _y;		z = _z;		return *this;	};

	movss	xmm0, DWORD PTR __real@ff7fffff
	movaps	xmm2, xmm1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	esi, DWORD PTR [edi+92]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 23   : 	ICF	SelfRef	set(T _x, T _y, T _z)					{ x = _x;		y = _y;		z = _z;		return *this;	};

	movaps	xmm3, xmm1
	movaps	xmm4, xmm0
	movaps	xmm5, xmm0
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp

; 402  :         bool bPlaying = false;

	mov	BYTE PTR _bPlaying$1[esp+48], cl
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 23   : 	ICF	SelfRef	set(T _x, T _y, T _z)					{ x = _x;		y = _y;		z = _z;		return *this;	};

	movss	DWORD PTR _box$4[esp+48], xmm1
	movss	DWORD PTR _box$4[esp+52], xmm2
	movss	DWORD PTR _box$4[esp+56], xmm3
	movss	DWORD PTR _box$4[esp+60], xmm0
	movss	DWORD PTR _box$4[esp+64], xmm4
	movss	DWORD PTR _box$4[esp+68], xmm5
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 150  :         return _Ptr == _Right._Ptr;

	cmp	esi, DWORD PTR [edi+96]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp

; 404  :         for (SItemVecIt i_it=items.begin(); i_it!=items.end(); i_it++) 

	je	SHORT $LN9@OnFrame
	npad	6
$LL10@OnFrame:

; 405  :         	i_it->OnFrame(u_dt,*m_Def->m_Effects[i_it-items.begin()],box,bPlaying);

	lea	eax, DWORD PTR _bPlaying$1[esp+48]
	push	eax
	lea	eax, DWORD PTR _box$4[esp+52]
	push	eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 141  :         return _Ptr - _Right._Ptr;

	mov	eax, esi
	sub	eax, DWORD PTR [edi+92]
	sar	eax, 2
	imul	ecx, eax, -1227133513
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp

; 405  :         	i_it->OnFrame(u_dt,*m_Def->m_Effects[i_it-items.begin()],box,bPlaying);

	mov	eax, DWORD PTR [edi+72]
	mov	eax, DWORD PTR [eax+12]
	push	DWORD PTR [eax+ecx*4]
	mov	ecx, esi
	push	ebx
	call	?OnFrame@SItem@CParticleGroup@PS@@QAEXIABUSEffect@CPGDef@3@AAV?$_box3@M@@AA_N@Z ; PS::CParticleGroup::SItem::OnFrame
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 74   :         ++_Ptr;

	add	esi, 28					; 0000001cH

; 150  :         return _Ptr == _Right._Ptr;

	cmp	esi, DWORD PTR [edi+96]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp

; 404  :         for (SItemVecIt i_it=items.begin(); i_it!=items.end(); i_it++) 

	jne	SHORT $LL10@OnFrame
	mov	cl, BYTE PTR _bPlaying$1[esp+48]
	movss	xmm5, DWORD PTR _box$4[esp+68]
	movss	xmm4, DWORD PTR _box$4[esp+64]
	movss	xmm0, DWORD PTR _box$4[esp+60]
	movss	xmm3, DWORD PTR _box$4[esp+56]
	movss	xmm2, DWORD PTR _box$4[esp+52]
	movss	xmm1, DWORD PTR _box$4[esp+48]
$LN9@OnFrame:
; File I:\Vitalya\mine\NSProjectX\xrCore\_flags.h

; 23   : 	IC 	BOOL	is		(const T mask)						const	{ return mask==(flags&mask);			}

	mov	al, BYTE PTR [edi+104]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp

; 407  :         if (m_RT_Flags.is(flRT_DefferedStop)&&!bPlaying){

	test	al, 2
	je	SHORT $LN143@OnFrame
	test	cl, cl
	jne	SHORT $LN143@OnFrame
; File I:\Vitalya\mine\NSProjectX\xrCore\_flags.h

; 22   : 	IC	SelfRef	set		(const T mask,	BOOL value)					{ if (value) flags|=mask; else flags&=~mask; return *this; }

	and	al, 252					; 000000fcH
	mov	BYTE PTR [edi+104], al
$LN143@OnFrame:
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h

; 26   : 	IC	BOOL	is_valid	()											{return (x2>=x1)&&(y2>=y1)&&(z2>=z1);}

	comiss	xmm0, xmm1
	jb	$LN12@OnFrame
	comiss	xmm4, xmm2
	jb	$LN12@OnFrame
	comiss	xmm5, xmm3
	jb	$LN12@OnFrame
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 24   : 	ICF SelfRef	set(const _vector3<float> &v)			{ x = T(v.x);	y = T(v.y);	z = T(v.z);	return *this;	};

	movss	DWORD PTR [edi+24], xmm1
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h

; 97   : 		C.x = (min.x + max.x) * 0.5f;

	addss	xmm1, xmm0
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 24   : 	ICF SelfRef	set(const _vector3<float> &v)			{ x = T(v.x);	y = T(v.y);	z = T(v.z);	return *this;	};

	movss	DWORD PTR [edi+28], xmm2
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h

; 98   : 		C.y = (min.y + max.y) * 0.5f;

	addss	xmm2, xmm4
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 24   : 	ICF SelfRef	set(const _vector3<float> &v)			{ x = T(v.x);	y = T(v.y);	z = T(v.z);	return *this;	};

	movss	DWORD PTR [edi+32], xmm3
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h

; 99   : 		C.z = (min.z + max.z) * 0.5f;

	addss	xmm3, xmm5
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 24   : 	ICF SelfRef	set(const _vector3<float> &v)			{ x = T(v.x);	y = T(v.y);	z = T(v.z);	return *this;	};

	movss	DWORD PTR [edi+36], xmm0
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h

; 97   : 		C.x = (min.x + max.x) * 0.5f;

	movss	xmm0, DWORD PTR __real@3f000000
	mulss	xmm1, xmm0

; 98   : 		C.y = (min.y + max.y) * 0.5f;

	mulss	xmm2, xmm0

; 99   : 		C.z = (min.z + max.z) * 0.5f;

	mulss	xmm3, xmm0
	movss	DWORD PTR [edi+8], xmm1
	movss	DWORD PTR [edi+12], xmm2
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 287  : 	{	return (x-v.x)*(x-v.x) + (y-v.y)*(y-v.y) + (z-v.z)*(z-v.z);	}

	subss	xmm2, xmm4
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h

; 99   : 		C.z = (min.z + max.z) * 0.5f;

	movss	DWORD PTR [edi+16], xmm3
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 287  : 	{	return (x-v.x)*(x-v.x) + (y-v.y)*(y-v.y) + (z-v.z)*(z-v.z);	}

	subss	xmm3, xmm5

; 24   : 	ICF SelfRef	set(const _vector3<float> &v)			{ x = T(v.x);	y = T(v.y);	z = T(v.z);	return *this;	};

	movss	DWORD PTR [edi+40], xmm4
	movss	DWORD PTR [edi+44], xmm5

; 287  : 	{	return (x-v.x)*(x-v.x) + (y-v.y)*(y-v.y) + (z-v.z)*(z-v.z);	}

	subss	xmm1, DWORD PTR [edi+36]
	mulss	xmm2, xmm2
	mulss	xmm3, xmm3
	mulss	xmm1, xmm1
	addss	xmm1, xmm2
	addss	xmm1, xmm3
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h

; 764  :             return (float)sqrt(_X);

	sqrtss	xmm0, xmm1
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp

; 419  : }

	movss	DWORD PTR [edi+20], xmm0
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
$LN11@OnFrame:
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 24   : 	ICF SelfRef	set(const _vector3<float> &v)			{ x = T(v.x);	y = T(v.y);	z = T(v.z);	return *this;	};

	movss	xmm1, DWORD PTR [edi+80]

; 35   : 	ICF SelfRef	sub(T s)								{ x-=s;		y-=s;		z-=s;			return *this;	};

	movss	xmm0, DWORD PTR __real@3a83126f

; 24   : 	ICF SelfRef	set(const _vector3<float> &v)			{ x = T(v.x);	y = T(v.y);	z = T(v.z);	return *this;	};

	movss	DWORD PTR [edi+24], xmm1

; 35   : 	ICF SelfRef	sub(T s)								{ x-=s;		y-=s;		z-=s;			return *this;	};

	subss	xmm1, xmm0

; 24   : 	ICF SelfRef	set(const _vector3<float> &v)			{ x = T(v.x);	y = T(v.y);	z = T(v.z);	return *this;	};

	movss	xmm6, DWORD PTR [edi+84]
	movss	DWORD PTR [edi+28], xmm6

; 35   : 	ICF SelfRef	sub(T s)								{ x-=s;		y-=s;		z-=s;			return *this;	};

	subss	xmm6, xmm0

; 24   : 	ICF SelfRef	set(const _vector3<float> &v)			{ x = T(v.x);	y = T(v.y);	z = T(v.z);	return *this;	};

	movss	xmm5, DWORD PTR [edi+88]
	movss	DWORD PTR [edi+32], xmm5

; 35   : 	ICF SelfRef	sub(T s)								{ x-=s;		y-=s;		z-=s;			return *this;	};

	subss	xmm5, xmm0

; 24   : 	ICF SelfRef	set(const _vector3<float> &v)			{ x = T(v.x);	y = T(v.y);	z = T(v.z);	return *this;	};

	movss	xmm4, DWORD PTR [edi+80]
	movss	DWORD PTR [edi+36], xmm4

; 30   : 	ICF SelfRef	add(T s)								{ x+=s;		y+=s;		z+=s;			return *this;	};

	addss	xmm4, xmm0

; 24   : 	ICF SelfRef	set(const _vector3<float> &v)			{ x = T(v.x);	y = T(v.y);	z = T(v.z);	return *this;	};

	movss	xmm2, DWORD PTR [edi+84]
	movss	DWORD PTR [edi+40], xmm2

; 30   : 	ICF SelfRef	add(T s)								{ x+=s;		y+=s;		z+=s;			return *this;	};

	addss	xmm2, xmm0

; 24   : 	ICF SelfRef	set(const _vector3<float> &v)			{ x = T(v.x);	y = T(v.y);	z = T(v.z);	return *this;	};

	movss	xmm3, DWORD PTR [edi+88]

; 30   : 	ICF SelfRef	add(T s)								{ x+=s;		y+=s;		z+=s;			return *this;	};

	addss	xmm3, xmm0

; 35   : 	ICF SelfRef	sub(T s)								{ x-=s;		y-=s;		z-=s;			return *this;	};

	movss	DWORD PTR [edi+28], xmm6
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h

; 97   : 		C.x = (min.x + max.x) * 0.5f;

	movss	xmm0, DWORD PTR __real@3f000000
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 35   : 	ICF SelfRef	sub(T s)								{ x-=s;		y-=s;		z-=s;			return *this;	};

	movss	DWORD PTR [edi+32], xmm5

; 30   : 	ICF SelfRef	add(T s)								{ x+=s;		y+=s;		z+=s;			return *this;	};

	movss	DWORD PTR [edi+36], xmm4
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h

; 98   : 		C.y = (min.y + max.y) * 0.5f;

	addss	xmm6, xmm2
	addss	xmm4, xmm1
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 35   : 	ICF SelfRef	sub(T s)								{ x-=s;		y-=s;		z-=s;			return *this;	};

	movss	DWORD PTR [edi+24], xmm1
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h

; 99   : 		C.z = (min.z + max.z) * 0.5f;

	addss	xmm5, xmm3
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 30   : 	ICF SelfRef	add(T s)								{ x+=s;		y+=s;		z+=s;			return *this;	};

	movss	DWORD PTR [edi+40], xmm2
	movss	DWORD PTR [edi+44], xmm3
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h

; 98   : 		C.y = (min.y + max.y) * 0.5f;

	mulss	xmm6, xmm0
	mulss	xmm4, xmm0

; 99   : 		C.z = (min.z + max.z) * 0.5f;

	mulss	xmm5, xmm0
	movss	DWORD PTR [edi+12], xmm6
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 287  : 	{	return (x-v.x)*(x-v.x) + (y-v.y)*(y-v.y) + (z-v.z)*(z-v.z);	}

	subss	xmm6, xmm2
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h

; 97   : 		C.x = (min.x + max.x) * 0.5f;

	movss	DWORD PTR [edi+8], xmm4

; 99   : 		C.z = (min.z + max.z) * 0.5f;

	movss	DWORD PTR [edi+16], xmm5
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 287  : 	{	return (x-v.x)*(x-v.x) + (y-v.y)*(y-v.y) + (z-v.z)*(z-v.z);	}

	subss	xmm5, xmm3
	subss	xmm4, DWORD PTR [edi+36]
	mulss	xmm6, xmm6
	mulss	xmm5, xmm5
	mulss	xmm4, xmm4
	addss	xmm6, xmm4
	addss	xmm6, xmm5
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h

; 764  :             return (float)sqrt(_X);

	sqrtss	xmm0, xmm6
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp

; 419  : }

	movss	DWORD PTR [edi+20], xmm0
$LN12@OnFrame:
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?OnFrame@CParticleGroup@PS@@UAEXI@Z ENDP		; PS::CParticleGroup::OnFrame
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp
_TEXT	SEGMENT
_m$ = 8							; size = 4
_velocity$ = 12						; size = 4
_bXFORM$ = 16						; size = 4
?UpdateParent@CParticleGroup@PS@@UAEXABU?$_matrix@M@@ABU?$_vector3@M@@H@Z PROC ; PS::CParticleGroup::UpdateParent
; _this$ = ecx

; 422  : {

	push	ebx

; 423  : 	m_InitialPosition		= m.c;

	mov	ebx, DWORD PTR _m$[esp]
	push	esi
	push	edi
	mov	edi, ecx
	mov	eax, DWORD PTR [ebx+48]
	mov	DWORD PTR [edi+80], eax
	mov	eax, DWORD PTR [ebx+52]
	mov	DWORD PTR [edi+84], eax
	mov	eax, DWORD PTR [ebx+56]
	mov	DWORD PTR [edi+88], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	esi, DWORD PTR [edi+92]

; 150  :         return _Ptr == _Right._Ptr;

	cmp	esi, DWORD PTR [edi+96]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp

; 424  :     for (SItemVecIt i_it=items.begin(); i_it!=items.end(); i_it++) 

	je	SHORT $LN3@UpdatePare
	push	ebp
	mov	ebp, DWORD PTR _bXFORM$[esp+12]
$LL4@UpdatePare:

; 238  :     CParticleEffect* E	= static_cast<CParticleEffect*>(_effect);

	mov	ecx, DWORD PTR [esi]

; 239  :     if (E) E->UpdateParent(m,velocity,bXFORM);

	test	ecx, ecx
	je	SHORT $LN2@UpdatePare
	mov	eax, DWORD PTR [ecx]
	push	ebp
	push	DWORD PTR _velocity$[esp+16]
	push	ebx
	call	DWORD PTR [eax+48]
$LN2@UpdatePare:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 74   :         ++_Ptr;

	add	esi, 28					; 0000001cH

; 150  :         return _Ptr == _Right._Ptr;

	cmp	esi, DWORD PTR [edi+96]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp

; 424  :     for (SItemVecIt i_it=items.begin(); i_it!=items.end(); i_it++) 

	jne	SHORT $LL4@UpdatePare
	pop	ebp
$LN3@UpdatePare:
	pop	edi

; 425  :     	i_it->UpdateParent(m,velocity,bXFORM);
; 426  : }

	pop	esi
	pop	ebx
	ret	12					; 0000000cH
?UpdateParent@CParticleGroup@PS@@UAEXABU?$_matrix@M@@ABU?$_vector3@M@@H@Z ENDP ; PS::CParticleGroup::UpdateParent
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_flags.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp
_TEXT	SEGMENT
?Play@CParticleGroup@PS@@UAEXXZ PROC			; PS::CParticleGroup::Play
; _this$ = ecx

; 449  : 	m_CurrentTime   = 0;

	mov	DWORD PTR [ecx+76], 0
; File I:\Vitalya\mine\NSProjectX\xrCore\_flags.h

; 22   : 	IC	SelfRef	set		(const T mask,	BOOL value)					{ if (value) flags|=mask; else flags&=~mask; return *this; }

	mov	al, BYTE PTR [ecx+104]
	and	al, 253					; 000000fdH
	or	al, 1
	mov	BYTE PTR [ecx+104], al
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp

; 452  : }

	ret	0
?Play@CParticleGroup@PS@@UAEXXZ ENDP			; PS::CParticleGroup::Play
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_flags.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_flags.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp
_TEXT	SEGMENT
_bDefferedStop$ = 8					; size = 4
?Stop@CParticleGroup@PS@@UAEXH@Z PROC			; PS::CParticleGroup::Stop
; _this$ = ecx

; 455  : {

	push	ebx

; 456  : 	if (bDefferedStop){

	mov	ebx, DWORD PTR _bDefferedStop$[esp]
	push	esi
	push	edi
	mov	edi, ecx
	test	ebx, ebx
	je	SHORT $LN5@Stop
; File I:\Vitalya\mine\NSProjectX\xrCore\_flags.h

; 22   : 	IC	SelfRef	set		(const T mask,	BOOL value)					{ if (value) flags|=mask; else flags&=~mask; return *this; }

	or	BYTE PTR [edi+104], 2
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp

; 458  :     }else{

	jmp	SHORT $LN14@Stop
$LN5@Stop:
; File I:\Vitalya\mine\NSProjectX\xrCore\_flags.h

; 22   : 	IC	SelfRef	set		(const T mask,	BOOL value)					{ if (value) flags|=mask; else flags&=~mask; return *this; }

	and	BYTE PTR [edi+104], 254			; 000000feH
$LN14@Stop:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	esi, DWORD PTR [edi+92]

; 150  :         return _Ptr == _Right._Ptr;

	cmp	esi, DWORD PTR [edi+96]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp

; 461  :     for (SItemVecIt i_it=items.begin(); i_it!=items.end(); i_it++) i_it->Stop(bDefferedStop);

	je	SHORT $LN3@Stop
	npad	1
$LL4@Stop:
	push	ebx
	mov	ecx, esi
	call	?Stop@SItem@CParticleGroup@PS@@QAEXH@Z	; PS::CParticleGroup::SItem::Stop
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 74   :         ++_Ptr;

	add	esi, 28					; 0000001cH

; 150  :         return _Ptr == _Right._Ptr;

	cmp	esi, DWORD PTR [edi+96]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp

; 461  :     for (SItemVecIt i_it=items.begin(); i_it!=items.end(); i_it++) i_it->Stop(bDefferedStop);

	jne	SHORT $LL4@Stop
$LN3@Stop:
	pop	edi

; 462  : }

	pop	esi
	pop	ebx
	ret	4
?Stop@CParticleGroup@PS@@UAEXH@Z ENDP			; PS::CParticleGroup::Stop
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp
_TEXT	SEGMENT
_visuals$1 = -12					; size = 12
?OnDeviceCreate@CParticleGroup@PS@@UAEXXZ PROC		; PS::CParticleGroup::OnDeviceCreate
; _this$ = ecx

; 465  : {

	sub	esp, 12					; 0000000cH
	push	ebx
	mov	ebx, ecx
	push	edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	edi, DWORD PTR [ebx+92]

; 150  :         return _Ptr == _Right._Ptr;

	cmp	edi, DWORD PTR [ebx+96]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp

; 466  :     for (SItemVecIt i_it=items.begin(); i_it!=items.end(); i_it++) i_it->OnDeviceCreate();

	je	$LN3@OnDeviceCr
	push	ebp
	mov	ebp, DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
	push	esi
	npad	5
$LL4@OnDeviceCr:

; 341  :     GetVisuals		(visuals);

	lea	eax, DWORD PTR _visuals$1[esp+28]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR _visuals$1[esp+28], 0
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp

; 341  :     GetVisuals		(visuals);

	push	eax
	mov	ecx, edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR _visuals$1[esp+36], 0
	mov	DWORD PTR _visuals$1[esp+40], 0
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp

; 341  :     GetVisuals		(visuals);

	call	?GetVisuals@SItem@CParticleGroup@PS@@QAEIAAV?$xr_vector@PAVIRender_Visual@@V?$xalloc@PAVIRender_Visual@@@@@@@Z ; PS::CParticleGroup::SItem::GetVisuals
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	esi, DWORD PTR _visuals$1[esp+28]
	cmp	esi, DWORD PTR _visuals$1[esp+32]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp

; 342  :     for (VisualVecIt it=visuals.begin(); it!=visuals.end(); it++)

	je	SHORT $LN28@OnDeviceCr
	npad	2
$LL29@OnDeviceCr:

; 343  : 	    static_cast<CParticleEffect*>(*it)->OnDeviceCreate();

	mov	ecx, DWORD PTR [esi]
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+40]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 74   :         ++_Ptr;

	add	esi, 4

; 150  :         return _Ptr == _Right._Ptr;

	cmp	esi, DWORD PTR _visuals$1[esp+32]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp

; 342  :     for (VisualVecIt it=visuals.begin(); it!=visuals.end(); it++)

	jne	SHORT $LL29@OnDeviceCr
	mov	esi, DWORD PTR _visuals$1[esp+28]
$LN28@OnDeviceCr:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	test	esi, esi
	je	SHORT $LN2@OnDeviceCr
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	esi
	call	ebp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR _visuals$1[esp+28], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR _visuals$1[esp+32], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR _visuals$1[esp+36], 0
$LN2@OnDeviceCr:

; 74   :         ++_Ptr;

	add	edi, 28					; 0000001cH

; 150  :         return _Ptr == _Right._Ptr;

	cmp	edi, DWORD PTR [ebx+96]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp

; 466  :     for (SItemVecIt i_it=items.begin(); i_it!=items.end(); i_it++) i_it->OnDeviceCreate();

	jne	SHORT $LL4@OnDeviceCr
	pop	esi
	pop	ebp
$LN3@OnDeviceCr:
	pop	edi

; 467  : }

	pop	ebx
	add	esp, 12					; 0000000cH
	ret	0
?OnDeviceCreate@CParticleGroup@PS@@UAEXXZ ENDP		; PS::CParticleGroup::OnDeviceCreate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp
_TEXT	SEGMENT
_visuals$1 = -12					; size = 12
?OnDeviceDestroy@CParticleGroup@PS@@UAEXXZ PROC		; PS::CParticleGroup::OnDeviceDestroy
; _this$ = ecx

; 470  : {

	sub	esp, 12					; 0000000cH
	push	ebx
	mov	ebx, ecx
	push	edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	edi, DWORD PTR [ebx+92]

; 150  :         return _Ptr == _Right._Ptr;

	cmp	edi, DWORD PTR [ebx+96]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp

; 471  :     for (SItemVecIt i_it=items.begin(); i_it!=items.end(); i_it++) i_it->OnDeviceDestroy();

	je	$LN3@OnDeviceDe
	push	ebp
	mov	ebp, DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
	push	esi
	npad	5
$LL4@OnDeviceDe:

; 348  :     GetVisuals		(visuals);

	lea	eax, DWORD PTR _visuals$1[esp+28]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR _visuals$1[esp+28], 0
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp

; 348  :     GetVisuals		(visuals);

	push	eax
	mov	ecx, edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR _visuals$1[esp+36], 0
	mov	DWORD PTR _visuals$1[esp+40], 0
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp

; 348  :     GetVisuals		(visuals);

	call	?GetVisuals@SItem@CParticleGroup@PS@@QAEIAAV?$xr_vector@PAVIRender_Visual@@V?$xalloc@PAVIRender_Visual@@@@@@@Z ; PS::CParticleGroup::SItem::GetVisuals
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	esi, DWORD PTR _visuals$1[esp+28]
	cmp	esi, DWORD PTR _visuals$1[esp+32]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp

; 349  :     for (VisualVecIt it=visuals.begin(); it!=visuals.end(); it++)

	je	SHORT $LN28@OnDeviceDe
	npad	2
$LL29@OnDeviceDe:

; 350  : 	    static_cast<CParticleEffect*>(*it)->OnDeviceDestroy();

	mov	ecx, DWORD PTR [esi]
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+44]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 74   :         ++_Ptr;

	add	esi, 4

; 150  :         return _Ptr == _Right._Ptr;

	cmp	esi, DWORD PTR _visuals$1[esp+32]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp

; 349  :     for (VisualVecIt it=visuals.begin(); it!=visuals.end(); it++)

	jne	SHORT $LL29@OnDeviceDe
	mov	esi, DWORD PTR _visuals$1[esp+28]
$LN28@OnDeviceDe:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	test	esi, esi
	je	SHORT $LN2@OnDeviceDe
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	esi
	call	ebp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR _visuals$1[esp+28], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR _visuals$1[esp+32], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR _visuals$1[esp+36], 0
$LN2@OnDeviceDe:

; 74   :         ++_Ptr;

	add	edi, 28					; 0000001cH

; 150  :         return _Ptr == _Right._Ptr;

	cmp	edi, DWORD PTR [ebx+96]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp

; 471  :     for (SItemVecIt i_it=items.begin(); i_it!=items.end(); i_it++) i_it->OnDeviceDestroy();

	jne	SHORT $LL4@OnDeviceDe
	pop	esi
	pop	ebp
$LN3@OnDeviceDe:
	pop	edi

; 472  : }

	pop	ebx
	add	esp, 12					; 0000000cH
	ret	0
?OnDeviceDestroy@CParticleGroup@PS@@UAEXXZ ENDP		; PS::CParticleGroup::OnDeviceDestroy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp
_TEXT	SEGMENT
_this$1$ = -16						; size = 4
_visuals$1 = -12					; size = 12
?ParticlesCount@CParticleGroup@PS@@UAEIXZ PROC		; PS::CParticleGroup::ParticlesCount
; _this$ = ecx

; 475  : {

	sub	esp, 16					; 00000010H
	mov	eax, ecx
	push	ebp
	push	edi

; 476  : 	int p_count=0;

	xor	ebp, ebp
	mov	DWORD PTR _this$1$[esp+24], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	edi, DWORD PTR [eax+92]

; 150  :         return _Ptr == _Right._Ptr;

	cmp	edi, DWORD PTR [eax+96]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp

; 477  :     for (SItemVecIt i_it=items.begin(); i_it!=items.end(); i_it++)

	je	SHORT $LN79@ParticlesC
	push	ebx
	push	esi
$LL4@ParticlesC:

; 354  : 	u32 p_count=0;

	xor	ebx, ebx

; 356  :     GetVisuals		(visuals);

	lea	eax, DWORD PTR _visuals$1[esp+32]
	push	eax
	mov	ecx, edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR _visuals$1[esp+36], ebx
	mov	DWORD PTR _visuals$1[esp+40], ebx
	mov	DWORD PTR _visuals$1[esp+44], ebx
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp

; 356  :     GetVisuals		(visuals);

	call	?GetVisuals@SItem@CParticleGroup@PS@@QAEIAAV?$xr_vector@PAVIRender_Visual@@V?$xalloc@PAVIRender_Visual@@@@@@@Z ; PS::CParticleGroup::SItem::GetVisuals
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	esi, DWORD PTR _visuals$1[esp+32]
	cmp	esi, DWORD PTR _visuals$1[esp+36]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp

; 357  :     for (VisualVecIt it=visuals.begin(); it!=visuals.end(); it++)

	je	SHORT $LN28@ParticlesC
	npad	5
$LL29@ParticlesC:

; 358  : 	    p_count		+= static_cast<CParticleEffect*>(*it)->ParticlesCount();

	mov	ecx, DWORD PTR [esi]
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+68]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 74   :         ++_Ptr;

	add	esi, 4
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp

; 358  : 	    p_count		+= static_cast<CParticleEffect*>(*it)->ParticlesCount();

	add	ebx, eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 150  :         return _Ptr == _Right._Ptr;

	cmp	esi, DWORD PTR _visuals$1[esp+36]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp

; 357  :     for (VisualVecIt it=visuals.begin(); it!=visuals.end(); it++)

	jne	SHORT $LL29@ParticlesC
	mov	esi, DWORD PTR _visuals$1[esp+32]
$LN28@ParticlesC:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	test	esi, esi
	je	SHORT $LN64@ParticlesC
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	esi
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR _visuals$1[esp+32], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR _visuals$1[esp+36], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR _visuals$1[esp+40], 0
$LN64@ParticlesC:

; 150  :         return _Ptr == _Right._Ptr;

	mov	eax, DWORD PTR _this$1$[esp+32]

; 74   :         ++_Ptr;

	add	edi, 28					; 0000001cH
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp

; 478  :         p_count 	+= i_it->ParticlesCount();

	add	ebp, ebx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 150  :         return _Ptr == _Right._Ptr;

	cmp	edi, DWORD PTR [eax+96]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp

; 477  :     for (SItemVecIt i_it=items.begin(); i_it!=items.end(); i_it++)

	jne	SHORT $LL4@ParticlesC

; 479  : 	return p_count;

	pop	esi
	pop	ebx
$LN79@ParticlesC:

; 480  : }

	pop	edi
	mov	eax, ebp
	pop	ebp
	add	esp, 16					; 00000010H
	ret	0
?ParticlesCount@CParticleGroup@PS@@UAEIXZ ENDP		; PS::CParticleGroup::ParticlesCount
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USItem@CParticleGroup@PS@@@std@@@std@@@std@@QAE?AV01@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$dead$ = 12					; size = 4
??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USItem@CParticleGroup@PS@@@std@@@std@@@std@@QAE?AV01@H@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<PS::CParticleGroup::SItem> > >::operator++, COMDAT
; _this$ = ecx

; 281  :         _Vector_iterator _Tmp = *this;

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx

; 74   :         ++_Ptr;

	add	edx, 28					; 0000001cH
	mov	DWORD PTR [ecx], edx

; 282  :         _Mybase::operator++();
; 283  :         return _Tmp;
; 284  :     }

	ret	8
??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USItem@CParticleGroup@PS@@@std@@@std@@@std@@QAE?AV01@H@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<PS::CParticleGroup::SItem> > >::operator++
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??C?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USItem@CParticleGroup@PS@@@std@@@std@@@std@@QBEPAUSItem@CParticleGroup@PS@@XZ
_TEXT	SEGMENT
??C?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USItem@CParticleGroup@PS@@@std@@@std@@@std@@QBEPAUSItem@CParticleGroup@PS@@XZ PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<PS::CParticleGroup::SItem> > >::operator->, COMDAT
; _this$ = ecx

; 265  : #if _ITERATOR_DEBUG_LEVEL != 0
; 266  :         const auto _Mycont = static_cast<const _Myvec*>(this->_Getcont());
; 267  :         _STL_VERIFY(this->_Ptr, "can't dereference value-initialized vector iterator");
; 268  :         _STL_VERIFY(_Mycont->_Myfirst <= this->_Ptr && this->_Ptr < _Mycont->_Mylast,
; 269  :             "can't dereference out of range vector iterator");
; 270  : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 271  : 
; 272  :         return this->_Ptr;

	mov	eax, DWORD PTR [ecx]

; 273  :     }

	ret	0
??C?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USItem@CParticleGroup@PS@@@std@@@std@@@std@@QBEPAUSItem@CParticleGroup@PS@@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<PS::CParticleGroup::SItem> > >::operator->
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@USItem@CParticleGroup@PS@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@USItem@CParticleGroup@PS@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<PS::CParticleGroup::SItem> > >::operator!=, COMDAT
; _this$ = ecx

; 160  :         return !(*this == _Right);

	mov	eax, DWORD PTR __Right$[esp-4]
	mov	ecx, DWORD PTR [ecx]
	cmp	ecx, DWORD PTR [eax]
	setne	al

; 161  :     }

	ret	4
??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@USItem@CParticleGroup@PS@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<PS::CParticleGroup::SItem> > >::operator!=
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??G?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@USItem@CParticleGroup@PS@@@std@@@std@@@std@@QBEHABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??G?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@USItem@CParticleGroup@PS@@@std@@@std@@@std@@QBEHABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<PS::CParticleGroup::SItem> > >::operator-, COMDAT
; _this$ = ecx

; 140  :         _Compat(_Right);
; 141  :         return _Ptr - _Right._Ptr;

	mov	eax, DWORD PTR __Right$[esp-4]
	mov	ecx, DWORD PTR [ecx]
	sub	ecx, DWORD PTR [eax]
	sar	ecx, 2
	imul	eax, ecx, -1227133513

; 142  :     }

	ret	4
??G?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@USItem@CParticleGroup@PS@@@std@@@std@@@std@@QBEHABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<PS::CParticleGroup::SItem> > >::operator-
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUSEffect@CPGDef@PS@@@std@@@std@@@std@@QAE?AV01@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$dead$ = 12					; size = 4
??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUSEffect@CPGDef@PS@@@std@@@std@@@std@@QAE?AV01@H@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<PS::CPGDef::SEffect *> > >::operator++, COMDAT
; _this$ = ecx

; 281  :         _Vector_iterator _Tmp = *this;

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx

; 74   :         ++_Ptr;

	add	edx, 4
	mov	DWORD PTR [ecx], edx

; 282  :         _Mybase::operator++();
; 283  :         return _Tmp;
; 284  :     }

	ret	8
??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUSEffect@CPGDef@PS@@@std@@@std@@@std@@QAE?AV01@H@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<PS::CPGDef::SEffect *> > >::operator++
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUSEffect@CPGDef@PS@@@std@@@std@@@std@@QBEAAPAUSEffect@CPGDef@PS@@XZ
_TEXT	SEGMENT
??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUSEffect@CPGDef@PS@@@std@@@std@@@std@@QBEAAPAUSEffect@CPGDef@PS@@XZ PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<PS::CPGDef::SEffect *> > >::operator*, COMDAT
; _this$ = ecx

; 261  :         return const_cast<reference>(_Mybase::operator*());

	mov	eax, DWORD PTR [ecx]

; 262  :     }

	ret	0
??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUSEffect@CPGDef@PS@@@std@@@std@@@std@@QBEAAPAUSEffect@CPGDef@PS@@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<PS::CPGDef::SEffect *> > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUSEffect@CPGDef@PS@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUSEffect@CPGDef@PS@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<PS::CPGDef::SEffect *> > >::operator!=, COMDAT
; _this$ = ecx

; 160  :         return !(*this == _Right);

	mov	eax, DWORD PTR __Right$[esp-4]
	mov	ecx, DWORD PTR [ecx]
	cmp	ecx, DWORD PTR [eax]
	setne	al

; 161  :     }

	ret	4
??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUSEffect@CPGDef@PS@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<PS::CPGDef::SEffect *> > >::operator!=
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??G?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUSEffect@CPGDef@PS@@@std@@@std@@@std@@QBEHABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??G?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUSEffect@CPGDef@PS@@@std@@@std@@@std@@QBEHABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<PS::CPGDef::SEffect *> > >::operator-, COMDAT
; _this$ = ecx

; 140  :         _Compat(_Right);
; 141  :         return _Ptr - _Right._Ptr;

	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR __Right$[esp-4]
	sub	eax, DWORD PTR [ecx]
	sar	eax, 2

; 142  :     }

	ret	4
??G?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUSEffect@CPGDef@PS@@@std@@@std@@@std@@QBEHABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<PS::CPGDef::SEffect *> > >::operator-
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUSEffect@CPGDef@PS@@@std@@@std@@@std@@QAE?AV01@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$dead$ = 12					; size = 4
??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUSEffect@CPGDef@PS@@@std@@@std@@@std@@QAE?AV01@H@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<PS::CPGDef::SEffect *> > >::operator++, COMDAT
; _this$ = ecx

; 79   :         _Vector_const_iterator _Tmp = *this;

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx

; 74   :         ++_Ptr;

	add	edx, 4
	mov	DWORD PTR [ecx], edx

; 80   :         ++*this;
; 81   :         return _Tmp;
; 82   :     }

	ret	8
??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUSEffect@CPGDef@PS@@@std@@@std@@@std@@QAE?AV01@H@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<PS::CPGDef::SEffect *> > >::operator++
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUSEffect@CPGDef@PS@@@std@@@std@@@std@@QBEABQAUSEffect@CPGDef@PS@@XZ
_TEXT	SEGMENT
??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUSEffect@CPGDef@PS@@@std@@@std@@@std@@QBEABQAUSEffect@CPGDef@PS@@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<PS::CPGDef::SEffect *> > >::operator*, COMDAT
; _this$ = ecx

; 46   : #if _ITERATOR_DEBUG_LEVEL != 0
; 47   :         const auto _Mycont = static_cast<const _Myvec*>(this->_Getcont());
; 48   :         _STL_VERIFY(_Ptr, "can't dereference value-initialized vector iterator");
; 49   :         _STL_VERIFY(
; 50   :             _Mycont->_Myfirst <= _Ptr && _Ptr < _Mycont->_Mylast, "can't dereference out of range vector iterator");
; 51   : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 52   : 
; 53   :         return *_Ptr;

	mov	eax, DWORD PTR [ecx]

; 54   :     }

	ret	0
??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUSEffect@CPGDef@PS@@@std@@@std@@@std@@QBEABQAUSEffect@CPGDef@PS@@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<PS::CPGDef::SEffect *> > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVIRender_Visual@@@std@@@std@@@std@@QAE?AV01@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$dead$ = 12					; size = 4
??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVIRender_Visual@@@std@@@std@@@std@@QAE?AV01@H@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<IRender_Visual *> > >::operator++, COMDAT
; _this$ = ecx

; 281  :         _Vector_iterator _Tmp = *this;

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx

; 74   :         ++_Ptr;

	add	edx, 4
	mov	DWORD PTR [ecx], edx

; 282  :         _Mybase::operator++();
; 283  :         return _Tmp;
; 284  :     }

	ret	8
??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVIRender_Visual@@@std@@@std@@@std@@QAE?AV01@H@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<IRender_Visual *> > >::operator++
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVIRender_Visual@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVIRender_Visual@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<IRender_Visual *> > >::operator!=, COMDAT
; _this$ = ecx

; 160  :         return !(*this == _Right);

	mov	eax, DWORD PTR __Right$[esp-4]
	mov	ecx, DWORD PTR [ecx]
	cmp	ecx, DWORD PTR [eax]
	setne	al

; 161  :     }

	ret	4
??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVIRender_Visual@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<IRender_Visual *> > >::operator!=
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVIRender_Visual@@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVIRender_Visual@@@std@@@std@@@std@@QAE@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<IRender_Visual *> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<IRender_Visual *> > >, COMDAT
; _this$ = ecx

; 39   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator() noexcept : _Ptr() {}

	mov	DWORD PTR [ecx], 0
	mov	eax, ecx
	ret	0
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVIRender_Visual@@@std@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<IRender_Visual *> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<IRender_Visual *> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ??A?$xr_vector@USItem@CParticleGroup@PS@@V?$xalloc@USItem@CParticleGroup@PS@@@@@@QAEAAUSItem@CParticleGroup@PS@@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$xr_vector@USItem@CParticleGroup@PS@@V?$xalloc@USItem@CParticleGroup@PS@@@@@@QAEAAUSItem@CParticleGroup@PS@@I@Z PROC ; xr_vector<PS::CParticleGroup::SItem,xalloc<PS::CParticleGroup::SItem> >::operator[], COMDAT
; _this$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 119  :         _Ptr += _Off;

	mov	eax, DWORD PTR __Pos$[esp-4]
	lea	edx, DWORD PTR [eax*8]
	sub	edx, eax
	mov	eax, DWORD PTR [ecx]
	lea	eax, DWORD PTR [eax+edx*4]
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 138  : 	reference operator[]		(size_type _Pos)					{ {VERIFY(_Pos<size());} return (*(begin() + _Pos)); }

	ret	4
??A?$xr_vector@USItem@CParticleGroup@PS@@V?$xalloc@USItem@CParticleGroup@PS@@@@@@QAEAAUSItem@CParticleGroup@PS@@I@Z ENDP ; xr_vector<PS::CParticleGroup::SItem,xalloc<PS::CParticleGroup::SItem> >::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?clear@?$xr_vector@USItem@CParticleGroup@PS@@V?$xalloc@USItem@CParticleGroup@PS@@@@@@QAEXXZ
_TEXT	SEGMENT
?clear@?$xr_vector@USItem@CParticleGroup@PS@@V?$xalloc@USItem@CParticleGroup@PS@@@@@@QAEXXZ PROC ; xr_vector<PS::CParticleGroup::SItem,xalloc<PS::CParticleGroup::SItem> >::clear, COMDAT
; _this$ = ecx

; 132  : 	void	clear				()									{ clear_and_free	();			}

	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [ecx+4], eax
	ret	0
?clear@?$xr_vector@USItem@CParticleGroup@PS@@V?$xalloc@USItem@CParticleGroup@PS@@@@@@QAEXXZ ENDP ; xr_vector<PS::CParticleGroup::SItem,xalloc<PS::CParticleGroup::SItem> >::clear
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?size@?$xr_vector@USItem@CParticleGroup@PS@@V?$xalloc@USItem@CParticleGroup@PS@@@@@@QBEIXZ
_TEXT	SEGMENT
?size@?$xr_vector@USItem@CParticleGroup@PS@@V?$xalloc@USItem@CParticleGroup@PS@@@@@@QBEIXZ PROC ; xr_vector<PS::CParticleGroup::SItem,xalloc<PS::CParticleGroup::SItem> >::size, COMDAT
; _this$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	eax, DWORD PTR [ecx+4]
	sub	eax, DWORD PTR [ecx]
	sar	eax, 2
	imul	eax, eax, -1227133513
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 125  : 	u32		size				() const							{ return (u32)inherited::size();} 

	ret	0
?size@?$xr_vector@USItem@CParticleGroup@PS@@V?$xalloc@USItem@CParticleGroup@PS@@@@@@QBEIXZ ENDP ; xr_vector<PS::CParticleGroup::SItem,xalloc<PS::CParticleGroup::SItem> >::size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ??0?$xr_vector@USItem@CParticleGroup@PS@@V?$xalloc@USItem@CParticleGroup@PS@@@@@@QAE@XZ
_TEXT	SEGMENT
??0?$xr_vector@USItem@CParticleGroup@PS@@V?$xalloc@USItem@CParticleGroup@PS@@@@@@QAE@XZ PROC ; xr_vector<PS::CParticleGroup::SItem,xalloc<PS::CParticleGroup::SItem> >::xr_vector<PS::CParticleGroup::SItem,xalloc<PS::CParticleGroup::SItem> >, COMDAT
; _this$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx], 0
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 122  : 			xr_vector			()									: inherited	()					{}

	mov	eax, ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 122  : 			xr_vector			()									: inherited	()					{}

	ret	0
??0?$xr_vector@USItem@CParticleGroup@PS@@V?$xalloc@USItem@CParticleGroup@PS@@@@@@QAE@XZ ENDP ; xr_vector<PS::CParticleGroup::SItem,xalloc<PS::CParticleGroup::SItem> >::xr_vector<PS::CParticleGroup::SItem,xalloc<PS::CParticleGroup::SItem> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?end@?$vector@USItem@CParticleGroup@PS@@V?$xalloc@USItem@CParticleGroup@PS@@@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USItem@CParticleGroup@PS@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@USItem@CParticleGroup@PS@@V?$xalloc@USItem@CParticleGroup@PS@@@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USItem@CParticleGroup@PS@@@std@@@std@@@2@XZ PROC ; std::vector<PS::CParticleGroup::SItem,xalloc<PS::CParticleGroup::SItem> >::end, COMDAT
; _this$ = ecx

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	ecx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax], ecx

; 1472 :         auto& _My_data = _Mypair._Myval2;
; 1473 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));
; 1474 :     }

	ret	4
?end@?$vector@USItem@CParticleGroup@PS@@V?$xalloc@USItem@CParticleGroup@PS@@@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USItem@CParticleGroup@PS@@@std@@@std@@@2@XZ ENDP ; std::vector<PS::CParticleGroup::SItem,xalloc<PS::CParticleGroup::SItem> >::end
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?begin@?$vector@USItem@CParticleGroup@PS@@V?$xalloc@USItem@CParticleGroup@PS@@@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USItem@CParticleGroup@PS@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@USItem@CParticleGroup@PS@@V?$xalloc@USItem@CParticleGroup@PS@@@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USItem@CParticleGroup@PS@@@std@@@std@@@2@XZ PROC ; std::vector<PS::CParticleGroup::SItem,xalloc<PS::CParticleGroup::SItem> >::begin, COMDAT
; _this$ = ecx

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	ecx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], ecx

; 1462 :         auto& _My_data = _Mypair._Myval2;
; 1463 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));
; 1464 :     }

	ret	4
?begin@?$vector@USItem@CParticleGroup@PS@@V?$xalloc@USItem@CParticleGroup@PS@@@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USItem@CParticleGroup@PS@@@std@@@std@@@2@XZ ENDP ; std::vector<PS::CParticleGroup::SItem,xalloc<PS::CParticleGroup::SItem> >::begin
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?resize@?$vector@USItem@CParticleGroup@PS@@V?$xalloc@USItem@CParticleGroup@PS@@@@@std@@QAEXI@Z
_TEXT	SEGMENT
$T1 = 8							; size = 1
__Newsize$ = 8						; size = 4
?resize@?$vector@USItem@CParticleGroup@PS@@V?$xalloc@USItem@CParticleGroup@PS@@@@@std@@QAEXI@Z PROC ; std::vector<PS::CParticleGroup::SItem,xalloc<PS::CParticleGroup::SItem> >::resize, COMDAT
; _this$ = ecx

; 1275 :     _CONSTEXPR20_CONTAINER void resize(_CRT_GUARDOVERFLOW const size_type _Newsize) {

	push	esi
	mov	esi, ecx

; 1251 :         if (_Newsize < _Oldsize) { // trim

	mov	ecx, DWORD PTR __Newsize$[esp]

; 1275 :     _CONSTEXPR20_CONTAINER void resize(_CRT_GUARDOVERFLOW const size_type _Newsize) {

	push	edi

; 1250 :         const auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);

	mov	eax, DWORD PTR [esi+4]
	mov	edi, DWORD PTR [esi]
	sub	eax, edi
	sar	eax, 2
	imul	edx, eax, -1227133513

; 1251 :         if (_Newsize < _Oldsize) { // trim

	cmp	ecx, edx
	jae	SHORT $LN4@resize

; 1252 :             const pointer _Newlast = _Myfirst + _Newsize;

	lea	eax, DWORD PTR [ecx*8]
	sub	eax, ecx
	lea	eax, DWORD PTR [edi+eax*4]
	pop	edi

; 1276 :         // trim or append value-initialized elements, provide strong guarantee
; 1277 :         _Resize(_Newsize, _Value_init_tag{});
; 1278 :     }

	mov	DWORD PTR [esi+4], eax
	pop	esi
	ret	4
$LN4@resize:

; 1259 :         if (_Newsize > _Oldsize) { // append

	jbe	SHORT $LN5@resize

; 1260 :             const auto _Oldcapacity = static_cast<size_type>(_My_data._Myend - _Myfirst);

	mov	eax, DWORD PTR [esi+8]
	sub	eax, edi
	sar	eax, 2
	imul	eax, eax, -1227133513

; 1261 :             if (_Newsize > _Oldcapacity) { // reallocate

	cmp	ecx, eax
	jbe	SHORT $LN6@resize

; 1262 :                 _Resize_reallocate(_Newsize, _Val);

	lea	eax, DWORD PTR $T1[esp+4]
	push	eax
	push	ecx
	mov	ecx, esi
	call	??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@USItem@CParticleGroup@PS@@V?$xalloc@USItem@CParticleGroup@PS@@@@@std@@AAEXIABU_Value_init_tag@1@@Z ; std::vector<PS::CParticleGroup::SItem,xalloc<PS::CParticleGroup::SItem> >::_Resize_reallocate<std::_Value_init_tag>
	pop	edi

; 1276 :         // trim or append value-initialized elements, provide strong guarantee
; 1277 :         _Resize(_Newsize, _Value_init_tag{});
; 1278 :     }

	pop	esi
	ret	4
$LN6@resize:

; 1267 :             _Mylast                = _Ufill(_Oldlast, _Newsize - _Oldsize, _Val);

	push	DWORD PTR $T1[esp+4]
	sub	ecx, edx
	push	ecx
	push	DWORD PTR [esi+4]
	call	?_Ufill@?$vector@USItem@CParticleGroup@PS@@V?$xalloc@USItem@CParticleGroup@PS@@@@@std@@AAEPAUSItem@CParticleGroup@PS@@PAU345@IU_Value_init_tag@2@@Z ; std::vector<PS::CParticleGroup::SItem,xalloc<PS::CParticleGroup::SItem> >::_Ufill

; 1276 :         // trim or append value-initialized elements, provide strong guarantee
; 1277 :         _Resize(_Newsize, _Value_init_tag{});
; 1278 :     }

	mov	DWORD PTR [esi+4], eax
$LN5@resize:
	pop	edi
	pop	esi
	ret	4
?resize@?$vector@USItem@CParticleGroup@PS@@V?$xalloc@USItem@CParticleGroup@PS@@@@@std@@QAEXI@Z ENDP ; std::vector<PS::CParticleGroup::SItem,xalloc<PS::CParticleGroup::SItem> >::resize
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??1?$vector@USItem@CParticleGroup@PS@@V?$xalloc@USItem@CParticleGroup@PS@@@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@USItem@CParticleGroup@PS@@V?$xalloc@USItem@CParticleGroup@PS@@@@@std@@QAE@XZ PROC ; std::vector<PS::CParticleGroup::SItem,xalloc<PS::CParticleGroup::SItem> >::~vector<PS::CParticleGroup::SItem,xalloc<PS::CParticleGroup::SItem> >, COMDAT
; _this$ = ecx

; 698  :     _CONSTEXPR20_CONTAINER ~vector() noexcept {

	push	esi
	mov	esi, ecx

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN4@vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+4], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+8], 0
$LN4@vector:
	pop	esi

; 699  :         _Tidy();
; 700  : #if _ITERATOR_DEBUG_LEVEL != 0
; 701  :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 702  :         _Delete_plain_internal(_Alproxy, _STD exchange(_Mypair._Myval2._Myproxy, nullptr));
; 703  : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 704  :     }

	ret	0
??1?$vector@USItem@CParticleGroup@PS@@V?$xalloc@USItem@CParticleGroup@PS@@@@@std@@QAE@XZ ENDP ; std::vector<PS::CParticleGroup::SItem,xalloc<PS::CParticleGroup::SItem> >::~vector<PS::CParticleGroup::SItem,xalloc<PS::CParticleGroup::SItem> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?back@?$vector@PAVIRender_Visual@@V?$xalloc@PAVIRender_Visual@@@@@std@@QAEAAPAVIRender_Visual@@XZ
_TEXT	SEGMENT
?back@?$vector@PAVIRender_Visual@@V?$xalloc@PAVIRender_Visual@@@@@std@@QAEAAPAVIRender_Visual@@XZ PROC ; std::vector<IRender_Visual *,xalloc<IRender_Visual *> >::back, COMDAT
; _this$ = ecx

; 1606 :         auto& _My_data = _Mypair._Myval2;
; 1607 : #if _CONTAINER_DEBUG_LEVEL > 0
; 1608 :         _STL_VERIFY(_My_data._Myfirst != _My_data._Mylast, "back() called on empty vector");
; 1609 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 1610 : 
; 1611 :         return _My_data._Mylast[-1];

	mov	eax, DWORD PTR [ecx+4]
	sub	eax, 4

; 1612 :     }

	ret	0
?back@?$vector@PAVIRender_Visual@@V?$xalloc@PAVIRender_Visual@@@@@std@@QAEAAPAVIRender_Visual@@XZ ENDP ; std::vector<IRender_Visual *,xalloc<IRender_Visual *> >::back
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?empty@?$vector@PAVIRender_Visual@@V?$xalloc@PAVIRender_Visual@@@@@std@@QBE_NXZ
_TEXT	SEGMENT
?empty@?$vector@PAVIRender_Visual@@V?$xalloc@PAVIRender_Visual@@@@@std@@QBE_NXZ PROC ; std::vector<IRender_Visual *,xalloc<IRender_Visual *> >::empty, COMDAT
; _this$ = ecx

; 1530 :         auto& _My_data = _Mypair._Myval2;
; 1531 :         return _My_data._Myfirst == _My_data._Mylast;

	mov	eax, DWORD PTR [ecx]
	cmp	eax, DWORD PTR [ecx+4]
	sete	al

; 1532 :     }

	ret	0
?empty@?$vector@PAVIRender_Visual@@V?$xalloc@PAVIRender_Visual@@@@@std@@QBE_NXZ ENDP ; std::vector<IRender_Visual *,xalloc<IRender_Visual *> >::empty
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?erase@?$vector@PAVIRender_Visual@@V?$xalloc@PAVIRender_Visual@@@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVIRender_Visual@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVIRender_Visual@@@std@@@std@@@2@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
?erase@?$vector@PAVIRender_Visual@@V?$xalloc@PAVIRender_Visual@@@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVIRender_Visual@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVIRender_Visual@@@std@@@std@@@2@0@Z PROC ; std::vector<IRender_Visual *,xalloc<IRender_Visual *> >::erase, COMDAT
; _this$ = ecx

; 1414 :         const pointer _Firstptr = _First._Ptr;
; 1415 :         const pointer _Lastptr  = _Last._Ptr;
; 1416 :         auto& _My_data          = _Mypair._Myval2;
; 1417 :         pointer& _Mylast        = _My_data._Mylast;

	mov	eax, DWORD PTR __Last$[esp-4]
	push	ebx
	push	edi
	mov	edi, DWORD PTR __First$[esp+4]
	mov	ebx, ecx
	cmp	edi, eax

; 1418 : 
; 1419 : #if _ITERATOR_DEBUG_LEVEL == 2
; 1420 :         _STL_VERIFY(_First._Getcont() == _STD addressof(_My_data) && _Last._Getcont() == _STD addressof(_My_data)
; 1421 :                         && _Firstptr >= _My_data._Myfirst && _Lastptr >= _Firstptr && _Mylast >= _Lastptr,
; 1422 :             "vector erase iterator outside range");
; 1423 : #endif // _ITERATOR_DEBUG_LEVEL == 2
; 1424 : 
; 1425 :         if (_Firstptr != _Lastptr) { // something to do, invalidate iterators

	je	SHORT $LN15@erase
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility

; 4065 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	push	esi
	mov	esi, DWORD PTR [ebx+4]
	sub	esi, eax

; 4066 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	push	esi
	push	eax
	push	edi
	call	_memmove
	add	esp, 12					; 0000000cH

; 4067 :     if constexpr (is_pointer_v<_OutCtgIt>) {
; 4068 :         return reinterpret_cast<_OutCtgIt>(_Dest_ch + _Count);

	lea	eax, DWORD PTR [edi+esi]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1430 :             _Mylast = _Newlast;

	mov	DWORD PTR [ebx+4], eax

; 1431 :         }
; 1432 : 
; 1433 :         return iterator(_Firstptr, _STD addressof(_My_data));

	pop	esi
$LN15@erase:

; 1434 :     }

	mov	eax, DWORD PTR ___$ReturnUdt$[esp+4]
	mov	DWORD PTR [eax], edi
	pop	edi
	pop	ebx
	ret	12					; 0000000cH
?erase@?$vector@PAVIRender_Visual@@V?$xalloc@PAVIRender_Visual@@@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVIRender_Visual@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVIRender_Visual@@@std@@@std@@@2@0@Z ENDP ; std::vector<IRender_Visual *,xalloc<IRender_Visual *> >::erase
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?pop_back@?$vector@PAVIRender_Visual@@V?$xalloc@PAVIRender_Visual@@@@@std@@QAEXXZ
_TEXT	SEGMENT
?pop_back@?$vector@PAVIRender_Visual@@V?$xalloc@PAVIRender_Visual@@@@@std@@QAEXXZ PROC ; std::vector<IRender_Visual *,xalloc<IRender_Visual *> >::pop_back, COMDAT
; _this$ = ecx

; 1381 :         auto& _My_data   = _Mypair._Myval2;
; 1382 :         pointer& _Mylast = _My_data._Mylast;
; 1383 : 
; 1384 : #if _ITERATOR_DEBUG_LEVEL == 2
; 1385 :         _STL_VERIFY(_My_data._Myfirst != _Mylast, "vector empty before pop");
; 1386 : #endif // _ITERATOR_DEBUG_LEVEL == 2
; 1387 : 
; 1388 :         _Orphan_range(_Mylast - 1, _Mylast);
; 1389 :         _Alty_traits::destroy(_Getal(), _Unfancy(_Mylast - 1));
; 1390 :         --_Mylast;

	add	DWORD PTR [ecx+4], -4			; fffffffcH

; 1391 :     }

	ret	0
?pop_back@?$vector@PAVIRender_Visual@@V?$xalloc@PAVIRender_Visual@@@@@std@@QAEXXZ ENDP ; std::vector<IRender_Visual *,xalloc<IRender_Visual *> >::pop_back
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?push_back@?$vector@PAVIRender_Visual@@V?$xalloc@PAVIRender_Visual@@@@@std@@QAEX$$QAPAVIRender_Visual@@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?push_back@?$vector@PAVIRender_Visual@@V?$xalloc@PAVIRender_Visual@@@@@std@@QAEX$$QAPAVIRender_Visual@@@Z PROC ; std::vector<IRender_Visual *,xalloc<IRender_Visual *> >::push_back, COMDAT
; _this$ = ecx

; 730  :         if (_Mylast != _My_data._Myend) {

	mov	edx, DWORD PTR [ecx+4]
	cmp	edx, DWORD PTR [ecx+8]
	je	SHORT $LN4@push_back

; 713  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

	mov	eax, DWORD PTR __Val$[esp-4]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edx], eax

; 714  :         _Orphan_range(_Mylast, _Mylast);
; 715  :         _Ty& _Result = *_Mylast;
; 716  :         ++_Mylast;

	add	DWORD PTR [ecx+4], 4

; 747  :         // insert by moving into element at end, provide strong guarantee
; 748  :         emplace_back(_STD move(_Val));
; 749  :     }

	ret	4
$LN4@push_back:

; 734  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	push	DWORD PTR __Val$[esp-4]
	push	edx
	call	??$_Emplace_reallocate@PAVIRender_Visual@@@?$vector@PAVIRender_Visual@@V?$xalloc@PAVIRender_Visual@@@@@std@@QAEPAPAVIRender_Visual@@QAPAV2@$$QAPAV2@@Z ; std::vector<IRender_Visual *,xalloc<IRender_Visual *> >::_Emplace_reallocate<IRender_Visual *>

; 747  :         // insert by moving into element at end, provide strong guarantee
; 748  :         emplace_back(_STD move(_Val));
; 749  :     }

	ret	4
?push_back@?$vector@PAVIRender_Visual@@V?$xalloc@PAVIRender_Visual@@@@@std@@QAEX$$QAPAVIRender_Visual@@@Z ENDP ; std::vector<IRender_Visual *,xalloc<IRender_Visual *> >::push_back
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??$emplace_back@PAVIRender_Visual@@@?$vector@PAVIRender_Visual@@V?$xalloc@PAVIRender_Visual@@@@@std@@QAE?A_T$$QAPAVIRender_Visual@@@Z
_TEXT	SEGMENT
_<_Val_0>$ = 8						; size = 4
??$emplace_back@PAVIRender_Visual@@@?$vector@PAVIRender_Visual@@V?$xalloc@PAVIRender_Visual@@@@@std@@QAE?A_T$$QAPAVIRender_Visual@@@Z PROC ; std::vector<IRender_Visual *,xalloc<IRender_Visual *> >::emplace_back<IRender_Visual *>, COMDAT
; _this$ = ecx

; 727  :         // insert by perfectly forwarding into element at end, provide strong guarantee
; 728  :         auto& _My_data   = _Mypair._Myval2;
; 729  :         pointer& _Mylast = _My_data._Mylast;
; 730  :         if (_Mylast != _My_data._Myend) {

	mov	edx, DWORD PTR [ecx+4]
	cmp	edx, DWORD PTR [ecx+8]
	je	SHORT $LN2@emplace_ba

; 713  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

	mov	eax, DWORD PTR _<_Val_0>$[esp-4]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edx], eax

; 714  :         _Orphan_range(_Mylast, _Mylast);
; 715  :         _Ty& _Result = *_Mylast;
; 716  :         ++_Mylast;

	add	DWORD PTR [ecx+4], 4

; 735  : #if _HAS_CXX17
; 736  :         return _Result;
; 737  : #else // ^^^ _HAS_CXX17 ^^^ // vvv !_HAS_CXX17 vvv
; 738  :         (void) _Result;
; 739  : #endif // _HAS_CXX17
; 740  :     }

	ret	4
$LN2@emplace_ba:

; 731  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);
; 732  :         }
; 733  : 
; 734  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	push	DWORD PTR _<_Val_0>$[esp-4]
	push	edx
	call	??$_Emplace_reallocate@PAVIRender_Visual@@@?$vector@PAVIRender_Visual@@V?$xalloc@PAVIRender_Visual@@@@@std@@QAEPAPAVIRender_Visual@@QAPAV2@$$QAPAV2@@Z ; std::vector<IRender_Visual *,xalloc<IRender_Visual *> >::_Emplace_reallocate<IRender_Visual *>

; 735  : #if _HAS_CXX17
; 736  :         return _Result;
; 737  : #else // ^^^ _HAS_CXX17 ^^^ // vvv !_HAS_CXX17 vvv
; 738  :         (void) _Result;
; 739  : #endif // _HAS_CXX17
; 740  :     }

	ret	4
??$emplace_back@PAVIRender_Visual@@@?$vector@PAVIRender_Visual@@V?$xalloc@PAVIRender_Visual@@@@@std@@QAE?A_T$$QAPAVIRender_Visual@@@Z ENDP ; std::vector<IRender_Visual *,xalloc<IRender_Visual *> >::emplace_back<IRender_Visual *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??$_Emplace_back_with_unused_capacity@PAVIRender_Visual@@@?$vector@PAVIRender_Visual@@V?$xalloc@PAVIRender_Visual@@@@@std@@AAE?A_T$$QAPAVIRender_Visual@@@Z
_TEXT	SEGMENT
_<_Val_0>$ = 8						; size = 4
??$_Emplace_back_with_unused_capacity@PAVIRender_Visual@@@?$vector@PAVIRender_Visual@@V?$xalloc@PAVIRender_Visual@@@@@std@@AAE?A_T$$QAPAVIRender_Visual@@@Z PROC ; std::vector<IRender_Visual *,xalloc<IRender_Visual *> >::_Emplace_back_with_unused_capacity<IRender_Visual *>, COMDAT
; _this$ = ecx

; 709  :         // insert by perfectly forwarding into element at end, provide strong guarantee
; 710  :         auto& _My_data   = _Mypair._Myval2;
; 711  :         pointer& _Mylast = _My_data._Mylast;
; 712  :         _STL_INTERNAL_CHECK(_Mylast != _My_data._Myend); // check that we have unused capacity
; 713  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _<_Val_0>$[esp-4]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edx], eax

; 714  :         _Orphan_range(_Mylast, _Mylast);
; 715  :         _Ty& _Result = *_Mylast;
; 716  :         ++_Mylast;

	add	DWORD PTR [ecx+4], 4

; 717  : #if _HAS_CXX17
; 718  :         return _Result;
; 719  : #else // ^^^ _HAS_CXX17 ^^^ // vvv !_HAS_CXX17 vvv
; 720  :         (void) _Result;
; 721  : #endif // _HAS_CXX17
; 722  :     }

	ret	4
??$_Emplace_back_with_unused_capacity@PAVIRender_Visual@@@?$vector@PAVIRender_Visual@@V?$xalloc@PAVIRender_Visual@@@@@std@@AAE?A_T$$QAPAVIRender_Visual@@@Z ENDP ; std::vector<IRender_Visual *,xalloc<IRender_Visual *> >::_Emplace_back_with_unused_capacity<IRender_Visual *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ??A?$xr_vector@PAUSEffect@CPGDef@PS@@V?$xalloc@PAUSEffect@CPGDef@PS@@@@@@QBEABQAUSEffect@CPGDef@PS@@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$xr_vector@PAUSEffect@CPGDef@PS@@V?$xalloc@PAUSEffect@CPGDef@PS@@@@@@QBEABQAUSEffect@CPGDef@PS@@I@Z PROC ; xr_vector<PS::CPGDef::SEffect *,xalloc<PS::CPGDef::SEffect *> >::operator[], COMDAT
; _this$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 119  :         _Ptr += _Off;

	mov	ecx, DWORD PTR [ecx]
	mov	eax, DWORD PTR __Pos$[esp-4]
	lea	eax, DWORD PTR [ecx+eax*4]
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 137  : 	const_reference operator[]	(size_type _Pos) const				{ {VERIFY(_Pos<size());} return (*(begin() + _Pos)); }

	ret	4
??A?$xr_vector@PAUSEffect@CPGDef@PS@@V?$xalloc@PAUSEffect@CPGDef@PS@@@@@@QBEABQAUSEffect@CPGDef@PS@@I@Z ENDP ; xr_vector<PS::CPGDef::SEffect *,xalloc<PS::CPGDef::SEffect *> >::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?clear@?$xr_vector@PAUSEffect@CPGDef@PS@@V?$xalloc@PAUSEffect@CPGDef@PS@@@@@@QAEXXZ
_TEXT	SEGMENT
?clear@?$xr_vector@PAUSEffect@CPGDef@PS@@V?$xalloc@PAUSEffect@CPGDef@PS@@@@@@QAEXXZ PROC ; xr_vector<PS::CPGDef::SEffect *,xalloc<PS::CPGDef::SEffect *> >::clear, COMDAT
; _this$ = ecx

; 132  : 	void	clear				()									{ clear_and_free	();			}

	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [ecx+4], eax
	ret	0
?clear@?$xr_vector@PAUSEffect@CPGDef@PS@@V?$xalloc@PAUSEffect@CPGDef@PS@@@@@@QAEXXZ ENDP ; xr_vector<PS::CPGDef::SEffect *,xalloc<PS::CPGDef::SEffect *> >::clear
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?size@?$xr_vector@PAUSEffect@CPGDef@PS@@V?$xalloc@PAUSEffect@CPGDef@PS@@@@@@QBEIXZ
_TEXT	SEGMENT
?size@?$xr_vector@PAUSEffect@CPGDef@PS@@V?$xalloc@PAUSEffect@CPGDef@PS@@@@@@QBEIXZ PROC ; xr_vector<PS::CPGDef::SEffect *,xalloc<PS::CPGDef::SEffect *> >::size, COMDAT
; _this$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	eax, DWORD PTR [ecx+4]
	sub	eax, DWORD PTR [ecx]
	sar	eax, 2
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 125  : 	u32		size				() const							{ return (u32)inherited::size();} 

	ret	0
?size@?$xr_vector@PAUSEffect@CPGDef@PS@@V?$xalloc@PAUSEffect@CPGDef@PS@@@@@@QBEIXZ ENDP ; xr_vector<PS::CPGDef::SEffect *,xalloc<PS::CPGDef::SEffect *> >::size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ??0?$xr_vector@PAUSEffect@CPGDef@PS@@V?$xalloc@PAUSEffect@CPGDef@PS@@@@@@QAE@XZ
_TEXT	SEGMENT
??0?$xr_vector@PAUSEffect@CPGDef@PS@@V?$xalloc@PAUSEffect@CPGDef@PS@@@@@@QAE@XZ PROC ; xr_vector<PS::CPGDef::SEffect *,xalloc<PS::CPGDef::SEffect *> >::xr_vector<PS::CPGDef::SEffect *,xalloc<PS::CPGDef::SEffect *> >, COMDAT
; _this$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx], 0
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 122  : 			xr_vector			()									: inherited	()					{}

	mov	eax, ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 122  : 			xr_vector			()									: inherited	()					{}

	ret	0
??0?$xr_vector@PAUSEffect@CPGDef@PS@@V?$xalloc@PAUSEffect@CPGDef@PS@@@@@@QAE@XZ ENDP ; xr_vector<PS::CPGDef::SEffect *,xalloc<PS::CPGDef::SEffect *> >::xr_vector<PS::CPGDef::SEffect *,xalloc<PS::CPGDef::SEffect *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?end@?$vector@PAUSEffect@CPGDef@PS@@V?$xalloc@PAUSEffect@CPGDef@PS@@@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUSEffect@CPGDef@PS@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@PAUSEffect@CPGDef@PS@@V?$xalloc@PAUSEffect@CPGDef@PS@@@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUSEffect@CPGDef@PS@@@std@@@std@@@2@XZ PROC ; std::vector<PS::CPGDef::SEffect *,xalloc<PS::CPGDef::SEffect *> >::end, COMDAT
; _this$ = ecx

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	ecx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax], ecx

; 1477 :         auto& _My_data = _Mypair._Myval2;
; 1478 :         return const_iterator(_My_data._Mylast, _STD addressof(_My_data));
; 1479 :     }

	ret	4
?end@?$vector@PAUSEffect@CPGDef@PS@@V?$xalloc@PAUSEffect@CPGDef@PS@@@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUSEffect@CPGDef@PS@@@std@@@std@@@2@XZ ENDP ; std::vector<PS::CPGDef::SEffect *,xalloc<PS::CPGDef::SEffect *> >::end
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?end@?$vector@PAUSEffect@CPGDef@PS@@V?$xalloc@PAUSEffect@CPGDef@PS@@@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUSEffect@CPGDef@PS@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@PAUSEffect@CPGDef@PS@@V?$xalloc@PAUSEffect@CPGDef@PS@@@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUSEffect@CPGDef@PS@@@std@@@std@@@2@XZ PROC ; std::vector<PS::CPGDef::SEffect *,xalloc<PS::CPGDef::SEffect *> >::end, COMDAT
; _this$ = ecx

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	ecx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax], ecx

; 1472 :         auto& _My_data = _Mypair._Myval2;
; 1473 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));
; 1474 :     }

	ret	4
?end@?$vector@PAUSEffect@CPGDef@PS@@V?$xalloc@PAUSEffect@CPGDef@PS@@@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUSEffect@CPGDef@PS@@@std@@@std@@@2@XZ ENDP ; std::vector<PS::CPGDef::SEffect *,xalloc<PS::CPGDef::SEffect *> >::end
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?begin@?$vector@PAUSEffect@CPGDef@PS@@V?$xalloc@PAUSEffect@CPGDef@PS@@@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUSEffect@CPGDef@PS@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@PAUSEffect@CPGDef@PS@@V?$xalloc@PAUSEffect@CPGDef@PS@@@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUSEffect@CPGDef@PS@@@std@@@std@@@2@XZ PROC ; std::vector<PS::CPGDef::SEffect *,xalloc<PS::CPGDef::SEffect *> >::begin, COMDAT
; _this$ = ecx

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	ecx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], ecx

; 1467 :         auto& _My_data = _Mypair._Myval2;
; 1468 :         return const_iterator(_My_data._Myfirst, _STD addressof(_My_data));
; 1469 :     }

	ret	4
?begin@?$vector@PAUSEffect@CPGDef@PS@@V?$xalloc@PAUSEffect@CPGDef@PS@@@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUSEffect@CPGDef@PS@@@std@@@std@@@2@XZ ENDP ; std::vector<PS::CPGDef::SEffect *,xalloc<PS::CPGDef::SEffect *> >::begin
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?begin@?$vector@PAUSEffect@CPGDef@PS@@V?$xalloc@PAUSEffect@CPGDef@PS@@@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUSEffect@CPGDef@PS@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@PAUSEffect@CPGDef@PS@@V?$xalloc@PAUSEffect@CPGDef@PS@@@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUSEffect@CPGDef@PS@@@std@@@std@@@2@XZ PROC ; std::vector<PS::CPGDef::SEffect *,xalloc<PS::CPGDef::SEffect *> >::begin, COMDAT
; _this$ = ecx

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	ecx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], ecx

; 1462 :         auto& _My_data = _Mypair._Myval2;
; 1463 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));
; 1464 :     }

	ret	4
?begin@?$vector@PAUSEffect@CPGDef@PS@@V?$xalloc@PAUSEffect@CPGDef@PS@@@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUSEffect@CPGDef@PS@@@std@@@std@@@2@XZ ENDP ; std::vector<PS::CPGDef::SEffect *,xalloc<PS::CPGDef::SEffect *> >::begin
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?resize@?$vector@PAUSEffect@CPGDef@PS@@V?$xalloc@PAUSEffect@CPGDef@PS@@@@@std@@QAEXI@Z
_TEXT	SEGMENT
__Newsize$ = 8						; size = 4
?resize@?$vector@PAUSEffect@CPGDef@PS@@V?$xalloc@PAUSEffect@CPGDef@PS@@@@@std@@QAEXI@Z PROC ; std::vector<PS::CPGDef::SEffect *,xalloc<PS::CPGDef::SEffect *> >::resize, COMDAT
; _this$ = ecx

; 1275 :     _CONSTEXPR20_CONTAINER void resize(_CRT_GUARDOVERFLOW const size_type _Newsize) {

	push	ebx
	push	esi

; 1251 :         if (_Newsize < _Oldsize) { // trim

	mov	esi, DWORD PTR __Newsize$[esp+4]

; 1275 :     _CONSTEXPR20_CONTAINER void resize(_CRT_GUARDOVERFLOW const size_type _Newsize) {

	push	edi
	mov	edi, ecx

; 1250 :         const auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);

	mov	ebx, DWORD PTR [edi+4]
	mov	ecx, ebx
	mov	edx, DWORD PTR [edi]
	sub	ecx, edx
	sar	ecx, 2

; 1251 :         if (_Newsize < _Oldsize) { // trim

	cmp	esi, ecx
	jae	SHORT $LN4@resize

; 1252 :             const pointer _Newlast = _Myfirst + _Newsize;

	lea	eax, DWORD PTR [edx+esi*4]

; 1278 :     }

	mov	DWORD PTR [edi+4], eax
	pop	edi
	pop	esi
	pop	ebx
	ret	4
$LN4@resize:

; 1259 :         if (_Newsize > _Oldsize) { // append

	jbe	SHORT $LN5@resize

; 1260 :             const auto _Oldcapacity = static_cast<size_type>(_My_data._Myend - _Myfirst);

	mov	eax, DWORD PTR [edi+8]
	sub	eax, edx
	sar	eax, 2

; 1261 :             if (_Newsize > _Oldcapacity) { // reallocate

	cmp	esi, eax
	jbe	SHORT $LN6@resize

; 1262 :                 _Resize_reallocate(_Newsize, _Val);

	push	ecx
	push	esi
	mov	ecx, edi
	call	??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@PAUSEffect@CPGDef@PS@@V?$xalloc@PAUSEffect@CPGDef@PS@@@@@std@@AAEXIABU_Value_init_tag@1@@Z ; std::vector<PS::CPGDef::SEffect *,xalloc<PS::CPGDef::SEffect *> >::_Resize_reallocate<std::_Value_init_tag>
	pop	edi

; 1278 :     }

	pop	esi
	pop	ebx
	ret	4
$LN6@resize:

; 1267 :             _Mylast                = _Ufill(_Oldlast, _Newsize - _Oldsize, _Val);

	sub	esi, ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1807 :             _Zero_range(_PFirst, _PFirst + _Count);

	shl	esi, 2

; 1792 :     _CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

	push	esi
	push	0
	push	ebx
	call	_memset

; 1808 :             return _First + _Count;

	lea	eax, DWORD PTR [esi+ebx]

; 1792 :     _CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

	add	esp, 12					; 0000000cH
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1278 :     }

	mov	DWORD PTR [edi+4], eax
$LN5@resize:
	pop	edi
	pop	esi
	pop	ebx
	ret	4
?resize@?$vector@PAUSEffect@CPGDef@PS@@V?$xalloc@PAUSEffect@CPGDef@PS@@@@@std@@QAEXI@Z ENDP ; std::vector<PS::CPGDef::SEffect *,xalloc<PS::CPGDef::SEffect *> >::resize
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??1?$vector@PAUSEffect@CPGDef@PS@@V?$xalloc@PAUSEffect@CPGDef@PS@@@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@PAUSEffect@CPGDef@PS@@V?$xalloc@PAUSEffect@CPGDef@PS@@@@@std@@QAE@XZ PROC ; std::vector<PS::CPGDef::SEffect *,xalloc<PS::CPGDef::SEffect *> >::~vector<PS::CPGDef::SEffect *,xalloc<PS::CPGDef::SEffect *> >, COMDAT
; _this$ = ecx

; 698  :     _CONSTEXPR20_CONTAINER ~vector() noexcept {

	push	esi
	mov	esi, ecx

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN4@vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+4], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+8], 0
$LN4@vector:
	pop	esi

; 699  :         _Tidy();
; 700  : #if _ITERATOR_DEBUG_LEVEL != 0
; 701  :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 702  :         _Delete_plain_internal(_Alproxy, _STD exchange(_Mypair._Myval2._Myproxy, nullptr));
; 703  : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 704  :     }

	ret	0
??1?$vector@PAUSEffect@CPGDef@PS@@V?$xalloc@PAUSEffect@CPGDef@PS@@@@@std@@QAE@XZ ENDP ; std::vector<PS::CPGDef::SEffect *,xalloc<PS::CPGDef::SEffect *> >::~vector<PS::CPGDef::SEffect *,xalloc<PS::CPGDef::SEffect *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h
;	COMDAT ?is_valid@?$_box3@M@@QAEHXZ
_TEXT	SEGMENT
?is_valid@?$_box3@M@@QAEHXZ PROC			; _box3<float>::is_valid, COMDAT
; _this$ = ecx

; 26   : 	IC	BOOL	is_valid	()											{return (x2>=x1)&&(y2>=y1)&&(z2>=z1);}

	movss	xmm0, DWORD PTR [ecx+12]
	comiss	xmm0, DWORD PTR [ecx]
	jb	SHORT $LN3@is_valid
	movss	xmm0, DWORD PTR [ecx+16]
	comiss	xmm0, DWORD PTR [ecx+4]
	jb	SHORT $LN3@is_valid
	movss	xmm0, DWORD PTR [ecx+20]
	comiss	xmm0, DWORD PTR [ecx+8]
	jb	SHORT $LN3@is_valid
	mov	eax, 1
	ret	0
$LN3@is_valid:
	xor	eax, eax
	ret	0
?is_valid@?$_box3@M@@QAEHXZ ENDP			; _box3<float>::is_valid
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
;	COMDAT ?transform_dir@?$_matrix@M@@QBEXAAU?$_vector3@M@@@Z
_TEXT	SEGMENT
_v$ = 8							; size = 4
?transform_dir@?$_matrix@M@@QBEXAAU?$_vector3@M@@@Z PROC ; _matrix<float>::transform_dir, COMDAT
; _this$ = ecx

; 516  : 		dest.x = v.x*_11 + v.y*_21 + v.z*_31;

	mov	eax, DWORD PTR _v$[esp-4]
	movss	xmm4, DWORD PTR [eax+4]
	movss	xmm5, DWORD PTR [eax]
	movaps	xmm3, xmm4
	mulss	xmm3, DWORD PTR [ecx+16]
	movaps	xmm0, xmm5
	mulss	xmm0, DWORD PTR [ecx]

; 517  : 		dest.y = v.x*_12 + v.y*_22 + v.z*_32;

	movaps	xmm1, xmm5
	movss	xmm2, DWORD PTR [eax+8]
	mulss	xmm1, DWORD PTR [ecx+4]

; 518  : 		dest.z = v.x*_13 + v.y*_23 + v.z*_33;

	mulss	xmm5, DWORD PTR [ecx+8]
	addss	xmm3, xmm0
	movaps	xmm0, xmm2
	mulss	xmm0, DWORD PTR [ecx+32]
	addss	xmm3, xmm0
	movaps	xmm0, xmm4
	mulss	xmm0, DWORD PTR [ecx+20]
	mulss	xmm4, DWORD PTR [ecx+24]
	addss	xmm1, xmm0
	movaps	xmm0, xmm2
	mulss	xmm0, DWORD PTR [ecx+36]
	mulss	xmm2, DWORD PTR [ecx+40]
	addss	xmm5, xmm4
	addss	xmm1, xmm0
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 24   : 	ICF SelfRef	set(const _vector3<float> &v)			{ x = T(v.x);	y = T(v.y);	z = T(v.z);	return *this;	};

	movss	DWORD PTR [eax], xmm3
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 518  : 		dest.z = v.x*_13 + v.y*_23 + v.z*_33;

	addss	xmm5, xmm2
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 24   : 	ICF SelfRef	set(const _vector3<float> &v)			{ x = T(v.x);	y = T(v.y);	z = T(v.z);	return *this;	};

	movss	DWORD PTR [eax+4], xmm1
	movss	DWORD PTR [eax+8], xmm5
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 552  : 	}

	ret	4
?transform_dir@?$_matrix@M@@QBEXAAU?$_vector3@M@@@Z ENDP ; _matrix<float>::transform_dir
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USItem@CParticleGroup@PS@@@std@@@std@@@std@@QAE@PAUSItem@CParticleGroup@PS@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
___param0$ = 8						; size = 4
___param1$dead$ = 12					; size = 4
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USItem@CParticleGroup@PS@@@std@@@std@@@std@@QAE@PAUSItem@CParticleGroup@PS@@PBU_Container_base0@1@@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<PS::CParticleGroup::SItem> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<PS::CParticleGroup::SItem> > >, COMDAT
; _this$ = ecx

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	eax, DWORD PTR ___param0$[esp-4]
	mov	DWORD PTR [ecx], eax
	mov	eax, ecx
	ret	8
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USItem@CParticleGroup@PS@@@std@@@std@@@std@@QAE@PAUSItem@CParticleGroup@PS@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<PS::CParticleGroup::SItem> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<PS::CParticleGroup::SItem> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUSEffect@CPGDef@PS@@@std@@@std@@@std@@QAE@PAPAUSEffect@CPGDef@PS@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
___param0$ = 8						; size = 4
___param1$dead$ = 12					; size = 4
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUSEffect@CPGDef@PS@@@std@@@std@@@std@@QAE@PAPAUSEffect@CPGDef@PS@@PBU_Container_base0@1@@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<PS::CPGDef::SEffect *> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<PS::CPGDef::SEffect *> > >, COMDAT
; _this$ = ecx

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	eax, DWORD PTR ___param0$[esp-4]
	mov	DWORD PTR [ecx], eax
	mov	eax, ecx
	ret	8
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUSEffect@CPGDef@PS@@@std@@@std@@@std@@QAE@PAPAUSEffect@CPGDef@PS@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<PS::CPGDef::SEffect *> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<PS::CPGDef::SEffect *> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USItem@CParticleGroup@PS@@@std@@@std@@@std@@QBE?AV01@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USItem@CParticleGroup@PS@@@std@@@std@@@std@@QBE?AV01@H@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<PS::CParticleGroup::SItem> > >::operator+, COMDAT
; _this$ = ecx

; 119  :         _Ptr += _Off;

	mov	eax, DWORD PTR __Off$[esp-4]
	lea	edx, DWORD PTR [eax*8]
	sub	edx, eax
	mov	eax, DWORD PTR [ecx]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 303  :         _Vector_iterator _Tmp = *this;
; 304  :         _Tmp += _Off; // TRANSITION, LLVM-49342
; 305  :         return _Tmp;
; 306  :     }

	ret	8
??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USItem@CParticleGroup@PS@@@std@@@std@@@std@@QBE?AV01@H@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<PS::CParticleGroup::SItem> > >::operator+
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USItem@CParticleGroup@PS@@@std@@@std@@@std@@QBEAAUSItem@CParticleGroup@PS@@XZ
_TEXT	SEGMENT
??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USItem@CParticleGroup@PS@@@std@@@std@@@std@@QBEAAUSItem@CParticleGroup@PS@@XZ PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<PS::CParticleGroup::SItem> > >::operator*, COMDAT
; _this$ = ecx

; 261  :         return const_cast<reference>(_Mybase::operator*());

	mov	eax, DWORD PTR [ecx]

; 262  :     }

	ret	0
??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USItem@CParticleGroup@PS@@@std@@@std@@@std@@QBEAAUSItem@CParticleGroup@PS@@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<PS::CParticleGroup::SItem> > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@USItem@CParticleGroup@PS@@@std@@@std@@@std@@QBEXABV12@@Z
_TEXT	SEGMENT
__Right$dead$ = 8					; size = 4
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@USItem@CParticleGroup@PS@@@std@@@std@@@std@@QBEXABV12@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<PS::CParticleGroup::SItem> > >::_Compat, COMDAT
; _this$dead$ = ecx

; 182  :         // test for compatible iterator pair
; 183  : #if _ITERATOR_DEBUG_LEVEL == 0
; 184  :         (void) _Right;
; 185  : #else // ^^^ _ITERATOR_DEBUG_LEVEL == 0 ^^^ // vvv _ITERATOR_DEBUG_LEVEL != 0 vvv
; 186  :         _STL_VERIFY(this->_Getcont() == _Right._Getcont(), "vector iterators incompatible");
; 187  : #endif // _ITERATOR_DEBUG_LEVEL == 0
; 188  :     }

	ret	4
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@USItem@CParticleGroup@PS@@@std@@@std@@@std@@QBEXABV12@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<PS::CParticleGroup::SItem> > >::_Compat
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@USItem@CParticleGroup@PS@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@USItem@CParticleGroup@PS@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<PS::CParticleGroup::SItem> > >::operator==, COMDAT
; _this$ = ecx

; 149  :         _Compat(_Right);
; 150  :         return _Ptr == _Right._Ptr;

	mov	eax, DWORD PTR __Right$[esp-4]
	mov	ecx, DWORD PTR [ecx]
	cmp	ecx, DWORD PTR [eax]
	sete	al

; 151  :     }

	ret	4
??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@USItem@CParticleGroup@PS@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<PS::CParticleGroup::SItem> > >::operator==
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@USItem@CParticleGroup@PS@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@USItem@CParticleGroup@PS@@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<PS::CParticleGroup::SItem> > >::operator++, COMDAT
; _this$ = ecx

; 68   : #if _ITERATOR_DEBUG_LEVEL != 0
; 69   :         const auto _Mycont = static_cast<const _Myvec*>(this->_Getcont());
; 70   :         _STL_VERIFY(_Ptr, "can't increment value-initialized vector iterator");
; 71   :         _STL_VERIFY(_Ptr < _Mycont->_Mylast, "can't increment vector iterator past end");
; 72   : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 73   : 
; 74   :         ++_Ptr;

	add	DWORD PTR [ecx], 28			; 0000001cH

; 75   :         return *this;

	mov	eax, ecx

; 76   :     }

	ret	0
??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@USItem@CParticleGroup@PS@@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<PS::CParticleGroup::SItem> > >::operator++
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@USItem@CParticleGroup@PS@@@std@@@std@@@std@@QAE@PAUSItem@CParticleGroup@PS@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Pvector$dead$ = 12					; size = 4
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@USItem@CParticleGroup@PS@@@std@@@std@@@std@@QAE@PAUSItem@CParticleGroup@PS@@PBU_Container_base0@1@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<PS::CParticleGroup::SItem> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<PS::CParticleGroup::SItem> > >, COMDAT
; _this$ = ecx

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	eax, DWORD PTR __Parg$[esp-4]
	mov	DWORD PTR [ecx], eax

; 42   :         this->_Adopt(_Pvector);
; 43   :     }

	mov	eax, ecx
	ret	8
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@USItem@CParticleGroup@PS@@@std@@@std@@@std@@QAE@PAUSItem@CParticleGroup@PS@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<PS::CParticleGroup::SItem> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<PS::CParticleGroup::SItem> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUSEffect@CPGDef@PS@@@std@@@std@@@std@@QBEXABV12@@Z
_TEXT	SEGMENT
__Right$dead$ = 8					; size = 4
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUSEffect@CPGDef@PS@@@std@@@std@@@std@@QBEXABV12@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<PS::CPGDef::SEffect *> > >::_Compat, COMDAT
; _this$dead$ = ecx

; 182  :         // test for compatible iterator pair
; 183  : #if _ITERATOR_DEBUG_LEVEL == 0
; 184  :         (void) _Right;
; 185  : #else // ^^^ _ITERATOR_DEBUG_LEVEL == 0 ^^^ // vvv _ITERATOR_DEBUG_LEVEL != 0 vvv
; 186  :         _STL_VERIFY(this->_Getcont() == _Right._Getcont(), "vector iterators incompatible");
; 187  : #endif // _ITERATOR_DEBUG_LEVEL == 0
; 188  :     }

	ret	4
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUSEffect@CPGDef@PS@@@std@@@std@@@std@@QBEXABV12@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<PS::CPGDef::SEffect *> > >::_Compat
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUSEffect@CPGDef@PS@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUSEffect@CPGDef@PS@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<PS::CPGDef::SEffect *> > >::operator==, COMDAT
; _this$ = ecx

; 149  :         _Compat(_Right);
; 150  :         return _Ptr == _Right._Ptr;

	mov	eax, DWORD PTR __Right$[esp-4]
	mov	ecx, DWORD PTR [ecx]
	cmp	ecx, DWORD PTR [eax]
	sete	al

; 151  :     }

	ret	4
??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUSEffect@CPGDef@PS@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<PS::CPGDef::SEffect *> > >::operator==
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??H?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUSEffect@CPGDef@PS@@@std@@@std@@@std@@QBE?AV01@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??H?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUSEffect@CPGDef@PS@@@std@@@std@@@std@@QBE?AV01@H@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<PS::CPGDef::SEffect *> > >::operator+, COMDAT
; _this$ = ecx

; 119  :         _Ptr += _Off;

	mov	eax, DWORD PTR __Off$[esp-4]
	mov	ecx, DWORD PTR [ecx]
	lea	ecx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 124  :         _Vector_const_iterator _Tmp = *this;
; 125  :         _Tmp += _Off; // TRANSITION, LLVM-49342
; 126  :         return _Tmp;
; 127  :     }

	ret	8
??H?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUSEffect@CPGDef@PS@@@std@@@std@@@std@@QBE?AV01@H@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<PS::CPGDef::SEffect *> > >::operator+
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUSEffect@CPGDef@PS@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUSEffect@CPGDef@PS@@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<PS::CPGDef::SEffect *> > >::operator++, COMDAT
; _this$ = ecx

; 68   : #if _ITERATOR_DEBUG_LEVEL != 0
; 69   :         const auto _Mycont = static_cast<const _Myvec*>(this->_Getcont());
; 70   :         _STL_VERIFY(_Ptr, "can't increment value-initialized vector iterator");
; 71   :         _STL_VERIFY(_Ptr < _Mycont->_Mylast, "can't increment vector iterator past end");
; 72   : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 73   : 
; 74   :         ++_Ptr;

	add	DWORD PTR [ecx], 4

; 75   :         return *this;

	mov	eax, ecx

; 76   :     }

	ret	0
??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUSEffect@CPGDef@PS@@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<PS::CPGDef::SEffect *> > >::operator++
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUSEffect@CPGDef@PS@@@std@@@std@@@std@@QAE@PAPAUSEffect@CPGDef@PS@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Pvector$dead$ = 12					; size = 4
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUSEffect@CPGDef@PS@@@std@@@std@@@std@@QAE@PAPAUSEffect@CPGDef@PS@@PBU_Container_base0@1@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<PS::CPGDef::SEffect *> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<PS::CPGDef::SEffect *> > >, COMDAT
; _this$ = ecx

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	eax, DWORD PTR __Parg$[esp-4]
	mov	DWORD PTR [ecx], eax

; 42   :         this->_Adopt(_Pvector);
; 43   :     }

	mov	eax, ecx
	ret	8
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUSEffect@CPGDef@PS@@@std@@@std@@@std@@QAE@PAPAUSEffect@CPGDef@PS@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<PS::CPGDef::SEffect *> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<PS::CPGDef::SEffect *> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVIRender_Visual@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVIRender_Visual@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<IRender_Visual *> > >::operator==, COMDAT
; _this$ = ecx

; 149  :         _Compat(_Right);
; 150  :         return _Ptr == _Right._Ptr;

	mov	eax, DWORD PTR __Right$[esp-4]
	mov	ecx, DWORD PTR [ecx]
	cmp	ecx, DWORD PTR [eax]
	sete	al

; 151  :     }

	ret	4
??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVIRender_Visual@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<IRender_Visual *> > >::operator==
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVIRender_Visual@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVIRender_Visual@@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<IRender_Visual *> > >::operator++, COMDAT
; _this$ = ecx

; 68   : #if _ITERATOR_DEBUG_LEVEL != 0
; 69   :         const auto _Mycont = static_cast<const _Myvec*>(this->_Getcont());
; 70   :         _STL_VERIFY(_Ptr, "can't increment value-initialized vector iterator");
; 71   :         _STL_VERIFY(_Ptr < _Mycont->_Mylast, "can't increment vector iterator past end");
; 72   : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 73   : 
; 74   :         ++_Ptr;

	add	DWORD PTR [ecx], 4

; 75   :         return *this;

	mov	eax, ecx

; 76   :     }

	ret	0
??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVIRender_Visual@@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<IRender_Visual *> > >::operator++
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?clear_and_free@?$xr_vector@USItem@CParticleGroup@PS@@V?$xalloc@USItem@CParticleGroup@PS@@@@@@QAEXXZ
_TEXT	SEGMENT
?clear_and_free@?$xr_vector@USItem@CParticleGroup@PS@@V?$xalloc@USItem@CParticleGroup@PS@@@@@@QAEXXZ PROC ; xr_vector<PS::CParticleGroup::SItem,xalloc<PS::CParticleGroup::SItem> >::clear_and_free, COMDAT
; _this$ = ecx

; 127  : 	void	clear_and_free		()									{ inherited::clear();			}

	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [ecx+4], eax
	ret	0
?clear_and_free@?$xr_vector@USItem@CParticleGroup@PS@@V?$xalloc@USItem@CParticleGroup@PS@@@@@@QAEXXZ ENDP ; xr_vector<PS::CParticleGroup::SItem,xalloc<PS::CParticleGroup::SItem> >::clear_and_free
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Tidy@?$vector@USItem@CParticleGroup@PS@@V?$xalloc@USItem@CParticleGroup@PS@@@@@std@@AAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@USItem@CParticleGroup@PS@@V?$xalloc@USItem@CParticleGroup@PS@@@@@std@@AAEXXZ PROC ; std::vector<PS::CParticleGroup::SItem,xalloc<PS::CParticleGroup::SItem> >::_Tidy, COMDAT
; _this$ = ecx

; 1742 :     _CONSTEXPR20_CONTAINER void _Tidy() noexcept { // free all storage

	push	esi
	mov	esi, ecx

; 1743 :         auto& _My_data    = _Mypair._Myval2;
; 1744 :         pointer& _Myfirst = _My_data._Myfirst;
; 1745 :         pointer& _Mylast  = _My_data._Mylast;
; 1746 :         pointer& _Myend   = _My_data._Myend;
; 1747 : 
; 1748 :         _My_data._Orphan_all();
; 1749 : 
; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN2@Tidy
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+4], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+8], 0
$LN2@Tidy:

; 1757 :         }
; 1758 :     }

	pop	esi
	ret	0
?_Tidy@?$vector@USItem@CParticleGroup@PS@@V?$xalloc@USItem@CParticleGroup@PS@@@@@std@@AAEXXZ ENDP ; std::vector<PS::CParticleGroup::SItem,xalloc<PS::CParticleGroup::SItem> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?size@?$vector@USItem@CParticleGroup@PS@@V?$xalloc@USItem@CParticleGroup@PS@@@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@USItem@CParticleGroup@PS@@V?$xalloc@USItem@CParticleGroup@PS@@@@@std@@QBEIXZ PROC ; std::vector<PS::CParticleGroup::SItem,xalloc<PS::CParticleGroup::SItem> >::size, COMDAT
; _this$ = ecx

; 1535 :         auto& _My_data = _Mypair._Myval2;
; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	eax, DWORD PTR [ecx+4]
	sub	eax, DWORD PTR [ecx]
	sar	eax, 2
	imul	eax, eax, -1227133513

; 1537 :     }

	ret	0
?size@?$vector@USItem@CParticleGroup@PS@@V?$xalloc@USItem@CParticleGroup@PS@@@@@std@@QBEIXZ ENDP ; std::vector<PS::CParticleGroup::SItem,xalloc<PS::CParticleGroup::SItem> >::size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0?$vector@USItem@CParticleGroup@PS@@V?$xalloc@USItem@CParticleGroup@PS@@@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@USItem@CParticleGroup@PS@@V?$xalloc@USItem@CParticleGroup@PS@@@@@std@@QAE@XZ PROC ; std::vector<PS::CParticleGroup::SItem,xalloc<PS::CParticleGroup::SItem> >::vector<PS::CParticleGroup::SItem,xalloc<PS::CParticleGroup::SItem> >, COMDAT
; _this$ = ecx

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx], 0

; 464  :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 465  :     }

	mov	eax, ecx

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0

; 464  :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 465  :     }

	ret	0
??0?$vector@USItem@CParticleGroup@PS@@V?$xalloc@USItem@CParticleGroup@PS@@@@@std@@QAE@XZ ENDP ; std::vector<PS::CParticleGroup::SItem,xalloc<PS::CParticleGroup::SItem> >::vector<PS::CParticleGroup::SItem,xalloc<PS::CParticleGroup::SItem> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?clear_and_free@?$xr_vector@PAUSEffect@CPGDef@PS@@V?$xalloc@PAUSEffect@CPGDef@PS@@@@@@QAEXXZ
_TEXT	SEGMENT
?clear_and_free@?$xr_vector@PAUSEffect@CPGDef@PS@@V?$xalloc@PAUSEffect@CPGDef@PS@@@@@@QAEXXZ PROC ; xr_vector<PS::CPGDef::SEffect *,xalloc<PS::CPGDef::SEffect *> >::clear_and_free, COMDAT
; _this$ = ecx

; 127  : 	void	clear_and_free		()									{ inherited::clear();			}

	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [ecx+4], eax
	ret	0
?clear_and_free@?$xr_vector@PAUSEffect@CPGDef@PS@@V?$xalloc@PAUSEffect@CPGDef@PS@@@@@@QAEXXZ ENDP ; xr_vector<PS::CPGDef::SEffect *,xalloc<PS::CPGDef::SEffect *> >::clear_and_free
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Tidy@?$vector@PAUSEffect@CPGDef@PS@@V?$xalloc@PAUSEffect@CPGDef@PS@@@@@std@@AAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@PAUSEffect@CPGDef@PS@@V?$xalloc@PAUSEffect@CPGDef@PS@@@@@std@@AAEXXZ PROC ; std::vector<PS::CPGDef::SEffect *,xalloc<PS::CPGDef::SEffect *> >::_Tidy, COMDAT
; _this$ = ecx

; 1742 :     _CONSTEXPR20_CONTAINER void _Tidy() noexcept { // free all storage

	push	esi
	mov	esi, ecx

; 1743 :         auto& _My_data    = _Mypair._Myval2;
; 1744 :         pointer& _Myfirst = _My_data._Myfirst;
; 1745 :         pointer& _Mylast  = _My_data._Mylast;
; 1746 :         pointer& _Myend   = _My_data._Myend;
; 1747 : 
; 1748 :         _My_data._Orphan_all();
; 1749 : 
; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN2@Tidy
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+4], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+8], 0
$LN2@Tidy:

; 1757 :         }
; 1758 :     }

	pop	esi
	ret	0
?_Tidy@?$vector@PAUSEffect@CPGDef@PS@@V?$xalloc@PAUSEffect@CPGDef@PS@@@@@std@@AAEXXZ ENDP ; std::vector<PS::CPGDef::SEffect *,xalloc<PS::CPGDef::SEffect *> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?size@?$vector@PAUSEffect@CPGDef@PS@@V?$xalloc@PAUSEffect@CPGDef@PS@@@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@PAUSEffect@CPGDef@PS@@V?$xalloc@PAUSEffect@CPGDef@PS@@@@@std@@QBEIXZ PROC ; std::vector<PS::CPGDef::SEffect *,xalloc<PS::CPGDef::SEffect *> >::size, COMDAT
; _this$ = ecx

; 1535 :         auto& _My_data = _Mypair._Myval2;
; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	eax, DWORD PTR [ecx+4]
	sub	eax, DWORD PTR [ecx]
	sar	eax, 2

; 1537 :     }

	ret	0
?size@?$vector@PAUSEffect@CPGDef@PS@@V?$xalloc@PAUSEffect@CPGDef@PS@@@@@std@@QBEIXZ ENDP ; std::vector<PS::CPGDef::SEffect *,xalloc<PS::CPGDef::SEffect *> >::size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0?$vector@PAUSEffect@CPGDef@PS@@V?$xalloc@PAUSEffect@CPGDef@PS@@@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@PAUSEffect@CPGDef@PS@@V?$xalloc@PAUSEffect@CPGDef@PS@@@@@std@@QAE@XZ PROC ; std::vector<PS::CPGDef::SEffect *,xalloc<PS::CPGDef::SEffect *> >::vector<PS::CPGDef::SEffect *,xalloc<PS::CPGDef::SEffect *> >, COMDAT
; _this$ = ecx

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx], 0

; 464  :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 465  :     }

	mov	eax, ecx

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0

; 464  :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 465  :     }

	ret	0
??0?$vector@PAUSEffect@CPGDef@PS@@V?$xalloc@PAUSEffect@CPGDef@PS@@@@@std@@QAE@XZ ENDP ; std::vector<PS::CPGDef::SEffect *,xalloc<PS::CPGDef::SEffect *> >::vector<PS::CPGDef::SEffect *,xalloc<PS::CPGDef::SEffect *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USItem@CParticleGroup@PS@@@std@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USItem@CParticleGroup@PS@@@std@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<PS::CParticleGroup::SItem> > >::operator+=, COMDAT
; _this$ = ecx

; 119  :         _Ptr += _Off;

	mov	eax, DWORD PTR __Off$[esp-4]
	lea	edx, DWORD PTR [eax*8]
	sub	edx, eax

; 298  :         _Mybase::operator+=(_Off);
; 299  :         return *this;

	mov	eax, ecx

; 119  :         _Ptr += _Off;

	shl	edx, 2
	add	DWORD PTR [ecx], edx

; 300  :     }

	ret	4
??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USItem@CParticleGroup@PS@@@std@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<PS::CParticleGroup::SItem> > >::operator+=
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@USItem@CParticleGroup@PS@@@std@@@std@@@std@@QBEABUSItem@CParticleGroup@PS@@XZ
_TEXT	SEGMENT
??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@USItem@CParticleGroup@PS@@@std@@@std@@@std@@QBEABUSItem@CParticleGroup@PS@@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<PS::CParticleGroup::SItem> > >::operator*, COMDAT
; _this$ = ecx

; 46   : #if _ITERATOR_DEBUG_LEVEL != 0
; 47   :         const auto _Mycont = static_cast<const _Myvec*>(this->_Getcont());
; 48   :         _STL_VERIFY(_Ptr, "can't dereference value-initialized vector iterator");
; 49   :         _STL_VERIFY(
; 50   :             _Mycont->_Myfirst <= _Ptr && _Ptr < _Mycont->_Mylast, "can't dereference out of range vector iterator");
; 51   : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 52   : 
; 53   :         return *_Ptr;

	mov	eax, DWORD PTR [ecx]

; 54   :     }

	ret	0
??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@USItem@CParticleGroup@PS@@@std@@@std@@@std@@QBEABUSItem@CParticleGroup@PS@@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<PS::CParticleGroup::SItem> > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUSEffect@CPGDef@PS@@@std@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUSEffect@CPGDef@PS@@@std@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<PS::CPGDef::SEffect *> > >::operator+=, COMDAT
; _this$ = ecx

; 118  :         _Verify_offset(_Off);
; 119  :         _Ptr += _Off;

	mov	eax, DWORD PTR __Off$[esp-4]
	shl	eax, 2
	add	DWORD PTR [ecx], eax

; 120  :         return *this;

	mov	eax, ecx

; 121  :     }

	ret	4
??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUSEffect@CPGDef@PS@@@std@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<PS::CPGDef::SEffect *> > >::operator+=
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVIRender_Visual@@@std@@@std@@@std@@QBEXABV12@@Z
_TEXT	SEGMENT
__Right$dead$ = 8					; size = 4
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVIRender_Visual@@@std@@@std@@@std@@QBEXABV12@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<IRender_Visual *> > >::_Compat, COMDAT
; _this$dead$ = ecx

; 182  :         // test for compatible iterator pair
; 183  : #if _ITERATOR_DEBUG_LEVEL == 0
; 184  :         (void) _Right;
; 185  : #else // ^^^ _ITERATOR_DEBUG_LEVEL == 0 ^^^ // vvv _ITERATOR_DEBUG_LEVEL != 0 vvv
; 186  :         _STL_VERIFY(this->_Getcont() == _Right._Getcont(), "vector iterators incompatible");
; 187  : #endif // _ITERATOR_DEBUG_LEVEL == 0
; 188  :     }

	ret	4
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVIRender_Visual@@@std@@@std@@@std@@QBEXABV12@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<IRender_Visual *> > >::_Compat
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Getal@?$vector@USItem@CParticleGroup@PS@@V?$xalloc@USItem@CParticleGroup@PS@@@@@std@@AAEAAV?$xalloc@USItem@CParticleGroup@PS@@@@XZ
_TEXT	SEGMENT
?_Getal@?$vector@USItem@CParticleGroup@PS@@V?$xalloc@USItem@CParticleGroup@PS@@@@@std@@AAEAAV?$xalloc@USItem@CParticleGroup@PS@@@@XZ PROC ; std::vector<PS::CParticleGroup::SItem,xalloc<PS::CParticleGroup::SItem> >::_Getal, COMDAT
; _this$ = ecx

; 1805 :         return _Mypair._Get_first();

	mov	eax, ecx

; 1806 :     }

	ret	0
?_Getal@?$vector@USItem@CParticleGroup@PS@@V?$xalloc@USItem@CParticleGroup@PS@@@@@std@@AAEAAV?$xalloc@USItem@CParticleGroup@PS@@@@XZ ENDP ; std::vector<PS::CParticleGroup::SItem,xalloc<PS::CParticleGroup::SItem> >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Destroy@?$vector@USItem@CParticleGroup@PS@@V?$xalloc@USItem@CParticleGroup@PS@@@@@std@@AAEXPAUSItem@CParticleGroup@PS@@0@Z
_TEXT	SEGMENT
__First$dead$ = 8					; size = 4
__Last$dead$ = 12					; size = 4
?_Destroy@?$vector@USItem@CParticleGroup@PS@@V?$xalloc@USItem@CParticleGroup@PS@@@@@std@@AAEXPAUSItem@CParticleGroup@PS@@0@Z PROC ; std::vector<PS::CParticleGroup::SItem,xalloc<PS::CParticleGroup::SItem> >::_Destroy, COMDAT
; _this$dead$ = ecx

; 1666 :         // destroy [_First, _Last) using allocator
; 1667 :         _Destroy_range(_First, _Last, _Getal());
; 1668 :     }

	ret	8
?_Destroy@?$vector@USItem@CParticleGroup@PS@@V?$xalloc@USItem@CParticleGroup@PS@@@@@std@@AAEXPAUSItem@CParticleGroup@PS@@0@Z ENDP ; std::vector<PS::CParticleGroup::SItem,xalloc<PS::CParticleGroup::SItem> >::_Destroy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?clear@?$vector@USItem@CParticleGroup@PS@@V?$xalloc@USItem@CParticleGroup@PS@@@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$vector@USItem@CParticleGroup@PS@@V?$xalloc@USItem@CParticleGroup@PS@@@@@std@@QAEXXZ PROC ; std::vector<PS::CParticleGroup::SItem,xalloc<PS::CParticleGroup::SItem> >::clear, COMDAT
; _this$ = ecx

; 1437 :         auto& _My_data    = _Mypair._Myval2;
; 1438 :         pointer& _Myfirst = _My_data._Myfirst;
; 1439 :         pointer& _Mylast  = _My_data._Mylast;
; 1440 : 
; 1441 :         _My_data._Orphan_all();
; 1442 :         _Destroy(_Myfirst, _Mylast);
; 1443 :         _Mylast = _Myfirst;

	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [ecx+4], eax

; 1444 :     }

	ret	0
?clear@?$vector@USItem@CParticleGroup@PS@@V?$xalloc@USItem@CParticleGroup@PS@@@@@std@@QAEXXZ ENDP ; std::vector<PS::CParticleGroup::SItem,xalloc<PS::CParticleGroup::SItem> >::clear
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?deallocate@?$xalloc@USItem@CParticleGroup@PS@@@@QBEXPAUSItem@CParticleGroup@PS@@I@Z
_TEXT	SEGMENT
_p$ = 8							; size = 4
_n$dead$ = 12						; size = 4
?deallocate@?$xalloc@USItem@CParticleGroup@PS@@@@QBEXPAUSItem@CParticleGroup@PS@@I@Z PROC ; xalloc<PS::CParticleGroup::SItem>::deallocate, COMDAT
; _this$dead$ = ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	eax, DWORD PTR _p$[esp-4]
	test	eax, eax
	je	SHORT $LN4@deallocate
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN4@deallocate:
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 82   : 							void					deallocate		(pointer p, size_type n) const			{	xr_free	(p);				}

	ret	8
?deallocate@?$xalloc@USItem@CParticleGroup@PS@@@@QBEXPAUSItem@CParticleGroup@PS@@I@Z ENDP ; xalloc<PS::CParticleGroup::SItem>::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Getal@?$vector@PAUSEffect@CPGDef@PS@@V?$xalloc@PAUSEffect@CPGDef@PS@@@@@std@@AAEAAV?$xalloc@PAUSEffect@CPGDef@PS@@@@XZ
_TEXT	SEGMENT
?_Getal@?$vector@PAUSEffect@CPGDef@PS@@V?$xalloc@PAUSEffect@CPGDef@PS@@@@@std@@AAEAAV?$xalloc@PAUSEffect@CPGDef@PS@@@@XZ PROC ; std::vector<PS::CPGDef::SEffect *,xalloc<PS::CPGDef::SEffect *> >::_Getal, COMDAT
; _this$ = ecx

; 1805 :         return _Mypair._Get_first();

	mov	eax, ecx

; 1806 :     }

	ret	0
?_Getal@?$vector@PAUSEffect@CPGDef@PS@@V?$xalloc@PAUSEffect@CPGDef@PS@@@@@std@@AAEAAV?$xalloc@PAUSEffect@CPGDef@PS@@@@XZ ENDP ; std::vector<PS::CPGDef::SEffect *,xalloc<PS::CPGDef::SEffect *> >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Destroy@?$vector@PAUSEffect@CPGDef@PS@@V?$xalloc@PAUSEffect@CPGDef@PS@@@@@std@@AAEXPAPAUSEffect@CPGDef@PS@@0@Z
_TEXT	SEGMENT
__First$dead$ = 8					; size = 4
__Last$dead$ = 12					; size = 4
?_Destroy@?$vector@PAUSEffect@CPGDef@PS@@V?$xalloc@PAUSEffect@CPGDef@PS@@@@@std@@AAEXPAPAUSEffect@CPGDef@PS@@0@Z PROC ; std::vector<PS::CPGDef::SEffect *,xalloc<PS::CPGDef::SEffect *> >::_Destroy, COMDAT
; _this$dead$ = ecx

; 1666 :         // destroy [_First, _Last) using allocator
; 1667 :         _Destroy_range(_First, _Last, _Getal());
; 1668 :     }

	ret	8
?_Destroy@?$vector@PAUSEffect@CPGDef@PS@@V?$xalloc@PAUSEffect@CPGDef@PS@@@@@std@@AAEXPAPAUSEffect@CPGDef@PS@@0@Z ENDP ; std::vector<PS::CPGDef::SEffect *,xalloc<PS::CPGDef::SEffect *> >::_Destroy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?clear@?$vector@PAUSEffect@CPGDef@PS@@V?$xalloc@PAUSEffect@CPGDef@PS@@@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$vector@PAUSEffect@CPGDef@PS@@V?$xalloc@PAUSEffect@CPGDef@PS@@@@@std@@QAEXXZ PROC ; std::vector<PS::CPGDef::SEffect *,xalloc<PS::CPGDef::SEffect *> >::clear, COMDAT
; _this$ = ecx

; 1437 :         auto& _My_data    = _Mypair._Myval2;
; 1438 :         pointer& _Myfirst = _My_data._Myfirst;
; 1439 :         pointer& _Mylast  = _My_data._Mylast;
; 1440 : 
; 1441 :         _My_data._Orphan_all();
; 1442 :         _Destroy(_Myfirst, _Mylast);
; 1443 :         _Mylast = _Myfirst;

	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [ecx+4], eax

; 1444 :     }

	ret	0
?clear@?$vector@PAUSEffect@CPGDef@PS@@V?$xalloc@PAUSEffect@CPGDef@PS@@@@@std@@QAEXXZ ENDP ; std::vector<PS::CPGDef::SEffect *,xalloc<PS::CPGDef::SEffect *> >::clear
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?deallocate@?$xalloc@PAUSEffect@CPGDef@PS@@@@QBEXPAPAUSEffect@CPGDef@PS@@I@Z
_TEXT	SEGMENT
_p$ = 8							; size = 4
_n$dead$ = 12						; size = 4
?deallocate@?$xalloc@PAUSEffect@CPGDef@PS@@@@QBEXPAPAUSEffect@CPGDef@PS@@I@Z PROC ; xalloc<PS::CPGDef::SEffect *>::deallocate, COMDAT
; _this$dead$ = ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	eax, DWORD PTR _p$[esp-4]
	test	eax, eax
	je	SHORT $LN4@deallocate
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN4@deallocate:
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 82   : 							void					deallocate		(pointer p, size_type n) const			{	xr_free	(p);				}

	ret	8
?deallocate@?$xalloc@PAUSEffect@CPGDef@PS@@@@QBEXPAPAUSEffect@CPGDef@PS@@I@Z ENDP ; xalloc<PS::CPGDef::SEffect *>::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@USItem@CParticleGroup@PS@@@std@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@USItem@CParticleGroup@PS@@@std@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<PS::CParticleGroup::SItem> > >::operator+=, COMDAT
; _this$ = ecx

; 118  :         _Verify_offset(_Off);
; 119  :         _Ptr += _Off;

	mov	eax, DWORD PTR __Off$[esp-4]
	lea	edx, DWORD PTR [eax*8]
	sub	edx, eax

; 120  :         return *this;

	mov	eax, ecx
	shl	edx, 2
	add	DWORD PTR [ecx], edx

; 121  :     }

	ret	4
??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@USItem@CParticleGroup@PS@@@std@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<PS::CParticleGroup::SItem> > >::operator+=
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Verify_offset@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUSEffect@CPGDef@PS@@@std@@@std@@@std@@QBEXH@Z
_TEXT	SEGMENT
__Off$dead$ = 8						; size = 4
?_Verify_offset@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUSEffect@CPGDef@PS@@@std@@@std@@@std@@QBEXH@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<PS::CPGDef::SEffect *> > >::_Verify_offset, COMDAT
; _this$dead$ = ecx

; 102  : #if _ITERATOR_DEBUG_LEVEL == 0
; 103  :         (void) _Off;
; 104  : #else // ^^^ _ITERATOR_DEBUG_LEVEL == 0 ^^^ // vvv _ITERATOR_DEBUG_LEVEL != 0 vvv
; 105  :         const auto _Mycont = static_cast<const _Myvec*>(this->_Getcont());
; 106  :         _STL_VERIFY(_Off == 0 || _Ptr, "cannot seek value-initialized vector iterator");
; 107  :         if (_Off < 0) {
; 108  :             _STL_VERIFY(_Off >= _Mycont->_Myfirst - _Ptr, "cannot seek vector iterator before begin");
; 109  :         }
; 110  : 
; 111  :         if (_Off > 0) {
; 112  :             _STL_VERIFY(_Off <= _Mycont->_Mylast - _Ptr, "cannot seek vector iterator after end");
; 113  :         }
; 114  : #endif // _ITERATOR_DEBUG_LEVEL == 0
; 115  :     }

	ret	4
?_Verify_offset@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUSEffect@CPGDef@PS@@@std@@@std@@@std@@QBEXH@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<PS::CPGDef::SEffect *> > >::_Verify_offset
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$xalloc@USItem@CParticleGroup@PS@@@@V?$_Vector_val@U?$_Simple_types@USItem@CParticleGroup@PS@@@std@@@std@@$00@std@@QAEAAV?$xalloc@USItem@CParticleGroup@PS@@@@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@V?$xalloc@USItem@CParticleGroup@PS@@@@V?$_Vector_val@U?$_Simple_types@USItem@CParticleGroup@PS@@@std@@@std@@$00@std@@QAEAAV?$xalloc@USItem@CParticleGroup@PS@@@@XZ PROC ; std::_Compressed_pair<xalloc<PS::CParticleGroup::SItem>,std::_Vector_val<std::_Simple_types<PS::CParticleGroup::SItem> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 1339 :         return *this;

	mov	eax, ecx

; 1340 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$xalloc@USItem@CParticleGroup@PS@@@@V?$_Vector_val@U?$_Simple_types@USItem@CParticleGroup@PS@@@std@@@std@@$00@std@@QAEAAV?$xalloc@USItem@CParticleGroup@PS@@@@XZ ENDP ; std::_Compressed_pair<xalloc<PS::CParticleGroup::SItem>,std::_Vector_val<std::_Simple_types<PS::CParticleGroup::SItem> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$xalloc@PAUSEffect@CPGDef@PS@@@@V?$_Vector_val@U?$_Simple_types@PAUSEffect@CPGDef@PS@@@std@@@std@@$00@std@@QAEAAV?$xalloc@PAUSEffect@CPGDef@PS@@@@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@V?$xalloc@PAUSEffect@CPGDef@PS@@@@V?$_Vector_val@U?$_Simple_types@PAUSEffect@CPGDef@PS@@@std@@@std@@$00@std@@QAEAAV?$xalloc@PAUSEffect@CPGDef@PS@@@@XZ PROC ; std::_Compressed_pair<xalloc<PS::CPGDef::SEffect *>,std::_Vector_val<std::_Simple_types<PS::CPGDef::SEffect *> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 1339 :         return *this;

	mov	eax, ecx

; 1340 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$xalloc@PAUSEffect@CPGDef@PS@@@@V?$_Vector_val@U?$_Simple_types@PAUSEffect@CPGDef@PS@@@std@@@std@@$00@std@@QAEAAV?$xalloc@PAUSEffect@CPGDef@PS@@@@XZ ENDP ; std::_Compressed_pair<xalloc<PS::CPGDef::SEffect *>,std::_Vector_val<std::_Simple_types<PS::CPGDef::SEffect *> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Verify_offset@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@USItem@CParticleGroup@PS@@@std@@@std@@@std@@QBEXH@Z
_TEXT	SEGMENT
__Off$dead$ = 8						; size = 4
?_Verify_offset@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@USItem@CParticleGroup@PS@@@std@@@std@@@std@@QBEXH@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<PS::CParticleGroup::SItem> > >::_Verify_offset, COMDAT
; _this$dead$ = ecx

; 102  : #if _ITERATOR_DEBUG_LEVEL == 0
; 103  :         (void) _Off;
; 104  : #else // ^^^ _ITERATOR_DEBUG_LEVEL == 0 ^^^ // vvv _ITERATOR_DEBUG_LEVEL != 0 vvv
; 105  :         const auto _Mycont = static_cast<const _Myvec*>(this->_Getcont());
; 106  :         _STL_VERIFY(_Off == 0 || _Ptr, "cannot seek value-initialized vector iterator");
; 107  :         if (_Off < 0) {
; 108  :             _STL_VERIFY(_Off >= _Mycont->_Myfirst - _Ptr, "cannot seek vector iterator before begin");
; 109  :         }
; 110  : 
; 111  :         if (_Off > 0) {
; 112  :             _STL_VERIFY(_Off <= _Mycont->_Mylast - _Ptr, "cannot seek vector iterator after end");
; 113  :         }
; 114  : #endif // _ITERATOR_DEBUG_LEVEL == 0
; 115  :     }

	ret	4
?_Verify_offset@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@USItem@CParticleGroup@PS@@@std@@@std@@@std@@QBEXH@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<PS::CParticleGroup::SItem> > >::_Verify_offset
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xrstring.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
;	COMDAT ??$xr_delete@USEffect@CPGDef@PS@@@@YAXAAPAUSEffect@CPGDef@PS@@@Z
_TEXT	SEGMENT
??$xr_delete@USEffect@CPGDef@PS@@@@YAXAAPAUSEffect@CPGDef@PS@@@Z PROC ; xr_delete<PS::CPGDef::SEffect>, COMDAT
; _ptr$ = ecx

; 150  : {

	push	esi
	mov	esi, ecx

; 151  : 	if (ptr) 

	mov	edx, DWORD PTR [esi]
	test	edx, edx
	je	SHORT $LN2@xr_delete
; File I:\Vitalya\mine\NSProjectX\xrCore\xrstring.h

; 50   : 	void				_dec		()								{	if (0==p_) return;	p_->dwReference--; 	if (0==p_->dwReference)	p_=0;						}

	mov	eax, DWORD PTR [edx+16]
	test	eax, eax
	je	SHORT $LN15@xr_delete
	dec	DWORD PTR [eax]
	mov	eax, DWORD PTR [edx+16]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN15@xr_delete
	mov	DWORD PTR [edx+16], 0
$LN15@xr_delete:
	mov	eax, DWORD PTR [edx+12]
	test	eax, eax
	je	SHORT $LN21@xr_delete
	dec	DWORD PTR [eax]
	mov	eax, DWORD PTR [edx+12]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN21@xr_delete
	mov	DWORD PTR [edx+12], 0
$LN21@xr_delete:
	mov	eax, DWORD PTR [edx+8]
	test	eax, eax
	je	SHORT $LN27@xr_delete
	dec	DWORD PTR [eax]
	mov	eax, DWORD PTR [edx+8]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN27@xr_delete
	mov	DWORD PTR [edx+8], 0
$LN27@xr_delete:
	mov	eax, DWORD PTR [edx+4]
	test	eax, eax
	je	SHORT $LN33@xr_delete
	dec	DWORD PTR [eax]
	mov	eax, DWORD PTR [edx+4]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN33@xr_delete
	mov	DWORD PTR [edx+4], 0
$LN33@xr_delete:
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h

; 144  : 		Memory.mem_free	(ptr);

	push	DWORD PTR [esi]
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z

; 152  : 	{
; 153  : 		xr_special_free<is_polymorphic<T>::result,T>()(ptr);
; 154  : 		ptr = nullptr;

	mov	DWORD PTR [esi], 0
$LN2@xr_delete:

; 155  : 	}
; 156  : }

	pop	esi
	ret	0
??$xr_delete@USEffect@CPGDef@PS@@@@YAXAAPAUSEffect@CPGDef@PS@@@Z ENDP ; xr_delete<PS::CPGDef::SEffect>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xrstring.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_flags.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
;	COMDAT ??$xr_new@USEffect@CPGDef@PS@@@@YAPAUSEffect@CPGDef@PS@@XZ
_TEXT	SEGMENT
??$xr_new@USEffect@CPGDef@PS@@@@YAPAUSEffect@CPGDef@PS@@XZ PROC ; xr_new<PS::CPGDef::SEffect>, COMDAT

; 68   : 	T* ptr	= (T*)Memory.mem_alloc(sizeof(T));

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	28					; 0000001cH
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
; File I:\Vitalya\mine\NSProjectX\xrCore\xrstring.h

; 57   : 						shared_str	()								{	p_ = 0;											}

	mov	DWORD PTR [eax+4], 0
	mov	DWORD PTR [eax+8], 0
	mov	DWORD PTR [eax+12], 0
	mov	DWORD PTR [eax+16], 0
; File I:\Vitalya\mine\NSProjectX\xrCore\_flags.h

; 15   :     IC	SelfRef	zero	()											{ flags=T(0);	return *this;	}

	mov	DWORD PTR [eax], 0
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.h

; 33   : 							SEffect				(){m_Flags.zero();/*set(flEnabled)*/m_Time0=0;m_Time1=0;}

	mov	DWORD PTR [eax+20], 0
	mov	DWORD PTR [eax+24], 0
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h

; 70   : }

	ret	0
??$xr_new@USEffect@CPGDef@PS@@@@YAPAUSEffect@CPGDef@PS@@XZ ENDP ; xr_new<PS::CPGDef::SEffect>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$remove_if@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVIRender_Visual@@@std@@@std@@@std@@Uzero_vis_pred@@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVIRender_Visual@@@std@@@std@@@0@V10@V10@Uzero_vis_pred@@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Pred$ = 16						; size = 1
??$remove_if@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVIRender_Visual@@@std@@@std@@@std@@Uzero_vis_pred@@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVIRender_Visual@@@std@@@std@@@0@V10@V10@Uzero_vis_pred@@@Z PROC ; std::remove_if<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<IRender_Visual *> > >,zero_vis_pred>, COMDAT
; ___$ReturnUdt$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility

; 5529 :     auto _UFirst      = _Get_unwrapped(_First);

	mov	eax, DWORD PTR __First$[esp-4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1976 : _NODISCARD _CONSTEXPR20 _FwdIt remove_if(_FwdIt _First, const _FwdIt _Last, _Pr _Pred) {

	push	esi

; 1977 :     // remove each satisfying _Pred
; 1978 :     _Adl_verify_range(_First, _Last);
; 1979 :     auto _UFirst      = _Get_unwrapped(_First);
; 1980 :     const auto _ULast = _Get_unwrapped(_Last);

	mov	esi, DWORD PTR __Last$[esp]
	push	edi
	mov	edi, ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility

; 5531 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	eax, esi
	je	SHORT $LN25@remove_if
$LL10@remove_if:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp

; 271  : 	bool operator()(const IRender_Visual* x){ return x==0; }

	cmp	DWORD PTR [eax], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility

; 5532 :         if (_Pred(*_UFirst)) {

	je	SHORT $LN27@remove_if

; 5531 :     for (; _UFirst != _ULast; ++_UFirst) {

	add	eax, 4
	cmp	eax, esi
	jne	SHORT $LL10@remove_if
$LN27@remove_if:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1983 :     if (_UFirst != _ULast) {

	cmp	eax, esi
	je	SHORT $LN25@remove_if

; 1984 :         while (++_UFirst != _ULast) {

	lea	ecx, DWORD PTR [eax+4]
	cmp	ecx, esi
	je	SHORT $LN25@remove_if
$LL2@remove_if:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp

; 271  : 	bool operator()(const IRender_Visual* x){ return x==0; }

	mov	edx, DWORD PTR [ecx]
	test	edx, edx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1985 :             if (!_Pred(*_UFirst)) {

	je	SHORT $LN5@remove_if

; 1986 :                 *_UNext = _STD move(*_UFirst);

	mov	DWORD PTR [eax], edx

; 1987 :                 ++_UNext;

	add	eax, 4
$LN5@remove_if:

; 1984 :         while (++_UFirst != _ULast) {

	add	ecx, 4
	cmp	ecx, esi
	jne	SHORT $LL2@remove_if
$LN25@remove_if:

; 1988 :             }
; 1989 :         }
; 1990 :     }
; 1991 : 
; 1992 :     _Seek_wrapped(_First, _UNext);
; 1993 :     return _First;
; 1994 : }

	mov	DWORD PTR [edi], eax
	mov	eax, edi
	pop	edi
	pop	esi
	ret	0
??$remove_if@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVIRender_Visual@@@std@@@std@@@std@@Uzero_vis_pred@@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVIRender_Visual@@@std@@@std@@@0@V10@V10@Uzero_vis_pred@@@Z ENDP ; std::remove_if<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<IRender_Visual *> > >,zero_vis_pred>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_Get_unwrapped@ABV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVIRender_Visual@@@std@@@std@@@std@@@std@@YA?A_TABV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVIRender_Visual@@@std@@@std@@@0@@Z
_TEXT	SEGMENT
??$_Get_unwrapped@ABV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVIRender_Visual@@@std@@@std@@@std@@@std@@YA?A_TABV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVIRender_Visual@@@std@@@std@@@0@@Z PROC ; std::_Get_unwrapped<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<IRender_Visual *> > > const &>, COMDAT
; __It$ = ecx

; 1275 :     // unwrap an iterator previously subjected to _Adl_verify_range or otherwise validated
; 1276 :     if constexpr (is_pointer_v<decay_t<_Iter>>) { // special-case pointers and arrays
; 1277 :         return _It + 0;
; 1278 :     } else if constexpr (_Unwrappable_v<_Iter>) {
; 1279 :         return static_cast<_Iter&&>(_It)._Unwrapped();

	mov	eax, DWORD PTR [ecx]

; 1280 :     } else {
; 1281 :         return static_cast<_Iter&&>(_It);
; 1282 :     }
; 1283 : }

	ret	0
??$_Get_unwrapped@ABV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVIRender_Visual@@@std@@@std@@@std@@@std@@YA?A_TABV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVIRender_Visual@@@std@@@std@@@0@@Z ENDP ; std::_Get_unwrapped<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<IRender_Visual *> > > const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef
;	COMDAT ??$addressof@V?$_Vector_val@U?$_Simple_types@USItem@CParticleGroup@PS@@@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@USItem@CParticleGroup@PS@@@std@@@0@AAV10@@Z
_TEXT	SEGMENT
??$addressof@V?$_Vector_val@U?$_Simple_types@USItem@CParticleGroup@PS@@@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@USItem@CParticleGroup@PS@@@std@@@0@AAV10@@Z PROC ; std::addressof<std::_Vector_val<std::_Simple_types<PS::CParticleGroup::SItem> > >, COMDAT
; __Val$ = ecx

; 253  :     return __builtin_addressof(_Val);

	mov	eax, ecx

; 254  : }

	ret	0
??$addressof@V?$_Vector_val@U?$_Simple_types@USItem@CParticleGroup@PS@@@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@USItem@CParticleGroup@PS@@@std@@@0@AAV10@@Z ENDP ; std::addressof<std::_Vector_val<std::_Simple_types<PS::CParticleGroup::SItem> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??$_Resize@U_Value_init_tag@std@@@?$vector@USItem@CParticleGroup@PS@@V?$xalloc@USItem@CParticleGroup@PS@@@@@std@@AAEXIABU_Value_init_tag@1@@Z
_TEXT	SEGMENT
__Newsize$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Resize@U_Value_init_tag@std@@@?$vector@USItem@CParticleGroup@PS@@V?$xalloc@USItem@CParticleGroup@PS@@@@@std@@AAEXIABU_Value_init_tag@1@@Z PROC ; std::vector<PS::CParticleGroup::SItem,xalloc<PS::CParticleGroup::SItem> >::_Resize<std::_Value_init_tag>, COMDAT
; _this$ = ecx

; 1245 :     _CONSTEXPR20_CONTAINER void _Resize(const size_type _Newsize, const _Ty2& _Val) {

	push	esi
	mov	esi, ecx

; 1246 :         // trim or append elements, provide strong guarantee
; 1247 :         auto& _My_data      = _Mypair._Myval2;
; 1248 :         pointer& _Myfirst   = _My_data._Myfirst;
; 1249 :         pointer& _Mylast    = _My_data._Mylast;
; 1250 :         const auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);
; 1251 :         if (_Newsize < _Oldsize) { // trim

	mov	ecx, DWORD PTR __Newsize$[esp]
	push	edi
	mov	eax, DWORD PTR [esi+4]
	mov	edi, DWORD PTR [esi]
	sub	eax, edi
	sar	eax, 2
	imul	edx, eax, -1227133513
	cmp	ecx, edx
	jae	SHORT $LN2@Resize

; 1252 :             const pointer _Newlast = _Myfirst + _Newsize;

	lea	eax, DWORD PTR [ecx*8]
	sub	eax, ecx
	lea	eax, DWORD PTR [edi+eax*4]
	pop	edi

; 1268 :             _Orphan_range(_Oldlast, _Oldlast);
; 1269 :         }
; 1270 : 
; 1271 :         // if _Newsize == _Oldsize, do nothing; avoid invalidating iterators
; 1272 :     }

	mov	DWORD PTR [esi+4], eax
	pop	esi
	ret	8
$LN2@Resize:

; 1253 :             _Orphan_range(_Newlast, _Mylast);
; 1254 :             _Destroy(_Newlast, _Mylast);
; 1255 :             _Mylast = _Newlast;
; 1256 :             return;
; 1257 :         }
; 1258 : 
; 1259 :         if (_Newsize > _Oldsize) { // append

	jbe	SHORT $LN3@Resize

; 1260 :             const auto _Oldcapacity = static_cast<size_type>(_My_data._Myend - _Myfirst);

	mov	eax, DWORD PTR [esi+8]
	sub	eax, edi
	sar	eax, 2
	imul	eax, eax, -1227133513

; 1261 :             if (_Newsize > _Oldcapacity) { // reallocate

	cmp	ecx, eax
	jbe	SHORT $LN4@Resize

; 1262 :                 _Resize_reallocate(_Newsize, _Val);

	push	DWORD PTR __Val$[esp+4]
	push	ecx
	mov	ecx, esi
	call	??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@USItem@CParticleGroup@PS@@V?$xalloc@USItem@CParticleGroup@PS@@@@@std@@AAEXIABU_Value_init_tag@1@@Z ; std::vector<PS::CParticleGroup::SItem,xalloc<PS::CParticleGroup::SItem> >::_Resize_reallocate<std::_Value_init_tag>
	pop	edi

; 1268 :             _Orphan_range(_Oldlast, _Oldlast);
; 1269 :         }
; 1270 : 
; 1271 :         // if _Newsize == _Oldsize, do nothing; avoid invalidating iterators
; 1272 :     }

	pop	esi
	ret	8
$LN4@Resize:

; 1263 :                 return;
; 1264 :             }
; 1265 : 
; 1266 :             const pointer _Oldlast = _Mylast;
; 1267 :             _Mylast                = _Ufill(_Oldlast, _Newsize - _Oldsize, _Val);

	mov	eax, DWORD PTR __Val$[esp+4]
	sub	ecx, edx
	movzx	eax, BYTE PTR [eax]
	push	eax
	push	ecx
	push	DWORD PTR [esi+4]
	call	?_Ufill@?$vector@USItem@CParticleGroup@PS@@V?$xalloc@USItem@CParticleGroup@PS@@@@@std@@AAEPAUSItem@CParticleGroup@PS@@PAU345@IU_Value_init_tag@2@@Z ; std::vector<PS::CParticleGroup::SItem,xalloc<PS::CParticleGroup::SItem> >::_Ufill

; 1268 :             _Orphan_range(_Oldlast, _Oldlast);
; 1269 :         }
; 1270 : 
; 1271 :         // if _Newsize == _Oldsize, do nothing; avoid invalidating iterators
; 1272 :     }

	mov	DWORD PTR [esi+4], eax
$LN3@Resize:
	pop	edi
	pop	esi
	ret	8
??$_Resize@U_Value_init_tag@std@@@?$vector@USItem@CParticleGroup@PS@@V?$xalloc@USItem@CParticleGroup@PS@@@@@std@@AAEXIABU_Value_init_tag@1@@Z ENDP ; std::vector<PS::CParticleGroup::SItem,xalloc<PS::CParticleGroup::SItem> >::_Resize<std::_Value_init_tag>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??$_Emplace_reallocate@PAVIRender_Visual@@@?$vector@PAVIRender_Visual@@V?$xalloc@PAVIRender_Visual@@@@@std@@QAEPAPAVIRender_Visual@@QAPAV2@$$QAPAV2@@Z
_TEXT	SEGMENT
__Newvec$ = -32						; size = 4
tv363 = -28						; size = 4
__Newsize$1$ = -24					; size = 4
tv362 = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Whereptr$ = 8						; size = 4
_<_Val_0>$ = 12						; size = 4
??$_Emplace_reallocate@PAVIRender_Visual@@@?$vector@PAVIRender_Visual@@V?$xalloc@PAVIRender_Visual@@@@@std@@QAEPAPAVIRender_Visual@@QAPAV2@$$QAPAV2@@Z PROC ; std::vector<IRender_Visual *,xalloc<IRender_Visual *> >::_Emplace_reallocate<IRender_Visual *>, COMDAT
; _this$ = ecx

; 752  :     _CONSTEXPR20_CONTAINER pointer _Emplace_reallocate(const pointer _Whereptr, _Valty&&... _Val) {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Emplace_reallocate@PAVIRender_Visual@@@?$vector@PAVIRender_Visual@@V?$xalloc@PAVIRender_Visual@@@@@std@@QAEPAPAVIRender_Visual@@QAPAV2@$$QAPAV2@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 20					; 00000014H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	esi, ecx

; 753  :         // reallocate and insert by perfectly forwarding _Val at _Whereptr
; 754  :         _Alty& _Al        = _Getal();
; 755  :         auto& _My_data    = _Mypair._Myval2;
; 756  :         pointer& _Myfirst = _My_data._Myfirst;
; 757  :         pointer& _Mylast  = _My_data._Mylast;
; 758  : 
; 759  :         _STL_INTERNAL_CHECK(_Mylast == _My_data._Myend); // check that we have no unused capacity
; 760  : 
; 761  :         const auto _Whereoff = static_cast<size_type>(_Whereptr - _Myfirst);

	mov	edx, DWORD PTR [esi]
	mov	ebx, DWORD PTR __Whereptr$[ebp]
	sub	ebx, edx
	sar	ebx, 2

; 762  :         const auto _Oldsize  = static_cast<size_type>(_Mylast - _Myfirst);

	mov	eax, DWORD PTR [esi+4]
	sub	eax, edx
	sar	eax, 2

; 763  : 
; 764  :         if (_Oldsize == max_size()) {

	cmp	eax, 1073741823				; 3fffffffH
	je	$LN32@Emplace_re

; 766  :         }
; 767  : 
; 768  :         const size_type _Newsize     = _Oldsize + 1;

	lea	edi, DWORD PTR [eax+1]
	mov	DWORD PTR __Newsize$1$[ebp], edi

; 1546 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	ecx, DWORD PTR [esi+8]
	sub	ecx, edx
	sar	ecx, 2

; 1675 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	edx, ecx
	shr	edx, 1
	mov	eax, 1073741823				; 3fffffffH
	sub	eax, edx
	cmp	ecx, eax
	jbe	SHORT $LN12@Emplace_re

; 1676 :             return _Max; // geometric growth would overflow

	mov	eax, 1073741823				; 3fffffffH
	jmp	SHORT $LN13@Emplace_re
$LN12@Emplace_re:

; 1677 :         }
; 1678 : 
; 1679 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	lea	eax, DWORD PTR [edx+ecx]

; 1680 : 
; 1681 :         if (_Geometric < _Newsize) {

	cmp	eax, edi
	cmovb	eax, edi
$LN13@Emplace_re:
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	shl	eax, 2
	mov	DWORD PTR tv363[ebp], eax
	push	eax
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 771  :         const pointer _Newvec           = _Al.allocate(_Newcapacity);

	mov	edi, eax
	mov	DWORD PTR __Newvec$[ebp], edi

; 772  :         const pointer _Constructed_last = _Newvec + _Whereoff + 1;
; 773  :         pointer _Constructed_first      = _Constructed_last;
; 774  : 
; 775  :         _TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 776  :         _Alty_traits::construct(_Al, _Unfancy(_Newvec + _Whereoff), _STD forward<_Valty>(_Val)...);

	lea	eax, DWORD PTR [edi+ebx*4]
	mov	DWORD PTR tv362[ebp], eax
	mov	ecx, DWORD PTR _<_Val_0>$[ebp]
	mov	ecx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], ecx

; 777  :         _Constructed_first = _Newvec + _Whereoff;
; 778  : 
; 779  :         if (_Whereptr == _Mylast) { // at back, provide strong guarantee

	mov	ecx, DWORD PTR [esi+4]
	mov	eax, DWORD PTR [esi]
	mov	ebx, DWORD PTR __Whereptr$[ebp]
	push	edi
	cmp	ebx, ecx
	jne	SHORT $LN4@Emplace_re

; 780  :             _Umove_if_noexcept(_Myfirst, _Mylast, _Newvec);

	push	ecx
	push	eax
	call	?_Umove_if_noexcept@?$vector@PAVIRender_Visual@@V?$xalloc@PAVIRender_Visual@@@@@std@@AAEXPAPAVIRender_Visual@@00@Z ; std::vector<IRender_Visual *,xalloc<IRender_Visual *> >::_Umove_if_noexcept

; 781  :         } else { // provide basic guarantee

	jmp	SHORT $LN5@Emplace_re
$LN4@Emplace_re:

; 782  :             _Umove(_Myfirst, _Whereptr, _Newvec);

	push	ebx
	push	eax
	call	?_Umove@?$vector@PAVIRender_Visual@@V?$xalloc@PAVIRender_Visual@@@@@std@@AAEPAPAVIRender_Visual@@PAPAV3@00@Z ; std::vector<IRender_Visual *,xalloc<IRender_Visual *> >::_Umove

; 783  :             _Constructed_first = _Newvec;
; 784  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

	mov	ecx, DWORD PTR tv362[ebp]
	lea	eax, DWORD PTR [ecx+4]
	push	eax
	push	DWORD PTR [esi+4]
	push	ebx
	call	?_Umove@?$vector@PAVIRender_Visual@@V?$xalloc@PAVIRender_Visual@@@@@std@@AAEPAPAVIRender_Visual@@PAPAV3@00@Z ; std::vector<IRender_Visual *,xalloc<IRender_Visual *> >::_Umove
$LN5@Emplace_re:
	mov	DWORD PTR __$EHRec$[ebp+12], -1

; 1732 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN27@Emplace_re
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	push	eax
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN27@Emplace_re:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1737 :         _Myfirst = _Newvec;

	mov	DWORD PTR [esi], edi

; 1738 :         _Mylast  = _Newvec + _Newsize;

	mov	eax, DWORD PTR __Newsize$1$[ebp]
	lea	ecx, DWORD PTR [edi+eax*4]
	mov	DWORD PTR [esi+4], ecx

; 1739 :         _Myend   = _Newvec + _Newcapacity;

	mov	ecx, DWORD PTR tv363[ebp]
	add	ecx, edi
	mov	DWORD PTR [esi+8], ecx

; 790  :         _CATCH_END
; 791  : 
; 792  :         _Change_array(_Newvec, _Newsize, _Newcapacity);
; 793  :         return _Newvec + _Whereoff;

	mov	eax, DWORD PTR tv362[ebp]

; 794  :     }

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
__catch$??$_Emplace_reallocate@PAVIRender_Visual@@@?$vector@PAVIRender_Visual@@V?$xalloc@PAVIRender_Visual@@@@@std@@QAEPAPAVIRender_Visual@@QAPAV2@$$QAPAV2@@Z$0:

; 785  :         }
; 786  :         _CATCH_ALL
; 787  :         _Destroy(_Constructed_first, _Constructed_last);
; 788  :         _Al.deallocate(_Newvec, _Newcapacity);

	push	ecx
	push	DWORD PTR __Newvec$[ebp]
	call	?deallocate@?$xalloc@PAVIRender_Visual@@@@QBEXPAPAVIRender_Visual@@I@Z ; xalloc<IRender_Visual *>::deallocate

; 789  :         _RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$LN32@Emplace_re:

; 765  :             _Xlength();

	call	?_Xlength@?$vector@PAVIRender_Visual@@V?$xalloc@PAVIRender_Visual@@@@@std@@CAXXZ ; std::vector<IRender_Visual *,xalloc<IRender_Visual *> >::_Xlength
$LN30@Emplace_re:
	int	3
	int	3
	int	3
	int	3
	int	3
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Emplace_reallocate@PAVIRender_Visual@@@?$vector@PAVIRender_Visual@@V?$xalloc@PAVIRender_Visual@@@@@std@@QAEPAPAVIRender_Visual@@QAPAV2@$$QAPAV2@@Z:
	npad	1
	npad	1
	mov	eax, OFFSET __ehfuncinfo$??$_Emplace_reallocate@PAVIRender_Visual@@@?$vector@PAVIRender_Visual@@V?$xalloc@PAVIRender_Visual@@@@@std@@QAEPAPAVIRender_Visual@@QAPAV2@$$QAPAV2@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Emplace_reallocate@PAVIRender_Visual@@@?$vector@PAVIRender_Visual@@V?$xalloc@PAVIRender_Visual@@@@@std@@QAEPAPAVIRender_Visual@@QAPAV2@$$QAPAV2@@Z ENDP ; std::vector<IRender_Visual *,xalloc<IRender_Visual *> >::_Emplace_reallocate<IRender_Visual *>
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef
;	COMDAT ??$addressof@$$CBV?$_Vector_val@U?$_Simple_types@PAUSEffect@CPGDef@PS@@@std@@@std@@@std@@YAPBV?$_Vector_val@U?$_Simple_types@PAUSEffect@CPGDef@PS@@@std@@@0@ABV10@@Z
_TEXT	SEGMENT
??$addressof@$$CBV?$_Vector_val@U?$_Simple_types@PAUSEffect@CPGDef@PS@@@std@@@std@@@std@@YAPBV?$_Vector_val@U?$_Simple_types@PAUSEffect@CPGDef@PS@@@std@@@0@ABV10@@Z PROC ; std::addressof<std::_Vector_val<std::_Simple_types<PS::CPGDef::SEffect *> > const >, COMDAT
; __Val$ = ecx

; 253  :     return __builtin_addressof(_Val);

	mov	eax, ecx

; 254  : }

	ret	0
??$addressof@$$CBV?$_Vector_val@U?$_Simple_types@PAUSEffect@CPGDef@PS@@@std@@@std@@@std@@YAPBV?$_Vector_val@U?$_Simple_types@PAUSEffect@CPGDef@PS@@@std@@@0@ABV10@@Z ENDP ; std::addressof<std::_Vector_val<std::_Simple_types<PS::CPGDef::SEffect *> > const >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef
;	COMDAT ??$addressof@V?$_Vector_val@U?$_Simple_types@PAUSEffect@CPGDef@PS@@@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@PAUSEffect@CPGDef@PS@@@std@@@0@AAV10@@Z
_TEXT	SEGMENT
??$addressof@V?$_Vector_val@U?$_Simple_types@PAUSEffect@CPGDef@PS@@@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@PAUSEffect@CPGDef@PS@@@std@@@0@AAV10@@Z PROC ; std::addressof<std::_Vector_val<std::_Simple_types<PS::CPGDef::SEffect *> > >, COMDAT
; __Val$ = ecx

; 253  :     return __builtin_addressof(_Val);

	mov	eax, ecx

; 254  : }

	ret	0
??$addressof@V?$_Vector_val@U?$_Simple_types@PAUSEffect@CPGDef@PS@@@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@PAUSEffect@CPGDef@PS@@@std@@@0@AAV10@@Z ENDP ; std::addressof<std::_Vector_val<std::_Simple_types<PS::CPGDef::SEffect *> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??$_Resize@U_Value_init_tag@std@@@?$vector@PAUSEffect@CPGDef@PS@@V?$xalloc@PAUSEffect@CPGDef@PS@@@@@std@@AAEXIABU_Value_init_tag@1@@Z
_TEXT	SEGMENT
__Newsize$ = 8						; size = 4
__Val$dead$ = 12					; size = 4
??$_Resize@U_Value_init_tag@std@@@?$vector@PAUSEffect@CPGDef@PS@@V?$xalloc@PAUSEffect@CPGDef@PS@@@@@std@@AAEXIABU_Value_init_tag@1@@Z PROC ; std::vector<PS::CPGDef::SEffect *,xalloc<PS::CPGDef::SEffect *> >::_Resize<std::_Value_init_tag>, COMDAT
; _this$ = ecx

; 1245 :     _CONSTEXPR20_CONTAINER void _Resize(const size_type _Newsize, const _Ty2& _Val) {

	push	ebx
	push	esi

; 1246 :         // trim or append elements, provide strong guarantee
; 1247 :         auto& _My_data      = _Mypair._Myval2;
; 1248 :         pointer& _Myfirst   = _My_data._Myfirst;
; 1249 :         pointer& _Mylast    = _My_data._Mylast;
; 1250 :         const auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);
; 1251 :         if (_Newsize < _Oldsize) { // trim

	mov	esi, DWORD PTR __Newsize$[esp+4]
	push	edi
	mov	edi, ecx
	mov	ebx, DWORD PTR [edi+4]
	mov	ecx, ebx
	mov	edx, DWORD PTR [edi]
	sub	ecx, edx
	sar	ecx, 2
	cmp	esi, ecx
	jae	SHORT $LN2@Resize

; 1252 :             const pointer _Newlast = _Myfirst + _Newsize;

	lea	eax, DWORD PTR [edx+esi*4]

; 1272 :     }

	mov	DWORD PTR [edi+4], eax
	pop	edi
	pop	esi
	pop	ebx
	ret	8
$LN2@Resize:

; 1253 :             _Orphan_range(_Newlast, _Mylast);
; 1254 :             _Destroy(_Newlast, _Mylast);
; 1255 :             _Mylast = _Newlast;
; 1256 :             return;
; 1257 :         }
; 1258 : 
; 1259 :         if (_Newsize > _Oldsize) { // append

	jbe	SHORT $LN3@Resize

; 1260 :             const auto _Oldcapacity = static_cast<size_type>(_My_data._Myend - _Myfirst);

	mov	eax, DWORD PTR [edi+8]
	sub	eax, edx
	sar	eax, 2

; 1261 :             if (_Newsize > _Oldcapacity) { // reallocate

	cmp	esi, eax
	jbe	SHORT $LN4@Resize

; 1262 :                 _Resize_reallocate(_Newsize, _Val);

	push	ecx
	push	esi
	mov	ecx, edi
	call	??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@PAUSEffect@CPGDef@PS@@V?$xalloc@PAUSEffect@CPGDef@PS@@@@@std@@AAEXIABU_Value_init_tag@1@@Z ; std::vector<PS::CPGDef::SEffect *,xalloc<PS::CPGDef::SEffect *> >::_Resize_reallocate<std::_Value_init_tag>
	pop	edi

; 1272 :     }

	pop	esi
	pop	ebx
	ret	8
$LN4@Resize:

; 1263 :                 return;
; 1264 :             }
; 1265 : 
; 1266 :             const pointer _Oldlast = _Mylast;
; 1267 :             _Mylast                = _Ufill(_Oldlast, _Newsize - _Oldsize, _Val);

	sub	esi, ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1807 :             _Zero_range(_PFirst, _PFirst + _Count);

	shl	esi, 2

; 1792 :     _CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

	push	esi
	push	0
	push	ebx
	call	_memset

; 1808 :             return _First + _Count;

	lea	eax, DWORD PTR [esi+ebx]

; 1792 :     _CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

	add	esp, 12					; 0000000cH
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1272 :     }

	mov	DWORD PTR [edi+4], eax
$LN3@Resize:
	pop	edi
	pop	esi
	pop	ebx
	ret	8
??$_Resize@U_Value_init_tag@std@@@?$vector@PAUSEffect@CPGDef@PS@@V?$xalloc@PAUSEffect@CPGDef@PS@@@@@std@@AAEXIABU_Value_init_tag@1@@Z ENDP ; std::vector<PS::CPGDef::SEffect *,xalloc<PS::CPGDef::SEffect *> >::_Resize<std::_Value_init_tag>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$?0$$V@?$_Compressed_pair@V?$xalloc@USItem@CParticleGroup@PS@@@@V?$_Vector_val@U?$_Simple_types@USItem@CParticleGroup@PS@@@std@@@std@@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$?0$$V@?$_Compressed_pair@V?$xalloc@USItem@CParticleGroup@PS@@@@V?$_Vector_val@U?$_Simple_types@USItem@CParticleGroup@PS@@@std@@@std@@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<xalloc<PS::CParticleGroup::SItem>,std::_Vector_val<std::_Simple_types<PS::CParticleGroup::SItem> >,1>::_Compressed_pair<xalloc<PS::CParticleGroup::SItem>,std::_Vector_val<std::_Simple_types<PS::CParticleGroup::SItem> >,1><>, COMDAT
; _this$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1331 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	eax, ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1331 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	ret	4
??$?0$$V@?$_Compressed_pair@V?$xalloc@USItem@CParticleGroup@PS@@@@V?$_Vector_val@U?$_Simple_types@USItem@CParticleGroup@PS@@@std@@@std@@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<xalloc<PS::CParticleGroup::SItem>,std::_Vector_val<std::_Simple_types<PS::CParticleGroup::SItem> >,1>::_Compressed_pair<xalloc<PS::CParticleGroup::SItem>,std::_Vector_val<std::_Simple_types<PS::CParticleGroup::SItem> >,1><>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$?0$$V@?$_Compressed_pair@V?$xalloc@PAUSEffect@CPGDef@PS@@@@V?$_Vector_val@U?$_Simple_types@PAUSEffect@CPGDef@PS@@@std@@@std@@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$?0$$V@?$_Compressed_pair@V?$xalloc@PAUSEffect@CPGDef@PS@@@@V?$_Vector_val@U?$_Simple_types@PAUSEffect@CPGDef@PS@@@std@@@std@@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<xalloc<PS::CPGDef::SEffect *>,std::_Vector_val<std::_Simple_types<PS::CPGDef::SEffect *> >,1>::_Compressed_pair<xalloc<PS::CPGDef::SEffect *>,std::_Vector_val<std::_Simple_types<PS::CPGDef::SEffect *> >,1><>, COMDAT
; _this$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1331 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	eax, ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1331 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	ret	4
??$?0$$V@?$_Compressed_pair@V?$xalloc@PAUSEffect@CPGDef@PS@@@@V?$_Vector_val@U?$_Simple_types@PAUSEffect@CPGDef@PS@@@std@@@std@@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<xalloc<PS::CPGDef::SEffect *>,std::_Vector_val<std::_Simple_types<PS::CPGDef::SEffect *> >,1>::_Compressed_pair<xalloc<PS::CPGDef::SEffect *>,std::_Vector_val<std::_Simple_types<PS::CPGDef::SEffect *> >,1><>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Destroy_range@V?$xalloc@USItem@CParticleGroup@PS@@@@@std@@YAXPAUSItem@CParticleGroup@PS@@QAU123@AAV?$xalloc@USItem@CParticleGroup@PS@@@@@Z
_TEXT	SEGMENT
__Al$dead$ = 8						; size = 4
??$_Destroy_range@V?$xalloc@USItem@CParticleGroup@PS@@@@@std@@YAXPAUSItem@CParticleGroup@PS@@QAU123@AAV?$xalloc@USItem@CParticleGroup@PS@@@@@Z PROC ; std::_Destroy_range<xalloc<PS::CParticleGroup::SItem> >, COMDAT
; __First$dead$ = ecx
; __Last$dead$ = edx

; 901  :     // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
; 902  :     using _Ty = typename _Alloc::value_type;
; 903  :     if constexpr (!conjunction_v<is_trivially_destructible<_Ty>, _Uses_default_destroy<_Alloc, _Ty*>>) {
; 904  :         for (; _First != _Last; ++_First) {
; 905  :             allocator_traits<_Alloc>::destroy(_Al, _Unfancy(_First));
; 906  :         }
; 907  :     }
; 908  : }

	ret	0
??$_Destroy_range@V?$xalloc@USItem@CParticleGroup@PS@@@@@std@@YAXPAUSItem@CParticleGroup@PS@@QAU123@AAV?$xalloc@USItem@CParticleGroup@PS@@@@@Z ENDP ; std::_Destroy_range<xalloc<PS::CParticleGroup::SItem> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
;	COMDAT ??$xr_free@USItem@CParticleGroup@PS@@@@YAXAAPAUSItem@CParticleGroup@PS@@@Z
_TEXT	SEGMENT
??$xr_free@USItem@CParticleGroup@PS@@@@YAXAAPAUSItem@CParticleGroup@PS@@@Z PROC ; xr_free<PS::CParticleGroup::SItem>, COMDAT
; _P$ = ecx

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	push	esi
	mov	esi, ecx
	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN2@xr_free
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
	mov	DWORD PTR [esi], 0
$LN2@xr_free:
	pop	esi
	ret	0
??$xr_free@USItem@CParticleGroup@PS@@@@YAXAAPAUSItem@CParticleGroup@PS@@@Z ENDP ; xr_free<PS::CParticleGroup::SItem>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Destroy_range@V?$xalloc@PAUSEffect@CPGDef@PS@@@@@std@@YAXPAPAUSEffect@CPGDef@PS@@QAPAU123@AAV?$xalloc@PAUSEffect@CPGDef@PS@@@@@Z
_TEXT	SEGMENT
__Al$dead$ = 8						; size = 4
??$_Destroy_range@V?$xalloc@PAUSEffect@CPGDef@PS@@@@@std@@YAXPAPAUSEffect@CPGDef@PS@@QAPAU123@AAV?$xalloc@PAUSEffect@CPGDef@PS@@@@@Z PROC ; std::_Destroy_range<xalloc<PS::CPGDef::SEffect *> >, COMDAT
; __First$dead$ = ecx
; __Last$dead$ = edx

; 901  :     // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
; 902  :     using _Ty = typename _Alloc::value_type;
; 903  :     if constexpr (!conjunction_v<is_trivially_destructible<_Ty>, _Uses_default_destroy<_Alloc, _Ty*>>) {
; 904  :         for (; _First != _Last; ++_First) {
; 905  :             allocator_traits<_Alloc>::destroy(_Al, _Unfancy(_First));
; 906  :         }
; 907  :     }
; 908  : }

	ret	0
??$_Destroy_range@V?$xalloc@PAUSEffect@CPGDef@PS@@@@@std@@YAXPAPAUSEffect@CPGDef@PS@@QAPAU123@AAV?$xalloc@PAUSEffect@CPGDef@PS@@@@@Z ENDP ; std::_Destroy_range<xalloc<PS::CPGDef::SEffect *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
;	COMDAT ??$xr_free@PAUSEffect@CPGDef@PS@@@@YAXAAPAPAUSEffect@CPGDef@PS@@@Z
_TEXT	SEGMENT
??$xr_free@PAUSEffect@CPGDef@PS@@@@YAXAAPAPAUSEffect@CPGDef@PS@@@Z PROC ; xr_free<PS::CPGDef::SEffect *>, COMDAT
; _P$ = ecx

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	push	esi
	mov	esi, ecx
	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN2@xr_free
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
	mov	DWORD PTR [esi], 0
$LN2@xr_free:
	pop	esi
	ret	0
??$xr_free@PAUSEffect@CPGDef@PS@@@@YAXAAPAPAUSEffect@CPGDef@PS@@@Z ENDP ; xr_free<PS::CPGDef::SEffect *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xrstring.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
;	COMDAT ??R?$xr_special_free@$0A@USEffect@CPGDef@PS@@@@QAEXAAPAUSEffect@CPGDef@PS@@@Z
_TEXT	SEGMENT
_ptr$ = 8						; size = 4
??R?$xr_special_free@$0A@USEffect@CPGDef@PS@@@@QAEXAAPAUSEffect@CPGDef@PS@@@Z PROC ; xr_special_free<0,PS::CPGDef::SEffect>::operator(), COMDAT
; _this$dead$ = ecx

; 143  : 		ptr->~T			();

	mov	edx, DWORD PTR _ptr$[esp-4]
	mov	ecx, DWORD PTR [edx]
; File I:\Vitalya\mine\NSProjectX\xrCore\xrstring.h

; 50   : 	void				_dec		()								{	if (0==p_) return;	p_->dwReference--; 	if (0==p_->dwReference)	p_=0;						}

	mov	eax, DWORD PTR [ecx+16]
	test	eax, eax
	je	SHORT $LN12@operator
	dec	DWORD PTR [eax]
	mov	eax, DWORD PTR [ecx+16]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN12@operator
	mov	DWORD PTR [ecx+16], 0
$LN12@operator:
	mov	eax, DWORD PTR [ecx+12]
	test	eax, eax
	je	SHORT $LN18@operator
	dec	DWORD PTR [eax]
	mov	eax, DWORD PTR [ecx+12]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN18@operator
	mov	DWORD PTR [ecx+12], 0
$LN18@operator:
	mov	eax, DWORD PTR [ecx+8]
	test	eax, eax
	je	SHORT $LN24@operator
	dec	DWORD PTR [eax]
	mov	eax, DWORD PTR [ecx+8]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN24@operator
	mov	DWORD PTR [ecx+8], 0
$LN24@operator:
	mov	eax, DWORD PTR [ecx+4]
	test	eax, eax
	je	SHORT $LN30@operator
	dec	DWORD PTR [eax]
	mov	eax, DWORD PTR [ecx+4]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN30@operator
	mov	DWORD PTR [ecx+4], 0
$LN30@operator:
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h

; 144  : 		Memory.mem_free	(ptr);

	push	DWORD PTR [edx]
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z

; 145  : 	}

	ret	4
??R?$xr_special_free@$0A@USEffect@CPGDef@PS@@@@QAEXAAPAUSEffect@CPGDef@PS@@@Z ENDP ; xr_special_free<0,PS::CPGDef::SEffect>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@USItem@CParticleGroup@PS@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Vector_val@U?$_Simple_types@USItem@CParticleGroup@PS@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<std::_Simple_types<PS::CParticleGroup::SItem> >::_Vector_val<std::_Simple_types<PS::CParticleGroup::SItem> >, COMDAT
; _this$ = ecx

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx], 0
	mov	eax, ecx
	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0
	ret	0
??0?$_Vector_val@U?$_Simple_types@USItem@CParticleGroup@PS@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<std::_Simple_types<PS::CParticleGroup::SItem> >::_Vector_val<std::_Simple_types<PS::CParticleGroup::SItem> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Orphan_range@?$vector@USItem@CParticleGroup@PS@@V?$xalloc@USItem@CParticleGroup@PS@@@@@std@@ABEXPAUSItem@CParticleGroup@PS@@0@Z
_TEXT	SEGMENT
___formal$dead$ = 8					; size = 4
___formal$dead$ = 12					; size = 4
?_Orphan_range@?$vector@USItem@CParticleGroup@PS@@V?$xalloc@USItem@CParticleGroup@PS@@@@@std@@ABEXPAUSItem@CParticleGroup@PS@@0@Z PROC ; std::vector<PS::CParticleGroup::SItem,xalloc<PS::CParticleGroup::SItem> >::_Orphan_range, COMDAT
; _this$dead$ = ecx

; 1801 :     _CONSTEXPR20_CONTAINER void _Orphan_range(pointer, pointer) const {}

	ret	8
?_Orphan_range@?$vector@USItem@CParticleGroup@PS@@V?$xalloc@USItem@CParticleGroup@PS@@@@@std@@ABEXPAUSItem@CParticleGroup@PS@@0@Z ENDP ; std::vector<PS::CParticleGroup::SItem,xalloc<PS::CParticleGroup::SItem> >::_Orphan_range
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Ufill@?$vector@USItem@CParticleGroup@PS@@V?$xalloc@USItem@CParticleGroup@PS@@@@@std@@AAEPAUSItem@CParticleGroup@PS@@PAU345@IU_Value_init_tag@2@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Count$ = 12						; size = 4
___formal$ = 16						; size = 1
?_Ufill@?$vector@USItem@CParticleGroup@PS@@V?$xalloc@USItem@CParticleGroup@PS@@@@@std@@AAEPAUSItem@CParticleGroup@PS@@PAU345@IU_Value_init_tag@2@@Z PROC ; std::vector<PS::CParticleGroup::SItem,xalloc<PS::CParticleGroup::SItem> >::_Ufill, COMDAT
; _this$dead$ = ecx

; 1635 :         return _Uninitialized_value_construct_n(_Dest, _Count, _Getal());

	mov	edx, DWORD PTR __Count$[esp-4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	eax, DWORD PTR __Dest$[esp-4]

; 1813 :     for (; 0 < _Count; --_Count) {

	test	edx, edx
	je	SHORT $LN5@Ufill

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	lea	ecx, DWORD PTR [eax+12]
	push	esi
$LL6@Ufill:

; 570  :             ::new (static_cast<void*>(_Ptr)) _Ty(_STD forward<_Types>(_Args)...);

	xor	esi, esi

; 1621 :         ++_Last;

	lea	ecx, DWORD PTR [ecx+28]

; 570  :             ::new (static_cast<void*>(_Ptr)) _Ty(_STD forward<_Types>(_Args)...);

	mov	DWORD PTR [eax], esi
	mov	DWORD PTR [eax+4], esi
	mov	DWORD PTR [eax+8], esi
	mov	DWORD PTR [eax+12], esi
	mov	DWORD PTR [eax+16], esi
	mov	DWORD PTR [eax+20], esi
	mov	DWORD PTR [eax+24], esi

; 1621 :         ++_Last;

	add	eax, 28					; 0000001cH
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx-36], esi
	mov	DWORD PTR [ecx-32], esi
	mov	DWORD PTR [ecx-28], esi
	mov	DWORD PTR [ecx-24], esi
	mov	DWORD PTR [ecx-20], esi
	mov	DWORD PTR [ecx-16], esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1813 :     for (; 0 < _Count; --_Count) {

	sub	edx, 1
	jne	SHORT $LL6@Ufill
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1635 :         return _Uninitialized_value_construct_n(_Dest, _Count, _Getal());

	pop	esi
$LN5@Ufill:

; 1636 :     }

	ret	12					; 0000000cH
?_Ufill@?$vector@USItem@CParticleGroup@PS@@V?$xalloc@USItem@CParticleGroup@PS@@@@@std@@AAEPAUSItem@CParticleGroup@PS@@PAU345@IU_Value_init_tag@2@@Z ENDP ; std::vector<PS::CParticleGroup::SItem,xalloc<PS::CParticleGroup::SItem> >::_Ufill
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ??0?$xalloc@USItem@CParticleGroup@PS@@@@QAE@XZ
_TEXT	SEGMENT
??0?$xalloc@USItem@CParticleGroup@PS@@@@QAE@XZ PROC	; xalloc<PS::CParticleGroup::SItem>::xalloc<PS::CParticleGroup::SItem>, COMDAT
; _this$ = ecx

; 76   : 													xalloc			()										{	}

	mov	eax, ecx
	ret	0
??0?$xalloc@USItem@CParticleGroup@PS@@@@QAE@XZ ENDP	; xalloc<PS::CParticleGroup::SItem>::xalloc<PS::CParticleGroup::SItem>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@PAUSEffect@CPGDef@PS@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Vector_val@U?$_Simple_types@PAUSEffect@CPGDef@PS@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<std::_Simple_types<PS::CPGDef::SEffect *> >::_Vector_val<std::_Simple_types<PS::CPGDef::SEffect *> >, COMDAT
; _this$ = ecx

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx], 0
	mov	eax, ecx
	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0
	ret	0
??0?$_Vector_val@U?$_Simple_types@PAUSEffect@CPGDef@PS@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<std::_Simple_types<PS::CPGDef::SEffect *> >::_Vector_val<std::_Simple_types<PS::CPGDef::SEffect *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Orphan_range@?$vector@PAUSEffect@CPGDef@PS@@V?$xalloc@PAUSEffect@CPGDef@PS@@@@@std@@ABEXPAPAUSEffect@CPGDef@PS@@0@Z
_TEXT	SEGMENT
___formal$dead$ = 8					; size = 4
___formal$dead$ = 12					; size = 4
?_Orphan_range@?$vector@PAUSEffect@CPGDef@PS@@V?$xalloc@PAUSEffect@CPGDef@PS@@@@@std@@ABEXPAPAUSEffect@CPGDef@PS@@0@Z PROC ; std::vector<PS::CPGDef::SEffect *,xalloc<PS::CPGDef::SEffect *> >::_Orphan_range, COMDAT
; _this$dead$ = ecx

; 1801 :     _CONSTEXPR20_CONTAINER void _Orphan_range(pointer, pointer) const {}

	ret	8
?_Orphan_range@?$vector@PAUSEffect@CPGDef@PS@@V?$xalloc@PAUSEffect@CPGDef@PS@@@@@std@@ABEXPAPAUSEffect@CPGDef@PS@@0@Z ENDP ; std::vector<PS::CPGDef::SEffect *,xalloc<PS::CPGDef::SEffect *> >::_Orphan_range
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Ufill@?$vector@PAUSEffect@CPGDef@PS@@V?$xalloc@PAUSEffect@CPGDef@PS@@@@@std@@AAEPAPAUSEffect@CPGDef@PS@@PAPAU345@IU_Value_init_tag@2@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Count$ = 12						; size = 4
___formal$ = 16						; size = 1
?_Ufill@?$vector@PAUSEffect@CPGDef@PS@@V?$xalloc@PAUSEffect@CPGDef@PS@@@@@std@@AAEPAPAUSEffect@CPGDef@PS@@PAPAU345@IU_Value_init_tag@2@@Z PROC ; std::vector<PS::CPGDef::SEffect *,xalloc<PS::CPGDef::SEffect *> >::_Ufill, COMDAT
; _this$dead$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1807 :             _Zero_range(_PFirst, _PFirst + _Count);

	mov	eax, DWORD PTR __Count$[esp-4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1633 :     _CONSTEXPR20_CONTAINER pointer _Ufill(pointer _Dest, const size_type _Count, _Value_init_tag) {

	push	esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1792 :     _CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

	mov	esi, DWORD PTR __Dest$[esp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1633 :     _CONSTEXPR20_CONTAINER pointer _Ufill(pointer _Dest, const size_type _Count, _Value_init_tag) {

	push	edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1807 :             _Zero_range(_PFirst, _PFirst + _Count);

	lea	edi, DWORD PTR [eax*4]

; 1792 :     _CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

	push	edi
	push	0
	push	esi
	call	_memset
	add	esp, 12					; 0000000cH

; 1808 :             return _First + _Count;

	lea	eax, DWORD PTR [edi+esi]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1635 :         return _Uninitialized_value_construct_n(_Dest, _Count, _Getal());

	pop	edi
	pop	esi

; 1636 :     }

	ret	12					; 0000000cH
?_Ufill@?$vector@PAUSEffect@CPGDef@PS@@V?$xalloc@PAUSEffect@CPGDef@PS@@@@@std@@AAEPAPAUSEffect@CPGDef@PS@@PAPAU345@IU_Value_init_tag@2@@Z ENDP ; std::vector<PS::CPGDef::SEffect *,xalloc<PS::CPGDef::SEffect *> >::_Ufill
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ??0?$xalloc@PAUSEffect@CPGDef@PS@@@@QAE@XZ
_TEXT	SEGMENT
??0?$xalloc@PAUSEffect@CPGDef@PS@@@@QAE@XZ PROC		; xalloc<PS::CPGDef::SEffect *>::xalloc<PS::CPGDef::SEffect *>, COMDAT
; _this$ = ecx

; 76   : 													xalloc			()										{	}

	mov	eax, ecx
	ret	0
??0?$xalloc@PAUSEffect@CPGDef@PS@@@@QAE@XZ ENDP		; xalloc<PS::CPGDef::SEffect *>::xalloc<PS::CPGDef::SEffect *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\xrstring.h
;	COMDAT ??_GSEffect@CPGDef@PS@@QAEPAXI@Z
_TEXT	SEGMENT
___flags$dead$ = 8					; size = 4
??_GSEffect@CPGDef@PS@@QAEPAXI@Z PROC			; PS::CPGDef::SEffect::`scalar deleting destructor', COMDAT
; _this$ = ecx

; 50   : 	void				_dec		()								{	if (0==p_) return;	p_->dwReference--; 	if (0==p_->dwReference)	p_=0;						}

	mov	eax, DWORD PTR [ecx+16]
	test	eax, eax
	je	SHORT $LN10@scalar
	dec	DWORD PTR [eax]
	mov	eax, DWORD PTR [ecx+16]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN10@scalar
	mov	DWORD PTR [ecx+16], 0
$LN10@scalar:
	mov	eax, DWORD PTR [ecx+12]
	test	eax, eax
	je	SHORT $LN16@scalar
	dec	DWORD PTR [eax]
	mov	eax, DWORD PTR [ecx+12]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN16@scalar
	mov	DWORD PTR [ecx+12], 0
$LN16@scalar:
	mov	eax, DWORD PTR [ecx+8]
	test	eax, eax
	je	SHORT $LN22@scalar
	dec	DWORD PTR [eax]
	mov	eax, DWORD PTR [ecx+8]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN22@scalar
	mov	DWORD PTR [ecx+8], 0
$LN22@scalar:
	mov	eax, DWORD PTR [ecx+4]
	test	eax, eax
	je	SHORT $LN31@scalar
	dec	DWORD PTR [eax]
	mov	eax, DWORD PTR [ecx+4]
	cmp	DWORD PTR [eax], 0
	mov	eax, ecx
	jne	SHORT $LN28@scalar
	mov	DWORD PTR [ecx+4], 0
	ret	4
$LN31@scalar:
	mov	eax, ecx
$LN28@scalar:
	ret	4
??_GSEffect@CPGDef@PS@@QAEPAXI@Z ENDP			; PS::CPGDef::SEffect::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\xrstring.h
;	COMDAT ??1SEffect@CPGDef@PS@@QAE@XZ
_TEXT	SEGMENT
??1SEffect@CPGDef@PS@@QAE@XZ PROC			; PS::CPGDef::SEffect::~SEffect, COMDAT
; _this$ = ecx

; 50   : 	void				_dec		()								{	if (0==p_) return;	p_->dwReference--; 	if (0==p_->dwReference)	p_=0;						}

	mov	eax, DWORD PTR [ecx+16]
	test	eax, eax
	je	SHORT $LN7@SEffect
	dec	DWORD PTR [eax]
	mov	eax, DWORD PTR [ecx+16]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN7@SEffect
	mov	DWORD PTR [ecx+16], 0
$LN7@SEffect:
	mov	eax, DWORD PTR [ecx+12]
	test	eax, eax
	je	SHORT $LN13@SEffect
	dec	DWORD PTR [eax]
	mov	eax, DWORD PTR [ecx+12]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN13@SEffect
	mov	DWORD PTR [ecx+12], 0
$LN13@SEffect:
	mov	eax, DWORD PTR [ecx+8]
	test	eax, eax
	je	SHORT $LN19@SEffect
	dec	DWORD PTR [eax]
	mov	eax, DWORD PTR [ecx+8]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN19@SEffect
	mov	DWORD PTR [ecx+8], 0
$LN19@SEffect:
	mov	eax, DWORD PTR [ecx+4]
	test	eax, eax
	je	SHORT $LN25@SEffect
	dec	DWORD PTR [eax]
	mov	eax, DWORD PTR [ecx+4]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN25@SEffect
	mov	DWORD PTR [ecx+4], 0
$LN25@SEffect:
	ret	0
??1SEffect@CPGDef@PS@@QAE@XZ ENDP			; PS::CPGDef::SEffect::~SEffect
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_Pass_fn@Uzero_vis_pred@@$0A@@std@@YA?AUzero_vis_pred@@U1@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 1
??$_Pass_fn@Uzero_vis_pred@@$0A@@std@@YA?AUzero_vis_pred@@U1@@Z PROC ; std::_Pass_fn<zero_vis_pred,0>, COMDAT
; ___$ReturnUdt$ = ecx

; 253  :     return _Val;

	mov	eax, ecx

; 254  : }

	ret	0
??$_Pass_fn@Uzero_vis_pred@@$0A@@std@@YA?AUzero_vis_pred@@U1@@Z ENDP ; std::_Pass_fn<zero_vis_pred,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$find_if@PAPAVIRender_Visual@@Uzero_vis_pred@@@std@@YAPAPAVIRender_Visual@@PAPAV1@QAPAV1@Uzero_vis_pred@@@Z
_TEXT	SEGMENT
__Pred$ = 8						; size = 1
??$find_if@PAPAVIRender_Visual@@Uzero_vis_pred@@@std@@YAPAPAVIRender_Visual@@PAPAV1@QAPAV1@Uzero_vis_pred@@@Z PROC ; std::find_if<IRender_Visual * *,zero_vis_pred>, COMDAT
; __First$ = ecx
; __Last$ = edx

; 5528 :     _Adl_verify_range(_First, _Last);
; 5529 :     auto _UFirst      = _Get_unwrapped(_First);
; 5530 :     const auto _ULast = _Get_unwrapped(_Last);
; 5531 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	ecx, edx
	je	SHORT $LN15@find_if
$LL4@find_if:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp

; 271  : 	bool operator()(const IRender_Visual* x){ return x==0; }

	cmp	DWORD PTR [ecx], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility

; 5532 :         if (_Pred(*_UFirst)) {

	je	SHORT $LN15@find_if

; 5528 :     _Adl_verify_range(_First, _Last);
; 5529 :     auto _UFirst      = _Get_unwrapped(_First);
; 5530 :     const auto _ULast = _Get_unwrapped(_Last);
; 5531 :     for (; _UFirst != _ULast; ++_UFirst) {

	add	ecx, 4
	cmp	ecx, edx
	jne	SHORT $LL4@find_if
$LN15@find_if:

; 5533 :             break;
; 5534 :         }
; 5535 :     }
; 5536 : 
; 5537 :     _Seek_wrapped(_First, _UFirst);
; 5538 :     return _First;
; 5539 : }

	mov	eax, ecx
	ret	0
??$find_if@PAPAVIRender_Visual@@Uzero_vis_pred@@@std@@YAPAPAVIRender_Visual@@PAPAV1@QAPAV1@Uzero_vis_pred@@@Z ENDP ; std::find_if<IRender_Visual * *,zero_vis_pred>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_Get_unwrapped@AAPAPAVIRender_Visual@@@std@@YA?A_TAAPAPAVIRender_Visual@@@Z
_TEXT	SEGMENT
??$_Get_unwrapped@AAPAPAVIRender_Visual@@@std@@YA?A_TAAPAPAVIRender_Visual@@@Z PROC ; std::_Get_unwrapped<IRender_Visual * * &>, COMDAT
; __It$ = ecx

; 1275 :     // unwrap an iterator previously subjected to _Adl_verify_range or otherwise validated
; 1276 :     if constexpr (is_pointer_v<decay_t<_Iter>>) { // special-case pointers and arrays
; 1277 :         return _It + 0;

	mov	eax, DWORD PTR [ecx]

; 1278 :     } else if constexpr (_Unwrappable_v<_Iter>) {
; 1279 :         return static_cast<_Iter&&>(_It)._Unwrapped();
; 1280 :     } else {
; 1281 :         return static_cast<_Iter&&>(_It);
; 1282 :     }
; 1283 : }

	ret	0
??$_Get_unwrapped@AAPAPAVIRender_Visual@@@std@@YA?A_TAAPAPAVIRender_Visual@@@Z ENDP ; std::_Get_unwrapped<IRender_Visual * * &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_Seek_wrapped@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVIRender_Visual@@@std@@@std@@@std@@AAPAPAVIRender_Visual@@@std@@YAXAAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVIRender_Visual@@@std@@@std@@@0@AAPAPAVIRender_Visual@@@Z
_TEXT	SEGMENT
??$_Seek_wrapped@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVIRender_Visual@@@std@@@std@@@std@@AAPAPAVIRender_Visual@@@std@@YAXAAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVIRender_Visual@@@std@@@std@@@0@AAPAPAVIRender_Visual@@@Z PROC ; std::_Seek_wrapped<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<IRender_Visual *> > >,IRender_Visual * * &>, COMDAT
; __It$ = ecx
; __UIt$ = edx

; 1375 :     if constexpr (_Wrapped_seekable_v<_Iter, _UIter>) {
; 1376 :         _It._Seek_to(_STD forward<_UIter>(_UIt));

	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax

; 1377 :     } else {
; 1378 :         _It = _STD forward<_UIter>(_UIt);
; 1379 :     }
; 1380 : }

	ret	0
??$_Seek_wrapped@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVIRender_Visual@@@std@@@std@@@std@@AAPAPAVIRender_Visual@@@std@@YAXAAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVIRender_Visual@@@std@@@std@@@0@AAPAPAVIRender_Visual@@@Z ENDP ; std::_Seek_wrapped<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<IRender_Visual *> > >,IRender_Visual * * &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@USItem@CParticleGroup@PS@@V?$xalloc@USItem@CParticleGroup@PS@@@@@std@@AAEXIABU_Value_init_tag@1@@Z
_TEXT	SEGMENT
__Newvec$ = -24						; size = 4
tv255 = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Oldsize$1$ = 8					; size = 4
__Newsize$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@USItem@CParticleGroup@PS@@V?$xalloc@USItem@CParticleGroup@PS@@@@@std@@AAEXIABU_Value_init_tag@1@@Z PROC ; std::vector<PS::CParticleGroup::SItem,xalloc<PS::CParticleGroup::SItem> >::_Resize_reallocate<std::_Value_init_tag>, COMDAT
; _this$ = ecx

; 1216 :     _CONSTEXPR20_CONTAINER void _Resize_reallocate(const size_type _Newsize, const _Ty2& _Val) {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@USItem@CParticleGroup@PS@@V?$xalloc@USItem@CParticleGroup@PS@@@@@std@@AAEXIABU_Value_init_tag@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 12					; 0000000cH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	esi, ecx

; 1217 :         if (_Newsize > max_size()) {

	mov	edi, DWORD PTR __Newsize$[ebp]
	cmp	edi, 153391689				; 09249249H
	ja	$LN30@Resize_rea

; 1219 :         }
; 1220 : 
; 1221 :         auto& _My_data    = _Mypair._Myval2;
; 1222 :         pointer& _Myfirst = _My_data._Myfirst;
; 1223 :         pointer& _Mylast  = _My_data._Mylast;
; 1224 : 
; 1225 :         const auto _Oldsize          = static_cast<size_type>(_Mylast - _Myfirst);

	mov	eax, DWORD PTR [esi+4]
	sub	eax, DWORD PTR [esi]
	sar	eax, 2
	imul	eax, eax, -1227133513
	mov	DWORD PTR __Oldsize$1$[ebp], eax

; 1546 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	eax, DWORD PTR [esi+8]
	sub	eax, DWORD PTR [esi]
	sar	eax, 2
	imul	edx, eax, -1227133513

; 1675 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	ecx, edx
	shr	ecx, 1
	mov	eax, 153391689				; 09249249H
	sub	eax, ecx
	cmp	edx, eax
	jbe	SHORT $LN10@Resize_rea

; 1676 :             return _Max; // geometric growth would overflow

	mov	eax, 153391689				; 09249249H
	jmp	SHORT $LN11@Resize_rea
$LN10@Resize_rea:

; 1677 :         }
; 1678 : 
; 1679 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	lea	eax, DWORD PTR [ecx+edx]

; 1680 : 
; 1681 :         if (_Geometric < _Newsize) {

	cmp	eax, edi
	cmovb	eax, edi
$LN11@Resize_rea:
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax
	shl	ecx, 2
	mov	DWORD PTR tv255[ebp], ecx
	push	ecx
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1228 :         const pointer _Newvec         = _Getal().allocate(_Newcapacity);

	mov	ebx, eax
	mov	DWORD PTR __Newvec$[ebp], ebx

; 1229 :         const pointer _Appended_first = _Newvec + _Oldsize;

	mov	edx, DWORD PTR __Oldsize$1$[ebp]
	lea	ecx, DWORD PTR [edx*8]
	sub	ecx, edx
	lea	ecx, DWORD PTR [ebx+ecx*4]

; 1230 :         pointer _Appended_last        = _Appended_first;
; 1231 : 
; 1232 :         _TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 1233 :         _Appended_last = _Ufill(_Appended_first, _Newsize - _Oldsize, _Val);

	mov	eax, DWORD PTR __Val$[ebp]
	movzx	eax, BYTE PTR [eax]
	push	eax
	mov	eax, edi
	sub	eax, edx
	push	eax
	push	ecx
	call	?_Ufill@?$vector@USItem@CParticleGroup@PS@@V?$xalloc@USItem@CParticleGroup@PS@@@@@std@@AAEPAUSItem@CParticleGroup@PS@@PAU345@IU_Value_init_tag@2@@Z ; std::vector<PS::CParticleGroup::SItem,xalloc<PS::CParticleGroup::SItem> >::_Ufill

; 1234 :         _Umove_if_noexcept(_Myfirst, _Mylast, _Newvec);

	push	ebx
	push	DWORD PTR [esi+4]
	push	DWORD PTR [esi]
	call	?_Umove_if_noexcept@?$vector@USItem@CParticleGroup@PS@@V?$xalloc@USItem@CParticleGroup@PS@@@@@std@@AAEXPAUSItem@CParticleGroup@PS@@00@Z ; std::vector<PS::CParticleGroup::SItem,xalloc<PS::CParticleGroup::SItem> >::_Umove_if_noexcept
	mov	DWORD PTR __$EHRec$[ebp+12], -1

; 1732 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN25@Resize_rea
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	push	eax
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN25@Resize_rea:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1737 :         _Myfirst = _Newvec;

	mov	DWORD PTR [esi], ebx

; 1738 :         _Mylast  = _Newvec + _Newsize;

	lea	eax, DWORD PTR [edi*8]
	sub	eax, edi
	lea	eax, DWORD PTR [ebx+eax*4]
	mov	DWORD PTR [esi+4], eax

; 1739 :         _Myend   = _Newvec + _Newcapacity;

	mov	eax, DWORD PTR tv255[ebp]
	add	eax, ebx
	mov	DWORD PTR [esi+8], eax

; 1239 :         _CATCH_END
; 1240 : 
; 1241 :         _Change_array(_Newvec, _Newsize, _Newcapacity);
; 1242 :     }

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
__catch$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@USItem@CParticleGroup@PS@@V?$xalloc@USItem@CParticleGroup@PS@@@@@std@@AAEXIABU_Value_init_tag@1@@Z$0:

; 1235 :         _CATCH_ALL
; 1236 :         _Destroy(_Appended_first, _Appended_last);
; 1237 :         _Getal().deallocate(_Newvec, _Newcapacity);

	push	ecx
	push	DWORD PTR __Newvec$[ebp]
	call	?deallocate@?$xalloc@USItem@CParticleGroup@PS@@@@QBEXPAUSItem@CParticleGroup@PS@@I@Z ; xalloc<PS::CParticleGroup::SItem>::deallocate

; 1238 :         _RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$LN30@Resize_rea:

; 1218 :             _Xlength();

	call	?_Xlength@?$vector@USItem@CParticleGroup@PS@@V?$xalloc@USItem@CParticleGroup@PS@@@@@std@@CAXXZ ; std::vector<PS::CParticleGroup::SItem,xalloc<PS::CParticleGroup::SItem> >::_Xlength
$LN28@Resize_rea:
	int	3
	int	3
	int	3
	int	3
	int	3
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@USItem@CParticleGroup@PS@@V?$xalloc@USItem@CParticleGroup@PS@@@@@std@@AAEXIABU_Value_init_tag@1@@Z:
	npad	1
	npad	1
	mov	eax, OFFSET __ehfuncinfo$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@USItem@CParticleGroup@PS@@V?$xalloc@USItem@CParticleGroup@PS@@@@@std@@AAEXIABU_Value_init_tag@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@USItem@CParticleGroup@PS@@V?$xalloc@USItem@CParticleGroup@PS@@@@@std@@AAEXIABU_Value_init_tag@1@@Z ENDP ; std::vector<PS::CParticleGroup::SItem,xalloc<PS::CParticleGroup::SItem> >::_Resize_reallocate<std::_Value_init_tag>
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@PAUSEffect@CPGDef@PS@@V?$xalloc@PAUSEffect@CPGDef@PS@@@@@std@@AAEXIABU_Value_init_tag@1@@Z
_TEXT	SEGMENT
__Backout$2 = -40					; size = 12
__Newvec$ = -28						; size = 4
__UFirst$3 = -24					; size = 4
__Newcapacity$1$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Newsize$ = 8						; size = 4
__Val$dead$ = 12					; size = 4
??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@PAUSEffect@CPGDef@PS@@V?$xalloc@PAUSEffect@CPGDef@PS@@@@@std@@AAEXIABU_Value_init_tag@1@@Z PROC ; std::vector<PS::CPGDef::SEffect *,xalloc<PS::CPGDef::SEffect *> >::_Resize_reallocate<std::_Value_init_tag>, COMDAT
; _this$ = ecx

; 1216 :     _CONSTEXPR20_CONTAINER void _Resize_reallocate(const size_type _Newsize, const _Ty2& _Val) {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@PAUSEffect@CPGDef@PS@@V?$xalloc@PAUSEffect@CPGDef@PS@@@@@std@@AAEXIABU_Value_init_tag@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 28					; 0000001cH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	esi, ecx

; 1217 :         if (_Newsize > max_size()) {

	mov	edx, DWORD PTR __Newsize$[ebp]
	cmp	edx, 1073741823				; 3fffffffH
	ja	$LN66@Resize_rea

; 1219 :         }
; 1220 : 
; 1221 :         auto& _My_data    = _Mypair._Myval2;
; 1222 :         pointer& _Myfirst = _My_data._Myfirst;
; 1223 :         pointer& _Mylast  = _My_data._Mylast;
; 1224 : 
; 1225 :         const auto _Oldsize          = static_cast<size_type>(_Mylast - _Myfirst);

	mov	edi, DWORD PTR [esi+4]
	sub	edi, DWORD PTR [esi]
	sar	edi, 2

; 1546 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	ecx, DWORD PTR [esi+8]
	sub	ecx, DWORD PTR [esi]
	sar	ecx, 2

; 1675 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	ebx, ecx
	shr	ebx, 1
	mov	eax, 1073741823				; 3fffffffH
	sub	eax, ebx
	cmp	ecx, eax
	jbe	SHORT $LN10@Resize_rea

; 1676 :             return _Max; // geometric growth would overflow

	mov	eax, 1073741823				; 3fffffffH
	jmp	SHORT $LN64@Resize_rea
$LN10@Resize_rea:

; 1677 :         }
; 1678 : 
; 1679 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	lea	eax, DWORD PTR [ebx+ecx]

; 1680 : 
; 1681 :         if (_Geometric < _Newsize) {

	cmp	eax, edx
	cmovb	eax, edx
$LN64@Resize_rea:
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	mov	DWORD PTR __Newcapacity$1$[ebp], eax
	shl	eax, 2
	push	eax
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1228 :         const pointer _Newvec         = _Getal().allocate(_Newcapacity);

	mov	ebx, eax
	mov	DWORD PTR __Newvec$[ebp], ebx

; 1229 :         const pointer _Appended_first = _Newvec + _Oldsize;

	lea	ecx, DWORD PTR [ebx+edi*4]

; 1230 :         pointer _Appended_last        = _Appended_first;
; 1231 : 
; 1232 :         _TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 1233 :         _Appended_last = _Ufill(_Appended_first, _Newsize - _Oldsize, _Val);

	mov	eax, DWORD PTR __Newsize$[ebp]
	sub	eax, edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1807 :             _Zero_range(_PFirst, _PFirst + _Count);

	shl	eax, 2

; 1792 :     _CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

	push	eax
	push	0
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1234 :         _Umove_if_noexcept(_Myfirst, _Mylast, _Newvec);

	mov	edi, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1703 :     auto _UFirst      = _Get_unwrapped(_First);

	mov	DWORD PTR __UFirst$3[ebp], ecx

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	DWORD PTR __Backout$2[ebp], ebx
	mov	edx, ebx
	mov	DWORD PTR __Backout$2[ebp+4], edx
	mov	DWORD PTR __Backout$2[ebp+8], esi
	npad	7
$LL43@Resize_rea:

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	ecx, edi
	je	SHORT $LN42@Resize_rea

; 1620 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax

; 1621 :         ++_Last;

	add	edx, 4
	mov	DWORD PTR __Backout$2[ebp+4], edx

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	add	ecx, 4
	mov	DWORD PTR __UFirst$3[ebp], ecx
	jmp	SHORT $LL43@Resize_rea
$LN42@Resize_rea:

; 1625 :         _First = _Last;

	mov	DWORD PTR __Backout$2[ebp], edx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
	mov	DWORD PTR __$EHRec$[ebp+12], -1

; 1732 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN57@Resize_rea
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	push	eax
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN57@Resize_rea:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1737 :         _Myfirst = _Newvec;

	mov	DWORD PTR [esi], ebx

; 1738 :         _Mylast  = _Newvec + _Newsize;

	mov	eax, DWORD PTR __Newsize$[ebp]
	lea	eax, DWORD PTR [ebx+eax*4]
	mov	DWORD PTR [esi+4], eax

; 1739 :         _Myend   = _Newvec + _Newcapacity;

	mov	eax, DWORD PTR __Newcapacity$1$[ebp]
	lea	eax, DWORD PTR [ebx+eax*4]
	mov	DWORD PTR [esi+8], eax

; 1239 :         _CATCH_END
; 1240 : 
; 1241 :         _Change_array(_Newvec, _Newsize, _Newcapacity);
; 1242 :     }

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
__catch$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@PAUSEffect@CPGDef@PS@@V?$xalloc@PAUSEffect@CPGDef@PS@@@@@std@@AAEXIABU_Value_init_tag@1@@Z$0:

; 1235 :         _CATCH_ALL
; 1236 :         _Destroy(_Appended_first, _Appended_last);
; 1237 :         _Getal().deallocate(_Newvec, _Newcapacity);

	push	ecx
	push	DWORD PTR __Newvec$[ebp]
	call	?deallocate@?$xalloc@PAUSEffect@CPGDef@PS@@@@QBEXPAPAUSEffect@CPGDef@PS@@I@Z ; xalloc<PS::CPGDef::SEffect *>::deallocate

; 1238 :         _RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$LN66@Resize_rea:

; 1218 :             _Xlength();

	call	?_Xlength@?$vector@PAUSEffect@CPGDef@PS@@V?$xalloc@PAUSEffect@CPGDef@PS@@@@@std@@CAXXZ ; std::vector<PS::CPGDef::SEffect *,xalloc<PS::CPGDef::SEffect *> >::_Xlength
$LN63@Resize_rea:
	int	3
	int	3
	int	3
	int	3
	int	3
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@PAUSEffect@CPGDef@PS@@V?$xalloc@PAUSEffect@CPGDef@PS@@@@@std@@AAEXIABU_Value_init_tag@1@@Z:
	npad	1
	npad	1
	mov	eax, OFFSET __ehfuncinfo$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@PAUSEffect@CPGDef@PS@@V?$xalloc@PAUSEffect@CPGDef@PS@@@@@std@@AAEXIABU_Value_init_tag@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@PAUSEffect@CPGDef@PS@@V?$xalloc@PAUSEffect@CPGDef@PS@@@@@std@@AAEXIABU_Value_init_tag@1@@Z ENDP ; std::vector<PS::CPGDef::SEffect *,xalloc<PS::CPGDef::SEffect *> >::_Resize_reallocate<std::_Value_init_tag>
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef
;	COMDAT ??$_Unfancy@USItem@CParticleGroup@PS@@@std@@YAPAUSItem@CParticleGroup@PS@@PAU123@@Z
_TEXT	SEGMENT
??$_Unfancy@USItem@CParticleGroup@PS@@@std@@YAPAUSItem@CParticleGroup@PS@@PAU123@@Z PROC ; std::_Unfancy<PS::CParticleGroup::SItem>, COMDAT
; __Ptr$ = ecx

; 266  :     return _Ptr;

	mov	eax, ecx

; 267  : }

	ret	0
??$_Unfancy@USItem@CParticleGroup@PS@@@std@@YAPAUSItem@CParticleGroup@PS@@PAU123@@Z ENDP ; std::_Unfancy<PS::CParticleGroup::SItem>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$destroy@USItem@CParticleGroup@PS@@@?$_Normal_allocator_traits@V?$xalloc@USItem@CParticleGroup@PS@@@@@std@@SAXAAV?$xalloc@USItem@CParticleGroup@PS@@@@PAUSItem@CParticleGroup@PS@@@Z
_TEXT	SEGMENT
??$destroy@USItem@CParticleGroup@PS@@@?$_Normal_allocator_traits@V?$xalloc@USItem@CParticleGroup@PS@@@@@std@@SAXAAV?$xalloc@USItem@CParticleGroup@PS@@@@PAUSItem@CParticleGroup@PS@@@Z PROC ; std::_Normal_allocator_traits<xalloc<PS::CParticleGroup::SItem> >::destroy<PS::CParticleGroup::SItem>, COMDAT
; __Al$dead$ = ecx
; __Ptr$dead$ = edx

; 579  :         if constexpr (_Uses_default_destroy<_Alloc, _Ty*>::value) {
; 580  : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 581  :             _STD destroy_at(_Ptr);
; 582  : #else // __cpp_lib_constexpr_dynamic_alloc
; 583  :             _Ptr->~_Ty();
; 584  : #endif // __cpp_lib_constexpr_dynamic_alloc
; 585  :         } else {
; 586  :             _Al.destroy(_Ptr);
; 587  :         }
; 588  :     }

	ret	0
??$destroy@USItem@CParticleGroup@PS@@@?$_Normal_allocator_traits@V?$xalloc@USItem@CParticleGroup@PS@@@@@std@@SAXAAV?$xalloc@USItem@CParticleGroup@PS@@@@PAUSItem@CParticleGroup@PS@@@Z ENDP ; std::_Normal_allocator_traits<xalloc<PS::CParticleGroup::SItem> >::destroy<PS::CParticleGroup::SItem>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef
;	COMDAT ??$_Unfancy@PAUSEffect@CPGDef@PS@@@std@@YAPAPAUSEffect@CPGDef@PS@@PAPAU123@@Z
_TEXT	SEGMENT
??$_Unfancy@PAUSEffect@CPGDef@PS@@@std@@YAPAPAUSEffect@CPGDef@PS@@PAPAU123@@Z PROC ; std::_Unfancy<PS::CPGDef::SEffect *>, COMDAT
; __Ptr$ = ecx

; 266  :     return _Ptr;

	mov	eax, ecx

; 267  : }

	ret	0
??$_Unfancy@PAUSEffect@CPGDef@PS@@@std@@YAPAPAUSEffect@CPGDef@PS@@PAPAU123@@Z ENDP ; std::_Unfancy<PS::CPGDef::SEffect *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$destroy@PAUSEffect@CPGDef@PS@@@?$_Normal_allocator_traits@V?$xalloc@PAUSEffect@CPGDef@PS@@@@@std@@SAXAAV?$xalloc@PAUSEffect@CPGDef@PS@@@@PAPAUSEffect@CPGDef@PS@@@Z
_TEXT	SEGMENT
??$destroy@PAUSEffect@CPGDef@PS@@@?$_Normal_allocator_traits@V?$xalloc@PAUSEffect@CPGDef@PS@@@@@std@@SAXAAV?$xalloc@PAUSEffect@CPGDef@PS@@@@PAPAUSEffect@CPGDef@PS@@@Z PROC ; std::_Normal_allocator_traits<xalloc<PS::CPGDef::SEffect *> >::destroy<PS::CPGDef::SEffect *>, COMDAT
; __Al$dead$ = ecx
; __Ptr$dead$ = edx

; 579  :         if constexpr (_Uses_default_destroy<_Alloc, _Ty*>::value) {
; 580  : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 581  :             _STD destroy_at(_Ptr);
; 582  : #else // __cpp_lib_constexpr_dynamic_alloc
; 583  :             _Ptr->~_Ty();
; 584  : #endif // __cpp_lib_constexpr_dynamic_alloc
; 585  :         } else {
; 586  :             _Al.destroy(_Ptr);
; 587  :         }
; 588  :     }

	ret	0
??$destroy@PAUSEffect@CPGDef@PS@@@?$_Normal_allocator_traits@V?$xalloc@PAUSEffect@CPGDef@PS@@@@@std@@SAXAAV?$xalloc@PAUSEffect@CPGDef@PS@@@@PAPAUSEffect@CPGDef@PS@@@Z ENDP ; std::_Normal_allocator_traits<xalloc<PS::CPGDef::SEffect *> >::destroy<PS::CPGDef::SEffect *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Uninitialized_value_construct_n@V?$xalloc@USItem@CParticleGroup@PS@@@@@std@@YAPAUSItem@CParticleGroup@PS@@PAU123@IAAV?$xalloc@USItem@CParticleGroup@PS@@@@@Z
_TEXT	SEGMENT
__Al$dead$ = 8						; size = 4
??$_Uninitialized_value_construct_n@V?$xalloc@USItem@CParticleGroup@PS@@@@@std@@YAPAUSItem@CParticleGroup@PS@@PAU123@IAAV?$xalloc@USItem@CParticleGroup@PS@@@@@Z PROC ; std::_Uninitialized_value_construct_n<xalloc<PS::CParticleGroup::SItem> >, COMDAT
; __First$ = ecx
; __Count$ = edx

; 1813 :     for (; 0 < _Count; --_Count) {

	test	edx, edx
	je	SHORT $LN36@Uninitiali
	lea	eax, DWORD PTR [ecx+12]
	push	esi
$LL4@Uninitiali:

; 570  :             ::new (static_cast<void*>(_Ptr)) _Ty(_STD forward<_Types>(_Args)...);

	xor	esi, esi

; 1621 :         ++_Last;

	lea	eax, DWORD PTR [eax+28]

; 570  :             ::new (static_cast<void*>(_Ptr)) _Ty(_STD forward<_Types>(_Args)...);

	mov	DWORD PTR [ecx], esi
	mov	DWORD PTR [ecx+4], esi
	mov	DWORD PTR [ecx+8], esi
	mov	DWORD PTR [ecx+12], esi
	mov	DWORD PTR [ecx+16], esi
	mov	DWORD PTR [ecx+20], esi
	mov	DWORD PTR [ecx+24], esi

; 1621 :         ++_Last;

	add	ecx, 28					; 0000001cH
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [eax-36], esi
	mov	DWORD PTR [eax-32], esi
	mov	DWORD PTR [eax-28], esi
	mov	DWORD PTR [eax-24], esi
	mov	DWORD PTR [eax-20], esi
	mov	DWORD PTR [eax-16], esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1813 :     for (; 0 < _Count; --_Count) {

	sub	edx, 1
	jne	SHORT $LL4@Uninitiali

; 1814 :         _Backout._Emplace_back();
; 1815 :     }
; 1816 : 
; 1817 :     return _Backout._Release();

	pop	esi
$LN36@Uninitiali:

; 1818 : }

	mov	eax, ecx
	ret	0
??$_Uninitialized_value_construct_n@V?$xalloc@USItem@CParticleGroup@PS@@@@@std@@YAPAUSItem@CParticleGroup@PS@@PAU123@IAAV?$xalloc@USItem@CParticleGroup@PS@@@@@Z ENDP ; std::_Uninitialized_value_construct_n<xalloc<PS::CParticleGroup::SItem> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Uninitialized_value_construct_n@V?$xalloc@PAUSEffect@CPGDef@PS@@@@@std@@YAPAPAUSEffect@CPGDef@PS@@PAPAU123@IAAV?$xalloc@PAUSEffect@CPGDef@PS@@@@@Z
_TEXT	SEGMENT
__Al$dead$ = 8						; size = 4
??$_Uninitialized_value_construct_n@V?$xalloc@PAUSEffect@CPGDef@PS@@@@@std@@YAPAPAUSEffect@CPGDef@PS@@PAPAU123@IAAV?$xalloc@PAUSEffect@CPGDef@PS@@@@@Z PROC ; std::_Uninitialized_value_construct_n<xalloc<PS::CPGDef::SEffect *> >, COMDAT
; __First$ = ecx
; __Count$ = edx

; 1798 :     _Alloc_ptr_t<_Alloc> _First, _Alloc_size_t<_Alloc> _Count, _Alloc& _Al) {

	push	esi
	push	edi

; 1799 :     // value-initialize _Count objects to raw _First, using _Al
; 1800 :     using _Ptrty = typename _Alloc::value_type*;
; 1801 :     if constexpr (_Use_memset_value_construct_v<_Ptrty> && _Uses_default_construct<_Alloc, _Ptrty>::value) {
; 1802 : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 1803 :         if (!_STD is_constant_evaluated())
; 1804 : #endif // __cpp_lib_constexpr_dynamic_alloc
; 1805 :         {
; 1806 :             auto _PFirst = _Unfancy(_First);
; 1807 :             _Zero_range(_PFirst, _PFirst + _Count);

	lea	esi, DWORD PTR [edx*4]
	mov	edi, ecx

; 1792 :     _CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

	push	esi
	push	0
	push	edi
	call	_memset
	add	esp, 12					; 0000000cH

; 1808 :             return _First + _Count;

	lea	eax, DWORD PTR [esi+edi]
	pop	edi
	pop	esi

; 1809 :         }
; 1810 :     }
; 1811 : 
; 1812 :     _Uninitialized_backout_al<_Alloc> _Backout{_First, _Al};
; 1813 :     for (; 0 < _Count; --_Count) {
; 1814 :         _Backout._Emplace_back();
; 1815 :     }
; 1816 : 
; 1817 :     return _Backout._Release();
; 1818 : }

	ret	0
??$_Uninitialized_value_construct_n@V?$xalloc@PAUSEffect@CPGDef@PS@@@@@std@@YAPAPAUSEffect@CPGDef@PS@@PAPAU123@IAAV?$xalloc@PAUSEffect@CPGDef@PS@@@@@Z ENDP ; std::_Uninitialized_value_construct_n<xalloc<PS::CPGDef::SEffect *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Release@?$_Uninitialized_backout_al@V?$xalloc@PAUSEffect@CPGDef@PS@@@@@std@@QAEPAPAUSEffect@CPGDef@PS@@XZ
_TEXT	SEGMENT
?_Release@?$_Uninitialized_backout_al@V?$xalloc@PAUSEffect@CPGDef@PS@@@@@std@@QAEPAPAUSEffect@CPGDef@PS@@XZ PROC ; std::_Uninitialized_backout_al<xalloc<PS::CPGDef::SEffect *> >::_Release, COMDAT
; _this$ = ecx

; 1625 :         _First = _Last;

	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [ecx], eax

; 1626 :         return _Last;
; 1627 :     }

	ret	0
?_Release@?$_Uninitialized_backout_al@V?$xalloc@PAUSEffect@CPGDef@PS@@@@@std@@QAEPAPAUSEffect@CPGDef@PS@@XZ ENDP ; std::_Uninitialized_backout_al<xalloc<PS::CPGDef::SEffect *> >::_Release
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??1?$_Uninitialized_backout_al@V?$xalloc@PAUSEffect@CPGDef@PS@@@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Uninitialized_backout_al@V?$xalloc@PAUSEffect@CPGDef@PS@@@@@std@@QAE@XZ PROC ; std::_Uninitialized_backout_al<xalloc<PS::CPGDef::SEffect *> >::~_Uninitialized_backout_al<xalloc<PS::CPGDef::SEffect *> >, COMDAT
; _this$ = ecx

; 1615 :         _Destroy_range(_First, _Last, _Al);
; 1616 :     }

	ret	0
??1?$_Uninitialized_backout_al@V?$xalloc@PAUSEffect@CPGDef@PS@@@@@std@@QAE@XZ ENDP ; std::_Uninitialized_backout_al<xalloc<PS::CPGDef::SEffect *> >::~_Uninitialized_backout_al<xalloc<PS::CPGDef::SEffect *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??0?$_Uninitialized_backout_al@V?$xalloc@PAUSEffect@CPGDef@PS@@@@@std@@QAE@PAPAUSEffect@CPGDef@PS@@AAV?$xalloc@PAUSEffect@CPGDef@PS@@@@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Al_$ = 12						; size = 4
??0?$_Uninitialized_backout_al@V?$xalloc@PAUSEffect@CPGDef@PS@@@@@std@@QAE@PAPAUSEffect@CPGDef@PS@@AAV?$xalloc@PAUSEffect@CPGDef@PS@@@@@Z PROC ; std::_Uninitialized_backout_al<xalloc<PS::CPGDef::SEffect *> >::_Uninitialized_backout_al<xalloc<PS::CPGDef::SEffect *> >, COMDAT
; _this$ = ecx

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	eax, DWORD PTR __Dest$[esp-4]
	mov	DWORD PTR [ecx], eax
	mov	DWORD PTR [ecx+4], eax
	mov	eax, DWORD PTR __Al_$[esp-4]
	mov	DWORD PTR [ecx+8], eax
	mov	eax, ecx
	ret	8
??0?$_Uninitialized_backout_al@V?$xalloc@PAUSEffect@CPGDef@PS@@@@@std@@QAE@PAPAUSEffect@CPGDef@PS@@AAV?$xalloc@PAUSEffect@CPGDef@PS@@@@@Z ENDP ; std::_Uninitialized_backout_al<xalloc<PS::CPGDef::SEffect *> >::_Uninitialized_backout_al<xalloc<PS::CPGDef::SEffect *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Release@?$_Uninitialized_backout_al@V?$xalloc@USItem@CParticleGroup@PS@@@@@std@@QAEPAUSItem@CParticleGroup@PS@@XZ
_TEXT	SEGMENT
?_Release@?$_Uninitialized_backout_al@V?$xalloc@USItem@CParticleGroup@PS@@@@@std@@QAEPAUSItem@CParticleGroup@PS@@XZ PROC ; std::_Uninitialized_backout_al<xalloc<PS::CParticleGroup::SItem> >::_Release, COMDAT
; _this$ = ecx

; 1625 :         _First = _Last;

	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [ecx], eax

; 1626 :         return _Last;
; 1627 :     }

	ret	0
?_Release@?$_Uninitialized_backout_al@V?$xalloc@USItem@CParticleGroup@PS@@@@@std@@QAEPAUSItem@CParticleGroup@PS@@XZ ENDP ; std::_Uninitialized_backout_al<xalloc<PS::CParticleGroup::SItem> >::_Release
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??1?$_Uninitialized_backout_al@V?$xalloc@USItem@CParticleGroup@PS@@@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Uninitialized_backout_al@V?$xalloc@USItem@CParticleGroup@PS@@@@@std@@QAE@XZ PROC ; std::_Uninitialized_backout_al<xalloc<PS::CParticleGroup::SItem> >::~_Uninitialized_backout_al<xalloc<PS::CParticleGroup::SItem> >, COMDAT
; _this$ = ecx

; 1615 :         _Destroy_range(_First, _Last, _Al);
; 1616 :     }

	ret	0
??1?$_Uninitialized_backout_al@V?$xalloc@USItem@CParticleGroup@PS@@@@@std@@QAE@XZ ENDP ; std::_Uninitialized_backout_al<xalloc<PS::CParticleGroup::SItem> >::~_Uninitialized_backout_al<xalloc<PS::CParticleGroup::SItem> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??0?$_Uninitialized_backout_al@V?$xalloc@USItem@CParticleGroup@PS@@@@@std@@QAE@PAUSItem@CParticleGroup@PS@@AAV?$xalloc@USItem@CParticleGroup@PS@@@@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Al_$ = 12						; size = 4
??0?$_Uninitialized_backout_al@V?$xalloc@USItem@CParticleGroup@PS@@@@@std@@QAE@PAUSItem@CParticleGroup@PS@@AAV?$xalloc@USItem@CParticleGroup@PS@@@@@Z PROC ; std::_Uninitialized_backout_al<xalloc<PS::CParticleGroup::SItem> >::_Uninitialized_backout_al<xalloc<PS::CParticleGroup::SItem> >, COMDAT
; _this$ = ecx

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	eax, DWORD PTR __Dest$[esp-4]
	mov	DWORD PTR [ecx], eax
	mov	DWORD PTR [ecx+4], eax
	mov	eax, DWORD PTR __Al_$[esp-4]
	mov	DWORD PTR [ecx+8], eax
	mov	eax, ecx
	ret	8
??0?$_Uninitialized_backout_al@V?$xalloc@USItem@CParticleGroup@PS@@@@@std@@QAE@PAUSItem@CParticleGroup@PS@@AAV?$xalloc@USItem@CParticleGroup@PS@@@@@Z ENDP ; std::_Uninitialized_backout_al<xalloc<PS::CParticleGroup::SItem> >::_Uninitialized_backout_al<xalloc<PS::CParticleGroup::SItem> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Seek_to@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVIRender_Visual@@@std@@@std@@@std@@QAEXPBQAVIRender_Visual@@@Z
_TEXT	SEGMENT
__It$ = 8						; size = 4
?_Seek_to@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVIRender_Visual@@@std@@@std@@@std@@QAEXPBQAVIRender_Visual@@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<IRender_Visual *> > >::_Seek_to, COMDAT
; _this$ = ecx

; 205  :         _Ptr = _Refancy<_Tptr>(const_cast<value_type*>(_It));

	mov	eax, DWORD PTR __It$[esp-4]
	mov	DWORD PTR [ecx], eax

; 206  :     }

	ret	4
?_Seek_to@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVIRender_Visual@@@std@@@std@@@std@@QAEXPBQAVIRender_Visual@@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<IRender_Visual *> > >::_Seek_to
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Xlength@?$vector@USItem@CParticleGroup@PS@@V?$xalloc@USItem@CParticleGroup@PS@@@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@USItem@CParticleGroup@PS@@V?$xalloc@USItem@CParticleGroup@PS@@@@@std@@CAXXZ PROC ; std::vector<PS::CParticleGroup::SItem,xalloc<PS::CParticleGroup::SItem> >::_Xlength, COMDAT

; 1761 :         _Xlength_error("vector too long");

	push	OFFSET ??_C@_0BA@FOIKENOD@vector?5too?5long@
	call	DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN3@Xlength:
	int	3
?_Xlength@?$vector@USItem@CParticleGroup@PS@@V?$xalloc@USItem@CParticleGroup@PS@@@@@std@@CAXXZ ENDP ; std::vector<PS::CParticleGroup::SItem,xalloc<PS::CParticleGroup::SItem> >::_Xlength
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Change_array@?$vector@USItem@CParticleGroup@PS@@V?$xalloc@USItem@CParticleGroup@PS@@@@@std@@AAEXQAUSItem@CParticleGroup@PS@@II@Z
_TEXT	SEGMENT
__Newvec$ = 8						; size = 4
__Newsize$ = 12						; size = 4
__Newcapacity$ = 16					; size = 4
?_Change_array@?$vector@USItem@CParticleGroup@PS@@V?$xalloc@USItem@CParticleGroup@PS@@@@@std@@AAEXQAUSItem@CParticleGroup@PS@@II@Z PROC ; std::vector<PS::CParticleGroup::SItem,xalloc<PS::CParticleGroup::SItem> >::_Change_array, COMDAT
; _this$ = ecx

; 1723 :         const pointer _Newvec, const size_type _Newsize, const size_type _Newcapacity) {

	push	esi
	mov	esi, ecx

; 1724 :         // orphan all iterators, discard old array, acquire new array
; 1725 :         auto& _My_data    = _Mypair._Myval2;
; 1726 :         pointer& _Myfirst = _My_data._Myfirst;
; 1727 :         pointer& _Mylast  = _My_data._Mylast;
; 1728 :         pointer& _Myend   = _My_data._Myend;
; 1729 : 
; 1730 :         _My_data._Orphan_all();
; 1731 : 
; 1732 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN7@Change_arr
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN7@Change_arr:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1738 :         _Mylast  = _Newvec + _Newsize;

	mov	eax, DWORD PTR __Newsize$[esp]
	mov	edx, DWORD PTR __Newvec$[esp]
	mov	DWORD PTR [esi], edx
	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR [esi+4], eax

; 1739 :         _Myend   = _Newvec + _Newcapacity;

	mov	eax, DWORD PTR __Newcapacity$[esp]
	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR [esi+8], eax
	pop	esi

; 1740 :     }

	ret	12					; 0000000cH
?_Change_array@?$vector@USItem@CParticleGroup@PS@@V?$xalloc@USItem@CParticleGroup@PS@@@@@std@@AAEXQAUSItem@CParticleGroup@PS@@II@Z ENDP ; std::vector<PS::CParticleGroup::SItem,xalloc<PS::CParticleGroup::SItem> >::_Change_array
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Calculate_growth@?$vector@USItem@CParticleGroup@PS@@V?$xalloc@USItem@CParticleGroup@PS@@@@@std@@ABEII@Z
_TEXT	SEGMENT
__Newsize$ = 8						; size = 4
?_Calculate_growth@?$vector@USItem@CParticleGroup@PS@@V?$xalloc@USItem@CParticleGroup@PS@@@@@std@@ABEII@Z PROC ; std::vector<PS::CParticleGroup::SItem,xalloc<PS::CParticleGroup::SItem> >::_Calculate_growth, COMDAT
; _this$ = ecx

; 1546 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx]

; 1671 :         // given _Oldcapacity and _Newsize, calculate geometric growth
; 1672 :         const size_type _Oldcapacity = capacity();
; 1673 :         const auto _Max              = max_size();
; 1674 : 
; 1675 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	ecx, 153391689				; 09249249H

; 1546 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	sar	eax, 2

; 1670 :     _CONSTEXPR20_CONTAINER size_type _Calculate_growth(const size_type _Newsize) const {

	push	esi

; 1546 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	imul	esi, eax, -1227133513

; 1671 :         // given _Oldcapacity and _Newsize, calculate geometric growth
; 1672 :         const size_type _Oldcapacity = capacity();
; 1673 :         const auto _Max              = max_size();
; 1674 : 
; 1675 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	edx, esi
	shr	edx, 1
	sub	ecx, edx
	cmp	esi, ecx
	jbe	SHORT $LN2@Calculate_

; 1676 :             return _Max; // geometric growth would overflow

	mov	eax, 153391689				; 09249249H
	pop	esi

; 1682 :             return _Newsize; // geometric growth would be insufficient
; 1683 :         }
; 1684 : 
; 1685 :         return _Geometric; // geometric growth is sufficient
; 1686 :     }

	ret	4
$LN2@Calculate_:

; 1677 :         }
; 1678 : 
; 1679 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	lea	eax, DWORD PTR [edx+esi]

; 1680 : 
; 1681 :         if (_Geometric < _Newsize) {

	cmp	eax, DWORD PTR __Newsize$[esp]
	pop	esi
	cmovb	eax, DWORD PTR __Newsize$[esp-4]

; 1682 :             return _Newsize; // geometric growth would be insufficient
; 1683 :         }
; 1684 : 
; 1685 :         return _Geometric; // geometric growth is sufficient
; 1686 :     }

	ret	4
?_Calculate_growth@?$vector@USItem@CParticleGroup@PS@@V?$xalloc@USItem@CParticleGroup@PS@@@@@std@@ABEII@Z ENDP ; std::vector<PS::CParticleGroup::SItem,xalloc<PS::CParticleGroup::SItem> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Umove_if_noexcept@?$vector@USItem@CParticleGroup@PS@@V?$xalloc@USItem@CParticleGroup@PS@@@@@std@@AAEXPAUSItem@CParticleGroup@PS@@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
?_Umove_if_noexcept@?$vector@USItem@CParticleGroup@PS@@V?$xalloc@USItem@CParticleGroup@PS@@@@@std@@AAEXPAUSItem@CParticleGroup@PS@@00@Z PROC ; std::vector<PS::CParticleGroup::SItem,xalloc<PS::CParticleGroup::SItem> >::_Umove_if_noexcept, COMDAT
; _this$dead$ = ecx

; 1659 :     _CONSTEXPR20_CONTAINER void _Umove_if_noexcept(pointer _First, pointer _Last, pointer _Dest) {

	push	ebx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	mov	ebx, DWORD PTR __Last$[esp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1659 :     _CONSTEXPR20_CONTAINER void _Umove_if_noexcept(pointer _First, pointer _Last, pointer _Dest) {

	push	esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1703 :     auto _UFirst      = _Get_unwrapped(_First);

	mov	esi, DWORD PTR __First$[esp+4]

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	esi, ebx
	je	SHORT $LN7@Umove_if_n

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	eax, DWORD PTR __Dest$[esp+4]
	push	ebp
	mov	ebp, esi
	push	edi
	lea	edi, DWORD PTR [eax+16]
	sub	ebp, eax
	npad	5
$LL8@Umove_if_n:
	mov	eax, DWORD PTR [esi]
	lea	ecx, DWORD PTR [edi-12]
	mov	DWORD PTR [edi-16], eax
	lea	eax, DWORD PTR [esi+4]
	push	eax
	call	??0?$xr_vector@PAVIRender_Visual@@V?$xalloc@PAVIRender_Visual@@@@@@QAE@ABV0@@Z
	lea	eax, DWORD PTR [edi+ebp]
	mov	ecx, edi
	push	eax
	call	??0?$xr_vector@PAVIRender_Visual@@V?$xalloc@PAVIRender_Visual@@@@@@QAE@ABV0@@Z

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	add	esi, 28					; 0000001cH
	add	edi, 28					; 0000001cH
	cmp	esi, ebx
	jne	SHORT $LL8@Umove_if_n
	pop	edi
	pop	ebp
$LN7@Umove_if_n:
	pop	esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1663 :     }

	pop	ebx
	ret	12					; 0000000cH
?_Umove_if_noexcept@?$vector@USItem@CParticleGroup@PS@@V?$xalloc@USItem@CParticleGroup@PS@@@@@std@@AAEXPAUSItem@CParticleGroup@PS@@00@Z ENDP ; std::vector<PS::CParticleGroup::SItem,xalloc<PS::CParticleGroup::SItem> >::_Umove_if_noexcept
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?max_size@?$vector@USItem@CParticleGroup@PS@@V?$xalloc@USItem@CParticleGroup@PS@@@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@USItem@CParticleGroup@PS@@V?$xalloc@USItem@CParticleGroup@PS@@@@@std@@QBEIXZ PROC ; std::vector<PS::CParticleGroup::SItem,xalloc<PS::CParticleGroup::SItem> >::max_size, COMDAT
; _this$dead$ = ecx

; 1540 :         return (_STD min)(

	mov	eax, 153391689				; 09249249H

; 1541 :             static_cast<size_type>((numeric_limits<difference_type>::max)()), _Alty_traits::max_size(_Getal()));
; 1542 :     }

	ret	0
?max_size@?$vector@USItem@CParticleGroup@PS@@V?$xalloc@USItem@CParticleGroup@PS@@@@@std@@QBEIXZ ENDP ; std::vector<PS::CParticleGroup::SItem,xalloc<PS::CParticleGroup::SItem> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?destroy@?$xalloc@USItem@CParticleGroup@PS@@@@QAEXPAUSItem@CParticleGroup@PS@@@Z
_TEXT	SEGMENT
_p$dead$ = 8						; size = 4
?destroy@?$xalloc@USItem@CParticleGroup@PS@@@@QAEXPAUSItem@CParticleGroup@PS@@@Z PROC ; xalloc<PS::CParticleGroup::SItem>::destroy, COMDAT
; _this$dead$ = ecx

; 85   : 							void					destroy			(pointer p)								{	std::_Destroy_in_place(p);			}

	ret	4
?destroy@?$xalloc@USItem@CParticleGroup@PS@@@@QAEXPAUSItem@CParticleGroup@PS@@@Z ENDP ; xalloc<PS::CParticleGroup::SItem>::destroy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?allocate@?$xalloc@USItem@CParticleGroup@PS@@@@QBEPAUSItem@CParticleGroup@PS@@IPBX@Z
_TEXT	SEGMENT
_n$ = 8							; size = 4
_p$dead$ = 12						; size = 4
?allocate@?$xalloc@USItem@CParticleGroup@PS@@@@QBEPAUSItem@CParticleGroup@PS@@IPBX@Z PROC ; xalloc<PS::CParticleGroup::SItem>::allocate, COMDAT
; _this$dead$ = ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	mov	eax, DWORD PTR _n$[esp-4]
	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax
	shl	ecx, 2
	push	ecx
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 80   : 							pointer					allocate		(size_type n, const void* p=0) const	{	return xr_alloc<T>((u32)n);	}

	ret	8
?allocate@?$xalloc@USItem@CParticleGroup@PS@@@@QBEPAUSItem@CParticleGroup@PS@@IPBX@Z ENDP ; xalloc<PS::CParticleGroup::SItem>::allocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Xlength@?$vector@PAUSEffect@CPGDef@PS@@V?$xalloc@PAUSEffect@CPGDef@PS@@@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@PAUSEffect@CPGDef@PS@@V?$xalloc@PAUSEffect@CPGDef@PS@@@@@std@@CAXXZ PROC ; std::vector<PS::CPGDef::SEffect *,xalloc<PS::CPGDef::SEffect *> >::_Xlength, COMDAT

; 1761 :         _Xlength_error("vector too long");

	push	OFFSET ??_C@_0BA@FOIKENOD@vector?5too?5long@
	call	DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN3@Xlength:
	int	3
?_Xlength@?$vector@PAUSEffect@CPGDef@PS@@V?$xalloc@PAUSEffect@CPGDef@PS@@@@@std@@CAXXZ ENDP ; std::vector<PS::CPGDef::SEffect *,xalloc<PS::CPGDef::SEffect *> >::_Xlength
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Change_array@?$vector@PAUSEffect@CPGDef@PS@@V?$xalloc@PAUSEffect@CPGDef@PS@@@@@std@@AAEXQAPAUSEffect@CPGDef@PS@@II@Z
_TEXT	SEGMENT
__Newvec$ = 8						; size = 4
__Newsize$ = 12						; size = 4
__Newcapacity$ = 16					; size = 4
?_Change_array@?$vector@PAUSEffect@CPGDef@PS@@V?$xalloc@PAUSEffect@CPGDef@PS@@@@@std@@AAEXQAPAUSEffect@CPGDef@PS@@II@Z PROC ; std::vector<PS::CPGDef::SEffect *,xalloc<PS::CPGDef::SEffect *> >::_Change_array, COMDAT
; _this$ = ecx

; 1723 :         const pointer _Newvec, const size_type _Newsize, const size_type _Newcapacity) {

	push	esi
	mov	esi, ecx

; 1724 :         // orphan all iterators, discard old array, acquire new array
; 1725 :         auto& _My_data    = _Mypair._Myval2;
; 1726 :         pointer& _Myfirst = _My_data._Myfirst;
; 1727 :         pointer& _Mylast  = _My_data._Mylast;
; 1728 :         pointer& _Myend   = _My_data._Myend;
; 1729 : 
; 1730 :         _My_data._Orphan_all();
; 1731 : 
; 1732 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN7@Change_arr
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN7@Change_arr:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1737 :         _Myfirst = _Newvec;

	mov	ecx, DWORD PTR __Newvec$[esp]

; 1738 :         _Mylast  = _Newvec + _Newsize;

	mov	eax, DWORD PTR __Newsize$[esp]
	mov	DWORD PTR [esi], ecx
	lea	eax, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR [esi+4], eax

; 1739 :         _Myend   = _Newvec + _Newcapacity;

	mov	eax, DWORD PTR __Newcapacity$[esp]
	lea	eax, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR [esi+8], eax
	pop	esi

; 1740 :     }

	ret	12					; 0000000cH
?_Change_array@?$vector@PAUSEffect@CPGDef@PS@@V?$xalloc@PAUSEffect@CPGDef@PS@@@@@std@@AAEXQAPAUSEffect@CPGDef@PS@@II@Z ENDP ; std::vector<PS::CPGDef::SEffect *,xalloc<PS::CPGDef::SEffect *> >::_Change_array
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Calculate_growth@?$vector@PAUSEffect@CPGDef@PS@@V?$xalloc@PAUSEffect@CPGDef@PS@@@@@std@@ABEII@Z
_TEXT	SEGMENT
__Newsize$ = 8						; size = 4
?_Calculate_growth@?$vector@PAUSEffect@CPGDef@PS@@V?$xalloc@PAUSEffect@CPGDef@PS@@@@@std@@ABEII@Z PROC ; std::vector<PS::CPGDef::SEffect *,xalloc<PS::CPGDef::SEffect *> >::_Calculate_growth, COMDAT
; _this$ = ecx

; 1546 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	edx, DWORD PTR [ecx+8]
	sub	edx, DWORD PTR [ecx]

; 1671 :         // given _Oldcapacity and _Newsize, calculate geometric growth
; 1672 :         const size_type _Oldcapacity = capacity();
; 1673 :         const auto _Max              = max_size();
; 1674 : 
; 1675 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	ecx, 1073741823				; 3fffffffH

; 1546 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	sar	edx, 2

; 1670 :     _CONSTEXPR20_CONTAINER size_type _Calculate_growth(const size_type _Newsize) const {

	push	esi

; 1671 :         // given _Oldcapacity and _Newsize, calculate geometric growth
; 1672 :         const size_type _Oldcapacity = capacity();
; 1673 :         const auto _Max              = max_size();
; 1674 : 
; 1675 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	esi, edx
	shr	esi, 1
	sub	ecx, esi
	cmp	edx, ecx
	jbe	SHORT $LN2@Calculate_

; 1676 :             return _Max; // geometric growth would overflow

	mov	eax, 1073741823				; 3fffffffH
	pop	esi

; 1682 :             return _Newsize; // geometric growth would be insufficient
; 1683 :         }
; 1684 : 
; 1685 :         return _Geometric; // geometric growth is sufficient
; 1686 :     }

	ret	4
$LN2@Calculate_:

; 1677 :         }
; 1678 : 
; 1679 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	lea	eax, DWORD PTR [esi+edx]

; 1680 : 
; 1681 :         if (_Geometric < _Newsize) {

	cmp	eax, DWORD PTR __Newsize$[esp]
	pop	esi
	cmovb	eax, DWORD PTR __Newsize$[esp-4]

; 1682 :             return _Newsize; // geometric growth would be insufficient
; 1683 :         }
; 1684 : 
; 1685 :         return _Geometric; // geometric growth is sufficient
; 1686 :     }

	ret	4
?_Calculate_growth@?$vector@PAUSEffect@CPGDef@PS@@V?$xalloc@PAUSEffect@CPGDef@PS@@@@@std@@ABEII@Z ENDP ; std::vector<PS::CPGDef::SEffect *,xalloc<PS::CPGDef::SEffect *> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Umove_if_noexcept@?$vector@PAUSEffect@CPGDef@PS@@V?$xalloc@PAUSEffect@CPGDef@PS@@@@@std@@AAEXPAPAUSEffect@CPGDef@PS@@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
?_Umove_if_noexcept@?$vector@PAUSEffect@CPGDef@PS@@V?$xalloc@PAUSEffect@CPGDef@PS@@@@@std@@AAEXPAPAUSEffect@CPGDef@PS@@00@Z PROC ; std::vector<PS::CPGDef::SEffect *,xalloc<PS::CPGDef::SEffect *> >::_Umove_if_noexcept, COMDAT
; _this$dead$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1703 :     auto _UFirst      = _Get_unwrapped(_First);

	mov	eax, DWORD PTR __First$[esp-4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1659 :     _CONSTEXPR20_CONTAINER void _Umove_if_noexcept(pointer _First, pointer _Last, pointer _Dest) {

	push	esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	mov	esi, DWORD PTR __Last$[esp]
	cmp	eax, esi
	je	SHORT $LN7@Umove_if_n

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	edx, DWORD PTR __Dest$[esp]
	sub	edx, eax
$LL8@Umove_if_n:

; 1620 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx+eax], ecx

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	add	eax, 4
	cmp	eax, esi
	jne	SHORT $LL8@Umove_if_n
$LN7@Umove_if_n:
	pop	esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1663 :     }

	ret	12					; 0000000cH
?_Umove_if_noexcept@?$vector@PAUSEffect@CPGDef@PS@@V?$xalloc@PAUSEffect@CPGDef@PS@@@@@std@@AAEXPAPAUSEffect@CPGDef@PS@@00@Z ENDP ; std::vector<PS::CPGDef::SEffect *,xalloc<PS::CPGDef::SEffect *> >::_Umove_if_noexcept
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?max_size@?$vector@PAUSEffect@CPGDef@PS@@V?$xalloc@PAUSEffect@CPGDef@PS@@@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@PAUSEffect@CPGDef@PS@@V?$xalloc@PAUSEffect@CPGDef@PS@@@@@std@@QBEIXZ PROC ; std::vector<PS::CPGDef::SEffect *,xalloc<PS::CPGDef::SEffect *> >::max_size, COMDAT
; _this$dead$ = ecx

; 1540 :         return (_STD min)(

	mov	eax, 1073741823				; 3fffffffH

; 1541 :             static_cast<size_type>((numeric_limits<difference_type>::max)()), _Alty_traits::max_size(_Getal()));
; 1542 :     }

	ret	0
?max_size@?$vector@PAUSEffect@CPGDef@PS@@V?$xalloc@PAUSEffect@CPGDef@PS@@@@@std@@QBEIXZ ENDP ; std::vector<PS::CPGDef::SEffect *,xalloc<PS::CPGDef::SEffect *> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?destroy@?$xalloc@PAUSEffect@CPGDef@PS@@@@QAEXPAPAUSEffect@CPGDef@PS@@@Z
_TEXT	SEGMENT
_p$dead$ = 8						; size = 4
?destroy@?$xalloc@PAUSEffect@CPGDef@PS@@@@QAEXPAPAUSEffect@CPGDef@PS@@@Z PROC ; xalloc<PS::CPGDef::SEffect *>::destroy, COMDAT
; _this$dead$ = ecx

; 85   : 							void					destroy			(pointer p)								{	std::_Destroy_in_place(p);			}

	ret	4
?destroy@?$xalloc@PAUSEffect@CPGDef@PS@@@@QAEXPAPAUSEffect@CPGDef@PS@@@Z ENDP ; xalloc<PS::CPGDef::SEffect *>::destroy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?allocate@?$xalloc@PAUSEffect@CPGDef@PS@@@@QBEPAPAUSEffect@CPGDef@PS@@IPBX@Z
_TEXT	SEGMENT
_n$ = 8							; size = 4
_p$dead$ = 12						; size = 4
?allocate@?$xalloc@PAUSEffect@CPGDef@PS@@@@QBEPAPAUSEffect@CPGDef@PS@@IPBX@Z PROC ; xalloc<PS::CPGDef::SEffect *>::allocate, COMDAT
; _this$dead$ = ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	mov	eax, DWORD PTR _n$[esp-4]
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	shl	eax, 2
	push	eax
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 80   : 							pointer					allocate		(size_type n, const void* p=0) const	{	return xr_alloc<T>((u32)n);	}

	ret	8
?allocate@?$xalloc@PAUSEffect@CPGDef@PS@@@@QBEPAPAUSEffect@CPGDef@PS@@IPBX@Z ENDP ; xalloc<PS::CPGDef::SEffect *>::allocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Getal@?$vector@USItem@CParticleGroup@PS@@V?$xalloc@USItem@CParticleGroup@PS@@@@@std@@ABEABV?$xalloc@USItem@CParticleGroup@PS@@@@XZ
_TEXT	SEGMENT
?_Getal@?$vector@USItem@CParticleGroup@PS@@V?$xalloc@USItem@CParticleGroup@PS@@@@@std@@ABEABV?$xalloc@USItem@CParticleGroup@PS@@@@XZ PROC ; std::vector<PS::CParticleGroup::SItem,xalloc<PS::CParticleGroup::SItem> >::_Getal, COMDAT
; _this$ = ecx

; 1809 :         return _Mypair._Get_first();

	mov	eax, ecx

; 1810 :     }

	ret	0
?_Getal@?$vector@USItem@CParticleGroup@PS@@V?$xalloc@USItem@CParticleGroup@PS@@@@@std@@ABEABV?$xalloc@USItem@CParticleGroup@PS@@@@XZ ENDP ; std::vector<PS::CParticleGroup::SItem,xalloc<PS::CParticleGroup::SItem> >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Umove_if_noexcept1@?$vector@USItem@CParticleGroup@PS@@V?$xalloc@USItem@CParticleGroup@PS@@@@@std@@AAEXPAUSItem@CParticleGroup@PS@@00U?$integral_constant@_N$00@2@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
?_Umove_if_noexcept1@?$vector@USItem@CParticleGroup@PS@@V?$xalloc@USItem@CParticleGroup@PS@@@@@std@@AAEXPAUSItem@CParticleGroup@PS@@00U?$integral_constant@_N$00@2@@Z PROC ; std::vector<PS::CParticleGroup::SItem,xalloc<PS::CParticleGroup::SItem> >::_Umove_if_noexcept1, COMDAT
; _this$dead$ = ecx

; 1649 :     _CONSTEXPR20_CONTAINER void _Umove_if_noexcept1(pointer _First, pointer _Last, pointer _Dest, true_type) {

	push	ebx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	mov	ebx, DWORD PTR __Last$[esp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1649 :     _CONSTEXPR20_CONTAINER void _Umove_if_noexcept1(pointer _First, pointer _Last, pointer _Dest, true_type) {

	push	esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1703 :     auto _UFirst      = _Get_unwrapped(_First);

	mov	esi, DWORD PTR __First$[esp+4]

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	esi, ebx
	je	SHORT $LN5@Umove_if_n

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	eax, DWORD PTR __Dest$[esp+4]
	push	ebp
	mov	ebp, esi
	push	edi
	lea	edi, DWORD PTR [eax+16]
	sub	ebp, eax
	npad	5
$LL6@Umove_if_n:
	mov	eax, DWORD PTR [esi]
	lea	ecx, DWORD PTR [edi-12]
	mov	DWORD PTR [edi-16], eax
	lea	eax, DWORD PTR [esi+4]
	push	eax
	call	??0?$xr_vector@PAVIRender_Visual@@V?$xalloc@PAVIRender_Visual@@@@@@QAE@ABV0@@Z
	lea	eax, DWORD PTR [edi+ebp]
	mov	ecx, edi
	push	eax
	call	??0?$xr_vector@PAVIRender_Visual@@V?$xalloc@PAVIRender_Visual@@@@@@QAE@ABV0@@Z

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	add	esi, 28					; 0000001cH
	add	edi, 28					; 0000001cH
	cmp	esi, ebx
	jne	SHORT $LL6@Umove_if_n
	pop	edi
	pop	ebp
$LN5@Umove_if_n:
	pop	esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1652 :     }

	pop	ebx
	ret	16					; 00000010H
?_Umove_if_noexcept1@?$vector@USItem@CParticleGroup@PS@@V?$xalloc@USItem@CParticleGroup@PS@@@@@std@@AAEXPAUSItem@CParticleGroup@PS@@00U?$integral_constant@_N$00@2@@Z ENDP ; std::vector<PS::CParticleGroup::SItem,xalloc<PS::CParticleGroup::SItem> >::_Umove_if_noexcept1
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?capacity@?$vector@USItem@CParticleGroup@PS@@V?$xalloc@USItem@CParticleGroup@PS@@@@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@USItem@CParticleGroup@PS@@V?$xalloc@USItem@CParticleGroup@PS@@@@@std@@QBEIXZ PROC ; std::vector<PS::CParticleGroup::SItem,xalloc<PS::CParticleGroup::SItem> >::capacity, COMDAT
; _this$ = ecx

; 1545 :         auto& _My_data = _Mypair._Myval2;
; 1546 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx]
	sar	eax, 2
	imul	eax, eax, -1227133513

; 1547 :     }

	ret	0
?capacity@?$vector@USItem@CParticleGroup@PS@@V?$xalloc@USItem@CParticleGroup@PS@@@@@std@@QBEIXZ ENDP ; std::vector<PS::CParticleGroup::SItem,xalloc<PS::CParticleGroup::SItem> >::capacity
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?max_size@?$_Normal_allocator_traits@V?$xalloc@USItem@CParticleGroup@PS@@@@@std@@SAIABV?$xalloc@USItem@CParticleGroup@PS@@@@@Z
_TEXT	SEGMENT
?max_size@?$_Normal_allocator_traits@V?$xalloc@USItem@CParticleGroup@PS@@@@@std@@SAIABV?$xalloc@USItem@CParticleGroup@PS@@@@@Z PROC ; std::_Normal_allocator_traits<xalloc<PS::CParticleGroup::SItem> >::max_size, COMDAT
; __Al$dead$ = ecx

; 591  :         if constexpr (_Has_max_size<_Alloc>::value) {
; 592  :             return _Al.max_size();

	mov	eax, 153391689				; 09249249H

; 593  :         } else {
; 594  :             return (numeric_limits<size_type>::max)() / sizeof(value_type);
; 595  :         }
; 596  :     }

	ret	0
?max_size@?$_Normal_allocator_traits@V?$xalloc@USItem@CParticleGroup@PS@@@@@std@@SAIABV?$xalloc@USItem@CParticleGroup@PS@@@@@Z ENDP ; std::_Normal_allocator_traits<xalloc<PS::CParticleGroup::SItem> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Getal@?$vector@PAUSEffect@CPGDef@PS@@V?$xalloc@PAUSEffect@CPGDef@PS@@@@@std@@ABEABV?$xalloc@PAUSEffect@CPGDef@PS@@@@XZ
_TEXT	SEGMENT
?_Getal@?$vector@PAUSEffect@CPGDef@PS@@V?$xalloc@PAUSEffect@CPGDef@PS@@@@@std@@ABEABV?$xalloc@PAUSEffect@CPGDef@PS@@@@XZ PROC ; std::vector<PS::CPGDef::SEffect *,xalloc<PS::CPGDef::SEffect *> >::_Getal, COMDAT
; _this$ = ecx

; 1809 :         return _Mypair._Get_first();

	mov	eax, ecx

; 1810 :     }

	ret	0
?_Getal@?$vector@PAUSEffect@CPGDef@PS@@V?$xalloc@PAUSEffect@CPGDef@PS@@@@@std@@ABEABV?$xalloc@PAUSEffect@CPGDef@PS@@@@XZ ENDP ; std::vector<PS::CPGDef::SEffect *,xalloc<PS::CPGDef::SEffect *> >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Umove_if_noexcept1@?$vector@PAUSEffect@CPGDef@PS@@V?$xalloc@PAUSEffect@CPGDef@PS@@@@@std@@AAEXPAPAUSEffect@CPGDef@PS@@00U?$integral_constant@_N$00@2@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
?_Umove_if_noexcept1@?$vector@PAUSEffect@CPGDef@PS@@V?$xalloc@PAUSEffect@CPGDef@PS@@@@@std@@AAEXPAPAUSEffect@CPGDef@PS@@00U?$integral_constant@_N$00@2@@Z PROC ; std::vector<PS::CPGDef::SEffect *,xalloc<PS::CPGDef::SEffect *> >::_Umove_if_noexcept1, COMDAT
; _this$dead$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1703 :     auto _UFirst      = _Get_unwrapped(_First);

	mov	eax, DWORD PTR __First$[esp-4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1649 :     _CONSTEXPR20_CONTAINER void _Umove_if_noexcept1(pointer _First, pointer _Last, pointer _Dest, true_type) {

	push	esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	mov	esi, DWORD PTR __Last$[esp]
	cmp	eax, esi
	je	SHORT $LN5@Umove_if_n

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	edx, DWORD PTR __Dest$[esp]
	sub	edx, eax
$LL6@Umove_if_n:

; 1620 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx+eax], ecx

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	add	eax, 4
	cmp	eax, esi
	jne	SHORT $LL6@Umove_if_n
$LN5@Umove_if_n:
	pop	esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1652 :     }

	ret	16					; 00000010H
?_Umove_if_noexcept1@?$vector@PAUSEffect@CPGDef@PS@@V?$xalloc@PAUSEffect@CPGDef@PS@@@@@std@@AAEXPAPAUSEffect@CPGDef@PS@@00U?$integral_constant@_N$00@2@@Z ENDP ; std::vector<PS::CPGDef::SEffect *,xalloc<PS::CPGDef::SEffect *> >::_Umove_if_noexcept1
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?capacity@?$vector@PAUSEffect@CPGDef@PS@@V?$xalloc@PAUSEffect@CPGDef@PS@@@@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@PAUSEffect@CPGDef@PS@@V?$xalloc@PAUSEffect@CPGDef@PS@@@@@std@@QBEIXZ PROC ; std::vector<PS::CPGDef::SEffect *,xalloc<PS::CPGDef::SEffect *> >::capacity, COMDAT
; _this$ = ecx

; 1545 :         auto& _My_data = _Mypair._Myval2;
; 1546 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx]
	sar	eax, 2

; 1547 :     }

	ret	0
?capacity@?$vector@PAUSEffect@CPGDef@PS@@V?$xalloc@PAUSEffect@CPGDef@PS@@@@@std@@QBEIXZ ENDP ; std::vector<PS::CPGDef::SEffect *,xalloc<PS::CPGDef::SEffect *> >::capacity
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?max_size@?$_Normal_allocator_traits@V?$xalloc@PAUSEffect@CPGDef@PS@@@@@std@@SAIABV?$xalloc@PAUSEffect@CPGDef@PS@@@@@Z
_TEXT	SEGMENT
?max_size@?$_Normal_allocator_traits@V?$xalloc@PAUSEffect@CPGDef@PS@@@@@std@@SAIABV?$xalloc@PAUSEffect@CPGDef@PS@@@@@Z PROC ; std::_Normal_allocator_traits<xalloc<PS::CPGDef::SEffect *> >::max_size, COMDAT
; __Al$dead$ = ecx

; 591  :         if constexpr (_Has_max_size<_Alloc>::value) {
; 592  :             return _Al.max_size();

	mov	eax, 1073741823				; 3fffffffH

; 593  :         } else {
; 594  :             return (numeric_limits<size_type>::max)() / sizeof(value_type);
; 595  :         }
; 596  :     }

	ret	0
?max_size@?$_Normal_allocator_traits@V?$xalloc@PAUSEffect@CPGDef@PS@@@@@std@@SAIABV?$xalloc@PAUSEffect@CPGDef@PS@@@@@Z ENDP ; std::_Normal_allocator_traits<xalloc<PS::CPGDef::SEffect *> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$xalloc@USItem@CParticleGroup@PS@@@@V?$_Vector_val@U?$_Simple_types@USItem@CParticleGroup@PS@@@std@@@std@@$00@std@@QBEABV?$xalloc@USItem@CParticleGroup@PS@@@@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@V?$xalloc@USItem@CParticleGroup@PS@@@@V?$_Vector_val@U?$_Simple_types@USItem@CParticleGroup@PS@@@std@@@std@@$00@std@@QBEABV?$xalloc@USItem@CParticleGroup@PS@@@@XZ PROC ; std::_Compressed_pair<xalloc<PS::CParticleGroup::SItem>,std::_Vector_val<std::_Simple_types<PS::CParticleGroup::SItem> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 1343 :         return *this;

	mov	eax, ecx

; 1344 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$xalloc@USItem@CParticleGroup@PS@@@@V?$_Vector_val@U?$_Simple_types@USItem@CParticleGroup@PS@@@std@@@std@@$00@std@@QBEABV?$xalloc@USItem@CParticleGroup@PS@@@@XZ ENDP ; std::_Compressed_pair<xalloc<PS::CParticleGroup::SItem>,std::_Vector_val<std::_Simple_types<PS::CParticleGroup::SItem> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?max_size@?$xalloc@USItem@CParticleGroup@PS@@@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$xalloc@USItem@CParticleGroup@PS@@@@QBEIXZ PROC ; xalloc<PS::CParticleGroup::SItem>::max_size, COMDAT
; _this$dead$ = ecx

; 86   : 							size_type				max_size		() const								{	size_type _Count = (size_type)(-1) / sizeof (T);	return (0 < _Count ? _Count : 1);	}

	mov	eax, 153391689				; 09249249H
	ret	0
?max_size@?$xalloc@USItem@CParticleGroup@PS@@@@QBEIXZ ENDP ; xalloc<PS::CParticleGroup::SItem>::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$xalloc@PAUSEffect@CPGDef@PS@@@@V?$_Vector_val@U?$_Simple_types@PAUSEffect@CPGDef@PS@@@std@@@std@@$00@std@@QBEABV?$xalloc@PAUSEffect@CPGDef@PS@@@@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@V?$xalloc@PAUSEffect@CPGDef@PS@@@@V?$_Vector_val@U?$_Simple_types@PAUSEffect@CPGDef@PS@@@std@@@std@@$00@std@@QBEABV?$xalloc@PAUSEffect@CPGDef@PS@@@@XZ PROC ; std::_Compressed_pair<xalloc<PS::CPGDef::SEffect *>,std::_Vector_val<std::_Simple_types<PS::CPGDef::SEffect *> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 1343 :         return *this;

	mov	eax, ecx

; 1344 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$xalloc@PAUSEffect@CPGDef@PS@@@@V?$_Vector_val@U?$_Simple_types@PAUSEffect@CPGDef@PS@@@std@@@std@@$00@std@@QBEABV?$xalloc@PAUSEffect@CPGDef@PS@@@@XZ ENDP ; std::_Compressed_pair<xalloc<PS::CPGDef::SEffect *>,std::_Vector_val<std::_Simple_types<PS::CPGDef::SEffect *> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?max_size@?$xalloc@PAUSEffect@CPGDef@PS@@@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$xalloc@PAUSEffect@CPGDef@PS@@@@QBEIXZ PROC	; xalloc<PS::CPGDef::SEffect *>::max_size, COMDAT
; _this$dead$ = ecx

; 86   : 							size_type				max_size		() const								{	size_type _Count = (size_type)(-1) / sizeof (T);	return (0 < _Count ? _Count : 1);	}

	mov	eax, 1073741823				; 3fffffffH
	ret	0
?max_size@?$xalloc@PAUSEffect@CPGDef@PS@@@@QBEIXZ ENDP	; xalloc<PS::CPGDef::SEffect *>::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_Adl_verify_range@PAPAVIRender_Visual@@PAPAV1@@std@@YAXABQAPAVIRender_Visual@@0@Z
_TEXT	SEGMENT
??$_Adl_verify_range@PAPAVIRender_Visual@@PAPAV1@@std@@YAXABQAPAVIRender_Visual@@0@Z PROC ; std::_Adl_verify_range<IRender_Visual * *,IRender_Visual * *>, COMDAT
; __First$dead$ = ecx
; __Last$dead$ = edx

; 1259 :     // check that [_First, _Last) forms an iterator range
; 1260 :     if constexpr (_Range_verifiable_v<_Iter, _Sentinel>) {
; 1261 :         _Verify_range(_First, _Last);
; 1262 :     }
; 1263 : }

	ret	0
??$_Adl_verify_range@PAPAVIRender_Visual@@PAPAV1@@std@@YAXABQAPAVIRender_Visual@@0@Z ENDP ; std::_Adl_verify_range<IRender_Visual * *,IRender_Visual * *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_Seek_wrapped@PAPAVIRender_Visual@@AAPAPAV1@@std@@YAXAAPAPAVIRender_Visual@@0@Z
_TEXT	SEGMENT
??$_Seek_wrapped@PAPAVIRender_Visual@@AAPAPAV1@@std@@YAXAAPAPAVIRender_Visual@@0@Z PROC ; std::_Seek_wrapped<IRender_Visual * *,IRender_Visual * * &>, COMDAT
; __It$ = ecx
; __UIt$ = edx

; 1375 :     if constexpr (_Wrapped_seekable_v<_Iter, _UIter>) {
; 1376 :         _It._Seek_to(_STD forward<_UIter>(_UIt));
; 1377 :     } else {
; 1378 :         _It = _STD forward<_UIter>(_UIt);

	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax

; 1379 :     }
; 1380 : }

	ret	0
??$_Seek_wrapped@PAPAVIRender_Visual@@AAPAPAV1@@std@@YAXAAPAPAVIRender_Visual@@0@Z ENDP ; std::_Seek_wrapped<IRender_Visual * *,IRender_Visual * * &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\type_traits
;	COMDAT ??$forward@AAPAPAVIRender_Visual@@@std@@YAAAPAPAVIRender_Visual@@AAPAPAV1@@Z
_TEXT	SEGMENT
??$forward@AAPAPAVIRender_Visual@@@std@@YAAAPAPAVIRender_Visual@@AAPAPAV1@@Z PROC ; std::forward<IRender_Visual * * &>, COMDAT
; __Arg$ = ecx

; 1386 :     return static_cast<_Ty&&>(_Arg);

	mov	eax, ecx

; 1387 : }

	ret	0
??$forward@AAPAPAVIRender_Visual@@@std@@YAAAPAPAVIRender_Visual@@AAPAPAV1@@Z ENDP ; std::forward<IRender_Visual * * &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Emplace_back@$$V@?$_Uninitialized_backout_al@V?$xalloc@USItem@CParticleGroup@PS@@@@@std@@QAEXXZ
_TEXT	SEGMENT
??$_Emplace_back@$$V@?$_Uninitialized_backout_al@V?$xalloc@USItem@CParticleGroup@PS@@@@@std@@QAEXXZ PROC ; std::_Uninitialized_backout_al<xalloc<PS::CParticleGroup::SItem> >::_Emplace_back<>, COMDAT
; _this$ = ecx

; 570  :             ::new (static_cast<void*>(_Ptr)) _Ty(_STD forward<_Types>(_Args)...);

	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax], 0
	mov	DWORD PTR [eax+8], 0
	mov	DWORD PTR [eax+12], 0
	mov	DWORD PTR [eax+20], 0
	mov	DWORD PTR [eax+24], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [eax+4], 0
	mov	DWORD PTR [eax+8], 0
	mov	DWORD PTR [eax+12], 0
	mov	DWORD PTR [eax+16], 0
	mov	DWORD PTR [eax+20], 0
	mov	DWORD PTR [eax+24], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1621 :         ++_Last;

	add	DWORD PTR [ecx+4], 28			; 0000001cH

; 1622 :     }

	ret	0
??$_Emplace_back@$$V@?$_Uninitialized_backout_al@V?$xalloc@USItem@CParticleGroup@PS@@@@@std@@QAEXXZ ENDP ; std::_Uninitialized_backout_al<xalloc<PS::CParticleGroup::SItem> >::_Emplace_back<>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Zero_range@PAPAUSEffect@CPGDef@PS@@@std@@YAPAPAUSEffect@CPGDef@PS@@QAPAU123@0@Z
_TEXT	SEGMENT
??$_Zero_range@PAPAUSEffect@CPGDef@PS@@@std@@YAPAPAUSEffect@CPGDef@PS@@QAPAU123@0@Z PROC ; std::_Zero_range<PS::CPGDef::SEffect * *>, COMDAT
; __First$ = ecx
; __Last$ = edx

; 1789 : _Ptr _Zero_range(const _Ptr _First, const _Ptr _Last) { // fill [_First, _Last) with zeroes

	push	esi
	mov	esi, edx

; 1790 :     char* const _First_ch = reinterpret_cast<char*>(_To_address(_First));
; 1791 :     char* const _Last_ch  = reinterpret_cast<char*>(_To_address(_Last));
; 1792 :     _CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

	mov	eax, esi
	sub	eax, ecx
	push	eax
	push	0
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 1793 :     return _Last;

	mov	eax, esi
	pop	esi

; 1794 : }

	ret	0
??$_Zero_range@PAPAUSEffect@CPGDef@PS@@@std@@YAPAPAUSEffect@CPGDef@PS@@QAPAU123@0@Z ENDP ; std::_Zero_range<PS::CPGDef::SEffect * *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_To_address@PAPAUSEffect@CPGDef@PS@@@std@@YA?A_PABQAPAUSEffect@CPGDef@PS@@@Z
_TEXT	SEGMENT
??$_To_address@PAPAUSEffect@CPGDef@PS@@@std@@YA?A_PABQAPAUSEffect@CPGDef@PS@@@Z PROC ; std::_To_address<PS::CPGDef::SEffect * *>, COMDAT
; __Val$ = ecx

; 3981 :     _STL_INTERNAL_STATIC_ASSERT(is_pointer_v<_Iter>);
; 3982 :     return _Val;

	mov	eax, DWORD PTR [ecx]

; 3983 : }

	ret	0
??$_To_address@PAPAUSEffect@CPGDef@PS@@@std@@YA?A_PABQAPAUSEffect@CPGDef@PS@@@Z ENDP ; std::_To_address<PS::CPGDef::SEffect * *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Emplace_back@$$V@?$_Uninitialized_backout_al@V?$xalloc@PAUSEffect@CPGDef@PS@@@@@std@@QAEXXZ
_TEXT	SEGMENT
??$_Emplace_back@$$V@?$_Uninitialized_backout_al@V?$xalloc@PAUSEffect@CPGDef@PS@@@@@std@@QAEXXZ PROC ; std::_Uninitialized_backout_al<xalloc<PS::CPGDef::SEffect *> >::_Emplace_back<>, COMDAT
; _this$ = ecx

; 570  :             ::new (static_cast<void*>(_Ptr)) _Ty(_STD forward<_Types>(_Args)...);

	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax], 0

; 1620 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);
; 1621 :         ++_Last;

	add	DWORD PTR [ecx+4], 4

; 1622 :     }

	ret	0
??$_Emplace_back@$$V@?$_Uninitialized_backout_al@V?$xalloc@PAUSEffect@CPGDef@PS@@@@@std@@QAEXXZ ENDP ; std::_Uninitialized_backout_al<xalloc<PS::CPGDef::SEffect *> >::_Emplace_back<>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Refancy@PAPAVIRender_Visual@@$0A@@std@@YAPAPAVIRender_Visual@@PAPAV1@@Z
_TEXT	SEGMENT
??$_Refancy@PAPAVIRender_Visual@@$0A@@std@@YAPAPAVIRender_Visual@@PAPAV1@@Z PROC ; std::_Refancy<IRender_Visual * *,0>, COMDAT
; __Ptr$ = ecx

; 287  :     return _Ptr;

	mov	eax, ecx

; 288  : }

	ret	0
??$_Refancy@PAPAVIRender_Visual@@$0A@@std@@YAPAPAVIRender_Visual@@PAPAV1@@Z ENDP ; std::_Refancy<IRender_Visual * *,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Destroy_in_place@PAUSItem@CParticleGroup@PS@@@std@@YAXAAPAUSItem@CParticleGroup@PS@@@Z
_TEXT	SEGMENT
??$_Destroy_in_place@PAUSItem@CParticleGroup@PS@@@std@@YAXAAPAUSItem@CParticleGroup@PS@@@Z PROC ; std::_Destroy_in_place<PS::CParticleGroup::SItem *>, COMDAT
; __Obj$dead$ = ecx

; 295  :     if constexpr (is_array_v<_Ty>) {
; 296  :         _Destroy_range(_Obj, _Obj + extent_v<_Ty>);
; 297  :     } else {
; 298  :         _Obj.~_Ty();
; 299  :     }
; 300  : }

	ret	0
??$_Destroy_in_place@PAUSItem@CParticleGroup@PS@@@std@@YAXAAPAUSItem@CParticleGroup@PS@@@Z ENDP ; std::_Destroy_in_place<PS::CParticleGroup::SItem *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
;	COMDAT ??$xr_alloc@USItem@CParticleGroup@PS@@@@YAPAUSItem@CParticleGroup@PS@@I@Z
_TEXT	SEGMENT
??$xr_alloc@USItem@CParticleGroup@PS@@@@YAPAUSItem@CParticleGroup@PS@@I@Z PROC ; xr_alloc<PS::CParticleGroup::SItem>, COMDAT
; _count$ = ecx

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	lea	eax, DWORD PTR [ecx*8]
	sub	eax, ecx
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	shl	eax, 2
	push	eax
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
	ret	0
??$xr_alloc@USItem@CParticleGroup@PS@@@@YAPAUSItem@CParticleGroup@PS@@I@Z ENDP ; xr_alloc<PS::CParticleGroup::SItem>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Destroy_in_place@PAPAUSEffect@CPGDef@PS@@@std@@YAXAAPAPAUSEffect@CPGDef@PS@@@Z
_TEXT	SEGMENT
??$_Destroy_in_place@PAPAUSEffect@CPGDef@PS@@@std@@YAXAAPAPAUSEffect@CPGDef@PS@@@Z PROC ; std::_Destroy_in_place<PS::CPGDef::SEffect * *>, COMDAT
; __Obj$dead$ = ecx

; 295  :     if constexpr (is_array_v<_Ty>) {
; 296  :         _Destroy_range(_Obj, _Obj + extent_v<_Ty>);
; 297  :     } else {
; 298  :         _Obj.~_Ty();
; 299  :     }
; 300  : }

	ret	0
??$_Destroy_in_place@PAPAUSEffect@CPGDef@PS@@@std@@YAXAAPAPAUSEffect@CPGDef@PS@@@Z ENDP ; std::_Destroy_in_place<PS::CPGDef::SEffect * *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
;	COMDAT ??$xr_alloc@PAUSEffect@CPGDef@PS@@@@YAPAPAUSEffect@CPGDef@PS@@I@Z
_TEXT	SEGMENT
??$xr_alloc@PAUSEffect@CPGDef@PS@@@@YAPAPAUSEffect@CPGDef@PS@@I@Z PROC ; xr_alloc<PS::CPGDef::SEffect *>, COMDAT
; _count$ = ecx

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	lea	eax, DWORD PTR [ecx*4]
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
	ret	0
??$xr_alloc@PAUSEffect@CPGDef@PS@@@@YAPAPAUSEffect@CPGDef@PS@@I@Z ENDP ; xr_alloc<PS::CPGDef::SEffect *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Uninitialized_move@PAUSItem@CParticleGroup@PS@@V?$xalloc@USItem@CParticleGroup@PS@@@@@std@@YAPAUSItem@CParticleGroup@PS@@QAU123@0PAU123@AAV?$xalloc@USItem@CParticleGroup@PS@@@@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Al$dead$ = 12						; size = 4
??$_Uninitialized_move@PAUSItem@CParticleGroup@PS@@V?$xalloc@USItem@CParticleGroup@PS@@@@@std@@YAPAUSItem@CParticleGroup@PS@@QAU123@0PAU123@AAV?$xalloc@USItem@CParticleGroup@PS@@@@@Z PROC ; std::_Uninitialized_move<PS::CParticleGroup::SItem *,xalloc<PS::CParticleGroup::SItem> >, COMDAT
; __First$ = ecx
; __Last$ = edx

; 1699 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

	push	ebp
	mov	ebp, edx
	push	edi

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	edi, DWORD PTR __Dest$[esp+4]

; 1700 :     // move [_First, _Last) to raw _Dest, using _Al
; 1701 :     // note: only called internally from elsewhere in the STL
; 1702 :     using _Ptrval     = typename _Alloc::value_type*;
; 1703 :     auto _UFirst      = _Get_unwrapped(_First);
; 1704 :     const auto _ULast = _Get_unwrapped(_Last);
; 1705 :     if constexpr (conjunction_v<bool_constant<_Ptr_move_cat<decltype(_UFirst), _Ptrval>::_Really_trivial>,
; 1706 :                       _Uses_default_construct<_Alloc, _Ptrval, decltype(_STD move(*_UFirst))>>) {
; 1707 : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 1708 :         if (!_STD is_constant_evaluated())
; 1709 : #endif // __cpp_lib_constexpr_dynamic_alloc
; 1710 :         {
; 1711 :             _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));
; 1712 :             return _Dest + (_ULast - _UFirst);
; 1713 :         }
; 1714 :     }
; 1715 : 
; 1716 :     _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	ecx, ebp
	je	SHORT $LN22@Uninitiali

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	push	ebx
	mov	ebx, edi
	push	esi
	lea	esi, DWORD PTR [ecx+16]
	sub	ebx, ecx
$LL4@Uninitiali:
	mov	eax, DWORD PTR [esi-16]
	lea	ecx, DWORD PTR [edi+4]
	mov	DWORD PTR [edi], eax
	lea	eax, DWORD PTR [esi-12]
	push	eax
	call	??0?$xr_vector@PAVIRender_Visual@@V?$xalloc@PAVIRender_Visual@@@@@@QAE@ABV0@@Z
	push	esi
	lea	ecx, DWORD PTR [ebx+esi]
	call	??0?$xr_vector@PAVIRender_Visual@@V?$xalloc@PAVIRender_Visual@@@@@@QAE@ABV0@@Z

; 1621 :         ++_Last;

	add	esi, 28					; 0000001cH
	add	edi, 28					; 0000001cH

; 1700 :     // move [_First, _Last) to raw _Dest, using _Al
; 1701 :     // note: only called internally from elsewhere in the STL
; 1702 :     using _Ptrval     = typename _Alloc::value_type*;
; 1703 :     auto _UFirst      = _Get_unwrapped(_First);
; 1704 :     const auto _ULast = _Get_unwrapped(_Last);
; 1705 :     if constexpr (conjunction_v<bool_constant<_Ptr_move_cat<decltype(_UFirst), _Ptrval>::_Really_trivial>,
; 1706 :                       _Uses_default_construct<_Alloc, _Ptrval, decltype(_STD move(*_UFirst))>>) {
; 1707 : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 1708 :         if (!_STD is_constant_evaluated())
; 1709 : #endif // __cpp_lib_constexpr_dynamic_alloc
; 1710 :         {
; 1711 :             _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));
; 1712 :             return _Dest + (_ULast - _UFirst);
; 1713 :         }
; 1714 :     }
; 1715 : 
; 1716 :     _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	lea	ecx, DWORD PTR [esi-16]
	cmp	ecx, ebp
	jne	SHORT $LL4@Uninitiali

; 1718 :         _Backout._Emplace_back(_STD move(*_UFirst));
; 1719 :     }
; 1720 : 
; 1721 :     return _Backout._Release();

	pop	esi
	pop	ebx
$LN22@Uninitiali:

; 1722 : }

	mov	eax, edi
	pop	edi
	pop	ebp
	ret	0
??$_Uninitialized_move@PAUSItem@CParticleGroup@PS@@V?$xalloc@USItem@CParticleGroup@PS@@@@@std@@YAPAUSItem@CParticleGroup@PS@@QAU123@0PAU123@AAV?$xalloc@USItem@CParticleGroup@PS@@@@@Z ENDP ; std::_Uninitialized_move<PS::CParticleGroup::SItem *,xalloc<PS::CParticleGroup::SItem> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_Get_unwrapped@ABQAUSItem@CParticleGroup@PS@@@std@@YA?A_TABQAUSItem@CParticleGroup@PS@@@Z
_TEXT	SEGMENT
??$_Get_unwrapped@ABQAUSItem@CParticleGroup@PS@@@std@@YA?A_TABQAUSItem@CParticleGroup@PS@@@Z PROC ; std::_Get_unwrapped<PS::CParticleGroup::SItem * const &>, COMDAT
; __It$ = ecx

; 1275 :     // unwrap an iterator previously subjected to _Adl_verify_range or otherwise validated
; 1276 :     if constexpr (is_pointer_v<decay_t<_Iter>>) { // special-case pointers and arrays
; 1277 :         return _It + 0;

	mov	eax, DWORD PTR [ecx]

; 1278 :     } else if constexpr (_Unwrappable_v<_Iter>) {
; 1279 :         return static_cast<_Iter&&>(_It)._Unwrapped();
; 1280 :     } else {
; 1281 :         return static_cast<_Iter&&>(_It);
; 1282 :     }
; 1283 : }

	ret	0
??$_Get_unwrapped@ABQAUSItem@CParticleGroup@PS@@@std@@YA?A_TABQAUSItem@CParticleGroup@PS@@@Z ENDP ; std::_Get_unwrapped<PS::CParticleGroup::SItem * const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Uninitialized_move@PAPAUSEffect@CPGDef@PS@@V?$xalloc@PAUSEffect@CPGDef@PS@@@@@std@@YAPAPAUSEffect@CPGDef@PS@@QAPAU123@0PAPAU123@AAV?$xalloc@PAUSEffect@CPGDef@PS@@@@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Al$dead$ = 12						; size = 4
??$_Uninitialized_move@PAPAUSEffect@CPGDef@PS@@V?$xalloc@PAUSEffect@CPGDef@PS@@@@@std@@YAPAPAUSEffect@CPGDef@PS@@QAPAU123@0PAPAU123@AAV?$xalloc@PAUSEffect@CPGDef@PS@@@@@Z PROC ; std::_Uninitialized_move<PS::CPGDef::SEffect * *,xalloc<PS::CPGDef::SEffect *> >, COMDAT
; __First$ = ecx
; __Last$ = edx

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	eax, DWORD PTR __Dest$[esp-4]

; 1699 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

	push	esi
	mov	esi, edx

; 1700 :     // move [_First, _Last) to raw _Dest, using _Al
; 1701 :     // note: only called internally from elsewhere in the STL
; 1702 :     using _Ptrval     = typename _Alloc::value_type*;
; 1703 :     auto _UFirst      = _Get_unwrapped(_First);
; 1704 :     const auto _ULast = _Get_unwrapped(_Last);
; 1705 :     if constexpr (conjunction_v<bool_constant<_Ptr_move_cat<decltype(_UFirst), _Ptrval>::_Really_trivial>,
; 1706 :                       _Uses_default_construct<_Alloc, _Ptrval, decltype(_STD move(*_UFirst))>>) {
; 1707 : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 1708 :         if (!_STD is_constant_evaluated())
; 1709 : #endif // __cpp_lib_constexpr_dynamic_alloc
; 1710 :         {
; 1711 :             _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));
; 1712 :             return _Dest + (_ULast - _UFirst);
; 1713 :         }
; 1714 :     }
; 1715 : 
; 1716 :     _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	ecx, esi
	je	SHORT $LN3@Uninitiali
	npad	5
$LL4@Uninitiali:

; 1620 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

	mov	edx, DWORD PTR [ecx]

; 1621 :         ++_Last;

	add	ecx, 4
	mov	DWORD PTR [eax], edx
	add	eax, 4

; 1700 :     // move [_First, _Last) to raw _Dest, using _Al
; 1701 :     // note: only called internally from elsewhere in the STL
; 1702 :     using _Ptrval     = typename _Alloc::value_type*;
; 1703 :     auto _UFirst      = _Get_unwrapped(_First);
; 1704 :     const auto _ULast = _Get_unwrapped(_Last);
; 1705 :     if constexpr (conjunction_v<bool_constant<_Ptr_move_cat<decltype(_UFirst), _Ptrval>::_Really_trivial>,
; 1706 :                       _Uses_default_construct<_Alloc, _Ptrval, decltype(_STD move(*_UFirst))>>) {
; 1707 : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 1708 :         if (!_STD is_constant_evaluated())
; 1709 : #endif // __cpp_lib_constexpr_dynamic_alloc
; 1710 :         {
; 1711 :             _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));
; 1712 :             return _Dest + (_ULast - _UFirst);
; 1713 :         }
; 1714 :     }
; 1715 : 
; 1716 :     _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	ecx, esi
	jne	SHORT $LL4@Uninitiali
$LN3@Uninitiali:
	pop	esi

; 1718 :         _Backout._Emplace_back(_STD move(*_UFirst));
; 1719 :     }
; 1720 : 
; 1721 :     return _Backout._Release();
; 1722 : }

	ret	0
??$_Uninitialized_move@PAPAUSEffect@CPGDef@PS@@V?$xalloc@PAUSEffect@CPGDef@PS@@@@@std@@YAPAPAUSEffect@CPGDef@PS@@QAPAU123@0PAPAU123@AAV?$xalloc@PAUSEffect@CPGDef@PS@@@@@Z ENDP ; std::_Uninitialized_move<PS::CPGDef::SEffect * *,xalloc<PS::CPGDef::SEffect *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_Get_unwrapped@ABQAPAUSEffect@CPGDef@PS@@@std@@YA?A_TABQAPAUSEffect@CPGDef@PS@@@Z
_TEXT	SEGMENT
??$_Get_unwrapped@ABQAPAUSEffect@CPGDef@PS@@@std@@YA?A_TABQAPAUSEffect@CPGDef@PS@@@Z PROC ; std::_Get_unwrapped<PS::CPGDef::SEffect * * const &>, COMDAT
; __It$ = ecx

; 1275 :     // unwrap an iterator previously subjected to _Adl_verify_range or otherwise validated
; 1276 :     if constexpr (is_pointer_v<decay_t<_Iter>>) { // special-case pointers and arrays
; 1277 :         return _It + 0;

	mov	eax, DWORD PTR [ecx]

; 1278 :     } else if constexpr (_Unwrappable_v<_Iter>) {
; 1279 :         return static_cast<_Iter&&>(_It)._Unwrapped();
; 1280 :     } else {
; 1281 :         return static_cast<_Iter&&>(_It);
; 1282 :     }
; 1283 : }

	ret	0
??$_Get_unwrapped@ABQAPAUSEffect@CPGDef@PS@@@std@@YA?A_TABQAPAUSEffect@CPGDef@PS@@@Z ENDP ; std::_Get_unwrapped<PS::CPGDef::SEffect * * const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$construct@USItem@CParticleGroup@PS@@$$V@?$_Normal_allocator_traits@V?$xalloc@USItem@CParticleGroup@PS@@@@@std@@SAXAAV?$xalloc@USItem@CParticleGroup@PS@@@@PAUSItem@CParticleGroup@PS@@@Z
_TEXT	SEGMENT
??$construct@USItem@CParticleGroup@PS@@$$V@?$_Normal_allocator_traits@V?$xalloc@USItem@CParticleGroup@PS@@@@@std@@SAXAAV?$xalloc@USItem@CParticleGroup@PS@@@@PAUSItem@CParticleGroup@PS@@@Z PROC ; std::_Normal_allocator_traits<xalloc<PS::CParticleGroup::SItem> >::construct<PS::CParticleGroup::SItem>, COMDAT
; __Al$dead$ = ecx
; __Ptr$ = edx

; 565  :         if constexpr (_Uses_default_construct<_Alloc, _Ty*, _Types...>::value) {
; 566  :             (void) _Al; // TRANSITION, DevCom-1004719
; 567  : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 568  :             _STD construct_at(_Ptr, _STD forward<_Types>(_Args)...);
; 569  : #else // __cpp_lib_constexpr_dynamic_alloc
; 570  :             ::new (static_cast<void*>(_Ptr)) _Ty(_STD forward<_Types>(_Args)...);

	mov	DWORD PTR [edx], 0
	mov	DWORD PTR [edx+8], 0
	mov	DWORD PTR [edx+12], 0
	mov	DWORD PTR [edx+20], 0
	mov	DWORD PTR [edx+24], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [edx+4], 0
	mov	DWORD PTR [edx+8], 0
	mov	DWORD PTR [edx+12], 0
	mov	DWORD PTR [edx+16], 0
	mov	DWORD PTR [edx+20], 0
	mov	DWORD PTR [edx+24], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 575  :     }

	ret	0
??$construct@USItem@CParticleGroup@PS@@$$V@?$_Normal_allocator_traits@V?$xalloc@USItem@CParticleGroup@PS@@@@@std@@SAXAAV?$xalloc@USItem@CParticleGroup@PS@@@@PAUSItem@CParticleGroup@PS@@@Z ENDP ; std::_Normal_allocator_traits<xalloc<PS::CParticleGroup::SItem> >::construct<PS::CParticleGroup::SItem>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$construct@PAUSEffect@CPGDef@PS@@$$V@?$_Normal_allocator_traits@V?$xalloc@PAUSEffect@CPGDef@PS@@@@@std@@SAXAAV?$xalloc@PAUSEffect@CPGDef@PS@@@@PAPAUSEffect@CPGDef@PS@@@Z
_TEXT	SEGMENT
??$construct@PAUSEffect@CPGDef@PS@@$$V@?$_Normal_allocator_traits@V?$xalloc@PAUSEffect@CPGDef@PS@@@@@std@@SAXAAV?$xalloc@PAUSEffect@CPGDef@PS@@@@PAPAUSEffect@CPGDef@PS@@@Z PROC ; std::_Normal_allocator_traits<xalloc<PS::CPGDef::SEffect *> >::construct<PS::CPGDef::SEffect *>, COMDAT
; __Al$dead$ = ecx
; __Ptr$ = edx

; 565  :         if constexpr (_Uses_default_construct<_Alloc, _Ty*, _Types...>::value) {
; 566  :             (void) _Al; // TRANSITION, DevCom-1004719
; 567  : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 568  :             _STD construct_at(_Ptr, _STD forward<_Types>(_Args)...);
; 569  : #else // __cpp_lib_constexpr_dynamic_alloc
; 570  :             ::new (static_cast<void*>(_Ptr)) _Ty(_STD forward<_Types>(_Args)...);

	mov	DWORD PTR [edx], 0

; 571  : #endif // __cpp_lib_constexpr_dynamic_alloc
; 572  :         } else {
; 573  :             _Al.construct(_Ptr, _STD forward<_Types>(_Args)...);
; 574  :         }
; 575  :     }

	ret	0
??$construct@PAUSEffect@CPGDef@PS@@$$V@?$_Normal_allocator_traits@V?$xalloc@PAUSEffect@CPGDef@PS@@@@@std@@SAXAAV?$xalloc@PAUSEffect@CPGDef@PS@@@@PAPAUSEffect@CPGDef@PS@@@Z ENDP ; std::_Normal_allocator_traits<xalloc<PS::CPGDef::SEffect *> >::construct<PS::CPGDef::SEffect *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\type_traits
;	COMDAT ??$move@AAUSItem@CParticleGroup@PS@@@std@@YA$$QAUSItem@CParticleGroup@PS@@AAU123@@Z
_TEXT	SEGMENT
??$move@AAUSItem@CParticleGroup@PS@@@std@@YA$$QAUSItem@CParticleGroup@PS@@AAU123@@Z PROC ; std::move<PS::CParticleGroup::SItem &>, COMDAT
; __Arg$ = ecx

; 1397 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

	mov	eax, ecx

; 1398 : }

	ret	0
??$move@AAUSItem@CParticleGroup@PS@@@std@@YA$$QAUSItem@CParticleGroup@PS@@AAU123@@Z ENDP ; std::move<PS::CParticleGroup::SItem &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Emplace_back@USItem@CParticleGroup@PS@@@?$_Uninitialized_backout_al@V?$xalloc@USItem@CParticleGroup@PS@@@@@std@@QAEX$$QAUSItem@CParticleGroup@PS@@@Z
_TEXT	SEGMENT
_<_Vals_0>$ = 8						; size = 4
??$_Emplace_back@USItem@CParticleGroup@PS@@@?$_Uninitialized_backout_al@V?$xalloc@USItem@CParticleGroup@PS@@@@@std@@QAEX$$QAUSItem@CParticleGroup@PS@@@Z PROC ; std::_Uninitialized_backout_al<xalloc<PS::CParticleGroup::SItem> >::_Emplace_back<PS::CParticleGroup::SItem>, COMDAT
; _this$ = ecx

; 1619 :     _CONSTEXPR20_DYNALLOC void _Emplace_back(_Types&&... _Vals) { // construct a new element at *_Last and increment

	push	ebx
	mov	ebx, ecx
	push	esi
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	esi, DWORD PTR _<_Vals_0>$[esp+4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1619 :     _CONSTEXPR20_DYNALLOC void _Emplace_back(_Types&&... _Vals) { // construct a new element at *_Last and increment

	push	edi
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	edi, DWORD PTR [ebx+4]
	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [edi], eax
	lea	ecx, DWORD PTR [edi+4]
	lea	eax, DWORD PTR [esi+4]
	push	eax
	call	??0?$xr_vector@PAVIRender_Visual@@V?$xalloc@PAVIRender_Visual@@@@@@QAE@ABV0@@Z
	lea	eax, DWORD PTR [esi+16]
	push	eax
	lea	ecx, DWORD PTR [edi+16]
	call	??0?$xr_vector@PAVIRender_Visual@@V?$xalloc@PAVIRender_Visual@@@@@@QAE@ABV0@@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1621 :         ++_Last;

	add	DWORD PTR [ebx+4], 28			; 0000001cH
	pop	edi
	pop	esi
	pop	ebx

; 1622 :     }

	ret	4
??$_Emplace_back@USItem@CParticleGroup@PS@@@?$_Uninitialized_backout_al@V?$xalloc@USItem@CParticleGroup@PS@@@@@std@@QAEX$$QAUSItem@CParticleGroup@PS@@@Z ENDP ; std::_Uninitialized_backout_al<xalloc<PS::CParticleGroup::SItem> >::_Emplace_back<PS::CParticleGroup::SItem>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\type_traits
;	COMDAT ??$move@AAPAUSEffect@CPGDef@PS@@@std@@YA$$QAPAUSEffect@CPGDef@PS@@AAPAU123@@Z
_TEXT	SEGMENT
??$move@AAPAUSEffect@CPGDef@PS@@@std@@YA$$QAPAUSEffect@CPGDef@PS@@AAPAU123@@Z PROC ; std::move<PS::CPGDef::SEffect * &>, COMDAT
; __Arg$ = ecx

; 1397 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

	mov	eax, ecx

; 1398 : }

	ret	0
??$move@AAPAUSEffect@CPGDef@PS@@@std@@YA$$QAPAUSEffect@CPGDef@PS@@AAPAU123@@Z ENDP ; std::move<PS::CPGDef::SEffect * &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Emplace_back@PAUSEffect@CPGDef@PS@@@?$_Uninitialized_backout_al@V?$xalloc@PAUSEffect@CPGDef@PS@@@@@std@@QAEX$$QAPAUSEffect@CPGDef@PS@@@Z
_TEXT	SEGMENT
_<_Vals_0>$ = 8						; size = 4
??$_Emplace_back@PAUSEffect@CPGDef@PS@@@?$_Uninitialized_backout_al@V?$xalloc@PAUSEffect@CPGDef@PS@@@@@std@@QAEX$$QAPAUSEffect@CPGDef@PS@@@Z PROC ; std::_Uninitialized_backout_al<xalloc<PS::CPGDef::SEffect *> >::_Emplace_back<PS::CPGDef::SEffect *>, COMDAT
; _this$ = ecx

; 1620 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _<_Vals_0>$[esp-4]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edx], eax

; 1621 :         ++_Last;

	add	DWORD PTR [ecx+4], 4

; 1622 :     }

	ret	4
??$_Emplace_back@PAUSEffect@CPGDef@PS@@@?$_Uninitialized_backout_al@V?$xalloc@PAUSEffect@CPGDef@PS@@@@@std@@QAEX$$QAPAUSEffect@CPGDef@PS@@@Z ENDP ; std::_Uninitialized_backout_al<xalloc<PS::CPGDef::SEffect *> >::_Emplace_back<PS::CPGDef::SEffect *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0SItem@CParticleGroup@PS@@QAE@XZ
_TEXT	SEGMENT
??0SItem@CParticleGroup@PS@@QAE@XZ PROC			; PS::CParticleGroup::SItem::SItem, COMDAT
; _this$ = ecx

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx+4], 0
	mov	eax, ecx
	mov	DWORD PTR [ecx+8], 0
	mov	DWORD PTR [ecx+12], 0
	mov	DWORD PTR [ecx+16], 0
	mov	DWORD PTR [ecx+20], 0
	mov	DWORD PTR [ecx+24], 0
	ret	0
??0SItem@CParticleGroup@PS@@QAE@XZ ENDP			; PS::CParticleGroup::SItem::SItem
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\type_traits
;	COMDAT ??$forward@USItem@CParticleGroup@PS@@@std@@YA$$QAUSItem@CParticleGroup@PS@@AAU123@@Z
_TEXT	SEGMENT
??$forward@USItem@CParticleGroup@PS@@@std@@YA$$QAUSItem@CParticleGroup@PS@@AAU123@@Z PROC ; std::forward<PS::CParticleGroup::SItem>, COMDAT
; __Arg$ = ecx

; 1386 :     return static_cast<_Ty&&>(_Arg);

	mov	eax, ecx

; 1387 : }

	ret	0
??$forward@USItem@CParticleGroup@PS@@@std@@YA$$QAUSItem@CParticleGroup@PS@@AAU123@@Z ENDP ; std::forward<PS::CParticleGroup::SItem>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$construct@USItem@CParticleGroup@PS@@U123@@?$_Normal_allocator_traits@V?$xalloc@USItem@CParticleGroup@PS@@@@@std@@SAXAAV?$xalloc@USItem@CParticleGroup@PS@@@@PAUSItem@CParticleGroup@PS@@$$QAU345@@Z
_TEXT	SEGMENT
_<_Args_0>$ = 8						; size = 4
??$construct@USItem@CParticleGroup@PS@@U123@@?$_Normal_allocator_traits@V?$xalloc@USItem@CParticleGroup@PS@@@@@std@@SAXAAV?$xalloc@USItem@CParticleGroup@PS@@@@PAUSItem@CParticleGroup@PS@@$$QAU345@@Z PROC ; std::_Normal_allocator_traits<xalloc<PS::CParticleGroup::SItem> >::construct<PS::CParticleGroup::SItem,PS::CParticleGroup::SItem>, COMDAT
; __Al$dead$ = ecx
; __Ptr$ = edx

; 564  :     static _CONSTEXPR20_DYNALLOC void construct(_Alloc& _Al, _Ty* _Ptr, _Types&&... _Args) {

	push	esi
	mov	esi, DWORD PTR _<_Args_0>$[esp]
	push	edi
	mov	edi, edx
	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [edi], eax
	lea	ecx, DWORD PTR [edi+4]
	lea	eax, DWORD PTR [esi+4]
	push	eax
	call	??0?$xr_vector@PAVIRender_Visual@@V?$xalloc@PAVIRender_Visual@@@@@@QAE@ABV0@@Z
	lea	eax, DWORD PTR [esi+16]
	push	eax
	lea	ecx, DWORD PTR [edi+16]
	call	??0?$xr_vector@PAVIRender_Visual@@V?$xalloc@PAVIRender_Visual@@@@@@QAE@ABV0@@Z
	pop	edi
	pop	esi

; 565  :         if constexpr (_Uses_default_construct<_Alloc, _Ty*, _Types...>::value) {
; 566  :             (void) _Al; // TRANSITION, DevCom-1004719
; 567  : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 568  :             _STD construct_at(_Ptr, _STD forward<_Types>(_Args)...);
; 569  : #else // __cpp_lib_constexpr_dynamic_alloc
; 570  :             ::new (static_cast<void*>(_Ptr)) _Ty(_STD forward<_Types>(_Args)...);
; 571  : #endif // __cpp_lib_constexpr_dynamic_alloc
; 572  :         } else {
; 573  :             _Al.construct(_Ptr, _STD forward<_Types>(_Args)...);
; 574  :         }
; 575  :     }

	ret	0
??$construct@USItem@CParticleGroup@PS@@U123@@?$_Normal_allocator_traits@V?$xalloc@USItem@CParticleGroup@PS@@@@@std@@SAXAAV?$xalloc@USItem@CParticleGroup@PS@@@@PAUSItem@CParticleGroup@PS@@$$QAU345@@Z ENDP ; std::_Normal_allocator_traits<xalloc<PS::CParticleGroup::SItem> >::construct<PS::CParticleGroup::SItem,PS::CParticleGroup::SItem>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\type_traits
;	COMDAT ??$forward@PAUSEffect@CPGDef@PS@@@std@@YA$$QAPAUSEffect@CPGDef@PS@@AAPAU123@@Z
_TEXT	SEGMENT
??$forward@PAUSEffect@CPGDef@PS@@@std@@YA$$QAPAUSEffect@CPGDef@PS@@AAPAU123@@Z PROC ; std::forward<PS::CPGDef::SEffect *>, COMDAT
; __Arg$ = ecx

; 1386 :     return static_cast<_Ty&&>(_Arg);

	mov	eax, ecx

; 1387 : }

	ret	0
??$forward@PAUSEffect@CPGDef@PS@@@std@@YA$$QAPAUSEffect@CPGDef@PS@@AAPAU123@@Z ENDP ; std::forward<PS::CPGDef::SEffect *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$construct@PAUSEffect@CPGDef@PS@@PAU123@@?$_Normal_allocator_traits@V?$xalloc@PAUSEffect@CPGDef@PS@@@@@std@@SAXAAV?$xalloc@PAUSEffect@CPGDef@PS@@@@PAPAUSEffect@CPGDef@PS@@$$QAPAU345@@Z
_TEXT	SEGMENT
_<_Args_0>$ = 8						; size = 4
??$construct@PAUSEffect@CPGDef@PS@@PAU123@@?$_Normal_allocator_traits@V?$xalloc@PAUSEffect@CPGDef@PS@@@@@std@@SAXAAV?$xalloc@PAUSEffect@CPGDef@PS@@@@PAPAUSEffect@CPGDef@PS@@$$QAPAU345@@Z PROC ; std::_Normal_allocator_traits<xalloc<PS::CPGDef::SEffect *> >::construct<PS::CPGDef::SEffect *,PS::CPGDef::SEffect *>, COMDAT
; __Al$dead$ = ecx
; __Ptr$ = edx

; 565  :         if constexpr (_Uses_default_construct<_Alloc, _Ty*, _Types...>::value) {
; 566  :             (void) _Al; // TRANSITION, DevCom-1004719
; 567  : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 568  :             _STD construct_at(_Ptr, _STD forward<_Types>(_Args)...);
; 569  : #else // __cpp_lib_constexpr_dynamic_alloc
; 570  :             ::new (static_cast<void*>(_Ptr)) _Ty(_STD forward<_Types>(_Args)...);
; 571  : #endif // __cpp_lib_constexpr_dynamic_alloc
; 572  :         } else {
; 573  :             _Al.construct(_Ptr, _STD forward<_Types>(_Args)...);

	mov	eax, DWORD PTR _<_Args_0>$[esp-4]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edx], eax

; 574  :         }
; 575  :     }

	ret	0
??$construct@PAUSEffect@CPGDef@PS@@PAU123@@?$_Normal_allocator_traits@V?$xalloc@PAUSEffect@CPGDef@PS@@@@@std@@SAXAAV?$xalloc@PAUSEffect@CPGDef@PS@@@@PAPAUSEffect@CPGDef@PS@@$$QAPAU345@@Z ENDP ; std::_Normal_allocator_traits<xalloc<PS::CPGDef::SEffect *> >::construct<PS::CPGDef::SEffect *,PS::CPGDef::SEffect *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?construct@?$xalloc@USItem@CParticleGroup@PS@@@@QAEXPAUSItem@CParticleGroup@PS@@ABU234@@Z
_TEXT	SEGMENT
_p$ = 8							; size = 4
__Val$ = 12						; size = 4
?construct@?$xalloc@USItem@CParticleGroup@PS@@@@QAEXPAUSItem@CParticleGroup@PS@@ABU234@@Z PROC ; xalloc<PS::CParticleGroup::SItem>::construct, COMDAT
; _this$dead$ = ecx

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	push	esi
	mov	esi, DWORD PTR __Val$[esp]
	push	edi
	mov	edi, DWORD PTR _p$[esp+4]
	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [edi], eax
	lea	ecx, DWORD PTR [edi+4]
	lea	eax, DWORD PTR [esi+4]
	push	eax
	call	??0?$xr_vector@PAVIRender_Visual@@V?$xalloc@PAVIRender_Visual@@@@@@QAE@ABV0@@Z
	lea	eax, DWORD PTR [esi+16]
	push	eax
	lea	ecx, DWORD PTR [edi+16]
	call	??0?$xr_vector@PAVIRender_Visual@@V?$xalloc@PAVIRender_Visual@@@@@@QAE@ABV0@@Z
	pop	edi
	pop	esi
	ret	8
?construct@?$xalloc@USItem@CParticleGroup@PS@@@@QAEXPAUSItem@CParticleGroup@PS@@ABU234@@Z ENDP ; xalloc<PS::CParticleGroup::SItem>::construct
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?construct@?$xalloc@PAUSEffect@CPGDef@PS@@@@QAEXPAPAUSEffect@CPGDef@PS@@ABQAU234@@Z
_TEXT	SEGMENT
_p$ = 8							; size = 4
__Val$ = 12						; size = 4
?construct@?$xalloc@PAUSEffect@CPGDef@PS@@@@QAEXPAPAUSEffect@CPGDef@PS@@ABQAU234@@Z PROC ; xalloc<PS::CPGDef::SEffect *>::construct, COMDAT
; _this$dead$ = ecx

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	eax, DWORD PTR __Val$[esp-4]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR _p$[esp-4]
	mov	DWORD PTR [eax], ecx
	ret	8
?construct@?$xalloc@PAUSEffect@CPGDef@PS@@@@QAEXPAPAUSEffect@CPGDef@PS@@ABQAU234@@Z ENDP ; xalloc<PS::CPGDef::SEffect *>::construct
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ??0SItem@CParticleGroup@PS@@QAE@ABU012@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0SItem@CParticleGroup@PS@@QAE@ABU012@@Z PROC		; PS::CParticleGroup::SItem::SItem, COMDAT
; _this$ = ecx
	push	esi
	mov	esi, DWORD PTR ___that$[esp]
	push	edi
	mov	edi, ecx
	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [edi], eax
	lea	ecx, DWORD PTR [edi+4]
	lea	eax, DWORD PTR [esi+4]
	push	eax
	call	??0?$xr_vector@PAVIRender_Visual@@V?$xalloc@PAVIRender_Visual@@@@@@QAE@ABV0@@Z
	lea	eax, DWORD PTR [esi+16]
	push	eax
	lea	ecx, DWORD PTR [edi+16]
	call	??0?$xr_vector@PAVIRender_Visual@@V?$xalloc@PAVIRender_Visual@@@@@@QAE@ABV0@@Z
	mov	eax, edi
	pop	edi
	pop	esi
	ret	4
??0SItem@CParticleGroup@PS@@QAE@ABU012@@Z ENDP		; PS::CParticleGroup::SItem::SItem
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0?$xr_vector@PAVIRender_Visual@@V?$xalloc@PAVIRender_Visual@@@@@@QAE@ABV0@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0?$xr_vector@PAVIRender_Visual@@V?$xalloc@PAVIRender_Visual@@@@@@QAE@ABV0@@Z PROC ; xr_vector<IRender_Visual *,xalloc<IRender_Visual *> >::xr_vector<IRender_Visual *,xalloc<IRender_Visual *> >, COMDAT
; _this$ = ecx

; 546  :         const pointer _Rightfirst = _Right_data._Myfirst;

	mov	eax, DWORD PTR ___that$[esp-4]

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	push	ebx
	mov	ebx, ecx
	push	ebp
	push	esi
	mov	DWORD PTR [ebx], 0
	mov	DWORD PTR [ebx+4], 0
	mov	DWORD PTR [ebx+8], 0

; 546  :         const pointer _Rightfirst = _Right_data._Myfirst;

	mov	esi, DWORD PTR [eax]

; 547  :         const pointer _Rightlast  = _Right_data._Mylast;

	mov	ebp, DWORD PTR [eax+4]

; 548  :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);
; 549  :         if (_Rightfirst != _Rightlast) {

	cmp	esi, ebp
	je	SHORT $LN44@xr_vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 550  :             _Buy_raw(static_cast<size_type>(_Rightlast - _Rightfirst));

	mov	eax, ebp
	sub	eax, esi
	sar	eax, 2
	push	edi
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	lea	edi, DWORD PTR [eax*4]
	push	edi
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1698 :         const auto _Newvec = _Getal().allocate(_Newcapacity);

	mov	edx, eax

; 1699 :         _Myfirst           = _Newvec;

	mov	DWORD PTR [ebx], edx

; 1700 :         _Mylast            = _Newvec;

	mov	DWORD PTR [ebx+4], edx

; 1701 :         _Myend             = _Newvec + _Newcapacity;

	lea	ecx, DWORD PTR [edi+edx]
	mov	DWORD PTR [ebx+8], ecx
	pop	edi
$LL21@xr_vector:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1620 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

	mov	eax, DWORD PTR [esi]

; 1658 :     for (; _UFirst != _ULast; ++_UFirst) {

	add	esi, 4

; 1620 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

	mov	DWORD PTR [edx], eax

; 1621 :         ++_Last;

	add	edx, 4

; 1658 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	esi, ebp
	jne	SHORT $LL21@xr_vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 552  :             _My_data._Mylast = _Ucopy(_Rightfirst, _Rightlast, _My_data._Myfirst);

	mov	DWORD PTR [ebx+4], edx
$LN44@xr_vector:
	pop	esi
	pop	ebp
	mov	eax, ebx
	pop	ebx
	ret	4
??0?$xr_vector@PAVIRender_Visual@@V?$xalloc@PAVIRender_Visual@@@@@@QAE@ABV0@@Z ENDP ; xr_vector<IRender_Visual *,xalloc<IRender_Visual *> >::xr_vector<IRender_Visual *,xalloc<IRender_Visual *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0?$vector@PAVIRender_Visual@@V?$xalloc@PAVIRender_Visual@@@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??0?$vector@PAVIRender_Visual@@V?$xalloc@PAVIRender_Visual@@@@@std@@QAE@ABV01@@Z PROC ; std::vector<IRender_Visual *,xalloc<IRender_Visual *> >::vector<IRender_Visual *,xalloc<IRender_Visual *> >, COMDAT
; _this$ = ecx

; 543  :         auto&& _Alproxy           = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 544  :         auto& _My_data            = _Mypair._Myval2;
; 545  :         const auto& _Right_data   = _Right._Mypair._Myval2;
; 546  :         const pointer _Rightfirst = _Right_data._Myfirst;

	mov	eax, DWORD PTR __Right$[esp-4]
	push	ebx
	mov	ebx, ecx
	push	ebp
	push	esi

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ebx], 0
	mov	DWORD PTR [ebx+4], 0
	mov	DWORD PTR [ebx+8], 0

; 543  :         auto&& _Alproxy           = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 544  :         auto& _My_data            = _Mypair._Myval2;
; 545  :         const auto& _Right_data   = _Right._Mypair._Myval2;
; 546  :         const pointer _Rightfirst = _Right_data._Myfirst;

	mov	esi, DWORD PTR [eax]

; 547  :         const pointer _Rightlast  = _Right_data._Mylast;

	mov	ebp, DWORD PTR [eax+4]

; 548  :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);
; 549  :         if (_Rightfirst != _Rightlast) {

	cmp	esi, ebp
	je	SHORT $LN42@vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 550  :             _Buy_raw(static_cast<size_type>(_Rightlast - _Rightfirst));

	mov	eax, ebp
	sub	eax, esi
	sar	eax, 2
	push	edi
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	lea	edi, DWORD PTR [eax*4]
	push	edi
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1698 :         const auto _Newvec = _Getal().allocate(_Newcapacity);

	mov	edx, eax

; 1699 :         _Myfirst           = _Newvec;

	mov	DWORD PTR [ebx], edx

; 1700 :         _Mylast            = _Newvec;

	mov	DWORD PTR [ebx+4], edx

; 1701 :         _Myend             = _Newvec + _Newcapacity;

	lea	ecx, DWORD PTR [edi+edx]
	mov	DWORD PTR [ebx+8], ecx
	pop	edi
$LL19@vector:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1620 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

	mov	eax, DWORD PTR [esi]

; 1658 :     for (; _UFirst != _ULast; ++_UFirst) {

	add	esi, 4

; 1620 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

	mov	DWORD PTR [edx], eax

; 1621 :         ++_Last;

	add	edx, 4

; 1658 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	esi, ebp
	jne	SHORT $LL19@vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 552  :             _My_data._Mylast = _Ucopy(_Rightfirst, _Rightlast, _My_data._Myfirst);

	mov	DWORD PTR [ebx+4], edx
$LN42@vector:
	pop	esi

; 553  :             _Guard._Target   = nullptr;
; 554  :         }
; 555  : 
; 556  :         _Proxy._Release();
; 557  :     }

	pop	ebp
	mov	eax, ebx
	pop	ebx
	ret	4
??0?$vector@PAVIRender_Visual@@V?$xalloc@PAVIRender_Visual@@@@@std@@QAE@ABV01@@Z ENDP ; std::vector<IRender_Visual *,xalloc<IRender_Visual *> >::vector<IRender_Visual *,xalloc<IRender_Visual *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??1?$_Tidy_guard@V?$vector@PAVIRender_Visual@@V?$xalloc@PAVIRender_Visual@@@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Tidy_guard@V?$vector@PAVIRender_Visual@@V?$xalloc@PAVIRender_Visual@@@@@std@@@std@@QAE@XZ PROC ; std::_Tidy_guard<std::vector<IRender_Visual *,xalloc<IRender_Visual *> > >::~_Tidy_guard<std::vector<IRender_Visual *,xalloc<IRender_Visual *> > >, COMDAT
; _this$ = ecx

; 33   :     _CONSTEXPR20_DYNALLOC ~_Tidy_guard() {

	push	esi

; 34   :         if (_Target) {

	mov	esi, DWORD PTR [ecx]
	test	esi, esi
	je	SHORT $LN5@Tidy_guard
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN5@Tidy_guard
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+4], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+8], 0
$LN5@Tidy_guard:
	pop	esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 37   :     }

	ret	0
??1?$_Tidy_guard@V?$vector@PAVIRender_Visual@@V?$xalloc@PAVIRender_Visual@@@@@std@@@std@@QAE@XZ ENDP ; std::_Tidy_guard<std::vector<IRender_Visual *,xalloc<IRender_Visual *> > >::~_Tidy_guard<std::vector<IRender_Visual *,xalloc<IRender_Visual *> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Buy_raw@?$vector@PAVIRender_Visual@@V?$xalloc@PAVIRender_Visual@@@@@std@@AAEXI@Z
_TEXT	SEGMENT
__Newcapacity$ = 8					; size = 4
?_Buy_raw@?$vector@PAVIRender_Visual@@V?$xalloc@PAVIRender_Visual@@@@@std@@AAEXI@Z PROC ; std::vector<IRender_Visual *,xalloc<IRender_Visual *> >::_Buy_raw, COMDAT
; _this$ = ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	mov	eax, DWORD PTR __Newcapacity$[esp-4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1688 :     _CONSTEXPR20_CONTAINER void _Buy_raw(const size_type _Newcapacity) {

	push	esi
	push	edi
	mov	edi, ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	lea	esi, DWORD PTR [eax*4]
	push	esi
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1699 :         _Myfirst           = _Newvec;

	mov	DWORD PTR [edi], eax

; 1700 :         _Mylast            = _Newvec;

	mov	DWORD PTR [edi+4], eax

; 1701 :         _Myend             = _Newvec + _Newcapacity;

	add	eax, esi
	mov	DWORD PTR [edi+8], eax
	pop	edi
	pop	esi

; 1702 :     }

	ret	4
?_Buy_raw@?$vector@PAVIRender_Visual@@V?$xalloc@PAVIRender_Visual@@@@@std@@AAEXI@Z ENDP ; std::vector<IRender_Visual *,xalloc<IRender_Visual *> >::_Buy_raw
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?select_on_container_copy_construction@?$_Normal_allocator_traits@V?$xalloc@PAVIRender_Visual@@@@@std@@SA?AV?$xalloc@PAVIRender_Visual@@@@ABV3@@Z
_TEXT	SEGMENT
?select_on_container_copy_construction@?$_Normal_allocator_traits@V?$xalloc@PAVIRender_Visual@@@@@std@@SA?AV?$xalloc@PAVIRender_Visual@@@@ABV3@@Z PROC ; std::_Normal_allocator_traits<xalloc<IRender_Visual *> >::select_on_container_copy_construction, COMDAT
; ___$ReturnUdt$ = ecx
; __Al$dead$ = edx

; 599  :         if constexpr (_Has_select_on_container_copy_construction<_Alloc>::value) {
; 600  :             return _Al.select_on_container_copy_construction();
; 601  :         } else {
; 602  :             return _Al;

	mov	eax, ecx

; 603  :         }
; 604  :     }

	ret	0
?select_on_container_copy_construction@?$_Normal_allocator_traits@V?$xalloc@PAVIRender_Visual@@@@@std@@SA?AV?$xalloc@PAVIRender_Visual@@@@ABV3@@Z ENDP ; std::_Normal_allocator_traits<xalloc<IRender_Visual *> >::select_on_container_copy_construction
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ??0?$xalloc@PAVIRender_Visual@@@@QAE@ABV0@@Z
_TEXT	SEGMENT
___formal$dead$ = 8					; size = 4
??0?$xalloc@PAVIRender_Visual@@@@QAE@ABV0@@Z PROC	; xalloc<IRender_Visual *>::xalloc<IRender_Visual *>, COMDAT
; _this$ = ecx

; 77   : 													xalloc			(const xalloc<T>&)						{	}

	mov	eax, ecx
	ret	4
??0?$xalloc@PAVIRender_Visual@@@@QAE@ABV0@@Z ENDP	; xalloc<IRender_Visual *>::xalloc<IRender_Visual *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$?0V?$xalloc@PAVIRender_Visual@@@@$$V@?$_Compressed_pair@V?$xalloc@PAVIRender_Visual@@@@V?$_Vector_val@U?$_Simple_types@PAVIRender_Visual@@@std@@@std@@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAV?$xalloc@PAVIRender_Visual@@@@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
__Val1$dead$ = 12					; size = 4
??$?0V?$xalloc@PAVIRender_Visual@@@@$$V@?$_Compressed_pair@V?$xalloc@PAVIRender_Visual@@@@V?$_Vector_val@U?$_Simple_types@PAVIRender_Visual@@@std@@@std@@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAV?$xalloc@PAVIRender_Visual@@@@@Z PROC ; std::_Compressed_pair<xalloc<IRender_Visual *>,std::_Vector_val<std::_Simple_types<IRender_Visual *> >,1>::_Compressed_pair<xalloc<IRender_Visual *>,std::_Vector_val<std::_Simple_types<IRender_Visual *> >,1><xalloc<IRender_Visual *> >, COMDAT
; _this$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1336 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	eax, ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1336 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	ret	8
??$?0V?$xalloc@PAVIRender_Visual@@@@$$V@?$_Compressed_pair@V?$xalloc@PAVIRender_Visual@@@@V?$_Vector_val@U?$_Simple_types@PAVIRender_Visual@@@std@@@std@@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAV?$xalloc@PAVIRender_Visual@@@@@Z ENDP ; std::_Compressed_pair<xalloc<IRender_Visual *>,std::_Vector_val<std::_Simple_types<IRender_Visual *> >,1>::_Compressed_pair<xalloc<IRender_Visual *>,std::_Vector_val<std::_Simple_types<IRender_Visual *> >,1><xalloc<IRender_Visual *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\type_traits
;	COMDAT ??$forward@V?$xalloc@PAVIRender_Visual@@@@@std@@YA$$QAV?$xalloc@PAVIRender_Visual@@@@AAV1@@Z
_TEXT	SEGMENT
??$forward@V?$xalloc@PAVIRender_Visual@@@@@std@@YA$$QAV?$xalloc@PAVIRender_Visual@@@@AAV1@@Z PROC ; std::forward<xalloc<IRender_Visual *> >, COMDAT
; __Arg$ = ecx

; 1386 :     return static_cast<_Ty&&>(_Arg);

	mov	eax, ecx

; 1387 : }

	ret	0
??$forward@V?$xalloc@PAVIRender_Visual@@@@@std@@YA$$QAV?$xalloc@PAVIRender_Visual@@@@AAV1@@Z ENDP ; std::forward<xalloc<IRender_Visual *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xrstring.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.h
;	COMDAT ?Name@CParticleGroup@PS@@UAE?BVshared_str@@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?Name@CParticleGroup@PS@@UAE?BVshared_str@@XZ PROC	; PS::CParticleGroup::Name, COMDAT
; _this$ = ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\xrstring.h

; 53   : 	void				_set		(shared_str const &rhs)			{	str_value* v = rhs.p_; if (0!=v) v->dwReference++; _dec(); p_ = v;							}

	mov	eax, DWORD PTR [ecx+72]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx
	test	ecx, ecx
	je	SHORT $LN9@Name
	inc	DWORD PTR [ecx]
$LN9@Name:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.h

; 137  : 		virtual const shared_str	Name		(){VERIFY(m_Def); return m_Def->m_Name;}

	ret	4
?Name@CParticleGroup@PS@@UAE?BVshared_str@@XZ ENDP	; PS::CParticleGroup::Name
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.h
;	COMDAT ?GetTimeLimit@CParticleGroup@PS@@UAEMXZ
_TEXT	SEGMENT
?GetTimeLimit@CParticleGroup@PS@@UAEMXZ PROC		; PS::CParticleGroup::GetTimeLimit, COMDAT
; _this$ = ecx

; 135  : 		virtual float		GetTimeLimit	(){VERIFY(m_Def); return m_Def->m_fTimeLimit;}

	mov	eax, DWORD PTR [ecx+72]
	fld	DWORD PTR [eax+8]
	ret	0
?GetTimeLimit@CParticleGroup@PS@@UAEMXZ ENDP		; PS::CParticleGroup::GetTimeLimit
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_flags.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.h
;	COMDAT ?IsPlaying@CParticleGroup@PS@@UAEHXZ
_TEXT	SEGMENT
?IsPlaying@CParticleGroup@PS@@UAEHXZ PROC		; PS::CParticleGroup::IsPlaying, COMDAT
; _this$ = ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\_flags.h

; 23   : 	IC 	BOOL	is		(const T mask)						const	{ return mask==(flags&mask);			}

	movzx	eax, BYTE PTR [ecx+104]
	and	eax, 1
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.h

; 133  : 		virtual BOOL		IsPlaying		(){return m_RT_Flags.is(flRT_Playing);}

	ret	0
?IsPlaying@CParticleGroup@PS@@UAEHXZ ENDP		; PS::CParticleGroup::IsPlaying
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.h
;	COMDAT ?Copy@CParticleGroup@PS@@UAEXPAVIRender_Visual@@@Z
_TEXT	SEGMENT
_pFrom$ = 8						; size = 4
?Copy@CParticleGroup@PS@@UAEXPAVIRender_Visual@@@Z PROC	; PS::CParticleGroup::Copy, COMDAT
; _this$ = ecx

; 120  : 		virtual void		Copy			(IRender_Visual* pFrom) {FATAL("Can't duplicate particle system - NOT IMPLEMENTED");}

	push	OFFSET ??_C@_0DC@EAPNALPN@Can?8t?5duplicate?5particle?5system@
	push	OFFSET ??_C@_0BJ@DIJHBDKI@PS?3?3CParticleGroup?3?3Copy@
	push	120					; 00000078H
	push	OFFSET ??_C@_0DL@JMPOGBPO@I?3?2Vitalya?2mine?2NSProjectX?2laye@
	push	DWORD PTR __imp_?Debug@@3VxrDebug@@A
	call	DWORD PTR __imp_?fatal@xrDebug@@QAAXPBDH00ZZ
	add	esp, 20					; 00000014H
	ret	4
?Copy@CParticleGroup@PS@@UAEXPAVIRender_Visual@@@Z ENDP	; PS::CParticleGroup::Copy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xrstring.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xrstring.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_flags.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.h
;	COMDAT ??0SEffect@CPGDef@PS@@QAE@XZ
_TEXT	SEGMENT
??0SEffect@CPGDef@PS@@QAE@XZ PROC			; PS::CPGDef::SEffect::SEffect, COMDAT
; _this$ = ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\xrstring.h

; 57   : 						shared_str	()								{	p_ = 0;											}

	mov	DWORD PTR [ecx+4], 0
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.h

; 33   : 							SEffect				(){m_Flags.zero();/*set(flEnabled)*/m_Time0=0;m_Time1=0;}

	mov	eax, ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\xrstring.h

; 57   : 						shared_str	()								{	p_ = 0;											}

	mov	DWORD PTR [ecx+8], 0
	mov	DWORD PTR [ecx+12], 0
	mov	DWORD PTR [ecx+16], 0
; File I:\Vitalya\mine\NSProjectX\xrCore\_flags.h

; 15   :     IC	SelfRef	zero	()											{ flags=T(0);	return *this;	}

	mov	DWORD PTR [ecx], 0
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.h

; 33   : 							SEffect				(){m_Flags.zero();/*set(flEnabled)*/m_Time0=0;m_Time1=0;}

	mov	DWORD PTR [ecx+20], 0
	mov	DWORD PTR [ecx+24], 0
	ret	0
??0SEffect@CPGDef@PS@@QAE@XZ ENDP			; PS::CPGDef::SEffect::SEffect
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
;	COMDAT ?translate@?$_matrix@M@@QAEAAU1@ABU?$_vector3@M@@@Z
_TEXT	SEGMENT
_Loc$ = 8						; size = 4
?translate@?$_matrix@M@@QAEAAU1@ABU?$_vector3@M@@@Z PROC ; _matrix<float>::translate, COMDAT
; _this$ = ecx

; 235  : 		identity();	c.set	(Loc.x,Loc.y,Loc.z);	

	mov	eax, DWORD PTR _Loc$[esp-4]

; 75   : 		_41=0; _42=0; _43=0; _44=1;

	mov	DWORD PTR [ecx+48], 0
	mov	DWORD PTR [ecx+52], 0
	mov	DWORD PTR [ecx+56], 0
	mov	DWORD PTR [ecx], 1065353216		; 3f800000H
	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0
	mov	DWORD PTR [ecx+12], 0
	mov	DWORD PTR [ecx+16], 0
	mov	DWORD PTR [ecx+20], 1065353216		; 3f800000H
	mov	DWORD PTR [ecx+24], 0
	mov	DWORD PTR [ecx+28], 0
	mov	DWORD PTR [ecx+32], 0
	mov	DWORD PTR [ecx+36], 0
	mov	DWORD PTR [ecx+40], 1065353216		; 3f800000H
	mov	DWORD PTR [ecx+44], 0
	mov	DWORD PTR [ecx+60], 1065353216		; 3f800000H

; 235  : 		identity();	c.set	(Loc.x,Loc.y,Loc.z);	

	movss	xmm0, DWORD PTR [eax+4]
	movss	xmm1, DWORD PTR [eax+8]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 23   : 	ICF	SelfRef	set(T _x, T _y, T _z)					{ x = _x;		y = _y;		z = _z;		return *this;	};

	fld	DWORD PTR [eax]
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 236  : 		return *this;

	mov	eax, ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 23   : 	ICF	SelfRef	set(T _x, T _y, T _z)					{ x = _x;		y = _y;		z = _z;		return *this;	};

	fstp	DWORD PTR [ecx+48]
	movss	DWORD PTR [ecx+52], xmm0
	movss	DWORD PTR [ecx+56], xmm1
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 237  : 	}

	ret	4
?translate@?$_matrix@M@@QAEAAU1@ABU?$_vector3@M@@@Z ENDP ; _matrix<float>::translate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleEffect.h
;	COMDAT ?GetHandleEffect@CParticleEffect@PS@@QAEHXZ
_TEXT	SEGMENT
?GetHandleEffect@CParticleEffect@PS@@QAEHXZ PROC	; PS::CParticleEffect::GetHandleEffect, COMDAT
; _this$ = ecx

; 59   : 		IC int				GetHandleEffect		(){return m_HandleEffect;}

	mov	eax, DWORD PTR [ecx+80]
	ret	0
?GetHandleEffect@CParticleEffect@PS@@QAEHXZ ENDP	; PS::CParticleEffect::GetHandleEffect
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.h
;	COMDAT ?GetDefinition@CParticleGroup@PS@@QAEPBVCPGDef@2@XZ
_TEXT	SEGMENT
?GetDefinition@CParticleGroup@PS@@QAEPBVCPGDef@2@XZ PROC ; PS::CParticleGroup::GetDefinition, COMDAT
; _this$ = ecx

; 129  : 		const CPGDef*		GetDefinition	(){return m_Def;}

	mov	eax, DWORD PTR [ecx+72]
	ret	0
?GetDefinition@CParticleGroup@PS@@QAEPBVCPGDef@2@XZ ENDP ; PS::CParticleGroup::GetDefinition
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Reallocate_exactly@?$vector@PAVIRender_Visual@@V?$xalloc@PAVIRender_Visual@@@@@std@@AAEXI@Z
_TEXT	SEGMENT
__Newvec$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
tv218 = 8						; size = 4
__Newcapacity$ = 8					; size = 4
?_Reallocate_exactly@?$vector@PAVIRender_Visual@@V?$xalloc@PAVIRender_Visual@@@@@std@@AAEXI@Z PROC ; std::vector<IRender_Visual *,xalloc<IRender_Visual *> >::_Reallocate_exactly, COMDAT
; _this$ = ecx

; 1286 :     _CONSTEXPR20_CONTAINER void _Reallocate_exactly(const size_type _Newcapacity) {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Reallocate_exactly@?$vector@PAVIRender_Visual@@V?$xalloc@PAVIRender_Visual@@@@@std@@AAEXI@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 8
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	esi, ecx

; 1287 :         // set capacity to _Newcapacity (without geometric growth), provide strong guarantee
; 1288 :         auto& _My_data    = _Mypair._Myval2;
; 1289 :         pointer& _Myfirst = _My_data._Myfirst;
; 1290 :         pointer& _Mylast  = _My_data._Mylast;
; 1291 : 
; 1292 :         const auto _Size = static_cast<size_type>(_Mylast - _Myfirst);

	mov	ebx, DWORD PTR [esi+4]
	sub	ebx, DWORD PTR [esi]
	sar	ebx, 2
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	mov	eax, DWORD PTR __Newcapacity$[ebp]
	shl	eax, 2
	mov	DWORD PTR tv218[ebp], eax
	push	eax
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1294 :         const pointer _Newvec = _Getal().allocate(_Newcapacity);

	mov	edi, eax
	mov	DWORD PTR __Newvec$[ebp], edi

; 1295 : 
; 1296 :         _TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 1297 :         _Umove_if_noexcept(_Myfirst, _Mylast, _Newvec);

	push	edi
	push	DWORD PTR [esi+4]
	push	DWORD PTR [esi]
	call	?_Umove_if_noexcept@?$vector@PAVIRender_Visual@@V?$xalloc@PAVIRender_Visual@@@@@std@@AAEXPAPAVIRender_Visual@@00@Z ; std::vector<IRender_Visual *,xalloc<IRender_Visual *> >::_Umove_if_noexcept
	mov	DWORD PTR __$EHRec$[ebp+12], -1

; 1732 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN18@Reallocate
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	push	eax
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN18@Reallocate:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1737 :         _Myfirst = _Newvec;

	mov	DWORD PTR [esi], edi

; 1738 :         _Mylast  = _Newvec + _Newsize;

	lea	eax, DWORD PTR [edi+ebx*4]
	mov	DWORD PTR [esi+4], eax

; 1739 :         _Myend   = _Newvec + _Newcapacity;

	mov	eax, DWORD PTR tv218[ebp]
	add	eax, edi
	mov	DWORD PTR [esi+8], eax

; 1301 :         _CATCH_END
; 1302 : 
; 1303 :         _Change_array(_Newvec, _Size, _Newcapacity);
; 1304 :     }

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
__catch$?_Reallocate_exactly@?$vector@PAVIRender_Visual@@V?$xalloc@PAVIRender_Visual@@@@@std@@AAEXI@Z$0:

; 1298 :         _CATCH_ALL
; 1299 :         _Getal().deallocate(_Newvec, _Newcapacity);

	push	ecx
	push	DWORD PTR __Newvec$[ebp]
	call	?deallocate@?$xalloc@PAVIRender_Visual@@@@QBEXPAPAVIRender_Visual@@I@Z ; xalloc<IRender_Visual *>::deallocate

; 1300 :         _RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$LN21@Reallocate:
	int	3
	int	3
	int	3
	int	3
	int	3
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Reallocate_exactly@?$vector@PAVIRender_Visual@@V?$xalloc@PAVIRender_Visual@@@@@std@@AAEXI@Z:
	npad	1
	npad	1
	mov	eax, OFFSET __ehfuncinfo$?_Reallocate_exactly@?$vector@PAVIRender_Visual@@V?$xalloc@PAVIRender_Visual@@@@@std@@AAEXI@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Reallocate_exactly@?$vector@PAVIRender_Visual@@V?$xalloc@PAVIRender_Visual@@@@@std@@AAEXI@Z ENDP ; std::vector<IRender_Visual *,xalloc<IRender_Visual *> >::_Reallocate_exactly
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?reserve@?$vector@PAVIRender_Visual@@V?$xalloc@PAVIRender_Visual@@@@@std@@QAEXI@Z
_TEXT	SEGMENT
__Newcapacity$ = 8					; size = 4
?reserve@?$vector@PAVIRender_Visual@@V?$xalloc@PAVIRender_Visual@@@@@std@@QAEXI@Z PROC ; std::vector<IRender_Visual *,xalloc<IRender_Visual *> >::reserve, COMDAT
; _this$ = ecx

; 1546 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx]

; 1357 :         // increase capacity to _Newcapacity (without geometric growth), provide strong guarantee
; 1358 :         if (_Newcapacity > capacity()) { // something to do (reserve() never shrinks)

	mov	edx, DWORD PTR __Newcapacity$[esp-4]

; 1546 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	sar	eax, 2

; 1357 :         // increase capacity to _Newcapacity (without geometric growth), provide strong guarantee
; 1358 :         if (_Newcapacity > capacity()) { // something to do (reserve() never shrinks)

	cmp	edx, eax
	jbe	SHORT $LN2@reserve

; 1359 :             if (_Newcapacity > max_size()) {

	cmp	edx, 1073741823				; 3fffffffH
	ja	SHORT $LN9@reserve

; 1361 :             }
; 1362 : 
; 1363 :             _Reallocate_exactly(_Newcapacity);

	mov	DWORD PTR __Newcapacity$[esp-4], edx
	jmp	?_Reallocate_exactly@?$vector@PAVIRender_Visual@@V?$xalloc@PAVIRender_Visual@@@@@std@@AAEXI@Z ; std::vector<IRender_Visual *,xalloc<IRender_Visual *> >::_Reallocate_exactly
$LN2@reserve:

; 1364 :         }
; 1365 :     }

	ret	4
$LN9@reserve:

; 1360 :                 _Xlength();

	call	?_Xlength@?$vector@PAVIRender_Visual@@V?$xalloc@PAVIRender_Visual@@@@@std@@CAXXZ ; std::vector<IRender_Visual *,xalloc<IRender_Visual *> >::_Xlength
$LN7@reserve:
	int	3
?reserve@?$vector@PAVIRender_Visual@@V?$xalloc@PAVIRender_Visual@@@@@std@@QAEXI@Z ENDP ; std::vector<IRender_Visual *,xalloc<IRender_Visual *> >::reserve
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_Adl_verify_range@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVIRender_Visual@@@std@@@std@@@std@@V12@@std@@YAXABV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVIRender_Visual@@@std@@@std@@@0@0@Z
_TEXT	SEGMENT
??$_Adl_verify_range@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVIRender_Visual@@@std@@@std@@@std@@V12@@std@@YAXABV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVIRender_Visual@@@std@@@std@@@0@0@Z PROC ; std::_Adl_verify_range<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<IRender_Visual *> > >,std::_Vector_iterator<std::_Vector_val<std::_Simple_types<IRender_Visual *> > > >, COMDAT
; __First$dead$ = ecx
; __Last$dead$ = edx

; 1259 :     // check that [_First, _Last) forms an iterator range
; 1260 :     if constexpr (_Range_verifiable_v<_Iter, _Sentinel>) {
; 1261 :         _Verify_range(_First, _Last);
; 1262 :     }
; 1263 : }

	ret	0
??$_Adl_verify_range@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVIRender_Visual@@@std@@@std@@@std@@V12@@std@@YAXABV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVIRender_Visual@@@std@@@std@@@0@0@Z ENDP ; std::_Adl_verify_range<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<IRender_Visual *> > >,std::_Vector_iterator<std::_Vector_val<std::_Simple_types<IRender_Visual *> > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$distance@PAPAVIRender_Visual@@@std@@YAHPAPAVIRender_Visual@@0@Z
_TEXT	SEGMENT
??$distance@PAPAVIRender_Visual@@@std@@YAHPAPAVIRender_Visual@@0@Z PROC ; std::distance<IRender_Visual * *>, COMDAT
; __First$ = ecx
; __Last$ = edx

; 1524 :     if constexpr (_Is_random_iter_v<_InIt>) {
; 1525 :         return _Last - _First; // assume the iterator will do debug checking

	sub	edx, ecx
	sar	edx, 2
	mov	eax, edx

; 1526 :     } else {
; 1527 :         _Adl_verify_range(_First, _Last);
; 1528 :         auto _UFirst             = _Get_unwrapped(_First);
; 1529 :         const auto _ULast        = _Get_unwrapped(_Last);
; 1530 :         _Iter_diff_t<_InIt> _Off = 0;
; 1531 :         for (; _UFirst != _ULast; ++_UFirst) {
; 1532 :             ++_Off;
; 1533 :         }
; 1534 : 
; 1535 :         return _Off;
; 1536 :     }
; 1537 : }

	ret	0
??$distance@PAPAVIRender_Visual@@@std@@YAHPAPAVIRender_Visual@@0@Z ENDP ; std::distance<IRender_Visual * *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_Copy_backward_memmove@PAPAVIRender_Visual@@PAPAV1@@std@@YAPAPAVIRender_Visual@@PAPAV1@00@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
??$_Copy_backward_memmove@PAPAVIRender_Visual@@PAPAV1@@std@@YAPAPAVIRender_Visual@@PAPAV1@00@Z PROC ; std::_Copy_backward_memmove<IRender_Visual * *,IRender_Visual * *>, COMDAT
; __First$ = ecx
; __Last$ = edx

; 4247 :     // implement copy_backward-like function as memmove
; 4248 :     auto _FirstPtr              = _To_address(_First);
; 4249 :     auto _LastPtr               = _To_address(_Last);
; 4250 :     auto _DestPtr               = _To_address(_Dest);
; 4251 :     const char* const _First_ch = const_cast<const char*>(reinterpret_cast<const volatile char*>(_FirstPtr));
; 4252 :     const char* const _Last_ch  = const_cast<const char*>(reinterpret_cast<const volatile char*>(_LastPtr));
; 4253 :     char* const _Dest_ch        = const_cast<char*>(reinterpret_cast<const volatile char*>(_DestPtr));
; 4254 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);
; 4255 :     auto _Result                = _CSTD memmove(_Dest_ch - _Count, _First_ch, _Count);

	mov	eax, DWORD PTR __Dest$[esp-4]
	sub	edx, ecx
	push	edx
	push	ecx
	sub	eax, edx
	push	eax
	call	_memmove
	add	esp, 12					; 0000000cH

; 4256 :     if constexpr (is_pointer_v<_CtgIt2>) {
; 4257 :         return static_cast<_CtgIt2>(_Result);
; 4258 :     } else {
; 4259 :         return _Dest - (_LastPtr - _FirstPtr);
; 4260 :     }
; 4261 : }

	ret	0
??$_Copy_backward_memmove@PAPAVIRender_Visual@@PAPAV1@@std@@YAPAPAVIRender_Visual@@PAPAV1@00@Z ENDP ; std::_Copy_backward_memmove<IRender_Visual * *,IRender_Visual * *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_Move_backward_unchecked@PAPAVIRender_Visual@@PAPAV1@@std@@YAPAPAVIRender_Visual@@PAPAV1@00@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
??$_Move_backward_unchecked@PAPAVIRender_Visual@@PAPAV1@@std@@YAPAPAVIRender_Visual@@PAPAV1@00@Z PROC ; std::_Move_backward_unchecked<IRender_Visual * *,IRender_Visual * *>, COMDAT
; __First$ = ecx
; __Last$ = edx

; 4255 :     auto _Result                = _CSTD memmove(_Dest_ch - _Count, _First_ch, _Count);

	mov	eax, DWORD PTR __Dest$[esp-4]
	sub	edx, ecx
	push	edx
	push	ecx
	sub	eax, edx
	push	eax
	call	_memmove
	add	esp, 12					; 0000000cH

; 4351 :     // move [_First, _Last) backwards to [..., _Dest)
; 4352 :     // note: _Move_backward_unchecked has callers other than the move_backward family
; 4353 :     if constexpr (_Ptr_move_cat<_BidIt1, _BidIt2>::_Trivially_copyable) {
; 4354 : #ifdef __cpp_lib_is_constant_evaluated
; 4355 :         if (!_STD is_constant_evaluated())
; 4356 : #endif // __cpp_lib_is_constant_evaluated
; 4357 :         {
; 4358 :             return _Copy_backward_memmove(_First, _Last, _Dest);
; 4359 :         }
; 4360 :     }
; 4361 : 
; 4362 :     while (_First != _Last) {
; 4363 :         *--_Dest = _STD move(*--_Last);
; 4364 :     }
; 4365 : 
; 4366 :     return _Dest;
; 4367 : }

	ret	0
??$_Move_backward_unchecked@PAPAVIRender_Visual@@PAPAV1@@std@@YAPAPAVIRender_Visual@@PAPAV1@00@Z ENDP ; std::_Move_backward_unchecked<IRender_Visual * *,IRender_Visual * *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_To_address@PAPAVIRender_Visual@@@std@@YA?A_PABQAPAVIRender_Visual@@@Z
_TEXT	SEGMENT
??$_To_address@PAPAVIRender_Visual@@@std@@YA?A_PABQAPAVIRender_Visual@@@Z PROC ; std::_To_address<IRender_Visual * *>, COMDAT
; __Val$ = ecx

; 3981 :     _STL_INTERNAL_STATIC_ASSERT(is_pointer_v<_Iter>);
; 3982 :     return _Val;

	mov	eax, DWORD PTR [ecx]

; 3983 : }

	ret	0
??$_To_address@PAPAVIRender_Visual@@@std@@YA?A_PABQAPAVIRender_Visual@@@Z ENDP ; std::_To_address<IRender_Visual * *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_Copy_memmove@PAPAVIRender_Visual@@PAPAV1@@std@@YAPAPAVIRender_Visual@@PAPAV1@00@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
??$_Copy_memmove@PAPAVIRender_Visual@@PAPAV1@@std@@YAPAPAVIRender_Visual@@PAPAV1@00@Z PROC ; std::_Copy_memmove<IRender_Visual * *,IRender_Visual * *>, COMDAT
; __First$ = ecx
; __Last$ = edx

; 4058 : _OutCtgIt _Copy_memmove(_CtgIt _First, _CtgIt _Last, _OutCtgIt _Dest) {

	push	esi

; 4059 :     auto _FirstPtr              = _To_address(_First);
; 4060 :     auto _LastPtr               = _To_address(_Last);
; 4061 :     auto _DestPtr               = _To_address(_Dest);
; 4062 :     const char* const _First_ch = const_cast<const char*>(reinterpret_cast<const volatile char*>(_FirstPtr));
; 4063 :     const char* const _Last_ch  = const_cast<const char*>(reinterpret_cast<const volatile char*>(_LastPtr));
; 4064 :     char* const _Dest_ch        = const_cast<char*>(reinterpret_cast<const volatile char*>(_DestPtr));
; 4065 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);
; 4066 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	esi, DWORD PTR __Dest$[esp]
	push	edi
	mov	edi, edx
	sub	edi, ecx
	push	edi
	push	ecx
	push	esi
	call	_memmove
	add	esp, 12					; 0000000cH

; 4067 :     if constexpr (is_pointer_v<_OutCtgIt>) {
; 4068 :         return reinterpret_cast<_OutCtgIt>(_Dest_ch + _Count);

	lea	eax, DWORD PTR [edi+esi]
	pop	edi
	pop	esi

; 4069 :     } else {
; 4070 :         return _Dest + (_LastPtr - _FirstPtr);
; 4071 :     }
; 4072 : }

	ret	0
??$_Copy_memmove@PAPAVIRender_Visual@@PAPAV1@@std@@YAPAPAVIRender_Visual@@PAPAV1@00@Z ENDP ; std::_Copy_memmove<IRender_Visual * *,IRender_Visual * *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_Move_unchecked@PAPAVIRender_Visual@@PAPAV1@@std@@YAPAPAVIRender_Visual@@PAPAV1@00@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
??$_Move_unchecked@PAPAVIRender_Visual@@PAPAV1@@std@@YAPAPAVIRender_Visual@@PAPAV1@00@Z PROC ; std::_Move_unchecked<IRender_Visual * *,IRender_Visual * *>, COMDAT
; __First$ = ecx
; __Last$ = edx

; 4308 : _CONSTEXPR20 _OutIt _Move_unchecked(_InIt _First, _InIt _Last, _OutIt _Dest) {

	push	esi

; 4066 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	esi, DWORD PTR __Dest$[esp]

; 4308 : _CONSTEXPR20 _OutIt _Move_unchecked(_InIt _First, _InIt _Last, _OutIt _Dest) {

	push	edi
	mov	edi, edx

; 4065 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	sub	edi, ecx

; 4066 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	push	edi
	push	ecx
	push	esi
	call	_memmove
	add	esp, 12					; 0000000cH

; 4067 :     if constexpr (is_pointer_v<_OutCtgIt>) {
; 4068 :         return reinterpret_cast<_OutCtgIt>(_Dest_ch + _Count);

	lea	eax, DWORD PTR [edi+esi]

; 4309 :     // move [_First, _Last) to [_Dest, ...)
; 4310 :     // note: _Move_unchecked has callers other than the move family
; 4311 :     if constexpr (_Ptr_move_cat<_InIt, _OutIt>::_Trivially_copyable) {
; 4312 : #ifdef __cpp_lib_is_constant_evaluated
; 4313 :         if (!_STD is_constant_evaluated())
; 4314 : #endif // __cpp_lib_is_constant_evaluated
; 4315 :         {
; 4316 :             return _Copy_memmove(_First, _Last, _Dest);

	pop	edi
	pop	esi

; 4317 :         }
; 4318 :     }
; 4319 : 
; 4320 :     for (; _First != _Last; ++_Dest, (void) ++_First) {
; 4321 :         *_Dest = _STD move(*_First);
; 4322 :     }
; 4323 : 
; 4324 :     return _Dest;
; 4325 : }

	ret	0
??$_Move_unchecked@PAPAVIRender_Visual@@PAPAV1@@std@@YAPAPAVIRender_Visual@@PAPAV1@00@Z ENDP ; std::_Move_unchecked<IRender_Visual * *,IRender_Visual * *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$construct@PAVIRender_Visual@@AAPAV1@@?$_Normal_allocator_traits@V?$xalloc@PAVIRender_Visual@@@@@std@@SAXAAV?$xalloc@PAVIRender_Visual@@@@PAPAVIRender_Visual@@AAPAV3@@Z
_TEXT	SEGMENT
_<_Args_0>$ = 8						; size = 4
??$construct@PAVIRender_Visual@@AAPAV1@@?$_Normal_allocator_traits@V?$xalloc@PAVIRender_Visual@@@@@std@@SAXAAV?$xalloc@PAVIRender_Visual@@@@PAPAVIRender_Visual@@AAPAV3@@Z PROC ; std::_Normal_allocator_traits<xalloc<IRender_Visual *> >::construct<IRender_Visual *,IRender_Visual * &>, COMDAT
; __Al$dead$ = ecx
; __Ptr$ = edx

; 565  :         if constexpr (_Uses_default_construct<_Alloc, _Ty*, _Types...>::value) {
; 566  :             (void) _Al; // TRANSITION, DevCom-1004719
; 567  : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 568  :             _STD construct_at(_Ptr, _STD forward<_Types>(_Args)...);
; 569  : #else // __cpp_lib_constexpr_dynamic_alloc
; 570  :             ::new (static_cast<void*>(_Ptr)) _Ty(_STD forward<_Types>(_Args)...);
; 571  : #endif // __cpp_lib_constexpr_dynamic_alloc
; 572  :         } else {
; 573  :             _Al.construct(_Ptr, _STD forward<_Types>(_Args)...);

	mov	eax, DWORD PTR _<_Args_0>$[esp-4]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edx], eax

; 574  :         }
; 575  :     }

	ret	0
??$construct@PAVIRender_Visual@@AAPAV1@@?$_Normal_allocator_traits@V?$xalloc@PAVIRender_Visual@@@@@std@@SAXAAV?$xalloc@PAVIRender_Visual@@@@PAPAVIRender_Visual@@AAPAV3@@Z ENDP ; std::_Normal_allocator_traits<xalloc<IRender_Visual *> >::construct<IRender_Visual *,IRender_Visual * &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Emplace_back@AAPAVIRender_Visual@@@?$_Uninitialized_backout_al@V?$xalloc@PAVIRender_Visual@@@@@std@@QAEXAAPAVIRender_Visual@@@Z
_TEXT	SEGMENT
_<_Vals_0>$ = 8						; size = 4
??$_Emplace_back@AAPAVIRender_Visual@@@?$_Uninitialized_backout_al@V?$xalloc@PAVIRender_Visual@@@@@std@@QAEXAAPAVIRender_Visual@@@Z PROC ; std::_Uninitialized_backout_al<xalloc<IRender_Visual *> >::_Emplace_back<IRender_Visual * &>, COMDAT
; _this$ = ecx

; 1620 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _<_Vals_0>$[esp-4]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edx], eax

; 1621 :         ++_Last;

	add	DWORD PTR [ecx+4], 4

; 1622 :     }

	ret	4
??$_Emplace_back@AAPAVIRender_Visual@@@?$_Uninitialized_backout_al@V?$xalloc@PAVIRender_Visual@@@@@std@@QAEXAAPAVIRender_Visual@@@Z ENDP ; std::_Uninitialized_backout_al<xalloc<IRender_Visual *> >::_Emplace_back<IRender_Visual * &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Uninitialized_copy@PAPAVIRender_Visual@@V?$xalloc@PAVIRender_Visual@@@@@std@@YAPAPAVIRender_Visual@@QAPAV1@0PAPAV1@AAV?$xalloc@PAVIRender_Visual@@@@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Al$dead$ = 12						; size = 4
??$_Uninitialized_copy@PAPAVIRender_Visual@@V?$xalloc@PAVIRender_Visual@@@@@std@@YAPAPAVIRender_Visual@@QAPAV1@0PAPAV1@AAV?$xalloc@PAVIRender_Visual@@@@@Z PROC ; std::_Uninitialized_copy<IRender_Visual * *,xalloc<IRender_Visual *> >, COMDAT
; __First$ = ecx
; __Last$ = edx

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	eax, DWORD PTR __Dest$[esp-4]

; 1637 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

	push	esi
	mov	esi, edx

; 1638 :     // copy [_First, _Last) to raw _Dest, using _Al
; 1639 :     // note: only called internally from elsewhere in the STL
; 1640 :     using _Ptrval = typename _Alloc::value_type*;
; 1641 : 
; 1642 :     auto _UFirst      = _Get_unwrapped(_First);
; 1643 :     const auto _ULast = _Get_unwrapped(_Last);
; 1644 : 
; 1645 :     if constexpr (conjunction_v<bool_constant<_Ptr_copy_cat<decltype(_UFirst), _Ptrval>::_Really_trivial>,
; 1646 :                       _Uses_default_construct<_Alloc, _Ptrval, decltype(*_UFirst)>>) {
; 1647 : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 1648 :         if (!_STD is_constant_evaluated())
; 1649 : #endif // __cpp_lib_constexpr_dynamic_alloc
; 1650 :         {
; 1651 :             _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));
; 1652 :             _Dest += _ULast - _UFirst;
; 1653 :             return _Dest;
; 1654 :         }
; 1655 :     }
; 1656 : 
; 1657 :     _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1658 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	ecx, esi
	je	SHORT $LN3@Uninitiali
	npad	5
$LL4@Uninitiali:

; 1620 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

	mov	edx, DWORD PTR [ecx]

; 1621 :         ++_Last;

	add	ecx, 4
	mov	DWORD PTR [eax], edx
	add	eax, 4

; 1638 :     // copy [_First, _Last) to raw _Dest, using _Al
; 1639 :     // note: only called internally from elsewhere in the STL
; 1640 :     using _Ptrval = typename _Alloc::value_type*;
; 1641 : 
; 1642 :     auto _UFirst      = _Get_unwrapped(_First);
; 1643 :     const auto _ULast = _Get_unwrapped(_Last);
; 1644 : 
; 1645 :     if constexpr (conjunction_v<bool_constant<_Ptr_copy_cat<decltype(_UFirst), _Ptrval>::_Really_trivial>,
; 1646 :                       _Uses_default_construct<_Alloc, _Ptrval, decltype(*_UFirst)>>) {
; 1647 : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 1648 :         if (!_STD is_constant_evaluated())
; 1649 : #endif // __cpp_lib_constexpr_dynamic_alloc
; 1650 :         {
; 1651 :             _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));
; 1652 :             _Dest += _ULast - _UFirst;
; 1653 :             return _Dest;
; 1654 :         }
; 1655 :     }
; 1656 : 
; 1657 :     _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1658 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	ecx, esi
	jne	SHORT $LL4@Uninitiali
$LN3@Uninitiali:
	pop	esi

; 1659 :         _Backout._Emplace_back(*_UFirst);
; 1660 :     }
; 1661 : 
; 1662 :     return _Backout._Release();
; 1663 : }

	ret	0
??$_Uninitialized_copy@PAPAVIRender_Visual@@V?$xalloc@PAVIRender_Visual@@@@@std@@YAPAPAVIRender_Visual@@QAPAV1@0PAPAV1@AAV?$xalloc@PAVIRender_Visual@@@@@Z ENDP ; std::_Uninitialized_copy<IRender_Visual * *,xalloc<IRender_Visual *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??$_Ucopy@PAPAVIRender_Visual@@@?$vector@PAVIRender_Visual@@V?$xalloc@PAVIRender_Visual@@@@@std@@AAEPAPAVIRender_Visual@@PAPAV2@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Ucopy@PAPAVIRender_Visual@@@?$vector@PAVIRender_Visual@@V?$xalloc@PAVIRender_Visual@@@@@std@@AAEPAPAVIRender_Visual@@PAPAV2@00@Z PROC ; std::vector<IRender_Visual *,xalloc<IRender_Visual *> >::_Ucopy<IRender_Visual * *>, COMDAT
; _this$dead$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1658 :     for (; _UFirst != _ULast; ++_UFirst) {

	mov	ecx, DWORD PTR __First$[esp-4]

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	eax, DWORD PTR __Dest$[esp-4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1639 :     _CONSTEXPR20_CONTAINER pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Dest) {

	push	esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1658 :     for (; _UFirst != _ULast; ++_UFirst) {

	mov	esi, DWORD PTR __Last$[esp]
	cmp	ecx, esi
	je	SHORT $LN5@Ucopy
$LL6@Ucopy:

; 1620 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

	mov	edx, DWORD PTR [ecx]

; 1621 :         ++_Last;

	add	ecx, 4
	mov	DWORD PTR [eax], edx
	add	eax, 4

; 1658 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	ecx, esi
	jne	SHORT $LL6@Ucopy
$LN5@Ucopy:
	pop	esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1642 :     }

	ret	12					; 0000000cH
??$_Ucopy@PAPAVIRender_Visual@@@?$vector@PAVIRender_Visual@@V?$xalloc@PAVIRender_Visual@@@@@std@@AAEPAPAVIRender_Visual@@PAPAV2@00@Z ENDP ; std::vector<IRender_Visual *,xalloc<IRender_Visual *> >::_Ucopy<IRender_Visual * *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??$_Insert_range@PAPAVIRender_Visual@@@?$vector@PAVIRender_Visual@@V?$xalloc@PAVIRender_Visual@@@@@std@@AAEXV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVIRender_Visual@@@std@@@std@@@1@PAPAVIRender_Visual@@1Uforward_iterator_tag@1@@Z
_TEXT	SEGMENT
__Backout$4 = -68					; size = 12
__Backout$5 = -68					; size = 12
__Backout$6 = -68					; size = 12
__UFirst$7 = -56					; size = 4
__UFirst$8 = -52					; size = 4
__UFirst$9 = -48					; size = 4
__Oldcapacity$1$ = -44					; size = 4
__Whereoff$1$ = -44					; size = 4
tv932 = -44						; size = 4
__Oldlast$ = -40					; size = 4
__Count$ = -36						; size = 4
__Newsize$1$ = -32					; size = 4
__Whereptr$ = -32					; size = 4
_this$1$ = -28						; size = 4
__Oldfirst$1$ = -24					; size = 4
__Newcapacity$1$ = -20					; size = 4
__Mylast$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Where$ = 8						; size = 4
__Count$1$ = 12						; size = 4
__Relocated$10 = 12					; size = 4
__Newvec$11 = 12					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Insert_range@PAPAVIRender_Visual@@@?$vector@PAVIRender_Visual@@V?$xalloc@PAVIRender_Visual@@@@@std@@AAEXV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVIRender_Visual@@@std@@@std@@@1@PAPAVIRender_Visual@@1Uforward_iterator_tag@1@@Z PROC ; std::vector<IRender_Visual *,xalloc<IRender_Visual *> >::_Insert_range<IRender_Visual * *>, COMDAT
; _this$ = ecx

; 937  :     _CONSTEXPR20_CONTAINER void _Insert_range(const_iterator _Where, _Iter _First, _Iter _Last, forward_iterator_tag) {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Insert_range@PAPAVIRender_Visual@@@?$vector@PAVIRender_Visual@@V?$xalloc@PAVIRender_Visual@@@@@std@@AAEXV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVIRender_Visual@@@std@@@std@@@1@PAPAVIRender_Visual@@1Uforward_iterator_tag@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 56					; 00000038H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	eax, ecx
	mov	DWORD PTR _this$1$[ebp], eax

; 938  :         // insert forward range [_First, _Last) at _Where
; 939  :         const pointer _Whereptr = _Where._Ptr;

	mov	edi, DWORD PTR __Where$[ebp]
	mov	DWORD PTR __Whereptr$[ebp], edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility

; 1525 :         return _Last - _First; // assume the iterator will do debug checking

	mov	ecx, DWORD PTR __Last$[ebp]
	mov	edx, ecx
	mov	esi, DWORD PTR __First$[ebp]
	sub	edx, esi
	sar	edx, 2
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 940  :         const auto _Count       = _Convert_size<size_type>(static_cast<size_t>(_STD distance(_First, _Last)));

	mov	DWORD PTR __Count$[ebp], edx

; 941  : 
; 942  :         auto& _My_data   = _Mypair._Myval2;
; 943  :         pointer& _Mylast = _My_data._Mylast;

	lea	ebx, DWORD PTR [eax+4]
	mov	DWORD PTR __Mylast$[ebp], ebx

; 944  : 
; 945  :         const pointer _Oldfirst     = _My_data._Myfirst;

	mov	ebx, DWORD PTR [eax]
	mov	DWORD PTR __Oldfirst$1$[ebp], ebx

; 946  :         const pointer _Oldlast      = _Mylast;

	mov	ebx, DWORD PTR [eax+4]
	mov	DWORD PTR __Oldlast$[ebp], ebx

; 947  :         const auto _Unused_capacity = static_cast<size_type>(_My_data._Myend - _Oldlast);

	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR __Oldcapacity$1$[ebp], eax
	sub	eax, ebx
	sar	eax, 2

; 948  : 
; 949  :         if (_Count == 0) { // nothing to do, avoid invalidating iterators

	test	edx, edx
	je	$LN35@Insert_ran

; 950  :         } else if (_Count > _Unused_capacity) { // reallocate

	cmp	edx, eax
	jbe	$LN4@Insert_ran

; 951  :             const auto _Oldsize = static_cast<size_type>(_Oldlast - _Oldfirst);

	mov	ecx, ebx
	sub	ecx, DWORD PTR __Oldfirst$1$[ebp]
	sar	ecx, 2

; 952  : 
; 953  :             if (_Count > max_size() - _Oldsize) {

	mov	eax, 1073741823				; 3fffffffH
	sub	eax, ecx
	cmp	edx, eax
	ja	$LN149@Insert_ran

; 955  :             }
; 956  : 
; 957  :             const size_type _Newsize     = _Oldsize + _Count;

	lea	eax, DWORD PTR [ecx+edx]
	mov	DWORD PTR __Newsize$1$[ebp], eax

; 1546 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	eax, DWORD PTR __Oldcapacity$1$[ebp]
	sub	eax, DWORD PTR __Oldfirst$1$[ebp]
	sar	eax, 2

; 1675 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	edx, eax
	shr	edx, 1
	mov	ecx, 1073741823				; 3fffffffH
	sub	ecx, edx
	cmp	eax, ecx
	jbe	SHORT $LN40@Insert_ran

; 1676 :             return _Max; // geometric growth would overflow

	mov	eax, 1073741823				; 3fffffffH
	jmp	SHORT $LN147@Insert_ran
$LN40@Insert_ran:

; 1677 :         }
; 1678 : 
; 1679 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	add	eax, edx

; 1680 : 
; 1681 :         if (_Geometric < _Newsize) {

	cmp	eax, DWORD PTR __Newsize$1$[ebp]
	cmovb	eax, DWORD PTR __Newsize$1$[ebp]
$LN147@Insert_ran:
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	mov	DWORD PTR __Newcapacity$1$[ebp], eax
	shl	eax, 2
	push	eax
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 960  :             const pointer _Newvec           = _Getal().allocate(_Newcapacity);

	mov	DWORD PTR __Newvec$11[ebp], eax

; 961  :             const auto _Whereoff            = static_cast<size_type>(_Whereptr - _Oldfirst);

	mov	ecx, edi
	sub	ecx, DWORD PTR __Oldfirst$1$[ebp]
	sar	ecx, 2
	mov	DWORD PTR __Whereoff$1$[ebp], ecx

; 962  :             const pointer _Constructed_last = _Newvec + _Whereoff + _Count;
; 963  :             pointer _Constructed_first      = _Constructed_last;
; 964  : 
; 965  :             _TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 966  :             _Ucopy(_First, _Last, _Newvec + _Whereoff);

	lea	ecx, DWORD PTR [eax+ecx*4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1642 :     auto _UFirst      = _Get_unwrapped(_First);

	mov	DWORD PTR __UFirst$9[ebp], esi

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	DWORD PTR __Backout$6[ebp], ecx
	mov	DWORD PTR __Backout$6[ebp+4], ecx
	mov	eax, DWORD PTR _this$1$[ebp]
	mov	DWORD PTR __Backout$6[ebp+8], eax

; 1658 :     for (; _UFirst != _ULast; ++_UFirst) {

	mov	edx, DWORD PTR __Last$[ebp]
	npad	6
$LL54@Insert_ran:
	cmp	esi, edx
	je	SHORT $LN53@Insert_ran

; 1620 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [ecx], eax

; 1621 :         ++_Last;

	add	ecx, 4
	mov	DWORD PTR __Backout$6[ebp+4], ecx

; 1658 :     for (; _UFirst != _ULast; ++_UFirst) {

	add	esi, 4
	mov	DWORD PTR __UFirst$9[ebp], esi
	jmp	SHORT $LL54@Insert_ran
$LN53@Insert_ran:

; 1625 :         _First = _Last;

	mov	DWORD PTR __Backout$6[ebp], ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 969  :             if (_Count == 1 && _Whereptr == _Oldlast) { // one at back, provide strong guarantee

	cmp	DWORD PTR __Count$[ebp], 1
	jne	SHORT $LN8@Insert_ran
	cmp	edi, ebx
	jne	SHORT $LN8@Insert_ran

; 970  :                 _Umove_if_noexcept(_Oldfirst, _Oldlast, _Newvec);

	mov	esi, DWORD PTR __Newvec$11[ebp]
	push	esi
	push	ebx
	push	DWORD PTR __Oldfirst$1$[ebp]
	call	?_Umove_if_noexcept@?$vector@PAVIRender_Visual@@V?$xalloc@PAVIRender_Visual@@@@@std@@AAEXPAPAVIRender_Visual@@00@Z ; std::vector<IRender_Visual *,xalloc<IRender_Visual *> >::_Umove_if_noexcept

; 971  :             } else { // provide basic guarantee

	jmp	SHORT $LN9@Insert_ran
$LN8@Insert_ran:

; 972  :                 _Umove(_Oldfirst, _Whereptr, _Newvec);

	mov	esi, DWORD PTR __Newvec$11[ebp]
	push	esi
	push	edi
	push	DWORD PTR __Oldfirst$1$[ebp]
	call	?_Umove@?$vector@PAVIRender_Visual@@V?$xalloc@PAVIRender_Visual@@@@@std@@AAEPAPAVIRender_Visual@@PAPAV3@00@Z ; std::vector<IRender_Visual *,xalloc<IRender_Visual *> >::_Umove

; 973  :                 _Constructed_first = _Newvec;
; 974  :                 _Umove(_Whereptr, _Oldlast, _Newvec + _Whereoff + _Count);

	mov	ecx, DWORD PTR __Count$[ebp]
	mov	eax, DWORD PTR __Whereoff$1$[ebp]
	add	eax, ecx
	lea	eax, DWORD PTR [esi+eax*4]
	push	eax
	push	ebx
	push	edi
	call	?_Umove@?$vector@PAVIRender_Visual@@V?$xalloc@PAVIRender_Visual@@@@@std@@AAEPAPAVIRender_Visual@@PAPAV3@00@Z ; std::vector<IRender_Visual *,xalloc<IRender_Visual *> >::_Umove
$LN9@Insert_ran:
	mov	DWORD PTR __$EHRec$[ebp+12], -1

; 1732 :         if (_Myfirst) { // destroy and deallocate old array

	mov	ebx, DWORD PTR _this$1$[ebp]
	mov	eax, DWORD PTR [ebx]
	test	eax, eax
	je	SHORT $LN68@Insert_ran
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	push	eax
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN68@Insert_ran:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1737 :         _Myfirst = _Newvec;

	mov	DWORD PTR [ebx], esi

; 1738 :         _Mylast  = _Newvec + _Newsize;

	mov	eax, DWORD PTR __Newsize$1$[ebp]
	lea	eax, DWORD PTR [esi+eax*4]
	mov	DWORD PTR [ebx+4], eax

; 1739 :         _Myend   = _Newvec + _Newcapacity;

	mov	eax, DWORD PTR __Newcapacity$1$[ebp]
	lea	eax, DWORD PTR [esi+eax*4]
	mov	DWORD PTR [ebx+8], eax
$LN35@Insert_ran:

; 1042 :     }

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
$LN4@Insert_ran:

; 980  :             _CATCH_END
; 981  : 
; 982  :             _Change_array(_Newvec, _Newsize, _Newcapacity);
; 983  :         } else { // Attempt to provide the strong guarantee for EmplaceConstructible failure.
; 984  :                  // If we encounter copy/move construction/assignment failure, provide the basic guarantee.
; 985  :                  // (For one-at-back, this provides the strong guarantee.)
; 986  : 
; 987  :             const auto _Affected_elements = static_cast<size_type>(_Oldlast - _Whereptr);

	mov	eax, ebx
	sub	eax, edi
	sar	eax, 2
	lea	esi, DWORD PTR [edx*4]
	mov	DWORD PTR tv932[ebp], esi

; 988  : 
; 989  :             if (_Count < _Affected_elements) { // some affected elements must be assigned

	cmp	edx, eax
	mov	esi, DWORD PTR __First$[ebp]
	jae	SHORT $LN10@Insert_ran

; 990  :                 _Mylast = _Umove(_Oldlast - _Count, _Oldlast, _Oldlast);

	mov	eax, ebx
	lea	ecx, DWORD PTR [edx*4]
	sub	eax, ecx
	mov	DWORD PTR __Count$1$[ebp], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	edx, ebx

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	eax, ebx
	je	SHORT $LN74@Insert_ran

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	ecx, eax
$LL75@Insert_ran:

; 1620 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax

; 1621 :         ++_Last;

	add	edx, 4
	add	ecx, 4

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	ecx, ebx
	jne	SHORT $LL75@Insert_ran
	mov	eax, DWORD PTR __Count$1$[ebp]
$LN74@Insert_ran:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 990  :                 _Mylast = _Umove(_Oldlast - _Count, _Oldlast, _Oldlast);

	mov	ecx, DWORD PTR __Mylast$[ebp]
	mov	DWORD PTR [ecx], edx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility

; 4254 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	sub	eax, edi

; 4255 :     auto _Result                = _CSTD memmove(_Dest_ch - _Count, _First_ch, _Count);

	push	eax
	push	edi
	sub	ebx, eax
	push	ebx
	call	_memmove
	add	esp, 12					; 0000000cH
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 994  :                 _TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 2
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1642 :     auto _UFirst      = _Get_unwrapped(_First);

	mov	DWORD PTR __UFirst$8[ebp], esi

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	DWORD PTR __Backout$5[ebp], edi
	mov	DWORD PTR __Backout$5[ebp+4], edi
	mov	eax, DWORD PTR _this$1$[ebp]
	mov	DWORD PTR __Backout$5[ebp+8], eax

; 1658 :     for (; _UFirst != _ULast; ++_UFirst) {

	mov	edx, DWORD PTR __Last$[ebp]
$LL94@Insert_ran:
	cmp	esi, edx
	je	SHORT $LN119@Insert_ran

; 1620 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [edi], eax

; 1621 :         ++_Last;

	add	edi, 4
	mov	DWORD PTR __Backout$5[ebp+4], edi

; 1658 :     for (; _UFirst != _ULast; ++_UFirst) {

	add	esi, 4
	mov	DWORD PTR __UFirst$8[ebp], esi
	jmp	SHORT $LL94@Insert_ran
$LN10@Insert_ran:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1015 :                 const pointer _Relocated = _Whereptr + _Count;

	mov	edx, DWORD PTR tv932[ebp]
	add	edx, edi
	mov	DWORD PTR __Relocated$10[ebp], edx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	cmp	edi, ebx

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	je	SHORT $LN106@Insert_ran
	mov	ecx, edi
$LL107@Insert_ran:

; 1620 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax

; 1621 :         ++_Last;

	add	edx, 4

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	add	ecx, 4
	cmp	ecx, ebx
	jne	SHORT $LL107@Insert_ran
	mov	ecx, DWORD PTR __Last$[ebp]
$LN106@Insert_ran:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1016 :                 _Mylast                  = _Umove(_Whereptr, _Oldlast, _Relocated);

	mov	eax, DWORD PTR __Mylast$[ebp]
	mov	DWORD PTR [eax], edx

; 1017 :                 _Destroy(_Whereptr, _Oldlast);
; 1018 : 
; 1019 :                 _TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 6
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1642 :     auto _UFirst      = _Get_unwrapped(_First);

	mov	DWORD PTR __UFirst$7[ebp], esi

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	DWORD PTR __Backout$4[ebp], edi
	mov	DWORD PTR __Backout$4[ebp+4], edi
	mov	eax, DWORD PTR _this$1$[ebp]
	mov	DWORD PTR __Backout$4[ebp+8], eax
$LL120@Insert_ran:

; 1658 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	esi, ecx
	je	SHORT $LN119@Insert_ran

; 1620 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [edi], eax

; 1621 :         ++_Last;

	add	edi, 4
	mov	DWORD PTR __Backout$4[ebp+4], edi

; 1658 :     for (; _UFirst != _ULast; ++_UFirst) {

	add	esi, 4
	mov	DWORD PTR __UFirst$7[ebp], esi
	jmp	SHORT $LL120@Insert_ran
$LN119@Insert_ran:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1042 :     }

	mov	DWORD PTR __Backout$4[ebp], edi
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
__catch$??$_Insert_range@PAPAVIRender_Visual@@@?$vector@PAVIRender_Visual@@V?$xalloc@PAVIRender_Visual@@@@@std@@AAEXV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVIRender_Visual@@@std@@@std@@@1@PAPAVIRender_Visual@@1Uforward_iterator_tag@1@@Z$6:

; 1020 :                 _Ucopy(_First, _Last, _Whereptr);
; 1021 :                 _CATCH_ALL

	mov	DWORD PTR __$EHRec$[ebp], esp

; 1022 :                 // glue the broken pieces back together
; 1023 : 
; 1024 :                 _TRY_BEGIN

	mov	BYTE PTR __$EHRec$[ebp+12], 8

; 1025 :                 _Umove(_Relocated, _Mylast, _Whereptr);

	push	DWORD PTR __Whereptr$[ebp]
	mov	esi, DWORD PTR __Mylast$[ebp]
	push	DWORD PTR [esi]
	push	DWORD PTR __Relocated$10[ebp]
	call	?_Umove@?$vector@PAVIRender_Visual@@V?$xalloc@PAVIRender_Visual@@@@@std@@AAEPAPAVIRender_Visual@@PAPAV3@00@Z ; std::vector<IRender_Visual *,xalloc<IRender_Visual *> >::_Umove
	mov	DWORD PTR __$EHRec$[ebp+12], 7

; 1026 :                 _CATCH_ALL
; 1027 :                 // vaporize the detached piece
; 1028 :                 _Orphan_range(_Whereptr, _Oldlast);
; 1029 :                 _Destroy(_Relocated, _Mylast);
; 1030 :                 _Mylast = _Whereptr;
; 1031 :                 _RERAISE;
; 1032 :                 _CATCH_END
; 1033 : 
; 1034 :                 _Destroy(_Relocated, _Mylast);
; 1035 :                 _Mylast = _Oldlast;

	mov	eax, DWORD PTR __Oldlast$[ebp]
	mov	DWORD PTR [esi], eax

; 1036 :                 _RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$LN149@Insert_ran:

; 954  :                 _Xlength();

	call	?_Xlength@?$vector@PAVIRender_Visual@@V?$xalloc@PAVIRender_Visual@@@@@std@@CAXXZ ; std::vector<IRender_Visual *,xalloc<IRender_Visual *> >::_Xlength
__catch$??$_Insert_range@PAPAVIRender_Visual@@@?$vector@PAVIRender_Visual@@V?$xalloc@PAVIRender_Visual@@@@@std@@AAEXV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVIRender_Visual@@@std@@@std@@@1@PAPAVIRender_Visual@@1Uforward_iterator_tag@1@@Z$0:

; 975  :             }
; 976  :             _CATCH_ALL
; 977  :             _Destroy(_Constructed_first, _Constructed_last);
; 978  :             _Getal().deallocate(_Newvec, _Newcapacity);

	push	ecx
	push	DWORD PTR __Newvec$11[ebp]
	call	?deallocate@?$xalloc@PAVIRender_Visual@@@@QBEXPAPAVIRender_Visual@@I@Z ; xalloc<IRender_Visual *>::deallocate

; 979  :             _RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
__catch$??$_Insert_range@PAPAVIRender_Visual@@@?$vector@PAVIRender_Visual@@V?$xalloc@PAVIRender_Visual@@@@@std@@AAEXV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVIRender_Visual@@@std@@@std@@@1@PAPAVIRender_Visual@@1Uforward_iterator_tag@1@@Z$2:

; 995  :                 _Ucopy(_First, _Last, _Whereptr);
; 996  :                 _CATCH_ALL

	mov	DWORD PTR __$EHRec$[ebp], esp

; 997  :                 // glue the broken pieces back together
; 998  : 
; 999  :                 _TRY_BEGIN

	mov	BYTE PTR __$EHRec$[ebp+12], 4

; 1000 :                 _Umove(_Whereptr + _Count, _Whereptr + 2 * _Count, _Whereptr);

	mov	ecx, DWORD PTR __Whereptr$[ebp]
	mov	eax, DWORD PTR __Count$[ebp]
	lea	edi, DWORD PTR [ecx+eax*8]
	lea	esi, DWORD PTR [ecx+eax*4]
	push	ecx
	push	edi
	push	esi
	call	?_Umove@?$vector@PAVIRender_Visual@@V?$xalloc@PAVIRender_Visual@@@@@std@@AAEPAPAVIRender_Visual@@PAPAV3@00@Z ; std::vector<IRender_Visual *,xalloc<IRender_Visual *> >::_Umove
	mov	DWORD PTR __$EHRec$[ebp+12], 3

; 1001 :                 _CATCH_ALL
; 1002 :                 // vaporize the detached piece
; 1003 :                 _Orphan_range(_Whereptr, _Oldlast);
; 1004 :                 _Destroy(_Whereptr + _Count, _Mylast);
; 1005 :                 _Mylast = _Whereptr;
; 1006 :                 _RERAISE;
; 1007 :                 _CATCH_END
; 1008 : 
; 1009 :                 _Move_unchecked(_Whereptr + 2 * _Count, _Mylast, _Whereptr + _Count);

	push	esi
	mov	esi, DWORD PTR __Mylast$[ebp]
	mov	edx, DWORD PTR [esi]
	mov	ecx, edi
	call	??$_Move_unchecked@PAPAVIRender_Visual@@PAPAV1@@std@@YAPAPAVIRender_Visual@@PAPAV1@00@Z ; std::_Move_unchecked<IRender_Visual * *,IRender_Visual * *>
	add	esp, 4

; 1010 :                 _Destroy(_Oldlast, _Mylast);
; 1011 :                 _Mylast = _Oldlast;

	mov	eax, DWORD PTR __Oldlast$[ebp]
	mov	DWORD PTR [esi], eax

; 1012 :                 _RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
__catch$??$_Insert_range@PAPAVIRender_Visual@@@?$vector@PAVIRender_Visual@@V?$xalloc@PAVIRender_Visual@@@@@std@@AAEXV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVIRender_Visual@@@std@@@std@@@1@PAPAVIRender_Visual@@1Uforward_iterator_tag@1@@Z$7:
__catch$??$_Insert_range@PAPAVIRender_Visual@@@?$vector@PAVIRender_Visual@@V?$xalloc@PAVIRender_Visual@@@@@std@@AAEXV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVIRender_Visual@@@std@@@std@@@1@PAPAVIRender_Visual@@1Uforward_iterator_tag@1@@Z$3:

; 1042 :     }

	mov	ecx, DWORD PTR __Whereptr$[ebp]
	mov	eax, DWORD PTR __Mylast$[ebp]
	mov	DWORD PTR [eax], ecx
	push	0
	push	0
	call	__CxxThrowException@8
$LN146@Insert_ran:
	int	3
	int	3
	int	3
	int	3
	int	3
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Insert_range@PAPAVIRender_Visual@@@?$vector@PAVIRender_Visual@@V?$xalloc@PAVIRender_Visual@@@@@std@@AAEXV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVIRender_Visual@@@std@@@std@@@1@PAPAVIRender_Visual@@1Uforward_iterator_tag@1@@Z:
	npad	1
	npad	1
	mov	eax, OFFSET __ehfuncinfo$??$_Insert_range@PAPAVIRender_Visual@@@?$vector@PAVIRender_Visual@@V?$xalloc@PAVIRender_Visual@@@@@std@@AAEXV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVIRender_Visual@@@std@@@std@@@1@PAPAVIRender_Visual@@1Uforward_iterator_tag@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Insert_range@PAPAVIRender_Visual@@@?$vector@PAVIRender_Visual@@V?$xalloc@PAVIRender_Visual@@@@@std@@AAEXV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVIRender_Visual@@@std@@@std@@@1@PAPAVIRender_Visual@@1Uforward_iterator_tag@1@@Z ENDP ; std::vector<IRender_Visual *,xalloc<IRender_Visual *> >::_Insert_range<IRender_Visual * *>
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Unwrapped@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVIRender_Visual@@@std@@@std@@@std@@QBEPAPAVIRender_Visual@@XZ
_TEXT	SEGMENT
?_Unwrapped@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVIRender_Visual@@@std@@@std@@@std@@QBEPAPAVIRender_Visual@@XZ PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<IRender_Visual *> > >::_Unwrapped, COMDAT
; _this$ = ecx

; 328  :         return _Unfancy(this->_Ptr);

	mov	eax, DWORD PTR [ecx]

; 329  :     }

	ret	0
?_Unwrapped@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVIRender_Visual@@@std@@@std@@@std@@QBEPAPAVIRender_Visual@@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<IRender_Visual *> > >::_Unwrapped
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_Get_unwrapped@AAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVIRender_Visual@@@std@@@std@@@std@@@std@@YA?A_TAAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVIRender_Visual@@@std@@@std@@@0@@Z
_TEXT	SEGMENT
??$_Get_unwrapped@AAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVIRender_Visual@@@std@@@std@@@std@@@std@@YA?A_TAAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVIRender_Visual@@@std@@@std@@@0@@Z PROC ; std::_Get_unwrapped<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<IRender_Visual *> > > &>, COMDAT
; __It$ = ecx

; 1275 :     // unwrap an iterator previously subjected to _Adl_verify_range or otherwise validated
; 1276 :     if constexpr (is_pointer_v<decay_t<_Iter>>) { // special-case pointers and arrays
; 1277 :         return _It + 0;
; 1278 :     } else if constexpr (_Unwrappable_v<_Iter>) {
; 1279 :         return static_cast<_Iter&&>(_It)._Unwrapped();

	mov	eax, DWORD PTR [ecx]

; 1280 :     } else {
; 1281 :         return static_cast<_Iter&&>(_It);
; 1282 :     }
; 1283 : }

	ret	0
??$_Get_unwrapped@AAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVIRender_Visual@@@std@@@std@@@std@@@std@@YA?A_TAAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVIRender_Visual@@@std@@@std@@@0@@Z ENDP ; std::_Get_unwrapped<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<IRender_Visual *> > > &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Make_iterator_offset@?$vector@PAVIRender_Visual@@V?$xalloc@PAVIRender_Visual@@@@@std@@AAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVIRender_Visual@@@std@@@std@@@2@I@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Offset$ = 12						; size = 4
?_Make_iterator_offset@?$vector@PAVIRender_Visual@@V?$xalloc@PAVIRender_Visual@@@@@std@@AAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVIRender_Visual@@@std@@@std@@@2@I@Z PROC ; std::vector<IRender_Visual *,xalloc<IRender_Visual *> >::_Make_iterator_offset, COMDAT
; _this$ = ecx

; 1817 :         // return the iterator begin() + _Offset without a debugging check
; 1818 :         auto& _My_data = _Mypair._Myval2;
; 1819 :         return iterator(_My_data._Myfirst + _Offset, _STD addressof(_My_data));

	mov	eax, DWORD PTR __Offset$[esp-4]
	mov	ecx, DWORD PTR [ecx]
	lea	ecx, DWORD PTR [ecx+eax*4]

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 1820 :     }

	ret	8
?_Make_iterator_offset@?$vector@PAVIRender_Visual@@V?$xalloc@PAVIRender_Visual@@@@@std@@AAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVIRender_Visual@@@std@@@std@@@2@I@Z ENDP ; std::vector<IRender_Visual *,xalloc<IRender_Visual *> >::_Make_iterator_offset
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??$insert@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVIRender_Visual@@@std@@@std@@@std@@$0A@@?$vector@PAVIRender_Visual@@V?$xalloc@PAVIRender_Visual@@@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVIRender_Visual@@@std@@@std@@@1@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVIRender_Visual@@@std@@@std@@@1@V21@1@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
$T1 = 12						; size = 1
__Where$ = 12						; size = 4
__First$ = 16						; size = 4
__Last$ = 20						; size = 4
??$insert@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVIRender_Visual@@@std@@@std@@@std@@$0A@@?$vector@PAVIRender_Visual@@V?$xalloc@PAVIRender_Visual@@@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVIRender_Visual@@@std@@@std@@@1@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVIRender_Visual@@@std@@@std@@@1@V21@1@Z PROC ; std::vector<IRender_Visual *,xalloc<IRender_Visual *> >::insert<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<IRender_Visual *> > >,0>, COMDAT
; _this$ = ecx

; 1047 :         const pointer _Whereptr = _Where._Ptr;
; 1048 :         auto& _My_data          = _Mypair._Myval2;
; 1049 :         const pointer _Oldfirst = _My_data._Myfirst;
; 1050 : #if _ITERATOR_DEBUG_LEVEL == 2
; 1051 :         _STL_VERIFY(
; 1052 :             _Where._Getcont() == _STD addressof(_My_data) && _Whereptr >= _Oldfirst && _My_data._Mylast >= _Whereptr,
; 1053 :             "vector insert iterator outside range");
; 1054 : #endif // _ITERATOR_DEBUG_LEVEL == 2
; 1055 : 
; 1056 :         _Adl_verify_range(_First, _Last);
; 1057 :         const auto _Whereoff = static_cast<size_type>(_Whereptr - _Oldfirst);

	mov	eax, DWORD PTR __Where$[esp-4]
	push	esi
	push	edi

; 1058 :         _Insert_range(_Where, _Get_unwrapped(_First), _Get_unwrapped(_Last), _Iter_cat_t<_Iter>{});

	push	DWORD PTR $T1[esp+4]
	mov	edi, ecx
	mov	esi, eax
	push	DWORD PTR __Last$[esp+8]
	push	DWORD PTR __First$[esp+12]
	sub	esi, DWORD PTR [edi]
	push	eax
	sar	esi, 2
	call	??$_Insert_range@PAPAVIRender_Visual@@@?$vector@PAVIRender_Visual@@V?$xalloc@PAVIRender_Visual@@@@@std@@AAEXV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVIRender_Visual@@@std@@@std@@@1@PAPAVIRender_Visual@@1Uforward_iterator_tag@1@@Z ; std::vector<IRender_Visual *,xalloc<IRender_Visual *> >::_Insert_range<IRender_Visual * *>

; 1819 :         return iterator(_My_data._Myfirst + _Offset, _STD addressof(_My_data));

	mov	eax, DWORD PTR [edi]

; 1059 :         return _Make_iterator_offset(_Whereoff);

	pop	edi

; 1819 :         return iterator(_My_data._Myfirst + _Offset, _STD addressof(_My_data));

	lea	ecx, DWORD PTR [eax+esi*4]

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	eax, DWORD PTR ___$ReturnUdt$[esp]

; 1059 :         return _Make_iterator_offset(_Whereoff);

	pop	esi

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	DWORD PTR [eax], ecx

; 1060 :     }

	ret	16					; 00000010H
??$insert@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVIRender_Visual@@@std@@@std@@@std@@$0A@@?$vector@PAVIRender_Visual@@V?$xalloc@PAVIRender_Visual@@@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVIRender_Visual@@@std@@@std@@@1@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVIRender_Visual@@@std@@@std@@@1@V21@1@Z ENDP ; std::vector<IRender_Visual *,xalloc<IRender_Visual *> >::insert<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<IRender_Visual *> > >,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?end@?$vector@PAVIRender_Visual@@V?$xalloc@PAVIRender_Visual@@@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVIRender_Visual@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@PAVIRender_Visual@@V?$xalloc@PAVIRender_Visual@@@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVIRender_Visual@@@std@@@std@@@2@XZ PROC ; std::vector<IRender_Visual *,xalloc<IRender_Visual *> >::end, COMDAT
; _this$ = ecx

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	ecx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax], ecx

; 1472 :         auto& _My_data = _Mypair._Myval2;
; 1473 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));
; 1474 :     }

	ret	4
?end@?$vector@PAVIRender_Visual@@V?$xalloc@PAVIRender_Visual@@@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVIRender_Visual@@@std@@@std@@@2@XZ ENDP ; std::vector<IRender_Visual *,xalloc<IRender_Visual *> >::end
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.h
;	COMDAT ?GetVisuals@SItem@CParticleGroup@PS@@QAEIAAV?$xr_vector@PAVIRender_Visual@@V?$xalloc@PAVIRender_Visual@@@@@@@Z
_TEXT	SEGMENT
$T1 = 8							; size = 1
$T2 = 8							; size = 1
_visuals$ = 8						; size = 4
?GetVisuals@SItem@CParticleGroup@PS@@QAEIAAV?$xr_vector@PAVIRender_Visual@@V?$xalloc@PAVIRender_Visual@@@@@@@Z PROC ; PS::CParticleGroup::SItem::GetVisuals, COMDAT
; _this$ = ecx

; 84   :             {

	push	esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1546 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	esi, DWORD PTR _visuals$[esp]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.h

; 84   :             {

	push	edi
	mov	edi, ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1546 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	eax, DWORD PTR [esi+8]
	sub	eax, DWORD PTR [esi]

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	ecx, DWORD PTR [edi+20]
	sub	ecx, DWORD PTR [edi+16]
	mov	edx, DWORD PTR [edi+8]
	sub	edx, DWORD PTR [edi+4]
	sar	ecx, 2
	sar	edx, 2
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.h

; 85   :             	visuals.reserve				(_children_related.size()+_children_free.size()+1);

	inc	ecx
	add	ecx, edx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1546 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	sar	eax, 2

; 1358 :         if (_Newcapacity > capacity()) { // something to do (reserve() never shrinks)

	cmp	ecx, eax
	jbe	SHORT $LN13@GetVisuals

; 1359 :             if (_Newcapacity > max_size()) {

	cmp	ecx, 1073741823				; 3fffffffH
	ja	SHORT $LN84@GetVisuals

; 1361 :             }
; 1362 : 
; 1363 :             _Reallocate_exactly(_Newcapacity);

	push	ecx
	mov	ecx, esi
	call	?_Reallocate_exactly@?$vector@PAVIRender_Visual@@V?$xalloc@PAVIRender_Visual@@@@@std@@AAEXI@Z ; std::vector<IRender_Visual *,xalloc<IRender_Visual *> >::_Reallocate_exactly
$LN13@GetVisuals:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.h

; 86   :                 if (_effect)				visuals.push_back(_effect);

	mov	ecx, DWORD PTR [edi]
	test	ecx, ecx
	je	SHORT $LN21@GetVisuals
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 730  :         if (_Mylast != _My_data._Myend) {

	mov	eax, DWORD PTR [esi+4]
	cmp	eax, DWORD PTR [esi+8]
	je	SHORT $LN22@GetVisuals

; 713  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

	mov	DWORD PTR [eax], ecx

; 714  :         _Orphan_range(_Mylast, _Mylast);
; 715  :         _Ty& _Result = *_Mylast;
; 716  :         ++_Mylast;

	add	DWORD PTR [esi+4], 4

; 731  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

	jmp	SHORT $LN21@GetVisuals
$LN22@GetVisuals:

; 732  :         }
; 733  : 
; 734  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	push	edi
	push	eax
	mov	ecx, esi
	call	??$_Emplace_reallocate@ABQAVIRender_Visual@@@?$vector@PAVIRender_Visual@@V?$xalloc@PAVIRender_Visual@@@@@std@@QAEPAPAVIRender_Visual@@QAPAV2@ABQAV2@@Z ; std::vector<IRender_Visual *,xalloc<IRender_Visual *> >::_Emplace_reallocate<IRender_Visual * const &>
$LN21@GetVisuals:

; 1058 :         _Insert_range(_Where, _Get_unwrapped(_First), _Get_unwrapped(_Last), _Iter_cat_t<_Iter>{});

	push	DWORD PTR $T2[esp+4]
	mov	ecx, esi
	push	DWORD PTR [edi+8]
	push	DWORD PTR [edi+4]
	push	DWORD PTR [esi+4]
	call	??$_Insert_range@PAPAVIRender_Visual@@@?$vector@PAVIRender_Visual@@V?$xalloc@PAVIRender_Visual@@@@@std@@AAEXV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVIRender_Visual@@@std@@@std@@@1@PAPAVIRender_Visual@@1Uforward_iterator_tag@1@@Z ; std::vector<IRender_Visual *,xalloc<IRender_Visual *> >::_Insert_range<IRender_Visual * *>
	push	DWORD PTR $T1[esp+4]
	mov	ecx, esi
	push	DWORD PTR [edi+20]
	push	DWORD PTR [edi+16]
	push	DWORD PTR [esi+4]
	call	??$_Insert_range@PAPAVIRender_Visual@@@?$vector@PAVIRender_Visual@@V?$xalloc@PAVIRender_Visual@@@@@std@@AAEXV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVIRender_Visual@@@std@@@std@@@1@PAPAVIRender_Visual@@1Uforward_iterator_tag@1@@Z ; std::vector<IRender_Visual *,xalloc<IRender_Visual *> >::_Insert_range<IRender_Visual * *>

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	eax, DWORD PTR [esi+4]
	sub	eax, DWORD PTR [esi]
	pop	edi
	sar	eax, 2
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.h

; 90   :             }

	pop	esi
	ret	4
$LN84@GetVisuals:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1360 :                 _Xlength();

	call	?_Xlength@?$vector@PAVIRender_Visual@@V?$xalloc@PAVIRender_Visual@@@@@std@@CAXXZ ; std::vector<IRender_Visual *,xalloc<IRender_Visual *> >::_Xlength
$LN82@GetVisuals:
	int	3
?GetVisuals@SItem@CParticleGroup@PS@@QAEIAAV?$xr_vector@PAVIRender_Visual@@V?$xalloc@PAVIRender_Visual@@@@@@@Z ENDP ; PS::CParticleGroup::SItem::GetVisuals
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\xrstring.h
;	COMDAT ?size@shared_str@@QBEIXZ
_TEXT	SEGMENT
?size@shared_str@@QBEIXZ PROC				; shared_str::size, COMDAT
; _this$ = ecx

; 71   : 	u32					size		()						const	{	if (0==p_) return 0; else return p_->dwLength;	}

	mov	eax, DWORD PTR [ecx]
	test	eax, eax
	jne	SHORT $LN2@size
	ret	0
$LN2@size:
	mov	eax, DWORD PTR [eax+4]
	ret	0
?size@shared_str@@QBEIXZ ENDP				; shared_str::size
_TEXT	ENDS
END
