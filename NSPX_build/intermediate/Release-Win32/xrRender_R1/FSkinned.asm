; Listing generated by Microsoft (R) Optimizing Compiler Version 19.29.30146.0 

	TITLE	i:\vitalya\mine\nsprojectx\nspx_build\intermediate\release-win32\xrrender_r1\fskinned.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	??_C@_0BJ@KMGOHEHC@CSkeletonX_ext?3?3_Load_hw@	; `string'
PUBLIC	??_C@_0DI@MPKGEPP@I?3?2Vitalya?2mine?2NSProjectX?2laye@ ; `string'
PUBLIC	??_C@_0FO@OKEEELNA@HW?4pDevice?9?$DOCreateVertexBuffer?$CI@ ; `string'
PUBLIC	??_C@_0CM@JFCBAHIP@V?4p_rm_Vertices?9?$DOLock?$CI0?00?0?$CIvoid@ ; `string'
PUBLIC	??_C@_0CC@IECPAAEB@CSkeletonX_ext?3?3_CollectBoneFac@ ; `string'
PUBLIC	??_C@_0EN@JBPJCDDE@V?9?$DOp_rm_Indices?9?$DOLock?$CI0?0V?9?$DOdwPr@ ; `string'
PUBLIC	??_C@_0EO@GEEHLIBL@V?9?$DOp_rm_Vertices?9?$DOLock?$CIV?9?$DOvBase@ ; `string'
PUBLIC	??_C@_0BL@KDGOOFMF@V?9?$DOp_rm_Vertices?9?$DOUnlock?$CI?$CJ@ ; `string'
PUBLIC	??_C@_0BK@PLGEAKCN@V?9?$DOp_rm_Indices?9?$DOUnlock?$CI?$CJ@ ; `string'
EXTRN	__imp_?AppendFace@CBoneData@@QAEXGG@Z:PROC
EXTRN	__imp_?ContactPoint@CSkeletonWallmark@@QAEABU?$_vector3@M@@XZ:PROC
EXTRN	__imp_?LL_GetBoneInstance@CKinematics@@QAEAAVCBoneInstance@@G@Z:PROC
EXTRN	__imp_?LL_GetData@CKinematics@@QAEAAVCBoneData@@G@Z:PROC
EXTRN	__imp_?get_pos@vertBoned1W@@QAEXAAU?$_vector3@M@@@Z:PROC
EXTRN	__imp_?get_pos@vertBoned2W@@QAEXAAU?$_vector3@M@@@Z:PROC
EXTRN	__imp_?_FillVerticesSoft2W@CSkeletonX@@IAEXABU?$_matrix@M@@AAVCSkeletonWallmark@@ABU?$_vector3@M@@MPAGAAV?$xr_vector@GV?$xalloc@G@@@@@Z:PROC
EXTRN	__imp_?_FillVerticesSoft1W@CSkeletonX@@IAEXABU?$_matrix@M@@AAVCSkeletonWallmark@@ABU?$_vector3@M@@MPAGAAV?$xr_vector@GV?$xalloc@G@@@@@Z:PROC
EXTRN	__imp_?_PickBoneSoft2W@CSkeletonX@@IAEHAAU?$_vector3@M@@AAMABU2@2PAGAAV?$xr_vector@GV?$xalloc@G@@@@@Z:PROC
EXTRN	__imp_?_PickBoneSoft1W@CSkeletonX@@IAEHAAU?$_vector3@M@@AAMABU2@2PAGAAV?$xr_vector@GV?$xalloc@G@@@@@Z:PROC
EXTRN	__imp_?AfterLoad@CSkeletonX@@UAEXPAVCKinematics@@G@Z:PROC
EXTRN	__imp__D3DXGetDeclVertexSize@8:PROC
EXTRN	__imp_?Render@@3PAVIRender_interface@@A:DWORD
EXTRN	__imp_?shader_option_skinning@IRender_interface@@QAEXH@Z:PROC
EXTRN	__imp_?_Load@CSkeletonX@@IAEXPBDPAVIReader@@AAI@Z:PROC
EXTRN	__imp_?_Render@CSkeletonX@@IAEXAAV?$resptr_core@USGeometry@@Uresptrcode_geom@@@@III@Z:PROC
EXTRN	__imp_?_Copy@CSkeletonX@@IAEXPAV1@@Z:PROC
EXTRN	_atexit:PROC
;	COMDAT ?ignore_always@?CI@??_CollectBoneFaces@CSkeletonX_ext@@MAEXPAVFvisual@@II@Z@4_NA
_BSS	SEGMENT
?ignore_always@?CI@??_CollectBoneFaces@CSkeletonX_ext@@MAEXPAVFvisual@@II@Z@4_NA DB 01H DUP (?) ; `CSkeletonX_ext::_CollectBoneFaces'::`40'::ignore_always
_BSS	ENDS
;	COMDAT ?ignore_always@?CE@??_CollectBoneFaces@CSkeletonX_ext@@MAEXPAVFvisual@@II@Z@4_NA
_BSS	SEGMENT
?ignore_always@?CE@??_CollectBoneFaces@CSkeletonX_ext@@MAEXPAVFvisual@@II@Z@4_NA DB 01H DUP (?) ; `CSkeletonX_ext::_CollectBoneFaces'::`36'::ignore_always
_BSS	ENDS
;	COMDAT ?ignore_always@?BO@??_CollectBoneFaces@CSkeletonX_ext@@MAEXPAVFvisual@@II@Z@4_NA
_BSS	SEGMENT
?ignore_always@?BO@??_CollectBoneFaces@CSkeletonX_ext@@MAEXPAVFvisual@@II@Z@4_NA DB 01H DUP (?) ; `CSkeletonX_ext::_CollectBoneFaces'::`30'::ignore_always
_BSS	ENDS
;	COMDAT ?ignore_always@?BH@??_CollectBoneFaces@CSkeletonX_ext@@MAEXPAVFvisual@@II@Z@4_NA
_BSS	SEGMENT
?ignore_always@?BH@??_CollectBoneFaces@CSkeletonX_ext@@MAEXPAVFvisual@@II@Z@4_NA DB 01H DUP (?) ; `CSkeletonX_ext::_CollectBoneFaces'::`23'::ignore_always
_BSS	ENDS
;	COMDAT ?ignore_always@?3??_CollectBoneFaces@CSkeletonX_ext@@MAEXPAVFvisual@@II@Z@4_NA
_BSS	SEGMENT
?ignore_always@?3??_CollectBoneFaces@CSkeletonX_ext@@MAEXPAVFvisual@@II@Z@4_NA DB 01H DUP (?) ; `CSkeletonX_ext::_CollectBoneFaces'::`4'::ignore_always
_BSS	ENDS
;	COMDAT ?ignore_always@?BO@??_Load_hw@CSkeletonX_ext@@MAEXAAVFvisual@@PAX@Z@4_NA
_BSS	SEGMENT
?ignore_always@?BO@??_Load_hw@CSkeletonX_ext@@MAEXAAVFvisual@@PAX@Z@4_NA DB 01H DUP (?) ; `CSkeletonX_ext::_Load_hw'::`30'::ignore_always
_BSS	ENDS
;	COMDAT ?ignore_always@?BK@??_Load_hw@CSkeletonX_ext@@MAEXAAVFvisual@@PAX@Z@4_NA
_BSS	SEGMENT
?ignore_always@?BK@??_Load_hw@CSkeletonX_ext@@MAEXAAVFvisual@@PAX@Z@4_NA DB 01H DUP (?) ; `CSkeletonX_ext::_Load_hw'::`26'::ignore_always
_BSS	ENDS
;	COMDAT ?ignore_always@?P@??_Load_hw@CSkeletonX_ext@@MAEXAAVFvisual@@PAX@Z@4_NA
_BSS	SEGMENT
?ignore_always@?P@??_Load_hw@CSkeletonX_ext@@MAEXAAVFvisual@@PAX@Z@4_NA DB 01H DUP (?) ; `CSkeletonX_ext::_Load_hw'::`15'::ignore_always
_BSS	ENDS
;	COMDAT ?ignore_always@?L@??_Load_hw@CSkeletonX_ext@@MAEXAAVFvisual@@PAX@Z@4_NA
_BSS	SEGMENT
?ignore_always@?L@??_Load_hw@CSkeletonX_ext@@MAEXAAVFvisual@@PAX@Z@4_NA DB 01H DUP (?) ; `CSkeletonX_ext::_Load_hw'::`11'::ignore_always
_BSS	ENDS
;	COMDAT ??_C@_0BK@PLGEAKCN@V?9?$DOp_rm_Indices?9?$DOUnlock?$CI?$CJ@
CONST	SEGMENT
??_C@_0BK@PLGEAKCN@V?9?$DOp_rm_Indices?9?$DOUnlock?$CI?$CJ@ DB 'V->p_rm_I'
	DB	'ndices->Unlock()', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@KDGOOFMF@V?9?$DOp_rm_Vertices?9?$DOUnlock?$CI?$CJ@
CONST	SEGMENT
??_C@_0BL@KDGOOFMF@V?9?$DOp_rm_Vertices?9?$DOUnlock?$CI?$CJ@ DB 'V->p_rm_'
	DB	'Vertices->Unlock()', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0EO@GEEHLIBL@V?9?$DOp_rm_Vertices?9?$DOLock?$CIV?9?$DOvBase@
CONST	SEGMENT
??_C@_0EO@GEEHLIBL@V?9?$DOp_rm_Vertices?9?$DOLock?$CIV?9?$DOvBase@ DB 'V-'
	DB	'>p_rm_Vertices->Lock(V->vBase,V->vCount,(void**)&vertices,D3D'
	DB	'LOCK_READONLY)', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0EN@JBPJCDDE@V?9?$DOp_rm_Indices?9?$DOLock?$CI0?0V?9?$DOdwPr@
CONST	SEGMENT
??_C@_0EN@JBPJCDDE@V?9?$DOp_rm_Indices?9?$DOLock?$CI0?0V?9?$DOdwPr@ DB 'V'
	DB	'->p_rm_Indices->Lock(0,V->dwPrimitives*3,(void**)&indices,D3D'
	DB	'LOCK_READONLY)', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@IECPAAEB@CSkeletonX_ext?3?3_CollectBoneFac@
CONST	SEGMENT
??_C@_0CC@IECPAAEB@CSkeletonX_ext?3?3_CollectBoneFac@ DB 'CSkeletonX_ext:'
	DB	':_CollectBoneFaces', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@JFCBAHIP@V?4p_rm_Vertices?9?$DOLock?$CI0?00?0?$CIvoid@
CONST	SEGMENT
??_C@_0CM@JFCBAHIP@V?4p_rm_Vertices?9?$DOLock?$CI0?00?0?$CIvoid@ DB 'V.p_'
	DB	'rm_Vertices->Lock(0,0,(void**)&bytes,0)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0FO@OKEEELNA@HW?4pDevice?9?$DOCreateVertexBuffer?$CI@
CONST	SEGMENT
??_C@_0FO@OKEEELNA@HW?4pDevice?9?$DOCreateVertexBuffer?$CI@ DB 'HW.pDevic'
	DB	'e->CreateVertexBuffer(V.vCount*vStride,dwUsage,0,D3DPOOL_MANA'
	DB	'GED,&V.p_rm_Vertices,0)', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DI@MPKGEPP@I?3?2Vitalya?2mine?2NSProjectX?2laye@
CONST	SEGMENT
??_C@_0DI@MPKGEPP@I?3?2Vitalya?2mine?2NSProjectX?2laye@ DB 'I:\Vitalya\mi'
	DB	'ne\NSProjectX\layers\xrRender\FSkinned.cpp', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@KMGOHEHC@CSkeletonX_ext?3?3_Load_hw@
CONST	SEGMENT
??_C@_0BJ@KMGOHEHC@CSkeletonX_ext?3?3_Load_hw@ DB 'CSkeletonX_ext::_Load_'
	DB	'hw', 00H					; `string'
?_Fake_alloc@std@@3U_Fake_allocator@1@B	ORG $+1		; std::_Fake_alloc
PUBLIC	?set@?$_vector2@M@@QAEAAU1@MM@Z			; _vector2<float>::set
PUBLIC	?_abs@@YAMM@Z					; _abs
PUBLIC	_fabsf
PUBLIC	??0shared_str@@QAE@XZ				; shared_str::shared_str
PUBLIC	??$clampr@H@@YAHABH00@Z				; clampr<int>
PUBLIC	?color_rgba@@YAIIIII@Z				; color_rgba
PUBLIC	?color_argb@@YAIIIII@Z				; color_argb
PUBLIC	?color_get_A@@YAII@Z				; color_get_A
PUBLIC	??$construct@UWMFace@CSkeletonWallmark@@U12@@?$_Normal_allocator_traits@V?$xalloc@UWMFace@CSkeletonWallmark@@@@@std@@SAXAAV?$xalloc@UWMFace@CSkeletonWallmark@@@@PAUWMFace@CSkeletonWallmark@@$$QAU34@@Z ; std::_Normal_allocator_traits<xalloc<CSkeletonWallmark::WMFace> >::construct<CSkeletonWallmark::WMFace,CSkeletonWallmark::WMFace>
PUBLIC	??$forward@UWMFace@CSkeletonWallmark@@@std@@YA$$QAUWMFace@CSkeletonWallmark@@AAU12@@Z ; std::forward<CSkeletonWallmark::WMFace>
PUBLIC	??$_Destroy_in_place@PAUWMFace@CSkeletonWallmark@@@std@@YAXAAPAUWMFace@CSkeletonWallmark@@@Z ; std::_Destroy_in_place<CSkeletonWallmark::WMFace *>
PUBLIC	??$_Emplace_back@UWMFace@CSkeletonWallmark@@@?$_Uninitialized_backout_al@V?$xalloc@UWMFace@CSkeletonWallmark@@@@@std@@QAEX$$QAUWMFace@CSkeletonWallmark@@@Z ; std::_Uninitialized_backout_al<xalloc<CSkeletonWallmark::WMFace> >::_Emplace_back<CSkeletonWallmark::WMFace>
PUBLIC	??$move@AAUWMFace@CSkeletonWallmark@@@std@@YA$$QAUWMFace@CSkeletonWallmark@@AAU12@@Z ; std::move<CSkeletonWallmark::WMFace &>
PUBLIC	?destroy@?$xalloc@UWMFace@CSkeletonWallmark@@@@QAEXPAUWMFace@CSkeletonWallmark@@@Z ; xalloc<CSkeletonWallmark::WMFace>::destroy
PUBLIC	??0?$_Uninitialized_backout_al@V?$xalloc@UWMFace@CSkeletonWallmark@@@@@std@@QAE@PAUWMFace@CSkeletonWallmark@@AAV?$xalloc@UWMFace@CSkeletonWallmark@@@@@Z ; std::_Uninitialized_backout_al<xalloc<CSkeletonWallmark::WMFace> >::_Uninitialized_backout_al<xalloc<CSkeletonWallmark::WMFace> >
PUBLIC	??1?$_Uninitialized_backout_al@V?$xalloc@UWMFace@CSkeletonWallmark@@@@@std@@QAE@XZ ; std::_Uninitialized_backout_al<xalloc<CSkeletonWallmark::WMFace> >::~_Uninitialized_backout_al<xalloc<CSkeletonWallmark::WMFace> >
PUBLIC	?_Release@?$_Uninitialized_backout_al@V?$xalloc@UWMFace@CSkeletonWallmark@@@@@std@@QAEPAUWMFace@CSkeletonWallmark@@XZ ; std::_Uninitialized_backout_al<xalloc<CSkeletonWallmark::WMFace> >::_Release
PUBLIC	??$xr_alloc@UWMFace@CSkeletonWallmark@@@@YAPAUWMFace@CSkeletonWallmark@@I@Z ; xr_alloc<CSkeletonWallmark::WMFace>
PUBLIC	??$_Get_unwrapped@ABQAUWMFace@CSkeletonWallmark@@@std@@YA?A_TABQAUWMFace@CSkeletonWallmark@@@Z ; std::_Get_unwrapped<CSkeletonWallmark::WMFace * const &>
PUBLIC	??$_Uninitialized_move@PAUWMFace@CSkeletonWallmark@@V?$xalloc@UWMFace@CSkeletonWallmark@@@@@std@@YAPAUWMFace@CSkeletonWallmark@@QAU12@0PAU12@AAV?$xalloc@UWMFace@CSkeletonWallmark@@@@@Z ; std::_Uninitialized_move<CSkeletonWallmark::WMFace *,xalloc<CSkeletonWallmark::WMFace> >
PUBLIC	??$destroy@UWMFace@CSkeletonWallmark@@@?$_Normal_allocator_traits@V?$xalloc@UWMFace@CSkeletonWallmark@@@@@std@@SAXAAV?$xalloc@UWMFace@CSkeletonWallmark@@@@PAUWMFace@CSkeletonWallmark@@@Z ; std::_Normal_allocator_traits<xalloc<CSkeletonWallmark::WMFace> >::destroy<CSkeletonWallmark::WMFace>
PUBLIC	?max_size@?$xalloc@UWMFace@CSkeletonWallmark@@@@QBEIXZ ; xalloc<CSkeletonWallmark::WMFace>::max_size
PUBLIC	?_Get_first@?$_Compressed_pair@V?$xalloc@UWMFace@CSkeletonWallmark@@@@V?$_Vector_val@U?$_Simple_types@UWMFace@CSkeletonWallmark@@@std@@@std@@$00@std@@QBEABV?$xalloc@UWMFace@CSkeletonWallmark@@@@XZ ; std::_Compressed_pair<xalloc<CSkeletonWallmark::WMFace>,std::_Vector_val<std::_Simple_types<CSkeletonWallmark::WMFace> >,1>::_Get_first
PUBLIC	?max_size@?$_Normal_allocator_traits@V?$xalloc@UWMFace@CSkeletonWallmark@@@@@std@@SAIABV?$xalloc@UWMFace@CSkeletonWallmark@@@@@Z ; std::_Normal_allocator_traits<xalloc<CSkeletonWallmark::WMFace> >::max_size
PUBLIC	?capacity@?$vector@UWMFace@CSkeletonWallmark@@V?$xalloc@UWMFace@CSkeletonWallmark@@@@@std@@QBEIXZ ; std::vector<CSkeletonWallmark::WMFace,xalloc<CSkeletonWallmark::WMFace> >::capacity
PUBLIC	?_Umove_if_noexcept1@?$vector@UWMFace@CSkeletonWallmark@@V?$xalloc@UWMFace@CSkeletonWallmark@@@@@std@@AAEXPAUWMFace@CSkeletonWallmark@@00U?$integral_constant@_N$00@2@@Z ; std::vector<CSkeletonWallmark::WMFace,xalloc<CSkeletonWallmark::WMFace> >::_Umove_if_noexcept1
PUBLIC	?_Getal@?$vector@UWMFace@CSkeletonWallmark@@V?$xalloc@UWMFace@CSkeletonWallmark@@@@@std@@ABEABV?$xalloc@UWMFace@CSkeletonWallmark@@@@XZ ; std::vector<CSkeletonWallmark::WMFace,xalloc<CSkeletonWallmark::WMFace> >::_Getal
PUBLIC	?allocate@?$xalloc@UWMFace@CSkeletonWallmark@@@@QBEPAUWMFace@CSkeletonWallmark@@IPBX@Z ; xalloc<CSkeletonWallmark::WMFace>::allocate
PUBLIC	?construct@?$xalloc@UWMFace@CSkeletonWallmark@@@@QAEXPAUWMFace@CSkeletonWallmark@@ABU23@@Z ; xalloc<CSkeletonWallmark::WMFace>::construct
PUBLIC	?max_size@?$vector@UWMFace@CSkeletonWallmark@@V?$xalloc@UWMFace@CSkeletonWallmark@@@@@std@@QBEIXZ ; std::vector<CSkeletonWallmark::WMFace,xalloc<CSkeletonWallmark::WMFace> >::max_size
PUBLIC	?_Umove@?$vector@UWMFace@CSkeletonWallmark@@V?$xalloc@UWMFace@CSkeletonWallmark@@@@@std@@AAEPAUWMFace@CSkeletonWallmark@@PAU34@00@Z ; std::vector<CSkeletonWallmark::WMFace,xalloc<CSkeletonWallmark::WMFace> >::_Umove
PUBLIC	?_Umove_if_noexcept@?$vector@UWMFace@CSkeletonWallmark@@V?$xalloc@UWMFace@CSkeletonWallmark@@@@@std@@AAEXPAUWMFace@CSkeletonWallmark@@00@Z ; std::vector<CSkeletonWallmark::WMFace,xalloc<CSkeletonWallmark::WMFace> >::_Umove_if_noexcept
PUBLIC	?_Calculate_growth@?$vector@UWMFace@CSkeletonWallmark@@V?$xalloc@UWMFace@CSkeletonWallmark@@@@@std@@ABEII@Z ; std::vector<CSkeletonWallmark::WMFace,xalloc<CSkeletonWallmark::WMFace> >::_Calculate_growth
PUBLIC	?_Change_array@?$vector@UWMFace@CSkeletonWallmark@@V?$xalloc@UWMFace@CSkeletonWallmark@@@@@std@@AAEXQAUWMFace@CSkeletonWallmark@@II@Z ; std::vector<CSkeletonWallmark::WMFace,xalloc<CSkeletonWallmark::WMFace> >::_Change_array
PUBLIC	?_Xlength@?$vector@UWMFace@CSkeletonWallmark@@V?$xalloc@UWMFace@CSkeletonWallmark@@@@@std@@CAXXZ ; std::vector<CSkeletonWallmark::WMFace,xalloc<CSkeletonWallmark::WMFace> >::_Xlength
PUBLIC	??A?$ref_smem@UvertBoned1W@@@@QAEAAUvertBoned1W@@I@Z ; ref_smem<vertBoned1W>::operator[]
PUBLIC	??A?$ref_smem@UvertBoned2W@@@@QAEAAUvertBoned2W@@I@Z ; ref_smem<vertBoned2W>::operator[]
PUBLIC	??$xr_free@UWMFace@CSkeletonWallmark@@@@YAXAAPAUWMFace@CSkeletonWallmark@@@Z ; xr_free<CSkeletonWallmark::WMFace>
PUBLIC	??$_Destroy_range@V?$xalloc@UWMFace@CSkeletonWallmark@@@@@std@@YAXPAUWMFace@CSkeletonWallmark@@QAU12@AAV?$xalloc@UWMFace@CSkeletonWallmark@@@@@Z ; std::_Destroy_range<xalloc<CSkeletonWallmark::WMFace> >
PUBLIC	??$addressof@V?$_Vector_val@U?$_Simple_types@V?$xr_vector@GV?$xalloc@G@@@@@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@V?$xr_vector@GV?$xalloc@G@@@@@std@@@0@AAV10@@Z ; std::addressof<std::_Vector_val<std::_Simple_types<xr_vector<unsigned short,xalloc<unsigned short> > > > >
PUBLIC	??$_Emplace_reallocate@ABUWMFace@CSkeletonWallmark@@@?$vector@UWMFace@CSkeletonWallmark@@V?$xalloc@UWMFace@CSkeletonWallmark@@@@@std@@QAEPAUWMFace@CSkeletonWallmark@@QAU23@ABU23@@Z ; std::vector<CSkeletonWallmark::WMFace,xalloc<CSkeletonWallmark::WMFace> >::_Emplace_reallocate<CSkeletonWallmark::WMFace const &>
PUBLIC	??$construct@UWMFace@CSkeletonWallmark@@ABU12@@?$_Normal_allocator_traits@V?$xalloc@UWMFace@CSkeletonWallmark@@@@@std@@SAXAAV?$xalloc@UWMFace@CSkeletonWallmark@@@@PAUWMFace@CSkeletonWallmark@@ABU34@@Z ; std::_Normal_allocator_traits<xalloc<CSkeletonWallmark::WMFace> >::construct<CSkeletonWallmark::WMFace,CSkeletonWallmark::WMFace const &>
PUBLIC	??$_Unfancy@UWMFace@CSkeletonWallmark@@@std@@YAPAUWMFace@CSkeletonWallmark@@PAU12@@Z ; std::_Unfancy<CSkeletonWallmark::WMFace>
PUBLIC	??$forward@ABUWMFace@CSkeletonWallmark@@@std@@YAABUWMFace@CSkeletonWallmark@@ABU12@@Z ; std::forward<CSkeletonWallmark::WMFace const &>
PUBLIC	??$TEnumBoneVertices@PAUvertHW_2W@@@@YAXPAUvertHW_2W@@PAGAAV?$xr_vector@GV?$xalloc@G@@@@AAUSEnumVerticesCallback@@@Z ; TEnumBoneVertices<vertHW_2W *>
PUBLIC	??$TEnumBoneVertices@PAUvertHW_1W@@@@YAXPAUvertHW_1W@@PAGAAV?$xr_vector@GV?$xalloc@G@@@@AAUSEnumVerticesCallback@@@Z ; TEnumBoneVertices<vertHW_1W *>
PUBLIC	??$TEnumBoneVertices@V?$ref_smem@UvertBoned2W@@@@@@YAXV?$ref_smem@UvertBoned2W@@@@PAGAAV?$xr_vector@GV?$xalloc@G@@@@AAUSEnumVerticesCallback@@@Z ; TEnumBoneVertices<ref_smem<vertBoned2W> >
PUBLIC	??$TEnumBoneVertices@V?$ref_smem@UvertBoned1W@@@@@@YAXV?$ref_smem@UvertBoned1W@@@@PAGAAV?$xr_vector@GV?$xalloc@G@@@@AAUSEnumVerticesCallback@@@Z ; TEnumBoneVertices<ref_smem<vertBoned1W> >
PUBLIC	?_Verify_offset@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$xr_vector@GV?$xalloc@G@@@@@std@@@std@@@std@@QBEXH@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<xr_vector<unsigned short,xalloc<unsigned short> > > > >::_Verify_offset
PUBLIC	??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$xr_vector@GV?$xalloc@G@@@@@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<xr_vector<unsigned short,xalloc<unsigned short> > > > >::operator+=
PUBLIC	??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$xr_vector@GV?$xalloc@G@@@@@std@@@std@@@std@@QBEABV?$xr_vector@GV?$xalloc@G@@@@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<xr_vector<unsigned short,xalloc<unsigned short> > > > >::operator*
PUBLIC	??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$xr_vector@GV?$xalloc@G@@@@@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<xr_vector<unsigned short,xalloc<unsigned short> > > > >::operator+=
PUBLIC	?deallocate@?$xalloc@UWMFace@CSkeletonWallmark@@@@QBEXPAUWMFace@CSkeletonWallmark@@I@Z ; xalloc<CSkeletonWallmark::WMFace>::deallocate
PUBLIC	?_Destroy@?$vector@UWMFace@CSkeletonWallmark@@V?$xalloc@UWMFace@CSkeletonWallmark@@@@@std@@AAEXPAUWMFace@CSkeletonWallmark@@0@Z ; std::vector<CSkeletonWallmark::WMFace,xalloc<CSkeletonWallmark::WMFace> >::_Destroy
PUBLIC	?_Get_first@?$_Compressed_pair@V?$xalloc@UWMFace@CSkeletonWallmark@@@@V?$_Vector_val@U?$_Simple_types@UWMFace@CSkeletonWallmark@@@std@@@std@@$00@std@@QAEAAV?$xalloc@UWMFace@CSkeletonWallmark@@@@XZ ; std::_Compressed_pair<xalloc<CSkeletonWallmark::WMFace>,std::_Vector_val<std::_Simple_types<CSkeletonWallmark::WMFace> >,1>::_Get_first
PUBLIC	?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@G@std@@@std@@@std@@QBEXABV12@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned short> > >::_Compat
PUBLIC	??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$xr_vector@GV?$xalloc@G@@@@@std@@@std@@@std@@QAE@PAV?$xr_vector@GV?$xalloc@G@@@@PBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<xr_vector<unsigned short,xalloc<unsigned short> > > > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<xr_vector<unsigned short,xalloc<unsigned short> > > > >
PUBLIC	??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$xr_vector@GV?$xalloc@G@@@@@std@@@std@@@std@@QBEAAV?$xr_vector@GV?$xalloc@G@@@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<xr_vector<unsigned short,xalloc<unsigned short> > > > >::operator*
PUBLIC	??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$xr_vector@GV?$xalloc@G@@@@@std@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<xr_vector<unsigned short,xalloc<unsigned short> > > > >::operator+
PUBLIC	?_Orphan_range@?$vector@UWMFace@CSkeletonWallmark@@V?$xalloc@UWMFace@CSkeletonWallmark@@@@@std@@ABEXPAUWMFace@CSkeletonWallmark@@0@Z ; std::vector<CSkeletonWallmark::WMFace,xalloc<CSkeletonWallmark::WMFace> >::_Orphan_range
PUBLIC	?_Getal@?$vector@UWMFace@CSkeletonWallmark@@V?$xalloc@UWMFace@CSkeletonWallmark@@@@@std@@AAEAAV?$xalloc@UWMFace@CSkeletonWallmark@@@@XZ ; std::vector<CSkeletonWallmark::WMFace,xalloc<CSkeletonWallmark::WMFace> >::_Getal
PUBLIC	?_dec@?$ref_smem@UvertBoned1W@@@@IAEXXZ		; ref_smem<vertBoned1W>::_dec
PUBLIC	?_set@?$ref_smem@UvertBoned1W@@@@QAEXABV1@@Z	; ref_smem<vertBoned1W>::_set
PUBLIC	?_dec@?$ref_smem@UvertBoned2W@@@@IAEXXZ		; ref_smem<vertBoned2W>::_dec
PUBLIC	?_set@?$ref_smem@UvertBoned2W@@@@QAEXABV1@@Z	; ref_smem<vertBoned2W>::_set
PUBLIC	??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@G@std@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned short> > >::operator++
PUBLIC	??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@G@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned short> > >::operator==
PUBLIC	??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$xr_vector@GV?$xalloc@G@@@@@std@@@std@@@std@@QAE@PAV?$xr_vector@GV?$xalloc@G@@@@PBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<xr_vector<unsigned short,xalloc<unsigned short> > > > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<xr_vector<unsigned short,xalloc<unsigned short> > > > >
PUBLIC	?lerp@?$_vector3@M@@QAEAAU1@ABU1@0M@Z		; _vector3<float>::lerp
PUBLIC	?square_magnitude@?$_vector3@M@@QBEMXZ		; _vector3<float>::square_magnitude
PUBLIC	?end@?$vector@GV?$xalloc@G@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@G@std@@@std@@@2@XZ ; std::vector<unsigned short,xalloc<unsigned short> >::end
PUBLIC	?transform_tiny@?$_matrix@M@@QBEXAAU?$_vector3@M@@@Z ; _matrix<float>::transform_tiny
PUBLIC	?begin@?$vector@V?$xr_vector@GV?$xalloc@G@@@@V?$xalloc@V?$xr_vector@GV?$xalloc@G@@@@@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$xr_vector@GV?$xalloc@G@@@@@std@@@std@@@2@XZ ; std::vector<xr_vector<unsigned short,xalloc<unsigned short> >,xalloc<xr_vector<unsigned short,xalloc<unsigned short> > > >::begin
PUBLIC	??A?$xr_vector@V?$xr_vector@GV?$xalloc@G@@@@V?$xalloc@V?$xr_vector@GV?$xalloc@G@@@@@@@@QAEAAV?$xr_vector@GV?$xalloc@G@@@@I@Z ; xr_vector<xr_vector<unsigned short,xalloc<unsigned short> >,xalloc<xr_vector<unsigned short,xalloc<unsigned short> > > >::operator[]
PUBLIC	??$_Emplace_back_with_unused_capacity@ABUWMFace@CSkeletonWallmark@@@?$vector@UWMFace@CSkeletonWallmark@@V?$xalloc@UWMFace@CSkeletonWallmark@@@@@std@@AAE?A_TABUWMFace@CSkeletonWallmark@@@Z ; std::vector<CSkeletonWallmark::WMFace,xalloc<CSkeletonWallmark::WMFace> >::_Emplace_back_with_unused_capacity<CSkeletonWallmark::WMFace const &>
PUBLIC	??$emplace_back@ABUWMFace@CSkeletonWallmark@@@?$vector@UWMFace@CSkeletonWallmark@@V?$xalloc@UWMFace@CSkeletonWallmark@@@@@std@@QAE?A_TABUWMFace@CSkeletonWallmark@@@Z ; std::vector<CSkeletonWallmark::WMFace,xalloc<CSkeletonWallmark::WMFace> >::emplace_back<CSkeletonWallmark::WMFace const &>
PUBLIC	?push_back@?$vector@UWMFace@CSkeletonWallmark@@V?$xalloc@UWMFace@CSkeletonWallmark@@@@@std@@QAEXABUWMFace@CSkeletonWallmark@@@Z ; std::vector<CSkeletonWallmark::WMFace,xalloc<CSkeletonWallmark::WMFace> >::push_back
PUBLIC	??0?$ref_smem@UvertBoned1W@@@@QAE@ABV0@@Z	; ref_smem<vertBoned1W>::ref_smem<vertBoned1W>
PUBLIC	??1?$ref_smem@UvertBoned1W@@@@QAE@XZ		; ref_smem<vertBoned1W>::~ref_smem<vertBoned1W>
PUBLIC	??D?$ref_smem@UvertBoned1W@@@@QBEPAUvertBoned1W@@XZ ; ref_smem<vertBoned1W>::operator*
PUBLIC	??0?$ref_smem@UvertBoned2W@@@@QAE@ABV0@@Z	; ref_smem<vertBoned2W>::ref_smem<vertBoned2W>
PUBLIC	??1?$ref_smem@UvertBoned2W@@@@QAE@XZ		; ref_smem<vertBoned2W>::~ref_smem<vertBoned2W>
PUBLIC	??D?$ref_smem@UvertBoned2W@@@@QBEPAUvertBoned2W@@XZ ; ref_smem<vertBoned2W>::operator*
PUBLIC	??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@G@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned short> > >::operator!=
PUBLIC	??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@G@std@@@std@@@std@@QAE?AV01@H@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned short> > >::operator++
PUBLIC	?_EnumBoneVertices@CSkeletonX_ext@@IBEXAAUSEnumVerticesCallback@@PAVFvisual@@GII@Z ; CSkeletonX_ext::_EnumBoneVertices
PUBLIC	?FillVertices@CSkeletonX_PM@@UAEXABU?$_matrix@M@@AAVCSkeletonWallmark@@ABU?$_vector3@M@@MG@Z ; CSkeletonX_PM::FillVertices
PUBLIC	?FillVertices@CSkeletonX_ST@@UAEXABU?$_matrix@M@@AAVCSkeletonWallmark@@ABU?$_vector3@M@@MG@Z ; CSkeletonX_ST::FillVertices
PUBLIC	?_FillVertices@CSkeletonX_ext@@MAEXABU?$_matrix@M@@AAVCSkeletonWallmark@@ABU?$_vector3@M@@MPAVFvisual@@GII@Z ; CSkeletonX_ext::_FillVertices
PUBLIC	?_FillVerticesHW2W@CSkeletonX_ext@@MAEXABU?$_matrix@M@@AAVCSkeletonWallmark@@ABU?$_vector3@M@@MPAVFvisual@@PAGAAV?$xr_vector@GV?$xalloc@G@@@@@Z ; CSkeletonX_ext::_FillVerticesHW2W
PUBLIC	?_FillVerticesHW1W@CSkeletonX_ext@@MAEXABU?$_matrix@M@@AAVCSkeletonWallmark@@ABU?$_vector3@M@@MPAVFvisual@@PAGAAV?$xr_vector@GV?$xalloc@G@@@@@Z ; CSkeletonX_ext::_FillVerticesHW1W
PUBLIC	?EnumBoneVertices@CSkeletonX_PM@@UAEXAAUSEnumVerticesCallback@@G@Z ; CSkeletonX_PM::EnumBoneVertices
PUBLIC	?EnumBoneVertices@CSkeletonX_ST@@UAEXAAUSEnumVerticesCallback@@G@Z ; CSkeletonX_ST::EnumBoneVertices
PUBLIC	?PickBone@CSkeletonX_PM@@UAEHAAU?$_vector3@M@@AAMABU2@2G@Z ; CSkeletonX_PM::PickBone
PUBLIC	?PickBone@CSkeletonX_ST@@UAEHAAU?$_vector3@M@@AAMABU2@2G@Z ; CSkeletonX_ST::PickBone
PUBLIC	?_PickBone@CSkeletonX_ext@@MAEHAAU?$_vector3@M@@AAMABU2@2PAVFvisual@@GII@Z ; CSkeletonX_ext::_PickBone
PUBLIC	?_PickBoneHW2W@CSkeletonX_ext@@MAEHAAU?$_vector3@M@@AAMABU2@2PAVFvisual@@PAGAAV?$xr_vector@GV?$xalloc@G@@@@@Z ; CSkeletonX_ext::_PickBoneHW2W
PUBLIC	?_PickBoneHW1W@CSkeletonX_ext@@MAEHAAU?$_vector3@M@@AAMABU2@2PAVFvisual@@PAGAAV?$xr_vector@GV?$xalloc@G@@@@@Z ; CSkeletonX_ext::_PickBoneHW1W
PUBLIC	?AfterLoad@CSkeletonX_PM@@UAEXPAVCKinematics@@G@Z ; CSkeletonX_PM::AfterLoad
PUBLIC	?AfterLoad@CSkeletonX_ST@@UAEXPAVCKinematics@@G@Z ; CSkeletonX_ST::AfterLoad
PUBLIC	?_CollectBoneFaces@CSkeletonX_ext@@MAEXPAVFvisual@@II@Z ; CSkeletonX_ext::_CollectBoneFaces
PUBLIC	?TestSphereTri@CDB@@YA?AW4EST_Result@1@ABU?$_vector3@M@@MPAU3@@Z ; CDB::TestSphereTri
PUBLIC	?TestSphereTri@CDB@@YA?AW4EST_Result@1@ABU?$_vector3@M@@M000@Z ; CDB::TestSphereTri
PUBLIC	?MgcSqrDistance@CDB@@YAMABU?$_vector3@M@@000@Z	; CDB::MgcSqrDistance
PUBLIC	?_Load_hw@CSkeletonX_ext@@MAEXAAVFvisual@@PAX@Z	; CSkeletonX_ext::_Load_hw
PUBLIC	?Load@CSkeletonX_ST@@UAEXPBDPAVIReader@@I@Z	; CSkeletonX_ST::Load
PUBLIC	?Load@CSkeletonX_PM@@UAEXPBDPAVIReader@@I@Z	; CSkeletonX_PM::Load
PUBLIC	?Release@CSkeletonX_ST@@UAEXXZ			; CSkeletonX_ST::Release
PUBLIC	?Release@CSkeletonX_PM@@UAEXXZ			; CSkeletonX_PM::Release
PUBLIC	?Render@CSkeletonX_ST@@UAEXM@Z			; CSkeletonX_ST::Render
PUBLIC	?Render@CSkeletonX_PM@@UAEXM@Z			; CSkeletonX_PM::Render
PUBLIC	?Copy@CSkeletonX_ST@@UAEXPAVIRender_Visual@@@Z	; CSkeletonX_ST::Copy
PUBLIC	?Copy@CSkeletonX_PM@@UAEXPAVIRender_Visual@@@Z	; CSkeletonX_PM::Copy
PUBLIC	?get_pos@vertHW_2W@@QAEXAAU?$_vector3@M@@@Z	; vertHW_2W::get_pos
PUBLIC	?get_bone@vertHW_2W@@QAEGG@Z			; vertHW_2W::get_bone
PUBLIC	?get_weight@vertHW_2W@@QAEMXZ			; vertHW_2W::get_weight
PUBLIC	?set@vertHW_2W@@QAEXAAU?$_vector3@M@@U2@11AAU?$_vector2@M@@HHM@Z ; vertHW_2W::set
PUBLIC	?get_pos@vertHW_1W@@QAEXAAU?$_vector3@M@@@Z	; vertHW_1W::get_pos
PUBLIC	?get_bone@vertHW_1W@@QAEGXZ			; vertHW_1W::get_bone
PUBLIC	?set@vertHW_1W@@QAEXAAU?$_vector3@M@@U2@11AAU?$_vector2@M@@H@Z ; vertHW_1W::set
PUBLIC	?q_tc@@YAFM@Z					; q_tc
PUBLIC	?q_N@@YAEM@Z					; q_N
PUBLIC	?q_P@@YAFM@Z					; q_P
PUBLIC	?u_P@@YAMF@Z					; u_P
?sbones_array@@3Vshared_str@@A DD 01H DUP (?)		; sbones_array
_BSS	ENDS
CRT$XCU	SEGMENT
?sbones_array$initializer$@@3P6AXXZA DD FLAT:??__Esbones_array@@YAXXZ ; sbones_array$initializer$
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$_Emplace_reallocate@ABUWMFace@CSkeletonWallmark@@@?$vector@UWMFace@CSkeletonWallmark@@V?$xalloc@UWMFace@CSkeletonWallmark@@@@@std@@QAEPAUWMFace@CSkeletonWallmark@@QAU23@ABU23@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Emplace_reallocate@ABUWMFace@CSkeletonWallmark@@@?$vector@UWMFace@CSkeletonWallmark@@V?$xalloc@UWMFace@CSkeletonWallmark@@@@@std@@QAEPAUWMFace@CSkeletonWallmark@@QAU23@ABU23@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Emplace_reallocate@ABUWMFace@CSkeletonWallmark@@@?$vector@UWMFace@CSkeletonWallmark@@V?$xalloc@UWMFace@CSkeletonWallmark@@@@@std@@QAEPAUWMFace@CSkeletonWallmark@@QAU23@ABU23@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
__unwindtable$??$_Emplace_reallocate@ABUWMFace@CSkeletonWallmark@@@?$vector@UWMFace@CSkeletonWallmark@@V?$xalloc@UWMFace@CSkeletonWallmark@@@@@std@@QAEPAUWMFace@CSkeletonWallmark@@QAU23@ABU23@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Emplace_reallocate@ABUWMFace@CSkeletonWallmark@@@?$vector@UWMFace@CSkeletonWallmark@@V?$xalloc@UWMFace@CSkeletonWallmark@@@@@std@@QAEPAUWMFace@CSkeletonWallmark@@QAU23@ABU23@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Emplace_reallocate@ABUWMFace@CSkeletonWallmark@@@?$vector@UWMFace@CSkeletonWallmark@@V?$xalloc@UWMFace@CSkeletonWallmark@@@@@std@@QAEPAUWMFace@CSkeletonWallmark@@QAU23@ABU23@@Z$2
__catchsym$??$_Emplace_reallocate@ABUWMFace@CSkeletonWallmark@@@?$vector@UWMFace@CSkeletonWallmark@@V?$xalloc@UWMFace@CSkeletonWallmark@@@@@std@@QAEPAUWMFace@CSkeletonWallmark@@QAU23@ABU23@@Z$2 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Emplace_reallocate@ABUWMFace@CSkeletonWallmark@@@?$vector@UWMFace@CSkeletonWallmark@@V?$xalloc@UWMFace@CSkeletonWallmark@@@@@std@@QAEPAUWMFace@CSkeletonWallmark@@QAU23@ABU23@@Z$0
?dwDecl_01W@@3PAU_D3DVERTEXELEMENT9@@A DW 00H		; dwDecl_01W
	DW	00H
	DB	07H
	DB	00H
	DB	00H
	DB	00H
	DW	00H
	DW	08H
	DB	04H
	DB	00H
	DB	03H
	DB	00H
	DW	00H
	DW	0cH
	DB	04H
	DB	00H
	DB	06H
	DB	00H
	DW	00H
	DW	010H
	DB	04H
	DB	00H
	DB	07H
	DB	00H
	DW	00H
	DW	014H
	DB	06H
	DB	00H
	DB	05H
	DB	00H
	DW	0ffH
	DW	00H
	DB	011H
	DB	00H
	DB	00H
	DB	00H
?dwDecl_2W@@3PAU_D3DVERTEXELEMENT9@@A DW 00H		; dwDecl_2W
	DW	00H
	DB	07H
	DB	00H
	DB	00H
	DB	00H
	DW	00H
	DW	08H
	DB	04H
	DB	00H
	DB	03H
	DB	00H
	DW	00H
	DW	0cH
	DB	04H
	DB	00H
	DB	06H
	DB	00H
	DW	00H
	DW	010H
	DB	04H
	DB	00H
	DB	07H
	DB	00H
	DW	00H
	DW	014H
	DB	07H
	DB	00H
	DB	05H
	DB	00H
	DW	0ffH
	DW	00H
	DB	011H
	DB	00H
	DB	00H
	DB	00H
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp
;	COMDAT ??__Esbones_array@@YAXXZ
text$di	SEGMENT
??__Esbones_array@@YAXXZ PROC				; `dynamic initializer for 'sbones_array'', COMDAT

; 20   : static	shared_str	sbones_array;

	push	OFFSET ??__Fsbones_array@@YAXXZ		; `dynamic atexit destructor for 'sbones_array''
	call	_atexit
	pop	ecx
	ret	0
??__Esbones_array@@YAXXZ ENDP				; `dynamic initializer for 'sbones_array''
text$di	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\xrstring.h
;	COMDAT ??__Fsbones_array@@YAXXZ
text$yd	SEGMENT
??__Fsbones_array@@YAXXZ PROC				; `dynamic atexit destructor for 'sbones_array'', COMDAT

; 50   : 	void				_dec		()								{	if (0==p_) return;	p_->dwReference--; 	if (0==p_->dwReference)	p_=0;						}

	mov	eax, DWORD PTR ?sbones_array@@3Vshared_str@@A
	test	eax, eax
	je	SHORT $LN7@dynamic
	dec	DWORD PTR [eax]
	xor	ecx, ecx
	mov	eax, DWORD PTR ?sbones_array@@3Vshared_str@@A
	cmp	DWORD PTR [eax], ecx
	cmove	eax, ecx
	mov	DWORD PTR ?sbones_array@@3Vshared_str@@A, eax
$LN7@dynamic:
	ret	0
??__Fsbones_array@@YAXXZ ENDP				; `dynamic atexit destructor for 'sbones_array''
text$yd	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp
_TEXT	SEGMENT
tv130 = -4						; size = 4
?u_P@@YAMF@Z PROC					; u_P
; _v$ = cx

; 24   : {

	push	ecx

; 25   : 	return	float(v)/(32767.f/12.f);

	movsx	eax, cx
	mov	DWORD PTR tv130[esp+4], eax
	fild	DWORD PTR tv130[esp+4]
	fmul	DWORD PTR __real@39c00180

; 26   : }

	pop	ecx
	ret	0
?u_P@@YAMF@Z ENDP					; u_P
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h
; File I:\Vitalya\mine\NSProjectX\xrCore\vector.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\vector.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp
_TEXT	SEGMENT
_a$1 = 8						; size = 4
_v$ = 8							; size = 4
?q_P@@YAFM@Z PROC					; q_P

; 29   : 	int		_v	= clampr(iFloor(v*(32767.f/12.f)), -32768, 32767);

	movss	xmm0, DWORD PTR _v$[esp-4]
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h

; 84   :     int exponent	= (127 + 31) - ((a >> 23) & 0xFF);

	mov	ecx, 158				; 0000009eH
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp

; 29   : 	int		_v	= clampr(iFloor(v*(32767.f/12.f)), -32768, 32767);

	mulss	xmm0, DWORD PTR __real@452aa955
	push	esi
	push	edi
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h

; 83   :     int a			= *(const int*)(&x);

	movss	DWORD PTR _a$1[esp+4], xmm0

; 84   :     int exponent	= (127 + 31) - ((a >> 23) & 0xFF);

	mov	esi, DWORD PTR _a$1[esp+4]
	mov	eax, esi
	sar	eax, 23					; 00000017H

; 85   :     int r			= (((u32)(a) << 8) | (1U << 31)) >> exponent;

	mov	edi, esi
	movzx	eax, al
	or	edi, -8388608				; ff800000H
	sub	ecx, eax
	shl	edi, 8
	shr	edi, cl

; 86   :     exponent		+= 31-127;
; 87   :     {
; 88   :         int imask	=	(!(((( (1<<(exponent)))-1)>>8)&a));

	mov	eax, 1
	sub	ecx, 96					; 00000060H

; 89   :         exponent	-=	(31-127)+32;
; 90   :         exponent	>>=	31;
; 91   :         a			>>=	31;

	mov	edx, esi
	shl	eax, cl
	dec	eax
	sar	edx, 31					; 0000001fH
	sar	eax, 8
	and	eax, esi
	neg	eax
	sbb	eax, eax
	inc	eax
	and	eax, edx

; 92   :         r			-=	(imask&a);

	sub	edi, eax
	lea	eax, DWORD PTR [ecx+64]
	sar	eax, 31					; 0000001fH

; 93   :         r			&=	exponent;

	and	edi, eax
	xor	edi, edx
; File I:\Vitalya\mine\NSProjectX\xrCore\vector.h

; 96   : 	if		( val<_low	)	return _low; 

	cmp	edi, -32768				; ffff8000H
	jge	SHORT $LN6@q_P
	pop	edi
	mov	eax, -32768				; ffff8000H
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp

; 31   : }

	pop	esi
	ret	0
$LN6@q_P:
; File I:\Vitalya\mine\NSProjectX\xrCore\vector.h

; 97   : 	else if	( val>_high )	return _high;

	mov	eax, 32767				; 00007fffH
	cmp	edi, eax
	cmovg	edi, eax
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp

; 30   : 	return	s16	(_v);

	mov	ax, di
	pop	edi

; 31   : }

	pop	esi
	ret	0
?q_P@@YAFM@Z ENDP					; q_P
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h
; File I:\Vitalya\mine\NSProjectX\xrCore\vector.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\vector.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp
_TEXT	SEGMENT
_a$1 = 8						; size = 4
_v$ = 8							; size = 4
?q_N@@YAEM@Z PROC					; q_N

; 34   : 	int		_v	= clampr(iFloor((v+1.f)*127.5f), 0, 255);

	movss	xmm0, DWORD PTR _v$[esp-4]
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h

; 84   :     int exponent	= (127 + 31) - ((a >> 23) & 0xFF);

	mov	ecx, 158				; 0000009eH
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp

; 34   : 	int		_v	= clampr(iFloor((v+1.f)*127.5f), 0, 255);

	addss	xmm0, DWORD PTR __real@3f800000
	push	ebx
	push	esi
	mulss	xmm0, DWORD PTR __real@42ff0000
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h

; 83   :     int a			= *(const int*)(&x);

	movss	DWORD PTR _a$1[esp+4], xmm0

; 84   :     int exponent	= (127 + 31) - ((a >> 23) & 0xFF);

	mov	esi, DWORD PTR _a$1[esp+4]
	mov	eax, esi
	sar	eax, 23					; 00000017H

; 85   :     int r			= (((u32)(a) << 8) | (1U << 31)) >> exponent;

	mov	ebx, esi
	movzx	eax, al
	or	ebx, -8388608				; ff800000H
	sub	ecx, eax
	shl	ebx, 8
	shr	ebx, cl

; 86   :     exponent		+= 31-127;
; 87   :     {
; 88   :         int imask	=	(!(((( (1<<(exponent)))-1)>>8)&a));

	mov	eax, 1
	sub	ecx, 96					; 00000060H

; 89   :         exponent	-=	(31-127)+32;
; 90   :         exponent	>>=	31;
; 91   :         a			>>=	31;

	mov	edx, esi
	shl	eax, cl
	dec	eax
	sar	edx, 31					; 0000001fH
	sar	eax, 8
	and	eax, esi
	neg	eax
	sbb	eax, eax
	inc	eax
	and	eax, edx

; 92   :         r			-=	(imask&a);

	sub	ebx, eax
	lea	eax, DWORD PTR [ecx+64]
	sar	eax, 31					; 0000001fH

; 93   :         r			&=	exponent;

	and	ebx, eax
	xor	ebx, edx
; File I:\Vitalya\mine\NSProjectX\xrCore\vector.h

; 96   : 	if		( val<_low	)	return _low; 

	jge	SHORT $LN6@q_N
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp

; 35   : 	return	u8	(_v);

	pop	esi
	xor	al, al

; 36   : }

	pop	ebx
	ret	0
$LN6@q_N:
; File I:\Vitalya\mine\NSProjectX\xrCore\vector.h

; 97   : 	else if	( val>_high )	return _high;

	mov	eax, 255				; 000000ffH
	cmp	ebx, eax
	pop	esi
	cmovg	ebx, eax
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp

; 35   : 	return	u8	(_v);

	mov	al, bl

; 36   : }

	pop	ebx
	ret	0
?q_N@@YAEM@Z ENDP					; q_N
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h
; File I:\Vitalya\mine\NSProjectX\xrCore\vector.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\vector.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp
_TEXT	SEGMENT
_a$1 = 8						; size = 4
_v$ = 8							; size = 4
?q_tc@@YAFM@Z PROC					; q_tc

; 39   : 	int		_v	= clampr(iFloor(v*(32767.f/16.f)), -32768, 32767);

	movss	xmm0, DWORD PTR _v$[esp-4]
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h

; 84   :     int exponent	= (127 + 31) - ((a >> 23) & 0xFF);

	mov	ecx, 158				; 0000009eH
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp

; 39   : 	int		_v	= clampr(iFloor(v*(32767.f/16.f)), -32768, 32767);

	mulss	xmm0, DWORD PTR __real@44fffe00
	push	esi
	push	edi
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h

; 83   :     int a			= *(const int*)(&x);

	movss	DWORD PTR _a$1[esp+4], xmm0

; 84   :     int exponent	= (127 + 31) - ((a >> 23) & 0xFF);

	mov	esi, DWORD PTR _a$1[esp+4]
	mov	eax, esi
	sar	eax, 23					; 00000017H

; 85   :     int r			= (((u32)(a) << 8) | (1U << 31)) >> exponent;

	mov	edi, esi
	movzx	eax, al
	or	edi, -8388608				; ff800000H
	sub	ecx, eax
	shl	edi, 8
	shr	edi, cl

; 86   :     exponent		+= 31-127;
; 87   :     {
; 88   :         int imask	=	(!(((( (1<<(exponent)))-1)>>8)&a));

	mov	eax, 1
	sub	ecx, 96					; 00000060H

; 89   :         exponent	-=	(31-127)+32;
; 90   :         exponent	>>=	31;
; 91   :         a			>>=	31;

	mov	edx, esi
	shl	eax, cl
	dec	eax
	sar	edx, 31					; 0000001fH
	sar	eax, 8
	and	eax, esi
	neg	eax
	sbb	eax, eax
	inc	eax
	and	eax, edx

; 92   :         r			-=	(imask&a);

	sub	edi, eax
	lea	eax, DWORD PTR [ecx+64]
	sar	eax, 31					; 0000001fH

; 93   :         r			&=	exponent;

	and	edi, eax
	xor	edi, edx
; File I:\Vitalya\mine\NSProjectX\xrCore\vector.h

; 96   : 	if		( val<_low	)	return _low; 

	cmp	edi, -32768				; ffff8000H
	jge	SHORT $LN6@q_tc
	pop	edi
	mov	eax, -32768				; ffff8000H
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp

; 41   : }

	pop	esi
	ret	0
$LN6@q_tc:
; File I:\Vitalya\mine\NSProjectX\xrCore\vector.h

; 97   : 	else if	( val>_high )	return _high;

	mov	eax, 32767				; 00007fffH
	cmp	edi, eax
	cmovg	edi, eax
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp

; 40   : 	return	s16	(_v);

	mov	ax, di
	pop	edi

; 41   : }

	pop	esi
	ret	0
?q_tc@@YAFM@Z ENDP					; q_tc
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_color.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_color.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_color.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_color.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_color.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_color.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_color.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_color.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_color.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_color.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_color.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp
;	COMDAT ?set@vertHW_1W@@QAEXAAU?$_vector3@M@@U2@11AAU?$_vector2@M@@H@Z
_TEXT	SEGMENT
_P$ = 8							; size = 4
_N$ = 12						; size = 12
_T$ = 24						; size = 12
_B$ = 36						; size = 12
_tc$ = 48						; size = 4
_index$ = 52						; size = 4
?set@vertHW_1W@@QAEXAAU?$_vector3@M@@U2@11AAU?$_vector2@M@@H@Z PROC ; vertHW_1W::set, COMDAT
; _this$ = ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 200  : 		T magnitude=x*x + y*y + z*z;

	movss	xmm3, DWORD PTR _N$[esp-4]
	movss	xmm4, DWORD PTR _N$[esp]
	movaps	xmm1, xmm3
	movss	xmm5, DWORD PTR _N$[esp+4]
	movaps	xmm0, xmm4

; 201  : 		if (magnitude> std::numeric_limits<T>::min()) {

	movss	xmm6, DWORD PTR __real@00800000
	movss	xmm2, DWORD PTR __real@3f800000
	mulss	xmm0, xmm4
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp

; 71   : 	{

	push	esi
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 200  : 		T magnitude=x*x + y*y + z*z;

	mulss	xmm1, xmm3
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp

; 71   : 	{

	push	edi
	mov	edi, ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 200  : 		T magnitude=x*x + y*y + z*z;

	addss	xmm1, xmm0
	movaps	xmm0, xmm5
	mulss	xmm0, xmm5
	addss	xmm1, xmm0

; 201  : 		if (magnitude> std::numeric_limits<T>::min()) {

	comiss	xmm1, xmm6
	jbe	SHORT $LN4@set

; 202  : 			magnitude=_sqrt(1/magnitude);

	movaps	xmm0, xmm2
	divss	xmm0, xmm1
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h

; 764  :             return (float)sqrt(_X);

	sqrtss	xmm1, xmm0
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 203  : 			x *= magnitude;

	movaps	xmm0, xmm1
	mulss	xmm0, xmm3
	movss	DWORD PTR _N$[esp+4], xmm0

; 204  : 			y *= magnitude;

	movaps	xmm0, xmm1
	mulss	xmm0, xmm4

; 205  : 			z *= magnitude;

	mulss	xmm1, xmm5
	movss	DWORD PTR _N$[esp+8], xmm0
	movss	DWORD PTR _N$[esp+12], xmm1
$LN4@set:

; 200  : 		T magnitude=x*x + y*y + z*z;

	movss	xmm3, DWORD PTR _T$[esp+4]
	movss	xmm4, DWORD PTR _T$[esp+8]
	movaps	xmm1, xmm3
	movss	xmm5, DWORD PTR _T$[esp+12]
	movaps	xmm0, xmm4
	mulss	xmm0, xmm4
	mulss	xmm1, xmm3
	addss	xmm1, xmm0
	movaps	xmm0, xmm5
	mulss	xmm0, xmm5
	addss	xmm1, xmm0

; 201  : 		if (magnitude> std::numeric_limits<T>::min()) {

	comiss	xmm1, xmm6
	jbe	SHORT $LN13@set

; 202  : 			magnitude=_sqrt(1/magnitude);

	movaps	xmm0, xmm2
	divss	xmm0, xmm1
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h

; 764  :             return (float)sqrt(_X);

	sqrtss	xmm1, xmm0
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 203  : 			x *= magnitude;

	movaps	xmm0, xmm1
	mulss	xmm0, xmm3
	movss	DWORD PTR _T$[esp+4], xmm0

; 204  : 			y *= magnitude;

	movaps	xmm0, xmm1
	mulss	xmm0, xmm4

; 205  : 			z *= magnitude;

	mulss	xmm1, xmm5
	movss	DWORD PTR _T$[esp+8], xmm0
	movss	DWORD PTR _T$[esp+12], xmm1
$LN13@set:

; 200  : 		T magnitude=x*x + y*y + z*z;

	movss	xmm3, DWORD PTR _B$[esp+4]
	movss	xmm4, DWORD PTR _B$[esp+8]
	movaps	xmm1, xmm3
	movss	xmm5, DWORD PTR _B$[esp+12]
	movaps	xmm0, xmm4
	mulss	xmm0, xmm4
	mulss	xmm1, xmm3
	addss	xmm1, xmm0
	movaps	xmm0, xmm5
	mulss	xmm0, xmm5
	addss	xmm1, xmm0

; 201  : 		if (magnitude> std::numeric_limits<T>::min()) {

	comiss	xmm1, xmm6
	jbe	SHORT $LN22@set

; 202  : 			magnitude=_sqrt(1/magnitude);

	divss	xmm2, xmm1
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h

; 764  :             return (float)sqrt(_X);

	sqrtss	xmm1, xmm2
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 203  : 			x *= magnitude;

	movaps	xmm0, xmm1
	mulss	xmm0, xmm3
	movss	DWORD PTR _B$[esp+4], xmm0

; 204  : 			y *= magnitude;

	movaps	xmm0, xmm1
	mulss	xmm0, xmm4

; 205  : 			z *= magnitude;

	mulss	xmm1, xmm5
	movss	DWORD PTR _B$[esp+8], xmm0
	movss	DWORD PTR _B$[esp+12], xmm1
$LN22@set:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp

; 75   : 		_P[0]		= q_P(P.x);

	mov	esi, DWORD PTR _P$[esp+4]
	push	ecx
	fld	DWORD PTR [esi]
	fstp	DWORD PTR [esp]
	call	?q_P@@YAFM@Z				; q_P
	mov	WORD PTR [edi], ax

; 76   : 		_P[1]		= q_P(P.y);

	fld	DWORD PTR [esi+4]
	fstp	DWORD PTR [esp]
	call	?q_P@@YAFM@Z				; q_P
	mov	WORD PTR [edi+2], ax

; 77   : 		_P[2]		= q_P(P.z);

	fld	DWORD PTR [esi+8]
	fstp	DWORD PTR [esp]
	call	?q_P@@YAFM@Z				; q_P

; 78   : 		_P[3]		= q_P(1);

	fld1
	fstp	DWORD PTR [esp]
	mov	WORD PTR [edi+4], ax
	call	?q_P@@YAFM@Z				; q_P

; 79   : 		_N_I		= color_rgba(q_N(N.x), q_N(N.y), q_N(N.z), u8(index));

	fld	DWORD PTR _N$[esp+8]
	fstp	DWORD PTR [esp]
	mov	WORD PTR [edi+6], ax
	call	?q_N@@YAEM@Z				; q_N
	fld	DWORD PTR _N$[esp+12]
	movzx	esi, al
	movzx	eax, BYTE PTR _index$[esp+8]
	shl	eax, 8
; File I:\Vitalya\mine\NSProjectX\xrCore\_color.h

; 5    : ICF u32	color_argb	(u32 a, u32 r, u32 g, u32 b)	{	return ((a&0xff)<<24)|((r&0xff)<<16)|((g&0xff)<<8)|(b&0xff);	}

	or	esi, eax
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp

; 79   : 		_N_I		= color_rgba(q_N(N.x), q_N(N.y), q_N(N.z), u8(index));

	fstp	DWORD PTR [esp]
; File I:\Vitalya\mine\NSProjectX\xrCore\_color.h

; 5    : ICF u32	color_argb	(u32 a, u32 r, u32 g, u32 b)	{	return ((a&0xff)<<24)|((r&0xff)<<16)|((g&0xff)<<8)|(b&0xff);	}

	shl	esi, 8
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp

; 79   : 		_N_I		= color_rgba(q_N(N.x), q_N(N.y), q_N(N.z), u8(index));

	call	?q_N@@YAEM@Z				; q_N
	fld	DWORD PTR _N$[esp+16]
	movzx	eax, al
; File I:\Vitalya\mine\NSProjectX\xrCore\_color.h

; 5    : ICF u32	color_argb	(u32 a, u32 r, u32 g, u32 b)	{	return ((a&0xff)<<24)|((r&0xff)<<16)|((g&0xff)<<8)|(b&0xff);	}

	or	esi, eax
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp

; 79   : 		_N_I		= color_rgba(q_N(N.x), q_N(N.y), q_N(N.z), u8(index));

	fstp	DWORD PTR [esp]
; File I:\Vitalya\mine\NSProjectX\xrCore\_color.h

; 5    : ICF u32	color_argb	(u32 a, u32 r, u32 g, u32 b)	{	return ((a&0xff)<<24)|((r&0xff)<<16)|((g&0xff)<<8)|(b&0xff);	}

	shl	esi, 8
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp

; 79   : 		_N_I		= color_rgba(q_N(N.x), q_N(N.y), q_N(N.z), u8(index));

	call	?q_N@@YAEM@Z				; q_N

; 80   : 		_T			= color_rgba(q_N(T.x), q_N(T.y), q_N(T.z), 0);

	fld	DWORD PTR _T$[esp+8]
	movzx	eax, al
; File I:\Vitalya\mine\NSProjectX\xrCore\_color.h

; 5    : ICF u32	color_argb	(u32 a, u32 r, u32 g, u32 b)	{	return ((a&0xff)<<24)|((r&0xff)<<16)|((g&0xff)<<8)|(b&0xff);	}

	or	esi, eax
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp

; 80   : 		_T			= color_rgba(q_N(T.x), q_N(T.y), q_N(T.z), 0);

	fstp	DWORD PTR [esp]
	mov	DWORD PTR [edi+8], esi
	call	?q_N@@YAEM@Z				; q_N
	fld	DWORD PTR _T$[esp+12]
	movzx	esi, al
	fstp	DWORD PTR [esp]
	shl	esi, 8
	call	?q_N@@YAEM@Z				; q_N
	fld	DWORD PTR _T$[esp+16]
	movzx	eax, al
; File I:\Vitalya\mine\NSProjectX\xrCore\_color.h

; 5    : ICF u32	color_argb	(u32 a, u32 r, u32 g, u32 b)	{	return ((a&0xff)<<24)|((r&0xff)<<16)|((g&0xff)<<8)|(b&0xff);	}

	or	esi, eax
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp

; 80   : 		_T			= color_rgba(q_N(T.x), q_N(T.y), q_N(T.z), 0);

	fstp	DWORD PTR [esp]
; File I:\Vitalya\mine\NSProjectX\xrCore\_color.h

; 5    : ICF u32	color_argb	(u32 a, u32 r, u32 g, u32 b)	{	return ((a&0xff)<<24)|((r&0xff)<<16)|((g&0xff)<<8)|(b&0xff);	}

	shl	esi, 8
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp

; 80   : 		_T			= color_rgba(q_N(T.x), q_N(T.y), q_N(T.z), 0);

	call	?q_N@@YAEM@Z				; q_N

; 81   : 		_B			= color_rgba(q_N(B.x), q_N(B.y), q_N(B.z), 0);

	fld	DWORD PTR _B$[esp+8]
	movzx	eax, al
; File I:\Vitalya\mine\NSProjectX\xrCore\_color.h

; 5    : ICF u32	color_argb	(u32 a, u32 r, u32 g, u32 b)	{	return ((a&0xff)<<24)|((r&0xff)<<16)|((g&0xff)<<8)|(b&0xff);	}

	or	esi, eax
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp

; 81   : 		_B			= color_rgba(q_N(B.x), q_N(B.y), q_N(B.z), 0);

	fstp	DWORD PTR [esp]
	mov	DWORD PTR [edi+12], esi
	call	?q_N@@YAEM@Z				; q_N
	fld	DWORD PTR _B$[esp+12]
	movzx	esi, al
	fstp	DWORD PTR [esp]
	shl	esi, 8
	call	?q_N@@YAEM@Z				; q_N
	fld	DWORD PTR _B$[esp+16]
	movzx	eax, al
; File I:\Vitalya\mine\NSProjectX\xrCore\_color.h

; 5    : ICF u32	color_argb	(u32 a, u32 r, u32 g, u32 b)	{	return ((a&0xff)<<24)|((r&0xff)<<16)|((g&0xff)<<8)|(b&0xff);	}

	or	esi, eax
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp

; 81   : 		_B			= color_rgba(q_N(B.x), q_N(B.y), q_N(B.z), 0);

	fstp	DWORD PTR [esp]
; File I:\Vitalya\mine\NSProjectX\xrCore\_color.h

; 5    : ICF u32	color_argb	(u32 a, u32 r, u32 g, u32 b)	{	return ((a&0xff)<<24)|((r&0xff)<<16)|((g&0xff)<<8)|(b&0xff);	}

	shl	esi, 8
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp

; 81   : 		_B			= color_rgba(q_N(B.x), q_N(B.y), q_N(B.z), 0);

	call	?q_N@@YAEM@Z				; q_N
	movzx	eax, al
; File I:\Vitalya\mine\NSProjectX\xrCore\_color.h

; 5    : ICF u32	color_argb	(u32 a, u32 r, u32 g, u32 b)	{	return ((a&0xff)<<24)|((r&0xff)<<16)|((g&0xff)<<8)|(b&0xff);	}

	or	esi, eax
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp

; 81   : 		_B			= color_rgba(q_N(B.x), q_N(B.y), q_N(B.z), 0);

	mov	DWORD PTR [edi+16], esi

; 82   : 		_tc[0]		= q_tc(tc.x);

	mov	esi, DWORD PTR _tc$[esp+8]
	fld	DWORD PTR [esi]
	fstp	DWORD PTR [esp]
	call	?q_tc@@YAFM@Z				; q_tc
	mov	WORD PTR [edi+20], ax

; 83   : 		_tc[1]		= q_tc(tc.y);

	fld	DWORD PTR [esi+4]
	fstp	DWORD PTR [esp]
	call	?q_tc@@YAFM@Z				; q_tc
	add	esp, 4
	mov	WORD PTR [edi+22], ax
	pop	edi
	pop	esi

; 84   : 	}

	ret	48					; 00000030H
?set@vertHW_1W@@QAEXAAU?$_vector3@M@@U2@11AAU?$_vector2@M@@H@Z ENDP ; vertHW_1W::set
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_color.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp
;	COMDAT ?get_bone@vertHW_1W@@QAEGXZ
_TEXT	SEGMENT
?get_bone@vertHW_1W@@QAEGXZ PROC			; vertHW_1W::get_bone, COMDAT
; _this$ = ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\_color.h

; 20   : ICF	u32 color_get_A (u32 rgba)						{	return ((rgba) >> 24);			}

	movzx	ecx, BYTE PTR [ecx+11]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp

; 87   : 		return	(u16)color_get_A(_N_I)/3;

	mov	eax, -1431655765			; aaaaaaabH
	mul	ecx
	shr	edx, 1
	mov	ax, dx

; 88   : 	}

	ret	0
?get_bone@vertHW_1W@@QAEGXZ ENDP			; vertHW_1W::get_bone
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp
;	COMDAT ?get_pos@vertHW_1W@@QAEXAAU?$_vector3@M@@@Z
_TEXT	SEGMENT
_p$ = 8							; size = 4
?get_pos@vertHW_1W@@QAEXAAU?$_vector3@M@@@Z PROC	; vertHW_1W::get_pos, COMDAT
; _this$ = ecx

; 25   : 	return	float(v)/(32767.f/12.f);

	movsx	eax, WORD PTR [ecx]
	movss	xmm1, DWORD PTR __real@39c00180

; 91   : 		p.x			= u_P(_P[0]);

	mov	edx, DWORD PTR _p$[esp-4]

; 25   : 	return	float(v)/(32767.f/12.f);

	cvtsi2ss xmm0, eax
	mulss	xmm0, xmm1

; 91   : 		p.x			= u_P(_P[0]);

	movss	DWORD PTR [edx], xmm0

; 25   : 	return	float(v)/(32767.f/12.f);

	movsx	eax, WORD PTR [ecx+2]
	cvtsi2ss xmm0, eax
	mulss	xmm0, xmm1

; 92   : 		p.y			= u_P(_P[1]);

	movss	DWORD PTR [edx+4], xmm0

; 25   : 	return	float(v)/(32767.f/12.f);

	movsx	eax, WORD PTR [ecx+4]
	cvtsi2ss xmm0, eax
	mulss	xmm0, xmm1

; 93   : 		p.z			= u_P(_P[2]);

	movss	DWORD PTR [edx+8], xmm0

; 94   : 	}

	ret	4
?get_pos@vertHW_1W@@QAEXAAU?$_vector3@M@@@Z ENDP	; vertHW_1W::get_pos
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h
; File I:\Vitalya\mine\NSProjectX\xrCore\vector.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_color.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_color.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_color.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_color.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_color.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_color.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_color.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_color.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_color.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_color.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_color.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp
;	COMDAT ?set@vertHW_2W@@QAEXAAU?$_vector3@M@@U2@11AAU?$_vector2@M@@HHM@Z
_TEXT	SEGMENT
_a$1 = 8						; size = 4
_P$ = 8							; size = 4
_N$ = 12						; size = 12
_T$ = 24						; size = 12
_B$ = 36						; size = 12
_tc$ = 48						; size = 4
_index0$ = 52						; size = 4
_index1$ = 56						; size = 4
_w$ = 60						; size = 4
?set@vertHW_2W@@QAEXAAU?$_vector3@M@@U2@11AAU?$_vector2@M@@HHM@Z PROC ; vertHW_2W::set, COMDAT
; _this$ = ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 200  : 		T magnitude=x*x + y*y + z*z;

	movss	xmm3, DWORD PTR _N$[esp-4]
	movss	xmm4, DWORD PTR _N$[esp]
	movaps	xmm1, xmm3
	movss	xmm5, DWORD PTR _N$[esp+4]
	movaps	xmm0, xmm4

; 201  : 		if (magnitude> std::numeric_limits<T>::min()) {

	movss	xmm6, DWORD PTR __real@00800000
	movss	xmm2, DWORD PTR __real@3f800000
	mulss	xmm0, xmm4
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp

; 114  : 	{

	push	ebx
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 200  : 		T magnitude=x*x + y*y + z*z;

	mulss	xmm1, xmm3
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp

; 114  : 	{

	push	ebp
	push	esi
	push	edi
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 200  : 		T magnitude=x*x + y*y + z*z;

	addss	xmm1, xmm0
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp

; 114  : 	{

	mov	ebp, ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 200  : 		T magnitude=x*x + y*y + z*z;

	movaps	xmm0, xmm5
	mulss	xmm0, xmm5
	addss	xmm1, xmm0

; 201  : 		if (magnitude> std::numeric_limits<T>::min()) {

	comiss	xmm1, xmm6
	jbe	SHORT $LN4@set

; 202  : 			magnitude=_sqrt(1/magnitude);

	movaps	xmm0, xmm2
	divss	xmm0, xmm1
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h

; 764  :             return (float)sqrt(_X);

	sqrtss	xmm1, xmm0
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 203  : 			x *= magnitude;

	movaps	xmm0, xmm1
	mulss	xmm0, xmm3
	movss	DWORD PTR _N$[esp+12], xmm0

; 204  : 			y *= magnitude;

	movaps	xmm0, xmm1
	mulss	xmm0, xmm4

; 205  : 			z *= magnitude;

	mulss	xmm1, xmm5
	movss	DWORD PTR _N$[esp+16], xmm0
	movss	DWORD PTR _N$[esp+20], xmm1
$LN4@set:

; 200  : 		T magnitude=x*x + y*y + z*z;

	movss	xmm3, DWORD PTR _T$[esp+12]
	movss	xmm4, DWORD PTR _T$[esp+16]
	movaps	xmm1, xmm3
	movss	xmm5, DWORD PTR _T$[esp+20]
	movaps	xmm0, xmm4
	mulss	xmm0, xmm4
	mulss	xmm1, xmm3
	addss	xmm1, xmm0
	movaps	xmm0, xmm5
	mulss	xmm0, xmm5
	addss	xmm1, xmm0

; 201  : 		if (magnitude> std::numeric_limits<T>::min()) {

	comiss	xmm1, xmm6
	jbe	SHORT $LN13@set

; 202  : 			magnitude=_sqrt(1/magnitude);

	movaps	xmm0, xmm2
	divss	xmm0, xmm1
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h

; 764  :             return (float)sqrt(_X);

	sqrtss	xmm1, xmm0
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 203  : 			x *= magnitude;

	movaps	xmm0, xmm1
	mulss	xmm0, xmm3
	movss	DWORD PTR _T$[esp+12], xmm0

; 204  : 			y *= magnitude;

	movaps	xmm0, xmm1
	mulss	xmm0, xmm4

; 205  : 			z *= magnitude;

	mulss	xmm1, xmm5
	movss	DWORD PTR _T$[esp+16], xmm0
	movss	DWORD PTR _T$[esp+20], xmm1
$LN13@set:

; 200  : 		T magnitude=x*x + y*y + z*z;

	movss	xmm3, DWORD PTR _B$[esp+12]
	movss	xmm4, DWORD PTR _B$[esp+16]
	movaps	xmm1, xmm3
	movss	xmm5, DWORD PTR _B$[esp+20]
	movaps	xmm0, xmm4
	mulss	xmm0, xmm4
	mulss	xmm1, xmm3
	addss	xmm1, xmm0
	movaps	xmm0, xmm5
	mulss	xmm0, xmm5
	addss	xmm1, xmm0

; 201  : 		if (magnitude> std::numeric_limits<T>::min()) {

	comiss	xmm1, xmm6
	jbe	SHORT $LN22@set

; 202  : 			magnitude=_sqrt(1/magnitude);

	divss	xmm2, xmm1
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h

; 764  :             return (float)sqrt(_X);

	sqrtss	xmm1, xmm2
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 203  : 			x *= magnitude;

	movaps	xmm0, xmm1
	mulss	xmm0, xmm3
	movss	DWORD PTR _B$[esp+12], xmm0

; 204  : 			y *= magnitude;

	movaps	xmm0, xmm1
	mulss	xmm0, xmm4

; 205  : 			z *= magnitude;

	mulss	xmm1, xmm5
	movss	DWORD PTR _B$[esp+16], xmm0
	movss	DWORD PTR _B$[esp+20], xmm1
$LN22@set:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp

; 118  : 		_P[0]		= q_P	(P.x);

	mov	esi, DWORD PTR _P$[esp+12]
	push	ecx
	fld	DWORD PTR [esi]
	fstp	DWORD PTR [esp]
	call	?q_P@@YAFM@Z				; q_P
	mov	WORD PTR [ebp], ax

; 119  : 		_P[1]		= q_P	(P.y);

	fld	DWORD PTR [esi+4]
	fstp	DWORD PTR [esp]
	call	?q_P@@YAFM@Z				; q_P
	mov	WORD PTR [ebp+2], ax

; 120  : 		_P[2]		= q_P	(P.z);

	fld	DWORD PTR [esi+8]
	fstp	DWORD PTR [esp]
	call	?q_P@@YAFM@Z				; q_P

; 122  : 		_N_w		= color_rgba(q_N(N.x), q_N(N.y), q_N(N.z), u8(clampr(iFloor(w*255.f+.5f),0,255)));

	movss	xmm0, DWORD PTR _w$[esp+16]
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h

; 84   :     int exponent	= (127 + 31) - ((a >> 23) & 0xFF);

	mov	ecx, 158				; 0000009eH
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp

; 122  : 		_N_w		= color_rgba(q_N(N.x), q_N(N.y), q_N(N.z), u8(clampr(iFloor(w*255.f+.5f),0,255)));

	mulss	xmm0, DWORD PTR __real@437f0000
	mov	edi, 1
	mov	WORD PTR [ebp+4], ax
	add	esp, 4
	mov	WORD PTR [ebp+6], di
	addss	xmm0, DWORD PTR __real@3f000000
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h

; 83   :     int a			= *(const int*)(&x);

	movss	DWORD PTR _a$1[esp+12], xmm0

; 84   :     int exponent	= (127 + 31) - ((a >> 23) & 0xFF);

	mov	esi, DWORD PTR _a$1[esp+12]
	mov	eax, esi
	sar	eax, 23					; 00000017H

; 85   :     int r			= (((u32)(a) << 8) | (1U << 31)) >> exponent;

	mov	ebx, esi
	or	ebx, -8388608				; ff800000H
	movzx	eax, al
	sub	ecx, eax
	shl	ebx, 8
	shr	ebx, cl

; 86   :     exponent		+= 31-127;
; 87   :     {
; 88   :         int imask	=	(!(((( (1<<(exponent)))-1)>>8)&a));
; 89   :         exponent	-=	(31-127)+32;
; 90   :         exponent	>>=	31;
; 91   :         a			>>=	31;

	mov	edx, esi
	sub	ecx, 96					; 00000060H
	sar	edx, 31					; 0000001fH
	shl	edi, cl
	dec	edi
	sar	edi, 8
	and	edi, esi
	lea	eax, DWORD PTR [ecx+64]
	neg	edi
	sbb	edi, edi
	sar	eax, 31					; 0000001fH
	inc	edi
	and	edi, edx

; 92   :         r			-=	(imask&a);

	sub	ebx, edi

; 93   :         r			&=	exponent;

	and	ebx, eax
	xor	ebx, edx
; File I:\Vitalya\mine\NSProjectX\xrCore\vector.h

; 96   : 	if		( val<_low	)	return _low; 

	jge	SHORT $LN33@set
	xor	ebx, ebx
	jmp	SHORT $LN35@set
$LN33@set:

; 97   : 	else if	( val>_high )	return _high;

	mov	eax, 255				; 000000ffH
	cmp	ebx, eax
	cmovg	ebx, eax
$LN35@set:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp

; 122  : 		_N_w		= color_rgba(q_N(N.x), q_N(N.y), q_N(N.z), u8(clampr(iFloor(w*255.f+.5f),0,255)));

	fld	DWORD PTR _N$[esp+12]
	push	ecx
	fstp	DWORD PTR [esp]
	call	?q_N@@YAEM@Z				; q_N
	fld	DWORD PTR _N$[esp+20]
	movzx	esi, al
	movzx	eax, bl
	shl	eax, 8
; File I:\Vitalya\mine\NSProjectX\xrCore\_color.h

; 5    : ICF u32	color_argb	(u32 a, u32 r, u32 g, u32 b)	{	return ((a&0xff)<<24)|((r&0xff)<<16)|((g&0xff)<<8)|(b&0xff);	}

	or	esi, eax
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp

; 122  : 		_N_w		= color_rgba(q_N(N.x), q_N(N.y), q_N(N.z), u8(clampr(iFloor(w*255.f+.5f),0,255)));

	fstp	DWORD PTR [esp]
; File I:\Vitalya\mine\NSProjectX\xrCore\_color.h

; 5    : ICF u32	color_argb	(u32 a, u32 r, u32 g, u32 b)	{	return ((a&0xff)<<24)|((r&0xff)<<16)|((g&0xff)<<8)|(b&0xff);	}

	shl	esi, 8
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp

; 122  : 		_N_w		= color_rgba(q_N(N.x), q_N(N.y), q_N(N.z), u8(clampr(iFloor(w*255.f+.5f),0,255)));

	call	?q_N@@YAEM@Z				; q_N
	fld	DWORD PTR _N$[esp+24]
	movzx	eax, al
; File I:\Vitalya\mine\NSProjectX\xrCore\_color.h

; 5    : ICF u32	color_argb	(u32 a, u32 r, u32 g, u32 b)	{	return ((a&0xff)<<24)|((r&0xff)<<16)|((g&0xff)<<8)|(b&0xff);	}

	or	esi, eax
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp

; 122  : 		_N_w		= color_rgba(q_N(N.x), q_N(N.y), q_N(N.z), u8(clampr(iFloor(w*255.f+.5f),0,255)));

	fstp	DWORD PTR [esp]
; File I:\Vitalya\mine\NSProjectX\xrCore\_color.h

; 5    : ICF u32	color_argb	(u32 a, u32 r, u32 g, u32 b)	{	return ((a&0xff)<<24)|((r&0xff)<<16)|((g&0xff)<<8)|(b&0xff);	}

	shl	esi, 8
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp

; 122  : 		_N_w		= color_rgba(q_N(N.x), q_N(N.y), q_N(N.z), u8(clampr(iFloor(w*255.f+.5f),0,255)));

	call	?q_N@@YAEM@Z				; q_N

; 123  : 		_T			= color_rgba(q_N(T.x), q_N(T.y), q_N(T.z), 0);

	fld	DWORD PTR _T$[esp+16]
	movzx	eax, al
; File I:\Vitalya\mine\NSProjectX\xrCore\_color.h

; 5    : ICF u32	color_argb	(u32 a, u32 r, u32 g, u32 b)	{	return ((a&0xff)<<24)|((r&0xff)<<16)|((g&0xff)<<8)|(b&0xff);	}

	or	esi, eax
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp

; 123  : 		_T			= color_rgba(q_N(T.x), q_N(T.y), q_N(T.z), 0);

	fstp	DWORD PTR [esp]
	mov	DWORD PTR [ebp+8], esi
	call	?q_N@@YAEM@Z				; q_N
	fld	DWORD PTR _T$[esp+20]
	movzx	esi, al
	fstp	DWORD PTR [esp]
	shl	esi, 8
	call	?q_N@@YAEM@Z				; q_N
	fld	DWORD PTR _T$[esp+24]
	movzx	eax, al
; File I:\Vitalya\mine\NSProjectX\xrCore\_color.h

; 5    : ICF u32	color_argb	(u32 a, u32 r, u32 g, u32 b)	{	return ((a&0xff)<<24)|((r&0xff)<<16)|((g&0xff)<<8)|(b&0xff);	}

	or	esi, eax
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp

; 123  : 		_T			= color_rgba(q_N(T.x), q_N(T.y), q_N(T.z), 0);

	fstp	DWORD PTR [esp]
; File I:\Vitalya\mine\NSProjectX\xrCore\_color.h

; 5    : ICF u32	color_argb	(u32 a, u32 r, u32 g, u32 b)	{	return ((a&0xff)<<24)|((r&0xff)<<16)|((g&0xff)<<8)|(b&0xff);	}

	shl	esi, 8
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp

; 123  : 		_T			= color_rgba(q_N(T.x), q_N(T.y), q_N(T.z), 0);

	call	?q_N@@YAEM@Z				; q_N

; 124  : 		_B			= color_rgba(q_N(B.x), q_N(B.y), q_N(B.z), 0);

	fld	DWORD PTR _B$[esp+16]
	movzx	eax, al
; File I:\Vitalya\mine\NSProjectX\xrCore\_color.h

; 5    : ICF u32	color_argb	(u32 a, u32 r, u32 g, u32 b)	{	return ((a&0xff)<<24)|((r&0xff)<<16)|((g&0xff)<<8)|(b&0xff);	}

	or	esi, eax
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp

; 124  : 		_B			= color_rgba(q_N(B.x), q_N(B.y), q_N(B.z), 0);

	fstp	DWORD PTR [esp]
	mov	DWORD PTR [ebp+12], esi
	call	?q_N@@YAEM@Z				; q_N
	fld	DWORD PTR _B$[esp+20]
	movzx	esi, al
	fstp	DWORD PTR [esp]
	shl	esi, 8
	call	?q_N@@YAEM@Z				; q_N
	fld	DWORD PTR _B$[esp+24]
	movzx	eax, al
; File I:\Vitalya\mine\NSProjectX\xrCore\_color.h

; 5    : ICF u32	color_argb	(u32 a, u32 r, u32 g, u32 b)	{	return ((a&0xff)<<24)|((r&0xff)<<16)|((g&0xff)<<8)|(b&0xff);	}

	or	esi, eax
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp

; 124  : 		_B			= color_rgba(q_N(B.x), q_N(B.y), q_N(B.z), 0);

	fstp	DWORD PTR [esp]
; File I:\Vitalya\mine\NSProjectX\xrCore\_color.h

; 5    : ICF u32	color_argb	(u32 a, u32 r, u32 g, u32 b)	{	return ((a&0xff)<<24)|((r&0xff)<<16)|((g&0xff)<<8)|(b&0xff);	}

	shl	esi, 8
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp

; 124  : 		_B			= color_rgba(q_N(B.x), q_N(B.y), q_N(B.z), 0);

	call	?q_N@@YAEM@Z				; q_N
	movzx	eax, al
; File I:\Vitalya\mine\NSProjectX\xrCore\_color.h

; 5    : ICF u32	color_argb	(u32 a, u32 r, u32 g, u32 b)	{	return ((a&0xff)<<24)|((r&0xff)<<16)|((g&0xff)<<8)|(b&0xff);	}

	or	esi, eax
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp

; 124  : 		_B			= color_rgba(q_N(B.x), q_N(B.y), q_N(B.z), 0);

	mov	DWORD PTR [ebp+16], esi

; 125  : 		_tc_i[0]	= q_tc	(tc.x);

	mov	esi, DWORD PTR _tc$[esp+16]
	fld	DWORD PTR [esi]
	fstp	DWORD PTR [esp]
	call	?q_tc@@YAFM@Z				; q_tc
	mov	WORD PTR [ebp+20], ax

; 126  : 		_tc_i[1]	= q_tc	(tc.y);

	fld	DWORD PTR [esi+4]
	fstp	DWORD PTR [esp]
	call	?q_tc@@YAFM@Z				; q_tc
	add	esp, 4
	mov	WORD PTR [ebp+22], ax

; 127  : 		_tc_i[2]	= s16	(index0);

	mov	ax, WORD PTR _index0$[esp+12]
	mov	WORD PTR [ebp+24], ax

; 128  : 		_tc_i[3]	= s16	(index1);

	mov	ax, WORD PTR _index1$[esp+12]
	pop	edi
	pop	esi
	mov	WORD PTR [ebp+26], ax
	pop	ebp
	pop	ebx

; 129  : 	}

	ret	56					; 00000038H
?set@vertHW_2W@@QAEXAAU?$_vector3@M@@U2@11AAU?$_vector2@M@@HHM@Z ENDP ; vertHW_2W::set
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp
;	COMDAT ?get_weight@vertHW_2W@@QAEMXZ
_TEXT	SEGMENT
tv134 = -4						; size = 4
?get_weight@vertHW_2W@@QAEMXZ PROC			; vertHW_2W::get_weight, COMDAT
; _this$ = ecx

; 131  : 	{

	push	ecx

; 132  : 		return	float(color_get_A(_N_w))/255.f;

	movzx	eax, BYTE PTR [ecx+11]
	mov	DWORD PTR tv134[esp+4], eax
	fild	DWORD PTR tv134[esp+4]
	fmul	DWORD PTR __real@3b808081

; 133  : 	}

	pop	ecx
	ret	0
?get_weight@vertHW_2W@@QAEMXZ ENDP			; vertHW_2W::get_weight
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp
;	COMDAT ?get_bone@vertHW_2W@@QAEGG@Z
_TEXT	SEGMENT
_w$ = 8							; size = 2
?get_bone@vertHW_2W@@QAEGG@Z PROC			; vertHW_2W::get_bone, COMDAT
; _this$ = ecx

; 136  : 		return	(u16)_tc_i[w+2]/3;

	movzx	eax, WORD PTR _w$[esp-4]
	movzx	ecx, WORD PTR [ecx+eax*2+24]
	mov	eax, -1431655765			; aaaaaaabH
	mul	ecx
	shr	edx, 1
	mov	ax, dx

; 137  : 	}

	ret	4
?get_bone@vertHW_2W@@QAEGG@Z ENDP			; vertHW_2W::get_bone
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp
;	COMDAT ?get_pos@vertHW_2W@@QAEXAAU?$_vector3@M@@@Z
_TEXT	SEGMENT
_p$ = 8							; size = 4
?get_pos@vertHW_2W@@QAEXAAU?$_vector3@M@@@Z PROC	; vertHW_2W::get_pos, COMDAT
; _this$ = ecx

; 25   : 	return	float(v)/(32767.f/12.f);

	movsx	eax, WORD PTR [ecx]
	movss	xmm1, DWORD PTR __real@39c00180

; 140  : 		p.x			= u_P(_P[0]);

	mov	edx, DWORD PTR _p$[esp-4]

; 25   : 	return	float(v)/(32767.f/12.f);

	cvtsi2ss xmm0, eax
	mulss	xmm0, xmm1

; 140  : 		p.x			= u_P(_P[0]);

	movss	DWORD PTR [edx], xmm0

; 25   : 	return	float(v)/(32767.f/12.f);

	movsx	eax, WORD PTR [ecx+2]
	cvtsi2ss xmm0, eax
	mulss	xmm0, xmm1

; 141  : 		p.y			= u_P(_P[1]);

	movss	DWORD PTR [edx+4], xmm0

; 25   : 	return	float(v)/(32767.f/12.f);

	movsx	eax, WORD PTR [ecx+4]
	cvtsi2ss xmm0, eax
	mulss	xmm0, xmm1

; 142  : 		p.z			= u_P(_P[2]);

	movss	DWORD PTR [edx+8], xmm0

; 143  : 	}

	ret	4
?get_pos@vertHW_2W@@QAEXAAU?$_vector3@M@@@Z ENDP	; vertHW_2W::get_pos
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FProgressive.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FProgressive.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FProgressive.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FProgressive.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp
_TEXT	SEGMENT
_V$ = 8							; size = 4
?Copy@CSkeletonX_PM@@UAEXPAVIRender_Visual@@@Z PROC	; CSkeletonX_PM::Copy
; _this$ = ecx

; 161  : {

	push	esi
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FProgressive.cpp

; 112  : 	Fvisual::Copy	(pSrc);

	mov	esi, DWORD PTR _V$[esp]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp

; 161  : {

	push	edi
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FProgressive.cpp

; 112  : 	Fvisual::Copy	(pSrc);

	push	esi
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp

; 161  : {

	mov	edi, ecx
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FProgressive.cpp

; 112  : 	Fvisual::Copy	(pSrc);

	call	?Copy@Fvisual@@UAEXPAVIRender_Visual@@@Z ; Fvisual::Copy

; 114  : 	PCOPY			(nSWI);

	mov	eax, DWORD PTR [esi+108]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp

; 164  : 	_Copy					((CSkeletonX*)X);

	lea	ecx, DWORD PTR [edi+140]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FProgressive.cpp

; 114  : 	PCOPY			(nSWI);

	mov	DWORD PTR [edi+108], eax
	mov	eax, DWORD PTR [esi+112]
	mov	DWORD PTR [edi+112], eax
	mov	eax, DWORD PTR [esi+116]
	mov	DWORD PTR [edi+116], eax
	mov	eax, DWORD PTR [esi+120]
	mov	DWORD PTR [edi+120], eax
	mov	eax, DWORD PTR [esi+124]
	mov	DWORD PTR [edi+124], eax
	mov	eax, DWORD PTR [esi+128]
	mov	DWORD PTR [edi+128], eax

; 115  : 	PCOPY			(xSWI);

	mov	eax, DWORD PTR [esi+132]
	mov	DWORD PTR [edi+132], eax
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp

; 164  : 	_Copy					((CSkeletonX*)X);

	lea	eax, DWORD PTR [esi+140]
	push	eax
	call	DWORD PTR __imp_?_Copy@CSkeletonX@@IAEXPAV1@@Z
	pop	edi
	pop	esi

; 165  : }

	ret	4
?Copy@CSkeletonX_PM@@UAEXPAVIRender_Visual@@@Z ENDP	; CSkeletonX_PM::Copy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp
_TEXT	SEGMENT
_P$ = 8							; size = 4
?Copy@CSkeletonX_ST@@UAEXPAVIRender_Visual@@@Z PROC	; CSkeletonX_ST::Copy
; _this$ = ecx

; 167  : {

	push	esi

; 168  : 	inherited1::Copy		(P);

	mov	esi, DWORD PTR _P$[esp]
	push	edi
	push	esi
	mov	edi, ecx
	call	?Copy@Fvisual@@UAEXPAVIRender_Visual@@@Z ; Fvisual::Copy

; 169  : 	CSkeletonX_ST *X		= (CSkeletonX_ST*)P;
; 170  : 	_Copy					((CSkeletonX*)X);

	lea	eax, DWORD PTR [esi+108]
	neg	esi
	lea	ecx, DWORD PTR [edi+108]
	sbb	esi, esi
	and	esi, eax
	push	esi
	call	DWORD PTR __imp_?_Copy@CSkeletonX@@IAEXPAV1@@Z
	pop	edi
	pop	esi

; 171  : }

	ret	4
?Copy@CSkeletonX_ST@@UAEXPAVIRender_Visual@@@Z ENDP	; CSkeletonX_ST::Copy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\vector.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp
_TEXT	SEGMENT
tv257 = -4						; size = 4
_a$1 = 8						; size = 4
_LOD$ = 8						; size = 4
?Render@CSkeletonX_PM@@UAEXM@Z PROC			; CSkeletonX_PM::Render
; _this$ = ecx

; 174  : {

	push	ecx

; 175  : 	int lod_id				= inherited1::last_lod;
; 176  : 	if (LOD>=0.f){

	movss	xmm0, DWORD PTR _LOD$[esp]
	comiss	xmm0, DWORD PTR __real@00000000
	push	ebx
	mov	ebx, ecx
	push	edi
	mov	edi, DWORD PTR [ebx+136]
	jb	$LN4@Render
; File I:\Vitalya\mine\NSProjectX\xrCore\vector.h

; 92   : 	if( val<_low ) val = _low; else if( val>_high ) val = _high;

	comiss	xmm0, DWORD PTR __real@3f800000
	jbe	SHORT $LN10@Render
	mov	DWORD PTR _LOD$[esp+8], 1065353216	; 3f800000H
$LN10@Render:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp

; 178  : 		lod_id				= iFloor((1.f-LOD)*float(nSWI.count-1)+0.5f);

	mov	eax, DWORD PTR [ebx+112]
	sub	eax, 1
	mov	DWORD PTR tv257[esp+12], eax
	fild	DWORD PTR tv257[esp+12]
	push	esi
	jns	SHORT $LN14@Render
	fadd	DWORD PTR __real@4f800000
$LN14@Render:
	fld1
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h

; 84   :     int exponent	= (127 + 31) - ((a >> 23) & 0xFF);

	mov	ecx, 158				; 0000009eH
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp

; 178  : 		lod_id				= iFloor((1.f-LOD)*float(nSWI.count-1)+0.5f);

	fsub	DWORD PTR _LOD$[esp+12]
	fmulp	ST(1), ST(0)
	fadd	DWORD PTR __real@3f000000
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h

; 83   :     int a			= *(const int*)(&x);

	fstp	DWORD PTR _a$1[esp+12]

; 84   :     int exponent	= (127 + 31) - ((a >> 23) & 0xFF);

	mov	esi, DWORD PTR _a$1[esp+12]
	mov	eax, esi
	sar	eax, 23					; 00000017H

; 85   :     int r			= (((u32)(a) << 8) | (1U << 31)) >> exponent;

	mov	edi, esi
	movzx	eax, al
	or	edi, -8388608				; ff800000H
	sub	ecx, eax
	shl	edi, 8
	shr	edi, cl

; 88   :         int imask	=	(!(((( (1<<(exponent)))-1)>>8)&a));

	mov	eax, 1
	sub	ecx, 96					; 00000060H

; 89   :         exponent	-=	(31-127)+32;
; 90   :         exponent	>>=	31;
; 91   :         a			>>=	31;

	mov	edx, esi
	shl	eax, cl
	dec	eax
	sar	edx, 31					; 0000001fH
	sar	eax, 8
	and	eax, esi
	neg	eax
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp

; 179  : 		inherited1::last_lod= lod_id;

	pop	esi
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h

; 88   :         int imask	=	(!(((( (1<<(exponent)))-1)>>8)&a));

	sbb	eax, eax
	inc	eax

; 89   :         exponent	-=	(31-127)+32;
; 90   :         exponent	>>=	31;
; 91   :         a			>>=	31;

	and	eax, edx

; 92   :         r			-=	(imask&a);

	sub	edi, eax
	lea	eax, DWORD PTR [ecx+64]
	sar	eax, 31					; 0000001fH

; 93   :         r			&=	exponent;

	and	edi, eax
	xor	edi, edx
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp

; 179  : 		inherited1::last_lod= lod_id;

	mov	DWORD PTR [ebx+136], edi
$LN4@Render:

; 180  : 	}
; 181  : 	VERIFY					(lod_id>=0 && lod_id<int(nSWI.count));
; 182  : 	FSlideWindow& SW		= nSWI.sw[lod_id];

	mov	ecx, DWORD PTR [ebx+108]

; 183  : 	_Render					(rm_geom,SW.num_verts,SW.offset,SW.num_tris);

	movzx	eax, WORD PTR [ecx+edi*8+4]
	push	eax
	push	DWORD PTR [ecx+edi*8]
	movzx	eax, WORD PTR [ecx+edi*8+6]
	lea	ecx, DWORD PTR [ebx+140]
	push	eax
	lea	eax, DWORD PTR [ebx+72]
	push	eax
	call	DWORD PTR __imp_?_Render@CSkeletonX@@IAEXAAV?$resptr_core@USGeometry@@Uresptrcode_geom@@@@III@Z
	pop	edi
	pop	ebx

; 184  : }

	pop	ecx
	ret	4
?Render@CSkeletonX_PM@@UAEXM@Z ENDP			; CSkeletonX_PM::Render
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp
_TEXT	SEGMENT
_LOD$ = 8						; size = 4
?Render@CSkeletonX_ST@@UAEXM@Z PROC			; CSkeletonX_ST::Render
; _this$ = ecx

; 187  : 	_Render		(rm_geom,vCount,0,dwPrimitives);

	push	DWORD PTR [ecx+100]
	lea	eax, DWORD PTR [ecx+72]
	push	0
	push	DWORD PTR [ecx+84]
	add	ecx, 108				; 0000006cH
	push	eax
	call	DWORD PTR __imp_?_Render@CSkeletonX@@IAEXAAV?$resptr_core@USGeometry@@Uresptrcode_geom@@@@III@Z

; 188  : }

	ret	4
?Render@CSkeletonX_ST@@UAEXM@Z ENDP			; CSkeletonX_ST::Render
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FVisual.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FProgressive.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp
_TEXT	SEGMENT
?Release@CSkeletonX_PM@@UAEXXZ PROC			; CSkeletonX_PM::Release
; _this$ = ecx

; 192  : {

	push	ebx
	push	esi
	push	edi
	mov	esi, ecx
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FVisual.cpp

; 31   : 	IRender_Visual::Release	();

	call	DWORD PTR __imp_?Release@IRender_Visual@@UAEXXZ
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	eax, DWORD PTR [esi+108]
	mov	ebx, DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
	test	eax, eax
	je	SHORT $LN9@Release
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	ebx
	mov	DWORD PTR [esi+108], 0
$LN9@Release:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FProgressive.cpp

; 30   : 	if (xSWI)		{

	mov	edi, DWORD PTR [esi+132]
	test	edi, edi
	je	SHORT $LN15@Release
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	eax, DWORD PTR [edi]
	test	eax, eax
	je	SHORT $LN12@Release
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	ebx
	mov	DWORD PTR [edi], 0
$LN12@Release:
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h

; 151  : 	if (ptr) 

	mov	eax, DWORD PTR [esi+132]
	test	eax, eax
	je	SHORT $LN15@Release

; 144  : 		Memory.mem_free	(ptr);

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	ebx

; 154  : 		ptr = nullptr;

	mov	DWORD PTR [esi+132], 0
$LN15@Release:
	pop	edi
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp

; 194  : }

	pop	esi
	pop	ebx
	ret	0
?Release@CSkeletonX_PM@@UAEXXZ ENDP			; CSkeletonX_PM::Release
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FVisual.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp
_TEXT	SEGMENT
?Release@CSkeletonX_ST@@UAEXXZ PROC			; CSkeletonX_ST::Release
; _this$ = ecx
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FVisual.cpp

; 31   : 	IRender_Visual::Release	();

	jmp	DWORD PTR __imp_?Release@IRender_Visual@@UAEXXZ
?Release@CSkeletonX_ST@@UAEXXZ ENDP			; CSkeletonX_ST::Release
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\FS.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FProgressive.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\FS.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FProgressive.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xrCore.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FProgressive.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FProgressive.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
; File I:\Vitalya\mine\NSProjectX\xrEngine\render.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp
; File I:\Vitalya\mine\NSProjectX\xrEngine\render.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp
_TEXT	SEGMENT
_N$ = 8							; size = 4
__verts_$1$ = 12					; size = 4
_data$ = 12						; size = 4
_dwFlags$ = 16						; size = 4
?Load@CSkeletonX_PM@@UAEXPBDPAVIReader@@I@Z PROC	; CSkeletonX_PM::Load
; _this$ = ecx

; 201  : {

	push	ebx
	push	ebp
	push	esi

; 202  : 	_Load							(N,data,vCount);

	mov	esi, DWORD PTR _N$[esp+8]
	mov	ebx, ecx
	push	edi
	mov	edi, DWORD PTR _data$[esp+12]
	lea	eax, DWORD PTR [ebx+84]
	push	eax
	push	edi
	push	esi
	lea	ecx, DWORD PTR [ebx+140]
	call	DWORD PTR __imp_?_Load@CSkeletonX@@IAEXPBDPAVIReader@@AAI@Z
; File I:\Vitalya\mine\NSProjectX\xrCore\FS.h

; 264  : 	IC void*		pointer		()	const		{	return &(data[Pos]);	};

	mov	eax, DWORD PTR [edi+8]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FProgressive.cpp

; 38   : 	Fvisual::Load	(N,data,dwFlags);

	mov	ecx, ebx
; File I:\Vitalya\mine\NSProjectX\xrCore\FS.h

; 264  : 	IC void*		pointer		()	const		{	return &(data[Pos]);	};

	add	eax, DWORD PTR [edi+4]
	mov	DWORD PTR __verts_$1$[esp+12], eax
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp

; 204  : 	inherited1::Load				(N,data,dwFlags|VLOAD_NOVERTICES);

	mov	eax, DWORD PTR _dwFlags$[esp+12]
	or	eax, 1
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FProgressive.cpp

; 38   : 	Fvisual::Load	(N,data,dwFlags);

	push	eax
	push	edi
	push	esi
	call	?Load@Fvisual@@UAEXPBDPAVIReader@@I@Z	; Fvisual::Load

; 39   : 
; 40   : 	// normal SWI
; 41   : 	destructor<IReader> lods (data->open_chunk	(OGF_SWIDATA));

	push	6
	mov	ecx, edi
	call	DWORD PTR __imp_?open_chunk@IReader@@QAEPAV1@I@Z
; File I:\Vitalya\mine\NSProjectX\xrCore\xrCore.h

; 257  : 	destructor(T* p)	{ ptr=p;			}

	mov	esi, eax
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FProgressive.cpp

; 42   :     nSWI.reserved[0]	= lods().r_u32();	// reserved 16 bytes

	mov	ecx, esi
	call	DWORD PTR __imp_?r_u32@?$IReaderBase@VIReader@@@@QAEIXZ

; 43   :     nSWI.reserved[1]	= lods().r_u32();

	mov	ecx, esi
	mov	DWORD PTR [ebx+116], eax
	call	DWORD PTR __imp_?r_u32@?$IReaderBase@VIReader@@@@QAEIXZ

; 44   :     nSWI.reserved[2]	= lods().r_u32();

	mov	ecx, esi
	mov	DWORD PTR [ebx+120], eax
	call	DWORD PTR __imp_?r_u32@?$IReaderBase@VIReader@@@@QAEIXZ

; 45   :     nSWI.reserved[3]	= lods().r_u32();

	mov	ecx, esi
	mov	DWORD PTR [ebx+124], eax
	call	DWORD PTR __imp_?r_u32@?$IReaderBase@VIReader@@@@QAEIXZ

; 46   :     nSWI.count			= lods().r_u32();

	mov	ecx, esi
	mov	DWORD PTR [ebx+128], eax
	call	DWORD PTR __imp_?r_u32@?$IReaderBase@VIReader@@@@QAEIXZ
	mov	DWORD PTR [ebx+112], eax
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	shl	eax, 3
	push	eax
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FProgressive.cpp

; 49   : 	lods().r			(nSWI.sw,nSWI.count*sizeof(FSlideWindow));

	mov	ecx, DWORD PTR [ebx+112]
	shl	ecx, 3
	push	ecx
	push	eax
	mov	ecx, esi
	mov	DWORD PTR [ebx+108], eax
	call	DWORD PTR __imp_?r@IReader@@QAEXPAXH@Z
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h

; 151  : 	if (ptr) 

	test	esi, esi
	je	SHORT $LN17@Load

; 132  : 		void*	_real_ptr	= dynamic_cast<void*>(ptr);

	push	esi
	call	___RTCastToVoid

; 133  : 		ptr->~T			();

	mov	edx, DWORD PTR [esi]
	add	esp, 4
	mov	ecx, esi
	mov	edi, eax
	push	0
	call	DWORD PTR [edx]

; 134  : 		Memory.mem_free	(_real_ptr);

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	edi
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN17@Load:
; File I:\Vitalya\mine\NSProjectX\xrEngine\render.h

; 170  : 	void					shader_option_skinning(s32 mode) { m_skinning = mode; }

	mov	eax, DWORD PTR __imp_?Render@@3PAVIRender_interface@@A
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp

; 207  : 	_Load_hw						(*this,_verts_);

	lea	ecx, DWORD PTR [ebx+140]
	push	DWORD PTR __verts_$1$[esp+12]
	push	ebx
; File I:\Vitalya\mine\NSProjectX\xrEngine\render.h

; 170  : 	void					shader_option_skinning(s32 mode) { m_skinning = mode; }

	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [eax+4], -1
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp

; 207  : 	_Load_hw						(*this,_verts_);

	mov	eax, DWORD PTR [ebx+140]
	mov	DWORD PTR [ebx+80], 0
	call	DWORD PTR [eax]
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 208  : }

	ret	12					; 0000000cH
?Load@CSkeletonX_PM@@UAEXPBDPAVIReader@@I@Z ENDP	; CSkeletonX_PM::Load
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\FS.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\FS.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp
; File I:\Vitalya\mine\NSProjectX\xrEngine\render.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp
; File I:\Vitalya\mine\NSProjectX\xrEngine\render.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp
_TEXT	SEGMENT
_this$1$ = -4						; size = 4
_N$ = 8							; size = 4
_data$ = 12						; size = 4
_dwFlags$ = 16						; size = 4
?Load@CSkeletonX_ST@@UAEXPBDPAVIReader@@I@Z PROC	; CSkeletonX_ST::Load
; _this$ = ecx

; 210  : {

	push	ecx
	push	ebx
	push	ebp
	mov	eax, ecx
	push	esi

; 211  : 	_Load							(N,data,vCount);

	mov	esi, DWORD PTR _N$[esp+12]
	push	edi
	mov	edi, DWORD PTR _data$[esp+16]
	lea	ebp, DWORD PTR [eax+108]
	mov	DWORD PTR _this$1$[esp+20], eax
	mov	ecx, ebp
	add	eax, 84					; 00000054H
	push	eax
	push	edi
	push	esi
	call	DWORD PTR __imp_?_Load@CSkeletonX@@IAEXPBDPAVIReader@@AAI@Z

; 213  : 	inherited1::Load				(N,data,dwFlags|VLOAD_NOVERTICES);

	mov	eax, DWORD PTR _dwFlags$[esp+16]
; File I:\Vitalya\mine\NSProjectX\xrCore\FS.h

; 264  : 	IC void*		pointer		()	const		{	return &(data[Pos]);	};

	mov	ebx, DWORD PTR [edi+8]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp

; 213  : 	inherited1::Load				(N,data,dwFlags|VLOAD_NOVERTICES);

	or	eax, 1
; File I:\Vitalya\mine\NSProjectX\xrCore\FS.h

; 264  : 	IC void*		pointer		()	const		{	return &(data[Pos]);	};

	add	ebx, DWORD PTR [edi+4]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp

; 213  : 	inherited1::Load				(N,data,dwFlags|VLOAD_NOVERTICES);

	push	eax
	push	edi
	push	esi
	mov	esi, DWORD PTR _this$1$[esp+32]
	mov	ecx, esi
	call	?Load@Fvisual@@UAEXPBDPAVIReader@@I@Z	; Fvisual::Load
; File I:\Vitalya\mine\NSProjectX\xrEngine\render.h

; 170  : 	void					shader_option_skinning(s32 mode) { m_skinning = mode; }

	mov	eax, DWORD PTR __imp_?Render@@3PAVIRender_interface@@A
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp

; 216  : 	_Load_hw						(*this,_verts_);

	mov	ecx, ebp
	push	ebx
	push	esi
; File I:\Vitalya\mine\NSProjectX\xrEngine\render.h

; 170  : 	void					shader_option_skinning(s32 mode) { m_skinning = mode; }

	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [eax+4], -1
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp

; 216  : 	_Load_hw						(*this,_verts_);

	mov	eax, DWORD PTR [ebp]
	mov	DWORD PTR [esi+80], 0
	call	DWORD PTR [eax]
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 217  : }

	pop	ecx
	ret	12					; 0000000cH
?Load@CSkeletonX_ST@@UAEXPBDPAVIReader@@I@Z ENDP	; CSkeletonX_ST::Load
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector2.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector2.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector2.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector2.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp
_TEXT	SEGMENT
_it$1$ = -16						; size = 4
_bytes$1 = -16						; size = 4
_it$1$ = -12						; size = 4
_bytes$2 = -12						; size = 4
_uv$3 = -8						; size = 8
_uv$4 = -8						; size = 8
_V$ = 8							; size = 4
__verts_$ = 12						; size = 4
?_Load_hw@CSkeletonX_ext@@MAEXAAVFvisual@@PAX@Z PROC	; CSkeletonX_ext::_Load_hw
; _this$ = ecx

; 220  : {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H

; 221  : 	// Create HW VB in case this is possible
; 222  : 	BOOL	bSoft				= HW.Caps.geometry.bSoftware;

	mov	eax, DWORD PTR __imp_?HW@@3VCHW@@A
	sub	esp, 20					; 00000014H
	push	ebx
	push	esi
	push	edi
	mov	edi, DWORD PTR [eax+56]

; 223  : 	u32		dwUsage				= /*D3DUSAGE_WRITEONLY |*/ (bSoft?D3DUSAGE_SOFTWAREPROCESSING:0);	// VB may be read by wallmarks code
; 224  : 	switch	(RenderMode)

	movzx	eax, WORD PTR [ecx+20]
	and	edi, 1
	shl	edi, 4
	cmp	eax, 3
	ja	$LN2@Load_hw
	jmp	DWORD PTR $LN57@Load_hw[eax*4]
$LN34@Load_hw:

; 225  : 	{
; 226  : 	case RM_SKINNING_SOFT:
; 227  : 		//Msg					("skinning: software");
; 228  : 		V.rm_geom.create		(vertRenderFVF, RCache.Vertex.Buffer(), V.p_rm_Indices);

	mov	ecx, DWORD PTR _V$[ebp]
	mov	eax, DWORD PTR __imp_?RCache@@3VCBackend@@A
	push	DWORD PTR [ecx+88]
	add	ecx, 72					; 00000048H
	push	DWORD PTR [eax]
	push	274					; 00000112H
	call	DWORD PTR __imp_?create@resptrcode_geom@@QAEXIPAUIDirect3DVertexBuffer9@@PAUIDirect3DIndexBuffer9@@@Z

; 269  : 		}
; 270  : 		break;
; 271  : 	}
; 272  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
$LN35@Load_hw:

; 229  : 		break;
; 230  : 	case RM_SINGLE:
; 231  : 	case RM_SKINNING_1B:
; 232  : 		//Msg					("skinning: hw, 1-weight");
; 233  : 		{
; 234  : 			u32		vStride		= D3DXGetDeclVertexSize		(dwDecl_01W,0);

	push	0
	push	OFFSET ?dwDecl_01W@@3PAU_D3DVERTEXELEMENT9@@A
	call	DWORD PTR __imp__D3DXGetDeclVertexSize@8

; 235  : 			VERIFY	(vStride==sizeof(vertHW_1W));
; 236  : 			BYTE*	bytes		= 0;
; 237  : 			VERIFY				(NULL==V.p_rm_Vertices);
; 238  : 			R_CHK				(HW.pDevice->CreateVertexBuffer(V.vCount*vStride,dwUsage,0,D3DPOOL_MANAGED,&V.p_rm_Vertices,0));

	mov	ebx, DWORD PTR _V$[ebp]
	mov	esi, eax
	mov	ecx, DWORD PTR __imp_?HW@@3VCHW@@A
	push	0
	mov	DWORD PTR _bytes$1[esp+36], 0
	lea	eax, DWORD PTR [ebx+76]
	mov	edx, DWORD PTR [ecx+8]
	push	eax
	mov	eax, DWORD PTR [ebx+84]
	push	1
	mov	ecx, DWORD PTR [edx]
	push	0
	imul	eax, esi
	push	edi
	push	eax
	push	edx
	call	DWORD PTR [ecx+104]
	cmp	BYTE PTR ?ignore_always@?L@??_Load_hw@CSkeletonX_ext@@MAEXAAVFvisual@@PAX@Z@4_NA, 0
	mov	esi, DWORD PTR __imp_?error@xrDebug@@QAEXJPBD0H0AA_N@Z
	jne	SHORT $LN10@Load_hw
	test	eax, eax
	jns	SHORT $LN10@Load_hw
	mov	ecx, DWORD PTR __imp_?Debug@@3VxrDebug@@A
	push	OFFSET ?ignore_always@?L@??_Load_hw@CSkeletonX_ext@@MAEXAAVFvisual@@PAX@Z@4_NA
	push	OFFSET ??_C@_0BJ@KMGOHEHC@CSkeletonX_ext?3?3_Load_hw@
	push	238					; 000000eeH
	push	OFFSET ??_C@_0DI@MPKGEPP@I?3?2Vitalya?2mine?2NSProjectX?2laye@
	push	OFFSET ??_C@_0FO@OKEEELNA@HW?4pDevice?9?$DOCreateVertexBuffer?$CI@
	push	eax
	call	esi
$LN10@Load_hw:

; 239  : 			R_CHK				(V.p_rm_Vertices->Lock(0,0,(void**)&bytes,0));

	mov	eax, DWORD PTR [ebx+76]
	lea	edx, DWORD PTR _bytes$1[esp+32]
	push	0
	push	edx
	push	0
	mov	ecx, DWORD PTR [eax]
	push	0
	push	eax
	call	DWORD PTR [ecx+44]
	cmp	BYTE PTR ?ignore_always@?P@??_Load_hw@CSkeletonX_ext@@MAEXAAVFvisual@@PAX@Z@4_NA, 0
	jne	SHORT $LN13@Load_hw
	test	eax, eax
	jns	SHORT $LN13@Load_hw
	mov	ecx, DWORD PTR __imp_?Debug@@3VxrDebug@@A
	push	OFFSET ?ignore_always@?P@??_Load_hw@CSkeletonX_ext@@MAEXAAVFvisual@@PAX@Z@4_NA
	push	OFFSET ??_C@_0BJ@KMGOHEHC@CSkeletonX_ext?3?3_Load_hw@
	push	239					; 000000efH
	push	OFFSET ??_C@_0DI@MPKGEPP@I?3?2Vitalya?2mine?2NSProjectX?2laye@
	push	OFFSET ??_C@_0CM@JFCBAHIP@V?4p_rm_Vertices?9?$DOLock?$CI0?00?0?$CIvoid@
	push	eax
	call	esi
$LN13@Load_hw:

; 241  : 			vertBoned1W*	src = (vertBoned1W*)_verts_;
; 242  : 			for (u32 it=0; it<V.vCount; it++)	{

	cmp	DWORD PTR [ebx+84], 0
	mov	edi, DWORD PTR _bytes$1[esp+32]
	mov	DWORD PTR _it$1$[esp+32], 0
	jbe	$LN17@Load_hw

; 240  : 			vertHW_1W*		dst	= (vertHW_1W*)bytes;

	mov	esi, DWORD PTR __verts_$[ebp]
	add	esi, 52					; 00000034H
$LL18@Load_hw:

; 244  : 				dst->set	(src->P,src->N,src->T,src->B,uv,src->matrix*3);

	mov	eax, DWORD PTR [esi+4]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector2.h

; 15   : 	IC SelfRef set(float _u, float _v)				{ x=T(_u); y=T(_v);				return *this;	}

	movss	xmm0, DWORD PTR [esi-4]
	movss	DWORD PTR _uv$4[esp+32], xmm0
	movss	xmm0, DWORD PTR [esi]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp

; 244  : 				dst->set	(src->P,src->N,src->T,src->B,uv,src->matrix*3);

	lea	eax, DWORD PTR [eax+eax*2]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector2.h

; 15   : 	IC SelfRef set(float _u, float _v)				{ x=T(_u); y=T(_v);				return *this;	}

	movss	DWORD PTR _uv$4[esp+36], xmm0
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp

; 244  : 				dst->set	(src->P,src->N,src->T,src->B,uv,src->matrix*3);

	push	eax
	lea	eax, DWORD PTR _uv$4[esp+36]
	push	eax
	mov	eax, DWORD PTR [esi-16]
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR [esi-12]
	mov	DWORD PTR [ecx+4], eax
	mov	eax, DWORD PTR [esi-8]
	mov	DWORD PTR [ecx+8], eax
	mov	ecx, esp
	mov	eax, DWORD PTR [esi-28]
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR [esi-24]
	mov	DWORD PTR [ecx+4], eax
	mov	eax, DWORD PTR [esi-20]
	mov	DWORD PTR [ecx+8], eax
	mov	ecx, esp
	mov	eax, DWORD PTR [esi-40]
	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR [esi-36]
	mov	DWORD PTR [ecx+4], eax
	mov	eax, DWORD PTR [esi-32]
	mov	DWORD PTR [ecx+8], eax
	lea	eax, DWORD PTR [esi-52]
	push	eax
	mov	ecx, edi
	call	?set@vertHW_1W@@QAEXAAU?$_vector3@M@@U2@11AAU?$_vector2@M@@H@Z ; vertHW_1W::set
	mov	eax, DWORD PTR _it$1$[esp+32]

; 245  : 				dst++; src++;

	lea	esi, DWORD PTR [esi+60]
	inc	eax
	add	edi, 24					; 00000018H
	mov	DWORD PTR _it$1$[esp+32], eax
	cmp	eax, DWORD PTR [ebx+84]
	jb	$LL18@Load_hw
$LN17@Load_hw:

; 246  : 			}
; 247  : 			V.p_rm_Vertices->Unlock	();

	mov	eax, DWORD PTR [ebx+76]
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+48]

; 248  : 			V.rm_geom.create		(dwDecl_01W, V.p_rm_Vertices, V.p_rm_Indices);

	push	DWORD PTR [ebx+88]

; 269  : 		}
; 270  : 		break;
; 271  : 	}
; 272  : }

	lea	ecx, DWORD PTR [ebx+72]
	push	DWORD PTR [ebx+76]
	push	OFFSET ?dwDecl_01W@@3PAU_D3DVERTEXELEMENT9@@A
	call	DWORD PTR __imp_?create@resptrcode_geom@@QAEXPAU_D3DVERTEXELEMENT9@@PAUIDirect3DVertexBuffer9@@PAUIDirect3DIndexBuffer9@@@Z
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
$LN39@Load_hw:

; 249  : 		}  
; 250  : 		break;
; 251  : 	case RM_SKINNING_2B:
; 252  : 		//Msg					("skinning: hw, 2-weight");
; 253  : 		{
; 254  : 			u32		vStride		= D3DXGetDeclVertexSize		(dwDecl_2W,0);

	push	0
	push	OFFSET ?dwDecl_2W@@3PAU_D3DVERTEXELEMENT9@@A
	call	DWORD PTR __imp__D3DXGetDeclVertexSize@8

; 255  : 			VERIFY	(vStride==sizeof(vertHW_2W));
; 256  : 			BYTE*	bytes		= 0;
; 257  : 			VERIFY				(NULL==V.p_rm_Vertices);
; 258  : 			R_CHK				(HW.pDevice->CreateVertexBuffer(V.vCount*vStride,dwUsage,0,D3DPOOL_MANAGED,&V.p_rm_Vertices,0));

	mov	ebx, DWORD PTR _V$[ebp]
	mov	esi, eax
	mov	ecx, DWORD PTR __imp_?HW@@3VCHW@@A
	push	0
	mov	DWORD PTR _bytes$2[esp+36], 0
	lea	eax, DWORD PTR [ebx+76]
	mov	edx, DWORD PTR [ecx+8]
	push	eax
	mov	eax, DWORD PTR [ebx+84]
	push	1
	mov	ecx, DWORD PTR [edx]
	push	0
	imul	eax, esi
	push	edi
	push	eax
	push	edx
	call	DWORD PTR [ecx+104]
	cmp	BYTE PTR ?ignore_always@?BK@??_Load_hw@CSkeletonX_ext@@MAEXAAVFvisual@@PAX@Z@4_NA, 0
	mov	esi, DWORD PTR __imp_?error@xrDebug@@QAEXJPBD0H0AA_N@Z
	jne	SHORT $LN25@Load_hw
	test	eax, eax
	jns	SHORT $LN25@Load_hw
	mov	ecx, DWORD PTR __imp_?Debug@@3VxrDebug@@A
	push	OFFSET ?ignore_always@?BK@??_Load_hw@CSkeletonX_ext@@MAEXAAVFvisual@@PAX@Z@4_NA
	push	OFFSET ??_C@_0BJ@KMGOHEHC@CSkeletonX_ext?3?3_Load_hw@
	push	258					; 00000102H
	push	OFFSET ??_C@_0DI@MPKGEPP@I?3?2Vitalya?2mine?2NSProjectX?2laye@
	push	OFFSET ??_C@_0FO@OKEEELNA@HW?4pDevice?9?$DOCreateVertexBuffer?$CI@
	push	eax
	call	esi
$LN25@Load_hw:

; 259  : 			R_CHK				(V.p_rm_Vertices->Lock(0,0,(void**)&bytes,0));

	mov	eax, DWORD PTR [ebx+76]
	lea	edx, DWORD PTR _bytes$2[esp+32]
	push	0
	push	edx
	push	0
	mov	ecx, DWORD PTR [eax]
	push	0
	push	eax
	call	DWORD PTR [ecx+44]
	cmp	BYTE PTR ?ignore_always@?BO@??_Load_hw@CSkeletonX_ext@@MAEXAAVFvisual@@PAX@Z@4_NA, 0
	jne	SHORT $LN28@Load_hw
	test	eax, eax
	jns	SHORT $LN28@Load_hw
	mov	ecx, DWORD PTR __imp_?Debug@@3VxrDebug@@A
	push	OFFSET ?ignore_always@?BO@??_Load_hw@CSkeletonX_ext@@MAEXAAVFvisual@@PAX@Z@4_NA
	push	OFFSET ??_C@_0BJ@KMGOHEHC@CSkeletonX_ext?3?3_Load_hw@
	push	259					; 00000103H
	push	OFFSET ??_C@_0DI@MPKGEPP@I?3?2Vitalya?2mine?2NSProjectX?2laye@
	push	OFFSET ??_C@_0CM@JFCBAHIP@V?4p_rm_Vertices?9?$DOLock?$CI0?00?0?$CIvoid@
	push	eax
	call	esi
$LN28@Load_hw:

; 261  : 			vertBoned2W*	src = (vertBoned2W*)_verts_;
; 262  : 			for (u32 it=0; it<V.vCount; it++)	{

	cmp	DWORD PTR [ebx+84], 0
	mov	edi, DWORD PTR _bytes$2[esp+32]
	mov	DWORD PTR _it$1$[esp+32], 0
	jbe	$LN32@Load_hw

; 260  : 			vertHW_2W*		dst	= (vertHW_2W*)bytes;

	mov	esi, DWORD PTR __verts_$[ebp]
	add	esi, 60					; 0000003cH
	npad	4
$LL33@Load_hw:

; 264  : 				dst->set	(src->P,src->N,src->T,src->B,uv,int(src->matrix0)*3,int(src->matrix1)*3,src->w);

	movzx	eax, WORD PTR [esi-58]
	fld	DWORD PTR [esi-8]
	push	ecx
	fstp	DWORD PTR [esp]
	lea	eax, DWORD PTR [eax+eax*2]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector2.h

; 15   : 	IC SelfRef set(float _u, float _v)				{ x=T(_u); y=T(_v);				return *this;	}

	movss	xmm0, DWORD PTR [esi-4]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp

; 264  : 				dst->set	(src->P,src->N,src->T,src->B,uv,int(src->matrix0)*3,int(src->matrix1)*3,src->w);

	push	eax
	movzx	eax, WORD PTR [esi-60]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector2.h

; 15   : 	IC SelfRef set(float _u, float _v)				{ x=T(_u); y=T(_v);				return *this;	}

	movss	DWORD PTR _uv$3[esp+40], xmm0
	movss	xmm0, DWORD PTR [esi]
	movss	DWORD PTR _uv$3[esp+44], xmm0
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp

; 264  : 				dst->set	(src->P,src->N,src->T,src->B,uv,int(src->matrix0)*3,int(src->matrix1)*3,src->w);

	lea	eax, DWORD PTR [eax+eax*2]
	push	eax
	lea	eax, DWORD PTR _uv$3[esp+44]
	push	eax
	mov	eax, DWORD PTR [esi-20]
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR [esi-16]
	mov	DWORD PTR [ecx+4], eax
	mov	eax, DWORD PTR [esi-12]
	mov	DWORD PTR [ecx+8], eax
	mov	ecx, esp
	mov	eax, DWORD PTR [esi-32]
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR [esi-28]
	mov	DWORD PTR [ecx+4], eax
	mov	eax, DWORD PTR [esi-24]
	mov	DWORD PTR [ecx+8], eax
	mov	ecx, esp
	mov	eax, DWORD PTR [esi-44]
	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR [esi-40]
	mov	DWORD PTR [ecx+4], eax
	mov	eax, DWORD PTR [esi-36]
	mov	DWORD PTR [ecx+8], eax
	lea	eax, DWORD PTR [esi-56]
	push	eax
	mov	ecx, edi
	call	?set@vertHW_2W@@QAEXAAU?$_vector3@M@@U2@11AAU?$_vector2@M@@HHM@Z ; vertHW_2W::set
	mov	eax, DWORD PTR _it$1$[esp+32]

; 265  : 				dst++;		src++;

	add	edi, 28					; 0000001cH
	inc	eax
	add	esi, 64					; 00000040H
	mov	DWORD PTR _it$1$[esp+32], eax
	cmp	eax, DWORD PTR [ebx+84]
	jb	$LL33@Load_hw
$LN32@Load_hw:

; 266  : 			}
; 267  : 			V.p_rm_Vertices->Unlock	();

	mov	eax, DWORD PTR [ebx+76]
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+48]

; 268  : 			V.rm_geom.create		(dwDecl_2W, V.p_rm_Vertices, V.p_rm_Indices);

	push	DWORD PTR [ebx+88]

; 269  : 		}
; 270  : 		break;
; 271  : 	}
; 272  : }

	lea	ecx, DWORD PTR [ebx+72]
	push	DWORD PTR [ebx+76]
	push	OFFSET ?dwDecl_2W@@3PAU_D3DVERTEXELEMENT9@@A
	call	DWORD PTR __imp_?create@resptrcode_geom@@QAEXPAU_D3DVERTEXELEMENT9@@PAUIDirect3DVertexBuffer9@@PAUIDirect3DIndexBuffer9@@@Z
$LN2@Load_hw:
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
$LN57@Load_hw:
	DD	$LN34@Load_hw
	DD	$LN35@Load_hw
	DD	$LN35@Load_hw
	DD	$LN39@Load_hw
?_Load_hw@CSkeletonX_ext@@MAEXAAVFvisual@@PAX@Z ENDP	; CSkeletonX_ext::_Load_hw
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\cl_intersect.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\cl_intersect.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\cl_intersect.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\cl_intersect.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\cl_intersect.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\cl_intersect.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\cl_intersect.h
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\cl_intersect.h
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\cl_intersect.h
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\cl_intersect.h
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\cl_intersect.h
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\cl_intersect.h
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\cl_intersect.h
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\cl_intersect.h
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\cl_intersect.h
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\cl_intersect.h
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\cl_intersect.h
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\cl_intersect.h
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\cl_intersect.h
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\cl_intersect.h
;	COMDAT ?MgcSqrDistance@CDB@@YAMABU?$_vector3@M@@000@Z
_TEXT	SEGMENT
$T1 = -16						; size = 4
$T2 = -12						; size = 4
_fDet$1$ = -8						; size = 4
tv913 = -8						; size = 4
_fS$2$ = -4						; size = 4
_fA00$1$ = -4						; size = 4
_fA01$1$ = 8						; size = 4
_fSqrDist$ = 8						; size = 4
_e0$ = 8						; size = 4
_fTmp0$2$ = 12						; size = 4
_fTmp0$1$ = 12						; size = 4
_fT$4$ = 12						; size = 4
_fS$5$ = 12						; size = 4
_fS$3$ = 12						; size = 4
_fA11$1$ = 12						; size = 4
_e1$ = 12						; size = 4
?MgcSqrDistance@CDB@@YAMABU?$_vector3@M@@000@Z PROC	; CDB::MgcSqrDistance, COMDAT
; _rkPoint$ = ecx
; _orig$ = edx

; 413  : 	IC float MgcSqrDistance (const Fvector& rkPoint, const Fvector& orig, const Fvector& e0,const Fvector& e1){

	sub	esp, 16					; 00000010H
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 167  : 		return x*x + y*y + z*z;

	mov	eax, DWORD PTR _e0$[esp+12]

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	xmm6, DWORD PTR [edx]
	subss	xmm6, DWORD PTR [ecx]
	movss	xmm5, DWORD PTR [edx+8]

; 167  : 		return x*x + y*y + z*z;

	movss	xmm3, DWORD PTR [eax]
	movss	xmm0, DWORD PTR [eax+4]
	movaps	xmm2, xmm3
	movss	xmm4, DWORD PTR [eax+8]

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	subss	xmm5, DWORD PTR [ecx+8]
	movss	xmm7, DWORD PTR [edx+4]
	subss	xmm7, DWORD PTR [ecx+4]

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	mov	ecx, DWORD PTR _e1$[esp+12]

; 167  : 		return x*x + y*y + z*z;

	mulss	xmm0, xmm0
	mulss	xmm2, xmm3

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	movss	xmm1, DWORD PTR [ecx]

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	DWORD PTR tv913[esp+16], xmm6

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	movaps	xmm6, xmm1

; 167  : 		return x*x + y*y + z*z;

	addss	xmm2, xmm0

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	mulss	xmm6, xmm3

; 167  : 		return x*x + y*y + z*z;

	movaps	xmm0, xmm4
	mulss	xmm0, xmm4
	addss	xmm2, xmm0

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	movss	xmm0, DWORD PTR [ecx+4]
	mulss	xmm0, DWORD PTR [eax+4]
	addss	xmm6, xmm0

; 167  : 		return x*x + y*y + z*z;

	movss	DWORD PTR _fA00$1$[esp+16], xmm2

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	movss	xmm2, DWORD PTR [ecx+8]
	movaps	xmm0, xmm2
	mulss	xmm0, xmm4
	mulss	xmm4, xmm5
	addss	xmm6, xmm0

; 167  : 		return x*x + y*y + z*z;

	movaps	xmm0, xmm1
	mulss	xmm0, xmm1
	movss	DWORD PTR _fA11$1$[esp+12], xmm0
	movss	xmm0, DWORD PTR [ecx+4]
	mulss	xmm0, xmm0

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	movss	DWORD PTR _fA01$1$[esp+12], xmm6

; 167  : 		return x*x + y*y + z*z;

	movss	xmm6, DWORD PTR _fA11$1$[esp+12]
	addss	xmm6, xmm0
	movaps	xmm0, xmm2
	mulss	xmm0, xmm2

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	mulss	xmm2, xmm5

; 167  : 		return x*x + y*y + z*z;

	addss	xmm6, xmm0
	mulss	xmm5, xmm5

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	movss	xmm0, DWORD PTR [eax+4]
	mulss	xmm0, xmm7

; 167  : 		return x*x + y*y + z*z;

	movss	DWORD PTR _fA11$1$[esp+12], xmm6

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	movss	xmm6, DWORD PTR tv913[esp+16]
	mulss	xmm3, xmm6
	mulss	xmm1, xmm6
	addss	xmm0, xmm3
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\cl_intersect.h

; 422  : 		float fB1 = kDiff.dotproduct(e1);

	mulss	xmm6, xmm6
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	movss	xmm3, DWORD PTR [ecx+4]
	mulss	xmm3, xmm7
	addss	xmm0, xmm4

; 167  : 		return x*x + y*y + z*z;

	mulss	xmm7, xmm7

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	addss	xmm3, xmm1
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\cl_intersect.h

; 424  : 		float fDet = _abs(fA00*fA11-fA01*fA01);

	movss	xmm1, DWORD PTR _fA01$1$[esp+12]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 167  : 		return x*x + y*y + z*z;

	addss	xmm7, xmm6

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	movss	DWORD PTR $T2[esp+16], xmm0
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\cl_intersect.h

; 424  : 		float fDet = _abs(fA00*fA11-fA01*fA01);

	movaps	xmm0, xmm1

; 425  : 		float fS = fA01*fB1-fA11*fB0;

	movss	xmm4, DWORD PTR $T2[esp+16]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	addss	xmm3, xmm2
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\cl_intersect.h

; 424  : 		float fDet = _abs(fA00*fA11-fA01*fA01);

	mulss	xmm0, xmm1
	movss	xmm2, DWORD PTR _fA11$1$[esp+12]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 167  : 		return x*x + y*y + z*z;

	addss	xmm7, xmm5
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\cl_intersect.h

; 424  : 		float fDet = _abs(fA00*fA11-fA01*fA01);

	movss	xmm5, DWORD PTR _fA00$1$[esp+16]
	mulss	xmm2, xmm5
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	movss	DWORD PTR $T1[esp+16], xmm3
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\cl_intersect.h

; 424  : 		float fDet = _abs(fA00*fA11-fA01*fA01);

	subss	xmm2, xmm0

; 425  : 		float fS = fA01*fB1-fA11*fB0;

	movaps	xmm0, xmm4
	mulss	xmm0, DWORD PTR _fA11$1$[esp+12]
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h

; 676  :             return (float)fabs(_X);

	andps	xmm2, DWORD PTR __xmm@7fffffff7fffffff7fffffff7fffffff
	movss	DWORD PTR _fDet$1$[esp+16], xmm2
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\cl_intersect.h

; 425  : 		float fS = fA01*fB1-fA11*fB0;

	movaps	xmm2, xmm3
	mulss	xmm2, xmm1
	subss	xmm2, xmm0

; 426  : 		float fT = fA01*fB0-fA00*fB1;

	movaps	xmm0, xmm3
	movss	DWORD PTR _fS$2$[esp+16], xmm2
	movaps	xmm2, xmm4
	mulss	xmm2, xmm1

; 427  : 		float fSqrDist;
; 428  : 
; 429  : 		if ( fS + fT <= fDet ){

	movss	xmm6, DWORD PTR _fDet$1$[esp+16]
	mulss	xmm0, xmm5
	subss	xmm2, xmm0
	movaps	xmm0, xmm2
	addss	xmm0, DWORD PTR _fS$2$[esp+16]
	comiss	xmm6, xmm0
	movss	xmm6, DWORD PTR _fA11$1$[esp+12]
	xorps	xmm0, xmm0
	jb	$LN2@MgcSqrDist

; 430  : 			if ( fS < 0.0f ){

	comiss	xmm0, DWORD PTR _fS$2$[esp+16]
	jbe	SHORT $LN4@MgcSqrDist

; 431  : 				if ( fT < 0.0f ){  // region 4

	comiss	xmm0, xmm2
	jbe	SHORT $LN6@MgcSqrDist

; 432  : 					if ( fB0 < 0.0f ){

	comiss	xmm0, xmm4
	ja	SHORT $LN22@MgcSqrDist
$LN6@MgcSqrDist:
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h

; 676  :             return (float)fabs(_X);

	comiss	xmm3, xmm0
	jae	$LN73@MgcSqrDist
	movaps	xmm0, xmm3
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	comiss	xmm0, xmm6
	jb	$LN34@MgcSqrDist
	jmp	$LN74@MgcSqrDist
$LN4@MgcSqrDist:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\cl_intersect.h

; 467  : 			}else if ( fT < 0.0f ){  // region 5

	comiss	xmm0, xmm2
	jbe	SHORT $LN20@MgcSqrDist

; 468  : 				fT = 0.0f;
; 469  : 				if ( fB0 >= 0.0f ){

	comiss	xmm4, xmm0
	jae	$LN73@MgcSqrDist
$LN22@MgcSqrDist:
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h

; 676  :             return (float)fabs(_X);

	movaps	xmm0, xmm4
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	comiss	xmm0, xmm5
	jb	$LN44@MgcSqrDist
$LN75@MgcSqrDist:
	addss	xmm5, xmm7
	addss	xmm4, xmm4
	addss	xmm5, xmm4
	movss	DWORD PTR _fSqrDist$[esp+12], xmm5
	fld	DWORD PTR _fSqrDist$[esp+12]
	fabs
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\cl_intersect.h

; 571  : 	}

	add	esp, 16					; 00000010H
	ret	0
$LN20@MgcSqrDist:

; 470  : 					fS = 0.0f;
; 471  : 					fSqrDist = fC;
; 472  : 				}else if ( -fB0 >= fA00 ){
; 473  : 					fS = 1.0;
; 474  : 					fSqrDist = fA00+2.0f*fB0+fC;
; 475  : 				}else{
; 476  : 					fS = -fB0/fA00;
; 477  : 					fSqrDist = fB0*fS+fC;
; 478  : 				}
; 479  : 			}else{  // region 0
; 480  : 				// minimum at interior point
; 481  : 				float fInvDet = 1.0f/fDet;

	movss	xmm3, DWORD PTR __real@3f800000

; 482  : 				fS *= fInvDet;
; 483  : 				fT *= fInvDet;
; 484  : 				fSqrDist = fS*(fA00*fS+fA01*fT+2.0f*fB0) +

	addss	xmm4, xmm4
	divss	xmm3, DWORD PTR _fDet$1$[esp+16]
	movaps	xmm1, xmm3
	mulss	xmm3, xmm2
	mulss	xmm1, DWORD PTR _fS$2$[esp+16]
	movaps	xmm2, xmm3
	mulss	xmm2, DWORD PTR _fA01$1$[esp+12]
	movaps	xmm0, xmm1
	mulss	xmm0, xmm5
	addss	xmm2, xmm0
	movaps	xmm0, xmm3
	mulss	xmm0, xmm6
	addss	xmm2, xmm4
	mulss	xmm2, xmm1
	mulss	xmm1, DWORD PTR _fA01$1$[esp+12]
	addss	xmm0, xmm1
	movss	xmm1, DWORD PTR $T1[esp+16]
	addss	xmm1, xmm1
	addss	xmm0, xmm1
	mulss	xmm0, xmm3
	addss	xmm2, xmm0
	addss	xmm2, xmm7
	movss	DWORD PTR _fSqrDist$[esp+12], xmm2
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h

; 676  :             return (float)fabs(_X);

	fld	DWORD PTR _fSqrDist$[esp+12]
	fabs
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\cl_intersect.h

; 571  : 	}

	add	esp, 16					; 00000010H
	ret	0
$LN2@MgcSqrDist:

; 485  : 					fT*(fA01*fS+fA11*fT+2.0f*fB1)+fC;
; 486  : 			}
; 487  : 		}else{
; 488  : 			float fTmp0, fTmp1, fNumer, fDenom;
; 489  : 
; 490  : 			if ( fS < 0.0f ){  // region 2

	comiss	xmm0, DWORD PTR _fS$2$[esp+16]
	jbe	$LN26@MgcSqrDist

; 491  : 				fTmp0 = fA01 + fB0;

	movaps	xmm2, xmm4
	addss	xmm2, xmm1
	movss	DWORD PTR _fTmp0$1$[esp+12], xmm2

; 492  : 				fTmp1 = fA11 + fB1;

	movaps	xmm2, xmm3
	addss	xmm2, xmm6

; 493  : 				if ( fTmp1 > fTmp0 ){

	comiss	xmm2, DWORD PTR _fTmp0$1$[esp+12]
	jbe	$LN28@MgcSqrDist

; 494  : 					fNumer = fTmp1 - fTmp0;

	subss	xmm2, DWORD PTR _fTmp0$1$[esp+12]

; 495  : 					fDenom = fA00-2.0f*fA01+fA11;

	movaps	xmm0, xmm1
	addss	xmm4, xmm4
	addss	xmm0, xmm1
	movaps	xmm1, xmm5
	subss	xmm1, xmm0
	addss	xmm1, xmm6

; 496  : 					if ( fNumer >= fDenom ){

	comiss	xmm2, xmm1
	jb	SHORT $LN30@MgcSqrDist

; 497  : 						fS = 1.0f;
; 498  : 						fT = 0.0f;
; 499  : 						fSqrDist = fA00+2.0f*fB0+fC;

	addss	xmm4, xmm5

; 504  : 							fT*(fA01*fS+fA11*fT+2.0f*fB1)+fC;
; 505  : 					}
; 506  : 				}else{

	addss	xmm4, xmm7
	movss	DWORD PTR _fSqrDist$[esp+12], xmm4
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h

; 676  :             return (float)fabs(_X);

	fld	DWORD PTR _fSqrDist$[esp+12]
	fabs
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\cl_intersect.h

; 571  : 	}

	add	esp, 16					; 00000010H
	ret	0
$LN30@MgcSqrDist:

; 500  : 					}else{
; 501  : 						fS = fNumer/fDenom;

	divss	xmm2, xmm1

; 502  : 						fT = 1.0f - fS;
; 503  : 						fSqrDist = fS*(fA00*fS+fA01*fT+2.0f*fB0) +

	addss	xmm3, xmm3
	movss	DWORD PTR _fS$3$[esp+12], xmm2
	movss	xmm0, DWORD PTR _fS$3$[esp+12]
	movss	xmm2, DWORD PTR __real@3f800000
	subss	xmm2, xmm0
	mulss	xmm0, DWORD PTR _fA01$1$[esp+12]
	movaps	xmm1, xmm2
	mulss	xmm1, xmm6
	addss	xmm1, xmm0
	movss	xmm0, DWORD PTR _fS$3$[esp+12]
	mulss	xmm0, xmm5
	addss	xmm1, xmm3
	mulss	xmm1, xmm2
	mulss	xmm2, DWORD PTR _fA01$1$[esp+12]
	addss	xmm2, xmm0
	addss	xmm4, xmm2
	mulss	xmm4, DWORD PTR _fS$3$[esp+12]
	addss	xmm4, xmm1

; 504  : 							fT*(fA01*fS+fA11*fT+2.0f*fB1)+fC;
; 505  : 					}
; 506  : 				}else{

	addss	xmm4, xmm7
	movss	DWORD PTR _fSqrDist$[esp+12], xmm4
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h

; 676  :             return (float)fabs(_X);

	fld	DWORD PTR _fSqrDist$[esp+12]
	fabs
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\cl_intersect.h

; 571  : 	}

	add	esp, 16					; 00000010H
	ret	0
$LN28@MgcSqrDist:

; 507  : 					fS = 0.0f;
; 508  : 					if ( fTmp1 <= 0.0f ){

	comiss	xmm0, xmm2
	jae	$LN74@MgcSqrDist

; 509  : 						fT = 1.0f;
; 510  : 						fSqrDist = fA11+2.0f*fB1+fC;
; 511  : 					}else if ( fB1 >= 0.0f ){

	comiss	xmm3, xmm0
	jae	$LN73@MgcSqrDist
$LN34@MgcSqrDist:
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h

; 676  :             return (float)fabs(_X);

	movaps	xmm0, xmm3
	divss	xmm0, xmm6
	mulss	xmm0, xmm3
	subss	xmm7, xmm0
	movss	DWORD PTR _fSqrDist$[esp+12], xmm7
	fld	DWORD PTR _fSqrDist$[esp+12]
	fabs
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\cl_intersect.h

; 571  : 	}

	add	esp, 16					; 00000010H
	ret	0
$LN26@MgcSqrDist:

; 512  : 						fT = 0.0f;
; 513  : 						fSqrDist = fC;
; 514  : 					}else{
; 515  : 						fT = -fB1/fA11;
; 516  : 						fSqrDist = fB1*fT+fC;
; 517  : 					}
; 518  : 				}
; 519  : 			}else if ( fT < 0.0 ){  // region 6

	comiss	xmm0, xmm2
	movaps	xmm2, xmm3
	jbe	$LN36@MgcSqrDist

; 520  : 				fTmp0 = fA01 + fB1;

	addss	xmm2, xmm1
	movss	DWORD PTR _fTmp0$2$[esp+12], xmm2

; 521  : 				fTmp1 = fA00 + fB0;

	movaps	xmm2, xmm4
	addss	xmm2, xmm5

; 522  : 				if ( fTmp1 > fTmp0 ){

	comiss	xmm2, DWORD PTR _fTmp0$2$[esp+12]
	jbe	$LN38@MgcSqrDist

; 523  : 					fNumer = fTmp1 - fTmp0;

	subss	xmm2, DWORD PTR _fTmp0$2$[esp+12]

; 524  : 					fDenom = fA00-2.0f*fA01+fA11;

	movaps	xmm0, xmm1
	addss	xmm3, xmm3
	addss	xmm0, xmm1
	movaps	xmm1, xmm5
	subss	xmm1, xmm0
	addss	xmm1, xmm6

; 525  : 					if ( fNumer >= fDenom ){

	comiss	xmm2, xmm1
	jb	SHORT $LN40@MgcSqrDist

; 526  : 						fT = 1.0f;
; 527  : 						fS = 0.0f;
; 528  : 						fSqrDist = fA11+2.0f*fB1+fC;

	addss	xmm3, xmm6

; 533  : 							fT*(fA01*fS+fA11*fT+2.0f*fB1)+fC;
; 534  : 					}
; 535  : 				}else{

	addss	xmm3, xmm7
	movss	DWORD PTR _fSqrDist$[esp+12], xmm3
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h

; 676  :             return (float)fabs(_X);

	fld	DWORD PTR _fSqrDist$[esp+12]
	fabs
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\cl_intersect.h

; 571  : 	}

	add	esp, 16					; 00000010H
	ret	0
$LN40@MgcSqrDist:

; 529  : 					}else{
; 530  : 						fT = fNumer/fDenom;

	divss	xmm2, xmm1

; 531  : 						fS = 1.0f - fT;

	movss	xmm1, DWORD PTR __real@3f800000

; 532  : 						fSqrDist = fS*(fA00*fS+fA01*fT+2.0f*fB0) +

	addss	xmm4, xmm4
	subss	xmm1, xmm2
	movss	DWORD PTR _fT$4$[esp+12], xmm2
	mulss	xmm2, DWORD PTR _fA01$1$[esp+12]
	movaps	xmm0, xmm1
	mulss	xmm0, xmm5
	addss	xmm2, xmm0
	movss	xmm0, DWORD PTR _fT$4$[esp+12]
	mulss	xmm0, xmm6
	addss	xmm2, xmm4
	mulss	xmm2, xmm1
	mulss	xmm1, DWORD PTR _fA01$1$[esp+12]
	addss	xmm0, xmm1
	addss	xmm3, xmm0
	mulss	xmm3, DWORD PTR _fT$4$[esp+12]
	addss	xmm3, xmm2

; 533  : 							fT*(fA01*fS+fA11*fT+2.0f*fB1)+fC;
; 534  : 					}
; 535  : 				}else{

	addss	xmm3, xmm7
	movss	DWORD PTR _fSqrDist$[esp+12], xmm3
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h

; 676  :             return (float)fabs(_X);

	fld	DWORD PTR _fSqrDist$[esp+12]
	fabs
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\cl_intersect.h

; 571  : 	}

	add	esp, 16					; 00000010H
	ret	0
$LN38@MgcSqrDist:

; 536  : 					fT = 0.0f;
; 537  : 					if ( fTmp1 <= 0.0f ){

	comiss	xmm0, xmm2
	jae	$LN75@MgcSqrDist

; 538  : 						fS = 1.0f;
; 539  : 						fSqrDist = fA00+2.0f*fB0+fC;
; 540  : 					}else if ( fB0 >= 0.0f ){

	comiss	xmm4, xmm0
	jae	SHORT $LN73@MgcSqrDist
$LN44@MgcSqrDist:
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h

; 676  :             return (float)fabs(_X);

	movaps	xmm0, xmm4
	divss	xmm0, xmm5
	mulss	xmm0, xmm4
	subss	xmm7, xmm0
	movss	DWORD PTR _fSqrDist$[esp+12], xmm7
	fld	DWORD PTR _fSqrDist$[esp+12]
	fabs
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\cl_intersect.h

; 571  : 	}

	add	esp, 16					; 00000010H
	ret	0
$LN36@MgcSqrDist:

; 541  : 						fS = 0.0f;
; 542  : 						fSqrDist = fC;
; 543  : 					}else{
; 544  : 						fS = -fB0/fA00;
; 545  : 						fSqrDist = fB0*fS+fC;
; 546  : 					}
; 547  : 				}
; 548  : 			}else{  // region 1
; 549  : 				fNumer = fA11 + fB1 - fA01 - fB0;

	addss	xmm2, xmm6
	subss	xmm2, xmm1
	subss	xmm2, xmm4

; 550  : 				if ( fNumer <= 0.0f ){

	comiss	xmm0, xmm2
	jb	SHORT $LN46@MgcSqrDist
$LN74@MgcSqrDist:
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h

; 676  :             return (float)fabs(_X);

	addss	xmm7, xmm6
	addss	xmm3, xmm3
	addss	xmm7, xmm3
$LN73@MgcSqrDist:
	movss	DWORD PTR _fSqrDist$[esp+12], xmm7
	fld	DWORD PTR _fSqrDist$[esp+12]
	fabs
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\cl_intersect.h

; 571  : 	}

	add	esp, 16					; 00000010H
	ret	0
$LN46@MgcSqrDist:

; 551  : 					fS = 0.0f;
; 552  : 					fT = 1.0f;
; 553  : 					fSqrDist = fA11+2.0f*fB1+fC;
; 554  : 				}else{
; 555  : 					fDenom = fA00-2.0f*fA01+fA11;

	movaps	xmm0, xmm1
	addss	xmm4, xmm4
	addss	xmm0, xmm1
	movaps	xmm1, xmm5
	subss	xmm1, xmm0
	addss	xmm1, xmm6

; 556  : 					if ( fNumer >= fDenom ){

	comiss	xmm2, xmm1
	jb	SHORT $LN48@MgcSqrDist

; 557  : 						fS = 1.0f;
; 558  : 						fT = 0.0f;
; 559  : 						fSqrDist = fA00+2.0f*fB0+fC;

	addss	xmm4, xmm5
	addss	xmm4, xmm7
	movss	DWORD PTR _fSqrDist$[esp+12], xmm4
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h

; 676  :             return (float)fabs(_X);

	fld	DWORD PTR _fSqrDist$[esp+12]
	fabs
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\cl_intersect.h

; 571  : 	}

	add	esp, 16					; 00000010H
	ret	0
$LN48@MgcSqrDist:

; 560  : 					}else{
; 561  : 						fS = fNumer/fDenom;

	divss	xmm2, xmm1

; 562  : 						fT = 1.0f - fS;
; 563  : 						fSqrDist = fS*(fA00*fS+fA01*fT+2.0f*fB0) +

	addss	xmm3, xmm3
	movss	DWORD PTR _fS$5$[esp+12], xmm2
	movss	xmm0, DWORD PTR _fS$5$[esp+12]
	movss	xmm2, DWORD PTR __real@3f800000
	subss	xmm2, xmm0
	mulss	xmm0, DWORD PTR _fA01$1$[esp+12]
	movaps	xmm1, xmm2
	mulss	xmm1, xmm6
	addss	xmm1, xmm0
	movss	xmm0, DWORD PTR _fS$5$[esp+12]
	mulss	xmm0, xmm5
	addss	xmm1, xmm3
	mulss	xmm1, xmm2
	mulss	xmm2, DWORD PTR _fA01$1$[esp+12]
	addss	xmm2, xmm0
	addss	xmm2, xmm4
	mulss	xmm2, DWORD PTR _fS$5$[esp+12]
	addss	xmm1, xmm2
	addss	xmm1, xmm7
	movss	DWORD PTR _fSqrDist$[esp+12], xmm1
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h

; 676  :             return (float)fabs(_X);

	fld	DWORD PTR _fSqrDist$[esp+12]
	fabs
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\cl_intersect.h

; 571  : 	}

	add	esp, 16					; 00000010H
	ret	0
?MgcSqrDistance@CDB@@YAMABU?$_vector3@M@@000@Z ENDP	; CDB::MgcSqrDistance
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\cl_intersect.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\cl_intersect.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\cl_intersect.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\cl_intersect.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\cl_intersect.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\cl_intersect.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\cl_intersect.h
;	COMDAT ?TestSphereTri@CDB@@YA?AW4EST_Result@1@ABU?$_vector3@M@@M000@Z
_TEXT	SEGMENT
_fRSqr$ = 8						; size = 4
_sphereRadius$ = 8					; size = 4
_e0$ = 12						; size = 4
_e1$ = 16						; size = 4
?TestSphereTri@CDB@@YA?AW4EST_Result@1@ABU?$_vector3@M@@M000@Z PROC ; CDB::TestSphereTri, COMDAT
; _sphereOrigin$ = ecx
; _orig$ = edx

; 583  : 		float fRSqr = sphereRadius*sphereRadius;

	movss	xmm6, DWORD PTR _sphereRadius$[esp-4]

; 588  : 		int iInside = 0;

	xor	eax, eax
	push	esi
	mov	esi, edx
	mulss	xmm6, xmm6
	push	edi
	mov	edi, ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	xmm4, DWORD PTR [esi]
	movss	xmm3, DWORD PTR [esi+4]
	subss	xmm4, DWORD PTR [edi]
	subss	xmm3, DWORD PTR [edi+4]
	movss	xmm5, DWORD PTR [esi+8]
	subss	xmm5, DWORD PTR [edi+8]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\cl_intersect.h

; 583  : 		float fRSqr = sphereRadius*sphereRadius;

	movss	DWORD PTR _fRSqr$[esp+4], xmm6
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 167  : 		return x*x + y*y + z*z;

	movaps	xmm0, xmm4
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\cl_intersect.h

; 588  : 		int iInside = 0;

	movaps	xmm1, xmm3
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 167  : 		return x*x + y*y + z*z;

	mulss	xmm0, xmm4
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\cl_intersect.h

; 588  : 		int iInside = 0;

	mulss	xmm1, xmm3
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 167  : 		return x*x + y*y + z*z;

	addss	xmm1, xmm0
	movaps	xmm0, xmm5
	mulss	xmm0, xmm5
	addss	xmm1, xmm0
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\cl_intersect.h

; 591  : 		if ( kV0mC.square_magnitude() <= fRSqr )

	comiss	xmm6, xmm1
	jb	SHORT $LN2@TestSphere

; 592  : 			iInside++;

	mov	eax, 1
$LN2@TestSphere:
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	mov	ecx, DWORD PTR _e0$[esp+4]
	movaps	xmm1, xmm4
	movaps	xmm2, xmm3
	movaps	xmm0, xmm5
	addss	xmm2, DWORD PTR [ecx+4]
	addss	xmm1, DWORD PTR [ecx]
	addss	xmm0, DWORD PTR [ecx+8]
	mulss	xmm2, xmm2

; 167  : 		return x*x + y*y + z*z;

	mulss	xmm1, xmm1
	mulss	xmm0, xmm0
	addss	xmm2, xmm1
	addss	xmm2, xmm0
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\cl_intersect.h

; 597  : 		if ( kDiff.square_magnitude() <= fRSqr )

	comiss	xmm6, xmm2
	jb	SHORT $LN3@TestSphere

; 598  : 			iInside++;

	inc	eax
$LN3@TestSphere:
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	mov	edx, DWORD PTR _e1$[esp+4]
	addss	xmm3, DWORD PTR [edx+4]
	addss	xmm4, DWORD PTR [edx]
	addss	xmm5, DWORD PTR [edx+8]
	mulss	xmm3, xmm3

; 167  : 		return x*x + y*y + z*z;

	mulss	xmm4, xmm4
	mulss	xmm5, xmm5
	addss	xmm3, xmm4
	addss	xmm3, xmm5
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\cl_intersect.h

; 602  : 		if ( kDiff.square_magnitude() <= fRSqr )

	comiss	xmm6, xmm3
	jb	SHORT $LN4@TestSphere

; 603  : 			iInside++;

	inc	eax
$LN4@TestSphere:

; 604  : 
; 605  : 		// triangle does not traversely intersect sphere
; 606  : 		if ( iInside == 3 ) return stInside;

	cmp	eax, 3
	jne	SHORT $LN5@TestSphere
	pop	edi
	mov	eax, 2

; 616  : 	}

	pop	esi
	ret	0
$LN5@TestSphere:

; 607  : 
; 608  : 		// triangle transversely intersects sphere
; 609  : 		if ( iInside > 0 ) return stIntersect;

	test	eax, eax
	je	SHORT $LN6@TestSphere
$LN22@TestSphere:
	pop	edi

; 616  : 	}

	mov	eax, 1
	pop	esi
	ret	0
$LN6@TestSphere:

; 610  : 
; 611  : 		// All vertices are outside the sphere, but the triangle might still
; 612  : 		// intersect the sphere.  This is the case when the distance from the
; 613  : 		// sphere center to the triangle is smaller than the radius.
; 614  : 		float fSqrDist = MgcSqrDistance(sphereOrigin,orig,e0,e1);

	push	edx
	push	ecx
	mov	edx, esi
	mov	ecx, edi
	call	?MgcSqrDistance@CDB@@YAMABU?$_vector3@M@@000@Z ; CDB::MgcSqrDistance

; 615  : 		return (fSqrDist < fRSqr)?stIntersect:stNone;

	fld	DWORD PTR _fRSqr$[esp+12]
	add	esp, 8
	fcomip	ST(1)
	fstp	ST(0)
	ja	SHORT $LN22@TestSphere
	pop	edi
	xor	eax, eax

; 616  : 	}

	pop	esi
	ret	0
?TestSphereTri@CDB@@YA?AW4EST_Result@1@ABU?$_vector3@M@@M000@Z ENDP ; CDB::TestSphereTri
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\cl_intersect.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\cl_intersect.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\cl_intersect.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\cl_intersect.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\cl_intersect.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\cl_intersect.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\cl_intersect.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\cl_intersect.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\cl_intersect.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\cl_intersect.h
;	COMDAT ?TestSphereTri@CDB@@YA?AW4EST_Result@1@ABU?$_vector3@M@@MPAU3@@Z
_TEXT	SEGMENT
tv445 = -40						; size = 4
tv448 = -36						; size = 4
tv450 = -32						; size = 4
tv453 = -28						; size = 4
_e1$ = -24						; size = 12
_e0$ = -12						; size = 12
_fRSqr$1 = 8						; size = 4
_sphereRadius$ = 8					; size = 4
?TestSphereTri@CDB@@YA?AW4EST_Result@1@ABU?$_vector3@M@@MPAU3@@Z PROC ; CDB::TestSphereTri, COMDAT
; _sphereOrigin$ = ecx
; _p$ = edx

; 619  : 	{

	sub	esp, 40					; 00000028H
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	xmm5, DWORD PTR [edx+8]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\cl_intersect.h

; 588  : 		int iInside = 0;

	xor	eax, eax
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	xmm0, DWORD PTR [edx+20]
	movss	xmm4, DWORD PTR [edx]
	subss	xmm0, xmm5
	movss	xmm3, DWORD PTR [edx+4]
	movss	xmm2, DWORD PTR [edx+12]
	movss	xmm7, DWORD PTR [edx+16]
	subss	xmm2, xmm4
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\cl_intersect.h

; 583  : 		float fRSqr = sphereRadius*sphereRadius;

	movss	xmm6, DWORD PTR _sphereRadius$[esp+36]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	subss	xmm7, xmm3
	movss	DWORD PTR tv445[esp+40], xmm0
	movss	DWORD PTR _e0$[esp+48], xmm0
	movss	xmm0, DWORD PTR [edx+24]
	subss	xmm0, xmm4
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\cl_intersect.h

; 583  : 		float fRSqr = sphereRadius*sphereRadius;

	mulss	xmm6, xmm6
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	subss	xmm4, DWORD PTR [ecx]
	movss	DWORD PTR _e0$[esp+40], xmm2
	movss	DWORD PTR _e0$[esp+44], xmm7
	movss	DWORD PTR tv448[esp+40], xmm0
	movss	DWORD PTR _e1$[esp+40], xmm0
	movss	xmm0, DWORD PTR [edx+28]
	subss	xmm0, xmm3
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\cl_intersect.h

; 583  : 		float fRSqr = sphereRadius*sphereRadius;

	movss	DWORD PTR _fRSqr$1[esp+36], xmm6
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	subss	xmm3, DWORD PTR [ecx+4]
	movss	DWORD PTR tv450[esp+40], xmm0
	movss	DWORD PTR _e1$[esp+44], xmm0
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\cl_intersect.h

; 588  : 		int iInside = 0;

	movaps	xmm1, xmm3
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	xmm0, DWORD PTR [edx+32]
	subss	xmm0, xmm5
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\cl_intersect.h

; 588  : 		int iInside = 0;

	mulss	xmm1, xmm3
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	subss	xmm5, DWORD PTR [ecx+8]
	movss	DWORD PTR tv453[esp+40], xmm0
	movss	DWORD PTR _e1$[esp+48], xmm0

; 167  : 		return x*x + y*y + z*z;

	movaps	xmm0, xmm4
	mulss	xmm0, xmm4
	addss	xmm1, xmm0
	movaps	xmm0, xmm5
	mulss	xmm0, xmm5
	addss	xmm1, xmm0
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\cl_intersect.h

; 591  : 		if ( kV0mC.square_magnitude() <= fRSqr )

	comiss	xmm6, xmm1
	jb	SHORT $LN8@TestSphere

; 592  : 			iInside++;

	mov	eax, 1
$LN8@TestSphere:
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	movaps	xmm1, xmm4
	movaps	xmm0, xmm5
	addss	xmm0, DWORD PTR tv445[esp+40]
	addss	xmm1, xmm2
	movaps	xmm2, xmm3
	addss	xmm2, xmm7

; 167  : 		return x*x + y*y + z*z;

	mulss	xmm0, xmm0

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	mulss	xmm2, xmm2

; 167  : 		return x*x + y*y + z*z;

	mulss	xmm1, xmm1
	addss	xmm2, xmm1
	addss	xmm2, xmm0
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\cl_intersect.h

; 597  : 		if ( kDiff.square_magnitude() <= fRSqr )

	comiss	xmm6, xmm2
	jb	SHORT $LN9@TestSphere

; 598  : 			iInside++;

	inc	eax
$LN9@TestSphere:
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	addss	xmm3, DWORD PTR tv450[esp+40]
	addss	xmm4, DWORD PTR tv448[esp+40]
	addss	xmm5, DWORD PTR tv453[esp+40]
	mulss	xmm3, xmm3

; 167  : 		return x*x + y*y + z*z;

	mulss	xmm4, xmm4
	mulss	xmm5, xmm5
	addss	xmm3, xmm4
	addss	xmm3, xmm5
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\cl_intersect.h

; 602  : 		if ( kDiff.square_magnitude() <= fRSqr )

	comiss	xmm6, xmm3
	jb	SHORT $LN10@TestSphere

; 603  : 			iInside++;

	inc	eax
$LN10@TestSphere:

; 604  : 
; 605  : 		// triangle does not traversely intersect sphere
; 606  : 		if ( iInside == 3 ) return stInside;

	cmp	eax, 3
	jne	SHORT $LN11@TestSphere

; 620  : 		Fvector e0, e1;
; 621  : 		// find vectors for two edges sharing vert0
; 622  : 		e0.sub(p[1], p[0]);
; 623  : 		e1.sub(p[2], p[0]);
; 624  : 		return TestSphereTri(sphereOrigin,sphereRadius,p[0],e0,e1);

	mov	eax, 2

; 625  : 	}

	add	esp, 40					; 00000028H
	ret	0
$LN11@TestSphere:

; 609  : 		if ( iInside > 0 ) return stIntersect;

	test	eax, eax
	jne	SHORT $LN28@TestSphere

; 610  : 
; 611  : 		// All vertices are outside the sphere, but the triangle might still
; 612  : 		// intersect the sphere.  This is the case when the distance from the
; 613  : 		// sphere center to the triangle is smaller than the radius.
; 614  : 		float fSqrDist = MgcSqrDistance(sphereOrigin,orig,e0,e1);

	lea	eax, DWORD PTR _e1$[esp+40]
	push	eax
	lea	eax, DWORD PTR _e0$[esp+44]
	push	eax
	call	?MgcSqrDistance@CDB@@YAMABU?$_vector3@M@@000@Z ; CDB::MgcSqrDistance

; 615  : 		return (fSqrDist < fRSqr)?stIntersect:stNone;

	fld	DWORD PTR _fRSqr$1[esp+44]
	add	esp, 8
	fcomip	ST(1)
	fstp	ST(0)
	jbe	SHORT $LN14@TestSphere
$LN28@TestSphere:

; 625  : 	}

	mov	eax, 1
	add	esp, 40					; 00000028H
	ret	0
$LN14@TestSphere:

; 620  : 		Fvector e0, e1;
; 621  : 		// find vectors for two edges sharing vert0
; 622  : 		e0.sub(p[1], p[0]);
; 623  : 		e1.sub(p[2], p[0]);
; 624  : 		return TestSphereTri(sphereOrigin,sphereRadius,p[0],e0,e1);

	xor	eax, eax

; 625  : 	}

	add	esp, 40					; 00000028H
	ret	0
?TestSphereTri@CDB@@YA?AW4EST_Result@1@ABU?$_vector3@M@@MPAU3@@Z ENDP ; CDB::TestSphereTri
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xrsharedmem.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xrsharedmem.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_color.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp
_TEXT	SEGMENT
_indices$ = -8						; size = 4
tv925 = -4						; size = 4
_vertices$1 = -4					; size = 4
_vertices$2 = 8						; size = 4
_V$ = 8							; size = 4
tv924 = 12						; size = 4
_idx$1$ = 12						; size = 4
_idx$1$ = 12						; size = 4
_iBase$ = 12						; size = 4
_iCount$ = 16						; size = 4
?_CollectBoneFaces@CSkeletonX_ext@@MAEXPAVFvisual@@II@Z PROC ; CSkeletonX_ext::_CollectBoneFaces
; _this$ = ecx

; 279  : {

	sub	esp, 8
	push	ebx
	push	ebp
	push	esi
	push	edi

; 280  : 	u16* indices		= 0;
; 281  : 	//.	R_CHK			(V->pIndices->Lock(iBase,iCount,(void**)&indices,D3DLOCK_READONLY));
; 282  : 	R_CHK				(V->p_rm_Indices->Lock(0,V->dwPrimitives*3,(void**)&indices,D3DLOCK_READONLY));

	mov	edi, DWORD PTR _V$[esp+20]
	lea	eax, DWORD PTR _indices$[esp+24]
	push	16					; 00000010H
	push	eax
	mov	DWORD PTR _indices$[esp+32], 0
	mov	ebp, ecx
	mov	eax, DWORD PTR [edi+100]
	mov	edx, DWORD PTR [edi+88]
	lea	eax, DWORD PTR [eax+eax*2]
	mov	esi, DWORD PTR [edx]
	push	eax
	push	0
	push	edx
	call	DWORD PTR [esi+44]
	cmp	BYTE PTR ?ignore_always@?3??_CollectBoneFaces@CSkeletonX_ext@@MAEXPAVFvisual@@II@Z@4_NA, 0
	mov	ebx, DWORD PTR __imp_?error@xrDebug@@QAEXJPBD0H0AA_N@Z
	jne	SHORT $LN2@CollectBon
	test	eax, eax
	jns	SHORT $LN2@CollectBon
	mov	ecx, DWORD PTR __imp_?Debug@@3VxrDebug@@A
	push	OFFSET ?ignore_always@?3??_CollectBoneFaces@CSkeletonX_ext@@MAEXPAVFvisual@@II@Z@4_NA
	push	OFFSET ??_C@_0CC@IECPAAEB@CSkeletonX_ext?3?3_CollectBoneFac@
	push	282					; 0000011aH
	push	OFFSET ??_C@_0DI@MPKGEPP@I?3?2Vitalya?2mine?2NSProjectX?2laye@
	push	OFFSET ??_C@_0EN@JBPJCDDE@V?9?$DOp_rm_Indices?9?$DOLock?$CI0?0V?9?$DOdwPr@
	push	eax
	call	ebx
$LN2@CollectBon:

; 283  : 	indices				+= iBase;

	mov	eax, DWORD PTR _indices$[esp+24]
	mov	ecx, DWORD PTR _iBase$[esp+20]
	lea	ecx, DWORD PTR [eax+ecx*2]

; 284  : 	switch	(RenderMode)

	movzx	eax, WORD PTR [ebp+20]
	mov	DWORD PTR _indices$[esp+24], ecx
	cmp	eax, 3
	ja	$LN29@CollectBon
	jmp	DWORD PTR $LN82@CollectBon[eax*4]
$LN35@CollectBon:
; File I:\Vitalya\mine\NSProjectX\xrCore\xrsharedmem.h

; 86   : 	T*					operator*	() const						{	return p_?(T*)p_->value:0;									}

	mov	edx, DWORD PTR [ebp+8]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp

; 288  : 			if (*Vertices1W){

	lea	eax, DWORD PTR [edx+16]
	neg	edx
	sbb	edx, edx
	and	edx, eax
	mov	DWORD PTR tv924[esp+20], edx
	je	SHORT $LN12@CollectBon

; 289  : 				vertBoned1W* vertices	= *Vertices1W;
; 290  : 				for (u32 idx=0; idx<iCount; idx++){

	xor	ebx, ebx
	cmp	DWORD PTR _iCount$[esp+20], ebx
	jbe	$LN29@CollectBon
$LL9@CollectBon:

; 291  : 					vertBoned1W& v	= vertices[V->vBase+indices[idx]];

	movzx	ecx, WORD PTR [ecx+ebx*2]
	add	ecx, DWORD PTR [edi+80]
	mov	eax, ecx
	shl	eax, 4
	sub	eax, ecx

; 292  : 					CBoneData& BD	= Parent->LL_GetData((u16)v.matrix);

	mov	ecx, DWORD PTR [ebp+4]
	movzx	eax, WORD PTR [edx+eax*4+56]
	push	eax
	call	DWORD PTR __imp_?LL_GetData@CKinematics@@QAEAAVCBoneData@@G@Z

; 293  : 					BD.AppendFace	(ChildIDX,(u16)(idx/3));

	movzx	ecx, WORD PTR [ebp+22]
	mov	esi, eax
	mov	eax, -1431655765			; aaaaaaabH
	mul	ebx
	shr	edx, 1
	push	edx
	push	ecx
	mov	ecx, esi
	call	DWORD PTR __imp_?AppendFace@CBoneData@@QAEXGG@Z
	inc	ebx
	cmp	ebx, DWORD PTR _iCount$[esp+20]
	jae	$LN29@CollectBon

; 289  : 				vertBoned1W* vertices	= *Vertices1W;
; 290  : 				for (u32 idx=0; idx<iCount; idx++){

	mov	ecx, DWORD PTR _indices$[esp+24]
	mov	edx, DWORD PTR tv924[esp+20]
	jmp	SHORT $LL9@CollectBon
$LN12@CollectBon:
; File I:\Vitalya\mine\NSProjectX\xrCore\xrsharedmem.h

; 86   : 	T*					operator*	() const						{	return p_?(T*)p_->value:0;									}

	mov	edx, DWORD PTR [ebp+12]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp

; 298  : 				for (u32 idx=0; idx<iCount; idx++){

	lea	eax, DWORD PTR [edx+16]
	neg	edx
	sbb	edx, edx
	and	edx, eax
	xor	eax, eax
	mov	DWORD PTR tv925[esp+24], edx
	mov	DWORD PTR _idx$1$[esp+20], eax
	cmp	DWORD PTR _iCount$[esp+20], eax
	jbe	$LN29@CollectBon
	npad	1
$LL15@CollectBon:

; 299  : 					vertBoned2W& v	= vertices[V->vBase+indices[idx]];

	movzx	ebx, WORD PTR [ecx+eax*2]
	add	ebx, DWORD PTR [edi+80]

; 300  : 					CBoneData& BD0	= Parent->LL_GetData((u16)v.matrix0);

	mov	ecx, DWORD PTR [ebp+4]
	shl	ebx, 6
	add	ebx, edx
	movzx	eax, WORD PTR [ebx]
	push	eax
	call	DWORD PTR __imp_?LL_GetData@CKinematics@@QAEAAVCBoneData@@G@Z

; 301  : 					BD0.AppendFace	(ChildIDX,(u16)(idx/3));

	movzx	ecx, WORD PTR [ebp+22]
	mov	esi, eax
	mov	eax, -1431655765			; aaaaaaabH
	mul	DWORD PTR _idx$1$[esp+20]
	shr	edx, 1
	movzx	edi, dx
	push	edi
	push	ecx
	mov	ecx, esi
	call	DWORD PTR __imp_?AppendFace@CBoneData@@QAEXGG@Z

; 302  : 					CBoneData& BD1	= Parent->LL_GetData((u16)v.matrix1);

	movzx	eax, WORD PTR [ebx+2]
	mov	ecx, DWORD PTR [ebp+4]
	push	eax
	call	DWORD PTR __imp_?LL_GetData@CKinematics@@QAEAAVCBoneData@@G@Z

; 303  : 					BD1.AppendFace	(ChildIDX,(u16)(idx/3));

	movzx	ecx, WORD PTR [ebp+22]
	push	edi
	push	ecx
	mov	ecx, eax
	call	DWORD PTR __imp_?AppendFace@CBoneData@@QAEXGG@Z
	mov	eax, DWORD PTR _idx$1$[esp+20]
	mov	edi, DWORD PTR _V$[esp+20]
	inc	eax
	mov	DWORD PTR _idx$1$[esp+20], eax
	cmp	eax, DWORD PTR _iCount$[esp+20]
	jae	$LN29@CollectBon

; 298  : 				for (u32 idx=0; idx<iCount; idx++){

	mov	ecx, DWORD PTR _indices$[esp+24]
	mov	edx, DWORD PTR tv925[esp+24]
	jmp	SHORT $LL15@CollectBon
$LN38@CollectBon:

; 304  : 				}
; 305  : 			}
; 306  : 		}
; 307  : 		break;
; 308  : 	case RM_SINGLE:
; 309  : 	case RM_SKINNING_1B:	
; 310  : 		{
; 311  : 			vertHW_1W* vertices	= 0;
; 312  : 			R_CHK				(V->p_rm_Vertices->Lock(V->vBase,V->vCount,(void**)&vertices,D3DLOCK_READONLY));

	mov	eax, DWORD PTR [edi+76]
	lea	edx, DWORD PTR _vertices$2[esp+20]
	push	16					; 00000010H
	push	edx
	push	DWORD PTR [edi+84]
	mov	DWORD PTR _vertices$2[esp+32], 0
	push	DWORD PTR [edi+80]
	mov	ecx, DWORD PTR [eax]
	push	eax
	call	DWORD PTR [ecx+44]
	cmp	BYTE PTR ?ignore_always@?BH@??_CollectBoneFaces@CSkeletonX_ext@@MAEXPAVFvisual@@II@Z@4_NA, 0
	jne	SHORT $LN16@CollectBon
	test	eax, eax
	jns	SHORT $LN16@CollectBon
	mov	ecx, DWORD PTR __imp_?Debug@@3VxrDebug@@A
	push	OFFSET ?ignore_always@?BH@??_CollectBoneFaces@CSkeletonX_ext@@MAEXPAVFvisual@@II@Z@4_NA
	push	OFFSET ??_C@_0CC@IECPAAEB@CSkeletonX_ext?3?3_CollectBoneFac@
	push	312					; 00000138H
	push	OFFSET ??_C@_0DI@MPKGEPP@I?3?2Vitalya?2mine?2NSProjectX?2laye@
	push	OFFSET ??_C@_0EO@GEEHLIBL@V?9?$DOp_rm_Vertices?9?$DOLock?$CIV?9?$DOvBase@
	push	eax
	call	ebx
$LN16@CollectBon:

; 313  : 			for (u32 idx=0; idx<iCount; idx++){

	xor	ebx, ebx
	cmp	DWORD PTR _iCount$[esp+20], ebx
	jbe	SHORT $LN20@CollectBon
	npad	7
$LL21@CollectBon:

; 314  : 				vertHW_1W& v	= vertices[indices[idx]];

	mov	eax, DWORD PTR _indices$[esp+24]
	movzx	eax, WORD PTR [eax+ebx*2]
	lea	ecx, DWORD PTR [eax+eax*2]
; File I:\Vitalya\mine\NSProjectX\xrCore\_color.h

; 20   : ICF	u32 color_get_A (u32 rgba)						{	return ((rgba) >> 24);			}

	mov	eax, DWORD PTR _vertices$2[esp+20]
	movzx	ecx, BYTE PTR [eax+ecx*8+11]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp

; 87   : 		return	(u16)color_get_A(_N_I)/3;

	mov	eax, -1431655765			; aaaaaaabH
	mul	ecx

; 315  : 				CBoneData& BD	= Parent->LL_GetData(v.get_bone());

	mov	ecx, DWORD PTR [ebp+4]

; 87   : 		return	(u16)color_get_A(_N_I)/3;

	shr	edx, 1
	movzx	eax, dx

; 315  : 				CBoneData& BD	= Parent->LL_GetData(v.get_bone());

	push	eax
	call	DWORD PTR __imp_?LL_GetData@CKinematics@@QAEAAVCBoneData@@G@Z

; 316  : 				BD.AppendFace	(ChildIDX,(u16)(idx/3));

	movzx	ecx, WORD PTR [ebp+22]
	mov	esi, eax
	mov	eax, -1431655765			; aaaaaaabH
	mul	ebx
	shr	edx, 1
	push	edx
	push	ecx
	mov	ecx, esi
	call	DWORD PTR __imp_?AppendFace@CBoneData@@QAEXGG@Z
	inc	ebx
	cmp	ebx, DWORD PTR _iCount$[esp+20]
	jb	SHORT $LL21@CollectBon
$LN20@CollectBon:

; 317  : 			}
; 318  : 			V->p_rm_Vertices->Unlock();

	mov	eax, DWORD PTR [edi+76]
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+48]

; 319  : 		}
; 320  : 		break;

	jmp	$LN29@CollectBon
$LN41@CollectBon:

; 321  : 	case RM_SKINNING_2B:{
; 322  : 		vertHW_2W* vertices	= 0;
; 323  : 		R_CHK				(V->p_rm_Vertices->Lock(V->vBase,V->vCount,(void**)&vertices,D3DLOCK_READONLY));

	mov	eax, DWORD PTR [edi+76]
	lea	edx, DWORD PTR _vertices$1[esp+24]
	push	16					; 00000010H
	push	edx
	push	DWORD PTR [edi+84]
	mov	DWORD PTR _vertices$1[esp+36], 0
	push	DWORD PTR [edi+80]
	mov	ecx, DWORD PTR [eax]
	push	eax
	call	DWORD PTR [ecx+44]
	cmp	BYTE PTR ?ignore_always@?BO@??_CollectBoneFaces@CSkeletonX_ext@@MAEXPAVFvisual@@II@Z@4_NA, 0
	jne	SHORT $LN22@CollectBon
	test	eax, eax
	jns	SHORT $LN22@CollectBon
	mov	ecx, DWORD PTR __imp_?Debug@@3VxrDebug@@A
	push	OFFSET ?ignore_always@?BO@??_CollectBoneFaces@CSkeletonX_ext@@MAEXPAVFvisual@@II@Z@4_NA
	push	OFFSET ??_C@_0CC@IECPAAEB@CSkeletonX_ext?3?3_CollectBoneFac@
	push	323					; 00000143H
	push	OFFSET ??_C@_0DI@MPKGEPP@I?3?2Vitalya?2mine?2NSProjectX?2laye@
	push	OFFSET ??_C@_0EO@GEEHLIBL@V?9?$DOp_rm_Vertices?9?$DOLock?$CIV?9?$DOvBase@
	push	eax
	call	ebx
$LN22@CollectBon:

; 324  : 		for (u32 idx=0; idx<iCount; idx++){

	xor	ecx, ecx
	mov	DWORD PTR _idx$1$[esp+20], ecx
	cmp	DWORD PTR _iCount$[esp+20], ecx
	jbe	$LN30@CollectBon
	npad	11
$LL27@CollectBon:

; 325  : 			vertHW_2W& v	= vertices[indices[idx]];

	mov	eax, DWORD PTR _indices$[esp+24]
	movzx	eax, WORD PTR [eax+ecx*2]
	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax
	mov	eax, DWORD PTR _vertices$1[esp+24]
	lea	ebx, DWORD PTR [eax+ecx*4]

; 136  : 		return	(u16)_tc_i[w+2]/3;

	mov	eax, -1431655765			; aaaaaaabH
	movzx	ecx, WORD PTR [ebx+24]
	mul	ecx

; 326  : 			CBoneData& BD0	= Parent->LL_GetData(v.get_bone(0));

	mov	ecx, DWORD PTR [ebp+4]

; 136  : 		return	(u16)_tc_i[w+2]/3;

	shr	edx, 1
	movzx	eax, dx

; 326  : 			CBoneData& BD0	= Parent->LL_GetData(v.get_bone(0));

	push	eax
	call	DWORD PTR __imp_?LL_GetData@CKinematics@@QAEAAVCBoneData@@G@Z

; 327  : 			BD0.AppendFace	(ChildIDX,(u16)(idx/3));

	movzx	ecx, WORD PTR [ebp+22]
	mov	esi, eax
	mov	eax, -1431655765			; aaaaaaabH
	mul	DWORD PTR _idx$1$[esp+20]
	shr	edx, 1
	movzx	edi, dx
	push	edi
	push	ecx
	mov	ecx, esi
	call	DWORD PTR __imp_?AppendFace@CBoneData@@QAEXGG@Z

; 136  : 		return	(u16)_tc_i[w+2]/3;

	movzx	ecx, WORD PTR [ebx+26]
	mov	eax, -1431655765			; aaaaaaabH
	mul	ecx

; 328  : 			CBoneData& BD1	= Parent->LL_GetData(v.get_bone(1));

	mov	ecx, DWORD PTR [ebp+4]

; 136  : 		return	(u16)_tc_i[w+2]/3;

	shr	edx, 1
	movzx	eax, dx

; 328  : 			CBoneData& BD1	= Parent->LL_GetData(v.get_bone(1));

	push	eax
	call	DWORD PTR __imp_?LL_GetData@CKinematics@@QAEAAVCBoneData@@G@Z

; 329  : 			BD1.AppendFace	(ChildIDX,(u16)(idx/3));

	movzx	ecx, WORD PTR [ebp+22]
	push	edi
	push	ecx
	mov	ecx, eax
	call	DWORD PTR __imp_?AppendFace@CBoneData@@QAEXGG@Z
	mov	ecx, DWORD PTR _idx$1$[esp+20]
	inc	ecx
	mov	DWORD PTR _idx$1$[esp+20], ecx
	cmp	ecx, DWORD PTR _iCount$[esp+20]
	jb	$LL27@CollectBon
	mov	edi, DWORD PTR _V$[esp+20]
	mov	ebx, DWORD PTR __imp_?error@xrDebug@@QAEXJPBD0H0AA_N@Z
$LN30@CollectBon:

; 330  : 		}
; 331  : 		R_CHK				(V->p_rm_Vertices->Unlock());

	mov	eax, DWORD PTR [edi+76]
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+48]
	cmp	BYTE PTR ?ignore_always@?CE@??_CollectBoneFaces@CSkeletonX_ext@@MAEXPAVFvisual@@II@Z@4_NA, 0
	jne	SHORT $LN29@CollectBon
	test	eax, eax
	jns	SHORT $LN29@CollectBon
	mov	ecx, DWORD PTR __imp_?Debug@@3VxrDebug@@A
	push	OFFSET ?ignore_always@?CE@??_CollectBoneFaces@CSkeletonX_ext@@MAEXPAVFvisual@@II@Z@4_NA
	push	OFFSET ??_C@_0CC@IECPAAEB@CSkeletonX_ext?3?3_CollectBoneFac@
	push	331					; 0000014bH
	push	OFFSET ??_C@_0DI@MPKGEPP@I?3?2Vitalya?2mine?2NSProjectX?2laye@
	push	OFFSET ??_C@_0BL@KDGOOFMF@V?9?$DOp_rm_Vertices?9?$DOUnlock?$CI?$CJ@
	push	eax
	call	ebx
$LN29@CollectBon:

; 332  : 						}break;
; 333  : 	}
; 334  : 	R_CHK					(V->p_rm_Indices->Unlock());

	mov	eax, DWORD PTR [edi+88]
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+48]
	cmp	BYTE PTR ?ignore_always@?CI@??_CollectBoneFaces@CSkeletonX_ext@@MAEXPAVFvisual@@II@Z@4_NA, 0
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	jne	SHORT $LN31@CollectBon
	test	eax, eax
	jns	SHORT $LN31@CollectBon
	mov	ecx, DWORD PTR __imp_?Debug@@3VxrDebug@@A
	push	OFFSET ?ignore_always@?CI@??_CollectBoneFaces@CSkeletonX_ext@@MAEXPAVFvisual@@II@Z@4_NA
	push	OFFSET ??_C@_0CC@IECPAAEB@CSkeletonX_ext?3?3_CollectBoneFac@
	push	334					; 0000014eH
	push	OFFSET ??_C@_0DI@MPKGEPP@I?3?2Vitalya?2mine?2NSProjectX?2laye@
	push	OFFSET ??_C@_0BK@PLGEAKCN@V?9?$DOp_rm_Indices?9?$DOUnlock?$CI?$CJ@
	push	eax
	call	DWORD PTR __imp_?error@xrDebug@@QAEXJPBD0H0AA_N@Z
$LN31@CollectBon:

; 335  : }

	add	esp, 8
	ret	12					; 0000000cH
	npad	1
$LN82@CollectBon:
	DD	$LN35@CollectBon
	DD	$LN38@CollectBon
	DD	$LN38@CollectBon
	DD	$LN41@CollectBon
?_CollectBoneFaces@CSkeletonX_ext@@MAEXPAVFvisual@@II@Z ENDP ; CSkeletonX_ext::_CollectBoneFaces
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp
_TEXT	SEGMENT
_parent$ = 8						; size = 4
_child_idx$ = 12					; size = 2
?AfterLoad@CSkeletonX_ST@@UAEXPAVCKinematics@@G@Z PROC	; CSkeletonX_ST::AfterLoad
; _this$ = ecx

; 338  : {

	push	esi

; 339  : 	inherited2::AfterLoad			(parent,child_idx);

	push	DWORD PTR _child_idx$[esp]
	mov	esi, ecx
	push	DWORD PTR _parent$[esp+4]
	call	DWORD PTR __imp_?AfterLoad@CSkeletonX@@UAEXPAVCKinematics@@G@Z

; 340  : 	inherited2::_CollectBoneFaces	(this,iBase,iCount);

	push	DWORD PTR [esi-12]
	lea	eax, DWORD PTR [esi-108]
	mov	ecx, esi
	push	DWORD PTR [esi-16]
	push	eax
	call	?_CollectBoneFaces@CSkeletonX_ext@@MAEXPAVFvisual@@II@Z ; CSkeletonX_ext::_CollectBoneFaces
	pop	esi

; 341  : }

	ret	8
?AfterLoad@CSkeletonX_ST@@UAEXPAVCKinematics@@G@Z ENDP	; CSkeletonX_ST::AfterLoad
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp
_TEXT	SEGMENT
_parent$ = 8						; size = 4
_child_idx$ = 12					; size = 2
?AfterLoad@CSkeletonX_PM@@UAEXPAVCKinematics@@G@Z PROC	; CSkeletonX_PM::AfterLoad
; _this$ = ecx

; 344  : {

	push	esi

; 345  : 	inherited2::AfterLoad			(parent,child_idx);

	push	DWORD PTR _child_idx$[esp]
	mov	esi, ecx
	push	DWORD PTR _parent$[esp+4]
	call	DWORD PTR __imp_?AfterLoad@CSkeletonX@@UAEXPAVCKinematics@@G@Z

; 346  : 	FSlideWindow& SW				= nSWI.sw[0]; // max LOD

	mov	edx, DWORD PTR [esi-32]

; 347  : 	inherited2::_CollectBoneFaces	(this,iBase+SW.offset,SW.num_tris*3);

	mov	ecx, esi
	movzx	eax, WORD PTR [edx+4]
	lea	eax, DWORD PTR [eax+eax*2]
	push	eax
	mov	eax, DWORD PTR [esi-48]
	add	eax, DWORD PTR [edx]
	push	eax
	lea	eax, DWORD PTR [esi-140]
	push	eax
	call	?_CollectBoneFaces@CSkeletonX_ext@@MAEXPAVFvisual@@II@Z ; CSkeletonX_ext::_CollectBoneFaces
	pop	esi

; 348  : }

	ret	8
?AfterLoad@CSkeletonX_PM@@UAEXPAVCKinematics@@G@Z ENDP	; CSkeletonX_PM::AfterLoad
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_color.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp
; File I:\Vitalya\mine\NSProjectX\xrEngine\SkeletonCustom.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp
; File I:\Vitalya\mine\NSProjectX\xrEngine\SkeletonCustom.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_color.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_color.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp
; File I:\Vitalya\mine\NSProjectX\xrEngine\SkeletonCustom.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp
; File I:\Vitalya\mine\NSProjectX\xrEngine\SkeletonCustom.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_color.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_color.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp
; File I:\Vitalya\mine\NSProjectX\xrEngine\SkeletonCustom.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp
; File I:\Vitalya\mine\NSProjectX\xrEngine\SkeletonCustom.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\cl_intersect.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\cl_intersect.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\cl_intersect.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\cl_intersect.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\cl_intersect.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp
_TEXT	SEGMENT
_intersect$1$ = -81					; size = 1
_vertices$ = -80					; size = 4
tv2273 = -76						; size = 4
tv2249 = -72						; size = 4
tv2248 = -68						; size = 4
tv2239 = -64						; size = 4
tv2240 = -60						; size = 4
tv2256 = -56						; size = 4
tv2253 = -52						; size = 4
tv2242 = -48						; size = 4
tv2243 = -44						; size = 4
tv2244 = -40						; size = 4
tv2241 = -36						; size = 4
tv2258 = -32						; size = 4
tv2259 = -28						; size = 4
tv2190 = -24						; size = 4
tv2191 = -20						; size = 4
_det$1$ = -16						; size = 4
tv2208 = -12						; size = 4
tv2205 = -8						; size = 4
$T1 = -4						; size = 4
tv2251 = 8						; size = 4
_normal$ = 8						; size = 4
_dist$ = 12						; size = 4
tv2252 = 16						; size = 4
_S$ = 16						; size = 4
_D$ = 20						; size = 4
_V$ = 24						; size = 4
_indices$ = 28						; size = 4
tv2250 = 32						; size = 4
_faces$ = 32						; size = 4
?_PickBoneHW1W@CSkeletonX_ext@@MAEHAAU?$_vector3@M@@AAMABU2@2PAVFvisual@@PAGAAV?$xr_vector@GV?$xalloc@G@@@@@Z PROC ; CSkeletonX_ext::_PickBoneHW1W
; _this$ = ecx

; 351  : {

	sub	esp, 84					; 00000054H
	push	ebx
	push	esi
	push	edi
	mov	esi, ecx

; 353  : 	CHK_DX				(V->p_rm_Vertices->Lock(V->vBase,V->vCount,(void**)&vertices,D3DLOCK_READONLY));

	lea	edi, DWORD PTR _vertices$[esp+96]
	mov	ecx, DWORD PTR _V$[esp+92]
	push	16					; 00000010H
	push	edi
	mov	eax, DWORD PTR [ecx+76]
	push	DWORD PTR [ecx+84]
	push	DWORD PTR [ecx+80]
	mov	edx, DWORD PTR [eax]
	push	eax
	call	DWORD PTR [edx+44]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 150  :         return _Ptr == _Right._Ptr;

	mov	ecx, DWORD PTR _faces$[esp+92]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp

; 354  : 	bool intersect		= FALSE;

	xor	bl, bl
	mov	BYTE PTR _intersect$1$[esp+96], bl
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 150  :         return _Ptr == _Right._Ptr;

	mov	eax, DWORD PTR [ecx+4]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp

; 353  : 	CHK_DX				(V->p_rm_Vertices->Lock(V->vBase,V->vCount,(void**)&vertices,D3DLOCK_READONLY));

	mov	ecx, DWORD PTR [ecx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 150  :         return _Ptr == _Right._Ptr;

	mov	DWORD PTR $T1[esp+96], eax
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp

; 355  : 	for (CBoneData::FacesVecIt it=faces.begin(); it!=faces.end(); it++){

	cmp	ecx, eax
	je	$LN3@PickBoneHW
	mov	eax, DWORD PTR [esi+4]
	mov	ebx, DWORD PTR _normal$[esp+92]
	movss	xmm5, DWORD PTR __real@39c00180
	push	ebp
	mov	eax, DWORD PTR [eax+120]
	mov	ebp, DWORD PTR _S$[esp+96]
	mov	DWORD PTR tv2273[esp+100], eax
	npad	8
$LL4@PickBoneHW:

; 356  : 		Fvector			p[3];
; 357  : 		u32 idx			= (*it)*3;

	movzx	eax, WORD PTR [ecx]
	lea	edi, DWORD PTR [eax+eax*2]

; 359  : 			vertHW_1W& vert			= vertices[indices[idx+k]];

	mov	eax, DWORD PTR _indices$[esp+96]
	movzx	eax, WORD PTR [eax+edi*2]
	lea	esi, DWORD PTR [eax+eax*2]
; File I:\Vitalya\mine\NSProjectX\xrCore\_color.h

; 20   : ICF	u32 color_get_A (u32 rgba)						{	return ((rgba) >> 24);			}

	mov	eax, DWORD PTR _vertices$[esp+100]
	movzx	edx, BYTE PTR [eax+esi*8+11]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp

; 87   : 		return	(u16)color_get_A(_N_I)/3;

	mov	eax, -1431655765			; aaaaaaabH
	mul	edx
	shr	edx, 1
; File I:\Vitalya\mine\NSProjectX\xrEngine\SkeletonCustom.h

; 243  : 	ICF CBoneInstance& LL_GetBoneInstance(u16 bone_id) { VERIFY(bone_id < LL_BoneCount()); VERIFY(bone_instances); return bone_instances[bone_id]; }

	movzx	eax, dx
	lea	edx, DWORD PTR [eax+eax*4]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp

; 25   : 	return	float(v)/(32767.f/12.f);

	mov	eax, DWORD PTR _vertices$[esp+100]
; File I:\Vitalya\mine\NSProjectX\xrEngine\SkeletonCustom.h

; 243  : 	ICF CBoneInstance& LL_GetBoneInstance(u16 bone_id) { VERIFY(bone_id < LL_BoneCount()); VERIFY(bone_instances); return bone_instances[bone_id]; }

	shl	edx, 5
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp

; 25   : 	return	float(v)/(32767.f/12.f);

	movsx	eax, WORD PTR [eax+esi*8]
	cvtsi2ss xmm2, eax
	mov	eax, DWORD PTR _vertices$[esp+100]
	movsx	eax, WORD PTR [eax+esi*8+2]
	mulss	xmm2, xmm5
	cvtsi2ss xmm6, eax
	mov	eax, DWORD PTR _vertices$[esp+100]
	movsx	eax, WORD PTR [eax+esi*8+4]
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 499  : 		dest.x = v.x*_11 + v.y*_21 + v.z*_31 + _41;

	movaps	xmm0, xmm2
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp

; 25   : 	return	float(v)/(32767.f/12.f);

	mulss	xmm6, xmm5
	cvtsi2ss xmm1, eax
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 499  : 		dest.x = v.x*_11 + v.y*_21 + v.z*_31 + _41;

	mov	eax, DWORD PTR tv2273[esp+100]
	mulss	xmm0, DWORD PTR [edx+eax+64]
	movaps	xmm7, xmm6
	mulss	xmm7, DWORD PTR [edx+eax+80]

; 500  : 		dest.y = v.x*_12 + v.y*_22 + v.z*_32 + _42;

	movaps	xmm3, xmm6
	mulss	xmm3, DWORD PTR [edx+eax+84]

; 501  : 		dest.z = v.x*_13 + v.y*_23 + v.z*_33 + _43;

	mulss	xmm6, DWORD PTR [edx+eax+88]
	addss	xmm7, xmm0
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp

; 25   : 	return	float(v)/(32767.f/12.f);

	mulss	xmm1, xmm5
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 499  : 		dest.x = v.x*_11 + v.y*_21 + v.z*_31 + _41;

	movaps	xmm0, xmm1
	mulss	xmm0, DWORD PTR [edx+eax+96]
	addss	xmm0, DWORD PTR [edx+eax+112]
	addss	xmm7, xmm0

; 500  : 		dest.y = v.x*_12 + v.y*_22 + v.z*_32 + _42;

	movaps	xmm0, xmm2
	mulss	xmm0, DWORD PTR [edx+eax+68]

; 501  : 		dest.z = v.x*_13 + v.y*_23 + v.z*_33 + _43;

	mulss	xmm2, DWORD PTR [edx+eax+72]
	addss	xmm3, xmm0
	movss	DWORD PTR tv2239[esp+100], xmm7
	movaps	xmm0, xmm1
	mulss	xmm1, DWORD PTR [edx+eax+104]
	mulss	xmm0, DWORD PTR [edx+eax+100]
	addss	xmm6, xmm2
	addss	xmm1, DWORD PTR [edx+eax+120]
	addss	xmm0, DWORD PTR [edx+eax+116]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp

; 359  : 			vertHW_1W& vert			= vertices[indices[idx+k]];

	mov	eax, DWORD PTR _indices$[esp+96]
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 501  : 		dest.z = v.x*_13 + v.y*_23 + v.z*_33 + _43;

	addss	xmm6, xmm1
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp

; 359  : 			vertHW_1W& vert			= vertices[indices[idx+k]];

	movzx	eax, WORD PTR [eax+edi*2+2]
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 500  : 		dest.y = v.x*_12 + v.y*_22 + v.z*_32 + _42;

	addss	xmm3, xmm0

; 501  : 		dest.z = v.x*_13 + v.y*_23 + v.z*_33 + _43;

	movss	DWORD PTR tv2241[esp+100], xmm6
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp

; 359  : 			vertHW_1W& vert			= vertices[indices[idx+k]];

	lea	esi, DWORD PTR [eax+eax*2]
; File I:\Vitalya\mine\NSProjectX\xrCore\_color.h

; 20   : ICF	u32 color_get_A (u32 rgba)						{	return ((rgba) >> 24);			}

	mov	eax, DWORD PTR _vertices$[esp+100]
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 500  : 		dest.y = v.x*_12 + v.y*_22 + v.z*_32 + _42;

	movss	DWORD PTR tv2240[esp+100], xmm3
; File I:\Vitalya\mine\NSProjectX\xrCore\_color.h

; 20   : ICF	u32 color_get_A (u32 rgba)						{	return ((rgba) >> 24);			}

	movzx	edx, BYTE PTR [eax+esi*8+11]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp

; 87   : 		return	(u16)color_get_A(_N_I)/3;

	mov	eax, -1431655765			; aaaaaaabH
	mul	edx
	shr	edx, 1
; File I:\Vitalya\mine\NSProjectX\xrEngine\SkeletonCustom.h

; 243  : 	ICF CBoneInstance& LL_GetBoneInstance(u16 bone_id) { VERIFY(bone_id < LL_BoneCount()); VERIFY(bone_instances); return bone_instances[bone_id]; }

	movzx	eax, dx
	lea	edx, DWORD PTR [eax+eax*4]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp

; 25   : 	return	float(v)/(32767.f/12.f);

	mov	eax, DWORD PTR _vertices$[esp+100]
; File I:\Vitalya\mine\NSProjectX\xrEngine\SkeletonCustom.h

; 243  : 	ICF CBoneInstance& LL_GetBoneInstance(u16 bone_id) { VERIFY(bone_id < LL_BoneCount()); VERIFY(bone_instances); return bone_instances[bone_id]; }

	shl	edx, 5
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp

; 25   : 	return	float(v)/(32767.f/12.f);

	movsx	eax, WORD PTR [eax+esi*8]
	cvtsi2ss xmm2, eax
	mov	eax, DWORD PTR _vertices$[esp+100]
	movsx	eax, WORD PTR [eax+esi*8+2]
	mulss	xmm2, xmm5
	cvtsi2ss xmm3, eax
	mov	eax, DWORD PTR _vertices$[esp+100]
	movsx	eax, WORD PTR [eax+esi*8+4]
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 499  : 		dest.x = v.x*_11 + v.y*_21 + v.z*_31 + _41;

	movaps	xmm0, xmm2
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp

; 25   : 	return	float(v)/(32767.f/12.f);

	mulss	xmm3, xmm5
	cvtsi2ss xmm1, eax
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 499  : 		dest.x = v.x*_11 + v.y*_21 + v.z*_31 + _41;

	mov	eax, DWORD PTR tv2273[esp+100]
	mulss	xmm0, DWORD PTR [edx+eax+64]
	movaps	xmm4, xmm3
	mulss	xmm4, DWORD PTR [edx+eax+80]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp

; 25   : 	return	float(v)/(32767.f/12.f);

	mulss	xmm1, xmm5
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 499  : 		dest.x = v.x*_11 + v.y*_21 + v.z*_31 + _41;

	addss	xmm4, xmm0
	movaps	xmm0, xmm1
	mulss	xmm0, DWORD PTR [edx+eax+96]
	addss	xmm0, DWORD PTR [edx+eax+112]
	addss	xmm4, xmm0

; 500  : 		dest.y = v.x*_12 + v.y*_22 + v.z*_32 + _42;

	movaps	xmm0, xmm2
	mulss	xmm0, DWORD PTR [edx+eax+68]

; 501  : 		dest.z = v.x*_13 + v.y*_23 + v.z*_33 + _43;

	mulss	xmm2, DWORD PTR [edx+eax+72]
	movss	DWORD PTR tv2242[esp+100], xmm4
	movaps	xmm4, xmm3
	mulss	xmm4, DWORD PTR [edx+eax+84]
	mulss	xmm3, DWORD PTR [edx+eax+88]
	addss	xmm4, xmm0
	movaps	xmm0, xmm1
	mulss	xmm0, DWORD PTR [edx+eax+100]
	mulss	xmm1, DWORD PTR [edx+eax+104]
	addss	xmm3, xmm2
	addss	xmm0, DWORD PTR [edx+eax+116]
	addss	xmm1, DWORD PTR [edx+eax+120]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp

; 359  : 			vertHW_1W& vert			= vertices[indices[idx+k]];

	mov	eax, DWORD PTR _indices$[esp+96]
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 500  : 		dest.y = v.x*_12 + v.y*_22 + v.z*_32 + _42;

	addss	xmm4, xmm0
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp

; 359  : 			vertHW_1W& vert			= vertices[indices[idx+k]];

	movzx	eax, WORD PTR [eax+edi*2+4]
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 501  : 		dest.z = v.x*_13 + v.y*_23 + v.z*_33 + _43;

	addss	xmm3, xmm1
; File I:\Vitalya\mine\NSProjectX\xrCore\_color.h

; 20   : ICF	u32 color_get_A (u32 rgba)						{	return ((rgba) >> 24);			}

	mov	edi, DWORD PTR _vertices$[esp+100]
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 500  : 		dest.y = v.x*_12 + v.y*_22 + v.z*_32 + _42;

	movss	DWORD PTR tv2243[esp+100], xmm4
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp

; 359  : 			vertHW_1W& vert			= vertices[indices[idx+k]];

	lea	esi, DWORD PTR [eax+eax*2]

; 87   : 		return	(u16)color_get_A(_N_I)/3;

	mov	eax, -1431655765			; aaaaaaabH
; File I:\Vitalya\mine\NSProjectX\xrCore\_color.h

; 20   : ICF	u32 color_get_A (u32 rgba)						{	return ((rgba) >> 24);			}

	movzx	edx, BYTE PTR [edi+esi*8+11]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp

; 87   : 		return	(u16)color_get_A(_N_I)/3;

	mul	edx
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 501  : 		dest.z = v.x*_13 + v.y*_23 + v.z*_33 + _43;

	movss	DWORD PTR tv2244[esp+100], xmm3
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp

; 87   : 		return	(u16)color_get_A(_N_I)/3;

	shr	edx, 1
; File I:\Vitalya\mine\NSProjectX\xrEngine\SkeletonCustom.h

; 243  : 	ICF CBoneInstance& LL_GetBoneInstance(u16 bone_id) { VERIFY(bone_id < LL_BoneCount()); VERIFY(bone_instances); return bone_instances[bone_id]; }

	movzx	eax, dx
	lea	edx, DWORD PTR [eax+eax*4]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp

; 25   : 	return	float(v)/(32767.f/12.f);

	movsx	eax, WORD PTR [edi+esi*8]
; File I:\Vitalya\mine\NSProjectX\xrEngine\SkeletonCustom.h

; 243  : 	ICF CBoneInstance& LL_GetBoneInstance(u16 bone_id) { VERIFY(bone_id < LL_BoneCount()); VERIFY(bone_instances); return bone_instances[bone_id]; }

	shl	edx, 5
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp

; 25   : 	return	float(v)/(32767.f/12.f);

	cvtsi2ss xmm2, eax
	movsx	eax, WORD PTR [edi+esi*8+2]
	cvtsi2ss xmm4, eax
	movsx	eax, WORD PTR [edi+esi*8+4]
	mulss	xmm2, xmm5
	mulss	xmm4, xmm5
	cvtsi2ss xmm1, eax
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 499  : 		dest.x = v.x*_11 + v.y*_21 + v.z*_31 + _41;

	mov	eax, DWORD PTR tv2273[esp+100]
	movaps	xmm0, xmm2

; 500  : 		dest.y = v.x*_12 + v.y*_22 + v.z*_32 + _42;

	movaps	xmm3, xmm4
	mulss	xmm0, DWORD PTR [edx+eax+64]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp

; 25   : 	return	float(v)/(32767.f/12.f);

	mulss	xmm1, xmm5
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 499  : 		dest.x = v.x*_11 + v.y*_21 + v.z*_31 + _41;

	movaps	xmm5, xmm4
	mulss	xmm5, DWORD PTR [edx+eax+80]

; 500  : 		dest.y = v.x*_12 + v.y*_22 + v.z*_32 + _42;

	mulss	xmm3, DWORD PTR [edx+eax+84]
	addss	xmm5, xmm0

; 501  : 		dest.z = v.x*_13 + v.y*_23 + v.z*_33 + _43;

	mulss	xmm4, DWORD PTR [edx+eax+88]
	movaps	xmm0, xmm1
	mulss	xmm0, DWORD PTR [edx+eax+96]
	addss	xmm0, DWORD PTR [edx+eax+112]
	addss	xmm5, xmm0
	movaps	xmm0, xmm2
	mulss	xmm0, DWORD PTR [edx+eax+68]
	mulss	xmm2, DWORD PTR [edx+eax+72]
	addss	xmm3, xmm0
	movss	DWORD PTR tv2208[esp+100], xmm5
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	subss	xmm5, DWORD PTR tv2239[esp+100]
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 500  : 		dest.y = v.x*_12 + v.y*_22 + v.z*_32 + _42;

	movaps	xmm0, xmm1

; 501  : 		dest.z = v.x*_13 + v.y*_23 + v.z*_33 + _43;

	addss	xmm4, xmm2
	mulss	xmm1, DWORD PTR [edx+eax+104]
	mulss	xmm0, DWORD PTR [edx+eax+100]
	addss	xmm1, DWORD PTR [edx+eax+120]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	xmm2, DWORD PTR tv2243[esp+100]
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 500  : 		dest.y = v.x*_12 + v.y*_22 + v.z*_32 + _42;

	addss	xmm0, DWORD PTR [edx+eax+116]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	subss	xmm2, DWORD PTR tv2240[esp+100]
	movss	DWORD PTR tv2251[esp+96], xmm5
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 501  : 		dest.z = v.x*_13 + v.y*_23 + v.z*_33 + _43;

	addss	xmm4, xmm1
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 24   : 	ICF SelfRef	set(const _vector3<float> &v)			{ x = T(v.x);	y = T(v.y);	z = T(v.z);	return *this;	};

	movss	xmm1, DWORD PTR tv2242[esp+100]
	subss	xmm1, xmm7

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	xmm7, DWORD PTR tv2244[esp+100]
	subss	xmm7, xmm6
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 500  : 		dest.y = v.x*_12 + v.y*_22 + v.z*_32 + _42;

	addss	xmm3, xmm0
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	DWORD PTR tv2249[esp+100], xmm2
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 501  : 		dest.z = v.x*_13 + v.y*_23 + v.z*_33 + _43;

	movss	DWORD PTR tv2205[esp+100], xmm4
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 24   : 	ICF SelfRef	set(const _vector3<float> &v)			{ x = T(v.x);	y = T(v.y);	z = T(v.z);	return *this;	};

	movss	DWORD PTR tv2248[esp+100], xmm1

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	DWORD PTR tv2250[esp+96], xmm7

; 273  : 		x = v1.y  * v2.z  - v1.z  * v2.y ;

	mov	eax, DWORD PTR _D$[esp+96]

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movaps	xmm0, xmm4
	subss	xmm0, xmm6
	movaps	xmm5, xmm3
	subss	xmm5, DWORD PTR tv2240[esp+100]

; 273  : 		x = v1.y  * v2.z  - v1.z  * v2.y ;

	movss	xmm6, DWORD PTR [eax+4]
	movaps	xmm4, xmm6
	mulss	xmm4, xmm0

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	DWORD PTR tv2253[esp+100], xmm0
	movss	DWORD PTR tv2252[esp+96], xmm5

; 273  : 		x = v1.y  * v2.z  - v1.z  * v2.y ;

	movss	xmm5, DWORD PTR [eax+8]
	movaps	xmm0, xmm5

; 274  : 		y = v1.z  * v2.x  - v1.x  * v2.z ;

	mulss	xmm5, DWORD PTR tv2251[esp+96]
	mulss	xmm0, DWORD PTR tv2252[esp+96]
	subss	xmm4, xmm0
	movss	DWORD PTR tv2256[esp+100], xmm4
	movss	xmm4, DWORD PTR [eax]
	movaps	xmm0, xmm4

; 275  : 		z = v1.x  * v2.y  - v1.y  * v2.x ;

	mulss	xmm4, DWORD PTR tv2252[esp+96]
	mulss	xmm0, DWORD PTR tv2253[esp+100]
	subss	xmm5, xmm0
	movaps	xmm0, xmm6
	mulss	xmm0, DWORD PTR tv2251[esp+96]
	subss	xmm4, xmm0
	movss	DWORD PTR tv2258[esp+100], xmm5

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	movss	xmm0, DWORD PTR tv2256[esp+100]
	mulss	xmm0, xmm1

; 275  : 		z = v1.x  * v2.y  - v1.y  * v2.x ;

	mulss	xmm5, xmm2
	movss	DWORD PTR tv2259[esp+100], xmm4

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	addss	xmm5, xmm0
	movaps	xmm0, xmm4
	mulss	xmm0, xmm7
	addss	xmm5, xmm0
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\cl_intersect.h

; 79   : 			if (det < EPS)  return false;

	movss	xmm0, DWORD PTR __real@3727c5ac
	comiss	xmm0, xmm5
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	movss	DWORD PTR _det$1$[esp+100], xmm5
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\cl_intersect.h

; 79   : 			if (det < EPS)  return false;

	ja	$LN2@PickBoneHW
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	xmm2, DWORD PTR [ebp]
	movss	xmm7, DWORD PTR [ebp+4]
	subss	xmm2, DWORD PTR tv2239[esp+100]
	subss	xmm7, DWORD PTR tv2240[esp+100]
	movss	xmm1, DWORD PTR [ebp+8]
	subss	xmm1, DWORD PTR tv2241[esp+100]

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	movaps	xmm4, xmm2
	mulss	xmm4, DWORD PTR tv2256[esp+100]

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movaps	xmm0, xmm7
	mulss	xmm0, DWORD PTR tv2258[esp+100]

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	addss	xmm4, xmm0
	movaps	xmm0, xmm1
	mulss	xmm0, DWORD PTR tv2259[esp+100]
	addss	xmm4, xmm0
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\cl_intersect.h

; 82   : 			if (u < 0.0f || u > det) return false;

	xorps	xmm0, xmm0
	comiss	xmm0, xmm4
	ja	$LN2@PickBoneHW
	comiss	xmm4, xmm5
	ja	$LN2@PickBoneHW
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 273  : 		x = v1.y  * v2.z  - v1.z  * v2.y ;

	movaps	xmm0, xmm1
	movaps	xmm5, xmm7
	mulss	xmm0, DWORD PTR tv2249[esp+100]
	mulss	xmm5, DWORD PTR tv2250[esp+96]
	mulss	xmm1, DWORD PTR tv2248[esp+100]

; 275  : 		z = v1.x  * v2.y  - v1.y  * v2.x ;

	mulss	xmm7, DWORD PTR tv2248[esp+100]
	subss	xmm5, xmm0
	movaps	xmm0, xmm2
	mulss	xmm2, DWORD PTR tv2249[esp+100]
	mulss	xmm0, DWORD PTR tv2250[esp+96]
	subss	xmm2, xmm7
	subss	xmm1, xmm0

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	movss	xmm0, DWORD PTR [eax]
	mulss	xmm0, xmm5
	mulss	xmm6, xmm1
	addss	xmm6, xmm0
	movss	xmm0, DWORD PTR [eax+8]
	mulss	xmm0, xmm2
	addss	xmm6, xmm0
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\cl_intersect.h

; 85   : 			if (v < 0.0f || u + v > det) return false;

	xorps	xmm0, xmm0
	comiss	xmm0, xmm6
	ja	$LN2@PickBoneHW
	movss	xmm0, DWORD PTR _det$1$[esp+100]
	addss	xmm4, xmm6
	comiss	xmm4, xmm0
	ja	$LN2@PickBoneHW
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	mulss	xmm1, DWORD PTR tv2252[esp+96]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp

; 364  : 		if (CDB::TestRayTri(S,D,p,u,v,range,true)&&(range<dist)){

	mov	eax, DWORD PTR _dist$[esp+96]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	mulss	xmm5, DWORD PTR tv2251[esp+96]
	mulss	xmm2, DWORD PTR tv2253[esp+100]
	addss	xmm1, xmm5
	addss	xmm1, xmm2
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\cl_intersect.h

; 88   : 			range *= inv_det;

	divss	xmm1, xmm0
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp

; 364  : 		if (CDB::TestRayTri(S,D,p,u,v,range,true)&&(range<dist)){

	movss	xmm0, DWORD PTR [eax]
	comiss	xmm0, xmm1
	jbe	$LN2@PickBoneHW
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	xmm5, DWORD PTR tv2205[esp+100]
	subss	xmm5, DWORD PTR tv2244[esp+100]
	movss	xmm6, DWORD PTR tv2208[esp+100]
	subss	xmm3, DWORD PTR tv2243[esp+100]
	subss	xmm6, DWORD PTR tv2242[esp+100]
	movaps	xmm2, xmm5

; 274  : 		y = v1.z  * v2.x  - v1.x  * v2.z ;

	mulss	xmm5, DWORD PTR tv2248[esp+100]

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	mulss	xmm2, DWORD PTR tv2249[esp+100]

; 273  : 		x = v1.y  * v2.z  - v1.z  * v2.y ;

	movaps	xmm0, xmm3
	mulss	xmm0, DWORD PTR tv2250[esp+96]
	movaps	xmm4, xmm6
	mulss	xmm4, DWORD PTR tv2250[esp+96]

; 274  : 		y = v1.z  * v2.x  - v1.x  * v2.z ;

	mulss	xmm3, DWORD PTR tv2248[esp+100]
	subss	xmm2, xmm0

; 275  : 		z = v1.x  * v2.y  - v1.y  * v2.x ;

	mulss	xmm6, DWORD PTR tv2249[esp+100]
	subss	xmm4, xmm5

; 200  : 		T magnitude=x*x + y*y + z*z;

	movaps	xmm0, xmm2

; 273  : 		x = v1.y  * v2.z  - v1.z  * v2.y ;

	movss	DWORD PTR [ebx], xmm2

; 275  : 		z = v1.x  * v2.y  - v1.y  * v2.x ;

	subss	xmm3, xmm6

; 200  : 		T magnitude=x*x + y*y + z*z;

	mulss	xmm0, xmm2
	movaps	xmm5, xmm4

; 274  : 		y = v1.z  * v2.x  - v1.x  * v2.z ;

	movss	DWORD PTR [ebx+4], xmm4

; 200  : 		T magnitude=x*x + y*y + z*z;

	mulss	xmm5, xmm4

; 275  : 		z = v1.x  * v2.y  - v1.y  * v2.x ;

	movss	DWORD PTR [ebx+8], xmm3

; 200  : 		T magnitude=x*x + y*y + z*z;

	addss	xmm5, xmm0
	movaps	xmm0, xmm3
	mulss	xmm0, xmm3
	addss	xmm5, xmm0

; 201  : 		if (magnitude> std::numeric_limits<T>::min()) {

	comiss	xmm5, DWORD PTR __real@00800000
	jbe	SHORT $LN111@PickBoneHW

; 202  : 			magnitude=_sqrt(1/magnitude);

	movss	xmm0, DWORD PTR __real@3f800000
	divss	xmm0, xmm5
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h

; 764  :             return (float)sqrt(_X);

	sqrtss	xmm0, xmm0
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 203  : 			x *= magnitude;

	mulss	xmm2, xmm0

; 204  : 			y *= magnitude;

	mulss	xmm4, xmm0

; 205  : 			z *= magnitude;

	mulss	xmm3, xmm0
	movss	DWORD PTR [ebx], xmm2
	movss	DWORD PTR [ebx+4], xmm4
	movss	DWORD PTR [ebx+8], xmm3
$LN111@PickBoneHW:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp

; 366  : 			dist		= range;

	movss	DWORD PTR [eax], xmm1

; 367  : 			intersect	= TRUE;

	mov	BYTE PTR _intersect$1$[esp+100], 1
$LN2@PickBoneHW:

; 355  : 	for (CBoneData::FacesVecIt it=faces.begin(); it!=faces.end(); it++){

	movss	xmm5, DWORD PTR __real@39c00180
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 74   :         ++_Ptr;

	add	ecx, 2
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp

; 355  : 	for (CBoneData::FacesVecIt it=faces.begin(); it!=faces.end(); it++){

	cmp	ecx, DWORD PTR $T1[esp+100]
	jne	$LL4@PickBoneHW
	mov	bl, BYTE PTR _intersect$1$[esp+100]
	pop	ebp
$LN3@PickBoneHW:

; 368  : 		}
; 369  : 	}
; 370  : 	CHK_DX				(V->p_rm_Vertices->Unlock());

	mov	eax, DWORD PTR _V$[esp+92]
	mov	eax, DWORD PTR [eax+76]
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+48]

; 371  : 	return intersect;

	pop	edi
	pop	esi
	movzx	eax, bl
	pop	ebx

; 372  : }

	add	esp, 84					; 00000054H
	ret	28					; 0000001cH
?_PickBoneHW1W@CSkeletonX_ext@@MAEHAAU?$_vector3@M@@AAMABU2@2PAVFvisual@@PAGAAV?$xr_vector@GV?$xalloc@G@@@@@Z ENDP ; CSkeletonX_ext::_PickBoneHW1W
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp
; File I:\Vitalya\mine\NSProjectX\xrEngine\SkeletonCustom.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp
; File I:\Vitalya\mine\NSProjectX\xrEngine\SkeletonCustom.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp
; File I:\Vitalya\mine\NSProjectX\xrEngine\SkeletonCustom.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp
; File I:\Vitalya\mine\NSProjectX\xrEngine\SkeletonCustom.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\cl_intersect.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\cl_intersect.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\cl_intersect.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\cl_intersect.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\cl_intersect.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\cl_intersect.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\cl_intersect.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp
_TEXT	SEGMENT
_intersect$1$ = -81					; size = 1
_vertices$ = -80					; size = 4
_p$9$ = -76						; size = 4
tv2018 = -72						; size = 4
tv1991 = -68						; size = 4
_it$1$ = -64						; size = 4
tv1970 = -64						; size = 4
_det$1$ = -60						; size = 4
tv2017 = -56						; size = 4
tv2016 = -52						; size = 4
_p$7$ = -48						; size = 4
_p$8$ = -44						; size = 4
$T1 = -40						; size = 4
_p$2 = -36						; size = 36
_normal$ = 8						; size = 4
_dist$ = 12						; size = 4
_S$ = 16						; size = 4
_D$ = 20						; size = 4
_V$ = 24						; size = 4
_indices$ = 28						; size = 4
_v$1$ = 32						; size = 4
tv2050 = 32						; size = 4
tv1962 = 32						; size = 4
_faces$ = 32						; size = 4
?_PickBoneHW2W@CSkeletonX_ext@@MAEHAAU?$_vector3@M@@AAMABU2@2PAVFvisual@@PAGAAV?$xr_vector@GV?$xalloc@G@@@@@Z PROC ; CSkeletonX_ext::_PickBoneHW2W
; _this$ = ecx

; 374  : {

	sub	esp, 84					; 00000054H
	push	ebx
	push	esi
	push	edi
	mov	esi, ecx

; 376  : 	CHK_DX				(V->p_rm_Vertices->Lock(V->vBase,V->vCount,(void**)&vertices,D3DLOCK_READONLY));

	lea	edi, DWORD PTR _vertices$[esp+96]
	mov	ecx, DWORD PTR _V$[esp+92]
	push	16					; 00000010H
	push	edi
	mov	eax, DWORD PTR [ecx+76]
	push	DWORD PTR [ecx+84]
	push	DWORD PTR [ecx+80]
	mov	edx, DWORD PTR [eax]
	push	eax
	call	DWORD PTR [edx+44]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 150  :         return _Ptr == _Right._Ptr;

	mov	ecx, DWORD PTR _faces$[esp+92]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp

; 377  : 	bool intersect		= FALSE;

	xor	bl, bl
	mov	BYTE PTR _intersect$1$[esp+96], bl
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 150  :         return _Ptr == _Right._Ptr;

	mov	eax, DWORD PTR [ecx+4]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp

; 376  : 	CHK_DX				(V->p_rm_Vertices->Lock(V->vBase,V->vCount,(void**)&vertices,D3DLOCK_READONLY));

	mov	ecx, DWORD PTR [ecx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 150  :         return _Ptr == _Right._Ptr;

	mov	DWORD PTR $T1[esp+96], eax
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp

; 376  : 	CHK_DX				(V->p_rm_Vertices->Lock(V->vBase,V->vCount,(void**)&vertices,D3DLOCK_READONLY));

	mov	DWORD PTR _it$1$[esp+96], ecx

; 378  : 	for (CBoneData::FacesVecIt it=faces.begin(); it!=faces.end(); it++){

	cmp	ecx, eax
	je	$LN3@PickBoneHW

; 384  : 			Fmatrix& xform0			= Parent->LL_GetBoneInstance(vert.get_bone(0)).mRenderTransform; 

	mov	eax, DWORD PTR [esi+4]
	movss	xmm0, DWORD PTR __real@39c00180
	push	ebp
	mov	ebx, DWORD PTR [eax+120]
$LL4@PickBoneHW:

; 379  : 		Fvector			p[3];
; 380  : 		u32 idx			= (*it)*3;

	movzx	eax, WORD PTR [ecx]
	lea	ebp, DWORD PTR _p$2[esp+108]
	mov	ecx, DWORD PTR _indices$[esp+96]
	mov	DWORD PTR tv2050[esp+96], 3
	lea	eax, DWORD PTR [eax+eax*2]
	lea	ecx, DWORD PTR [ecx+eax*2]
	npad	4
$LL7@PickBoneHW:

; 383  : 			vertHW_2W& vert			= vertices[indices[idx+k]];

	movzx	eax, WORD PTR [ecx]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 127  : 		T invt = 1.f-t;

	movss	xmm4, DWORD PTR __real@3f800000
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp

; 383  : 			vertHW_2W& vert			= vertices[indices[idx+k]];

	lea	esi, DWORD PTR [eax*8]
	sub	esi, eax

; 136  : 		return	(u16)_tc_i[w+2]/3;

	mov	eax, DWORD PTR _vertices$[esp+100]
	movzx	edx, WORD PTR [eax+esi*4+24]
	mov	eax, -1431655765			; aaaaaaabH
	mul	edx
	shr	edx, 1
; File I:\Vitalya\mine\NSProjectX\xrEngine\SkeletonCustom.h

; 243  : 	ICF CBoneInstance& LL_GetBoneInstance(u16 bone_id) { VERIFY(bone_id < LL_BoneCount()); VERIFY(bone_instances); return bone_instances[bone_id]; }

	movzx	eax, dx
	lea	edi, DWORD PTR [eax+eax*4]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp

; 136  : 		return	(u16)_tc_i[w+2]/3;

	mov	eax, DWORD PTR _vertices$[esp+100]
; File I:\Vitalya\mine\NSProjectX\xrEngine\SkeletonCustom.h

; 243  : 	ICF CBoneInstance& LL_GetBoneInstance(u16 bone_id) { VERIFY(bone_id < LL_BoneCount()); VERIFY(bone_instances); return bone_instances[bone_id]; }

	shl	edi, 5
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp

; 136  : 		return	(u16)_tc_i[w+2]/3;

	movzx	edx, WORD PTR [eax+esi*4+26]
	mov	eax, -1431655765			; aaaaaaabH
	mul	edx
	shr	edx, 1
; File I:\Vitalya\mine\NSProjectX\xrEngine\SkeletonCustom.h

; 243  : 	ICF CBoneInstance& LL_GetBoneInstance(u16 bone_id) { VERIFY(bone_id < LL_BoneCount()); VERIFY(bone_instances); return bone_instances[bone_id]; }

	movzx	eax, dx
	lea	edx, DWORD PTR [eax+eax*4]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp

; 25   : 	return	float(v)/(32767.f/12.f);

	mov	eax, DWORD PTR _vertices$[esp+100]
; File I:\Vitalya\mine\NSProjectX\xrEngine\SkeletonCustom.h

; 243  : 	ICF CBoneInstance& LL_GetBoneInstance(u16 bone_id) { VERIFY(bone_id < LL_BoneCount()); VERIFY(bone_instances); return bone_instances[bone_id]; }

	shl	edx, 5
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp

; 25   : 	return	float(v)/(32767.f/12.f);

	movsx	eax, WORD PTR [eax+esi*4]
	cvtsi2ss xmm6, eax
	mov	eax, DWORD PTR _vertices$[esp+100]
	movsx	eax, WORD PTR [eax+esi*4+2]
	mulss	xmm6, xmm0
	cvtsi2ss xmm7, eax
	mov	eax, DWORD PTR _vertices$[esp+100]
	movsx	eax, WORD PTR [eax+esi*4+4]
	mulss	xmm7, xmm0
	cvtsi2ss xmm5, eax

; 132  : 		return	float(color_get_A(_N_w))/255.f;

	mov	eax, DWORD PTR _vertices$[esp+100]
	movzx	eax, BYTE PTR [eax+esi*4+11]
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 499  : 		dest.x = v.x*_11 + v.y*_21 + v.z*_31 + _41;

	movaps	xmm2, xmm7
	mulss	xmm2, DWORD PTR [edi+ebx+80]
	movaps	xmm1, xmm7
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp

; 25   : 	return	float(v)/(32767.f/12.f);

	mulss	xmm5, xmm0
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 499  : 		dest.x = v.x*_11 + v.y*_21 + v.z*_31 + _41;

	movaps	xmm0, xmm6
	mulss	xmm0, DWORD PTR [edi+ebx+64]
	mulss	xmm1, DWORD PTR [edx+ebx+80]
	addss	xmm2, xmm0
	movaps	xmm0, xmm5
	mulss	xmm0, DWORD PTR [edi+ebx+96]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp

; 132  : 		return	float(color_get_A(_N_w))/255.f;

	cvtsi2ss xmm3, eax
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 499  : 		dest.x = v.x*_11 + v.y*_21 + v.z*_31 + _41;

	addss	xmm0, DWORD PTR [edi+ebx+112]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp

; 132  : 		return	float(color_get_A(_N_w))/255.f;

	mulss	xmm3, DWORD PTR __real@3b808081
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 499  : 		dest.x = v.x*_11 + v.y*_21 + v.z*_31 + _41;

	addss	xmm2, xmm0
	movaps	xmm0, xmm6
	mulss	xmm0, DWORD PTR [edx+ebx+64]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 127  : 		T invt = 1.f-t;

	subss	xmm4, xmm3
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 499  : 		dest.x = v.x*_11 + v.y*_21 + v.z*_31 + _41;

	addss	xmm1, xmm0
	movaps	xmm0, xmm5
	mulss	xmm0, DWORD PTR [edx+ebx+96]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 128  : 		x = p1.x*invt + p2.x*t;

	mulss	xmm2, xmm4
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 499  : 		dest.x = v.x*_11 + v.y*_21 + v.z*_31 + _41;

	addss	xmm0, DWORD PTR [edx+ebx+112]
	addss	xmm1, xmm0

; 500  : 		dest.y = v.x*_12 + v.y*_22 + v.z*_32 + _42;

	movaps	xmm0, xmm6
	mulss	xmm0, DWORD PTR [edx+ebx+68]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 128  : 		x = p1.x*invt + p2.x*t;

	mulss	xmm1, xmm3
	addss	xmm2, xmm1
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 500  : 		dest.y = v.x*_12 + v.y*_22 + v.z*_32 + _42;

	movaps	xmm1, xmm7
	mulss	xmm1, DWORD PTR [edi+ebx+84]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 128  : 		x = p1.x*invt + p2.x*t;

	movss	DWORD PTR [ebp-8], xmm2
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 500  : 		dest.y = v.x*_12 + v.y*_22 + v.z*_32 + _42;

	movaps	xmm2, xmm7
	mulss	xmm2, DWORD PTR [edx+ebx+84]
	addss	xmm2, xmm0
	movaps	xmm0, xmm5
	mulss	xmm0, DWORD PTR [edx+ebx+100]
	addss	xmm0, DWORD PTR [edx+ebx+116]
	addss	xmm2, xmm0
	movaps	xmm0, xmm6
	mulss	xmm0, DWORD PTR [edi+ebx+68]
	addss	xmm1, xmm0
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 129  : 		y = p1.y*invt + p2.y*t;

	mulss	xmm2, xmm3
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 500  : 		dest.y = v.x*_12 + v.y*_22 + v.z*_32 + _42;

	movaps	xmm0, xmm5
	mulss	xmm0, DWORD PTR [edi+ebx+100]
	addss	xmm0, DWORD PTR [edi+ebx+116]
	addss	xmm1, xmm0
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 129  : 		y = p1.y*invt + p2.y*t;

	mulss	xmm1, xmm4
	addss	xmm2, xmm1
	movss	DWORD PTR [ebp-4], xmm2
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 501  : 		dest.z = v.x*_13 + v.y*_23 + v.z*_33 + _43;

	movaps	xmm1, xmm7
	movaps	xmm0, xmm6
	mulss	xmm0, DWORD PTR [edx+ebx+72]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp

; 381  : 		for (u32 k=0; k<3; k++){

	add	ecx, 2
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 501  : 		dest.z = v.x*_13 + v.y*_23 + v.z*_33 + _43;

	mulss	xmm1, DWORD PTR [edx+ebx+88]
	mulss	xmm7, DWORD PTR [edi+ebx+88]
	mulss	xmm6, DWORD PTR [edi+ebx+72]
	addss	xmm1, xmm0
	movaps	xmm0, xmm5
	mulss	xmm5, DWORD PTR [edi+ebx+104]
	mulss	xmm0, DWORD PTR [edx+ebx+104]
	addss	xmm7, xmm6
	addss	xmm5, DWORD PTR [edi+ebx+120]
	addss	xmm0, DWORD PTR [edx+ebx+120]
	addss	xmm7, xmm5
	addss	xmm1, xmm0
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp

; 381  : 		for (u32 k=0; k<3; k++){

	movss	xmm0, DWORD PTR __real@39c00180
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 130  : 		z = p1.z*invt + p2.z*t;

	mulss	xmm7, xmm4
	mulss	xmm1, xmm3
	addss	xmm1, xmm7
	movss	DWORD PTR [ebp], xmm1
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp

; 381  : 		for (u32 k=0; k<3; k++){

	add	ebp, 12					; 0000000cH
	sub	DWORD PTR tv2050[esp+96], 1
	jne	$LL7@PickBoneHW
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	xmm0, DWORD PTR _p$2[esp+124]

; 273  : 		x = v1.y  * v2.z  - v1.z  * v2.y ;

	mov	edx, DWORD PTR _D$[esp+96]

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movaps	xmm7, xmm0
	subss	xmm7, DWORD PTR _p$2[esp+100]
	movss	DWORD PTR _p$7$[esp+100], xmm0
	movss	xmm0, DWORD PTR _p$2[esp+128]
	movaps	xmm3, xmm0
	movss	DWORD PTR _p$8$[esp+100], xmm0
	movss	xmm0, DWORD PTR _p$2[esp+132]
	subss	xmm3, DWORD PTR _p$2[esp+104]
	movss	DWORD PTR _p$9$[esp+100], xmm0

; 274  : 		y = v1.z  * v2.x  - v1.x  * v2.z ;

	movaps	xmm1, xmm7

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	subss	xmm0, DWORD PTR _p$2[esp+108]

; 274  : 		y = v1.z  * v2.x  - v1.x  * v2.z ;

	mulss	xmm1, DWORD PTR [edx+8]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\cl_intersect.h

; 79   : 			if (det < EPS)  return false;

	mov	ecx, DWORD PTR _it$1$[esp+100]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	xmm5, DWORD PTR _p$2[esp+112]
	movss	xmm2, DWORD PTR _p$2[esp+116]
	subss	xmm2, DWORD PTR _p$2[esp+104]
	subss	xmm5, DWORD PTR _p$2[esp+100]

; 273  : 		x = v1.y  * v2.z  - v1.z  * v2.y ;

	movaps	xmm6, xmm0

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	DWORD PTR tv2018[esp+100], xmm0

; 273  : 		x = v1.y  * v2.z  - v1.z  * v2.y ;

	mulss	xmm6, DWORD PTR [edx+4]
	movaps	xmm0, xmm3
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\cl_intersect.h

; 79   : 			if (det < EPS)  return false;

	mov	ebp, DWORD PTR _normal$[esp+96]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 273  : 		x = v1.y  * v2.z  - v1.z  * v2.y ;

	mulss	xmm0, DWORD PTR [edx+8]

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	xmm4, DWORD PTR _p$2[esp+120]
	subss	xmm4, DWORD PTR _p$2[esp+108]

; 273  : 		x = v1.y  * v2.z  - v1.z  * v2.y ;

	subss	xmm6, xmm0

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	DWORD PTR tv2017[esp+100], xmm3

; 274  : 		y = v1.z  * v2.x  - v1.x  * v2.z ;

	movss	xmm0, DWORD PTR tv2018[esp+100]
	mulss	xmm0, DWORD PTR [edx]

; 275  : 		z = v1.x  * v2.y  - v1.y  * v2.x ;

	mulss	xmm3, DWORD PTR [edx]
	subss	xmm1, xmm0

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	DWORD PTR tv2016[esp+100], xmm7

; 275  : 		z = v1.x  * v2.y  - v1.y  * v2.x ;

	movaps	xmm0, xmm7

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	DWORD PTR tv1991[esp+100], xmm2

; 275  : 		z = v1.x  * v2.y  - v1.y  * v2.x ;

	mulss	xmm0, DWORD PTR [edx+4]
	movaps	xmm7, xmm1
	subss	xmm3, xmm0
	mulss	xmm7, xmm2

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	movaps	xmm0, xmm6
	mulss	xmm0, xmm5

; 275  : 		z = v1.x  * v2.y  - v1.y  * v2.x ;

	movss	DWORD PTR tv1962[esp+96], xmm3

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	addss	xmm7, xmm0
	movaps	xmm0, xmm3
	mulss	xmm0, xmm4
	addss	xmm7, xmm0
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\cl_intersect.h

; 79   : 			if (det < EPS)  return false;

	movss	xmm0, DWORD PTR __real@3727c5ac
	comiss	xmm0, xmm7
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	movss	DWORD PTR _det$1$[esp+100], xmm7
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\cl_intersect.h

; 79   : 			if (det < EPS)  return false;

	ja	$LN2@PickBoneHW
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	mov	eax, DWORD PTR _S$[esp+96]
	movss	xmm3, DWORD PTR [eax]
	movss	xmm0, DWORD PTR [eax+4]
	subss	xmm0, DWORD PTR _p$2[esp+104]
	subss	xmm3, DWORD PTR _p$2[esp+100]
	movss	xmm2, DWORD PTR [eax+8]
	subss	xmm2, DWORD PTR _p$2[esp+108]
	mulss	xmm1, xmm0

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	mulss	xmm6, xmm3

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	DWORD PTR tv1970[esp+100], xmm0

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	addss	xmm1, xmm6
	movss	xmm6, DWORD PTR tv1962[esp+96]
	mulss	xmm6, xmm2
	addss	xmm1, xmm6
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\cl_intersect.h

; 82   : 			if (u < 0.0f || u > det) return false;

	xorps	xmm6, xmm6
	comiss	xmm6, xmm1
	ja	$LN2@PickBoneHW
	comiss	xmm1, xmm7
	ja	$LN2@PickBoneHW
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 273  : 		x = v1.y  * v2.z  - v1.z  * v2.y ;

	movaps	xmm6, xmm0
	movaps	xmm0, xmm2
	mulss	xmm0, DWORD PTR tv1991[esp+100]
	mulss	xmm6, xmm4
	mulss	xmm2, xmm5
	subss	xmm6, xmm0

; 274  : 		y = v1.z  * v2.x  - v1.x  * v2.z ;

	movaps	xmm0, xmm3
	mulss	xmm3, DWORD PTR tv1991[esp+100]
	mulss	xmm0, xmm4
	subss	xmm2, xmm0

; 275  : 		z = v1.x  * v2.y  - v1.y  * v2.x ;

	movss	xmm0, DWORD PTR tv1970[esp+100]
	mulss	xmm0, xmm5
	subss	xmm3, xmm0

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	movaps	xmm0, xmm6
	mulss	xmm0, DWORD PTR [edx]
	movss	DWORD PTR _v$1$[esp+96], xmm0
	movaps	xmm0, xmm2
	mulss	xmm0, DWORD PTR [edx+4]
	movss	xmm7, DWORD PTR _v$1$[esp+96]
	addss	xmm7, xmm0
	movaps	xmm0, xmm3
	mulss	xmm0, DWORD PTR [edx+8]
	addss	xmm7, xmm0
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\cl_intersect.h

; 85   : 			if (v < 0.0f || u + v > det) return false;

	movaps	xmm0, xmm7
	xorps	xmm7, xmm7
	comiss	xmm7, xmm0
	movss	xmm7, DWORD PTR _det$1$[esp+100]
	ja	$LN2@PickBoneHW
	addss	xmm1, xmm0
	comiss	xmm1, xmm7
	ja	$LN2@PickBoneHW
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	mulss	xmm2, DWORD PTR tv2017[esp+100]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp

; 391  : 		if (CDB::TestRayTri(S,D,p,u,v,range,true)&&(range<dist)){

	mov	eax, DWORD PTR _dist$[esp+96]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	mulss	xmm6, DWORD PTR tv2016[esp+100]
	mulss	xmm3, DWORD PTR tv2018[esp+100]
	addss	xmm2, xmm6
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp

; 391  : 		if (CDB::TestRayTri(S,D,p,u,v,range,true)&&(range<dist)){

	movss	xmm0, DWORD PTR [eax]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	addss	xmm2, xmm3
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\cl_intersect.h

; 88   : 			range *= inv_det;

	divss	xmm2, xmm7
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp

; 391  : 		if (CDB::TestRayTri(S,D,p,u,v,range,true)&&(range<dist)){

	comiss	xmm0, xmm2
	jbe	$LN2@PickBoneHW
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	xmm0, DWORD PTR _p$9$[esp+100]
	subss	xmm0, DWORD PTR _p$2[esp+120]
	movss	xmm1, DWORD PTR tv1991[esp+100]
	movss	xmm7, DWORD PTR _p$8$[esp+100]
	movaps	xmm3, xmm1
	subss	xmm7, DWORD PTR _p$2[esp+116]
	movss	xmm6, DWORD PTR _p$7$[esp+100]
	subss	xmm6, DWORD PTR _p$2[esp+112]
	mulss	xmm3, xmm0
	movss	DWORD PTR _p$9$[esp+100], xmm0

; 273  : 		x = v1.y  * v2.z  - v1.z  * v2.y ;

	movaps	xmm0, xmm4
	mulss	xmm0, xmm7
	mulss	xmm4, xmm6
	subss	xmm3, xmm0

; 275  : 		z = v1.x  * v2.y  - v1.y  * v2.x ;

	mulss	xmm1, xmm6
	movaps	xmm0, xmm5
	mulss	xmm5, xmm7
	mulss	xmm0, DWORD PTR _p$9$[esp+100]
	subss	xmm5, xmm1
	movss	DWORD PTR [ebp], xmm3
	subss	xmm4, xmm0

; 200  : 		T magnitude=x*x + y*y + z*z;

	movaps	xmm0, xmm3
	mulss	xmm0, xmm3

; 275  : 		z = v1.x  * v2.y  - v1.y  * v2.x ;

	movss	DWORD PTR [ebp+8], xmm5

; 200  : 		T magnitude=x*x + y*y + z*z;

	movaps	xmm1, xmm4

; 274  : 		y = v1.z  * v2.x  - v1.x  * v2.z ;

	movss	DWORD PTR [ebp+4], xmm4

; 200  : 		T magnitude=x*x + y*y + z*z;

	mulss	xmm1, xmm4
	addss	xmm1, xmm0
	movaps	xmm0, xmm5
	mulss	xmm0, xmm5
	addss	xmm1, xmm0

; 201  : 		if (magnitude> std::numeric_limits<T>::min()) {

	comiss	xmm1, DWORD PTR __real@00800000
	jbe	SHORT $LN139@PickBoneHW

; 202  : 			magnitude=_sqrt(1/magnitude);

	movss	xmm0, DWORD PTR __real@3f800000
	divss	xmm0, xmm1
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h

; 764  :             return (float)sqrt(_X);

	sqrtss	xmm1, xmm0
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 203  : 			x *= magnitude;

	movaps	xmm0, xmm1
	mulss	xmm0, xmm3
	movss	DWORD PTR [ebp], xmm0

; 204  : 			y *= magnitude;

	movaps	xmm0, xmm1
	mulss	xmm0, xmm4

; 205  : 			z *= magnitude;

	mulss	xmm1, xmm5
	movss	DWORD PTR [ebp+4], xmm0
	movss	DWORD PTR [ebp+8], xmm1
$LN139@PickBoneHW:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp

; 393  : 			dist		= range;

	movss	DWORD PTR [eax], xmm2

; 394  : 			intersect	= TRUE;

	mov	BYTE PTR _intersect$1$[esp+100], 1
$LN2@PickBoneHW:

; 378  : 	for (CBoneData::FacesVecIt it=faces.begin(); it!=faces.end(); it++){

	movss	xmm0, DWORD PTR __real@39c00180
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 74   :         ++_Ptr;

	add	ecx, 2
	mov	DWORD PTR _it$1$[esp+100], ecx
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp

; 378  : 	for (CBoneData::FacesVecIt it=faces.begin(); it!=faces.end(); it++){

	cmp	ecx, DWORD PTR $T1[esp+100]
	jne	$LL4@PickBoneHW
	mov	bl, BYTE PTR _intersect$1$[esp+100]
	pop	ebp
$LN3@PickBoneHW:

; 395  : 		}
; 396  : 	}
; 397  : 	CHK_DX				(V->p_rm_Vertices->Unlock());

	mov	eax, DWORD PTR _V$[esp+92]
	mov	eax, DWORD PTR [eax+76]
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+48]

; 398  : 	return intersect;

	pop	edi
	pop	esi
	movzx	eax, bl
	pop	ebx

; 399  : }

	add	esp, 84					; 00000054H
	ret	28					; 0000001cH
?_PickBoneHW2W@CSkeletonX_ext@@MAEHAAU?$_vector3@M@@AAMABU2@2PAVFvisual@@PAGAAV?$xr_vector@GV?$xalloc@G@@@@@Z ENDP ; CSkeletonX_ext::_PickBoneHW2W
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xrsharedmem.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp
_TEXT	SEGMENT
_normal$ = 8						; size = 4
_dist$ = 12						; size = 4
_start$ = 16						; size = 4
_dir$ = 20						; size = 4
_V$ = 24						; size = 4
_bone_id$ = 28						; size = 2
_indices$ = 28						; size = 4
_iBase$ = 32						; size = 4
_iCount$ = 36						; size = 4
?_PickBone@CSkeletonX_ext@@MAEHAAU?$_vector3@M@@AAMABU2@2PAVFvisual@@GII@Z PROC ; CSkeletonX_ext::_PickBone
; _this$ = ecx

; 403  : {

	push	ebx
	push	esi
	mov	esi, ecx
	push	edi

; 404  : 	VERIFY							(Parent && (ChildIDX!=u16(-1)));
; 405  : 	CBoneData& BD					= Parent->LL_GetData(bone_id);

	push	DWORD PTR _bone_id$[esp+8]
	mov	ecx, DWORD PTR [esi+4]
	call	DWORD PTR __imp_?LL_GetData@CKinematics@@QAEAAVCBoneData@@G@Z

; 406  : 	CBoneData::FacesVec*	faces	= &BD.child_faces[ChildIDX];

	movzx	edx, WORD PTR [esi+22]

; 409  : 	CHK_DX				(V->p_rm_Indices->Lock(0,V->dwPrimitives*3,(void**)&indices,D3DLOCK_READONLY));

	mov	ebx, DWORD PTR _V$[esp+8]
	push	16					; 00000010H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 303  :         _Vector_iterator _Tmp = *this;

	mov	eax, DWORD PTR [eax+424]

; 119  :         _Ptr += _Off;

	lea	ecx, DWORD PTR [edx+edx*2]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp

; 407  : 	u16* indices		= 0;

	mov	DWORD PTR _indices$[esp+12], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 119  :         _Ptr += _Off;

	lea	edi, DWORD PTR [eax+ecx*4]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp

; 409  : 	CHK_DX				(V->p_rm_Indices->Lock(0,V->dwPrimitives*3,(void**)&indices,D3DLOCK_READONLY));

	mov	ecx, DWORD PTR [ebx+88]
	lea	eax, DWORD PTR _indices$[esp+12]
	push	eax
	mov	eax, DWORD PTR [ebx+100]
	mov	edx, DWORD PTR [ecx]
	lea	eax, DWORD PTR [eax+eax*2]
	push	eax
	push	0
	push	ecx
	call	DWORD PTR [edx+44]

; 410  : 	// fill vertices
; 411  : 	BOOL result			= FALSE;
; 412  : 	switch	(RenderMode){

	movzx	eax, WORD PTR [esi+20]
	jmp	DWORD PTR $LN36@PickBone[eax*4]
$LN7@PickBone:
; File I:\Vitalya\mine\NSProjectX\xrCore\xrsharedmem.h

; 86   : 	T*					operator*	() const						{	return p_?(T*)p_->value:0;									}

	mov	eax, DWORD PTR [esi+8]
	test	eax, eax
	je	SHORT $LN8@PickBone
	add	eax, 16					; 00000010H
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp

; 414  : 	if (*Vertices1W)result = _PickBoneSoft1W	(normal,dist,start,dir,indices+iBase,*faces);

	je	SHORT $LN8@PickBone
	mov	ecx, DWORD PTR _iBase$[esp+8]
	mov	eax, DWORD PTR _indices$[esp+8]
	push	edi
	lea	eax, DWORD PTR [eax+ecx*2]
	mov	ecx, esi
	push	eax
	push	DWORD PTR _dir$[esp+16]
	push	DWORD PTR _start$[esp+20]
	push	DWORD PTR _dist$[esp+24]
	push	DWORD PTR _normal$[esp+28]
	call	DWORD PTR __imp_?_PickBoneSoft1W@CSkeletonX@@IAEHAAU?$_vector3@M@@AAMABU2@2PAGAAV?$xr_vector@GV?$xalloc@G@@@@@Z

; 420  : default: NODEFAULT;
; 421  : 	}
; 422  : 	CHK_DX				(V->p_rm_Indices->Unlock());

	mov	esi, eax
	mov	eax, DWORD PTR [ebx+88]
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+48]
	pop	edi

; 423  : 	return result;

	mov	eax, esi

; 424  : }

	pop	esi
	pop	ebx
	ret	32					; 00000020H
$LN8@PickBone:

; 415  : 	else			result = _PickBoneSoft2W	(normal,dist,start,dir,indices+iBase,*faces);

	mov	ecx, DWORD PTR _iBase$[esp+8]
	mov	eax, DWORD PTR _indices$[esp+8]
	push	edi
	lea	eax, DWORD PTR [eax+ecx*2]
	mov	ecx, esi
	push	eax
	push	DWORD PTR _dir$[esp+16]
	push	DWORD PTR _start$[esp+20]
	push	DWORD PTR _dist$[esp+24]
	push	DWORD PTR _normal$[esp+28]
	call	DWORD PTR __imp_?_PickBoneSoft2W@CSkeletonX@@IAEHAAU?$_vector3@M@@AAMABU2@2PAGAAV?$xr_vector@GV?$xalloc@G@@@@@Z

; 420  : default: NODEFAULT;
; 421  : 	}
; 422  : 	CHK_DX				(V->p_rm_Indices->Unlock());

	mov	esi, eax
	mov	eax, DWORD PTR [ebx+88]
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+48]
	pop	edi

; 423  : 	return result;

	mov	eax, esi

; 424  : }

	pop	esi
	pop	ebx
	ret	32					; 00000020H
$LN10@PickBone:

; 416  : 	break;
; 417  : case RM_SINGLE:
; 418  : case RM_SKINNING_1B:	result = _PickBoneHW1W	(normal,dist,start,dir,V,indices+iBase,*faces); break;

	mov	ecx, DWORD PTR _iBase$[esp+8]
	mov	eax, DWORD PTR _indices$[esp+8]
	mov	edx, DWORD PTR [esi]
	push	edi
	lea	eax, DWORD PTR [eax+ecx*2]
	mov	ecx, esi
	push	eax
	push	ebx
	push	DWORD PTR _dir$[esp+20]
	push	DWORD PTR _start$[esp+24]
	push	DWORD PTR _dist$[esp+28]
	push	DWORD PTR _normal$[esp+32]
	call	DWORD PTR [edx+20]

; 420  : default: NODEFAULT;
; 421  : 	}
; 422  : 	CHK_DX				(V->p_rm_Indices->Unlock());

	mov	esi, eax
	mov	eax, DWORD PTR [ebx+88]
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+48]
	pop	edi

; 423  : 	return result;

	mov	eax, esi

; 424  : }

	pop	esi
	pop	ebx
	ret	32					; 00000020H
$LN12@PickBone:

; 419  : case RM_SKINNING_2B:	result = _PickBoneHW2W	(normal,dist,start,dir,V,indices+iBase,*faces);	break;

	mov	ecx, DWORD PTR _iBase$[esp+8]
	mov	eax, DWORD PTR _indices$[esp+8]
	mov	edx, DWORD PTR [esi]
	push	edi
	lea	eax, DWORD PTR [eax+ecx*2]
	mov	ecx, esi
	push	eax
	push	ebx
	push	DWORD PTR _dir$[esp+20]
	push	DWORD PTR _start$[esp+24]
	push	DWORD PTR _dist$[esp+28]
	push	DWORD PTR _normal$[esp+32]
	call	DWORD PTR [edx+24]

; 420  : default: NODEFAULT;
; 421  : 	}
; 422  : 	CHK_DX				(V->p_rm_Indices->Unlock());

	mov	esi, eax
	mov	eax, DWORD PTR [ebx+88]
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+48]
	pop	edi

; 423  : 	return result;

	mov	eax, esi

; 424  : }

	pop	esi
	pop	ebx
	ret	32					; 00000020H
	npad	2
$LN36@PickBone:
	DD	$LN7@PickBone
	DD	$LN10@PickBone
	DD	$LN10@PickBone
	DD	$LN12@PickBone
?_PickBone@CSkeletonX_ext@@MAEHAAU?$_vector3@M@@AAMABU2@2PAVFvisual@@GII@Z ENDP ; CSkeletonX_ext::_PickBone
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp
_TEXT	SEGMENT
_normal$ = 8						; size = 4
_dist$ = 12						; size = 4
_start$ = 16						; size = 4
_dir$ = 20						; size = 4
_bone_id$ = 24						; size = 2
?PickBone@CSkeletonX_ST@@UAEHAAU?$_vector3@M@@AAMABU2@2G@Z PROC ; CSkeletonX_ST::PickBone
; _this$ = ecx

; 427  : 	return inherited2::_PickBone	(normal,dist,start,dir,this,bone_id,iBase,iCount);

	push	DWORD PTR [ecx-12]
	lea	eax, DWORD PTR [ecx-108]
	push	DWORD PTR [ecx-16]
	push	DWORD PTR _bone_id$[esp+4]
	push	eax
	push	DWORD PTR _dir$[esp+12]
	push	DWORD PTR _start$[esp+16]
	push	DWORD PTR _dist$[esp+20]
	push	DWORD PTR _normal$[esp+24]
	call	?_PickBone@CSkeletonX_ext@@MAEHAAU?$_vector3@M@@AAMABU2@2PAVFvisual@@GII@Z ; CSkeletonX_ext::_PickBone

; 428  : }

	ret	20					; 00000014H
?PickBone@CSkeletonX_ST@@UAEHAAU?$_vector3@M@@AAMABU2@2G@Z ENDP ; CSkeletonX_ST::PickBone
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp
_TEXT	SEGMENT
_normal$ = 8						; size = 4
_dist$ = 12						; size = 4
_start$ = 16						; size = 4
_dir$ = 20						; size = 4
_bone_id$ = 24						; size = 2
?PickBone@CSkeletonX_PM@@UAEHAAU?$_vector3@M@@AAMABU2@2G@Z PROC ; CSkeletonX_PM::PickBone
; _this$ = ecx

; 431  : 	FSlideWindow& SW				= nSWI.sw[0];

	mov	edx, DWORD PTR [ecx-32]

; 432  : 	return inherited2::_PickBone	(normal,dist,start,dir,this,bone_id,iBase+SW.offset,SW.num_tris*3);

	movzx	eax, WORD PTR [edx+4]
	lea	eax, DWORD PTR [eax+eax*2]
	push	eax
	mov	eax, DWORD PTR [ecx-48]
	add	eax, DWORD PTR [edx]
	push	eax
	push	DWORD PTR _bone_id$[esp+4]
	lea	eax, DWORD PTR [ecx-140]
	push	eax
	push	DWORD PTR _dir$[esp+12]
	push	DWORD PTR _start$[esp+16]
	push	DWORD PTR _dist$[esp+20]
	push	DWORD PTR _normal$[esp+24]
	call	?_PickBone@CSkeletonX_ext@@MAEHAAU?$_vector3@M@@AAMABU2@2PAVFvisual@@GII@Z ; CSkeletonX_ext::_PickBone

; 433  : }

	ret	20					; 00000014H
?PickBone@CSkeletonX_PM@@UAEHAAU?$_vector3@M@@AAMABU2@2G@Z ENDP ; CSkeletonX_PM::PickBone
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp
_TEXT	SEGMENT
_C$ = 8							; size = 4
_bone_id$ = 12						; size = 2
?EnumBoneVertices@CSkeletonX_ST@@UAEXAAUSEnumVerticesCallback@@G@Z PROC ; CSkeletonX_ST::EnumBoneVertices
; _this$ = ecx

; 438  : 	inherited2::_EnumBoneVertices( C, this, bone_id, iBase, iCount );

	push	ecx
	push	DWORD PTR [ecx-16]
	lea	eax, DWORD PTR [ecx-108]
	push	DWORD PTR _bone_id$[esp+4]
	push	eax
	push	DWORD PTR _C$[esp+12]
	call	?_EnumBoneVertices@CSkeletonX_ext@@IBEXAAUSEnumVerticesCallback@@PAVFvisual@@GII@Z ; CSkeletonX_ext::_EnumBoneVertices

; 439  : }

	ret	8
?EnumBoneVertices@CSkeletonX_ST@@UAEXAAUSEnumVerticesCallback@@G@Z ENDP ; CSkeletonX_ST::EnumBoneVertices
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp
_TEXT	SEGMENT
_C$ = 8							; size = 4
_bone_id$ = 12						; size = 2
?EnumBoneVertices@CSkeletonX_PM@@UAEXAAUSEnumVerticesCallback@@G@Z PROC ; CSkeletonX_PM::EnumBoneVertices
; _this$ = ecx

; 443  : 	FSlideWindow& SW				= nSWI.sw[0];
; 444  : 	inherited2::_EnumBoneVertices( C, this, bone_id, iBase+SW.offset, SW.num_tris*3 );

	mov	eax, DWORD PTR [ecx-32]
	push	ecx
	mov	eax, DWORD PTR [eax]
	add	eax, DWORD PTR [ecx-48]
	push	eax
	push	DWORD PTR _bone_id$[esp+4]
	lea	eax, DWORD PTR [ecx-140]
	push	eax
	push	DWORD PTR _C$[esp+12]
	call	?_EnumBoneVertices@CSkeletonX_ext@@IBEXAAUSEnumVerticesCallback@@PAVFvisual@@GII@Z ; CSkeletonX_ext::_EnumBoneVertices

; 445  : }

	ret	8
?EnumBoneVertices@CSkeletonX_PM@@UAEXAAUSEnumVerticesCallback@@G@Z ENDP ; CSkeletonX_PM::EnumBoneVertices
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_color.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp
; File I:\Vitalya\mine\NSProjectX\xrEngine\SkeletonCustom.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp
; File I:\Vitalya\mine\NSProjectX\xrEngine\SkeletonCustom.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_color.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp
; File I:\Vitalya\mine\NSProjectX\xrEngine\SkeletonCustom.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp
; File I:\Vitalya\mine\NSProjectX\xrEngine\SkeletonCustom.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_color.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp
; File I:\Vitalya\mine\NSProjectX\xrEngine\SkeletonCustom.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrEngine\SkeletonCustom.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\cl_intersect.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrEngine\SkeletonCustom.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrEngine\SkeletonCustom.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\cl_intersect.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\cl_intersect.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\cl_intersect.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\cl_intersect.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\cl_intersect.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\cl_intersect.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\cl_intersect.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp
_TEXT	SEGMENT
_vertices$ = -212					; size = 4
tv2864 = -208						; size = 4
_p$1$ = -204						; size = 4
_p$4$ = -200						; size = 4
_p$6$ = -196						; size = 4
_p$7$ = -192						; size = 4
tv2743 = -188						; size = 4
tv2633 = -184						; size = 4
_p$2$ = -180						; size = 4
_p$3$ = -176						; size = 4
_p$5$ = -172						; size = 4
_p$8$ = -168						; size = 4
_it$1$ = -164						; size = 4
tv2863 = -160						; size = 4
tv2749 = -156						; size = 4
_fRSqr$2 = -152						; size = 4
_this$1$ = -148						; size = 4
_e1$3 = -144						; size = 12
_e0$4 = -132						; size = 12
_F$5 = -120						; size = 84
_p$6 = -36						; size = 36
_view$ = 8						; size = 4
_wm$ = 12						; size = 4
_normal$ = 16						; size = 4
_size$ = 20						; size = 4
_V$ = 24						; size = 4
_indices$ = 28						; size = 4
_faces$ = 32						; size = 4
?_FillVerticesHW1W@CSkeletonX_ext@@MAEXABU?$_matrix@M@@AAVCSkeletonWallmark@@ABU?$_vector3@M@@MPAVFvisual@@PAGAAV?$xr_vector@GV?$xalloc@G@@@@@Z PROC ; CSkeletonX_ext::_FillVerticesHW1W
; _this$ = ecx

; 448  : {

	sub	esp, 212				; 000000d4H
	push	ebx
	push	esi
	mov	ebx, ecx

; 449  : 	vertHW_1W*			vertices;
; 450  : 	CHK_DX				(V->p_rm_Vertices->Lock(V->vBase,V->vCount,(void**)&vertices,D3DLOCK_READONLY));

	lea	esi, DWORD PTR _vertices$[esp+220]
	mov	ecx, DWORD PTR _V$[esp+216]
	push	16					; 00000010H
	push	esi
	mov	DWORD PTR _this$1$[esp+228], ebx
	mov	eax, DWORD PTR [ecx+76]
	push	DWORD PTR [ecx+84]
	push	DWORD PTR [ecx+80]
	mov	edx, DWORD PTR [eax]
	push	eax
	call	DWORD PTR [edx+44]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	ecx, DWORD PTR _faces$[esp+216]
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR _it$1$[esp+220], eax

; 150  :         return _Ptr == _Right._Ptr;

	cmp	eax, DWORD PTR [ecx+4]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp

; 451  : 	for (CBoneData::FacesVecIt it=faces.begin(); it!=faces.end(); it++){

	je	$LN3@FillVertic
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 500  : 		dest.y = v.x*_12 + v.y*_22 + v.z*_32 + _42;

	movss	xmm7, DWORD PTR __real@39c00180
	mov	edx, DWORD PTR _vertices$[esp+220]

; 499  : 		dest.x = v.x*_11 + v.y*_21 + v.z*_31 + _41;

	push	ebp
	mov	ebp, DWORD PTR _view$[esp+220]
	push	edi
	npad	10
$LL4@FillVertic:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp

; 453  : 		u32 idx			= (*it)*3;

	movzx	eax, WORD PTR [eax]

; 459  : 			F.weight[k]				= 0.f;

	mov	DWORD PTR _F$5[esp+300], 0
	mov	DWORD PTR _F$5[esp+304], 0
	lea	edi, DWORD PTR [eax+eax*2]

; 460  : 			const Fmatrix& xform	= Parent->LL_GetBoneInstance(F.bone_id[k][0]).mRenderTransform; 

	mov	eax, DWORD PTR [ebx+4]
	mov	ebx, DWORD PTR [eax+120]
	mov	eax, DWORD PTR _indices$[esp+224]
	movzx	eax, WORD PTR [eax+edi*2]
	lea	esi, DWORD PTR [eax+eax*2]

; 87   : 		return	(u16)color_get_A(_N_I)/3;

	mov	eax, -1431655765			; aaaaaaabH
; File I:\Vitalya\mine\NSProjectX\xrCore\_color.h

; 20   : ICF	u32 color_get_A (u32 rgba)						{	return ((rgba) >> 24);			}

	movzx	ecx, BYTE PTR [edx+esi*8+11]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp

; 87   : 		return	(u16)color_get_A(_N_I)/3;

	mul	ecx
	shr	edx, 1

; 457  : 			F.bone_id[k][0]			= vert.get_bone();

	movzx	eax, dx

; 25   : 	return	float(v)/(32767.f/12.f);

	mov	edx, DWORD PTR _vertices$[esp+228]

; 457  : 			F.bone_id[k][0]			= vert.get_bone();

	mov	WORD PTR _F$5[esp+288], ax

; 458  : 			F.bone_id[k][1]			= F.bone_id[k][0];

	mov	WORD PTR _F$5[esp+290], ax
; File I:\Vitalya\mine\NSProjectX\xrEngine\SkeletonCustom.h

; 243  : 	ICF CBoneInstance& LL_GetBoneInstance(u16 bone_id) { VERIFY(bone_id < LL_BoneCount()); VERIFY(bone_instances); return bone_instances[bone_id]; }

	lea	ecx, DWORD PTR [eax+eax*4]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp

; 25   : 	return	float(v)/(32767.f/12.f);

	movsx	eax, WORD PTR [edx+esi*8]
; File I:\Vitalya\mine\NSProjectX\xrEngine\SkeletonCustom.h

; 243  : 	ICF CBoneInstance& LL_GetBoneInstance(u16 bone_id) { VERIFY(bone_id < LL_BoneCount()); VERIFY(bone_instances); return bone_instances[bone_id]; }

	shl	ecx, 5
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp

; 25   : 	return	float(v)/(32767.f/12.f);

	cvtsi2ss xmm2, eax
	movsx	eax, WORD PTR [edx+esi*8+2]
	cvtsi2ss xmm3, eax
	movsx	eax, WORD PTR [edx+esi*8+4]
	cvtsi2ss xmm1, eax

; 456  : 			vertHW_1W& vert			= vertices[indices[idx+k]];

	mov	eax, DWORD PTR _indices$[esp+224]

; 25   : 	return	float(v)/(32767.f/12.f);

	mulss	xmm2, xmm7

; 456  : 			vertHW_1W& vert			= vertices[indices[idx+k]];

	movzx	eax, WORD PTR [eax+edi*2+2]

; 25   : 	return	float(v)/(32767.f/12.f);

	mulss	xmm3, xmm7
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 499  : 		dest.x = v.x*_11 + v.y*_21 + v.z*_31 + _41;

	movaps	xmm0, xmm2
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp

; 25   : 	return	float(v)/(32767.f/12.f);

	mulss	xmm1, xmm7

; 456  : 			vertHW_1W& vert			= vertices[indices[idx+k]];

	lea	esi, DWORD PTR [eax+eax*2]

; 87   : 		return	(u16)color_get_A(_N_I)/3;

	mov	eax, -1431655765			; aaaaaaabH
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 499  : 		dest.x = v.x*_11 + v.y*_21 + v.z*_31 + _41;

	mulss	xmm0, DWORD PTR [ecx+ebx+64]
	movaps	xmm4, xmm3
	mulss	xmm4, DWORD PTR [ecx+ebx+80]

; 500  : 		dest.y = v.x*_12 + v.y*_22 + v.z*_32 + _42;

	movaps	xmm6, xmm3
	mulss	xmm6, DWORD PTR [ecx+ebx+84]
	addss	xmm4, xmm0
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp

; 93   : 		p.z			= u_P(_P[2]);

	movss	DWORD PTR _F$5[esp+236], xmm1
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 499  : 		dest.x = v.x*_11 + v.y*_21 + v.z*_31 + _41;

	movaps	xmm0, xmm1
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp

; 91   : 		p.x			= u_P(_P[0]);

	movss	DWORD PTR _F$5[esp+228], xmm2
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 499  : 		dest.x = v.x*_11 + v.y*_21 + v.z*_31 + _41;

	mulss	xmm0, DWORD PTR [ecx+ebx+96]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp

; 92   : 		p.y			= u_P(_P[1]);

	movss	DWORD PTR _F$5[esp+232], xmm3
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 501  : 		dest.z = v.x*_13 + v.y*_23 + v.z*_33 + _43;

	mulss	xmm3, DWORD PTR [ecx+ebx+88]
	addss	xmm0, DWORD PTR [ecx+ebx+112]
	addss	xmm4, xmm0
	movaps	xmm0, xmm2
	mulss	xmm0, DWORD PTR [ecx+ebx+68]
	mulss	xmm2, DWORD PTR [ecx+ebx+72]
	addss	xmm6, xmm0
	movss	DWORD PTR tv2633[esp+228], xmm4
	movaps	xmm0, xmm1
	movss	DWORD PTR _p$6[esp+228], xmm4
	mulss	xmm0, DWORD PTR [ecx+ebx+100]
	addss	xmm3, xmm2
	mulss	xmm1, DWORD PTR [ecx+ebx+104]
	addss	xmm0, DWORD PTR [ecx+ebx+116]
	addss	xmm1, DWORD PTR [ecx+ebx+120]
; File I:\Vitalya\mine\NSProjectX\xrCore\_color.h

; 20   : ICF	u32 color_get_A (u32 rgba)						{	return ((rgba) >> 24);			}

	movzx	ecx, BYTE PTR [edx+esi*8+11]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp

; 87   : 		return	(u16)color_get_A(_N_I)/3;

	mul	ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 500  : 		dest.y = v.x*_12 + v.y*_22 + v.z*_32 + _42;

	addss	xmm6, xmm0

; 501  : 		dest.z = v.x*_13 + v.y*_23 + v.z*_33 + _43;

	addss	xmm3, xmm1
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp

; 87   : 		return	(u16)color_get_A(_N_I)/3;

	shr	edx, 1

; 457  : 			F.bone_id[k][0]			= vert.get_bone();

	movzx	eax, dx

; 25   : 	return	float(v)/(32767.f/12.f);

	mov	edx, DWORD PTR _vertices$[esp+228]

; 457  : 			F.bone_id[k][0]			= vert.get_bone();

	mov	WORD PTR _F$5[esp+292], ax

; 458  : 			F.bone_id[k][1]			= F.bone_id[k][0];

	mov	WORD PTR _F$5[esp+294], ax
; File I:\Vitalya\mine\NSProjectX\xrEngine\SkeletonCustom.h

; 243  : 	ICF CBoneInstance& LL_GetBoneInstance(u16 bone_id) { VERIFY(bone_id < LL_BoneCount()); VERIFY(bone_instances); return bone_instances[bone_id]; }

	lea	ecx, DWORD PTR [eax+eax*4]
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 500  : 		dest.y = v.x*_12 + v.y*_22 + v.z*_32 + _42;

	movss	DWORD PTR _p$1$[esp+228], xmm6
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp

; 25   : 	return	float(v)/(32767.f/12.f);

	movsx	eax, WORD PTR [edx+esi*8]
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 500  : 		dest.y = v.x*_12 + v.y*_22 + v.z*_32 + _42;

	movss	DWORD PTR _p$6[esp+232], xmm6

; 501  : 		dest.z = v.x*_13 + v.y*_23 + v.z*_33 + _43;

	movss	DWORD PTR _p$2$[esp+228], xmm3
	movss	DWORD PTR _p$6[esp+236], xmm3
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp

; 25   : 	return	float(v)/(32767.f/12.f);

	cvtsi2ss xmm2, eax
	movsx	eax, WORD PTR [edx+esi*8+2]
; File I:\Vitalya\mine\NSProjectX\xrEngine\SkeletonCustom.h

; 243  : 	ICF CBoneInstance& LL_GetBoneInstance(u16 bone_id) { VERIFY(bone_id < LL_BoneCount()); VERIFY(bone_instances); return bone_instances[bone_id]; }

	shl	ecx, 5
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp

; 25   : 	return	float(v)/(32767.f/12.f);

	cvtsi2ss xmm5, eax
	mulss	xmm2, xmm7
	mulss	xmm5, xmm7

; 91   : 		p.x			= u_P(_P[0]);

	movss	DWORD PTR _F$5[esp+240], xmm2

; 25   : 	return	float(v)/(32767.f/12.f);

	movsx	eax, WORD PTR [edx+esi*8+4]
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 499  : 		dest.x = v.x*_11 + v.y*_21 + v.z*_31 + _41;

	movaps	xmm0, xmm2
	mulss	xmm0, DWORD PTR [ecx+ebx+64]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp

; 459  : 			F.weight[k]				= 0.f;

	mov	DWORD PTR _F$5[esp+308], 0

; 92   : 		p.y			= u_P(_P[1]);

	movss	DWORD PTR _F$5[esp+244], xmm5

; 25   : 	return	float(v)/(32767.f/12.f);

	cvtsi2ss xmm1, eax

; 456  : 			vertHW_1W& vert			= vertices[indices[idx+k]];

	mov	eax, DWORD PTR _indices$[esp+224]
	movzx	eax, WORD PTR [eax+edi*2+4]

; 25   : 	return	float(v)/(32767.f/12.f);

	mulss	xmm1, xmm7
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 499  : 		dest.x = v.x*_11 + v.y*_21 + v.z*_31 + _41;

	movaps	xmm7, xmm5
	mulss	xmm7, DWORD PTR [ecx+ebx+80]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp

; 456  : 			vertHW_1W& vert			= vertices[indices[idx+k]];

	lea	esi, DWORD PTR [eax+eax*2]

; 87   : 		return	(u16)color_get_A(_N_I)/3;

	mov	eax, -1431655765			; aaaaaaabH

; 93   : 		p.z			= u_P(_P[2]);

	movss	DWORD PTR _F$5[esp+248], xmm1
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 499  : 		dest.x = v.x*_11 + v.y*_21 + v.z*_31 + _41;

	addss	xmm7, xmm0
	movaps	xmm0, xmm1
	mulss	xmm0, DWORD PTR [ecx+ebx+96]
	addss	xmm0, DWORD PTR [ecx+ebx+112]
	addss	xmm7, xmm0

; 500  : 		dest.y = v.x*_12 + v.y*_22 + v.z*_32 + _42;

	movaps	xmm0, xmm2
	mulss	xmm0, DWORD PTR [ecx+ebx+68]

; 501  : 		dest.z = v.x*_13 + v.y*_23 + v.z*_33 + _43;

	mulss	xmm2, DWORD PTR [ecx+ebx+72]
	movss	DWORD PTR _p$3$[esp+228], xmm7
	movss	DWORD PTR _p$6[esp+240], xmm7
	movaps	xmm7, xmm5
	mulss	xmm7, DWORD PTR [ecx+ebx+84]
	mulss	xmm5, DWORD PTR [ecx+ebx+88]
	addss	xmm7, xmm0
	movaps	xmm0, xmm1
	mulss	xmm0, DWORD PTR [ecx+ebx+100]
	mulss	xmm1, DWORD PTR [ecx+ebx+104]
	addss	xmm5, xmm2
	addss	xmm0, DWORD PTR [ecx+ebx+116]
	addss	xmm1, DWORD PTR [ecx+ebx+120]
; File I:\Vitalya\mine\NSProjectX\xrCore\_color.h

; 20   : ICF	u32 color_get_A (u32 rgba)						{	return ((rgba) >> 24);			}

	movzx	ecx, BYTE PTR [edx+esi*8+11]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp

; 87   : 		return	(u16)color_get_A(_N_I)/3;

	mul	ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 500  : 		dest.y = v.x*_12 + v.y*_22 + v.z*_32 + _42;

	addss	xmm7, xmm0
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp

; 25   : 	return	float(v)/(32767.f/12.f);

	movss	xmm0, DWORD PTR __real@39c00180
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 501  : 		dest.z = v.x*_13 + v.y*_23 + v.z*_33 + _43;

	addss	xmm5, xmm1
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp

; 87   : 		return	(u16)color_get_A(_N_I)/3;

	shr	edx, 1

; 457  : 			F.bone_id[k][0]			= vert.get_bone();

	movzx	eax, dx

; 25   : 	return	float(v)/(32767.f/12.f);

	mov	edx, DWORD PTR _vertices$[esp+228]

; 457  : 			F.bone_id[k][0]			= vert.get_bone();

	mov	WORD PTR _F$5[esp+296], ax

; 458  : 			F.bone_id[k][1]			= F.bone_id[k][0];

	mov	WORD PTR _F$5[esp+298], ax
; File I:\Vitalya\mine\NSProjectX\xrEngine\SkeletonCustom.h

; 243  : 	ICF CBoneInstance& LL_GetBoneInstance(u16 bone_id) { VERIFY(bone_id < LL_BoneCount()); VERIFY(bone_instances); return bone_instances[bone_id]; }

	lea	ecx, DWORD PTR [eax+eax*4]
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 501  : 		dest.z = v.x*_13 + v.y*_23 + v.z*_33 + _43;

	movss	DWORD PTR _p$5$[esp+228], xmm5
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp

; 25   : 	return	float(v)/(32767.f/12.f);

	movsx	eax, WORD PTR [edx+esi*8]
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 501  : 		dest.z = v.x*_13 + v.y*_23 + v.z*_33 + _43;

	movss	DWORD PTR _p$6[esp+248], xmm5
; File I:\Vitalya\mine\NSProjectX\xrEngine\SkeletonCustom.h

; 243  : 	ICF CBoneInstance& LL_GetBoneInstance(u16 bone_id) { VERIFY(bone_id < LL_BoneCount()); VERIFY(bone_instances); return bone_instances[bone_id]; }

	shl	ecx, 5
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 500  : 		dest.y = v.x*_12 + v.y*_22 + v.z*_32 + _42;

	movss	DWORD PTR _p$4$[esp+228], xmm7
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp

; 25   : 	return	float(v)/(32767.f/12.f);

	cvtsi2ss xmm2, eax
	movsx	eax, WORD PTR [edx+esi*8+2]
	cvtsi2ss xmm5, eax
	movsx	eax, WORD PTR [edx+esi*8+4]
	mulss	xmm2, xmm0
	mulss	xmm5, xmm0
	cvtsi2ss xmm1, eax
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 500  : 		dest.y = v.x*_12 + v.y*_22 + v.z*_32 + _42;

	movss	DWORD PTR _p$6[esp+244], xmm7
	movaps	xmm7, xmm5
	mulss	xmm7, DWORD PTR [ecx+ebx+80]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp

; 25   : 	return	float(v)/(32767.f/12.f);

	mulss	xmm1, xmm0
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 499  : 		dest.x = v.x*_11 + v.y*_21 + v.z*_31 + _41;

	movaps	xmm0, xmm2
	mulss	xmm0, DWORD PTR [ecx+ebx+64]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp

; 91   : 		p.x			= u_P(_P[0]);

	movss	DWORD PTR _F$5[esp+252], xmm2

; 92   : 		p.y			= u_P(_P[1]);

	movss	DWORD PTR _F$5[esp+256], xmm5
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 499  : 		dest.x = v.x*_11 + v.y*_21 + v.z*_31 + _41;

	addss	xmm7, xmm0
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp

; 93   : 		p.z			= u_P(_P[2]);

	movss	DWORD PTR _F$5[esp+260], xmm1
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 499  : 		dest.x = v.x*_11 + v.y*_21 + v.z*_31 + _41;

	movaps	xmm0, xmm1
	mulss	xmm0, DWORD PTR [ecx+ebx+96]
	addss	xmm0, DWORD PTR [ecx+ebx+112]
	addss	xmm7, xmm0

; 500  : 		dest.y = v.x*_12 + v.y*_22 + v.z*_32 + _42;

	movaps	xmm0, xmm2
	mulss	xmm0, DWORD PTR [ecx+ebx+68]
	movss	DWORD PTR _p$6$[esp+228], xmm7
	movss	DWORD PTR _p$6[esp+252], xmm7
	movaps	xmm7, xmm5
	mulss	xmm7, DWORD PTR [ecx+ebx+84]
	addss	xmm7, xmm0
	movaps	xmm0, xmm1
	mulss	xmm0, DWORD PTR [ecx+ebx+100]
	addss	xmm0, DWORD PTR [ecx+ebx+116]

; 501  : 		dest.z = v.x*_13 + v.y*_23 + v.z*_33 + _43;

	mulss	xmm2, DWORD PTR [ecx+ebx+72]
	addss	xmm7, xmm0
	mulss	xmm1, DWORD PTR [ecx+ebx+104]
	mulss	xmm5, DWORD PTR [ecx+ebx+88]
	addss	xmm1, DWORD PTR [ecx+ebx+120]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	xmm0, DWORD PTR _p$5$[esp+228]
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 501  : 		dest.z = v.x*_13 + v.y*_23 + v.z*_33 + _43;

	addss	xmm5, xmm2
	movss	DWORD PTR _p$7$[esp+228], xmm7
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	xmm2, DWORD PTR _p$7$[esp+228]
	subss	xmm0, xmm3
	subss	xmm2, DWORD PTR _p$4$[esp+228]
	movss	xmm3, DWORD PTR _p$6$[esp+228]
	subss	xmm3, DWORD PTR _p$3$[esp+228]
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 501  : 		dest.z = v.x*_13 + v.y*_23 + v.z*_33 + _43;

	addss	xmm5, xmm1
	movss	DWORD PTR _p$6[esp+256], xmm7
	movss	xmm7, DWORD PTR _p$3$[esp+228]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	DWORD PTR tv2743[esp+228], xmm0
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 501  : 		dest.z = v.x*_13 + v.y*_23 + v.z*_33 + _43;

	subss	xmm7, xmm4
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 273  : 		x = v1.y  * v2.z  - v1.z  * v2.y ;

	mulss	xmm0, xmm2
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 501  : 		dest.z = v.x*_13 + v.y*_23 + v.z*_33 + _43;

	movss	DWORD PTR _p$8$[esp+228], xmm5
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 273  : 		x = v1.y  * v2.z  - v1.z  * v2.y ;

	movaps	xmm4, xmm3

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	xmm1, DWORD PTR _p$8$[esp+228]
	subss	xmm1, DWORD PTR _p$5$[esp+228]

; 273  : 		x = v1.y  * v2.z  - v1.z  * v2.y ;

	mulss	xmm4, DWORD PTR tv2743[esp+228]
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 501  : 		dest.z = v.x*_13 + v.y*_23 + v.z*_33 + _43;

	movss	DWORD PTR _p$6[esp+260], xmm5
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	xmm5, DWORD PTR _p$4$[esp+228]
	subss	xmm5, xmm6
	movaps	xmm6, xmm5

; 275  : 		z = v1.x  * v2.y  - v1.y  * v2.x ;

	mulss	xmm3, xmm5

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	mulss	xmm6, xmm1

; 273  : 		x = v1.y  * v2.z  - v1.z  * v2.y ;

	subss	xmm6, xmm0

; 274  : 		y = v1.z  * v2.x  - v1.x  * v2.z ;

	movaps	xmm0, xmm7
	mulss	xmm0, xmm1
	movaps	xmm1, xmm7
	mulss	xmm1, xmm2
	subss	xmm4, xmm0

; 200  : 		T magnitude=x*x + y*y + z*z;

	movaps	xmm0, xmm6
	mulss	xmm0, xmm6

; 275  : 		z = v1.x  * v2.y  - v1.y  * v2.x ;

	subss	xmm1, xmm3
	movaps	xmm2, xmm4
	mulss	xmm2, xmm4

; 200  : 		T magnitude=x*x + y*y + z*z;

	addss	xmm2, xmm0
	movaps	xmm0, xmm1
	mulss	xmm0, xmm1
	addss	xmm2, xmm0

; 201  : 		if (magnitude> std::numeric_limits<T>::min()) {

	comiss	xmm2, DWORD PTR __real@00800000
	jbe	SHORT $LN67@FillVertic

; 202  : 			magnitude=_sqrt(1/magnitude);

	movss	xmm0, DWORD PTR __real@3f800000
	divss	xmm0, xmm2
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h

; 764  :             return (float)sqrt(_X);

	sqrtss	xmm0, xmm0
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 202  : 			magnitude=_sqrt(1/magnitude);

	mulss	xmm6, xmm0

; 203  : 			x *= magnitude;

	mulss	xmm4, xmm0

; 204  : 			y *= magnitude;

	mulss	xmm1, xmm0
$LN67@FillVertic:

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	mov	eax, DWORD PTR _normal$[esp+224]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp

; 467  : 		if (cosa<EPS)			continue;

	movss	xmm0, DWORD PTR __real@3727c5ac
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	mulss	xmm4, DWORD PTR [eax+4]
	mulss	xmm6, DWORD PTR [eax]
	mulss	xmm1, DWORD PTR [eax+8]
	addss	xmm4, xmm6
	addss	xmm4, xmm1
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp

; 467  : 		if (cosa<EPS)			continue;

	comiss	xmm0, xmm4
	ja	$LN2@FillVertic
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	xmm0, DWORD PTR tv2743[esp+228]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\cl_intersect.h

; 588  : 		int iInside = 0;

	xor	eax, eax
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	xmm3, DWORD PTR _p$2$[esp+228]
; File I:\Vitalya\mine\NSProjectX\xrEngine\SkeletonCustom.h

; 155  : 	IC const Fvector3& ContactPoint() { return m_ContactPoint; }

	mov	ebx, DWORD PTR _wm$[esp+224]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	xmm1, DWORD PTR _p$1$[esp+228]
; File I:\Vitalya\mine\NSProjectX\xrEngine\SkeletonCustom.h

; 155  : 	IC const Fvector3& ContactPoint() { return m_ContactPoint; }

	lea	ecx, DWORD PTR [ebx+16]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	subss	xmm1, DWORD PTR [ecx+4]
	movss	DWORD PTR _e0$4[esp+236], xmm0
	movss	xmm0, DWORD PTR _p$8$[esp+228]
	subss	xmm0, xmm3
	movss	xmm4, DWORD PTR _p$6$[esp+228]
	subss	xmm3, DWORD PTR [ecx+8]
	movss	xmm2, DWORD PTR _p$7$[esp+228]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\cl_intersect.h

; 583  : 		float fRSqr = sphereRadius*sphereRadius;

	movss	xmm6, DWORD PTR _size$[esp+224]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	subss	xmm4, DWORD PTR tv2633[esp+228]
	movss	DWORD PTR tv2749[esp+228], xmm0
	movss	DWORD PTR _e1$3[esp+236], xmm0
	movss	xmm0, DWORD PTR tv2633[esp+228]
	subss	xmm0, DWORD PTR [ecx]
	subss	xmm2, DWORD PTR _p$1$[esp+228]
	movss	DWORD PTR tv2864[esp+228], xmm1
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\cl_intersect.h

; 583  : 		float fRSqr = sphereRadius*sphereRadius;

	mulss	xmm6, xmm6
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 167  : 		return x*x + y*y + z*z;

	movaps	xmm1, xmm0

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	DWORD PTR tv2863[esp+228], xmm0

; 167  : 		return x*x + y*y + z*z;

	mulss	xmm1, xmm0
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\cl_intersect.h

; 588  : 		int iInside = 0;

	movss	xmm0, DWORD PTR tv2864[esp+228]
	mulss	xmm0, xmm0
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	DWORD PTR _e0$4[esp+228], xmm7
	movss	DWORD PTR _e0$4[esp+232], xmm5

; 167  : 		return x*x + y*y + z*z;

	addss	xmm1, xmm0

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	DWORD PTR _e1$3[esp+228], xmm4

; 167  : 		return x*x + y*y + z*z;

	movaps	xmm0, xmm3

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	DWORD PTR _e1$3[esp+232], xmm2

; 167  : 		return x*x + y*y + z*z;

	mulss	xmm0, xmm3
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\cl_intersect.h

; 583  : 		float fRSqr = sphereRadius*sphereRadius;

	movss	DWORD PTR _fRSqr$2[esp+228], xmm6
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 167  : 		return x*x + y*y + z*z;

	addss	xmm1, xmm0
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\cl_intersect.h

; 591  : 		if ( kV0mC.square_magnitude() <= fRSqr )

	comiss	xmm6, xmm1
	jb	SHORT $LN86@FillVertic

; 592  : 			iInside++;

	mov	eax, 1
$LN86@FillVertic:
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	movss	xmm1, DWORD PTR tv2863[esp+228]
	movaps	xmm0, xmm3
	addss	xmm5, DWORD PTR tv2864[esp+228]
	addss	xmm0, DWORD PTR tv2743[esp+228]
	addss	xmm7, xmm1
	mulss	xmm5, xmm5

; 167  : 		return x*x + y*y + z*z;

	mulss	xmm7, xmm7
	mulss	xmm0, xmm0
	addss	xmm5, xmm7
	addss	xmm5, xmm0
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\cl_intersect.h

; 597  : 		if ( kDiff.square_magnitude() <= fRSqr )

	comiss	xmm6, xmm5
	jb	SHORT $LN87@FillVertic

; 598  : 			iInside++;

	inc	eax
$LN87@FillVertic:
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	addss	xmm2, DWORD PTR tv2864[esp+228]
	addss	xmm3, DWORD PTR tv2749[esp+228]
	addss	xmm4, xmm1
	mulss	xmm2, xmm2

; 167  : 		return x*x + y*y + z*z;

	mulss	xmm4, xmm4
	mulss	xmm3, xmm3
	addss	xmm2, xmm4
	addss	xmm2, xmm3
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\cl_intersect.h

; 602  : 		if ( kDiff.square_magnitude() <= fRSqr )

	comiss	xmm6, xmm2
	jb	SHORT $LN88@FillVertic

; 603  : 			iInside++;

	inc	eax
$LN88@FillVertic:

; 604  : 
; 605  : 		// triangle does not traversely intersect sphere
; 606  : 		if ( iInside == 3 ) return stInside;

	cmp	eax, 3
	je	SHORT $LN137@FillVertic

; 607  : 
; 608  : 		// triangle transversely intersects sphere
; 609  : 		if ( iInside > 0 ) return stIntersect;

	test	eax, eax
	jne	SHORT $LN137@FillVertic

; 610  : 
; 611  : 		// All vertices are outside the sphere, but the triangle might still
; 612  : 		// intersect the sphere.  This is the case when the distance from the
; 613  : 		// sphere center to the triangle is smaller than the radius.
; 614  : 		float fSqrDist = MgcSqrDistance(sphereOrigin,orig,e0,e1);

	lea	eax, DWORD PTR _e1$3[esp+228]
	push	eax
	lea	eax, DWORD PTR _e0$4[esp+232]
	push	eax
	lea	edx, DWORD PTR _p$6[esp+236]
	call	?MgcSqrDistance@CDB@@YAMABU?$_vector3@M@@000@Z ; CDB::MgcSqrDistance

; 615  : 		return (fSqrDist < fRSqr)?stIntersect:stNone;

	fld	DWORD PTR _fRSqr$2[esp+236]
	add	esp, 8
	fcomip	ST(1)
	fstp	ST(0)
	jbe	$LN138@FillVertic
$LN137@FillVertic:
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 499  : 		dest.x = v.x*_11 + v.y*_21 + v.z*_31 + _41;

	movss	xmm3, DWORD PTR [ebp+16]
	movss	xmm0, DWORD PTR [ebp]
	movaps	xmm1, xmm3
	mulss	xmm0, DWORD PTR tv2633[esp+228]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 730  :         if (_Mylast != _My_data._Myend) {

	mov	edx, DWORD PTR [ebx+52]
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 499  : 		dest.x = v.x*_11 + v.y*_21 + v.z*_31 + _41;

	mulss	xmm1, DWORD PTR _p$1$[esp+228]
	movss	xmm4, DWORD PTR [ebp+32]
	movss	xmm2, DWORD PTR [ebp+48]
	addss	xmm1, xmm0

; 500  : 		dest.y = v.x*_12 + v.y*_22 + v.z*_32 + _42;

	movss	xmm6, DWORD PTR [ebp+20]
	movaps	xmm0, xmm4
	movss	xmm7, DWORD PTR [ebp+36]
	mulss	xmm0, DWORD PTR _p$2$[esp+228]
	movss	xmm5, DWORD PTR [ebp+52]
	addss	xmm0, xmm2
	addss	xmm1, xmm0
	movss	xmm0, DWORD PTR [ebp+4]
	mulss	xmm0, DWORD PTR tv2633[esp+228]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp

; 474  : 				uv.x			= (1+UV.x)*.5f;

	addss	xmm1, DWORD PTR __real@3f800000
	mulss	xmm1, DWORD PTR __real@3f000000
	movss	DWORD PTR _F$5[esp+264], xmm1
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 500  : 		dest.y = v.x*_12 + v.y*_22 + v.z*_32 + _42;

	movaps	xmm1, xmm6
	mulss	xmm1, DWORD PTR _p$1$[esp+228]
	addss	xmm1, xmm0
	movaps	xmm0, xmm7
	mulss	xmm0, DWORD PTR _p$2$[esp+228]
	addss	xmm0, xmm5
	addss	xmm1, xmm0
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp

; 474  : 				uv.x			= (1+UV.x)*.5f;

	movss	xmm0, DWORD PTR __real@3f800000
	subss	xmm0, xmm1
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 499  : 		dest.x = v.x*_11 + v.y*_21 + v.z*_31 + _41;

	movaps	xmm1, xmm3
	mulss	xmm1, DWORD PTR _p$4$[esp+228]
	mulss	xmm3, DWORD PTR _p$7$[esp+228]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp

; 475  : 				uv.y			= (1-UV.y)*.5f;

	mulss	xmm0, DWORD PTR __real@3f000000
	movss	DWORD PTR _F$5[esp+268], xmm0
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 499  : 		dest.x = v.x*_11 + v.y*_21 + v.z*_31 + _41;

	movss	xmm0, DWORD PTR [ebp]
	mulss	xmm0, DWORD PTR _p$3$[esp+228]
	addss	xmm1, xmm0
	movaps	xmm0, xmm4
	mulss	xmm0, DWORD PTR _p$5$[esp+228]
	mulss	xmm4, DWORD PTR _p$8$[esp+228]
	addss	xmm0, xmm2
	addss	xmm4, xmm2

; 500  : 		dest.y = v.x*_12 + v.y*_22 + v.z*_32 + _42;

	addss	xmm1, xmm0
	movss	xmm0, DWORD PTR [ebp+4]
	mulss	xmm0, DWORD PTR _p$3$[esp+228]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp

; 474  : 				uv.x			= (1+UV.x)*.5f;

	addss	xmm1, DWORD PTR __real@3f800000
	mulss	xmm1, DWORD PTR __real@3f000000
	movss	DWORD PTR _F$5[esp+272], xmm1
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 500  : 		dest.y = v.x*_12 + v.y*_22 + v.z*_32 + _42;

	movaps	xmm1, xmm6
	mulss	xmm1, DWORD PTR _p$4$[esp+228]
	mulss	xmm6, DWORD PTR _p$7$[esp+228]
	addss	xmm1, xmm0
	movaps	xmm0, xmm7
	mulss	xmm0, DWORD PTR _p$5$[esp+228]
	mulss	xmm7, DWORD PTR _p$8$[esp+228]
	addss	xmm0, xmm5
	addss	xmm7, xmm5
	addss	xmm1, xmm0
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp

; 474  : 				uv.x			= (1+UV.x)*.5f;

	movss	xmm0, DWORD PTR __real@3f800000
	subss	xmm0, xmm1
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 500  : 		dest.y = v.x*_12 + v.y*_22 + v.z*_32 + _42;

	movss	xmm1, DWORD PTR [ebp+4]
	mulss	xmm1, DWORD PTR _p$6$[esp+228]
	addss	xmm1, xmm6
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp

; 475  : 				uv.y			= (1-UV.y)*.5f;

	mulss	xmm0, DWORD PTR __real@3f000000
	movss	DWORD PTR _F$5[esp+276], xmm0
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 500  : 		dest.y = v.x*_12 + v.y*_22 + v.z*_32 + _42;

	addss	xmm1, xmm7
	movss	xmm0, DWORD PTR [ebp]
	mulss	xmm0, DWORD PTR _p$6$[esp+228]
	addss	xmm0, xmm3
	addss	xmm0, xmm4
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp

; 474  : 				uv.x			= (1+UV.x)*.5f;

	addss	xmm0, DWORD PTR __real@3f800000
	mulss	xmm0, DWORD PTR __real@3f000000
	movss	DWORD PTR _F$5[esp+280], xmm0
	movss	xmm0, DWORD PTR __real@3f800000
	subss	xmm0, xmm1

; 475  : 				uv.y			= (1-UV.y)*.5f;

	mulss	xmm0, DWORD PTR __real@3f000000
	movss	DWORD PTR _F$5[esp+284], xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 730  :         if (_Mylast != _My_data._Myend) {

	cmp	edx, DWORD PTR [ebx+56]
	je	SHORT $LN111@FillVertic
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	ecx, 21					; 00000015H
	lea	esi, DWORD PTR _F$5[esp+228]
	mov	edi, edx
	rep movsd
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 716  :         ++_Mylast;

	add	DWORD PTR [ebx+52], 84			; 00000054H

; 731  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

	jmp	SHORT $LN138@FillVertic
$LN111@FillVertic:

; 732  :         }
; 733  : 
; 734  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	lea	ecx, DWORD PTR _F$5[esp+228]
	push	ecx
	push	edx
	lea	ecx, DWORD PTR [ebx+48]
	call	??$_Emplace_reallocate@ABUWMFace@CSkeletonWallmark@@@?$vector@UWMFace@CSkeletonWallmark@@V?$xalloc@UWMFace@CSkeletonWallmark@@@@@std@@QAEPAUWMFace@CSkeletonWallmark@@QAU23@ABU23@@Z ; std::vector<CSkeletonWallmark::WMFace,xalloc<CSkeletonWallmark::WMFace> >::_Emplace_reallocate<CSkeletonWallmark::WMFace const &>
$LN138@FillVertic:

; 74   :         ++_Ptr;

	mov	edx, DWORD PTR _vertices$[esp+228]
$LN2@FillVertic:
	mov	eax, DWORD PTR _it$1$[esp+228]

; 150  :         return _Ptr == _Right._Ptr;

	mov	ecx, DWORD PTR _faces$[esp+224]

; 74   :         ++_Ptr;

	add	eax, 2
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp

; 451  : 	for (CBoneData::FacesVecIt it=faces.begin(); it!=faces.end(); it++){

	movss	xmm7, DWORD PTR __real@39c00180
	mov	ebx, DWORD PTR _this$1$[esp+228]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 74   :         ++_Ptr;

	mov	DWORD PTR _it$1$[esp+228], eax

; 150  :         return _Ptr == _Right._Ptr;

	cmp	eax, DWORD PTR [ecx+4]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp

; 451  : 	for (CBoneData::FacesVecIt it=faces.begin(); it!=faces.end(); it++){

	jne	$LL4@FillVertic
	pop	edi
	pop	ebp
$LN3@FillVertic:

; 476  : 			}
; 477  : 			wm.m_Faces.push_back(F);
; 478  : 		}
; 479  : 	}
; 480  : 	CHK_DX				(V->p_rm_Vertices->Unlock());

	mov	eax, DWORD PTR _V$[esp+216]
	mov	eax, DWORD PTR [eax+76]
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+48]
	pop	esi
	pop	ebx

; 481  : }

	add	esp, 212				; 000000d4H
	ret	28					; 0000001cH
?_FillVerticesHW1W@CSkeletonX_ext@@MAEXABU?$_matrix@M@@AAVCSkeletonWallmark@@ABU?$_vector3@M@@MPAVFvisual@@PAGAAV?$xr_vector@GV?$xalloc@G@@@@@Z ENDP ; CSkeletonX_ext::_FillVerticesHW1W
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp
; File I:\Vitalya\mine\NSProjectX\xrEngine\SkeletonCustom.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp
; File I:\Vitalya\mine\NSProjectX\xrEngine\SkeletonCustom.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp
; File I:\Vitalya\mine\NSProjectX\xrEngine\SkeletonCustom.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\cl_intersect.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrEngine\SkeletonCustom.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrEngine\SkeletonCustom.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\cl_intersect.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\cl_intersect.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\cl_intersect.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\cl_intersect.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\cl_intersect.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\cl_intersect.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp
_TEXT	SEGMENT
tv2689 = -216						; size = 4
tv2578 = -216						; size = 4
_p$6$ = -212						; size = 4
tv2706 = -212						; size = 4
_p$7$ = -208						; size = 4
tv2687 = -208						; size = 4
_p$8$ = -204						; size = 4
tv2688 = -204						; size = 4
tv2579 = -200						; size = 4
_p$4$ = -196						; size = 4
tv2581 = -192						; size = 4
tv2577 = -192						; size = 4
_p$2$ = -188						; size = 4
_p$1$ = -184						; size = 4
_p$3$ = -180						; size = 4
_p$5$ = -176						; size = 4
_p$9$ = -172						; size = 4
_it$1$ = -168						; size = 4
_vertices$ = -164					; size = 4
tv2583 = -160						; size = 4
tv2585 = -156						; size = 4
_fRSqr$2 = -152						; size = 4
_this$1$ = -148						; size = 4
_p$3 = -144						; size = 36
_e1$4 = -108						; size = 12
_e0$5 = -96						; size = 12
_F$6 = -84						; size = 84
_view$ = 8						; size = 4
_wm$ = 12						; size = 4
_normal$ = 16						; size = 4
_size$ = 20						; size = 4
_V$ = 24						; size = 4
_indices$ = 28						; size = 4
_faces$ = 32						; size = 4
?_FillVerticesHW2W@CSkeletonX_ext@@MAEXABU?$_matrix@M@@AAVCSkeletonWallmark@@ABU?$_vector3@M@@MPAVFvisual@@PAGAAV?$xr_vector@GV?$xalloc@G@@@@@Z PROC ; CSkeletonX_ext::_FillVerticesHW2W
; _this$ = ecx

; 483  : {

	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	mov	ebx, ecx

; 484  : 	vertHW_2W* vertices;
; 485  : 	CHK_DX				(V->p_rm_Vertices->Lock(V->vBase,V->vCount,(void**)&vertices,D3DLOCK_READONLY));

	lea	esi, DWORD PTR _vertices$[esp+224]
	mov	ecx, DWORD PTR _V$[esp+220]
	push	16					; 00000010H
	push	esi
	mov	DWORD PTR _this$1$[esp+232], ebx
	mov	eax, DWORD PTR [ecx+76]
	push	DWORD PTR [ecx+84]
	push	DWORD PTR [ecx+80]
	mov	edx, DWORD PTR [eax]
	push	eax
	call	DWORD PTR [edx+44]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	ecx, DWORD PTR _faces$[esp+220]
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR _it$1$[esp+224], eax

; 150  :         return _Ptr == _Right._Ptr;

	cmp	eax, DWORD PTR [ecx+4]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp

; 486  : 	for (CBoneData::FacesVecIt it=faces.begin(); it!=faces.end(); it++){

	je	$LN3@FillVertic
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 500  : 		dest.y = v.x*_12 + v.y*_22 + v.z*_32 + _42;

	movss	xmm1, DWORD PTR __real@39c00180
	movss	xmm4, DWORD PTR __real@3f800000
	push	ebp
	push	edi
	npad	13
$LL4@FillVertic:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp

; 496  : 			Fmatrix& xform0			= Parent->LL_GetBoneInstance(F.bone_id[k][0]).mRenderTransform; 

	mov	ecx, DWORD PTR [ebx+4]
	movzx	eax, WORD PTR [eax]
	mov	DWORD PTR tv2687[esp+232], 0
	mov	DWORD PTR tv2706[esp+232], 3
	mov	ebp, DWORD PTR [ecx+120]
	lea	ecx, DWORD PTR _F$6[esp+294]
	mov	DWORD PTR tv2689[esp+232], ecx
	lea	eax, DWORD PTR [eax+eax*2]
	mov	ecx, DWORD PTR _indices$[esp+228]
	lea	ecx, DWORD PTR [ecx+eax*2]
	mov	DWORD PTR tv2688[esp+232], ecx
	npad	11
$LL7@FillVertic:

; 491  : 			Fvector		P0,P1;
; 492  : 			vertHW_2W& vert			= vertices[indices[idx+k]];

	movzx	eax, WORD PTR [ecx]
	mov	edi, DWORD PTR _vertices$[esp+232]
	lea	ebx, DWORD PTR [eax*8]
	sub	ebx, eax

; 136  : 		return	(u16)_tc_i[w+2]/3;

	mov	eax, -1431655765			; aaaaaaabH
	movzx	ecx, WORD PTR [edi+ebx*4+24]
	mul	ecx

; 493  : 			F.bone_id[k][0]			= vert.get_bone(0);

	mov	eax, DWORD PTR tv2689[esp+232]

; 136  : 		return	(u16)_tc_i[w+2]/3;

	movzx	ecx, WORD PTR [edi+ebx*4+26]
	shr	edx, 1

; 493  : 			F.bone_id[k][0]			= vert.get_bone(0);

	movzx	esi, dx
	mov	WORD PTR [eax-2], si

; 136  : 		return	(u16)_tc_i[w+2]/3;

	mov	eax, -1431655765			; aaaaaaabH
	mul	ecx

; 132  : 		return	float(color_get_A(_N_w))/255.f;

	movzx	eax, BYTE PTR [edi+ebx*4+11]

; 136  : 		return	(u16)_tc_i[w+2]/3;

	shr	edx, 1

; 494  : 			F.bone_id[k][1]			= vert.get_bone(1);

	movzx	ecx, dx
	mov	edx, DWORD PTR tv2689[esp+232]

; 132  : 		return	float(color_get_A(_N_w))/255.f;

	cvtsi2ss xmm0, eax
; File I:\Vitalya\mine\NSProjectX\xrEngine\SkeletonCustom.h

; 243  : 	ICF CBoneInstance& LL_GetBoneInstance(u16 bone_id) { VERIFY(bone_id < LL_BoneCount()); VERIFY(bone_instances); return bone_instances[bone_id]; }

	mov	eax, esi
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp

; 140  : 		p.x			= u_P(_P[0]);

	mov	esi, DWORD PTR tv2687[esp+232]

; 494  : 			F.bone_id[k][1]			= vert.get_bone(1);

	mov	WORD PTR [edx], cx

; 132  : 		return	float(color_get_A(_N_w))/255.f;

	mulss	xmm0, DWORD PTR __real@3b808081

; 495  : 			F.weight[k]				= vert.get_weight();

	movss	DWORD PTR [edx+10], xmm0
; File I:\Vitalya\mine\NSProjectX\xrEngine\SkeletonCustom.h

; 243  : 	ICF CBoneInstance& LL_GetBoneInstance(u16 bone_id) { VERIFY(bone_id < LL_BoneCount()); VERIFY(bone_instances); return bone_instances[bone_id]; }

	lea	edx, DWORD PTR [eax+eax*4]
	mov	eax, ecx
	shl	edx, 5
	lea	ecx, DWORD PTR [eax+eax*4]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp

; 25   : 	return	float(v)/(32767.f/12.f);

	movsx	eax, WORD PTR [edi+ebx*4]
; File I:\Vitalya\mine\NSProjectX\xrEngine\SkeletonCustom.h

; 243  : 	ICF CBoneInstance& LL_GetBoneInstance(u16 bone_id) { VERIFY(bone_id < LL_BoneCount()); VERIFY(bone_instances); return bone_instances[bone_id]; }

	shl	ecx, 5
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp

; 25   : 	return	float(v)/(32767.f/12.f);

	cvtsi2ss xmm7, eax
	movsx	eax, WORD PTR [edi+ebx*4+2]
	cvtsi2ss xmm6, eax
	movsx	eax, WORD PTR [edi+ebx*4+4]
	mulss	xmm7, xmm1
	mulss	xmm6, xmm1
	cvtsi2ss xmm5, eax

; 497  : 			Fmatrix& xform1			= Parent->LL_GetBoneInstance(F.bone_id[k][1]).mRenderTransform; 
; 498  : 			vert.get_pos			(F.vert[k]);		
; 499  : 			xform0.transform_tiny	(P0,F.vert[k]);
; 500  : 			xform1.transform_tiny	(P1,F.vert[k]);
; 501  : 			p[k].lerp				(P0,P1,F.weight[k]);

	mov	eax, DWORD PTR tv2689[esp+232]
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 499  : 		dest.x = v.x*_11 + v.y*_21 + v.z*_31 + _41;

	movaps	xmm0, xmm7
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp

; 140  : 		p.x			= u_P(_P[0]);

	movss	DWORD PTR _F$6[esp+esi+232], xmm7
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 499  : 		dest.x = v.x*_11 + v.y*_21 + v.z*_31 + _41;

	mulss	xmm0, DWORD PTR [edx+ebp+64]
	movaps	xmm2, xmm6
	mulss	xmm2, DWORD PTR [edx+ebp+80]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp

; 25   : 	return	float(v)/(32767.f/12.f);

	mulss	xmm5, xmm1
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 499  : 		dest.x = v.x*_11 + v.y*_21 + v.z*_31 + _41;

	movaps	xmm1, xmm6
	addss	xmm2, xmm0
	mulss	xmm1, DWORD PTR [ecx+ebp+80]
	movaps	xmm0, xmm5
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp

; 141  : 		p.y			= u_P(_P[1]);

	movss	DWORD PTR _F$6[esp+esi+236], xmm6
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 499  : 		dest.x = v.x*_11 + v.y*_21 + v.z*_31 + _41;

	mulss	xmm0, DWORD PTR [edx+ebp+96]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp

; 142  : 		p.z			= u_P(_P[2]);

	movss	DWORD PTR _F$6[esp+esi+240], xmm5

; 497  : 			Fmatrix& xform1			= Parent->LL_GetBoneInstance(F.bone_id[k][1]).mRenderTransform; 
; 498  : 			vert.get_pos			(F.vert[k]);		
; 499  : 			xform0.transform_tiny	(P0,F.vert[k]);
; 500  : 			xform1.transform_tiny	(P1,F.vert[k]);
; 501  : 			p[k].lerp				(P0,P1,F.weight[k]);

	movss	xmm3, DWORD PTR [eax+10]
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 499  : 		dest.x = v.x*_11 + v.y*_21 + v.z*_31 + _41;

	addss	xmm0, DWORD PTR [edx+ebp+112]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 127  : 		T invt = 1.f-t;

	subss	xmm4, xmm3
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 499  : 		dest.x = v.x*_11 + v.y*_21 + v.z*_31 + _41;

	addss	xmm2, xmm0
	movaps	xmm0, xmm7
	mulss	xmm0, DWORD PTR [ecx+ebp+64]
	addss	xmm1, xmm0
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 128  : 		x = p1.x*invt + p2.x*t;

	mulss	xmm2, xmm4
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 499  : 		dest.x = v.x*_11 + v.y*_21 + v.z*_31 + _41;

	movaps	xmm0, xmm5
	mulss	xmm0, DWORD PTR [ecx+ebp+96]
	addss	xmm0, DWORD PTR [ecx+ebp+112]
	addss	xmm1, xmm0

; 500  : 		dest.y = v.x*_12 + v.y*_22 + v.z*_32 + _42;

	movaps	xmm0, xmm7
	mulss	xmm0, DWORD PTR [ecx+ebp+68]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 127  : 		T invt = 1.f-t;

	mulss	xmm1, xmm3

; 128  : 		x = p1.x*invt + p2.x*t;

	addss	xmm2, xmm1
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 500  : 		dest.y = v.x*_12 + v.y*_22 + v.z*_32 + _42;

	movaps	xmm1, xmm6
	mulss	xmm1, DWORD PTR [edx+ebp+84]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 128  : 		x = p1.x*invt + p2.x*t;

	movss	DWORD PTR _p$3[esp+esi+232], xmm2
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 500  : 		dest.y = v.x*_12 + v.y*_22 + v.z*_32 + _42;

	movaps	xmm2, xmm6
	mulss	xmm2, DWORD PTR [ecx+ebp+84]
	addss	xmm2, xmm0
	movaps	xmm0, xmm5
	mulss	xmm0, DWORD PTR [ecx+ebp+100]
	addss	xmm0, DWORD PTR [ecx+ebp+116]
	addss	xmm2, xmm0
	movaps	xmm0, xmm7
	mulss	xmm0, DWORD PTR [edx+ebp+68]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 128  : 		x = p1.x*invt + p2.x*t;

	mulss	xmm2, xmm3
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 500  : 		dest.y = v.x*_12 + v.y*_22 + v.z*_32 + _42;

	addss	xmm1, xmm0
	movaps	xmm0, xmm5
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp

; 490  : 		for (u32 k=0; k<3; k++){

	add	eax, 4
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 500  : 		dest.y = v.x*_12 + v.y*_22 + v.z*_32 + _42;

	mulss	xmm0, DWORD PTR [edx+ebp+100]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp

; 490  : 		for (u32 k=0; k<3; k++){

	mov	DWORD PTR tv2689[esp+232], eax
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 500  : 		dest.y = v.x*_12 + v.y*_22 + v.z*_32 + _42;

	addss	xmm0, DWORD PTR [edx+ebp+116]
	addss	xmm1, xmm0

; 501  : 		dest.z = v.x*_13 + v.y*_23 + v.z*_33 + _43;

	movaps	xmm0, xmm7
	mulss	xmm0, DWORD PTR [ecx+ebp+72]
	mulss	xmm7, DWORD PTR [edx+ebp+72]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 129  : 		y = p1.y*invt + p2.y*t;

	mulss	xmm1, xmm4
	addss	xmm2, xmm1
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 501  : 		dest.z = v.x*_13 + v.y*_23 + v.z*_33 + _43;

	movaps	xmm1, xmm6
	mulss	xmm1, DWORD PTR [ecx+ebp+88]
	mulss	xmm6, DWORD PTR [edx+ebp+88]
	addss	xmm1, xmm0
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 129  : 		y = p1.y*invt + p2.y*t;

	movss	DWORD PTR _p$3[esp+esi+236], xmm2
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 501  : 		dest.z = v.x*_13 + v.y*_23 + v.z*_33 + _43;

	movaps	xmm0, xmm5
	mulss	xmm5, DWORD PTR [edx+ebp+104]
	mulss	xmm0, DWORD PTR [ecx+ebp+104]
	addss	xmm6, xmm7
	addss	xmm5, DWORD PTR [edx+ebp+120]
	addss	xmm0, DWORD PTR [ecx+ebp+120]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp

; 490  : 		for (u32 k=0; k<3; k++){

	mov	ecx, DWORD PTR tv2688[esp+232]
	add	ecx, 2
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 501  : 		dest.z = v.x*_13 + v.y*_23 + v.z*_33 + _43;

	addss	xmm6, xmm5
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp

; 490  : 		for (u32 k=0; k<3; k++){

	mov	DWORD PTR tv2688[esp+232], ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 501  : 		dest.z = v.x*_13 + v.y*_23 + v.z*_33 + _43;

	addss	xmm1, xmm0
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 130  : 		z = p1.z*invt + p2.z*t;

	mulss	xmm6, xmm4
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp

; 490  : 		for (u32 k=0; k<3; k++){

	movss	xmm4, DWORD PTR __real@3f800000
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 129  : 		y = p1.y*invt + p2.y*t;

	mulss	xmm1, xmm3

; 130  : 		z = p1.z*invt + p2.z*t;

	addss	xmm1, xmm6
	movss	DWORD PTR _p$3[esp+esi+240], xmm1
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp

; 490  : 		for (u32 k=0; k<3; k++){

	add	esi, 12					; 0000000cH
	sub	DWORD PTR tv2706[esp+232], 1
	movss	xmm1, DWORD PTR __real@39c00180
	mov	DWORD PTR tv2687[esp+232], esi
	jne	$LL7@FillVertic
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	xmm0, DWORD PTR _p$3[esp+248]
	movss	xmm5, DWORD PTR _p$3[esp+252]
	movaps	xmm4, xmm0
	movss	xmm2, DWORD PTR _p$3[esp+240]
	movss	xmm1, DWORD PTR _p$3[esp+244]
	movss	DWORD PTR _p$3$[esp+232], xmm0
	movaps	xmm6, xmm1
	movss	xmm0, DWORD PTR _p$3[esp+236]
	subss	xmm4, xmm0
	movss	DWORD PTR _p$4$[esp+232], xmm0
	movss	xmm7, DWORD PTR _p$3[esp+232]
	movaps	xmm0, xmm5
	subss	xmm0, xmm2
	movss	DWORD PTR _p$1$[esp+232], xmm1
	movss	DWORD PTR _p$6$[esp+232], xmm2
	subss	xmm6, xmm7
	movss	DWORD PTR _p$5$[esp+232], xmm5
	movss	DWORD PTR tv2578[esp+232], xmm4
	movss	DWORD PTR _p$2$[esp+232], xmm7
	movss	DWORD PTR tv2579[esp+232], xmm0
	movss	xmm0, DWORD PTR _p$3[esp+256]
	movaps	xmm3, xmm0
	movss	DWORD PTR _p$7$[esp+232], xmm0
	movss	xmm0, DWORD PTR _p$3[esp+260]
	subss	xmm3, xmm1
	movaps	xmm2, xmm0
	movss	DWORD PTR _p$8$[esp+232], xmm0
	movss	xmm0, DWORD PTR _p$3[esp+264]
	subss	xmm2, DWORD PTR _p$3[esp+248]
	movaps	xmm1, xmm0
	movss	DWORD PTR _p$9$[esp+232], xmm0
	subss	xmm1, xmm5
	movss	DWORD PTR tv2577[esp+232], xmm6
	movaps	xmm5, xmm4

; 273  : 		x = v1.y  * v2.z  - v1.z  * v2.y ;

	movss	xmm4, DWORD PTR tv2579[esp+232]
	movaps	xmm0, xmm4
	mulss	xmm4, xmm3
	mulss	xmm0, xmm2

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	mulss	xmm5, xmm1

; 273  : 		x = v1.y  * v2.z  - v1.z  * v2.y ;

	subss	xmm5, xmm0

; 274  : 		y = v1.z  * v2.x  - v1.x  * v2.z ;

	movaps	xmm0, xmm6
	mulss	xmm0, xmm1
	mulss	xmm6, xmm2
	subss	xmm4, xmm0

; 275  : 		z = v1.x  * v2.y  - v1.y  * v2.x ;

	movss	xmm0, DWORD PTR tv2578[esp+232]
	mulss	xmm0, xmm3
	subss	xmm6, xmm0
	movaps	xmm1, xmm4

; 200  : 		T magnitude=x*x + y*y + z*z;

	movaps	xmm0, xmm5

; 275  : 		z = v1.x  * v2.y  - v1.y  * v2.x ;

	mulss	xmm1, xmm4

; 200  : 		T magnitude=x*x + y*y + z*z;

	mulss	xmm0, xmm5
	addss	xmm1, xmm0
	movaps	xmm0, xmm6
	mulss	xmm0, xmm6
	addss	xmm1, xmm0

; 201  : 		if (magnitude> std::numeric_limits<T>::min()) {

	comiss	xmm1, DWORD PTR __real@00800000
	jbe	SHORT $LN83@FillVertic

; 202  : 			magnitude=_sqrt(1/magnitude);

	movss	xmm0, DWORD PTR __real@3f800000
	divss	xmm0, xmm1
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h

; 764  :             return (float)sqrt(_X);

	sqrtss	xmm1, xmm0
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 202  : 			magnitude=_sqrt(1/magnitude);

	movaps	xmm0, xmm1

; 203  : 			x *= magnitude;
; 204  : 			y *= magnitude;

	mulss	xmm6, xmm1
	mulss	xmm5, xmm0
	mulss	xmm4, xmm0
$LN83@FillVertic:

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	mov	eax, DWORD PTR _normal$[esp+228]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp

; 506  : 		if (cosa<EPS)			continue;

	movss	xmm0, DWORD PTR __real@3727c5ac
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	mulss	xmm4, DWORD PTR [eax+4]
	mulss	xmm5, DWORD PTR [eax]
	mulss	xmm6, DWORD PTR [eax+8]
	addss	xmm4, xmm5
	addss	xmm4, xmm6
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp

; 506  : 		if (cosa<EPS)			continue;

	comiss	xmm0, xmm4
	ja	$LN152@FillVertic
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	xmm0, DWORD PTR tv2578[esp+232]
	movaps	xmm4, xmm7
	movss	xmm3, DWORD PTR _p$9$[esp+232]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\cl_intersect.h

; 588  : 		int iInside = 0;

	xor	eax, eax
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	subss	xmm3, DWORD PTR _p$6$[esp+232]
; File I:\Vitalya\mine\NSProjectX\xrEngine\SkeletonCustom.h

; 155  : 	IC const Fvector3& ContactPoint() { return m_ContactPoint; }

	mov	ebx, DWORD PTR _wm$[esp+228]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	xmm2, DWORD PTR tv2577[esp+232]
; File I:\Vitalya\mine\NSProjectX\xrEngine\SkeletonCustom.h

; 155  : 	IC const Fvector3& ContactPoint() { return m_ContactPoint; }

	lea	ecx, DWORD PTR [ebx+16]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	subss	xmm4, DWORD PTR [ecx]
	movss	xmm5, DWORD PTR _p$6$[esp+232]
	subss	xmm5, DWORD PTR [ecx+8]
	movss	DWORD PTR _e0$5[esp+236], xmm0
	movss	xmm0, DWORD PTR tv2579[esp+232]
	movss	DWORD PTR _e0$5[esp+240], xmm0
	movss	xmm0, DWORD PTR _p$7$[esp+232]
	subss	xmm0, xmm7
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\cl_intersect.h

; 583  : 		float fRSqr = sphereRadius*sphereRadius;

	movss	xmm6, DWORD PTR _size$[esp+228]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	DWORD PTR tv2585[esp+232], xmm3
	movss	DWORD PTR _e1$4[esp+240], xmm3
	movss	xmm3, DWORD PTR _p$4$[esp+232]
	subss	xmm3, DWORD PTR [ecx+4]
	movss	DWORD PTR tv2581[esp+232], xmm0
	movss	DWORD PTR _e1$4[esp+232], xmm0
	movss	xmm0, DWORD PTR _p$8$[esp+232]
	subss	xmm0, DWORD PTR _p$4$[esp+232]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\cl_intersect.h

; 588  : 		int iInside = 0;

	movaps	xmm1, xmm3
	mulss	xmm6, xmm6
	mulss	xmm1, xmm3
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	DWORD PTR tv2583[esp+232], xmm0
	movss	DWORD PTR _e1$4[esp+236], xmm0

; 167  : 		return x*x + y*y + z*z;

	movaps	xmm0, xmm4
	mulss	xmm0, xmm4

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	DWORD PTR _e0$5[esp+232], xmm2
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\cl_intersect.h

; 583  : 		float fRSqr = sphereRadius*sphereRadius;

	movss	DWORD PTR _fRSqr$2[esp+232], xmm6
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 167  : 		return x*x + y*y + z*z;

	addss	xmm1, xmm0
	movaps	xmm0, xmm5
	mulss	xmm0, xmm5
	addss	xmm1, xmm0
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\cl_intersect.h

; 591  : 		if ( kV0mC.square_magnitude() <= fRSqr )

	comiss	xmm6, xmm1
	jb	SHORT $LN102@FillVertic

; 592  : 			iInside++;

	mov	eax, 1
$LN102@FillVertic:
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	movaps	xmm1, xmm4
	movaps	xmm0, xmm5
	addss	xmm0, DWORD PTR tv2579[esp+232]
	addss	xmm1, xmm2
	movaps	xmm2, xmm3
	addss	xmm2, DWORD PTR tv2578[esp+232]

; 167  : 		return x*x + y*y + z*z;

	mulss	xmm0, xmm0

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	mulss	xmm2, xmm2

; 167  : 		return x*x + y*y + z*z;

	mulss	xmm1, xmm1
	addss	xmm2, xmm1
	addss	xmm2, xmm0
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\cl_intersect.h

; 597  : 		if ( kDiff.square_magnitude() <= fRSqr )

	comiss	xmm6, xmm2
	jb	SHORT $LN103@FillVertic

; 598  : 			iInside++;

	inc	eax
$LN103@FillVertic:
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	addss	xmm3, DWORD PTR tv2583[esp+232]
	addss	xmm4, DWORD PTR tv2581[esp+232]
	addss	xmm5, DWORD PTR tv2585[esp+232]
	mulss	xmm3, xmm3

; 167  : 		return x*x + y*y + z*z;

	mulss	xmm4, xmm4
	mulss	xmm5, xmm5
	addss	xmm3, xmm4
	addss	xmm3, xmm5
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\cl_intersect.h

; 602  : 		if ( kDiff.square_magnitude() <= fRSqr )

	comiss	xmm6, xmm3
	jb	SHORT $LN104@FillVertic

; 603  : 			iInside++;

	inc	eax
$LN104@FillVertic:

; 604  : 
; 605  : 		// triangle does not traversely intersect sphere
; 606  : 		if ( iInside == 3 ) return stInside;

	cmp	eax, 3
	je	SHORT $LN150@FillVertic

; 607  : 
; 608  : 		// triangle transversely intersects sphere
; 609  : 		if ( iInside > 0 ) return stIntersect;

	test	eax, eax
	jne	SHORT $LN150@FillVertic

; 610  : 
; 611  : 		// All vertices are outside the sphere, but the triangle might still
; 612  : 		// intersect the sphere.  This is the case when the distance from the
; 613  : 		// sphere center to the triangle is smaller than the radius.
; 614  : 		float fSqrDist = MgcSqrDistance(sphereOrigin,orig,e0,e1);

	lea	eax, DWORD PTR _e1$4[esp+232]
	push	eax
	lea	eax, DWORD PTR _e0$5[esp+236]
	push	eax
	lea	edx, DWORD PTR _p$3[esp+240]
	call	?MgcSqrDistance@CDB@@YAMABU?$_vector3@M@@000@Z ; CDB::MgcSqrDistance

; 615  : 		return (fSqrDist < fRSqr)?stIntersect:stNone;

	fld	DWORD PTR _fRSqr$2[esp+240]
	add	esp, 8
	fcomip	ST(1)
	fstp	ST(0)
	jbe	$LN152@FillVertic
$LN150@FillVertic:
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 499  : 		dest.x = v.x*_11 + v.y*_21 + v.z*_31 + _41;

	mov	eax, DWORD PTR _view$[esp+228]
	movss	xmm1, DWORD PTR _p$2$[esp+232]
	movss	xmm0, DWORD PTR _p$4$[esp+232]
	movss	xmm2, DWORD PTR [eax]
	movss	xmm5, DWORD PTR [eax+16]
	mulss	xmm0, xmm5
	mulss	xmm1, xmm2
	movss	xmm4, DWORD PTR [eax+32]
	movss	xmm3, DWORD PTR [eax+48]
	addss	xmm1, xmm0

; 500  : 		dest.y = v.x*_12 + v.y*_22 + v.z*_32 + _42;

	movss	xmm6, DWORD PTR [eax+4]
	movss	xmm0, DWORD PTR _p$6$[esp+232]
	mulss	xmm0, xmm4
	movss	xmm7, DWORD PTR [eax+52]
	addss	xmm0, xmm3
	addss	xmm1, xmm0
	movss	xmm0, DWORD PTR _p$4$[esp+232]
	mulss	xmm0, DWORD PTR [eax+20]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp

; 512  : 				uv.x			= (1+UV.x)*.5f;

	addss	xmm1, DWORD PTR __real@3f800000
	mulss	xmm1, DWORD PTR __real@3f000000
	movss	DWORD PTR _F$6[esp+268], xmm1
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 500  : 		dest.y = v.x*_12 + v.y*_22 + v.z*_32 + _42;

	movss	xmm1, DWORD PTR _p$2$[esp+232]
	mulss	xmm1, xmm6
	addss	xmm1, xmm0
	movss	xmm0, DWORD PTR _p$6$[esp+232]
	mulss	xmm0, DWORD PTR [eax+36]
	addss	xmm0, xmm7
	addss	xmm1, xmm0
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp

; 512  : 				uv.x			= (1+UV.x)*.5f;

	movss	xmm0, DWORD PTR __real@3f800000
	subss	xmm0, xmm1
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 499  : 		dest.x = v.x*_11 + v.y*_21 + v.z*_31 + _41;

	movss	xmm1, DWORD PTR _p$1$[esp+232]
	mulss	xmm1, xmm2
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp

; 513  : 				uv.y			= (1-UV.y)*.5f;

	mulss	xmm0, DWORD PTR __real@3f000000
	movss	DWORD PTR _F$6[esp+272], xmm0
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 499  : 		dest.x = v.x*_11 + v.y*_21 + v.z*_31 + _41;

	movss	xmm0, DWORD PTR _p$3$[esp+232]
	mulss	xmm0, xmm5
	addss	xmm1, xmm0
	movss	xmm0, DWORD PTR _p$5$[esp+232]
	mulss	xmm0, xmm4
	addss	xmm0, xmm3

; 500  : 		dest.y = v.x*_12 + v.y*_22 + v.z*_32 + _42;

	addss	xmm1, xmm0
	movss	xmm0, DWORD PTR _p$3$[esp+232]
	mulss	xmm0, DWORD PTR [eax+20]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp

; 512  : 				uv.x			= (1+UV.x)*.5f;

	addss	xmm1, DWORD PTR __real@3f800000
	mulss	xmm1, DWORD PTR __real@3f000000
	movss	DWORD PTR _F$6[esp+276], xmm1
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 500  : 		dest.y = v.x*_12 + v.y*_22 + v.z*_32 + _42;

	movss	xmm1, DWORD PTR _p$1$[esp+232]
	mulss	xmm1, xmm6
	addss	xmm1, xmm0
	movss	xmm0, DWORD PTR _p$5$[esp+232]
	mulss	xmm0, DWORD PTR [eax+36]
	addss	xmm0, xmm7
	addss	xmm1, xmm0
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp

; 512  : 				uv.x			= (1+UV.x)*.5f;

	movss	xmm0, DWORD PTR __real@3f800000
	subss	xmm0, xmm1
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 499  : 		dest.x = v.x*_11 + v.y*_21 + v.z*_31 + _41;

	movss	xmm1, DWORD PTR _p$7$[esp+232]
	mulss	xmm1, xmm2
	movss	xmm2, DWORD PTR _p$9$[esp+232]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp

; 513  : 				uv.y			= (1-UV.y)*.5f;

	mulss	xmm0, DWORD PTR __real@3f000000
	movss	DWORD PTR _F$6[esp+280], xmm0
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 499  : 		dest.x = v.x*_11 + v.y*_21 + v.z*_31 + _41;

	movss	xmm0, DWORD PTR _p$8$[esp+232]
	mulss	xmm0, xmm5
	addss	xmm1, xmm0
	movaps	xmm0, xmm2
	mulss	xmm0, xmm4
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp

; 512  : 				uv.x			= (1+UV.x)*.5f;

	movss	xmm4, DWORD PTR __real@3f800000
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 500  : 		dest.y = v.x*_12 + v.y*_22 + v.z*_32 + _42;

	mulss	xmm2, DWORD PTR [eax+36]
	addss	xmm0, xmm3
	addss	xmm2, xmm7
	addss	xmm1, xmm0
	movss	xmm0, DWORD PTR _p$8$[esp+232]
	mulss	xmm0, DWORD PTR [eax+20]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp

; 512  : 				uv.x			= (1+UV.x)*.5f;

	addss	xmm1, xmm4
	mulss	xmm1, DWORD PTR __real@3f000000
	movss	DWORD PTR _F$6[esp+284], xmm1
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 500  : 		dest.y = v.x*_12 + v.y*_22 + v.z*_32 + _42;

	movss	xmm1, DWORD PTR _p$7$[esp+232]
	mulss	xmm1, xmm6
	addss	xmm1, xmm0
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp

; 512  : 				uv.x			= (1+UV.x)*.5f;

	movaps	xmm0, xmm4
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 500  : 		dest.y = v.x*_12 + v.y*_22 + v.z*_32 + _42;

	addss	xmm1, xmm2
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp

; 512  : 				uv.x			= (1+UV.x)*.5f;

	subss	xmm0, xmm1

; 513  : 				uv.y			= (1-UV.y)*.5f;

	mulss	xmm0, DWORD PTR __real@3f000000
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 730  :         if (_Mylast != _My_data._Myend) {

	mov	edx, DWORD PTR [ebx+52]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp

; 513  : 				uv.y			= (1-UV.y)*.5f;

	movss	DWORD PTR _F$6[esp+288], xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 730  :         if (_Mylast != _My_data._Myend) {

	cmp	edx, DWORD PTR [ebx+56]
	je	SHORT $LN127@FillVertic
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	ecx, 21					; 00000015H
	lea	esi, DWORD PTR _F$6[esp+232]
	mov	edi, edx
	rep movsd
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 716  :         ++_Mylast;

	add	DWORD PTR [ebx+52], 84			; 00000054H

; 731  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

	jmp	SHORT $LN2@FillVertic
$LN127@FillVertic:

; 732  :         }
; 733  : 
; 734  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	lea	ecx, DWORD PTR _F$6[esp+232]
	push	ecx
	push	edx
	lea	ecx, DWORD PTR [ebx+48]
	call	??$_Emplace_reallocate@ABUWMFace@CSkeletonWallmark@@@?$vector@UWMFace@CSkeletonWallmark@@V?$xalloc@UWMFace@CSkeletonWallmark@@@@@std@@QAEPAUWMFace@CSkeletonWallmark@@QAU23@ABU23@@Z ; std::vector<CSkeletonWallmark::WMFace,xalloc<CSkeletonWallmark::WMFace> >::_Emplace_reallocate<CSkeletonWallmark::WMFace const &>
$LN152@FillVertic:

; 74   :         ++_Ptr;

	movss	xmm4, DWORD PTR __real@3f800000
$LN2@FillVertic:
	mov	eax, DWORD PTR _it$1$[esp+232]

; 150  :         return _Ptr == _Right._Ptr;

	mov	ecx, DWORD PTR _faces$[esp+228]

; 74   :         ++_Ptr;

	add	eax, 2
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp

; 486  : 	for (CBoneData::FacesVecIt it=faces.begin(); it!=faces.end(); it++){

	movss	xmm1, DWORD PTR __real@39c00180
	mov	ebx, DWORD PTR _this$1$[esp+232]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 74   :         ++_Ptr;

	mov	DWORD PTR _it$1$[esp+232], eax

; 150  :         return _Ptr == _Right._Ptr;

	cmp	eax, DWORD PTR [ecx+4]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp

; 486  : 	for (CBoneData::FacesVecIt it=faces.begin(); it!=faces.end(); it++){

	jne	$LL4@FillVertic
	pop	edi
	pop	ebp
$LN3@FillVertic:

; 514  : 			}
; 515  : 			wm.m_Faces.push_back(F);
; 516  : 		}
; 517  : 	}
; 518  : 	CHK_DX				(V->p_rm_Vertices->Unlock());

	mov	eax, DWORD PTR _V$[esp+220]
	mov	eax, DWORD PTR [eax+76]
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+48]
	pop	esi
	pop	ebx

; 519  : }

	add	esp, 216				; 000000d8H
	ret	28					; 0000001cH
?_FillVerticesHW2W@CSkeletonX_ext@@MAEXABU?$_matrix@M@@AAVCSkeletonWallmark@@ABU?$_vector3@M@@MPAVFvisual@@PAGAAV?$xr_vector@GV?$xalloc@G@@@@@Z ENDP ; CSkeletonX_ext::_FillVerticesHW2W
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xrsharedmem.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp
_TEXT	SEGMENT
_view$ = 8						; size = 4
_wm$ = 12						; size = 4
_normal$ = 16						; size = 4
_size$ = 20						; size = 4
_V$ = 24						; size = 4
_bone_id$ = 28						; size = 2
_indices$ = 28						; size = 4
_iBase$ = 32						; size = 4
_iCount$ = 36						; size = 4
?_FillVertices@CSkeletonX_ext@@MAEXABU?$_matrix@M@@AAVCSkeletonWallmark@@ABU?$_vector3@M@@MPAVFvisual@@GII@Z PROC ; CSkeletonX_ext::_FillVertices
; _this$ = ecx

; 522  : {

	push	ebx
	push	esi
	mov	esi, ecx
	push	edi

; 523  : 	VERIFY				(Parent&&(ChildIDX!=u16(-1)));
; 524  : 	CBoneData& BD					= Parent->LL_GetData(bone_id);

	push	DWORD PTR _bone_id$[esp+8]
	mov	ecx, DWORD PTR [esi+4]
	call	DWORD PTR __imp_?LL_GetData@CKinematics@@QAEAAVCBoneData@@G@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 119  :         _Ptr += _Off;

	movzx	edx, WORD PTR [esi+22]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp

; 528  : 	CHK_DX				(V->p_rm_Indices->Lock(0,V->dwPrimitives*3,(void**)&indices,D3DLOCK_READONLY));

	mov	ebx, DWORD PTR _V$[esp+8]
	push	16					; 00000010H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 119  :         _Ptr += _Off;

	mov	eax, DWORD PTR [eax+424]
	lea	edx, DWORD PTR [edx+edx*2]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp

; 526  : 	u16* indices		= 0;

	mov	DWORD PTR _indices$[esp+12], 0

; 528  : 	CHK_DX				(V->p_rm_Indices->Lock(0,V->dwPrimitives*3,(void**)&indices,D3DLOCK_READONLY));

	mov	ecx, DWORD PTR [ebx+88]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 119  :         _Ptr += _Off;

	lea	edi, DWORD PTR [eax+edx*4]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp

; 528  : 	CHK_DX				(V->p_rm_Indices->Lock(0,V->dwPrimitives*3,(void**)&indices,D3DLOCK_READONLY));

	lea	eax, DWORD PTR _indices$[esp+12]
	mov	edx, DWORD PTR [ecx]
	push	eax
	mov	eax, DWORD PTR [ebx+100]
	lea	eax, DWORD PTR [eax+eax*2]
	push	eax
	push	0
	push	ecx
	call	DWORD PTR [edx+44]

; 529  : 	// fill vertices
; 530  : 	switch	(RenderMode)

	movzx	eax, WORD PTR [esi+20]
	cmp	eax, 3
	ja	$LN5@FillVertic
	jmp	DWORD PTR $LN35@FillVertic[eax*4]
$LN7@FillVertic:
; File I:\Vitalya\mine\NSProjectX\xrCore\xrsharedmem.h

; 86   : 	T*					operator*	() const						{	return p_?(T*)p_->value:0;									}

	mov	ecx, DWORD PTR [esi+8]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp

; 533  : 		if (*Vertices1W)			_FillVerticesSoft1W		(view,wm,normal,size,indices+iBase,*faces);

	mov	edx, DWORD PTR _iBase$[esp+8]
	fld	DWORD PTR _size$[esp+8]
	push	edi
	lea	eax, DWORD PTR [ecx+16]
	neg	ecx
	sbb	ecx, ecx
	test	ecx, eax
	mov	eax, DWORD PTR _indices$[esp+12]
	lea	eax, DWORD PTR [eax+edx*2]
	push	eax
	push	ecx
	fstp	DWORD PTR [esp]
	push	DWORD PTR _normal$[esp+20]
	mov	ecx, esi
	push	DWORD PTR _wm$[esp+24]
	push	DWORD PTR _view$[esp+28]
	je	SHORT $LN8@FillVertic
	call	DWORD PTR __imp_?_FillVerticesSoft1W@CSkeletonX@@IAEXABU?$_matrix@M@@AAVCSkeletonWallmark@@ABU?$_vector3@M@@MPAGAAV?$xr_vector@GV?$xalloc@G@@@@@Z

; 539  : 	}
; 540  : 	CHK_DX				(V->p_rm_Indices->Unlock());

	mov	eax, DWORD PTR [ebx+88]
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+48]
	pop	edi
	pop	esi
	pop	ebx

; 541  : }

	ret	32					; 00000020H
$LN8@FillVertic:

; 534  : 		else						_FillVerticesSoft2W		(view,wm,normal,size,indices+iBase,*faces);

	call	DWORD PTR __imp_?_FillVerticesSoft2W@CSkeletonX@@IAEXABU?$_matrix@M@@AAVCSkeletonWallmark@@ABU?$_vector3@M@@MPAGAAV?$xr_vector@GV?$xalloc@G@@@@@Z

; 539  : 	}
; 540  : 	CHK_DX				(V->p_rm_Indices->Unlock());

	mov	eax, DWORD PTR [ebx+88]
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+48]
	pop	edi
	pop	esi
	pop	ebx

; 541  : }

	ret	32					; 00000020H
$LN10@FillVertic:

; 535  : 		break;
; 536  : 	case RM_SINGLE:
; 537  : 	case RM_SKINNING_1B:			_FillVerticesHW1W		(view,wm,normal,size,V,indices+iBase,*faces);		break;

	mov	ecx, DWORD PTR _iBase$[esp+8]
	mov	eax, DWORD PTR _indices$[esp+8]
	fld	DWORD PTR _size$[esp+8]
	mov	edx, DWORD PTR [esi]
	push	edi
	lea	eax, DWORD PTR [eax+ecx*2]
	push	eax
	push	ebx
	push	ecx
	fstp	DWORD PTR [esp]
	push	DWORD PTR _normal$[esp+24]
	mov	ecx, esi
	push	DWORD PTR _wm$[esp+28]
	push	DWORD PTR _view$[esp+32]
	call	DWORD PTR [edx+8]

; 539  : 	}
; 540  : 	CHK_DX				(V->p_rm_Indices->Unlock());

	mov	eax, DWORD PTR [ebx+88]
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+48]
	pop	edi
	pop	esi
	pop	ebx

; 541  : }

	ret	32					; 00000020H
$LN12@FillVertic:

; 538  : 	case RM_SKINNING_2B:			_FillVerticesHW2W		(view,wm,normal,size,V,indices+iBase,*faces);		break;

	mov	ecx, DWORD PTR _iBase$[esp+8]
	mov	eax, DWORD PTR _indices$[esp+8]
	fld	DWORD PTR _size$[esp+8]
	mov	edx, DWORD PTR [esi]
	push	edi
	lea	eax, DWORD PTR [eax+ecx*2]
	push	eax
	push	ebx
	push	ecx
	fstp	DWORD PTR [esp]
	push	DWORD PTR _normal$[esp+24]
	mov	ecx, esi
	push	DWORD PTR _wm$[esp+28]
	push	DWORD PTR _view$[esp+32]
	call	DWORD PTR [edx+12]
$LN5@FillVertic:

; 539  : 	}
; 540  : 	CHK_DX				(V->p_rm_Indices->Unlock());

	mov	eax, DWORD PTR [ebx+88]
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+48]
	pop	edi
	pop	esi
	pop	ebx

; 541  : }

	ret	32					; 00000020H
	npad	2
$LN35@FillVertic:
	DD	$LN7@FillVertic
	DD	$LN10@FillVertic
	DD	$LN10@FillVertic
	DD	$LN12@FillVertic
?_FillVertices@CSkeletonX_ext@@MAEXABU?$_matrix@M@@AAVCSkeletonWallmark@@ABU?$_vector3@M@@MPAVFvisual@@GII@Z ENDP ; CSkeletonX_ext::_FillVertices
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp
_TEXT	SEGMENT
_view$ = 8						; size = 4
_wm$ = 12						; size = 4
_normal$ = 16						; size = 4
_size$ = 20						; size = 4
_bone_id$ = 24						; size = 2
?FillVertices@CSkeletonX_ST@@UAEXABU?$_matrix@M@@AAVCSkeletonWallmark@@ABU?$_vector3@M@@MG@Z PROC ; CSkeletonX_ST::FillVertices
; _this$ = ecx

; 545  : 	inherited2::_FillVertices		(view,wm,normal,size,this,bone_id,iBase,iCount);

	push	DWORD PTR [ecx-12]
	fld	DWORD PTR _size$[esp]
	lea	eax, DWORD PTR [ecx-108]
	push	DWORD PTR [ecx-16]
	push	DWORD PTR _bone_id$[esp+4]
	push	eax
	push	ecx
	fstp	DWORD PTR [esp]
	push	DWORD PTR _normal$[esp+16]
	push	DWORD PTR _wm$[esp+20]
	push	DWORD PTR _view$[esp+24]
	call	?_FillVertices@CSkeletonX_ext@@MAEXABU?$_matrix@M@@AAVCSkeletonWallmark@@ABU?$_vector3@M@@MPAVFvisual@@GII@Z ; CSkeletonX_ext::_FillVertices

; 546  : }

	ret	20					; 00000014H
?FillVertices@CSkeletonX_ST@@UAEXABU?$_matrix@M@@AAVCSkeletonWallmark@@ABU?$_vector3@M@@MG@Z ENDP ; CSkeletonX_ST::FillVertices
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp
_TEXT	SEGMENT
_view$ = 8						; size = 4
_wm$ = 12						; size = 4
_normal$ = 16						; size = 4
_size$ = 20						; size = 4
_bone_id$ = 24						; size = 2
?FillVertices@CSkeletonX_PM@@UAEXABU?$_matrix@M@@AAVCSkeletonWallmark@@ABU?$_vector3@M@@MG@Z PROC ; CSkeletonX_PM::FillVertices
; _this$ = ecx

; 549  : 	FSlideWindow& SW				= nSWI.sw[0];

	mov	edx, DWORD PTR [ecx-32]

; 550  : 	inherited2::_FillVertices		(view,wm,normal,size,this,bone_id,iBase+SW.offset,SW.num_tris*3);

	fld	DWORD PTR _size$[esp-4]
	movzx	eax, WORD PTR [edx+4]
	lea	eax, DWORD PTR [eax+eax*2]
	push	eax
	mov	eax, DWORD PTR [ecx-48]
	add	eax, DWORD PTR [edx]
	push	eax
	push	DWORD PTR _bone_id$[esp+4]
	lea	eax, DWORD PTR [ecx-140]
	push	eax
	push	ecx
	fstp	DWORD PTR [esp]
	push	DWORD PTR _normal$[esp+16]
	push	DWORD PTR _wm$[esp+20]
	push	DWORD PTR _view$[esp+24]
	call	?_FillVertices@CSkeletonX_ext@@MAEXABU?$_matrix@M@@AAVCSkeletonWallmark@@ABU?$_vector3@M@@MPAVFvisual@@GII@Z ; CSkeletonX_ext::_FillVertices

; 551  : }

	ret	20					; 00000014H
?FillVertices@CSkeletonX_PM@@UAEXABU?$_matrix@M@@AAVCSkeletonWallmark@@ABU?$_vector3@M@@MG@Z ENDP ; CSkeletonX_PM::FillVertices
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xrsharedmem.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xrsharedmem.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xrsharedmem.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xrsharedmem.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xrsharedmem.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xrsharedmem.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xrsharedmem.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xrsharedmem.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp
_TEXT	SEGMENT
$T1 = -36						; size = 4
tv1426 = -32						; size = 4
_this$1$ = -28						; size = 4
_vertices$ = -24					; size = 4
_v$1$ = -20						; size = 4
_v$1$ = -20						; size = 4
_indices$1$ = -16					; size = 4
$T2 = -16						; size = 4
$T3 = -16						; size = 4
_indices$1$ = -16					; size = 4
_P$4 = -12						; size = 12
_P$5 = -12						; size = 12
_P$6 = -12						; size = 12
_P$7 = -12						; size = 12
_C$ = 8							; size = 4
_V$ = 12						; size = 4
_bone_id$ = 16						; size = 2
_indices$ = 16						; size = 4
_it$1$ = 20						; size = 4
_it$1$ = 20						; size = 4
_it$1$ = 20						; size = 4
_it$1$ = 20						; size = 4
_iBase$ = 20						; size = 4
_iCount$dead$ = 24					; size = 4
?_EnumBoneVertices@CSkeletonX_ext@@IBEXAAUSEnumVerticesCallback@@PAVFvisual@@GII@Z PROC ; CSkeletonX_ext::_EnumBoneVertices
; _this$ = ecx

; 622  : {

	sub	esp, 36					; 00000024H
	push	ebx
	push	ebp
	push	esi
	mov	ebx, ecx
	push	edi

; 623  : 
; 624  : 	VERIFY							(Parent && (ChildIDX!=u16(-1)));
; 625  : 	CBoneData& BD					= Parent->LL_GetData(bone_id);

	push	DWORD PTR _bone_id$[esp+48]
	mov	DWORD PTR _this$1$[esp+56], ebx
	mov	ecx, DWORD PTR [ebx+4]
	call	DWORD PTR __imp_?LL_GetData@CKinematics@@QAEAAVCBoneData@@G@Z

; 629  : 	CHK_DX				(V->p_rm_Indices->Lock(0,V->dwPrimitives*3,(void**)&indices,D3DLOCK_READONLY));

	mov	esi, DWORD PTR _V$[esp+48]
	movzx	edx, WORD PTR [ebx+22]
	push	16					; 00000010H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 303  :         _Vector_iterator _Tmp = *this;

	mov	edi, DWORD PTR [eax+424]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp

; 629  : 	CHK_DX				(V->p_rm_Indices->Lock(0,V->dwPrimitives*3,(void**)&indices,D3DLOCK_READONLY));

	lea	eax, DWORD PTR _indices$[esp+52]
	mov	ecx, DWORD PTR [esi+88]
	push	eax
	mov	eax, DWORD PTR [esi+100]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 119  :         _Ptr += _Off;

	lea	ebp, DWORD PTR [edx+edx*2]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp

; 627  : 	u16* indices		= 0;

	mov	DWORD PTR _indices$[esp+56], 0

; 629  : 	CHK_DX				(V->p_rm_Indices->Lock(0,V->dwPrimitives*3,(void**)&indices,D3DLOCK_READONLY));

	mov	edx, DWORD PTR [ecx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 303  :         _Vector_iterator _Tmp = *this;

	mov	DWORD PTR $T1[esp+60], edi
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp

; 629  : 	CHK_DX				(V->p_rm_Indices->Lock(0,V->dwPrimitives*3,(void**)&indices,D3DLOCK_READONLY));

	lea	eax, DWORD PTR [eax+eax*2]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 119  :         _Ptr += _Off;

	mov	DWORD PTR tv1426[esp+60], ebp
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp

; 629  : 	CHK_DX				(V->p_rm_Indices->Lock(0,V->dwPrimitives*3,(void**)&indices,D3DLOCK_READONLY));

	push	eax
	push	0
	push	ecx
	call	DWORD PTR [edx+44]

; 630  : 	// fill vertices
; 631  : 	void				*vertices	=0;
; 632  : 	if( RenderMode!= RM_SKINNING_SOFT)

	mov	eax, DWORD PTR _this$1$[esp+52]
	xor	ebx, ebx
	mov	DWORD PTR _vertices$[esp+52], ebx
	movzx	eax, WORD PTR [eax+20]
	mov	ecx, eax
	test	ax, ax
	je	SHORT $LN237@EnumBoneVe

; 633  : 		CHK_DX				(V->p_rm_Vertices->Lock(V->vBase,V->vCount,(void**)&vertices,D3DLOCK_READONLY));

	mov	eax, DWORD PTR [esi+76]
	lea	edx, DWORD PTR _vertices$[esp+52]
	push	16					; 00000010H
	push	edx
	push	DWORD PTR [esi+84]
	mov	ecx, DWORD PTR [eax]
	push	DWORD PTR [esi+80]
	push	eax
	call	DWORD PTR [ecx+44]
	mov	esi, DWORD PTR _this$1$[esp+52]
	mov	ebx, DWORD PTR _vertices$[esp+52]
	movzx	ecx, WORD PTR [esi+20]
	jmp	SHORT $LN7@EnumBoneVe
$LN237@EnumBoneVe:

; 630  : 	// fill vertices
; 631  : 	void				*vertices	=0;
; 632  : 	if( RenderMode!= RM_SKINNING_SOFT)

	mov	esi, DWORD PTR _this$1$[esp+52]
$LN7@EnumBoneVe:

; 634  : 	switch	(RenderMode)

	movzx	eax, cx
	jmp	DWORD PTR $LN235@EnumBoneVe[eax*4]
$LN8@EnumBoneVe:
; File I:\Vitalya\mine\NSProjectX\xrCore\xrsharedmem.h

; 86   : 	T*					operator*	() const						{	return p_?(T*)p_->value:0;									}

	mov	edx, DWORD PTR [esi+8]
	mov	DWORD PTR _v$1$[esp+52], edx
	test	edx, edx
	je	$LN9@EnumBoneVe
	lea	eax, DWORD PTR [edx+16]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp

; 637  : 			if (*Vertices1W) 

	test	eax, eax
	je	$LN9@EnumBoneVe

; 638  : 				TEnumBoneVertices( Vertices1W, indices+iBase, *faces, C );

	mov	ecx, DWORD PTR _iBase$[esp+48]
	mov	eax, DWORD PTR _indices$[esp+48]
; File I:\Vitalya\mine\NSProjectX\xrCore\xrsharedmem.h

; 70   : 	void				_set		(ref_smem const &rhs)			{	smem_value* v = rhs.p_; if (0!=v) v->dwReference++; _dec(); p_ = v;							}

	inc	DWORD PTR [edx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	esi, DWORD PTR [edi+ebp*4]
	mov	DWORD PTR _it$1$[esp+48], esi
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp

; 638  : 				TEnumBoneVertices( Vertices1W, indices+iBase, *faces, C );

	lea	ecx, DWORD PTR [eax+ecx*2]
	mov	DWORD PTR $T3[esp+52], ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 150  :         return _Ptr == _Right._Ptr;

	cmp	esi, DWORD PTR [edi+ebp*4+4]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp

; 611  : 		for (CBoneData::FacesVecIt it=faces.begin(); it!=faces.end(); it++){

	je	SHORT $LN234@EnumBoneVe
$LL50@EnumBoneVe:

; 612  : 			u32 idx			= (*it)*3;

	movzx	eax, WORD PTR [esi]
	mov	ebp, 3
	mov	edi, DWORD PTR _C$[esp+48]
	mov	esi, DWORD PTR _v$1$[esp+52]
	lea	eax, DWORD PTR [eax+eax*2]
	lea	ebx, DWORD PTR [ecx+eax*2]
	npad	7
$LL53@EnumBoneVe:

; 615  : 				vertices[indices[idx+k]].get_pos( P );

	movzx	ecx, WORD PTR [ebx]
	lea	eax, DWORD PTR _P$7[esp+52]
	push	eax
; File I:\Vitalya\mine\NSProjectX\xrCore\xrsharedmem.h

; 88   : 	T&					operator[]	(size_t id)						{	return ((T*)(p_->value))[id];								}

	mov	eax, ecx
	shl	eax, 4
	sub	eax, ecx
	add	eax, 4
	lea	ecx, DWORD PTR [esi+eax*4]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp

; 615  : 				vertices[indices[idx+k]].get_pos( P );

	call	DWORD PTR __imp_?get_pos@vertBoned1W@@QAEXAAU?$_vector3@M@@@Z

; 616  : 				C( P );

	mov	eax, DWORD PTR [edi]
	lea	ecx, DWORD PTR _P$7[esp+52]
	push	ecx
	mov	ecx, edi
	call	DWORD PTR [eax]
	lea	ebx, DWORD PTR [ebx+2]
	sub	ebp, 1
	jne	SHORT $LL53@EnumBoneVe
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 74   :         ++_Ptr;

	mov	esi, DWORD PTR _it$1$[esp+48]

; 150  :         return _Ptr == _Right._Ptr;

	mov	edi, DWORD PTR $T1[esp+52]

; 74   :         ++_Ptr;

	add	esi, 2

; 150  :         return _Ptr == _Right._Ptr;

	mov	eax, DWORD PTR tv1426[esp+52]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp

; 611  : 		for (CBoneData::FacesVecIt it=faces.begin(); it!=faces.end(); it++){

	mov	ecx, DWORD PTR $T3[esp+52]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 74   :         ++_Ptr;

	mov	DWORD PTR _it$1$[esp+48], esi

; 150  :         return _Ptr == _Right._Ptr;

	cmp	esi, DWORD PTR [edi+eax*4+4]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp

; 611  : 		for (CBoneData::FacesVecIt it=faces.begin(); it!=faces.end(); it++){

	jne	SHORT $LL50@EnumBoneVe
	mov	edx, DWORD PTR _v$1$[esp+52]
$LN234@EnumBoneVe:
; File I:\Vitalya\mine\NSProjectX\xrCore\xrsharedmem.h

; 68   : 	void				_dec		()								{	if (0==p_) return;	p_->dwReference--; 	if (0==p_->dwReference)	p_=0;						}

	dec	DWORD PTR [edx]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp

; 638  : 				TEnumBoneVertices( Vertices1W, indices+iBase, *faces, C );

	jmp	$LN166@EnumBoneVe
$LN9@EnumBoneVe:

; 640  : 				TEnumBoneVertices( Vertices2W, indices+iBase, *faces, C  );				

	mov	eax, DWORD PTR _indices$[esp+48]
	mov	ecx, DWORD PTR _iBase$[esp+48]
	lea	ecx, DWORD PTR [eax+ecx*2]
; File I:\Vitalya\mine\NSProjectX\xrCore\xrsharedmem.h

; 70   : 	void				_set		(ref_smem const &rhs)			{	smem_value* v = rhs.p_; if (0!=v) v->dwReference++; _dec(); p_ = v;							}

	mov	eax, DWORD PTR [esi+12]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp

; 640  : 				TEnumBoneVertices( Vertices2W, indices+iBase, *faces, C  );				

	mov	DWORD PTR $T2[esp+52], ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\xrsharedmem.h

; 70   : 	void				_set		(ref_smem const &rhs)			{	smem_value* v = rhs.p_; if (0!=v) v->dwReference++; _dec(); p_ = v;							}

	mov	DWORD PTR _v$1$[esp+52], eax
	test	eax, eax
	je	SHORT $LN233@EnumBoneVe
	inc	DWORD PTR [eax]
$LN233@EnumBoneVe:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	esi, DWORD PTR [edi+ebp*4]
	mov	DWORD PTR _it$1$[esp+48], esi

; 150  :         return _Ptr == _Right._Ptr;

	cmp	esi, DWORD PTR [edi+ebp*4+4]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp

; 611  : 		for (CBoneData::FacesVecIt it=faces.begin(); it!=faces.end(); it++){

	je	SHORT $LN94@EnumBoneVe
	npad	1
$LL95@EnumBoneVe:

; 612  : 			u32 idx			= (*it)*3;

	movzx	eax, WORD PTR [esi]
	mov	ebp, 3
	mov	edi, DWORD PTR _C$[esp+48]
	mov	esi, DWORD PTR _v$1$[esp+52]
	lea	eax, DWORD PTR [eax+eax*2]
	lea	ebx, DWORD PTR [ecx+eax*2]
$LL98@EnumBoneVe:

; 615  : 				vertices[indices[idx+k]].get_pos( P );

	lea	eax, DWORD PTR _P$6[esp+52]
	push	eax
	movzx	eax, WORD PTR [ebx]
; File I:\Vitalya\mine\NSProjectX\xrCore\xrsharedmem.h

; 88   : 	T&					operator[]	(size_t id)						{	return ((T*)(p_->value))[id];								}

	lea	ecx, DWORD PTR [esi+16]
	shl	eax, 6
	add	ecx, eax
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp

; 615  : 				vertices[indices[idx+k]].get_pos( P );

	call	DWORD PTR __imp_?get_pos@vertBoned2W@@QAEXAAU?$_vector3@M@@@Z

; 616  : 				C( P );

	mov	eax, DWORD PTR [edi]
	lea	ecx, DWORD PTR _P$6[esp+52]
	push	ecx
	mov	ecx, edi
	call	DWORD PTR [eax]
	lea	ebx, DWORD PTR [ebx+2]
	sub	ebp, 1
	jne	SHORT $LL98@EnumBoneVe
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 74   :         ++_Ptr;

	mov	esi, DWORD PTR _it$1$[esp+48]

; 150  :         return _Ptr == _Right._Ptr;

	mov	edi, DWORD PTR $T1[esp+52]

; 74   :         ++_Ptr;

	add	esi, 2

; 150  :         return _Ptr == _Right._Ptr;

	mov	eax, DWORD PTR tv1426[esp+52]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp

; 611  : 		for (CBoneData::FacesVecIt it=faces.begin(); it!=faces.end(); it++){

	mov	ecx, DWORD PTR $T2[esp+52]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 74   :         ++_Ptr;

	mov	DWORD PTR _it$1$[esp+48], esi

; 150  :         return _Ptr == _Right._Ptr;

	cmp	esi, DWORD PTR [edi+eax*4+4]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp

; 611  : 		for (CBoneData::FacesVecIt it=faces.begin(); it!=faces.end(); it++){

	jne	SHORT $LL95@EnumBoneVe
	mov	eax, DWORD PTR _v$1$[esp+52]
$LN94@EnumBoneVe:
; File I:\Vitalya\mine\NSProjectX\xrCore\xrsharedmem.h

; 68   : 	void				_dec		()								{	if (0==p_) return;	p_->dwReference--; 	if (0==p_->dwReference)	p_=0;						}

	test	eax, eax
	je	$LN166@EnumBoneVe
	dec	DWORD PTR [eax]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp

; 641  : 			break;

	jmp	$LN166@EnumBoneVe
$LN11@EnumBoneVe:

; 643  : 		case RM_SKINNING_1B: TEnumBoneVertices	( (vertHW_1W*)vertices, indices+iBase, *faces, C  );break;

	mov	ecx, DWORD PTR _iBase$[esp+48]
	mov	eax, DWORD PTR _indices$[esp+48]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	esi, DWORD PTR [edi+ebp*4]
	mov	DWORD PTR _it$1$[esp+48], esi
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp

; 643  : 		case RM_SKINNING_1B: TEnumBoneVertices	( (vertHW_1W*)vertices, indices+iBase, *faces, C  );break;

	lea	ecx, DWORD PTR [eax+ecx*2]
	mov	DWORD PTR _indices$1$[esp+52], ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 150  :         return _Ptr == _Right._Ptr;

	cmp	esi, DWORD PTR [edi+ebp*4+4]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp

; 611  : 		for (CBoneData::FacesVecIt it=faces.begin(); it!=faces.end(); it++){

	je	$LN166@EnumBoneVe
	movss	xmm1, DWORD PTR __real@39c00180
	npad	9
$LL131@EnumBoneVe:

; 612  : 			u32 idx			= (*it)*3;

	movzx	eax, WORD PTR [esi]
	mov	edi, 3
	mov	esi, DWORD PTR _C$[esp+48]
	lea	eax, DWORD PTR [eax+eax*2]
	lea	ebp, DWORD PTR [ecx+eax*2]
$LL134@EnumBoneVe:

; 615  : 				vertices[indices[idx+k]].get_pos( P );

	movzx	eax, WORD PTR [ebp]
	lea	ecx, DWORD PTR [eax+eax*2]

; 25   : 	return	float(v)/(32767.f/12.f);

	movsx	eax, WORD PTR [ebx+ecx*8]
	cvtsi2ss xmm0, eax
	mulss	xmm0, xmm1

; 91   : 		p.x			= u_P(_P[0]);

	movss	DWORD PTR _P$5[esp+52], xmm0

; 25   : 	return	float(v)/(32767.f/12.f);

	movsx	eax, WORD PTR [ebx+ecx*8+2]
	cvtsi2ss xmm0, eax
	mulss	xmm0, xmm1

; 92   : 		p.y			= u_P(_P[1]);

	movss	DWORD PTR _P$5[esp+56], xmm0

; 25   : 	return	float(v)/(32767.f/12.f);

	movsx	eax, WORD PTR [ebx+ecx*8+4]

; 616  : 				C( P );

	lea	ecx, DWORD PTR _P$5[esp+52]
	push	ecx
	mov	ecx, esi

; 25   : 	return	float(v)/(32767.f/12.f);

	cvtsi2ss xmm0, eax

; 616  : 				C( P );

	mov	eax, DWORD PTR [esi]

; 25   : 	return	float(v)/(32767.f/12.f);

	mulss	xmm0, xmm1

; 93   : 		p.z			= u_P(_P[2]);

	movss	DWORD PTR _P$5[esp+64], xmm0

; 616  : 				C( P );

	call	DWORD PTR [eax]
	movss	xmm1, DWORD PTR __real@39c00180
	lea	ebp, DWORD PTR [ebp+2]
	sub	edi, 1
	jne	SHORT $LL134@EnumBoneVe
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 74   :         ++_Ptr;

	mov	esi, DWORD PTR _it$1$[esp+48]

; 150  :         return _Ptr == _Right._Ptr;

	mov	edi, DWORD PTR $T1[esp+52]

; 74   :         ++_Ptr;

	add	esi, 2

; 150  :         return _Ptr == _Right._Ptr;

	mov	eax, DWORD PTR tv1426[esp+52]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp

; 611  : 		for (CBoneData::FacesVecIt it=faces.begin(); it!=faces.end(); it++){

	mov	ecx, DWORD PTR _indices$1$[esp+52]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 74   :         ++_Ptr;

	mov	DWORD PTR _it$1$[esp+48], esi

; 150  :         return _Ptr == _Right._Ptr;

	cmp	esi, DWORD PTR [edi+eax*4+4]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp

; 611  : 		for (CBoneData::FacesVecIt it=faces.begin(); it!=faces.end(); it++){

	jne	$LL131@EnumBoneVe

; 643  : 		case RM_SKINNING_1B: TEnumBoneVertices	( (vertHW_1W*)vertices, indices+iBase, *faces, C  );break;

	jmp	$LN166@EnumBoneVe
$LN13@EnumBoneVe:

; 644  : 		case RM_SKINNING_2B: TEnumBoneVertices	( (vertHW_2W*)vertices, indices+iBase, *faces, C  );break;

	mov	ecx, DWORD PTR _iBase$[esp+48]
	mov	eax, DWORD PTR _indices$[esp+48]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	esi, DWORD PTR [edi+ebp*4]
	mov	DWORD PTR _it$1$[esp+48], esi
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp

; 644  : 		case RM_SKINNING_2B: TEnumBoneVertices	( (vertHW_2W*)vertices, indices+iBase, *faces, C  );break;

	lea	ecx, DWORD PTR [eax+ecx*2]
	mov	DWORD PTR _indices$1$[esp+52], ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 150  :         return _Ptr == _Right._Ptr;

	cmp	esi, DWORD PTR [edi+ebp*4+4]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp

; 611  : 		for (CBoneData::FacesVecIt it=faces.begin(); it!=faces.end(); it++){

	je	$LN166@EnumBoneVe
	movss	xmm1, DWORD PTR __real@39c00180
	npad	6
$LL167@EnumBoneVe:

; 612  : 			u32 idx			= (*it)*3;

	movzx	eax, WORD PTR [esi]
	mov	edi, 3
	mov	esi, DWORD PTR _C$[esp+48]
	lea	eax, DWORD PTR [eax+eax*2]
	lea	ebp, DWORD PTR [ecx+eax*2]
$LL170@EnumBoneVe:

; 615  : 				vertices[indices[idx+k]].get_pos( P );

	movzx	eax, WORD PTR [ebp]
	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax

; 25   : 	return	float(v)/(32767.f/12.f);

	movsx	eax, WORD PTR [ebx+ecx*4]
	cvtsi2ss xmm0, eax
	mulss	xmm0, xmm1

; 140  : 		p.x			= u_P(_P[0]);

	movss	DWORD PTR _P$4[esp+52], xmm0

; 25   : 	return	float(v)/(32767.f/12.f);

	movsx	eax, WORD PTR [ebx+ecx*4+2]
	cvtsi2ss xmm0, eax
	mulss	xmm0, xmm1

; 141  : 		p.y			= u_P(_P[1]);

	movss	DWORD PTR _P$4[esp+56], xmm0

; 25   : 	return	float(v)/(32767.f/12.f);

	movsx	eax, WORD PTR [ebx+ecx*4+4]

; 616  : 				C( P );

	lea	ecx, DWORD PTR _P$4[esp+52]
	push	ecx
	mov	ecx, esi

; 25   : 	return	float(v)/(32767.f/12.f);

	cvtsi2ss xmm0, eax

; 616  : 				C( P );

	mov	eax, DWORD PTR [esi]

; 25   : 	return	float(v)/(32767.f/12.f);

	mulss	xmm0, xmm1

; 142  : 		p.z			= u_P(_P[2]);

	movss	DWORD PTR _P$4[esp+64], xmm0

; 616  : 				C( P );

	call	DWORD PTR [eax]
	movss	xmm1, DWORD PTR __real@39c00180
	lea	ebp, DWORD PTR [ebp+2]
	sub	edi, 1
	jne	SHORT $LL170@EnumBoneVe
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 74   :         ++_Ptr;

	mov	esi, DWORD PTR _it$1$[esp+48]

; 150  :         return _Ptr == _Right._Ptr;

	mov	edi, DWORD PTR $T1[esp+52]

; 74   :         ++_Ptr;

	add	esi, 2

; 150  :         return _Ptr == _Right._Ptr;

	mov	eax, DWORD PTR tv1426[esp+52]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp

; 611  : 		for (CBoneData::FacesVecIt it=faces.begin(); it!=faces.end(); it++){

	mov	ecx, DWORD PTR _indices$1$[esp+52]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 74   :         ++_Ptr;

	mov	DWORD PTR _it$1$[esp+48], esi

; 150  :         return _Ptr == _Right._Ptr;

	cmp	esi, DWORD PTR [edi+eax*4+4]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp

; 611  : 		for (CBoneData::FacesVecIt it=faces.begin(); it!=faces.end(); it++){

	jne	$LL167@EnumBoneVe
$LN166@EnumBoneVe:

; 645  : 		default: NODEFAULT;
; 646  : 	}
; 647  : 	if( RenderMode!= RM_SKINNING_SOFT)

	mov	eax, DWORD PTR _this$1$[esp+52]
	mov	esi, DWORD PTR _V$[esp+48]
	cmp	WORD PTR [eax+20], 0
	je	SHORT $LN15@EnumBoneVe

; 648  : 		CHK_DX				(V->p_rm_Vertices->Unlock());

	mov	eax, DWORD PTR [esi+76]
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+48]
$LN15@EnumBoneVe:

; 649  : 	CHK_DX				(V->p_rm_Indices->Unlock());

	mov	eax, DWORD PTR [esi+88]
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+48]

; 650  : }

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 36					; 00000024H
	ret	20					; 00000014H
	npad	2
$LN235@EnumBoneVe:
	DD	$LN8@EnumBoneVe
	DD	$LN11@EnumBoneVe
	DD	$LN11@EnumBoneVe
	DD	$LN13@EnumBoneVe
?_EnumBoneVertices@CSkeletonX_ext@@IBEXAAUSEnumVerticesCallback@@PAVFvisual@@GII@Z ENDP ; CSkeletonX_ext::_EnumBoneVertices
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@G@std@@@std@@@std@@QAE?AV01@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$dead$ = 12					; size = 4
??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@G@std@@@std@@@std@@QAE?AV01@H@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned short> > >::operator++, COMDAT
; _this$ = ecx

; 281  :         _Vector_iterator _Tmp = *this;

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx

; 74   :         ++_Ptr;

	add	edx, 2
	mov	DWORD PTR [ecx], edx

; 282  :         _Mybase::operator++();
; 283  :         return _Tmp;
; 284  :     }

	ret	8
??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@G@std@@@std@@@std@@QAE?AV01@H@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned short> > >::operator++
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@G@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@G@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned short> > >::operator!=, COMDAT
; _this$ = ecx

; 160  :         return !(*this == _Right);

	mov	eax, DWORD PTR __Right$[esp-4]
	mov	ecx, DWORD PTR [ecx]
	cmp	ecx, DWORD PTR [eax]
	setne	al

; 161  :     }

	ret	4
??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@G@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned short> > >::operator!=
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\xrsharedmem.h
;	COMDAT ??D?$ref_smem@UvertBoned2W@@@@QBEPAUvertBoned2W@@XZ
_TEXT	SEGMENT
??D?$ref_smem@UvertBoned2W@@@@QBEPAUvertBoned2W@@XZ PROC ; ref_smem<vertBoned2W>::operator*, COMDAT
; _this$ = ecx

; 86   : 	T*					operator*	() const						{	return p_?(T*)p_->value:0;									}

	mov	eax, DWORD PTR [ecx]
	lea	ecx, DWORD PTR [eax+16]
	neg	eax
	sbb	eax, eax
	and	eax, ecx
	ret	0
??D?$ref_smem@UvertBoned2W@@@@QBEPAUvertBoned2W@@XZ ENDP ; ref_smem<vertBoned2W>::operator*
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\xrsharedmem.h
;	COMDAT ??1?$ref_smem@UvertBoned2W@@@@QAE@XZ
_TEXT	SEGMENT
??1?$ref_smem@UvertBoned2W@@@@QAE@XZ PROC		; ref_smem<vertBoned2W>::~ref_smem<vertBoned2W>, COMDAT
; _this$ = ecx

; 68   : 	void				_dec		()								{	if (0==p_) return;	p_->dwReference--; 	if (0==p_->dwReference)	p_=0;						}

	mov	eax, DWORD PTR [ecx]
	test	eax, eax
	je	SHORT $LN5@ref_smem
	dec	DWORD PTR [eax]
	mov	eax, DWORD PTR [ecx]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN5@ref_smem
	mov	DWORD PTR [ecx], 0
$LN5@ref_smem:

; 76   : 	~ref_smem			()											{	_dec();														}

	ret	0
??1?$ref_smem@UvertBoned2W@@@@QAE@XZ ENDP		; ref_smem<vertBoned2W>::~ref_smem<vertBoned2W>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\xrsharedmem.h
;	COMDAT ??0?$ref_smem@UvertBoned2W@@@@QAE@ABV0@@Z
_TEXT	SEGMENT
_rhs$ = 8						; size = 4
??0?$ref_smem@UvertBoned2W@@@@QAE@ABV0@@Z PROC		; ref_smem<vertBoned2W>::ref_smem<vertBoned2W>, COMDAT
; _this$ = ecx

; 70   : 	void				_set		(ref_smem const &rhs)			{	smem_value* v = rhs.p_; if (0!=v) v->dwReference++; _dec(); p_ = v;							}

	mov	eax, DWORD PTR _rhs$[esp-4]

; 75   : 	ref_smem			(ref_smem<T> const &rhs)					{	p_ = 0;	_set(rhs);											}

	mov	DWORD PTR [ecx], 0

; 70   : 	void				_set		(ref_smem const &rhs)			{	smem_value* v = rhs.p_; if (0!=v) v->dwReference++; _dec(); p_ = v;							}

	mov	eax, DWORD PTR [eax]
	test	eax, eax
	je	SHORT $LN11@ref_smem
	inc	DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx]

; 68   : 	void				_dec		()								{	if (0==p_) return;	p_->dwReference--; 	if (0==p_->dwReference)	p_=0;						}

	test	edx, edx
	je	SHORT $LN11@ref_smem
	dec	DWORD PTR [edx]
$LN11@ref_smem:

; 75   : 	ref_smem			(ref_smem<T> const &rhs)					{	p_ = 0;	_set(rhs);											}

	mov	DWORD PTR [ecx], eax
	mov	eax, ecx
	ret	4
??0?$ref_smem@UvertBoned2W@@@@QAE@ABV0@@Z ENDP		; ref_smem<vertBoned2W>::ref_smem<vertBoned2W>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\xrsharedmem.h
;	COMDAT ??D?$ref_smem@UvertBoned1W@@@@QBEPAUvertBoned1W@@XZ
_TEXT	SEGMENT
??D?$ref_smem@UvertBoned1W@@@@QBEPAUvertBoned1W@@XZ PROC ; ref_smem<vertBoned1W>::operator*, COMDAT
; _this$ = ecx

; 86   : 	T*					operator*	() const						{	return p_?(T*)p_->value:0;									}

	mov	eax, DWORD PTR [ecx]
	lea	ecx, DWORD PTR [eax+16]
	neg	eax
	sbb	eax, eax
	and	eax, ecx
	ret	0
??D?$ref_smem@UvertBoned1W@@@@QBEPAUvertBoned1W@@XZ ENDP ; ref_smem<vertBoned1W>::operator*
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\xrsharedmem.h
;	COMDAT ??1?$ref_smem@UvertBoned1W@@@@QAE@XZ
_TEXT	SEGMENT
??1?$ref_smem@UvertBoned1W@@@@QAE@XZ PROC		; ref_smem<vertBoned1W>::~ref_smem<vertBoned1W>, COMDAT
; _this$ = ecx

; 68   : 	void				_dec		()								{	if (0==p_) return;	p_->dwReference--; 	if (0==p_->dwReference)	p_=0;						}

	mov	eax, DWORD PTR [ecx]
	test	eax, eax
	je	SHORT $LN5@ref_smem
	dec	DWORD PTR [eax]
	mov	eax, DWORD PTR [ecx]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN5@ref_smem
	mov	DWORD PTR [ecx], 0
$LN5@ref_smem:

; 76   : 	~ref_smem			()											{	_dec();														}

	ret	0
??1?$ref_smem@UvertBoned1W@@@@QAE@XZ ENDP		; ref_smem<vertBoned1W>::~ref_smem<vertBoned1W>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\xrsharedmem.h
;	COMDAT ??0?$ref_smem@UvertBoned1W@@@@QAE@ABV0@@Z
_TEXT	SEGMENT
_rhs$ = 8						; size = 4
??0?$ref_smem@UvertBoned1W@@@@QAE@ABV0@@Z PROC		; ref_smem<vertBoned1W>::ref_smem<vertBoned1W>, COMDAT
; _this$ = ecx

; 70   : 	void				_set		(ref_smem const &rhs)			{	smem_value* v = rhs.p_; if (0!=v) v->dwReference++; _dec(); p_ = v;							}

	mov	eax, DWORD PTR _rhs$[esp-4]

; 75   : 	ref_smem			(ref_smem<T> const &rhs)					{	p_ = 0;	_set(rhs);											}

	mov	DWORD PTR [ecx], 0

; 70   : 	void				_set		(ref_smem const &rhs)			{	smem_value* v = rhs.p_; if (0!=v) v->dwReference++; _dec(); p_ = v;							}

	mov	eax, DWORD PTR [eax]
	test	eax, eax
	je	SHORT $LN11@ref_smem
	inc	DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx]

; 68   : 	void				_dec		()								{	if (0==p_) return;	p_->dwReference--; 	if (0==p_->dwReference)	p_=0;						}

	test	edx, edx
	je	SHORT $LN11@ref_smem
	dec	DWORD PTR [edx]
$LN11@ref_smem:

; 75   : 	ref_smem			(ref_smem<T> const &rhs)					{	p_ = 0;	_set(rhs);											}

	mov	DWORD PTR [ecx], eax
	mov	eax, ecx
	ret	4
??0?$ref_smem@UvertBoned1W@@@@QAE@ABV0@@Z ENDP		; ref_smem<vertBoned1W>::ref_smem<vertBoned1W>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?push_back@?$vector@UWMFace@CSkeletonWallmark@@V?$xalloc@UWMFace@CSkeletonWallmark@@@@@std@@QAEXABUWMFace@CSkeletonWallmark@@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?push_back@?$vector@UWMFace@CSkeletonWallmark@@V?$xalloc@UWMFace@CSkeletonWallmark@@@@@std@@QAEXABUWMFace@CSkeletonWallmark@@@Z PROC ; std::vector<CSkeletonWallmark::WMFace,xalloc<CSkeletonWallmark::WMFace> >::push_back, COMDAT
; _this$ = ecx

; 742  :     _CONSTEXPR20_CONTAINER void push_back(const _Ty& _Val) { // insert element at end, provide strong guarantee

	mov	eax, ecx

; 730  :         if (_Mylast != _My_data._Myend) {

	mov	edx, DWORD PTR [eax+4]
	cmp	edx, DWORD PTR [eax+8]
	je	SHORT $LN4@push_back
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	push	esi
	mov	esi, DWORD PTR __Val$[esp]
	mov	ecx, 21					; 00000015H
	push	edi
	mov	edi, edx
	rep movsd
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 716  :         ++_Mylast;

	add	DWORD PTR [eax+4], 84			; 00000054H
	pop	edi
	pop	esi

; 743  :         emplace_back(_Val);
; 744  :     }

	ret	4
$LN4@push_back:

; 734  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	push	DWORD PTR __Val$[esp-4]
	push	edx
	call	??$_Emplace_reallocate@ABUWMFace@CSkeletonWallmark@@@?$vector@UWMFace@CSkeletonWallmark@@V?$xalloc@UWMFace@CSkeletonWallmark@@@@@std@@QAEPAUWMFace@CSkeletonWallmark@@QAU23@ABU23@@Z ; std::vector<CSkeletonWallmark::WMFace,xalloc<CSkeletonWallmark::WMFace> >::_Emplace_reallocate<CSkeletonWallmark::WMFace const &>

; 743  :         emplace_back(_Val);
; 744  :     }

	ret	4
?push_back@?$vector@UWMFace@CSkeletonWallmark@@V?$xalloc@UWMFace@CSkeletonWallmark@@@@@std@@QAEXABUWMFace@CSkeletonWallmark@@@Z ENDP ; std::vector<CSkeletonWallmark::WMFace,xalloc<CSkeletonWallmark::WMFace> >::push_back
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??$emplace_back@ABUWMFace@CSkeletonWallmark@@@?$vector@UWMFace@CSkeletonWallmark@@V?$xalloc@UWMFace@CSkeletonWallmark@@@@@std@@QAE?A_TABUWMFace@CSkeletonWallmark@@@Z
_TEXT	SEGMENT
_<_Val_0>$ = 8						; size = 4
??$emplace_back@ABUWMFace@CSkeletonWallmark@@@?$vector@UWMFace@CSkeletonWallmark@@V?$xalloc@UWMFace@CSkeletonWallmark@@@@@std@@QAE?A_TABUWMFace@CSkeletonWallmark@@@Z PROC ; std::vector<CSkeletonWallmark::WMFace,xalloc<CSkeletonWallmark::WMFace> >::emplace_back<CSkeletonWallmark::WMFace const &>, COMDAT
; _this$ = ecx

; 726  :     _CONSTEXPR20_CONTAINER decltype(auto) emplace_back(_Valty&&... _Val) {

	mov	eax, ecx

; 727  :         // insert by perfectly forwarding into element at end, provide strong guarantee
; 728  :         auto& _My_data   = _Mypair._Myval2;
; 729  :         pointer& _Mylast = _My_data._Mylast;
; 730  :         if (_Mylast != _My_data._Myend) {

	mov	edx, DWORD PTR [eax+4]
	cmp	edx, DWORD PTR [eax+8]
	je	SHORT $LN2@emplace_ba
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	push	esi
	mov	esi, DWORD PTR _<_Val_0>$[esp]
	mov	ecx, 21					; 00000015H
	push	edi
	mov	edi, edx
	rep movsd
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 716  :         ++_Mylast;

	add	DWORD PTR [eax+4], 84			; 00000054H
	pop	edi
	pop	esi

; 735  : #if _HAS_CXX17
; 736  :         return _Result;
; 737  : #else // ^^^ _HAS_CXX17 ^^^ // vvv !_HAS_CXX17 vvv
; 738  :         (void) _Result;
; 739  : #endif // _HAS_CXX17
; 740  :     }

	ret	4
$LN2@emplace_ba:

; 731  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);
; 732  :         }
; 733  : 
; 734  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	push	DWORD PTR _<_Val_0>$[esp-4]
	push	edx
	call	??$_Emplace_reallocate@ABUWMFace@CSkeletonWallmark@@@?$vector@UWMFace@CSkeletonWallmark@@V?$xalloc@UWMFace@CSkeletonWallmark@@@@@std@@QAEPAUWMFace@CSkeletonWallmark@@QAU23@ABU23@@Z ; std::vector<CSkeletonWallmark::WMFace,xalloc<CSkeletonWallmark::WMFace> >::_Emplace_reallocate<CSkeletonWallmark::WMFace const &>

; 735  : #if _HAS_CXX17
; 736  :         return _Result;
; 737  : #else // ^^^ _HAS_CXX17 ^^^ // vvv !_HAS_CXX17 vvv
; 738  :         (void) _Result;
; 739  : #endif // _HAS_CXX17
; 740  :     }

	ret	4
??$emplace_back@ABUWMFace@CSkeletonWallmark@@@?$vector@UWMFace@CSkeletonWallmark@@V?$xalloc@UWMFace@CSkeletonWallmark@@@@@std@@QAE?A_TABUWMFace@CSkeletonWallmark@@@Z ENDP ; std::vector<CSkeletonWallmark::WMFace,xalloc<CSkeletonWallmark::WMFace> >::emplace_back<CSkeletonWallmark::WMFace const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??$_Emplace_back_with_unused_capacity@ABUWMFace@CSkeletonWallmark@@@?$vector@UWMFace@CSkeletonWallmark@@V?$xalloc@UWMFace@CSkeletonWallmark@@@@@std@@AAE?A_TABUWMFace@CSkeletonWallmark@@@Z
_TEXT	SEGMENT
_<_Val_0>$ = 8						; size = 4
??$_Emplace_back_with_unused_capacity@ABUWMFace@CSkeletonWallmark@@@?$vector@UWMFace@CSkeletonWallmark@@V?$xalloc@UWMFace@CSkeletonWallmark@@@@@std@@AAE?A_TABUWMFace@CSkeletonWallmark@@@Z PROC ; std::vector<CSkeletonWallmark::WMFace,xalloc<CSkeletonWallmark::WMFace> >::_Emplace_back_with_unused_capacity<CSkeletonWallmark::WMFace const &>, COMDAT
; _this$ = ecx

; 708  :     _CONSTEXPR20_CONTAINER decltype(auto) _Emplace_back_with_unused_capacity(_Valty&&... _Val) {

	mov	eax, ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	ecx, 21					; 00000015H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 708  :     _CONSTEXPR20_CONTAINER decltype(auto) _Emplace_back_with_unused_capacity(_Valty&&... _Val) {

	push	esi
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	esi, DWORD PTR _<_Val_0>$[esp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 708  :     _CONSTEXPR20_CONTAINER decltype(auto) _Emplace_back_with_unused_capacity(_Valty&&... _Val) {

	push	edi
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	edi, DWORD PTR [eax+4]
	rep movsd
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 716  :         ++_Mylast;

	add	DWORD PTR [eax+4], 84			; 00000054H
	pop	edi
	pop	esi

; 717  : #if _HAS_CXX17
; 718  :         return _Result;
; 719  : #else // ^^^ _HAS_CXX17 ^^^ // vvv !_HAS_CXX17 vvv
; 720  :         (void) _Result;
; 721  : #endif // _HAS_CXX17
; 722  :     }

	ret	4
??$_Emplace_back_with_unused_capacity@ABUWMFace@CSkeletonWallmark@@@?$vector@UWMFace@CSkeletonWallmark@@V?$xalloc@UWMFace@CSkeletonWallmark@@@@@std@@AAE?A_TABUWMFace@CSkeletonWallmark@@@Z ENDP ; std::vector<CSkeletonWallmark::WMFace,xalloc<CSkeletonWallmark::WMFace> >::_Emplace_back_with_unused_capacity<CSkeletonWallmark::WMFace const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ??A?$xr_vector@V?$xr_vector@GV?$xalloc@G@@@@V?$xalloc@V?$xr_vector@GV?$xalloc@G@@@@@@@@QAEAAV?$xr_vector@GV?$xalloc@G@@@@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$xr_vector@V?$xr_vector@GV?$xalloc@G@@@@V?$xalloc@V?$xr_vector@GV?$xalloc@G@@@@@@@@QAEAAV?$xr_vector@GV?$xalloc@G@@@@I@Z PROC ; xr_vector<xr_vector<unsigned short,xalloc<unsigned short> >,xalloc<xr_vector<unsigned short,xalloc<unsigned short> > > >::operator[], COMDAT
; _this$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 119  :         _Ptr += _Off;

	mov	eax, DWORD PTR __Pos$[esp-4]
	lea	edx, DWORD PTR [eax+eax*2]
	mov	eax, DWORD PTR [ecx]
	lea	eax, DWORD PTR [eax+edx*4]
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 138  : 	reference operator[]		(size_type _Pos)					{ {VERIFY(_Pos<size());} return (*(begin() + _Pos)); }

	ret	4
??A?$xr_vector@V?$xr_vector@GV?$xalloc@G@@@@V?$xalloc@V?$xr_vector@GV?$xalloc@G@@@@@@@@QAEAAV?$xr_vector@GV?$xalloc@G@@@@I@Z ENDP ; xr_vector<xr_vector<unsigned short,xalloc<unsigned short> >,xalloc<xr_vector<unsigned short,xalloc<unsigned short> > > >::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?begin@?$vector@V?$xr_vector@GV?$xalloc@G@@@@V?$xalloc@V?$xr_vector@GV?$xalloc@G@@@@@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$xr_vector@GV?$xalloc@G@@@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@V?$xr_vector@GV?$xalloc@G@@@@V?$xalloc@V?$xr_vector@GV?$xalloc@G@@@@@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$xr_vector@GV?$xalloc@G@@@@@std@@@std@@@2@XZ PROC ; std::vector<xr_vector<unsigned short,xalloc<unsigned short> >,xalloc<xr_vector<unsigned short,xalloc<unsigned short> > > >::begin, COMDAT
; _this$ = ecx

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	ecx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], ecx

; 1462 :         auto& _My_data = _Mypair._Myval2;
; 1463 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));
; 1464 :     }

	ret	4
?begin@?$vector@V?$xr_vector@GV?$xalloc@G@@@@V?$xalloc@V?$xr_vector@GV?$xalloc@G@@@@@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$xr_vector@GV?$xalloc@G@@@@@std@@@std@@@2@XZ ENDP ; std::vector<xr_vector<unsigned short,xalloc<unsigned short> >,xalloc<xr_vector<unsigned short,xalloc<unsigned short> > > >::begin
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
;	COMDAT ?transform_tiny@?$_matrix@M@@QBEXAAU?$_vector3@M@@@Z
_TEXT	SEGMENT
_v$ = 8							; size = 4
?transform_tiny@?$_matrix@M@@QBEXAAU?$_vector3@M@@@Z PROC ; _matrix<float>::transform_tiny, COMDAT
; _this$ = ecx

; 499  : 		dest.x = v.x*_11 + v.y*_21 + v.z*_31 + _41;

	mov	eax, DWORD PTR _v$[esp-4]
	movss	xmm4, DWORD PTR [eax+4]
	movss	xmm5, DWORD PTR [eax]
	movaps	xmm3, xmm4
	mulss	xmm3, DWORD PTR [ecx+16]
	movaps	xmm0, xmm5
	mulss	xmm0, DWORD PTR [ecx]

; 500  : 		dest.y = v.x*_12 + v.y*_22 + v.z*_32 + _42;

	movaps	xmm1, xmm5
	movss	xmm2, DWORD PTR [eax+8]
	mulss	xmm1, DWORD PTR [ecx+4]

; 501  : 		dest.z = v.x*_13 + v.y*_23 + v.z*_33 + _43;

	mulss	xmm5, DWORD PTR [ecx+8]
	addss	xmm3, xmm0
	movaps	xmm0, xmm2
	mulss	xmm0, DWORD PTR [ecx+32]
	addss	xmm0, DWORD PTR [ecx+48]
	addss	xmm3, xmm0
	movaps	xmm0, xmm4
	mulss	xmm0, DWORD PTR [ecx+20]
	mulss	xmm4, DWORD PTR [ecx+24]
	addss	xmm1, xmm0
	movaps	xmm0, xmm2
	mulss	xmm0, DWORD PTR [ecx+36]
	mulss	xmm2, DWORD PTR [ecx+40]
	addss	xmm5, xmm4
	addss	xmm0, DWORD PTR [ecx+52]
	addss	xmm2, DWORD PTR [ecx+56]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 24   : 	ICF SelfRef	set(const _vector3<float> &v)			{ x = T(v.x);	y = T(v.y);	z = T(v.z);	return *this;	};

	movss	DWORD PTR [eax], xmm3
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 500  : 		dest.y = v.x*_12 + v.y*_22 + v.z*_32 + _42;

	addss	xmm1, xmm0

; 501  : 		dest.z = v.x*_13 + v.y*_23 + v.z*_33 + _43;

	addss	xmm5, xmm2
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 24   : 	ICF SelfRef	set(const _vector3<float> &v)			{ x = T(v.x);	y = T(v.y);	z = T(v.z);	return *this;	};

	movss	DWORD PTR [eax+4], xmm1
	movss	DWORD PTR [eax+8], xmm5
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 540  : 	}

	ret	4
?transform_tiny@?$_matrix@M@@QBEXAAU?$_vector3@M@@@Z ENDP ; _matrix<float>::transform_tiny
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?end@?$vector@GV?$xalloc@G@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@G@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@GV?$xalloc@G@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@G@std@@@std@@@2@XZ PROC ; std::vector<unsigned short,xalloc<unsigned short> >::end, COMDAT
; _this$ = ecx

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	ecx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax], ecx

; 1472 :         auto& _My_data = _Mypair._Myval2;
; 1473 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));
; 1474 :     }

	ret	4
?end@?$vector@GV?$xalloc@G@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@G@std@@@std@@@2@XZ ENDP ; std::vector<unsigned short,xalloc<unsigned short> >::end
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
;	COMDAT ?square_magnitude@?$_vector3@M@@QBEMXZ
_TEXT	SEGMENT
?square_magnitude@?$_vector3@M@@QBEMXZ PROC		; _vector3<float>::square_magnitude, COMDAT
; _this$ = ecx

; 167  : 		return x*x + y*y + z*z;

	fld	DWORD PTR [ecx+4]
	fld	DWORD PTR [ecx+8]
	fld	DWORD PTR [ecx]
	fmul	ST(0), ST(0)
	fxch	ST(2)
	fmul	ST(0), ST(0)
	faddp	ST(2), ST(0)
	fmul	ST(0), ST(0)
	faddp	ST(1), ST(0)

; 168  : 	}

	ret	0
?square_magnitude@?$_vector3@M@@QBEMXZ ENDP		; _vector3<float>::square_magnitude
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
;	COMDAT ?lerp@?$_vector3@M@@QAEAAU1@ABU1@0M@Z
_TEXT	SEGMENT
_p1$ = 8						; size = 4
_p2$ = 12						; size = 4
_t$ = 16						; size = 4
?lerp@?$_vector3@M@@QAEAAU1@ABU1@0M@Z PROC		; _vector3<float>::lerp, COMDAT
; _this$ = ecx

; 127  : 		T invt = 1.f-t;

	movss	xmm2, DWORD PTR _t$[esp-4]
	movss	xmm3, DWORD PTR __real@3f800000

; 128  : 		x = p1.x*invt + p2.x*t;

	movaps	xmm0, xmm2
	mov	eax, DWORD PTR _p2$[esp-4]
	subss	xmm3, xmm2
	mov	edx, DWORD PTR _p1$[esp-4]
	mulss	xmm0, DWORD PTR [eax]
	movaps	xmm1, xmm3
	mulss	xmm1, DWORD PTR [edx]
	addss	xmm1, xmm0

; 129  : 		y = p1.y*invt + p2.y*t;

	movaps	xmm0, xmm2
	movss	DWORD PTR [ecx], xmm1
	movaps	xmm1, xmm3
	mulss	xmm0, DWORD PTR [eax+4]
	mulss	xmm1, DWORD PTR [edx+4]
	addss	xmm1, xmm0
	movss	DWORD PTR [ecx+4], xmm1

; 130  : 		z = p1.z*invt + p2.z*t;

	mulss	xmm2, DWORD PTR [eax+8]

; 131  : 		return *this;	

	mov	eax, ecx
	mulss	xmm3, DWORD PTR [edx+8]
	addss	xmm3, xmm2
	movss	DWORD PTR [ecx+8], xmm3

; 132  : 	}

	ret	12					; 0000000cH
?lerp@?$_vector3@M@@QAEAAU1@ABU1@0M@Z ENDP		; _vector3<float>::lerp
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$xr_vector@GV?$xalloc@G@@@@@std@@@std@@@std@@QAE@PAV?$xr_vector@GV?$xalloc@G@@@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
___param0$ = 8						; size = 4
___param1$dead$ = 12					; size = 4
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$xr_vector@GV?$xalloc@G@@@@@std@@@std@@@std@@QAE@PAV?$xr_vector@GV?$xalloc@G@@@@PBU_Container_base0@1@@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<xr_vector<unsigned short,xalloc<unsigned short> > > > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<xr_vector<unsigned short,xalloc<unsigned short> > > > >, COMDAT
; _this$ = ecx

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	eax, DWORD PTR ___param0$[esp-4]
	mov	DWORD PTR [ecx], eax
	mov	eax, ecx
	ret	8
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$xr_vector@GV?$xalloc@G@@@@@std@@@std@@@std@@QAE@PAV?$xr_vector@GV?$xalloc@G@@@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<xr_vector<unsigned short,xalloc<unsigned short> > > > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<xr_vector<unsigned short,xalloc<unsigned short> > > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@G@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@G@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned short> > >::operator==, COMDAT
; _this$ = ecx

; 149  :         _Compat(_Right);
; 150  :         return _Ptr == _Right._Ptr;

	mov	eax, DWORD PTR __Right$[esp-4]
	mov	ecx, DWORD PTR [ecx]
	cmp	ecx, DWORD PTR [eax]
	sete	al

; 151  :     }

	ret	4
??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@G@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned short> > >::operator==
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@G@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@G@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned short> > >::operator++, COMDAT
; _this$ = ecx

; 68   : #if _ITERATOR_DEBUG_LEVEL != 0
; 69   :         const auto _Mycont = static_cast<const _Myvec*>(this->_Getcont());
; 70   :         _STL_VERIFY(_Ptr, "can't increment value-initialized vector iterator");
; 71   :         _STL_VERIFY(_Ptr < _Mycont->_Mylast, "can't increment vector iterator past end");
; 72   : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 73   : 
; 74   :         ++_Ptr;

	add	DWORD PTR [ecx], 2

; 75   :         return *this;

	mov	eax, ecx

; 76   :     }

	ret	0
??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@G@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned short> > >::operator++
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\xrsharedmem.h
;	COMDAT ?_set@?$ref_smem@UvertBoned2W@@@@QAEXABV1@@Z
_TEXT	SEGMENT
_rhs$ = 8						; size = 4
?_set@?$ref_smem@UvertBoned2W@@@@QAEXABV1@@Z PROC	; ref_smem<vertBoned2W>::_set, COMDAT
; _this$ = ecx

; 70   : 	void				_set		(ref_smem const &rhs)			{	smem_value* v = rhs.p_; if (0!=v) v->dwReference++; _dec(); p_ = v;							}

	mov	eax, DWORD PTR _rhs$[esp-4]
	mov	edx, ecx
	mov	eax, DWORD PTR [eax]
	test	eax, eax
	je	SHORT $LN2@set
	inc	DWORD PTR [eax]
$LN2@set:

; 68   : 	void				_dec		()								{	if (0==p_) return;	p_->dwReference--; 	if (0==p_->dwReference)	p_=0;						}

	mov	ecx, DWORD PTR [edx]
	test	ecx, ecx
	je	SHORT $LN8@set
	dec	DWORD PTR [ecx]
$LN8@set:

; 70   : 	void				_set		(ref_smem const &rhs)			{	smem_value* v = rhs.p_; if (0!=v) v->dwReference++; _dec(); p_ = v;							}

	mov	DWORD PTR [edx], eax
	ret	4
?_set@?$ref_smem@UvertBoned2W@@@@QAEXABV1@@Z ENDP	; ref_smem<vertBoned2W>::_set
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\xrsharedmem.h
;	COMDAT ?_dec@?$ref_smem@UvertBoned2W@@@@IAEXXZ
_TEXT	SEGMENT
?_dec@?$ref_smem@UvertBoned2W@@@@IAEXXZ PROC		; ref_smem<vertBoned2W>::_dec, COMDAT
; _this$ = ecx

; 68   : 	void				_dec		()								{	if (0==p_) return;	p_->dwReference--; 	if (0==p_->dwReference)	p_=0;						}

	mov	eax, DWORD PTR [ecx]
	test	eax, eax
	je	SHORT $LN3@dec
	dec	DWORD PTR [eax]
	mov	eax, DWORD PTR [ecx]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN3@dec
	mov	DWORD PTR [ecx], 0
$LN3@dec:
	ret	0
?_dec@?$ref_smem@UvertBoned2W@@@@IAEXXZ ENDP		; ref_smem<vertBoned2W>::_dec
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\xrsharedmem.h
;	COMDAT ?_set@?$ref_smem@UvertBoned1W@@@@QAEXABV1@@Z
_TEXT	SEGMENT
_rhs$ = 8						; size = 4
?_set@?$ref_smem@UvertBoned1W@@@@QAEXABV1@@Z PROC	; ref_smem<vertBoned1W>::_set, COMDAT
; _this$ = ecx

; 70   : 	void				_set		(ref_smem const &rhs)			{	smem_value* v = rhs.p_; if (0!=v) v->dwReference++; _dec(); p_ = v;							}

	mov	eax, DWORD PTR _rhs$[esp-4]
	mov	edx, ecx
	mov	eax, DWORD PTR [eax]
	test	eax, eax
	je	SHORT $LN2@set
	inc	DWORD PTR [eax]
$LN2@set:

; 68   : 	void				_dec		()								{	if (0==p_) return;	p_->dwReference--; 	if (0==p_->dwReference)	p_=0;						}

	mov	ecx, DWORD PTR [edx]
	test	ecx, ecx
	je	SHORT $LN8@set
	dec	DWORD PTR [ecx]
$LN8@set:

; 70   : 	void				_set		(ref_smem const &rhs)			{	smem_value* v = rhs.p_; if (0!=v) v->dwReference++; _dec(); p_ = v;							}

	mov	DWORD PTR [edx], eax
	ret	4
?_set@?$ref_smem@UvertBoned1W@@@@QAEXABV1@@Z ENDP	; ref_smem<vertBoned1W>::_set
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\xrsharedmem.h
;	COMDAT ?_dec@?$ref_smem@UvertBoned1W@@@@IAEXXZ
_TEXT	SEGMENT
?_dec@?$ref_smem@UvertBoned1W@@@@IAEXXZ PROC		; ref_smem<vertBoned1W>::_dec, COMDAT
; _this$ = ecx

; 68   : 	void				_dec		()								{	if (0==p_) return;	p_->dwReference--; 	if (0==p_->dwReference)	p_=0;						}

	mov	eax, DWORD PTR [ecx]
	test	eax, eax
	je	SHORT $LN3@dec
	dec	DWORD PTR [eax]
	mov	eax, DWORD PTR [ecx]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN3@dec
	mov	DWORD PTR [ecx], 0
$LN3@dec:
	ret	0
?_dec@?$ref_smem@UvertBoned1W@@@@IAEXXZ ENDP		; ref_smem<vertBoned1W>::_dec
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Getal@?$vector@UWMFace@CSkeletonWallmark@@V?$xalloc@UWMFace@CSkeletonWallmark@@@@@std@@AAEAAV?$xalloc@UWMFace@CSkeletonWallmark@@@@XZ
_TEXT	SEGMENT
?_Getal@?$vector@UWMFace@CSkeletonWallmark@@V?$xalloc@UWMFace@CSkeletonWallmark@@@@@std@@AAEAAV?$xalloc@UWMFace@CSkeletonWallmark@@@@XZ PROC ; std::vector<CSkeletonWallmark::WMFace,xalloc<CSkeletonWallmark::WMFace> >::_Getal, COMDAT
; _this$ = ecx

; 1805 :         return _Mypair._Get_first();

	mov	eax, ecx

; 1806 :     }

	ret	0
?_Getal@?$vector@UWMFace@CSkeletonWallmark@@V?$xalloc@UWMFace@CSkeletonWallmark@@@@@std@@AAEAAV?$xalloc@UWMFace@CSkeletonWallmark@@@@XZ ENDP ; std::vector<CSkeletonWallmark::WMFace,xalloc<CSkeletonWallmark::WMFace> >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Orphan_range@?$vector@UWMFace@CSkeletonWallmark@@V?$xalloc@UWMFace@CSkeletonWallmark@@@@@std@@ABEXPAUWMFace@CSkeletonWallmark@@0@Z
_TEXT	SEGMENT
___formal$dead$ = 8					; size = 4
___formal$dead$ = 12					; size = 4
?_Orphan_range@?$vector@UWMFace@CSkeletonWallmark@@V?$xalloc@UWMFace@CSkeletonWallmark@@@@@std@@ABEXPAUWMFace@CSkeletonWallmark@@0@Z PROC ; std::vector<CSkeletonWallmark::WMFace,xalloc<CSkeletonWallmark::WMFace> >::_Orphan_range, COMDAT
; _this$dead$ = ecx

; 1801 :     _CONSTEXPR20_CONTAINER void _Orphan_range(pointer, pointer) const {}

	ret	8
?_Orphan_range@?$vector@UWMFace@CSkeletonWallmark@@V?$xalloc@UWMFace@CSkeletonWallmark@@@@@std@@ABEXPAUWMFace@CSkeletonWallmark@@0@Z ENDP ; std::vector<CSkeletonWallmark::WMFace,xalloc<CSkeletonWallmark::WMFace> >::_Orphan_range
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$xr_vector@GV?$xalloc@G@@@@@std@@@std@@@std@@QBE?AV01@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$xr_vector@GV?$xalloc@G@@@@@std@@@std@@@std@@QBE?AV01@H@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<xr_vector<unsigned short,xalloc<unsigned short> > > > >::operator+, COMDAT
; _this$ = ecx

; 119  :         _Ptr += _Off;

	mov	eax, DWORD PTR __Off$[esp-4]
	lea	edx, DWORD PTR [eax+eax*2]
	mov	eax, DWORD PTR [ecx]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 303  :         _Vector_iterator _Tmp = *this;
; 304  :         _Tmp += _Off; // TRANSITION, LLVM-49342
; 305  :         return _Tmp;
; 306  :     }

	ret	8
??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$xr_vector@GV?$xalloc@G@@@@@std@@@std@@@std@@QBE?AV01@H@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<xr_vector<unsigned short,xalloc<unsigned short> > > > >::operator+
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$xr_vector@GV?$xalloc@G@@@@@std@@@std@@@std@@QBEAAV?$xr_vector@GV?$xalloc@G@@@@XZ
_TEXT	SEGMENT
??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$xr_vector@GV?$xalloc@G@@@@@std@@@std@@@std@@QBEAAV?$xr_vector@GV?$xalloc@G@@@@XZ PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<xr_vector<unsigned short,xalloc<unsigned short> > > > >::operator*, COMDAT
; _this$ = ecx

; 261  :         return const_cast<reference>(_Mybase::operator*());

	mov	eax, DWORD PTR [ecx]

; 262  :     }

	ret	0
??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$xr_vector@GV?$xalloc@G@@@@@std@@@std@@@std@@QBEAAV?$xr_vector@GV?$xalloc@G@@@@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<xr_vector<unsigned short,xalloc<unsigned short> > > > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$xr_vector@GV?$xalloc@G@@@@@std@@@std@@@std@@QAE@PAV?$xr_vector@GV?$xalloc@G@@@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Pvector$dead$ = 12					; size = 4
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$xr_vector@GV?$xalloc@G@@@@@std@@@std@@@std@@QAE@PAV?$xr_vector@GV?$xalloc@G@@@@PBU_Container_base0@1@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<xr_vector<unsigned short,xalloc<unsigned short> > > > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<xr_vector<unsigned short,xalloc<unsigned short> > > > >, COMDAT
; _this$ = ecx

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	eax, DWORD PTR __Parg$[esp-4]
	mov	DWORD PTR [ecx], eax

; 42   :         this->_Adopt(_Pvector);
; 43   :     }

	mov	eax, ecx
	ret	8
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$xr_vector@GV?$xalloc@G@@@@@std@@@std@@@std@@QAE@PAV?$xr_vector@GV?$xalloc@G@@@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<xr_vector<unsigned short,xalloc<unsigned short> > > > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<xr_vector<unsigned short,xalloc<unsigned short> > > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@G@std@@@std@@@std@@QBEXABV12@@Z
_TEXT	SEGMENT
__Right$dead$ = 8					; size = 4
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@G@std@@@std@@@std@@QBEXABV12@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned short> > >::_Compat, COMDAT
; _this$dead$ = ecx

; 182  :         // test for compatible iterator pair
; 183  : #if _ITERATOR_DEBUG_LEVEL == 0
; 184  :         (void) _Right;
; 185  : #else // ^^^ _ITERATOR_DEBUG_LEVEL == 0 ^^^ // vvv _ITERATOR_DEBUG_LEVEL != 0 vvv
; 186  :         _STL_VERIFY(this->_Getcont() == _Right._Getcont(), "vector iterators incompatible");
; 187  : #endif // _ITERATOR_DEBUG_LEVEL == 0
; 188  :     }

	ret	4
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@G@std@@@std@@@std@@QBEXABV12@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned short> > >::_Compat
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$xalloc@UWMFace@CSkeletonWallmark@@@@V?$_Vector_val@U?$_Simple_types@UWMFace@CSkeletonWallmark@@@std@@@std@@$00@std@@QAEAAV?$xalloc@UWMFace@CSkeletonWallmark@@@@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@V?$xalloc@UWMFace@CSkeletonWallmark@@@@V?$_Vector_val@U?$_Simple_types@UWMFace@CSkeletonWallmark@@@std@@@std@@$00@std@@QAEAAV?$xalloc@UWMFace@CSkeletonWallmark@@@@XZ PROC ; std::_Compressed_pair<xalloc<CSkeletonWallmark::WMFace>,std::_Vector_val<std::_Simple_types<CSkeletonWallmark::WMFace> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 1339 :         return *this;

	mov	eax, ecx

; 1340 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$xalloc@UWMFace@CSkeletonWallmark@@@@V?$_Vector_val@U?$_Simple_types@UWMFace@CSkeletonWallmark@@@std@@@std@@$00@std@@QAEAAV?$xalloc@UWMFace@CSkeletonWallmark@@@@XZ ENDP ; std::_Compressed_pair<xalloc<CSkeletonWallmark::WMFace>,std::_Vector_val<std::_Simple_types<CSkeletonWallmark::WMFace> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Destroy@?$vector@UWMFace@CSkeletonWallmark@@V?$xalloc@UWMFace@CSkeletonWallmark@@@@@std@@AAEXPAUWMFace@CSkeletonWallmark@@0@Z
_TEXT	SEGMENT
__First$dead$ = 8					; size = 4
__Last$dead$ = 12					; size = 4
?_Destroy@?$vector@UWMFace@CSkeletonWallmark@@V?$xalloc@UWMFace@CSkeletonWallmark@@@@@std@@AAEXPAUWMFace@CSkeletonWallmark@@0@Z PROC ; std::vector<CSkeletonWallmark::WMFace,xalloc<CSkeletonWallmark::WMFace> >::_Destroy, COMDAT
; _this$dead$ = ecx

; 1666 :         // destroy [_First, _Last) using allocator
; 1667 :         _Destroy_range(_First, _Last, _Getal());
; 1668 :     }

	ret	8
?_Destroy@?$vector@UWMFace@CSkeletonWallmark@@V?$xalloc@UWMFace@CSkeletonWallmark@@@@@std@@AAEXPAUWMFace@CSkeletonWallmark@@0@Z ENDP ; std::vector<CSkeletonWallmark::WMFace,xalloc<CSkeletonWallmark::WMFace> >::_Destroy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?deallocate@?$xalloc@UWMFace@CSkeletonWallmark@@@@QBEXPAUWMFace@CSkeletonWallmark@@I@Z
_TEXT	SEGMENT
_p$ = 8							; size = 4
_n$dead$ = 12						; size = 4
?deallocate@?$xalloc@UWMFace@CSkeletonWallmark@@@@QBEXPAUWMFace@CSkeletonWallmark@@I@Z PROC ; xalloc<CSkeletonWallmark::WMFace>::deallocate, COMDAT
; _this$dead$ = ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	eax, DWORD PTR _p$[esp-4]
	test	eax, eax
	je	SHORT $LN4@deallocate
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN4@deallocate:
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 82   : 							void					deallocate		(pointer p, size_type n) const			{	xr_free	(p);				}

	ret	8
?deallocate@?$xalloc@UWMFace@CSkeletonWallmark@@@@QBEXPAUWMFace@CSkeletonWallmark@@I@Z ENDP ; xalloc<CSkeletonWallmark::WMFace>::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$xr_vector@GV?$xalloc@G@@@@@std@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$xr_vector@GV?$xalloc@G@@@@@std@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<xr_vector<unsigned short,xalloc<unsigned short> > > > >::operator+=, COMDAT
; _this$ = ecx

; 119  :         _Ptr += _Off;

	mov	eax, DWORD PTR __Off$[esp-4]
	lea	eax, DWORD PTR [eax+eax*2]
	shl	eax, 2
	add	DWORD PTR [ecx], eax

; 298  :         _Mybase::operator+=(_Off);
; 299  :         return *this;

	mov	eax, ecx

; 300  :     }

	ret	4
??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$xr_vector@GV?$xalloc@G@@@@@std@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<xr_vector<unsigned short,xalloc<unsigned short> > > > >::operator+=
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$xr_vector@GV?$xalloc@G@@@@@std@@@std@@@std@@QBEABV?$xr_vector@GV?$xalloc@G@@@@XZ
_TEXT	SEGMENT
??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$xr_vector@GV?$xalloc@G@@@@@std@@@std@@@std@@QBEABV?$xr_vector@GV?$xalloc@G@@@@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<xr_vector<unsigned short,xalloc<unsigned short> > > > >::operator*, COMDAT
; _this$ = ecx

; 46   : #if _ITERATOR_DEBUG_LEVEL != 0
; 47   :         const auto _Mycont = static_cast<const _Myvec*>(this->_Getcont());
; 48   :         _STL_VERIFY(_Ptr, "can't dereference value-initialized vector iterator");
; 49   :         _STL_VERIFY(
; 50   :             _Mycont->_Myfirst <= _Ptr && _Ptr < _Mycont->_Mylast, "can't dereference out of range vector iterator");
; 51   : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 52   : 
; 53   :         return *_Ptr;

	mov	eax, DWORD PTR [ecx]

; 54   :     }

	ret	0
??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$xr_vector@GV?$xalloc@G@@@@@std@@@std@@@std@@QBEABV?$xr_vector@GV?$xalloc@G@@@@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<xr_vector<unsigned short,xalloc<unsigned short> > > > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$xr_vector@GV?$xalloc@G@@@@@std@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$xr_vector@GV?$xalloc@G@@@@@std@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<xr_vector<unsigned short,xalloc<unsigned short> > > > >::operator+=, COMDAT
; _this$ = ecx

; 118  :         _Verify_offset(_Off);
; 119  :         _Ptr += _Off;

	mov	eax, DWORD PTR __Off$[esp-4]
	lea	eax, DWORD PTR [eax+eax*2]
	shl	eax, 2
	add	DWORD PTR [ecx], eax

; 120  :         return *this;

	mov	eax, ecx

; 121  :     }

	ret	4
??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$xr_vector@GV?$xalloc@G@@@@@std@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<xr_vector<unsigned short,xalloc<unsigned short> > > > >::operator+=
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Verify_offset@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$xr_vector@GV?$xalloc@G@@@@@std@@@std@@@std@@QBEXH@Z
_TEXT	SEGMENT
__Off$dead$ = 8						; size = 4
?_Verify_offset@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$xr_vector@GV?$xalloc@G@@@@@std@@@std@@@std@@QBEXH@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<xr_vector<unsigned short,xalloc<unsigned short> > > > >::_Verify_offset, COMDAT
; _this$dead$ = ecx

; 102  : #if _ITERATOR_DEBUG_LEVEL == 0
; 103  :         (void) _Off;
; 104  : #else // ^^^ _ITERATOR_DEBUG_LEVEL == 0 ^^^ // vvv _ITERATOR_DEBUG_LEVEL != 0 vvv
; 105  :         const auto _Mycont = static_cast<const _Myvec*>(this->_Getcont());
; 106  :         _STL_VERIFY(_Off == 0 || _Ptr, "cannot seek value-initialized vector iterator");
; 107  :         if (_Off < 0) {
; 108  :             _STL_VERIFY(_Off >= _Mycont->_Myfirst - _Ptr, "cannot seek vector iterator before begin");
; 109  :         }
; 110  : 
; 111  :         if (_Off > 0) {
; 112  :             _STL_VERIFY(_Off <= _Mycont->_Mylast - _Ptr, "cannot seek vector iterator after end");
; 113  :         }
; 114  : #endif // _ITERATOR_DEBUG_LEVEL == 0
; 115  :     }

	ret	4
?_Verify_offset@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$xr_vector@GV?$xalloc@G@@@@@std@@@std@@@std@@QBEXH@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<xr_vector<unsigned short,xalloc<unsigned short> > > > >::_Verify_offset
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xrsharedmem.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xrsharedmem.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp
;	COMDAT ??$TEnumBoneVertices@V?$ref_smem@UvertBoned1W@@@@@@YAXV?$ref_smem@UvertBoned1W@@@@PAGAAV?$xr_vector@GV?$xalloc@G@@@@AAUSEnumVerticesCallback@@@Z
_TEXT	SEGMENT
_faces$1$ = -20						; size = 4
_indices$1$ = -16					; size = 4
_P$1 = -12						; size = 12
_vertices$ = 8						; size = 4
_C$ = 12						; size = 4
??$TEnumBoneVertices@V?$ref_smem@UvertBoned1W@@@@@@YAXV?$ref_smem@UvertBoned1W@@@@PAGAAV?$xr_vector@GV?$xalloc@G@@@@AAUSEnumVerticesCallback@@@Z PROC ; TEnumBoneVertices<ref_smem<vertBoned1W> >, COMDAT
; _indices$ = ecx
; _faces$ = edx

; 610  : {

	sub	esp, 20					; 00000014H
	mov	eax, edx
	mov	DWORD PTR _indices$1$[esp+20], ecx
	push	esi
	mov	DWORD PTR _faces$1$[esp+24], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	esi, DWORD PTR [eax]

; 150  :         return _Ptr == _Right._Ptr;

	cmp	esi, DWORD PTR [eax+4]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp

; 611  : 		for (CBoneData::FacesVecIt it=faces.begin(); it!=faces.end(); it++){

	je	SHORT $LN3@TEnumBoneV
	push	ebx
	push	ebp
	mov	ebp, DWORD PTR _C$[esp+28]
	push	edi
	npad	4
$LL4@TEnumBoneV:

; 612  : 			u32 idx			= (*it)*3;

	movzx	eax, WORD PTR [esi]
	mov	ebx, 3
	lea	eax, DWORD PTR [eax+eax*2]
	lea	edi, DWORD PTR [ecx+eax*2]
	npad	2
$LL7@TEnumBoneV:

; 615  : 				vertices[indices[idx+k]].get_pos( P );

	lea	eax, DWORD PTR _P$1[esp+36]
	push	eax
	movzx	eax, WORD PTR [edi]
; File I:\Vitalya\mine\NSProjectX\xrCore\xrsharedmem.h

; 88   : 	T&					operator[]	(size_t id)						{	return ((T*)(p_->value))[id];								}

	mov	ecx, eax
	shl	ecx, 4
	sub	ecx, eax
	mov	eax, DWORD PTR _vertices$[esp+36]
	add	eax, 16					; 00000010H
	lea	ecx, DWORD PTR [eax+ecx*4]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp

; 615  : 				vertices[indices[idx+k]].get_pos( P );

	call	DWORD PTR __imp_?get_pos@vertBoned1W@@QAEXAAU?$_vector3@M@@@Z

; 616  : 				C( P );

	mov	eax, DWORD PTR [ebp]
	lea	ecx, DWORD PTR _P$1[esp+36]
	push	ecx
	mov	ecx, ebp
	call	DWORD PTR [eax]
	lea	edi, DWORD PTR [edi+2]
	sub	ebx, 1
	jne	SHORT $LL7@TEnumBoneV
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 150  :         return _Ptr == _Right._Ptr;

	mov	eax, DWORD PTR _faces$1$[esp+36]

; 74   :         ++_Ptr;

	add	esi, 2
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp

; 611  : 		for (CBoneData::FacesVecIt it=faces.begin(); it!=faces.end(); it++){

	mov	ecx, DWORD PTR _indices$1$[esp+36]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 150  :         return _Ptr == _Right._Ptr;

	cmp	esi, DWORD PTR [eax+4]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp

; 611  : 		for (CBoneData::FacesVecIt it=faces.begin(); it!=faces.end(); it++){

	jne	SHORT $LL4@TEnumBoneV
	pop	edi
	pop	ebp
	pop	ebx
$LN3@TEnumBoneV:
; File I:\Vitalya\mine\NSProjectX\xrCore\xrsharedmem.h

; 68   : 	void				_dec		()								{	if (0==p_) return;	p_->dwReference--; 	if (0==p_->dwReference)	p_=0;						}

	mov	eax, DWORD PTR _vertices$[esp+20]
	pop	esi
	test	eax, eax
	je	SHORT $LN35@TEnumBoneV
	dec	DWORD PTR [eax]
$LN35@TEnumBoneV:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp

; 619  : }

	add	esp, 20					; 00000014H
	ret	0
??$TEnumBoneVertices@V?$ref_smem@UvertBoned1W@@@@@@YAXV?$ref_smem@UvertBoned1W@@@@PAGAAV?$xr_vector@GV?$xalloc@G@@@@AAUSEnumVerticesCallback@@@Z ENDP ; TEnumBoneVertices<ref_smem<vertBoned1W> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xrsharedmem.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xrsharedmem.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp
;	COMDAT ??$TEnumBoneVertices@V?$ref_smem@UvertBoned2W@@@@@@YAXV?$ref_smem@UvertBoned2W@@@@PAGAAV?$xr_vector@GV?$xalloc@G@@@@AAUSEnumVerticesCallback@@@Z
_TEXT	SEGMENT
_faces$1$ = -20						; size = 4
_indices$1$ = -16					; size = 4
_P$1 = -12						; size = 12
_vertices$ = 8						; size = 4
_C$ = 12						; size = 4
??$TEnumBoneVertices@V?$ref_smem@UvertBoned2W@@@@@@YAXV?$ref_smem@UvertBoned2W@@@@PAGAAV?$xr_vector@GV?$xalloc@G@@@@AAUSEnumVerticesCallback@@@Z PROC ; TEnumBoneVertices<ref_smem<vertBoned2W> >, COMDAT
; _indices$ = ecx
; _faces$ = edx

; 610  : {

	sub	esp, 20					; 00000014H
	mov	eax, edx
	mov	DWORD PTR _indices$1$[esp+20], ecx
	push	esi
	mov	DWORD PTR _faces$1$[esp+24], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	esi, DWORD PTR [eax]

; 150  :         return _Ptr == _Right._Ptr;

	cmp	esi, DWORD PTR [eax+4]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp

; 611  : 		for (CBoneData::FacesVecIt it=faces.begin(); it!=faces.end(); it++){

	je	SHORT $LN3@TEnumBoneV
	push	ebx
	push	ebp
	mov	ebp, DWORD PTR _C$[esp+28]
	push	edi
	npad	4
$LL4@TEnumBoneV:

; 612  : 			u32 idx			= (*it)*3;

	movzx	eax, WORD PTR [esi]
	mov	ebx, 3
	lea	eax, DWORD PTR [eax+eax*2]
	lea	edi, DWORD PTR [ecx+eax*2]
	npad	2
$LL7@TEnumBoneV:

; 615  : 				vertices[indices[idx+k]].get_pos( P );

	movzx	ecx, WORD PTR [edi]
	lea	eax, DWORD PTR _P$1[esp+36]
	push	eax
; File I:\Vitalya\mine\NSProjectX\xrCore\xrsharedmem.h

; 88   : 	T&					operator[]	(size_t id)						{	return ((T*)(p_->value))[id];								}

	mov	eax, DWORD PTR _vertices$[esp+36]
	shl	ecx, 6
	add	eax, 16					; 00000010H
	add	ecx, eax
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp

; 615  : 				vertices[indices[idx+k]].get_pos( P );

	call	DWORD PTR __imp_?get_pos@vertBoned2W@@QAEXAAU?$_vector3@M@@@Z

; 616  : 				C( P );

	mov	eax, DWORD PTR [ebp]
	lea	ecx, DWORD PTR _P$1[esp+36]
	push	ecx
	mov	ecx, ebp
	call	DWORD PTR [eax]
	lea	edi, DWORD PTR [edi+2]
	sub	ebx, 1
	jne	SHORT $LL7@TEnumBoneV
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 150  :         return _Ptr == _Right._Ptr;

	mov	eax, DWORD PTR _faces$1$[esp+36]

; 74   :         ++_Ptr;

	add	esi, 2
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp

; 611  : 		for (CBoneData::FacesVecIt it=faces.begin(); it!=faces.end(); it++){

	mov	ecx, DWORD PTR _indices$1$[esp+36]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 150  :         return _Ptr == _Right._Ptr;

	cmp	esi, DWORD PTR [eax+4]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp

; 611  : 		for (CBoneData::FacesVecIt it=faces.begin(); it!=faces.end(); it++){

	jne	SHORT $LL4@TEnumBoneV
	pop	edi
	pop	ebp
	pop	ebx
$LN3@TEnumBoneV:
; File I:\Vitalya\mine\NSProjectX\xrCore\xrsharedmem.h

; 68   : 	void				_dec		()								{	if (0==p_) return;	p_->dwReference--; 	if (0==p_->dwReference)	p_=0;						}

	mov	eax, DWORD PTR _vertices$[esp+20]
	pop	esi
	test	eax, eax
	je	SHORT $LN35@TEnumBoneV
	dec	DWORD PTR [eax]
$LN35@TEnumBoneV:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp

; 619  : }

	add	esp, 20					; 00000014H
	ret	0
??$TEnumBoneVertices@V?$ref_smem@UvertBoned2W@@@@@@YAXV?$ref_smem@UvertBoned2W@@@@PAGAAV?$xr_vector@GV?$xalloc@G@@@@AAUSEnumVerticesCallback@@@Z ENDP ; TEnumBoneVertices<ref_smem<vertBoned2W> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp
;	COMDAT ??$TEnumBoneVertices@PAUvertHW_1W@@@@YAXPAUvertHW_1W@@PAGAAV?$xr_vector@GV?$xalloc@G@@@@AAUSEnumVerticesCallback@@@Z
_TEXT	SEGMENT
_it$1$ = -20						; size = 4
_indices$1$ = -16					; size = 4
_P$1 = -12						; size = 12
_faces$ = 8						; size = 4
_C$ = 12						; size = 4
??$TEnumBoneVertices@PAUvertHW_1W@@@@YAXPAUvertHW_1W@@PAGAAV?$xr_vector@GV?$xalloc@G@@@@AAUSEnumVerticesCallback@@@Z PROC ; TEnumBoneVertices<vertHW_1W *>, COMDAT
; _vertices$ = ecx
; _indices$ = edx

; 610  : {

	sub	esp, 20					; 00000014H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	eax, DWORD PTR _faces$[esp+16]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp

; 610  : {

	push	ebx
	push	esi
	mov	DWORD PTR _indices$1$[esp+28], edx
	mov	ebx, ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	esi, DWORD PTR [eax]
	mov	DWORD PTR _it$1$[esp+28], esi

; 150  :         return _Ptr == _Right._Ptr;

	cmp	esi, DWORD PTR [eax+4]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp

; 611  : 		for (CBoneData::FacesVecIt it=faces.begin(); it!=faces.end(); it++){

	je	$LN3@TEnumBoneV
	movss	xmm1, DWORD PTR __real@39c00180
	push	ebp
	push	edi
	npad	8
$LL4@TEnumBoneV:

; 612  : 			u32 idx			= (*it)*3;

	movzx	eax, WORD PTR [esi]
	mov	ebp, 3
	mov	esi, DWORD PTR _C$[esp+32]
	lea	eax, DWORD PTR [eax+eax*2]
	lea	edi, DWORD PTR [edx+eax*2]
$LL7@TEnumBoneV:

; 613  : 			for (u32 k=0; k<3; k++){
; 614  : 				Fvector		P;
; 615  : 				vertices[indices[idx+k]].get_pos( P );

	movzx	eax, WORD PTR [edi]
	lea	ecx, DWORD PTR [eax+eax*2]

; 25   : 	return	float(v)/(32767.f/12.f);

	movsx	eax, WORD PTR [ebx+ecx*8]
	cvtsi2ss xmm0, eax
	mulss	xmm0, xmm1

; 91   : 		p.x			= u_P(_P[0]);

	movss	DWORD PTR _P$1[esp+36], xmm0

; 25   : 	return	float(v)/(32767.f/12.f);

	movsx	eax, WORD PTR [ebx+ecx*8+2]
	cvtsi2ss xmm0, eax
	mulss	xmm0, xmm1

; 92   : 		p.y			= u_P(_P[1]);

	movss	DWORD PTR _P$1[esp+40], xmm0

; 25   : 	return	float(v)/(32767.f/12.f);

	movsx	eax, WORD PTR [ebx+ecx*8+4]

; 616  : 				C( P );

	lea	ecx, DWORD PTR _P$1[esp+36]
	push	ecx
	mov	ecx, esi

; 25   : 	return	float(v)/(32767.f/12.f);

	cvtsi2ss xmm0, eax

; 616  : 				C( P );

	mov	eax, DWORD PTR [esi]

; 25   : 	return	float(v)/(32767.f/12.f);

	mulss	xmm0, xmm1

; 93   : 		p.z			= u_P(_P[2]);

	movss	DWORD PTR _P$1[esp+48], xmm0

; 616  : 				C( P );

	call	DWORD PTR [eax]
	movss	xmm1, DWORD PTR __real@39c00180
	lea	edi, DWORD PTR [edi+2]
	sub	ebp, 1
	jne	SHORT $LL7@TEnumBoneV
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 74   :         ++_Ptr;

	mov	esi, DWORD PTR _it$1$[esp+36]

; 150  :         return _Ptr == _Right._Ptr;

	mov	eax, DWORD PTR _faces$[esp+32]

; 74   :         ++_Ptr;

	add	esi, 2
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp

; 611  : 		for (CBoneData::FacesVecIt it=faces.begin(); it!=faces.end(); it++){

	mov	edx, DWORD PTR _indices$1$[esp+36]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 74   :         ++_Ptr;

	mov	DWORD PTR _it$1$[esp+36], esi

; 150  :         return _Ptr == _Right._Ptr;

	cmp	esi, DWORD PTR [eax+4]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp

; 611  : 		for (CBoneData::FacesVecIt it=faces.begin(); it!=faces.end(); it++){

	jne	$LL4@TEnumBoneV
	pop	edi
	pop	ebp
$LN3@TEnumBoneV:
	pop	esi

; 617  : 			}
; 618  : 		}
; 619  : }

	pop	ebx
	add	esp, 20					; 00000014H
	ret	0
??$TEnumBoneVertices@PAUvertHW_1W@@@@YAXPAUvertHW_1W@@PAGAAV?$xr_vector@GV?$xalloc@G@@@@AAUSEnumVerticesCallback@@@Z ENDP ; TEnumBoneVertices<vertHW_1W *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp
;	COMDAT ??$TEnumBoneVertices@PAUvertHW_2W@@@@YAXPAUvertHW_2W@@PAGAAV?$xr_vector@GV?$xalloc@G@@@@AAUSEnumVerticesCallback@@@Z
_TEXT	SEGMENT
_it$1$ = -20						; size = 4
_indices$1$ = -16					; size = 4
_P$1 = -12						; size = 12
_faces$ = 8						; size = 4
_C$ = 12						; size = 4
??$TEnumBoneVertices@PAUvertHW_2W@@@@YAXPAUvertHW_2W@@PAGAAV?$xr_vector@GV?$xalloc@G@@@@AAUSEnumVerticesCallback@@@Z PROC ; TEnumBoneVertices<vertHW_2W *>, COMDAT
; _vertices$ = ecx
; _indices$ = edx

; 610  : {

	sub	esp, 20					; 00000014H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	eax, DWORD PTR _faces$[esp+16]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp

; 610  : {

	push	ebx
	push	esi
	mov	DWORD PTR _indices$1$[esp+28], edx
	mov	ebx, ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	esi, DWORD PTR [eax]
	mov	DWORD PTR _it$1$[esp+28], esi

; 150  :         return _Ptr == _Right._Ptr;

	cmp	esi, DWORD PTR [eax+4]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp

; 611  : 		for (CBoneData::FacesVecIt it=faces.begin(); it!=faces.end(); it++){

	je	$LN3@TEnumBoneV
	movss	xmm1, DWORD PTR __real@39c00180
	push	ebp
	push	edi
	npad	8
$LL4@TEnumBoneV:

; 612  : 			u32 idx			= (*it)*3;

	movzx	eax, WORD PTR [esi]
	mov	ebp, 3
	mov	esi, DWORD PTR _C$[esp+32]
	lea	eax, DWORD PTR [eax+eax*2]
	lea	edi, DWORD PTR [edx+eax*2]
$LL7@TEnumBoneV:

; 613  : 			for (u32 k=0; k<3; k++){
; 614  : 				Fvector		P;
; 615  : 				vertices[indices[idx+k]].get_pos( P );

	movzx	eax, WORD PTR [edi]
	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax

; 25   : 	return	float(v)/(32767.f/12.f);

	movsx	eax, WORD PTR [ebx+ecx*4]
	cvtsi2ss xmm0, eax
	mulss	xmm0, xmm1

; 140  : 		p.x			= u_P(_P[0]);

	movss	DWORD PTR _P$1[esp+36], xmm0

; 25   : 	return	float(v)/(32767.f/12.f);

	movsx	eax, WORD PTR [ebx+ecx*4+2]
	cvtsi2ss xmm0, eax
	mulss	xmm0, xmm1

; 141  : 		p.y			= u_P(_P[1]);

	movss	DWORD PTR _P$1[esp+40], xmm0

; 25   : 	return	float(v)/(32767.f/12.f);

	movsx	eax, WORD PTR [ebx+ecx*4+4]

; 616  : 				C( P );

	lea	ecx, DWORD PTR _P$1[esp+36]
	push	ecx
	mov	ecx, esi

; 25   : 	return	float(v)/(32767.f/12.f);

	cvtsi2ss xmm0, eax

; 616  : 				C( P );

	mov	eax, DWORD PTR [esi]

; 25   : 	return	float(v)/(32767.f/12.f);

	mulss	xmm0, xmm1

; 142  : 		p.z			= u_P(_P[2]);

	movss	DWORD PTR _P$1[esp+48], xmm0

; 616  : 				C( P );

	call	DWORD PTR [eax]
	movss	xmm1, DWORD PTR __real@39c00180
	lea	edi, DWORD PTR [edi+2]
	sub	ebp, 1
	jne	SHORT $LL7@TEnumBoneV
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 74   :         ++_Ptr;

	mov	esi, DWORD PTR _it$1$[esp+36]

; 150  :         return _Ptr == _Right._Ptr;

	mov	eax, DWORD PTR _faces$[esp+32]

; 74   :         ++_Ptr;

	add	esi, 2
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp

; 611  : 		for (CBoneData::FacesVecIt it=faces.begin(); it!=faces.end(); it++){

	mov	edx, DWORD PTR _indices$1$[esp+36]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 74   :         ++_Ptr;

	mov	DWORD PTR _it$1$[esp+36], esi

; 150  :         return _Ptr == _Right._Ptr;

	cmp	esi, DWORD PTR [eax+4]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FSkinned.cpp

; 611  : 		for (CBoneData::FacesVecIt it=faces.begin(); it!=faces.end(); it++){

	jne	$LL4@TEnumBoneV
	pop	edi
	pop	ebp
$LN3@TEnumBoneV:
	pop	esi

; 617  : 			}
; 618  : 		}
; 619  : }

	pop	ebx
	add	esp, 20					; 00000014H
	ret	0
??$TEnumBoneVertices@PAUvertHW_2W@@@@YAXPAUvertHW_2W@@PAGAAV?$xr_vector@GV?$xalloc@G@@@@AAUSEnumVerticesCallback@@@Z ENDP ; TEnumBoneVertices<vertHW_2W *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\type_traits
;	COMDAT ??$forward@ABUWMFace@CSkeletonWallmark@@@std@@YAABUWMFace@CSkeletonWallmark@@ABU12@@Z
_TEXT	SEGMENT
??$forward@ABUWMFace@CSkeletonWallmark@@@std@@YAABUWMFace@CSkeletonWallmark@@ABU12@@Z PROC ; std::forward<CSkeletonWallmark::WMFace const &>, COMDAT
; __Arg$ = ecx

; 1386 :     return static_cast<_Ty&&>(_Arg);

	mov	eax, ecx

; 1387 : }

	ret	0
??$forward@ABUWMFace@CSkeletonWallmark@@@std@@YAABUWMFace@CSkeletonWallmark@@ABU12@@Z ENDP ; std::forward<CSkeletonWallmark::WMFace const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef
;	COMDAT ??$_Unfancy@UWMFace@CSkeletonWallmark@@@std@@YAPAUWMFace@CSkeletonWallmark@@PAU12@@Z
_TEXT	SEGMENT
??$_Unfancy@UWMFace@CSkeletonWallmark@@@std@@YAPAUWMFace@CSkeletonWallmark@@PAU12@@Z PROC ; std::_Unfancy<CSkeletonWallmark::WMFace>, COMDAT
; __Ptr$ = ecx

; 266  :     return _Ptr;

	mov	eax, ecx

; 267  : }

	ret	0
??$_Unfancy@UWMFace@CSkeletonWallmark@@@std@@YAPAUWMFace@CSkeletonWallmark@@PAU12@@Z ENDP ; std::_Unfancy<CSkeletonWallmark::WMFace>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$construct@UWMFace@CSkeletonWallmark@@ABU12@@?$_Normal_allocator_traits@V?$xalloc@UWMFace@CSkeletonWallmark@@@@@std@@SAXAAV?$xalloc@UWMFace@CSkeletonWallmark@@@@PAUWMFace@CSkeletonWallmark@@ABU34@@Z
_TEXT	SEGMENT
_<_Args_0>$ = 8						; size = 4
??$construct@UWMFace@CSkeletonWallmark@@ABU12@@?$_Normal_allocator_traits@V?$xalloc@UWMFace@CSkeletonWallmark@@@@@std@@SAXAAV?$xalloc@UWMFace@CSkeletonWallmark@@@@PAUWMFace@CSkeletonWallmark@@ABU34@@Z PROC ; std::_Normal_allocator_traits<xalloc<CSkeletonWallmark::WMFace> >::construct<CSkeletonWallmark::WMFace,CSkeletonWallmark::WMFace const &>, COMDAT
; __Al$dead$ = ecx
; __Ptr$ = edx

; 564  :     static _CONSTEXPR20_DYNALLOC void construct(_Alloc& _Al, _Ty* _Ptr, _Types&&... _Args) {

	push	esi
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	esi, DWORD PTR _<_Args_0>$[esp]
	mov	ecx, 21					; 00000015H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 564  :     static _CONSTEXPR20_DYNALLOC void construct(_Alloc& _Al, _Ty* _Ptr, _Types&&... _Args) {

	push	edi
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	edi, edx
	rep movsd
	pop	edi
	pop	esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 575  :     }

	ret	0
??$construct@UWMFace@CSkeletonWallmark@@ABU12@@?$_Normal_allocator_traits@V?$xalloc@UWMFace@CSkeletonWallmark@@@@@std@@SAXAAV?$xalloc@UWMFace@CSkeletonWallmark@@@@PAUWMFace@CSkeletonWallmark@@ABU34@@Z ENDP ; std::_Normal_allocator_traits<xalloc<CSkeletonWallmark::WMFace> >::construct<CSkeletonWallmark::WMFace,CSkeletonWallmark::WMFace const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??$_Emplace_reallocate@ABUWMFace@CSkeletonWallmark@@@?$vector@UWMFace@CSkeletonWallmark@@V?$xalloc@UWMFace@CSkeletonWallmark@@@@@std@@QAEPAUWMFace@CSkeletonWallmark@@QAU23@ABU23@@Z
_TEXT	SEGMENT
__Backout$2 = -48					; size = 12
__Oldsize$1$ = -36					; size = 4
__UFirst$3 = -32					; size = 4
__Newvec$ = -28						; size = 4
__Newcapacity$1$ = -24					; size = 4
tv474 = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Whereptr$ = 8						; size = 4
__ULast$1$ = 12						; size = 4
_<_Val_0>$ = 12						; size = 4
??$_Emplace_reallocate@ABUWMFace@CSkeletonWallmark@@@?$vector@UWMFace@CSkeletonWallmark@@V?$xalloc@UWMFace@CSkeletonWallmark@@@@@std@@QAEPAUWMFace@CSkeletonWallmark@@QAU23@ABU23@@Z PROC ; std::vector<CSkeletonWallmark::WMFace,xalloc<CSkeletonWallmark::WMFace> >::_Emplace_reallocate<CSkeletonWallmark::WMFace const &>, COMDAT
; _this$ = ecx

; 752  :     _CONSTEXPR20_CONTAINER pointer _Emplace_reallocate(const pointer _Whereptr, _Valty&&... _Val) {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Emplace_reallocate@ABUWMFace@CSkeletonWallmark@@@?$vector@UWMFace@CSkeletonWallmark@@V?$xalloc@UWMFace@CSkeletonWallmark@@@@@std@@QAEPAUWMFace@CSkeletonWallmark@@QAU23@ABU23@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 36					; 00000024H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	ebx, ecx

; 753  :         // reallocate and insert by perfectly forwarding _Val at _Whereptr
; 754  :         _Alty& _Al        = _Getal();
; 755  :         auto& _My_data    = _Mypair._Myval2;
; 756  :         pointer& _Myfirst = _My_data._Myfirst;
; 757  :         pointer& _Mylast  = _My_data._Mylast;
; 758  : 
; 759  :         _STL_INTERNAL_CHECK(_Mylast == _My_data._Myend); // check that we have no unused capacity
; 760  : 
; 761  :         const auto _Whereoff = static_cast<size_type>(_Whereptr - _Myfirst);

	mov	ecx, DWORD PTR [ebx]
	mov	edx, DWORD PTR __Whereptr$[ebp]
	sub	edx, ecx
	mov	eax, 818089009				; 30c30c31H
	imul	edx
	sar	edx, 4
	mov	esi, edx
	shr	esi, 31					; 0000001fH
	add	esi, edx

; 762  :         const auto _Oldsize  = static_cast<size_type>(_Mylast - _Myfirst);

	mov	eax, DWORD PTR [ebx+4]
	sub	eax, ecx
	sar	eax, 2
	imul	eax, eax, 1022611261
	mov	DWORD PTR __Oldsize$1$[ebp], eax

; 763  : 
; 764  :         if (_Oldsize == max_size()) {

	cmp	eax, 51130563				; 030c30c3H
	je	$LN59@Emplace_re

; 766  :         }
; 767  : 
; 768  :         const size_type _Newsize     = _Oldsize + 1;

	lea	edi, DWORD PTR [eax+1]

; 1546 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	eax, DWORD PTR [ebx+8]
	sub	eax, ecx
	sar	eax, 2
	imul	edx, eax, 1022611261

; 1675 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	ecx, edx
	shr	ecx, 1
	mov	eax, 51130563				; 030c30c3H
	sub	eax, ecx
	cmp	edx, eax
	jbe	SHORT $LN12@Emplace_re

; 1676 :             return _Max; // geometric growth would overflow

	mov	eax, 51130563				; 030c30c3H
	jmp	SHORT $LN57@Emplace_re
$LN12@Emplace_re:

; 1677 :         }
; 1678 : 
; 1679 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	lea	eax, DWORD PTR [ecx+edx]

; 1680 : 
; 1681 :         if (_Geometric < _Newsize) {

	cmp	eax, edi
	cmovb	eax, edi
$LN57@Emplace_re:
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	mov	DWORD PTR __Newcapacity$1$[ebp], eax
	imul	eax, eax, 84
	push	eax
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 771  :         const pointer _Newvec           = _Al.allocate(_Newcapacity);

	mov	edx, eax
	mov	DWORD PTR __Newvec$[ebp], edx

; 772  :         const pointer _Constructed_last = _Newvec + _Whereoff + 1;
; 773  :         pointer _Constructed_first      = _Constructed_last;
; 774  : 
; 775  :         _TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 776  :         _Alty_traits::construct(_Al, _Unfancy(_Newvec + _Whereoff), _STD forward<_Valty>(_Val)...);

	imul	eax, esi, 84
	add	eax, edx
	mov	DWORD PTR tv474[ebp], eax
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	ecx, 21					; 00000015H
	mov	esi, DWORD PTR _<_Val_0>$[ebp]
	mov	edi, eax
	rep movsd
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 779  :         if (_Whereptr == _Mylast) { // at back, provide strong guarantee

	mov	ecx, DWORD PTR [ebx+4]
	mov	DWORD PTR __ULast$1$[ebp], ecx
	mov	eax, DWORD PTR [ebx]
	mov	esi, DWORD PTR __Whereptr$[ebp]
	cmp	esi, ecx
	jne	SHORT $LN4@Emplace_re
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1703 :     auto _UFirst      = _Get_unwrapped(_First);

	mov	DWORD PTR __UFirst$3[ebp], eax

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	DWORD PTR __Backout$2[ebp], edx
	mov	DWORD PTR __Backout$2[ebp+4], edx
	mov	DWORD PTR __Backout$2[ebp+8], ebx
$LL32@Emplace_re:

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	eax, ecx
	je	SHORT $LN31@Emplace_re
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	ecx, 21					; 00000015H
	mov	esi, eax
	mov	edi, edx
	rep movsd
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1621 :         ++_Last;

	add	edx, 84					; 00000054H
	mov	DWORD PTR __Backout$2[ebp+4], edx

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	add	eax, 84					; 00000054H
	mov	DWORD PTR __UFirst$3[ebp], eax
	mov	ecx, DWORD PTR __ULast$1$[ebp]
	jmp	SHORT $LL32@Emplace_re
$LN31@Emplace_re:

; 1625 :         _First = _Last;

	mov	DWORD PTR __Backout$2[ebp], edx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 781  :         } else { // provide basic guarantee

	mov	edi, DWORD PTR tv474[ebp]
	jmp	SHORT $LN5@Emplace_re
$LN4@Emplace_re:

; 782  :             _Umove(_Myfirst, _Whereptr, _Newvec);

	push	edx
	push	esi
	push	eax
	call	?_Umove@?$vector@UWMFace@CSkeletonWallmark@@V?$xalloc@UWMFace@CSkeletonWallmark@@@@@std@@AAEPAUWMFace@CSkeletonWallmark@@PAU34@00@Z ; std::vector<CSkeletonWallmark::WMFace,xalloc<CSkeletonWallmark::WMFace> >::_Umove

; 783  :             _Constructed_first = _Newvec;
; 784  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

	mov	edi, DWORD PTR tv474[ebp]
	lea	eax, DWORD PTR [edi+84]
	push	eax
	push	DWORD PTR [ebx+4]
	push	esi
	call	?_Umove@?$vector@UWMFace@CSkeletonWallmark@@V?$xalloc@UWMFace@CSkeletonWallmark@@@@@std@@AAEPAUWMFace@CSkeletonWallmark@@PAU34@00@Z ; std::vector<CSkeletonWallmark::WMFace,xalloc<CSkeletonWallmark::WMFace> >::_Umove
$LN5@Emplace_re:
	mov	DWORD PTR __$EHRec$[ebp+12], -1

; 1732 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [ebx]
	test	eax, eax
	je	SHORT $LN50@Emplace_re
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	push	eax
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN50@Emplace_re:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1737 :         _Myfirst = _Newvec;

	mov	eax, DWORD PTR __Newvec$[ebp]
	mov	DWORD PTR [ebx], eax

; 1738 :         _Mylast  = _Newvec + _Newsize;

	mov	ecx, DWORD PTR __Oldsize$1$[ebp]
	inc	ecx
	imul	ecx, ecx, 84
	add	ecx, eax
	mov	DWORD PTR [ebx+4], ecx

; 1739 :         _Myend   = _Newvec + _Newcapacity;

	imul	ecx, DWORD PTR __Newcapacity$1$[ebp], 84
	add	ecx, eax
	mov	DWORD PTR [ebx+8], ecx

; 790  :         _CATCH_END
; 791  : 
; 792  :         _Change_array(_Newvec, _Newsize, _Newcapacity);
; 793  :         return _Newvec + _Whereoff;

	mov	eax, edi

; 794  :     }

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
__catch$??$_Emplace_reallocate@ABUWMFace@CSkeletonWallmark@@@?$vector@UWMFace@CSkeletonWallmark@@V?$xalloc@UWMFace@CSkeletonWallmark@@@@@std@@QAEPAUWMFace@CSkeletonWallmark@@QAU23@ABU23@@Z$0:

; 785  :         }
; 786  :         _CATCH_ALL
; 787  :         _Destroy(_Constructed_first, _Constructed_last);
; 788  :         _Al.deallocate(_Newvec, _Newcapacity);

	push	ecx
	push	DWORD PTR __Newvec$[ebp]
	call	?deallocate@?$xalloc@UWMFace@CSkeletonWallmark@@@@QBEXPAUWMFace@CSkeletonWallmark@@I@Z ; xalloc<CSkeletonWallmark::WMFace>::deallocate

; 789  :         _RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$LN59@Emplace_re:

; 765  :             _Xlength();

	call	?_Xlength@?$vector@UWMFace@CSkeletonWallmark@@V?$xalloc@UWMFace@CSkeletonWallmark@@@@@std@@CAXXZ ; std::vector<CSkeletonWallmark::WMFace,xalloc<CSkeletonWallmark::WMFace> >::_Xlength
$LN56@Emplace_re:
	int	3
	int	3
	int	3
	int	3
	int	3
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Emplace_reallocate@ABUWMFace@CSkeletonWallmark@@@?$vector@UWMFace@CSkeletonWallmark@@V?$xalloc@UWMFace@CSkeletonWallmark@@@@@std@@QAEPAUWMFace@CSkeletonWallmark@@QAU23@ABU23@@Z:
	npad	1
	npad	1
	mov	eax, OFFSET __ehfuncinfo$??$_Emplace_reallocate@ABUWMFace@CSkeletonWallmark@@@?$vector@UWMFace@CSkeletonWallmark@@V?$xalloc@UWMFace@CSkeletonWallmark@@@@@std@@QAEPAUWMFace@CSkeletonWallmark@@QAU23@ABU23@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Emplace_reallocate@ABUWMFace@CSkeletonWallmark@@@?$vector@UWMFace@CSkeletonWallmark@@V?$xalloc@UWMFace@CSkeletonWallmark@@@@@std@@QAEPAUWMFace@CSkeletonWallmark@@QAU23@ABU23@@Z ENDP ; std::vector<CSkeletonWallmark::WMFace,xalloc<CSkeletonWallmark::WMFace> >::_Emplace_reallocate<CSkeletonWallmark::WMFace const &>
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef
;	COMDAT ??$addressof@V?$_Vector_val@U?$_Simple_types@V?$xr_vector@GV?$xalloc@G@@@@@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@V?$xr_vector@GV?$xalloc@G@@@@@std@@@0@AAV10@@Z
_TEXT	SEGMENT
??$addressof@V?$_Vector_val@U?$_Simple_types@V?$xr_vector@GV?$xalloc@G@@@@@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@V?$xr_vector@GV?$xalloc@G@@@@@std@@@0@AAV10@@Z PROC ; std::addressof<std::_Vector_val<std::_Simple_types<xr_vector<unsigned short,xalloc<unsigned short> > > > >, COMDAT
; __Val$ = ecx

; 253  :     return __builtin_addressof(_Val);

	mov	eax, ecx

; 254  : }

	ret	0
??$addressof@V?$_Vector_val@U?$_Simple_types@V?$xr_vector@GV?$xalloc@G@@@@@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@V?$xr_vector@GV?$xalloc@G@@@@@std@@@0@AAV10@@Z ENDP ; std::addressof<std::_Vector_val<std::_Simple_types<xr_vector<unsigned short,xalloc<unsigned short> > > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Destroy_range@V?$xalloc@UWMFace@CSkeletonWallmark@@@@@std@@YAXPAUWMFace@CSkeletonWallmark@@QAU12@AAV?$xalloc@UWMFace@CSkeletonWallmark@@@@@Z
_TEXT	SEGMENT
__Al$dead$ = 8						; size = 4
??$_Destroy_range@V?$xalloc@UWMFace@CSkeletonWallmark@@@@@std@@YAXPAUWMFace@CSkeletonWallmark@@QAU12@AAV?$xalloc@UWMFace@CSkeletonWallmark@@@@@Z PROC ; std::_Destroy_range<xalloc<CSkeletonWallmark::WMFace> >, COMDAT
; __First$dead$ = ecx
; __Last$dead$ = edx

; 901  :     // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
; 902  :     using _Ty = typename _Alloc::value_type;
; 903  :     if constexpr (!conjunction_v<is_trivially_destructible<_Ty>, _Uses_default_destroy<_Alloc, _Ty*>>) {
; 904  :         for (; _First != _Last; ++_First) {
; 905  :             allocator_traits<_Alloc>::destroy(_Al, _Unfancy(_First));
; 906  :         }
; 907  :     }
; 908  : }

	ret	0
??$_Destroy_range@V?$xalloc@UWMFace@CSkeletonWallmark@@@@@std@@YAXPAUWMFace@CSkeletonWallmark@@QAU12@AAV?$xalloc@UWMFace@CSkeletonWallmark@@@@@Z ENDP ; std::_Destroy_range<xalloc<CSkeletonWallmark::WMFace> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
;	COMDAT ??$xr_free@UWMFace@CSkeletonWallmark@@@@YAXAAPAUWMFace@CSkeletonWallmark@@@Z
_TEXT	SEGMENT
??$xr_free@UWMFace@CSkeletonWallmark@@@@YAXAAPAUWMFace@CSkeletonWallmark@@@Z PROC ; xr_free<CSkeletonWallmark::WMFace>, COMDAT
; _P$ = ecx

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	push	esi
	mov	esi, ecx
	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN2@xr_free
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
	mov	DWORD PTR [esi], 0
$LN2@xr_free:
	pop	esi
	ret	0
??$xr_free@UWMFace@CSkeletonWallmark@@@@YAXAAPAUWMFace@CSkeletonWallmark@@@Z ENDP ; xr_free<CSkeletonWallmark::WMFace>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\xrsharedmem.h
;	COMDAT ??A?$ref_smem@UvertBoned2W@@@@QAEAAUvertBoned2W@@I@Z
_TEXT	SEGMENT
_id$ = 8						; size = 4
??A?$ref_smem@UvertBoned2W@@@@QAEAAUvertBoned2W@@I@Z PROC ; ref_smem<vertBoned2W>::operator[], COMDAT
; _this$ = ecx

; 88   : 	T&					operator[]	(size_t id)						{	return ((T*)(p_->value))[id];								}

	mov	edx, DWORD PTR _id$[esp-4]
	mov	eax, DWORD PTR [ecx]
	shl	edx, 6
	add	eax, 16					; 00000010H
	add	eax, edx
	ret	4
??A?$ref_smem@UvertBoned2W@@@@QAEAAUvertBoned2W@@I@Z ENDP ; ref_smem<vertBoned2W>::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\xrsharedmem.h
;	COMDAT ??A?$ref_smem@UvertBoned1W@@@@QAEAAUvertBoned1W@@I@Z
_TEXT	SEGMENT
_id$ = 8						; size = 4
??A?$ref_smem@UvertBoned1W@@@@QAEAAUvertBoned1W@@I@Z PROC ; ref_smem<vertBoned1W>::operator[], COMDAT
; _this$ = ecx

; 88   : 	T&					operator[]	(size_t id)						{	return ((T*)(p_->value))[id];								}

	mov	edx, DWORD PTR _id$[esp-4]
	mov	eax, DWORD PTR [ecx]
	shl	edx, 4
	sub	edx, DWORD PTR _id$[esp-4]
	lea	eax, DWORD PTR [eax+edx*4]
	add	eax, 16					; 00000010H
	ret	4
??A?$ref_smem@UvertBoned1W@@@@QAEAAUvertBoned1W@@I@Z ENDP ; ref_smem<vertBoned1W>::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Xlength@?$vector@UWMFace@CSkeletonWallmark@@V?$xalloc@UWMFace@CSkeletonWallmark@@@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@UWMFace@CSkeletonWallmark@@V?$xalloc@UWMFace@CSkeletonWallmark@@@@@std@@CAXXZ PROC ; std::vector<CSkeletonWallmark::WMFace,xalloc<CSkeletonWallmark::WMFace> >::_Xlength, COMDAT

; 1761 :         _Xlength_error("vector too long");

	push	OFFSET ??_C@_0BA@FOIKENOD@vector?5too?5long@
	call	DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN3@Xlength:
	int	3
?_Xlength@?$vector@UWMFace@CSkeletonWallmark@@V?$xalloc@UWMFace@CSkeletonWallmark@@@@@std@@CAXXZ ENDP ; std::vector<CSkeletonWallmark::WMFace,xalloc<CSkeletonWallmark::WMFace> >::_Xlength
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Change_array@?$vector@UWMFace@CSkeletonWallmark@@V?$xalloc@UWMFace@CSkeletonWallmark@@@@@std@@AAEXQAUWMFace@CSkeletonWallmark@@II@Z
_TEXT	SEGMENT
__Newvec$ = 8						; size = 4
__Newsize$ = 12						; size = 4
__Newcapacity$ = 16					; size = 4
?_Change_array@?$vector@UWMFace@CSkeletonWallmark@@V?$xalloc@UWMFace@CSkeletonWallmark@@@@@std@@AAEXQAUWMFace@CSkeletonWallmark@@II@Z PROC ; std::vector<CSkeletonWallmark::WMFace,xalloc<CSkeletonWallmark::WMFace> >::_Change_array, COMDAT
; _this$ = ecx

; 1723 :         const pointer _Newvec, const size_type _Newsize, const size_type _Newcapacity) {

	push	esi
	mov	esi, ecx

; 1724 :         // orphan all iterators, discard old array, acquire new array
; 1725 :         auto& _My_data    = _Mypair._Myval2;
; 1726 :         pointer& _Myfirst = _My_data._Myfirst;
; 1727 :         pointer& _Mylast  = _My_data._Mylast;
; 1728 :         pointer& _Myend   = _My_data._Myend;
; 1729 : 
; 1730 :         _My_data._Orphan_all();
; 1731 : 
; 1732 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN7@Change_arr
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN7@Change_arr:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1738 :         _Mylast  = _Newvec + _Newsize;

	imul	eax, DWORD PTR __Newsize$[esp], 84
	mov	ecx, DWORD PTR __Newvec$[esp]
	mov	DWORD PTR [esi], ecx
	add	eax, ecx
	mov	DWORD PTR [esi+4], eax

; 1739 :         _Myend   = _Newvec + _Newcapacity;

	imul	eax, DWORD PTR __Newcapacity$[esp], 84
	add	eax, ecx
	mov	DWORD PTR [esi+8], eax
	pop	esi

; 1740 :     }

	ret	12					; 0000000cH
?_Change_array@?$vector@UWMFace@CSkeletonWallmark@@V?$xalloc@UWMFace@CSkeletonWallmark@@@@@std@@AAEXQAUWMFace@CSkeletonWallmark@@II@Z ENDP ; std::vector<CSkeletonWallmark::WMFace,xalloc<CSkeletonWallmark::WMFace> >::_Change_array
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Calculate_growth@?$vector@UWMFace@CSkeletonWallmark@@V?$xalloc@UWMFace@CSkeletonWallmark@@@@@std@@ABEII@Z
_TEXT	SEGMENT
__Newsize$ = 8						; size = 4
?_Calculate_growth@?$vector@UWMFace@CSkeletonWallmark@@V?$xalloc@UWMFace@CSkeletonWallmark@@@@@std@@ABEII@Z PROC ; std::vector<CSkeletonWallmark::WMFace,xalloc<CSkeletonWallmark::WMFace> >::_Calculate_growth, COMDAT
; _this$ = ecx

; 1546 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx]

; 1671 :         // given _Oldcapacity and _Newsize, calculate geometric growth
; 1672 :         const size_type _Oldcapacity = capacity();
; 1673 :         const auto _Max              = max_size();
; 1674 : 
; 1675 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	ecx, 51130563				; 030c30c3H

; 1546 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	sar	eax, 2

; 1670 :     _CONSTEXPR20_CONTAINER size_type _Calculate_growth(const size_type _Newsize) const {

	push	esi

; 1546 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	imul	esi, eax, 1022611261

; 1671 :         // given _Oldcapacity and _Newsize, calculate geometric growth
; 1672 :         const size_type _Oldcapacity = capacity();
; 1673 :         const auto _Max              = max_size();
; 1674 : 
; 1675 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	edx, esi
	shr	edx, 1
	sub	ecx, edx
	cmp	esi, ecx
	jbe	SHORT $LN2@Calculate_

; 1676 :             return _Max; // geometric growth would overflow

	mov	eax, 51130563				; 030c30c3H
	pop	esi

; 1682 :             return _Newsize; // geometric growth would be insufficient
; 1683 :         }
; 1684 : 
; 1685 :         return _Geometric; // geometric growth is sufficient
; 1686 :     }

	ret	4
$LN2@Calculate_:

; 1677 :         }
; 1678 : 
; 1679 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	lea	eax, DWORD PTR [edx+esi]

; 1680 : 
; 1681 :         if (_Geometric < _Newsize) {

	cmp	eax, DWORD PTR __Newsize$[esp]
	pop	esi
	cmovb	eax, DWORD PTR __Newsize$[esp-4]

; 1682 :             return _Newsize; // geometric growth would be insufficient
; 1683 :         }
; 1684 : 
; 1685 :         return _Geometric; // geometric growth is sufficient
; 1686 :     }

	ret	4
?_Calculate_growth@?$vector@UWMFace@CSkeletonWallmark@@V?$xalloc@UWMFace@CSkeletonWallmark@@@@@std@@ABEII@Z ENDP ; std::vector<CSkeletonWallmark::WMFace,xalloc<CSkeletonWallmark::WMFace> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Umove_if_noexcept@?$vector@UWMFace@CSkeletonWallmark@@V?$xalloc@UWMFace@CSkeletonWallmark@@@@@std@@AAEXPAUWMFace@CSkeletonWallmark@@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
?_Umove_if_noexcept@?$vector@UWMFace@CSkeletonWallmark@@V?$xalloc@UWMFace@CSkeletonWallmark@@@@@std@@AAEXPAUWMFace@CSkeletonWallmark@@00@Z PROC ; std::vector<CSkeletonWallmark::WMFace,xalloc<CSkeletonWallmark::WMFace> >::_Umove_if_noexcept, COMDAT
; _this$dead$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1703 :     auto _UFirst      = _Get_unwrapped(_First);

	mov	eax, DWORD PTR __First$[esp-4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1659 :     _CONSTEXPR20_CONTAINER void _Umove_if_noexcept(pointer _First, pointer _Last, pointer _Dest) {

	push	ebx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	mov	ebx, DWORD PTR __Last$[esp]
	cmp	eax, ebx
	je	SHORT $LN7@Umove_if_n

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	edx, DWORD PTR __Dest$[esp]
	push	esi
	sub	edx, eax
	push	edi
$LL8@Umove_if_n:
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	lea	edi, DWORD PTR [edx+eax]
	mov	esi, eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	add	eax, 84					; 00000054H
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	ecx, 21					; 00000015H
	rep movsd
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	eax, ebx
	jne	SHORT $LL8@Umove_if_n
	pop	edi
	pop	esi
$LN7@Umove_if_n:
	pop	ebx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1663 :     }

	ret	12					; 0000000cH
?_Umove_if_noexcept@?$vector@UWMFace@CSkeletonWallmark@@V?$xalloc@UWMFace@CSkeletonWallmark@@@@@std@@AAEXPAUWMFace@CSkeletonWallmark@@00@Z ENDP ; std::vector<CSkeletonWallmark::WMFace,xalloc<CSkeletonWallmark::WMFace> >::_Umove_if_noexcept
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Umove@?$vector@UWMFace@CSkeletonWallmark@@V?$xalloc@UWMFace@CSkeletonWallmark@@@@@std@@AAEPAUWMFace@CSkeletonWallmark@@PAU34@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
?_Umove@?$vector@UWMFace@CSkeletonWallmark@@V?$xalloc@UWMFace@CSkeletonWallmark@@@@@std@@AAEPAUWMFace@CSkeletonWallmark@@PAU34@00@Z PROC ; std::vector<CSkeletonWallmark::WMFace,xalloc<CSkeletonWallmark::WMFace> >::_Umove, COMDAT
; _this$dead$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	mov	edx, DWORD PTR __First$[esp-4]

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	eax, DWORD PTR __Dest$[esp-4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1644 :     _CONSTEXPR20_CONTAINER pointer _Umove(pointer _First, pointer _Last, pointer _Dest) {

	push	ebx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	mov	ebx, DWORD PTR __Last$[esp]
	cmp	edx, ebx
	je	SHORT $LN5@Umove
	push	esi
	push	edi
$LL6@Umove:
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	esi, edx
	mov	edi, eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1621 :         ++_Last;

	add	edx, 84					; 00000054H
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	ecx, 21					; 00000015H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1621 :         ++_Last;

	add	eax, 84					; 00000054H
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	rep movsd
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	edx, ebx
	jne	SHORT $LL6@Umove
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1646 :         return _Uninitialized_move(_First, _Last, _Dest, _Getal());

	pop	edi
	pop	esi
$LN5@Umove:

; 1647 :     }

	pop	ebx
	ret	12					; 0000000cH
?_Umove@?$vector@UWMFace@CSkeletonWallmark@@V?$xalloc@UWMFace@CSkeletonWallmark@@@@@std@@AAEPAUWMFace@CSkeletonWallmark@@PAU34@00@Z ENDP ; std::vector<CSkeletonWallmark::WMFace,xalloc<CSkeletonWallmark::WMFace> >::_Umove
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?max_size@?$vector@UWMFace@CSkeletonWallmark@@V?$xalloc@UWMFace@CSkeletonWallmark@@@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@UWMFace@CSkeletonWallmark@@V?$xalloc@UWMFace@CSkeletonWallmark@@@@@std@@QBEIXZ PROC ; std::vector<CSkeletonWallmark::WMFace,xalloc<CSkeletonWallmark::WMFace> >::max_size, COMDAT
; _this$dead$ = ecx

; 1540 :         return (_STD min)(

	mov	eax, 51130563				; 030c30c3H

; 1541 :             static_cast<size_type>((numeric_limits<difference_type>::max)()), _Alty_traits::max_size(_Getal()));
; 1542 :     }

	ret	0
?max_size@?$vector@UWMFace@CSkeletonWallmark@@V?$xalloc@UWMFace@CSkeletonWallmark@@@@@std@@QBEIXZ ENDP ; std::vector<CSkeletonWallmark::WMFace,xalloc<CSkeletonWallmark::WMFace> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?construct@?$xalloc@UWMFace@CSkeletonWallmark@@@@QAEXPAUWMFace@CSkeletonWallmark@@ABU23@@Z
_TEXT	SEGMENT
_p$ = 8							; size = 4
__Val$ = 12						; size = 4
?construct@?$xalloc@UWMFace@CSkeletonWallmark@@@@QAEXPAUWMFace@CSkeletonWallmark@@ABU23@@Z PROC ; xalloc<CSkeletonWallmark::WMFace>::construct, COMDAT
; _this$dead$ = ecx

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	push	esi
	mov	esi, DWORD PTR __Val$[esp]
	mov	ecx, 21					; 00000015H
	push	edi
	mov	edi, DWORD PTR _p$[esp+4]
	rep movsd
	pop	edi
	pop	esi
	ret	8
?construct@?$xalloc@UWMFace@CSkeletonWallmark@@@@QAEXPAUWMFace@CSkeletonWallmark@@ABU23@@Z ENDP ; xalloc<CSkeletonWallmark::WMFace>::construct
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?allocate@?$xalloc@UWMFace@CSkeletonWallmark@@@@QBEPAUWMFace@CSkeletonWallmark@@IPBX@Z
_TEXT	SEGMENT
_n$ = 8							; size = 4
_p$dead$ = 12						; size = 4
?allocate@?$xalloc@UWMFace@CSkeletonWallmark@@@@QBEPAUWMFace@CSkeletonWallmark@@IPBX@Z PROC ; xalloc<CSkeletonWallmark::WMFace>::allocate, COMDAT
; _this$dead$ = ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	imul	eax, DWORD PTR _n$[esp-4], 84
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 80   : 							pointer					allocate		(size_type n, const void* p=0) const	{	return xr_alloc<T>((u32)n);	}

	ret	8
?allocate@?$xalloc@UWMFace@CSkeletonWallmark@@@@QBEPAUWMFace@CSkeletonWallmark@@IPBX@Z ENDP ; xalloc<CSkeletonWallmark::WMFace>::allocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Getal@?$vector@UWMFace@CSkeletonWallmark@@V?$xalloc@UWMFace@CSkeletonWallmark@@@@@std@@ABEABV?$xalloc@UWMFace@CSkeletonWallmark@@@@XZ
_TEXT	SEGMENT
?_Getal@?$vector@UWMFace@CSkeletonWallmark@@V?$xalloc@UWMFace@CSkeletonWallmark@@@@@std@@ABEABV?$xalloc@UWMFace@CSkeletonWallmark@@@@XZ PROC ; std::vector<CSkeletonWallmark::WMFace,xalloc<CSkeletonWallmark::WMFace> >::_Getal, COMDAT
; _this$ = ecx

; 1809 :         return _Mypair._Get_first();

	mov	eax, ecx

; 1810 :     }

	ret	0
?_Getal@?$vector@UWMFace@CSkeletonWallmark@@V?$xalloc@UWMFace@CSkeletonWallmark@@@@@std@@ABEABV?$xalloc@UWMFace@CSkeletonWallmark@@@@XZ ENDP ; std::vector<CSkeletonWallmark::WMFace,xalloc<CSkeletonWallmark::WMFace> >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Umove_if_noexcept1@?$vector@UWMFace@CSkeletonWallmark@@V?$xalloc@UWMFace@CSkeletonWallmark@@@@@std@@AAEXPAUWMFace@CSkeletonWallmark@@00U?$integral_constant@_N$00@2@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
?_Umove_if_noexcept1@?$vector@UWMFace@CSkeletonWallmark@@V?$xalloc@UWMFace@CSkeletonWallmark@@@@@std@@AAEXPAUWMFace@CSkeletonWallmark@@00U?$integral_constant@_N$00@2@@Z PROC ; std::vector<CSkeletonWallmark::WMFace,xalloc<CSkeletonWallmark::WMFace> >::_Umove_if_noexcept1, COMDAT
; _this$dead$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1703 :     auto _UFirst      = _Get_unwrapped(_First);

	mov	eax, DWORD PTR __First$[esp-4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1649 :     _CONSTEXPR20_CONTAINER void _Umove_if_noexcept1(pointer _First, pointer _Last, pointer _Dest, true_type) {

	push	ebx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	mov	ebx, DWORD PTR __Last$[esp]
	cmp	eax, ebx
	je	SHORT $LN5@Umove_if_n

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	edx, DWORD PTR __Dest$[esp]
	push	esi
	sub	edx, eax
	push	edi
$LL6@Umove_if_n:
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	lea	edi, DWORD PTR [edx+eax]
	mov	esi, eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	add	eax, 84					; 00000054H
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	ecx, 21					; 00000015H
	rep movsd
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	eax, ebx
	jne	SHORT $LL6@Umove_if_n
	pop	edi
	pop	esi
$LN5@Umove_if_n:
	pop	ebx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1652 :     }

	ret	16					; 00000010H
?_Umove_if_noexcept1@?$vector@UWMFace@CSkeletonWallmark@@V?$xalloc@UWMFace@CSkeletonWallmark@@@@@std@@AAEXPAUWMFace@CSkeletonWallmark@@00U?$integral_constant@_N$00@2@@Z ENDP ; std::vector<CSkeletonWallmark::WMFace,xalloc<CSkeletonWallmark::WMFace> >::_Umove_if_noexcept1
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?capacity@?$vector@UWMFace@CSkeletonWallmark@@V?$xalloc@UWMFace@CSkeletonWallmark@@@@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@UWMFace@CSkeletonWallmark@@V?$xalloc@UWMFace@CSkeletonWallmark@@@@@std@@QBEIXZ PROC ; std::vector<CSkeletonWallmark::WMFace,xalloc<CSkeletonWallmark::WMFace> >::capacity, COMDAT
; _this$ = ecx

; 1545 :         auto& _My_data = _Mypair._Myval2;
; 1546 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx]
	sar	eax, 2
	imul	eax, eax, 1022611261

; 1547 :     }

	ret	0
?capacity@?$vector@UWMFace@CSkeletonWallmark@@V?$xalloc@UWMFace@CSkeletonWallmark@@@@@std@@QBEIXZ ENDP ; std::vector<CSkeletonWallmark::WMFace,xalloc<CSkeletonWallmark::WMFace> >::capacity
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?max_size@?$_Normal_allocator_traits@V?$xalloc@UWMFace@CSkeletonWallmark@@@@@std@@SAIABV?$xalloc@UWMFace@CSkeletonWallmark@@@@@Z
_TEXT	SEGMENT
?max_size@?$_Normal_allocator_traits@V?$xalloc@UWMFace@CSkeletonWallmark@@@@@std@@SAIABV?$xalloc@UWMFace@CSkeletonWallmark@@@@@Z PROC ; std::_Normal_allocator_traits<xalloc<CSkeletonWallmark::WMFace> >::max_size, COMDAT
; __Al$dead$ = ecx

; 591  :         if constexpr (_Has_max_size<_Alloc>::value) {
; 592  :             return _Al.max_size();

	mov	eax, 51130563				; 030c30c3H

; 593  :         } else {
; 594  :             return (numeric_limits<size_type>::max)() / sizeof(value_type);
; 595  :         }
; 596  :     }

	ret	0
?max_size@?$_Normal_allocator_traits@V?$xalloc@UWMFace@CSkeletonWallmark@@@@@std@@SAIABV?$xalloc@UWMFace@CSkeletonWallmark@@@@@Z ENDP ; std::_Normal_allocator_traits<xalloc<CSkeletonWallmark::WMFace> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$xalloc@UWMFace@CSkeletonWallmark@@@@V?$_Vector_val@U?$_Simple_types@UWMFace@CSkeletonWallmark@@@std@@@std@@$00@std@@QBEABV?$xalloc@UWMFace@CSkeletonWallmark@@@@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@V?$xalloc@UWMFace@CSkeletonWallmark@@@@V?$_Vector_val@U?$_Simple_types@UWMFace@CSkeletonWallmark@@@std@@@std@@$00@std@@QBEABV?$xalloc@UWMFace@CSkeletonWallmark@@@@XZ PROC ; std::_Compressed_pair<xalloc<CSkeletonWallmark::WMFace>,std::_Vector_val<std::_Simple_types<CSkeletonWallmark::WMFace> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 1343 :         return *this;

	mov	eax, ecx

; 1344 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$xalloc@UWMFace@CSkeletonWallmark@@@@V?$_Vector_val@U?$_Simple_types@UWMFace@CSkeletonWallmark@@@std@@@std@@$00@std@@QBEABV?$xalloc@UWMFace@CSkeletonWallmark@@@@XZ ENDP ; std::_Compressed_pair<xalloc<CSkeletonWallmark::WMFace>,std::_Vector_val<std::_Simple_types<CSkeletonWallmark::WMFace> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?max_size@?$xalloc@UWMFace@CSkeletonWallmark@@@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$xalloc@UWMFace@CSkeletonWallmark@@@@QBEIXZ PROC ; xalloc<CSkeletonWallmark::WMFace>::max_size, COMDAT
; _this$dead$ = ecx

; 86   : 							size_type				max_size		() const								{	size_type _Count = (size_type)(-1) / sizeof (T);	return (0 < _Count ? _Count : 1);	}

	mov	eax, 51130563				; 030c30c3H
	ret	0
?max_size@?$xalloc@UWMFace@CSkeletonWallmark@@@@QBEIXZ ENDP ; xalloc<CSkeletonWallmark::WMFace>::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$destroy@UWMFace@CSkeletonWallmark@@@?$_Normal_allocator_traits@V?$xalloc@UWMFace@CSkeletonWallmark@@@@@std@@SAXAAV?$xalloc@UWMFace@CSkeletonWallmark@@@@PAUWMFace@CSkeletonWallmark@@@Z
_TEXT	SEGMENT
??$destroy@UWMFace@CSkeletonWallmark@@@?$_Normal_allocator_traits@V?$xalloc@UWMFace@CSkeletonWallmark@@@@@std@@SAXAAV?$xalloc@UWMFace@CSkeletonWallmark@@@@PAUWMFace@CSkeletonWallmark@@@Z PROC ; std::_Normal_allocator_traits<xalloc<CSkeletonWallmark::WMFace> >::destroy<CSkeletonWallmark::WMFace>, COMDAT
; __Al$dead$ = ecx
; __Ptr$dead$ = edx

; 579  :         if constexpr (_Uses_default_destroy<_Alloc, _Ty*>::value) {
; 580  : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 581  :             _STD destroy_at(_Ptr);
; 582  : #else // __cpp_lib_constexpr_dynamic_alloc
; 583  :             _Ptr->~_Ty();
; 584  : #endif // __cpp_lib_constexpr_dynamic_alloc
; 585  :         } else {
; 586  :             _Al.destroy(_Ptr);
; 587  :         }
; 588  :     }

	ret	0
??$destroy@UWMFace@CSkeletonWallmark@@@?$_Normal_allocator_traits@V?$xalloc@UWMFace@CSkeletonWallmark@@@@@std@@SAXAAV?$xalloc@UWMFace@CSkeletonWallmark@@@@PAUWMFace@CSkeletonWallmark@@@Z ENDP ; std::_Normal_allocator_traits<xalloc<CSkeletonWallmark::WMFace> >::destroy<CSkeletonWallmark::WMFace>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Uninitialized_move@PAUWMFace@CSkeletonWallmark@@V?$xalloc@UWMFace@CSkeletonWallmark@@@@@std@@YAPAUWMFace@CSkeletonWallmark@@QAU12@0PAU12@AAV?$xalloc@UWMFace@CSkeletonWallmark@@@@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Al$dead$ = 12						; size = 4
??$_Uninitialized_move@PAUWMFace@CSkeletonWallmark@@V?$xalloc@UWMFace@CSkeletonWallmark@@@@@std@@YAPAUWMFace@CSkeletonWallmark@@QAU12@0PAU12@AAV?$xalloc@UWMFace@CSkeletonWallmark@@@@@Z PROC ; std::_Uninitialized_move<CSkeletonWallmark::WMFace *,xalloc<CSkeletonWallmark::WMFace> >, COMDAT
; __First$ = ecx
; __Last$ = edx

; 1699 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

	push	ebx
	mov	ebx, edx
	mov	eax, ecx

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	edx, DWORD PTR __Dest$[esp]

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	eax, ebx
	je	SHORT $LN20@Uninitiali
	push	esi
	push	edi
	npad	1
$LL4@Uninitiali:
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	esi, eax
	mov	edi, edx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1621 :         ++_Last;

	add	eax, 84					; 00000054H
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	ecx, 21					; 00000015H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1621 :         ++_Last;

	add	edx, 84					; 00000054H
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	rep movsd
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	eax, ebx
	jne	SHORT $LL4@Uninitiali

; 1718 :         _Backout._Emplace_back(_STD move(*_UFirst));
; 1719 :     }
; 1720 : 
; 1721 :     return _Backout._Release();

	pop	edi
	pop	esi
$LN20@Uninitiali:

; 1722 : }

	mov	eax, edx
	pop	ebx
	ret	0
??$_Uninitialized_move@PAUWMFace@CSkeletonWallmark@@V?$xalloc@UWMFace@CSkeletonWallmark@@@@@std@@YAPAUWMFace@CSkeletonWallmark@@QAU12@0PAU12@AAV?$xalloc@UWMFace@CSkeletonWallmark@@@@@Z ENDP ; std::_Uninitialized_move<CSkeletonWallmark::WMFace *,xalloc<CSkeletonWallmark::WMFace> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_Get_unwrapped@ABQAUWMFace@CSkeletonWallmark@@@std@@YA?A_TABQAUWMFace@CSkeletonWallmark@@@Z
_TEXT	SEGMENT
??$_Get_unwrapped@ABQAUWMFace@CSkeletonWallmark@@@std@@YA?A_TABQAUWMFace@CSkeletonWallmark@@@Z PROC ; std::_Get_unwrapped<CSkeletonWallmark::WMFace * const &>, COMDAT
; __It$ = ecx

; 1275 :     // unwrap an iterator previously subjected to _Adl_verify_range or otherwise validated
; 1276 :     if constexpr (is_pointer_v<decay_t<_Iter>>) { // special-case pointers and arrays
; 1277 :         return _It + 0;

	mov	eax, DWORD PTR [ecx]

; 1278 :     } else if constexpr (_Unwrappable_v<_Iter>) {
; 1279 :         return static_cast<_Iter&&>(_It)._Unwrapped();
; 1280 :     } else {
; 1281 :         return static_cast<_Iter&&>(_It);
; 1282 :     }
; 1283 : }

	ret	0
??$_Get_unwrapped@ABQAUWMFace@CSkeletonWallmark@@@std@@YA?A_TABQAUWMFace@CSkeletonWallmark@@@Z ENDP ; std::_Get_unwrapped<CSkeletonWallmark::WMFace * const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
;	COMDAT ??$xr_alloc@UWMFace@CSkeletonWallmark@@@@YAPAUWMFace@CSkeletonWallmark@@I@Z
_TEXT	SEGMENT
??$xr_alloc@UWMFace@CSkeletonWallmark@@@@YAPAUWMFace@CSkeletonWallmark@@I@Z PROC ; xr_alloc<CSkeletonWallmark::WMFace>, COMDAT
; _count$ = ecx

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	imul	eax, ecx, 84
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
	ret	0
??$xr_alloc@UWMFace@CSkeletonWallmark@@@@YAPAUWMFace@CSkeletonWallmark@@I@Z ENDP ; xr_alloc<CSkeletonWallmark::WMFace>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Release@?$_Uninitialized_backout_al@V?$xalloc@UWMFace@CSkeletonWallmark@@@@@std@@QAEPAUWMFace@CSkeletonWallmark@@XZ
_TEXT	SEGMENT
?_Release@?$_Uninitialized_backout_al@V?$xalloc@UWMFace@CSkeletonWallmark@@@@@std@@QAEPAUWMFace@CSkeletonWallmark@@XZ PROC ; std::_Uninitialized_backout_al<xalloc<CSkeletonWallmark::WMFace> >::_Release, COMDAT
; _this$ = ecx

; 1625 :         _First = _Last;

	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [ecx], eax

; 1626 :         return _Last;
; 1627 :     }

	ret	0
?_Release@?$_Uninitialized_backout_al@V?$xalloc@UWMFace@CSkeletonWallmark@@@@@std@@QAEPAUWMFace@CSkeletonWallmark@@XZ ENDP ; std::_Uninitialized_backout_al<xalloc<CSkeletonWallmark::WMFace> >::_Release
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??1?$_Uninitialized_backout_al@V?$xalloc@UWMFace@CSkeletonWallmark@@@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Uninitialized_backout_al@V?$xalloc@UWMFace@CSkeletonWallmark@@@@@std@@QAE@XZ PROC ; std::_Uninitialized_backout_al<xalloc<CSkeletonWallmark::WMFace> >::~_Uninitialized_backout_al<xalloc<CSkeletonWallmark::WMFace> >, COMDAT
; _this$ = ecx

; 1615 :         _Destroy_range(_First, _Last, _Al);
; 1616 :     }

	ret	0
??1?$_Uninitialized_backout_al@V?$xalloc@UWMFace@CSkeletonWallmark@@@@@std@@QAE@XZ ENDP ; std::_Uninitialized_backout_al<xalloc<CSkeletonWallmark::WMFace> >::~_Uninitialized_backout_al<xalloc<CSkeletonWallmark::WMFace> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??0?$_Uninitialized_backout_al@V?$xalloc@UWMFace@CSkeletonWallmark@@@@@std@@QAE@PAUWMFace@CSkeletonWallmark@@AAV?$xalloc@UWMFace@CSkeletonWallmark@@@@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Al_$ = 12						; size = 4
??0?$_Uninitialized_backout_al@V?$xalloc@UWMFace@CSkeletonWallmark@@@@@std@@QAE@PAUWMFace@CSkeletonWallmark@@AAV?$xalloc@UWMFace@CSkeletonWallmark@@@@@Z PROC ; std::_Uninitialized_backout_al<xalloc<CSkeletonWallmark::WMFace> >::_Uninitialized_backout_al<xalloc<CSkeletonWallmark::WMFace> >, COMDAT
; _this$ = ecx

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	eax, DWORD PTR __Dest$[esp-4]
	mov	DWORD PTR [ecx], eax
	mov	DWORD PTR [ecx+4], eax
	mov	eax, DWORD PTR __Al_$[esp-4]
	mov	DWORD PTR [ecx+8], eax
	mov	eax, ecx
	ret	8
??0?$_Uninitialized_backout_al@V?$xalloc@UWMFace@CSkeletonWallmark@@@@@std@@QAE@PAUWMFace@CSkeletonWallmark@@AAV?$xalloc@UWMFace@CSkeletonWallmark@@@@@Z ENDP ; std::_Uninitialized_backout_al<xalloc<CSkeletonWallmark::WMFace> >::_Uninitialized_backout_al<xalloc<CSkeletonWallmark::WMFace> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?destroy@?$xalloc@UWMFace@CSkeletonWallmark@@@@QAEXPAUWMFace@CSkeletonWallmark@@@Z
_TEXT	SEGMENT
_p$dead$ = 8						; size = 4
?destroy@?$xalloc@UWMFace@CSkeletonWallmark@@@@QAEXPAUWMFace@CSkeletonWallmark@@@Z PROC ; xalloc<CSkeletonWallmark::WMFace>::destroy, COMDAT
; _this$dead$ = ecx

; 85   : 							void					destroy			(pointer p)								{	std::_Destroy_in_place(p);			}

	ret	4
?destroy@?$xalloc@UWMFace@CSkeletonWallmark@@@@QAEXPAUWMFace@CSkeletonWallmark@@@Z ENDP ; xalloc<CSkeletonWallmark::WMFace>::destroy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\type_traits
;	COMDAT ??$move@AAUWMFace@CSkeletonWallmark@@@std@@YA$$QAUWMFace@CSkeletonWallmark@@AAU12@@Z
_TEXT	SEGMENT
??$move@AAUWMFace@CSkeletonWallmark@@@std@@YA$$QAUWMFace@CSkeletonWallmark@@AAU12@@Z PROC ; std::move<CSkeletonWallmark::WMFace &>, COMDAT
; __Arg$ = ecx

; 1397 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

	mov	eax, ecx

; 1398 : }

	ret	0
??$move@AAUWMFace@CSkeletonWallmark@@@std@@YA$$QAUWMFace@CSkeletonWallmark@@AAU12@@Z ENDP ; std::move<CSkeletonWallmark::WMFace &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Emplace_back@UWMFace@CSkeletonWallmark@@@?$_Uninitialized_backout_al@V?$xalloc@UWMFace@CSkeletonWallmark@@@@@std@@QAEX$$QAUWMFace@CSkeletonWallmark@@@Z
_TEXT	SEGMENT
_<_Vals_0>$ = 8						; size = 4
??$_Emplace_back@UWMFace@CSkeletonWallmark@@@?$_Uninitialized_backout_al@V?$xalloc@UWMFace@CSkeletonWallmark@@@@@std@@QAEX$$QAUWMFace@CSkeletonWallmark@@@Z PROC ; std::_Uninitialized_backout_al<xalloc<CSkeletonWallmark::WMFace> >::_Emplace_back<CSkeletonWallmark::WMFace>, COMDAT
; _this$ = ecx

; 1619 :     _CONSTEXPR20_DYNALLOC void _Emplace_back(_Types&&... _Vals) { // construct a new element at *_Last and increment

	mov	eax, ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	ecx, 21					; 00000015H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1619 :     _CONSTEXPR20_DYNALLOC void _Emplace_back(_Types&&... _Vals) { // construct a new element at *_Last and increment

	push	esi
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	esi, DWORD PTR _<_Vals_0>$[esp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1619 :     _CONSTEXPR20_DYNALLOC void _Emplace_back(_Types&&... _Vals) { // construct a new element at *_Last and increment

	push	edi
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	edi, DWORD PTR [eax+4]
	rep movsd
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1621 :         ++_Last;

	add	DWORD PTR [eax+4], 84			; 00000054H
	pop	edi
	pop	esi

; 1622 :     }

	ret	4
??$_Emplace_back@UWMFace@CSkeletonWallmark@@@?$_Uninitialized_backout_al@V?$xalloc@UWMFace@CSkeletonWallmark@@@@@std@@QAEX$$QAUWMFace@CSkeletonWallmark@@@Z ENDP ; std::_Uninitialized_backout_al<xalloc<CSkeletonWallmark::WMFace> >::_Emplace_back<CSkeletonWallmark::WMFace>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Destroy_in_place@PAUWMFace@CSkeletonWallmark@@@std@@YAXAAPAUWMFace@CSkeletonWallmark@@@Z
_TEXT	SEGMENT
??$_Destroy_in_place@PAUWMFace@CSkeletonWallmark@@@std@@YAXAAPAUWMFace@CSkeletonWallmark@@@Z PROC ; std::_Destroy_in_place<CSkeletonWallmark::WMFace *>, COMDAT
; __Obj$dead$ = ecx

; 295  :     if constexpr (is_array_v<_Ty>) {
; 296  :         _Destroy_range(_Obj, _Obj + extent_v<_Ty>);
; 297  :     } else {
; 298  :         _Obj.~_Ty();
; 299  :     }
; 300  : }

	ret	0
??$_Destroy_in_place@PAUWMFace@CSkeletonWallmark@@@std@@YAXAAPAUWMFace@CSkeletonWallmark@@@Z ENDP ; std::_Destroy_in_place<CSkeletonWallmark::WMFace *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\type_traits
;	COMDAT ??$forward@UWMFace@CSkeletonWallmark@@@std@@YA$$QAUWMFace@CSkeletonWallmark@@AAU12@@Z
_TEXT	SEGMENT
??$forward@UWMFace@CSkeletonWallmark@@@std@@YA$$QAUWMFace@CSkeletonWallmark@@AAU12@@Z PROC ; std::forward<CSkeletonWallmark::WMFace>, COMDAT
; __Arg$ = ecx

; 1386 :     return static_cast<_Ty&&>(_Arg);

	mov	eax, ecx

; 1387 : }

	ret	0
??$forward@UWMFace@CSkeletonWallmark@@@std@@YA$$QAUWMFace@CSkeletonWallmark@@AAU12@@Z ENDP ; std::forward<CSkeletonWallmark::WMFace>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$construct@UWMFace@CSkeletonWallmark@@U12@@?$_Normal_allocator_traits@V?$xalloc@UWMFace@CSkeletonWallmark@@@@@std@@SAXAAV?$xalloc@UWMFace@CSkeletonWallmark@@@@PAUWMFace@CSkeletonWallmark@@$$QAU34@@Z
_TEXT	SEGMENT
_<_Args_0>$ = 8						; size = 4
??$construct@UWMFace@CSkeletonWallmark@@U12@@?$_Normal_allocator_traits@V?$xalloc@UWMFace@CSkeletonWallmark@@@@@std@@SAXAAV?$xalloc@UWMFace@CSkeletonWallmark@@@@PAUWMFace@CSkeletonWallmark@@$$QAU34@@Z PROC ; std::_Normal_allocator_traits<xalloc<CSkeletonWallmark::WMFace> >::construct<CSkeletonWallmark::WMFace,CSkeletonWallmark::WMFace>, COMDAT
; __Al$dead$ = ecx
; __Ptr$ = edx

; 564  :     static _CONSTEXPR20_DYNALLOC void construct(_Alloc& _Al, _Ty* _Ptr, _Types&&... _Args) {

	push	esi
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	esi, DWORD PTR _<_Args_0>$[esp]
	mov	ecx, 21					; 00000015H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 564  :     static _CONSTEXPR20_DYNALLOC void construct(_Alloc& _Al, _Ty* _Ptr, _Types&&... _Args) {

	push	edi
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	edi, edx
	rep movsd
	pop	edi
	pop	esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 575  :     }

	ret	0
??$construct@UWMFace@CSkeletonWallmark@@U12@@?$_Normal_allocator_traits@V?$xalloc@UWMFace@CSkeletonWallmark@@@@@std@@SAXAAV?$xalloc@UWMFace@CSkeletonWallmark@@@@PAUWMFace@CSkeletonWallmark@@$$QAU34@@Z ENDP ; std::_Normal_allocator_traits<xalloc<CSkeletonWallmark::WMFace> >::construct<CSkeletonWallmark::WMFace,CSkeletonWallmark::WMFace>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_color.h
;	COMDAT ?color_get_A@@YAII@Z
_TEXT	SEGMENT
?color_get_A@@YAII@Z PROC				; color_get_A, COMDAT
; _rgba$ = ecx

; 20   : ICF	u32 color_get_A (u32 rgba)						{	return ((rgba) >> 24);			}

	shr	ecx, 24					; 00000018H
	mov	eax, ecx
	ret	0
?color_get_A@@YAII@Z ENDP				; color_get_A
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_color.h
;	COMDAT ?color_argb@@YAIIIII@Z
_TEXT	SEGMENT
_g$ = 8							; size = 4
_b$ = 12						; size = 4
?color_argb@@YAIIIII@Z PROC				; color_argb, COMDAT
; _a$ = ecx
; _r$ = edx

; 5    : ICF u32	color_argb	(u32 a, u32 r, u32 g, u32 b)	{	return ((a&0xff)<<24)|((r&0xff)<<16)|((g&0xff)<<8)|(b&0xff);	}

	shl	ecx, 8
	movzx	eax, dl
	or	eax, ecx
	movzx	ecx, BYTE PTR _g$[esp-4]
	shl	eax, 8
	or	eax, ecx
	movzx	ecx, BYTE PTR _b$[esp-4]
	shl	eax, 8
	or	eax, ecx
	ret	0
?color_argb@@YAIIIII@Z ENDP				; color_argb
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_color.h
;	COMDAT ?color_rgba@@YAIIIII@Z
_TEXT	SEGMENT
_b$ = 8							; size = 4
_a$ = 12						; size = 4
?color_rgba@@YAIIIII@Z PROC				; color_rgba, COMDAT
; _r$ = ecx
; _g$ = edx

; 5    : ICF u32	color_argb	(u32 a, u32 r, u32 g, u32 b)	{	return ((a&0xff)<<24)|((r&0xff)<<16)|((g&0xff)<<8)|(b&0xff);	}

	movzx	eax, cl
	mov	ecx, DWORD PTR _a$[esp-4]
	shl	ecx, 8
	or	eax, ecx
	movzx	ecx, dl
	shl	eax, 8
	or	eax, ecx
	movzx	ecx, BYTE PTR _b$[esp-4]
	shl	eax, 8
	or	eax, ecx

; 6    : ICF u32	color_rgba	(u32 r, u32 g, u32 b, u32 a)	{	return color_argb(a,r,g,b);		}

	ret	0
?color_rgba@@YAIIIII@Z ENDP				; color_rgba
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\vector.h
;	COMDAT ??$clampr@H@@YAHABH00@Z
_TEXT	SEGMENT
__high$ = 8						; size = 4
??$clampr@H@@YAHABH00@Z PROC				; clampr<int>, COMDAT
; _val$ = ecx
; __low$ = edx

; 96   : 	if		( val<_low	)	return _low; 

	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx]
	cmp	eax, ecx
	jge	SHORT $LN2@clampr
	mov	eax, ecx

; 98   : 	else					return val;
; 99   : };

	ret	0
$LN2@clampr:

; 97   : 	else if	( val>_high )	return _high;

	mov	ecx, DWORD PTR __high$[esp-4]
	mov	ecx, DWORD PTR [ecx]
	cmp	eax, ecx
	cmovg	eax, ecx

; 98   : 	else					return val;
; 99   : };

	ret	0
??$clampr@H@@YAHABH00@Z ENDP				; clampr<int>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\xrstring.h
;	COMDAT ??0shared_str@@QAE@XZ
_TEXT	SEGMENT
??0shared_str@@QAE@XZ PROC				; shared_str::shared_str, COMDAT
; _this$ = ecx

; 57   : 						shared_str	()								{	p_ = 0;											}

	mov	DWORD PTR [ecx], 0
	mov	eax, ecx
	ret	0
??0shared_str@@QAE@XZ ENDP				; shared_str::shared_str
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h
;	COMDAT _fabsf
_TEXT	SEGMENT
__X$ = 8						; size = 4
_fabsf	PROC						; COMDAT

; 676  :             return (float)fabs(_X);

	fld	DWORD PTR __X$[esp-4]
	fabs

; 677  :         }

	ret	0
_fabsf	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_std_extensions.h
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_std_extensions.h
;	COMDAT ?_abs@@YAMM@Z
_TEXT	SEGMENT
_x$ = 8							; size = 4
?_abs@@YAMM@Z PROC					; _abs, COMDAT
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h

; 676  :             return (float)fabs(_X);

	fld	DWORD PTR _x$[esp-4]
	fabs
; File I:\Vitalya\mine\NSProjectX\xrCore\_std_extensions.h

; 98   : IC float	_abs	(float x)		{ return fabsf(x); }

	ret	0
?_abs@@YAMM@Z ENDP					; _abs
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector2.h
;	COMDAT ?set@?$_vector2@M@@QAEAAU1@MM@Z
_TEXT	SEGMENT
__u$ = 8						; size = 4
__v$ = 12						; size = 4
?set@?$_vector2@M@@QAEAAU1@MM@Z PROC			; _vector2<float>::set, COMDAT
; _this$ = ecx

; 15   : 	IC SelfRef set(float _u, float _v)				{ x=T(_u); y=T(_v);				return *this;	}

	movss	xmm0, DWORD PTR __u$[esp-4]
	mov	eax, ecx
	movss	DWORD PTR [ecx], xmm0
	movss	xmm0, DWORD PTR __v$[esp-4]
	movss	DWORD PTR [ecx+4], xmm0
	ret	8
?set@?$_vector2@M@@QAEAAU1@MM@Z ENDP			; _vector2<float>::set
_TEXT	ENDS
END
