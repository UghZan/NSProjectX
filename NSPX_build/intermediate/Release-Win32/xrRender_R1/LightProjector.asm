; Listing generated by Microsoft (R) Optimizing Compiler Version 19.29.30146.0 

	TITLE	i:\vitalya\mine\nsprojectx\nspx_build\intermediate\release-win32\xrrender_r1\lightprojector.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	??_C@_0O@EGLBEPCM@m_plmap_xform@		; `string'
PUBLIC	??_C@_0O@GNNJFKLH@m_plmap_clamp@		; `string'
PUBLIC	??_C@_0P@OGGMHHEA@m_plmap_factor@		; `string'
PUBLIC	??_C@_0DN@FFEDFBLH@?$CB?5Invalid?5object?5?8?$CFs?8?5position?4@ ; `string'
PUBLIC	??_R2CLightProjector@@8				; CLightProjector::`RTTI Base Class Array'
PUBLIC	??_R2pureAppActivate@@8				; pureAppActivate::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CLightProjector@@8		; CLightProjector::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@pureAppActivate@@8		; pureAppActivate::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R3pureAppActivate@@8				; pureAppActivate::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R0?AVpureAppActivate@@@8			; pureAppActivate `RTTI Type Descriptor'
PUBLIC	??_R3CLightProjector@@8				; CLightProjector::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R0?AVCLightProjector@@@8			; CLightProjector `RTTI Type Descriptor'
PUBLIC	??_R4CLightProjector@@6B@			; CLightProjector::`RTTI Complete Object Locator'
PUBLIC	??_7CLightProjector@@6B@			; CLightProjector::`vftable'
EXTRN	__imp_?cName@CObject@@QBE?AVshared_str@@XZ:PROC
EXTRN	__imp_??0pureAppActivate@@QAE@XZ:PROC
EXTRN	__imp_?seta@R_constants@@QAEXPAUR_constant@@IABU?$_vector4@M@@@Z:PROC
EXTRN	__imp_?seta@R_constants@@QAEXPAUR_constant@@IMMMM@Z:PROC
EXTRN	__imp_?set_ca@CBackend@@QAEXPAUR_constant@@IMMMM@Z:PROC
EXTRN	__imp_?set_ca@CBackend@@QAEXAAVshared_str@@IMMMM@Z:PROC
EXTRN	__imp_??_7pureAppActivate@@6B@:QWORD
;	COMDAT ??_7CLightProjector@@6B@
CONST	SEGMENT
??_7CLightProjector@@6B@ DD FLAT:??_R4CLightProjector@@6B@ ; CLightProjector::`vftable'
	DD	FLAT:?OnAppActivate@CLightProjector@@UAEXXZ
CONST	ENDS
;	COMDAT ??_R4CLightProjector@@6B@
rdata$r	SEGMENT
??_R4CLightProjector@@6B@ DD 00H			; CLightProjector::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCLightProjector@@@8
	DD	FLAT:??_R3CLightProjector@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCLightProjector@@@8
data$rs	SEGMENT
??_R0?AVCLightProjector@@@8 DD FLAT:??_7type_info@@6B@	; CLightProjector `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCLightProjector@@', 00H
data$rs	ENDS
;	COMDAT ??_R3CLightProjector@@8
rdata$r	SEGMENT
??_R3CLightProjector@@8 DD 00H				; CLightProjector::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2CLightProjector@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVpureAppActivate@@@8
data$rs	SEGMENT
??_R0?AVpureAppActivate@@@8 DD FLAT:??_7type_info@@6B@	; pureAppActivate `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVpureAppActivate@@', 00H
data$rs	ENDS
;	COMDAT ??_R3pureAppActivate@@8
rdata$r	SEGMENT
??_R3pureAppActivate@@8 DD 00H				; pureAppActivate::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2pureAppActivate@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@pureAppActivate@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@pureAppActivate@@8 DD FLAT:??_R0?AVpureAppActivate@@@8 ; pureAppActivate::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3pureAppActivate@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@CLightProjector@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CLightProjector@@8 DD FLAT:??_R0?AVCLightProjector@@@8 ; CLightProjector::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CLightProjector@@8
rdata$r	ENDS
;	COMDAT ??_R2pureAppActivate@@8
rdata$r	SEGMENT
??_R2pureAppActivate@@8 DD FLAT:??_R1A@?0A@EA@pureAppActivate@@8 ; pureAppActivate::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R2CLightProjector@@8
rdata$r	SEGMENT
??_R2CLightProjector@@8 DD FLAT:??_R1A@?0A@EA@CLightProjector@@8 ; CLightProjector::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@pureAppActivate@@8
rdata$r	ENDS
;	COMDAT ??_C@_0DN@FFEDFBLH@?$CB?5Invalid?5object?5?8?$CFs?8?5position?4@
CONST	SEGMENT
??_C@_0DN@FFEDFBLH@?$CB?5Invalid?5object?5?8?$CFs?8?5position?4@ DB '! In'
	DB	'valid object ''%s'' position. Outside of sector structure.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@OGGMHHEA@m_plmap_factor@
CONST	SEGMENT
??_C@_0P@OGGMHHEA@m_plmap_factor@ DB 'm_plmap_factor', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@GNNJFKLH@m_plmap_clamp@
CONST	SEGMENT
??_C@_0O@GNNJFKLH@m_plmap_clamp@ DB 'm_plmap_clamp', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@EGLBEPCM@m_plmap_xform@
CONST	SEGMENT
??_C@_0O@EGLBEPCM@m_plmap_xform@ DB 'm_plmap_xform', 00H ; `string'
?_Fake_alloc@std@@3U_Fake_allocator@1@B	ORG $+1		; std::_Fake_alloc
PUBLIC	?seta@R_constant_array@@QAEXPAUR_constant@@AAUR_constant_load@@IABU?$_vector4@M@@@Z ; R_constant_array::seta
PUBLIC	?construct@?$xalloc@Urecv@CLightProjector@@@@QAEXPAUrecv@CLightProjector@@ABU23@@Z ; xalloc<CLightProjector::recv>::construct
PUBLIC	??$construct@Urecv@CLightProjector@@U12@@?$_Normal_allocator_traits@V?$xalloc@Urecv@CLightProjector@@@@@std@@SAXAAV?$xalloc@Urecv@CLightProjector@@@@PAUrecv@CLightProjector@@$$QAU34@@Z ; std::_Normal_allocator_traits<xalloc<CLightProjector::recv> >::construct<CLightProjector::recv,CLightProjector::recv>
PUBLIC	??$forward@Urecv@CLightProjector@@@std@@YA$$QAUrecv@CLightProjector@@AAU12@@Z ; std::forward<CLightProjector::recv>
PUBLIC	??$_Emplace_back@Urecv@CLightProjector@@@?$_Uninitialized_backout_al@V?$xalloc@Urecv@CLightProjector@@@@@std@@QAEX$$QAUrecv@CLightProjector@@@Z ; std::_Uninitialized_backout_al<xalloc<CLightProjector::recv> >::_Emplace_back<CLightProjector::recv>
PUBLIC	??$move@AAUrecv@CLightProjector@@@std@@YA$$QAUrecv@CLightProjector@@AAU12@@Z ; std::move<CLightProjector::recv &>
PUBLIC	??$construct@Urecv@CLightProjector@@$$V@?$_Normal_allocator_traits@V?$xalloc@Urecv@CLightProjector@@@@@std@@SAXAAV?$xalloc@Urecv@CLightProjector@@@@PAUrecv@CLightProjector@@@Z ; std::_Normal_allocator_traits<xalloc<CLightProjector::recv> >::construct<CLightProjector::recv>
PUBLIC	??$construct@PAVIRenderable@@PAV1@@?$_Normal_allocator_traits@V?$xalloc@PAVIRenderable@@@@@std@@SAXAAV?$xalloc@PAVIRenderable@@@@PAPAVIRenderable@@$$QAPAV3@@Z ; std::_Normal_allocator_traits<xalloc<IRenderable *> >::construct<IRenderable *,IRenderable *>
PUBLIC	??$forward@PAVIRenderable@@@std@@YA$$QAPAVIRenderable@@AAPAV1@@Z ; std::forward<IRenderable *>
PUBLIC	??$_Get_unwrapped@ABQAUrecv@CLightProjector@@@std@@YA?A_TABQAUrecv@CLightProjector@@@Z ; std::_Get_unwrapped<CLightProjector::recv * const &>
PUBLIC	??$_Uninitialized_move@PAUrecv@CLightProjector@@V?$xalloc@Urecv@CLightProjector@@@@@std@@YAPAUrecv@CLightProjector@@QAU12@0PAU12@AAV?$xalloc@Urecv@CLightProjector@@@@@Z ; std::_Uninitialized_move<CLightProjector::recv *,xalloc<CLightProjector::recv> >
PUBLIC	??$xr_alloc@Urecv@CLightProjector@@@@YAPAUrecv@CLightProjector@@I@Z ; xr_alloc<CLightProjector::recv>
PUBLIC	??$_Destroy_in_place@PAUrecv@CLightProjector@@@std@@YAXAAPAUrecv@CLightProjector@@@Z ; std::_Destroy_in_place<CLightProjector::recv *>
PUBLIC	??$_Emplace_back@$$V@?$_Uninitialized_backout_al@V?$xalloc@Urecv@CLightProjector@@@@@std@@QAEXXZ ; std::_Uninitialized_backout_al<xalloc<CLightProjector::recv> >::_Emplace_back<>
PUBLIC	??$_Emplace_back@PAVIRenderable@@@?$_Uninitialized_backout_al@V?$xalloc@PAVIRenderable@@@@@std@@QAEX$$QAPAVIRenderable@@@Z ; std::_Uninitialized_backout_al<xalloc<IRenderable *> >::_Emplace_back<IRenderable *>
PUBLIC	??$move@AAPAVIRenderable@@@std@@YA$$QAPAVIRenderable@@AAPAV1@@Z ; std::move<IRenderable * &>
PUBLIC	?max_size@?$xalloc@Urecv@CLightProjector@@@@QBEIXZ ; xalloc<CLightProjector::recv>::max_size
PUBLIC	?_Get_first@?$_Compressed_pair@V?$xalloc@Urecv@CLightProjector@@@@V?$_Vector_val@U?$_Simple_types@Urecv@CLightProjector@@@std@@@std@@$00@std@@QBEABV?$xalloc@Urecv@CLightProjector@@@@XZ ; std::_Compressed_pair<xalloc<CLightProjector::recv>,std::_Vector_val<std::_Simple_types<CLightProjector::recv> >,1>::_Get_first
PUBLIC	?max_size@?$_Normal_allocator_traits@V?$xalloc@Urecv@CLightProjector@@@@@std@@SAIABV?$xalloc@Urecv@CLightProjector@@@@@Z ; std::_Normal_allocator_traits<xalloc<CLightProjector::recv> >::max_size
PUBLIC	?capacity@?$vector@Urecv@CLightProjector@@V?$xalloc@Urecv@CLightProjector@@@@@std@@QBEIXZ ; std::vector<CLightProjector::recv,xalloc<CLightProjector::recv> >::capacity
PUBLIC	?_Umove_if_noexcept1@?$vector@Urecv@CLightProjector@@V?$xalloc@Urecv@CLightProjector@@@@@std@@AAEXPAUrecv@CLightProjector@@00U?$integral_constant@_N$00@2@@Z ; std::vector<CLightProjector::recv,xalloc<CLightProjector::recv> >::_Umove_if_noexcept1
PUBLIC	?_Getal@?$vector@Urecv@CLightProjector@@V?$xalloc@Urecv@CLightProjector@@@@@std@@ABEABV?$xalloc@Urecv@CLightProjector@@@@XZ ; std::vector<CLightProjector::recv,xalloc<CLightProjector::recv> >::_Getal
PUBLIC	?allocate@?$xalloc@Urecv@CLightProjector@@@@QBEPAUrecv@CLightProjector@@IPBX@Z ; xalloc<CLightProjector::recv>::allocate
PUBLIC	?destroy@?$xalloc@Urecv@CLightProjector@@@@QAEXPAUrecv@CLightProjector@@@Z ; xalloc<CLightProjector::recv>::destroy
PUBLIC	?max_size@?$vector@Urecv@CLightProjector@@V?$xalloc@Urecv@CLightProjector@@@@@std@@QBEIXZ ; std::vector<CLightProjector::recv,xalloc<CLightProjector::recv> >::max_size
PUBLIC	?_Umove_if_noexcept@?$vector@Urecv@CLightProjector@@V?$xalloc@Urecv@CLightProjector@@@@@std@@AAEXPAUrecv@CLightProjector@@00@Z ; std::vector<CLightProjector::recv,xalloc<CLightProjector::recv> >::_Umove_if_noexcept
PUBLIC	?_Calculate_growth@?$vector@Urecv@CLightProjector@@V?$xalloc@Urecv@CLightProjector@@@@@std@@ABEII@Z ; std::vector<CLightProjector::recv,xalloc<CLightProjector::recv> >::_Calculate_growth
PUBLIC	?_Change_array@?$vector@Urecv@CLightProjector@@V?$xalloc@Urecv@CLightProjector@@@@@std@@AAEXQAUrecv@CLightProjector@@II@Z ; std::vector<CLightProjector::recv,xalloc<CLightProjector::recv> >::_Change_array
PUBLIC	?_Xlength@?$vector@Urecv@CLightProjector@@V?$xalloc@Urecv@CLightProjector@@@@@std@@CAXXZ ; std::vector<CLightProjector::recv,xalloc<CLightProjector::recv> >::_Xlength
PUBLIC	??0?$_Uninitialized_backout_al@V?$xalloc@PAVIRenderable@@@@@std@@QAE@PAPAVIRenderable@@AAV?$xalloc@PAVIRenderable@@@@@Z ; std::_Uninitialized_backout_al<xalloc<IRenderable *> >::_Uninitialized_backout_al<xalloc<IRenderable *> >
PUBLIC	??1?$_Uninitialized_backout_al@V?$xalloc@PAVIRenderable@@@@@std@@QAE@XZ ; std::_Uninitialized_backout_al<xalloc<IRenderable *> >::~_Uninitialized_backout_al<xalloc<IRenderable *> >
PUBLIC	?_Release@?$_Uninitialized_backout_al@V?$xalloc@PAVIRenderable@@@@@std@@QAEPAPAVIRenderable@@XZ ; std::_Uninitialized_backout_al<xalloc<IRenderable *> >::_Release
PUBLIC	??0?$_Uninitialized_backout_al@V?$xalloc@Urecv@CLightProjector@@@@@std@@QAE@PAUrecv@CLightProjector@@AAV?$xalloc@Urecv@CLightProjector@@@@@Z ; std::_Uninitialized_backout_al<xalloc<CLightProjector::recv> >::_Uninitialized_backout_al<xalloc<CLightProjector::recv> >
PUBLIC	??1?$_Uninitialized_backout_al@V?$xalloc@Urecv@CLightProjector@@@@@std@@QAE@XZ ; std::_Uninitialized_backout_al<xalloc<CLightProjector::recv> >::~_Uninitialized_backout_al<xalloc<CLightProjector::recv> >
PUBLIC	?_Release@?$_Uninitialized_backout_al@V?$xalloc@Urecv@CLightProjector@@@@@std@@QAEPAUrecv@CLightProjector@@XZ ; std::_Uninitialized_backout_al<xalloc<CLightProjector::recv> >::_Release
PUBLIC	??$_Uninitialized_value_construct_n@V?$xalloc@Urecv@CLightProjector@@@@@std@@YAPAUrecv@CLightProjector@@PAU12@IAAV?$xalloc@Urecv@CLightProjector@@@@@Z ; std::_Uninitialized_value_construct_n<xalloc<CLightProjector::recv> >
PUBLIC	??$xr_alloc@PAVIRenderable@@@@YAPAPAVIRenderable@@I@Z ; xr_alloc<IRenderable *>
PUBLIC	??$_Get_unwrapped@ABQAPAVIRenderable@@@std@@YA?A_TABQAPAVIRenderable@@@Z ; std::_Get_unwrapped<IRenderable * * const &>
PUBLIC	??$_Uninitialized_move@PAPAVIRenderable@@V?$xalloc@PAVIRenderable@@@@@std@@YAPAPAVIRenderable@@QAPAV1@0PAPAV1@AAV?$xalloc@PAVIRenderable@@@@@Z ; std::_Uninitialized_move<IRenderable * *,xalloc<IRenderable *> >
PUBLIC	??$destroy@Urecv@CLightProjector@@@?$_Normal_allocator_traits@V?$xalloc@Urecv@CLightProjector@@@@@std@@SAXAAV?$xalloc@Urecv@CLightProjector@@@@PAUrecv@CLightProjector@@@Z ; std::_Normal_allocator_traits<xalloc<CLightProjector::recv> >::destroy<CLightProjector::recv>
PUBLIC	??$_Unfancy@Urecv@CLightProjector@@@std@@YAPAUrecv@CLightProjector@@PAU12@@Z ; std::_Unfancy<CLightProjector::recv>
PUBLIC	??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@Urecv@CLightProjector@@V?$xalloc@Urecv@CLightProjector@@@@@std@@AAEXIABU_Value_init_tag@1@@Z ; std::vector<CLightProjector::recv,xalloc<CLightProjector::recv> >::_Resize_reallocate<std::_Value_init_tag>
PUBLIC	?max_size@?$xalloc@PAVIRenderable@@@@QBEIXZ	; xalloc<IRenderable *>::max_size
PUBLIC	?_Get_first@?$_Compressed_pair@V?$xalloc@PAVIRenderable@@@@V?$_Vector_val@U?$_Simple_types@PAVIRenderable@@@std@@@std@@$00@std@@QBEABV?$xalloc@PAVIRenderable@@@@XZ ; std::_Compressed_pair<xalloc<IRenderable *>,std::_Vector_val<std::_Simple_types<IRenderable *> >,1>::_Get_first
PUBLIC	?max_size@?$_Normal_allocator_traits@V?$xalloc@PAVIRenderable@@@@@std@@SAIABV?$xalloc@PAVIRenderable@@@@@Z ; std::_Normal_allocator_traits<xalloc<IRenderable *> >::max_size
PUBLIC	?capacity@?$vector@PAVIRenderable@@V?$xalloc@PAVIRenderable@@@@@std@@QBEIXZ ; std::vector<IRenderable *,xalloc<IRenderable *> >::capacity
PUBLIC	?_Umove_if_noexcept1@?$vector@PAVIRenderable@@V?$xalloc@PAVIRenderable@@@@@std@@AAEXPAPAVIRenderable@@00U?$integral_constant@_N$00@2@@Z ; std::vector<IRenderable *,xalloc<IRenderable *> >::_Umove_if_noexcept1
PUBLIC	?_Getal@?$vector@PAVIRenderable@@V?$xalloc@PAVIRenderable@@@@@std@@ABEABV?$xalloc@PAVIRenderable@@@@XZ ; std::vector<IRenderable *,xalloc<IRenderable *> >::_Getal
PUBLIC	??0?$xalloc@Urecv@CLightProjector@@@@QAE@XZ	; xalloc<CLightProjector::recv>::xalloc<CLightProjector::recv>
PUBLIC	?_Ufill@?$vector@Urecv@CLightProjector@@V?$xalloc@Urecv@CLightProjector@@@@@std@@AAEPAUrecv@CLightProjector@@PAU34@IU_Value_init_tag@2@@Z ; std::vector<CLightProjector::recv,xalloc<CLightProjector::recv> >::_Ufill
PUBLIC	?_Orphan_range@?$vector@Urecv@CLightProjector@@V?$xalloc@Urecv@CLightProjector@@@@@std@@ABEXPAUrecv@CLightProjector@@0@Z ; std::vector<CLightProjector::recv,xalloc<CLightProjector::recv> >::_Orphan_range
PUBLIC	??0?$_Vector_val@U?$_Simple_types@Urecv@CLightProjector@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<CLightProjector::recv> >::_Vector_val<std::_Simple_types<CLightProjector::recv> >
PUBLIC	??0?$xalloc@PAVIRenderable@@@@QAE@XZ		; xalloc<IRenderable *>::xalloc<IRenderable *>
PUBLIC	?allocate@?$xalloc@PAVIRenderable@@@@QBEPAPAVIRenderable@@IPBX@Z ; xalloc<IRenderable *>::allocate
PUBLIC	?construct@?$xalloc@PAVIRenderable@@@@QAEXPAPAVIRenderable@@ABQAV2@@Z ; xalloc<IRenderable *>::construct
PUBLIC	?max_size@?$vector@PAVIRenderable@@V?$xalloc@PAVIRenderable@@@@@std@@QBEIXZ ; std::vector<IRenderable *,xalloc<IRenderable *> >::max_size
PUBLIC	?_Umove@?$vector@PAVIRenderable@@V?$xalloc@PAVIRenderable@@@@@std@@AAEPAPAVIRenderable@@PAPAV3@00@Z ; std::vector<IRenderable *,xalloc<IRenderable *> >::_Umove
PUBLIC	?_Umove_if_noexcept@?$vector@PAVIRenderable@@V?$xalloc@PAVIRenderable@@@@@std@@AAEXPAPAVIRenderable@@00@Z ; std::vector<IRenderable *,xalloc<IRenderable *> >::_Umove_if_noexcept
PUBLIC	?_Calculate_growth@?$vector@PAVIRenderable@@V?$xalloc@PAVIRenderable@@@@@std@@ABEII@Z ; std::vector<IRenderable *,xalloc<IRenderable *> >::_Calculate_growth
PUBLIC	?_Change_array@?$vector@PAVIRenderable@@V?$xalloc@PAVIRenderable@@@@@std@@AAEXQAPAVIRenderable@@II@Z ; std::vector<IRenderable *,xalloc<IRenderable *> >::_Change_array
PUBLIC	?_Xlength@?$vector@PAVIRenderable@@V?$xalloc@PAVIRenderable@@@@@std@@CAXXZ ; std::vector<IRenderable *,xalloc<IRenderable *> >::_Xlength
PUBLIC	??0?$_Vector_val@U?$_Simple_types@PAVIRenderable@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<IRenderable *> >::_Vector_val<std::_Simple_types<IRenderable *> >
PUBLIC	??$xr_free@Urecv@CLightProjector@@@@YAXAAPAUrecv@CLightProjector@@@Z ; xr_free<CLightProjector::recv>
PUBLIC	??$_Destroy_range@V?$xalloc@Urecv@CLightProjector@@@@@std@@YAXPAUrecv@CLightProjector@@QAU12@AAV?$xalloc@Urecv@CLightProjector@@@@@Z ; std::_Destroy_range<xalloc<CLightProjector::recv> >
PUBLIC	??$xr_free@PAVIRenderable@@@@YAXAAPAPAVIRenderable@@@Z ; xr_free<IRenderable *>
PUBLIC	??$?0$$V@?$_Compressed_pair@V?$xalloc@Urecv@CLightProjector@@@@V?$_Vector_val@U?$_Simple_types@Urecv@CLightProjector@@@std@@@std@@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<xalloc<CLightProjector::recv>,std::_Vector_val<std::_Simple_types<CLightProjector::recv> >,1>::_Compressed_pair<xalloc<CLightProjector::recv>,std::_Vector_val<std::_Simple_types<CLightProjector::recv> >,1><>
PUBLIC	??$addressof@V?$_Vector_val@U?$_Simple_types@Urecv@CLightProjector@@@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@Urecv@CLightProjector@@@std@@@0@AAV10@@Z ; std::addressof<std::_Vector_val<std::_Simple_types<CLightProjector::recv> > >
PUBLIC	??$?0$$V@?$_Compressed_pair@V?$xalloc@PAVIRenderable@@@@V?$_Vector_val@U?$_Simple_types@PAVIRenderable@@@std@@@std@@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<xalloc<IRenderable *>,std::_Vector_val<std::_Simple_types<IRenderable *> >,1>::_Compressed_pair<xalloc<IRenderable *>,std::_Vector_val<std::_Simple_types<IRenderable *> >,1><>
PUBLIC	??$addressof@V?$_Vector_val@U?$_Simple_types@PAVIRenderable@@@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@PAVIRenderable@@@std@@@0@AAV10@@Z ; std::addressof<std::_Vector_val<std::_Simple_types<IRenderable *> > >
PUBLIC	??$_Resize@U_Value_init_tag@std@@@?$vector@Urecv@CLightProjector@@V?$xalloc@Urecv@CLightProjector@@@@@std@@AAEXIABU_Value_init_tag@1@@Z ; std::vector<CLightProjector::recv,xalloc<CLightProjector::recv> >::_Resize<std::_Value_init_tag>
PUBLIC	??$_Emplace_reallocate@ABQAVIRenderable@@@?$vector@PAVIRenderable@@V?$xalloc@PAVIRenderable@@@@@std@@QAEPAPAVIRenderable@@QAPAV2@ABQAV2@@Z ; std::vector<IRenderable *,xalloc<IRenderable *> >::_Emplace_reallocate<IRenderable * const &>
PUBLIC	??$construct@PAVIRenderable@@ABQAV1@@?$_Normal_allocator_traits@V?$xalloc@PAVIRenderable@@@@@std@@SAXAAV?$xalloc@PAVIRenderable@@@@PAPAVIRenderable@@ABQAV3@@Z ; std::_Normal_allocator_traits<xalloc<IRenderable *> >::construct<IRenderable *,IRenderable * const &>
PUBLIC	??$forward@ABQAVIRenderable@@@std@@YAABQAVIRenderable@@ABQAV1@@Z ; std::forward<IRenderable * const &>
PUBLIC	?_Verify_offset@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVIRenderable@@@std@@@std@@@std@@QBEXH@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<IRenderable *> > >::_Verify_offset
PUBLIC	?_Verify_offset@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@Urecv@CLightProjector@@@std@@@std@@@std@@QBEXH@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CLightProjector::recv> > >::_Verify_offset
PUBLIC	?_Get_first@?$_Compressed_pair@V?$xalloc@Urecv@CLightProjector@@@@V?$_Vector_val@U?$_Simple_types@Urecv@CLightProjector@@@std@@@std@@$00@std@@QAEAAV?$xalloc@Urecv@CLightProjector@@@@XZ ; std::_Compressed_pair<xalloc<CLightProjector::recv>,std::_Vector_val<std::_Simple_types<CLightProjector::recv> >,1>::_Get_first
PUBLIC	??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVIRenderable@@@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<IRenderable *> > >::operator+=
PUBLIC	??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@Urecv@CLightProjector@@@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CLightProjector::recv> > >::operator+=
PUBLIC	?sub@?$_vector3@M@@QAEAAU1@ABU1@@Z		; _vector3<float>::sub
PUBLIC	?deallocate@?$xalloc@Urecv@CLightProjector@@@@QBEXPAUrecv@CLightProjector@@I@Z ; xalloc<CLightProjector::recv>::deallocate
PUBLIC	?_Destroy@?$vector@Urecv@CLightProjector@@V?$xalloc@Urecv@CLightProjector@@@@@std@@AAEXPAUrecv@CLightProjector@@0@Z ; std::vector<CLightProjector::recv,xalloc<CLightProjector::recv> >::_Destroy
PUBLIC	?_Getal@?$vector@Urecv@CLightProjector@@V?$xalloc@Urecv@CLightProjector@@@@@std@@AAEAAV?$xalloc@Urecv@CLightProjector@@@@XZ ; std::vector<CLightProjector::recv,xalloc<CLightProjector::recv> >::_Getal
PUBLIC	?deallocate@?$xalloc@PAVIRenderable@@@@QBEXPAPAVIRenderable@@I@Z ; xalloc<IRenderable *>::deallocate
PUBLIC	??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVIRenderable@@@std@@@std@@@std@@QAE@PAPAVIRenderable@@PBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<IRenderable *> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<IRenderable *> > >
PUBLIC	??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVIRenderable@@@std@@@std@@@std@@QBEABQAVIRenderable@@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<IRenderable *> > >::operator*
PUBLIC	??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVIRenderable@@@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<IRenderable *> > >::operator+=
PUBLIC	??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@Urecv@CLightProjector@@@std@@@std@@@std@@QAE@PAUrecv@CLightProjector@@PBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CLightProjector::recv> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CLightProjector::recv> > >
PUBLIC	??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@Urecv@CLightProjector@@@std@@@std@@@std@@QBEABUrecv@CLightProjector@@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CLightProjector::recv> > >::operator*
PUBLIC	??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@Urecv@CLightProjector@@@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CLightProjector::recv> > >::operator+=
PUBLIC	??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@Urecv@CLightProjector@@@std@@@std@@@std@@QAE@PAUrecv@CLightProjector@@PBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CLightProjector::recv> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<CLightProjector::recv> > >
PUBLIC	??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVIRenderable@@@std@@@std@@@std@@QAE@PAPAVIRenderable@@PBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<IRenderable *> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<IRenderable *> > >
PUBLIC	?grow@?$_box3@M@@QAEAAV1@ABU?$_vector3@M@@@Z	; _box3<float>::grow
PUBLIC	?Resort@?$CRegistrator@VpureAppActivate@@@@QAEXXZ ; CRegistrator<pureAppActivate>::Resort
PUBLIC	??0?$vector@Urecv@CLightProjector@@V?$xalloc@Urecv@CLightProjector@@@@@std@@QAE@XZ ; std::vector<CLightProjector::recv,xalloc<CLightProjector::recv> >::vector<CLightProjector::recv,xalloc<CLightProjector::recv> >
PUBLIC	?begin@?$vector@Urecv@CLightProjector@@V?$xalloc@Urecv@CLightProjector@@@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@Urecv@CLightProjector@@@std@@@std@@@2@XZ ; std::vector<CLightProjector::recv,xalloc<CLightProjector::recv> >::begin
PUBLIC	?size@?$vector@Urecv@CLightProjector@@V?$xalloc@Urecv@CLightProjector@@@@@std@@QBEIXZ ; std::vector<CLightProjector::recv,xalloc<CLightProjector::recv> >::size
PUBLIC	?_Tidy@?$vector@Urecv@CLightProjector@@V?$xalloc@Urecv@CLightProjector@@@@@std@@AAEXXZ ; std::vector<CLightProjector::recv,xalloc<CLightProjector::recv> >::_Tidy
PUBLIC	??0?$vector@PAVIRenderable@@V?$xalloc@PAVIRenderable@@@@@std@@QAE@XZ ; std::vector<IRenderable *,xalloc<IRenderable *> >::vector<IRenderable *,xalloc<IRenderable *> >
PUBLIC	?begin@?$vector@PAVIRenderable@@V?$xalloc@PAVIRenderable@@@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVIRenderable@@@std@@@std@@@2@XZ ; std::vector<IRenderable *,xalloc<IRenderable *> >::begin
PUBLIC	?size@?$vector@PAVIRenderable@@V?$xalloc@PAVIRenderable@@@@@std@@QBEIXZ ; std::vector<IRenderable *,xalloc<IRenderable *> >::size
PUBLIC	?_Tidy@?$vector@PAVIRenderable@@V?$xalloc@PAVIRenderable@@@@@std@@AAEXXZ ; std::vector<IRenderable *,xalloc<IRenderable *> >::_Tidy
PUBLIC	?_Orphan_range@?$vector@PAVIRenderable@@V?$xalloc@PAVIRenderable@@@@@std@@ABEXPAPAVIRenderable@@0@Z ; std::vector<IRenderable *,xalloc<IRenderable *> >::_Orphan_range
PUBLIC	??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVIRenderable@@@std@@@std@@@std@@QBEAAPAVIRenderable@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<IRenderable *> > >::operator*
PUBLIC	??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVIRenderable@@@std@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<IRenderable *> > >::operator+
PUBLIC	??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@Urecv@CLightProjector@@@std@@@std@@@std@@QBEAAUrecv@CLightProjector@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CLightProjector::recv> > >::operator*
PUBLIC	??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@Urecv@CLightProjector@@@std@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CLightProjector::recv> > >::operator+
PUBLIC	?pop_back@?$vector@HV?$xalloc@H@@@std@@QAEXXZ	; std::vector<int,xalloc<int> >::pop_back
PUBLIC	?empty@?$vector@HV?$xalloc@H@@@std@@QBE_NXZ	; std::vector<int,xalloc<int> >::empty
PUBLIC	?back@?$vector@HV?$xalloc@H@@@std@@QAEAAHXZ	; std::vector<int,xalloc<int> >::back
PUBLIC	?mulA_44@?$_matrix@M@@QAEAAU1@ABU1@@Z		; _matrix<float>::mulA_44
PUBLIC	?translate@?$_matrix@M@@QAEAAU1@MMM@Z		; _matrix<float>::translate
PUBLIC	?contains@?$_box3@M@@QBEHABV1@@Z		; _box3<float>::contains
PUBLIC	?scale@?$_box3@M@@QAEAAV1@M@Z			; _box3<float>::scale
PUBLIC	?Add@?$CRegistrator@VpureAppActivate@@@@QAEXPAVpureAppActivate@@HI@Z ; CRegistrator<pureAppActivate>::Add
PUBLIC	?Remove@?$CRegistrator@VpureAppActivate@@@@QAEXPAVpureAppActivate@@@Z ; CRegistrator<pureAppActivate>::Remove
PUBLIC	??1?$vector@Urecv@CLightProjector@@V?$xalloc@Urecv@CLightProjector@@@@@std@@QAE@XZ ; std::vector<CLightProjector::recv,xalloc<CLightProjector::recv> >::~vector<CLightProjector::recv,xalloc<CLightProjector::recv> >
PUBLIC	?resize@?$vector@Urecv@CLightProjector@@V?$xalloc@Urecv@CLightProjector@@@@@std@@QAEXI@Z ; std::vector<CLightProjector::recv,xalloc<CLightProjector::recv> >::resize
PUBLIC	??0?$xr_vector@Urecv@CLightProjector@@V?$xalloc@Urecv@CLightProjector@@@@@@QAE@XZ ; xr_vector<CLightProjector::recv,xalloc<CLightProjector::recv> >::xr_vector<CLightProjector::recv,xalloc<CLightProjector::recv> >
PUBLIC	?size@?$xr_vector@Urecv@CLightProjector@@V?$xalloc@Urecv@CLightProjector@@@@@@QBEIXZ ; xr_vector<CLightProjector::recv,xalloc<CLightProjector::recv> >::size
PUBLIC	??A?$xr_vector@Urecv@CLightProjector@@V?$xalloc@Urecv@CLightProjector@@@@@@QAEAAUrecv@CLightProjector@@I@Z ; xr_vector<CLightProjector::recv,xalloc<CLightProjector::recv> >::operator[]
PUBLIC	??1?$vector@PAVIRenderable@@V?$xalloc@PAVIRenderable@@@@@std@@QAE@XZ ; std::vector<IRenderable *,xalloc<IRenderable *> >::~vector<IRenderable *,xalloc<IRenderable *> >
PUBLIC	??$_Emplace_back_with_unused_capacity@ABQAVIRenderable@@@?$vector@PAVIRenderable@@V?$xalloc@PAVIRenderable@@@@@std@@AAE?A_TABQAVIRenderable@@@Z ; std::vector<IRenderable *,xalloc<IRenderable *> >::_Emplace_back_with_unused_capacity<IRenderable * const &>
PUBLIC	??$emplace_back@ABQAVIRenderable@@@?$vector@PAVIRenderable@@V?$xalloc@PAVIRenderable@@@@@std@@QAE?A_TABQAVIRenderable@@@Z ; std::vector<IRenderable *,xalloc<IRenderable *> >::emplace_back<IRenderable * const &>
PUBLIC	?push_back@?$vector@PAVIRenderable@@V?$xalloc@PAVIRenderable@@@@@std@@QAEXABQAVIRenderable@@@Z ; std::vector<IRenderable *,xalloc<IRenderable *> >::push_back
PUBLIC	?empty@?$vector@PAVIRenderable@@V?$xalloc@PAVIRenderable@@@@@std@@QBE_NXZ ; std::vector<IRenderable *,xalloc<IRenderable *> >::empty
PUBLIC	??0?$xr_vector@PAVIRenderable@@V?$xalloc@PAVIRenderable@@@@@@QAE@XZ ; xr_vector<IRenderable *,xalloc<IRenderable *> >::xr_vector<IRenderable *,xalloc<IRenderable *> >
PUBLIC	?size@?$xr_vector@PAVIRenderable@@V?$xalloc@PAVIRenderable@@@@@@QBEIXZ ; xr_vector<IRenderable *,xalloc<IRenderable *> >::size
PUBLIC	??A?$xr_vector@PAVIRenderable@@V?$xalloc@PAVIRenderable@@@@@@QAEAAPAVIRenderable@@I@Z ; xr_vector<IRenderable *,xalloc<IRenderable *> >::operator[]
PUBLIC	?OnAppActivate@CLightProjector@@UAEXXZ		; CLightProjector::OnAppActivate
PUBLIC	??1?$xr_vector@PAVIRenderable@@V?$xalloc@PAVIRenderable@@@@@@QAE@XZ ; xr_vector<IRenderable *,xalloc<IRenderable *> >::~xr_vector<IRenderable *,xalloc<IRenderable *> >
PUBLIC	??1?$xr_vector@Urecv@CLightProjector@@V?$xalloc@Urecv@CLightProjector@@@@@@QAE@XZ ; xr_vector<CLightProjector::recv,xalloc<CLightProjector::recv> >::~xr_vector<CLightProjector::recv,xalloc<CLightProjector::recv> >
PUBLIC	?clipD@@YAMM@Z					; clipD
PUBLIC	?get_approximate@CROS_impl@@QAEAAU?$_vector3@M@@XZ ; CROS_impl::get_approximate
PUBLIC	??0CLightProjector@@QAE@XZ			; CLightProjector::CLightProjector
PUBLIC	??1CLightProjector@@QAE@XZ			; CLightProjector::~CLightProjector
PUBLIC	?invalidate@CLightProjector@@QAEXXZ		; CLightProjector::invalidate
PUBLIC	?set_object@CLightProjector@@QAEXPAVIRenderable@@@Z ; CLightProjector::set_object
PUBLIC	?setup@CLightProjector@@QAEXH@Z			; CLightProjector::setup
PUBLIC	?calculate@CLightProjector@@QAEXXZ		; CLightProjector::calculate
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$_Emplace_reallocate@ABQAVIRenderable@@@?$vector@PAVIRenderable@@V?$xalloc@PAVIRenderable@@@@@std@@QAEPAPAVIRenderable@@QAPAV2@ABQAV2@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Emplace_reallocate@ABQAVIRenderable@@@?$vector@PAVIRenderable@@V?$xalloc@PAVIRenderable@@@@@std@@QAEPAPAVIRenderable@@QAPAV2@ABQAV2@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Emplace_reallocate@ABQAVIRenderable@@@?$vector@PAVIRenderable@@V?$xalloc@PAVIRenderable@@@@@std@@QAEPAPAVIRenderable@@QAPAV2@ABQAV2@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
__unwindtable$??$_Emplace_reallocate@ABQAVIRenderable@@@?$vector@PAVIRenderable@@V?$xalloc@PAVIRenderable@@@@@std@@QAEPAPAVIRenderable@@QAPAV2@ABQAV2@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Emplace_reallocate@ABQAVIRenderable@@@?$vector@PAVIRenderable@@V?$xalloc@PAVIRenderable@@@@@std@@QAEPAPAVIRenderable@@QAPAV2@ABQAV2@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Emplace_reallocate@ABQAVIRenderable@@@?$vector@PAVIRenderable@@V?$xalloc@PAVIRenderable@@@@@std@@QAEPAPAVIRenderable@@QAPAV2@ABQAV2@@Z$2
__catchsym$??$_Emplace_reallocate@ABQAVIRenderable@@@?$vector@PAVIRenderable@@V?$xalloc@PAVIRenderable@@@@@std@@QAEPAPAVIRenderable@@QAPAV2@ABQAV2@@Z$2 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Emplace_reallocate@ABQAVIRenderable@@@?$vector@PAVIRenderable@@V?$xalloc@PAVIRenderable@@@@@std@@QAEPAPAVIRenderable@@QAPAV2@ABQAV2@@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@Urecv@CLightProjector@@V?$xalloc@Urecv@CLightProjector@@@@@std@@AAEXIABU_Value_init_tag@1@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@Urecv@CLightProjector@@V?$xalloc@Urecv@CLightProjector@@@@@std@@AAEXIABU_Value_init_tag@1@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@Urecv@CLightProjector@@V?$xalloc@Urecv@CLightProjector@@@@@std@@AAEXIABU_Value_init_tag@1@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
__unwindtable$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@Urecv@CLightProjector@@V?$xalloc@Urecv@CLightProjector@@@@@std@@AAEXIABU_Value_init_tag@1@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@Urecv@CLightProjector@@V?$xalloc@Urecv@CLightProjector@@@@@std@@AAEXIABU_Value_init_tag@1@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@Urecv@CLightProjector@@V?$xalloc@Urecv@CLightProjector@@@@@std@@AAEXIABU_Value_init_tag@1@@Z$2
__catchsym$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@Urecv@CLightProjector@@V?$xalloc@Urecv@CLightProjector@@@@@std@@AAEXIABU_Value_init_tag@1@@Z$2 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@Urecv@CLightProjector@@V?$xalloc@Urecv@CLightProjector@@@@@std@@AAEXIABU_Value_init_tag@1@@Z$0
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightProjector.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightProjector.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightProjector.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightProjector.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightProjector.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightProjector.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightProjector.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightProjector.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightProjector.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightProjector.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightProjector.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\FTimer.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightProjector.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\FTimer.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightProjector.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightProjector.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightProjector.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightProjector.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightProjector.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightProjector.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightProjector.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightProjector.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_random.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightProjector.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_random.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightProjector.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightProjector.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightProjector.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightProjector.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightProjector.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightProjector.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightProjector.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\lighttrack.h
; File I:\Vitalya\mine\NSProjectX\xrCore\vector.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\LightTrack.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\vector.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\LightTrack.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightProjector.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_color.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightProjector.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\vector.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightProjector.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_color.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightProjector.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h
; File I:\Vitalya\mine\NSProjectX\xrCore\vector.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_color.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h
; File I:\Vitalya\mine\NSProjectX\xrCore\vector.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_color.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h
; File I:\Vitalya\mine\NSProjectX\xrCore\vector.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_color.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h
; File I:\Vitalya\mine\NSProjectX\xrCore\vector.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightProjector.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_color.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightProjector.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_color.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightProjector.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_color.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightProjector.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightProjector.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightProjector.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightProjector.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightProjector.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightProjector.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightProjector.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightProjector.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightProjector.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightProjector.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightProjector.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightProjector.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightProjector.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightProjector.cpp
; File I:\Vitalya\mine\NSProjectX\xrEngine\ispatial.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightProjector.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightProjector.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightProjector.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\FTimer.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightProjector.cpp
_TEXT	SEGMENT
tv6681 = -528						; size = 4
tv6413 = -528						; size = 4
tv6353 = -528						; size = 4
tv6228 = -528						; size = 4
_a$3 = -528						; size = 4
_a$4 = -528						; size = 4
_a$5 = -528						; size = 4
_a$6 = -528						; size = 4
$T7 = -528						; size = 4
_mProject$2$ = -524					; size = 4
$T8 = -524						; size = 4
_vz$1$ = -524						; size = 4
tv6355 = -524						; size = 4
_mView$12$ = -520					; size = 4
_vz$3$ = -520						; size = 4
__b$1$ = -520						; size = 4
_mView$16$ = -516					; size = 4
__r$1$ = -516						; size = 4
tv6767 = -516						; size = 4
_mView$8$ = -512					; size = 4
__g$1$ = -512						; size = 4
_mView$4$ = -508					; size = 4
_mView$1$ = -508					; size = 4
tv6433 = -508						; size = 4
tv6278 = -508						; size = 4
_c_it$1$ = -504						; size = 4
tv6766 = -504						; size = 4
_vz$9 = -500						; size = 12
_vy$10 = -500						; size = 12
_vx$11 = -488						; size = 12
_vz$12 = -488						; size = 12
_vy$13 = -476						; size = 12
_vx$14 = -476						; size = 12
_mProject$15 = -464					; size = 64
_this$1$ = -400						; size = 4
tv6967 = -396						; size = 4
_mTemp$16 = -392					; size = 64
tv6677 = -328						; size = 4
tv6847 = -324						; size = 4
tv6676 = -320						; size = 4
tv6850 = -316						; size = 4
tv6680 = -312						; size = 4
tv6855 = -308						; size = 4
tv6679 = -304						; size = 4
tv6854 = -300						; size = 4
tv6682 = -296						; size = 4
tv6858 = -292						; size = 4
tv6860 = -288						; size = 4
tv6686 = -284						; size = 4
tv6861 = -280						; size = 4
tv6685 = -276						; size = 4
tv6863 = -272						; size = 4
tv6870 = -268						; size = 4
tv6869 = -264						; size = 4
tv6688 = -260						; size = 4
tv6868 = -256						; size = 4
tv6691 = -252						; size = 4
tv6871 = -248						; size = 4
tv6690 = -244						; size = 4
tv6874 = -240						; size = 4
tv6694 = -236						; size = 4
tv6877 = -232						; size = 4
tv6693 = -228						; size = 4
tv6875 = -224						; size = 4
tv6697 = -220						; size = 4
tv6883 = -216						; size = 4
tv6696 = -212						; size = 4
tv6882 = -208						; size = 4
tv6699 = -204						; size = 4
tv6888 = -200						; size = 4
tv6678 = -196						; size = 4
tv6918 = -192						; size = 4
tv6917 = -188						; size = 4
_p_R$1$ = -184						; size = 4
_O$1$ = -180						; size = 4
tv6966 = -176						; size = 4
tv6674 = -172						; size = 4
tv6843 = -168						; size = 4
tv6889 = -164						; size = 4
tv6673 = -160						; size = 4
tv6844 = -156						; size = 4
_mView$17 = -152					; size = 64
_v_C$18 = -84						; size = 12
_v_N$19 = -72						; size = 12
_v_Cs$20 = -60						; size = 12
_VP$21 = -48						; size = 24
_BB$22 = -24						; size = 24
?calculate@CLightProjector@@QAEXXZ PROC			; CLightProjector::calculate
; _this$ = ecx

; 122  : {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	sub	esp, 528				; 00000210H
	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	ebp, ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1531 :         return _My_data._Myfirst == _My_data._Mylast;

	mov	ecx, DWORD PTR [ebp+20]
	mov	eax, DWORD PTR [ebp+24]
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightProjector.cpp

; 122  : {

	mov	DWORD PTR _this$1$[esp+544], ebp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1531 :         return _My_data._Myfirst == _My_data._Mylast;

	cmp	ecx, eax
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightProjector.cpp

; 123  : 	if (receivers.empty())		return;

	je	$LN1@calculate
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	sub	eax, ecx
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightProjector.cpp

; 126  : 	for (u32 r_it=0; r_it<receivers.size(); r_it++)

	xor	edi, edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	sar	eax, 2
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightProjector.cpp

; 126  : 	for (u32 r_it=0; r_it<receivers.size(); r_it++)

	test	eax, eax
	mov	eax, DWORD PTR __imp_?renderable_ROS@IRenderable@@QAEPAVIRender_ObjectSpecific@@XZ
	mov	DWORD PTR tv6967[esp+544], eax
	je	$LN3@calculate
$LL4@calculate:

; 127  : 	{
; 128  : 		// validate
; 129  : 		BOOL				bValid	= TRUE;
; 130  : 		IRenderable*		O		= receivers[r_it];

	mov	esi, DWORD PTR [ecx+edi*4]

; 131  : 		CROS_impl*			LT		= (CROS_impl*)O->renderable_ROS();

	mov	ecx, esi
	call	eax

; 132  : 		int					slot	= LT->shadow_recv_slot;

	mov	eax, DWORD PTR [eax+1928]

; 133  : 		if (slot<0 || slot>=P_o_count)								bValid = FALSE;	// invalid slot

	cmp	eax, 99					; 00000063H
	ja	$LN29@calculate

; 134  : 		else if (cache[slot].O!=O)									bValid = FALSE;	// not the same object

	mov	edx, DWORD PTR [ebp+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 119  :         _Ptr += _Off;

	imul	ecx, eax, 136
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightProjector.cpp

; 134  : 		else if (cache[slot].O!=O)									bValid = FALSE;	// not the same object

	cmp	DWORD PTR [ecx+edx], esi
	jne	$LN29@calculate

; 135  : 		else {
; 136  : 			// seems to be valid
; 137  : 			Fbox	bb;		bb.xform		(O->renderable.visual->vis.box,O->renderable.xform);

	mov	eax, DWORD PTR [esi+68]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 42   : 	ICF SelfRef	mul(const Self &a, T s)					{ x=a.x*s;  y=a.y*s;	z=a.z*s;		return *this;	};

	movss	xmm1, DWORD PTR [esi+4]
	movss	xmm7, DWORD PTR [esi+20]
	movaps	xmm2, xmm7
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h

; 64   : 		vx.mul				(m.i, B.max.x-B.min.x);	

	movss	xmm6, DWORD PTR [eax+24]
	movss	xmm0, DWORD PTR [eax+36]
	subss	xmm0, xmm6
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 499  : 		dest.x = v.x*_11 + v.y*_21 + v.z*_31 + _41;

	mulss	xmm7, DWORD PTR [eax+28]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 42   : 	ICF SelfRef	mul(const Self &a, T s)					{ x=a.x*s;  y=a.y*s;	z=a.z*s;		return *this;	};

	mulss	xmm1, xmm0
	movss	DWORD PTR _vx$14[esp+544], xmm1
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h

; 25   : 	IC BOOL negative(const float &f)	{ return (*((unsigned*)(&f))&fdSGN);	}

	test	DWORD PTR _vx$14[esp+544], -2147483648	; 80000000H
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 42   : 	ICF SelfRef	mul(const Self &a, T s)					{ x=a.x*s;  y=a.y*s;	z=a.z*s;		return *this;	};

	movss	DWORD PTR tv6228[esp+544], xmm1
	movss	xmm1, DWORD PTR [esi+8]
	mulss	xmm1, xmm0
	movss	DWORD PTR tv6766[esp+544], xmm1
	movss	DWORD PTR _vx$14[esp+548], xmm1
	movss	xmm1, DWORD PTR [esi+12]
	mulss	xmm1, xmm0
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 499  : 		dest.x = v.x*_11 + v.y*_21 + v.z*_31 + _41;

	movaps	xmm0, xmm6
	mulss	xmm0, DWORD PTR [esi+4]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 42   : 	ICF SelfRef	mul(const Self &a, T s)					{ x=a.x*s;  y=a.y*s;	z=a.z*s;		return *this;	};

	movss	DWORD PTR tv6767[esp+544], xmm1
	movss	DWORD PTR _vx$14[esp+552], xmm1
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h

; 65   : 		vy.mul				(m.j, B.max.y-B.min.y);	

	movss	xmm1, DWORD PTR [eax+40]
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 499  : 		dest.x = v.x*_11 + v.y*_21 + v.z*_31 + _41;

	addss	xmm7, xmm0
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h

; 65   : 		vy.mul				(m.j, B.max.y-B.min.y);	

	subss	xmm1, DWORD PTR [eax+28]
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 500  : 		dest.y = v.x*_12 + v.y*_22 + v.z*_32 + _42;

	movaps	xmm0, xmm6

; 501  : 		dest.z = v.x*_13 + v.y*_23 + v.z*_33 + _43;

	mulss	xmm6, DWORD PTR [esi+12]
	mulss	xmm0, DWORD PTR [esi+8]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 42   : 	ICF SelfRef	mul(const Self &a, T s)					{ x=a.x*s;  y=a.y*s;	z=a.z*s;		return *this;	};

	mulss	xmm2, xmm1
	movss	DWORD PTR tv6278[esp+544], xmm2
	movss	DWORD PTR _vy$10[esp+544], xmm2
	movaps	xmm2, xmm1
	mulss	xmm1, DWORD PTR [esi+28]
	mulss	xmm2, DWORD PTR [esi+24]
	movss	DWORD PTR _vy$10[esp+552], xmm1
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h

; 66   : 		vz.mul				(m.k, B.max.z-B.min.z);	

	movss	xmm1, DWORD PTR [eax+44]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 42   : 	ICF SelfRef	mul(const Self &a, T s)					{ x=a.x*s;  y=a.y*s;	z=a.z*s;		return *this;	};

	movss	DWORD PTR _vy$10[esp+548], xmm2
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h

; 66   : 		vz.mul				(m.k, B.max.z-B.min.z);	

	movss	xmm2, DWORD PTR [eax+32]
	subss	xmm1, xmm2
	movss	DWORD PTR _vz$3$[esp+544], xmm1
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 42   : 	ICF SelfRef	mul(const Self &a, T s)					{ x=a.x*s;  y=a.y*s;	z=a.z*s;		return *this;	};

	movss	xmm1, DWORD PTR [esi+36]
	movss	xmm5, DWORD PTR _vz$3$[esp+544]
	movaps	xmm4, xmm1
	movss	DWORD PTR _vz$1$[esp+544], xmm1
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 499  : 		dest.x = v.x*_11 + v.y*_21 + v.z*_31 + _41;

	mulss	xmm1, xmm2
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 42   : 	ICF SelfRef	mul(const Self &a, T s)					{ x=a.x*s;  y=a.y*s;	z=a.z*s;		return *this;	};

	mulss	xmm4, xmm5
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 499  : 		dest.x = v.x*_11 + v.y*_21 + v.z*_31 + _41;

	addss	xmm1, DWORD PTR [esi+52]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 42   : 	ICF SelfRef	mul(const Self &a, T s)					{ x=a.x*s;  y=a.y*s;	z=a.z*s;		return *this;	};

	movss	DWORD PTR _vz$1$[esp+544], xmm4
	movss	DWORD PTR _vz$12[esp+544], xmm4
	movaps	xmm4, xmm5
	mulss	xmm5, DWORD PTR [esi+44]
	mulss	xmm4, DWORD PTR [esi+40]
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 499  : 		dest.x = v.x*_11 + v.y*_21 + v.z*_31 + _41;

	addss	xmm7, xmm1

; 500  : 		dest.y = v.x*_12 + v.y*_22 + v.z*_32 + _42;

	movss	xmm1, DWORD PTR [eax+28]
	movaps	xmm3, xmm1
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 42   : 	ICF SelfRef	mul(const Self &a, T s)					{ x=a.x*s;  y=a.y*s;	z=a.z*s;		return *this;	};

	movss	DWORD PTR _vz$3$[esp+544], xmm5
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 500  : 		dest.y = v.x*_12 + v.y*_22 + v.z*_32 + _42;

	mulss	xmm3, DWORD PTR [esi+24]

; 501  : 		dest.z = v.x*_13 + v.y*_23 + v.z*_33 + _43;

	mulss	xmm1, DWORD PTR [esi+28]
	addss	xmm3, xmm0
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 42   : 	ICF SelfRef	mul(const Self &a, T s)					{ x=a.x*s;  y=a.y*s;	z=a.z*s;		return *this;	};

	movss	DWORD PTR _vz$12[esp+548], xmm4
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 500  : 		dest.y = v.x*_12 + v.y*_22 + v.z*_32 + _42;

	movaps	xmm0, xmm2
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 42   : 	ICF SelfRef	mul(const Self &a, T s)					{ x=a.x*s;  y=a.y*s;	z=a.z*s;		return *this;	};

	movss	DWORD PTR _vz$12[esp+552], xmm5
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 501  : 		dest.z = v.x*_13 + v.y*_23 + v.z*_33 + _43;

	mulss	xmm2, DWORD PTR [esi+44]
	addss	xmm1, xmm6
	mulss	xmm0, DWORD PTR [esi+40]
	addss	xmm2, DWORD PTR [esi+60]
	addss	xmm0, DWORD PTR [esi+56]
	addss	xmm1, xmm2
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 24   : 	ICF SelfRef	set(const _vector3<float> &v)			{ x = T(v.x);	y = T(v.y);	z = T(v.z);	return *this;	};

	movaps	xmm2, xmm7
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 500  : 		dest.y = v.x*_12 + v.y*_22 + v.z*_32 + _42;

	addss	xmm3, xmm0

; 501  : 		dest.z = v.x*_13 + v.y*_23 + v.z*_33 + _43;

	movaps	xmm5, xmm1
	movaps	xmm4, xmm3
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h

; 74   : 		if(negative(vx.x))	min.x += vx.x; else max.x += vx.x;

	je	SHORT $LN79@calculate
	addss	xmm7, DWORD PTR tv6228[esp+544]
	jmp	SHORT $LN80@calculate
$LN79@calculate:
	movaps	xmm2, xmm7
	addss	xmm2, DWORD PTR tv6228[esp+544]
$LN80@calculate:
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h

; 25   : 	IC BOOL negative(const float &f)	{ return (*((unsigned*)(&f))&fdSGN);	}

	test	DWORD PTR _vx$14[esp+548], -2147483648	; 80000000H
	movss	xmm0, DWORD PTR tv6766[esp+544]
	addss	xmm0, xmm3
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h

; 75   : 		if(negative(vx.y))	min.y += vx.y; else max.y += vx.y;

	je	SHORT $LN81@calculate
	movaps	xmm4, xmm0
	jmp	SHORT $LN82@calculate
$LN81@calculate:
	movaps	xmm3, xmm0
$LN82@calculate:
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h

; 25   : 	IC BOOL negative(const float &f)	{ return (*((unsigned*)(&f))&fdSGN);	}

	test	DWORD PTR _vx$14[esp+552], -2147483648	; 80000000H
	movss	xmm0, DWORD PTR tv6767[esp+544]
	addss	xmm0, xmm1
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h

; 76   : 		if(negative(vx.z))	min.z += vx.z; else max.z += vx.z;

	je	SHORT $LN83@calculate
	movaps	xmm5, xmm0
	jmp	SHORT $LN84@calculate
$LN83@calculate:
	movaps	xmm1, xmm0
$LN84@calculate:
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h

; 25   : 	IC BOOL negative(const float &f)	{ return (*((unsigned*)(&f))&fdSGN);	}

	test	DWORD PTR _vy$10[esp+544], -2147483648	; 80000000H
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h

; 77   : 		if(negative(vy.x))	min.x += vy.x; else max.x += vy.x;

	je	SHORT $LN85@calculate
	addss	xmm7, DWORD PTR tv6278[esp+544]
	jmp	SHORT $LN86@calculate
$LN85@calculate:
	addss	xmm2, DWORD PTR tv6278[esp+544]
$LN86@calculate:
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h

; 25   : 	IC BOOL negative(const float &f)	{ return (*((unsigned*)(&f))&fdSGN);	}

	test	DWORD PTR _vy$10[esp+548], -2147483648	; 80000000H
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h

; 78   : 		if(negative(vy.y))	min.y += vy.y; else max.y += vy.y;

	je	SHORT $LN87@calculate
	addss	xmm4, DWORD PTR _vy$10[esp+548]
	jmp	SHORT $LN88@calculate
$LN87@calculate:
	addss	xmm3, DWORD PTR _vy$10[esp+548]
$LN88@calculate:
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h

; 25   : 	IC BOOL negative(const float &f)	{ return (*((unsigned*)(&f))&fdSGN);	}

	test	DWORD PTR _vy$10[esp+552], -2147483648	; 80000000H
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h

; 79   : 		if(negative(vy.z))	min.z += vy.z; else max.z += vy.z;

	je	SHORT $LN89@calculate
	addss	xmm5, DWORD PTR _vy$10[esp+552]
	jmp	SHORT $LN90@calculate
$LN89@calculate:
	addss	xmm1, DWORD PTR _vy$10[esp+552]
$LN90@calculate:
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h

; 25   : 	IC BOOL negative(const float &f)	{ return (*((unsigned*)(&f))&fdSGN);	}

	test	DWORD PTR _vz$12[esp+544], -2147483648	; 80000000H
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h

; 80   : 		if(negative(vz.x))	min.x += vz.x; else max.x += vz.x;

	je	SHORT $LN91@calculate
	addss	xmm7, DWORD PTR _vz$1$[esp+544]
	jmp	SHORT $LN92@calculate
$LN91@calculate:
	addss	xmm2, DWORD PTR _vz$1$[esp+544]
$LN92@calculate:
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h

; 25   : 	IC BOOL negative(const float &f)	{ return (*((unsigned*)(&f))&fdSGN);	}

	test	DWORD PTR _vz$12[esp+548], -2147483648	; 80000000H
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h

; 81   : 		if(negative(vz.y))	min.y += vz.y; else max.y += vz.y;

	je	SHORT $LN93@calculate
	addss	xmm4, DWORD PTR _vz$12[esp+548]
	jmp	SHORT $LN94@calculate
$LN93@calculate:
	addss	xmm3, DWORD PTR _vz$12[esp+548]
$LN94@calculate:
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h

; 25   : 	IC BOOL negative(const float &f)	{ return (*((unsigned*)(&f))&fdSGN);	}

	test	DWORD PTR _vz$12[esp+552], -2147483648	; 80000000H
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h

; 82   : 		if(negative(vz.z))	min.z += vz.z; else max.z += vz.z;

	je	SHORT $LN95@calculate
	addss	xmm5, DWORD PTR _vz$3$[esp+544]
	jmp	SHORT $LN129@calculate
$LN95@calculate:
	addss	xmm1, DWORD PTR _vz$3$[esp+544]
$LN129@calculate:

; 49   : 	ICF	BOOL	contains	(T x, T y, T z)		const		{ return (x>=x1) && (x<=x2) && (y>=y1) && (y<=y2) && (z>=z1) && (z<=z2); };

	comiss	xmm7, DWORD PTR [ecx+edx+104]
	jb	$LN29@calculate
	movss	xmm0, DWORD PTR [ecx+edx+116]
	comiss	xmm0, xmm7
	jb	SHORT $LN29@calculate
	movss	xmm6, DWORD PTR [ecx+edx+108]
	comiss	xmm4, xmm6
	jb	SHORT $LN29@calculate
	movss	xmm7, DWORD PTR [ecx+edx+120]
	comiss	xmm7, xmm4
	jb	SHORT $LN29@calculate
	movss	xmm4, DWORD PTR [ecx+edx+112]
	comiss	xmm5, xmm4
	jb	SHORT $LN29@calculate
	movss	xmm0, DWORD PTR [ecx+edx+124]
	comiss	xmm0, xmm5
	jb	SHORT $LN29@calculate
	comiss	xmm2, DWORD PTR [ecx+edx+104]
	jb	SHORT $LN29@calculate
	movss	xmm5, DWORD PTR [ecx+edx+116]
	comiss	xmm5, xmm2
	jb	SHORT $LN29@calculate
	comiss	xmm3, xmm6
	jb	SHORT $LN29@calculate
	comiss	xmm7, xmm3
	jb	SHORT $LN29@calculate
	comiss	xmm1, xmm4
	jb	SHORT $LN29@calculate
	comiss	xmm0, xmm1
	jb	SHORT $LN29@calculate
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightProjector.cpp

; 145  : 		if (bValid)			{

	mov	esi, DWORD PTR __imp_?Device@@3VCRenderDevice@@A
	mov	eax, DWORD PTR [esi+480]
	cmp	eax, DWORD PTR [ecx+edx+132]
	ja	SHORT $LN29@calculate

; 146  : 			// Ok, use cached version
; 147  : 			cache[slot].dwFrame	= Device.dwFrame;

	mov	eax, DWORD PTR [esi+244]
	mov	DWORD PTR [ecx+edx+128], eax

; 148  : 		} else {

	jmp	SHORT $LN2@calculate
$LN29@calculate:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 730  :         if (_Mylast != _My_data._Myend) {

	mov	eax, DWORD PTR [ebp+36]
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightProjector.cpp

; 149  : 			taskid.push_back	(r_it);

	lea	ecx, DWORD PTR [ebp+32]
	mov	DWORD PTR $T7[esp+544], edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 730  :         if (_Mylast != _My_data._Myend) {

	cmp	eax, DWORD PTR [ecx+8]
	je	SHORT $LN196@calculate

; 713  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

	mov	DWORD PTR [eax], edi

; 714  :         _Orphan_range(_Mylast, _Mylast);
; 715  :         _Ty& _Result = *_Mylast;
; 716  :         ++_Mylast;

	add	DWORD PTR [ecx+4], 4

; 731  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

	jmp	SHORT $LN2@calculate
$LN196@calculate:

; 732  :         }
; 733  : 
; 734  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	lea	edx, DWORD PTR $T7[esp+544]
	push	edx
	push	eax
	call	??$_Emplace_reallocate@H@?$vector@HV?$xalloc@H@@@std@@QAEPAHQAH$$QAH@Z ; std::vector<int,xalloc<int> >::_Emplace_reallocate<int>
$LN2@calculate:

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	eax, DWORD PTR [ebp+24]
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightProjector.cpp

; 126  : 	for (u32 r_it=0; r_it<receivers.size(); r_it++)

	inc	edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	ecx, DWORD PTR [ebp+20]
	sub	eax, ecx
	sar	eax, 2
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightProjector.cpp

; 126  : 	for (u32 r_it=0; r_it<receivers.size(); r_it++)

	cmp	edi, eax
	mov	eax, DWORD PTR tv6967[esp+544]
	jb	$LL4@calculate
$LN3@calculate:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1531 :         return _My_data._Myfirst == _My_data._Mylast;

	mov	eax, DWORD PTR [ebp+32]
	cmp	eax, DWORD PTR [ebp+36]
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightProjector.cpp

; 152  : 	if (taskid.empty())			return;

	je	$LN1@calculate

; 155  : 	Device.Statistic->RenderDUMP_Pcalc.Begin	();

	mov	eax, DWORD PTR __imp_?Device@@3VCRenderDevice@@A
	mov	esi, DWORD PTR [eax+436]
; File I:\Vitalya\mine\NSProjectX\xrCore\FTimer.h

; 173  : 	ICF void	Begin			()		{	if (!g_bEnableStatGather) return;	count++; T.Start();				}

	mov	eax, DWORD PTR __imp_?g_bEnableStatGather@@3HA
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightProjector.cpp

; 155  : 	Device.Statistic->RenderDUMP_Pcalc.Begin	();

	add	esi, 2496				; 000009c0H
; File I:\Vitalya\mine\NSProjectX\xrCore\FTimer.h

; 173  : 	ICF void	Begin			()		{	if (!g_bEnableStatGather) return;	count++; T.Start();				}

	cmp	DWORD PTR [eax], 0
	je	SHORT $LN205@calculate
	inc	DWORD PTR [esi+68]

; 73   : 		if (bPause)

	cmp	DWORD PTR [esi+24], 0
	jne	SHORT $LN205@calculate

; 29   : 	ICF	void	Start			()		{	if(bPause) return;	qwStartTime = CPU::QPC()-qwPauseAccum;		}

	call	DWORD PTR __imp_?QPC@CPU@@YA_KXZ
	sub	eax, DWORD PTR [esi+16]
	mov	DWORD PTR [esi], eax
	sbb	edx, DWORD PTR [esi+20]
	mov	DWORD PTR [esi+4], edx

; 78   : 		m_real_ticks	= 0;

	mov	DWORD PTR [esi+40], 0
	mov	DWORD PTR [esi+44], 0

; 79   : 		m_ticks			= 0;

	mov	DWORD PTR [esi+48], 0
	mov	DWORD PTR [esi+52], 0
$LN205@calculate:
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightProjector.cpp

; 156  : 	RCache.set_RT				(RT->pRT);

	mov	eax, DWORD PTR [ebp+44]
	mov	ecx, DWORD PTR __imp_?RCache@@3VCBackend@@A
	push	0
	push	DWORD PTR [eax+16]
	call	DWORD PTR __imp_?set_RT@CBackend@@QAEXPAUIDirect3DSurface9@@I@Z

; 157  : 	RCache.set_ZB				(RImplementation.Target->pTempZB);

	mov	eax, DWORD PTR ?RImplementation@@3VCRender@@A+1012
	mov	ecx, DWORD PTR __imp_?RCache@@3VCBackend@@A
	push	DWORD PTR [eax+104]
	call	DWORD PTR __imp_?set_ZB@CBackend@@QAEXPAUIDirect3DSurface9@@@Z

; 158  : 	CHK_DX(HW.pDevice->Clear	(0,0, D3DCLEAR_ZBUFFER | (HW.Caps.bStencil?D3DCLEAR_STENCIL:0), 0,1,0 ));

	mov	ecx, DWORD PTR __imp_?HW@@3VCHW@@A
	xor	eax, eax
	fld1
	push	0
	push	ecx
	cmp	DWORD PTR [ecx+80], eax
	mov	edx, DWORD PTR [ecx+8]
	fstp	DWORD PTR [esp]
	setne	al
	push	0
	mov	esi, DWORD PTR [edx]
	lea	eax, DWORD PTR [eax*4+2]
	push	eax
	push	0
	push	0
	push	edx
	call	DWORD PTR [esi+172]

; 159  : 	RCache.set_xform_world		(Fidentity);

	push	DWORD PTR __imp_?Fidentity@@3U?$_matrix@M@@A
	mov	ecx, DWORD PTR __imp_?RCache@@3VCBackend@@A
	call	DWORD PTR __imp_?set_xform_world@CBackend@@QAEXABU?$_matrix@M@@@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	esi, DWORD PTR [ebp+8]
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightProjector.cpp

; 162  : 	for (u32 c_it=0; c_it<cache.size(); c_it++)

	xor	ecx, ecx
	mov	DWORD PTR _c_it$1$[esp+544], ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	eax, 2021161081				; 78787879H
	mov	ecx, DWORD PTR [ebp+12]
	sub	ecx, esi
	imul	ecx
	sar	edx, 6
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightProjector.cpp

; 162  : 	for (u32 c_it=0; c_it<cache.size(); c_it++)

	je	$LN500@calculate
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1530 :         auto& _My_data = _Mypair._Myval2;

	mov	eax, DWORD PTR __imp_?spatial_updatesector_internal@ISpatial@@QAEXXZ
	xor	edi, edi
	mov	ebx, esi
	mov	DWORD PTR tv6966[esp+544], eax
$LL7@calculate:

; 1531 :         return _My_data._Myfirst == _My_data._Mylast;

	mov	eax, DWORD PTR [ebp+32]
	cmp	eax, DWORD PTR [ebp+36]
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightProjector.cpp

; 164  : 		if (taskid.empty())							break;

	je	$LN500@calculate

; 165  : 		if (Device.dwFrame==cache[c_it].dwFrame)	continue;

	mov	eax, DWORD PTR __imp_?Device@@3VCRenderDevice@@A
	mov	eax, DWORD PTR [eax+244]
	cmp	eax, DWORD PTR [esi+edi+128]
	je	$LN5@calculate
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1611 :         return _My_data._Mylast[-1];

	mov	eax, DWORD PTR [ebp+36]
	add	eax, -4					; fffffffcH
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightProjector.cpp

; 168  : 		int				tid		= taskid.back();	taskid.pop_back();

	mov	ecx, DWORD PTR [eax]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1390 :         --_Mylast;

	mov	DWORD PTR [ebp+36], eax
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightProjector.cpp

; 170  : 		IRenderable*	O		= receivers	[tid];

	mov	eax, DWORD PTR [ebp+20]
	mov	ebp, DWORD PTR [eax+ecx*4]

; 171  : 		CROS_impl*	LT		= (CROS_impl*)O->renderable_ROS();

	mov	ecx, ebp
	mov	DWORD PTR _O$1$[esp+544], ebp
	call	DWORD PTR tv6967[esp+544]

; 172  : 		VERIFY2			(_valid(O->renderable.xform),"Invalid object transformation");
; 173  : 		VERIFY2			(_valid(O->renderable.visual->vis.sphere.P),"Invalid object's visual sphere");
; 174  : 
; 175  : 		Fvector			C;		O->renderable.xform.transform_tiny		(C,O->renderable.visual->vis.sphere.P);

	mov	ecx, DWORD PTR [ebp+68]
	mov	esi, eax
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 499  : 		dest.x = v.x*_11 + v.y*_21 + v.z*_31 + _41;

	movss	xmm2, DWORD PTR [ebp+4]
	movss	xmm7, DWORD PTR [ebp+20]
	movss	xmm4, DWORD PTR [ebp+36]
	movss	xmm1, DWORD PTR [ecx+8]
	movss	xmm0, DWORD PTR [ecx+12]

; 500  : 		dest.y = v.x*_12 + v.y*_22 + v.z*_32 + _42;

	movaps	xmm5, xmm1
	mulss	xmm5, DWORD PTR [ebp+8]
	movss	xmm6, DWORD PTR [ecx+16]
	movss	DWORD PTR tv6353[esp+544], xmm0
	mulss	xmm0, DWORD PTR [ebp+24]
	movss	DWORD PTR tv6355[esp+544], xmm1

; 501  : 		dest.z = v.x*_13 + v.y*_23 + v.z*_33 + _43;

	mulss	xmm1, DWORD PTR [ebp+12]
	addss	xmm5, xmm0
	movss	xmm3, DWORD PTR [ebp+52]
	movaps	xmm0, xmm6
	mulss	xmm0, DWORD PTR [ebp+40]
	addss	xmm0, DWORD PTR [ebp+56]
	addss	xmm5, xmm0
	movss	xmm0, DWORD PTR tv6353[esp+544]
	mulss	xmm0, DWORD PTR [ebp+28]
	addss	xmm1, xmm0
	movaps	xmm0, xmm6
	mulss	xmm0, DWORD PTR [ebp+44]
	mulss	xmm6, xmm4
	addss	xmm0, DWORD PTR [ebp+60]
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightProjector.cpp

; 176  : 		R.O						= O;

	mov	DWORD PTR [ebx+edi], ebp
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 499  : 		dest.x = v.x*_11 + v.y*_21 + v.z*_31 + _41;

	addss	xmm6, xmm3

; 501  : 		dest.z = v.x*_13 + v.y*_23 + v.z*_33 + _43;

	addss	xmm1, xmm0
	movss	xmm0, DWORD PTR tv6355[esp+544]
	mulss	xmm0, xmm2
	movss	DWORD PTR tv6355[esp+544], xmm0
	movss	xmm0, DWORD PTR tv6353[esp+544]
	movss	xmm2, DWORD PTR tv6355[esp+544]
	mulss	xmm0, xmm7
	addss	xmm2, xmm0
	addss	xmm2, xmm6
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightProjector.cpp

; 177  : 		R.C						= C;

	movss	DWORD PTR [ebx+edi+4], xmm2
	movss	DWORD PTR [ebx+edi+8], xmm5
	movss	DWORD PTR [ebx+edi+12], xmm1

; 178  : 		R.C.y					+= O->renderable.visual->vis.sphere.R*0.1f;		//. YURA: 0.1 can be more

	mov	eax, DWORD PTR [ebp+68]
	movss	xmm0, DWORD PTR [eax+20]
	mulss	xmm0, DWORD PTR __real@3dcccccd
	addss	xmm0, DWORD PTR [ebx+edi+8]
	movss	DWORD PTR [ebx+edi+8], xmm0

; 179  : 		R.BB.xform				(O->renderable.visual->vis.box,O->renderable.xform).scale(0.1f);

	mov	eax, DWORD PTR [ebp+68]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 42   : 	ICF SelfRef	mul(const Self &a, T s)					{ x=a.x*s;  y=a.y*s;	z=a.z*s;		return *this;	};

	movss	xmm5, DWORD PTR [ebp+4]
	movss	xmm2, DWORD PTR [ebp+20]
	movaps	xmm0, xmm5
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h

; 64   : 		vx.mul				(m.i, B.max.x-B.min.x);	

	movss	xmm6, DWORD PTR [eax+36]
	subss	xmm6, DWORD PTR [eax+24]

; 65   : 		vy.mul				(m.j, B.max.y-B.min.y);	

	movss	xmm7, DWORD PTR [eax+40]
	subss	xmm7, DWORD PTR [eax+28]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 42   : 	ICF SelfRef	mul(const Self &a, T s)					{ x=a.x*s;  y=a.y*s;	z=a.z*s;		return *this;	};

	mulss	xmm0, xmm6
	movss	DWORD PTR tv6413[esp+544], xmm0
	movss	DWORD PTR _vx$11[esp+544], xmm0
	movaps	xmm0, xmm6
	mulss	xmm0, DWORD PTR [ebp+8]
	mulss	xmm6, DWORD PTR [ebp+12]
	movss	DWORD PTR _vx$11[esp+548], xmm0
	movaps	xmm0, xmm7
	mulss	xmm0, xmm2
	movss	DWORD PTR _vx$11[esp+552], xmm6
	movss	DWORD PTR tv6433[esp+544], xmm0
	movss	DWORD PTR _vy$13[esp+544], xmm0
	movaps	xmm0, xmm7
	mulss	xmm0, DWORD PTR [ebp+24]
	mulss	xmm7, DWORD PTR [ebp+28]
	movss	DWORD PTR _vy$13[esp+548], xmm0
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h

; 66   : 		vz.mul				(m.k, B.max.z-B.min.z);	

	movss	xmm0, DWORD PTR [eax+44]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 42   : 	ICF SelfRef	mul(const Self &a, T s)					{ x=a.x*s;  y=a.y*s;	z=a.z*s;		return *this;	};

	movss	DWORD PTR _vy$13[esp+552], xmm7
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h

; 25   : 	IC BOOL negative(const float &f)	{ return (*((unsigned*)(&f))&fdSGN);	}

	test	DWORD PTR _vx$11[esp+544], -2147483648	; 80000000H
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h

; 66   : 		vz.mul				(m.k, B.max.z-B.min.z);	

	subss	xmm0, DWORD PTR [eax+32]
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 499  : 		dest.x = v.x*_11 + v.y*_21 + v.z*_31 + _41;

	mulss	xmm2, DWORD PTR [eax+28]
	mulss	xmm5, DWORD PTR [eax+24]
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h

; 66   : 		vz.mul				(m.k, B.max.z-B.min.z);	

	movss	DWORD PTR $T8[esp+544], xmm0
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 42   : 	ICF SelfRef	mul(const Self &a, T s)					{ x=a.x*s;  y=a.y*s;	z=a.z*s;		return *this;	};

	movss	xmm0, DWORD PTR [ebp+36]
	movss	xmm4, DWORD PTR $T8[esp+544]
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 499  : 		dest.x = v.x*_11 + v.y*_21 + v.z*_31 + _41;

	addss	xmm5, xmm2
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 42   : 	ICF SelfRef	mul(const Self &a, T s)					{ x=a.x*s;  y=a.y*s;	z=a.z*s;		return *this;	};

	movaps	xmm3, xmm4
	mulss	xmm3, xmm0
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 499  : 		dest.x = v.x*_11 + v.y*_21 + v.z*_31 + _41;

	mulss	xmm0, DWORD PTR [eax+32]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 42   : 	ICF SelfRef	mul(const Self &a, T s)					{ x=a.x*s;  y=a.y*s;	z=a.z*s;		return *this;	};

	movss	DWORD PTR _vz$9[esp+544], xmm3
	movaps	xmm3, xmm4
	mulss	xmm4, DWORD PTR [ebp+44]
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 499  : 		dest.x = v.x*_11 + v.y*_21 + v.z*_31 + _41;

	addss	xmm0, DWORD PTR [ebp+52]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 42   : 	ICF SelfRef	mul(const Self &a, T s)					{ x=a.x*s;  y=a.y*s;	z=a.z*s;		return *this;	};

	mulss	xmm3, DWORD PTR [ebp+40]
	movss	DWORD PTR $T8[esp+544], xmm4
	movss	DWORD PTR _vz$9[esp+552], xmm4
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 499  : 		dest.x = v.x*_11 + v.y*_21 + v.z*_31 + _41;

	addss	xmm5, xmm0
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 42   : 	ICF SelfRef	mul(const Self &a, T s)					{ x=a.x*s;  y=a.y*s;	z=a.z*s;		return *this;	};

	movss	DWORD PTR _vz$9[esp+548], xmm3
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 499  : 		dest.x = v.x*_11 + v.y*_21 + v.z*_31 + _41;

	movss	DWORD PTR [ebx+edi+104], xmm5

; 500  : 		dest.y = v.x*_12 + v.y*_22 + v.z*_32 + _42;

	movss	xmm0, DWORD PTR [eax+24]
	mulss	xmm0, DWORD PTR [ebp+8]
	movss	xmm1, DWORD PTR [ebp+24]
	mulss	xmm1, DWORD PTR [eax+28]
	addss	xmm1, xmm0
	movss	xmm0, DWORD PTR [ebp+40]
	mulss	xmm0, DWORD PTR [eax+32]
	addss	xmm0, DWORD PTR [ebp+56]
	addss	xmm1, xmm0
	movss	DWORD PTR [ebx+edi+108], xmm1

; 501  : 		dest.z = v.x*_13 + v.y*_23 + v.z*_33 + _43;

	movss	xmm0, DWORD PTR [ebp+12]
	mulss	xmm0, DWORD PTR [eax+24]
	movss	xmm2, DWORD PTR [ebp+28]
	mulss	xmm2, DWORD PTR [eax+28]
	addss	xmm2, xmm0
	movss	xmm0, DWORD PTR [ebp+44]
	mulss	xmm0, DWORD PTR [eax+32]
	addss	xmm0, DWORD PTR [ebp+60]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 24   : 	ICF SelfRef	set(const _vector3<float> &v)			{ x = T(v.x);	y = T(v.y);	z = T(v.z);	return *this;	};

	movss	DWORD PTR [ebx+edi+116], xmm5
	movss	DWORD PTR [ebx+edi+120], xmm1
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 501  : 		dest.z = v.x*_13 + v.y*_23 + v.z*_33 + _43;

	addss	xmm2, xmm0
	movss	DWORD PTR [ebx+edi+112], xmm2
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 24   : 	ICF SelfRef	set(const _vector3<float> &v)			{ x = T(v.x);	y = T(v.y);	z = T(v.z);	return *this;	};

	movss	DWORD PTR [ebx+edi+124], xmm2
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h

; 74   : 		if(negative(vx.x))	min.x += vx.x; else max.x += vx.x;

	je	SHORT $LN275@calculate
	movss	xmm0, DWORD PTR tv6413[esp+544]
	addss	xmm0, xmm5
	movss	DWORD PTR [ebx+edi+104], xmm0
	jmp	SHORT $LN276@calculate
$LN275@calculate:
	addss	xmm5, DWORD PTR tv6413[esp+544]
	movss	DWORD PTR [ebx+edi+116], xmm5
$LN276@calculate:
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h

; 25   : 	IC BOOL negative(const float &f)	{ return (*((unsigned*)(&f))&fdSGN);	}

	test	DWORD PTR _vx$11[esp+548], -2147483648	; 80000000H
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h

; 75   : 		if(negative(vx.y))	min.y += vx.y; else max.y += vx.y;

	movss	xmm0, DWORD PTR _vx$11[esp+548]
	addss	xmm0, xmm1
	je	SHORT $LN277@calculate
	movss	DWORD PTR [ebx+edi+108], xmm0
	jmp	SHORT $LN278@calculate
$LN277@calculate:
	movss	DWORD PTR [ebx+edi+120], xmm0
	movaps	xmm0, xmm1
$LN278@calculate:
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h

; 25   : 	IC BOOL negative(const float &f)	{ return (*((unsigned*)(&f))&fdSGN);	}

	test	DWORD PTR _vx$11[esp+552], -2147483648	; 80000000H
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h

; 76   : 		if(negative(vx.z))	min.z += vx.z; else max.z += vx.z;

	addss	xmm6, xmm2
	je	SHORT $LN279@calculate
	movss	DWORD PTR [ebx+edi+112], xmm6
	jmp	SHORT $LN280@calculate
$LN279@calculate:
	movss	DWORD PTR [ebx+edi+124], xmm6
	movaps	xmm6, xmm2
$LN280@calculate:
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h

; 25   : 	IC BOOL negative(const float &f)	{ return (*((unsigned*)(&f))&fdSGN);	}

	test	DWORD PTR _vy$13[esp+544], -2147483648	; 80000000H
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h

; 77   : 		if(negative(vy.x))	min.x += vy.x; else max.x += vy.x;

	je	SHORT $LN281@calculate
	movss	xmm1, DWORD PTR tv6433[esp+544]
	addss	xmm1, DWORD PTR [ebx+edi+104]
	movss	DWORD PTR [ebx+edi+104], xmm1
	jmp	SHORT $LN282@calculate
$LN281@calculate:
	addss	xmm5, DWORD PTR tv6433[esp+544]
	movss	DWORD PTR [ebx+edi+116], xmm5
$LN282@calculate:
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h

; 25   : 	IC BOOL negative(const float &f)	{ return (*((unsigned*)(&f))&fdSGN);	}

	test	DWORD PTR _vy$13[esp+548], -2147483648	; 80000000H
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h

; 78   : 		if(negative(vy.y))	min.y += vy.y; else max.y += vy.y;

	movss	xmm1, DWORD PTR _vy$13[esp+548]
	je	SHORT $LN283@calculate
	addss	xmm1, xmm0
	movss	DWORD PTR [ebx+edi+108], xmm1
	jmp	SHORT $LN284@calculate
$LN283@calculate:
	addss	xmm1, DWORD PTR [ebx+edi+120]
	movss	DWORD PTR [ebx+edi+120], xmm1
	movaps	xmm1, xmm0
$LN284@calculate:
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h

; 25   : 	IC BOOL negative(const float &f)	{ return (*((unsigned*)(&f))&fdSGN);	}

	test	DWORD PTR _vy$13[esp+552], -2147483648	; 80000000H
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h

; 79   : 		if(negative(vy.z))	min.z += vy.z; else max.z += vy.z;

	je	SHORT $LN285@calculate
	addss	xmm7, xmm6
	movss	DWORD PTR [ebx+edi+112], xmm7
	jmp	SHORT $LN286@calculate
$LN285@calculate:
	addss	xmm7, DWORD PTR [ebx+edi+124]
	movss	DWORD PTR [ebx+edi+124], xmm7
	movaps	xmm7, xmm6
$LN286@calculate:
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h

; 25   : 	IC BOOL negative(const float &f)	{ return (*((unsigned*)(&f))&fdSGN);	}

	test	DWORD PTR _vz$9[esp+544], -2147483648	; 80000000H
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h

; 80   : 		if(negative(vz.x))	min.x += vz.x; else max.x += vz.x;

	je	SHORT $LN287@calculate
	movss	xmm0, DWORD PTR _vz$9[esp+544]
	addss	xmm0, DWORD PTR [ebx+edi+104]
	movss	DWORD PTR [ebx+edi+104], xmm0
	jmp	SHORT $LN288@calculate
$LN287@calculate:
	addss	xmm5, DWORD PTR _vz$9[esp+544]
	movss	DWORD PTR [ebx+edi+116], xmm5
$LN288@calculate:
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h

; 25   : 	IC BOOL negative(const float &f)	{ return (*((unsigned*)(&f))&fdSGN);	}

	test	DWORD PTR _vz$9[esp+548], -2147483648	; 80000000H
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h

; 81   : 		if(negative(vz.y))	min.y += vz.y; else max.y += vz.y;

	movss	xmm2, DWORD PTR _vz$9[esp+548]
	je	SHORT $LN289@calculate
	addss	xmm2, xmm1
	movss	DWORD PTR [ebx+edi+108], xmm2
	jmp	SHORT $LN290@calculate
$LN289@calculate:
	addss	xmm2, DWORD PTR [ebx+edi+120]
	movss	DWORD PTR [ebx+edi+120], xmm2
	movaps	xmm2, xmm1
$LN290@calculate:
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h

; 25   : 	IC BOOL negative(const float &f)	{ return (*((unsigned*)(&f))&fdSGN);	}

	test	DWORD PTR _vz$9[esp+552], -2147483648	; 80000000H
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h

; 82   : 		if(negative(vz.z))	min.z += vz.z; else max.z += vz.z;

	movss	xmm3, DWORD PTR $T8[esp+544]
	je	SHORT $LN291@calculate
	addss	xmm3, xmm7
	movss	DWORD PTR [ebx+edi+112], xmm3
	jmp	SHORT $LN292@calculate
$LN291@calculate:
	addss	xmm3, DWORD PTR [ebx+edi+124]
	movss	DWORD PTR [ebx+edi+124], xmm3
	movaps	xmm3, xmm7
$LN292@calculate:
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	xmm0, DWORD PTR [ebx+edi+104]
	movss	xmm1, DWORD PTR [ebx+edi+120]
	subss	xmm5, xmm0
	movss	xmm4, DWORD PTR __real@3dcccccd
	subss	xmm1, xmm2
	movss	xmm2, DWORD PTR [ebx+edi+124]
	subss	xmm2, xmm3
	mulss	xmm5, xmm4

; 40   : 	ICF SelfRef	mul(T s)								{ x*=s;		y*=s;		z*=s;			return *this;	};

	mulss	xmm1, xmm4

; 34   : 	ICF	SelfRef	sub(const Self &v)						{ x-=v.x;	y-=v.y;		z-=v.z;			return *this;	};

	subss	xmm0, xmm5

; 40   : 	ICF SelfRef	mul(T s)								{ x*=s;		y*=s;		z*=s;			return *this;	};

	mulss	xmm2, xmm4

; 34   : 	ICF	SelfRef	sub(const Self &v)						{ x-=v.x;	y-=v.y;		z-=v.z;			return *this;	};

	movss	DWORD PTR [ebx+edi+104], xmm0
	movss	xmm0, DWORD PTR [ebx+edi+108]

; 29   : 	ICF	SelfRef	add(const Self &v)						{ x+=v.x;	y+=v.y;		z+=v.z;			return *this;	};

	addss	xmm5, DWORD PTR [ebx+edi+116]

; 34   : 	ICF	SelfRef	sub(const Self &v)						{ x-=v.x;	y-=v.y;		z-=v.z;			return *this;	};

	subss	xmm0, xmm1

; 29   : 	ICF	SelfRef	add(const Self &v)						{ x+=v.x;	y+=v.y;		z+=v.z;			return *this;	};

	addss	xmm1, DWORD PTR [ebx+edi+120]
	movss	DWORD PTR [ebx+edi+116], xmm5

; 34   : 	ICF	SelfRef	sub(const Self &v)						{ x-=v.x;	y-=v.y;		z-=v.z;			return *this;	};

	movss	DWORD PTR [ebx+edi+108], xmm0
	movss	xmm0, DWORD PTR [ebx+edi+112]
	subss	xmm0, xmm2

; 29   : 	ICF	SelfRef	add(const Self &v)						{ x+=v.x;	y+=v.y;		z+=v.z;			return *this;	};

	movss	DWORD PTR [ebx+edi+120], xmm1
	addss	xmm2, DWORD PTR [ebx+edi+124]

; 34   : 	ICF	SelfRef	sub(const Self &v)						{ x-=v.x;	y-=v.y;		z-=v.z;			return *this;	};

	movss	DWORD PTR [ebx+edi+112], xmm0

; 29   : 	ICF	SelfRef	add(const Self &v)						{ x+=v.x;	y+=v.y;		z+=v.z;			return *this;	};

	movss	DWORD PTR [ebx+edi+124], xmm2
; File I:\Vitalya\mine\NSProjectX\xrCore\_random.h

; 33   : 	IC 	s32		randI	(s32 max)					{ VERIFY(max);  return randI()%max; }

	mov	ecx, DWORD PTR __imp_?Random@@3VCRandom@@A
	call	?randI@CRandom@@QAEHXZ			; CRandom::randI
	cdq
	mov	ecx, 60000				; 0000ea60H
	idiv	ecx
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightProjector.cpp

; 180  : 		R.dwTimeValid			= Device.dwTimeGlobal + ::Random.randI(time_min,time_max);

	mov	eax, DWORD PTR __imp_?Device@@3VCRenderDevice@@A

; 181  : 		LT->shadow_recv_slot	= c_it; 

	mov	ebp, DWORD PTR _c_it$1$[esp+544]
; File I:\Vitalya\mine\NSProjectX\xrCore\_random.h

; 34   : 	IC 	s32		randI	(s32 min, s32 max)			{ return min+randI(max-min); }

	add	edx, 30000				; 00007530H
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 406  : 		T cot	= T(1)/HAT;

	movss	xmm1, DWORD PTR __real@43480000
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightProjector.cpp

; 180  : 		R.dwTimeValid			= Device.dwTimeGlobal + ::Random.randI(time_min,time_max);

	mov	eax, DWORD PTR [eax+480]
	add	eax, edx
	mov	DWORD PTR [ebx+edi+132], eax

; 181  : 		LT->shadow_recv_slot	= c_it; 

	mov	DWORD PTR [esi+1928], ebp

; 182  : 
; 183  : 		// Msg					("[%f,%f,%f]-%f",C.C.x,C.C.y,C.C.z,C.O->renderable.visual->vis.sphere.R);
; 184  : 		// calculate projection-matrix
; 185  : 		Fmatrix		mProject;
; 186  : 		float		p_R			=	R.O->renderable.visual->vis.sphere.R * 1.1f;

	mov	eax, DWORD PTR [ebx+edi]

; 193  : 		RCache.set_xform_project		(mProject);

	mov	ecx, DWORD PTR __imp_?RCache@@3VCBackend@@A
	mov	eax, DWORD PTR [eax+68]
	movss	xmm0, DWORD PTR [eax+20]
	lea	eax, DWORD PTR _mProject$15[esp+544]
	mulss	xmm0, DWORD PTR __real@3f8ccccd
	push	eax
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 411  : 		_11		= w;	_12 = 0;	_13 = 0;			_14 = 0;

	mov	DWORD PTR _mProject$15[esp+552], 0
	mov	DWORD PTR _mProject$15[esp+556], 0
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightProjector.cpp

; 191  : 		float		p_far		=	P_cam_dist+p_R+P_cam_range;	

	movaps	xmm2, xmm0
	movss	DWORD PTR _p_R$1$[esp+548], xmm0
	addss	xmm2, DWORD PTR __real@434f0000
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 406  : 		T cot	= T(1)/HAT;

	divss	xmm1, xmm0

; 411  : 		_11		= w;	_12 = 0;	_13 = 0;			_14 = 0;

	mov	DWORD PTR _mProject$15[esp+560], 0

; 412  : 		_21		= 0;	_22	= h;	_23 = 0;			_24 = 0;

	mov	DWORD PTR _mProject$15[esp+564], 0
	mov	DWORD PTR _mProject$15[esp+572], 0
	mov	DWORD PTR _mProject$15[esp+576], 0

; 413  : 		_31		= 0;	_32 = 0;	_33 = Q;			_34 = 1.0f;

	mov	DWORD PTR _mProject$15[esp+580], 0
	mov	DWORD PTR _mProject$15[esp+584], 0
	mov	DWORD PTR _mProject$15[esp+592], 1065353216 ; 3f800000H

; 414  : 		_41		= 0;	_42 = 0;	_43	= -Q*fNearPlane;_44 = 0;

	mov	DWORD PTR _mProject$15[esp+596], 0
	mov	DWORD PTR _mProject$15[esp+600], 0
	mov	DWORD PTR _mProject$15[esp+608], 0
	movaps	xmm0, xmm2
	subss	xmm0, DWORD PTR __real@4347ffbe
	movss	DWORD PTR _mProject$15[esp+548], xmm1
	movss	DWORD PTR _mProject$15[esp+568], xmm1
	divss	xmm2, xmm0
	movss	DWORD PTR _mProject$15[esp+588], xmm2
	mulss	xmm2, DWORD PTR __real@c347ffbe
	movss	DWORD PTR _mProject$15[esp+604], xmm2
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightProjector.cpp

; 193  : 		RCache.set_xform_project		(mProject);

	call	DWORD PTR __imp_?set_xform_project@CBackend@@QAEXABU?$_matrix@M@@@Z
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 24   : 	ICF SelfRef	set(const _vector3<float> &v)			{ x = T(v.x);	y = T(v.y);	z = T(v.z);	return *this;	};

	movss	xmm2, DWORD PTR [ebx+edi+8]
	movss	xmm1, DWORD PTR [ebx+edi+4]
	movss	xmm0, DWORD PTR [ebx+edi+12]
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightProjector.cpp

; 199  : 		v_Cs					= v_C;

	movss	DWORD PTR _v_Cs$20[esp+548], xmm2
	addss	xmm2, DWORD PTR __real@43480000
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 24   : 	ICF SelfRef	set(const _vector3<float> &v)			{ x = T(v.x);	y = T(v.y);	z = T(v.z);	return *this;	};

	movss	DWORD PTR _v_C$18[esp+544], xmm1
	movss	DWORD PTR _v_C$18[esp+552], xmm0
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightProjector.cpp

; 199  : 		v_Cs					= v_C;

	movss	DWORD PTR _v_Cs$20[esp+544], xmm1
	movss	DWORD PTR _v_Cs$20[esp+552], xmm0

; 200  : 		v_C.y					+=	P_cam_dist;

	movss	DWORD PTR _v_C$18[esp+548], xmm2
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 23   : 	ICF	SelfRef	set(T _x, T _y, T _z)					{ x = _x;		y = _y;		z = _z;		return *this;	};

	mov	DWORD PTR _v_N$19[esp+544], 0
	mov	DWORD PTR _v_N$19[esp+548], 0
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightProjector.cpp

; 245  : 		mView.build_camera		(v_C,v_Cs,v_N);

	lea	eax, DWORD PTR _v_N$19[esp+544]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 23   : 	ICF	SelfRef	set(T _x, T _y, T _z)					{ x = _x;		y = _y;		z = _z;		return *this;	};

	mov	DWORD PTR _v_N$19[esp+552], 1065353216	; 3f800000H
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightProjector.cpp

; 245  : 		mView.build_camera		(v_C,v_Cs,v_N);

	push	eax
	lea	eax, DWORD PTR _v_Cs$20[esp+548]
	push	eax
	lea	eax, DWORD PTR _v_C$18[esp+552]
	push	eax
	lea	ecx, DWORD PTR _mView$17[esp+556]
	call	?build_camera@?$_matrix@M@@QAEAAU1@ABU?$_vector3@M@@00@Z ; _matrix<float>::build_camera

; 246  : 		RCache.set_xform_view	(mView);

	mov	ecx, DWORD PTR __imp_?RCache@@3VCBackend@@A
	lea	eax, DWORD PTR _mView$17[esp+544]
	push	eax
	call	DWORD PTR __imp_?set_xform_view@CBackend@@QAEXABU?$_matrix@M@@@Z

; 247  : 
; 248  : 		// Select slot, set viewport
; 249  : 		int		s_x				=	c_it%P_o_line;

	mov	eax, -858993459				; cccccccdH

; 250  : 		int		s_y				=	c_it/P_o_line;
; 251  : 		D3DVIEWPORT9 VP			=	{s_x*P_o_size,s_y*P_o_size,P_o_size,P_o_size,0,1 };

	mov	DWORD PTR _VP$21[esp+552], 51		; 00000033H
	mul	ebp
	mov	ecx, ebp
	mov	DWORD PTR _VP$21[esp+556], 51		; 00000033H
	shr	edx, 3
	mov	DWORD PTR _VP$21[esp+560], 0
	mov	DWORD PTR _VP$21[esp+564], 1065353216	; 3f800000H
	lea	eax, DWORD PTR [edx+edx*4]
	add	eax, eax
	sub	ecx, eax
	imul	eax, ecx, 51
	mov	DWORD PTR _VP$21[esp+544], eax
	mov	DWORD PTR tv6918[esp+544], eax
	imul	eax, edx, 51

; 252  : 		CHK_DX					(HW.pDevice->SetViewport(&VP));

	lea	edx, DWORD PTR _VP$21[esp+544]
	push	edx
	mov	DWORD PTR _VP$21[esp+552], eax
	mov	DWORD PTR tv6917[esp+548], eax
	mov	eax, DWORD PTR __imp_?HW@@3VCHW@@A
	mov	eax, DWORD PTR [eax+8]
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+188]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\lighttrack.h

; 74   : 		if (dwFrameSmooth!=Device.dwFrame)		update_smooth();

	mov	eax, DWORD PTR __imp_?Device@@3VCRenderDevice@@A
	mov	eax, DWORD PTR [eax+244]
	cmp	DWORD PTR [esi+12], eax
	je	SHORT $LN360@calculate
; File I:\Vitalya\mine\NSProjectX\xrCore\vector.h

; 92   : 	if( val<_low ) val = _low; else if( val>_high ) val = _high;

	movss	xmm3, DWORD PTR __real@3f800000
	xorps	xmm0, xmm0
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\LightTrack.cpp

; 260  : 	dwFrameSmooth			=	Device.dwFrame					;

	mov	DWORD PTR [esi+12], eax

; 261  : 	if (O && (0==result_count))	update(O)						;	// First time only
; 262  : 	float	l_f				=	Device.fTimeDelta*ps_r2_lt_smooth;

	mov	eax, DWORD PTR __imp_?Device@@3VCRenderDevice@@A
	movss	xmm2, DWORD PTR [eax+468]
; File I:\Vitalya\mine\NSProjectX\xrCore\vector.h

; 92   : 	if( val<_low ) val = _low; else if( val>_high ) val = _high;

	comiss	xmm0, xmm2
	jbe	SHORT $LN365@calculate
	movaps	xmm2, xmm0
	jmp	SHORT $LN367@calculate
$LN365@calculate:
	comiss	xmm2, xmm3
	jbe	SHORT $LN367@calculate
	movaps	xmm2, xmm3
$LN367@calculate:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\LightTrack.cpp

; 264  : 	float	l_i				=	1.f-l_f							;

	subss	xmm3, xmm2

; 265  : 	hemi_smooth				=	hemi_value*l_f + hemi_smooth*l_i;

	movaps	xmm1, xmm2
	mulss	xmm1, DWORD PTR [esi+1932]

; 266  : 	sun_smooth				=	sun_value *l_f + sun_smooth *l_i;

	mulss	xmm2, DWORD PTR [esi+1940]
	movaps	xmm0, xmm3
	mulss	xmm3, DWORD PTR [esi+1944]
	mulss	xmm0, DWORD PTR [esi+1936]
	addss	xmm2, xmm3
	addss	xmm1, xmm0
	movss	DWORD PTR [esi+1944], xmm2
	movss	DWORD PTR [esi+1936], xmm1
$LN360@calculate:
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightProjector.cpp

; 256  : 		CHK_DX					(HW.pDevice->Clear(0,0, D3DCLEAR_TARGET, color_rgba_f(cap.x,cap.y,cap.z, (cap.x+cap.y+cap.z)/4.f), 1, 0 ));

	movss	xmm0, DWORD PTR [esi+1948]
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h

; 84   :     int exponent	= (127 + 31) - ((a >> 23) & 0xFF);

	mov	ecx, 158				; 0000009eH
; File I:\Vitalya\mine\NSProjectX\xrCore\_color.h

; 9    : 	s32	 _r = clampr(iFloor(r*255.f),0,255);

	movss	xmm4, DWORD PTR __real@437f0000
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightProjector.cpp

; 256  : 		CHK_DX					(HW.pDevice->Clear(0,0, D3DCLEAR_TARGET, color_rgba_f(cap.x,cap.y,cap.z, (cap.x+cap.y+cap.z)/4.f), 1, 0 ));

	movaps	xmm1, xmm0
	movss	xmm2, DWORD PTR [esi+1952]
; File I:\Vitalya\mine\NSProjectX\xrCore\vector.h

; 96   : 	if		( val<_low	)	return _low; 

	mov	ebp, 255				; 000000ffH
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightProjector.cpp

; 256  : 		CHK_DX					(HW.pDevice->Clear(0,0, D3DCLEAR_TARGET, color_rgba_f(cap.x,cap.y,cap.z, (cap.x+cap.y+cap.z)/4.f), 1, 0 ));

	movss	xmm3, DWORD PTR [esi+1956]
	addss	xmm1, xmm2
; File I:\Vitalya\mine\NSProjectX\xrCore\_color.h

; 9    : 	s32	 _r = clampr(iFloor(r*255.f),0,255);

	mulss	xmm0, xmm4
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h

; 83   :     int a			= *(const int*)(&x);

	movss	DWORD PTR _a$6[esp+544], xmm0
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightProjector.cpp

; 256  : 		CHK_DX					(HW.pDevice->Clear(0,0, D3DCLEAR_TARGET, color_rgba_f(cap.x,cap.y,cap.z, (cap.x+cap.y+cap.z)/4.f), 1, 0 ));

	addss	xmm1, xmm3
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h

; 84   :     int exponent	= (127 + 31) - ((a >> 23) & 0xFF);

	mov	esi, DWORD PTR _a$6[esp+544]
	mov	eax, esi
	sar	eax, 23					; 00000017H

; 89   :         exponent	-=	(31-127)+32;
; 90   :         exponent	>>=	31;
; 91   :         a			>>=	31;

	mov	edx, esi
	movzx	eax, al
	sub	ecx, eax
	sar	edx, 31					; 0000001fH
	mov	eax, esi
	or	eax, -8388608				; ff800000H
	shl	eax, 8
	shr	eax, cl
	sub	ecx, 96					; 00000060H
	mov	DWORD PTR __r$1$[esp+544], eax
	mov	eax, 1
	shl	eax, cl
	dec	eax
	sar	eax, 8
	and	eax, esi
	neg	eax
	sbb	eax, eax
	inc	eax
	and	eax, edx

; 92   :         r			-=	(imask&a);

	sub	DWORD PTR __r$1$[esp+544], eax
	lea	eax, DWORD PTR [ecx+64]

; 93   :         r			&=	exponent;

	mov	ecx, DWORD PTR __r$1$[esp+544]
	sar	eax, 31					; 0000001fH
	and	ecx, eax
	xor	ecx, edx
; File I:\Vitalya\mine\NSProjectX\xrCore\vector.h

; 96   : 	if		( val<_low	)	return _low; 

	jge	SHORT $LN376@calculate
	mov	DWORD PTR __r$1$[esp+544], 0
	jmp	SHORT $LN378@calculate
$LN376@calculate:

; 97   : 	else if	( val>_high )	return _high;

	cmp	ecx, 255				; 000000ffH
	cmovg	ecx, ebp
	mov	DWORD PTR __r$1$[esp+544], ecx
$LN378@calculate:
; File I:\Vitalya\mine\NSProjectX\xrCore\_color.h

; 10   : 	s32	 _g = clampr(iFloor(g*255.f),0,255);

	mulss	xmm2, xmm4
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h

; 84   :     int exponent	= (127 + 31) - ((a >> 23) & 0xFF);

	mov	ecx, 158				; 0000009eH
	movss	DWORD PTR _a$5[esp+544], xmm2
	mov	esi, DWORD PTR _a$5[esp+544]
	mov	eax, esi
	sar	eax, 23					; 00000017H

; 89   :         exponent	-=	(31-127)+32;
; 90   :         exponent	>>=	31;
; 91   :         a			>>=	31;

	mov	edx, esi
	movzx	eax, al
	sub	ecx, eax
	sar	edx, 31					; 0000001fH
	mov	eax, esi
	or	eax, -8388608				; ff800000H
	shl	eax, 8
	shr	eax, cl
	sub	ecx, 96					; 00000060H
	mov	DWORD PTR __g$1$[esp+544], eax
	mov	eax, 1
	shl	eax, cl
	dec	eax
	sar	eax, 8
	and	eax, esi
	neg	eax
	sbb	eax, eax
	inc	eax
	and	eax, edx

; 92   :         r			-=	(imask&a);

	sub	DWORD PTR __g$1$[esp+544], eax
	lea	eax, DWORD PTR [ecx+64]

; 93   :         r			&=	exponent;

	mov	ecx, DWORD PTR __g$1$[esp+544]
	sar	eax, 31					; 0000001fH
	and	ecx, eax
	xor	ecx, edx
; File I:\Vitalya\mine\NSProjectX\xrCore\vector.h

; 96   : 	if		( val<_low	)	return _low; 

	jge	SHORT $LN384@calculate
	mov	DWORD PTR __g$1$[esp+544], 0
	jmp	SHORT $LN386@calculate
$LN384@calculate:

; 97   : 	else if	( val>_high )	return _high;

	cmp	ecx, 255				; 000000ffH
	cmovg	ecx, ebp
	mov	DWORD PTR __g$1$[esp+544], ecx
$LN386@calculate:
; File I:\Vitalya\mine\NSProjectX\xrCore\_color.h

; 11   : 	s32	 _b = clampr(iFloor(b*255.f),0,255);

	mulss	xmm3, xmm4
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h

; 84   :     int exponent	= (127 + 31) - ((a >> 23) & 0xFF);

	mov	ecx, 158				; 0000009eH
	movss	DWORD PTR _a$4[esp+544], xmm3
	mov	esi, DWORD PTR _a$4[esp+544]
	mov	eax, esi
	sar	eax, 23					; 00000017H

; 89   :         exponent	-=	(31-127)+32;
; 90   :         exponent	>>=	31;
; 91   :         a			>>=	31;

	mov	edx, esi
	movzx	eax, al
	sub	ecx, eax
	sar	edx, 31					; 0000001fH
	mov	eax, esi
	or	eax, -8388608				; ff800000H
	shl	eax, 8
	shr	eax, cl
	sub	ecx, 96					; 00000060H
	mov	DWORD PTR __b$1$[esp+544], eax
	mov	eax, 1
	shl	eax, cl
	dec	eax
	sar	eax, 8
	and	eax, esi
	neg	eax
	sbb	eax, eax
	inc	eax
	and	eax, edx

; 92   :         r			-=	(imask&a);

	sub	DWORD PTR __b$1$[esp+544], eax
	lea	eax, DWORD PTR [ecx+64]

; 93   :         r			&=	exponent;

	mov	ecx, DWORD PTR __b$1$[esp+544]
	sar	eax, 31					; 0000001fH
	and	ecx, eax
	xor	ecx, edx
; File I:\Vitalya\mine\NSProjectX\xrCore\vector.h

; 96   : 	if		( val<_low	)	return _low; 

	jge	SHORT $LN392@calculate
	mov	DWORD PTR __b$1$[esp+544], 0
	jmp	SHORT $LN394@calculate
$LN392@calculate:

; 97   : 	else if	( val>_high )	return _high;

	cmp	ecx, 255				; 000000ffH
	cmovg	ecx, ebp
	mov	DWORD PTR __b$1$[esp+544], ecx
$LN394@calculate:
; File I:\Vitalya\mine\NSProjectX\xrCore\_color.h

; 12   : 	s32	 _a = clampr(iFloor(a*255.f),0,255);

	mulss	xmm1, DWORD PTR __real@427f0000
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h

; 84   :     int exponent	= (127 + 31) - ((a >> 23) & 0xFF);

	mov	ecx, 158				; 0000009eH
	movss	DWORD PTR _a$3[esp+544], xmm1
	mov	esi, DWORD PTR _a$3[esp+544]
	mov	eax, esi
	sar	eax, 23					; 00000017H

; 85   :     int r			= (((u32)(a) << 8) | (1U << 31)) >> exponent;

	mov	ebp, esi
	movzx	eax, al
	or	ebp, -8388608				; ff800000H
	sub	ecx, eax
	shl	ebp, 8
	shr	ebp, cl

; 86   :     exponent		+= 31-127;
; 87   :     {
; 88   :         int imask	=	(!(((( (1<<(exponent)))-1)>>8)&a));

	mov	eax, 1
	sub	ecx, 96					; 00000060H

; 89   :         exponent	-=	(31-127)+32;
; 90   :         exponent	>>=	31;
; 91   :         a			>>=	31;

	mov	edx, esi
	shl	eax, cl
	dec	eax
	sar	edx, 31					; 0000001fH
	sar	eax, 8
	and	eax, esi
	neg	eax
	sbb	eax, eax
	inc	eax
	and	eax, edx

; 92   :         r			-=	(imask&a);

	sub	ebp, eax
	lea	eax, DWORD PTR [ecx+64]
	sar	eax, 31					; 0000001fH

; 93   :         r			&=	exponent;

	and	ebp, eax
	xor	ebp, edx
; File I:\Vitalya\mine\NSProjectX\xrCore\vector.h

; 96   : 	if		( val<_low	)	return _low; 

	jge	SHORT $LN400@calculate
	xor	ebp, ebp
	jmp	SHORT $LN402@calculate
$LN400@calculate:

; 97   : 	else if	( val>_high )	return _high;

	cmp	ebp, 255				; 000000ffH
	mov	eax, 255				; 000000ffH
	cmovg	ebp, eax
$LN402@calculate:
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightProjector.cpp

; 256  : 		CHK_DX					(HW.pDevice->Clear(0,0, D3DCLEAR_TARGET, color_rgba_f(cap.x,cap.y,cap.z, (cap.x+cap.y+cap.z)/4.f), 1, 0 ));

	mov	eax, DWORD PTR __imp_?HW@@3VCHW@@A
	fld1
	push	0
	push	ecx
	mov	edx, DWORD PTR [eax+8]
; File I:\Vitalya\mine\NSProjectX\xrCore\_color.h

; 5    : ICF u32	color_argb	(u32 a, u32 r, u32 g, u32 b)	{	return ((a&0xff)<<24)|((r&0xff)<<16)|((g&0xff)<<8)|(b&0xff);	}

	mov	eax, DWORD PTR __r$1$[esp+552]
	movzx	ecx, al
	mov	eax, DWORD PTR __g$1$[esp+552]
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightProjector.cpp

; 256  : 		CHK_DX					(HW.pDevice->Clear(0,0, D3DCLEAR_TARGET, color_rgba_f(cap.x,cap.y,cap.z, (cap.x+cap.y+cap.z)/4.f), 1, 0 ));

	mov	esi, DWORD PTR [edx]
; File I:\Vitalya\mine\NSProjectX\xrCore\_color.h

; 5    : ICF u32	color_argb	(u32 a, u32 r, u32 g, u32 b)	{	return ((a&0xff)<<24)|((r&0xff)<<16)|((g&0xff)<<8)|(b&0xff);	}

	shl	ebp, 8
	or	ecx, ebp
	movzx	eax, al
	shl	ecx, 8
	or	ecx, eax
	mov	eax, DWORD PTR __b$1$[esp+552]
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightProjector.cpp

; 256  : 		CHK_DX					(HW.pDevice->Clear(0,0, D3DCLEAR_TARGET, color_rgba_f(cap.x,cap.y,cap.z, (cap.x+cap.y+cap.z)/4.f), 1, 0 ));

	fstp	DWORD PTR [esp]
; File I:\Vitalya\mine\NSProjectX\xrCore\_color.h

; 5    : ICF u32	color_argb	(u32 a, u32 r, u32 g, u32 b)	{	return ((a&0xff)<<24)|((r&0xff)<<16)|((g&0xff)<<8)|(b&0xff);	}

	shl	ecx, 8
	movzx	eax, al
	or	ecx, eax
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightProjector.cpp

; 256  : 		CHK_DX					(HW.pDevice->Clear(0,0, D3DCLEAR_TARGET, color_rgba_f(cap.x,cap.y,cap.z, (cap.x+cap.y+cap.z)/4.f), 1, 0 ));

	push	ecx
	push	1
	push	0
	push	0
	push	edx
	call	DWORD PTR [esi+172]
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 86   : 		m[0][1] = A.m[0][1] * B.m[0][0] + A.m[1][1] * B.m[0][1] + A.m[2][1] * B.m[0][2] + A.m[3][1] * B.m[0][3];

	movss	xmm5, DWORD PTR _mView$17[esp+548]
	movss	xmm4, DWORD PTR _mView$17[esp+544]
	movaps	xmm0, xmm5
	mulss	xmm0, DWORD PTR _mProject$15[esp+564]
	movss	xmm2, DWORD PTR _mView$17[esp+556]

; 88   : 		m[0][3] = A.m[0][3] * B.m[0][0] + A.m[1][3] * B.m[0][1] + A.m[2][3] * B.m[0][2] + A.m[3][3] * B.m[0][3];

	movss	xmm7, DWORD PTR _mProject$15[esp+572]
	movss	DWORD PTR tv6674[esp+544], xmm0
	movss	xmm0, DWORD PTR _mProject$15[esp+548]
	movss	DWORD PTR _mProject$2$[esp+544], xmm0
	mulss	xmm0, xmm4
	movss	xmm6, DWORD PTR _mProject$15[esp+556]
	movss	DWORD PTR _mView$4$[esp+544], xmm2
	movss	DWORD PTR tv6843[esp+544], xmm0
	movss	xmm0, DWORD PTR _mView$17[esp+552]
	movaps	xmm1, xmm0
	mulss	xmm1, DWORD PTR _mProject$15[esp+580]
	movss	DWORD PTR tv6844[esp+544], xmm1
	movaps	xmm1, xmm2
	mulss	xmm1, DWORD PTR _mProject$15[esp+596]
	movss	DWORD PTR tv6673[esp+544], xmm1
	movaps	xmm1, xmm5
	mulss	xmm1, DWORD PTR _mProject$15[esp+568]
	movss	DWORD PTR tv6677[esp+544], xmm1
	movaps	xmm1, xmm4
	mulss	xmm1, DWORD PTR _mProject$15[esp+552]
	movss	DWORD PTR tv6847[esp+544], xmm1
	movaps	xmm1, xmm0
	mulss	xmm1, DWORD PTR _mProject$15[esp+584]
	mulss	xmm0, DWORD PTR _mProject$15[esp+588]
	movss	DWORD PTR tv6676[esp+544], xmm1
	movaps	xmm1, xmm2
	mulss	xmm1, DWORD PTR _mProject$15[esp+600]
	mulss	xmm2, DWORD PTR _mProject$15[esp+604]
	movss	DWORD PTR tv6850[esp+544], xmm1
	movaps	xmm1, xmm5
	mulss	xmm1, xmm7
	addss	xmm2, xmm0

; 89   : 
; 90   : 		m[1][0] = A.m[0][0] * B.m[1][0] + A.m[1][0] * B.m[1][1] + A.m[2][0] * B.m[1][2] + A.m[3][0] * B.m[1][3];

	movss	xmm5, DWORD PTR _mProject$15[esp+576]
	movaps	xmm0, xmm4
	mulss	xmm0, xmm6
	addss	xmm1, xmm0
	addss	xmm2, xmm1
	movss	xmm1, DWORD PTR _mView$17[esp+560]
	movss	DWORD PTR tv6678[esp+544], xmm2
	movss	xmm2, DWORD PTR _mView$17[esp+564]
	movaps	xmm0, xmm2
	mulss	xmm0, DWORD PTR _mProject$15[esp+560]
	movss	DWORD PTR tv6679[esp+544], xmm0
	movss	xmm0, DWORD PTR _mProject$15[esp+544]
	mulss	xmm0, xmm1
	movss	DWORD PTR tv6854[esp+544], xmm0
	movss	xmm0, DWORD PTR _mView$17[esp+568]
	mulss	xmm0, xmm5
	movss	DWORD PTR tv6855[esp+544], xmm0
	movss	xmm0, DWORD PTR _mView$17[esp+572]
	movss	DWORD PTR _mView$8$[esp+544], xmm0
	movss	xmm4, DWORD PTR _mProject$15[esp+592]
	mulss	xmm0, xmm4
	movss	DWORD PTR tv6680[esp+544], xmm0

; 91   : 		m[1][1] = A.m[0][1] * B.m[1][0] + A.m[1][1] * B.m[1][1] + A.m[2][1] * B.m[1][2] + A.m[3][1] * B.m[1][3];

	movaps	xmm0, xmm2
	mulss	xmm0, DWORD PTR _mProject$15[esp+564]
	movss	DWORD PTR tv6682[esp+544], xmm0
	movss	xmm0, DWORD PTR _mProject$2$[esp+544]
	mulss	xmm0, xmm1
	movss	DWORD PTR tv6858[esp+544], xmm0
	movss	xmm0, DWORD PTR _mView$17[esp+568]
	mulss	xmm0, DWORD PTR _mProject$15[esp+580]
	movss	DWORD PTR tv6681[esp+544], xmm0
	movss	xmm0, DWORD PTR _mView$8$[esp+544]
	mulss	xmm0, DWORD PTR _mProject$15[esp+596]
	movss	DWORD PTR tv6860[esp+544], xmm0

; 92   : 		m[1][2] = A.m[0][2] * B.m[1][0] + A.m[1][2] * B.m[1][1] + A.m[2][2] * B.m[1][2] + A.m[3][2] * B.m[1][3];

	movaps	xmm0, xmm2
	mulss	xmm0, DWORD PTR _mProject$15[esp+568]

; 93   : 		m[1][3] = A.m[0][3] * B.m[1][0] + A.m[1][3] * B.m[1][1] + A.m[2][3] * B.m[1][2] + A.m[3][3] * B.m[1][3];

	mulss	xmm2, xmm7
	movss	DWORD PTR tv6861[esp+544], xmm0
	movaps	xmm0, xmm1
	mulss	xmm0, DWORD PTR _mProject$15[esp+552]
	movss	DWORD PTR tv6686[esp+544], xmm0
	movss	xmm0, DWORD PTR _mView$17[esp+568]
	movaps	xmm1, xmm0
	mulss	xmm0, DWORD PTR _mProject$15[esp+588]
	mulss	xmm1, DWORD PTR _mProject$15[esp+584]
	movss	DWORD PTR tv6863[esp+544], xmm1
	movss	xmm1, DWORD PTR _mView$8$[esp+544]
	mulss	xmm1, DWORD PTR _mProject$15[esp+600]
	movss	DWORD PTR tv6685[esp+544], xmm1
	movss	xmm1, DWORD PTR _mView$8$[esp+544]
	mulss	xmm1, DWORD PTR _mProject$15[esp+604]
	addss	xmm1, xmm0
	movss	DWORD PTR _mView$8$[esp+544], xmm1
	movss	xmm1, DWORD PTR _mView$17[esp+560]
	movss	xmm0, DWORD PTR _mView$8$[esp+544]
	mulss	xmm1, xmm6
	addss	xmm2, xmm1

; 94   : 
; 95   : 		m[2][0] = A.m[0][0] * B.m[2][0] + A.m[1][0] * B.m[2][1] + A.m[2][0] * B.m[2][2] + A.m[3][0] * B.m[2][3];

	movss	xmm1, DWORD PTR _mView$17[esp+576]
	addss	xmm0, xmm2
	movss	xmm2, DWORD PTR _mView$17[esp+580]
	movss	DWORD PTR _mView$8$[esp+544], xmm0
	movaps	xmm0, xmm2
	mulss	xmm0, DWORD PTR _mProject$15[esp+560]
	movss	DWORD PTR tv6688[esp+544], xmm0
	movss	xmm0, DWORD PTR _mProject$15[esp+544]
	mulss	xmm0, xmm1
	movss	DWORD PTR tv6868[esp+544], xmm0
	movss	xmm0, DWORD PTR _mView$17[esp+584]
	movaps	xmm3, xmm0
	mulss	xmm3, xmm5
	movss	DWORD PTR tv6869[esp+544], xmm3
	movss	xmm3, DWORD PTR _mView$17[esp+588]
	movss	DWORD PTR _mView$12$[esp+544], xmm3
	mulss	xmm3, xmm4
	movss	DWORD PTR tv6870[esp+544], xmm3

; 96   : 		m[2][1] = A.m[0][1] * B.m[2][0] + A.m[1][1] * B.m[2][1] + A.m[2][1] * B.m[2][2] + A.m[3][1] * B.m[2][3];

	movaps	xmm3, xmm2
	mulss	xmm3, DWORD PTR _mProject$15[esp+564]
	movss	DWORD PTR tv6871[esp+544], xmm3
	movss	xmm3, DWORD PTR _mProject$2$[esp+544]
	mulss	xmm3, xmm1
	movss	DWORD PTR tv6691[esp+544], xmm3
	movaps	xmm3, xmm0
	mulss	xmm3, DWORD PTR _mProject$15[esp+580]
	movss	DWORD PTR tv6690[esp+544], xmm3
	movss	xmm3, DWORD PTR _mView$12$[esp+544]
	mulss	xmm3, DWORD PTR _mProject$15[esp+596]
	movss	DWORD PTR tv6874[esp+544], xmm3

; 97   : 		m[2][2] = A.m[0][2] * B.m[2][0] + A.m[1][2] * B.m[2][1] + A.m[2][2] * B.m[2][2] + A.m[3][2] * B.m[2][3];

	movaps	xmm3, xmm2
	mulss	xmm3, DWORD PTR _mProject$15[esp+568]
	movss	DWORD PTR tv6875[esp+544], xmm3
	movaps	xmm3, xmm1
	mulss	xmm3, DWORD PTR _mProject$15[esp+552]
	movss	DWORD PTR tv6693[esp+544], xmm3
	movaps	xmm3, xmm0
	mulss	xmm3, DWORD PTR _mProject$15[esp+584]
	movss	DWORD PTR tv6877[esp+544], xmm3
	movss	xmm3, DWORD PTR _mView$12$[esp+544]
	mulss	xmm3, DWORD PTR _mProject$15[esp+600]
	movss	DWORD PTR tv6694[esp+544], xmm3

; 98   : 		m[2][3] = A.m[0][3] * B.m[2][0] + A.m[1][3] * B.m[2][1] + A.m[2][3] * B.m[2][2] + A.m[3][3] * B.m[2][3];

	movss	xmm3, DWORD PTR _mView$12$[esp+544]
	mulss	xmm0, DWORD PTR _mProject$15[esp+588]
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightProjector.cpp

; 272  : 		R.UVgen.mul				(m_TexelAdjust,mCombine);

	lea	esi, DWORD PTR [ebx+edi]
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 98   : 		m[2][3] = A.m[0][3] * B.m[2][0] + A.m[1][3] * B.m[2][1] + A.m[2][3] * B.m[2][2] + A.m[3][3] * B.m[2][3];

	mulss	xmm3, DWORD PTR _mProject$15[esp+604]
	mulss	xmm1, xmm6
	addss	xmm3, xmm0
	mulss	xmm2, xmm7
	addss	xmm2, xmm1

; 99   : 
; 100  : 		m[3][0] = A.m[0][0] * B.m[3][0] + A.m[1][0] * B.m[3][1] + A.m[2][0] * B.m[3][2] + A.m[3][0] * B.m[3][3];

	movss	xmm1, DWORD PTR _mView$17[esp+592]

; 102  : 		m[3][2] = A.m[0][2] * B.m[3][0] + A.m[1][2] * B.m[3][1] + A.m[2][2] * B.m[3][2] + A.m[3][2] * B.m[3][3];

	movaps	xmm6, xmm1
	mulss	xmm6, DWORD PTR _mProject$15[esp+552]
	addss	xmm3, xmm2
	movss	xmm2, DWORD PTR _mView$17[esp+596]
	movaps	xmm0, xmm2
	mulss	xmm0, DWORD PTR _mProject$15[esp+560]
	movss	DWORD PTR _mView$12$[esp+544], xmm3
	movss	DWORD PTR tv6696[esp+544], xmm0
	movss	xmm0, DWORD PTR _mProject$15[esp+544]
	mulss	xmm0, xmm1
	movss	DWORD PTR tv6882[esp+544], xmm0
	movss	xmm0, DWORD PTR _mView$17[esp+600]
	movaps	xmm3, xmm0
	movaps	xmm7, xmm0
	mulss	xmm3, xmm5
	movss	xmm5, DWORD PTR _mView$17[esp+604]
	movss	DWORD PTR _mView$16$[esp+544], xmm5
	movss	DWORD PTR tv6883[esp+544], xmm3
	movaps	xmm3, xmm5
	mulss	xmm5, DWORD PTR _mProject$15[esp+596]
	mulss	xmm3, xmm4
	movss	xmm4, DWORD PTR _mView$16$[esp+544]
	movss	DWORD PTR tv6888[esp+544], xmm5

; 103  : 		m[3][3] = A.m[0][3] * B.m[3][0] + A.m[1][3] * B.m[3][1] + A.m[2][3] * B.m[3][2] + A.m[3][3] * B.m[3][3];

	movss	xmm5, DWORD PTR _mView$16$[esp+544]
	mulss	xmm5, DWORD PTR _mProject$15[esp+604]
	movss	DWORD PTR tv6697[esp+544], xmm3
	movaps	xmm3, xmm2
	mulss	xmm3, DWORD PTR _mProject$15[esp+564]
	mulss	xmm7, DWORD PTR _mProject$15[esp+580]
	movss	DWORD PTR tv6699[esp+544], xmm3
	movss	xmm3, DWORD PTR _mProject$2$[esp+544]
	mulss	xmm3, xmm1
	mulss	xmm1, DWORD PTR _mProject$15[esp+556]
	movss	DWORD PTR _mProject$2$[esp+544], xmm3
	movaps	xmm3, xmm2
	mulss	xmm3, DWORD PTR _mProject$15[esp+568]
	mulss	xmm2, DWORD PTR _mProject$15[esp+572]
	movss	DWORD PTR tv6889[esp+544], xmm3
	movaps	xmm3, xmm0
	mulss	xmm0, DWORD PTR _mProject$15[esp+588]
	addss	xmm2, xmm1
	mulss	xmm3, DWORD PTR _mProject$15[esp+584]
	addss	xmm5, xmm0
	mulss	xmm4, DWORD PTR _mProject$15[esp+600]
	movss	xmm0, DWORD PTR _mView$17[esp+552]
	mulss	xmm0, DWORD PTR _mProject$15[esp+576]
	movaps	xmm1, xmm5
	movss	DWORD PTR _mView$16$[esp+544], xmm5
	movss	xmm5, DWORD PTR _mView$4$[esp+544]
	addss	xmm1, xmm2
	mulss	xmm5, DWORD PTR _mProject$15[esp+592]
	movss	xmm2, DWORD PTR tv6678[esp+544]
	addss	xmm5, xmm2
	movss	DWORD PTR _mView$16$[esp+544], xmm1
	addss	xmm5, xmm0
	movss	xmm0, DWORD PTR _mView$17[esp+548]
	mulss	xmm0, DWORD PTR _mProject$15[esp+560]
	movss	DWORD PTR _mView$1$[esp+544], xmm0
	movss	xmm0, DWORD PTR _mProject$15[esp+544]
	mulss	xmm0, DWORD PTR _mView$17[esp+544]
	movss	xmm1, DWORD PTR _mView$1$[esp+544]
	addss	xmm1, xmm0

; 86   : 		m[0][1] = A.m[0][1] * B.m[0][0] + A.m[1][1] * B.m[0][1] + A.m[2][1] * B.m[0][2] + A.m[3][1] * B.m[0][3];

	movaps	xmm0, xmm2
	mulss	xmm0, DWORD PTR __real@3f004000
	addss	xmm5, xmm1

; 85   : 		m[0][0] = A.m[0][0] * B.m[0][0] + A.m[1][0] * B.m[0][1] + A.m[2][0] * B.m[0][2] + A.m[3][0] * B.m[0][3];

	movss	DWORD PTR _mView$1$[esp+544], xmm1

; 86   : 		m[0][1] = A.m[0][1] * B.m[0][0] + A.m[1][1] * B.m[0][1] + A.m[2][1] * B.m[0][2] + A.m[3][1] * B.m[0][3];

	movss	xmm1, DWORD PTR tv6674[esp+544]
	addss	xmm1, DWORD PTR tv6843[esp+544]
	mulss	xmm5, DWORD PTR __real@3f000000
	movss	DWORD PTR [esi+16], xmm5
	movss	xmm5, DWORD PTR tv6673[esp+544]
	addss	xmm5, DWORD PTR tv6844[esp+544]
	addss	xmm1, xmm5

; 76   : 		return *this;
; 77   : 	}
; 78   : 	IC	SelfRef	rotation	(const _quaternion<T> &Q);
; 79   : 	ICF	SelfRef	mk_xform	(const _quaternion<T> &Q, const Tvector &V);
; 80   : 
; 81   : 	// Multiply RES = A[4x4]*B[4x4] (WITH projection)
; 82   : 	ICF	SelfRef	mul			(const Self &A,const Self &B)
; 83   : 	{
; 84   : 		VERIFY	((this!=&A)&&(this!=&B));
; 85   : 		m[0][0] = A.m[0][0] * B.m[0][0] + A.m[1][0] * B.m[0][1] + A.m[2][0] * B.m[0][2] + A.m[3][0] * B.m[0][3];

	mulss	xmm1, DWORD PTR __real@3f000000

; 87   : 		m[0][2] = A.m[0][2] * B.m[0][0] + A.m[1][2] * B.m[0][1] + A.m[2][2] * B.m[0][2] + A.m[3][2] * B.m[0][3];

	movss	xmm5, DWORD PTR tv6677[esp+544]
	addss	xmm5, DWORD PTR tv6847[esp+544]

; 86   : 		m[0][1] = A.m[0][1] * B.m[0][0] + A.m[1][1] * B.m[0][1] + A.m[2][1] * B.m[0][2] + A.m[3][1] * B.m[0][3];

	subss	xmm0, xmm1

; 88   : 		m[0][3] = A.m[0][3] * B.m[0][0] + A.m[1][3] * B.m[0][1] + A.m[2][3] * B.m[0][2] + A.m[3][3] * B.m[0][3];

	movss	DWORD PTR [esi+28], xmm2

; 90   : 		m[1][0] = A.m[0][0] * B.m[1][0] + A.m[1][0] * B.m[1][1] + A.m[2][0] * B.m[1][2] + A.m[3][0] * B.m[1][3];

	movss	xmm2, DWORD PTR tv6679[esp+544]
	addss	xmm2, DWORD PTR tv6854[esp+544]
	movss	xmm1, DWORD PTR __real@3f000000

; 101  : 		m[3][1] = A.m[0][1] * B.m[3][0] + A.m[1][1] * B.m[3][1] + A.m[2][1] * B.m[3][2] + A.m[3][1] * B.m[3][3];

	addss	xmm7, DWORD PTR tv6888[esp+544]
	movss	DWORD PTR [esi+20], xmm0

; 87   : 		m[0][2] = A.m[0][2] * B.m[0][0] + A.m[1][2] * B.m[0][1] + A.m[2][2] * B.m[0][2] + A.m[3][2] * B.m[0][3];

	movss	xmm0, DWORD PTR tv6676[esp+544]
	addss	xmm0, DWORD PTR tv6850[esp+544]
	addss	xmm5, xmm0

; 89   : 
; 90   : 		m[1][0] = A.m[0][0] * B.m[1][0] + A.m[1][0] * B.m[1][1] + A.m[2][0] * B.m[1][2] + A.m[3][0] * B.m[1][3];

	movss	xmm0, DWORD PTR tv6680[esp+544]
	addss	xmm0, DWORD PTR _mView$8$[esp+544]

; 87   : 		m[0][2] = A.m[0][2] * B.m[0][0] + A.m[1][2] * B.m[0][1] + A.m[2][2] * B.m[0][2] + A.m[3][2] * B.m[0][3];

	movss	DWORD PTR [esi+24], xmm5

; 90   : 		m[1][0] = A.m[0][0] * B.m[1][0] + A.m[1][0] * B.m[1][1] + A.m[2][0] * B.m[1][2] + A.m[3][0] * B.m[1][3];

	addss	xmm0, DWORD PTR tv6855[esp+544]

; 91   : 		m[1][1] = A.m[0][1] * B.m[1][0] + A.m[1][1] * B.m[1][1] + A.m[2][1] * B.m[1][2] + A.m[3][1] * B.m[1][3];

	movss	xmm5, DWORD PTR tv6682[esp+544]
	addss	xmm5, DWORD PTR tv6858[esp+544]
	addss	xmm0, xmm2
	movss	xmm2, DWORD PTR tv6681[esp+544]
	addss	xmm2, DWORD PTR tv6860[esp+544]
	mulss	xmm0, xmm1
	addss	xmm5, xmm2

; 92   : 		m[1][2] = A.m[0][2] * B.m[1][0] + A.m[1][2] * B.m[1][1] + A.m[2][2] * B.m[1][2] + A.m[3][2] * B.m[1][3];

	movss	xmm2, DWORD PTR tv6686[esp+544]
	addss	xmm2, DWORD PTR tv6861[esp+544]

; 90   : 		m[1][0] = A.m[0][0] * B.m[1][0] + A.m[1][0] * B.m[1][1] + A.m[2][0] * B.m[1][2] + A.m[3][0] * B.m[1][3];

	movss	DWORD PTR [esi+32], xmm0

; 91   : 		m[1][1] = A.m[0][1] * B.m[1][0] + A.m[1][1] * B.m[1][1] + A.m[2][1] * B.m[1][2] + A.m[3][1] * B.m[1][3];

	movss	xmm0, DWORD PTR _mView$8$[esp+544]
	mulss	xmm0, DWORD PTR __real@3f004000
	mulss	xmm5, xmm1
	subss	xmm0, xmm5

; 96   : 		m[2][1] = A.m[0][1] * B.m[2][0] + A.m[1][1] * B.m[2][1] + A.m[2][1] * B.m[2][2] + A.m[3][1] * B.m[2][3];

	movss	xmm5, DWORD PTR tv6691[esp+544]
	addss	xmm5, DWORD PTR tv6871[esp+544]
	movss	DWORD PTR [esi+36], xmm0

; 92   : 		m[1][2] = A.m[0][2] * B.m[1][0] + A.m[1][2] * B.m[1][1] + A.m[2][2] * B.m[1][2] + A.m[3][2] * B.m[1][3];

	movss	xmm0, DWORD PTR tv6685[esp+544]
	addss	xmm0, DWORD PTR tv6863[esp+544]
	addss	xmm2, xmm0

; 93   : 		m[1][3] = A.m[0][3] * B.m[1][0] + A.m[1][3] * B.m[1][1] + A.m[2][3] * B.m[1][2] + A.m[3][3] * B.m[1][3];

	movss	xmm0, DWORD PTR _mView$8$[esp+544]
	movss	DWORD PTR [esi+44], xmm0

; 95   : 		m[2][0] = A.m[0][0] * B.m[2][0] + A.m[1][0] * B.m[2][1] + A.m[2][0] * B.m[2][2] + A.m[3][0] * B.m[2][3];

	movss	xmm0, DWORD PTR _mView$12$[esp+544]
	addss	xmm0, DWORD PTR tv6870[esp+544]

; 92   : 		m[1][2] = A.m[0][2] * B.m[1][0] + A.m[1][2] * B.m[1][1] + A.m[2][2] * B.m[1][2] + A.m[3][2] * B.m[1][3];

	movss	DWORD PTR [esi+40], xmm2

; 95   : 		m[2][0] = A.m[0][0] * B.m[2][0] + A.m[1][0] * B.m[2][1] + A.m[2][0] * B.m[2][2] + A.m[3][0] * B.m[2][3];

	movss	xmm2, DWORD PTR tv6688[esp+544]
	addss	xmm2, DWORD PTR tv6868[esp+544]
	addss	xmm0, DWORD PTR tv6869[esp+544]
	addss	xmm0, xmm2

; 96   : 		m[2][1] = A.m[0][1] * B.m[2][0] + A.m[1][1] * B.m[2][1] + A.m[2][1] * B.m[2][2] + A.m[3][1] * B.m[2][3];

	movss	xmm2, DWORD PTR tv6690[esp+544]
	addss	xmm2, DWORD PTR tv6874[esp+544]
	mulss	xmm0, xmm1
	addss	xmm5, xmm2

; 97   : 		m[2][2] = A.m[0][2] * B.m[2][0] + A.m[1][2] * B.m[2][1] + A.m[2][2] * B.m[2][2] + A.m[3][2] * B.m[2][3];

	movss	xmm2, DWORD PTR tv6693[esp+544]
	addss	xmm2, DWORD PTR tv6875[esp+544]

; 95   : 		m[2][0] = A.m[0][0] * B.m[2][0] + A.m[1][0] * B.m[2][1] + A.m[2][0] * B.m[2][2] + A.m[3][0] * B.m[2][3];

	movss	DWORD PTR [esi+48], xmm0

; 96   : 		m[2][1] = A.m[0][1] * B.m[2][0] + A.m[1][1] * B.m[2][1] + A.m[2][1] * B.m[2][2] + A.m[3][1] * B.m[2][3];

	movss	xmm0, DWORD PTR _mView$12$[esp+544]
	mulss	xmm0, DWORD PTR __real@3f004000
	mulss	xmm5, xmm1

; 100  : 		m[3][0] = A.m[0][0] * B.m[3][0] + A.m[1][0] * B.m[3][1] + A.m[2][0] * B.m[3][2] + A.m[3][0] * B.m[3][3];

	movss	xmm1, DWORD PTR tv6696[esp+544]
	addss	xmm1, DWORD PTR tv6882[esp+544]

; 96   : 		m[2][1] = A.m[0][1] * B.m[2][0] + A.m[1][1] * B.m[2][1] + A.m[2][1] * B.m[2][2] + A.m[3][1] * B.m[2][3];

	subss	xmm0, xmm5
	movss	DWORD PTR [esi+52], xmm0

; 97   : 		m[2][2] = A.m[0][2] * B.m[2][0] + A.m[1][2] * B.m[2][1] + A.m[2][2] * B.m[2][2] + A.m[3][2] * B.m[2][3];

	movss	xmm0, DWORD PTR tv6694[esp+544]
	addss	xmm0, DWORD PTR tv6877[esp+544]
	addss	xmm0, xmm2

; 101  : 		m[3][1] = A.m[0][1] * B.m[3][0] + A.m[1][1] * B.m[3][1] + A.m[2][1] * B.m[3][2] + A.m[3][1] * B.m[3][3];

	movss	xmm2, DWORD PTR _mView$16$[esp+544]
	movss	DWORD PTR [esi+56], xmm0
	movss	xmm0, DWORD PTR _mView$12$[esp+544]
	movss	DWORD PTR [esi+60], xmm0

; 100  : 		m[3][0] = A.m[0][0] * B.m[3][0] + A.m[1][0] * B.m[3][1] + A.m[2][0] * B.m[3][2] + A.m[3][0] * B.m[3][3];

	movss	xmm0, DWORD PTR tv6697[esp+544]
	addss	xmm0, DWORD PTR _mView$16$[esp+544]
	addss	xmm0, DWORD PTR tv6883[esp+544]
	addss	xmm0, xmm1

; 101  : 		m[3][1] = A.m[0][1] * B.m[3][0] + A.m[1][1] * B.m[3][1] + A.m[2][1] * B.m[3][2] + A.m[3][1] * B.m[3][3];

	movss	xmm1, DWORD PTR tv6699[esp+544]
	addss	xmm1, DWORD PTR _mProject$2$[esp+544]
	mulss	xmm0, DWORD PTR __real@3f000000
	addss	xmm1, xmm7
	movss	DWORD PTR [esi+64], xmm0
	movaps	xmm0, xmm2
	mulss	xmm0, DWORD PTR __real@3f004000
	mulss	xmm1, DWORD PTR __real@3f000000
	subss	xmm0, xmm1
	movss	DWORD PTR [esi+68], xmm0

; 102  : 		m[3][2] = A.m[0][2] * B.m[3][0] + A.m[1][2] * B.m[3][1] + A.m[2][2] * B.m[3][2] + A.m[3][2] * B.m[3][3];

	addss	xmm6, DWORD PTR tv6889[esp+544]

; 103  : 		m[3][3] = A.m[0][3] * B.m[3][0] + A.m[1][3] * B.m[3][1] + A.m[2][3] * B.m[3][2] + A.m[3][3] * B.m[3][3];

	movss	DWORD PTR [esi+76], xmm2

; 102  : 		m[3][2] = A.m[0][2] * B.m[3][0] + A.m[1][2] * B.m[3][1] + A.m[2][2] * B.m[3][2] + A.m[3][2] * B.m[3][3];

	addss	xmm4, xmm3
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightProjector.cpp

; 274  : 		R.UVgen.mulA_44			(mTemp);

	lea	eax, DWORD PTR _mTemp$16[esp+544]
	push	eax
	lea	ecx, DWORD PTR [esi+16]
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 102  : 		m[3][2] = A.m[0][2] * B.m[3][0] + A.m[1][2] * B.m[3][1] + A.m[2][2] * B.m[3][2] + A.m[3][2] * B.m[3][3];

	addss	xmm4, xmm6
	movss	DWORD PTR [esi+72], xmm4

; 72   : 		_11=1; _12=0; _13=0; _14=0;

	mov	DWORD PTR _mTemp$16[esp+552], 0
	mov	DWORD PTR _mTemp$16[esp+556], 0
	mov	DWORD PTR _mTemp$16[esp+560], 0

; 73   : 		_21=0; _22=1; _23=0; _24=0;

	mov	DWORD PTR _mTemp$16[esp+564], 0
	mov	DWORD PTR _mTemp$16[esp+572], 0
	mov	DWORD PTR _mTemp$16[esp+576], 0

; 74   : 		_31=0; _32=0; _33=1; _34=0;

	mov	DWORD PTR _mTemp$16[esp+580], 0
	mov	DWORD PTR _mTemp$16[esp+584], 0
	mov	DWORD PTR _mTemp$16[esp+592], 0

; 75   : 		_41=0; _42=0; _43=0; _44=1;

	mov	DWORD PTR _mTemp$16[esp+596], 0
	mov	DWORD PTR _mTemp$16[esp+600], 0
	mov	DWORD PTR _mTemp$16[esp+604], 0
	mov	DWORD PTR _mTemp$16[esp+608], 1065353216 ; 3f800000H

; 260  : 		identity(); m[0][0]=x; m[1][1]=y; m[2][2]=z; 

	mov	DWORD PTR _mTemp$16[esp+548], 1036779520 ; 3dcc0000H
	mov	DWORD PTR _mTemp$16[esp+568], 1036779520 ; 3dcc0000H
	mov	DWORD PTR _mTemp$16[esp+588], 1065353216 ; 3f800000H
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightProjector.cpp

; 274  : 		R.UVgen.mulA_44			(mTemp);

	call	?mulA_44@?$_matrix@M@@QAEAAU1@ABU1@@Z	; _matrix<float>::mulA_44
	cvtsi2ss xmm0, DWORD PTR tv6918[esp+544]

; 276  : 		R.UVgen.mulA_44			(mTemp);

	lea	eax, DWORD PTR _mTemp$16[esp+544]
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 72   : 		_11=1; _12=0; _13=0; _14=0;

	mov	DWORD PTR _mTemp$16[esp+544], 1065353216 ; 3f800000H
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightProjector.cpp

; 276  : 		R.UVgen.mulA_44			(mTemp);

	push	eax
	lea	ecx, DWORD PTR [esi+16]
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 72   : 		_11=1; _12=0; _13=0; _14=0;

	mov	DWORD PTR _mTemp$16[esp+552], 0
	mov	DWORD PTR _mTemp$16[esp+556], 0
	mov	DWORD PTR _mTemp$16[esp+560], 0

; 73   : 		_21=0; _22=1; _23=0; _24=0;

	mov	DWORD PTR _mTemp$16[esp+564], 0
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightProjector.cpp

; 262  : 		float					fSlotX			= float(s_x*P_o_size)/float(P_rt_size);

	mulss	xmm0, DWORD PTR __real@3b000000
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 73   : 		_21=0; _22=1; _23=0; _24=0;

	mov	DWORD PTR _mTemp$16[esp+568], 1065353216 ; 3f800000H
	mov	DWORD PTR _mTemp$16[esp+572], 0
	mov	DWORD PTR _mTemp$16[esp+576], 0
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightProjector.cpp

; 275  : 		mTemp.translate			(fSlotX+fTexelOffs,fSlotY+fTexelOffs,0);

	addss	xmm0, DWORD PTR __real@3a800000
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 74   : 		_31=0; _32=0; _33=1; _34=0;

	mov	DWORD PTR _mTemp$16[esp+580], 0
	mov	DWORD PTR _mTemp$16[esp+584], 0
	mov	DWORD PTR _mTemp$16[esp+588], 1065353216 ; 3f800000H
	mov	DWORD PTR _mTemp$16[esp+592], 0
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 23   : 	ICF	SelfRef	set(T _x, T _y, T _z)					{ x = _x;		y = _y;		z = _z;		return *this;	};

	movss	DWORD PTR _mTemp$16[esp+596], xmm0
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightProjector.cpp

; 263  : 		float					fSlotY			= float(s_y*P_o_size)/float(P_rt_size);

	cvtsi2ss xmm0, DWORD PTR tv6917[esp+548]
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 75   : 		_41=0; _42=0; _43=0; _44=1;

	mov	DWORD PTR _mTemp$16[esp+608], 1065353216 ; 3f800000H
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 23   : 	ICF	SelfRef	set(T _x, T _y, T _z)					{ x = _x;		y = _y;		z = _z;		return *this;	};

	mov	DWORD PTR _mTemp$16[esp+604], 0
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightProjector.cpp

; 263  : 		float					fSlotY			= float(s_y*P_o_size)/float(P_rt_size);

	mulss	xmm0, DWORD PTR __real@3b000000

; 275  : 		mTemp.translate			(fSlotX+fTexelOffs,fSlotY+fTexelOffs,0);

	addss	xmm0, DWORD PTR __real@3a800000
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 23   : 	ICF	SelfRef	set(T _x, T _y, T _z)					{ x = _x;		y = _y;		z = _z;		return *this;	};

	movss	DWORD PTR _mTemp$16[esp+600], xmm0
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightProjector.cpp

; 276  : 		R.UVgen.mulA_44			(mTemp);

	call	?mulA_44@?$_matrix@M@@QAEAAU1@ABU1@@Z	; _matrix<float>::mulA_44

; 277  : 
; 278  : 		// Build bbox and render
; 279  : 		Fvector					min,max;
; 280  : 		Fbox					BB;
; 281  : 		min.set					(R.C.x-p_R,	R.C.y-(p_R+P_cam_range),	R.C.z-p_R);

	movss	xmm6, DWORD PTR _p_R$1$[esp+544]
	movss	xmm4, DWORD PTR [ebx+edi+8]
	movaps	xmm0, xmm6
	addss	xmm0, DWORD PTR __real@40e00000
	movss	xmm5, DWORD PTR [ebx+edi+4]
	movaps	xmm1, xmm4
	movss	xmm3, DWORD PTR [ebx+edi+12]
	movaps	xmm2, xmm5
	subss	xmm2, xmm6
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 24   : 	ICF SelfRef	set(const _vector3<float> &v)			{ x = T(v.x);	y = T(v.y);	z = T(v.z);	return *this;	};

	movss	DWORD PTR _BB$22[esp+560], xmm4
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightProjector.cpp

; 282  : 		max.set					(R.C.x+p_R,	R.C.y+0,					R.C.z+p_R);

	addss	xmm5, xmm6
	subss	xmm1, xmm0
	movaps	xmm0, xmm3
	subss	xmm0, xmm6
	addss	xmm3, xmm6
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 30   : 	ICF SelfRef	add(T s)								{ x+=s;		y+=s;		z+=s;			return *this;	};

	movss	xmm6, DWORD PTR __real@3d4ccccd

; 24   : 	ICF SelfRef	set(const _vector3<float> &v)			{ x = T(v.x);	y = T(v.y);	z = T(v.z);	return *this;	};

	movss	DWORD PTR _BB$22[esp+544], xmm2

; 35   : 	ICF SelfRef	sub(T s)								{ x-=s;		y-=s;		z-=s;			return *this;	};

	subss	xmm4, xmm6

; 24   : 	ICF SelfRef	set(const _vector3<float> &v)			{ x = T(v.x);	y = T(v.y);	z = T(v.z);	return *this;	};

	movss	DWORD PTR _BB$22[esp+556], xmm5

; 30   : 	ICF SelfRef	add(T s)								{ x+=s;		y+=s;		z+=s;			return *this;	};

	addss	xmm2, xmm6

; 24   : 	ICF SelfRef	set(const _vector3<float> &v)			{ x = T(v.x);	y = T(v.y);	z = T(v.z);	return *this;	};

	movss	DWORD PTR _BB$22[esp+548], xmm1

; 35   : 	ICF SelfRef	sub(T s)								{ x-=s;		y-=s;		z-=s;			return *this;	};

	subss	xmm5, xmm6

; 24   : 	ICF SelfRef	set(const _vector3<float> &v)			{ x = T(v.x);	y = T(v.y);	z = T(v.z);	return *this;	};

	movss	DWORD PTR _BB$22[esp+552], xmm0

; 30   : 	ICF SelfRef	add(T s)								{ x+=s;		y+=s;		z+=s;			return *this;	};

	addss	xmm1, xmm6
	addss	xmm0, xmm6

; 24   : 	ICF SelfRef	set(const _vector3<float> &v)			{ x = T(v.x);	y = T(v.y);	z = T(v.z);	return *this;	};

	movss	DWORD PTR _BB$22[esp+564], xmm3

; 30   : 	ICF SelfRef	add(T s)								{ x+=s;		y+=s;		z+=s;			return *this;	};

	movss	DWORD PTR [ebx+edi+80], xmm2

; 35   : 	ICF SelfRef	sub(T s)								{ x-=s;		y-=s;		z-=s;			return *this;	};

	movss	DWORD PTR [ebx+edi+92], xmm5

; 30   : 	ICF SelfRef	add(T s)								{ x+=s;		y+=s;		z+=s;			return *this;	};

	movss	DWORD PTR [ebx+edi+84], xmm1
	movss	DWORD PTR [ebx+edi+88], xmm0
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightProjector.cpp

; 286  : 		ISpatial*	spatial		= dynamic_cast<ISpatial*>	(O);

	push	0
	push	OFFSET ??_R0?AVISpatial@@@8
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 35   : 	ICF SelfRef	sub(T s)								{ x-=s;		y-=s;		z-=s;			return *this;	};

	subss	xmm3, xmm6
	movss	DWORD PTR [ebx+edi+96], xmm4
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightProjector.cpp

; 286  : 		ISpatial*	spatial		= dynamic_cast<ISpatial*>	(O);

	push	OFFSET ??_R0?AVIRenderable@@@8
	push	0
	push	DWORD PTR _O$1$[esp+560]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 35   : 	ICF SelfRef	sub(T s)								{ x-=s;		y-=s;		z-=s;			return *this;	};

	movss	DWORD PTR [ebx+edi+100], xmm3
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightProjector.cpp

; 286  : 		ISpatial*	spatial		= dynamic_cast<ISpatial*>	(O);

	call	___RTDynamicCast
	mov	esi, eax
	add	esp, 20					; 00000014H

; 287  : 		if (spatial)			{

	test	esi, esi
	je	SHORT $LN502@calculate
; File I:\Vitalya\mine\NSProjectX\xrEngine\ispatial.h

; 87   : 		if (0 == (spatial.type & STYPEFLAG_INVALIDSECTOR))	return;

	test	DWORD PTR [esi+4], 65536		; 00010000H
	je	SHORT $LN479@calculate

; 88   : 		spatial_updatesector_internal();

	mov	ecx, esi
	call	DWORD PTR tv6966[esp+544]
$LN479@calculate:
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightProjector.cpp

; 289  : 			if (spatial->spatial.sector)			RImplementation.r_dsgraph_render_R1_box	(spatial->spatial.sector,BB,SE_R1_LMODELS);

	mov	eax, DWORD PTR [esi+44]
	test	eax, eax
	je	SHORT $LN502@calculate
	push	ecx
	lea	ecx, DWORD PTR _BB$22[esp+548]
	push	ecx
	push	eax
	mov	ecx, OFFSET ?RImplementation@@3VCRender@@A ; RImplementation
	call	?r_dsgraph_render_R1_box@R_dsgraph_structure@@QAEXPAVIRender_Sector@@AAV?$_box3@M@@H@Z ; R_dsgraph_structure::r_dsgraph_render_R1_box
$LN502@calculate:

; 162  : 	for (u32 c_it=0; c_it<cache.size(); c_it++)

	mov	ebp, DWORD PTR _this$1$[esp+544]
$LN5@calculate:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	esi, DWORD PTR [ebp+8]
	mov	eax, 2021161081				; 78787879H
	mov	ecx, DWORD PTR [ebp+12]
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightProjector.cpp

; 162  : 	for (u32 c_it=0; c_it<cache.size(); c_it++)

	add	edi, 136				; 00000088H
	inc	DWORD PTR _c_it$1$[esp+544]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	sub	ecx, esi
	imul	ecx
	mov	ebx, esi
	sar	edx, 6
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightProjector.cpp

; 162  : 	for (u32 c_it=0; c_it<cache.size(); c_it++)

	cmp	DWORD PTR _c_it$1$[esp+544], eax
	jb	$LL7@calculate
$LN500@calculate:

; 290  : 		}
; 291  : 		//if (spatial)		RImplementation.r_dsgraph_render_subspace	(spatial->spatial.sector,mCombine,v_C,FALSE);
; 292  : 	}
; 293  : 
; 294  : 	// Blur
; 295  : 	/*
; 296  : 	{
; 297  : 		// Fill vertex buffer
; 298  : 		u32							Offset;
; 299  : 		FVF::TL4uv* pv				= (FVF::TL4uv*) RCache.Vertex.Lock	(4,geom_Blur.stride(),Offset);
; 300  : 		RImplementation.ApplyBlur4	(pv,P_rt_size,P_rt_size,P_blur_kernel);
; 301  : 		RCache.Vertex.Unlock		(4,geom_Blur.stride());
; 302  : 
; 303  : 		// Actual rendering (pass0, temp2real)
; 304  : 		RCache.set_RT				(RT->pRT);
; 305  : 		RCache.set_ZB				(NULL);
; 306  : 		RCache.set_Shader			(sh_BlurTR	);
; 307  : 		RCache.set_Geometry			(geom_Blur	);
; 308  : 		RCache.Render				(D3DPT_TRIANGLELIST,Offset,0,4,0,2);
; 309  : 	}
; 310  : 	*/
; 311  : 
; 312  : 	// Finita la comedia
; 313  : 	Device.Statistic->RenderDUMP_Pcalc.End	();

	mov	eax, DWORD PTR __imp_?Device@@3VCRenderDevice@@A
	mov	esi, DWORD PTR [eax+436]
; File I:\Vitalya\mine\NSProjectX\xrCore\FTimer.h

; 174  : 	ICF void	End				()		{	if (!g_bEnableStatGather) return;	accum += T.GetElapsed_ticks();	}

	mov	eax, DWORD PTR __imp_?g_bEnableStatGather@@3HA
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN482@calculate
	lea	ecx, DWORD PTR [esi+2496]
	call	DWORD PTR __imp_?GetElapsed_ticks@CTimer@@QBE_KXZ
	add	DWORD PTR [esi+2552], eax
	adc	DWORD PTR [esi+2556], edx
$LN482@calculate:
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightProjector.cpp

; 315  : 	RCache.set_xform_project	(Device.mProject);

	mov	eax, DWORD PTR __imp_?Device@@3VCRenderDevice@@A
	mov	ecx, DWORD PTR __imp_?RCache@@3VCBackend@@A
	add	eax, 600				; 00000258H
	push	eax
	call	DWORD PTR __imp_?set_xform_project@CBackend@@QAEXABU?$_matrix@M@@@Z

; 316  : 	RCache.set_xform_view		(Device.mView);

	mov	eax, DWORD PTR __imp_?Device@@3VCRenderDevice@@A
	mov	ecx, DWORD PTR __imp_?RCache@@3VCBackend@@A
	add	eax, 536				; 00000218H
	push	eax
	call	DWORD PTR __imp_?set_xform_view@CBackend@@QAEXABU?$_matrix@M@@@Z
$LN1@calculate:

; 317  : }

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?calculate@CLightProjector@@QAEXXZ ENDP			; CLightProjector::calculate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightProjector.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightProjector.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightProjector.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrEngine\R_Backend.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightProjector.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightProjector.cpp
; File I:\Vitalya\mine\NSProjectX\xrEngine\R_Backend.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightProjector.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightProjector.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightProjector.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_std_extensions.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightProjector.cpp
; File I:\Vitalya\mine\NSProjectX\xrEngine\R_Backend.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightProjector.cpp
; File I:\Vitalya\mine\NSProjectX\xrEngine\R_Backend.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File I:\Vitalya\mine\NSProjectX\xrEngine\R_Backend.h
; File I:\Vitalya\mine\NSProjectX\xrEngine\r_constants_cache.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightProjector.cpp
; File I:\Vitalya\mine\NSProjectX\xrEngine\R_Backend.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightProjector.cpp
; File I:\Vitalya\mine\NSProjectX\xrEngine\R_Backend.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightProjector.cpp
; File I:\Vitalya\mine\NSProjectX\xrEngine\R_Backend.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File I:\Vitalya\mine\NSProjectX\xrEngine\R_Backend.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector4.h
; File I:\Vitalya\mine\NSProjectX\xrEngine\r_constants_cache.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector4.h
; File I:\Vitalya\mine\NSProjectX\xrEngine\r_constants_cache.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector4.h
; File I:\Vitalya\mine\NSProjectX\xrEngine\r_constants_cache.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightProjector.cpp
; File I:\Vitalya\mine\NSProjectX\xrEngine\R_Backend.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightProjector.cpp
; File I:\Vitalya\mine\NSProjectX\xrEngine\R_Backend.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightProjector.cpp
; File I:\Vitalya\mine\NSProjectX\xrEngine\R_Backend.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File I:\Vitalya\mine\NSProjectX\xrEngine\R_Backend.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector4.h
; File I:\Vitalya\mine\NSProjectX\xrEngine\r_constants_cache.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector4.h
; File I:\Vitalya\mine\NSProjectX\xrEngine\r_constants_cache.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector4.h
; File I:\Vitalya\mine\NSProjectX\xrEngine\r_constants_cache.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightProjector.cpp
_TEXT	SEGMENT
_y$1$ = -32						; size = 4
_z$1$ = -28						; size = 4
$T1 = -28						; size = 4
_z$1$ = -24						; size = 4
_factor$1$ = -24					; size = 4
_y$1$ = -20						; size = 4
$T2 = -20						; size = 4
_data$3 = -16						; size = 16
_data$4 = -16						; size = 16
_x$1$ = 8						; size = 4
_x$1$ = 8						; size = 4
$T5 = 8							; size = 4
_id$ = 8						; size = 4
?setup@CLightProjector@@QAEXH@Z PROC			; CLightProjector::setup
; _this$ = ecx

; 92   : {

	sub	esp, 32					; 00000020H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	eax, 2021161081				; 78787879H
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightProjector.cpp

; 92   : {

	push	ebp
	mov	ebp, ecx

; 93   : 	if (id>=int(cache.size()) || id<0)	{

	mov	ecx, DWORD PTR _id$[esp+32]
	push	esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	edx, DWORD PTR [ebp+12]
	mov	esi, DWORD PTR [ebp+8]
	sub	edx, esi
	imul	edx
	sar	edx, 6
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightProjector.cpp

; 93   : 	if (id>=int(cache.size()) || id<0)	{

	cmp	ecx, eax
	jge	$LN3@setup
	test	ecx, ecx
	js	$LN3@setup
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 119  :         _Ptr += _Off;

	push	ebx
	imul	ebx, ecx, 136
	add	ebx, esi
; File I:\Vitalya\mine\NSProjectX\xrEngine\R_Backend.h

; 205  : 	ICF	void						set_c(shared_str& n, const Fmatrix& A) { if (ctable)	set_c(&*ctable->get(n), A); }

	mov	edx, DWORD PTR __imp_?get@R_constant_table@@QAE?AV?$resptr_core@UR_constant@@V?$resptr_base@UR_constant@@@@@@AAVshared_str@@@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 119  :         _Ptr += _Off;

	push	edi
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightProjector.cpp

; 101  : 	RCache.set_c	(c_xform,	R.UVgen);

	mov	edi, DWORD PTR __imp_?RCache@@3VCBackend@@A
	mov	eax, DWORD PTR [ebx]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 287  : 	{	return (x-v.x)*(x-v.x) + (y-v.y)*(y-v.y) + (z-v.z)*(z-v.z);	}

	movss	xmm1, DWORD PTR [ebx+8]
	movss	xmm2, DWORD PTR [ebx+4]
	movss	xmm0, DWORD PTR [ebx+12]
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightProjector.cpp

; 98   : 	float			Rd			= R.O->renderable.visual->vis.sphere.R;

	mov	eax, DWORD PTR [eax+68]
; File I:\Vitalya\mine\NSProjectX\xrEngine\R_Backend.h

; 205  : 	ICF	void						set_c(shared_str& n, const Fmatrix& A) { if (ctable)	set_c(&*ctable->get(n), A); }

	mov	ecx, DWORD PTR [edi+8864]
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightProjector.cpp

; 98   : 	float			Rd			= R.O->renderable.visual->vis.sphere.R;

	movss	xmm3, DWORD PTR [eax+20]

; 99   : 	float			dist		= R.C.distance_to	(Device.vCameraPosition)+Rd;

	mov	eax, DWORD PTR __imp_?Device@@3VCRenderDevice@@A
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 287  : 	{	return (x-v.x)*(x-v.x) + (y-v.y)*(y-v.y) + (z-v.z)*(z-v.z);	}

	subss	xmm2, DWORD PTR [eax+488]
	subss	xmm1, DWORD PTR [eax+492]
	subss	xmm0, DWORD PTR [eax+496]
	mulss	xmm2, xmm2
	mulss	xmm1, xmm1
	mulss	xmm0, xmm0
	addss	xmm2, xmm1
	addss	xmm2, xmm0
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightProjector.cpp

; 100  : 	float			factor		= _sqr(dist/clipD(Rd))*(1-ps_r1_lmodel_lerp) + ps_r1_lmodel_lerp;

	movss	xmm0, DWORD PTR __real@3ca3d70a
	divss	xmm0, xmm3
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h

; 764  :             return (float)sqrt(_X);

	sqrtss	xmm2, xmm2
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightProjector.cpp

; 99   : 	float			dist		= R.C.distance_to	(Device.vCameraPosition)+Rd;

	addss	xmm2, xmm3

; 100  : 	float			factor		= _sqr(dist/clipD(Rd))*(1-ps_r1_lmodel_lerp) + ps_r1_lmodel_lerp;

	mulss	xmm2, xmm0
	movss	xmm0, DWORD PTR __real@3f800000
	subss	xmm0, DWORD PTR ?ps_r1_lmodel_lerp@@3MA
; File I:\Vitalya\mine\NSProjectX\xrCore\_std_extensions.h

; 95   : template <class T>	IC T		_sqr	(T a)		{ return a*a;		}

	mulss	xmm2, xmm2
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightProjector.cpp

; 100  : 	float			factor		= _sqr(dist/clipD(Rd))*(1-ps_r1_lmodel_lerp) + ps_r1_lmodel_lerp;

	mulss	xmm2, xmm0
	addss	xmm2, DWORD PTR ?ps_r1_lmodel_lerp@@3MA
	movss	DWORD PTR _factor$1$[esp+48], xmm2
; File I:\Vitalya\mine\NSProjectX\xrEngine\R_Backend.h

; 205  : 	ICF	void						set_c(shared_str& n, const Fmatrix& A) { if (ctable)	set_c(&*ctable->get(n), A); }

	test	ecx, ecx
	je	SHORT $LN39@setup
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightProjector.cpp

; 101  : 	RCache.set_c	(c_xform,	R.UVgen);

	lea	eax, DWORD PTR [ebp+48]
; File I:\Vitalya\mine\NSProjectX\xrEngine\R_Backend.h

; 205  : 	ICF	void						set_c(shared_str& n, const Fmatrix& A) { if (ctable)	set_c(&*ctable->get(n), A); }

	push	eax
	lea	eax, DWORD PTR $T5[esp+48]
	push	eax
	call	edx
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 70   : 	T &					operator*() const												{	return *p_;	}

	mov	esi, DWORD PTR [eax]
; File I:\Vitalya\mine\NSProjectX\xrEngine\R_Backend.h

; 189  : 	ICF	void						set_c(R_constant* C, const Fmatrix& A) { if (C)		constants.set(C, A); }

	test	esi, esi
	je	SHORT $LN48@setup
; File I:\Vitalya\mine\NSProjectX\xrEngine\r_constants_cache.h

; 143  : 		if (C->destination & 1) { a_pixel.set(C, C->ps, A); a_pixel.b_dirty = TRUE; }

	movzx	eax, WORD PTR [esi+10]
	mov	ecx, eax
	test	al, 1
	je	SHORT $LN47@setup
	lea	eax, DWORD PTR [ebx+16]
	push	eax
	lea	eax, DWORD PTR [esi+12]
	push	eax
	push	esi
	lea	ecx, DWORD PTR [edi+608]
	call	?set@R_constant_array@@QAEXPAUR_constant@@AAUR_constant_load@@ABU?$_matrix@M@@@Z ; R_constant_array::set
	mov	DWORD PTR [edi+4720], 1
	movzx	ecx, WORD PTR [esi+10]
$LN47@setup:

; 144  : 		if (C->destination & 2) { a_vertex.set(C, C->vs, A); a_vertex.b_dirty = TRUE; }

	test	cl, 2
	je	SHORT $LN48@setup
	lea	eax, DWORD PTR [ebx+16]
	push	eax
	lea	eax, DWORD PTR [esi+16]
	push	eax
	push	esi
	lea	ecx, DWORD PTR [edi+4736]
	call	?set@R_constant_array@@QAEXPAUR_constant@@AAUR_constant_load@@ABU?$_matrix@M@@@Z ; R_constant_array::set
	mov	DWORD PTR [edi+8848], 1
$LN48@setup:
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 64   : 						~resptr_core	()												{	_dec();						}

	lea	ecx, DWORD PTR $T5[esp+44]
	call	?_dec@?$resptr_base@UR_constant@@@@IAEXXZ ; resptr_base<R_constant>::_dec
	mov	edi, DWORD PTR __imp_?RCache@@3VCBackend@@A
	mov	edx, DWORD PTR __imp_?get@R_constant_table@@QAE?AV?$resptr_core@UR_constant@@V?$resptr_base@UR_constant@@@@@@AAVshared_str@@@Z
$LN39@setup:
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightProjector.cpp

; 103  : 	RCache.set_ca	(c_clamp,	0,m.x,m.y,m.z,factor);

	movss	xmm0, DWORD PTR [ebx+80]
; File I:\Vitalya\mine\NSProjectX\xrEngine\R_Backend.h

; 210  : 	ICF	void						set_ca(shared_str& n, u32 e, float x, float y, float z, float w) { if (ctable)	set_ca(&*ctable->get(n), e, x, y, z, w); }

	mov	ecx, DWORD PTR [edi+8864]
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightProjector.cpp

; 103  : 	RCache.set_ca	(c_clamp,	0,m.x,m.y,m.z,factor);

	movss	DWORD PTR _x$1$[esp+44], xmm0
	movss	xmm0, DWORD PTR [ebx+84]
	movss	DWORD PTR _y$1$[esp+48], xmm0
	movss	xmm0, DWORD PTR [ebx+88]
	movss	DWORD PTR _z$1$[esp+48], xmm0
; File I:\Vitalya\mine\NSProjectX\xrEngine\R_Backend.h

; 210  : 	ICF	void						set_ca(shared_str& n, u32 e, float x, float y, float z, float w) { if (ctable)	set_ca(&*ctable->get(n), e, x, y, z, w); }

	test	ecx, ecx
	je	$LN73@setup
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightProjector.cpp

; 103  : 	RCache.set_ca	(c_clamp,	0,m.x,m.y,m.z,factor);

	lea	eax, DWORD PTR [ebp+52]
; File I:\Vitalya\mine\NSProjectX\xrEngine\R_Backend.h

; 210  : 	ICF	void						set_ca(shared_str& n, u32 e, float x, float y, float z, float w) { if (ctable)	set_ca(&*ctable->get(n), e, x, y, z, w); }

	push	eax
	lea	eax, DWORD PTR $T2[esp+52]
	push	eax
	call	edx
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 70   : 	T &					operator*() const												{	return *p_;	}

	mov	esi, DWORD PTR [eax]
; File I:\Vitalya\mine\NSProjectX\xrEngine\R_Backend.h

; 194  : 	ICF	void						set_ca(R_constant* C, u32 e, float x, float y, float z, float w) { if (C)		constants.seta(C, e, x, y, z, w); }

	test	esi, esi
	je	$LN86@setup
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector4.h

; 17   : 	IC	SelfRef 	set(T _x, T _y, T _z, T _w=1)		{ x=_x;		y=_y;		z=_z;		w=_w;		return *this; }

	movss	xmm0, DWORD PTR _x$1$[esp+44]
; File I:\Vitalya\mine\NSProjectX\xrEngine\r_constants_cache.h

; 161  : 		if (C->destination & 1) { a_pixel.seta(C, C->ps, e, A); a_pixel.b_dirty = TRUE; }

	movzx	eax, WORD PTR [esi+10]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector4.h

; 17   : 	IC	SelfRef 	set(T _x, T _y, T _z, T _w=1)		{ x=_x;		y=_y;		z=_z;		w=_w;		return *this; }

	movss	DWORD PTR _data$4[esp+48], xmm0
; File I:\Vitalya\mine\NSProjectX\xrEngine\r_constants_cache.h

; 161  : 		if (C->destination & 1) { a_pixel.seta(C, C->ps, e, A); a_pixel.b_dirty = TRUE; }

	mov	ecx, eax
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector4.h

; 17   : 	IC	SelfRef 	set(T _x, T _y, T _z, T _w=1)		{ x=_x;		y=_y;		z=_z;		w=_w;		return *this; }

	movss	xmm0, DWORD PTR _y$1$[esp+48]
	movss	DWORD PTR _data$4[esp+52], xmm0
	movss	xmm0, DWORD PTR _z$1$[esp+48]
	movss	DWORD PTR _data$4[esp+56], xmm0
	movss	xmm0, DWORD PTR _factor$1$[esp+48]
	movss	DWORD PTR _data$4[esp+60], xmm0
; File I:\Vitalya\mine\NSProjectX\xrEngine\r_constants_cache.h

; 161  : 		if (C->destination & 1) { a_pixel.seta(C, C->ps, e, A); a_pixel.b_dirty = TRUE; }

	test	al, 1
	je	SHORT $LN85@setup
	lea	eax, DWORD PTR _data$4[esp+48]
	push	eax
	push	0
	lea	eax, DWORD PTR [esi+12]
	push	eax
	push	esi
	lea	ecx, DWORD PTR [edi+608]
	call	?seta@R_constant_array@@QAEXPAUR_constant@@AAUR_constant_load@@IABU?$_vector4@M@@@Z ; R_constant_array::seta
	mov	DWORD PTR [edi+4720], 1
	movzx	ecx, WORD PTR [esi+10]
$LN85@setup:

; 162  : 		if (C->destination & 2) { a_vertex.seta(C, C->vs, e, A); a_vertex.b_dirty = TRUE; }

	test	cl, 2
	je	SHORT $LN86@setup
	lea	eax, DWORD PTR _data$4[esp+48]
	push	eax
	push	0
	lea	eax, DWORD PTR [esi+16]
	push	eax
	push	esi
	lea	ecx, DWORD PTR [edi+4736]
	call	?seta@R_constant_array@@QAEXPAUR_constant@@AAUR_constant_load@@IABU?$_vector4@M@@@Z ; R_constant_array::seta
	mov	DWORD PTR [edi+8848], 1
$LN86@setup:
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 64   : 						~resptr_core	()												{	_dec();						}

	lea	ecx, DWORD PTR $T2[esp+48]
	call	?_dec@?$resptr_base@UR_constant@@@@IAEXXZ ; resptr_base<R_constant>::_dec
	mov	edi, DWORD PTR __imp_?RCache@@3VCBackend@@A
$LN73@setup:
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightProjector.cpp

; 105  : 	RCache.set_ca	(c_clamp,	1,M.x,M.y,M.z,0);

	movss	xmm0, DWORD PTR [ebx+92]
; File I:\Vitalya\mine\NSProjectX\xrEngine\R_Backend.h

; 210  : 	ICF	void						set_ca(shared_str& n, u32 e, float x, float y, float z, float w) { if (ctable)	set_ca(&*ctable->get(n), e, x, y, z, w); }

	mov	ecx, DWORD PTR [edi+8864]
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightProjector.cpp

; 105  : 	RCache.set_ca	(c_clamp,	1,M.x,M.y,M.z,0);

	movss	DWORD PTR _x$1$[esp+44], xmm0
	movss	xmm0, DWORD PTR [ebx+96]
	movss	DWORD PTR _y$1$[esp+48], xmm0
	movss	xmm0, DWORD PTR [ebx+100]
	movss	DWORD PTR _z$1$[esp+48], xmm0
; File I:\Vitalya\mine\NSProjectX\xrEngine\R_Backend.h

; 210  : 	ICF	void						set_ca(shared_str& n, u32 e, float x, float y, float z, float w) { if (ctable)	set_ca(&*ctable->get(n), e, x, y, z, w); }

	test	ecx, ecx
	je	$LN232@setup
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightProjector.cpp

; 105  : 	RCache.set_ca	(c_clamp,	1,M.x,M.y,M.z,0);

	lea	eax, DWORD PTR [ebp+52]
; File I:\Vitalya\mine\NSProjectX\xrEngine\R_Backend.h

; 210  : 	ICF	void						set_ca(shared_str& n, u32 e, float x, float y, float z, float w) { if (ctable)	set_ca(&*ctable->get(n), e, x, y, z, w); }

	push	eax
	lea	eax, DWORD PTR $T1[esp+52]
	push	eax
	call	DWORD PTR __imp_?get@R_constant_table@@QAE?AV?$resptr_core@UR_constant@@V?$resptr_base@UR_constant@@@@@@AAVshared_str@@@Z
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 70   : 	T &					operator*() const												{	return *p_;	}

	mov	esi, DWORD PTR [eax]
; File I:\Vitalya\mine\NSProjectX\xrEngine\R_Backend.h

; 194  : 	ICF	void						set_ca(R_constant* C, u32 e, float x, float y, float z, float w) { if (C)		constants.seta(C, e, x, y, z, w); }

	test	esi, esi
	je	$LN166@setup
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector4.h

; 17   : 	IC	SelfRef 	set(T _x, T _y, T _z, T _w=1)		{ x=_x;		y=_y;		z=_z;		w=_w;		return *this; }

	movss	xmm0, DWORD PTR _x$1$[esp+44]
; File I:\Vitalya\mine\NSProjectX\xrEngine\r_constants_cache.h

; 161  : 		if (C->destination & 1) { a_pixel.seta(C, C->ps, e, A); a_pixel.b_dirty = TRUE; }

	movzx	eax, WORD PTR [esi+10]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector4.h

; 17   : 	IC	SelfRef 	set(T _x, T _y, T _z, T _w=1)		{ x=_x;		y=_y;		z=_z;		w=_w;		return *this; }

	movss	DWORD PTR _data$3[esp+48], xmm0
; File I:\Vitalya\mine\NSProjectX\xrEngine\r_constants_cache.h

; 161  : 		if (C->destination & 1) { a_pixel.seta(C, C->ps, e, A); a_pixel.b_dirty = TRUE; }

	mov	ecx, eax
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector4.h

; 17   : 	IC	SelfRef 	set(T _x, T _y, T _z, T _w=1)		{ x=_x;		y=_y;		z=_z;		w=_w;		return *this; }

	movss	xmm0, DWORD PTR _y$1$[esp+48]
	movss	DWORD PTR _data$3[esp+52], xmm0
	movss	xmm0, DWORD PTR _z$1$[esp+48]
	movss	DWORD PTR _data$3[esp+56], xmm0
	mov	DWORD PTR _data$3[esp+60], 0
; File I:\Vitalya\mine\NSProjectX\xrEngine\r_constants_cache.h

; 161  : 		if (C->destination & 1) { a_pixel.seta(C, C->ps, e, A); a_pixel.b_dirty = TRUE; }

	test	al, 1
	je	SHORT $LN165@setup
	lea	eax, DWORD PTR _data$3[esp+48]
	push	eax
	push	1
	lea	eax, DWORD PTR [esi+12]
	push	eax
	push	esi
	lea	ecx, DWORD PTR [edi+608]
	call	?seta@R_constant_array@@QAEXPAUR_constant@@AAUR_constant_load@@IABU?$_vector4@M@@@Z ; R_constant_array::seta
	mov	DWORD PTR [edi+4720], 1
	movzx	ecx, WORD PTR [esi+10]
$LN165@setup:

; 162  : 		if (C->destination & 2) { a_vertex.seta(C, C->vs, e, A); a_vertex.b_dirty = TRUE; }

	test	cl, 2
	je	SHORT $LN166@setup
	lea	eax, DWORD PTR _data$3[esp+48]
	push	eax
	push	1
	lea	eax, DWORD PTR [esi+16]
	push	eax
	push	esi
	lea	ecx, DWORD PTR [edi+4736]
	call	?seta@R_constant_array@@QAEXPAUR_constant@@AAUR_constant_load@@IABU?$_vector4@M@@@Z ; R_constant_array::seta
	mov	DWORD PTR [edi+8848], 1
$LN166@setup:
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 64   : 						~resptr_core	()												{	_dec();						}

	lea	ecx, DWORD PTR $T1[esp+48]
	call	?_dec@?$resptr_base@UR_constant@@@@IAEXXZ ; resptr_base<R_constant>::_dec
$LN232@setup:
	pop	edi
	pop	ebx
$LN3@setup:
	pop	esi
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightProjector.cpp

; 106  : }

	pop	ebp
	add	esp, 32					; 00000020H
	ret	4
?setup@CLightProjector@@QAEXH@Z ENDP			; CLightProjector::setup
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightProjector.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightProjector.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightProjector.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightProjector.cpp
; File I:\Vitalya\mine\NSProjectX\xrEngine\ispatial.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightProjector.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xrstring.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightProjector.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightProjector.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightProjector.cpp
_TEXT	SEGMENT
tv791 = -4						; size = 4
$T2 = 8							; size = 4
_O$ = 8							; size = 4
?set_object@CLightProjector@@QAEXPAVIRenderable@@@Z PROC ; CLightProjector::set_object
; _this$ = ecx

; 53   : {

	push	ecx
	push	ebx
	push	ebp
	push	esi

; 54   : 	if ((0==O) || (receivers.size()>=P_o_count))	current		= 0;

	mov	esi, DWORD PTR _O$[esp+12]
	mov	ebx, ecx
	push	edi
	test	esi, esi
	je	$LN4@set_object
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	eax, DWORD PTR [ebx+24]
	lea	edi, DWORD PTR [ebx+20]
	sub	eax, DWORD PTR [edi]
	sar	eax, 2
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightProjector.cpp

; 54   : 	if ((0==O) || (receivers.size()>=P_o_count))	current		= 0;

	cmp	eax, 100				; 00000064H
	jae	$LN4@set_object

; 55   : 	else
; 56   : 	{
; 57   : 		if (!O->renderable_ShadowReceive() || RImplementation.val_bInvisible || ((CROS_impl*)O->renderable_ROS())->shadow_recv_frame==Device.dwFrame)	

	mov	eax, DWORD PTR [esi]
	mov	ecx, esi
	call	DWORD PTR [eax+12]
	test	eax, eax
	je	$LN4@set_object
	cmp	DWORD PTR ?RImplementation@@3VCRender@@A+272, 0
	jne	$LN4@set_object
	mov	ebp, DWORD PTR __imp_?renderable_ROS@IRenderable@@QAEPAVIRender_ObjectSpecific@@XZ
	mov	ecx, esi
	mov	DWORD PTR tv791[esp+20], ebp
	call	ebp
	mov	ecx, DWORD PTR __imp_?Device@@3VCRenderDevice@@A
	mov	eax, DWORD PTR [eax+1924]
	cmp	eax, DWORD PTR [ecx+244]
	je	$LN4@set_object

; 58   : 		{
; 59   : 			current		= 0;
; 60   : 			return;
; 61   : 		}
; 62   : 
; 63   : 		Fvector		C;	O->renderable.xform.transform_tiny		(C,O->renderable.visual->vis.sphere.P);

	mov	eax, DWORD PTR [esi+68]

; 22   : float	clipD		(float R)		{ return P_distance*(R/P_ideal_size); }

	add	ebx, 4
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 499  : 		dest.x = v.x*_11 + v.y*_21 + v.z*_31 + _41;

	movss	xmm2, DWORD PTR [eax+12]
	movss	xmm5, DWORD PTR [eax+8]

; 500  : 		dest.y = v.x*_12 + v.y*_22 + v.z*_32 + _42;

	movaps	xmm0, xmm2
	mulss	xmm0, DWORD PTR [esi+24]
	movaps	xmm4, xmm5
	mulss	xmm4, DWORD PTR [esi+8]
	movaps	xmm1, xmm2
	movss	xmm3, DWORD PTR [eax+16]
	mulss	xmm1, DWORD PTR [esi+20]
	addss	xmm4, xmm0

; 501  : 		dest.z = v.x*_13 + v.y*_23 + v.z*_33 + _43;

	mulss	xmm2, DWORD PTR [esi+28]
	movaps	xmm0, xmm3
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightProjector.cpp

; 64   : 		float		R	= O->renderable.visual->vis.sphere.R;

	movss	xmm6, DWORD PTR [eax+20]
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 500  : 		dest.y = v.x*_12 + v.y*_22 + v.z*_32 + _42;

	mulss	xmm0, DWORD PTR [esi+40]
	addss	xmm0, DWORD PTR [esi+56]
	addss	xmm4, xmm0
	movaps	xmm0, xmm5
	mulss	xmm0, DWORD PTR [esi+4]

; 501  : 		dest.z = v.x*_13 + v.y*_23 + v.z*_33 + _43;

	mulss	xmm5, DWORD PTR [esi+12]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 287  : 	{	return (x-v.x)*(x-v.x) + (y-v.y)*(y-v.y) + (z-v.z)*(z-v.z);	}

	subss	xmm4, DWORD PTR [ecx+492]
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 499  : 		dest.x = v.x*_11 + v.y*_21 + v.z*_31 + _41;

	addss	xmm1, xmm0
	movaps	xmm0, xmm3
	mulss	xmm0, DWORD PTR [esi+36]

; 501  : 		dest.z = v.x*_13 + v.y*_23 + v.z*_33 + _43;

	addss	xmm5, xmm2
	mulss	xmm3, DWORD PTR [esi+44]
	addss	xmm0, DWORD PTR [esi+52]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 287  : 	{	return (x-v.x)*(x-v.x) + (y-v.y)*(y-v.y) + (z-v.z)*(z-v.z);	}

	mulss	xmm4, xmm4
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 501  : 		dest.z = v.x*_13 + v.y*_23 + v.z*_33 + _43;

	addss	xmm3, DWORD PTR [esi+60]
	addss	xmm1, xmm0
	addss	xmm5, xmm3
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 287  : 	{	return (x-v.x)*(x-v.x) + (y-v.y)*(y-v.y) + (z-v.z)*(z-v.z);	}

	subss	xmm1, DWORD PTR [ecx+488]
	subss	xmm5, DWORD PTR [ecx+496]
	mulss	xmm1, xmm1
	mulss	xmm5, xmm5
	addss	xmm1, xmm4
	addss	xmm1, xmm5
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h

; 764  :             return (float)sqrt(_X);

	sqrtss	xmm0, xmm1
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightProjector.cpp

; 65   : 		float		D	= C.distance_to	(Device.vCameraPosition)+R;

	addss	xmm0, xmm6

; 22   : float	clipD		(float R)		{ return P_distance*(R/P_ideal_size); }

	mulss	xmm6, DWORD PTR __real@42480000

; 66   : 
; 67   : 		if (D < clipD(R))	current	= O;

	comiss	xmm6, xmm0
	jbe	$LN7@set_object

; 69   : 		
; 70   : 		if (current)				{
; 71   : 			ISpatial*	spatial		= dynamic_cast<ISpatial*>	(O);

	push	0
	push	OFFSET ??_R0?AVISpatial@@@8
	push	OFFSET ??_R0?AVIRenderable@@@8
	push	0
	push	esi
	mov	DWORD PTR [ebx], esi
	call	___RTDynamicCast
	mov	ebp, eax
	add	esp, 20					; 00000014H

; 72   : 			if	(0==spatial) current= 0;

	test	ebp, ebp
	je	$LN54@set_object
; File I:\Vitalya\mine\NSProjectX\xrEngine\ispatial.h

; 87   : 		if (0 == (spatial.type & STYPEFLAG_INVALIDSECTOR))	return;

	test	DWORD PTR [ebp+4], 65536		; 00010000H
	je	SHORT $LN32@set_object

; 88   : 		spatial_updatesector_internal();

	mov	ecx, ebp
	call	DWORD PTR __imp_?spatial_updatesector_internal@ISpatial@@QAEXXZ
$LN32@set_object:
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightProjector.cpp

; 75   : 				if (0==spatial->spatial.sector)	{

	cmp	DWORD PTR [ebp+44], 0
	jne	SHORT $LN66@set_object

; 76   : 					CObject*		obj = dynamic_cast<CObject*>(O);

	push	0
	push	OFFSET ??_R0?AVCObject@@@8
	push	OFFSET ??_R0?AVIRenderable@@@8
	push	0
	push	esi
	call	___RTDynamicCast
	add	esp, 20					; 00000014H

; 77   : 					if (obj)		Msg	("! Invalid object '%s' position. Outside of sector structure.",obj->cName().c_str());

	test	eax, eax
	je	SHORT $LN54@set_object
; File I:\Vitalya\mine\NSProjectX\xrCore\xrstring.h

; 53   : 	void				_set		(shared_str const &rhs)			{	str_value* v = rhs.p_; if (0!=v) v->dwReference++; _dec(); p_ = v;							}

	mov	esi, DWORD PTR [eax+168]
	lea	ecx, DWORD PTR $T2[esp+16]

; 59   : 						shared_str	(shared_str const &rhs)			{	p_ = 0;	_set(rhs);								}

	mov	DWORD PTR $T2[esp+16], 0

; 53   : 	void				_set		(shared_str const &rhs)			{	str_value* v = rhs.p_; if (0!=v) v->dwReference++; _dec(); p_ = v;							}

	test	esi, esi
	je	SHORT $LN63@set_object
	inc	DWORD PTR [esi]
	call	?_dec@shared_str@@IAEXXZ		; shared_str::_dec
	mov	ecx, esi
	lea	eax, DWORD PTR [esi+12]
	neg	ecx
	sbb	ecx, ecx
	and	ecx, eax
	push	ecx
	push	OFFSET ??_C@_0DN@FFEDFBLH@?$CB?5Invalid?5object?5?8?$CFs?8?5position?4@
	call	DWORD PTR __imp_?Msg@@YAXPBDZZ
	add	esp, 8

; 50   : 	void				_dec		()								{	if (0==p_) return;	p_->dwReference--; 	if (0==p_->dwReference)	p_=0;						}

	dec	DWORD PTR [esi]
	jmp	SHORT $LN54@set_object
$LN63@set_object:

; 53   : 	void				_set		(shared_str const &rhs)			{	str_value* v = rhs.p_; if (0!=v) v->dwReference++; _dec(); p_ = v;							}

	call	?_dec@shared_str@@IAEXXZ		; shared_str::_dec
	lea	eax, DWORD PTR [esi+12]
	neg	esi
	sbb	esi, esi
	and	esi, eax
	push	esi
	push	OFFSET ??_C@_0DN@FFEDFBLH@?$CB?5Invalid?5object?5?8?$CFs?8?5position?4@
	call	DWORD PTR __imp_?Msg@@YAXPBDZZ
	add	esp, 8
$LN54@set_object:
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightProjector.cpp

; 78   : 					current			= 0;

	mov	DWORD PTR [ebx], 0
$LN66@set_object:

; 79   : 				}
; 80   : 			}
; 81   : 		}
; 82   : 		if (current)				{

	mov	ebp, DWORD PTR tv791[esp+20]
$LN12@set_object:
	mov	ecx, DWORD PTR [ebx]
	test	ecx, ecx
	je	SHORT $LN58@set_object

; 83   : 			CROS_impl*	LT			= (CROS_impl*)current->renderable_ROS	();

	call	ebp

; 84   : 			LT->shadow_recv_frame	= Device.dwFrame;

	mov	ecx, DWORD PTR __imp_?Device@@3VCRenderDevice@@A
	mov	ecx, DWORD PTR [ecx+244]
	mov	DWORD PTR [eax+1924], ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 730  :         if (_Mylast != _My_data._Myend) {

	mov	ecx, DWORD PTR [edi+4]
	cmp	ecx, DWORD PTR [edi+8]
	je	SHORT $LN59@set_object

; 713  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

	mov	eax, DWORD PTR [ebx]
	mov	DWORD PTR [ecx], eax

; 714  :         _Orphan_range(_Mylast, _Mylast);
; 715  :         _Ty& _Result = *_Mylast;
; 716  :         ++_Mylast;

	add	DWORD PTR [edi+4], 4
	pop	edi
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightProjector.cpp

; 88   : }

	pop	esi
	pop	ebp
	pop	ebx
	pop	ecx
	ret	4
$LN7@set_object:

; 68   : 		else				current = 0;

	mov	DWORD PTR [ebx], 0

; 75   : 				if (0==spatial->spatial.sector)	{

	jmp	SHORT $LN12@set_object
$LN59@set_object:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 734  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	push	ebx
	push	ecx
	mov	ecx, edi
	call	??$_Emplace_reallocate@ABQAVIRenderable@@@?$vector@PAVIRenderable@@V?$xalloc@PAVIRenderable@@@@@std@@QAEPAPAVIRenderable@@QAPAV2@ABQAV2@@Z ; std::vector<IRenderable *,xalloc<IRenderable *> >::_Emplace_reallocate<IRenderable * const &>
	pop	edi
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightProjector.cpp

; 88   : }

	pop	esi
	pop	ebp
	pop	ebx
	pop	ecx
	ret	4
$LN4@set_object:

; 54   : 	if ((0==O) || (receivers.size()>=P_o_count))	current		= 0;

	mov	DWORD PTR [ebx+4], 0
$LN58@set_object:
	pop	edi

; 88   : }

	pop	esi
	pop	ebp
	pop	ebx
	pop	ecx
	ret	4
?set_object@CLightProjector@@QAEXPAVIRenderable@@@Z ENDP ; CLightProjector::set_object
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightProjector.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightProjector.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightProjector.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightProjector.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightProjector.cpp
_TEXT	SEGMENT
?invalidate@CLightProjector@@QAEXXZ PROC		; CLightProjector::invalidate
; _this$ = ecx

; 109  : {

	push	ebx
	push	esi
	mov	esi, ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	eax, 2021161081				; 78787879H
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightProjector.cpp

; 110  : 	for (u32 c_it=0; c_it<cache.size(); c_it++)

	xor	ebx, ebx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	edx, DWORD PTR [esi+12]
	sub	edx, DWORD PTR [esi+8]
	imul	edx
	sar	edx, 6
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightProjector.cpp

; 110  : 	for (u32 c_it=0; c_it<cache.size(); c_it++)

	je	SHORT $LN3@invalidate
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1535 :         auto& _My_data = _Mypair._Myval2;

	push	edi
	xor	edi, edi
$LL4@invalidate:
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightProjector.cpp

; 111  : 		cache[c_it].dwTimeValid	= 0;

	mov	eax, DWORD PTR [esi+8]
	lea	edi, DWORD PTR [edi+136]
	inc	ebx
	mov	DWORD PTR [edi+eax-4], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	eax, 2021161081				; 78787879H
	mov	ecx, DWORD PTR [esi+12]
	sub	ecx, DWORD PTR [esi+8]
	imul	ecx
	sar	edx, 6
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightProjector.cpp

; 110  : 	for (u32 c_it=0; c_it<cache.size(); c_it++)

	cmp	ebx, eax
	jb	SHORT $LL4@invalidate
	pop	edi
$LN3@invalidate:
	pop	esi

; 112  : }

	pop	ebx
	ret	0
?invalidate@CLightProjector@@QAEXXZ ENDP		; CLightProjector::invalidate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightProjector.cpp
; File I:\Vitalya\mine\NSProjectX\xrEngine\pure.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightProjector.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrEngine\pure.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrEngine\pure.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrEngine\pure.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrEngine\pure.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrEngine\pure.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xrstring.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightProjector.cpp
_TEXT	SEGMENT
??1CLightProjector@@QAE@XZ PROC				; CLightProjector::~CLightProjector
; _this$ = ecx

; 47   : {

	push	ebx
	push	esi
	mov	esi, ecx
; File I:\Vitalya\mine\NSProjectX\xrEngine\pure.h

; 63   : 		for (u32 i = 0; i < R.size(); i++) {

	xor	ebx, ebx
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightProjector.cpp

; 47   : {

	push	edi
	mov	DWORD PTR [esi], OFFSET ??_7CLightProjector@@6B@

; 48   : 	Device.seqAppActivate.Remove	(this);

	mov	edx, DWORD PTR __imp_?Device@@3VCRenderDevice@@A
	add	edx, 308				; 00000134H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [edx]
	sub	eax, ecx
	sar	eax, 2
	imul	eax, eax, -1431655765
; File I:\Vitalya\mine\NSProjectX\xrEngine\pure.h

; 63   : 		for (u32 i = 0; i < R.size(); i++) {

	test	eax, eax
	je	SHORT $LN5@CLightProj
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1535 :         auto& _My_data = _Mypair._Myval2;

	xor	edi, edi
	npad	1
$LL6@CLightProj:
; File I:\Vitalya\mine\NSProjectX\xrEngine\pure.h

; 64   : 			if (R[i].Object == obj) R[i].Prio = REG_PRIORITY_INVALID;

	cmp	DWORD PTR [edi+ecx], esi
	lea	eax, DWORD PTR [edi+ecx]
	jne	SHORT $LN4@CLightProj
	mov	DWORD PTR [eax+4], -1
	mov	ecx, DWORD PTR [edx]
$LN4@CLightProj:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	eax, DWORD PTR [edx+4]
; File I:\Vitalya\mine\NSProjectX\xrEngine\pure.h

; 63   : 		for (u32 i = 0; i < R.size(); i++) {

	inc	ebx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	sub	eax, ecx
; File I:\Vitalya\mine\NSProjectX\xrEngine\pure.h

; 63   : 		for (u32 i = 0; i < R.size(); i++) {

	add	edi, 12					; 0000000cH
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	sar	eax, 2
	imul	eax, eax, -1431655765
; File I:\Vitalya\mine\NSProjectX\xrEngine\pure.h

; 63   : 		for (u32 i = 0; i < R.size(); i++) {

	cmp	ebx, eax
	jb	SHORT $LL6@CLightProj
$LN5@CLightProj:

; 65   : 		}
; 66   : 		if (in_process)		changed = true;

	mov	eax, DWORD PTR [edx+12]
	test	al, 1
	je	SHORT $LN8@CLightProj
	or	eax, 2
	mov	DWORD PTR [edx+12], eax
	jmp	SHORT $LN9@CLightProj
$LN8@CLightProj:

; 67   : 		else Resort();

	mov	ecx, edx
	call	?Resort@?$CRegistrator@VpureAppActivate@@@@QAEXXZ ; CRegistrator<pureAppActivate>::Resort
$LN9@CLightProj:
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 46   : 	ICF		void		_set	(T * rhs) 							{	if (0!=rhs) rhs->dwReference++;	_dec(); p_ = rhs;											}

	lea	ecx, DWORD PTR [esi+44]
	call	DWORD PTR __imp_?_dec@?$resptr_base@VCRT@@@@IAEXXZ
	mov	DWORD PTR [esi+44], 0
; File I:\Vitalya\mine\NSProjectX\xrCore\xrstring.h

; 50   : 	void				_dec		()								{	if (0==p_) return;	p_->dwReference--; 	if (0==p_->dwReference)	p_=0;						}

	mov	eax, DWORD PTR [esi+56]
	test	eax, eax
	je	SHORT $LN58@CLightProj
	dec	DWORD PTR [eax]
	mov	eax, DWORD PTR [esi+56]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN58@CLightProj
	mov	DWORD PTR [esi+56], 0
$LN58@CLightProj:
	mov	eax, DWORD PTR [esi+52]
	test	eax, eax
	je	SHORT $LN64@CLightProj
	dec	DWORD PTR [eax]
	mov	eax, DWORD PTR [esi+52]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN64@CLightProj
	mov	DWORD PTR [esi+52], 0
$LN64@CLightProj:
	mov	eax, DWORD PTR [esi+48]
	test	eax, eax
	je	SHORT $LN70@CLightProj
	dec	DWORD PTR [eax]
	mov	eax, DWORD PTR [esi+48]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN70@CLightProj
	mov	DWORD PTR [esi+48], 0
$LN70@CLightProj:
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 64   : 						~resptr_core	()												{	_dec();						}

	lea	ecx, DWORD PTR [esi+44]
	call	DWORD PTR __imp_?_dec@?$resptr_base@VCRT@@@@IAEXXZ
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [esi+32]
	mov	edi, DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
	test	eax, eax
	je	SHORT $LN79@CLightProj
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi+32], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+36], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+40], 0
$LN79@CLightProj:

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [esi+20]
	test	eax, eax
	je	SHORT $LN91@CLightProj
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi+20], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+24], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+28], 0
$LN91@CLightProj:

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [esi+8]
	test	eax, eax
	je	SHORT $LN103@CLightProj
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi+8], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+12], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+16], 0
$LN103@CLightProj:
	pop	edi
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightProjector.cpp

; 50   : }

	pop	esi
	pop	ebx
	ret	0
??1CLightProjector@@QAE@XZ ENDP				; CLightProjector::~CLightProjector
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightProjector.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightProjector.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xrstring.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightProjector.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightProjector.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xrstring.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightProjector.cpp
; File I:\Vitalya\mine\NSProjectX\xrEngine\pure.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrEngine\pure.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightProjector.cpp
; File I:\Vitalya\mine\NSProjectX\xrEngine\pure.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightProjector.cpp
_TEXT	SEGMENT
$T2 = -17						; size = 1
$T3 = -16						; size = 4
_I$4 = -12						; size = 12
??0CLightProjector@@QAE@XZ PROC				; CLightProjector::CLightProjector
; _this$ = ecx

; 30   : {

	sub	esp, 20					; 00000014H
	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	edi, ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 62   : 						resptr_core		(T * p, bool add_ref = true) 					{	p_ = p;	if(add_ref)	_inc(); }

	mov	DWORD PTR $T3[esp+36], 0

; 46   : 	ICF		void		_set	(T * rhs) 							{	if (0!=rhs) rhs->dwReference++;	_dec(); p_ = rhs;											}

	lea	ecx, DWORD PTR [edi+44]
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightProjector.cpp

; 30   : {

	mov	DWORD PTR [edi], OFFSET ??_7CLightProjector@@6B@
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [edi+8], 0
	mov	DWORD PTR [edi+12], 0
	mov	DWORD PTR [edi+16], 0
	mov	DWORD PTR [edi+20], 0
	mov	DWORD PTR [edi+24], 0
	mov	DWORD PTR [edi+28], 0
	mov	DWORD PTR [edi+32], 0
	mov	DWORD PTR [edi+36], 0
	mov	DWORD PTR [edi+40], 0
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 61   : 						resptr_core		()												{	p_ = 0;						}

	mov	DWORD PTR [edi+44], 0
; File I:\Vitalya\mine\NSProjectX\xrCore\xrstring.h

; 57   : 						shared_str	()								{	p_ = 0;											}

	mov	DWORD PTR [edi+48], 0
	mov	DWORD PTR [edi+52], 0
	mov	DWORD PTR [edi+56], 0
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightProjector.cpp

; 31   : 	current				= 0;

	mov	DWORD PTR [edi+4], 0
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 46   : 	ICF		void		_set	(T * rhs) 							{	if (0!=rhs) rhs->dwReference++;	_dec(); p_ = rhs;											}

	call	DWORD PTR __imp_?_dec@?$resptr_base@VCRT@@@@IAEXXZ

; 64   : 						~resptr_core	()												{	_dec();						}

	lea	ecx, DWORD PTR $T3[esp+36]

; 46   : 	ICF		void		_set	(T * rhs) 							{	if (0!=rhs) rhs->dwReference++;	_dec(); p_ = rhs;											}

	mov	DWORD PTR [edi+44], 0

; 64   : 						~resptr_core	()												{	_dec();						}

	call	DWORD PTR __imp_?_dec@?$resptr_base@VCRT@@@@IAEXXZ
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightProjector.cpp

; 35   : 	RT.create			("$user$projector",P_rt_size,P_rt_size,P_rtf);

	push	21					; 00000015H
	push	512					; 00000200H
	push	512					; 00000200H
	push	OFFSET ??_C@_0BA@KMBCAHDL@$user$projector@
	lea	ecx, DWORD PTR [edi+44]
	call	DWORD PTR __imp_?create@resptrcode_crt@@QAEXPBDIIW4_D3DFORMAT@@@Z
; File I:\Vitalya\mine\NSProjectX\xrCore\xrstring.h

; 52   : 	void				_set		(str_c rhs) 					{	str_value* v = g_pStringContainer->dock(rhs); if (0!=v) v->dwReference++; _dec(); p_ = v;	}

	mov	ecx, DWORD PTR __imp_?g_pStringContainer@@3PAVstr_container@@A
	mov	esi, DWORD PTR __imp_?dock@str_container@@QAEPAUstr_value@@PBD@Z
	push	OFFSET ??_C@_0O@EGLBEPCM@m_plmap_xform@
	mov	ecx, DWORD PTR [ecx]
	call	esi
	test	eax, eax
	je	SHORT $LN57@CLightProj
	inc	DWORD PTR [eax]
$LN57@CLightProj:

; 50   : 	void				_dec		()								{	if (0==p_) return;	p_->dwReference--; 	if (0==p_->dwReference)	p_=0;						}

	mov	ecx, DWORD PTR [edi+48]
	test	ecx, ecx
	je	SHORT $LN61@CLightProj
	dec	DWORD PTR [ecx]
$LN61@CLightProj:

; 52   : 	void				_set		(str_c rhs) 					{	str_value* v = g_pStringContainer->dock(rhs); if (0!=v) v->dwReference++; _dec(); p_ = v;	}

	mov	ecx, DWORD PTR __imp_?g_pStringContainer@@3PAVstr_container@@A
	mov	DWORD PTR [edi+48], eax
	push	OFFSET ??_C@_0O@GNNJFKLH@m_plmap_clamp@
	mov	ecx, DWORD PTR [ecx]
	call	esi
	test	eax, eax
	je	SHORT $LN66@CLightProj
	inc	DWORD PTR [eax]
$LN66@CLightProj:

; 50   : 	void				_dec		()								{	if (0==p_) return;	p_->dwReference--; 	if (0==p_->dwReference)	p_=0;						}

	mov	ecx, DWORD PTR [edi+52]
	test	ecx, ecx
	je	SHORT $LN70@CLightProj
	dec	DWORD PTR [ecx]
$LN70@CLightProj:

; 52   : 	void				_set		(str_c rhs) 					{	str_value* v = g_pStringContainer->dock(rhs); if (0!=v) v->dwReference++; _dec(); p_ = v;	}

	mov	ecx, DWORD PTR __imp_?g_pStringContainer@@3PAVstr_container@@A
	mov	DWORD PTR [edi+52], eax
	push	OFFSET ??_C@_0P@OGGMHHEA@m_plmap_factor@
	mov	ecx, DWORD PTR [ecx]
	call	esi
	test	eax, eax
	je	SHORT $LN75@CLightProj
	inc	DWORD PTR [eax]
$LN75@CLightProj:

; 50   : 	void				_dec		()								{	if (0==p_) return;	p_->dwReference--; 	if (0==p_->dwReference)	p_=0;						}

	mov	ecx, DWORD PTR [edi+56]
	test	ecx, ecx
	je	SHORT $LN79@CLightProj
	dec	DWORD PTR [ecx]
$LN79@CLightProj:

; 52   : 	void				_set		(str_c rhs) 					{	str_value* v = g_pStringContainer->dock(rhs); if (0!=v) v->dwReference++; _dec(); p_ = v;	}

	mov	DWORD PTR [edi+56], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1250 :         const auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);

	mov	eax, 2021161081				; 78787879H
	mov	ebp, DWORD PTR [edi+12]
	mov	ecx, ebp
	sub	ecx, DWORD PTR [edi+8]
	imul	ecx
	sar	edx, 6
	mov	esi, edx
	shr	esi, 31					; 0000001fH
	add	esi, edx

; 1251 :         if (_Newsize < _Oldsize) { // trim

	cmp	esi, 100				; 00000064H
	jbe	SHORT $LN84@CLightProj

; 1252 :             const pointer _Newlast = _Myfirst + _Newsize;

	mov	eax, DWORD PTR [edi+8]
	add	eax, 13600				; 00003520H

; 1253 :             _Orphan_range(_Newlast, _Mylast);
; 1254 :             _Destroy(_Newlast, _Mylast);
; 1255 :             _Mylast = _Newlast;

	mov	DWORD PTR [edi+12], eax

; 1256 :             return;

	jmp	SHORT $LN85@CLightProj
$LN84@CLightProj:

; 1257 :         }
; 1258 : 
; 1259 :         if (_Newsize > _Oldsize) { // append

	jae	SHORT $LN85@CLightProj

; 1260 :             const auto _Oldcapacity = static_cast<size_type>(_My_data._Myend - _Myfirst);

	mov	ecx, DWORD PTR [edi+16]
	mov	eax, 2021161081				; 78787879H
	sub	ecx, DWORD PTR [edi+8]
	imul	ecx
	sar	edx, 6
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx

; 1261 :             if (_Newsize > _Oldcapacity) { // reallocate

	cmp	eax, 100				; 00000064H
	jae	SHORT $LN86@CLightProj

; 1262 :                 _Resize_reallocate(_Newsize, _Val);

	lea	eax, DWORD PTR $T2[esp+36]
	push	eax
	push	ecx
	lea	ecx, DWORD PTR [edi+8]
	call	??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@Urecv@CLightProjector@@V?$xalloc@Urecv@CLightProjector@@@@@std@@AAEXIABU_Value_init_tag@1@@Z ; std::vector<CLightProjector::recv,xalloc<CLightProjector::recv> >::_Resize_reallocate<std::_Value_init_tag>

; 1263 :                 return;

	jmp	SHORT $LN85@CLightProj
$LN86@CLightProj:

; 1267 :             _Mylast                = _Ufill(_Oldlast, _Newsize - _Oldsize, _Val);

	mov	eax, 100				; 00000064H
	sub	eax, esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1813 :     for (; 0 < _Count; --_Count) {

	je	SHORT $LN93@CLightProj
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1267 :             _Mylast                = _Ufill(_Oldlast, _Newsize - _Oldsize, _Val);

	imul	esi, eax, 136
	push	esi
	push	0
	push	ebp
	call	_memset
	add	esp, 12					; 0000000cH
	add	ebp, esi
$LN93@CLightProj:
	mov	DWORD PTR [edi+12], ebp
$LN85@CLightProj:
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightProjector.cpp

; 43   : 	Device.seqAppActivate.Add		(this);

	mov	esi, DWORD PTR __imp_?Device@@3VCRenderDevice@@A
	add	esi, 308				; 00000134H
; File I:\Vitalya\mine\NSProjectX\xrEngine\pure.h

; 53   : 		I.Object = obj;

	mov	DWORD PTR _I$4[esp+36], edi

; 54   : 		I.Prio = priority;

	mov	DWORD PTR _I$4[esp+40], 572662306	; 22222222H

; 55   : 		I.Flags = flags;

	mov	DWORD PTR _I$4[esp+44], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 730  :         if (_Mylast != _My_data._Myend) {

	mov	eax, DWORD PTR [esi+4]
	cmp	eax, DWORD PTR [esi+8]
	je	SHORT $LN110@CLightProj
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	DWORD PTR [eax], edi
	mov	DWORD PTR [eax+4], 572662306		; 22222222H
	mov	DWORD PTR [eax+8], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 716  :         ++_Mylast;

	add	DWORD PTR [esi+4], 12			; 0000000cH

; 731  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

	jmp	SHORT $LN109@CLightProj
$LN110@CLightProj:

; 732  :         }
; 733  : 
; 734  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	lea	ecx, DWORD PTR _I$4[esp+36]
	push	ecx
	push	eax
	mov	ecx, esi
	call	??$_Emplace_reallocate@ABU_REG_INFO@@@?$vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@std@@QAEPAU_REG_INFO@@QAU2@ABU2@@Z ; std::vector<_REG_INFO,xalloc<_REG_INFO> >::_Emplace_reallocate<_REG_INFO const &>
$LN109@CLightProj:
; File I:\Vitalya\mine\NSProjectX\xrEngine\pure.h

; 58   : 		if (in_process)		changed = true;

	mov	eax, DWORD PTR [esi+12]
	test	al, 1
	je	SHORT $LN104@CLightProj
	or	eax, 2
	mov	DWORD PTR [esi+12], eax
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightProjector.cpp

; 44   : }

	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 20					; 00000014H
	ret	0
$LN104@CLightProj:
; File I:\Vitalya\mine\NSProjectX\xrEngine\pure.h

; 59   : 		else Resort();

	mov	ecx, esi
	call	?Resort@?$CRegistrator@VpureAppActivate@@@@QAEXXZ ; CRegistrator<pureAppActivate>::Resort
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightProjector.cpp

; 44   : }

	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 20					; 00000014H
	ret	0
??0CLightProjector@@QAE@XZ ENDP				; CLightProjector::CLightProjector
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\lighttrack.h
; File I:\Vitalya\mine\NSProjectX\xrCore\vector.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\LightTrack.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\vector.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\LightTrack.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\lighttrack.h
;	COMDAT ?get_approximate@CROS_impl@@QAEAAU?$_vector3@M@@XZ
_TEXT	SEGMENT
?get_approximate@CROS_impl@@QAEAAU?$_vector3@M@@XZ PROC	; CROS_impl::get_approximate, COMDAT
; _this$ = ecx

; 73   : 	ICF Fvector3&			get_approximate		()	{

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H

; 74   : 		if (dwFrameSmooth!=Device.dwFrame)		update_smooth();

	mov	eax, DWORD PTR __imp_?Device@@3VCRenderDevice@@A
	mov	eax, DWORD PTR [eax+244]
	cmp	DWORD PTR [ecx+12], eax
	je	SHORT $LN14@get_approx
; File I:\Vitalya\mine\NSProjectX\xrCore\vector.h

; 92   : 	if( val<_low ) val = _low; else if( val>_high ) val = _high;

	movss	xmm3, DWORD PTR __real@3f800000
	xorps	xmm0, xmm0
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\LightTrack.cpp

; 260  : 	dwFrameSmooth			=	Device.dwFrame					;

	mov	DWORD PTR [ecx+12], eax

; 261  : 	if (O && (0==result_count))	update(O)						;	// First time only
; 262  : 	float	l_f				=	Device.fTimeDelta*ps_r2_lt_smooth;

	mov	eax, DWORD PTR __imp_?Device@@3VCRenderDevice@@A
	movss	xmm2, DWORD PTR [eax+468]
; File I:\Vitalya\mine\NSProjectX\xrCore\vector.h

; 92   : 	if( val<_low ) val = _low; else if( val>_high ) val = _high;

	comiss	xmm0, xmm2
	jbe	SHORT $LN9@get_approx
	movaps	xmm2, xmm0
	jmp	SHORT $LN11@get_approx
$LN9@get_approx:
	comiss	xmm2, xmm3
	jbe	SHORT $LN11@get_approx
	movaps	xmm2, xmm3
$LN11@get_approx:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\LightTrack.cpp

; 264  : 	float	l_i				=	1.f-l_f							;

	subss	xmm3, xmm2

; 265  : 	hemi_smooth				=	hemi_value*l_f + hemi_smooth*l_i;

	movaps	xmm1, xmm2
	mulss	xmm1, DWORD PTR [ecx+1932]

; 266  : 	sun_smooth				=	sun_value *l_f + sun_smooth *l_i;

	mulss	xmm2, DWORD PTR [ecx+1940]
	movaps	xmm0, xmm3
	mulss	xmm3, DWORD PTR [ecx+1944]
	mulss	xmm0, DWORD PTR [ecx+1936]
	addss	xmm2, xmm3
	addss	xmm1, xmm0
	movss	DWORD PTR [ecx+1944], xmm2
	movss	DWORD PTR [ecx+1936], xmm1
$LN14@get_approx:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\lighttrack.h

; 76   : 	}

	lea	eax, DWORD PTR [ecx+1948]
	mov	esp, ebp
	pop	ebp
	ret	0
?get_approximate@CROS_impl@@QAEAAU?$_vector3@M@@XZ ENDP	; CROS_impl::get_approximate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightProjector.cpp
_TEXT	SEGMENT
_R$ = 8							; size = 4
?clipD@@YAMM@Z PROC					; clipD

; 22   : float	clipD		(float R)		{ return P_distance*(R/P_ideal_size); }

	fld	DWORD PTR _R$[esp-4]
	fmul	DWORD PTR __real@42480000
	ret	0
?clipD@@YAMM@Z ENDP					; clipD
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??1?$xr_vector@Urecv@CLightProjector@@V?$xalloc@Urecv@CLightProjector@@@@@@QAE@XZ
_TEXT	SEGMENT
??1?$xr_vector@Urecv@CLightProjector@@V?$xalloc@Urecv@CLightProjector@@@@@@QAE@XZ PROC ; xr_vector<CLightProjector::recv,xalloc<CLightProjector::recv> >::~xr_vector<CLightProjector::recv,xalloc<CLightProjector::recv> >, COMDAT
; _this$ = ecx

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	push	esi
	mov	esi, ecx
	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN6@xr_vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+4], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+8], 0
$LN6@xr_vector:
	pop	esi
	ret	0
??1?$xr_vector@Urecv@CLightProjector@@V?$xalloc@Urecv@CLightProjector@@@@@@QAE@XZ ENDP ; xr_vector<CLightProjector::recv,xalloc<CLightProjector::recv> >::~xr_vector<CLightProjector::recv,xalloc<CLightProjector::recv> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??1?$xr_vector@PAVIRenderable@@V?$xalloc@PAVIRenderable@@@@@@QAE@XZ
_TEXT	SEGMENT
??1?$xr_vector@PAVIRenderable@@V?$xalloc@PAVIRenderable@@@@@@QAE@XZ PROC ; xr_vector<IRenderable *,xalloc<IRenderable *> >::~xr_vector<IRenderable *,xalloc<IRenderable *> >, COMDAT
; _this$ = ecx

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	push	esi
	mov	esi, ecx
	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN6@xr_vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+4], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+8], 0
$LN6@xr_vector:
	pop	esi
	ret	0
??1?$xr_vector@PAVIRenderable@@V?$xalloc@PAVIRenderable@@@@@@QAE@XZ ENDP ; xr_vector<IRenderable *,xalloc<IRenderable *> >::~xr_vector<IRenderable *,xalloc<IRenderable *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightProjector.cpp
_TEXT	SEGMENT
?OnAppActivate@CLightProjector@@UAEXXZ PROC		; CLightProjector::OnAppActivate
; _this$ = ecx

; 116  : 	invalidate					();

	jmp	?invalidate@CLightProjector@@QAEXXZ	; CLightProjector::invalidate
?OnAppActivate@CLightProjector@@UAEXXZ ENDP		; CLightProjector::OnAppActivate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ??A?$xr_vector@PAVIRenderable@@V?$xalloc@PAVIRenderable@@@@@@QAEAAPAVIRenderable@@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$xr_vector@PAVIRenderable@@V?$xalloc@PAVIRenderable@@@@@@QAEAAPAVIRenderable@@I@Z PROC ; xr_vector<IRenderable *,xalloc<IRenderable *> >::operator[], COMDAT
; _this$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 119  :         _Ptr += _Off;

	mov	ecx, DWORD PTR [ecx]
	mov	eax, DWORD PTR __Pos$[esp-4]
	lea	eax, DWORD PTR [ecx+eax*4]
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 138  : 	reference operator[]		(size_type _Pos)					{ {VERIFY(_Pos<size());} return (*(begin() + _Pos)); }

	ret	4
??A?$xr_vector@PAVIRenderable@@V?$xalloc@PAVIRenderable@@@@@@QAEAAPAVIRenderable@@I@Z ENDP ; xr_vector<IRenderable *,xalloc<IRenderable *> >::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?size@?$xr_vector@PAVIRenderable@@V?$xalloc@PAVIRenderable@@@@@@QBEIXZ
_TEXT	SEGMENT
?size@?$xr_vector@PAVIRenderable@@V?$xalloc@PAVIRenderable@@@@@@QBEIXZ PROC ; xr_vector<IRenderable *,xalloc<IRenderable *> >::size, COMDAT
; _this$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	eax, DWORD PTR [ecx+4]
	sub	eax, DWORD PTR [ecx]
	sar	eax, 2
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 125  : 	u32		size				() const							{ return (u32)inherited::size();} 

	ret	0
?size@?$xr_vector@PAVIRenderable@@V?$xalloc@PAVIRenderable@@@@@@QBEIXZ ENDP ; xr_vector<IRenderable *,xalloc<IRenderable *> >::size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ??0?$xr_vector@PAVIRenderable@@V?$xalloc@PAVIRenderable@@@@@@QAE@XZ
_TEXT	SEGMENT
??0?$xr_vector@PAVIRenderable@@V?$xalloc@PAVIRenderable@@@@@@QAE@XZ PROC ; xr_vector<IRenderable *,xalloc<IRenderable *> >::xr_vector<IRenderable *,xalloc<IRenderable *> >, COMDAT
; _this$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx], 0
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 122  : 			xr_vector			()									: inherited	()					{}

	mov	eax, ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 122  : 			xr_vector			()									: inherited	()					{}

	ret	0
??0?$xr_vector@PAVIRenderable@@V?$xalloc@PAVIRenderable@@@@@@QAE@XZ ENDP ; xr_vector<IRenderable *,xalloc<IRenderable *> >::xr_vector<IRenderable *,xalloc<IRenderable *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?empty@?$vector@PAVIRenderable@@V?$xalloc@PAVIRenderable@@@@@std@@QBE_NXZ
_TEXT	SEGMENT
?empty@?$vector@PAVIRenderable@@V?$xalloc@PAVIRenderable@@@@@std@@QBE_NXZ PROC ; std::vector<IRenderable *,xalloc<IRenderable *> >::empty, COMDAT
; _this$ = ecx

; 1530 :         auto& _My_data = _Mypair._Myval2;
; 1531 :         return _My_data._Myfirst == _My_data._Mylast;

	mov	eax, DWORD PTR [ecx]
	cmp	eax, DWORD PTR [ecx+4]
	sete	al

; 1532 :     }

	ret	0
?empty@?$vector@PAVIRenderable@@V?$xalloc@PAVIRenderable@@@@@std@@QBE_NXZ ENDP ; std::vector<IRenderable *,xalloc<IRenderable *> >::empty
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?push_back@?$vector@PAVIRenderable@@V?$xalloc@PAVIRenderable@@@@@std@@QAEXABQAVIRenderable@@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?push_back@?$vector@PAVIRenderable@@V?$xalloc@PAVIRenderable@@@@@std@@QAEXABQAVIRenderable@@@Z PROC ; std::vector<IRenderable *,xalloc<IRenderable *> >::push_back, COMDAT
; _this$ = ecx

; 730  :         if (_Mylast != _My_data._Myend) {

	mov	edx, DWORD PTR [ecx+4]
	cmp	edx, DWORD PTR [ecx+8]
	je	SHORT $LN4@push_back

; 713  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

	mov	eax, DWORD PTR __Val$[esp-4]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edx], eax

; 714  :         _Orphan_range(_Mylast, _Mylast);
; 715  :         _Ty& _Result = *_Mylast;
; 716  :         ++_Mylast;

	add	DWORD PTR [ecx+4], 4

; 743  :         emplace_back(_Val);
; 744  :     }

	ret	4
$LN4@push_back:

; 734  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	push	DWORD PTR __Val$[esp-4]
	push	edx
	call	??$_Emplace_reallocate@ABQAVIRenderable@@@?$vector@PAVIRenderable@@V?$xalloc@PAVIRenderable@@@@@std@@QAEPAPAVIRenderable@@QAPAV2@ABQAV2@@Z ; std::vector<IRenderable *,xalloc<IRenderable *> >::_Emplace_reallocate<IRenderable * const &>

; 743  :         emplace_back(_Val);
; 744  :     }

	ret	4
?push_back@?$vector@PAVIRenderable@@V?$xalloc@PAVIRenderable@@@@@std@@QAEXABQAVIRenderable@@@Z ENDP ; std::vector<IRenderable *,xalloc<IRenderable *> >::push_back
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??$emplace_back@ABQAVIRenderable@@@?$vector@PAVIRenderable@@V?$xalloc@PAVIRenderable@@@@@std@@QAE?A_TABQAVIRenderable@@@Z
_TEXT	SEGMENT
_<_Val_0>$ = 8						; size = 4
??$emplace_back@ABQAVIRenderable@@@?$vector@PAVIRenderable@@V?$xalloc@PAVIRenderable@@@@@std@@QAE?A_TABQAVIRenderable@@@Z PROC ; std::vector<IRenderable *,xalloc<IRenderable *> >::emplace_back<IRenderable * const &>, COMDAT
; _this$ = ecx

; 727  :         // insert by perfectly forwarding into element at end, provide strong guarantee
; 728  :         auto& _My_data   = _Mypair._Myval2;
; 729  :         pointer& _Mylast = _My_data._Mylast;
; 730  :         if (_Mylast != _My_data._Myend) {

	mov	edx, DWORD PTR [ecx+4]
	cmp	edx, DWORD PTR [ecx+8]
	je	SHORT $LN2@emplace_ba

; 713  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

	mov	eax, DWORD PTR _<_Val_0>$[esp-4]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edx], eax

; 714  :         _Orphan_range(_Mylast, _Mylast);
; 715  :         _Ty& _Result = *_Mylast;
; 716  :         ++_Mylast;

	add	DWORD PTR [ecx+4], 4

; 735  : #if _HAS_CXX17
; 736  :         return _Result;
; 737  : #else // ^^^ _HAS_CXX17 ^^^ // vvv !_HAS_CXX17 vvv
; 738  :         (void) _Result;
; 739  : #endif // _HAS_CXX17
; 740  :     }

	ret	4
$LN2@emplace_ba:

; 731  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);
; 732  :         }
; 733  : 
; 734  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	push	DWORD PTR _<_Val_0>$[esp-4]
	push	edx
	call	??$_Emplace_reallocate@ABQAVIRenderable@@@?$vector@PAVIRenderable@@V?$xalloc@PAVIRenderable@@@@@std@@QAEPAPAVIRenderable@@QAPAV2@ABQAV2@@Z ; std::vector<IRenderable *,xalloc<IRenderable *> >::_Emplace_reallocate<IRenderable * const &>

; 735  : #if _HAS_CXX17
; 736  :         return _Result;
; 737  : #else // ^^^ _HAS_CXX17 ^^^ // vvv !_HAS_CXX17 vvv
; 738  :         (void) _Result;
; 739  : #endif // _HAS_CXX17
; 740  :     }

	ret	4
??$emplace_back@ABQAVIRenderable@@@?$vector@PAVIRenderable@@V?$xalloc@PAVIRenderable@@@@@std@@QAE?A_TABQAVIRenderable@@@Z ENDP ; std::vector<IRenderable *,xalloc<IRenderable *> >::emplace_back<IRenderable * const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??$_Emplace_back_with_unused_capacity@ABQAVIRenderable@@@?$vector@PAVIRenderable@@V?$xalloc@PAVIRenderable@@@@@std@@AAE?A_TABQAVIRenderable@@@Z
_TEXT	SEGMENT
_<_Val_0>$ = 8						; size = 4
??$_Emplace_back_with_unused_capacity@ABQAVIRenderable@@@?$vector@PAVIRenderable@@V?$xalloc@PAVIRenderable@@@@@std@@AAE?A_TABQAVIRenderable@@@Z PROC ; std::vector<IRenderable *,xalloc<IRenderable *> >::_Emplace_back_with_unused_capacity<IRenderable * const &>, COMDAT
; _this$ = ecx

; 709  :         // insert by perfectly forwarding into element at end, provide strong guarantee
; 710  :         auto& _My_data   = _Mypair._Myval2;
; 711  :         pointer& _Mylast = _My_data._Mylast;
; 712  :         _STL_INTERNAL_CHECK(_Mylast != _My_data._Myend); // check that we have unused capacity
; 713  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _<_Val_0>$[esp-4]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edx], eax

; 714  :         _Orphan_range(_Mylast, _Mylast);
; 715  :         _Ty& _Result = *_Mylast;
; 716  :         ++_Mylast;

	add	DWORD PTR [ecx+4], 4

; 717  : #if _HAS_CXX17
; 718  :         return _Result;
; 719  : #else // ^^^ _HAS_CXX17 ^^^ // vvv !_HAS_CXX17 vvv
; 720  :         (void) _Result;
; 721  : #endif // _HAS_CXX17
; 722  :     }

	ret	4
??$_Emplace_back_with_unused_capacity@ABQAVIRenderable@@@?$vector@PAVIRenderable@@V?$xalloc@PAVIRenderable@@@@@std@@AAE?A_TABQAVIRenderable@@@Z ENDP ; std::vector<IRenderable *,xalloc<IRenderable *> >::_Emplace_back_with_unused_capacity<IRenderable * const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??1?$vector@PAVIRenderable@@V?$xalloc@PAVIRenderable@@@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@PAVIRenderable@@V?$xalloc@PAVIRenderable@@@@@std@@QAE@XZ PROC ; std::vector<IRenderable *,xalloc<IRenderable *> >::~vector<IRenderable *,xalloc<IRenderable *> >, COMDAT
; _this$ = ecx

; 698  :     _CONSTEXPR20_CONTAINER ~vector() noexcept {

	push	esi
	mov	esi, ecx

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN4@vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+4], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+8], 0
$LN4@vector:
	pop	esi

; 699  :         _Tidy();
; 700  : #if _ITERATOR_DEBUG_LEVEL != 0
; 701  :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 702  :         _Delete_plain_internal(_Alproxy, _STD exchange(_Mypair._Myval2._Myproxy, nullptr));
; 703  : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 704  :     }

	ret	0
??1?$vector@PAVIRenderable@@V?$xalloc@PAVIRenderable@@@@@std@@QAE@XZ ENDP ; std::vector<IRenderable *,xalloc<IRenderable *> >::~vector<IRenderable *,xalloc<IRenderable *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ??A?$xr_vector@Urecv@CLightProjector@@V?$xalloc@Urecv@CLightProjector@@@@@@QAEAAUrecv@CLightProjector@@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$xr_vector@Urecv@CLightProjector@@V?$xalloc@Urecv@CLightProjector@@@@@@QAEAAUrecv@CLightProjector@@I@Z PROC ; xr_vector<CLightProjector::recv,xalloc<CLightProjector::recv> >::operator[], COMDAT
; _this$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 119  :         _Ptr += _Off;

	imul	eax, DWORD PTR __Pos$[esp-4], 136
	add	eax, DWORD PTR [ecx]
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 138  : 	reference operator[]		(size_type _Pos)					{ {VERIFY(_Pos<size());} return (*(begin() + _Pos)); }

	ret	4
??A?$xr_vector@Urecv@CLightProjector@@V?$xalloc@Urecv@CLightProjector@@@@@@QAEAAUrecv@CLightProjector@@I@Z ENDP ; xr_vector<CLightProjector::recv,xalloc<CLightProjector::recv> >::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?size@?$xr_vector@Urecv@CLightProjector@@V?$xalloc@Urecv@CLightProjector@@@@@@QBEIXZ
_TEXT	SEGMENT
?size@?$xr_vector@Urecv@CLightProjector@@V?$xalloc@Urecv@CLightProjector@@@@@@QBEIXZ PROC ; xr_vector<CLightProjector::recv,xalloc<CLightProjector::recv> >::size, COMDAT
; _this$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	edx, DWORD PTR [ecx+4]
	mov	eax, 2021161081				; 78787879H
	sub	edx, DWORD PTR [ecx]
	imul	edx
	sar	edx, 6
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 125  : 	u32		size				() const							{ return (u32)inherited::size();} 

	ret	0
?size@?$xr_vector@Urecv@CLightProjector@@V?$xalloc@Urecv@CLightProjector@@@@@@QBEIXZ ENDP ; xr_vector<CLightProjector::recv,xalloc<CLightProjector::recv> >::size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ??0?$xr_vector@Urecv@CLightProjector@@V?$xalloc@Urecv@CLightProjector@@@@@@QAE@XZ
_TEXT	SEGMENT
??0?$xr_vector@Urecv@CLightProjector@@V?$xalloc@Urecv@CLightProjector@@@@@@QAE@XZ PROC ; xr_vector<CLightProjector::recv,xalloc<CLightProjector::recv> >::xr_vector<CLightProjector::recv,xalloc<CLightProjector::recv> >, COMDAT
; _this$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx], 0
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 122  : 			xr_vector			()									: inherited	()					{}

	mov	eax, ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 122  : 			xr_vector			()									: inherited	()					{}

	ret	0
??0?$xr_vector@Urecv@CLightProjector@@V?$xalloc@Urecv@CLightProjector@@@@@@QAE@XZ ENDP ; xr_vector<CLightProjector::recv,xalloc<CLightProjector::recv> >::xr_vector<CLightProjector::recv,xalloc<CLightProjector::recv> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?resize@?$vector@Urecv@CLightProjector@@V?$xalloc@Urecv@CLightProjector@@@@@std@@QAEXI@Z
_TEXT	SEGMENT
$T2 = -1						; size = 1
__Newsize$dead$ = 8					; size = 4
?resize@?$vector@Urecv@CLightProjector@@V?$xalloc@Urecv@CLightProjector@@@@@std@@QAEXI@Z PROC ; std::vector<CLightProjector::recv,xalloc<CLightProjector::recv> >::resize, COMDAT
; _this$ = ecx

; 1275 :     _CONSTEXPR20_CONTAINER void resize(_CRT_GUARDOVERFLOW const size_type _Newsize) {

	push	ecx
	push	ebx
	push	ebp
	push	esi
	mov	ebx, ecx

; 1250 :         const auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);

	mov	eax, 2021161081				; 78787879H

; 1275 :     _CONSTEXPR20_CONTAINER void resize(_CRT_GUARDOVERFLOW const size_type _Newsize) {

	push	edi

; 1250 :         const auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);

	mov	edi, DWORD PTR [ebx+4]
	mov	edx, edi
	mov	ebp, DWORD PTR [ebx]
	sub	edx, ebp
	imul	edx
	sar	edx, 6
	mov	esi, edx
	shr	esi, 31					; 0000001fH
	add	esi, edx

; 1251 :         if (_Newsize < _Oldsize) { // trim

	cmp	esi, 100				; 00000064H
	jbe	SHORT $LN4@resize

; 1276 :         // trim or append value-initialized elements, provide strong guarantee
; 1277 :         _Resize(_Newsize, _Value_init_tag{});
; 1278 :     }

	pop	edi
	pop	esi

; 1252 :             const pointer _Newlast = _Myfirst + _Newsize;

	lea	eax, DWORD PTR [ebp+13600]

; 1276 :         // trim or append value-initialized elements, provide strong guarantee
; 1277 :         _Resize(_Newsize, _Value_init_tag{});
; 1278 :     }

	pop	ebp

; 1255 :             _Mylast = _Newlast;

	mov	DWORD PTR [ebx+4], eax

; 1276 :         // trim or append value-initialized elements, provide strong guarantee
; 1277 :         _Resize(_Newsize, _Value_init_tag{});
; 1278 :     }

	pop	ebx
	pop	ecx
	ret	4
$LN4@resize:

; 1259 :         if (_Newsize > _Oldsize) { // append

	jae	SHORT $LN5@resize

; 1260 :             const auto _Oldcapacity = static_cast<size_type>(_My_data._Myend - _Myfirst);

	mov	ecx, DWORD PTR [ebx+8]
	mov	eax, 2021161081				; 78787879H
	sub	ecx, ebp
	imul	ecx
	sar	edx, 6
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx

; 1261 :             if (_Newsize > _Oldcapacity) { // reallocate

	cmp	eax, 100				; 00000064H
	jae	SHORT $LN6@resize

; 1262 :                 _Resize_reallocate(_Newsize, _Val);

	lea	eax, DWORD PTR $T2[esp+20]
	push	eax
	push	ecx
	mov	ecx, ebx
	call	??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@Urecv@CLightProjector@@V?$xalloc@Urecv@CLightProjector@@@@@std@@AAEXIABU_Value_init_tag@1@@Z ; std::vector<CLightProjector::recv,xalloc<CLightProjector::recv> >::_Resize_reallocate<std::_Value_init_tag>
	pop	edi

; 1276 :         // trim or append value-initialized elements, provide strong guarantee
; 1277 :         _Resize(_Newsize, _Value_init_tag{});
; 1278 :     }

	pop	esi
	pop	ebp
	pop	ebx
	pop	ecx
	ret	4
$LN6@resize:

; 1267 :             _Mylast                = _Ufill(_Oldlast, _Newsize - _Oldsize, _Val);

	mov	eax, 100				; 00000064H
	sub	eax, esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1813 :     for (; 0 < _Count; --_Count) {

	je	SHORT $LN13@resize
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1267 :             _Mylast                = _Ufill(_Oldlast, _Newsize - _Oldsize, _Val);

	imul	esi, eax, 136
	push	esi
	push	0
	push	edi
	call	_memset
	add	esp, 12					; 0000000cH
	add	edi, esi
$LN13@resize:
	mov	DWORD PTR [ebx+4], edi
$LN5@resize:
	pop	edi

; 1276 :         // trim or append value-initialized elements, provide strong guarantee
; 1277 :         _Resize(_Newsize, _Value_init_tag{});
; 1278 :     }

	pop	esi
	pop	ebp
	pop	ebx
	pop	ecx
	ret	4
?resize@?$vector@Urecv@CLightProjector@@V?$xalloc@Urecv@CLightProjector@@@@@std@@QAEXI@Z ENDP ; std::vector<CLightProjector::recv,xalloc<CLightProjector::recv> >::resize
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??1?$vector@Urecv@CLightProjector@@V?$xalloc@Urecv@CLightProjector@@@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@Urecv@CLightProjector@@V?$xalloc@Urecv@CLightProjector@@@@@std@@QAE@XZ PROC ; std::vector<CLightProjector::recv,xalloc<CLightProjector::recv> >::~vector<CLightProjector::recv,xalloc<CLightProjector::recv> >, COMDAT
; _this$ = ecx

; 698  :     _CONSTEXPR20_CONTAINER ~vector() noexcept {

	push	esi
	mov	esi, ecx

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN4@vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+4], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+8], 0
$LN4@vector:
	pop	esi

; 699  :         _Tidy();
; 700  : #if _ITERATOR_DEBUG_LEVEL != 0
; 701  :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 702  :         _Delete_plain_internal(_Alproxy, _STD exchange(_Mypair._Myval2._Myproxy, nullptr));
; 703  : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 704  :     }

	ret	0
??1?$vector@Urecv@CLightProjector@@V?$xalloc@Urecv@CLightProjector@@@@@std@@QAE@XZ ENDP ; std::vector<CLightProjector::recv,xalloc<CLightProjector::recv> >::~vector<CLightProjector::recv,xalloc<CLightProjector::recv> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrEngine\pure.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrEngine\pure.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrEngine\pure.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrEngine\pure.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrEngine\pure.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrEngine\pure.h
;	COMDAT ?Remove@?$CRegistrator@VpureAppActivate@@@@QAEXPAVpureAppActivate@@@Z
_TEXT	SEGMENT
_obj$ = 8						; size = 4
?Remove@?$CRegistrator@VpureAppActivate@@@@QAEXPAVpureAppActivate@@@Z PROC ; CRegistrator<pureAppActivate>::Remove, COMDAT
; _this$ = ecx

; 62   : 	{

	push	esi
	mov	esi, ecx
	push	edi

; 63   : 		for (u32 i = 0; i < R.size(); i++) {

	xor	edi, edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	edx, DWORD PTR [esi+4]
	mov	eax, DWORD PTR [esi]
	sub	edx, eax
	sar	edx, 2
	imul	ecx, edx, -1431655765
; File I:\Vitalya\mine\NSProjectX\xrEngine\pure.h

; 63   : 		for (u32 i = 0; i < R.size(); i++) {

	test	ecx, ecx
	je	SHORT $LN3@Remove
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1535 :         auto& _My_data = _Mypair._Myval2;

	push	ebx
	mov	ebx, DWORD PTR _obj$[esp+8]
	xor	edx, edx
$LL4@Remove:
; File I:\Vitalya\mine\NSProjectX\xrEngine\pure.h

; 64   : 			if (R[i].Object == obj) R[i].Prio = REG_PRIORITY_INVALID;

	cmp	DWORD PTR [edx+eax], ebx
	lea	ecx, DWORD PTR [edx+eax]
	jne	SHORT $LN2@Remove
	mov	DWORD PTR [ecx+4], -1
	mov	eax, DWORD PTR [esi]
$LN2@Remove:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	ecx, DWORD PTR [esi+4]
; File I:\Vitalya\mine\NSProjectX\xrEngine\pure.h

; 63   : 		for (u32 i = 0; i < R.size(); i++) {

	inc	edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	sub	ecx, eax
; File I:\Vitalya\mine\NSProjectX\xrEngine\pure.h

; 63   : 		for (u32 i = 0; i < R.size(); i++) {

	add	edx, 12					; 0000000cH
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	sar	ecx, 2
	imul	ecx, ecx, -1431655765
; File I:\Vitalya\mine\NSProjectX\xrEngine\pure.h

; 63   : 		for (u32 i = 0; i < R.size(); i++) {

	cmp	edi, ecx
	jb	SHORT $LL4@Remove
	pop	ebx
$LN3@Remove:

; 65   : 		}
; 66   : 		if (in_process)		changed = true;

	mov	eax, DWORD PTR [esi+12]
	test	al, 1
	je	SHORT $LN6@Remove
	or	eax, 2
	pop	edi
	mov	DWORD PTR [esi+12], eax

; 68   : 	};

	pop	esi
	ret	4
$LN6@Remove:

; 67   : 		else Resort();

	mov	ecx, esi
	call	?Resort@?$CRegistrator@VpureAppActivate@@@@QAEXXZ ; CRegistrator<pureAppActivate>::Resort
	pop	edi

; 68   : 	};

	pop	esi
	ret	4
?Remove@?$CRegistrator@VpureAppActivate@@@@QAEXPAVpureAppActivate@@@Z ENDP ; CRegistrator<pureAppActivate>::Remove
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrEngine\pure.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrEngine\pure.h
;	COMDAT ?Add@?$CRegistrator@VpureAppActivate@@@@QAEXPAVpureAppActivate@@HI@Z
_TEXT	SEGMENT
_I$ = -12						; size = 12
_obj$ = 8						; size = 4
_priority$dead$ = 12					; size = 4
_flags$dead$ = 16					; size = 4
?Add@?$CRegistrator@VpureAppActivate@@@@QAEXPAVpureAppActivate@@HI@Z PROC ; CRegistrator<pureAppActivate>::Add, COMDAT
; _this$ = ecx

; 46   : 	{

	sub	esp, 12					; 0000000cH
	push	esi
	mov	esi, ecx

; 47   : #ifdef DEBUG
; 48   : 		VERIFY(priority != REG_PRIORITY_INVALID);
; 49   : 		VERIFY(obj);
; 50   : 		for (u32 i = 0; i < R.size(); i++) VERIFY(!((R[i].Prio != REG_PRIORITY_INVALID) && (R[i].Object == (void*)obj)));
; 51   : #endif
; 52   : 		_REG_INFO			I;
; 53   : 		I.Object = obj;
; 54   : 		I.Prio = priority;

	mov	DWORD PTR _I$[esp+20], 572662306	; 22222222H
	mov	ecx, DWORD PTR _obj$[esp+12]
	mov	DWORD PTR _I$[esp+16], ecx

; 55   : 		I.Flags = flags;

	mov	DWORD PTR _I$[esp+24], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 730  :         if (_Mylast != _My_data._Myend) {

	mov	eax, DWORD PTR [esi+4]
	cmp	eax, DWORD PTR [esi+8]
	je	SHORT $LN8@Add
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], 572662306		; 22222222H
	mov	DWORD PTR [eax+8], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 716  :         ++_Mylast;

	add	DWORD PTR [esi+4], 12			; 0000000cH

; 731  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

	jmp	SHORT $LN7@Add
$LN8@Add:

; 732  :         }
; 733  : 
; 734  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	lea	ecx, DWORD PTR _I$[esp+16]
	push	ecx
	push	eax
	mov	ecx, esi
	call	??$_Emplace_reallocate@ABU_REG_INFO@@@?$vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@std@@QAEPAU_REG_INFO@@QAU2@ABU2@@Z ; std::vector<_REG_INFO,xalloc<_REG_INFO> >::_Emplace_reallocate<_REG_INFO const &>
$LN7@Add:
; File I:\Vitalya\mine\NSProjectX\xrEngine\pure.h

; 58   : 		if (in_process)		changed = true;

	mov	eax, DWORD PTR [esi+12]
	test	al, 1
	je	SHORT $LN2@Add
	or	eax, 2
	mov	DWORD PTR [esi+12], eax
	pop	esi

; 60   : 	};

	add	esp, 12					; 0000000cH
	ret	12					; 0000000cH
$LN2@Add:

; 59   : 		else Resort();

	mov	ecx, esi
	call	?Resort@?$CRegistrator@VpureAppActivate@@@@QAEXXZ ; CRegistrator<pureAppActivate>::Resort
	pop	esi

; 60   : 	};

	add	esp, 12					; 0000000cH
	ret	12					; 0000000cH
?Add@?$CRegistrator@VpureAppActivate@@@@QAEXPAVpureAppActivate@@HI@Z ENDP ; CRegistrator<pureAppActivate>::Add
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h
;	COMDAT ?scale@?$_box3@M@@QAEAAV1@M@Z
_TEXT	SEGMENT
_s$dead$ = 8						; size = 4
?scale@?$_box3@M@@QAEAAV1@M@Z PROC			; _box3<float>::scale, COMDAT
; _this$ = ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	xmm1, DWORD PTR [ecx]
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h

; 112  : 		return				*this;

	mov	eax, ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	xmm2, DWORD PTR [ecx+4]
	movss	xmm3, DWORD PTR [ecx+8]
	movss	xmm6, DWORD PTR [ecx+12]
	movss	xmm4, DWORD PTR [ecx+16]
	subss	xmm6, xmm1
	movss	xmm5, DWORD PTR [ecx+20]
	subss	xmm4, xmm2
	movss	xmm0, DWORD PTR __real@3dcccccd
	subss	xmm5, xmm3
	mulss	xmm6, xmm0

; 40   : 	ICF SelfRef	mul(T s)								{ x*=s;		y*=s;		z*=s;			return *this;	};

	mulss	xmm4, xmm0
	mulss	xmm5, xmm0

; 34   : 	ICF	SelfRef	sub(const Self &v)						{ x-=v.x;	y-=v.y;		z-=v.z;			return *this;	};

	subss	xmm1, xmm6
	subss	xmm2, xmm4
	subss	xmm3, xmm5
	movss	DWORD PTR [ecx], xmm1

; 29   : 	ICF	SelfRef	add(const Self &v)						{ x+=v.x;	y+=v.y;		z+=v.z;			return *this;	};

	addss	xmm4, DWORD PTR [ecx+16]
	addss	xmm5, DWORD PTR [ecx+20]

; 34   : 	ICF	SelfRef	sub(const Self &v)						{ x-=v.x;	y-=v.y;		z-=v.z;			return *this;	};

	movss	DWORD PTR [ecx+4], xmm2
	movss	DWORD PTR [ecx+8], xmm3

; 29   : 	ICF	SelfRef	add(const Self &v)						{ x+=v.x;	y+=v.y;		z+=v.z;			return *this;	};

	addss	xmm6, DWORD PTR [ecx+12]
	movss	DWORD PTR [ecx+16], xmm4
	movss	DWORD PTR [ecx+20], xmm5
	movss	DWORD PTR [ecx+12], xmm6
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h

; 113  : 	}

	ret	4
?scale@?$_box3@M@@QAEAAV1@M@Z ENDP			; _box3<float>::scale
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h
;	COMDAT ?contains@?$_box3@M@@QBEHABV1@@Z
_TEXT	SEGMENT
_b$ = 8							; size = 4
?contains@?$_box3@M@@QBEHABV1@@Z PROC			; _box3<float>::contains, COMDAT
; _this$ = ecx

; 50   : 	ICF	BOOL	contains	(const Tvector &p)	const		{ return contains(p.x,p.y,p.z);	};

	mov	eax, DWORD PTR _b$[esp-4]

; 49   : 	ICF	BOOL	contains	(T x, T y, T z)		const		{ return (x>=x1) && (x<=x2) && (y>=y1) && (y<=y2) && (z>=z1) && (z<=z2); };

	movss	xmm6, DWORD PTR [ecx]

; 50   : 	ICF	BOOL	contains	(const Tvector &p)	const		{ return contains(p.x,p.y,p.z);	};

	movss	xmm0, DWORD PTR [eax]

; 49   : 	ICF	BOOL	contains	(T x, T y, T z)		const		{ return (x>=x1) && (x<=x2) && (y>=y1) && (y<=y2) && (z>=z1) && (z<=z2); };

	comiss	xmm0, xmm6
	jb	SHORT $LN3@contains
	movss	xmm1, DWORD PTR [ecx+12]
	comiss	xmm1, xmm0
	jb	SHORT $LN3@contains
	movss	xmm4, DWORD PTR [ecx+4]

; 50   : 	ICF	BOOL	contains	(const Tvector &p)	const		{ return contains(p.x,p.y,p.z);	};

	movss	xmm0, DWORD PTR [eax+4]

; 49   : 	ICF	BOOL	contains	(T x, T y, T z)		const		{ return (x>=x1) && (x<=x2) && (y>=y1) && (y<=y2) && (z>=z1) && (z<=z2); };

	comiss	xmm0, xmm4
	jb	SHORT $LN3@contains
	movss	xmm3, DWORD PTR [ecx+16]
	comiss	xmm3, xmm0
	jb	SHORT $LN3@contains
	movss	xmm5, DWORD PTR [ecx+8]

; 50   : 	ICF	BOOL	contains	(const Tvector &p)	const		{ return contains(p.x,p.y,p.z);	};

	movss	xmm0, DWORD PTR [eax+8]

; 49   : 	ICF	BOOL	contains	(T x, T y, T z)		const		{ return (x>=x1) && (x<=x2) && (y>=y1) && (y<=y2) && (z>=z1) && (z<=z2); };

	comiss	xmm0, xmm5
	jb	SHORT $LN3@contains
	movss	xmm2, DWORD PTR [ecx+20]
	comiss	xmm2, xmm0
	jb	SHORT $LN3@contains

; 50   : 	ICF	BOOL	contains	(const Tvector &p)	const		{ return contains(p.x,p.y,p.z);	};

	movss	xmm0, DWORD PTR [eax+12]

; 49   : 	ICF	BOOL	contains	(T x, T y, T z)		const		{ return (x>=x1) && (x<=x2) && (y>=y1) && (y<=y2) && (z>=z1) && (z<=z2); };

	comiss	xmm0, xmm6
	jb	SHORT $LN3@contains
	comiss	xmm1, xmm0
	jb	SHORT $LN3@contains

; 50   : 	ICF	BOOL	contains	(const Tvector &p)	const		{ return contains(p.x,p.y,p.z);	};

	movss	xmm0, DWORD PTR [eax+16]

; 49   : 	ICF	BOOL	contains	(T x, T y, T z)		const		{ return (x>=x1) && (x<=x2) && (y>=y1) && (y<=y2) && (z>=z1) && (z<=z2); };

	comiss	xmm0, xmm4
	jb	SHORT $LN3@contains
	comiss	xmm3, xmm0
	jb	SHORT $LN3@contains

; 50   : 	ICF	BOOL	contains	(const Tvector &p)	const		{ return contains(p.x,p.y,p.z);	};

	movss	xmm0, DWORD PTR [eax+20]

; 49   : 	ICF	BOOL	contains	(T x, T y, T z)		const		{ return (x>=x1) && (x<=x2) && (y>=y1) && (y<=y2) && (z>=z1) && (z<=z2); };

	comiss	xmm0, xmm5
	jb	SHORT $LN3@contains
	comiss	xmm2, xmm0
	jb	SHORT $LN3@contains

; 51   : 	ICF	BOOL	contains	(SelfCRef b)		const		{ return contains(b.min) && contains(b.max); };

	mov	eax, 1
	ret	4
$LN3@contains:
	xor	eax, eax
	ret	4
?contains@?$_box3@M@@QBEHABV1@@Z ENDP			; _box3<float>::contains
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
;	COMDAT ?translate@?$_matrix@M@@QAEAAU1@MMM@Z
_TEXT	SEGMENT
__x$ = 8						; size = 4
__y$ = 12						; size = 4
__z$dead$ = 16						; size = 4
?translate@?$_matrix@M@@QAEAAU1@MMM@Z PROC		; _matrix<float>::translate, COMDAT
; _this$ = ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 23   : 	ICF	SelfRef	set(T _x, T _y, T _z)					{ x = _x;		y = _y;		z = _z;		return *this;	};

	movss	xmm0, DWORD PTR __x$[esp-4]
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 241  : 		return *this;

	mov	eax, ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 23   : 	ICF	SelfRef	set(T _x, T _y, T _z)					{ x = _x;		y = _y;		z = _z;		return *this;	};

	movss	DWORD PTR [ecx+48], xmm0
	movss	xmm0, DWORD PTR __y$[esp-4]
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 75   : 		_41=0; _42=0; _43=0; _44=1;

	mov	DWORD PTR [ecx+52], 0
	mov	DWORD PTR [ecx+56], 0
	mov	DWORD PTR [ecx], 1065353216		; 3f800000H
	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0
	mov	DWORD PTR [ecx+12], 0
	mov	DWORD PTR [ecx+16], 0
	mov	DWORD PTR [ecx+20], 1065353216		; 3f800000H
	mov	DWORD PTR [ecx+24], 0
	mov	DWORD PTR [ecx+28], 0
	mov	DWORD PTR [ecx+32], 0
	mov	DWORD PTR [ecx+36], 0
	mov	DWORD PTR [ecx+40], 1065353216		; 3f800000H
	mov	DWORD PTR [ecx+44], 0
	mov	DWORD PTR [ecx+60], 1065353216		; 3f800000H
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 23   : 	ICF	SelfRef	set(T _x, T _y, T _z)					{ x = _x;		y = _y;		z = _z;		return *this;	};

	movss	DWORD PTR [ecx+52], xmm0
	mov	DWORD PTR [ecx+56], 0
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 242  : 	}

	ret	12					; 0000000cH
?translate@?$_matrix@M@@QAEAAU1@MMM@Z ENDP		; _matrix<float>::translate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
;	COMDAT ?mulA_44@?$_matrix@M@@QAEAAU1@ABU1@@Z
_TEXT	SEGMENT
tv1642 = -36						; size = 4
tv1641 = -32						; size = 4
tv1643 = -28						; size = 4
tv1656 = -24						; size = 4
tv1659 = -20						; size = 4
tv1658 = -16						; size = 4
tv1674 = -12						; size = 4
tv1672 = -8						; size = 4
tv1675 = -4						; size = 4
_A$ = 8							; size = 4
?mulA_44@?$_matrix@M@@QAEAAU1@ABU1@@Z PROC		; _matrix<float>::mulA_44, COMDAT
; _this$ = ecx

; 85   : 		m[0][0] = A.m[0][0] * B.m[0][0] + A.m[1][0] * B.m[0][1] + A.m[2][0] * B.m[0][2] + A.m[3][0] * B.m[0][3];

	mov	eax, DWORD PTR _A$[esp-4]

; 133  : 	{

	sub	esp, 36					; 00000024H
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 24   : 	ICF SelfRef	set(const _vector3<float> &v)			{ x = T(v.x);	y = T(v.y);	z = T(v.z);	return *this;	};

	movss	xmm5, DWORD PTR [ecx+8]
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 56   : 		i.set(a.i); _14_=a._14;

	movss	xmm3, DWORD PTR [ecx+12]

; 85   : 		m[0][0] = A.m[0][0] * B.m[0][0] + A.m[1][0] * B.m[0][1] + A.m[2][0] * B.m[0][2] + A.m[3][0] * B.m[0][3];

	movaps	xmm2, xmm5
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 24   : 	ICF SelfRef	set(const _vector3<float> &v)			{ x = T(v.x);	y = T(v.y);	z = T(v.z);	return *this;	};

	movss	xmm4, DWORD PTR [ecx+4]
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 85   : 		m[0][0] = A.m[0][0] * B.m[0][0] + A.m[1][0] * B.m[0][1] + A.m[2][0] * B.m[0][2] + A.m[3][0] * B.m[0][3];

	movaps	xmm0, xmm3
	mulss	xmm2, DWORD PTR [eax+32]
	movaps	xmm1, xmm4
	mulss	xmm0, DWORD PTR [eax+48]
	mulss	xmm1, DWORD PTR [eax+16]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 24   : 	ICF SelfRef	set(const _vector3<float> &v)			{ x = T(v.x);	y = T(v.y);	z = T(v.z);	return *this;	};

	movss	xmm6, DWORD PTR [ecx]
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 85   : 		m[0][0] = A.m[0][0] * B.m[0][0] + A.m[1][0] * B.m[0][1] + A.m[2][0] * B.m[0][2] + A.m[3][0] * B.m[0][3];

	addss	xmm2, xmm0
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 24   : 	ICF SelfRef	set(const _vector3<float> &v)			{ x = T(v.x);	y = T(v.y);	z = T(v.z);	return *this;	};

	movss	xmm7, DWORD PTR [ecx+24]
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 85   : 		m[0][0] = A.m[0][0] * B.m[0][0] + A.m[1][0] * B.m[0][1] + A.m[2][0] * B.m[0][2] + A.m[3][0] * B.m[0][3];

	movaps	xmm0, xmm6
	mulss	xmm0, DWORD PTR [eax]
	addss	xmm1, xmm0

; 86   : 		m[0][1] = A.m[0][1] * B.m[0][0] + A.m[1][1] * B.m[0][1] + A.m[2][1] * B.m[0][2] + A.m[3][1] * B.m[0][3];

	movaps	xmm0, xmm3
	addss	xmm2, xmm1
	movaps	xmm1, xmm6
	movss	DWORD PTR [ecx], xmm2
	movaps	xmm2, xmm5
	mulss	xmm2, DWORD PTR [eax+36]
	mulss	xmm0, DWORD PTR [eax+52]
	mulss	xmm1, DWORD PTR [eax+4]
	addss	xmm2, xmm0
	movaps	xmm0, xmm4
	mulss	xmm0, DWORD PTR [eax+20]
	addss	xmm1, xmm0

; 87   : 		m[0][2] = A.m[0][2] * B.m[0][0] + A.m[1][2] * B.m[0][1] + A.m[2][2] * B.m[0][2] + A.m[3][2] * B.m[0][3];

	movaps	xmm0, xmm6
	addss	xmm2, xmm1
	movaps	xmm1, xmm5
	movss	DWORD PTR [ecx+4], xmm2
	movaps	xmm2, xmm4
	mulss	xmm2, DWORD PTR [eax+24]
	mulss	xmm0, DWORD PTR [eax+8]
	mulss	xmm1, DWORD PTR [eax+40]
	addss	xmm2, xmm0
	movaps	xmm0, xmm3
	mulss	xmm0, DWORD PTR [eax+56]
	addss	xmm1, xmm0
	addss	xmm2, xmm1

; 88   : 		m[0][3] = A.m[0][3] * B.m[0][0] + A.m[1][3] * B.m[0][1] + A.m[2][3] * B.m[0][2] + A.m[3][3] * B.m[0][3];
; 89   : 
; 90   : 		m[1][0] = A.m[0][0] * B.m[1][0] + A.m[1][0] * B.m[1][1] + A.m[2][0] * B.m[1][2] + A.m[3][0] * B.m[1][3];

	movaps	xmm1, xmm7
	movss	DWORD PTR [ecx+8], xmm2
	mulss	xmm6, DWORD PTR [eax+12]
	mulss	xmm4, DWORD PTR [eax+28]
	mulss	xmm3, DWORD PTR [eax+60]
	mulss	xmm5, DWORD PTR [eax+44]
	addss	xmm6, xmm4
	addss	xmm3, xmm5
	addss	xmm6, xmm3
	movss	xmm3, DWORD PTR [ecx+28]
	movss	DWORD PTR [ecx+12], xmm6
	movss	xmm5, DWORD PTR [ecx+16]
	movss	xmm4, DWORD PTR [ecx+20]
	movaps	xmm2, xmm5
	mulss	xmm2, DWORD PTR [eax]
	movaps	xmm0, xmm4
	mulss	xmm0, DWORD PTR [eax+16]
	mulss	xmm1, DWORD PTR [eax+32]
	addss	xmm2, xmm0
	movaps	xmm0, xmm3
	mulss	xmm0, DWORD PTR [eax+48]
	addss	xmm1, xmm0

; 91   : 		m[1][1] = A.m[0][1] * B.m[1][0] + A.m[1][1] * B.m[1][1] + A.m[2][1] * B.m[1][2] + A.m[3][1] * B.m[1][3];

	movaps	xmm0, xmm3
	addss	xmm2, xmm1
	movaps	xmm1, xmm5
	movss	DWORD PTR [ecx+16], xmm2
	movaps	xmm2, xmm7
	mulss	xmm2, DWORD PTR [eax+36]
	mulss	xmm0, DWORD PTR [eax+52]
	mulss	xmm1, DWORD PTR [eax+4]
	addss	xmm2, xmm0
	movaps	xmm0, xmm4
	mulss	xmm0, DWORD PTR [eax+20]
	addss	xmm1, xmm0

; 92   : 		m[1][2] = A.m[0][2] * B.m[1][0] + A.m[1][2] * B.m[1][1] + A.m[2][2] * B.m[1][2] + A.m[3][2] * B.m[1][3];

	movaps	xmm0, xmm5
	addss	xmm2, xmm1
	movss	DWORD PTR [ecx+20], xmm2
	movaps	xmm2, xmm4
	mulss	xmm2, DWORD PTR [eax+24]
	mulss	xmm0, DWORD PTR [eax+8]
	movaps	xmm1, xmm7
	mulss	xmm1, DWORD PTR [eax+40]
	addss	xmm2, xmm0
	movaps	xmm0, xmm3
	mulss	xmm0, DWORD PTR [eax+56]
	addss	xmm1, xmm0
	addss	xmm2, xmm1
	movss	DWORD PTR [ecx+24], xmm2

; 93   : 		m[1][3] = A.m[0][3] * B.m[1][0] + A.m[1][3] * B.m[1][1] + A.m[2][3] * B.m[1][2] + A.m[3][3] * B.m[1][3];

	mulss	xmm3, DWORD PTR [eax+60]
	mulss	xmm5, DWORD PTR [eax+12]
	mulss	xmm4, DWORD PTR [eax+28]
	mulss	xmm7, DWORD PTR [eax+44]
	addss	xmm5, xmm4
	addss	xmm3, xmm7
	addss	xmm3, xmm5
	movss	DWORD PTR [ecx+28], xmm3

; 94   : 
; 95   : 		m[2][0] = A.m[0][0] * B.m[2][0] + A.m[1][0] * B.m[2][1] + A.m[2][0] * B.m[2][2] + A.m[3][0] * B.m[2][3];

	movss	xmm4, DWORD PTR [ecx+32]
	movss	xmm6, DWORD PTR [ecx+36]
	movaps	xmm2, xmm4
	mulss	xmm2, DWORD PTR [eax]
	movaps	xmm0, xmm6
	mulss	xmm0, DWORD PTR [eax+16]
	movss	xmm5, DWORD PTR [ecx+40]
	movss	xmm3, DWORD PTR [ecx+44]
	movaps	xmm1, xmm5
	mulss	xmm1, DWORD PTR [eax+32]
	addss	xmm2, xmm0
	movaps	xmm0, xmm3
	mulss	xmm0, DWORD PTR [eax+48]
	addss	xmm1, xmm0

; 96   : 		m[2][1] = A.m[0][1] * B.m[2][0] + A.m[1][1] * B.m[2][1] + A.m[2][1] * B.m[2][2] + A.m[3][1] * B.m[2][3];

	movaps	xmm0, xmm6
	addss	xmm2, xmm1
	movaps	xmm1, xmm5
	movss	DWORD PTR [ecx+32], xmm2
	movaps	xmm2, xmm4
	mulss	xmm0, DWORD PTR [eax+20]
	mulss	xmm2, DWORD PTR [eax+4]
	mulss	xmm1, DWORD PTR [eax+36]
	addss	xmm2, xmm0
	movaps	xmm0, xmm3
	mulss	xmm0, DWORD PTR [eax+52]
	addss	xmm1, xmm0

; 97   : 		m[2][2] = A.m[0][2] * B.m[2][0] + A.m[1][2] * B.m[2][1] + A.m[2][2] * B.m[2][2] + A.m[3][2] * B.m[2][3];

	movaps	xmm0, xmm3
	addss	xmm2, xmm1
	movaps	xmm1, xmm4
	movss	DWORD PTR [ecx+36], xmm2
	movaps	xmm2, xmm5
	mulss	xmm0, DWORD PTR [eax+56]
	mulss	xmm2, DWORD PTR [eax+40]
	mulss	xmm1, DWORD PTR [eax+8]
	addss	xmm2, xmm0
	movaps	xmm0, xmm6
	mulss	xmm0, DWORD PTR [eax+24]
	addss	xmm1, xmm0
	addss	xmm2, xmm1
	movss	DWORD PTR [ecx+40], xmm2

; 98   : 		m[2][3] = A.m[0][3] * B.m[2][0] + A.m[1][3] * B.m[2][1] + A.m[2][3] * B.m[2][2] + A.m[3][3] * B.m[2][3];

	mulss	xmm6, DWORD PTR [eax+28]
	mulss	xmm4, DWORD PTR [eax+12]
	mulss	xmm5, DWORD PTR [eax+44]
	mulss	xmm3, DWORD PTR [eax+60]
	addss	xmm6, xmm4

; 99   : 
; 100  : 		m[3][0] = A.m[0][0] * B.m[3][0] + A.m[1][0] * B.m[3][1] + A.m[2][0] * B.m[3][2] + A.m[3][0] * B.m[3][3];

	movss	xmm4, DWORD PTR [ecx+60]
	movaps	xmm2, xmm4
	addss	xmm5, xmm3
	addss	xmm6, xmm5
	movss	DWORD PTR [ecx+44], xmm6
	movss	xmm5, DWORD PTR [ecx+56]
	mulss	xmm2, DWORD PTR [eax+48]
	movaps	xmm0, xmm5
	mulss	xmm0, DWORD PTR [eax+32]
	movss	xmm3, DWORD PTR [ecx+52]
	movss	xmm6, DWORD PTR [ecx+48]
	movaps	xmm1, xmm3
	mulss	xmm1, DWORD PTR [eax+16]
	addss	xmm2, xmm0
	movaps	xmm0, xmm6
	mulss	xmm0, DWORD PTR [eax]
	addss	xmm1, xmm0
	addss	xmm2, xmm1
	movss	DWORD PTR [ecx+48], xmm2

; 101  : 		m[3][1] = A.m[0][1] * B.m[3][0] + A.m[1][1] * B.m[3][1] + A.m[2][1] * B.m[3][2] + A.m[3][1] * B.m[3][3];

	movaps	xmm0, xmm5
	movaps	xmm2, xmm4
	mulss	xmm0, DWORD PTR [eax+36]
	movaps	xmm1, xmm3
	mulss	xmm2, DWORD PTR [eax+52]
	mulss	xmm1, DWORD PTR [eax+20]
	addss	xmm2, xmm0
	movaps	xmm0, xmm6
	mulss	xmm0, DWORD PTR [eax+4]
	addss	xmm1, xmm0

; 102  : 		m[3][2] = A.m[0][2] * B.m[3][0] + A.m[1][2] * B.m[3][1] + A.m[2][2] * B.m[3][2] + A.m[3][2] * B.m[3][3];

	movaps	xmm0, xmm4
	addss	xmm2, xmm1
	movaps	xmm1, xmm6
	movss	DWORD PTR [ecx+52], xmm2
	movaps	xmm2, xmm5
	mulss	xmm0, DWORD PTR [eax+56]
	mulss	xmm2, DWORD PTR [eax+40]
	mulss	xmm1, DWORD PTR [eax+8]
	addss	xmm2, xmm0
	movaps	xmm0, xmm3
	mulss	xmm0, DWORD PTR [eax+24]
	addss	xmm1, xmm0
	addss	xmm2, xmm1
	movss	DWORD PTR [ecx+56], xmm2

; 103  : 		m[3][3] = A.m[0][3] * B.m[3][0] + A.m[1][3] * B.m[3][1] + A.m[2][3] * B.m[3][2] + A.m[3][3] * B.m[3][3];

	mulss	xmm6, DWORD PTR [eax+12]
	mulss	xmm3, DWORD PTR [eax+28]
	mulss	xmm5, DWORD PTR [eax+44]
	mulss	xmm4, DWORD PTR [eax+60]
	addss	xmm6, xmm3

; 134  :     	Self B; B.set( *this ); 	mul		( A, B );
; 135  : 		return *this;

	mov	eax, ecx

; 103  : 		m[3][3] = A.m[0][3] * B.m[3][0] + A.m[1][3] * B.m[3][1] + A.m[2][3] * B.m[3][2] + A.m[3][3] * B.m[3][3];

	addss	xmm5, xmm4
	addss	xmm6, xmm5
	movss	DWORD PTR [ecx+60], xmm6

; 136  :     };

	add	esp, 36					; 00000024H
	ret	4
?mulA_44@?$_matrix@M@@QAEAAU1@ABU1@@Z ENDP		; _matrix<float>::mulA_44
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?back@?$vector@HV?$xalloc@H@@@std@@QAEAAHXZ
_TEXT	SEGMENT
?back@?$vector@HV?$xalloc@H@@@std@@QAEAAHXZ PROC	; std::vector<int,xalloc<int> >::back, COMDAT
; _this$ = ecx

; 1606 :         auto& _My_data = _Mypair._Myval2;
; 1607 : #if _CONTAINER_DEBUG_LEVEL > 0
; 1608 :         _STL_VERIFY(_My_data._Myfirst != _My_data._Mylast, "back() called on empty vector");
; 1609 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 1610 : 
; 1611 :         return _My_data._Mylast[-1];

	mov	eax, DWORD PTR [ecx+4]
	sub	eax, 4

; 1612 :     }

	ret	0
?back@?$vector@HV?$xalloc@H@@@std@@QAEAAHXZ ENDP	; std::vector<int,xalloc<int> >::back
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?empty@?$vector@HV?$xalloc@H@@@std@@QBE_NXZ
_TEXT	SEGMENT
?empty@?$vector@HV?$xalloc@H@@@std@@QBE_NXZ PROC	; std::vector<int,xalloc<int> >::empty, COMDAT
; _this$ = ecx

; 1530 :         auto& _My_data = _Mypair._Myval2;
; 1531 :         return _My_data._Myfirst == _My_data._Mylast;

	mov	eax, DWORD PTR [ecx]
	cmp	eax, DWORD PTR [ecx+4]
	sete	al

; 1532 :     }

	ret	0
?empty@?$vector@HV?$xalloc@H@@@std@@QBE_NXZ ENDP	; std::vector<int,xalloc<int> >::empty
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?pop_back@?$vector@HV?$xalloc@H@@@std@@QAEXXZ
_TEXT	SEGMENT
?pop_back@?$vector@HV?$xalloc@H@@@std@@QAEXXZ PROC	; std::vector<int,xalloc<int> >::pop_back, COMDAT
; _this$ = ecx

; 1381 :         auto& _My_data   = _Mypair._Myval2;
; 1382 :         pointer& _Mylast = _My_data._Mylast;
; 1383 : 
; 1384 : #if _ITERATOR_DEBUG_LEVEL == 2
; 1385 :         _STL_VERIFY(_My_data._Myfirst != _Mylast, "vector empty before pop");
; 1386 : #endif // _ITERATOR_DEBUG_LEVEL == 2
; 1387 : 
; 1388 :         _Orphan_range(_Mylast - 1, _Mylast);
; 1389 :         _Alty_traits::destroy(_Getal(), _Unfancy(_Mylast - 1));
; 1390 :         --_Mylast;

	add	DWORD PTR [ecx+4], -4			; fffffffcH

; 1391 :     }

	ret	0
?pop_back@?$vector@HV?$xalloc@H@@@std@@QAEXXZ ENDP	; std::vector<int,xalloc<int> >::pop_back
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@Urecv@CLightProjector@@@std@@@std@@@std@@QBE?AV01@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@Urecv@CLightProjector@@@std@@@std@@@std@@QBE?AV01@H@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CLightProjector::recv> > >::operator+, COMDAT
; _this$ = ecx

; 119  :         _Ptr += _Off;

	imul	edx, DWORD PTR __Off$[esp-4], 136
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	add	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx

; 303  :         _Vector_iterator _Tmp = *this;
; 304  :         _Tmp += _Off; // TRANSITION, LLVM-49342
; 305  :         return _Tmp;
; 306  :     }

	ret	8
??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@Urecv@CLightProjector@@@std@@@std@@@std@@QBE?AV01@H@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CLightProjector::recv> > >::operator+
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@Urecv@CLightProjector@@@std@@@std@@@std@@QBEAAUrecv@CLightProjector@@XZ
_TEXT	SEGMENT
??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@Urecv@CLightProjector@@@std@@@std@@@std@@QBEAAUrecv@CLightProjector@@XZ PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CLightProjector::recv> > >::operator*, COMDAT
; _this$ = ecx

; 261  :         return const_cast<reference>(_Mybase::operator*());

	mov	eax, DWORD PTR [ecx]

; 262  :     }

	ret	0
??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@Urecv@CLightProjector@@@std@@@std@@@std@@QBEAAUrecv@CLightProjector@@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CLightProjector::recv> > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVIRenderable@@@std@@@std@@@std@@QBE?AV01@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVIRenderable@@@std@@@std@@@std@@QBE?AV01@H@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<IRenderable *> > >::operator+, COMDAT
; _this$ = ecx

; 119  :         _Ptr += _Off;

	mov	eax, DWORD PTR __Off$[esp-4]
	mov	ecx, DWORD PTR [ecx]
	lea	ecx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 303  :         _Vector_iterator _Tmp = *this;
; 304  :         _Tmp += _Off; // TRANSITION, LLVM-49342
; 305  :         return _Tmp;
; 306  :     }

	ret	8
??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVIRenderable@@@std@@@std@@@std@@QBE?AV01@H@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<IRenderable *> > >::operator+
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVIRenderable@@@std@@@std@@@std@@QBEAAPAVIRenderable@@XZ
_TEXT	SEGMENT
??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVIRenderable@@@std@@@std@@@std@@QBEAAPAVIRenderable@@XZ PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<IRenderable *> > >::operator*, COMDAT
; _this$ = ecx

; 261  :         return const_cast<reference>(_Mybase::operator*());

	mov	eax, DWORD PTR [ecx]

; 262  :     }

	ret	0
??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVIRenderable@@@std@@@std@@@std@@QBEAAPAVIRenderable@@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<IRenderable *> > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Orphan_range@?$vector@PAVIRenderable@@V?$xalloc@PAVIRenderable@@@@@std@@ABEXPAPAVIRenderable@@0@Z
_TEXT	SEGMENT
___formal$dead$ = 8					; size = 4
___formal$dead$ = 12					; size = 4
?_Orphan_range@?$vector@PAVIRenderable@@V?$xalloc@PAVIRenderable@@@@@std@@ABEXPAPAVIRenderable@@0@Z PROC ; std::vector<IRenderable *,xalloc<IRenderable *> >::_Orphan_range, COMDAT
; _this$dead$ = ecx

; 1801 :     _CONSTEXPR20_CONTAINER void _Orphan_range(pointer, pointer) const {}

	ret	8
?_Orphan_range@?$vector@PAVIRenderable@@V?$xalloc@PAVIRenderable@@@@@std@@ABEXPAPAVIRenderable@@0@Z ENDP ; std::vector<IRenderable *,xalloc<IRenderable *> >::_Orphan_range
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Tidy@?$vector@PAVIRenderable@@V?$xalloc@PAVIRenderable@@@@@std@@AAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@PAVIRenderable@@V?$xalloc@PAVIRenderable@@@@@std@@AAEXXZ PROC ; std::vector<IRenderable *,xalloc<IRenderable *> >::_Tidy, COMDAT
; _this$ = ecx

; 1742 :     _CONSTEXPR20_CONTAINER void _Tidy() noexcept { // free all storage

	push	esi
	mov	esi, ecx

; 1743 :         auto& _My_data    = _Mypair._Myval2;
; 1744 :         pointer& _Myfirst = _My_data._Myfirst;
; 1745 :         pointer& _Mylast  = _My_data._Mylast;
; 1746 :         pointer& _Myend   = _My_data._Myend;
; 1747 : 
; 1748 :         _My_data._Orphan_all();
; 1749 : 
; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN2@Tidy
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+4], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+8], 0
$LN2@Tidy:

; 1757 :         }
; 1758 :     }

	pop	esi
	ret	0
?_Tidy@?$vector@PAVIRenderable@@V?$xalloc@PAVIRenderable@@@@@std@@AAEXXZ ENDP ; std::vector<IRenderable *,xalloc<IRenderable *> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?size@?$vector@PAVIRenderable@@V?$xalloc@PAVIRenderable@@@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@PAVIRenderable@@V?$xalloc@PAVIRenderable@@@@@std@@QBEIXZ PROC ; std::vector<IRenderable *,xalloc<IRenderable *> >::size, COMDAT
; _this$ = ecx

; 1535 :         auto& _My_data = _Mypair._Myval2;
; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	eax, DWORD PTR [ecx+4]
	sub	eax, DWORD PTR [ecx]
	sar	eax, 2

; 1537 :     }

	ret	0
?size@?$vector@PAVIRenderable@@V?$xalloc@PAVIRenderable@@@@@std@@QBEIXZ ENDP ; std::vector<IRenderable *,xalloc<IRenderable *> >::size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?begin@?$vector@PAVIRenderable@@V?$xalloc@PAVIRenderable@@@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVIRenderable@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@PAVIRenderable@@V?$xalloc@PAVIRenderable@@@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVIRenderable@@@std@@@std@@@2@XZ PROC ; std::vector<IRenderable *,xalloc<IRenderable *> >::begin, COMDAT
; _this$ = ecx

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	ecx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], ecx

; 1462 :         auto& _My_data = _Mypair._Myval2;
; 1463 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));
; 1464 :     }

	ret	4
?begin@?$vector@PAVIRenderable@@V?$xalloc@PAVIRenderable@@@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVIRenderable@@@std@@@std@@@2@XZ ENDP ; std::vector<IRenderable *,xalloc<IRenderable *> >::begin
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0?$vector@PAVIRenderable@@V?$xalloc@PAVIRenderable@@@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@PAVIRenderable@@V?$xalloc@PAVIRenderable@@@@@std@@QAE@XZ PROC ; std::vector<IRenderable *,xalloc<IRenderable *> >::vector<IRenderable *,xalloc<IRenderable *> >, COMDAT
; _this$ = ecx

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx], 0

; 464  :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 465  :     }

	mov	eax, ecx

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0

; 464  :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 465  :     }

	ret	0
??0?$vector@PAVIRenderable@@V?$xalloc@PAVIRenderable@@@@@std@@QAE@XZ ENDP ; std::vector<IRenderable *,xalloc<IRenderable *> >::vector<IRenderable *,xalloc<IRenderable *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Tidy@?$vector@Urecv@CLightProjector@@V?$xalloc@Urecv@CLightProjector@@@@@std@@AAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@Urecv@CLightProjector@@V?$xalloc@Urecv@CLightProjector@@@@@std@@AAEXXZ PROC ; std::vector<CLightProjector::recv,xalloc<CLightProjector::recv> >::_Tidy, COMDAT
; _this$ = ecx

; 1742 :     _CONSTEXPR20_CONTAINER void _Tidy() noexcept { // free all storage

	push	esi
	mov	esi, ecx

; 1743 :         auto& _My_data    = _Mypair._Myval2;
; 1744 :         pointer& _Myfirst = _My_data._Myfirst;
; 1745 :         pointer& _Mylast  = _My_data._Mylast;
; 1746 :         pointer& _Myend   = _My_data._Myend;
; 1747 : 
; 1748 :         _My_data._Orphan_all();
; 1749 : 
; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN2@Tidy
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+4], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+8], 0
$LN2@Tidy:

; 1757 :         }
; 1758 :     }

	pop	esi
	ret	0
?_Tidy@?$vector@Urecv@CLightProjector@@V?$xalloc@Urecv@CLightProjector@@@@@std@@AAEXXZ ENDP ; std::vector<CLightProjector::recv,xalloc<CLightProjector::recv> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?size@?$vector@Urecv@CLightProjector@@V?$xalloc@Urecv@CLightProjector@@@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@Urecv@CLightProjector@@V?$xalloc@Urecv@CLightProjector@@@@@std@@QBEIXZ PROC ; std::vector<CLightProjector::recv,xalloc<CLightProjector::recv> >::size, COMDAT
; _this$ = ecx

; 1535 :         auto& _My_data = _Mypair._Myval2;
; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	edx, DWORD PTR [ecx+4]
	mov	eax, 2021161081				; 78787879H
	sub	edx, DWORD PTR [ecx]
	imul	edx
	sar	edx, 6
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx

; 1537 :     }

	ret	0
?size@?$vector@Urecv@CLightProjector@@V?$xalloc@Urecv@CLightProjector@@@@@std@@QBEIXZ ENDP ; std::vector<CLightProjector::recv,xalloc<CLightProjector::recv> >::size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?begin@?$vector@Urecv@CLightProjector@@V?$xalloc@Urecv@CLightProjector@@@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@Urecv@CLightProjector@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@Urecv@CLightProjector@@V?$xalloc@Urecv@CLightProjector@@@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@Urecv@CLightProjector@@@std@@@std@@@2@XZ PROC ; std::vector<CLightProjector::recv,xalloc<CLightProjector::recv> >::begin, COMDAT
; _this$ = ecx

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	ecx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], ecx

; 1462 :         auto& _My_data = _Mypair._Myval2;
; 1463 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));
; 1464 :     }

	ret	4
?begin@?$vector@Urecv@CLightProjector@@V?$xalloc@Urecv@CLightProjector@@@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@Urecv@CLightProjector@@@std@@@std@@@2@XZ ENDP ; std::vector<CLightProjector::recv,xalloc<CLightProjector::recv> >::begin
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0?$vector@Urecv@CLightProjector@@V?$xalloc@Urecv@CLightProjector@@@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@Urecv@CLightProjector@@V?$xalloc@Urecv@CLightProjector@@@@@std@@QAE@XZ PROC ; std::vector<CLightProjector::recv,xalloc<CLightProjector::recv> >::vector<CLightProjector::recv,xalloc<CLightProjector::recv> >, COMDAT
; _this$ = ecx

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx], 0

; 464  :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 465  :     }

	mov	eax, ecx

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0

; 464  :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 465  :     }

	ret	0
??0?$vector@Urecv@CLightProjector@@V?$xalloc@Urecv@CLightProjector@@@@@std@@QAE@XZ ENDP ; std::vector<CLightProjector::recv,xalloc<CLightProjector::recv> >::vector<CLightProjector::recv,xalloc<CLightProjector::recv> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrEngine\pure.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrEngine\pure.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrEngine\pure.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrEngine\pure.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrEngine\pure.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrEngine\pure.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrEngine\pure.h
;	COMDAT ?Resort@?$CRegistrator@VpureAppActivate@@@@QAEXXZ
_TEXT	SEGMENT
?Resort@?$CRegistrator@VpureAppActivate@@@@QAEXXZ PROC	; CRegistrator<pureAppActivate>::Resort, COMDAT
; _this$ = ecx

; 83   : 	{

	push	esi

; 84   : 		qsort(&*R.begin(), R.size(), sizeof(_REG_INFO), _REG_Compare);

	push	DWORD PTR __imp_?_REG_Compare@@YAHPBX0@Z
	mov	esi, ecx
	push	12					; 0000000cH
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	edx, DWORD PTR [esi]
	mov	eax, DWORD PTR [esi+4]
	sub	eax, edx
	sar	eax, 2
	imul	eax, eax, -1431655765
; File I:\Vitalya\mine\NSProjectX\xrEngine\pure.h

; 84   : 		qsort(&*R.begin(), R.size(), sizeof(_REG_INFO), _REG_Compare);

	push	eax
	push	edx
	call	DWORD PTR __imp__qsort
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	eax, DWORD PTR [esi+4]
; File I:\Vitalya\mine\NSProjectX\xrEngine\pure.h

; 84   : 		qsort(&*R.begin(), R.size(), sizeof(_REG_INFO), _REG_Compare);

	add	esp, 16					; 00000010H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	edx, DWORD PTR [esi]
	mov	ecx, eax
	sub	ecx, edx
; File I:\Vitalya\mine\NSProjectX\xrEngine\pure.h

; 85   : 		while ((R.size()) && (R[R.size() - 1].Prio == REG_PRIORITY_INVALID)) R.pop_back();

	je	SHORT $LN50@Resort
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1535 :         auto& _My_data = _Mypair._Myval2;

	push	edi
	mov	edi, eax
$LL2@Resort:

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	ecx, edi
	sub	ecx, edx
	sar	ecx, 2
	imul	ecx, ecx, -1431655765

; 1463 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));

	lea	ecx, DWORD PTR [ecx+ecx*2]
; File I:\Vitalya\mine\NSProjectX\xrEngine\pure.h

; 85   : 		while ((R.size()) && (R[R.size() - 1].Prio == REG_PRIORITY_INVALID)) R.pop_back();

	cmp	DWORD PTR [edx+ecx*4-8], -1
	jne	SHORT $LN51@Resort
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1390 :         --_Mylast;

	lea	eax, DWORD PTR [edi-12]

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	ecx, eax

; 1390 :         --_Mylast;

	mov	DWORD PTR [esi+4], eax

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	edi, eax
	sub	ecx, edx
; File I:\Vitalya\mine\NSProjectX\xrEngine\pure.h

; 85   : 		while ((R.size()) && (R[R.size() - 1].Prio == REG_PRIORITY_INVALID)) R.pop_back();

	jne	SHORT $LL2@Resort
$LN51@Resort:
	pop	edi
$LN50@Resort:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1531 :         return _My_data._Myfirst == _My_data._Mylast;

	cmp	edx, eax
; File I:\Vitalya\mine\NSProjectX\xrEngine\pure.h

; 86   : 		if (R.empty())		R.clear();

	jne	SHORT $LN49@Resort
	mov	DWORD PTR [esi+4], edx
$LN49@Resort:

; 87   : 		changed = false;
; 88   : 	};

	and	DWORD PTR [esi+12], -3			; fffffffdH
	pop	esi
	ret	0
?Resort@?$CRegistrator@VpureAppActivate@@@@QAEXXZ ENDP	; CRegistrator<pureAppActivate>::Resort
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h
;	COMDAT ?grow@?$_box3@M@@QAEAAV1@ABU?$_vector3@M@@@Z
_TEXT	SEGMENT
_s$ = 8							; size = 4
?grow@?$_box3@M@@QAEAAV1@ABU?$_vector3@M@@@Z PROC	; _box3<float>::grow, COMDAT
; _this$ = ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 34   : 	ICF	SelfRef	sub(const Self &v)						{ x-=v.x;	y-=v.y;		z-=v.z;			return *this;	};

	mov	eax, DWORD PTR _s$[esp-4]
	movss	xmm0, DWORD PTR [ecx]
	subss	xmm0, DWORD PTR [eax]
	movss	DWORD PTR [ecx], xmm0
	movss	xmm0, DWORD PTR [ecx+4]
	subss	xmm0, DWORD PTR [eax+4]
	movss	DWORD PTR [ecx+4], xmm0
	movss	xmm0, DWORD PTR [ecx+8]
	subss	xmm0, DWORD PTR [eax+8]
	movss	DWORD PTR [ecx+8], xmm0

; 29   : 	ICF	SelfRef	add(const Self &v)						{ x+=v.x;	y+=v.y;		z+=v.z;			return *this;	};

	movss	xmm0, DWORD PTR [ecx+12]
	addss	xmm0, DWORD PTR [eax]
	movss	DWORD PTR [ecx+12], xmm0
	movss	xmm0, DWORD PTR [ecx+16]
	addss	xmm0, DWORD PTR [eax+4]
	movss	DWORD PTR [ecx+16], xmm0
	movss	xmm0, DWORD PTR [ecx+20]
	addss	xmm0, DWORD PTR [eax+8]
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h

; 42   : 	IC	SelfRef	grow		(const Tvector& s)				{ min.sub(s); max.add(s);	return *this;	};

	mov	eax, ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 29   : 	ICF	SelfRef	add(const Self &v)						{ x+=v.x;	y+=v.y;		z+=v.z;			return *this;	};

	movss	DWORD PTR [ecx+20], xmm0
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h

; 42   : 	IC	SelfRef	grow		(const Tvector& s)				{ min.sub(s); max.add(s);	return *this;	};

	ret	4
?grow@?$_box3@M@@QAEAAV1@ABU?$_vector3@M@@@Z ENDP	; _box3<float>::grow
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVIRenderable@@@std@@@std@@@std@@QAE@PAPAVIRenderable@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
___param0$ = 8						; size = 4
___param1$dead$ = 12					; size = 4
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVIRenderable@@@std@@@std@@@std@@QAE@PAPAVIRenderable@@PBU_Container_base0@1@@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<IRenderable *> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<IRenderable *> > >, COMDAT
; _this$ = ecx

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	eax, DWORD PTR ___param0$[esp-4]
	mov	DWORD PTR [ecx], eax
	mov	eax, ecx
	ret	8
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVIRenderable@@@std@@@std@@@std@@QAE@PAPAVIRenderable@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<IRenderable *> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<IRenderable *> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@Urecv@CLightProjector@@@std@@@std@@@std@@QAE@PAUrecv@CLightProjector@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
___param0$ = 8						; size = 4
___param1$dead$ = 12					; size = 4
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@Urecv@CLightProjector@@@std@@@std@@@std@@QAE@PAUrecv@CLightProjector@@PBU_Container_base0@1@@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CLightProjector::recv> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<CLightProjector::recv> > >, COMDAT
; _this$ = ecx

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	eax, DWORD PTR ___param0$[esp-4]
	mov	DWORD PTR [ecx], eax
	mov	eax, ecx
	ret	8
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@Urecv@CLightProjector@@@std@@@std@@@std@@QAE@PAUrecv@CLightProjector@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CLightProjector::recv> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<CLightProjector::recv> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@Urecv@CLightProjector@@@std@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@Urecv@CLightProjector@@@std@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CLightProjector::recv> > >::operator+=, COMDAT
; _this$ = ecx

; 119  :         _Ptr += _Off;

	imul	eax, DWORD PTR __Off$[esp-4], 136
	add	DWORD PTR [ecx], eax

; 298  :         _Mybase::operator+=(_Off);
; 299  :         return *this;

	mov	eax, ecx

; 300  :     }

	ret	4
??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@Urecv@CLightProjector@@@std@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CLightProjector::recv> > >::operator+=
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@Urecv@CLightProjector@@@std@@@std@@@std@@QBEABUrecv@CLightProjector@@XZ
_TEXT	SEGMENT
??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@Urecv@CLightProjector@@@std@@@std@@@std@@QBEABUrecv@CLightProjector@@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CLightProjector::recv> > >::operator*, COMDAT
; _this$ = ecx

; 46   : #if _ITERATOR_DEBUG_LEVEL != 0
; 47   :         const auto _Mycont = static_cast<const _Myvec*>(this->_Getcont());
; 48   :         _STL_VERIFY(_Ptr, "can't dereference value-initialized vector iterator");
; 49   :         _STL_VERIFY(
; 50   :             _Mycont->_Myfirst <= _Ptr && _Ptr < _Mycont->_Mylast, "can't dereference out of range vector iterator");
; 51   : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 52   : 
; 53   :         return *_Ptr;

	mov	eax, DWORD PTR [ecx]

; 54   :     }

	ret	0
??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@Urecv@CLightProjector@@@std@@@std@@@std@@QBEABUrecv@CLightProjector@@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CLightProjector::recv> > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@Urecv@CLightProjector@@@std@@@std@@@std@@QAE@PAUrecv@CLightProjector@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Pvector$dead$ = 12					; size = 4
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@Urecv@CLightProjector@@@std@@@std@@@std@@QAE@PAUrecv@CLightProjector@@PBU_Container_base0@1@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CLightProjector::recv> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CLightProjector::recv> > >, COMDAT
; _this$ = ecx

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	eax, DWORD PTR __Parg$[esp-4]
	mov	DWORD PTR [ecx], eax

; 42   :         this->_Adopt(_Pvector);
; 43   :     }

	mov	eax, ecx
	ret	8
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@Urecv@CLightProjector@@@std@@@std@@@std@@QAE@PAUrecv@CLightProjector@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CLightProjector::recv> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CLightProjector::recv> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVIRenderable@@@std@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVIRenderable@@@std@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<IRenderable *> > >::operator+=, COMDAT
; _this$ = ecx

; 119  :         _Ptr += _Off;

	mov	eax, DWORD PTR __Off$[esp-4]
	shl	eax, 2
	add	DWORD PTR [ecx], eax

; 298  :         _Mybase::operator+=(_Off);
; 299  :         return *this;

	mov	eax, ecx

; 300  :     }

	ret	4
??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVIRenderable@@@std@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<IRenderable *> > >::operator+=
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVIRenderable@@@std@@@std@@@std@@QBEABQAVIRenderable@@XZ
_TEXT	SEGMENT
??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVIRenderable@@@std@@@std@@@std@@QBEABQAVIRenderable@@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<IRenderable *> > >::operator*, COMDAT
; _this$ = ecx

; 46   : #if _ITERATOR_DEBUG_LEVEL != 0
; 47   :         const auto _Mycont = static_cast<const _Myvec*>(this->_Getcont());
; 48   :         _STL_VERIFY(_Ptr, "can't dereference value-initialized vector iterator");
; 49   :         _STL_VERIFY(
; 50   :             _Mycont->_Myfirst <= _Ptr && _Ptr < _Mycont->_Mylast, "can't dereference out of range vector iterator");
; 51   : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 52   : 
; 53   :         return *_Ptr;

	mov	eax, DWORD PTR [ecx]

; 54   :     }

	ret	0
??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVIRenderable@@@std@@@std@@@std@@QBEABQAVIRenderable@@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<IRenderable *> > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVIRenderable@@@std@@@std@@@std@@QAE@PAPAVIRenderable@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Pvector$dead$ = 12					; size = 4
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVIRenderable@@@std@@@std@@@std@@QAE@PAPAVIRenderable@@PBU_Container_base0@1@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<IRenderable *> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<IRenderable *> > >, COMDAT
; _this$ = ecx

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	eax, DWORD PTR __Parg$[esp-4]
	mov	DWORD PTR [ecx], eax

; 42   :         this->_Adopt(_Pvector);
; 43   :     }

	mov	eax, ecx
	ret	8
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVIRenderable@@@std@@@std@@@std@@QAE@PAPAVIRenderable@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<IRenderable *> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<IRenderable *> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?deallocate@?$xalloc@PAVIRenderable@@@@QBEXPAPAVIRenderable@@I@Z
_TEXT	SEGMENT
_p$ = 8							; size = 4
_n$dead$ = 12						; size = 4
?deallocate@?$xalloc@PAVIRenderable@@@@QBEXPAPAVIRenderable@@I@Z PROC ; xalloc<IRenderable *>::deallocate, COMDAT
; _this$dead$ = ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	eax, DWORD PTR _p$[esp-4]
	test	eax, eax
	je	SHORT $LN4@deallocate
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN4@deallocate:
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 82   : 							void					deallocate		(pointer p, size_type n) const			{	xr_free	(p);				}

	ret	8
?deallocate@?$xalloc@PAVIRenderable@@@@QBEXPAPAVIRenderable@@I@Z ENDP ; xalloc<IRenderable *>::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Getal@?$vector@Urecv@CLightProjector@@V?$xalloc@Urecv@CLightProjector@@@@@std@@AAEAAV?$xalloc@Urecv@CLightProjector@@@@XZ
_TEXT	SEGMENT
?_Getal@?$vector@Urecv@CLightProjector@@V?$xalloc@Urecv@CLightProjector@@@@@std@@AAEAAV?$xalloc@Urecv@CLightProjector@@@@XZ PROC ; std::vector<CLightProjector::recv,xalloc<CLightProjector::recv> >::_Getal, COMDAT
; _this$ = ecx

; 1805 :         return _Mypair._Get_first();

	mov	eax, ecx

; 1806 :     }

	ret	0
?_Getal@?$vector@Urecv@CLightProjector@@V?$xalloc@Urecv@CLightProjector@@@@@std@@AAEAAV?$xalloc@Urecv@CLightProjector@@@@XZ ENDP ; std::vector<CLightProjector::recv,xalloc<CLightProjector::recv> >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Destroy@?$vector@Urecv@CLightProjector@@V?$xalloc@Urecv@CLightProjector@@@@@std@@AAEXPAUrecv@CLightProjector@@0@Z
_TEXT	SEGMENT
__First$dead$ = 8					; size = 4
__Last$dead$ = 12					; size = 4
?_Destroy@?$vector@Urecv@CLightProjector@@V?$xalloc@Urecv@CLightProjector@@@@@std@@AAEXPAUrecv@CLightProjector@@0@Z PROC ; std::vector<CLightProjector::recv,xalloc<CLightProjector::recv> >::_Destroy, COMDAT
; _this$dead$ = ecx

; 1666 :         // destroy [_First, _Last) using allocator
; 1667 :         _Destroy_range(_First, _Last, _Getal());
; 1668 :     }

	ret	8
?_Destroy@?$vector@Urecv@CLightProjector@@V?$xalloc@Urecv@CLightProjector@@@@@std@@AAEXPAUrecv@CLightProjector@@0@Z ENDP ; std::vector<CLightProjector::recv,xalloc<CLightProjector::recv> >::_Destroy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?deallocate@?$xalloc@Urecv@CLightProjector@@@@QBEXPAUrecv@CLightProjector@@I@Z
_TEXT	SEGMENT
_p$ = 8							; size = 4
_n$dead$ = 12						; size = 4
?deallocate@?$xalloc@Urecv@CLightProjector@@@@QBEXPAUrecv@CLightProjector@@I@Z PROC ; xalloc<CLightProjector::recv>::deallocate, COMDAT
; _this$dead$ = ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	eax, DWORD PTR _p$[esp-4]
	test	eax, eax
	je	SHORT $LN4@deallocate
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN4@deallocate:
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 82   : 							void					deallocate		(pointer p, size_type n) const			{	xr_free	(p);				}

	ret	8
?deallocate@?$xalloc@Urecv@CLightProjector@@@@QBEXPAUrecv@CLightProjector@@I@Z ENDP ; xalloc<CLightProjector::recv>::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
;	COMDAT ?sub@?$_vector3@M@@QAEAAU1@ABU1@@Z
_TEXT	SEGMENT
_v$ = 8							; size = 4
?sub@?$_vector3@M@@QAEAAU1@ABU1@@Z PROC			; _vector3<float>::sub, COMDAT
; _this$ = ecx

; 34   : 	ICF	SelfRef	sub(const Self &v)						{ x-=v.x;	y-=v.y;		z-=v.z;			return *this;	};

	mov	eax, DWORD PTR _v$[esp-4]
	movss	xmm0, DWORD PTR [ecx]
	subss	xmm0, DWORD PTR [eax]
	movss	DWORD PTR [ecx], xmm0
	movss	xmm0, DWORD PTR [ecx+4]
	subss	xmm0, DWORD PTR [eax+4]
	movss	DWORD PTR [ecx+4], xmm0
	movss	xmm0, DWORD PTR [ecx+8]
	subss	xmm0, DWORD PTR [eax+8]
	mov	eax, ecx
	movss	DWORD PTR [ecx+8], xmm0
	ret	4
?sub@?$_vector3@M@@QAEAAU1@ABU1@@Z ENDP			; _vector3<float>::sub
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@Urecv@CLightProjector@@@std@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@Urecv@CLightProjector@@@std@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CLightProjector::recv> > >::operator+=, COMDAT
; _this$ = ecx

; 118  :         _Verify_offset(_Off);
; 119  :         _Ptr += _Off;

	imul	eax, DWORD PTR __Off$[esp-4], 136
	add	DWORD PTR [ecx], eax

; 120  :         return *this;

	mov	eax, ecx

; 121  :     }

	ret	4
??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@Urecv@CLightProjector@@@std@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CLightProjector::recv> > >::operator+=
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVIRenderable@@@std@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVIRenderable@@@std@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<IRenderable *> > >::operator+=, COMDAT
; _this$ = ecx

; 118  :         _Verify_offset(_Off);
; 119  :         _Ptr += _Off;

	mov	eax, DWORD PTR __Off$[esp-4]
	shl	eax, 2
	add	DWORD PTR [ecx], eax

; 120  :         return *this;

	mov	eax, ecx

; 121  :     }

	ret	4
??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVIRenderable@@@std@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<IRenderable *> > >::operator+=
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$xalloc@Urecv@CLightProjector@@@@V?$_Vector_val@U?$_Simple_types@Urecv@CLightProjector@@@std@@@std@@$00@std@@QAEAAV?$xalloc@Urecv@CLightProjector@@@@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@V?$xalloc@Urecv@CLightProjector@@@@V?$_Vector_val@U?$_Simple_types@Urecv@CLightProjector@@@std@@@std@@$00@std@@QAEAAV?$xalloc@Urecv@CLightProjector@@@@XZ PROC ; std::_Compressed_pair<xalloc<CLightProjector::recv>,std::_Vector_val<std::_Simple_types<CLightProjector::recv> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 1339 :         return *this;

	mov	eax, ecx

; 1340 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$xalloc@Urecv@CLightProjector@@@@V?$_Vector_val@U?$_Simple_types@Urecv@CLightProjector@@@std@@@std@@$00@std@@QAEAAV?$xalloc@Urecv@CLightProjector@@@@XZ ENDP ; std::_Compressed_pair<xalloc<CLightProjector::recv>,std::_Vector_val<std::_Simple_types<CLightProjector::recv> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Verify_offset@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@Urecv@CLightProjector@@@std@@@std@@@std@@QBEXH@Z
_TEXT	SEGMENT
__Off$dead$ = 8						; size = 4
?_Verify_offset@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@Urecv@CLightProjector@@@std@@@std@@@std@@QBEXH@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CLightProjector::recv> > >::_Verify_offset, COMDAT
; _this$dead$ = ecx

; 102  : #if _ITERATOR_DEBUG_LEVEL == 0
; 103  :         (void) _Off;
; 104  : #else // ^^^ _ITERATOR_DEBUG_LEVEL == 0 ^^^ // vvv _ITERATOR_DEBUG_LEVEL != 0 vvv
; 105  :         const auto _Mycont = static_cast<const _Myvec*>(this->_Getcont());
; 106  :         _STL_VERIFY(_Off == 0 || _Ptr, "cannot seek value-initialized vector iterator");
; 107  :         if (_Off < 0) {
; 108  :             _STL_VERIFY(_Off >= _Mycont->_Myfirst - _Ptr, "cannot seek vector iterator before begin");
; 109  :         }
; 110  : 
; 111  :         if (_Off > 0) {
; 112  :             _STL_VERIFY(_Off <= _Mycont->_Mylast - _Ptr, "cannot seek vector iterator after end");
; 113  :         }
; 114  : #endif // _ITERATOR_DEBUG_LEVEL == 0
; 115  :     }

	ret	4
?_Verify_offset@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@Urecv@CLightProjector@@@std@@@std@@@std@@QBEXH@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CLightProjector::recv> > >::_Verify_offset
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Verify_offset@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVIRenderable@@@std@@@std@@@std@@QBEXH@Z
_TEXT	SEGMENT
__Off$dead$ = 8						; size = 4
?_Verify_offset@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVIRenderable@@@std@@@std@@@std@@QBEXH@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<IRenderable *> > >::_Verify_offset, COMDAT
; _this$dead$ = ecx

; 102  : #if _ITERATOR_DEBUG_LEVEL == 0
; 103  :         (void) _Off;
; 104  : #else // ^^^ _ITERATOR_DEBUG_LEVEL == 0 ^^^ // vvv _ITERATOR_DEBUG_LEVEL != 0 vvv
; 105  :         const auto _Mycont = static_cast<const _Myvec*>(this->_Getcont());
; 106  :         _STL_VERIFY(_Off == 0 || _Ptr, "cannot seek value-initialized vector iterator");
; 107  :         if (_Off < 0) {
; 108  :             _STL_VERIFY(_Off >= _Mycont->_Myfirst - _Ptr, "cannot seek vector iterator before begin");
; 109  :         }
; 110  : 
; 111  :         if (_Off > 0) {
; 112  :             _STL_VERIFY(_Off <= _Mycont->_Mylast - _Ptr, "cannot seek vector iterator after end");
; 113  :         }
; 114  : #endif // _ITERATOR_DEBUG_LEVEL == 0
; 115  :     }

	ret	4
?_Verify_offset@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVIRenderable@@@std@@@std@@@std@@QBEXH@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<IRenderable *> > >::_Verify_offset
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\type_traits
;	COMDAT ??$forward@ABQAVIRenderable@@@std@@YAABQAVIRenderable@@ABQAV1@@Z
_TEXT	SEGMENT
??$forward@ABQAVIRenderable@@@std@@YAABQAVIRenderable@@ABQAV1@@Z PROC ; std::forward<IRenderable * const &>, COMDAT
; __Arg$ = ecx

; 1386 :     return static_cast<_Ty&&>(_Arg);

	mov	eax, ecx

; 1387 : }

	ret	0
??$forward@ABQAVIRenderable@@@std@@YAABQAVIRenderable@@ABQAV1@@Z ENDP ; std::forward<IRenderable * const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$construct@PAVIRenderable@@ABQAV1@@?$_Normal_allocator_traits@V?$xalloc@PAVIRenderable@@@@@std@@SAXAAV?$xalloc@PAVIRenderable@@@@PAPAVIRenderable@@ABQAV3@@Z
_TEXT	SEGMENT
_<_Args_0>$ = 8						; size = 4
??$construct@PAVIRenderable@@ABQAV1@@?$_Normal_allocator_traits@V?$xalloc@PAVIRenderable@@@@@std@@SAXAAV?$xalloc@PAVIRenderable@@@@PAPAVIRenderable@@ABQAV3@@Z PROC ; std::_Normal_allocator_traits<xalloc<IRenderable *> >::construct<IRenderable *,IRenderable * const &>, COMDAT
; __Al$dead$ = ecx
; __Ptr$ = edx

; 565  :         if constexpr (_Uses_default_construct<_Alloc, _Ty*, _Types...>::value) {
; 566  :             (void) _Al; // TRANSITION, DevCom-1004719
; 567  : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 568  :             _STD construct_at(_Ptr, _STD forward<_Types>(_Args)...);
; 569  : #else // __cpp_lib_constexpr_dynamic_alloc
; 570  :             ::new (static_cast<void*>(_Ptr)) _Ty(_STD forward<_Types>(_Args)...);
; 571  : #endif // __cpp_lib_constexpr_dynamic_alloc
; 572  :         } else {
; 573  :             _Al.construct(_Ptr, _STD forward<_Types>(_Args)...);

	mov	eax, DWORD PTR _<_Args_0>$[esp-4]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edx], eax

; 574  :         }
; 575  :     }

	ret	0
??$construct@PAVIRenderable@@ABQAV1@@?$_Normal_allocator_traits@V?$xalloc@PAVIRenderable@@@@@std@@SAXAAV?$xalloc@PAVIRenderable@@@@PAPAVIRenderable@@ABQAV3@@Z ENDP ; std::_Normal_allocator_traits<xalloc<IRenderable *> >::construct<IRenderable *,IRenderable * const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??$_Emplace_reallocate@ABQAVIRenderable@@@?$vector@PAVIRenderable@@V?$xalloc@PAVIRenderable@@@@@std@@QAEPAPAVIRenderable@@QAPAV2@ABQAV2@@Z
_TEXT	SEGMENT
__Backout$2 = -76					; size = 12
__Backout$3 = -64					; size = 12
__Backout$4 = -52					; size = 12
__UFirst$5 = -40					; size = 4
__UFirst$6 = -36					; size = 4
__UFirst$7 = -32					; size = 4
__Newvec$ = -28						; size = 4
__Newcapacity$1$ = -24					; size = 4
__Newsize$1$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
tv555 = 8						; size = 4
__Whereptr$ = 8						; size = 4
_<_Val_0>$ = 12						; size = 4
??$_Emplace_reallocate@ABQAVIRenderable@@@?$vector@PAVIRenderable@@V?$xalloc@PAVIRenderable@@@@@std@@QAEPAPAVIRenderable@@QAPAV2@ABQAV2@@Z PROC ; std::vector<IRenderable *,xalloc<IRenderable *> >::_Emplace_reallocate<IRenderable * const &>, COMDAT
; _this$ = ecx

; 752  :     _CONSTEXPR20_CONTAINER pointer _Emplace_reallocate(const pointer _Whereptr, _Valty&&... _Val) {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Emplace_reallocate@ABQAVIRenderable@@@?$vector@PAVIRenderable@@V?$xalloc@PAVIRenderable@@@@@std@@QAEPAPAVIRenderable@@QAPAV2@ABQAV2@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	edi, ecx

; 753  :         // reallocate and insert by perfectly forwarding _Val at _Whereptr
; 754  :         _Alty& _Al        = _Getal();
; 755  :         auto& _My_data    = _Mypair._Myval2;
; 756  :         pointer& _Myfirst = _My_data._Myfirst;
; 757  :         pointer& _Mylast  = _My_data._Mylast;
; 758  : 
; 759  :         _STL_INTERNAL_CHECK(_Mylast == _My_data._Myend); // check that we have no unused capacity
; 760  : 
; 761  :         const auto _Whereoff = static_cast<size_type>(_Whereptr - _Myfirst);

	mov	edx, DWORD PTR [edi]
	mov	esi, DWORD PTR __Whereptr$[ebp]
	mov	ebx, esi
	sub	ebx, edx
	sar	ebx, 2

; 762  :         const auto _Oldsize  = static_cast<size_type>(_Mylast - _Myfirst);

	mov	eax, DWORD PTR [edi+4]
	sub	eax, edx
	sar	eax, 2

; 763  : 
; 764  :         if (_Oldsize == max_size()) {

	cmp	eax, 1073741823				; 3fffffffH
	je	$LN83@Emplace_re

; 766  :         }
; 767  : 
; 768  :         const size_type _Newsize     = _Oldsize + 1;

	inc	eax
	mov	DWORD PTR __Newsize$1$[ebp], eax

; 1546 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	ecx, DWORD PTR [edi+8]
	sub	ecx, edx
	sar	ecx, 2

; 1675 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	edx, ecx
	shr	edx, 1
	mov	eax, 1073741823				; 3fffffffH
	sub	eax, edx
	cmp	ecx, eax
	jbe	SHORT $LN12@Emplace_re

; 1676 :             return _Max; // geometric growth would overflow

	mov	eax, 1073741823				; 3fffffffH
	jmp	SHORT $LN81@Emplace_re
$LN12@Emplace_re:

; 1677 :         }
; 1678 : 
; 1679 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	lea	eax, DWORD PTR [edx+ecx]

; 1680 : 
; 1681 :         if (_Geometric < _Newsize) {

	cmp	eax, DWORD PTR __Newsize$1$[ebp]
	cmovb	eax, DWORD PTR __Newsize$1$[ebp]
$LN81@Emplace_re:
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	mov	DWORD PTR __Newcapacity$1$[ebp], eax
	shl	eax, 2
	push	eax
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 771  :         const pointer _Newvec           = _Al.allocate(_Newcapacity);

	mov	edx, eax
	mov	DWORD PTR __Newvec$[ebp], edx

; 772  :         const pointer _Constructed_last = _Newvec + _Whereoff + 1;
; 773  :         pointer _Constructed_first      = _Constructed_last;
; 774  : 
; 775  :         _TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 776  :         _Alty_traits::construct(_Al, _Unfancy(_Newvec + _Whereoff), _STD forward<_Valty>(_Val)...);

	lea	ecx, DWORD PTR [edx+ebx*4]
	mov	DWORD PTR tv555[ebp], ecx
	mov	eax, DWORD PTR _<_Val_0>$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax

; 777  :         _Constructed_first = _Newvec + _Whereoff;
; 778  : 
; 779  :         if (_Whereptr == _Mylast) { // at back, provide strong guarantee

	mov	ebx, DWORD PTR [edi+4]
	mov	ecx, DWORD PTR [edi]
	cmp	esi, ebx
	jne	SHORT $LN4@Emplace_re
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1703 :     auto _UFirst      = _Get_unwrapped(_First);

	mov	DWORD PTR __UFirst$7[ebp], ecx

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	DWORD PTR __Backout$4[ebp], edx
	mov	DWORD PTR __Backout$4[ebp+4], edx
	mov	DWORD PTR __Backout$4[ebp+8], edi
	npad	1
$LL28@Emplace_re:

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	ecx, ebx
	je	SHORT $LN27@Emplace_re

; 1620 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax

; 1621 :         ++_Last;

	add	edx, 4
	mov	DWORD PTR __Backout$4[ebp+4], edx

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	add	ecx, 4
	mov	DWORD PTR __UFirst$7[ebp], ecx
	jmp	SHORT $LL28@Emplace_re
$LN27@Emplace_re:

; 1625 :         _First = _Last;

	mov	DWORD PTR __Backout$4[ebp], edx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 781  :         } else { // provide basic guarantee

	mov	ebx, DWORD PTR tv555[ebp]
	jmp	SHORT $LN5@Emplace_re
$LN4@Emplace_re:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1703 :     auto _UFirst      = _Get_unwrapped(_First);

	mov	DWORD PTR __UFirst$6[ebp], ecx

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	DWORD PTR __Backout$3[ebp], edx
	mov	DWORD PTR __Backout$3[ebp+4], edx
	mov	DWORD PTR __Backout$3[ebp+8], edi
	npad	6
$LL41@Emplace_re:

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	ecx, esi
	je	SHORT $LN40@Emplace_re

; 1620 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax

; 1621 :         ++_Last;

	add	edx, 4
	mov	DWORD PTR __Backout$3[ebp+4], edx

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	add	ecx, 4
	mov	DWORD PTR __UFirst$6[ebp], ecx
	jmp	SHORT $LL41@Emplace_re
$LN40@Emplace_re:

; 1625 :         _First = _Last;

	mov	DWORD PTR __Backout$3[ebp], edx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 784  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

	mov	ebx, DWORD PTR tv555[ebp]
	lea	ecx, DWORD PTR [ebx+4]

; 1646 :         return _Uninitialized_move(_First, _Last, _Dest, _Getal());

	mov	edx, DWORD PTR [edi+4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1703 :     auto _UFirst      = _Get_unwrapped(_First);

	mov	DWORD PTR __UFirst$5[ebp], esi

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	DWORD PTR __Backout$2[ebp], ecx
	mov	DWORD PTR __Backout$2[ebp+4], ecx
	mov	DWORD PTR __Backout$2[ebp+8], edi
	npad	2
$LL54@Emplace_re:

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	esi, edx
	je	SHORT $LN53@Emplace_re

; 1620 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [ecx], eax

; 1621 :         ++_Last;

	add	ecx, 4
	mov	DWORD PTR __Backout$2[ebp+4], ecx

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	add	esi, 4
	mov	DWORD PTR __UFirst$5[ebp], esi
	jmp	SHORT $LL54@Emplace_re
$LN53@Emplace_re:

; 1625 :         _First = _Last;

	mov	DWORD PTR __Backout$2[ebp], ecx
$LN5@Emplace_re:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
	mov	DWORD PTR __$EHRec$[ebp+12], -1

; 1732 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [edi]
	test	eax, eax
	je	SHORT $LN68@Emplace_re
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	push	eax
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN68@Emplace_re:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1737 :         _Myfirst = _Newvec;

	mov	eax, DWORD PTR __Newvec$[ebp]
	mov	DWORD PTR [edi], eax

; 1738 :         _Mylast  = _Newvec + _Newsize;

	mov	ecx, DWORD PTR __Newsize$1$[ebp]
	lea	ecx, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR [edi+4], ecx

; 1739 :         _Myend   = _Newvec + _Newcapacity;

	mov	ecx, DWORD PTR __Newcapacity$1$[ebp]
	lea	ecx, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR [edi+8], ecx

; 790  :         _CATCH_END
; 791  : 
; 792  :         _Change_array(_Newvec, _Newsize, _Newcapacity);
; 793  :         return _Newvec + _Whereoff;

	mov	eax, ebx

; 794  :     }

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
__catch$??$_Emplace_reallocate@ABQAVIRenderable@@@?$vector@PAVIRenderable@@V?$xalloc@PAVIRenderable@@@@@std@@QAEPAPAVIRenderable@@QAPAV2@ABQAV2@@Z$0:

; 785  :         }
; 786  :         _CATCH_ALL
; 787  :         _Destroy(_Constructed_first, _Constructed_last);
; 788  :         _Al.deallocate(_Newvec, _Newcapacity);

	push	ecx
	push	DWORD PTR __Newvec$[ebp]
	call	?deallocate@?$xalloc@PAVIRenderable@@@@QBEXPAPAVIRenderable@@I@Z ; xalloc<IRenderable *>::deallocate

; 789  :         _RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$LN83@Emplace_re:

; 765  :             _Xlength();

	call	?_Xlength@?$vector@PAVIRenderable@@V?$xalloc@PAVIRenderable@@@@@std@@CAXXZ ; std::vector<IRenderable *,xalloc<IRenderable *> >::_Xlength
$LN80@Emplace_re:
	int	3
	int	3
	int	3
	int	3
	int	3
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Emplace_reallocate@ABQAVIRenderable@@@?$vector@PAVIRenderable@@V?$xalloc@PAVIRenderable@@@@@std@@QAEPAPAVIRenderable@@QAPAV2@ABQAV2@@Z:
	npad	1
	npad	1
	mov	eax, OFFSET __ehfuncinfo$??$_Emplace_reallocate@ABQAVIRenderable@@@?$vector@PAVIRenderable@@V?$xalloc@PAVIRenderable@@@@@std@@QAEPAPAVIRenderable@@QAPAV2@ABQAV2@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Emplace_reallocate@ABQAVIRenderable@@@?$vector@PAVIRenderable@@V?$xalloc@PAVIRenderable@@@@@std@@QAEPAPAVIRenderable@@QAPAV2@ABQAV2@@Z ENDP ; std::vector<IRenderable *,xalloc<IRenderable *> >::_Emplace_reallocate<IRenderable * const &>
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??$_Resize@U_Value_init_tag@std@@@?$vector@Urecv@CLightProjector@@V?$xalloc@Urecv@CLightProjector@@@@@std@@AAEXIABU_Value_init_tag@1@@Z
_TEXT	SEGMENT
__Newsize$dead$ = 8					; size = 4
__Val$ = 12						; size = 4
??$_Resize@U_Value_init_tag@std@@@?$vector@Urecv@CLightProjector@@V?$xalloc@Urecv@CLightProjector@@@@@std@@AAEXIABU_Value_init_tag@1@@Z PROC ; std::vector<CLightProjector::recv,xalloc<CLightProjector::recv> >::_Resize<std::_Value_init_tag>, COMDAT
; _this$ = ecx

; 1245 :     _CONSTEXPR20_CONTAINER void _Resize(const size_type _Newsize, const _Ty2& _Val) {

	push	ebx
	push	ebp
	push	esi
	mov	ebx, ecx

; 1246 :         // trim or append elements, provide strong guarantee
; 1247 :         auto& _My_data      = _Mypair._Myval2;
; 1248 :         pointer& _Myfirst   = _My_data._Myfirst;
; 1249 :         pointer& _Mylast    = _My_data._Mylast;
; 1250 :         const auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);

	mov	eax, 2021161081				; 78787879H
	push	edi
	mov	edi, DWORD PTR [ebx+4]
	mov	edx, edi
	mov	ebp, DWORD PTR [ebx]
	sub	edx, ebp
	imul	edx
	sar	edx, 6
	mov	esi, edx
	shr	esi, 31					; 0000001fH
	add	esi, edx

; 1251 :         if (_Newsize < _Oldsize) { // trim

	cmp	esi, 100				; 00000064H
	jbe	SHORT $LN2@Resize

; 1268 :             _Orphan_range(_Oldlast, _Oldlast);
; 1269 :         }
; 1270 : 
; 1271 :         // if _Newsize == _Oldsize, do nothing; avoid invalidating iterators
; 1272 :     }

	pop	edi
	pop	esi
	lea	eax, DWORD PTR [ebp+13600]
	pop	ebp
	mov	DWORD PTR [ebx+4], eax
	pop	ebx
	ret	8
$LN2@Resize:

; 1252 :             const pointer _Newlast = _Myfirst + _Newsize;
; 1253 :             _Orphan_range(_Newlast, _Mylast);
; 1254 :             _Destroy(_Newlast, _Mylast);
; 1255 :             _Mylast = _Newlast;
; 1256 :             return;
; 1257 :         }
; 1258 : 
; 1259 :         if (_Newsize > _Oldsize) { // append

	jae	SHORT $LN3@Resize

; 1260 :             const auto _Oldcapacity = static_cast<size_type>(_My_data._Myend - _Myfirst);

	mov	ecx, DWORD PTR [ebx+8]
	mov	eax, 2021161081				; 78787879H
	sub	ecx, ebp
	imul	ecx
	sar	edx, 6
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx

; 1261 :             if (_Newsize > _Oldcapacity) { // reallocate

	cmp	eax, 100				; 00000064H
	jae	SHORT $LN4@Resize

; 1262 :                 _Resize_reallocate(_Newsize, _Val);

	push	DWORD PTR __Val$[esp+12]
	push	ecx
	mov	ecx, ebx
	call	??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@Urecv@CLightProjector@@V?$xalloc@Urecv@CLightProjector@@@@@std@@AAEXIABU_Value_init_tag@1@@Z ; std::vector<CLightProjector::recv,xalloc<CLightProjector::recv> >::_Resize_reallocate<std::_Value_init_tag>
	pop	edi

; 1268 :             _Orphan_range(_Oldlast, _Oldlast);
; 1269 :         }
; 1270 : 
; 1271 :         // if _Newsize == _Oldsize, do nothing; avoid invalidating iterators
; 1272 :     }

	pop	esi
	pop	ebp
	pop	ebx
	ret	8
$LN4@Resize:

; 1267 :             _Mylast                = _Ufill(_Oldlast, _Newsize - _Oldsize, _Val);

	mov	eax, 100				; 00000064H
	sub	eax, esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1813 :     for (; 0 < _Count; --_Count) {

	je	SHORT $LN11@Resize
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1267 :             _Mylast                = _Ufill(_Oldlast, _Newsize - _Oldsize, _Val);

	imul	esi, eax, 136
	push	esi
	push	0
	push	edi
	call	_memset
	add	esp, 12					; 0000000cH
	add	edi, esi
$LN11@Resize:
	mov	DWORD PTR [ebx+4], edi
$LN3@Resize:
	pop	edi

; 1268 :             _Orphan_range(_Oldlast, _Oldlast);
; 1269 :         }
; 1270 : 
; 1271 :         // if _Newsize == _Oldsize, do nothing; avoid invalidating iterators
; 1272 :     }

	pop	esi
	pop	ebp
	pop	ebx
	ret	8
??$_Resize@U_Value_init_tag@std@@@?$vector@Urecv@CLightProjector@@V?$xalloc@Urecv@CLightProjector@@@@@std@@AAEXIABU_Value_init_tag@1@@Z ENDP ; std::vector<CLightProjector::recv,xalloc<CLightProjector::recv> >::_Resize<std::_Value_init_tag>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef
;	COMDAT ??$addressof@V?$_Vector_val@U?$_Simple_types@PAVIRenderable@@@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@PAVIRenderable@@@std@@@0@AAV10@@Z
_TEXT	SEGMENT
??$addressof@V?$_Vector_val@U?$_Simple_types@PAVIRenderable@@@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@PAVIRenderable@@@std@@@0@AAV10@@Z PROC ; std::addressof<std::_Vector_val<std::_Simple_types<IRenderable *> > >, COMDAT
; __Val$ = ecx

; 253  :     return __builtin_addressof(_Val);

	mov	eax, ecx

; 254  : }

	ret	0
??$addressof@V?$_Vector_val@U?$_Simple_types@PAVIRenderable@@@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@PAVIRenderable@@@std@@@0@AAV10@@Z ENDP ; std::addressof<std::_Vector_val<std::_Simple_types<IRenderable *> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$?0$$V@?$_Compressed_pair@V?$xalloc@PAVIRenderable@@@@V?$_Vector_val@U?$_Simple_types@PAVIRenderable@@@std@@@std@@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$?0$$V@?$_Compressed_pair@V?$xalloc@PAVIRenderable@@@@V?$_Vector_val@U?$_Simple_types@PAVIRenderable@@@std@@@std@@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<xalloc<IRenderable *>,std::_Vector_val<std::_Simple_types<IRenderable *> >,1>::_Compressed_pair<xalloc<IRenderable *>,std::_Vector_val<std::_Simple_types<IRenderable *> >,1><>, COMDAT
; _this$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1331 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	eax, ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1331 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	ret	4
??$?0$$V@?$_Compressed_pair@V?$xalloc@PAVIRenderable@@@@V?$_Vector_val@U?$_Simple_types@PAVIRenderable@@@std@@@std@@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<xalloc<IRenderable *>,std::_Vector_val<std::_Simple_types<IRenderable *> >,1>::_Compressed_pair<xalloc<IRenderable *>,std::_Vector_val<std::_Simple_types<IRenderable *> >,1><>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef
;	COMDAT ??$addressof@V?$_Vector_val@U?$_Simple_types@Urecv@CLightProjector@@@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@Urecv@CLightProjector@@@std@@@0@AAV10@@Z
_TEXT	SEGMENT
??$addressof@V?$_Vector_val@U?$_Simple_types@Urecv@CLightProjector@@@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@Urecv@CLightProjector@@@std@@@0@AAV10@@Z PROC ; std::addressof<std::_Vector_val<std::_Simple_types<CLightProjector::recv> > >, COMDAT
; __Val$ = ecx

; 253  :     return __builtin_addressof(_Val);

	mov	eax, ecx

; 254  : }

	ret	0
??$addressof@V?$_Vector_val@U?$_Simple_types@Urecv@CLightProjector@@@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@Urecv@CLightProjector@@@std@@@0@AAV10@@Z ENDP ; std::addressof<std::_Vector_val<std::_Simple_types<CLightProjector::recv> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$?0$$V@?$_Compressed_pair@V?$xalloc@Urecv@CLightProjector@@@@V?$_Vector_val@U?$_Simple_types@Urecv@CLightProjector@@@std@@@std@@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$?0$$V@?$_Compressed_pair@V?$xalloc@Urecv@CLightProjector@@@@V?$_Vector_val@U?$_Simple_types@Urecv@CLightProjector@@@std@@@std@@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<xalloc<CLightProjector::recv>,std::_Vector_val<std::_Simple_types<CLightProjector::recv> >,1>::_Compressed_pair<xalloc<CLightProjector::recv>,std::_Vector_val<std::_Simple_types<CLightProjector::recv> >,1><>, COMDAT
; _this$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1331 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	eax, ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1331 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	ret	4
??$?0$$V@?$_Compressed_pair@V?$xalloc@Urecv@CLightProjector@@@@V?$_Vector_val@U?$_Simple_types@Urecv@CLightProjector@@@std@@@std@@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<xalloc<CLightProjector::recv>,std::_Vector_val<std::_Simple_types<CLightProjector::recv> >,1>::_Compressed_pair<xalloc<CLightProjector::recv>,std::_Vector_val<std::_Simple_types<CLightProjector::recv> >,1><>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
;	COMDAT ??$xr_free@PAVIRenderable@@@@YAXAAPAPAVIRenderable@@@Z
_TEXT	SEGMENT
??$xr_free@PAVIRenderable@@@@YAXAAPAPAVIRenderable@@@Z PROC ; xr_free<IRenderable *>, COMDAT
; _P$ = ecx

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	push	esi
	mov	esi, ecx
	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN2@xr_free
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
	mov	DWORD PTR [esi], 0
$LN2@xr_free:
	pop	esi
	ret	0
??$xr_free@PAVIRenderable@@@@YAXAAPAPAVIRenderable@@@Z ENDP ; xr_free<IRenderable *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Destroy_range@V?$xalloc@Urecv@CLightProjector@@@@@std@@YAXPAUrecv@CLightProjector@@QAU12@AAV?$xalloc@Urecv@CLightProjector@@@@@Z
_TEXT	SEGMENT
__Al$dead$ = 8						; size = 4
??$_Destroy_range@V?$xalloc@Urecv@CLightProjector@@@@@std@@YAXPAUrecv@CLightProjector@@QAU12@AAV?$xalloc@Urecv@CLightProjector@@@@@Z PROC ; std::_Destroy_range<xalloc<CLightProjector::recv> >, COMDAT
; __First$dead$ = ecx
; __Last$dead$ = edx

; 901  :     // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
; 902  :     using _Ty = typename _Alloc::value_type;
; 903  :     if constexpr (!conjunction_v<is_trivially_destructible<_Ty>, _Uses_default_destroy<_Alloc, _Ty*>>) {
; 904  :         for (; _First != _Last; ++_First) {
; 905  :             allocator_traits<_Alloc>::destroy(_Al, _Unfancy(_First));
; 906  :         }
; 907  :     }
; 908  : }

	ret	0
??$_Destroy_range@V?$xalloc@Urecv@CLightProjector@@@@@std@@YAXPAUrecv@CLightProjector@@QAU12@AAV?$xalloc@Urecv@CLightProjector@@@@@Z ENDP ; std::_Destroy_range<xalloc<CLightProjector::recv> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
;	COMDAT ??$xr_free@Urecv@CLightProjector@@@@YAXAAPAUrecv@CLightProjector@@@Z
_TEXT	SEGMENT
??$xr_free@Urecv@CLightProjector@@@@YAXAAPAUrecv@CLightProjector@@@Z PROC ; xr_free<CLightProjector::recv>, COMDAT
; _P$ = ecx

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	push	esi
	mov	esi, ecx
	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN2@xr_free
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
	mov	DWORD PTR [esi], 0
$LN2@xr_free:
	pop	esi
	ret	0
??$xr_free@Urecv@CLightProjector@@@@YAXAAPAUrecv@CLightProjector@@@Z ENDP ; xr_free<CLightProjector::recv>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@PAVIRenderable@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Vector_val@U?$_Simple_types@PAVIRenderable@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<std::_Simple_types<IRenderable *> >::_Vector_val<std::_Simple_types<IRenderable *> >, COMDAT
; _this$ = ecx

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx], 0
	mov	eax, ecx
	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0
	ret	0
??0?$_Vector_val@U?$_Simple_types@PAVIRenderable@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<std::_Simple_types<IRenderable *> >::_Vector_val<std::_Simple_types<IRenderable *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Xlength@?$vector@PAVIRenderable@@V?$xalloc@PAVIRenderable@@@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@PAVIRenderable@@V?$xalloc@PAVIRenderable@@@@@std@@CAXXZ PROC ; std::vector<IRenderable *,xalloc<IRenderable *> >::_Xlength, COMDAT

; 1761 :         _Xlength_error("vector too long");

	push	OFFSET ??_C@_0BA@FOIKENOD@vector?5too?5long@
	call	DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN3@Xlength:
	int	3
?_Xlength@?$vector@PAVIRenderable@@V?$xalloc@PAVIRenderable@@@@@std@@CAXXZ ENDP ; std::vector<IRenderable *,xalloc<IRenderable *> >::_Xlength
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Change_array@?$vector@PAVIRenderable@@V?$xalloc@PAVIRenderable@@@@@std@@AAEXQAPAVIRenderable@@II@Z
_TEXT	SEGMENT
__Newvec$ = 8						; size = 4
__Newsize$ = 12						; size = 4
__Newcapacity$ = 16					; size = 4
?_Change_array@?$vector@PAVIRenderable@@V?$xalloc@PAVIRenderable@@@@@std@@AAEXQAPAVIRenderable@@II@Z PROC ; std::vector<IRenderable *,xalloc<IRenderable *> >::_Change_array, COMDAT
; _this$ = ecx

; 1723 :         const pointer _Newvec, const size_type _Newsize, const size_type _Newcapacity) {

	push	esi
	mov	esi, ecx

; 1724 :         // orphan all iterators, discard old array, acquire new array
; 1725 :         auto& _My_data    = _Mypair._Myval2;
; 1726 :         pointer& _Myfirst = _My_data._Myfirst;
; 1727 :         pointer& _Mylast  = _My_data._Mylast;
; 1728 :         pointer& _Myend   = _My_data._Myend;
; 1729 : 
; 1730 :         _My_data._Orphan_all();
; 1731 : 
; 1732 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN7@Change_arr
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN7@Change_arr:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1737 :         _Myfirst = _Newvec;

	mov	ecx, DWORD PTR __Newvec$[esp]

; 1738 :         _Mylast  = _Newvec + _Newsize;

	mov	eax, DWORD PTR __Newsize$[esp]
	mov	DWORD PTR [esi], ecx
	lea	eax, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR [esi+4], eax

; 1739 :         _Myend   = _Newvec + _Newcapacity;

	mov	eax, DWORD PTR __Newcapacity$[esp]
	lea	eax, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR [esi+8], eax
	pop	esi

; 1740 :     }

	ret	12					; 0000000cH
?_Change_array@?$vector@PAVIRenderable@@V?$xalloc@PAVIRenderable@@@@@std@@AAEXQAPAVIRenderable@@II@Z ENDP ; std::vector<IRenderable *,xalloc<IRenderable *> >::_Change_array
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Calculate_growth@?$vector@PAVIRenderable@@V?$xalloc@PAVIRenderable@@@@@std@@ABEII@Z
_TEXT	SEGMENT
__Newsize$ = 8						; size = 4
?_Calculate_growth@?$vector@PAVIRenderable@@V?$xalloc@PAVIRenderable@@@@@std@@ABEII@Z PROC ; std::vector<IRenderable *,xalloc<IRenderable *> >::_Calculate_growth, COMDAT
; _this$ = ecx

; 1546 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	edx, DWORD PTR [ecx+8]
	sub	edx, DWORD PTR [ecx]

; 1671 :         // given _Oldcapacity and _Newsize, calculate geometric growth
; 1672 :         const size_type _Oldcapacity = capacity();
; 1673 :         const auto _Max              = max_size();
; 1674 : 
; 1675 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	ecx, 1073741823				; 3fffffffH

; 1546 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	sar	edx, 2

; 1670 :     _CONSTEXPR20_CONTAINER size_type _Calculate_growth(const size_type _Newsize) const {

	push	esi

; 1671 :         // given _Oldcapacity and _Newsize, calculate geometric growth
; 1672 :         const size_type _Oldcapacity = capacity();
; 1673 :         const auto _Max              = max_size();
; 1674 : 
; 1675 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	esi, edx
	shr	esi, 1
	sub	ecx, esi
	cmp	edx, ecx
	jbe	SHORT $LN2@Calculate_

; 1676 :             return _Max; // geometric growth would overflow

	mov	eax, 1073741823				; 3fffffffH
	pop	esi

; 1682 :             return _Newsize; // geometric growth would be insufficient
; 1683 :         }
; 1684 : 
; 1685 :         return _Geometric; // geometric growth is sufficient
; 1686 :     }

	ret	4
$LN2@Calculate_:

; 1677 :         }
; 1678 : 
; 1679 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	lea	eax, DWORD PTR [esi+edx]

; 1680 : 
; 1681 :         if (_Geometric < _Newsize) {

	cmp	eax, DWORD PTR __Newsize$[esp]
	pop	esi
	cmovb	eax, DWORD PTR __Newsize$[esp-4]

; 1682 :             return _Newsize; // geometric growth would be insufficient
; 1683 :         }
; 1684 : 
; 1685 :         return _Geometric; // geometric growth is sufficient
; 1686 :     }

	ret	4
?_Calculate_growth@?$vector@PAVIRenderable@@V?$xalloc@PAVIRenderable@@@@@std@@ABEII@Z ENDP ; std::vector<IRenderable *,xalloc<IRenderable *> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Umove_if_noexcept@?$vector@PAVIRenderable@@V?$xalloc@PAVIRenderable@@@@@std@@AAEXPAPAVIRenderable@@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
?_Umove_if_noexcept@?$vector@PAVIRenderable@@V?$xalloc@PAVIRenderable@@@@@std@@AAEXPAPAVIRenderable@@00@Z PROC ; std::vector<IRenderable *,xalloc<IRenderable *> >::_Umove_if_noexcept, COMDAT
; _this$dead$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1703 :     auto _UFirst      = _Get_unwrapped(_First);

	mov	eax, DWORD PTR __First$[esp-4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1659 :     _CONSTEXPR20_CONTAINER void _Umove_if_noexcept(pointer _First, pointer _Last, pointer _Dest) {

	push	esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	mov	esi, DWORD PTR __Last$[esp]
	cmp	eax, esi
	je	SHORT $LN7@Umove_if_n

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	edx, DWORD PTR __Dest$[esp]
	sub	edx, eax
$LL8@Umove_if_n:

; 1620 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx+eax], ecx

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	add	eax, 4
	cmp	eax, esi
	jne	SHORT $LL8@Umove_if_n
$LN7@Umove_if_n:
	pop	esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1663 :     }

	ret	12					; 0000000cH
?_Umove_if_noexcept@?$vector@PAVIRenderable@@V?$xalloc@PAVIRenderable@@@@@std@@AAEXPAPAVIRenderable@@00@Z ENDP ; std::vector<IRenderable *,xalloc<IRenderable *> >::_Umove_if_noexcept
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Umove@?$vector@PAVIRenderable@@V?$xalloc@PAVIRenderable@@@@@std@@AAEPAPAVIRenderable@@PAPAV3@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
?_Umove@?$vector@PAVIRenderable@@V?$xalloc@PAVIRenderable@@@@@std@@AAEPAPAVIRenderable@@PAPAV3@00@Z PROC ; std::vector<IRenderable *,xalloc<IRenderable *> >::_Umove, COMDAT
; _this$dead$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	mov	ecx, DWORD PTR __First$[esp-4]

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	eax, DWORD PTR __Dest$[esp-4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1644 :     _CONSTEXPR20_CONTAINER pointer _Umove(pointer _First, pointer _Last, pointer _Dest) {

	push	esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	mov	esi, DWORD PTR __Last$[esp]
	cmp	ecx, esi
	je	SHORT $LN5@Umove
$LL6@Umove:

; 1620 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

	mov	edx, DWORD PTR [ecx]

; 1621 :         ++_Last;

	add	ecx, 4
	mov	DWORD PTR [eax], edx
	add	eax, 4

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	ecx, esi
	jne	SHORT $LL6@Umove
$LN5@Umove:
	pop	esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1647 :     }

	ret	12					; 0000000cH
?_Umove@?$vector@PAVIRenderable@@V?$xalloc@PAVIRenderable@@@@@std@@AAEPAPAVIRenderable@@PAPAV3@00@Z ENDP ; std::vector<IRenderable *,xalloc<IRenderable *> >::_Umove
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?max_size@?$vector@PAVIRenderable@@V?$xalloc@PAVIRenderable@@@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@PAVIRenderable@@V?$xalloc@PAVIRenderable@@@@@std@@QBEIXZ PROC ; std::vector<IRenderable *,xalloc<IRenderable *> >::max_size, COMDAT
; _this$dead$ = ecx

; 1540 :         return (_STD min)(

	mov	eax, 1073741823				; 3fffffffH

; 1541 :             static_cast<size_type>((numeric_limits<difference_type>::max)()), _Alty_traits::max_size(_Getal()));
; 1542 :     }

	ret	0
?max_size@?$vector@PAVIRenderable@@V?$xalloc@PAVIRenderable@@@@@std@@QBEIXZ ENDP ; std::vector<IRenderable *,xalloc<IRenderable *> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?construct@?$xalloc@PAVIRenderable@@@@QAEXPAPAVIRenderable@@ABQAV2@@Z
_TEXT	SEGMENT
_p$ = 8							; size = 4
__Val$ = 12						; size = 4
?construct@?$xalloc@PAVIRenderable@@@@QAEXPAPAVIRenderable@@ABQAV2@@Z PROC ; xalloc<IRenderable *>::construct, COMDAT
; _this$dead$ = ecx

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	eax, DWORD PTR __Val$[esp-4]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR _p$[esp-4]
	mov	DWORD PTR [eax], ecx
	ret	8
?construct@?$xalloc@PAVIRenderable@@@@QAEXPAPAVIRenderable@@ABQAV2@@Z ENDP ; xalloc<IRenderable *>::construct
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?allocate@?$xalloc@PAVIRenderable@@@@QBEPAPAVIRenderable@@IPBX@Z
_TEXT	SEGMENT
_n$ = 8							; size = 4
_p$dead$ = 12						; size = 4
?allocate@?$xalloc@PAVIRenderable@@@@QBEPAPAVIRenderable@@IPBX@Z PROC ; xalloc<IRenderable *>::allocate, COMDAT
; _this$dead$ = ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	mov	eax, DWORD PTR _n$[esp-4]
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	shl	eax, 2
	push	eax
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 80   : 							pointer					allocate		(size_type n, const void* p=0) const	{	return xr_alloc<T>((u32)n);	}

	ret	8
?allocate@?$xalloc@PAVIRenderable@@@@QBEPAPAVIRenderable@@IPBX@Z ENDP ; xalloc<IRenderable *>::allocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ??0?$xalloc@PAVIRenderable@@@@QAE@XZ
_TEXT	SEGMENT
??0?$xalloc@PAVIRenderable@@@@QAE@XZ PROC		; xalloc<IRenderable *>::xalloc<IRenderable *>, COMDAT
; _this$ = ecx

; 76   : 													xalloc			()										{	}

	mov	eax, ecx
	ret	0
??0?$xalloc@PAVIRenderable@@@@QAE@XZ ENDP		; xalloc<IRenderable *>::xalloc<IRenderable *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@Urecv@CLightProjector@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Vector_val@U?$_Simple_types@Urecv@CLightProjector@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<std::_Simple_types<CLightProjector::recv> >::_Vector_val<std::_Simple_types<CLightProjector::recv> >, COMDAT
; _this$ = ecx

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx], 0
	mov	eax, ecx
	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0
	ret	0
??0?$_Vector_val@U?$_Simple_types@Urecv@CLightProjector@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<std::_Simple_types<CLightProjector::recv> >::_Vector_val<std::_Simple_types<CLightProjector::recv> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Orphan_range@?$vector@Urecv@CLightProjector@@V?$xalloc@Urecv@CLightProjector@@@@@std@@ABEXPAUrecv@CLightProjector@@0@Z
_TEXT	SEGMENT
___formal$dead$ = 8					; size = 4
___formal$dead$ = 12					; size = 4
?_Orphan_range@?$vector@Urecv@CLightProjector@@V?$xalloc@Urecv@CLightProjector@@@@@std@@ABEXPAUrecv@CLightProjector@@0@Z PROC ; std::vector<CLightProjector::recv,xalloc<CLightProjector::recv> >::_Orphan_range, COMDAT
; _this$dead$ = ecx

; 1801 :     _CONSTEXPR20_CONTAINER void _Orphan_range(pointer, pointer) const {}

	ret	8
?_Orphan_range@?$vector@Urecv@CLightProjector@@V?$xalloc@Urecv@CLightProjector@@@@@std@@ABEXPAUrecv@CLightProjector@@0@Z ENDP ; std::vector<CLightProjector::recv,xalloc<CLightProjector::recv> >::_Orphan_range
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Ufill@?$vector@Urecv@CLightProjector@@V?$xalloc@Urecv@CLightProjector@@@@@std@@AAEPAUrecv@CLightProjector@@PAU34@IU_Value_init_tag@2@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Count$ = 12						; size = 4
___formal$ = 16						; size = 1
?_Ufill@?$vector@Urecv@CLightProjector@@V?$xalloc@Urecv@CLightProjector@@@@@std@@AAEPAUrecv@CLightProjector@@PAU34@IU_Value_init_tag@2@@Z PROC ; std::vector<CLightProjector::recv,xalloc<CLightProjector::recv> >::_Ufill, COMDAT
; _this$dead$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1813 :     for (; 0 < _Count; --_Count) {

	mov	eax, DWORD PTR __Count$[esp-4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1633 :     _CONSTEXPR20_CONTAINER pointer _Ufill(pointer _Dest, const size_type _Count, _Value_init_tag) {

	push	edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	edi, DWORD PTR __Dest$[esp]

; 1813 :     for (; 0 < _Count; --_Count) {

	test	eax, eax
	je	SHORT $LN20@Ufill

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	push	esi
	imul	esi, eax, 136
	push	esi
	push	0
	push	edi
	call	_memset
	add	esp, 12					; 0000000cH
	lea	eax, DWORD PTR [esi+edi]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1635 :         return _Uninitialized_value_construct_n(_Dest, _Count, _Getal());

	pop	esi
	pop	edi

; 1636 :     }

	ret	12					; 0000000cH
$LN20@Ufill:

; 1635 :         return _Uninitialized_value_construct_n(_Dest, _Count, _Getal());

	mov	eax, edi
	pop	edi

; 1636 :     }

	ret	12					; 0000000cH
?_Ufill@?$vector@Urecv@CLightProjector@@V?$xalloc@Urecv@CLightProjector@@@@@std@@AAEPAUrecv@CLightProjector@@PAU34@IU_Value_init_tag@2@@Z ENDP ; std::vector<CLightProjector::recv,xalloc<CLightProjector::recv> >::_Ufill
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ??0?$xalloc@Urecv@CLightProjector@@@@QAE@XZ
_TEXT	SEGMENT
??0?$xalloc@Urecv@CLightProjector@@@@QAE@XZ PROC	; xalloc<CLightProjector::recv>::xalloc<CLightProjector::recv>, COMDAT
; _this$ = ecx

; 76   : 													xalloc			()										{	}

	mov	eax, ecx
	ret	0
??0?$xalloc@Urecv@CLightProjector@@@@QAE@XZ ENDP	; xalloc<CLightProjector::recv>::xalloc<CLightProjector::recv>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Getal@?$vector@PAVIRenderable@@V?$xalloc@PAVIRenderable@@@@@std@@ABEABV?$xalloc@PAVIRenderable@@@@XZ
_TEXT	SEGMENT
?_Getal@?$vector@PAVIRenderable@@V?$xalloc@PAVIRenderable@@@@@std@@ABEABV?$xalloc@PAVIRenderable@@@@XZ PROC ; std::vector<IRenderable *,xalloc<IRenderable *> >::_Getal, COMDAT
; _this$ = ecx

; 1809 :         return _Mypair._Get_first();

	mov	eax, ecx

; 1810 :     }

	ret	0
?_Getal@?$vector@PAVIRenderable@@V?$xalloc@PAVIRenderable@@@@@std@@ABEABV?$xalloc@PAVIRenderable@@@@XZ ENDP ; std::vector<IRenderable *,xalloc<IRenderable *> >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Umove_if_noexcept1@?$vector@PAVIRenderable@@V?$xalloc@PAVIRenderable@@@@@std@@AAEXPAPAVIRenderable@@00U?$integral_constant@_N$00@2@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
?_Umove_if_noexcept1@?$vector@PAVIRenderable@@V?$xalloc@PAVIRenderable@@@@@std@@AAEXPAPAVIRenderable@@00U?$integral_constant@_N$00@2@@Z PROC ; std::vector<IRenderable *,xalloc<IRenderable *> >::_Umove_if_noexcept1, COMDAT
; _this$dead$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1703 :     auto _UFirst      = _Get_unwrapped(_First);

	mov	eax, DWORD PTR __First$[esp-4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1649 :     _CONSTEXPR20_CONTAINER void _Umove_if_noexcept1(pointer _First, pointer _Last, pointer _Dest, true_type) {

	push	esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	mov	esi, DWORD PTR __Last$[esp]
	cmp	eax, esi
	je	SHORT $LN5@Umove_if_n

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	edx, DWORD PTR __Dest$[esp]
	sub	edx, eax
$LL6@Umove_if_n:

; 1620 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx+eax], ecx

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	add	eax, 4
	cmp	eax, esi
	jne	SHORT $LL6@Umove_if_n
$LN5@Umove_if_n:
	pop	esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1652 :     }

	ret	16					; 00000010H
?_Umove_if_noexcept1@?$vector@PAVIRenderable@@V?$xalloc@PAVIRenderable@@@@@std@@AAEXPAPAVIRenderable@@00U?$integral_constant@_N$00@2@@Z ENDP ; std::vector<IRenderable *,xalloc<IRenderable *> >::_Umove_if_noexcept1
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?capacity@?$vector@PAVIRenderable@@V?$xalloc@PAVIRenderable@@@@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@PAVIRenderable@@V?$xalloc@PAVIRenderable@@@@@std@@QBEIXZ PROC ; std::vector<IRenderable *,xalloc<IRenderable *> >::capacity, COMDAT
; _this$ = ecx

; 1545 :         auto& _My_data = _Mypair._Myval2;
; 1546 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx]
	sar	eax, 2

; 1547 :     }

	ret	0
?capacity@?$vector@PAVIRenderable@@V?$xalloc@PAVIRenderable@@@@@std@@QBEIXZ ENDP ; std::vector<IRenderable *,xalloc<IRenderable *> >::capacity
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?max_size@?$_Normal_allocator_traits@V?$xalloc@PAVIRenderable@@@@@std@@SAIABV?$xalloc@PAVIRenderable@@@@@Z
_TEXT	SEGMENT
?max_size@?$_Normal_allocator_traits@V?$xalloc@PAVIRenderable@@@@@std@@SAIABV?$xalloc@PAVIRenderable@@@@@Z PROC ; std::_Normal_allocator_traits<xalloc<IRenderable *> >::max_size, COMDAT
; __Al$dead$ = ecx

; 591  :         if constexpr (_Has_max_size<_Alloc>::value) {
; 592  :             return _Al.max_size();

	mov	eax, 1073741823				; 3fffffffH

; 593  :         } else {
; 594  :             return (numeric_limits<size_type>::max)() / sizeof(value_type);
; 595  :         }
; 596  :     }

	ret	0
?max_size@?$_Normal_allocator_traits@V?$xalloc@PAVIRenderable@@@@@std@@SAIABV?$xalloc@PAVIRenderable@@@@@Z ENDP ; std::_Normal_allocator_traits<xalloc<IRenderable *> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$xalloc@PAVIRenderable@@@@V?$_Vector_val@U?$_Simple_types@PAVIRenderable@@@std@@@std@@$00@std@@QBEABV?$xalloc@PAVIRenderable@@@@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@V?$xalloc@PAVIRenderable@@@@V?$_Vector_val@U?$_Simple_types@PAVIRenderable@@@std@@@std@@$00@std@@QBEABV?$xalloc@PAVIRenderable@@@@XZ PROC ; std::_Compressed_pair<xalloc<IRenderable *>,std::_Vector_val<std::_Simple_types<IRenderable *> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 1343 :         return *this;

	mov	eax, ecx

; 1344 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$xalloc@PAVIRenderable@@@@V?$_Vector_val@U?$_Simple_types@PAVIRenderable@@@std@@@std@@$00@std@@QBEABV?$xalloc@PAVIRenderable@@@@XZ ENDP ; std::_Compressed_pair<xalloc<IRenderable *>,std::_Vector_val<std::_Simple_types<IRenderable *> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?max_size@?$xalloc@PAVIRenderable@@@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$xalloc@PAVIRenderable@@@@QBEIXZ PROC	; xalloc<IRenderable *>::max_size, COMDAT
; _this$dead$ = ecx

; 86   : 							size_type				max_size		() const								{	size_type _Count = (size_type)(-1) / sizeof (T);	return (0 < _Count ? _Count : 1);	}

	mov	eax, 1073741823				; 3fffffffH
	ret	0
?max_size@?$xalloc@PAVIRenderable@@@@QBEIXZ ENDP	; xalloc<IRenderable *>::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@Urecv@CLightProjector@@V?$xalloc@Urecv@CLightProjector@@@@@std@@AAEXIABU_Value_init_tag@1@@Z
_TEXT	SEGMENT
__Backout$2 = -48					; size = 12
__Newvec$ = -36						; size = 4
_this$1$ = -32						; size = 4
__UFirst$3 = -28					; size = 4
__Oldsize$1$ = -24					; size = 4
__Newcapacity$1$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Newsize$dead$ = 8					; size = 4
__ULast$1$ = 12						; size = 4
__Val$ = 12						; size = 4
??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@Urecv@CLightProjector@@V?$xalloc@Urecv@CLightProjector@@@@@std@@AAEXIABU_Value_init_tag@1@@Z PROC ; std::vector<CLightProjector::recv,xalloc<CLightProjector::recv> >::_Resize_reallocate<std::_Value_init_tag>, COMDAT
; _this$ = ecx

; 1216 :     _CONSTEXPR20_CONTAINER void _Resize_reallocate(const size_type _Newsize, const _Ty2& _Val) {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@Urecv@CLightProjector@@V?$xalloc@Urecv@CLightProjector@@@@@std@@AAEXIABU_Value_init_tag@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 36					; 00000024H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	edi, ecx
	mov	DWORD PTR _this$1$[ebp], edi

; 1217 :         if (_Newsize > max_size()) {
; 1218 :             _Xlength();
; 1219 :         }
; 1220 : 
; 1221 :         auto& _My_data    = _Mypair._Myval2;
; 1222 :         pointer& _Myfirst = _My_data._Myfirst;
; 1223 :         pointer& _Mylast  = _My_data._Mylast;
; 1224 : 
; 1225 :         const auto _Oldsize          = static_cast<size_type>(_Mylast - _Myfirst);

	mov	edx, DWORD PTR [edi+4]
	sub	edx, DWORD PTR [edi]
	mov	eax, 2021161081				; 78787879H
	imul	edx
	sar	edx, 6
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	mov	DWORD PTR __Oldsize$1$[ebp], eax

; 1546 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	ecx, DWORD PTR [edi+8]
	sub	ecx, DWORD PTR [edi]
	mov	eax, 2021161081				; 78787879H
	imul	ecx
	sar	edx, 6
	mov	ecx, edx
	shr	ecx, 31					; 0000001fH
	add	ecx, edx

; 1675 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	edx, ecx
	shr	edx, 1
	mov	eax, 31580641				; 01e1e1e1H
	sub	eax, edx
	cmp	ecx, eax
	jbe	SHORT $LN10@Resize_rea

; 1676 :             return _Max; // geometric growth would overflow

	mov	esi, 31580641				; 01e1e1e1H
	jmp	SHORT $LN51@Resize_rea
$LN10@Resize_rea:

; 1677 :         }
; 1678 : 
; 1679 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	lea	esi, DWORD PTR [edx+ecx]

; 1680 : 
; 1681 :         if (_Geometric < _Newsize) {

	mov	eax, 100				; 00000064H
	cmp	esi, eax
	cmovb	esi, eax
$LN51@Resize_rea:
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	mov	DWORD PTR __Newcapacity$1$[ebp], esi
	imul	eax, esi, 136
	push	eax
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1228 :         const pointer _Newvec         = _Getal().allocate(_Newcapacity);

	mov	ebx, eax
	mov	DWORD PTR __Newvec$[ebp], ebx

; 1229 :         const pointer _Appended_first = _Newvec + _Oldsize;

	mov	edx, DWORD PTR __Oldsize$1$[ebp]
	imul	ecx, edx, 136
	add	ecx, ebx

; 1230 :         pointer _Appended_last        = _Appended_first;
; 1231 : 
; 1232 :         _TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 1233 :         _Appended_last = _Ufill(_Appended_first, _Newsize - _Oldsize, _Val);

	mov	eax, DWORD PTR __Val$[ebp]
	movzx	eax, BYTE PTR [eax]
	push	eax
	mov	eax, 100				; 00000064H
	sub	eax, edx
	push	eax
	push	ecx
	call	?_Ufill@?$vector@Urecv@CLightProjector@@V?$xalloc@Urecv@CLightProjector@@@@@std@@AAEPAUrecv@CLightProjector@@PAU34@IU_Value_init_tag@2@@Z ; std::vector<CLightProjector::recv,xalloc<CLightProjector::recv> >::_Ufill

; 1234 :         _Umove_if_noexcept(_Myfirst, _Mylast, _Newvec);

	mov	ecx, DWORD PTR [edi+4]
	mov	DWORD PTR __ULast$1$[ebp], ecx
	mov	eax, DWORD PTR [edi]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1703 :     auto _UFirst      = _Get_unwrapped(_First);

	mov	DWORD PTR __UFirst$3[ebp], eax

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	DWORD PTR __Backout$2[ebp], ebx
	mov	edx, ebx
	mov	DWORD PTR __Backout$2[ebp+4], edx
	mov	DWORD PTR __Backout$2[ebp+8], edi
$LL26@Resize_rea:

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	eax, ecx
	je	SHORT $LN25@Resize_rea
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	ecx, 34					; 00000022H
	mov	esi, eax
	mov	edi, edx
	rep movsd
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1621 :         ++_Last;

	add	edx, 136				; 00000088H
	mov	DWORD PTR __Backout$2[ebp+4], edx

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	add	eax, 136				; 00000088H
	mov	DWORD PTR __UFirst$3[ebp], eax
	mov	ecx, DWORD PTR __ULast$1$[ebp]
	jmp	SHORT $LL26@Resize_rea
$LN25@Resize_rea:

; 1625 :         _First = _Last;

	mov	DWORD PTR __Backout$2[ebp], edx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
	mov	DWORD PTR __$EHRec$[ebp+12], -1

; 1732 :         if (_Myfirst) { // destroy and deallocate old array

	mov	edi, DWORD PTR _this$1$[ebp]
	mov	eax, DWORD PTR [edi]
	test	eax, eax
	je	SHORT $LN44@Resize_rea
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	push	eax
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN44@Resize_rea:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1737 :         _Myfirst = _Newvec;

	mov	DWORD PTR [edi], ebx

; 1738 :         _Mylast  = _Newvec + _Newsize;

	lea	eax, DWORD PTR [ebx+13600]
	mov	DWORD PTR [edi+4], eax

; 1739 :         _Myend   = _Newvec + _Newcapacity;

	imul	eax, DWORD PTR __Newcapacity$1$[ebp], 136
	add	eax, ebx
	mov	DWORD PTR [edi+8], eax

; 1239 :         _CATCH_END
; 1240 : 
; 1241 :         _Change_array(_Newvec, _Newsize, _Newcapacity);
; 1242 :     }

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
__catch$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@Urecv@CLightProjector@@V?$xalloc@Urecv@CLightProjector@@@@@std@@AAEXIABU_Value_init_tag@1@@Z$0:

; 1235 :         _CATCH_ALL
; 1236 :         _Destroy(_Appended_first, _Appended_last);
; 1237 :         _Getal().deallocate(_Newvec, _Newcapacity);

	push	ecx
	push	DWORD PTR __Newvec$[ebp]
	call	?deallocate@?$xalloc@Urecv@CLightProjector@@@@QBEXPAUrecv@CLightProjector@@I@Z ; xalloc<CLightProjector::recv>::deallocate

; 1238 :         _RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$LN50@Resize_rea:
	int	3
	int	3
	int	3
	int	3
	int	3
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@Urecv@CLightProjector@@V?$xalloc@Urecv@CLightProjector@@@@@std@@AAEXIABU_Value_init_tag@1@@Z:
	npad	1
	npad	1
	mov	eax, OFFSET __ehfuncinfo$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@Urecv@CLightProjector@@V?$xalloc@Urecv@CLightProjector@@@@@std@@AAEXIABU_Value_init_tag@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@Urecv@CLightProjector@@V?$xalloc@Urecv@CLightProjector@@@@@std@@AAEXIABU_Value_init_tag@1@@Z ENDP ; std::vector<CLightProjector::recv,xalloc<CLightProjector::recv> >::_Resize_reallocate<std::_Value_init_tag>
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef
;	COMDAT ??$_Unfancy@Urecv@CLightProjector@@@std@@YAPAUrecv@CLightProjector@@PAU12@@Z
_TEXT	SEGMENT
??$_Unfancy@Urecv@CLightProjector@@@std@@YAPAUrecv@CLightProjector@@PAU12@@Z PROC ; std::_Unfancy<CLightProjector::recv>, COMDAT
; __Ptr$ = ecx

; 266  :     return _Ptr;

	mov	eax, ecx

; 267  : }

	ret	0
??$_Unfancy@Urecv@CLightProjector@@@std@@YAPAUrecv@CLightProjector@@PAU12@@Z ENDP ; std::_Unfancy<CLightProjector::recv>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$destroy@Urecv@CLightProjector@@@?$_Normal_allocator_traits@V?$xalloc@Urecv@CLightProjector@@@@@std@@SAXAAV?$xalloc@Urecv@CLightProjector@@@@PAUrecv@CLightProjector@@@Z
_TEXT	SEGMENT
??$destroy@Urecv@CLightProjector@@@?$_Normal_allocator_traits@V?$xalloc@Urecv@CLightProjector@@@@@std@@SAXAAV?$xalloc@Urecv@CLightProjector@@@@PAUrecv@CLightProjector@@@Z PROC ; std::_Normal_allocator_traits<xalloc<CLightProjector::recv> >::destroy<CLightProjector::recv>, COMDAT
; __Al$dead$ = ecx
; __Ptr$dead$ = edx

; 579  :         if constexpr (_Uses_default_destroy<_Alloc, _Ty*>::value) {
; 580  : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 581  :             _STD destroy_at(_Ptr);
; 582  : #else // __cpp_lib_constexpr_dynamic_alloc
; 583  :             _Ptr->~_Ty();
; 584  : #endif // __cpp_lib_constexpr_dynamic_alloc
; 585  :         } else {
; 586  :             _Al.destroy(_Ptr);
; 587  :         }
; 588  :     }

	ret	0
??$destroy@Urecv@CLightProjector@@@?$_Normal_allocator_traits@V?$xalloc@Urecv@CLightProjector@@@@@std@@SAXAAV?$xalloc@Urecv@CLightProjector@@@@PAUrecv@CLightProjector@@@Z ENDP ; std::_Normal_allocator_traits<xalloc<CLightProjector::recv> >::destroy<CLightProjector::recv>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Uninitialized_move@PAPAVIRenderable@@V?$xalloc@PAVIRenderable@@@@@std@@YAPAPAVIRenderable@@QAPAV1@0PAPAV1@AAV?$xalloc@PAVIRenderable@@@@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Al$dead$ = 12						; size = 4
??$_Uninitialized_move@PAPAVIRenderable@@V?$xalloc@PAVIRenderable@@@@@std@@YAPAPAVIRenderable@@QAPAV1@0PAPAV1@AAV?$xalloc@PAVIRenderable@@@@@Z PROC ; std::_Uninitialized_move<IRenderable * *,xalloc<IRenderable *> >, COMDAT
; __First$ = ecx
; __Last$ = edx

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	eax, DWORD PTR __Dest$[esp-4]

; 1699 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

	push	esi
	mov	esi, edx

; 1700 :     // move [_First, _Last) to raw _Dest, using _Al
; 1701 :     // note: only called internally from elsewhere in the STL
; 1702 :     using _Ptrval     = typename _Alloc::value_type*;
; 1703 :     auto _UFirst      = _Get_unwrapped(_First);
; 1704 :     const auto _ULast = _Get_unwrapped(_Last);
; 1705 :     if constexpr (conjunction_v<bool_constant<_Ptr_move_cat<decltype(_UFirst), _Ptrval>::_Really_trivial>,
; 1706 :                       _Uses_default_construct<_Alloc, _Ptrval, decltype(_STD move(*_UFirst))>>) {
; 1707 : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 1708 :         if (!_STD is_constant_evaluated())
; 1709 : #endif // __cpp_lib_constexpr_dynamic_alloc
; 1710 :         {
; 1711 :             _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));
; 1712 :             return _Dest + (_ULast - _UFirst);
; 1713 :         }
; 1714 :     }
; 1715 : 
; 1716 :     _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	ecx, esi
	je	SHORT $LN3@Uninitiali
	npad	5
$LL4@Uninitiali:

; 1620 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

	mov	edx, DWORD PTR [ecx]

; 1621 :         ++_Last;

	add	ecx, 4
	mov	DWORD PTR [eax], edx
	add	eax, 4

; 1700 :     // move [_First, _Last) to raw _Dest, using _Al
; 1701 :     // note: only called internally from elsewhere in the STL
; 1702 :     using _Ptrval     = typename _Alloc::value_type*;
; 1703 :     auto _UFirst      = _Get_unwrapped(_First);
; 1704 :     const auto _ULast = _Get_unwrapped(_Last);
; 1705 :     if constexpr (conjunction_v<bool_constant<_Ptr_move_cat<decltype(_UFirst), _Ptrval>::_Really_trivial>,
; 1706 :                       _Uses_default_construct<_Alloc, _Ptrval, decltype(_STD move(*_UFirst))>>) {
; 1707 : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 1708 :         if (!_STD is_constant_evaluated())
; 1709 : #endif // __cpp_lib_constexpr_dynamic_alloc
; 1710 :         {
; 1711 :             _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));
; 1712 :             return _Dest + (_ULast - _UFirst);
; 1713 :         }
; 1714 :     }
; 1715 : 
; 1716 :     _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	ecx, esi
	jne	SHORT $LL4@Uninitiali
$LN3@Uninitiali:
	pop	esi

; 1718 :         _Backout._Emplace_back(_STD move(*_UFirst));
; 1719 :     }
; 1720 : 
; 1721 :     return _Backout._Release();
; 1722 : }

	ret	0
??$_Uninitialized_move@PAPAVIRenderable@@V?$xalloc@PAVIRenderable@@@@@std@@YAPAPAVIRenderable@@QAPAV1@0PAPAV1@AAV?$xalloc@PAVIRenderable@@@@@Z ENDP ; std::_Uninitialized_move<IRenderable * *,xalloc<IRenderable *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_Get_unwrapped@ABQAPAVIRenderable@@@std@@YA?A_TABQAPAVIRenderable@@@Z
_TEXT	SEGMENT
??$_Get_unwrapped@ABQAPAVIRenderable@@@std@@YA?A_TABQAPAVIRenderable@@@Z PROC ; std::_Get_unwrapped<IRenderable * * const &>, COMDAT
; __It$ = ecx

; 1275 :     // unwrap an iterator previously subjected to _Adl_verify_range or otherwise validated
; 1276 :     if constexpr (is_pointer_v<decay_t<_Iter>>) { // special-case pointers and arrays
; 1277 :         return _It + 0;

	mov	eax, DWORD PTR [ecx]

; 1278 :     } else if constexpr (_Unwrappable_v<_Iter>) {
; 1279 :         return static_cast<_Iter&&>(_It)._Unwrapped();
; 1280 :     } else {
; 1281 :         return static_cast<_Iter&&>(_It);
; 1282 :     }
; 1283 : }

	ret	0
??$_Get_unwrapped@ABQAPAVIRenderable@@@std@@YA?A_TABQAPAVIRenderable@@@Z ENDP ; std::_Get_unwrapped<IRenderable * * const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
;	COMDAT ??$xr_alloc@PAVIRenderable@@@@YAPAPAVIRenderable@@I@Z
_TEXT	SEGMENT
??$xr_alloc@PAVIRenderable@@@@YAPAPAVIRenderable@@I@Z PROC ; xr_alloc<IRenderable *>, COMDAT
; _count$ = ecx

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	lea	eax, DWORD PTR [ecx*4]
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
	ret	0
??$xr_alloc@PAVIRenderable@@@@YAPAPAVIRenderable@@I@Z ENDP ; xr_alloc<IRenderable *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Uninitialized_value_construct_n@V?$xalloc@Urecv@CLightProjector@@@@@std@@YAPAUrecv@CLightProjector@@PAU12@IAAV?$xalloc@Urecv@CLightProjector@@@@@Z
_TEXT	SEGMENT
__Al$dead$ = 8						; size = 4
??$_Uninitialized_value_construct_n@V?$xalloc@Urecv@CLightProjector@@@@@std@@YAPAUrecv@CLightProjector@@PAU12@IAAV?$xalloc@Urecv@CLightProjector@@@@@Z PROC ; std::_Uninitialized_value_construct_n<xalloc<CLightProjector::recv> >, COMDAT
; __First$ = ecx
; __Count$ = edx

; 1798 :     _Alloc_ptr_t<_Alloc> _First, _Alloc_size_t<_Alloc> _Count, _Alloc& _Al) {

	push	edi
	mov	edi, ecx

; 1799 :     // value-initialize _Count objects to raw _First, using _Al
; 1800 :     using _Ptrty = typename _Alloc::value_type*;
; 1801 :     if constexpr (_Use_memset_value_construct_v<_Ptrty> && _Uses_default_construct<_Alloc, _Ptrty>::value) {
; 1802 : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 1803 :         if (!_STD is_constant_evaluated())
; 1804 : #endif // __cpp_lib_constexpr_dynamic_alloc
; 1805 :         {
; 1806 :             auto _PFirst = _Unfancy(_First);
; 1807 :             _Zero_range(_PFirst, _PFirst + _Count);
; 1808 :             return _First + _Count;
; 1809 :         }
; 1810 :     }
; 1811 : 
; 1812 :     _Uninitialized_backout_al<_Alloc> _Backout{_First, _Al};
; 1813 :     for (; 0 < _Count; --_Count) {

	test	edx, edx
	je	SHORT $LN18@Uninitiali
	push	esi
	imul	esi, edx, 136
	push	esi
	push	0
	push	edi
	call	_memset
	add	esp, 12					; 0000000cH
	lea	eax, DWORD PTR [esi+edi]

; 1814 :         _Backout._Emplace_back();
; 1815 :     }
; 1816 : 
; 1817 :     return _Backout._Release();

	pop	esi
	pop	edi

; 1818 : }

	ret	0
$LN18@Uninitiali:

; 1814 :         _Backout._Emplace_back();
; 1815 :     }
; 1816 : 
; 1817 :     return _Backout._Release();

	mov	eax, edi
	pop	edi

; 1818 : }

	ret	0
??$_Uninitialized_value_construct_n@V?$xalloc@Urecv@CLightProjector@@@@@std@@YAPAUrecv@CLightProjector@@PAU12@IAAV?$xalloc@Urecv@CLightProjector@@@@@Z ENDP ; std::_Uninitialized_value_construct_n<xalloc<CLightProjector::recv> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Release@?$_Uninitialized_backout_al@V?$xalloc@Urecv@CLightProjector@@@@@std@@QAEPAUrecv@CLightProjector@@XZ
_TEXT	SEGMENT
?_Release@?$_Uninitialized_backout_al@V?$xalloc@Urecv@CLightProjector@@@@@std@@QAEPAUrecv@CLightProjector@@XZ PROC ; std::_Uninitialized_backout_al<xalloc<CLightProjector::recv> >::_Release, COMDAT
; _this$ = ecx

; 1625 :         _First = _Last;

	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [ecx], eax

; 1626 :         return _Last;
; 1627 :     }

	ret	0
?_Release@?$_Uninitialized_backout_al@V?$xalloc@Urecv@CLightProjector@@@@@std@@QAEPAUrecv@CLightProjector@@XZ ENDP ; std::_Uninitialized_backout_al<xalloc<CLightProjector::recv> >::_Release
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??1?$_Uninitialized_backout_al@V?$xalloc@Urecv@CLightProjector@@@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Uninitialized_backout_al@V?$xalloc@Urecv@CLightProjector@@@@@std@@QAE@XZ PROC ; std::_Uninitialized_backout_al<xalloc<CLightProjector::recv> >::~_Uninitialized_backout_al<xalloc<CLightProjector::recv> >, COMDAT
; _this$ = ecx

; 1615 :         _Destroy_range(_First, _Last, _Al);
; 1616 :     }

	ret	0
??1?$_Uninitialized_backout_al@V?$xalloc@Urecv@CLightProjector@@@@@std@@QAE@XZ ENDP ; std::_Uninitialized_backout_al<xalloc<CLightProjector::recv> >::~_Uninitialized_backout_al<xalloc<CLightProjector::recv> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??0?$_Uninitialized_backout_al@V?$xalloc@Urecv@CLightProjector@@@@@std@@QAE@PAUrecv@CLightProjector@@AAV?$xalloc@Urecv@CLightProjector@@@@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Al_$ = 12						; size = 4
??0?$_Uninitialized_backout_al@V?$xalloc@Urecv@CLightProjector@@@@@std@@QAE@PAUrecv@CLightProjector@@AAV?$xalloc@Urecv@CLightProjector@@@@@Z PROC ; std::_Uninitialized_backout_al<xalloc<CLightProjector::recv> >::_Uninitialized_backout_al<xalloc<CLightProjector::recv> >, COMDAT
; _this$ = ecx

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	eax, DWORD PTR __Dest$[esp-4]
	mov	DWORD PTR [ecx], eax
	mov	DWORD PTR [ecx+4], eax
	mov	eax, DWORD PTR __Al_$[esp-4]
	mov	DWORD PTR [ecx+8], eax
	mov	eax, ecx
	ret	8
??0?$_Uninitialized_backout_al@V?$xalloc@Urecv@CLightProjector@@@@@std@@QAE@PAUrecv@CLightProjector@@AAV?$xalloc@Urecv@CLightProjector@@@@@Z ENDP ; std::_Uninitialized_backout_al<xalloc<CLightProjector::recv> >::_Uninitialized_backout_al<xalloc<CLightProjector::recv> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Release@?$_Uninitialized_backout_al@V?$xalloc@PAVIRenderable@@@@@std@@QAEPAPAVIRenderable@@XZ
_TEXT	SEGMENT
?_Release@?$_Uninitialized_backout_al@V?$xalloc@PAVIRenderable@@@@@std@@QAEPAPAVIRenderable@@XZ PROC ; std::_Uninitialized_backout_al<xalloc<IRenderable *> >::_Release, COMDAT
; _this$ = ecx

; 1625 :         _First = _Last;

	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [ecx], eax

; 1626 :         return _Last;
; 1627 :     }

	ret	0
?_Release@?$_Uninitialized_backout_al@V?$xalloc@PAVIRenderable@@@@@std@@QAEPAPAVIRenderable@@XZ ENDP ; std::_Uninitialized_backout_al<xalloc<IRenderable *> >::_Release
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??1?$_Uninitialized_backout_al@V?$xalloc@PAVIRenderable@@@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Uninitialized_backout_al@V?$xalloc@PAVIRenderable@@@@@std@@QAE@XZ PROC ; std::_Uninitialized_backout_al<xalloc<IRenderable *> >::~_Uninitialized_backout_al<xalloc<IRenderable *> >, COMDAT
; _this$ = ecx

; 1615 :         _Destroy_range(_First, _Last, _Al);
; 1616 :     }

	ret	0
??1?$_Uninitialized_backout_al@V?$xalloc@PAVIRenderable@@@@@std@@QAE@XZ ENDP ; std::_Uninitialized_backout_al<xalloc<IRenderable *> >::~_Uninitialized_backout_al<xalloc<IRenderable *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??0?$_Uninitialized_backout_al@V?$xalloc@PAVIRenderable@@@@@std@@QAE@PAPAVIRenderable@@AAV?$xalloc@PAVIRenderable@@@@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Al_$ = 12						; size = 4
??0?$_Uninitialized_backout_al@V?$xalloc@PAVIRenderable@@@@@std@@QAE@PAPAVIRenderable@@AAV?$xalloc@PAVIRenderable@@@@@Z PROC ; std::_Uninitialized_backout_al<xalloc<IRenderable *> >::_Uninitialized_backout_al<xalloc<IRenderable *> >, COMDAT
; _this$ = ecx

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	eax, DWORD PTR __Dest$[esp-4]
	mov	DWORD PTR [ecx], eax
	mov	DWORD PTR [ecx+4], eax
	mov	eax, DWORD PTR __Al_$[esp-4]
	mov	DWORD PTR [ecx+8], eax
	mov	eax, ecx
	ret	8
??0?$_Uninitialized_backout_al@V?$xalloc@PAVIRenderable@@@@@std@@QAE@PAPAVIRenderable@@AAV?$xalloc@PAVIRenderable@@@@@Z ENDP ; std::_Uninitialized_backout_al<xalloc<IRenderable *> >::_Uninitialized_backout_al<xalloc<IRenderable *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Xlength@?$vector@Urecv@CLightProjector@@V?$xalloc@Urecv@CLightProjector@@@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@Urecv@CLightProjector@@V?$xalloc@Urecv@CLightProjector@@@@@std@@CAXXZ PROC ; std::vector<CLightProjector::recv,xalloc<CLightProjector::recv> >::_Xlength, COMDAT

; 1761 :         _Xlength_error("vector too long");

	push	OFFSET ??_C@_0BA@FOIKENOD@vector?5too?5long@
	call	DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN3@Xlength:
	int	3
?_Xlength@?$vector@Urecv@CLightProjector@@V?$xalloc@Urecv@CLightProjector@@@@@std@@CAXXZ ENDP ; std::vector<CLightProjector::recv,xalloc<CLightProjector::recv> >::_Xlength
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Change_array@?$vector@Urecv@CLightProjector@@V?$xalloc@Urecv@CLightProjector@@@@@std@@AAEXQAUrecv@CLightProjector@@II@Z
_TEXT	SEGMENT
__Newvec$ = 8						; size = 4
__Newsize$dead$ = 12					; size = 4
__Newcapacity$ = 16					; size = 4
?_Change_array@?$vector@Urecv@CLightProjector@@V?$xalloc@Urecv@CLightProjector@@@@@std@@AAEXQAUrecv@CLightProjector@@II@Z PROC ; std::vector<CLightProjector::recv,xalloc<CLightProjector::recv> >::_Change_array, COMDAT
; _this$ = ecx

; 1723 :         const pointer _Newvec, const size_type _Newsize, const size_type _Newcapacity) {

	push	esi
	mov	esi, ecx

; 1724 :         // orphan all iterators, discard old array, acquire new array
; 1725 :         auto& _My_data    = _Mypair._Myval2;
; 1726 :         pointer& _Myfirst = _My_data._Myfirst;
; 1727 :         pointer& _Mylast  = _My_data._Mylast;
; 1728 :         pointer& _Myend   = _My_data._Myend;
; 1729 : 
; 1730 :         _My_data._Orphan_all();
; 1731 : 
; 1732 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN7@Change_arr
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN7@Change_arr:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1737 :         _Myfirst = _Newvec;

	mov	ecx, DWORD PTR __Newvec$[esp]
	mov	DWORD PTR [esi], ecx

; 1738 :         _Mylast  = _Newvec + _Newsize;

	lea	eax, DWORD PTR [ecx+13600]
	mov	DWORD PTR [esi+4], eax

; 1739 :         _Myend   = _Newvec + _Newcapacity;

	imul	eax, DWORD PTR __Newcapacity$[esp], 136
	add	eax, ecx
	mov	DWORD PTR [esi+8], eax
	pop	esi

; 1740 :     }

	ret	12					; 0000000cH
?_Change_array@?$vector@Urecv@CLightProjector@@V?$xalloc@Urecv@CLightProjector@@@@@std@@AAEXQAUrecv@CLightProjector@@II@Z ENDP ; std::vector<CLightProjector::recv,xalloc<CLightProjector::recv> >::_Change_array
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Calculate_growth@?$vector@Urecv@CLightProjector@@V?$xalloc@Urecv@CLightProjector@@@@@std@@ABEII@Z
_TEXT	SEGMENT
__Newsize$dead$ = 8					; size = 4
?_Calculate_growth@?$vector@Urecv@CLightProjector@@V?$xalloc@Urecv@CLightProjector@@@@@std@@ABEII@Z PROC ; std::vector<CLightProjector::recv,xalloc<CLightProjector::recv> >::_Calculate_growth, COMDAT
; _this$ = ecx

; 1546 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	edx, DWORD PTR [ecx+8]
	mov	eax, 2021161081				; 78787879H
	sub	edx, DWORD PTR [ecx]

; 1671 :         // given _Oldcapacity and _Newsize, calculate geometric growth
; 1672 :         const size_type _Oldcapacity = capacity();
; 1673 :         const auto _Max              = max_size();
; 1674 : 
; 1675 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	ecx, 31580641				; 01e1e1e1H

; 1546 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	imul	edx

; 1670 :     _CONSTEXPR20_CONTAINER size_type _Calculate_growth(const size_type _Newsize) const {

	push	esi

; 1546 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	sar	edx, 6
	mov	esi, edx
	shr	esi, 31					; 0000001fH
	add	esi, edx

; 1671 :         // given _Oldcapacity and _Newsize, calculate geometric growth
; 1672 :         const size_type _Oldcapacity = capacity();
; 1673 :         const auto _Max              = max_size();
; 1674 : 
; 1675 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	edx, esi
	shr	edx, 1
	sub	ecx, edx
	cmp	esi, ecx
	jbe	SHORT $LN2@Calculate_

; 1676 :             return _Max; // geometric growth would overflow

	mov	eax, 31580641				; 01e1e1e1H
	pop	esi

; 1682 :             return _Newsize; // geometric growth would be insufficient
; 1683 :         }
; 1684 : 
; 1685 :         return _Geometric; // geometric growth is sufficient
; 1686 :     }

	ret	4
$LN2@Calculate_:

; 1677 :         }
; 1678 : 
; 1679 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	lea	eax, DWORD PTR [edx+esi]

; 1680 : 
; 1681 :         if (_Geometric < _Newsize) {

	mov	ecx, 100				; 00000064H
	cmp	eax, ecx
	pop	esi
	cmovb	eax, ecx

; 1682 :             return _Newsize; // geometric growth would be insufficient
; 1683 :         }
; 1684 : 
; 1685 :         return _Geometric; // geometric growth is sufficient
; 1686 :     }

	ret	4
?_Calculate_growth@?$vector@Urecv@CLightProjector@@V?$xalloc@Urecv@CLightProjector@@@@@std@@ABEII@Z ENDP ; std::vector<CLightProjector::recv,xalloc<CLightProjector::recv> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Umove_if_noexcept@?$vector@Urecv@CLightProjector@@V?$xalloc@Urecv@CLightProjector@@@@@std@@AAEXPAUrecv@CLightProjector@@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
?_Umove_if_noexcept@?$vector@Urecv@CLightProjector@@V?$xalloc@Urecv@CLightProjector@@@@@std@@AAEXPAUrecv@CLightProjector@@00@Z PROC ; std::vector<CLightProjector::recv,xalloc<CLightProjector::recv> >::_Umove_if_noexcept, COMDAT
; _this$dead$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1703 :     auto _UFirst      = _Get_unwrapped(_First);

	mov	eax, DWORD PTR __First$[esp-4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1659 :     _CONSTEXPR20_CONTAINER void _Umove_if_noexcept(pointer _First, pointer _Last, pointer _Dest) {

	push	ebx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	mov	ebx, DWORD PTR __Last$[esp]
	cmp	eax, ebx
	je	SHORT $LN7@Umove_if_n

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	edx, DWORD PTR __Dest$[esp]
	push	esi
	sub	edx, eax
	push	edi
$LL8@Umove_if_n:
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	lea	edi, DWORD PTR [edx+eax]
	mov	esi, eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	add	eax, 136				; 00000088H
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	ecx, 34					; 00000022H
	rep movsd
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	eax, ebx
	jne	SHORT $LL8@Umove_if_n
	pop	edi
	pop	esi
$LN7@Umove_if_n:
	pop	ebx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1663 :     }

	ret	12					; 0000000cH
?_Umove_if_noexcept@?$vector@Urecv@CLightProjector@@V?$xalloc@Urecv@CLightProjector@@@@@std@@AAEXPAUrecv@CLightProjector@@00@Z ENDP ; std::vector<CLightProjector::recv,xalloc<CLightProjector::recv> >::_Umove_if_noexcept
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?max_size@?$vector@Urecv@CLightProjector@@V?$xalloc@Urecv@CLightProjector@@@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@Urecv@CLightProjector@@V?$xalloc@Urecv@CLightProjector@@@@@std@@QBEIXZ PROC ; std::vector<CLightProjector::recv,xalloc<CLightProjector::recv> >::max_size, COMDAT
; _this$dead$ = ecx

; 1540 :         return (_STD min)(

	mov	eax, 31580641				; 01e1e1e1H

; 1541 :             static_cast<size_type>((numeric_limits<difference_type>::max)()), _Alty_traits::max_size(_Getal()));
; 1542 :     }

	ret	0
?max_size@?$vector@Urecv@CLightProjector@@V?$xalloc@Urecv@CLightProjector@@@@@std@@QBEIXZ ENDP ; std::vector<CLightProjector::recv,xalloc<CLightProjector::recv> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?destroy@?$xalloc@Urecv@CLightProjector@@@@QAEXPAUrecv@CLightProjector@@@Z
_TEXT	SEGMENT
_p$dead$ = 8						; size = 4
?destroy@?$xalloc@Urecv@CLightProjector@@@@QAEXPAUrecv@CLightProjector@@@Z PROC ; xalloc<CLightProjector::recv>::destroy, COMDAT
; _this$dead$ = ecx

; 85   : 							void					destroy			(pointer p)								{	std::_Destroy_in_place(p);			}

	ret	4
?destroy@?$xalloc@Urecv@CLightProjector@@@@QAEXPAUrecv@CLightProjector@@@Z ENDP ; xalloc<CLightProjector::recv>::destroy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?allocate@?$xalloc@Urecv@CLightProjector@@@@QBEPAUrecv@CLightProjector@@IPBX@Z
_TEXT	SEGMENT
_n$ = 8							; size = 4
_p$dead$ = 12						; size = 4
?allocate@?$xalloc@Urecv@CLightProjector@@@@QBEPAUrecv@CLightProjector@@IPBX@Z PROC ; xalloc<CLightProjector::recv>::allocate, COMDAT
; _this$dead$ = ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	imul	eax, DWORD PTR _n$[esp-4], 136
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 80   : 							pointer					allocate		(size_type n, const void* p=0) const	{	return xr_alloc<T>((u32)n);	}

	ret	8
?allocate@?$xalloc@Urecv@CLightProjector@@@@QBEPAUrecv@CLightProjector@@IPBX@Z ENDP ; xalloc<CLightProjector::recv>::allocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Getal@?$vector@Urecv@CLightProjector@@V?$xalloc@Urecv@CLightProjector@@@@@std@@ABEABV?$xalloc@Urecv@CLightProjector@@@@XZ
_TEXT	SEGMENT
?_Getal@?$vector@Urecv@CLightProjector@@V?$xalloc@Urecv@CLightProjector@@@@@std@@ABEABV?$xalloc@Urecv@CLightProjector@@@@XZ PROC ; std::vector<CLightProjector::recv,xalloc<CLightProjector::recv> >::_Getal, COMDAT
; _this$ = ecx

; 1809 :         return _Mypair._Get_first();

	mov	eax, ecx

; 1810 :     }

	ret	0
?_Getal@?$vector@Urecv@CLightProjector@@V?$xalloc@Urecv@CLightProjector@@@@@std@@ABEABV?$xalloc@Urecv@CLightProjector@@@@XZ ENDP ; std::vector<CLightProjector::recv,xalloc<CLightProjector::recv> >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Umove_if_noexcept1@?$vector@Urecv@CLightProjector@@V?$xalloc@Urecv@CLightProjector@@@@@std@@AAEXPAUrecv@CLightProjector@@00U?$integral_constant@_N$00@2@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
?_Umove_if_noexcept1@?$vector@Urecv@CLightProjector@@V?$xalloc@Urecv@CLightProjector@@@@@std@@AAEXPAUrecv@CLightProjector@@00U?$integral_constant@_N$00@2@@Z PROC ; std::vector<CLightProjector::recv,xalloc<CLightProjector::recv> >::_Umove_if_noexcept1, COMDAT
; _this$dead$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1703 :     auto _UFirst      = _Get_unwrapped(_First);

	mov	eax, DWORD PTR __First$[esp-4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1649 :     _CONSTEXPR20_CONTAINER void _Umove_if_noexcept1(pointer _First, pointer _Last, pointer _Dest, true_type) {

	push	ebx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	mov	ebx, DWORD PTR __Last$[esp]
	cmp	eax, ebx
	je	SHORT $LN5@Umove_if_n

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	edx, DWORD PTR __Dest$[esp]
	push	esi
	sub	edx, eax
	push	edi
$LL6@Umove_if_n:
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	lea	edi, DWORD PTR [edx+eax]
	mov	esi, eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	add	eax, 136				; 00000088H
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	ecx, 34					; 00000022H
	rep movsd
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	eax, ebx
	jne	SHORT $LL6@Umove_if_n
	pop	edi
	pop	esi
$LN5@Umove_if_n:
	pop	ebx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1652 :     }

	ret	16					; 00000010H
?_Umove_if_noexcept1@?$vector@Urecv@CLightProjector@@V?$xalloc@Urecv@CLightProjector@@@@@std@@AAEXPAUrecv@CLightProjector@@00U?$integral_constant@_N$00@2@@Z ENDP ; std::vector<CLightProjector::recv,xalloc<CLightProjector::recv> >::_Umove_if_noexcept1
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?capacity@?$vector@Urecv@CLightProjector@@V?$xalloc@Urecv@CLightProjector@@@@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@Urecv@CLightProjector@@V?$xalloc@Urecv@CLightProjector@@@@@std@@QBEIXZ PROC ; std::vector<CLightProjector::recv,xalloc<CLightProjector::recv> >::capacity, COMDAT
; _this$ = ecx

; 1545 :         auto& _My_data = _Mypair._Myval2;
; 1546 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	edx, DWORD PTR [ecx+8]
	mov	eax, 2021161081				; 78787879H
	sub	edx, DWORD PTR [ecx]
	imul	edx
	sar	edx, 6
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx

; 1547 :     }

	ret	0
?capacity@?$vector@Urecv@CLightProjector@@V?$xalloc@Urecv@CLightProjector@@@@@std@@QBEIXZ ENDP ; std::vector<CLightProjector::recv,xalloc<CLightProjector::recv> >::capacity
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?max_size@?$_Normal_allocator_traits@V?$xalloc@Urecv@CLightProjector@@@@@std@@SAIABV?$xalloc@Urecv@CLightProjector@@@@@Z
_TEXT	SEGMENT
?max_size@?$_Normal_allocator_traits@V?$xalloc@Urecv@CLightProjector@@@@@std@@SAIABV?$xalloc@Urecv@CLightProjector@@@@@Z PROC ; std::_Normal_allocator_traits<xalloc<CLightProjector::recv> >::max_size, COMDAT
; __Al$dead$ = ecx

; 591  :         if constexpr (_Has_max_size<_Alloc>::value) {
; 592  :             return _Al.max_size();

	mov	eax, 31580641				; 01e1e1e1H

; 593  :         } else {
; 594  :             return (numeric_limits<size_type>::max)() / sizeof(value_type);
; 595  :         }
; 596  :     }

	ret	0
?max_size@?$_Normal_allocator_traits@V?$xalloc@Urecv@CLightProjector@@@@@std@@SAIABV?$xalloc@Urecv@CLightProjector@@@@@Z ENDP ; std::_Normal_allocator_traits<xalloc<CLightProjector::recv> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$xalloc@Urecv@CLightProjector@@@@V?$_Vector_val@U?$_Simple_types@Urecv@CLightProjector@@@std@@@std@@$00@std@@QBEABV?$xalloc@Urecv@CLightProjector@@@@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@V?$xalloc@Urecv@CLightProjector@@@@V?$_Vector_val@U?$_Simple_types@Urecv@CLightProjector@@@std@@@std@@$00@std@@QBEABV?$xalloc@Urecv@CLightProjector@@@@XZ PROC ; std::_Compressed_pair<xalloc<CLightProjector::recv>,std::_Vector_val<std::_Simple_types<CLightProjector::recv> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 1343 :         return *this;

	mov	eax, ecx

; 1344 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$xalloc@Urecv@CLightProjector@@@@V?$_Vector_val@U?$_Simple_types@Urecv@CLightProjector@@@std@@@std@@$00@std@@QBEABV?$xalloc@Urecv@CLightProjector@@@@XZ ENDP ; std::_Compressed_pair<xalloc<CLightProjector::recv>,std::_Vector_val<std::_Simple_types<CLightProjector::recv> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?max_size@?$xalloc@Urecv@CLightProjector@@@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$xalloc@Urecv@CLightProjector@@@@QBEIXZ PROC	; xalloc<CLightProjector::recv>::max_size, COMDAT
; _this$dead$ = ecx

; 86   : 							size_type				max_size		() const								{	size_type _Count = (size_type)(-1) / sizeof (T);	return (0 < _Count ? _Count : 1);	}

	mov	eax, 31580641				; 01e1e1e1H
	ret	0
?max_size@?$xalloc@Urecv@CLightProjector@@@@QBEIXZ ENDP	; xalloc<CLightProjector::recv>::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\type_traits
;	COMDAT ??$move@AAPAVIRenderable@@@std@@YA$$QAPAVIRenderable@@AAPAV1@@Z
_TEXT	SEGMENT
??$move@AAPAVIRenderable@@@std@@YA$$QAPAVIRenderable@@AAPAV1@@Z PROC ; std::move<IRenderable * &>, COMDAT
; __Arg$ = ecx

; 1397 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

	mov	eax, ecx

; 1398 : }

	ret	0
??$move@AAPAVIRenderable@@@std@@YA$$QAPAVIRenderable@@AAPAV1@@Z ENDP ; std::move<IRenderable * &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Emplace_back@PAVIRenderable@@@?$_Uninitialized_backout_al@V?$xalloc@PAVIRenderable@@@@@std@@QAEX$$QAPAVIRenderable@@@Z
_TEXT	SEGMENT
_<_Vals_0>$ = 8						; size = 4
??$_Emplace_back@PAVIRenderable@@@?$_Uninitialized_backout_al@V?$xalloc@PAVIRenderable@@@@@std@@QAEX$$QAPAVIRenderable@@@Z PROC ; std::_Uninitialized_backout_al<xalloc<IRenderable *> >::_Emplace_back<IRenderable *>, COMDAT
; _this$ = ecx

; 1620 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _<_Vals_0>$[esp-4]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edx], eax

; 1621 :         ++_Last;

	add	DWORD PTR [ecx+4], 4

; 1622 :     }

	ret	4
??$_Emplace_back@PAVIRenderable@@@?$_Uninitialized_backout_al@V?$xalloc@PAVIRenderable@@@@@std@@QAEX$$QAPAVIRenderable@@@Z ENDP ; std::_Uninitialized_backout_al<xalloc<IRenderable *> >::_Emplace_back<IRenderable *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Emplace_back@$$V@?$_Uninitialized_backout_al@V?$xalloc@Urecv@CLightProjector@@@@@std@@QAEXXZ
_TEXT	SEGMENT
??$_Emplace_back@$$V@?$_Uninitialized_backout_al@V?$xalloc@Urecv@CLightProjector@@@@@std@@QAEXXZ PROC ; std::_Uninitialized_backout_al<xalloc<CLightProjector::recv> >::_Emplace_back<>, COMDAT
; _this$ = ecx

; 1619 :     _CONSTEXPR20_DYNALLOC void _Emplace_back(_Types&&... _Vals) { // construct a new element at *_Last and increment

	push	esi
	mov	esi, ecx

; 570  :             ::new (static_cast<void*>(_Ptr)) _Ty(_STD forward<_Types>(_Args)...);

	push	136					; 00000088H
	push	0
	push	DWORD PTR [esi+4]
	call	_memset

; 1620 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);
; 1621 :         ++_Last;

	add	DWORD PTR [esi+4], 136			; 00000088H

; 570  :             ::new (static_cast<void*>(_Ptr)) _Ty(_STD forward<_Types>(_Args)...);

	add	esp, 12					; 0000000cH

; 1620 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);
; 1621 :         ++_Last;

	pop	esi

; 1622 :     }

	ret	0
??$_Emplace_back@$$V@?$_Uninitialized_backout_al@V?$xalloc@Urecv@CLightProjector@@@@@std@@QAEXXZ ENDP ; std::_Uninitialized_backout_al<xalloc<CLightProjector::recv> >::_Emplace_back<>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Destroy_in_place@PAUrecv@CLightProjector@@@std@@YAXAAPAUrecv@CLightProjector@@@Z
_TEXT	SEGMENT
??$_Destroy_in_place@PAUrecv@CLightProjector@@@std@@YAXAAPAUrecv@CLightProjector@@@Z PROC ; std::_Destroy_in_place<CLightProjector::recv *>, COMDAT
; __Obj$dead$ = ecx

; 295  :     if constexpr (is_array_v<_Ty>) {
; 296  :         _Destroy_range(_Obj, _Obj + extent_v<_Ty>);
; 297  :     } else {
; 298  :         _Obj.~_Ty();
; 299  :     }
; 300  : }

	ret	0
??$_Destroy_in_place@PAUrecv@CLightProjector@@@std@@YAXAAPAUrecv@CLightProjector@@@Z ENDP ; std::_Destroy_in_place<CLightProjector::recv *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
;	COMDAT ??$xr_alloc@Urecv@CLightProjector@@@@YAPAUrecv@CLightProjector@@I@Z
_TEXT	SEGMENT
??$xr_alloc@Urecv@CLightProjector@@@@YAPAUrecv@CLightProjector@@I@Z PROC ; xr_alloc<CLightProjector::recv>, COMDAT
; _count$ = ecx

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	imul	eax, ecx, 136
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
	ret	0
??$xr_alloc@Urecv@CLightProjector@@@@YAPAUrecv@CLightProjector@@I@Z ENDP ; xr_alloc<CLightProjector::recv>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Uninitialized_move@PAUrecv@CLightProjector@@V?$xalloc@Urecv@CLightProjector@@@@@std@@YAPAUrecv@CLightProjector@@QAU12@0PAU12@AAV?$xalloc@Urecv@CLightProjector@@@@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Al$dead$ = 12						; size = 4
??$_Uninitialized_move@PAUrecv@CLightProjector@@V?$xalloc@Urecv@CLightProjector@@@@@std@@YAPAUrecv@CLightProjector@@QAU12@0PAU12@AAV?$xalloc@Urecv@CLightProjector@@@@@Z PROC ; std::_Uninitialized_move<CLightProjector::recv *,xalloc<CLightProjector::recv> >, COMDAT
; __First$ = ecx
; __Last$ = edx

; 1699 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

	push	ebx
	mov	ebx, edx
	mov	eax, ecx

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	edx, DWORD PTR __Dest$[esp]

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	eax, ebx
	je	SHORT $LN20@Uninitiali
	push	esi
	push	edi
	npad	1
$LL4@Uninitiali:
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	esi, eax
	mov	edi, edx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1621 :         ++_Last;

	add	eax, 136				; 00000088H
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	ecx, 34					; 00000022H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1621 :         ++_Last;

	add	edx, 136				; 00000088H
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	rep movsd
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	eax, ebx
	jne	SHORT $LL4@Uninitiali

; 1718 :         _Backout._Emplace_back(_STD move(*_UFirst));
; 1719 :     }
; 1720 : 
; 1721 :     return _Backout._Release();

	pop	edi
	pop	esi
$LN20@Uninitiali:

; 1722 : }

	mov	eax, edx
	pop	ebx
	ret	0
??$_Uninitialized_move@PAUrecv@CLightProjector@@V?$xalloc@Urecv@CLightProjector@@@@@std@@YAPAUrecv@CLightProjector@@QAU12@0PAU12@AAV?$xalloc@Urecv@CLightProjector@@@@@Z ENDP ; std::_Uninitialized_move<CLightProjector::recv *,xalloc<CLightProjector::recv> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_Get_unwrapped@ABQAUrecv@CLightProjector@@@std@@YA?A_TABQAUrecv@CLightProjector@@@Z
_TEXT	SEGMENT
??$_Get_unwrapped@ABQAUrecv@CLightProjector@@@std@@YA?A_TABQAUrecv@CLightProjector@@@Z PROC ; std::_Get_unwrapped<CLightProjector::recv * const &>, COMDAT
; __It$ = ecx

; 1275 :     // unwrap an iterator previously subjected to _Adl_verify_range or otherwise validated
; 1276 :     if constexpr (is_pointer_v<decay_t<_Iter>>) { // special-case pointers and arrays
; 1277 :         return _It + 0;

	mov	eax, DWORD PTR [ecx]

; 1278 :     } else if constexpr (_Unwrappable_v<_Iter>) {
; 1279 :         return static_cast<_Iter&&>(_It)._Unwrapped();
; 1280 :     } else {
; 1281 :         return static_cast<_Iter&&>(_It);
; 1282 :     }
; 1283 : }

	ret	0
??$_Get_unwrapped@ABQAUrecv@CLightProjector@@@std@@YA?A_TABQAUrecv@CLightProjector@@@Z ENDP ; std::_Get_unwrapped<CLightProjector::recv * const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\type_traits
;	COMDAT ??$forward@PAVIRenderable@@@std@@YA$$QAPAVIRenderable@@AAPAV1@@Z
_TEXT	SEGMENT
??$forward@PAVIRenderable@@@std@@YA$$QAPAVIRenderable@@AAPAV1@@Z PROC ; std::forward<IRenderable *>, COMDAT
; __Arg$ = ecx

; 1386 :     return static_cast<_Ty&&>(_Arg);

	mov	eax, ecx

; 1387 : }

	ret	0
??$forward@PAVIRenderable@@@std@@YA$$QAPAVIRenderable@@AAPAV1@@Z ENDP ; std::forward<IRenderable *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$construct@PAVIRenderable@@PAV1@@?$_Normal_allocator_traits@V?$xalloc@PAVIRenderable@@@@@std@@SAXAAV?$xalloc@PAVIRenderable@@@@PAPAVIRenderable@@$$QAPAV3@@Z
_TEXT	SEGMENT
_<_Args_0>$ = 8						; size = 4
??$construct@PAVIRenderable@@PAV1@@?$_Normal_allocator_traits@V?$xalloc@PAVIRenderable@@@@@std@@SAXAAV?$xalloc@PAVIRenderable@@@@PAPAVIRenderable@@$$QAPAV3@@Z PROC ; std::_Normal_allocator_traits<xalloc<IRenderable *> >::construct<IRenderable *,IRenderable *>, COMDAT
; __Al$dead$ = ecx
; __Ptr$ = edx

; 565  :         if constexpr (_Uses_default_construct<_Alloc, _Ty*, _Types...>::value) {
; 566  :             (void) _Al; // TRANSITION, DevCom-1004719
; 567  : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 568  :             _STD construct_at(_Ptr, _STD forward<_Types>(_Args)...);
; 569  : #else // __cpp_lib_constexpr_dynamic_alloc
; 570  :             ::new (static_cast<void*>(_Ptr)) _Ty(_STD forward<_Types>(_Args)...);
; 571  : #endif // __cpp_lib_constexpr_dynamic_alloc
; 572  :         } else {
; 573  :             _Al.construct(_Ptr, _STD forward<_Types>(_Args)...);

	mov	eax, DWORD PTR _<_Args_0>$[esp-4]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edx], eax

; 574  :         }
; 575  :     }

	ret	0
??$construct@PAVIRenderable@@PAV1@@?$_Normal_allocator_traits@V?$xalloc@PAVIRenderable@@@@@std@@SAXAAV?$xalloc@PAVIRenderable@@@@PAPAVIRenderable@@$$QAPAV3@@Z ENDP ; std::_Normal_allocator_traits<xalloc<IRenderable *> >::construct<IRenderable *,IRenderable *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$construct@Urecv@CLightProjector@@$$V@?$_Normal_allocator_traits@V?$xalloc@Urecv@CLightProjector@@@@@std@@SAXAAV?$xalloc@Urecv@CLightProjector@@@@PAUrecv@CLightProjector@@@Z
_TEXT	SEGMENT
??$construct@Urecv@CLightProjector@@$$V@?$_Normal_allocator_traits@V?$xalloc@Urecv@CLightProjector@@@@@std@@SAXAAV?$xalloc@Urecv@CLightProjector@@@@PAUrecv@CLightProjector@@@Z PROC ; std::_Normal_allocator_traits<xalloc<CLightProjector::recv> >::construct<CLightProjector::recv>, COMDAT
; __Al$dead$ = ecx
; __Ptr$ = edx

; 565  :         if constexpr (_Uses_default_construct<_Alloc, _Ty*, _Types...>::value) {
; 566  :             (void) _Al; // TRANSITION, DevCom-1004719
; 567  : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 568  :             _STD construct_at(_Ptr, _STD forward<_Types>(_Args)...);
; 569  : #else // __cpp_lib_constexpr_dynamic_alloc
; 570  :             ::new (static_cast<void*>(_Ptr)) _Ty(_STD forward<_Types>(_Args)...);

	push	136					; 00000088H
	push	0
	push	edx
	call	_memset
	add	esp, 12					; 0000000cH

; 571  : #endif // __cpp_lib_constexpr_dynamic_alloc
; 572  :         } else {
; 573  :             _Al.construct(_Ptr, _STD forward<_Types>(_Args)...);
; 574  :         }
; 575  :     }

	ret	0
??$construct@Urecv@CLightProjector@@$$V@?$_Normal_allocator_traits@V?$xalloc@Urecv@CLightProjector@@@@@std@@SAXAAV?$xalloc@Urecv@CLightProjector@@@@PAUrecv@CLightProjector@@@Z ENDP ; std::_Normal_allocator_traits<xalloc<CLightProjector::recv> >::construct<CLightProjector::recv>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\type_traits
;	COMDAT ??$move@AAUrecv@CLightProjector@@@std@@YA$$QAUrecv@CLightProjector@@AAU12@@Z
_TEXT	SEGMENT
??$move@AAUrecv@CLightProjector@@@std@@YA$$QAUrecv@CLightProjector@@AAU12@@Z PROC ; std::move<CLightProjector::recv &>, COMDAT
; __Arg$ = ecx

; 1397 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

	mov	eax, ecx

; 1398 : }

	ret	0
??$move@AAUrecv@CLightProjector@@@std@@YA$$QAUrecv@CLightProjector@@AAU12@@Z ENDP ; std::move<CLightProjector::recv &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Emplace_back@Urecv@CLightProjector@@@?$_Uninitialized_backout_al@V?$xalloc@Urecv@CLightProjector@@@@@std@@QAEX$$QAUrecv@CLightProjector@@@Z
_TEXT	SEGMENT
_<_Vals_0>$ = 8						; size = 4
??$_Emplace_back@Urecv@CLightProjector@@@?$_Uninitialized_backout_al@V?$xalloc@Urecv@CLightProjector@@@@@std@@QAEX$$QAUrecv@CLightProjector@@@Z PROC ; std::_Uninitialized_backout_al<xalloc<CLightProjector::recv> >::_Emplace_back<CLightProjector::recv>, COMDAT
; _this$ = ecx

; 1619 :     _CONSTEXPR20_DYNALLOC void _Emplace_back(_Types&&... _Vals) { // construct a new element at *_Last and increment

	mov	eax, ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	ecx, 34					; 00000022H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1619 :     _CONSTEXPR20_DYNALLOC void _Emplace_back(_Types&&... _Vals) { // construct a new element at *_Last and increment

	push	esi
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	esi, DWORD PTR _<_Vals_0>$[esp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1619 :     _CONSTEXPR20_DYNALLOC void _Emplace_back(_Types&&... _Vals) { // construct a new element at *_Last and increment

	push	edi
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	edi, DWORD PTR [eax+4]
	rep movsd
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1621 :         ++_Last;

	add	DWORD PTR [eax+4], 136			; 00000088H
	pop	edi
	pop	esi

; 1622 :     }

	ret	4
??$_Emplace_back@Urecv@CLightProjector@@@?$_Uninitialized_backout_al@V?$xalloc@Urecv@CLightProjector@@@@@std@@QAEX$$QAUrecv@CLightProjector@@@Z ENDP ; std::_Uninitialized_backout_al<xalloc<CLightProjector::recv> >::_Emplace_back<CLightProjector::recv>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\type_traits
;	COMDAT ??$forward@Urecv@CLightProjector@@@std@@YA$$QAUrecv@CLightProjector@@AAU12@@Z
_TEXT	SEGMENT
??$forward@Urecv@CLightProjector@@@std@@YA$$QAUrecv@CLightProjector@@AAU12@@Z PROC ; std::forward<CLightProjector::recv>, COMDAT
; __Arg$ = ecx

; 1386 :     return static_cast<_Ty&&>(_Arg);

	mov	eax, ecx

; 1387 : }

	ret	0
??$forward@Urecv@CLightProjector@@@std@@YA$$QAUrecv@CLightProjector@@AAU12@@Z ENDP ; std::forward<CLightProjector::recv>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$construct@Urecv@CLightProjector@@U12@@?$_Normal_allocator_traits@V?$xalloc@Urecv@CLightProjector@@@@@std@@SAXAAV?$xalloc@Urecv@CLightProjector@@@@PAUrecv@CLightProjector@@$$QAU34@@Z
_TEXT	SEGMENT
_<_Args_0>$ = 8						; size = 4
??$construct@Urecv@CLightProjector@@U12@@?$_Normal_allocator_traits@V?$xalloc@Urecv@CLightProjector@@@@@std@@SAXAAV?$xalloc@Urecv@CLightProjector@@@@PAUrecv@CLightProjector@@$$QAU34@@Z PROC ; std::_Normal_allocator_traits<xalloc<CLightProjector::recv> >::construct<CLightProjector::recv,CLightProjector::recv>, COMDAT
; __Al$dead$ = ecx
; __Ptr$ = edx

; 564  :     static _CONSTEXPR20_DYNALLOC void construct(_Alloc& _Al, _Ty* _Ptr, _Types&&... _Args) {

	push	esi
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	esi, DWORD PTR _<_Args_0>$[esp]
	mov	ecx, 34					; 00000022H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 564  :     static _CONSTEXPR20_DYNALLOC void construct(_Alloc& _Al, _Ty* _Ptr, _Types&&... _Args) {

	push	edi
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	edi, edx
	rep movsd
	pop	edi
	pop	esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 575  :     }

	ret	0
??$construct@Urecv@CLightProjector@@U12@@?$_Normal_allocator_traits@V?$xalloc@Urecv@CLightProjector@@@@@std@@SAXAAV?$xalloc@Urecv@CLightProjector@@@@PAUrecv@CLightProjector@@$$QAU34@@Z ENDP ; std::_Normal_allocator_traits<xalloc<CLightProjector::recv> >::construct<CLightProjector::recv,CLightProjector::recv>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?construct@?$xalloc@Urecv@CLightProjector@@@@QAEXPAUrecv@CLightProjector@@ABU23@@Z
_TEXT	SEGMENT
_p$ = 8							; size = 4
__Val$ = 12						; size = 4
?construct@?$xalloc@Urecv@CLightProjector@@@@QAEXPAUrecv@CLightProjector@@ABU23@@Z PROC ; xalloc<CLightProjector::recv>::construct, COMDAT
; _this$dead$ = ecx

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	push	esi
	mov	esi, DWORD PTR __Val$[esp]
	mov	ecx, 34					; 00000022H
	push	edi
	mov	edi, DWORD PTR _p$[esp+4]
	rep movsd
	pop	edi
	pop	esi
	ret	8
?construct@?$xalloc@Urecv@CLightProjector@@@@QAEXPAUrecv@CLightProjector@@ABU23@@Z ENDP ; xalloc<CLightProjector::recv>::construct
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrEngine\r_constants_cache.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector4.h
; File I:\Vitalya\mine\NSProjectX\xrCore\FixedVector.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector4.h
; File I:\Vitalya\mine\NSProjectX\xrEngine\r_constants_cache.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector4.h
; File I:\Vitalya\mine\NSProjectX\xrEngine\r_constants_cache.h
;	COMDAT ?seta@R_constant_array@@QAEXPAUR_constant@@AAUR_constant_load@@IABU?$_vector4@M@@@Z
_TEXT	SEGMENT
_C$ = 8							; size = 4
_L$ = 12						; size = 4
_e$ = 16						; size = 4
_A$ = 20						; size = 4
?seta@R_constant_array@@QAEXPAUR_constant@@AAUR_constant_load@@IABU?$_vector4@M@@@Z PROC ; R_constant_array::seta, COMDAT
; _this$ = ecx

; 125  : 		VERIFY(RC_float == C->type);
; 126  : 		VERIFY(RC_1x4 == L.cls);
; 127  : 		u32			base = L.index + e;

	mov	eax, DWORD PTR _L$[esp-4]
	push	esi
	movzx	esi, WORD PTR [eax]
	add	esi, DWORD PTR _e$[esp]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector4.h

; 18   : 	IC	SelfRef		set(const Self& v)					{ x=v.x;	y=v.y;		z=v.z;		w=v.w;		return *this; }

	mov	eax, DWORD PTR _A$[esp]
; File I:\Vitalya\mine\NSProjectX\xrCore\FixedVector.h

; 38   : 	IC reference		operator[] (u32 id)			{ VERIFY(id<count); return array[id];	}

	mov	edx, esi
	shl	edx, 4
	add	edx, ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector4.h

; 18   : 	IC	SelfRef		set(const Self& v)					{ x=v.x;	y=v.y;		z=v.z;		w=v.w;		return *this; }

	fld	DWORD PTR [eax]
	fstp	DWORD PTR [edx]
	fld	DWORD PTR [eax+4]
	fstp	DWORD PTR [edx+4]
	fld	DWORD PTR [eax+8]
	fstp	DWORD PTR [edx+8]
	fld	DWORD PTR [eax+12]
; File I:\Vitalya\mine\NSProjectX\xrEngine\r_constants_cache.h

; 129  : 		c_f.dirty(base, base + 1);

	lea	eax, DWORD PTR [esi+1]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector4.h

; 18   : 	IC	SelfRef		set(const Self& v)					{ x=v.x;	y=v.y;		z=v.z;		w=v.w;		return *this; }

	fstp	DWORD PTR [edx+12]
; File I:\Vitalya\mine\NSProjectX\xrEngine\r_constants_cache.h

; 21   : 	ICF void				dirty(u32 _lo, u32 _hi) { if (_lo < lo) lo = _lo; if (_hi > hi) hi = _hi; }

	cmp	esi, DWORD PTR [ecx+4100]
	jae	SHORT $LN19@seta
	mov	DWORD PTR [ecx+4100], esi
$LN19@seta:
	pop	esi
	cmp	eax, DWORD PTR [ecx+4104]
	jbe	SHORT $LN20@seta
	mov	DWORD PTR [ecx+4104], eax
$LN20@seta:

; 130  : 	}

	ret	16					; 00000010H
?seta@R_constant_array@@QAEXPAUR_constant@@AAUR_constant_load@@IABU?$_vector4@M@@@Z ENDP ; R_constant_array::seta
_TEXT	ENDS
END
