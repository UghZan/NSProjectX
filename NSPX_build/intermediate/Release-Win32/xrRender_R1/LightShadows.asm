; Listing generated by Microsoft (R) Optimizing Compiler Version 19.29.30146.0 

	TITLE	i:\vitalya\mine\nsprojectx\nspx_build\intermediate\release-win32\xrrender_r1\lightshadows.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	??_C@_0N@MGAGAIMH@$user$shadow@			; `string'
PUBLIC	??_C@_0L@GLCIELMM@$user$temp@			; `string'
PUBLIC	??_C@_01IHBHIGKO@?0@				; `string'
PUBLIC	??_C@_0BF@CDILBIKA@effects?2shadow_world@	; `string'
PUBLIC	??_C@_05OHHNHFCG@blur4@				; `string'
PUBLIC	??_C@_0BD@KGPINAGD@effects?2screen_set@		; `string'
;	COMDAT ??_C@_0BD@KGPINAGD@effects?2screen_set@
CONST	SEGMENT
??_C@_0BD@KGPINAGD@effects?2screen_set@ DB 'effects\screen_set', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_05OHHNHFCG@blur4@
CONST	SEGMENT
??_C@_05OHHNHFCG@blur4@ DB 'blur4', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@CDILBIKA@effects?2shadow_world@
CONST	SEGMENT
??_C@_0BF@CDILBIKA@effects?2shadow_world@ DB 'effects\shadow_world', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_01IHBHIGKO@?0@
CONST	SEGMENT
??_C@_01IHBHIGKO@?0@ DB ',', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@GLCIELMM@$user$temp@
CONST	SEGMENT
??_C@_0L@GLCIELMM@$user$temp@ DB '$user$temp', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@MGAGAIMH@$user$shadow@
CONST	SEGMENT
??_C@_0N@MGAGAIMH@$user$shadow@ DB '$user$shadow', 00H	; `string'
?_Fake_alloc@std@@3U_Fake_allocator@1@B	ORG $+1		; std::_Fake_alloc
	ORG $+2
?S_ambient@@3HB DD 020H					; S_ambient
PUBLIC	??0cache_item@CLightShadows@@QAE@XZ		; CLightShadows::cache_item::cache_item
PUBLIC	??$_Emplace_back@Ucache_item@CLightShadows@@@?$_Uninitialized_backout_al@V?$xalloc@Ucache_item@CLightShadows@@@@@std@@QAEX$$QAUcache_item@CLightShadows@@@Z ; std::_Uninitialized_backout_al<xalloc<CLightShadows::cache_item> >::_Emplace_back<CLightShadows::cache_item>
PUBLIC	??$construct@U_MatrixItem@R_dsgraph@@U12@@?$_Normal_allocator_traits@V?$xalloc@U_MatrixItem@R_dsgraph@@@@@std@@SAXAAV?$xalloc@U_MatrixItem@R_dsgraph@@@@PAU_MatrixItem@R_dsgraph@@$$QAU34@@Z ; std::_Normal_allocator_traits<xalloc<R_dsgraph::_MatrixItem> >::construct<R_dsgraph::_MatrixItem,R_dsgraph::_MatrixItem>
PUBLIC	??$construct@PAUcaster@CLightShadows@@PAU12@@?$_Normal_allocator_traits@V?$xalloc@PAUcaster@CLightShadows@@@@@std@@SAXAAV?$xalloc@PAUcaster@CLightShadows@@@@PAPAUcaster@CLightShadows@@$$QAPAU34@@Z ; std::_Normal_allocator_traits<xalloc<CLightShadows::caster *> >::construct<CLightShadows::caster *,CLightShadows::caster *>
PUBLIC	??$forward@PAUcaster@CLightShadows@@@std@@YA$$QAPAUcaster@CLightShadows@@AAPAU12@@Z ; std::forward<CLightShadows::caster *>
PUBLIC	??0?$_Uninitialized_backout_al@V?$xalloc@Ucache_item@CLightShadows@@@@@std@@QAE@PAUcache_item@CLightShadows@@AAV?$xalloc@Ucache_item@CLightShadows@@@@@Z ; std::_Uninitialized_backout_al<xalloc<CLightShadows::cache_item> >::_Uninitialized_backout_al<xalloc<CLightShadows::cache_item> >
PUBLIC	??1?$_Uninitialized_backout_al@V?$xalloc@Ucache_item@CLightShadows@@@@@std@@QAE@XZ ; std::_Uninitialized_backout_al<xalloc<CLightShadows::cache_item> >::~_Uninitialized_backout_al<xalloc<CLightShadows::cache_item> >
PUBLIC	?_Release@?$_Uninitialized_backout_al@V?$xalloc@Ucache_item@CLightShadows@@@@@std@@QAEPAUcache_item@CLightShadows@@XZ ; std::_Uninitialized_backout_al<xalloc<CLightShadows::cache_item> >::_Release
PUBLIC	??$_Destroy_in_place@PAUshadow@CLightShadows@@@std@@YAXAAPAUshadow@CLightShadows@@@Z ; std::_Destroy_in_place<CLightShadows::shadow *>
PUBLIC	??$_Destroy_in_place@PAUtess_tri@CLightShadows@@@std@@YAXAAPAUtess_tri@CLightShadows@@@Z ; std::_Destroy_in_place<CLightShadows::tess_tri *>
PUBLIC	??$xr_alloc@Ucache_item@CLightShadows@@@@YAPAUcache_item@CLightShadows@@I@Z ; xr_alloc<CLightShadows::cache_item>
PUBLIC	??$_Get_unwrapped@ABQAUcache_item@CLightShadows@@@std@@YA?A_TABQAUcache_item@CLightShadows@@@Z ; std::_Get_unwrapped<CLightShadows::cache_item * const &>
PUBLIC	??$_Uninitialized_move@PAUcache_item@CLightShadows@@V?$xalloc@Ucache_item@CLightShadows@@@@@std@@YAPAUcache_item@CLightShadows@@QAU12@0PAU12@AAV?$xalloc@Ucache_item@CLightShadows@@@@@Z ; std::_Uninitialized_move<CLightShadows::cache_item *,xalloc<CLightShadows::cache_item> >
PUBLIC	??$_Refancy@PAUcache_item@CLightShadows@@$0A@@std@@YAPAUcache_item@CLightShadows@@PAU12@@Z ; std::_Refancy<CLightShadows::cache_item *,0>
PUBLIC	??$_Emplace_back@U_MatrixItem@R_dsgraph@@@?$_Uninitialized_backout_al@V?$xalloc@U_MatrixItem@R_dsgraph@@@@@std@@QAEX$$QAU_MatrixItem@R_dsgraph@@@Z ; std::_Uninitialized_backout_al<xalloc<R_dsgraph::_MatrixItem> >::_Emplace_back<R_dsgraph::_MatrixItem>
PUBLIC	??$_Emplace_back@PAUcaster@CLightShadows@@@?$_Uninitialized_backout_al@V?$xalloc@PAUcaster@CLightShadows@@@@@std@@QAEX$$QAPAUcaster@CLightShadows@@@Z ; std::_Uninitialized_backout_al<xalloc<CLightShadows::caster *> >::_Emplace_back<CLightShadows::caster *>
PUBLIC	??$move@AAPAUcaster@CLightShadows@@@std@@YA$$QAPAUcaster@CLightShadows@@AAPAU12@@Z ; std::move<CLightShadows::caster * &>
PUBLIC	??$_Emplace_back@Ushadow@CLightShadows@@@?$_Uninitialized_backout_al@V?$xalloc@Ushadow@CLightShadows@@@@@std@@QAEX$$QAUshadow@CLightShadows@@@Z ; std::_Uninitialized_backout_al<xalloc<CLightShadows::shadow> >::_Emplace_back<CLightShadows::shadow>
PUBLIC	??$_Emplace_back@Utess_tri@CLightShadows@@@?$_Uninitialized_backout_al@V?$xalloc@Utess_tri@CLightShadows@@@@@std@@QAEX$$QAUtess_tri@CLightShadows@@@Z ; std::_Uninitialized_backout_al<xalloc<CLightShadows::tess_tri> >::_Emplace_back<CLightShadows::tess_tri>
PUBLIC	??$_Copy_backward_memmove@PAUcache_item@CLightShadows@@PAU12@@std@@YAPAUcache_item@CLightShadows@@PAU12@00@Z ; std::_Copy_backward_memmove<CLightShadows::cache_item *,CLightShadows::cache_item *>
PUBLIC	??$forward@Ucache_item@CLightShadows@@@std@@YA$$QAUcache_item@CLightShadows@@AAU12@@Z ; std::forward<CLightShadows::cache_item>
PUBLIC	??$forward@AAPAUcache_item@CLightShadows@@@std@@YAAAPAUcache_item@CLightShadows@@AAPAU12@@Z ; std::forward<CLightShadows::cache_item * &>
PUBLIC	??$advance@PAUcache_item@CLightShadows@@H@std@@YAXAAPAUcache_item@CLightShadows@@H@Z ; std::advance<CLightShadows::cache_item *,int>
PUBLIC	?max_size@?$xalloc@Ucache_item@CLightShadows@@@@QBEIXZ ; xalloc<CLightShadows::cache_item>::max_size
PUBLIC	?_Get_first@?$_Compressed_pair@V?$xalloc@Ucache_item@CLightShadows@@@@V?$_Vector_val@U?$_Simple_types@Ucache_item@CLightShadows@@@std@@@std@@$00@std@@QBEABV?$xalloc@Ucache_item@CLightShadows@@@@XZ ; std::_Compressed_pair<xalloc<CLightShadows::cache_item>,std::_Vector_val<std::_Simple_types<CLightShadows::cache_item> >,1>::_Get_first
PUBLIC	?max_size@?$_Normal_allocator_traits@V?$xalloc@Ucache_item@CLightShadows@@@@@std@@SAIABV?$xalloc@Ucache_item@CLightShadows@@@@@Z ; std::_Normal_allocator_traits<xalloc<CLightShadows::cache_item> >::max_size
PUBLIC	?capacity@?$vector@Ucache_item@CLightShadows@@V?$xalloc@Ucache_item@CLightShadows@@@@@std@@QBEIXZ ; std::vector<CLightShadows::cache_item,xalloc<CLightShadows::cache_item> >::capacity
PUBLIC	?_Umove_if_noexcept1@?$vector@Ucache_item@CLightShadows@@V?$xalloc@Ucache_item@CLightShadows@@@@@std@@AAEXPAUcache_item@CLightShadows@@00U?$integral_constant@_N$00@2@@Z ; std::vector<CLightShadows::cache_item,xalloc<CLightShadows::cache_item> >::_Umove_if_noexcept1
PUBLIC	?_Getal@?$vector@Ucache_item@CLightShadows@@V?$xalloc@Ucache_item@CLightShadows@@@@@std@@ABEABV?$xalloc@Ucache_item@CLightShadows@@@@XZ ; std::vector<CLightShadows::cache_item,xalloc<CLightShadows::cache_item> >::_Getal
PUBLIC	??0?$_Vector_val@U?$_Simple_types@U_MatrixItem@R_dsgraph@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<R_dsgraph::_MatrixItem> >::_Vector_val<std::_Simple_types<R_dsgraph::_MatrixItem> >
PUBLIC	??0?$xalloc@U_MatrixItem@R_dsgraph@@@@QAE@XZ	; xalloc<R_dsgraph::_MatrixItem>::xalloc<R_dsgraph::_MatrixItem>
PUBLIC	?destroy@?$xalloc@U_MatrixItem@R_dsgraph@@@@QAEXPAU_MatrixItem@R_dsgraph@@@Z ; xalloc<R_dsgraph::_MatrixItem>::destroy
PUBLIC	?destroy@?$xalloc@Ushadow@CLightShadows@@@@QAEXPAUshadow@CLightShadows@@@Z ; xalloc<CLightShadows::shadow>::destroy
PUBLIC	?destroy@?$xalloc@Utess_tri@CLightShadows@@@@QAEXPAUtess_tri@CLightShadows@@@Z ; xalloc<CLightShadows::tess_tri>::destroy
PUBLIC	?allocate@?$xalloc@Ucache_item@CLightShadows@@@@QBEPAUcache_item@CLightShadows@@IPBX@Z ; xalloc<CLightShadows::cache_item>::allocate
PUBLIC	?construct@?$xalloc@Ucache_item@CLightShadows@@@@QAEXPAUcache_item@CLightShadows@@ABU23@@Z ; xalloc<CLightShadows::cache_item>::construct
PUBLIC	?max_size@?$vector@Ucache_item@CLightShadows@@V?$xalloc@Ucache_item@CLightShadows@@@@@std@@QBEIXZ ; std::vector<CLightShadows::cache_item,xalloc<CLightShadows::cache_item> >::max_size
PUBLIC	?_Umove@?$vector@Ucache_item@CLightShadows@@V?$xalloc@Ucache_item@CLightShadows@@@@@std@@AAEPAUcache_item@CLightShadows@@PAU34@00@Z ; std::vector<CLightShadows::cache_item,xalloc<CLightShadows::cache_item> >::_Umove
PUBLIC	?_Umove_if_noexcept@?$vector@Ucache_item@CLightShadows@@V?$xalloc@Ucache_item@CLightShadows@@@@@std@@AAEXPAUcache_item@CLightShadows@@00@Z ; std::vector<CLightShadows::cache_item,xalloc<CLightShadows::cache_item> >::_Umove_if_noexcept
PUBLIC	?_Calculate_growth@?$vector@Ucache_item@CLightShadows@@V?$xalloc@Ucache_item@CLightShadows@@@@@std@@ABEII@Z ; std::vector<CLightShadows::cache_item,xalloc<CLightShadows::cache_item> >::_Calculate_growth
PUBLIC	?_Change_array@?$vector@Ucache_item@CLightShadows@@V?$xalloc@Ucache_item@CLightShadows@@@@@std@@AAEXQAUcache_item@CLightShadows@@II@Z ; std::vector<CLightShadows::cache_item,xalloc<CLightShadows::cache_item> >::_Change_array
PUBLIC	?_Xlength@?$vector@Ucache_item@CLightShadows@@V?$xalloc@Ucache_item@CLightShadows@@@@@std@@CAXXZ ; std::vector<CLightShadows::cache_item,xalloc<CLightShadows::cache_item> >::_Xlength
PUBLIC	?_Seek_to@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@Ucache_item@CLightShadows@@@std@@@std@@@std@@QAEXPBUcache_item@CLightShadows@@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CLightShadows::cache_item> > >::_Seek_to
PUBLIC	??0?$_Uninitialized_backout_al@V?$xalloc@Utess_tri@CLightShadows@@@@@std@@QAE@PAUtess_tri@CLightShadows@@AAV?$xalloc@Utess_tri@CLightShadows@@@@@Z ; std::_Uninitialized_backout_al<xalloc<CLightShadows::tess_tri> >::_Uninitialized_backout_al<xalloc<CLightShadows::tess_tri> >
PUBLIC	??1?$_Uninitialized_backout_al@V?$xalloc@Utess_tri@CLightShadows@@@@@std@@QAE@XZ ; std::_Uninitialized_backout_al<xalloc<CLightShadows::tess_tri> >::~_Uninitialized_backout_al<xalloc<CLightShadows::tess_tri> >
PUBLIC	?_Release@?$_Uninitialized_backout_al@V?$xalloc@Utess_tri@CLightShadows@@@@@std@@QAEPAUtess_tri@CLightShadows@@XZ ; std::_Uninitialized_backout_al<xalloc<CLightShadows::tess_tri> >::_Release
PUBLIC	??0?$_Uninitialized_backout_al@V?$xalloc@Ushadow@CLightShadows@@@@@std@@QAE@PAUshadow@CLightShadows@@AAV?$xalloc@Ushadow@CLightShadows@@@@@Z ; std::_Uninitialized_backout_al<xalloc<CLightShadows::shadow> >::_Uninitialized_backout_al<xalloc<CLightShadows::shadow> >
PUBLIC	??1?$_Uninitialized_backout_al@V?$xalloc@Ushadow@CLightShadows@@@@@std@@QAE@XZ ; std::_Uninitialized_backout_al<xalloc<CLightShadows::shadow> >::~_Uninitialized_backout_al<xalloc<CLightShadows::shadow> >
PUBLIC	?_Release@?$_Uninitialized_backout_al@V?$xalloc@Ushadow@CLightShadows@@@@@std@@QAEPAUshadow@CLightShadows@@XZ ; std::_Uninitialized_backout_al<xalloc<CLightShadows::shadow> >::_Release
PUBLIC	??0?$_Uninitialized_backout_al@V?$xalloc@PAUcaster@CLightShadows@@@@@std@@QAE@PAPAUcaster@CLightShadows@@AAV?$xalloc@PAUcaster@CLightShadows@@@@@Z ; std::_Uninitialized_backout_al<xalloc<CLightShadows::caster *> >::_Uninitialized_backout_al<xalloc<CLightShadows::caster *> >
PUBLIC	??1?$_Uninitialized_backout_al@V?$xalloc@PAUcaster@CLightShadows@@@@@std@@QAE@XZ ; std::_Uninitialized_backout_al<xalloc<CLightShadows::caster *> >::~_Uninitialized_backout_al<xalloc<CLightShadows::caster *> >
PUBLIC	?_Release@?$_Uninitialized_backout_al@V?$xalloc@PAUcaster@CLightShadows@@@@@std@@QAEPAPAUcaster@CLightShadows@@XZ ; std::_Uninitialized_backout_al<xalloc<CLightShadows::caster *> >::_Release
PUBLIC	??0?$_Uninitialized_backout_al@V?$xalloc@U_MatrixItem@R_dsgraph@@@@@std@@QAE@PAU_MatrixItem@R_dsgraph@@AAV?$xalloc@U_MatrixItem@R_dsgraph@@@@@Z ; std::_Uninitialized_backout_al<xalloc<R_dsgraph::_MatrixItem> >::_Uninitialized_backout_al<xalloc<R_dsgraph::_MatrixItem> >
PUBLIC	??1?$_Uninitialized_backout_al@V?$xalloc@U_MatrixItem@R_dsgraph@@@@@std@@QAE@XZ ; std::_Uninitialized_backout_al<xalloc<R_dsgraph::_MatrixItem> >::~_Uninitialized_backout_al<xalloc<R_dsgraph::_MatrixItem> >
PUBLIC	?_Release@?$_Uninitialized_backout_al@V?$xalloc@U_MatrixItem@R_dsgraph@@@@@std@@QAEPAU_MatrixItem@R_dsgraph@@XZ ; std::_Uninitialized_backout_al<xalloc<R_dsgraph::_MatrixItem> >::_Release
PUBLIC	??$?0$$V@?$_Compressed_pair@V?$xalloc@U_MatrixItem@R_dsgraph@@@@V?$_Vector_val@U?$_Simple_types@U_MatrixItem@R_dsgraph@@@std@@@std@@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<xalloc<R_dsgraph::_MatrixItem>,std::_Vector_val<std::_Simple_types<R_dsgraph::_MatrixItem> >,1>::_Compressed_pair<xalloc<R_dsgraph::_MatrixItem>,std::_Vector_val<std::_Simple_types<R_dsgraph::_MatrixItem> >,1><>
PUBLIC	??$xr_alloc@U_MatrixItem@R_dsgraph@@@@YAPAU_MatrixItem@R_dsgraph@@I@Z ; xr_alloc<R_dsgraph::_MatrixItem>
PUBLIC	??$xr_free@U_MatrixItem@R_dsgraph@@@@YAXAAPAU_MatrixItem@R_dsgraph@@@Z ; xr_free<R_dsgraph::_MatrixItem>
PUBLIC	??$_Uninitialized_move@PAU_MatrixItem@R_dsgraph@@V?$xalloc@U_MatrixItem@R_dsgraph@@@@@std@@YAPAU_MatrixItem@R_dsgraph@@QAU12@0PAU12@AAV?$xalloc@U_MatrixItem@R_dsgraph@@@@@Z ; std::_Uninitialized_move<R_dsgraph::_MatrixItem *,xalloc<R_dsgraph::_MatrixItem> >
PUBLIC	??$xr_alloc@PAUcaster@CLightShadows@@@@YAPAPAUcaster@CLightShadows@@I@Z ; xr_alloc<CLightShadows::caster *>
PUBLIC	??$_Destroy_in_place@PAPAUcaster@CLightShadows@@@std@@YAXAAPAPAUcaster@CLightShadows@@@Z ; std::_Destroy_in_place<CLightShadows::caster * *>
PUBLIC	??$_Get_unwrapped@ABQAPAUcaster@CLightShadows@@@std@@YA?A_TABQAPAUcaster@CLightShadows@@@Z ; std::_Get_unwrapped<CLightShadows::caster * * const &>
PUBLIC	??$_Uninitialized_move@PAPAUcaster@CLightShadows@@V?$xalloc@PAUcaster@CLightShadows@@@@@std@@YAPAPAUcaster@CLightShadows@@QAPAU12@0PAPAU12@AAV?$xalloc@PAUcaster@CLightShadows@@@@@Z ; std::_Uninitialized_move<CLightShadows::caster * *,xalloc<CLightShadows::caster *> >
PUBLIC	??$xr_alloc@Ushadow@CLightShadows@@@@YAPAUshadow@CLightShadows@@I@Z ; xr_alloc<CLightShadows::shadow>
PUBLIC	??$_Get_unwrapped@ABQAUshadow@CLightShadows@@@std@@YA?A_TABQAUshadow@CLightShadows@@@Z ; std::_Get_unwrapped<CLightShadows::shadow * const &>
PUBLIC	??$_Uninitialized_move@PAUshadow@CLightShadows@@V?$xalloc@Ushadow@CLightShadows@@@@@std@@YAPAUshadow@CLightShadows@@QAU12@0PAU12@AAV?$xalloc@Ushadow@CLightShadows@@@@@Z ; std::_Uninitialized_move<CLightShadows::shadow *,xalloc<CLightShadows::shadow> >
PUBLIC	??$_Get_unwrapped@ABQAUtess_tri@CLightShadows@@@std@@YA?A_TABQAUtess_tri@CLightShadows@@@Z ; std::_Get_unwrapped<CLightShadows::tess_tri * const &>
PUBLIC	??$_Uninitialized_move@PAUtess_tri@CLightShadows@@V?$xalloc@Utess_tri@CLightShadows@@@@@std@@YAPAUtess_tri@CLightShadows@@QAU12@0PAU12@AAV?$xalloc@Utess_tri@CLightShadows@@@@@Z ; std::_Uninitialized_move<CLightShadows::tess_tri *,xalloc<CLightShadows::tess_tri> >
PUBLIC	??$_Destroy_in_place@PAUcache_item@CLightShadows@@@std@@YAXAAPAUcache_item@CLightShadows@@@Z ; std::_Destroy_in_place<CLightShadows::cache_item *>
PUBLIC	??$destroy@U_MatrixItem@R_dsgraph@@@?$_Normal_allocator_traits@V?$xalloc@U_MatrixItem@R_dsgraph@@@@@std@@SAXAAV?$xalloc@U_MatrixItem@R_dsgraph@@@@PAU_MatrixItem@R_dsgraph@@@Z ; std::_Normal_allocator_traits<xalloc<R_dsgraph::_MatrixItem> >::destroy<R_dsgraph::_MatrixItem>
PUBLIC	??$destroy@Ushadow@CLightShadows@@@?$_Normal_allocator_traits@V?$xalloc@Ushadow@CLightShadows@@@@@std@@SAXAAV?$xalloc@Ushadow@CLightShadows@@@@PAUshadow@CLightShadows@@@Z ; std::_Normal_allocator_traits<xalloc<CLightShadows::shadow> >::destroy<CLightShadows::shadow>
PUBLIC	??$destroy@Utess_tri@CLightShadows@@@?$_Normal_allocator_traits@V?$xalloc@Utess_tri@CLightShadows@@@@@std@@SAXAAV?$xalloc@Utess_tri@CLightShadows@@@@PAUtess_tri@CLightShadows@@@Z ; std::_Normal_allocator_traits<xalloc<CLightShadows::tess_tri> >::destroy<CLightShadows::tess_tri>
PUBLIC	??$_Emplace_reallocate@ABUcache_item@CLightShadows@@@?$vector@Ucache_item@CLightShadows@@V?$xalloc@Ucache_item@CLightShadows@@@@@std@@QAEPAUcache_item@CLightShadows@@QAU23@ABU23@@Z ; std::vector<CLightShadows::cache_item,xalloc<CLightShadows::cache_item> >::_Emplace_reallocate<CLightShadows::cache_item const &>
PUBLIC	??$_Move_backward_unchecked@PAUcache_item@CLightShadows@@PAU12@@std@@YAPAUcache_item@CLightShadows@@PAU12@00@Z ; std::_Move_backward_unchecked<CLightShadows::cache_item *,CLightShadows::cache_item *>
PUBLIC	??$construct@Ucache_item@CLightShadows@@U12@@?$_Normal_allocator_traits@V?$xalloc@Ucache_item@CLightShadows@@@@@std@@SAXAAV?$xalloc@Ucache_item@CLightShadows@@@@PAUcache_item@CLightShadows@@$$QAU34@@Z ; std::_Normal_allocator_traits<xalloc<CLightShadows::cache_item> >::construct<CLightShadows::cache_item,CLightShadows::cache_item>
PUBLIC	??$addressof@Ucache_item@CLightShadows@@@std@@YAPAUcache_item@CLightShadows@@AAU12@@Z ; std::addressof<CLightShadows::cache_item>
PUBLIC	??$?0ABUcache_item@CLightShadows@@@?$_Alloc_temporary2@V?$xalloc@Ucache_item@CLightShadows@@@@@std@@QAE@AAV?$xalloc@Ucache_item@CLightShadows@@@@ABUcache_item@CLightShadows@@@Z ; std::_Alloc_temporary2<xalloc<CLightShadows::cache_item> >::_Alloc_temporary2<xalloc<CLightShadows::cache_item> ><CLightShadows::cache_item const &>
PUBLIC	??$construct@Ucache_item@CLightShadows@@ABU12@@?$_Normal_allocator_traits@V?$xalloc@Ucache_item@CLightShadows@@@@@std@@SAXAAV?$xalloc@Ucache_item@CLightShadows@@@@PAUcache_item@CLightShadows@@ABU34@@Z ; std::_Normal_allocator_traits<xalloc<CLightShadows::cache_item> >::construct<CLightShadows::cache_item,CLightShadows::cache_item const &>
PUBLIC	??$forward@ABUcache_item@CLightShadows@@@std@@YAABUcache_item@CLightShadows@@ABU12@@Z ; std::forward<CLightShadows::cache_item const &>
PUBLIC	??$move@AAUcache_item@CLightShadows@@@std@@YA$$QAUcache_item@CLightShadows@@AAU12@@Z ; std::move<CLightShadows::cache_item &>
PUBLIC	??$_To_address@PAUcache_item@CLightShadows@@@std@@YA?A_PABQAUcache_item@CLightShadows@@@Z ; std::_To_address<CLightShadows::cache_item *>
PUBLIC	??$_Copy_memmove@PAUcache_item@CLightShadows@@PAU12@@std@@YAPAUcache_item@CLightShadows@@PAU12@00@Z ; std::_Copy_memmove<CLightShadows::cache_item *,CLightShadows::cache_item *>
PUBLIC	??$_Seek_wrapped@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@Ucache_item@CLightShadows@@@std@@@std@@@std@@AAPAUcache_item@CLightShadows@@@std@@YAXAAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@Ucache_item@CLightShadows@@@std@@@std@@@0@AAPAUcache_item@CLightShadows@@@Z ; std::_Seek_wrapped<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CLightShadows::cache_item> > >,CLightShadows::cache_item * &>
PUBLIC	??$_Next_iter@PAUcache_item@CLightShadows@@@std@@YAPAUcache_item@CLightShadows@@PAU12@@Z ; std::_Next_iter<CLightShadows::cache_item *>
PUBLIC	??$next@PAUcache_item@CLightShadows@@@std@@YAPAUcache_item@CLightShadows@@PAU12@H@Z ; std::next<CLightShadows::cache_item *>
PUBLIC	??$distance@PAUcache_item@CLightShadows@@@std@@YAHPAUcache_item@CLightShadows@@0@Z ; std::distance<CLightShadows::cache_item *>
PUBLIC	??$_Adl_verify_range@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@Ucache_item@CLightShadows@@@std@@@std@@@std@@V12@@std@@YAXABV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@Ucache_item@CLightShadows@@@std@@@std@@@0@0@Z ; std::_Adl_verify_range<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CLightShadows::cache_item> > >,std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CLightShadows::cache_item> > > >
PUBLIC	?max_size@?$xalloc@U_MatrixItem@R_dsgraph@@@@QBEIXZ ; xalloc<R_dsgraph::_MatrixItem>::max_size
PUBLIC	?_Get_first@?$_Compressed_pair@V?$xalloc@U_MatrixItem@R_dsgraph@@@@V?$_Vector_val@U?$_Simple_types@U_MatrixItem@R_dsgraph@@@std@@@std@@$00@std@@QBEABV?$xalloc@U_MatrixItem@R_dsgraph@@@@XZ ; std::_Compressed_pair<xalloc<R_dsgraph::_MatrixItem>,std::_Vector_val<std::_Simple_types<R_dsgraph::_MatrixItem> >,1>::_Get_first
PUBLIC	?max_size@?$xalloc@PAUcaster@CLightShadows@@@@QBEIXZ ; xalloc<CLightShadows::caster *>::max_size
PUBLIC	?_Get_first@?$_Compressed_pair@V?$xalloc@PAUcaster@CLightShadows@@@@V?$_Vector_val@U?$_Simple_types@PAUcaster@CLightShadows@@@std@@@std@@$00@std@@QBEABV?$xalloc@PAUcaster@CLightShadows@@@@XZ ; std::_Compressed_pair<xalloc<CLightShadows::caster *>,std::_Vector_val<std::_Simple_types<CLightShadows::caster *> >,1>::_Get_first
PUBLIC	?max_size@?$xalloc@Ushadow@CLightShadows@@@@QBEIXZ ; xalloc<CLightShadows::shadow>::max_size
PUBLIC	?_Get_first@?$_Compressed_pair@V?$xalloc@Ushadow@CLightShadows@@@@V?$_Vector_val@U?$_Simple_types@Ushadow@CLightShadows@@@std@@@std@@$00@std@@QBEABV?$xalloc@Ushadow@CLightShadows@@@@XZ ; std::_Compressed_pair<xalloc<CLightShadows::shadow>,std::_Vector_val<std::_Simple_types<CLightShadows::shadow> >,1>::_Get_first
PUBLIC	?max_size@?$xalloc@Utess_tri@CLightShadows@@@@QBEIXZ ; xalloc<CLightShadows::tess_tri>::max_size
PUBLIC	?_Get_first@?$_Compressed_pair@V?$xalloc@Utess_tri@CLightShadows@@@@V?$_Vector_val@U?$_Simple_types@Utess_tri@CLightShadows@@@std@@@std@@$00@std@@QBEABV?$xalloc@Utess_tri@CLightShadows@@@@XZ ; std::_Compressed_pair<xalloc<CLightShadows::tess_tri>,std::_Vector_val<std::_Simple_types<CLightShadows::tess_tri> >,1>::_Get_first
PUBLIC	?max_size@?$_Normal_allocator_traits@V?$xalloc@U_MatrixItem@R_dsgraph@@@@@std@@SAIABV?$xalloc@U_MatrixItem@R_dsgraph@@@@@Z ; std::_Normal_allocator_traits<xalloc<R_dsgraph::_MatrixItem> >::max_size
PUBLIC	??0?$vector@U_MatrixItem@R_dsgraph@@V?$xalloc@U_MatrixItem@R_dsgraph@@@@@std@@QAE@XZ ; std::vector<R_dsgraph::_MatrixItem,xalloc<R_dsgraph::_MatrixItem> >::vector<R_dsgraph::_MatrixItem,xalloc<R_dsgraph::_MatrixItem> >
PUBLIC	?capacity@?$vector@U_MatrixItem@R_dsgraph@@V?$xalloc@U_MatrixItem@R_dsgraph@@@@@std@@QBEIXZ ; std::vector<R_dsgraph::_MatrixItem,xalloc<R_dsgraph::_MatrixItem> >::capacity
PUBLIC	?_Umove_if_noexcept1@?$vector@U_MatrixItem@R_dsgraph@@V?$xalloc@U_MatrixItem@R_dsgraph@@@@@std@@AAEXPAU_MatrixItem@R_dsgraph@@00U?$integral_constant@_N$00@2@@Z ; std::vector<R_dsgraph::_MatrixItem,xalloc<R_dsgraph::_MatrixItem> >::_Umove_if_noexcept1
PUBLIC	?_Tidy@?$vector@U_MatrixItem@R_dsgraph@@V?$xalloc@U_MatrixItem@R_dsgraph@@@@@std@@AAEXXZ ; std::vector<R_dsgraph::_MatrixItem,xalloc<R_dsgraph::_MatrixItem> >::_Tidy
PUBLIC	?_Getal@?$vector@U_MatrixItem@R_dsgraph@@V?$xalloc@U_MatrixItem@R_dsgraph@@@@@std@@ABEABV?$xalloc@U_MatrixItem@R_dsgraph@@@@XZ ; std::vector<R_dsgraph::_MatrixItem,xalloc<R_dsgraph::_MatrixItem> >::_Getal
PUBLIC	?max_size@?$_Normal_allocator_traits@V?$xalloc@PAUcaster@CLightShadows@@@@@std@@SAIABV?$xalloc@PAUcaster@CLightShadows@@@@@Z ; std::_Normal_allocator_traits<xalloc<CLightShadows::caster *> >::max_size
PUBLIC	?capacity@?$vector@PAUcaster@CLightShadows@@V?$xalloc@PAUcaster@CLightShadows@@@@@std@@QBEIXZ ; std::vector<CLightShadows::caster *,xalloc<CLightShadows::caster *> >::capacity
PUBLIC	?_Umove_if_noexcept1@?$vector@PAUcaster@CLightShadows@@V?$xalloc@PAUcaster@CLightShadows@@@@@std@@AAEXPAPAUcaster@CLightShadows@@00U?$integral_constant@_N$00@2@@Z ; std::vector<CLightShadows::caster *,xalloc<CLightShadows::caster *> >::_Umove_if_noexcept1
PUBLIC	?_Getal@?$vector@PAUcaster@CLightShadows@@V?$xalloc@PAUcaster@CLightShadows@@@@@std@@ABEABV?$xalloc@PAUcaster@CLightShadows@@@@XZ ; std::vector<CLightShadows::caster *,xalloc<CLightShadows::caster *> >::_Getal
PUBLIC	?max_size@?$_Normal_allocator_traits@V?$xalloc@Ushadow@CLightShadows@@@@@std@@SAIABV?$xalloc@Ushadow@CLightShadows@@@@@Z ; std::_Normal_allocator_traits<xalloc<CLightShadows::shadow> >::max_size
PUBLIC	?capacity@?$vector@Ushadow@CLightShadows@@V?$xalloc@Ushadow@CLightShadows@@@@@std@@QBEIXZ ; std::vector<CLightShadows::shadow,xalloc<CLightShadows::shadow> >::capacity
PUBLIC	?_Umove_if_noexcept1@?$vector@Ushadow@CLightShadows@@V?$xalloc@Ushadow@CLightShadows@@@@@std@@AAEXPAUshadow@CLightShadows@@00U?$integral_constant@_N$00@2@@Z ; std::vector<CLightShadows::shadow,xalloc<CLightShadows::shadow> >::_Umove_if_noexcept1
PUBLIC	?_Getal@?$vector@Ushadow@CLightShadows@@V?$xalloc@Ushadow@CLightShadows@@@@@std@@ABEABV?$xalloc@Ushadow@CLightShadows@@@@XZ ; std::vector<CLightShadows::shadow,xalloc<CLightShadows::shadow> >::_Getal
PUBLIC	?max_size@?$_Normal_allocator_traits@V?$xalloc@Utess_tri@CLightShadows@@@@@std@@SAIABV?$xalloc@Utess_tri@CLightShadows@@@@@Z ; std::_Normal_allocator_traits<xalloc<CLightShadows::tess_tri> >::max_size
PUBLIC	?capacity@?$vector@Utess_tri@CLightShadows@@V?$xalloc@Utess_tri@CLightShadows@@@@@std@@QBEIXZ ; std::vector<CLightShadows::tess_tri,xalloc<CLightShadows::tess_tri> >::capacity
PUBLIC	?_Umove_if_noexcept1@?$vector@Utess_tri@CLightShadows@@V?$xalloc@Utess_tri@CLightShadows@@@@@std@@AAEXPAUtess_tri@CLightShadows@@00U?$integral_constant@_N$00@2@@Z ; std::vector<CLightShadows::tess_tri,xalloc<CLightShadows::tess_tri> >::_Umove_if_noexcept1
PUBLIC	?_Getal@?$vector@Utess_tri@CLightShadows@@V?$xalloc@Utess_tri@CLightShadows@@@@@std@@ABEABV?$xalloc@Utess_tri@CLightShadows@@@@XZ ; std::vector<CLightShadows::tess_tri,xalloc<CLightShadows::tess_tri> >::_Getal
PUBLIC	??1caster@CLightShadows@@QAE@XZ			; CLightShadows::caster::~caster
PUBLIC	??_Gcaster@CLightShadows@@QAEPAXI@Z		; CLightShadows::caster::`scalar deleting destructor'
PUBLIC	?allocate@?$xalloc@U_MatrixItem@R_dsgraph@@@@QBEPAU_MatrixItem@R_dsgraph@@IPBX@Z ; xalloc<R_dsgraph::_MatrixItem>::allocate
PUBLIC	?deallocate@?$xalloc@U_MatrixItem@R_dsgraph@@@@QBEXPAU_MatrixItem@R_dsgraph@@I@Z ; xalloc<R_dsgraph::_MatrixItem>::deallocate
PUBLIC	?construct@?$xalloc@U_MatrixItem@R_dsgraph@@@@QAEXPAU_MatrixItem@R_dsgraph@@ABU23@@Z ; xalloc<R_dsgraph::_MatrixItem>::construct
PUBLIC	??1?$vector@U_MatrixItem@R_dsgraph@@V?$xalloc@U_MatrixItem@R_dsgraph@@@@@std@@QAE@XZ ; std::vector<R_dsgraph::_MatrixItem,xalloc<R_dsgraph::_MatrixItem> >::~vector<R_dsgraph::_MatrixItem,xalloc<R_dsgraph::_MatrixItem> >
PUBLIC	?max_size@?$vector@U_MatrixItem@R_dsgraph@@V?$xalloc@U_MatrixItem@R_dsgraph@@@@@std@@QBEIXZ ; std::vector<R_dsgraph::_MatrixItem,xalloc<R_dsgraph::_MatrixItem> >::max_size
PUBLIC	?_Umove@?$vector@U_MatrixItem@R_dsgraph@@V?$xalloc@U_MatrixItem@R_dsgraph@@@@@std@@AAEPAU_MatrixItem@R_dsgraph@@PAU34@00@Z ; std::vector<R_dsgraph::_MatrixItem,xalloc<R_dsgraph::_MatrixItem> >::_Umove
PUBLIC	?_Umove_if_noexcept@?$vector@U_MatrixItem@R_dsgraph@@V?$xalloc@U_MatrixItem@R_dsgraph@@@@@std@@AAEXPAU_MatrixItem@R_dsgraph@@00@Z ; std::vector<R_dsgraph::_MatrixItem,xalloc<R_dsgraph::_MatrixItem> >::_Umove_if_noexcept
PUBLIC	?_Calculate_growth@?$vector@U_MatrixItem@R_dsgraph@@V?$xalloc@U_MatrixItem@R_dsgraph@@@@@std@@ABEII@Z ; std::vector<R_dsgraph::_MatrixItem,xalloc<R_dsgraph::_MatrixItem> >::_Calculate_growth
PUBLIC	?_Change_array@?$vector@U_MatrixItem@R_dsgraph@@V?$xalloc@U_MatrixItem@R_dsgraph@@@@@std@@AAEXQAU_MatrixItem@R_dsgraph@@II@Z ; std::vector<R_dsgraph::_MatrixItem,xalloc<R_dsgraph::_MatrixItem> >::_Change_array
PUBLIC	?_Xlength@?$vector@U_MatrixItem@R_dsgraph@@V?$xalloc@U_MatrixItem@R_dsgraph@@@@@std@@CAXXZ ; std::vector<R_dsgraph::_MatrixItem,xalloc<R_dsgraph::_MatrixItem> >::_Xlength
PUBLIC	??0?$xr_vector@U_MatrixItem@R_dsgraph@@V?$xalloc@U_MatrixItem@R_dsgraph@@@@@@QAE@XZ ; xr_vector<R_dsgraph::_MatrixItem,xalloc<R_dsgraph::_MatrixItem> >::xr_vector<R_dsgraph::_MatrixItem,xalloc<R_dsgraph::_MatrixItem> >
PUBLIC	??0?$xalloc@PAUcaster@CLightShadows@@@@QAE@XZ	; xalloc<CLightShadows::caster *>::xalloc<CLightShadows::caster *>
PUBLIC	?allocate@?$xalloc@PAUcaster@CLightShadows@@@@QBEPAPAUcaster@CLightShadows@@IPBX@Z ; xalloc<CLightShadows::caster *>::allocate
PUBLIC	?construct@?$xalloc@PAUcaster@CLightShadows@@@@QAEXPAPAUcaster@CLightShadows@@ABQAU23@@Z ; xalloc<CLightShadows::caster *>::construct
PUBLIC	?destroy@?$xalloc@PAUcaster@CLightShadows@@@@QAEXPAPAUcaster@CLightShadows@@@Z ; xalloc<CLightShadows::caster *>::destroy
PUBLIC	?max_size@?$vector@PAUcaster@CLightShadows@@V?$xalloc@PAUcaster@CLightShadows@@@@@std@@QBEIXZ ; std::vector<CLightShadows::caster *,xalloc<CLightShadows::caster *> >::max_size
PUBLIC	?_Umove@?$vector@PAUcaster@CLightShadows@@V?$xalloc@PAUcaster@CLightShadows@@@@@std@@AAEPAPAUcaster@CLightShadows@@PAPAU34@00@Z ; std::vector<CLightShadows::caster *,xalloc<CLightShadows::caster *> >::_Umove
PUBLIC	?_Umove_if_noexcept@?$vector@PAUcaster@CLightShadows@@V?$xalloc@PAUcaster@CLightShadows@@@@@std@@AAEXPAPAUcaster@CLightShadows@@00@Z ; std::vector<CLightShadows::caster *,xalloc<CLightShadows::caster *> >::_Umove_if_noexcept
PUBLIC	?_Calculate_growth@?$vector@PAUcaster@CLightShadows@@V?$xalloc@PAUcaster@CLightShadows@@@@@std@@ABEII@Z ; std::vector<CLightShadows::caster *,xalloc<CLightShadows::caster *> >::_Calculate_growth
PUBLIC	?_Change_array@?$vector@PAUcaster@CLightShadows@@V?$xalloc@PAUcaster@CLightShadows@@@@@std@@AAEXQAPAUcaster@CLightShadows@@II@Z ; std::vector<CLightShadows::caster *,xalloc<CLightShadows::caster *> >::_Change_array
PUBLIC	?_Xlength@?$vector@PAUcaster@CLightShadows@@V?$xalloc@PAUcaster@CLightShadows@@@@@std@@CAXXZ ; std::vector<CLightShadows::caster *,xalloc<CLightShadows::caster *> >::_Xlength
PUBLIC	??0?$_Vector_val@U?$_Simple_types@PAUcaster@CLightShadows@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<CLightShadows::caster *> >::_Vector_val<std::_Simple_types<CLightShadows::caster *> >
PUBLIC	??0?$xalloc@Ushadow@CLightShadows@@@@QAE@XZ	; xalloc<CLightShadows::shadow>::xalloc<CLightShadows::shadow>
PUBLIC	?allocate@?$xalloc@Ushadow@CLightShadows@@@@QBEPAUshadow@CLightShadows@@IPBX@Z ; xalloc<CLightShadows::shadow>::allocate
PUBLIC	?construct@?$xalloc@Ushadow@CLightShadows@@@@QAEXPAUshadow@CLightShadows@@ABU23@@Z ; xalloc<CLightShadows::shadow>::construct
PUBLIC	?max_size@?$vector@Ushadow@CLightShadows@@V?$xalloc@Ushadow@CLightShadows@@@@@std@@QBEIXZ ; std::vector<CLightShadows::shadow,xalloc<CLightShadows::shadow> >::max_size
PUBLIC	?_Umove@?$vector@Ushadow@CLightShadows@@V?$xalloc@Ushadow@CLightShadows@@@@@std@@AAEPAUshadow@CLightShadows@@PAU34@00@Z ; std::vector<CLightShadows::shadow,xalloc<CLightShadows::shadow> >::_Umove
PUBLIC	?_Umove_if_noexcept@?$vector@Ushadow@CLightShadows@@V?$xalloc@Ushadow@CLightShadows@@@@@std@@AAEXPAUshadow@CLightShadows@@00@Z ; std::vector<CLightShadows::shadow,xalloc<CLightShadows::shadow> >::_Umove_if_noexcept
PUBLIC	?_Calculate_growth@?$vector@Ushadow@CLightShadows@@V?$xalloc@Ushadow@CLightShadows@@@@@std@@ABEII@Z ; std::vector<CLightShadows::shadow,xalloc<CLightShadows::shadow> >::_Calculate_growth
PUBLIC	?_Change_array@?$vector@Ushadow@CLightShadows@@V?$xalloc@Ushadow@CLightShadows@@@@@std@@AAEXQAUshadow@CLightShadows@@II@Z ; std::vector<CLightShadows::shadow,xalloc<CLightShadows::shadow> >::_Change_array
PUBLIC	?_Xlength@?$vector@Ushadow@CLightShadows@@V?$xalloc@Ushadow@CLightShadows@@@@@std@@CAXXZ ; std::vector<CLightShadows::shadow,xalloc<CLightShadows::shadow> >::_Xlength
PUBLIC	??0?$_Vector_val@U?$_Simple_types@Ushadow@CLightShadows@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<CLightShadows::shadow> >::_Vector_val<std::_Simple_types<CLightShadows::shadow> >
PUBLIC	??0?$xalloc@Utess_tri@CLightShadows@@@@QAE@XZ	; xalloc<CLightShadows::tess_tri>::xalloc<CLightShadows::tess_tri>
PUBLIC	?allocate@?$xalloc@Utess_tri@CLightShadows@@@@QBEPAUtess_tri@CLightShadows@@IPBX@Z ; xalloc<CLightShadows::tess_tri>::allocate
PUBLIC	?construct@?$xalloc@Utess_tri@CLightShadows@@@@QAEXPAUtess_tri@CLightShadows@@ABU23@@Z ; xalloc<CLightShadows::tess_tri>::construct
PUBLIC	?max_size@?$vector@Utess_tri@CLightShadows@@V?$xalloc@Utess_tri@CLightShadows@@@@@std@@QBEIXZ ; std::vector<CLightShadows::tess_tri,xalloc<CLightShadows::tess_tri> >::max_size
PUBLIC	?_Umove@?$vector@Utess_tri@CLightShadows@@V?$xalloc@Utess_tri@CLightShadows@@@@@std@@AAEPAUtess_tri@CLightShadows@@PAU34@00@Z ; std::vector<CLightShadows::tess_tri,xalloc<CLightShadows::tess_tri> >::_Umove
PUBLIC	?_Umove_if_noexcept@?$vector@Utess_tri@CLightShadows@@V?$xalloc@Utess_tri@CLightShadows@@@@@std@@AAEXPAUtess_tri@CLightShadows@@00@Z ; std::vector<CLightShadows::tess_tri,xalloc<CLightShadows::tess_tri> >::_Umove_if_noexcept
PUBLIC	?_Calculate_growth@?$vector@Utess_tri@CLightShadows@@V?$xalloc@Utess_tri@CLightShadows@@@@@std@@ABEII@Z ; std::vector<CLightShadows::tess_tri,xalloc<CLightShadows::tess_tri> >::_Calculate_growth
PUBLIC	?_Change_array@?$vector@Utess_tri@CLightShadows@@V?$xalloc@Utess_tri@CLightShadows@@@@@std@@AAEXQAUtess_tri@CLightShadows@@II@Z ; std::vector<CLightShadows::tess_tri,xalloc<CLightShadows::tess_tri> >::_Change_array
PUBLIC	?_Xlength@?$vector@Utess_tri@CLightShadows@@V?$xalloc@Utess_tri@CLightShadows@@@@@std@@CAXXZ ; std::vector<CLightShadows::tess_tri,xalloc<CLightShadows::tess_tri> >::_Xlength
PUBLIC	??0?$_Vector_val@U?$_Simple_types@Utess_tri@CLightShadows@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<CLightShadows::tess_tri> >::_Vector_val<std::_Simple_types<CLightShadows::tess_tri> >
PUBLIC	??0?$xalloc@Ucache_item@CLightShadows@@@@QAE@XZ	; xalloc<CLightShadows::cache_item>::xalloc<CLightShadows::cache_item>
PUBLIC	?destroy@?$xalloc@Ucache_item@CLightShadows@@@@QAEXPAUcache_item@CLightShadows@@@Z ; xalloc<CLightShadows::cache_item>::destroy
PUBLIC	?_Make_iterator@?$vector@Ucache_item@CLightShadows@@V?$xalloc@Ucache_item@CLightShadows@@@@@std@@AAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@Ucache_item@CLightShadows@@@std@@@std@@@2@QAUcache_item@CLightShadows@@@Z ; std::vector<CLightShadows::cache_item,xalloc<CLightShadows::cache_item> >::_Make_iterator
PUBLIC	??0?$_Vector_val@U?$_Simple_types@Ucache_item@CLightShadows@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<CLightShadows::cache_item> >::_Vector_val<std::_Simple_types<CLightShadows::cache_item> >
PUBLIC	?_Unwrapped@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@Ucache_item@CLightShadows@@@std@@@std@@@std@@QBEPAUcache_item@CLightShadows@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CLightShadows::cache_item> > >::_Unwrapped
PUBLIC	??R?$xr_special_free@$0A@Ucaster@CLightShadows@@@@QAEXAAPAUcaster@CLightShadows@@@Z ; xr_special_free<0,CLightShadows::caster>::operator()
PUBLIC	?_Get_value@?$_Alloc_temporary2@V?$xalloc@Ucache_item@CLightShadows@@@@@std@@QAEAAUcache_item@CLightShadows@@XZ ; std::_Alloc_temporary2<xalloc<CLightShadows::cache_item> >::_Get_value
PUBLIC	??1?$_Alloc_temporary2@V?$xalloc@Ucache_item@CLightShadows@@@@@std@@QAE@XZ ; std::_Alloc_temporary2<xalloc<CLightShadows::cache_item> >::~_Alloc_temporary2<xalloc<CLightShadows::cache_item> >
PUBLIC	??1?$xr_vector@U_MatrixItem@R_dsgraph@@V?$xalloc@U_MatrixItem@R_dsgraph@@@@@@QAE@XZ ; xr_vector<R_dsgraph::_MatrixItem,xalloc<R_dsgraph::_MatrixItem> >::~xr_vector<R_dsgraph::_MatrixItem,xalloc<R_dsgraph::_MatrixItem> >
PUBLIC	??0caster@CLightShadows@@QAE@XZ			; CLightShadows::caster::caster
PUBLIC	??$_Destroy_range@V?$xalloc@U_MatrixItem@R_dsgraph@@@@@std@@YAXPAU_MatrixItem@R_dsgraph@@QAU12@AAV?$xalloc@U_MatrixItem@R_dsgraph@@@@@Z ; std::_Destroy_range<xalloc<R_dsgraph::_MatrixItem> >
PUBLIC	??$xr_free@PAUcaster@CLightShadows@@@@YAXAAPAPAUcaster@CLightShadows@@@Z ; xr_free<CLightShadows::caster *>
PUBLIC	??$_Destroy_range@V?$xalloc@PAUcaster@CLightShadows@@@@@std@@YAXPAPAUcaster@CLightShadows@@QAPAU12@AAV?$xalloc@PAUcaster@CLightShadows@@@@@Z ; std::_Destroy_range<xalloc<CLightShadows::caster *> >
PUBLIC	??$xr_free@Ushadow@CLightShadows@@@@YAXAAPAUshadow@CLightShadows@@@Z ; xr_free<CLightShadows::shadow>
PUBLIC	??$_Destroy_range@V?$xalloc@Ushadow@CLightShadows@@@@@std@@YAXPAUshadow@CLightShadows@@QAU12@AAV?$xalloc@Ushadow@CLightShadows@@@@@Z ; std::_Destroy_range<xalloc<CLightShadows::shadow> >
PUBLIC	??$_Destroy_range@V?$xalloc@Utess_tri@CLightShadows@@@@@std@@YAXPAUtess_tri@CLightShadows@@QAU12@AAV?$xalloc@Utess_tri@CLightShadows@@@@@Z ; std::_Destroy_range<xalloc<CLightShadows::tess_tri> >
PUBLIC	??$xr_free@Ucache_item@CLightShadows@@@@YAXAAPAUcache_item@CLightShadows@@@Z ; xr_free<CLightShadows::cache_item>
PUBLIC	??$_Destroy_range@V?$xalloc@Ucache_item@CLightShadows@@@@@std@@YAXPAUcache_item@CLightShadows@@QAU12@AAV?$xalloc@Ucache_item@CLightShadows@@@@@Z ; std::_Destroy_range<xalloc<CLightShadows::cache_item> >
PUBLIC	??$?0$$V@?$_Compressed_pair@V?$xalloc@PAUcaster@CLightShadows@@@@V?$_Vector_val@U?$_Simple_types@PAUcaster@CLightShadows@@@std@@@std@@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<xalloc<CLightShadows::caster *>,std::_Vector_val<std::_Simple_types<CLightShadows::caster *> >,1>::_Compressed_pair<xalloc<CLightShadows::caster *>,std::_Vector_val<std::_Simple_types<CLightShadows::caster *> >,1><>
PUBLIC	??$addressof@V?$_Vector_val@U?$_Simple_types@PAUcaster@CLightShadows@@@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@PAUcaster@CLightShadows@@@std@@@0@AAV10@@Z ; std::addressof<std::_Vector_val<std::_Simple_types<CLightShadows::caster *> > >
PUBLIC	??$?0$$V@?$_Compressed_pair@V?$xalloc@Ushadow@CLightShadows@@@@V?$_Vector_val@U?$_Simple_types@Ushadow@CLightShadows@@@std@@@std@@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<xalloc<CLightShadows::shadow>,std::_Vector_val<std::_Simple_types<CLightShadows::shadow> >,1>::_Compressed_pair<xalloc<CLightShadows::shadow>,std::_Vector_val<std::_Simple_types<CLightShadows::shadow> >,1><>
PUBLIC	??$addressof@V?$_Vector_val@U?$_Simple_types@Ushadow@CLightShadows@@@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@Ushadow@CLightShadows@@@std@@@0@AAV10@@Z ; std::addressof<std::_Vector_val<std::_Simple_types<CLightShadows::shadow> > >
PUBLIC	??$?0$$V@?$_Compressed_pair@V?$xalloc@Utess_tri@CLightShadows@@@@V?$_Vector_val@U?$_Simple_types@Utess_tri@CLightShadows@@@std@@@std@@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<xalloc<CLightShadows::tess_tri>,std::_Vector_val<std::_Simple_types<CLightShadows::tess_tri> >,1>::_Compressed_pair<xalloc<CLightShadows::tess_tri>,std::_Vector_val<std::_Simple_types<CLightShadows::tess_tri> >,1><>
PUBLIC	??$?0$$V@?$_Compressed_pair@V?$xalloc@Ucache_item@CLightShadows@@@@V?$_Vector_val@U?$_Simple_types@Ucache_item@CLightShadows@@@std@@@std@@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<xalloc<CLightShadows::cache_item>,std::_Vector_val<std::_Simple_types<CLightShadows::cache_item> >,1>::_Compressed_pair<xalloc<CLightShadows::cache_item>,std::_Vector_val<std::_Simple_types<CLightShadows::cache_item> >,1><>
PUBLIC	??$_Emplace_reallocate@ABU_MatrixItem@R_dsgraph@@@?$vector@U_MatrixItem@R_dsgraph@@V?$xalloc@U_MatrixItem@R_dsgraph@@@@@std@@QAEPAU_MatrixItem@R_dsgraph@@QAU23@ABU23@@Z ; std::vector<R_dsgraph::_MatrixItem,xalloc<R_dsgraph::_MatrixItem> >::_Emplace_reallocate<R_dsgraph::_MatrixItem const &>
PUBLIC	??$construct@U_MatrixItem@R_dsgraph@@ABU12@@?$_Normal_allocator_traits@V?$xalloc@U_MatrixItem@R_dsgraph@@@@@std@@SAXAAV?$xalloc@U_MatrixItem@R_dsgraph@@@@PAU_MatrixItem@R_dsgraph@@ABU34@@Z ; std::_Normal_allocator_traits<xalloc<R_dsgraph::_MatrixItem> >::construct<R_dsgraph::_MatrixItem,R_dsgraph::_MatrixItem const &>
PUBLIC	??$_Emplace_reallocate@ABQAUcaster@CLightShadows@@@?$vector@PAUcaster@CLightShadows@@V?$xalloc@PAUcaster@CLightShadows@@@@@std@@QAEPAPAUcaster@CLightShadows@@QAPAU23@ABQAU23@@Z ; std::vector<CLightShadows::caster *,xalloc<CLightShadows::caster *> >::_Emplace_reallocate<CLightShadows::caster * const &>
PUBLIC	??$construct@PAUcaster@CLightShadows@@ABQAU12@@?$_Normal_allocator_traits@V?$xalloc@PAUcaster@CLightShadows@@@@@std@@SAXAAV?$xalloc@PAUcaster@CLightShadows@@@@PAPAUcaster@CLightShadows@@ABQAU34@@Z ; std::_Normal_allocator_traits<xalloc<CLightShadows::caster *> >::construct<CLightShadows::caster *,CLightShadows::caster * const &>
PUBLIC	??$forward@ABQAUcaster@CLightShadows@@@std@@YAABQAUcaster@CLightShadows@@ABQAU12@@Z ; std::forward<CLightShadows::caster * const &>
PUBLIC	??$destroy@PAUcaster@CLightShadows@@@?$_Normal_allocator_traits@V?$xalloc@PAUcaster@CLightShadows@@@@@std@@SAXAAV?$xalloc@PAUcaster@CLightShadows@@@@PAPAUcaster@CLightShadows@@@Z ; std::_Normal_allocator_traits<xalloc<CLightShadows::caster *> >::destroy<CLightShadows::caster *>
PUBLIC	??$_Unfancy@PAUcaster@CLightShadows@@@std@@YAPAPAUcaster@CLightShadows@@PAPAU12@@Z ; std::_Unfancy<CLightShadows::caster *>
PUBLIC	??$_Emplace_reallocate@Ushadow@CLightShadows@@@?$vector@Ushadow@CLightShadows@@V?$xalloc@Ushadow@CLightShadows@@@@@std@@QAEPAUshadow@CLightShadows@@QAU23@$$QAU23@@Z ; std::vector<CLightShadows::shadow,xalloc<CLightShadows::shadow> >::_Emplace_reallocate<CLightShadows::shadow>
PUBLIC	??$construct@Ushadow@CLightShadows@@U12@@?$_Normal_allocator_traits@V?$xalloc@Ushadow@CLightShadows@@@@@std@@SAXAAV?$xalloc@Ushadow@CLightShadows@@@@PAUshadow@CLightShadows@@$$QAU34@@Z ; std::_Normal_allocator_traits<xalloc<CLightShadows::shadow> >::construct<CLightShadows::shadow,CLightShadows::shadow>
PUBLIC	??$_Unfancy@Ushadow@CLightShadows@@@std@@YAPAUshadow@CLightShadows@@PAU12@@Z ; std::_Unfancy<CLightShadows::shadow>
PUBLIC	??$forward@Ushadow@CLightShadows@@@std@@YA$$QAUshadow@CLightShadows@@AAU12@@Z ; std::forward<CLightShadows::shadow>
PUBLIC	??$move@AAUshadow@CLightShadows@@@std@@YA$$QAUshadow@CLightShadows@@AAU12@@Z ; std::move<CLightShadows::shadow &>
PUBLIC	??$_Emplace_reallocate@Utess_tri@CLightShadows@@@?$vector@Utess_tri@CLightShadows@@V?$xalloc@Utess_tri@CLightShadows@@@@@std@@QAEPAUtess_tri@CLightShadows@@QAU23@$$QAU23@@Z ; std::vector<CLightShadows::tess_tri,xalloc<CLightShadows::tess_tri> >::_Emplace_reallocate<CLightShadows::tess_tri>
PUBLIC	??$construct@Utess_tri@CLightShadows@@U12@@?$_Normal_allocator_traits@V?$xalloc@Utess_tri@CLightShadows@@@@@std@@SAXAAV?$xalloc@Utess_tri@CLightShadows@@@@PAUtess_tri@CLightShadows@@$$QAU34@@Z ; std::_Normal_allocator_traits<xalloc<CLightShadows::tess_tri> >::construct<CLightShadows::tess_tri,CLightShadows::tess_tri>
PUBLIC	??$_Unfancy@Utess_tri@CLightShadows@@@std@@YAPAUtess_tri@CLightShadows@@PAU12@@Z ; std::_Unfancy<CLightShadows::tess_tri>
PUBLIC	??$forward@Utess_tri@CLightShadows@@@std@@YA$$QAUtess_tri@CLightShadows@@AAU12@@Z ; std::forward<CLightShadows::tess_tri>
PUBLIC	??$move@AAUtess_tri@CLightShadows@@@std@@YA$$QAUtess_tri@CLightShadows@@AAU12@@Z ; std::move<CLightShadows::tess_tri &>
PUBLIC	??$addressof@V?$_Vector_val@U?$_Simple_types@Utess_tri@CLightShadows@@@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@Utess_tri@CLightShadows@@@std@@@0@AAV10@@Z ; std::addressof<std::_Vector_val<std::_Simple_types<CLightShadows::tess_tri> > >
PUBLIC	??$_Emplace_back_with_unused_capacity@ABUcache_item@CLightShadows@@@?$vector@Ucache_item@CLightShadows@@V?$xalloc@Ucache_item@CLightShadows@@@@@std@@AAE?A_TABUcache_item@CLightShadows@@@Z ; std::vector<CLightShadows::cache_item,xalloc<CLightShadows::cache_item> >::_Emplace_back_with_unused_capacity<CLightShadows::cache_item const &>
PUBLIC	??$emplace@ABUcache_item@CLightShadows@@@?$vector@Ucache_item@CLightShadows@@V?$xalloc@Ucache_item@CLightShadows@@@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@Ucache_item@CLightShadows@@@std@@@std@@@1@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@Ucache_item@CLightShadows@@@std@@@std@@@1@ABUcache_item@CLightShadows@@@Z ; std::vector<CLightShadows::cache_item,xalloc<CLightShadows::cache_item> >::emplace<CLightShadows::cache_item const &>
PUBLIC	??$destroy@Ucache_item@CLightShadows@@@?$_Normal_allocator_traits@V?$xalloc@Ucache_item@CLightShadows@@@@@std@@SAXAAV?$xalloc@Ucache_item@CLightShadows@@@@PAUcache_item@CLightShadows@@@Z ; std::_Normal_allocator_traits<xalloc<CLightShadows::cache_item> >::destroy<CLightShadows::cache_item>
PUBLIC	??$_Unfancy@Ucache_item@CLightShadows@@@std@@YAPAUcache_item@CLightShadows@@PAU12@@Z ; std::_Unfancy<CLightShadows::cache_item>
PUBLIC	??$_Move_unchecked@PAUcache_item@CLightShadows@@PAU12@@std@@YAPAUcache_item@CLightShadows@@PAU12@00@Z ; std::_Move_unchecked<CLightShadows::cache_item *,CLightShadows::cache_item *>
PUBLIC	??$addressof@V?$_Vector_val@U?$_Simple_types@Ucache_item@CLightShadows@@@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@Ucache_item@CLightShadows@@@std@@@0@AAV10@@Z ; std::addressof<std::_Vector_val<std::_Simple_types<CLightShadows::cache_item> > >
PUBLIC	??$xr_alloc@Utess_tri@CLightShadows@@@@YAPAUtess_tri@CLightShadows@@I@Z ; xr_alloc<CLightShadows::tess_tri>
PUBLIC	??$_Get_unwrapped@ABV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@Ucache_item@CLightShadows@@@std@@@std@@@std@@@std@@YA?A_TABV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@Ucache_item@CLightShadows@@@std@@@std@@@0@@Z ; std::_Get_unwrapped<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CLightShadows::cache_item> > > const &>
PUBLIC	??$_Get_unwrapped@AAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@Ucache_item@CLightShadows@@@std@@@std@@@std@@@std@@YA?A_TAAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@Ucache_item@CLightShadows@@@std@@@std@@@0@@Z ; std::_Get_unwrapped<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CLightShadows::cache_item> > > &>
PUBLIC	??$lower_bound@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@Ucache_item@CLightShadows@@@std@@@std@@@std@@Ucache_item@CLightShadows@@P6A_NABU34@0@Z@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@Ucache_item@CLightShadows@@@std@@@std@@@0@V10@V10@ABUcache_item@CLightShadows@@P6A_N22@Z@Z ; std::lower_bound<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CLightShadows::cache_item> > >,CLightShadows::cache_item,bool (__cdecl*)(CLightShadows::cache_item const &,CLightShadows::cache_item const &)>
PUBLIC	??$xr_new@Ucaster@CLightShadows@@@@YAPAUcaster@CLightShadows@@XZ ; xr_new<CLightShadows::caster>
PUBLIC	??$xr_free@Utess_tri@CLightShadows@@@@YAXAAPAUtess_tri@CLightShadows@@@Z ; xr_free<CLightShadows::tess_tri>
PUBLIC	??$xr_delete@Ucaster@CLightShadows@@@@YAXAAPAUcaster@CLightShadows@@@Z ; xr_delete<CLightShadows::caster>
PUBLIC	?_Verify_offset@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@Ushadow@CLightShadows@@@std@@@std@@@std@@QBEXH@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CLightShadows::shadow> > >::_Verify_offset
PUBLIC	?_Verify_offset@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUcaster@CLightShadows@@@std@@@std@@@std@@QBEXH@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CLightShadows::caster *> > >::_Verify_offset
PUBLIC	?_Verify_offset@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U_MatrixItem@R_dsgraph@@@std@@@std@@@std@@QBEXH@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<R_dsgraph::_MatrixItem> > >::_Verify_offset
PUBLIC	?_Destroy@?$vector@U_MatrixItem@R_dsgraph@@V?$xalloc@U_MatrixItem@R_dsgraph@@@@@std@@AAEXPAU_MatrixItem@R_dsgraph@@0@Z ; std::vector<R_dsgraph::_MatrixItem,xalloc<R_dsgraph::_MatrixItem> >::_Destroy
PUBLIC	?_Verify_offset@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@Ucache_item@CLightShadows@@@std@@@std@@@std@@QBEXH@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CLightShadows::cache_item> > >::_Verify_offset
PUBLIC	??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@Ushadow@CLightShadows@@@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CLightShadows::shadow> > >::operator+=
PUBLIC	??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUcaster@CLightShadows@@@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CLightShadows::caster *> > >::operator+=
PUBLIC	??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U_MatrixItem@R_dsgraph@@@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<R_dsgraph::_MatrixItem> > >::operator+=
PUBLIC	?clear@?$vector@U_MatrixItem@R_dsgraph@@V?$xalloc@U_MatrixItem@R_dsgraph@@@@@std@@QAEXXZ ; std::vector<R_dsgraph::_MatrixItem,xalloc<R_dsgraph::_MatrixItem> >::clear
PUBLIC	?_Get_first@?$_Compressed_pair@V?$xalloc@U_MatrixItem@R_dsgraph@@@@V?$_Vector_val@U?$_Simple_types@U_MatrixItem@R_dsgraph@@@std@@@std@@$00@std@@QAEAAV?$xalloc@U_MatrixItem@R_dsgraph@@@@XZ ; std::_Compressed_pair<xalloc<R_dsgraph::_MatrixItem>,std::_Vector_val<std::_Simple_types<R_dsgraph::_MatrixItem> >,1>::_Get_first
PUBLIC	?deallocate@?$xalloc@PAUcaster@CLightShadows@@@@QBEXPAPAUcaster@CLightShadows@@I@Z ; xalloc<CLightShadows::caster *>::deallocate
PUBLIC	?clear@?$vector@PAUcaster@CLightShadows@@V?$xalloc@PAUcaster@CLightShadows@@@@@std@@QAEXXZ ; std::vector<CLightShadows::caster *,xalloc<CLightShadows::caster *> >::clear
PUBLIC	?_Destroy@?$vector@PAUcaster@CLightShadows@@V?$xalloc@PAUcaster@CLightShadows@@@@@std@@AAEXPAPAUcaster@CLightShadows@@0@Z ; std::vector<CLightShadows::caster *,xalloc<CLightShadows::caster *> >::_Destroy
PUBLIC	?_Get_first@?$_Compressed_pair@V?$xalloc@PAUcaster@CLightShadows@@@@V?$_Vector_val@U?$_Simple_types@PAUcaster@CLightShadows@@@std@@@std@@$00@std@@QAEAAV?$xalloc@PAUcaster@CLightShadows@@@@XZ ; std::_Compressed_pair<xalloc<CLightShadows::caster *>,std::_Vector_val<std::_Simple_types<CLightShadows::caster *> >,1>::_Get_first
PUBLIC	?deallocate@?$xalloc@Ushadow@CLightShadows@@@@QBEXPAUshadow@CLightShadows@@I@Z ; xalloc<CLightShadows::shadow>::deallocate
PUBLIC	?clear@?$vector@Ushadow@CLightShadows@@V?$xalloc@Ushadow@CLightShadows@@@@@std@@QAEXXZ ; std::vector<CLightShadows::shadow,xalloc<CLightShadows::shadow> >::clear
PUBLIC	?_Destroy@?$vector@Ushadow@CLightShadows@@V?$xalloc@Ushadow@CLightShadows@@@@@std@@AAEXPAUshadow@CLightShadows@@0@Z ; std::vector<CLightShadows::shadow,xalloc<CLightShadows::shadow> >::_Destroy
PUBLIC	?_Get_first@?$_Compressed_pair@V?$xalloc@Ushadow@CLightShadows@@@@V?$_Vector_val@U?$_Simple_types@Ushadow@CLightShadows@@@std@@@std@@$00@std@@QAEAAV?$xalloc@Ushadow@CLightShadows@@@@XZ ; std::_Compressed_pair<xalloc<CLightShadows::shadow>,std::_Vector_val<std::_Simple_types<CLightShadows::shadow> >,1>::_Get_first
PUBLIC	?deallocate@?$xalloc@Utess_tri@CLightShadows@@@@QBEXPAUtess_tri@CLightShadows@@I@Z ; xalloc<CLightShadows::tess_tri>::deallocate
PUBLIC	?clear@?$vector@Utess_tri@CLightShadows@@V?$xalloc@Utess_tri@CLightShadows@@@@@std@@QAEXXZ ; std::vector<CLightShadows::tess_tri,xalloc<CLightShadows::tess_tri> >::clear
PUBLIC	?_Destroy@?$vector@Utess_tri@CLightShadows@@V?$xalloc@Utess_tri@CLightShadows@@@@@std@@AAEXPAUtess_tri@CLightShadows@@0@Z ; std::vector<CLightShadows::tess_tri,xalloc<CLightShadows::tess_tri> >::_Destroy
PUBLIC	?_Get_first@?$_Compressed_pair@V?$xalloc@Utess_tri@CLightShadows@@@@V?$_Vector_val@U?$_Simple_types@Utess_tri@CLightShadows@@@std@@@std@@$00@std@@QAEAAV?$xalloc@Utess_tri@CLightShadows@@@@XZ ; std::_Compressed_pair<xalloc<CLightShadows::tess_tri>,std::_Vector_val<std::_Simple_types<CLightShadows::tess_tri> >,1>::_Get_first
PUBLIC	?deallocate@?$xalloc@Ucache_item@CLightShadows@@@@QBEXPAUcache_item@CLightShadows@@I@Z ; xalloc<CLightShadows::cache_item>::deallocate
PUBLIC	?clear@?$vector@Ucache_item@CLightShadows@@V?$xalloc@Ucache_item@CLightShadows@@@@@std@@QAEXXZ ; std::vector<CLightShadows::cache_item,xalloc<CLightShadows::cache_item> >::clear
PUBLIC	?_Destroy@?$vector@Ucache_item@CLightShadows@@V?$xalloc@Ucache_item@CLightShadows@@@@@std@@AAEXPAUcache_item@CLightShadows@@0@Z ; std::vector<CLightShadows::cache_item,xalloc<CLightShadows::cache_item> >::_Destroy
PUBLIC	?_Get_first@?$_Compressed_pair@V?$xalloc@Ucache_item@CLightShadows@@@@V?$_Vector_val@U?$_Simple_types@Ucache_item@CLightShadows@@@std@@@std@@$00@std@@QAEAAV?$xalloc@Ucache_item@CLightShadows@@@@XZ ; std::_Compressed_pair<xalloc<CLightShadows::cache_item>,std::_Vector_val<std::_Simple_types<CLightShadows::cache_item> >,1>::_Get_first
PUBLIC	??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@Ucache_item@CLightShadows@@@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CLightShadows::cache_item> > >::operator+=
PUBLIC	??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@Ushadow@CLightShadows@@@std@@@std@@@std@@QAE@PAUshadow@CLightShadows@@PBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CLightShadows::shadow> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CLightShadows::shadow> > >
PUBLIC	??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@Ushadow@CLightShadows@@@std@@@std@@@std@@QBEABUshadow@CLightShadows@@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CLightShadows::shadow> > >::operator*
PUBLIC	??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@Ushadow@CLightShadows@@@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CLightShadows::shadow> > >::operator+=
PUBLIC	??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUcaster@CLightShadows@@@std@@@std@@@std@@QAE@PAPAUcaster@CLightShadows@@PBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CLightShadows::caster *> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CLightShadows::caster *> > >
PUBLIC	??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUcaster@CLightShadows@@@std@@@std@@@std@@QBEABQAUcaster@CLightShadows@@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CLightShadows::caster *> > >::operator*
PUBLIC	??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUcaster@CLightShadows@@@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CLightShadows::caster *> > >::operator+=
PUBLIC	??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U_MatrixItem@R_dsgraph@@@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<R_dsgraph::_MatrixItem> > >::operator+=
PUBLIC	??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUcaster@CLightShadows@@@std@@@std@@@std@@QAE@PAPAUcaster@CLightShadows@@PBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CLightShadows::caster *> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<CLightShadows::caster *> > >
PUBLIC	??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@Ushadow@CLightShadows@@@std@@@std@@@std@@QAE@PAUshadow@CLightShadows@@PBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CLightShadows::shadow> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<CLightShadows::shadow> > >
PUBLIC	?begin@?$vector@U_MatrixItem@R_dsgraph@@V?$xalloc@U_MatrixItem@R_dsgraph@@@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U_MatrixItem@R_dsgraph@@@std@@@std@@@2@XZ ; std::vector<R_dsgraph::_MatrixItem,xalloc<R_dsgraph::_MatrixItem> >::begin
PUBLIC	?size@?$vector@U_MatrixItem@R_dsgraph@@V?$xalloc@U_MatrixItem@R_dsgraph@@@@@std@@QBEIXZ ; std::vector<R_dsgraph::_MatrixItem,xalloc<R_dsgraph::_MatrixItem> >::size
PUBLIC	?_Orphan_range@?$vector@U_MatrixItem@R_dsgraph@@V?$xalloc@U_MatrixItem@R_dsgraph@@@@@std@@ABEXPAU_MatrixItem@R_dsgraph@@0@Z ; std::vector<R_dsgraph::_MatrixItem,xalloc<R_dsgraph::_MatrixItem> >::_Orphan_range
PUBLIC	?_Getal@?$vector@U_MatrixItem@R_dsgraph@@V?$xalloc@U_MatrixItem@R_dsgraph@@@@@std@@AAEAAV?$xalloc@U_MatrixItem@R_dsgraph@@@@XZ ; std::vector<R_dsgraph::_MatrixItem,xalloc<R_dsgraph::_MatrixItem> >::_Getal
PUBLIC	?clear_and_free@?$xr_vector@U_MatrixItem@R_dsgraph@@V?$xalloc@U_MatrixItem@R_dsgraph@@@@@@QAEXXZ ; xr_vector<R_dsgraph::_MatrixItem,xalloc<R_dsgraph::_MatrixItem> >::clear_and_free
PUBLIC	??0?$vector@PAUcaster@CLightShadows@@V?$xalloc@PAUcaster@CLightShadows@@@@@std@@QAE@XZ ; std::vector<CLightShadows::caster *,xalloc<CLightShadows::caster *> >::vector<CLightShadows::caster *,xalloc<CLightShadows::caster *> >
PUBLIC	?begin@?$vector@PAUcaster@CLightShadows@@V?$xalloc@PAUcaster@CLightShadows@@@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUcaster@CLightShadows@@@std@@@std@@@2@XZ ; std::vector<CLightShadows::caster *,xalloc<CLightShadows::caster *> >::begin
PUBLIC	?size@?$vector@PAUcaster@CLightShadows@@V?$xalloc@PAUcaster@CLightShadows@@@@@std@@QBEIXZ ; std::vector<CLightShadows::caster *,xalloc<CLightShadows::caster *> >::size
PUBLIC	?_Tidy@?$vector@PAUcaster@CLightShadows@@V?$xalloc@PAUcaster@CLightShadows@@@@@std@@AAEXXZ ; std::vector<CLightShadows::caster *,xalloc<CLightShadows::caster *> >::_Tidy
PUBLIC	?_Orphan_range@?$vector@PAUcaster@CLightShadows@@V?$xalloc@PAUcaster@CLightShadows@@@@@std@@ABEXPAPAUcaster@CLightShadows@@0@Z ; std::vector<CLightShadows::caster *,xalloc<CLightShadows::caster *> >::_Orphan_range
PUBLIC	?_Getal@?$vector@PAUcaster@CLightShadows@@V?$xalloc@PAUcaster@CLightShadows@@@@@std@@AAEAAV?$xalloc@PAUcaster@CLightShadows@@@@XZ ; std::vector<CLightShadows::caster *,xalloc<CLightShadows::caster *> >::_Getal
PUBLIC	?clear_and_free@?$xr_vector@PAUcaster@CLightShadows@@V?$xalloc@PAUcaster@CLightShadows@@@@@@QAEXXZ ; xr_vector<CLightShadows::caster *,xalloc<CLightShadows::caster *> >::clear_and_free
PUBLIC	??0?$vector@Ushadow@CLightShadows@@V?$xalloc@Ushadow@CLightShadows@@@@@std@@QAE@XZ ; std::vector<CLightShadows::shadow,xalloc<CLightShadows::shadow> >::vector<CLightShadows::shadow,xalloc<CLightShadows::shadow> >
PUBLIC	?begin@?$vector@Ushadow@CLightShadows@@V?$xalloc@Ushadow@CLightShadows@@@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@Ushadow@CLightShadows@@@std@@@std@@@2@XZ ; std::vector<CLightShadows::shadow,xalloc<CLightShadows::shadow> >::begin
PUBLIC	?size@?$vector@Ushadow@CLightShadows@@V?$xalloc@Ushadow@CLightShadows@@@@@std@@QBEIXZ ; std::vector<CLightShadows::shadow,xalloc<CLightShadows::shadow> >::size
PUBLIC	?_Tidy@?$vector@Ushadow@CLightShadows@@V?$xalloc@Ushadow@CLightShadows@@@@@std@@AAEXXZ ; std::vector<CLightShadows::shadow,xalloc<CLightShadows::shadow> >::_Tidy
PUBLIC	?_Orphan_range@?$vector@Ushadow@CLightShadows@@V?$xalloc@Ushadow@CLightShadows@@@@@std@@ABEXPAUshadow@CLightShadows@@0@Z ; std::vector<CLightShadows::shadow,xalloc<CLightShadows::shadow> >::_Orphan_range
PUBLIC	?_Getal@?$vector@Ushadow@CLightShadows@@V?$xalloc@Ushadow@CLightShadows@@@@@std@@AAEAAV?$xalloc@Ushadow@CLightShadows@@@@XZ ; std::vector<CLightShadows::shadow,xalloc<CLightShadows::shadow> >::_Getal
PUBLIC	?clear_and_free@?$xr_vector@Ushadow@CLightShadows@@V?$xalloc@Ushadow@CLightShadows@@@@@@QAEXXZ ; xr_vector<CLightShadows::shadow,xalloc<CLightShadows::shadow> >::clear_and_free
PUBLIC	??0?$vector@Utess_tri@CLightShadows@@V?$xalloc@Utess_tri@CLightShadows@@@@@std@@QAE@XZ ; std::vector<CLightShadows::tess_tri,xalloc<CLightShadows::tess_tri> >::vector<CLightShadows::tess_tri,xalloc<CLightShadows::tess_tri> >
PUBLIC	?size@?$vector@Utess_tri@CLightShadows@@V?$xalloc@Utess_tri@CLightShadows@@@@@std@@QBEIXZ ; std::vector<CLightShadows::tess_tri,xalloc<CLightShadows::tess_tri> >::size
PUBLIC	?_Tidy@?$vector@Utess_tri@CLightShadows@@V?$xalloc@Utess_tri@CLightShadows@@@@@std@@AAEXXZ ; std::vector<CLightShadows::tess_tri,xalloc<CLightShadows::tess_tri> >::_Tidy
PUBLIC	?_Orphan_range@?$vector@Utess_tri@CLightShadows@@V?$xalloc@Utess_tri@CLightShadows@@@@@std@@ABEXPAUtess_tri@CLightShadows@@0@Z ; std::vector<CLightShadows::tess_tri,xalloc<CLightShadows::tess_tri> >::_Orphan_range
PUBLIC	?_Getal@?$vector@Utess_tri@CLightShadows@@V?$xalloc@Utess_tri@CLightShadows@@@@@std@@AAEAAV?$xalloc@Utess_tri@CLightShadows@@@@XZ ; std::vector<CLightShadows::tess_tri,xalloc<CLightShadows::tess_tri> >::_Getal
PUBLIC	?clear_and_free@?$xr_vector@Utess_tri@CLightShadows@@V?$xalloc@Utess_tri@CLightShadows@@@@@@QAEXXZ ; xr_vector<CLightShadows::tess_tri,xalloc<CLightShadows::tess_tri> >::clear_and_free
PUBLIC	??0?$vector@Ucache_item@CLightShadows@@V?$xalloc@Ucache_item@CLightShadows@@@@@std@@QAE@XZ ; std::vector<CLightShadows::cache_item,xalloc<CLightShadows::cache_item> >::vector<CLightShadows::cache_item,xalloc<CLightShadows::cache_item> >
PUBLIC	?size@?$vector@Ucache_item@CLightShadows@@V?$xalloc@Ucache_item@CLightShadows@@@@@std@@QBEIXZ ; std::vector<CLightShadows::cache_item,xalloc<CLightShadows::cache_item> >::size
PUBLIC	?_Tidy@?$vector@Ucache_item@CLightShadows@@V?$xalloc@Ucache_item@CLightShadows@@@@@std@@AAEXXZ ; std::vector<CLightShadows::cache_item,xalloc<CLightShadows::cache_item> >::_Tidy
PUBLIC	?_Orphan_range@?$vector@Ucache_item@CLightShadows@@V?$xalloc@Ucache_item@CLightShadows@@@@@std@@ABEXPAUcache_item@CLightShadows@@0@Z ; std::vector<CLightShadows::cache_item,xalloc<CLightShadows::cache_item> >::_Orphan_range
PUBLIC	?_Getal@?$vector@Ucache_item@CLightShadows@@V?$xalloc@Ucache_item@CLightShadows@@@@@std@@AAEAAV?$xalloc@Ucache_item@CLightShadows@@@@XZ ; std::vector<CLightShadows::cache_item,xalloc<CLightShadows::cache_item> >::_Getal
PUBLIC	?clear_and_free@?$xr_vector@Ucache_item@CLightShadows@@V?$xalloc@Ucache_item@CLightShadows@@@@@@QAEXXZ ; xr_vector<CLightShadows::cache_item,xalloc<CLightShadows::cache_item> >::clear_and_free
PUBLIC	??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@Ucache_item@CLightShadows@@@std@@@std@@@std@@QAE@PAUcache_item@CLightShadows@@PBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CLightShadows::cache_item> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CLightShadows::cache_item> > >
PUBLIC	??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@Ucache_item@CLightShadows@@@std@@@std@@@std@@QBEABUcache_item@CLightShadows@@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CLightShadows::cache_item> > >::operator*
PUBLIC	?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@Ucache_item@CLightShadows@@@std@@@std@@@std@@QBEXABV12@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CLightShadows::cache_item> > >::_Compat
PUBLIC	??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@Ucache_item@CLightShadows@@@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CLightShadows::cache_item> > >::operator+=
PUBLIC	??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@Utess_tri@CLightShadows@@@std@@@std@@@std@@QAE@PAUtess_tri@CLightShadows@@PBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CLightShadows::tess_tri> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CLightShadows::tess_tri> > >
PUBLIC	??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@Utess_tri@CLightShadows@@@std@@@std@@@std@@QBEABUtess_tri@CLightShadows@@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CLightShadows::tess_tri> > >::operator*
PUBLIC	??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@Ushadow@CLightShadows@@@std@@@std@@@std@@QBEAAUshadow@CLightShadows@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CLightShadows::shadow> > >::operator*
PUBLIC	??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@Ushadow@CLightShadows@@@std@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CLightShadows::shadow> > >::operator+
PUBLIC	??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUcaster@CLightShadows@@@std@@@std@@@std@@QBEAAPAUcaster@CLightShadows@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CLightShadows::caster *> > >::operator*
PUBLIC	??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUcaster@CLightShadows@@@std@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CLightShadows::caster *> > >::operator+
PUBLIC	??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U_MatrixItem@R_dsgraph@@@std@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<R_dsgraph::_MatrixItem> > >::operator+
PUBLIC	??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@Utess_tri@CLightShadows@@@std@@@std@@@std@@QAE@PAUtess_tri@CLightShadows@@PBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CLightShadows::tess_tri> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<CLightShadows::tess_tri> > >
PUBLIC	??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@Ucache_item@CLightShadows@@@std@@@std@@@std@@QAE@PAUcache_item@CLightShadows@@PBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CLightShadows::cache_item> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<CLightShadows::cache_item> > >
PUBLIC	?build_unit_normal@?$_plane@M@@QAEAAV1@ABU?$_vector3@M@@0@Z ; _plane<float>::build_unit_normal
PUBLIC	??$_Emplace_back_with_unused_capacity@ABU_MatrixItem@R_dsgraph@@@?$vector@U_MatrixItem@R_dsgraph@@V?$xalloc@U_MatrixItem@R_dsgraph@@@@@std@@AAE?A_TABU_MatrixItem@R_dsgraph@@@Z ; std::vector<R_dsgraph::_MatrixItem,xalloc<R_dsgraph::_MatrixItem> >::_Emplace_back_with_unused_capacity<R_dsgraph::_MatrixItem const &>
PUBLIC	??$emplace_back@ABU_MatrixItem@R_dsgraph@@@?$vector@U_MatrixItem@R_dsgraph@@V?$xalloc@U_MatrixItem@R_dsgraph@@@@@std@@QAE?A_TABU_MatrixItem@R_dsgraph@@@Z ; std::vector<R_dsgraph::_MatrixItem,xalloc<R_dsgraph::_MatrixItem> >::emplace_back<R_dsgraph::_MatrixItem const &>
PUBLIC	?push_back@?$vector@U_MatrixItem@R_dsgraph@@V?$xalloc@U_MatrixItem@R_dsgraph@@@@@std@@QAEXABU_MatrixItem@R_dsgraph@@@Z ; std::vector<R_dsgraph::_MatrixItem,xalloc<R_dsgraph::_MatrixItem> >::push_back
PUBLIC	?empty@?$vector@U_MatrixItem@R_dsgraph@@V?$xalloc@U_MatrixItem@R_dsgraph@@@@@std@@QBE_NXZ ; std::vector<R_dsgraph::_MatrixItem,xalloc<R_dsgraph::_MatrixItem> >::empty
PUBLIC	?size@?$xr_vector@U_MatrixItem@R_dsgraph@@V?$xalloc@U_MatrixItem@R_dsgraph@@@@@@QBEIXZ ; xr_vector<R_dsgraph::_MatrixItem,xalloc<R_dsgraph::_MatrixItem> >::size
PUBLIC	?clear@?$xr_vector@U_MatrixItem@R_dsgraph@@V?$xalloc@U_MatrixItem@R_dsgraph@@@@@@QAEXXZ ; xr_vector<R_dsgraph::_MatrixItem,xalloc<R_dsgraph::_MatrixItem> >::clear
PUBLIC	??A?$xr_vector@U_MatrixItem@R_dsgraph@@V?$xalloc@U_MatrixItem@R_dsgraph@@@@@@QAEAAU_MatrixItem@R_dsgraph@@I@Z ; xr_vector<R_dsgraph::_MatrixItem,xalloc<R_dsgraph::_MatrixItem> >::operator[]
PUBLIC	??1?$vector@PAUcaster@CLightShadows@@V?$xalloc@PAUcaster@CLightShadows@@@@@std@@QAE@XZ ; std::vector<CLightShadows::caster *,xalloc<CLightShadows::caster *> >::~vector<CLightShadows::caster *,xalloc<CLightShadows::caster *> >
PUBLIC	??$_Emplace_back_with_unused_capacity@ABQAUcaster@CLightShadows@@@?$vector@PAUcaster@CLightShadows@@V?$xalloc@PAUcaster@CLightShadows@@@@@std@@AAE?A_TABQAUcaster@CLightShadows@@@Z ; std::vector<CLightShadows::caster *,xalloc<CLightShadows::caster *> >::_Emplace_back_with_unused_capacity<CLightShadows::caster * const &>
PUBLIC	??$emplace_back@ABQAUcaster@CLightShadows@@@?$vector@PAUcaster@CLightShadows@@V?$xalloc@PAUcaster@CLightShadows@@@@@std@@QAE?A_TABQAUcaster@CLightShadows@@@Z ; std::vector<CLightShadows::caster *,xalloc<CLightShadows::caster *> >::emplace_back<CLightShadows::caster * const &>
PUBLIC	?push_back@?$vector@PAUcaster@CLightShadows@@V?$xalloc@PAUcaster@CLightShadows@@@@@std@@QAEXABQAUcaster@CLightShadows@@@Z ; std::vector<CLightShadows::caster *,xalloc<CLightShadows::caster *> >::push_back
PUBLIC	?pop_back@?$vector@PAUcaster@CLightShadows@@V?$xalloc@PAUcaster@CLightShadows@@@@@std@@QAEXXZ ; std::vector<CLightShadows::caster *,xalloc<CLightShadows::caster *> >::pop_back
PUBLIC	?empty@?$vector@PAUcaster@CLightShadows@@V?$xalloc@PAUcaster@CLightShadows@@@@@std@@QBE_NXZ ; std::vector<CLightShadows::caster *,xalloc<CLightShadows::caster *> >::empty
PUBLIC	?back@?$vector@PAUcaster@CLightShadows@@V?$xalloc@PAUcaster@CLightShadows@@@@@std@@QAEAAPAUcaster@CLightShadows@@XZ ; std::vector<CLightShadows::caster *,xalloc<CLightShadows::caster *> >::back
PUBLIC	??0?$xr_vector@PAUcaster@CLightShadows@@V?$xalloc@PAUcaster@CLightShadows@@@@@@QAE@XZ ; xr_vector<CLightShadows::caster *,xalloc<CLightShadows::caster *> >::xr_vector<CLightShadows::caster *,xalloc<CLightShadows::caster *> >
PUBLIC	?size@?$xr_vector@PAUcaster@CLightShadows@@V?$xalloc@PAUcaster@CLightShadows@@@@@@QBEIXZ ; xr_vector<CLightShadows::caster *,xalloc<CLightShadows::caster *> >::size
PUBLIC	?clear@?$xr_vector@PAUcaster@CLightShadows@@V?$xalloc@PAUcaster@CLightShadows@@@@@@QAEXXZ ; xr_vector<CLightShadows::caster *,xalloc<CLightShadows::caster *> >::clear
PUBLIC	??A?$xr_vector@PAUcaster@CLightShadows@@V?$xalloc@PAUcaster@CLightShadows@@@@@@QAEAAPAUcaster@CLightShadows@@I@Z ; xr_vector<CLightShadows::caster *,xalloc<CLightShadows::caster *> >::operator[]
PUBLIC	??1?$vector@Ushadow@CLightShadows@@V?$xalloc@Ushadow@CLightShadows@@@@@std@@QAE@XZ ; std::vector<CLightShadows::shadow,xalloc<CLightShadows::shadow> >::~vector<CLightShadows::shadow,xalloc<CLightShadows::shadow> >
PUBLIC	??$_Emplace_back_with_unused_capacity@Ushadow@CLightShadows@@@?$vector@Ushadow@CLightShadows@@V?$xalloc@Ushadow@CLightShadows@@@@@std@@AAE?A_T$$QAUshadow@CLightShadows@@@Z ; std::vector<CLightShadows::shadow,xalloc<CLightShadows::shadow> >::_Emplace_back_with_unused_capacity<CLightShadows::shadow>
PUBLIC	??$emplace_back@Ushadow@CLightShadows@@@?$vector@Ushadow@CLightShadows@@V?$xalloc@Ushadow@CLightShadows@@@@@std@@QAE?A_T$$QAUshadow@CLightShadows@@@Z ; std::vector<CLightShadows::shadow,xalloc<CLightShadows::shadow> >::emplace_back<CLightShadows::shadow>
PUBLIC	?push_back@?$vector@Ushadow@CLightShadows@@V?$xalloc@Ushadow@CLightShadows@@@@@std@@QAEX$$QAUshadow@CLightShadows@@@Z ; std::vector<CLightShadows::shadow,xalloc<CLightShadows::shadow> >::push_back
PUBLIC	?back@?$vector@Ushadow@CLightShadows@@V?$xalloc@Ushadow@CLightShadows@@@@@std@@QAEAAUshadow@CLightShadows@@XZ ; std::vector<CLightShadows::shadow,xalloc<CLightShadows::shadow> >::back
PUBLIC	??0?$xr_vector@Ushadow@CLightShadows@@V?$xalloc@Ushadow@CLightShadows@@@@@@QAE@XZ ; xr_vector<CLightShadows::shadow,xalloc<CLightShadows::shadow> >::xr_vector<CLightShadows::shadow,xalloc<CLightShadows::shadow> >
PUBLIC	?size@?$xr_vector@Ushadow@CLightShadows@@V?$xalloc@Ushadow@CLightShadows@@@@@@QBEIXZ ; xr_vector<CLightShadows::shadow,xalloc<CLightShadows::shadow> >::size
PUBLIC	?clear@?$xr_vector@Ushadow@CLightShadows@@V?$xalloc@Ushadow@CLightShadows@@@@@@QAEXXZ ; xr_vector<CLightShadows::shadow,xalloc<CLightShadows::shadow> >::clear
PUBLIC	??A?$xr_vector@Ushadow@CLightShadows@@V?$xalloc@Ushadow@CLightShadows@@@@@@QAEAAUshadow@CLightShadows@@I@Z ; xr_vector<CLightShadows::shadow,xalloc<CLightShadows::shadow> >::operator[]
PUBLIC	??1?$vector@Utess_tri@CLightShadows@@V?$xalloc@Utess_tri@CLightShadows@@@@@std@@QAE@XZ ; std::vector<CLightShadows::tess_tri,xalloc<CLightShadows::tess_tri> >::~vector<CLightShadows::tess_tri,xalloc<CLightShadows::tess_tri> >
PUBLIC	??$_Emplace_back_with_unused_capacity@Utess_tri@CLightShadows@@@?$vector@Utess_tri@CLightShadows@@V?$xalloc@Utess_tri@CLightShadows@@@@@std@@AAE?A_T$$QAUtess_tri@CLightShadows@@@Z ; std::vector<CLightShadows::tess_tri,xalloc<CLightShadows::tess_tri> >::_Emplace_back_with_unused_capacity<CLightShadows::tess_tri>
PUBLIC	??$emplace_back@Utess_tri@CLightShadows@@@?$vector@Utess_tri@CLightShadows@@V?$xalloc@Utess_tri@CLightShadows@@@@@std@@QAE?A_T$$QAUtess_tri@CLightShadows@@@Z ; std::vector<CLightShadows::tess_tri,xalloc<CLightShadows::tess_tri> >::emplace_back<CLightShadows::tess_tri>
PUBLIC	?push_back@?$vector@Utess_tri@CLightShadows@@V?$xalloc@Utess_tri@CLightShadows@@@@@std@@QAEX$$QAUtess_tri@CLightShadows@@@Z ; std::vector<CLightShadows::tess_tri,xalloc<CLightShadows::tess_tri> >::push_back
PUBLIC	?begin@?$vector@Utess_tri@CLightShadows@@V?$xalloc@Utess_tri@CLightShadows@@@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@Utess_tri@CLightShadows@@@std@@@std@@@2@XZ ; std::vector<CLightShadows::tess_tri,xalloc<CLightShadows::tess_tri> >::begin
PUBLIC	?back@?$vector@Utess_tri@CLightShadows@@V?$xalloc@Utess_tri@CLightShadows@@@@@std@@QAEAAUtess_tri@CLightShadows@@XZ ; std::vector<CLightShadows::tess_tri,xalloc<CLightShadows::tess_tri> >::back
PUBLIC	??0?$xr_vector@Utess_tri@CLightShadows@@V?$xalloc@Utess_tri@CLightShadows@@@@@@QAE@XZ ; xr_vector<CLightShadows::tess_tri,xalloc<CLightShadows::tess_tri> >::xr_vector<CLightShadows::tess_tri,xalloc<CLightShadows::tess_tri> >
PUBLIC	?size@?$xr_vector@Utess_tri@CLightShadows@@V?$xalloc@Utess_tri@CLightShadows@@@@@@QBEIXZ ; xr_vector<CLightShadows::tess_tri,xalloc<CLightShadows::tess_tri> >::size
PUBLIC	?clear@?$xr_vector@Utess_tri@CLightShadows@@V?$xalloc@Utess_tri@CLightShadows@@@@@@QAEXXZ ; xr_vector<CLightShadows::tess_tri,xalloc<CLightShadows::tess_tri> >::clear
PUBLIC	??1?$vector@Ucache_item@CLightShadows@@V?$xalloc@Ucache_item@CLightShadows@@@@@std@@QAE@XZ ; std::vector<CLightShadows::cache_item,xalloc<CLightShadows::cache_item> >::~vector<CLightShadows::cache_item,xalloc<CLightShadows::cache_item> >
PUBLIC	?insert@?$vector@Ucache_item@CLightShadows@@V?$xalloc@Ucache_item@CLightShadows@@@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@Ucache_item@CLightShadows@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@Ucache_item@CLightShadows@@@std@@@std@@@2@ABUcache_item@CLightShadows@@@Z ; std::vector<CLightShadows::cache_item,xalloc<CLightShadows::cache_item> >::insert
PUBLIC	?erase@?$vector@Ucache_item@CLightShadows@@V?$xalloc@Ucache_item@CLightShadows@@@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@Ucache_item@CLightShadows@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@Ucache_item@CLightShadows@@@std@@@std@@@2@@Z ; std::vector<CLightShadows::cache_item,xalloc<CLightShadows::cache_item> >::erase
PUBLIC	?begin@?$vector@Ucache_item@CLightShadows@@V?$xalloc@Ucache_item@CLightShadows@@@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@Ucache_item@CLightShadows@@@std@@@std@@@2@XZ ; std::vector<CLightShadows::cache_item,xalloc<CLightShadows::cache_item> >::begin
PUBLIC	?end@?$vector@Ucache_item@CLightShadows@@V?$xalloc@Ucache_item@CLightShadows@@@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@Ucache_item@CLightShadows@@@std@@@std@@@2@XZ ; std::vector<CLightShadows::cache_item,xalloc<CLightShadows::cache_item> >::end
PUBLIC	??0?$xr_vector@Ucache_item@CLightShadows@@V?$xalloc@Ucache_item@CLightShadows@@@@@@QAE@XZ ; xr_vector<CLightShadows::cache_item,xalloc<CLightShadows::cache_item> >::xr_vector<CLightShadows::cache_item,xalloc<CLightShadows::cache_item> >
PUBLIC	?size@?$xr_vector@Ucache_item@CLightShadows@@V?$xalloc@Ucache_item@CLightShadows@@@@@@QBEIXZ ; xr_vector<CLightShadows::cache_item,xalloc<CLightShadows::cache_item> >::size
PUBLIC	?clear@?$xr_vector@Ucache_item@CLightShadows@@V?$xalloc@Ucache_item@CLightShadows@@@@@@QAEXXZ ; xr_vector<CLightShadows::cache_item,xalloc<CLightShadows::cache_item> >::clear
PUBLIC	??A?$xr_vector@Ucache_item@CLightShadows@@V?$xalloc@Ucache_item@CLightShadows@@@@@@QAEAAUcache_item@CLightShadows@@I@Z ; xr_vector<CLightShadows::cache_item,xalloc<CLightShadows::cache_item> >::operator[]
PUBLIC	??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@Ucache_item@CLightShadows@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CLightShadows::cache_item> > >::operator==
PUBLIC	??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@Ucache_item@CLightShadows@@@std@@@std@@@std@@QBEAAUcache_item@CLightShadows@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CLightShadows::cache_item> > >::operator*
PUBLIC	??C?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@Ucache_item@CLightShadows@@@std@@@std@@@std@@QBEPAUcache_item@CLightShadows@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CLightShadows::cache_item> > >::operator->
PUBLIC	??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@Ucache_item@CLightShadows@@@std@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CLightShadows::cache_item> > >::operator+
PUBLIC	??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@Utess_tri@CLightShadows@@@std@@@std@@@std@@QBEAAUtess_tri@CLightShadows@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CLightShadows::tess_tri> > >::operator*
PUBLIC	?cache_search@@YA_NABUcache_item@CLightShadows@@0@Z ; cache_search
PUBLIC	?PLC_calc@@YAHAAU?$_vector3@M@@0PAVlight@@M0@Z	; PLC_calc
PUBLIC	?PLC_energy@@YAMAAU?$_vector3@M@@0PAVlight@@M@Z	; PLC_energy
PUBLIC	??1?$xr_vector@Ucache_item@CLightShadows@@V?$xalloc@Ucache_item@CLightShadows@@@@@@QAE@XZ ; xr_vector<CLightShadows::cache_item,xalloc<CLightShadows::cache_item> >::~xr_vector<CLightShadows::cache_item,xalloc<CLightShadows::cache_item> >
PUBLIC	??1?$xr_vector@Utess_tri@CLightShadows@@V?$xalloc@Utess_tri@CLightShadows@@@@@@QAE@XZ ; xr_vector<CLightShadows::tess_tri,xalloc<CLightShadows::tess_tri> >::~xr_vector<CLightShadows::tess_tri,xalloc<CLightShadows::tess_tri> >
PUBLIC	??1?$xr_vector@Ushadow@CLightShadows@@V?$xalloc@Ushadow@CLightShadows@@@@@@QAE@XZ ; xr_vector<CLightShadows::shadow,xalloc<CLightShadows::shadow> >::~xr_vector<CLightShadows::shadow,xalloc<CLightShadows::shadow> >
PUBLIC	??1?$xr_vector@PAUcaster@CLightShadows@@V?$xalloc@PAUcaster@CLightShadows@@@@@@QAE@XZ ; xr_vector<CLightShadows::caster *,xalloc<CLightShadows::caster *> >::~xr_vector<CLightShadows::caster *,xalloc<CLightShadows::caster *> >
PUBLIC	??0CLightShadows@@QAE@XZ			; CLightShadows::CLightShadows
PUBLIC	??1CLightShadows@@QAE@XZ			; CLightShadows::~CLightShadows
PUBLIC	?set_object@CLightShadows@@QAEXPAVIRenderable@@@Z ; CLightShadows::set_object
PUBLIC	?calculate@CLightShadows@@QAEXXZ		; CLightShadows::calculate
PUBLIC	?render@CLightShadows@@QAEXXZ			; CLightShadows::render
PUBLIC	?add_element@CLightShadows@@QAEXAAU_MatrixItem@R_dsgraph@@@Z ; CLightShadows::add_element
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$_Emplace_reallocate@Utess_tri@CLightShadows@@@?$vector@Utess_tri@CLightShadows@@V?$xalloc@Utess_tri@CLightShadows@@@@@std@@QAEPAUtess_tri@CLightShadows@@QAU23@$$QAU23@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Emplace_reallocate@Utess_tri@CLightShadows@@@?$vector@Utess_tri@CLightShadows@@V?$xalloc@Utess_tri@CLightShadows@@@@@std@@QAEPAUtess_tri@CLightShadows@@QAU23@$$QAU23@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Emplace_reallocate@Utess_tri@CLightShadows@@@?$vector@Utess_tri@CLightShadows@@V?$xalloc@Utess_tri@CLightShadows@@@@@std@@QAEPAUtess_tri@CLightShadows@@QAU23@$$QAU23@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
__unwindtable$??$_Emplace_reallocate@Utess_tri@CLightShadows@@@?$vector@Utess_tri@CLightShadows@@V?$xalloc@Utess_tri@CLightShadows@@@@@std@@QAEPAUtess_tri@CLightShadows@@QAU23@$$QAU23@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Emplace_reallocate@Utess_tri@CLightShadows@@@?$vector@Utess_tri@CLightShadows@@V?$xalloc@Utess_tri@CLightShadows@@@@@std@@QAEPAUtess_tri@CLightShadows@@QAU23@$$QAU23@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Emplace_reallocate@Utess_tri@CLightShadows@@@?$vector@Utess_tri@CLightShadows@@V?$xalloc@Utess_tri@CLightShadows@@@@@std@@QAEPAUtess_tri@CLightShadows@@QAU23@$$QAU23@@Z$2
__catchsym$??$_Emplace_reallocate@Utess_tri@CLightShadows@@@?$vector@Utess_tri@CLightShadows@@V?$xalloc@Utess_tri@CLightShadows@@@@@std@@QAEPAUtess_tri@CLightShadows@@QAU23@$$QAU23@@Z$2 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Emplace_reallocate@Utess_tri@CLightShadows@@@?$vector@Utess_tri@CLightShadows@@V?$xalloc@Utess_tri@CLightShadows@@@@@std@@QAEPAUtess_tri@CLightShadows@@QAU23@$$QAU23@@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$_Emplace_reallocate@Ushadow@CLightShadows@@@?$vector@Ushadow@CLightShadows@@V?$xalloc@Ushadow@CLightShadows@@@@@std@@QAEPAUshadow@CLightShadows@@QAU23@$$QAU23@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Emplace_reallocate@Ushadow@CLightShadows@@@?$vector@Ushadow@CLightShadows@@V?$xalloc@Ushadow@CLightShadows@@@@@std@@QAEPAUshadow@CLightShadows@@QAU23@$$QAU23@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Emplace_reallocate@Ushadow@CLightShadows@@@?$vector@Ushadow@CLightShadows@@V?$xalloc@Ushadow@CLightShadows@@@@@std@@QAEPAUshadow@CLightShadows@@QAU23@$$QAU23@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
__unwindtable$??$_Emplace_reallocate@Ushadow@CLightShadows@@@?$vector@Ushadow@CLightShadows@@V?$xalloc@Ushadow@CLightShadows@@@@@std@@QAEPAUshadow@CLightShadows@@QAU23@$$QAU23@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Emplace_reallocate@Ushadow@CLightShadows@@@?$vector@Ushadow@CLightShadows@@V?$xalloc@Ushadow@CLightShadows@@@@@std@@QAEPAUshadow@CLightShadows@@QAU23@$$QAU23@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Emplace_reallocate@Ushadow@CLightShadows@@@?$vector@Ushadow@CLightShadows@@V?$xalloc@Ushadow@CLightShadows@@@@@std@@QAEPAUshadow@CLightShadows@@QAU23@$$QAU23@@Z$2
__catchsym$??$_Emplace_reallocate@Ushadow@CLightShadows@@@?$vector@Ushadow@CLightShadows@@V?$xalloc@Ushadow@CLightShadows@@@@@std@@QAEPAUshadow@CLightShadows@@QAU23@$$QAU23@@Z$2 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Emplace_reallocate@Ushadow@CLightShadows@@@?$vector@Ushadow@CLightShadows@@V?$xalloc@Ushadow@CLightShadows@@@@@std@@QAEPAUshadow@CLightShadows@@QAU23@$$QAU23@@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$_Emplace_reallocate@ABQAUcaster@CLightShadows@@@?$vector@PAUcaster@CLightShadows@@V?$xalloc@PAUcaster@CLightShadows@@@@@std@@QAEPAPAUcaster@CLightShadows@@QAPAU23@ABQAU23@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Emplace_reallocate@ABQAUcaster@CLightShadows@@@?$vector@PAUcaster@CLightShadows@@V?$xalloc@PAUcaster@CLightShadows@@@@@std@@QAEPAPAUcaster@CLightShadows@@QAPAU23@ABQAU23@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Emplace_reallocate@ABQAUcaster@CLightShadows@@@?$vector@PAUcaster@CLightShadows@@V?$xalloc@PAUcaster@CLightShadows@@@@@std@@QAEPAPAUcaster@CLightShadows@@QAPAU23@ABQAU23@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
__unwindtable$??$_Emplace_reallocate@ABQAUcaster@CLightShadows@@@?$vector@PAUcaster@CLightShadows@@V?$xalloc@PAUcaster@CLightShadows@@@@@std@@QAEPAPAUcaster@CLightShadows@@QAPAU23@ABQAU23@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Emplace_reallocate@ABQAUcaster@CLightShadows@@@?$vector@PAUcaster@CLightShadows@@V?$xalloc@PAUcaster@CLightShadows@@@@@std@@QAEPAPAUcaster@CLightShadows@@QAPAU23@ABQAU23@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Emplace_reallocate@ABQAUcaster@CLightShadows@@@?$vector@PAUcaster@CLightShadows@@V?$xalloc@PAUcaster@CLightShadows@@@@@std@@QAEPAPAUcaster@CLightShadows@@QAPAU23@ABQAU23@@Z$2
__catchsym$??$_Emplace_reallocate@ABQAUcaster@CLightShadows@@@?$vector@PAUcaster@CLightShadows@@V?$xalloc@PAUcaster@CLightShadows@@@@@std@@QAEPAPAUcaster@CLightShadows@@QAPAU23@ABQAU23@@Z$2 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Emplace_reallocate@ABQAUcaster@CLightShadows@@@?$vector@PAUcaster@CLightShadows@@V?$xalloc@PAUcaster@CLightShadows@@@@@std@@QAEPAPAUcaster@CLightShadows@@QAPAU23@ABQAU23@@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$_Emplace_reallocate@ABU_MatrixItem@R_dsgraph@@@?$vector@U_MatrixItem@R_dsgraph@@V?$xalloc@U_MatrixItem@R_dsgraph@@@@@std@@QAEPAU_MatrixItem@R_dsgraph@@QAU23@ABU23@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Emplace_reallocate@ABU_MatrixItem@R_dsgraph@@@?$vector@U_MatrixItem@R_dsgraph@@V?$xalloc@U_MatrixItem@R_dsgraph@@@@@std@@QAEPAU_MatrixItem@R_dsgraph@@QAU23@ABU23@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Emplace_reallocate@ABU_MatrixItem@R_dsgraph@@@?$vector@U_MatrixItem@R_dsgraph@@V?$xalloc@U_MatrixItem@R_dsgraph@@@@@std@@QAEPAU_MatrixItem@R_dsgraph@@QAU23@ABU23@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
__unwindtable$??$_Emplace_reallocate@ABU_MatrixItem@R_dsgraph@@@?$vector@U_MatrixItem@R_dsgraph@@V?$xalloc@U_MatrixItem@R_dsgraph@@@@@std@@QAEPAU_MatrixItem@R_dsgraph@@QAU23@ABU23@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Emplace_reallocate@ABU_MatrixItem@R_dsgraph@@@?$vector@U_MatrixItem@R_dsgraph@@V?$xalloc@U_MatrixItem@R_dsgraph@@@@@std@@QAEPAU_MatrixItem@R_dsgraph@@QAU23@ABU23@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Emplace_reallocate@ABU_MatrixItem@R_dsgraph@@@?$vector@U_MatrixItem@R_dsgraph@@V?$xalloc@U_MatrixItem@R_dsgraph@@@@@std@@QAEPAU_MatrixItem@R_dsgraph@@QAU23@ABU23@@Z$2
__catchsym$??$_Emplace_reallocate@ABU_MatrixItem@R_dsgraph@@@?$vector@U_MatrixItem@R_dsgraph@@V?$xalloc@U_MatrixItem@R_dsgraph@@@@@std@@QAEPAU_MatrixItem@R_dsgraph@@QAU23@ABU23@@Z$2 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Emplace_reallocate@ABU_MatrixItem@R_dsgraph@@@?$vector@U_MatrixItem@R_dsgraph@@V?$xalloc@U_MatrixItem@R_dsgraph@@@@@std@@QAEPAU_MatrixItem@R_dsgraph@@QAU23@ABU23@@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$_Emplace_reallocate@ABUcache_item@CLightShadows@@@?$vector@Ucache_item@CLightShadows@@V?$xalloc@Ucache_item@CLightShadows@@@@@std@@QAEPAUcache_item@CLightShadows@@QAU23@ABU23@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Emplace_reallocate@ABUcache_item@CLightShadows@@@?$vector@Ucache_item@CLightShadows@@V?$xalloc@Ucache_item@CLightShadows@@@@@std@@QAEPAUcache_item@CLightShadows@@QAU23@ABU23@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Emplace_reallocate@ABUcache_item@CLightShadows@@@?$vector@Ucache_item@CLightShadows@@V?$xalloc@Ucache_item@CLightShadows@@@@@std@@QAEPAUcache_item@CLightShadows@@QAU23@ABU23@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
__unwindtable$??$_Emplace_reallocate@ABUcache_item@CLightShadows@@@?$vector@Ucache_item@CLightShadows@@V?$xalloc@Ucache_item@CLightShadows@@@@@std@@QAEPAUcache_item@CLightShadows@@QAU23@ABU23@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Emplace_reallocate@ABUcache_item@CLightShadows@@@?$vector@Ucache_item@CLightShadows@@V?$xalloc@Ucache_item@CLightShadows@@@@@std@@QAEPAUcache_item@CLightShadows@@QAU23@ABU23@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Emplace_reallocate@ABUcache_item@CLightShadows@@@?$vector@Ucache_item@CLightShadows@@V?$xalloc@Ucache_item@CLightShadows@@@@@std@@QAEPAUcache_item@CLightShadows@@QAU23@ABU23@@Z$2
__catchsym$??$_Emplace_reallocate@ABUcache_item@CLightShadows@@@?$vector@Ucache_item@CLightShadows@@V?$xalloc@Ucache_item@CLightShadows@@@@@std@@QAEPAUcache_item@CLightShadows@@QAU23@ABU23@@Z$2 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Emplace_reallocate@ABUcache_item@CLightShadows@@@?$vector@Ucache_item@CLightShadows@@V?$xalloc@Ucache_item@CLightShadows@@@@@std@@QAEPAUcache_item@CLightShadows@@QAU23@ABU23@@Z$0
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp
_TEXT	SEGMENT
_N$ = 8							; size = 4
?add_element@CLightShadows@@QAEXAAU_MatrixItem@R_dsgraph@@@Z PROC ; CLightShadows::add_element
; _this$ = ecx

; 128  : 	if (0==current)										return;

	cmp	DWORD PTR [ecx], 0
	je	SHORT $LN12@add_elemen

; 129  : 	VERIFY2	(casters.back()->nodes.size()<24,"Object exceeds limit of 24 renderable parts/materials");
; 130  : 	if (0==N.pVisual->shader->E[SE_R1_LMODELS]._get())	return;

	mov	edx, DWORD PTR _N$[esp-4]
	mov	eax, DWORD PTR [edx+8]
	mov	eax, DWORD PTR [eax+64]
	cmp	DWORD PTR [eax+24], 0
	je	SHORT $LN12@add_elemen

; 131  : 	casters.back()->nodes.push_back		(N);

	mov	eax, DWORD PTR [ecx+20]
	push	edi
	mov	eax, DWORD PTR [eax-4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 730  :         if (_Mylast != _My_data._Myend) {

	mov	edi, DWORD PTR [eax+24]
	cmp	edi, DWORD PTR [eax+28]
	je	SHORT $LN13@add_elemen
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	push	esi
	mov	ecx, 19					; 00000013H
	mov	esi, edx
	rep movsd
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 716  :         ++_Mylast;

	add	DWORD PTR [eax+24], 76			; 0000004cH
	pop	esi
	pop	edi
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp

; 132  : }

	ret	4
$LN13@add_elemen:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 734  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	push	edx
	push	edi
	lea	ecx, DWORD PTR [eax+20]
	call	??$_Emplace_reallocate@ABU_MatrixItem@R_dsgraph@@@?$vector@U_MatrixItem@R_dsgraph@@V?$xalloc@U_MatrixItem@R_dsgraph@@@@@std@@QAEPAU_MatrixItem@R_dsgraph@@QAU23@ABU23@@Z ; std::vector<R_dsgraph::_MatrixItem,xalloc<R_dsgraph::_MatrixItem> >::_Emplace_reallocate<R_dsgraph::_MatrixItem const &>
	pop	edi
$LN12@add_elemen:
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp

; 132  : }

	ret	4
?add_element@CLightShadows@@QAEXAAU_MatrixItem@R_dsgraph@@@Z ENDP ; CLightShadows::add_element
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp
; File I:\Vitalya\mine\NSProjectX\xrEngine\xr_area.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp
; File I:\Vitalya\mine\NSProjectX\xrEngine\xr_area.h
; File I:\Vitalya\mine\NSProjectX\xrCDB\xrCDB.h
; File I:\Vitalya\mine\NSProjectX\xrEngine\xr_area.h
; File I:\Vitalya\mine\NSProjectX\xrCDB\xrCDB.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp
; File I:\Vitalya\mine\NSProjectX\xrEngine\xr_area.h
; File I:\Vitalya\mine\NSProjectX\xrCDB\xrCDB.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp
; File I:\Vitalya\mine\NSProjectX\xrEngine\R_Backend_Runtime.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\FTimer.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\FTimer.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_color.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_color.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector2.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp
; File I:\Vitalya\mine\NSProjectX\xrCDB\xrCDB.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp
; File I:\Vitalya\mine\NSProjectX\xrCDB\xrCDB.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp
; File I:\Vitalya\mine\NSProjectX\xrCDB\xrCDB.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp
; File I:\Vitalya\mine\NSProjectX\xrCDB\xrCDB.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp
; File I:\Vitalya\mine\NSProjectX\xrCDB\xrCDB.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\FixedVector.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\FixedVector.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\FixedVector.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\FixedVector.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\FixedVector.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\FixedVector.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\FixedVector.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp
; File I:\Vitalya\mine\NSProjectX\xrCDB\xrCDB.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp
; File I:\Vitalya\mine\NSProjectX\xrCDB\xrCDB.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp
; File I:\Vitalya\mine\NSProjectX\xrCDB\xrCDB.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_plane.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\vector.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\vector.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\vector.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\vector.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\vector.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\vector.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\vector.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\vector.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\vector.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector2.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_color.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_color.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_color.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_color.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_color.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_color.h
; File I:\Vitalya\mine\NSProjectX\xrEngine\fvf.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp
; File I:\Vitalya\mine\NSProjectX\xrEngine\fvf.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector2.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector2.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector2.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_color.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_color.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_color.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_color.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_color.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_color.h
; File I:\Vitalya\mine\NSProjectX\xrEngine\fvf.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector2.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector2.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector2.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector2.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_color.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_color.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_color.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_color.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_color.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrEngine\fvf.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector2.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector2.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector2.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector2.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp
; File I:\Vitalya\mine\NSProjectX\xrEngine\R_Backend_Runtime.h
; File I:\Vitalya\mine\NSProjectX\xrEngine\r_constants_cache.h
; File I:\Vitalya\mine\NSProjectX\xrEngine\R_Backend_Runtime.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\FTimer.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp
; File I:\Vitalya\mine\NSProjectX\xrEngine\R_Backend_Runtime.h
; File I:\Vitalya\mine\NSProjectX\xrEngine\r_constants_cache.h
; File I:\Vitalya\mine\NSProjectX\xrEngine\R_Backend_Runtime.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp
_TEXT	SEGMENT
_magnitude$1$ = -1700					; size = 4
_c0$2$ = -1700						; size = 4
_v$1$ = -1700						; size = 4
_CI_what$2$ = -1700					; size = 4
tv7006 = -1700						; size = 4
tv6979 = -1700						; size = 4
_a$7 = -1700						; size = 4
_magnitude$1$ = -1696					; size = 4
_sqD$1$ = -1696						; size = 4
_C1$1$ = -1696						; size = 4
_c1$2$ = -1696						; size = 4
_p$1$ = -1696						; size = 4
__vb$1$ = -1692						; size = 4
_cit$1$ = -1692						; size = 4
_tid$1$ = -1692						; size = 4
_clip$1$ = -1692					; size = 4
tv7293 = -1692						; size = 4
tv7080 = -1692						; size = 4
tv7072 = -1692						; size = 4
_iw$1$ = -1688						; size = 4
tv7007 = -1688						; size = 4
tv6978 = -1688						; size = 4
tv6800 = -1688						; size = 4
_a$8 = -1688						; size = 4
_a$9 = -1688						; size = 4
__My_data$1$ = -1684					; size = 4
tv6947 = -1684						; size = 4
_e$1$ = -1680						; size = 4
tv7008 = -1680						; size = 4
tv6977 = -1680						; size = 4
tv6732 = -1680						; size = 4
_CI$1$ = -1676						; size = 4
tv7092 = -1672						; size = 4
tv7204 = -1668						; size = 4
tv7079 = -1668						; size = 4
tv6949 = -1664						; size = 4
_iw$1$ = -1660						; size = 4
_iw$1$ = -1660						; size = 4
tv7175 = -1660						; size = 4
tv6799 = -1660						; size = 4
_Le$1$ = -1656						; size = 4
_this$1$ = -1652					; size = 4
_S$1$ = -1648						; size = 4
_this$1$ = -1644					; size = 4
_pv$1$ = -1640						; size = 4
_batch$1$ = -1636					; size = 4
tv7200 = -1632						; size = 4
tv7187 = -1632						; size = 4
tv6789 = -1632						; size = 4
_Offset$ = -1628					; size = 4
_e$3$ = -1624						; size = 4
tv6731 = -1624						; size = 4
_t_offset$2$sroa$3657$1$ = -1620			; size = 4
_t_offset$2$sroa$3658$1$ = -1616			; size = 4
_s_it$1$ = -1612					; size = 4
$T10 = -1608						; size = 4
tv7252 = -1604						; size = 4
tv6788 = -1600						; size = 4
_C1$1$ = -1596						; size = 4
_DB$1$ = -1592						; size = 4
_TRIS$1$ = -1588					; size = 4
_VERTS$1$ = -1584					; size = 4
__43$1$ = -1580						; size = 4
_e$ = -1576						; size = 12
_e$ = -1564						; size = 12
_e$ = -1552						; size = 12
_View$ = -1540						; size = 12
_P$11 = -1528						; size = 16
$T12 = -1512						; size = 4
_CI_what$13 = -1508					; size = 44
$T14 = -1464						; size = 48
_A$15 = -1416						; size = 580
_F$16 = -832						; size = 244
_B$17 = -584						; size = 580
?render@CLightShadows@@QAEXXZ PROC			; CLightShadows::render
; _this$ = ecx

; 357  : {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	sub	esp, 1700				; 000006a4H
; File I:\Vitalya\mine\NSProjectX\xrEngine\xr_area.h

; 61   : 	CDB::MODEL* GetStaticModel() { return &Static; }

	mov	eax, DWORD PTR __imp_?g_pGameLevel@@3PAVIGame_Level@@A
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp

; 357  : {

	push	ebx
	mov	ebx, ecx
	push	esi
; File I:\Vitalya\mine\NSProjectX\xrEngine\xr_area.h

; 61   : 	CDB::MODEL* GetStaticModel() { return &Static; }

	mov	ecx, DWORD PTR [eax]
; File I:\Vitalya\mine\NSProjectX\xrCDB\xrCDB.h

; 86   : 		IC TRI*					get_tris		()			{ return tris;		}

	mov	eax, DWORD PTR [ecx+184]
; File I:\Vitalya\mine\NSProjectX\xrEngine\xr_area.h

; 61   : 	CDB::MODEL* GetStaticModel() { return &Static; }

	add	ecx, 172				; 000000acH
; File I:\Vitalya\mine\NSProjectX\xrCDB\xrCDB.h

; 86   : 		IC TRI*					get_tris		()			{ return tris;		}

	mov	DWORD PTR _TRIS$1$[esp+1708], eax
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp

; 357  : {

	push	edi
; File I:\Vitalya\mine\NSProjectX\xrEngine\xr_area.h

; 61   : 	CDB::MODEL* GetStaticModel() { return &Static; }

	mov	DWORD PTR _DB$1$[esp+1712], ecx
; File I:\Vitalya\mine\NSProjectX\xrCDB\xrCDB.h

; 84   : 		IC Fvector*				get_verts		()			{ return verts;		}

	mov	eax, DWORD PTR [ecx+20]
	mov	DWORD PTR _VERTS$1$[esp+1712], eax
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp

; 366  : 	float _43					=	Device.mProject._43;

	mov	eax, DWORD PTR __imp_?Device@@3VCRenderDevice@@A
	mov	DWORD PTR _this$1$[esp+1712], ebx
	movss	xmm0, DWORD PTR [eax+656]
	movss	DWORD PTR __43$1$[esp+1712], xmm0

; 367  : 	Device.mProject._43			-=	0.002f; 

	subss	xmm0, DWORD PTR __real@3b03126f
	movss	DWORD PTR [eax+656], xmm0

; 368  : 	RCache.set_xform_world		(Fidentity);

	push	DWORD PTR __imp_?Fidentity@@3U?$_matrix@M@@A
	mov	ecx, DWORD PTR __imp_?RCache@@3VCBackend@@A
	call	DWORD PTR __imp_?set_xform_world@CBackend@@QAEXABU?$_matrix@M@@@Z

; 369  : 	RCache.set_xform_project	(Device.mProject);

	mov	eax, DWORD PTR __imp_?Device@@3VCRenderDevice@@A
	mov	ecx, DWORD PTR __imp_?RCache@@3VCBackend@@A
	add	eax, 600				; 00000258H
	push	eax
	call	DWORD PTR __imp_?set_xform_project@CBackend@@QAEXABU?$_matrix@M@@@Z

; 370  : 	Fvector	View				= Device.vCameraPosition;

	mov	ecx, DWORD PTR __imp_?Device@@3VCRenderDevice@@A

; 371  : 	
; 372  : 	// Render shadows
; 373  : 	RCache.set_Shader			(sh_World);

	push	0
	mov	eax, DWORD PTR [ecx+488]
	mov	DWORD PTR _View$[esp+1716], eax
	mov	eax, DWORD PTR [ecx+492]
	mov	DWORD PTR _View$[esp+1720], eax
	mov	eax, DWORD PTR [ecx+496]
	mov	ecx, DWORD PTR __imp_?RCache@@3VCBackend@@A
	mov	DWORD PTR _View$[esp+1724], eax
	lea	eax, DWORD PTR [ebx+108]
	push	eax
	call	DWORD PTR __imp_?set_Shader@CBackend@@QAEXAAV?$resptr_core@UShader@@Uresptrcode_shader@@@@I@Z
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 70   : 	T &					operator*() const												{	return *p_;	}

	mov	edi, DWORD PTR [ebx+112]
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp

; 374  : 	RCache.set_Geometry			(geom_World);

	mov	esi, DWORD PTR __imp_?RCache@@3VCBackend@@A
; File I:\Vitalya\mine\NSProjectX\xrEngine\R_Backend_Runtime.h

; 224  : 	set_Format(_geom->dcl._get()->dcl);

	mov	eax, DWORD PTR [edi+8]
	mov	edx, DWORD PTR [eax+8]

; 131  : 	if (decl != _decl)

	cmp	DWORD PTR [esi+592], edx
	je	SHORT $LN62@render

; 132  : 	{
; 133  : 		PGO(Msg("PGO:v_format:%x", _decl));
; 134  : #ifdef DEBUG
; 135  : 		stat.decl++;
; 136  : #endif
; 137  : 		decl = _decl;

	mov	DWORD PTR [esi+592], edx

; 138  : 		CHK_DX(HW.pDevice->SetVertexDeclaration(decl));

	mov	eax, DWORD PTR __imp_?HW@@3VCHW@@A
	push	edx
	mov	eax, DWORD PTR [eax+8]
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+348]
$LN62@render:

; 225  : 	set_Vertices(_geom->vb, _geom->vb_stride);

	mov	eax, DWORD PTR [edi+12]
	mov	edx, DWORD PTR [edi+20]
	mov	DWORD PTR __vb$1$[esp+1712], eax

; 172  : 	if ((vb != _vb) || (vb_stride != _vb_stride))

	cmp	DWORD PTR [esi+596], eax
	jne	SHORT $LN66@render
	cmp	DWORD PTR [esi+604], edx
	je	SHORT $LN65@render
$LN66@render:

; 173  : 	{
; 174  : 		PGO(Msg("PGO:VB:%x,%d", _vb, _vb_stride));
; 175  : #ifdef DEBUG
; 176  : 		stat.vb++;
; 177  : #endif
; 178  : 		vb = _vb;

	mov	DWORD PTR [esi+596], eax

; 179  : 		vb_stride = _vb_stride;

	mov	DWORD PTR [esi+604], edx

; 180  : 		CHK_DX(HW.pDevice->SetStreamSource(0, vb, 0, vb_stride));

	mov	eax, DWORD PTR __imp_?HW@@3VCHW@@A
	push	edx
	push	0
	push	DWORD PTR __vb$1$[esp+1720]
	mov	eax, DWORD PTR [eax+8]
	push	0
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+400]
$LN65@render:

; 226  : 	set_Indices(_geom->ib);

	mov	edx, DWORD PTR [edi+16]

; 186  : 	if (ib != _ib)

	cmp	DWORD PTR [esi+600], edx
	je	SHORT $LN69@render

; 187  : 	{
; 188  : 		PGO(Msg("PGO:IB:%x", _ib));
; 189  : #ifdef DEBUG
; 190  : 		stat.ib++;
; 191  : #endif
; 192  : 		ib = _ib;

	mov	DWORD PTR [esi+600], edx

; 193  : 		CHK_DX(HW.pDevice->SetIndices(ib));

	mov	eax, DWORD PTR __imp_?HW@@3VCHW@@A
	push	edx
	mov	eax, DWORD PTR [eax+8]
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+416]
$LN69@render:
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp

; 377  : 	FVF::LIT* pv				= (FVF::LIT*) RCache.Vertex.Lock	(batch_size*3,geom_World->vb_stride,Offset);

	mov	ecx, DWORD PTR __imp_?RCache@@3VCBackend@@A
	lea	eax, DWORD PTR _Offset$[esp+1712]
	push	eax
	mov	eax, DWORD PTR [ebx+112]
	xor	edi, edi
	mov	DWORD PTR _Offset$[esp+1716], edi
	mov	DWORD PTR _batch$1$[esp+1716], edi
	push	DWORD PTR [eax+20]
	push	768					; 00000300H
	call	DWORD PTR __imp_?Lock@_VertexStream@@QAEPAXIIAAI@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	ecx, DWORD PTR [ebx+32]
	sub	ecx, DWORD PTR [ebx+28]
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp

; 377  : 	FVF::LIT* pv				= (FVF::LIT*) RCache.Vertex.Lock	(batch_size*3,geom_World->vb_stride,Offset);

	mov	DWORD PTR _pv$1$[esp+1712], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	eax, -1307163959			; b21642c9H
	imul	ecx
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp

; 378  : 	for (u32 s_it=0; s_it<shadows.size(); s_it++)

	mov	DWORD PTR _s_it$1$[esp+1712], edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	add	edx, ecx
	sar	edx, 6
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp

; 378  : 	for (u32 s_it=0; s_it<shadows.size(); s_it++)

	je	$LN3@render
	movss	xmm1, DWORD PTR __xmm@7fffffff7fffffff7fffffff7fffffff
	lea	eax, DWORD PTR [ebx+52]
	movss	xmm2, DWORD PTR __real@3e2aaaab
	mov	edi, 6
	movss	xmm3, DWORD PTR __real@3a800000
	mov	DWORD PTR _this$1$[esp+1712], eax
	npad	5
$LL4@render:

; 380  : 		Device.Statistic->RenderDUMP_Srender.Begin	();

	mov	eax, DWORD PTR __imp_?Device@@3VCRenderDevice@@A
	mov	esi, DWORD PTR [eax+436]
; File I:\Vitalya\mine\NSProjectX\xrCore\FTimer.h

; 173  : 	ICF void	Begin			()		{	if (!g_bEnableStatGather) return;	count++; T.Start();				}

	mov	eax, DWORD PTR __imp_?g_bEnableStatGather@@3HA
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp

; 380  : 		Device.Statistic->RenderDUMP_Srender.Begin	();

	add	esi, 2656				; 00000a60H
; File I:\Vitalya\mine\NSProjectX\xrCore\FTimer.h

; 173  : 	ICF void	Begin			()		{	if (!g_bEnableStatGather) return;	count++; T.Start();				}

	cmp	DWORD PTR [eax], 0
	je	SHORT $LN87@render
	inc	DWORD PTR [esi+68]

; 73   : 		if (bPause)

	cmp	DWORD PTR [esi+24], 0
	jne	SHORT $LN87@render

; 29   : 	ICF	void	Start			()		{	if(bPause) return;	qwStartTime = CPU::QPC()-qwPauseAccum;		}

	call	DWORD PTR __imp_?QPC@CPU@@YA_KXZ
	sub	eax, DWORD PTR [esi+16]

; 73   : 		if (bPause)

	movss	xmm1, DWORD PTR __xmm@7fffffff7fffffff7fffffff7fffffff

; 29   : 	ICF	void	Start			()		{	if(bPause) return;	qwStartTime = CPU::QPC()-qwPauseAccum;		}

	sbb	edx, DWORD PTR [esi+20]

; 73   : 		if (bPause)

	movss	xmm2, DWORD PTR __real@3e2aaaab
	movss	xmm3, DWORD PTR __real@3a800000

; 29   : 	ICF	void	Start			()		{	if(bPause) return;	qwStartTime = CPU::QPC()-qwPauseAccum;		}

	mov	DWORD PTR [esi], eax
	mov	DWORD PTR [esi+4], edx

; 78   : 		m_real_ticks	= 0;

	mov	DWORD PTR [esi+40], 0
	mov	DWORD PTR [esi+44], 0

; 79   : 		m_ticks			= 0;

	mov	DWORD PTR [esi+48], 0
	mov	DWORD PTR [esi+52], 0
$LN87@render:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 119  :         _Ptr += _Off;

	imul	esi, DWORD PTR _s_it$1$[esp+1712], 92
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp

; 394  : 		cache_item						CI_what; CI_what.O	= S.O; CI_what.L = S.L; CI_what.tris=0;

	mov	DWORD PTR _CI_what$13[esp+1748], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 119  :         _Ptr += _Off;

	add	esi, DWORD PTR [ebx+28]
	mov	DWORD PTR _S$1$[esp+1712], esi
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp

; 383  : 		int			s_x			=	S.slot%slot_line;

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi+84]
	cdq
	idiv	edi
; File I:\Vitalya\mine\NSProjectX\xrCore\_color.h

; 203  : 		return (r + g + b)/3.f;

	movss	xmm0, DWORD PTR [ecx+112]
	addss	xmm0, DWORD PTR [ecx+108]
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp

; 394  : 		cache_item						CI_what; CI_what.O	= S.O; CI_what.L = S.L; CI_what.tris=0;

	mov	edi, DWORD PTR [esi]
	mov	DWORD PTR _CI_what$2$[esp+1712], ecx
	mov	DWORD PTR _CI_what$13[esp+1712], edi
	mov	DWORD PTR _CI_what$13[esp+1728], ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\_color.h

; 203  : 		return (r + g + b)/3.f;

	addss	xmm0, DWORD PTR [ecx+116]
	mulss	xmm0, DWORD PTR __real@3eaaaaab
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp

; 382  : 		float		Le			=	S.L->color.intensity()*S.E;

	mulss	xmm0, DWORD PTR [esi+88]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility

; 5810 :     auto _UFirst                = _Get_unwrapped(_First);

	lea	esi, DWORD PTR [ebx+52]
	mov	ebx, DWORD PTR [esi]
	mov	DWORD PTR _CI$1$[esp+1712], ebx
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp

; 382  : 		float		Le			=	S.L->color.intensity()*S.E;

	movss	DWORD PTR _Le$1$[esp+1712], xmm0

; 388  : 		t_offset.set(float(s_x)/float(slot_line),float(s_y)/float(slot_line));

	cvtsi2ss xmm0, edx
	mulss	xmm0, xmm2
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector2.h

; 15   : 	IC SelfRef set(float _u, float _v)				{ x=T(_u); y=T(_v);				return *this;	}

	addss	xmm0, xmm3
	movss	DWORD PTR _t_offset$2$sroa$3657$1$[esp+1712], xmm0
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp

; 388  : 		t_offset.set(float(s_x)/float(slot_line),float(s_y)/float(slot_line));

	cvtsi2ss xmm0, eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility

; 1525 :         return _Last - _First; // assume the iterator will do debug checking

	mov	eax, DWORD PTR _this$1$[esp+1712]
	mov	eax, DWORD PTR [eax+56]
	mov	DWORD PTR tv7293[esp+1712], eax
	sub	eax, ebx
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp

; 388  : 		t_offset.set(float(s_x)/float(slot_line),float(s_y)/float(slot_line));

	mulss	xmm0, xmm2
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility

; 1525 :         return _Last - _First; // assume the iterator will do debug checking

	sar	eax, 2
	imul	edx, eax, -1171354717
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp

; 389  : 		t_offset.x	+= .5f/S_rt_size;

	addss	xmm0, xmm3
	movss	DWORD PTR _t_offset$2$sroa$3658$1$[esp+1712], xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility

; 5813 :     while (0 < _Count) { // divide and conquer, find half that contains answer

	test	edx, edx
	jle	SHORT $LN125@render
$LL124@render:

; 5814 :         const _Iter_diff_t<_FwdIt> _Count2 = _Count / 2;

	mov	ecx, edx
	shr	ecx, 1

; 1497 :         _Where += _Off;

	imul	eax, ecx, 44
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp

; 349  : 	if (A.O < B.O)	return true;

	cmp	DWORD PTR [eax+ebx], edi
	jb	SHORT $LN710@render

; 350  : 	if (A.O > B.O)	return false;

	ja	SHORT $LN126@render

; 351  : 	if (A.L < B.L)	return true;

	mov	esi, DWORD PTR _CI_what$2$[esp+1712]
	cmp	DWORD PTR [eax+ebx+16], esi
	jb	SHORT $LN710@render
$LN126@render:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility

; 5820 :             _Count = _Count2;

	mov	edx, ecx
	jmp	SHORT $LN127@render
$LN710@render:

; 5815 :         const auto _UMid                   = _STD next(_UFirst, _Count2);
; 5816 :         if (_Pred(*_UMid, _Val)) { // try top half
; 5817 :             _UFirst = _Next_iter(_UMid);

	add	eax, 44					; 0000002cH
	add	ebx, eax

; 5818 :             _Count -= _Count2 + 1;

	or	eax, -1
	sub	eax, ecx
	add	edx, eax
$LN127@render:

; 5813 :     while (0 < _Count) { // divide and conquer, find half that contains answer

	test	edx, edx
	jg	SHORT $LL124@render
	mov	ecx, DWORD PTR _CI_what$2$[esp+1712]
	mov	esi, DWORD PTR _this$1$[esp+1712]
	mov	DWORD PTR _CI$1$[esp+1712], ebx
$LN125@render:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 150  :         return _Ptr == _Right._Ptr;

	cmp	ebx, DWORD PTR tv7293[esp+1712]
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp

; 396  : 		if (CI_ptr==cache.end())		

	jne	SHORT $LN26@render
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 801  :         const pointer _Oldlast  = _My_data._Mylast;

	mov	edx, DWORD PTR [esi+4]

; 802  : #if _ITERATOR_DEBUG_LEVEL == 2
; 803  :         _STL_VERIFY(
; 804  :             _Where._Getcont() == _STD addressof(_My_data) && _Whereptr >= _My_data._Myfirst && _Oldlast >= _Whereptr,
; 805  :             "vector emplace iterator outside range");
; 806  : #endif // _ITERATOR_DEBUG_LEVEL == 2
; 807  : 
; 808  :         if (_Oldlast != _My_data._Myend) {

	cmp	edx, DWORD PTR [esi+8]
	je	SHORT $LN152@render

; 809  :             if (_Whereptr == _Oldlast) { // at back, provide strong guarantee

	mov	eax, DWORD PTR _this$1$[esp+1712]
	mov	ecx, 11					; 0000000bH
	mov	edi, edx
	cmp	ebx, edx
	jne	SHORT $LN153@render
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	lea	esi, DWORD PTR _CI_what$13[esp+1712]
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp

; 399  : 			CI		= &*CI_ptr;

	mov	DWORD PTR _CI$1$[esp+1712], ebx
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	rep movsd
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 716  :         ++_Mylast;

	add	DWORD PTR [eax+4], 44			; 0000002cH
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp

; 401  : 		} else {

	jmp	$LN192@render
$LN153@render:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 816  :                 _Alty_traits::construct(_Al, _Unfancy(_Oldlast), _STD move(_Oldlast[-1]));

	lea	esi, DWORD PTR [edx-44]
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	rep movsd
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 817  :                 ++_My_data._Mylast;

	add	DWORD PTR [eax+4], 44			; 0000002cH
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility

; 4254 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	mov	eax, edx
	sub	eax, ebx
	sub	eax, 44					; 0000002cH

; 4255 :     auto _Result                = _CSTD memmove(_Dest_ch - _Count, _First_ch, _Count);

	push	eax
	sub	edx, eax
	push	ebx
	push	edx
	call	_memmove
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 819  :                 *_Whereptr = _STD move(_Obj._Get_value());

	mov	ecx, 11					; 0000000bH
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp

; 399  : 			CI		= &*CI_ptr;

	mov	DWORD PTR _CI$1$[esp+1724], ebx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 819  :                 *_Whereptr = _STD move(_Obj._Get_value());

	lea	esi, DWORD PTR _CI_what$13[esp+1724]
	mov	edi, ebx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility

; 4255 :     auto _Result                = _CSTD memmove(_Dest_ch - _Count, _First_ch, _Count);

	add	esp, 12					; 0000000cH
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 819  :                 *_Whereptr = _STD move(_Obj._Get_value());

	rep movsd
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp

; 401  : 		} else {

	jmp	$LN192@render
$LN152@render:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 825  :         return _Make_iterator(_Emplace_reallocate(_Whereptr, _STD forward<_Valty>(_Val)...));

	lea	eax, DWORD PTR _CI_what$13[esp+1712]
	mov	ecx, esi
	push	eax
	push	ebx
	call	??$_Emplace_reallocate@ABUcache_item@CLightShadows@@@?$vector@Ucache_item@CLightShadows@@V?$xalloc@Ucache_item@CLightShadows@@@@@std@@QAEPAUcache_item@CLightShadows@@QAU23@ABU23@@Z ; std::vector<CLightShadows::cache_item,xalloc<CLightShadows::cache_item> >::_Emplace_reallocate<CLightShadows::cache_item const &>

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	ebx, eax
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp

; 399  : 			CI		= &*CI_ptr;

	mov	DWORD PTR _CI$1$[esp+1712], ebx

; 401  : 		} else {

	jmp	$LN192@render
$LN26@render:

; 402  : 			if (CI_ptr->O != CI_what.O  || CI_ptr->L != CI_what.L)	

	mov	eax, DWORD PTR [ebx]
	cmp	eax, edi
	jne	$LN30@render
	mov	edx, DWORD PTR [ebx+16]
	cmp	edx, ecx
	jne	$LN30@render
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 58   : 	ICF BOOL	similar(const Self &v, T E=EPS_L) const	{ return _abs(x-v.x)<E && _abs(y-v.y)<E && _abs(z-v.z)<E;};

	movss	xmm0, DWORD PTR [ebx+4]
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp

; 410  : 				bValid	= TRUE;

	mov	ecx, 1
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 58   : 	ICF BOOL	similar(const Self &v, T E=EPS_L) const	{ return _abs(x-v.x)<E && _abs(y-v.y)<E && _abs(z-v.z)<E;};

	subss	xmm0, DWORD PTR [eax+52]
	movss	xmm2, DWORD PTR __real@3a83126f
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h

; 676  :             return (float)fabs(_X);

	andps	xmm0, xmm1
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 58   : 	ICF BOOL	similar(const Self &v, T E=EPS_L) const	{ return _abs(x-v.x)<E && _abs(y-v.y)<E && _abs(z-v.z)<E;};

	comiss	xmm2, xmm0
	jbe	$LN192@render
	movss	xmm0, DWORD PTR [ebx+8]
	subss	xmm0, DWORD PTR [eax+56]
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h

; 676  :             return (float)fabs(_X);

	andps	xmm0, xmm1
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 58   : 	ICF BOOL	similar(const Self &v, T E=EPS_L) const	{ return _abs(x-v.x)<E && _abs(y-v.y)<E && _abs(z-v.z)<E;};

	comiss	xmm2, xmm0
	jbe	$LN192@render
	movss	xmm0, DWORD PTR [ebx+12]
	subss	xmm0, DWORD PTR [eax+60]
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h

; 676  :             return (float)fabs(_X);

	andps	xmm0, xmm1
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 58   : 	ICF BOOL	similar(const Self &v, T E=EPS_L) const	{ return _abs(x-v.x)<E && _abs(y-v.y)<E && _abs(z-v.z)<E;};

	comiss	xmm2, xmm0
	jbe	$LN192@render
	movss	xmm0, DWORD PTR [ebx+20]
	subss	xmm0, DWORD PTR [edx+64]
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h

; 676  :             return (float)fabs(_X);

	andps	xmm0, xmm1
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 58   : 	ICF BOOL	similar(const Self &v, T E=EPS_L) const	{ return _abs(x-v.x)<E && _abs(y-v.y)<E && _abs(z-v.z)<E;};

	comiss	xmm2, xmm0
	jbe	$LN192@render
	movss	xmm0, DWORD PTR [ebx+24]
	subss	xmm0, DWORD PTR [edx+68]
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h

; 676  :             return (float)fabs(_X);

	andps	xmm0, xmm1
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 58   : 	ICF BOOL	similar(const Self &v, T E=EPS_L) const	{ return _abs(x-v.x)<E && _abs(y-v.y)<E && _abs(z-v.z)<E;};

	comiss	xmm2, xmm0
	jbe	$LN192@render
	movss	xmm0, DWORD PTR [ebx+28]
	subss	xmm0, DWORD PTR [edx+72]
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h

; 676  :             return (float)fabs(_X);

	andps	xmm0, xmm1
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 58   : 	ICF BOOL	similar(const Self &v, T E=EPS_L) const	{ return _abs(x-v.x)<E && _abs(y-v.y)<E && _abs(z-v.z)<E;};

	comiss	xmm2, xmm0
	ja	SHORT $LN33@render
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp

; 412  : 				else if (!CI->Lp.similar(CI->L->position))		bValid = FALSE;

	jmp	SHORT $LN192@render
$LN30@render:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 801  :         const pointer _Oldlast  = _My_data._Mylast;

	mov	edx, DWORD PTR [esi+4]

; 802  : #if _ITERATOR_DEBUG_LEVEL == 2
; 803  :         _STL_VERIFY(
; 804  :             _Where._Getcont() == _STD addressof(_My_data) && _Whereptr >= _My_data._Myfirst && _Oldlast >= _Whereptr,
; 805  :             "vector emplace iterator outside range");
; 806  : #endif // _ITERATOR_DEBUG_LEVEL == 2
; 807  : 
; 808  :         if (_Oldlast != _My_data._Myend) {

	cmp	edx, DWORD PTR [esi+8]
	je	SHORT $LN193@render

; 809  :             if (_Whereptr == _Oldlast) { // at back, provide strong guarantee

	mov	eax, DWORD PTR _this$1$[esp+1712]
	mov	ecx, 11					; 0000000bH
	mov	edi, edx
	cmp	ebx, edx
	jne	SHORT $LN194@render
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	lea	esi, DWORD PTR _CI_what$13[esp+1712]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	DWORD PTR _CI$1$[esp+1712], ebx
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	rep movsd
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 716  :         ++_Mylast;

	add	DWORD PTR [eax+4], 44			; 0000002cH

; 822  :             return _Make_iterator(_Whereptr);

	jmp	SHORT $LN192@render
$LN194@render:

; 816  :                 _Alty_traits::construct(_Al, _Unfancy(_Oldlast), _STD move(_Oldlast[-1]));

	lea	esi, DWORD PTR [edx-44]
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	rep movsd
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 817  :                 ++_My_data._Mylast;

	add	DWORD PTR [eax+4], 44			; 0000002cH
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility

; 4254 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	mov	eax, edx
	sub	eax, ebx
	sub	eax, 44					; 0000002cH

; 4255 :     auto _Result                = _CSTD memmove(_Dest_ch - _Count, _First_ch, _Count);

	push	eax
	sub	edx, eax
	push	ebx
	push	edx
	call	_memmove
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 819  :                 *_Whereptr = _STD move(_Obj._Get_value());

	mov	ecx, 11					; 0000000bH

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	DWORD PTR _CI$1$[esp+1724], ebx

; 819  :                 *_Whereptr = _STD move(_Obj._Get_value());

	lea	esi, DWORD PTR _CI_what$13[esp+1724]
	mov	edi, ebx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility

; 4255 :     auto _Result                = _CSTD memmove(_Dest_ch - _Count, _First_ch, _Count);

	add	esp, 12					; 0000000cH
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 819  :                 *_Whereptr = _STD move(_Obj._Get_value());

	rep movsd

; 820  :             }
; 821  : 
; 822  :             return _Make_iterator(_Whereptr);

	jmp	SHORT $LN192@render
$LN193@render:

; 825  :         return _Make_iterator(_Emplace_reallocate(_Whereptr, _STD forward<_Valty>(_Val)...));

	lea	eax, DWORD PTR _CI_what$13[esp+1712]
	mov	ecx, esi
	push	eax
	push	ebx
	call	??$_Emplace_reallocate@ABUcache_item@CLightShadows@@@?$vector@Ucache_item@CLightShadows@@V?$xalloc@Ucache_item@CLightShadows@@@@@std@@QAEPAUcache_item@CLightShadows@@QAU23@ABU23@@Z ; std::vector<CLightShadows::cache_item,xalloc<CLightShadows::cache_item> >::_Emplace_reallocate<CLightShadows::cache_item const &>

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	ebx, eax
	mov	DWORD PTR _CI$1$[esp+1712], eax
$LN192@render:
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp

; 415  : 		CI->time				= Device.dwTimeGlobal;	// acess time

	xor	ecx, ecx
$LN33@render:
	mov	eax, DWORD PTR __imp_?Device@@3VCRenderDevice@@A
	mov	eax, DWORD PTR [eax+480]
	mov	DWORD PTR [ebx+32], eax

; 416  : 
; 417  : 		if (!bValid)			{

	test	ecx, ecx
	jne	$LN40@render

; 418  : 			// Frustum
; 419  : 			CFrustum				F;
; 420  : 			F.CreateFromMatrix		(S.M,FRUSTUM_P_ALL);

	mov	eax, DWORD PTR _S$1$[esp+1712]
	lea	ecx, DWORD PTR _F$16[esp+1712]
	push	63					; 0000003fH
	add	eax, 20					; 00000014H
	push	eax
	call	DWORD PTR __imp_?CreateFromMatrix@CFrustum@@QAEXAAU?$_matrix@M@@I@Z
; File I:\Vitalya\mine\NSProjectX\xrCDB\xrCDB.h

; 151  : 		ICF void		frustum_options	(u32 f)	{	frustum_mode = f;	}

	mov	esi, DWORD PTR _this$1$[esp+1712]
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp

; 424  : 			xrc.frustum_query		(DB,F);

	lea	eax, DWORD PTR _F$16[esp+1712]
	push	eax
	push	DWORD PTR _DB$1$[esp+1716]
	lea	ecx, DWORD PTR [esi+64]
; File I:\Vitalya\mine\NSProjectX\xrCDB\xrCDB.h

; 151  : 		ICF void		frustum_options	(u32 f)	{	frustum_mode = f;	}

	mov	DWORD PTR [esi+72], 0
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp

; 424  : 			xrc.frustum_query		(DB,F);

	call	DWORD PTR __imp_?frustum_query@xrXRC@@QAEXPBVMODEL@CDB@@ABVCFrustum@@@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	eax, DWORD PTR [esi+80]
	lea	ecx, DWORD PTR [esi+76]
	mov	DWORD PTR __My_data$1$[esp+1712], ecx
	sub	eax, DWORD PTR [ecx]
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp

; 425  : 			if (0==xrc.r_count())	continue;

	je	$LN2@render

; 426  : 
; 427  : 			// Clip polys by frustum
; 428  : 			tess.clear				();

	mov	eax, DWORD PTR [esi+40]
	add	esi, 40					; 00000028H
	mov	DWORD PTR [esi+4], eax
; File I:\Vitalya\mine\NSProjectX\xrCDB\xrCDB.h

; 154  : 		ICF RESULT*		r_begin			()	{	return &*rd.begin();		};

	lea	eax, DWORD PTR $T12[esp+1712]
	push	eax
	call	?begin@?$vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@URESULT@CDB@@@std@@@std@@@2@XZ ; std::vector<CDB::RESULT,xalloc<CDB::RESULT> >::begin

; 155  : 		ICF RESULT*		r_end			()	{	return &*rd.end();			};

	mov	ecx, DWORD PTR __My_data$1$[esp+1712]
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp

; 429  : 			for (CDB::RESULT* p = xrc.r_begin(); p!=xrc.r_end(); p++)

	mov	edi, DWORD PTR [eax]
; File I:\Vitalya\mine\NSProjectX\xrCDB\xrCDB.h

; 155  : 		ICF RESULT*		r_end			()	{	return &*rd.end();			};

	lea	eax, DWORD PTR $T10[esp+1712]
	push	eax
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp

; 429  : 			for (CDB::RESULT* p = xrc.r_begin(); p!=xrc.r_end(); p++)

	mov	DWORD PTR _p$1$[esp+1716], edi
; File I:\Vitalya\mine\NSProjectX\xrCDB\xrCDB.h

; 155  : 		ICF RESULT*		r_end			()	{	return &*rd.end();			};

	call	?end@?$vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@URESULT@CDB@@@std@@@std@@@2@XZ ; std::vector<CDB::RESULT,xalloc<CDB::RESULT> >::end
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp

; 429  : 			for (CDB::RESULT* p = xrc.r_begin(); p!=xrc.r_end(); p++)

	cmp	edi, DWORD PTR [eax]
	je	$LN6@render
	npad	4
$LL7@render:

; 430  : 			{
; 431  : 				VERIFY((p->id>=0)&&(p->id<DB->get_tris_count()));
; 432  : 				// 
; 433  : 				CDB::TRI&	t		= TRIS[p->id];

	mov	edi, DWORD PTR [edi+40]
	shl	edi, 4
	add	edi, DWORD PTR _TRIS$1$[esp+1712]

; 434  : 				if (t.suppress_shadows) continue;

	test	DWORD PTR [edi+12], 16384		; 00004000H
	jne	$LN5@render

; 436  : 				A.push_back			(VERTS[t.verts[0]]);

	mov	ebx, DWORD PTR _VERTS$1$[esp+1712]
; File I:\Vitalya\mine\NSProjectX\xrCore\FixedVector.h

; 21   : 	svector() : count(0) 

	mov	DWORD PTR _A$15[esp+2288], 0
	mov	DWORD PTR _B$17[esp+2288], 0
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp

; 436  : 				A.push_back			(VERTS[t.verts[0]]);

	mov	eax, DWORD PTR [edi]
	lea	eax, DWORD PTR [eax+eax*2]
	mov	edx, DWORD PTR [ebx+eax*4]
	mov	ecx, DWORD PTR [ebx+eax*4+4]
	mov	eax, DWORD PTR [ebx+eax*4+8]
; File I:\Vitalya\mine\NSProjectX\xrCore\FixedVector.h

; 35   : 	IC void		push_back(value_type e)		{ VERIFY(count<dim); array[count++]=e;	}

	mov	DWORD PTR _A$15[esp+1720], eax
	mov	DWORD PTR _A$15[esp+2288], 1
	mov	DWORD PTR _A$15[esp+1712], edx
	mov	DWORD PTR _A$15[esp+1716], ecx
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp

; 436  : 				A.push_back			(VERTS[t.verts[0]]);

	mov	DWORD PTR _e$[esp+1720], eax

; 437  : 				A.push_back			(VERTS[t.verts[1]]);

	mov	eax, DWORD PTR [edi+4]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	xmm1, DWORD PTR _e$[esp+1720]
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp

; 436  : 				A.push_back			(VERTS[t.verts[0]]);

	mov	DWORD PTR _e$[esp+1712], edx
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movaps	xmm2, xmm1
	movss	xmm0, DWORD PTR _e$[esp+1712]
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp

; 437  : 				A.push_back			(VERTS[t.verts[1]]);

	lea	eax, DWORD PTR [eax+eax*2]
	mov	DWORD PTR _e$[esp+1716], ecx
	mov	edx, DWORD PTR [ebx+eax*4]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movaps	xmm5, xmm0
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp

; 437  : 				A.push_back			(VERTS[t.verts[1]]);

	mov	ecx, DWORD PTR [ebx+eax*4+4]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movaps	xmm3, xmm0
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp

; 437  : 				A.push_back			(VERTS[t.verts[1]]);

	mov	eax, DWORD PTR [ebx+eax*4+8]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	xmm6, DWORD PTR _e$[esp+1716]
; File I:\Vitalya\mine\NSProjectX\xrCore\FixedVector.h

; 35   : 	IC void		push_back(value_type e)		{ VERIFY(count<dim); array[count++]=e;	}

	mov	DWORD PTR _A$15[esp+1732], eax
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movaps	xmm4, xmm6
; File I:\Vitalya\mine\NSProjectX\xrCore\FixedVector.h

; 35   : 	IC void		push_back(value_type e)		{ VERIFY(count<dim); array[count++]=e;	}

	mov	DWORD PTR _A$15[esp+2288], 2
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movaps	xmm7, xmm6
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp

; 437  : 				A.push_back			(VERTS[t.verts[1]]);

	mov	DWORD PTR _e$[esp+1720], eax
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	subss	xmm2, DWORD PTR _e$[esp+1720]
; File I:\Vitalya\mine\NSProjectX\xrCore\FixedVector.h

; 35   : 	IC void		push_back(value_type e)		{ VERIFY(count<dim); array[count++]=e;	}

	mov	DWORD PTR _A$15[esp+1724], edx
	mov	DWORD PTR _A$15[esp+1728], ecx
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp

; 438  : 				A.push_back			(VERTS[t.verts[2]]);

	mov	eax, DWORD PTR [edi+8]
	mov	DWORD PTR _e$[esp+1712], edx
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	subss	xmm5, DWORD PTR _e$[esp+1712]
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp

; 437  : 				A.push_back			(VERTS[t.verts[1]]);

	mov	DWORD PTR _e$[esp+1716], ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	subss	xmm4, DWORD PTR _e$[esp+1716]
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp

; 438  : 				A.push_back			(VERTS[t.verts[2]]);

	lea	eax, DWORD PTR [eax+eax*2]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	DWORD PTR _e$1$[esp+1712], xmm0
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp

; 438  : 				A.push_back			(VERTS[t.verts[2]]);

	mov	edx, DWORD PTR [ebx+eax*4]
	mov	ecx, DWORD PTR [ebx+eax*4+4]
	mov	eax, DWORD PTR [ebx+eax*4+8]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	DWORD PTR _e$3$[esp+1712], xmm1
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp

; 438  : 				A.push_back			(VERTS[t.verts[2]]);

	mov	DWORD PTR _e$[esp+1720], eax
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	subss	xmm1, DWORD PTR _e$[esp+1720]
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp

; 438  : 				A.push_back			(VERTS[t.verts[2]]);

	mov	DWORD PTR _e$[esp+1716], ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	subss	xmm7, DWORD PTR _e$[esp+1716]
	movss	DWORD PTR tv7072[esp+1712], xmm5
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp

; 438  : 				A.push_back			(VERTS[t.verts[2]]);

	mov	DWORD PTR _e$[esp+1712], edx
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	subss	xmm3, DWORD PTR _e$[esp+1712]
	movaps	xmm0, xmm1
; File I:\Vitalya\mine\NSProjectX\xrCore\FixedVector.h

; 35   : 	IC void		push_back(value_type e)		{ VERIFY(count<dim); array[count++]=e;	}

	mov	DWORD PTR _A$15[esp+1736], edx
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	mulss	xmm0, xmm4
; File I:\Vitalya\mine\NSProjectX\xrCore\FixedVector.h

; 35   : 	IC void		push_back(value_type e)		{ VERIFY(count<dim); array[count++]=e;	}

	mov	DWORD PTR _A$15[esp+1740], ecx
	mov	DWORD PTR _A$15[esp+1744], eax
	mov	DWORD PTR _A$15[esp+2288], 3
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	DWORD PTR tv7079[esp+1712], xmm0

; 273  : 		x = v1.y  * v2.z  - v1.z  * v2.y ;

	movaps	xmm0, xmm7
	movss	xmm5, DWORD PTR tv7079[esp+1712]
	mulss	xmm0, xmm2
	subss	xmm5, xmm0
	movaps	xmm0, xmm3
	mulss	xmm0, xmm2

; 275  : 		z = v1.x  * v2.y  - v1.y  * v2.x ;

	mulss	xmm3, xmm4
	movss	DWORD PTR tv7079[esp+1712], xmm5
	movss	xmm5, DWORD PTR tv7072[esp+1712]

; 167  : 		return x*x + y*y + z*z;

	movss	xmm2, DWORD PTR tv7079[esp+1712]

; 274  : 		y = v1.z  * v2.x  - v1.x  * v2.z ;

	mulss	xmm1, xmm5
	mulss	xmm7, xmm5
	subss	xmm0, xmm1

; 275  : 		z = v1.x  * v2.y  - v1.y  * v2.x ;

	subss	xmm7, xmm3
	movaps	xmm1, xmm0
	movss	DWORD PTR tv7080[esp+1712], xmm0
	mulss	xmm1, xmm0

; 167  : 		return x*x + y*y + z*z;

	movaps	xmm0, xmm2
	mulss	xmm0, xmm2
	addss	xmm1, xmm0
	movaps	xmm0, xmm7
	mulss	xmm0, xmm7
	addss	xmm1, xmm0
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp

; 447  : 				if (mag<EPS_S)						continue;

	movss	xmm0, DWORD PTR __real@33d6bf95
	comiss	xmm0, xmm1
	ja	$LN5@render
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h

; 764  :             return (float)sqrt(_X);

	sqrtss	xmm0, xmm1
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp

; 450  : 				float	DOT_Fade	= P.classify(S.L->position);

	mov	eax, DWORD PTR _S$1$[esp+1712]
	mov	eax, DWORD PTR [eax+84]
	movss	xmm4, DWORD PTR __real@3f800000
	divss	xmm4, xmm0
	movaps	xmm3, xmm4
	mulss	xmm3, xmm2
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 40   : 	ICF SelfRef	mul(T s)								{ x*=s;		y*=s;		z*=s;			return *this;	};

	movaps	xmm2, xmm4
	mulss	xmm2, DWORD PTR tv7080[esp+1712]

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	movaps	xmm0, xmm3

; 40   : 	ICF SelfRef	mul(T s)								{ x*=s;		y*=s;		z*=s;			return *this;	};

	mulss	xmm4, xmm7

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	mulss	xmm0, DWORD PTR [eax+64]
	movaps	xmm1, xmm2
	mulss	xmm1, DWORD PTR [eax+68]
	mulss	xmm6, xmm2
	addss	xmm1, xmm0

; 24   : 	ICF SelfRef	set(const _vector3<float> &v)			{ x = T(v.x);	y = T(v.y);	z = T(v.z);	return *this;	};

	movss	DWORD PTR _P$11[esp+1712], xmm3

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	movaps	xmm0, xmm4

; 24   : 	ICF SelfRef	set(const _vector3<float> &v)			{ x = T(v.x);	y = T(v.y);	z = T(v.z);	return *this;	};

	movss	DWORD PTR _P$11[esp+1716], xmm2

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	mulss	xmm0, DWORD PTR [eax+72]

; 24   : 	ICF SelfRef	set(const _vector3<float> &v)			{ x = T(v.x);	y = T(v.y);	z = T(v.z);	return *this;	};

	movss	DWORD PTR _P$11[esp+1720], xmm4

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	addss	xmm1, xmm0
	movss	xmm0, DWORD PTR _e$1$[esp+1712]
	mulss	xmm0, xmm3
	addss	xmm6, xmm0
	movss	xmm0, DWORD PTR _e$3$[esp+1712]
	mulss	xmm0, xmm4
	addss	xmm6, xmm0
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp

; 451  : 				if (DOT_Fade<0)		continue;

	xorps	xmm0, xmm0
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	subss	xmm1, xmm6
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp

; 451  : 				if (DOT_Fade<0)		continue;

	comiss	xmm0, xmm1
	ja	$LN5@render

; 452  : 
; 453  : 				// Clip polygon
; 454  : 				sPoly*		clip	= F.ClipPoly	(A,B);

	lea	eax, DWORD PTR _B$17[esp+1712]
	push	eax
	lea	eax, DWORD PTR _A$15[esp+1716]
	push	eax
	lea	ecx, DWORD PTR _F$16[esp+1720]
	call	DWORD PTR __imp_?ClipPoly@CFrustum@@QBEPAV?$svector@U?$_vector3@M@@$0DA@@@AAV2@0@Z
	mov	edi, eax
	mov	DWORD PTR _clip$1$[esp+1712], edi

; 455  : 				if (0==clip)		continue;

	test	edi, edi
	je	$LN5@render

; 456  : 
; 457  : 				// Triangulate poly 
; 458  : 				for (u32 v=2; v<clip->size(); v++)	{

	cmp	DWORD PTR [edi+576], 2
	mov	DWORD PTR _v$1$[esp+1712], 2
	jbe	$LN5@render
	lea	ebx, DWORD PTR [edi+24]
	npad	1
$LL13@render:

; 459  : 					tess.push_back	(tess_tri());

	push	48					; 00000030H
	lea	eax, DWORD PTR $T14[esp+1716]
	push	0
	push	eax
	call	_memset
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 730  :         if (_Mylast != _My_data._Myend) {

	mov	eax, DWORD PTR [esi+4]
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp

; 459  : 					tess.push_back	(tess_tri());

	add	esp, 12					; 0000000cH
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 730  :         if (_Mylast != _My_data._Myend) {

	cmp	eax, DWORD PTR [esi+8]
	je	SHORT $LN365@render
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	edi, eax
	lea	esi, DWORD PTR $T14[esp+1712]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 716  :         ++_Mylast;

	mov	eax, DWORD PTR _this$1$[esp+1712]
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	ecx, 12					; 0000000cH
	rep movsd
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 716  :         ++_Mylast;

	add	DWORD PTR [eax+44], 48			; 00000030H
	lea	esi, DWORD PTR [eax+40]

; 731  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

	mov	edi, DWORD PTR _clip$1$[esp+1712]
	jmp	SHORT $LN364@render
$LN365@render:

; 732  :         }
; 733  : 
; 734  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	lea	ecx, DWORD PTR $T14[esp+1712]
	push	ecx
	push	eax
	mov	ecx, esi
	call	??$_Emplace_reallocate@Utess_tri@CLightShadows@@@?$vector@Utess_tri@CLightShadows@@V?$xalloc@Utess_tri@CLightShadows@@@@@std@@QAEPAUtess_tri@CLightShadows@@QAU23@$$QAU23@@Z ; std::vector<CLightShadows::tess_tri,xalloc<CLightShadows::tess_tri> >::_Emplace_reallocate<CLightShadows::tess_tri>
	mov	eax, DWORD PTR _this$1$[esp+1712]
$LN364@render:

; 1611 :         return _My_data._Mylast[-1];

	mov	ecx, DWORD PTR [eax+44]
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp

; 461  : 					T.v[0]			= (*clip)[0];

	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR [ecx-48], eax
	mov	eax, DWORD PTR [edi+4]
	mov	DWORD PTR [ecx-44], eax
	mov	eax, DWORD PTR [edi+8]
	mov	DWORD PTR [ecx-40], eax

; 462  : 					T.v[1]			= (*clip)[v-1];

	mov	eax, DWORD PTR [ebx-12]
	mov	DWORD PTR [ecx-36], eax
	mov	eax, DWORD PTR [ebx-8]
	mov	DWORD PTR [ecx-32], eax
	mov	eax, DWORD PTR [ebx-4]
	mov	DWORD PTR [ecx-28], eax

; 463  : 					T.v[2]			= (*clip)[v];

	mov	eax, DWORD PTR [ebx]
	mov	DWORD PTR [ecx-24], eax
	mov	eax, DWORD PTR [ebx+4]
	mov	DWORD PTR [ecx-20], eax
	mov	eax, DWORD PTR [ebx+8]
	add	ebx, 12					; 0000000cH
	mov	DWORD PTR [ecx-16], eax

; 464  : 					T.N				= P.n;

	mov	eax, DWORD PTR _P$11[esp+1712]
	mov	DWORD PTR [ecx-12], eax
	mov	eax, DWORD PTR _P$11[esp+1716]
	mov	DWORD PTR [ecx-8], eax
	mov	eax, DWORD PTR _P$11[esp+1720]
	mov	DWORD PTR [ecx-4], eax
	mov	eax, DWORD PTR _v$1$[esp+1712]
	inc	eax
	mov	DWORD PTR _v$1$[esp+1712], eax
	cmp	eax, DWORD PTR [edi+576]
	jb	$LL13@render
$LN5@render:

; 429  : 			for (CDB::RESULT* p = xrc.r_begin(); p!=xrc.r_end(); p++)

	mov	edi, DWORD PTR _p$1$[esp+1712]
; File I:\Vitalya\mine\NSProjectX\xrCDB\xrCDB.h

; 155  : 		ICF RESULT*		r_end			()	{	return &*rd.end();			};

	lea	eax, DWORD PTR $T10[esp+1712]
	mov	ecx, DWORD PTR __My_data$1$[esp+1712]
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp

; 429  : 			for (CDB::RESULT* p = xrc.r_begin(); p!=xrc.r_end(); p++)

	add	edi, 56					; 00000038H
; File I:\Vitalya\mine\NSProjectX\xrCDB\xrCDB.h

; 155  : 		ICF RESULT*		r_end			()	{	return &*rd.end();			};

	push	eax
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp

; 429  : 			for (CDB::RESULT* p = xrc.r_begin(); p!=xrc.r_end(); p++)

	mov	DWORD PTR _p$1$[esp+1716], edi
; File I:\Vitalya\mine\NSProjectX\xrCDB\xrCDB.h

; 155  : 		ICF RESULT*		r_end			()	{	return &*rd.end();			};

	call	?end@?$vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@URESULT@CDB@@@std@@@std@@@2@XZ ; std::vector<CDB::RESULT,xalloc<CDB::RESULT> >::end
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp

; 429  : 			for (CDB::RESULT* p = xrc.r_begin(); p!=xrc.r_end(); p++)

	cmp	edi, DWORD PTR [eax]
	jne	$LL7@render
	mov	ebx, DWORD PTR _CI$1$[esp+1712]
$LN6@render:

; 465  : 				}
; 466  : 			}
; 467  : 
; 468  : 			// Remember params which builded cache item
; 469  : 			CI->O					= S.O;

	mov	edx, DWORD PTR _S$1$[esp+1712]
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [ebx], ecx

; 470  : 			CI->Op					= CI->O->renderable.xform.c;

	mov	eax, DWORD PTR [ecx+52]
	mov	DWORD PTR [ebx+4], eax
	mov	eax, DWORD PTR [ecx+56]
	mov	DWORD PTR [ebx+8], eax
	mov	eax, DWORD PTR [ecx+60]
	mov	DWORD PTR [ebx+12], eax

; 471  : 			CI->L					= S.L;

	mov	ecx, DWORD PTR [edx+84]
	mov	DWORD PTR [ebx+16], ecx

; 472  : 			CI->Lp					= CI->L->position;

	mov	eax, DWORD PTR [ecx+64]
	mov	DWORD PTR [ebx+20], eax
	mov	eax, DWORD PTR [ecx+68]
	mov	DWORD PTR [ebx+24], eax
	mov	eax, DWORD PTR [ecx+72]
	mov	DWORD PTR [ebx+28], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	eax, DWORD PTR [esi+4]
	sub	eax, DWORD PTR [esi]
	sar	eax, 4
	imul	ecx, eax, -1431655765
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp

; 473  : 			CI->tcnt				= tess.size();

	mov	DWORD PTR [ebx+40], ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	eax, DWORD PTR [ebx+36]
	test	eax, eax
	je	SHORT $LN16@render
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
	mov	DWORD PTR [ebx+36], 0
	mov	ecx, DWORD PTR [ebx+40]
$LN16@render:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	eax, DWORD PTR [esi+4]
	sub	eax, DWORD PTR [esi]
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp

; 476  : 			if (tess.size())		{

	je	SHORT $LN40@render
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	lea	eax, DWORD PTR [ecx+ecx*2]
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	shl	eax, 4
	push	eax
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp

; 479  : 				CopyMemory		(CI->tris,&*tess.begin(),CI->tcnt * sizeof(tess_tri));

	mov	ecx, DWORD PTR [ebx+40]
	mov	DWORD PTR [ebx+36], eax
	lea	ecx, DWORD PTR [ecx+ecx*2]
	shl	ecx, 4
	push	ecx
	push	DWORD PTR [esi]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN40@render:

; 480  : 			}
; 481  : 		}
; 482  : 
; 483  : 		// Fill VB
; 484  : 		for (u32 tid=0; tid<CI->tcnt; tid++)	{

	cmp	DWORD PTR [ebx+40], 0
	mov	DWORD PTR _tid$1$[esp+1712], 0
	jbe	$LN716@render
	xor	eax, eax
	xorps	xmm4, xmm4
	mov	DWORD PTR tv7204[esp+1712], eax
$LL19@render:

; 485  : 			tess_tri&	TT		= CI->tris[tid];

	mov	edi, DWORD PTR [ebx+36]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	movss	xmm2, DWORD PTR _View$[esp+1716]
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp

; 485  : 			tess_tri&	TT		= CI->tris[tid];

	add	edi, eax
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	movss	xmm0, DWORD PTR [edi+8]

; 24   : 	ICF SelfRef	set(const _vector3<float> &v)			{ x = T(v.x);	y = T(v.y);	z = T(v.z);	return *this;	};

	movss	xmm5, DWORD PTR [edi+36]
	movss	xmm3, DWORD PTR [edi+40]
	movss	xmm6, DWORD PTR [edi+44]

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	movss	xmm7, DWORD PTR [edi+4]
	movss	xmm1, DWORD PTR [edi]
	movss	DWORD PTR tv7092[esp+1712], xmm0
; File I:\Vitalya\mine\NSProjectX\xrCore\_plane.h

; 47   : 		d			= - n.set(_n).dotproduct(_p);

	movss	xmm0, DWORD PTR _View$[esp+1712]
	mulss	xmm0, xmm5
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	mulss	xmm2, xmm3
	movss	DWORD PTR tv6949[esp+1712], xmm1
	mulss	xmm1, xmm5
	addss	xmm2, xmm0

; 24   : 	ICF SelfRef	set(const _vector3<float> &v)			{ x = T(v.x);	y = T(v.y);	z = T(v.z);	return *this;	};

	movss	DWORD PTR tv6731[esp+1712], xmm5

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	movss	xmm0, DWORD PTR _View$[esp+1720]
	mulss	xmm0, xmm6

; 24   : 	ICF SelfRef	set(const _vector3<float> &v)			{ x = T(v.x);	y = T(v.y);	z = T(v.z);	return *this;	};

	movss	DWORD PTR tv6732[esp+1712], xmm6

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	movss	DWORD PTR tv6947[esp+1712], xmm7
	addss	xmm2, xmm0
	movaps	xmm0, xmm7
	mulss	xmm0, xmm3
	addss	xmm1, xmm0
	movss	xmm0, DWORD PTR tv7092[esp+1712]
	mulss	xmm0, xmm6
	addss	xmm1, xmm0
	subss	xmm2, xmm1
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp

; 490  : 			if (ttp.classify(View)<0)						continue;

	comiss	xmm4, xmm2
	ja	$LN17@render

; 491  : 			int	c0		= PLC_calc(v[0],TT.N,S.L,Le,S.C);

	mov	ecx, DWORD PTR _S$1$[esp+1712]
	mov	ebx, DWORD PTR [ecx+84]

; 137  : 	if (L->flags.type==IRender_Light::DIRECT)

	mov	eax, DWORD PTR [ebx+60]
	and	eax, 15					; 0000000fH
	mov	DWORD PTR tv7252[esp+1712], eax
	jne	SHORT $LN425@render
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	movaps	xmm0, xmm5
	movaps	xmm2, xmm3
	mulss	xmm2, DWORD PTR [ebx+80]
	mulss	xmm0, DWORD PTR [ebx+76]
	addss	xmm2, xmm0
	movaps	xmm0, xmm6
	mulss	xmm0, DWORD PTR [ebx+84]
	addss	xmm2, xmm0
	xorps	xmm2, DWORD PTR __xmm@80000000800000008000000080000000
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp

; 142  : 		if( D <=0 )						return 0;

	comiss	xmm4, xmm2
	jb	SHORT $LN427@render
	movaps	xmm2, xmm4
	jmp	$LN426@render
$LN427@render:

; 143  : 		
; 144  : 		// Trace Light
; 145  : 		float A		= D*E;

	mulss	xmm2, DWORD PTR _Le$1$[esp+1712]

; 146  : 		return A;

	jmp	$LN426@render
$LN425@render:
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 287  : 	{	return (x-v.x)*(x-v.x) + (y-v.y)*(y-v.y) + (z-v.z)*(z-v.z);	}

	movss	xmm2, DWORD PTR [ebx+68]
	movaps	xmm1, xmm7
	movss	xmm5, DWORD PTR [ebx+64]
	subss	xmm1, xmm2
	movss	xmm7, DWORD PTR tv6949[esp+1712]
	movss	xmm0, DWORD PTR tv7092[esp+1712]
	subss	xmm7, xmm5
	movss	xmm6, DWORD PTR [ebx+72]
	subss	xmm0, xmm6
	mulss	xmm1, xmm1
	mulss	xmm7, xmm7
	mulss	xmm0, xmm0
	addss	xmm7, xmm1
	addss	xmm7, xmm0
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp

; 150  : 		if (sqD > (L->range*L->range))	return 0;

	movss	xmm0, DWORD PTR [ebx+100]
	mulss	xmm0, xmm0
	comiss	xmm7, xmm0
	jbe	SHORT $LN428@render
	movaps	xmm2, xmm4
	jmp	$LN723@render
$LN428@render:
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	subss	xmm5, DWORD PTR tv6949[esp+1712]
	subss	xmm2, DWORD PTR tv6947[esp+1712]
	subss	xmm6, DWORD PTR tv7092[esp+1712]

; 200  : 		T magnitude=x*x + y*y + z*z;

	movaps	xmm0, xmm5

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movaps	xmm1, xmm2

; 200  : 		T magnitude=x*x + y*y + z*z;

	mulss	xmm0, xmm5

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	mulss	xmm1, xmm2

; 200  : 		T magnitude=x*x + y*y + z*z;

	addss	xmm1, xmm0
	movaps	xmm0, xmm6
	mulss	xmm0, xmm6
	addss	xmm1, xmm0

; 201  : 		if (magnitude> std::numeric_limits<T>::min()) {

	comiss	xmm1, DWORD PTR __real@00800000
	movss	DWORD PTR _magnitude$1$[esp+1712], xmm1
	movss	xmm1, DWORD PTR __real@3f800000
	jbe	SHORT $LN440@render

; 202  : 			magnitude=_sqrt(1/magnitude);

	movaps	xmm0, xmm1
	divss	xmm0, DWORD PTR _magnitude$1$[esp+1712]
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h

; 764  :             return (float)sqrt(_X);

	sqrtss	xmm0, xmm0
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 202  : 			magnitude=_sqrt(1/magnitude);

	mulss	xmm5, xmm0

; 203  : 			x *= magnitude;

	mulss	xmm2, xmm0

; 204  : 			y *= magnitude;

	mulss	xmm6, xmm0
$LN440@render:

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	mulss	xmm5, DWORD PTR tv6731[esp+1712]
	mulss	xmm6, DWORD PTR tv6732[esp+1712]
	mulss	xmm2, xmm3
	addss	xmm2, xmm5
	addss	xmm2, xmm6
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp

; 156  : 		if( D <=0 )						return 0;

	comiss	xmm4, xmm2
	jb	SHORT $LN429@render
	movaps	xmm2, xmm4
	jmp	SHORT $LN723@render
$LN429@render:
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h

; 764  :             return (float)sqrt(_X);

	sqrtss	xmm0, xmm7
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp

; 161  : 		float A		= D * E * att;

	mulss	xmm2, DWORD PTR _Le$1$[esp+1712]
	addss	xmm0, xmm1
	movaps	xmm1, xmm2
	divss	xmm1, xmm0
	subss	xmm2, xmm1
$LN723@render:
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 287  : 	{	return (x-v.x)*(x-v.x) + (y-v.y)*(y-v.y) + (z-v.z)*(z-v.z);	}

	movss	xmm7, DWORD PTR tv6947[esp+1712]
$LN426@render:
	mov	eax, DWORD PTR __imp_?Device@@3VCRenderDevice@@A
; File I:\Vitalya\mine\NSProjectX\xrCore\vector.h

; 96   : 	if		( val<_low	)	return _low; 

	movss	xmm5, DWORD PTR __real@3f800000
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 287  : 	{	return (x-v.x)*(x-v.x) + (y-v.y)*(y-v.y) + (z-v.z)*(z-v.z);	}

	movss	xmm1, DWORD PTR [eax+492]
	movss	xmm6, DWORD PTR [eax+488]
	movss	xmm0, DWORD PTR [eax+496]
	movss	DWORD PTR _C1$1$[esp+1712], xmm6
	subss	xmm6, DWORD PTR tv6949[esp+1712]
	movss	DWORD PTR tv6788[esp+1712], xmm1
	subss	xmm1, xmm7
	movss	DWORD PTR tv6789[esp+1712], xmm0
	subss	xmm0, DWORD PTR tv7092[esp+1712]
	mulss	xmm6, xmm6
	mulss	xmm1, xmm1
	mulss	xmm0, xmm0
	addss	xmm6, xmm1
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp

; 169  : 	float	C1		= clampr(Device.vCameraPosition.distance_to_sqr(P)/S_distance2,	0.f,1.f);

	addss	xmm6, xmm0
	mulss	xmm6, DWORD PTR __real@39e38e39
; File I:\Vitalya\mine\NSProjectX\xrCore\vector.h

; 96   : 	if		( val<_low	)	return _low; 

	comiss	xmm4, xmm6
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp

; 169  : 	float	C1		= clampr(Device.vCameraPosition.distance_to_sqr(P)/S_distance2,	0.f,1.f);

	movss	DWORD PTR _C1$1$[esp+1712], xmm6
; File I:\Vitalya\mine\NSProjectX\xrCore\vector.h

; 96   : 	if		( val<_low	)	return _low; 

	jbe	SHORT $LN457@render
	movss	DWORD PTR _C1$1$[esp+1712], xmm4
	jmp	SHORT $LN459@render
$LN457@render:

; 97   : 	else if	( val>_high )	return _high;

	comiss	xmm6, xmm5
	jbe	SHORT $LN459@render
	movss	DWORD PTR _C1$1$[esp+1712], xmm5
$LN459@render:
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 287  : 	{	return (x-v.x)*(x-v.x) + (y-v.y)*(y-v.y) + (z-v.z)*(z-v.z);	}

	movss	xmm1, DWORD PTR [ecx+12]
	movss	xmm6, DWORD PTR [ecx+8]
	movss	xmm0, DWORD PTR [ecx+16]
	movss	DWORD PTR tv6799[esp+1712], xmm1
	subss	xmm1, xmm7
	movaps	xmm7, xmm6
	movss	DWORD PTR tv6800[esp+1712], xmm0
	subss	xmm7, DWORD PTR tv6949[esp+1712]
	subss	xmm0, DWORD PTR tv7092[esp+1712]
	mulss	xmm1, xmm1
	mulss	xmm7, xmm7
	mulss	xmm0, xmm0
	addss	xmm7, xmm1
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp

; 170  : 	float	C2		= clampr(O.distance_to_sqr(P)/S_fade2,							0.f,1.f);

	addss	xmm7, xmm0
	mulss	xmm7, DWORD PTR __real@3d4a4588
; File I:\Vitalya\mine\NSProjectX\xrCore\vector.h

; 96   : 	if		( val<_low	)	return _low; 

	comiss	xmm4, xmm7
	jbe	SHORT $LN465@render
	movaps	xmm7, xmm4
	jmp	SHORT $LN467@render
$LN465@render:

; 97   : 	else if	( val>_high )	return _high;

	comiss	xmm7, xmm5
	jbe	SHORT $LN467@render
	movaps	xmm7, xmm5
$LN467@render:
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp

; 172  : 	return			iCeil(255.f*A);

	mulss	xmm2, DWORD PTR __real@43bf4000
	movaps	xmm0, xmm5
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h

; 105  :     int exponent	= (127 + 31) - ((a >> 23) & 0xFF);

	mov	ecx, 158				; 0000009eH
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp

; 171  : 	float	A		= 1.f-1.5f*E*(1.f-C1)*(1.f-C2);

	subss	xmm0, DWORD PTR _C1$1$[esp+1712]
	movaps	xmm1, xmm5
	subss	xmm1, xmm7

; 172  : 	return			iCeil(255.f*A);

	mulss	xmm1, xmm0
	movss	xmm0, DWORD PTR __real@437f0000
	mulss	xmm1, xmm2
	subss	xmm0, xmm1
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h

; 104  :     int a			= (*(const int*)(&x));

	movss	DWORD PTR _a$7[esp+1712], xmm0

; 105  :     int exponent	= (127 + 31) - ((a >> 23) & 0xFF);

	mov	esi, DWORD PTR _a$7[esp+1712]
	mov	eax, esi
	sar	eax, 23					; 00000017H
	movzx	eax, al
	sub	ecx, eax

; 106  :     int r			= (((u32)(a) << 8) | (1U << 31)) >> exponent;

	mov	eax, esi
	or	eax, -8388608				; ff800000H

; 112  :         a			=	~((a-1)>>31);		/* change sign */

	lea	edx, DWORD PTR [esi-1]
	shl	eax, 8
	shr	eax, cl
	sub	ecx, 96					; 00000060H
	mov	DWORD PTR _c0$2$[esp+1712], eax
	mov	eax, 1
	shl	eax, cl
	dec	eax
	sar	edx, 31					; 0000001fH
	sar	eax, 8
	not	edx
	and	eax, esi

; 113  :         r			-=	(imask&a);

	mov	esi, DWORD PTR _c0$2$[esp+1712]
	neg	eax
	sbb	eax, eax
	inc	eax
	and	eax, edx
	sub	esi, eax
	lea	eax, DWORD PTR [ecx+64]
	sar	eax, 31					; 0000001fH

; 114  :         r			&=	exponent;

	and	esi, eax
	xor	esi, edx

; 116  :         r			=	-r;                 /* change sign */

	neg	esi
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp

; 137  : 	if (L->flags.type==IRender_Light::DIRECT)

	cmp	DWORD PTR tv7252[esp+1712], 0
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h

; 116  :         r			=	-r;                 /* change sign */

	mov	DWORD PTR _c0$2$[esp+1712], esi
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp

; 137  : 	if (L->flags.type==IRender_Light::DIRECT)

	jne	SHORT $LN475@render
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	movss	xmm0, DWORD PTR tv6731[esp+1712]
	mulss	xmm3, DWORD PTR [ebx+80]
	mulss	xmm0, DWORD PTR [ebx+76]
	addss	xmm3, xmm0
	movss	xmm0, DWORD PTR tv6732[esp+1712]
	mulss	xmm0, DWORD PTR [ebx+84]
	addss	xmm3, xmm0
	xorps	xmm3, DWORD PTR __xmm@80000000800000008000000080000000
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp

; 142  : 		if( D <=0 )						return 0;

	comiss	xmm4, xmm3
	jb	SHORT $LN477@render
	movaps	xmm3, xmm4
	jmp	$LN476@render
$LN477@render:

; 143  : 		
; 144  : 		// Trace Light
; 145  : 		float A		= D*E;

	mulss	xmm3, DWORD PTR _Le$1$[esp+1712]

; 146  : 		return A;

	jmp	$LN476@render
$LN475@render:
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 287  : 	{	return (x-v.x)*(x-v.x) + (y-v.y)*(y-v.y) + (z-v.z)*(z-v.z);	}

	movss	xmm0, DWORD PTR [edi+12]
	movss	xmm2, DWORD PTR [ebx+64]
	movss	xmm1, DWORD PTR [edi+16]
	subss	xmm0, xmm2
	movss	xmm3, DWORD PTR [ebx+68]
	movss	xmm7, DWORD PTR [ebx+72]
	subss	xmm1, xmm3
	movss	DWORD PTR _sqD$1$[esp+1712], xmm0
	movss	xmm4, DWORD PTR _sqD$1$[esp+1712]
	movss	xmm0, DWORD PTR [edi+20]
	mulss	xmm4, xmm4
	subss	xmm0, xmm7
	mulss	xmm1, xmm1
	mulss	xmm0, xmm0
	addss	xmm4, xmm1
	movaps	xmm1, xmm4
	movss	DWORD PTR _sqD$1$[esp+1712], xmm4
	addss	xmm1, xmm0
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp

; 150  : 		if (sqD > (L->range*L->range))	return 0;

	xorps	xmm4, xmm4
	movss	xmm0, DWORD PTR [ebx+100]
	mulss	xmm0, xmm0
	comiss	xmm1, xmm0
	jbe	SHORT $LN478@render
	movaps	xmm3, xmm4
	jmp	$LN476@render
$LN478@render:
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	subss	xmm3, DWORD PTR [edi+16]
	subss	xmm2, DWORD PTR [edi+12]
	subss	xmm7, DWORD PTR [edi+20]
	movaps	xmm0, xmm3
	mulss	xmm0, xmm3
	movss	DWORD PTR _magnitude$1$[esp+1712], xmm0

; 200  : 		T magnitude=x*x + y*y + z*z;

	movaps	xmm0, xmm2
	movss	xmm4, DWORD PTR _magnitude$1$[esp+1712]
	mulss	xmm0, xmm2
	addss	xmm4, xmm0
	movaps	xmm0, xmm7
	mulss	xmm0, xmm7
	addss	xmm4, xmm0

; 201  : 		if (magnitude> std::numeric_limits<T>::min()) {

	movaps	xmm0, xmm4
	movss	DWORD PTR _magnitude$1$[esp+1712], xmm4
	comiss	xmm0, DWORD PTR __real@00800000
	xorps	xmm4, xmm4
	jbe	SHORT $LN490@render

; 202  : 			magnitude=_sqrt(1/magnitude);

	movaps	xmm0, xmm5
	divss	xmm0, DWORD PTR _magnitude$1$[esp+1712]
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h

; 764  :             return (float)sqrt(_X);

	sqrtss	xmm0, xmm0
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 202  : 			magnitude=_sqrt(1/magnitude);

	mulss	xmm2, xmm0

; 203  : 			x *= magnitude;

	mulss	xmm3, xmm0

; 204  : 			y *= magnitude;

	mulss	xmm7, xmm0
$LN490@render:

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	mulss	xmm3, DWORD PTR [edi+40]
	mulss	xmm2, DWORD PTR [edi+36]
	mulss	xmm7, DWORD PTR [edi+44]
	addss	xmm3, xmm2
	addss	xmm3, xmm7
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp

; 156  : 		if( D <=0 )						return 0;

	comiss	xmm4, xmm3
	jb	SHORT $LN479@render
	movaps	xmm3, xmm4
	jmp	SHORT $LN476@render
$LN479@render:
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h

; 764  :             return (float)sqrt(_X);

	sqrtss	xmm0, xmm1
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp

; 161  : 		float A		= D * E * att;

	mulss	xmm3, DWORD PTR _Le$1$[esp+1712]
	addss	xmm0, xmm5
	movaps	xmm1, xmm3
	divss	xmm1, xmm0
	subss	xmm3, xmm1
$LN476@render:
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 287  : 	{	return (x-v.x)*(x-v.x) + (y-v.y)*(y-v.y) + (z-v.z)*(z-v.z);	}

	movss	xmm7, DWORD PTR [edi+16]
	movss	xmm1, DWORD PTR tv6788[esp+1712]
	movss	xmm0, DWORD PTR _C1$1$[esp+1712]
	subss	xmm1, xmm7
	subss	xmm0, DWORD PTR [edi+12]
	movss	xmm2, DWORD PTR tv6789[esp+1712]
	subss	xmm2, DWORD PTR [edi+20]
	mulss	xmm1, xmm1
	mulss	xmm0, xmm0
	mulss	xmm2, xmm2
	addss	xmm0, xmm1
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp

; 169  : 	float	C1		= clampr(Device.vCameraPosition.distance_to_sqr(P)/S_distance2,	0.f,1.f);

	addss	xmm0, xmm2
	mulss	xmm0, DWORD PTR __real@39e38e39
; File I:\Vitalya\mine\NSProjectX\xrCore\vector.h

; 96   : 	if		( val<_low	)	return _low; 

	comiss	xmm4, xmm0
	jbe	SHORT $LN507@render
	movaps	xmm0, xmm4
	jmp	SHORT $LN509@render
$LN507@render:

; 97   : 	else if	( val>_high )	return _high;

	comiss	xmm0, xmm5
	jbe	SHORT $LN509@render
	movaps	xmm0, xmm5
$LN509@render:
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 287  : 	{	return (x-v.x)*(x-v.x) + (y-v.y)*(y-v.y) + (z-v.z)*(z-v.z);	}

	subss	xmm6, DWORD PTR [edi+12]
	movss	xmm1, DWORD PTR tv6799[esp+1712]
	movss	xmm2, DWORD PTR tv6800[esp+1712]
	subss	xmm1, xmm7
	subss	xmm2, DWORD PTR [edi+20]
	mulss	xmm6, xmm6
	mulss	xmm1, xmm1
	mulss	xmm2, xmm2
	addss	xmm6, xmm1
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp

; 170  : 	float	C2		= clampr(O.distance_to_sqr(P)/S_fade2,							0.f,1.f);

	addss	xmm6, xmm2
	mulss	xmm6, DWORD PTR __real@3d4a4588
; File I:\Vitalya\mine\NSProjectX\xrCore\vector.h

; 96   : 	if		( val<_low	)	return _low; 

	comiss	xmm4, xmm6
	jbe	SHORT $LN515@render
	movaps	xmm6, xmm4
	jmp	SHORT $LN517@render
$LN515@render:

; 97   : 	else if	( val>_high )	return _high;

	comiss	xmm6, xmm5
	jbe	SHORT $LN517@render
	movaps	xmm6, xmm5
$LN517@render:
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp

; 172  : 	return			iCeil(255.f*A);

	mulss	xmm3, DWORD PTR __real@43bf4000
	movaps	xmm1, xmm5
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h

; 105  :     int exponent	= (127 + 31) - ((a >> 23) & 0xFF);

	mov	ecx, 158				; 0000009eH
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp

; 171  : 	float	A		= 1.f-1.5f*E*(1.f-C1)*(1.f-C2);

	subss	xmm1, xmm0
	movaps	xmm0, xmm5
	subss	xmm0, xmm6

; 172  : 	return			iCeil(255.f*A);

	mulss	xmm1, xmm0
	movss	xmm0, DWORD PTR __real@437f0000
	mulss	xmm1, xmm3
	subss	xmm0, xmm1
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h

; 104  :     int a			= (*(const int*)(&x));

	movss	DWORD PTR _a$9[esp+1712], xmm0

; 105  :     int exponent	= (127 + 31) - ((a >> 23) & 0xFF);

	mov	esi, DWORD PTR _a$9[esp+1712]
	mov	eax, esi
	sar	eax, 23					; 00000017H
	movzx	eax, al
	sub	ecx, eax

; 106  :     int r			= (((u32)(a) << 8) | (1U << 31)) >> exponent;

	mov	eax, esi
	or	eax, -8388608				; ff800000H

; 112  :         a			=	~((a-1)>>31);		/* change sign */

	lea	edx, DWORD PTR [esi-1]
	shl	eax, 8
	shr	eax, cl
	sub	ecx, 96					; 00000060H
	mov	DWORD PTR _c1$2$[esp+1712], eax
	mov	eax, 1
	shl	eax, cl
	dec	eax
	sar	edx, 31					; 0000001fH
	sar	eax, 8
	not	edx
	and	eax, esi

; 113  :         r			-=	(imask&a);

	mov	esi, DWORD PTR _c1$2$[esp+1712]
	neg	eax
	sbb	eax, eax
	inc	eax
	and	eax, edx
	sub	esi, eax
	lea	eax, DWORD PTR [ecx+64]
	sar	eax, 31					; 0000001fH

; 114  :         r			&=	exponent;

	and	esi, eax
	xor	esi, edx

; 116  :         r			=	-r;                 /* change sign */

	neg	esi
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp

; 137  : 	if (L->flags.type==IRender_Light::DIRECT)

	test	BYTE PTR [ebx+60], 15			; 0000000fH
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h

; 116  :         r			=	-r;                 /* change sign */

	mov	DWORD PTR _c1$2$[esp+1712], esi
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp

; 137  : 	if (L->flags.type==IRender_Light::DIRECT)

	jne	SHORT $LN525@render
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	movss	xmm0, DWORD PTR [ebx+76]
	movss	xmm2, DWORD PTR [ebx+80]
	mulss	xmm2, DWORD PTR [edi+40]
	mulss	xmm0, DWORD PTR [edi+36]
	addss	xmm2, xmm0
	movss	xmm0, DWORD PTR [ebx+84]
	mulss	xmm0, DWORD PTR [edi+44]
	addss	xmm2, xmm0
	xorps	xmm2, DWORD PTR __xmm@80000000800000008000000080000000
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp

; 142  : 		if( D <=0 )						return 0;

	comiss	xmm4, xmm2
	jb	SHORT $LN527@render
	movaps	xmm2, xmm4
	jmp	$LN526@render
$LN527@render:

; 143  : 		
; 144  : 		// Trace Light
; 145  : 		float A		= D*E;

	mulss	xmm2, DWORD PTR _Le$1$[esp+1712]

; 146  : 		return A;

	jmp	$LN526@render
$LN525@render:
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 287  : 	{	return (x-v.x)*(x-v.x) + (y-v.y)*(y-v.y) + (z-v.z)*(z-v.z);	}

	movss	xmm2, DWORD PTR [ebx+68]
	movss	xmm1, DWORD PTR [edi+28]
	movss	xmm3, DWORD PTR [ebx+64]
	subss	xmm1, xmm2
	movss	xmm7, DWORD PTR [edi+24]
	movss	xmm0, DWORD PTR [edi+32]
	subss	xmm7, xmm3
	movss	xmm6, DWORD PTR [ebx+72]
	subss	xmm0, xmm6
	mulss	xmm1, xmm1
	mulss	xmm7, xmm7
	mulss	xmm0, xmm0
	addss	xmm7, xmm1
	addss	xmm7, xmm0
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp

; 150  : 		if (sqD > (L->range*L->range))	return 0;

	movss	xmm0, DWORD PTR [ebx+100]
	mulss	xmm0, xmm0
	comiss	xmm7, xmm0
	jbe	SHORT $LN528@render
	movaps	xmm2, xmm4
	jmp	$LN526@render
$LN528@render:
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	subss	xmm3, DWORD PTR [edi+24]
	subss	xmm2, DWORD PTR [edi+28]
	subss	xmm6, DWORD PTR [edi+32]

; 200  : 		T magnitude=x*x + y*y + z*z;

	movaps	xmm0, xmm3

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movaps	xmm1, xmm2

; 200  : 		T magnitude=x*x + y*y + z*z;

	mulss	xmm0, xmm3

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	mulss	xmm1, xmm2

; 200  : 		T magnitude=x*x + y*y + z*z;

	addss	xmm1, xmm0
	movaps	xmm0, xmm6
	mulss	xmm0, xmm6
	addss	xmm1, xmm0

; 201  : 		if (magnitude> std::numeric_limits<T>::min()) {

	comiss	xmm1, DWORD PTR __real@00800000
	jbe	SHORT $LN540@render

; 202  : 			magnitude=_sqrt(1/magnitude);

	movaps	xmm0, xmm5
	divss	xmm0, xmm1
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h

; 764  :             return (float)sqrt(_X);

	sqrtss	xmm1, xmm0
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 202  : 			magnitude=_sqrt(1/magnitude);

	movaps	xmm0, xmm1

; 204  : 			y *= magnitude;

	mulss	xmm6, xmm1
	mulss	xmm3, xmm0
	mulss	xmm2, xmm0
$LN540@render:

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	mulss	xmm2, DWORD PTR [edi+40]
	mulss	xmm3, DWORD PTR [edi+36]
	mulss	xmm6, DWORD PTR [edi+44]
	addss	xmm2, xmm3
	addss	xmm2, xmm6
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp

; 156  : 		if( D <=0 )						return 0;

	comiss	xmm4, xmm2
	jb	SHORT $LN529@render
	movaps	xmm2, xmm4
	jmp	SHORT $LN526@render
$LN529@render:
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h

; 764  :             return (float)sqrt(_X);

	sqrtss	xmm0, xmm7
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp

; 161  : 		float A		= D * E * att;

	mulss	xmm2, DWORD PTR _Le$1$[esp+1712]
	addss	xmm0, xmm5
	movaps	xmm1, xmm2
	divss	xmm1, xmm0
	subss	xmm2, xmm1
$LN526@render:
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 287  : 	{	return (x-v.x)*(x-v.x) + (y-v.y)*(y-v.y) + (z-v.z)*(z-v.z);	}

	mov	eax, DWORD PTR __imp_?Device@@3VCRenderDevice@@A
	movss	xmm3, DWORD PTR [edi+28]
	movss	xmm7, DWORD PTR [edi+24]
	movss	xmm1, DWORD PTR [eax+492]
	movss	xmm6, DWORD PTR [eax+488]
	subss	xmm1, xmm3
	movss	xmm0, DWORD PTR [eax+496]
	subss	xmm6, xmm7
	subss	xmm0, DWORD PTR [edi+32]
	mulss	xmm1, xmm1
	mulss	xmm6, xmm6
	mulss	xmm0, xmm0
	addss	xmm6, xmm1
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp

; 169  : 	float	C1		= clampr(Device.vCameraPosition.distance_to_sqr(P)/S_distance2,	0.f,1.f);

	addss	xmm6, xmm0
	mulss	xmm6, DWORD PTR __real@39e38e39
; File I:\Vitalya\mine\NSProjectX\xrCore\vector.h

; 96   : 	if		( val<_low	)	return _low; 

	comiss	xmm4, xmm6
	jbe	SHORT $LN557@render
	movaps	xmm6, xmm4
	jmp	SHORT $LN559@render
$LN557@render:

; 97   : 	else if	( val>_high )	return _high;

	comiss	xmm6, xmm5
	jbe	SHORT $LN559@render
	movaps	xmm6, xmm5
$LN559@render:
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 287  : 	{	return (x-v.x)*(x-v.x) + (y-v.y)*(y-v.y) + (z-v.z)*(z-v.z);	}

	mov	eax, DWORD PTR _S$1$[esp+1712]
	movss	xmm1, DWORD PTR [eax+12]
	movss	xmm0, DWORD PTR [eax+16]
	subss	xmm1, xmm3
	movss	xmm3, DWORD PTR [eax+8]
	subss	xmm0, DWORD PTR [edi+32]
	subss	xmm3, xmm7
	mulss	xmm1, xmm1
	mulss	xmm0, xmm0
	mulss	xmm3, xmm3
	addss	xmm3, xmm1
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp

; 170  : 	float	C2		= clampr(O.distance_to_sqr(P)/S_fade2,							0.f,1.f);

	addss	xmm3, xmm0
	mulss	xmm3, DWORD PTR __real@3d4a4588
; File I:\Vitalya\mine\NSProjectX\xrCore\vector.h

; 96   : 	if		( val<_low	)	return _low; 

	comiss	xmm4, xmm3
	jbe	SHORT $LN565@render
	movaps	xmm3, xmm4
	jmp	SHORT $LN567@render
$LN565@render:

; 97   : 	else if	( val>_high )	return _high;

	comiss	xmm3, xmm5
	jbe	SHORT $LN567@render
	movaps	xmm3, xmm5
$LN567@render:
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp

; 171  : 	float	A		= 1.f-1.5f*E*(1.f-C1)*(1.f-C2);

	movaps	xmm0, xmm5
	movaps	xmm1, xmm5
	subss	xmm0, xmm3
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h

; 105  :     int exponent	= (127 + 31) - ((a >> 23) & 0xFF);

	mov	ecx, 158				; 0000009eH
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp

; 171  : 	float	A		= 1.f-1.5f*E*(1.f-C1)*(1.f-C2);

	subss	xmm1, xmm6

; 172  : 	return			iCeil(255.f*A);

	mulss	xmm0, DWORD PTR __real@43bf4000
	mulss	xmm1, xmm2
	mulss	xmm1, xmm0
	movss	xmm0, DWORD PTR __real@437f0000
	subss	xmm0, xmm1
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h

; 104  :     int a			= (*(const int*)(&x));

	movss	DWORD PTR _a$8[esp+1712], xmm0

; 105  :     int exponent	= (127 + 31) - ((a >> 23) & 0xFF);

	mov	esi, DWORD PTR _a$8[esp+1712]
	mov	eax, esi
	sar	eax, 23					; 00000017H

; 106  :     int r			= (((u32)(a) << 8) | (1U << 31)) >> exponent;

	mov	ebx, esi
	movzx	eax, al
	or	ebx, -8388608				; ff800000H
	sub	ecx, eax
	shl	ebx, 8
	shr	ebx, cl

; 112  :         a			=	~((a-1)>>31);		/* change sign */

	lea	edx, DWORD PTR [esi-1]
	sub	ecx, 96					; 00000060H
	sar	edx, 31					; 0000001fH
	mov	eax, 1
	not	edx
	shl	eax, cl
	dec	eax
	sar	eax, 8
	and	eax, esi
	neg	eax
	sbb	eax, eax
	inc	eax
	and	eax, edx

; 113  :         r			-=	(imask&a);

	sub	ebx, eax
	lea	eax, DWORD PTR [ecx+64]
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp

; 494  : 			if (c0>S_clip && c1>S_clip && c2>S_clip)		continue;	

	mov	ecx, DWORD PTR _c1$2$[esp+1712]
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h

; 111  :         exponent	>>=	31;

	sar	eax, 31					; 0000001fH

; 114  :         r			&=	exponent;

	and	ebx, eax
	xor	ebx, edx
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp

; 494  : 			if (c0>S_clip && c1>S_clip && c2>S_clip)		continue;	

	mov	edx, DWORD PTR _c0$2$[esp+1712]
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h

; 116  :         r			=	-r;                 /* change sign */

	neg	ebx
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp

; 494  : 			if (c0>S_clip && c1>S_clip && c2>S_clip)		continue;	

	cmp	edx, 248				; 000000f8H
	jle	SHORT $LN42@render
	cmp	ecx, 248				; 000000f8H
	jle	SHORT $LN573@render
	cmp	ebx, 248				; 000000f8H
	jg	$LN722@render
$LN42@render:
; File I:\Vitalya\mine\NSProjectX\xrCore\vector.h

; 92   : 	if( val<_low ) val = _low; else if( val>_high ) val = _high;

	cmp	edx, 32					; 00000020H
	jge	SHORT $LN573@render
	mov	edx, 32					; 00000020H
	mov	eax, 255				; 000000ffH
	jmp	SHORT $LN575@render
$LN573@render:
	cmp	edx, 255				; 000000ffH
	mov	eax, 255				; 000000ffH
	cmovg	edx, eax
$LN575@render:
	cmp	ecx, 32					; 00000020H
	jge	SHORT $LN578@render
	mov	ecx, 32					; 00000020H
	jmp	SHORT $LN580@render
$LN578@render:
	cmp	ecx, 255				; 000000ffH
	cmovg	ecx, eax
$LN580@render:
	cmp	ebx, 32					; 00000020H
	jge	SHORT $LN583@render
	mov	ebx, 32					; 00000020H
	jmp	SHORT $LN585@render
$LN583@render:
	cmp	ebx, 255				; 000000ffH
	cmovg	ebx, eax
$LN585@render:
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 529  : 		T iw	= 1.f/(v.x*_14 + v.y*_24 + v.z*_34 + _44);

	mov	esi, DWORD PTR _S$1$[esp+1712]
	movss	xmm1, DWORD PTR tv6949[esp+1712]
	movss	xmm0, DWORD PTR tv6947[esp+1712]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 24   : 	ICF SelfRef	set(const _vector3<float> &v)			{ x = T(v.x);	y = T(v.y);	z = T(v.z);	return *this;	};

	mov	eax, DWORD PTR _pv$1$[esp+1712]
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 529  : 		T iw	= 1.f/(v.x*_14 + v.y*_24 + v.z*_34 + _44);

	mulss	xmm0, DWORD PTR [esi+48]
	mulss	xmm1, DWORD PTR [esi+32]

; 530  : 		dest.x	= (v.x*_11 + v.y*_21 + v.z*_31 + _41)*iw;

	movss	xmm2, DWORD PTR [esi+52]
	movss	xmm7, DWORD PTR [esi+20]
	addss	xmm1, xmm0
	mulss	xmm2, DWORD PTR tv7092[esp+1712]
	movss	xmm0, DWORD PTR tv7092[esp+1712]
	mulss	xmm0, DWORD PTR [esi+64]

; 531  : 		dest.y	= (v.x*_12 + v.y*_22 + v.z*_32 + _42)*iw;

	movss	xmm3, DWORD PTR [esi+24]
	movss	xmm6, DWORD PTR [esi+56]
	addss	xmm0, DWORD PTR [esi+80]
	movss	xmm4, DWORD PTR [esi+72]
	mulss	xmm6, DWORD PTR tv7092[esp+1712]
	addss	xmm1, xmm0
	movaps	xmm0, xmm5
	movss	xmm5, DWORD PTR [esi+40]
	addss	xmm6, xmm4
	movss	DWORD PTR tv7175[esp+1712], xmm5
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 24   : 	ICF SelfRef	set(const _vector3<float> &v)			{ x = T(v.x);	y = T(v.y);	z = T(v.z);	return *this;	};

	movss	xmm5, DWORD PTR tv6949[esp+1712]
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 530  : 		dest.x	= (v.x*_11 + v.y*_21 + v.z*_31 + _41)*iw;

	mulss	xmm7, xmm5
	divss	xmm0, xmm1
	movss	xmm1, DWORD PTR [esi+36]
	mulss	xmm1, DWORD PTR tv6947[esp+1712]
	movss	DWORD PTR _iw$1$[esp+1712], xmm0
	movss	xmm0, DWORD PTR [esi+68]
	addss	xmm2, xmm0
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 24   : 	ICF SelfRef	set(const _vector3<float> &v)			{ x = T(v.x);	y = T(v.y);	z = T(v.z);	return *this;	};

	movss	DWORD PTR [eax], xmm5
	fld	DWORD PTR [edi+4]
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 530  : 		dest.x	= (v.x*_11 + v.y*_21 + v.z*_31 + _41)*iw;

	addss	xmm7, xmm1
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector2.h

; 15   : 	IC SelfRef set(float _u, float _v)				{ x=T(_u); y=T(_v);				return *this;	}

	movss	xmm0, DWORD PTR __real@3f800000
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 24   : 	ICF SelfRef	set(const _vector3<float> &v)			{ x = T(v.x);	y = T(v.y);	z = T(v.z);	return *this;	};

	fstp	DWORD PTR [eax+4]
	fld	DWORD PTR [edi+8]
	fstp	DWORD PTR [eax+8]
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 530  : 		dest.x	= (v.x*_11 + v.y*_21 + v.z*_31 + _41)*iw;

	addss	xmm7, xmm2
; File I:\Vitalya\mine\NSProjectX\xrCore\_color.h

; 5    : ICF u32	color_argb	(u32 a, u32 r, u32 g, u32 b)	{	return ((a&0xff)<<24)|((r&0xff)<<16)|((g&0xff)<<8)|(b&0xff);	}

	movzx	eax, dl
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 531  : 		dest.y	= (v.x*_12 + v.y*_22 + v.z*_32 + _42)*iw;

	movaps	xmm2, xmm5
; File I:\Vitalya\mine\NSProjectX\xrCore\_color.h

; 5    : ICF u32	color_argb	(u32 a, u32 r, u32 g, u32 b)	{	return ((a&0xff)<<24)|((r&0xff)<<16)|((g&0xff)<<8)|(b&0xff);	}

	shl	edx, 8
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 531  : 		dest.y	= (v.x*_12 + v.y*_22 + v.z*_32 + _42)*iw;

	mulss	xmm2, xmm3
; File I:\Vitalya\mine\NSProjectX\xrCore\_color.h

; 5    : ICF u32	color_argb	(u32 a, u32 r, u32 g, u32 b)	{	return ((a&0xff)<<24)|((r&0xff)<<16)|((g&0xff)<<8)|(b&0xff);	}

	or	edx, eax
	shl	edx, 8
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 531  : 		dest.y	= (v.x*_12 + v.y*_22 + v.z*_32 + _42)*iw;

	movss	xmm3, DWORD PTR tv6947[esp+1712]
; File I:\Vitalya\mine\NSProjectX\xrCore\_color.h

; 5    : ICF u32	color_argb	(u32 a, u32 r, u32 g, u32 b)	{	return ((a&0xff)<<24)|((r&0xff)<<16)|((g&0xff)<<8)|(b&0xff);	}

	or	edx, eax
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 531  : 		dest.y	= (v.x*_12 + v.y*_22 + v.z*_32 + _42)*iw;

	mulss	xmm3, DWORD PTR tv7175[esp+1712]
; File I:\Vitalya\mine\NSProjectX\xrCore\_color.h

; 5    : ICF u32	color_argb	(u32 a, u32 r, u32 g, u32 b)	{	return ((a&0xff)<<24)|((r&0xff)<<16)|((g&0xff)<<8)|(b&0xff);	}

	shl	edx, 8
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 530  : 		dest.x	= (v.x*_11 + v.y*_21 + v.z*_31 + _41)*iw;

	mulss	xmm7, DWORD PTR _iw$1$[esp+1712]
; File I:\Vitalya\mine\NSProjectX\xrCore\_color.h

; 5    : ICF u32	color_argb	(u32 a, u32 r, u32 g, u32 b)	{	return ((a&0xff)<<24)|((r&0xff)<<16)|((g&0xff)<<8)|(b&0xff);	}

	or	edx, eax
; File I:\Vitalya\mine\NSProjectX\xrEngine\fvf.h

; 32   : 		IC void		set(const Fvector& _p, u32 C, float u, float v) { p.set(_p); color = C; t.set(u, v); }

	mov	eax, DWORD PTR _pv$1$[esp+1712]
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 531  : 		dest.y	= (v.x*_12 + v.y*_22 + v.z*_32 + _42)*iw;

	addss	xmm2, xmm3
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp

; 499  : 			S.M.transform(T,v[0]); pv->set(v[0],CLS(c0),(T.x+1)*t_scale.x+t_offset.x,(1-T.y)*t_scale.y+t_offset.y); pv++;

	addss	xmm7, DWORD PTR __real@3f800000
; File I:\Vitalya\mine\NSProjectX\xrEngine\fvf.h

; 32   : 		IC void		set(const Fvector& _p, u32 C, float u, float v) { p.set(_p); color = C; t.set(u, v); }

	mov	DWORD PTR [eax+12], edx
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector2.h

; 15   : 	IC SelfRef set(float _u, float _v)				{ x=T(_u); y=T(_v);				return *this;	}

	mov	edx, eax
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 531  : 		dest.y	= (v.x*_12 + v.y*_22 + v.z*_32 + _42)*iw;

	addss	xmm2, xmm6
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp

; 499  : 			S.M.transform(T,v[0]); pv->set(v[0],CLS(c0),(T.x+1)*t_scale.x+t_offset.x,(1-T.y)*t_scale.y+t_offset.y); pv++;

	mulss	xmm7, DWORD PTR __real@3daa0000
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 531  : 		dest.y	= (v.x*_12 + v.y*_22 + v.z*_32 + _42)*iw;

	mulss	xmm2, DWORD PTR _iw$1$[esp+1712]
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp

; 499  : 			S.M.transform(T,v[0]); pv->set(v[0],CLS(c0),(T.x+1)*t_scale.x+t_offset.x,(1-T.y)*t_scale.y+t_offset.y); pv++;

	addss	xmm7, DWORD PTR _t_offset$2$sroa$3657$1$[esp+1712]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector2.h

; 15   : 	IC SelfRef set(float _u, float _v)				{ x=T(_u); y=T(_v);				return *this;	}

	subss	xmm0, xmm2
	movss	DWORD PTR [edx+16], xmm7
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp

; 499  : 			S.M.transform(T,v[0]); pv->set(v[0],CLS(c0),(T.x+1)*t_scale.x+t_offset.x,(1-T.y)*t_scale.y+t_offset.y); pv++;

	mulss	xmm0, DWORD PTR __real@3daa0000
	addss	xmm0, DWORD PTR _t_offset$2$sroa$3658$1$[esp+1712]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector2.h

; 15   : 	IC SelfRef set(float _u, float _v)				{ x=T(_u); y=T(_v);				return *this;	}

	movss	DWORD PTR [edx+20], xmm0
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 529  : 		T iw	= 1.f/(v.x*_14 + v.y*_24 + v.z*_34 + _44);

	movss	xmm0, DWORD PTR [edi+16]
	movss	xmm1, DWORD PTR [edi+12]
	movss	xmm2, DWORD PTR [edi+20]
	movss	DWORD PTR tv6977[esp+1712], xmm0
	mulss	xmm0, DWORD PTR [esi+48]
	movss	DWORD PTR tv6979[esp+1712], xmm1
	mulss	xmm1, DWORD PTR [esi+32]
	movss	DWORD PTR tv6978[esp+1712], xmm2
	addss	xmm1, xmm0
	movaps	xmm0, xmm2
	mulss	xmm0, DWORD PTR [esi+64]
	addss	xmm0, DWORD PTR [esi+80]
	addss	xmm1, xmm0
	movss	xmm0, DWORD PTR __real@3f800000
	divss	xmm0, xmm1
	movss	DWORD PTR _iw$1$[esp+1712], xmm0

; 530  : 		dest.x	= (v.x*_11 + v.y*_21 + v.z*_31 + _41)*iw;

	movss	xmm0, DWORD PTR [esi+36]

; 531  : 		dest.y	= (v.x*_12 + v.y*_22 + v.z*_32 + _42)*iw;

	movss	xmm1, DWORD PTR [esi+40]
	movss	xmm4, DWORD PTR [esi+20]
	movss	xmm3, DWORD PTR [esi+52]
	movss	xmm2, DWORD PTR [esi+68]
	movss	xmm5, DWORD PTR [esi+24]
	movss	xmm7, DWORD PTR [esi+56]
	movss	xmm6, DWORD PTR [esi+72]
	mulss	xmm4, DWORD PTR tv6979[esp+1712]
; File I:\Vitalya\mine\NSProjectX\xrCore\_color.h

; 5    : ICF u32	color_argb	(u32 a, u32 r, u32 g, u32 b)	{	return ((a&0xff)<<24)|((r&0xff)<<16)|((g&0xff)<<8)|(b&0xff);	}

	movzx	eax, cl
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 531  : 		dest.y	= (v.x*_12 + v.y*_22 + v.z*_32 + _42)*iw;

	movss	DWORD PTR tv7187[esp+1712], xmm1
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 24   : 	ICF SelfRef	set(const _vector3<float> &v)			{ x = T(v.x);	y = T(v.y);	z = T(v.z);	return *this;	};

	movss	xmm1, DWORD PTR tv6979[esp+1712]
	movss	DWORD PTR [edx+24], xmm1
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 530  : 		dest.x	= (v.x*_11 + v.y*_21 + v.z*_31 + _41)*iw;

	movss	xmm1, DWORD PTR tv6977[esp+1712]
	mulss	xmm1, xmm0
; File I:\Vitalya\mine\NSProjectX\xrCore\_color.h

; 5    : ICF u32	color_argb	(u32 a, u32 r, u32 g, u32 b)	{	return ((a&0xff)<<24)|((r&0xff)<<16)|((g&0xff)<<8)|(b&0xff);	}

	shl	ecx, 8
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 24   : 	ICF SelfRef	set(const _vector3<float> &v)			{ x = T(v.x);	y = T(v.y);	z = T(v.z);	return *this;	};

	fld	DWORD PTR [edi+16]
; File I:\Vitalya\mine\NSProjectX\xrCore\_color.h

; 5    : ICF u32	color_argb	(u32 a, u32 r, u32 g, u32 b)	{	return ((a&0xff)<<24)|((r&0xff)<<16)|((g&0xff)<<8)|(b&0xff);	}

	or	ecx, eax
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 24   : 	ICF SelfRef	set(const _vector3<float> &v)			{ x = T(v.x);	y = T(v.y);	z = T(v.z);	return *this;	};

	fstp	DWORD PTR [edx+28]
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 530  : 		dest.x	= (v.x*_11 + v.y*_21 + v.z*_31 + _41)*iw;

	addss	xmm1, xmm4
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 24   : 	ICF SelfRef	set(const _vector3<float> &v)			{ x = T(v.x);	y = T(v.y);	z = T(v.z);	return *this;	};

	fld	DWORD PTR [edi+20]
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 530  : 		dest.x	= (v.x*_11 + v.y*_21 + v.z*_31 + _41)*iw;

	movss	xmm4, DWORD PTR tv6978[esp+1712]
	movaps	xmm0, xmm4
; File I:\Vitalya\mine\NSProjectX\xrCore\_color.h

; 5    : ICF u32	color_argb	(u32 a, u32 r, u32 g, u32 b)	{	return ((a&0xff)<<24)|((r&0xff)<<16)|((g&0xff)<<8)|(b&0xff);	}

	shl	ecx, 8
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 530  : 		dest.x	= (v.x*_11 + v.y*_21 + v.z*_31 + _41)*iw;

	mulss	xmm0, xmm3
; File I:\Vitalya\mine\NSProjectX\xrCore\_color.h

; 5    : ICF u32	color_argb	(u32 a, u32 r, u32 g, u32 b)	{	return ((a&0xff)<<24)|((r&0xff)<<16)|((g&0xff)<<8)|(b&0xff);	}

	or	ecx, eax
	shl	ecx, 8
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 531  : 		dest.y	= (v.x*_12 + v.y*_22 + v.z*_32 + _42)*iw;

	mulss	xmm4, xmm7
; File I:\Vitalya\mine\NSProjectX\xrCore\_color.h

; 5    : ICF u32	color_argb	(u32 a, u32 r, u32 g, u32 b)	{	return ((a&0xff)<<24)|((r&0xff)<<16)|((g&0xff)<<8)|(b&0xff);	}

	or	ecx, eax
; File I:\Vitalya\mine\NSProjectX\xrEngine\fvf.h

; 32   : 		IC void		set(const Fvector& _p, u32 C, float u, float v) { p.set(_p); color = C; t.set(u, v); }

	mov	DWORD PTR [edx+36], ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 530  : 		dest.x	= (v.x*_11 + v.y*_21 + v.z*_31 + _41)*iw;

	addss	xmm0, xmm2

; 531  : 		dest.y	= (v.x*_12 + v.y*_22 + v.z*_32 + _42)*iw;

	movss	xmm2, DWORD PTR tv6979[esp+1712]
	mulss	xmm2, xmm5
	addss	xmm4, xmm6
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 24   : 	ICF SelfRef	set(const _vector3<float> &v)			{ x = T(v.x);	y = T(v.y);	z = T(v.z);	return *this;	};

	fstp	DWORD PTR [edx+32]
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 530  : 		dest.x	= (v.x*_11 + v.y*_21 + v.z*_31 + _41)*iw;

	addss	xmm1, xmm0
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector2.h

; 15   : 	IC SelfRef set(float _u, float _v)				{ x=T(_u); y=T(_v);				return *this;	}

	movss	xmm0, DWORD PTR __real@3f800000
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 530  : 		dest.x	= (v.x*_11 + v.y*_21 + v.z*_31 + _41)*iw;

	mulss	xmm1, DWORD PTR _iw$1$[esp+1712]
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp

; 500  : 			S.M.transform(T,v[1]); pv->set(v[1],CLS(c1),(T.x+1)*t_scale.x+t_offset.x,(1-T.y)*t_scale.y+t_offset.y); pv++;

	addss	xmm1, DWORD PTR __real@3f800000
	mulss	xmm1, DWORD PTR __real@3daa0000
	addss	xmm1, DWORD PTR _t_offset$2$sroa$3657$1$[esp+1712]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector2.h

; 15   : 	IC SelfRef set(float _u, float _v)				{ x=T(_u); y=T(_v);				return *this;	}

	movss	DWORD PTR [edx+40], xmm1
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 531  : 		dest.y	= (v.x*_12 + v.y*_22 + v.z*_32 + _42)*iw;

	movss	xmm1, DWORD PTR tv6977[esp+1712]
	mulss	xmm1, DWORD PTR tv7187[esp+1712]
	addss	xmm2, xmm1
	addss	xmm2, xmm4
	mulss	xmm2, DWORD PTR _iw$1$[esp+1712]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector2.h

; 15   : 	IC SelfRef set(float _u, float _v)				{ x=T(_u); y=T(_v);				return *this;	}

	subss	xmm0, xmm2
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp

; 500  : 			S.M.transform(T,v[1]); pv->set(v[1],CLS(c1),(T.x+1)*t_scale.x+t_offset.x,(1-T.y)*t_scale.y+t_offset.y); pv++;

	mulss	xmm0, DWORD PTR __real@3daa0000
	addss	xmm0, DWORD PTR _t_offset$2$sroa$3658$1$[esp+1712]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector2.h

; 15   : 	IC SelfRef set(float _u, float _v)				{ x=T(_u); y=T(_v);				return *this;	}

	movss	DWORD PTR [edx+44], xmm0
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 529  : 		T iw	= 1.f/(v.x*_14 + v.y*_24 + v.z*_34 + _44);

	movss	xmm0, DWORD PTR [edi+24]
	movss	xmm3, DWORD PTR [edi+28]
	movaps	xmm1, xmm0
	mulss	xmm1, DWORD PTR [esi+32]
	movss	xmm2, DWORD PTR [edi+32]
	movss	DWORD PTR tv7006[esp+1712], xmm0
	movaps	xmm0, xmm3
	mulss	xmm0, DWORD PTR [esi+48]

; 530  : 		dest.x	= (v.x*_11 + v.y*_21 + v.z*_31 + _41)*iw;

	movss	xmm4, DWORD PTR [esi+52]

; 531  : 		dest.y	= (v.x*_12 + v.y*_22 + v.z*_32 + _42)*iw;

	movss	xmm5, DWORD PTR [esi+40]
	addss	xmm1, xmm0
	movss	xmm6, DWORD PTR [esi+24]
	movaps	xmm0, xmm2
	movss	xmm7, DWORD PTR [esi+72]
	mulss	xmm0, DWORD PTR [esi+64]
	movss	DWORD PTR tv7008[esp+1712], xmm3
	movss	xmm3, DWORD PTR [esi+68]
	addss	xmm0, DWORD PTR [esi+80]
	movss	DWORD PTR tv7007[esp+1712], xmm2
	movss	xmm2, DWORD PTR [esi+20]
	addss	xmm1, xmm0
	movss	xmm0, DWORD PTR __real@3f800000
	divss	xmm0, xmm1
	movss	xmm1, DWORD PTR [esi+56]
	movss	DWORD PTR tv7200[esp+1712], xmm1
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 24   : 	ICF SelfRef	set(const _vector3<float> &v)			{ x = T(v.x);	y = T(v.y);	z = T(v.z);	return *this;	};

	movss	xmm1, DWORD PTR tv7006[esp+1712]
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 529  : 		T iw	= 1.f/(v.x*_14 + v.y*_24 + v.z*_34 + _44);

	movss	DWORD PTR _iw$1$[esp+1712], xmm0

; 530  : 		dest.x	= (v.x*_11 + v.y*_21 + v.z*_31 + _41)*iw;

	movss	xmm0, DWORD PTR [esi+36]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 24   : 	ICF SelfRef	set(const _vector3<float> &v)			{ x = T(v.x);	y = T(v.y);	z = T(v.z);	return *this;	};

	movss	DWORD PTR [edx+48], xmm1
	fld	DWORD PTR [edi+28]
	fstp	DWORD PTR [edx+52]
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 530  : 		dest.x	= (v.x*_11 + v.y*_21 + v.z*_31 + _41)*iw;

	movss	xmm1, DWORD PTR tv7008[esp+1712]
	mulss	xmm1, xmm0
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp

; 503  : 			batch++;

	mov	ecx, DWORD PTR _batch$1$[esp+1712]
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 530  : 		dest.x	= (v.x*_11 + v.y*_21 + v.z*_31 + _41)*iw;

	movss	xmm0, DWORD PTR tv7006[esp+1712]
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp

; 503  : 			batch++;

	inc	ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 530  : 		dest.x	= (v.x*_11 + v.y*_21 + v.z*_31 + _41)*iw;

	mulss	xmm0, xmm2
; File I:\Vitalya\mine\NSProjectX\xrCore\_color.h

; 5    : ICF u32	color_argb	(u32 a, u32 r, u32 g, u32 b)	{	return ((a&0xff)<<24)|((r&0xff)<<16)|((g&0xff)<<8)|(b&0xff);	}

	movzx	eax, bl
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 530  : 		dest.x	= (v.x*_11 + v.y*_21 + v.z*_31 + _41)*iw;

	movss	xmm2, DWORD PTR tv7007[esp+1712]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 24   : 	ICF SelfRef	set(const _vector3<float> &v)			{ x = T(v.x);	y = T(v.y);	z = T(v.z);	return *this;	};

	fld	DWORD PTR [edi+32]
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 530  : 		dest.x	= (v.x*_11 + v.y*_21 + v.z*_31 + _41)*iw;

	addss	xmm1, xmm0
; File I:\Vitalya\mine\NSProjectX\xrCore\_color.h

; 5    : ICF u32	color_argb	(u32 a, u32 r, u32 g, u32 b)	{	return ((a&0xff)<<24)|((r&0xff)<<16)|((g&0xff)<<8)|(b&0xff);	}

	shl	ebx, 8
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 530  : 		dest.x	= (v.x*_11 + v.y*_21 + v.z*_31 + _41)*iw;

	movaps	xmm0, xmm2
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp

; 503  : 			batch++;

	mov	DWORD PTR _batch$1$[esp+1712], ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 530  : 		dest.x	= (v.x*_11 + v.y*_21 + v.z*_31 + _41)*iw;

	mulss	xmm0, xmm4
; File I:\Vitalya\mine\NSProjectX\xrCore\_color.h

; 5    : ICF u32	color_argb	(u32 a, u32 r, u32 g, u32 b)	{	return ((a&0xff)<<24)|((r&0xff)<<16)|((g&0xff)<<8)|(b&0xff);	}

	or	ebx, eax
	shl	ebx, 8
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 531  : 		dest.y	= (v.x*_12 + v.y*_22 + v.z*_32 + _42)*iw;

	mulss	xmm2, DWORD PTR tv7200[esp+1712]
; File I:\Vitalya\mine\NSProjectX\xrCore\_color.h

; 5    : ICF u32	color_argb	(u32 a, u32 r, u32 g, u32 b)	{	return ((a&0xff)<<24)|((r&0xff)<<16)|((g&0xff)<<8)|(b&0xff);	}

	or	ebx, eax
	shl	ebx, 8
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 530  : 		dest.x	= (v.x*_11 + v.y*_21 + v.z*_31 + _41)*iw;

	addss	xmm0, xmm3
; File I:\Vitalya\mine\NSProjectX\xrCore\_color.h

; 5    : ICF u32	color_argb	(u32 a, u32 r, u32 g, u32 b)	{	return ((a&0xff)<<24)|((r&0xff)<<16)|((g&0xff)<<8)|(b&0xff);	}

	or	ebx, eax
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 531  : 		dest.y	= (v.x*_12 + v.y*_22 + v.z*_32 + _42)*iw;

	movss	xmm3, DWORD PTR tv7008[esp+1712]
	mulss	xmm3, xmm5
	addss	xmm2, xmm7
; File I:\Vitalya\mine\NSProjectX\xrEngine\fvf.h

; 32   : 		IC void		set(const Fvector& _p, u32 C, float u, float v) { p.set(_p); color = C; t.set(u, v); }

	mov	DWORD PTR [edx+60], ebx
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 24   : 	ICF SelfRef	set(const _vector3<float> &v)			{ x = T(v.x);	y = T(v.y);	z = T(v.z);	return *this;	};

	fstp	DWORD PTR [edx+56]
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 530  : 		dest.x	= (v.x*_11 + v.y*_21 + v.z*_31 + _41)*iw;

	addss	xmm1, xmm0
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector2.h

; 15   : 	IC SelfRef set(float _u, float _v)				{ x=T(_u); y=T(_v);				return *this;	}

	movss	xmm0, DWORD PTR __real@3f800000
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 530  : 		dest.x	= (v.x*_11 + v.y*_21 + v.z*_31 + _41)*iw;

	mulss	xmm1, DWORD PTR _iw$1$[esp+1712]
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp

; 501  : 			S.M.transform(T,v[2]); pv->set(v[2],CLS(c2),(T.x+1)*t_scale.x+t_offset.x,(1-T.y)*t_scale.y+t_offset.y); pv++;

	addss	xmm1, DWORD PTR __real@3f800000
	mulss	xmm1, DWORD PTR __real@3daa0000
	addss	xmm1, DWORD PTR _t_offset$2$sroa$3657$1$[esp+1712]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector2.h

; 15   : 	IC SelfRef set(float _u, float _v)				{ x=T(_u); y=T(_v);				return *this;	}

	movss	DWORD PTR [edx+64], xmm1
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 531  : 		dest.y	= (v.x*_12 + v.y*_22 + v.z*_32 + _42)*iw;

	movss	xmm1, DWORD PTR tv7006[esp+1712]
	mulss	xmm1, xmm6
	addss	xmm3, xmm1
	addss	xmm3, xmm2
	mulss	xmm3, DWORD PTR _iw$1$[esp+1712]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector2.h

; 15   : 	IC SelfRef set(float _u, float _v)				{ x=T(_u); y=T(_v);				return *this;	}

	subss	xmm0, xmm3
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp

; 501  : 			S.M.transform(T,v[2]); pv->set(v[2],CLS(c2),(T.x+1)*t_scale.x+t_offset.x,(1-T.y)*t_scale.y+t_offset.y); pv++;

	mulss	xmm0, DWORD PTR __real@3daa0000
	addss	xmm0, DWORD PTR _t_offset$2$sroa$3658$1$[esp+1712]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector2.h

; 15   : 	IC SelfRef set(float _u, float _v)				{ x=T(_u); y=T(_v);				return *this;	}

	movss	DWORD PTR [edx+68], xmm0
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp

; 501  : 			S.M.transform(T,v[2]); pv->set(v[2],CLS(c2),(T.x+1)*t_scale.x+t_offset.x,(1-T.y)*t_scale.y+t_offset.y); pv++;

	add	edx, 72					; 00000048H
	mov	DWORD PTR _pv$1$[esp+1712], edx

; 504  : 			if (batch==batch_size)	{

	cmp	ecx, 256				; 00000100H
	jne	$LN719@render

; 505  : 				// Flush
; 506  : 				RCache.Vertex.Unlock	(batch*3,geom_World->vb_stride);

	mov	ebx, DWORD PTR _this$1$[esp+1712]
	mov	ecx, DWORD PTR __imp_?RCache@@3VCBackend@@A
	mov	eax, DWORD PTR [ebx+112]
	push	DWORD PTR [eax+20]
	push	768					; 00000300H
	call	DWORD PTR __imp_?Unlock@_VertexStream@@QAEXII@Z

; 507  : 				RCache.Render			(D3DPT_TRIANGLELIST,Offset,batch);

	mov	eax, DWORD PTR __imp_?RCache@@3VCBackend@@A
	mov	esi, DWORD PTR _Offset$[esp+1712]
; File I:\Vitalya\mine\NSProjectX\xrEngine\R_Backend_Runtime.h

; 212  : 	constants.flush();

	lea	ecx, DWORD PTR [eax+608]
	inc	DWORD PTR [eax+9024]
	add	DWORD PTR [eax+9020], 768		; 00000300H
	add	DWORD PTR [eax+9016], 256		; 00000100H
; File I:\Vitalya\mine\NSProjectX\xrEngine\r_constants_cache.h

; 172  : 		if (a_pixel.b_dirty || a_vertex.b_dirty)	flush_cache();

	cmp	DWORD PTR [ecx+4112], 0
	jne	SHORT $LN627@render
	cmp	DWORD PTR [ecx+8240], 0
	je	SHORT $LN626@render
$LN627@render:
	call	DWORD PTR __imp_?flush_cache@R_constants@@QAEXXZ
$LN626@render:
; File I:\Vitalya\mine\NSProjectX\xrEngine\R_Backend_Runtime.h

; 213  : 	CHK_DX(HW.pDevice->DrawPrimitive(T, startV, PC));

	mov	eax, DWORD PTR __imp_?HW@@3VCHW@@A
	push	256					; 00000100H
	push	esi
	push	4
	mov	eax, DWORD PTR [eax+8]
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+324]
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp

; 509  : 				pv						= (FVF::LIT*) RCache.Vertex.Lock(batch_size*3,geom_World->vb_stride,Offset);

	mov	ecx, DWORD PTR __imp_?RCache@@3VCBackend@@A
	lea	eax, DWORD PTR _Offset$[esp+1712]
	push	eax
	mov	eax, DWORD PTR [ebx+112]
	push	DWORD PTR [eax+20]
	push	768					; 00000300H
	call	DWORD PTR __imp_?Lock@_VertexStream@@QAEPAXIIAAI@Z
	mov	DWORD PTR _pv$1$[esp+1712], eax

; 510  : 				batch					= 0;

	mov	DWORD PTR _batch$1$[esp+1712], 0
$LN719@render:

; 480  : 			}
; 481  : 		}
; 482  : 
; 483  : 		// Fill VB
; 484  : 		for (u32 tid=0; tid<CI->tcnt; tid++)	{

	xorps	xmm4, xmm4
$LN722@render:
	mov	ebx, DWORD PTR _CI$1$[esp+1712]
	mov	eax, DWORD PTR tv7204[esp+1712]
$LN17@render:
	mov	edi, DWORD PTR _tid$1$[esp+1712]
	add	eax, 48					; 00000030H
	inc	edi
	mov	DWORD PTR tv7204[esp+1712], eax
	mov	DWORD PTR _tid$1$[esp+1712], edi
	cmp	edi, DWORD PTR [ebx+40]
	jb	$LL19@render
$LN716@render:

; 511  : 			}
; 512  : 		}
; 513  : 		Device.Statistic->RenderDUMP_Srender.End	();

	mov	eax, DWORD PTR __imp_?Device@@3VCRenderDevice@@A
	mov	esi, DWORD PTR [eax+436]
; File I:\Vitalya\mine\NSProjectX\xrCore\FTimer.h

; 174  : 	ICF void	End				()		{	if (!g_bEnableStatGather) return;	accum += T.GetElapsed_ticks();	}

	mov	eax, DWORD PTR __imp_?g_bEnableStatGather@@3HA
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN2@render
	lea	ecx, DWORD PTR [esi+2656]
	call	DWORD PTR __imp_?GetElapsed_ticks@CTimer@@QBE_KXZ
	add	DWORD PTR [esi+2712], eax
	adc	DWORD PTR [esi+2716], edx
$LN2@render:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	ebx, DWORD PTR _this$1$[esp+1712]
	mov	eax, -1307163959			; b21642c9H
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp

; 378  : 	for (u32 s_it=0; s_it<shadows.size(); s_it++)

	mov	esi, DWORD PTR _s_it$1$[esp+1712]
	mov	edi, 6
	movss	xmm1, DWORD PTR __xmm@7fffffff7fffffff7fffffff7fffffff
	inc	esi
	movss	xmm2, DWORD PTR __real@3e2aaaab
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	ecx, DWORD PTR [ebx+32]
	sub	ecx, DWORD PTR [ebx+28]
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp

; 378  : 	for (u32 s_it=0; s_it<shadows.size(); s_it++)

	movss	xmm3, DWORD PTR __real@3a800000
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	imul	ecx
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp

; 378  : 	for (u32 s_it=0; s_it<shadows.size(); s_it++)

	mov	DWORD PTR _s_it$1$[esp+1712], esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	add	edx, ecx
	sar	edx, 6
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp

; 378  : 	for (u32 s_it=0; s_it<shadows.size(); s_it++)

	cmp	esi, eax
	jb	$LL4@render
	mov	edi, DWORD PTR _batch$1$[esp+1712]
$LN3@render:

; 514  : 	}
; 515  : 
; 516  : 	// Flush if nessesary
; 517  : 	RCache.Vertex.Unlock	(batch*3,geom_World->vb_stride);

	mov	eax, DWORD PTR [ebx+112]
	lea	esi, DWORD PTR [edi+edi*2]
	mov	ecx, DWORD PTR __imp_?RCache@@3VCBackend@@A
	push	DWORD PTR [eax+20]
	push	esi
	call	DWORD PTR __imp_?Unlock@_VertexStream@@QAEXII@Z

; 518  : 	if (batch)				{

	test	edi, edi
	je	SHORT $LN44@render

; 519  : 		RCache.Render			(D3DPT_TRIANGLELIST,Offset,batch);

	mov	eax, DWORD PTR __imp_?RCache@@3VCBackend@@A
	mov	edi, DWORD PTR _Offset$[esp+1712]
; File I:\Vitalya\mine\NSProjectX\xrEngine\R_Backend_Runtime.h

; 212  : 	constants.flush();

	lea	ecx, DWORD PTR [eax+608]
	add	DWORD PTR [eax+9020], esi
	mov	esi, DWORD PTR _batch$1$[esp+1712]
	inc	DWORD PTR [eax+9024]
	add	DWORD PTR [eax+9016], esi
; File I:\Vitalya\mine\NSProjectX\xrEngine\r_constants_cache.h

; 172  : 		if (a_pixel.b_dirty || a_vertex.b_dirty)	flush_cache();

	cmp	DWORD PTR [ecx+4112], 0
	jne	SHORT $LN636@render
	cmp	DWORD PTR [ecx+8240], 0
	je	SHORT $LN635@render
$LN636@render:
	call	DWORD PTR __imp_?flush_cache@R_constants@@QAEXXZ
$LN635@render:
; File I:\Vitalya\mine\NSProjectX\xrEngine\R_Backend_Runtime.h

; 213  : 	CHK_DX(HW.pDevice->DrawPrimitive(T, startV, PC));

	mov	eax, DWORD PTR __imp_?HW@@3VCHW@@A
	push	esi
	push	edi
	push	4
	mov	eax, DWORD PTR [eax+8]
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+324]
$LN44@render:
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp

; 523  : 	shadows.clear				();

	mov	eax, DWORD PTR [ebx+28]

; 524  : 	for (int cit=0; cit<int(cache.size()); cit++)	{

	xor	ecx, ecx
	mov	DWORD PTR [ebx+32], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	eax, DWORD PTR [ebx+56]
	mov	edi, DWORD PTR [ebx+52]
	sub	eax, edi
	sar	eax, 2
	imul	eax, eax, -1171354717
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp

; 524  : 	for (int cit=0; cit<int(cache.size()); cit++)	{

	mov	DWORD PTR _cit$1$[esp+1712], ecx
	test	eax, eax
	jle	$LN718@render
	xor	esi, esi
	npad	14
$LL22@render:

; 525  : 		cache_item&		ci		= cache[cit];
; 526  : 		u32				time	= Device.dwTimeGlobal - ci.time;

	mov	eax, DWORD PTR __imp_?Device@@3VCRenderDevice@@A
	mov	eax, DWORD PTR [eax+480]
	sub	eax, DWORD PTR [esi+edi+32]

; 527  : 		if				(time > cache_old)	{

	cmp	eax, 30000				; 00007530H
	jbe	SHORT $LN20@render
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	eax, DWORD PTR [esi+edi+36]
	test	eax, eax
	je	SHORT $LN25@render
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
	mov	DWORD PTR [esi+edi+36], 0
	mov	edi, DWORD PTR [ebx+52]
$LN25@render:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility

; 4065 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	mov	eax, DWORD PTR [ebx+56]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 119  :         _Ptr += _Off;

	lea	edx, DWORD PTR [esi+edi]

; 1406 :         _Move_unchecked(_Whereptr + 1, _Mylast, _Whereptr);

	lea	ecx, DWORD PTR [edx+44]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility

; 4065 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	sub	eax, ecx

; 4066 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	push	eax
	push	ecx
	push	edx
	call	_memmove
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp

; 531  : 			cit			--;

	mov	ecx, DWORD PTR _cit$1$[esp+1724]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility

; 4066 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	add	esp, 12					; 0000000cH
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1408 :         --_Mylast;

	add	DWORD PTR [ebx+56], -44			; ffffffd4H
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp

; 531  : 			cit			--;

	dec	ecx
	sub	esi, 44					; 0000002cH
$LN20@render:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	eax, DWORD PTR [ebx+56]
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp

; 524  : 	for (int cit=0; cit<int(cache.size()); cit++)	{

	inc	ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	edi, DWORD PTR [ebx+52]
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp

; 524  : 	for (int cit=0; cit<int(cache.size()); cit++)	{

	add	esi, 44					; 0000002cH
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	sub	eax, edi
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp

; 524  : 	for (int cit=0; cit<int(cache.size()); cit++)	{

	mov	DWORD PTR _cit$1$[esp+1712], ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	sar	eax, 2
	imul	eax, eax, -1171354717
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp

; 524  : 	for (int cit=0; cit<int(cache.size()); cit++)	{

	cmp	ecx, eax
	jl	SHORT $LL22@render
$LN718@render:

; 532  : 		}
; 533  : 	}
; 534  : 
; 535  : 	// Projection
; 536  : 	Device.mProject._43			= _43;

	mov	eax, DWORD PTR __imp_?Device@@3VCRenderDevice@@A
	movss	xmm0, DWORD PTR __43$1$[esp+1712]
	movss	DWORD PTR [eax+656], xmm0

; 537  : 	RCache.set_xform_project	(Device.mProject);

	mov	eax, DWORD PTR __imp_?Device@@3VCRenderDevice@@A
	mov	ecx, DWORD PTR __imp_?RCache@@3VCBackend@@A
	add	eax, 600				; 00000258H
	push	eax
	call	DWORD PTR __imp_?set_xform_project@CBackend@@QAEXABU?$_matrix@M@@@Z

; 538  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?render@CLightShadows@@QAEXXZ ENDP			; CLightShadows::render
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\FTimer.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\FTimer.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_std_extensions.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_std_extensions.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp
; File I:\Vitalya\mine\NSProjectX\xrEngine\shader.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector4.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector2.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector4.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector2.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector4.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector2.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector4.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector2.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp
; File I:\Vitalya\mine\NSProjectX\xrEngine\R_Backend_Runtime.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp
; File I:\Vitalya\mine\NSProjectX\xrEngine\R_Backend_Runtime.h
; File I:\Vitalya\mine\NSProjectX\xrEngine\r_constants_cache.h
; File I:\Vitalya\mine\NSProjectX\xrEngine\R_Backend_Runtime.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\FTimer.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\FTimer.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\FTimer.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp
_TEXT	SEGMENT
_mProjectR$9$ = -468					; size = 4
_mProjectR$5$ = -468					; size = 4
_mProjectR$3$ = -468					; size = 4
_Lpos$2$ = -468						; size = 4
_mProjectR$11$ = -464					; size = 4
_mProjectR$7$ = -464					; size = 4
_Lpos$3$ = -464						; size = 4
_p_far$2$ = -460					; size = 4
_n_it$1$ = -460						; size = 4
_p_far$1 = -460						; size = 4
_l_it$1$ = -456						; size = 4
_Lpos$1$ = -452						; size = 4
_slot_id$1$ = -448					; size = 4
tv4826 = -444						; size = 4
tv4811 = -444						; size = 4
_mProjectR$1$ = -440					; size = 4
tv4566 = -440						; size = 4
_p_near$2 = -440					; size = 4
tv4816 = -436						; size = 4
_Lpos$3 = -432						; size = 12
_this$1$ = -420						; size = 4
_bRTS$1$ = -416						; size = 4
__R$1$ = -412						; size = 4
$T4 = -412						; size = 4
tv4807 = -408						; size = 4
_p_hat$5 = -408						; size = 4
_lights$1$ = -404					; size = 4
_Offset$6 = -404					; size = 4
_mProjectR$7 = -400					; size = 64
tv4808 = -336						; size = 4
$T8 = -332						; size = 4
_o_it$1$ = -328						; size = 4
_v_N$9 = -324						; size = 12
_mView$10 = -312					; size = 64
_VP$11 = -248						; size = 24
_mCombineR$12 = -224					; size = 64
$T13 = -156						; size = 92
_mProject$14 = -64					; size = 64
?calculate@CLightShadows@@QAEXXZ PROC			; CLightShadows::calculate
; _this$ = ecx

; 177  : {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	sub	esp, 468				; 000001d4H
	push	ebx
	push	esi
	push	edi
	mov	edi, ecx
	mov	DWORD PTR _this$1$[esp+480], edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1531 :         return _My_data._Myfirst == _My_data._Mylast;

	mov	eax, DWORD PTR [edi+16]
	cmp	eax, DWORD PTR [edi+20]
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp

; 178  : 	if (casters.empty())		return;

	je	$LN1@calculate

; 181  : 	Device.Statistic->RenderDUMP_Scalc.Begin	();

	mov	eax, DWORD PTR __imp_?Device@@3VCRenderDevice@@A
	mov	DWORD PTR _bRTS$1$[esp+480], 0
	mov	esi, DWORD PTR [eax+436]
; File I:\Vitalya\mine\NSProjectX\xrCore\FTimer.h

; 173  : 	ICF void	Begin			()		{	if (!g_bEnableStatGather) return;	count++; T.Start();				}

	mov	eax, DWORD PTR __imp_?g_bEnableStatGather@@3HA
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp

; 181  : 	Device.Statistic->RenderDUMP_Scalc.Begin	();

	add	esi, 2576				; 00000a10H
; File I:\Vitalya\mine\NSProjectX\xrCore\FTimer.h

; 173  : 	ICF void	Begin			()		{	if (!g_bEnableStatGather) return;	count++; T.Start();				}

	cmp	DWORD PTR [eax], 0
	je	SHORT $LN43@calculate
	inc	DWORD PTR [esi+68]

; 73   : 		if (bPause)

	cmp	DWORD PTR [esi+24], 0
	jne	SHORT $LN43@calculate

; 29   : 	ICF	void	Start			()		{	if(bPause) return;	qwStartTime = CPU::QPC()-qwPauseAccum;		}

	call	DWORD PTR __imp_?QPC@CPU@@YA_KXZ
	sub	eax, DWORD PTR [esi+16]
	mov	DWORD PTR [esi], eax
	sbb	edx, DWORD PTR [esi+20]
	mov	DWORD PTR [esi+4], edx

; 78   : 		m_real_ticks	= 0;

	mov	DWORD PTR [esi+40], 0
	mov	DWORD PTR [esi+44], 0

; 79   : 		m_ticks			= 0;

	mov	DWORD PTR [esi+48], 0
	mov	DWORD PTR [esi+52], 0
$LN43@calculate:
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp

; 182  : 	HW.pDevice->SetRenderState	(D3DRS_ZENABLE, D3DZB_FALSE);

	mov	eax, DWORD PTR __imp_?HW@@3VCHW@@A
	push	0
	push	7
	mov	eax, DWORD PTR [eax+8]
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+228]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	edx, DWORD PTR [edi+20]
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp

; 189  : 	for (u32 o_it=0; o_it<casters.size(); o_it++)

	xor	ebx, ebx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	ecx, DWORD PTR [edi+16]
	mov	eax, edx
	sub	eax, ecx
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp

; 185  : 	int	slot_id		= 0;

	mov	DWORD PTR _slot_id$1$[esp+480], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	sar	eax, 2
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp

; 189  : 	for (u32 o_it=0; o_it<casters.size(); o_it++)

	mov	DWORD PTR _o_it$1$[esp+480], ebx
	test	eax, eax
	je	$LN3@calculate
$LL4@calculate:

; 190  : 	{
; 191  : 		caster&	C	= *casters	[o_it];

	mov	ebx, DWORD PTR [ecx+ebx*4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1531 :         return _My_data._Myfirst == _My_data._Mylast;

	mov	eax, DWORD PTR [ebx+20]
	cmp	eax, DWORD PTR [ebx+24]
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp

; 192  : 		if (C.nodes.empty())	continue;

	je	$LN2@calculate

; 193  : 		
; 194  : 		// Select lights and calc importance
; 195  : 		CROS_impl* LT			= (CROS_impl*)C.O->renderable_ROS();

	mov	ecx, DWORD PTR [ebx]
	call	DWORD PTR __imp_?renderable_ROS@IRenderable@@QAEPAVIRender_ObjectSpecific@@XZ
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	esi, DWORD PTR [eax+28]
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp

; 196  : 		xr_vector<CROS_impl::Light>& lights = LT->lights;

	add	eax, 28					; 0000001cH
	mov	DWORD PTR _lights$1$[esp+480], eax

; 199  : 		for (u32 l_it=0; (l_it<lights.size()) && (slot_id<slot_max); l_it++)

	mov	DWORD PTR _l_it$1$[esp+480], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	DWORD PTR $T8[esp+480], esi
	mov	ecx, DWORD PTR [eax+4]
	sub	ecx, esi
	sar	ecx, 3
	imul	eax, ecx, -1431655765
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp

; 199  : 		for (u32 l_it=0; (l_it<lights.size()) && (slot_id<slot_max); l_it++)

	test	eax, eax
	je	$LN2@calculate
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1535 :         auto& _My_data = _Mypair._Myval2;

	xor	edx, edx
	mov	DWORD PTR tv4816[esp+480], edx
	mov	ecx, edx
$LL7@calculate:
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp

; 199  : 		for (u32 l_it=0; (l_it<lights.size()) && (slot_id<slot_max); l_it++)

	cmp	DWORD PTR _slot_id$1$[esp+480], 36	; 00000024H
	jge	$LN2@calculate

; 200  : 		{
; 201  : 			CROS_impl::Light&	L			=	lights[l_it];
; 202  : 			if (L.energy<S_level)			continue;

	movss	xmm0, DWORD PTR __real@3d4ccccd
	comiss	xmm0, DWORD PTR [edx+esi+4]
	ja	$LN5@calculate

; 203  : 			
; 204  : 			//Msg	("~ light: %d",l_it);
; 205  : 
; 206  : 			// setup rt+state(s) for first use
; 207  : 			if (!bRTS)	{

	cmp	DWORD PTR _bRTS$1$[esp+480], 0
	jne	SHORT $LN25@calculate

; 208  : 				bRTS						= TRUE;
; 209  : 				RCache.set_RT				(RT_temp->pRT);

	mov	eax, DWORD PTR [edi+92]
	mov	ecx, DWORD PTR __imp_?RCache@@3VCBackend@@A
	push	0
	mov	DWORD PTR _bRTS$1$[esp+484], 1
	push	DWORD PTR [eax+16]
	call	DWORD PTR __imp_?set_RT@CBackend@@QAEXPAUIDirect3DSurface9@@I@Z

; 210  : 				RCache.set_ZB				(RImplementation.Target->pTempZB);

	mov	eax, DWORD PTR ?RImplementation@@3VCRender@@A+1012
	mov	ecx, DWORD PTR __imp_?RCache@@3VCBackend@@A
	push	DWORD PTR [eax+104]
	call	DWORD PTR __imp_?set_ZB@CBackend@@QAEXPAUIDirect3DSurface9@@@Z

; 211  : 				HW.pDevice->Clear			(0,0,D3DCLEAR_TARGET,D3DCOLOR_XRGB(255,255,255),1,0);

	mov	eax, DWORD PTR __imp_?HW@@3VCHW@@A
	fld1
	push	0
	mov	eax, DWORD PTR [eax+8]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	fstp	DWORD PTR [esp]
	push	-1
	push	1
	push	0
	push	0
	push	eax
	call	DWORD PTR [ecx+172]
	mov	edx, DWORD PTR tv4816[esp+480]
$LN25@calculate:

; 212  : 			}
; 213  : 
; 214  : 			// calculate light center
; 215  : 			Fvector		Lpos	= L.source->position;

	mov	ecx, DWORD PTR [edx+esi]

; 216  : 			float		Lrange	= L.source->range;
; 217  : 			//Log	("* l-pos:",Lpos);
; 218  : 			//Msg	("* l-range: %f",Lrange);
; 219  : 			if (L.source->flags.type==IRender_Light::DIRECT)

	lea	esi, DWORD PTR [ebx+4]
	movss	xmm6, DWORD PTR [esi]
	movss	xmm4, DWORD PTR [esi+4]
	movss	xmm7, DWORD PTR [esi+8]
	test	BYTE PTR [ecx+60], 15			; 0000000fH
	mov	eax, DWORD PTR [ecx+64]
	movss	xmm0, DWORD PTR [ecx+100]
	mov	DWORD PTR _Lpos$3[esp+480], eax
	mov	eax, DWORD PTR [ecx+68]
	mov	DWORD PTR _Lpos$3[esp+484], eax
	mov	eax, DWORD PTR [ecx+72]
	mov	DWORD PTR _Lpos$3[esp+488], eax
	movss	DWORD PTR _p_far$2$[esp+480], xmm0
	jne	SHORT $LN10@calculate
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 42   : 	ICF SelfRef	mul(const Self &a, T s)					{ x=a.x*s;  y=a.y*s;	z=a.z*s;		return *this;	};

	movss	xmm1, DWORD PTR __real@42c80000

; 29   : 	ICF	SelfRef	add(const Self &v)						{ x+=v.x;	y+=v.y;		z+=v.z;			return *this;	};

	movaps	xmm2, xmm6

; 42   : 	ICF SelfRef	mul(const Self &a, T s)					{ x=a.x*s;  y=a.y*s;	z=a.z*s;		return *this;	};

	movss	xmm0, DWORD PTR [ecx+76]

; 29   : 	ICF	SelfRef	add(const Self &v)						{ x+=v.x;	y+=v.y;		z+=v.z;			return *this;	};

	movaps	xmm3, xmm4

; 42   : 	ICF SelfRef	mul(const Self &a, T s)					{ x=a.x*s;  y=a.y*s;	z=a.z*s;		return *this;	};

	mulss	xmm0, xmm1
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp

; 224  : 				Lrange		= 120;

	movss	xmm5, DWORD PTR __real@42f00000
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 29   : 	ICF	SelfRef	add(const Self &v)						{ x+=v.x;	y+=v.y;		z+=v.z;			return *this;	};

	subss	xmm2, xmm0

; 42   : 	ICF SelfRef	mul(const Self &a, T s)					{ x=a.x*s;  y=a.y*s;	z=a.z*s;		return *this;	};

	movss	xmm0, DWORD PTR [ecx+80]
	mulss	xmm0, xmm1

; 29   : 	ICF	SelfRef	add(const Self &v)						{ x+=v.x;	y+=v.y;		z+=v.z;			return *this;	};

	subss	xmm3, xmm0
	movss	DWORD PTR _Lpos$1$[esp+480], xmm2

; 42   : 	ICF SelfRef	mul(const Self &a, T s)					{ x=a.x*s;  y=a.y*s;	z=a.z*s;		return *this;	};

	movss	xmm0, DWORD PTR [ecx+84]
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp

; 224  : 				Lrange		= 120;

	mov	ecx, DWORD PTR [ebx]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 42   : 	ICF SelfRef	mul(const Self &a, T s)					{ x=a.x*s;  y=a.y*s;	z=a.z*s;		return *this;	};

	mulss	xmm0, xmm1

; 29   : 	ICF	SelfRef	add(const Self &v)						{ x+=v.x;	y+=v.y;		z+=v.z;			return *this;	};

	movaps	xmm1, xmm7
	movss	DWORD PTR _Lpos$3[esp+480], xmm2
	movss	DWORD PTR _Lpos$2$[esp+480], xmm3
	subss	xmm1, xmm0
	movss	DWORD PTR _Lpos$3[esp+484], xmm3
	movss	DWORD PTR _Lpos$3$[esp+480], xmm1
	movss	DWORD PTR _Lpos$3[esp+488], xmm1
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp

; 225  : 			} else {

	jmp	$LN29@calculate
$LN10@calculate:
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 287  : 	{	return (x-v.x)*(x-v.x) + (y-v.y)*(y-v.y) + (z-v.z)*(z-v.z);	}

	movss	xmm2, DWORD PTR _Lpos$3[esp+480]
	movaps	xmm5, xmm6
	movss	xmm3, DWORD PTR _Lpos$3[esp+484]
	subss	xmm5, xmm2
	movaps	xmm0, xmm4
	movss	DWORD PTR _Lpos$2$[esp+480], xmm3
	subss	xmm0, xmm3
	movss	DWORD PTR _Lpos$1$[esp+480], xmm2
	movss	DWORD PTR $T4[esp+480], xmm7
	movaps	xmm1, xmm5
	movss	DWORD PTR tv4807[esp+480], xmm5
	mulss	xmm1, xmm5
	movss	xmm5, DWORD PTR _Lpos$3[esp+488]
	movss	DWORD PTR _Lpos$3$[esp+480], xmm5
	movss	DWORD PTR tv4808[esp+480], xmm1
	movaps	xmm1, xmm7
	subss	xmm1, xmm5
	mulss	xmm0, xmm0
	movaps	xmm5, xmm1
	movss	DWORD PTR tv4566[esp+480], xmm1
	mulss	xmm5, xmm1
	movss	xmm1, DWORD PTR tv4808[esp+480]
	addss	xmm0, xmm1
	movss	DWORD PTR tv4811[esp+480], xmm5
	addss	xmm0, xmm5
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h

; 764  :             return (float)sqrt(_X);

	sqrtss	xmm5, xmm0
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp

; 232  : 					if (_dist>EPS_L)		break;

	comiss	xmm5, DWORD PTR __real@3a83126f
	ja	SHORT $LN334@calculate
	movss	xmm2, DWORD PTR tv4811[esp+480]
	movss	xmm7, DWORD PTR __real@3c23d70a
	npad	6
$LL14@calculate:

; 233  : 					Lpos.y					+=	.01f;	//. hack to avoid light-in-the-center-of-object

	addss	xmm3, xmm7
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 287  : 	{	return (x-v.x)*(x-v.x) + (y-v.y)*(y-v.y) + (z-v.z)*(z-v.z);	}

	movaps	xmm0, xmm4
	subss	xmm0, xmm3
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp

; 233  : 					Lpos.y					+=	.01f;	//. hack to avoid light-in-the-center-of-object

	movss	DWORD PTR _Lpos$3[esp+484], xmm3
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 287  : 	{	return (x-v.x)*(x-v.x) + (y-v.y)*(y-v.y) + (z-v.z)*(z-v.z);	}

	mulss	xmm0, xmm0
	addss	xmm0, xmm1
	addss	xmm0, xmm2
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h

; 764  :             return (float)sqrt(_X);

	sqrtss	xmm5, xmm0
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp

; 232  : 					if (_dist>EPS_L)		break;

	comiss	xmm5, DWORD PTR __real@3a83126f
	jbe	SHORT $LL14@calculate
	movss	xmm7, DWORD PTR $T4[esp+480]
	movss	xmm2, DWORD PTR _Lpos$1$[esp+480]
	movss	DWORD PTR _Lpos$2$[esp+480], xmm3
$LN334@calculate:

; 234  : 				}
; 235  : 				float		_R		=	C.O->renderable.visual->vis.sphere.R+0.1f;

	mov	ecx, DWORD PTR [ebx]
	mov	eax, DWORD PTR [ecx+68]
	movss	xmm0, DWORD PTR [eax+20]
	addss	xmm0, DWORD PTR __real@3dcccccd

; 237  : 				if (_dist<_R)		{

	comiss	xmm0, xmm5
	movss	DWORD PTR __R$1$[esp+480], xmm0
	jbe	$LN350@calculate
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 190  : 		T mag=_sqrt(T(1)/(x*x + y*y + z*z));

	movss	xmm0, DWORD PTR __real@3f800000

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movaps	xmm2, xmm4
	subss	xmm2, xmm3
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp

; 241  : 					Lpos.mad		(Lpos,Ldir,_dist-_R);

	subss	xmm5, DWORD PTR __R$1$[esp+480]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movaps	xmm1, xmm2
	mulss	xmm1, xmm2

; 190  : 		T mag=_sqrt(T(1)/(x*x + y*y + z*z));

	addss	xmm1, DWORD PTR tv4808[esp+480]
	addss	xmm1, DWORD PTR tv4811[esp+480]
	divss	xmm0, xmm1
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h

; 764  :             return (float)sqrt(_X);

	sqrtss	xmm1, xmm0
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 190  : 		T mag=_sqrt(T(1)/(x*x + y*y + z*z));

	movaps	xmm0, xmm1

; 191  : 		x *= mag;

	mulss	xmm2, xmm1
	mulss	xmm0, DWORD PTR tv4807[esp+480]

; 192  : 		y *= mag;

	mulss	xmm1, DWORD PTR tv4566[esp+480]
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp

; 241  : 					Lpos.mad		(Lpos,Ldir,_dist-_R);

	mulss	xmm0, xmm5
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 144  : 		x = p.x + d.x*m;

	mulss	xmm2, xmm5
	addss	xmm0, DWORD PTR _Lpos$1$[esp+480]

; 145  : 		y = p.y + d.y*m;

	mulss	xmm1, xmm5
	addss	xmm3, xmm2

; 146  : 		z = p.z + d.z*m;

	addss	xmm1, DWORD PTR _Lpos$3$[esp+480]
	movss	DWORD PTR _Lpos$1$[esp+480], xmm0
	movaps	xmm2, xmm0

; 144  : 		x = p.x + d.x*m;

	movss	DWORD PTR _Lpos$3[esp+480], xmm0

; 145  : 		y = p.y + d.y*m;

	movss	DWORD PTR _Lpos$2$[esp+480], xmm3
	movss	DWORD PTR _Lpos$3[esp+484], xmm3

; 146  : 		z = p.z + d.z*m;

	movss	DWORD PTR _Lpos$3$[esp+480], xmm1
	movss	DWORD PTR _Lpos$3[esp+488], xmm1
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp

; 237  : 				if (_dist<_R)		{

	jmp	SHORT $LN355@calculate
$LN350@calculate:
	movss	xmm1, DWORD PTR _Lpos$3$[esp+480]
$LN355@calculate:
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 287  : 	{	return (x-v.x)*(x-v.x) + (y-v.y)*(y-v.y) + (z-v.z)*(z-v.z);	}

	movss	xmm5, DWORD PTR _p_far$2$[esp+480]
$LN29@calculate:
	subss	xmm4, xmm3
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp

; 249  : 			float		p_R		=	C.O->renderable.visual->vis.sphere.R;

	mov	eax, DWORD PTR [ecx+68]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 287  : 	{	return (x-v.x)*(x-v.x) + (y-v.y)*(y-v.y) + (z-v.z)*(z-v.z);	}

	subss	xmm6, xmm2
	subss	xmm7, xmm1
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp

; 249  : 			float		p_R		=	C.O->renderable.visual->vis.sphere.R;

	movss	xmm2, DWORD PTR [eax+20]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 287  : 	{	return (x-v.x)*(x-v.x) + (y-v.y)*(y-v.y) + (z-v.z)*(z-v.z);	}

	mulss	xmm4, xmm4
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp

; 250  : 			float		p_hat	=	p_R/p_dist;

	movaps	xmm3, xmm2
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 287  : 	{	return (x-v.x)*(x-v.x) + (y-v.y)*(y-v.y) + (z-v.z)*(z-v.z);	}

	mulss	xmm6, xmm6
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp

; 255  : 			float		p_far	=	_min(Lrange,_max(p_dist+S_fade,p_dist+p_R));	

	movaps	xmm0, xmm2
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 287  : 	{	return (x-v.x)*(x-v.x) + (y-v.y)*(y-v.y) + (z-v.z)*(z-v.z);	}

	mulss	xmm7, xmm7
	addss	xmm6, xmm4
	addss	xmm6, xmm7
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h

; 764  :             return (float)sqrt(_X);

	sqrtss	xmm4, xmm6
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp

; 250  : 			float		p_hat	=	p_R/p_dist;

	divss	xmm3, xmm4

; 252  : 			float		p_near	=	p_dist-p_R-eps;									

	movaps	xmm7, xmm4

; 255  : 			float		p_far	=	_min(Lrange,_max(p_dist+S_fade,p_dist+p_R));	

	addss	xmm0, xmm4
	subss	xmm7, xmm2
	movss	DWORD PTR _p_hat$5[esp+480], xmm3
	movaps	xmm1, xmm4
	addss	xmm1, DWORD PTR __real@40900000
	movaps	xmm6, xmm7
	subss	xmm6, DWORD PTR __real@3b03126f
; File I:\Vitalya\mine\NSProjectX\xrCore\_std_extensions.h

; 94   : template <class T>	IC T		_max	(T a, T b)	{ return a>b?a:b;	}

	comiss	xmm1, xmm0
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp

; 252  : 			float		p_near	=	p_dist-p_R-eps;									

	movss	DWORD PTR _p_near$2[esp+480], xmm6
; File I:\Vitalya\mine\NSProjectX\xrCore\_std_extensions.h

; 94   : template <class T>	IC T		_max	(T a, T b)	{ return a>b?a:b;	}

	jbe	SHORT $LN136@calculate
	movss	xmm2, DWORD PTR __real@40900000
$LN136@calculate:

; 93   : template <class T>	IC T		_min	(T a, T b)	{ return a<b?a:b;	}

	addss	xmm2, xmm4
	comiss	xmm2, xmm5
	ja	SHORT $LN356@calculate
	movaps	xmm5, xmm2
$LN356@calculate:
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp

; 256  : 			if (p_near<eps)			continue;

	movss	xmm0, DWORD PTR __real@3b03126f
	comiss	xmm0, xmm6
	movss	DWORD PTR _p_far$1[esp+480], xmm5
	ja	$LN354@calculate

; 257  : 			if (p_far<(p_near+eps))	continue;

	comiss	xmm7, xmm5
	ja	$LN354@calculate

; 258  : 			if (p_hat>0.9f)			continue;

	comiss	xmm3, DWORD PTR __real@3f666666
	ja	$LN354@calculate

; 259  : 			if (p_hat<0.01f)		continue;

	movss	xmm0, DWORD PTR __real@3c23d70a
	comiss	xmm0, xmm3
	ja	$LN354@calculate

; 260  : 
; 261  : 			//Msg			("* near(%f), near-x(%f)",p_near,p_nearR);
; 262  : 			
; 263  : 			mProject.build_projection_HAT	(p_hat,p_asp,p_near,	p_far);

	fld	DWORD PTR _p_far$1[esp+480]
	lea	ecx, DWORD PTR _mProject$14[esp+480]
	sub	esp, 16					; 00000010H
	fst	DWORD PTR [esp+12]
	fld	DWORD PTR _p_near$2[esp+496]
	fst	DWORD PTR [esp+8]
	fld1
	fst	DWORD PTR [esp+4]
	fld	DWORD PTR _p_hat$5[esp+496]
	fst	DWORD PTR [esp]
	call	?build_projection_HAT@?$_matrix@M@@QAEAAU1@MMMM@Z ; _matrix<float>::build_projection_HAT

; 264  : 			mProjectR.build_projection_HAT	(p_hat,p_asp,p_nearR,	p_far);

	sub	esp, 16					; 00000010H
	lea	ecx, DWORD PTR _mProjectR$7[esp+496]
	fxch	ST(3)
	fstp	DWORD PTR [esp+12]
	fxch	ST(1)
	fstp	DWORD PTR [esp+8]
	fstp	DWORD PTR [esp+4]
	fstp	DWORD PTR [esp]
	call	?build_projection_HAT@?$_matrix@M@@QAEAAU1@MMMM@Z ; _matrix<float>::build_projection_HAT

; 265  : 			RCache.set_xform_project		(mProject);

	mov	ecx, DWORD PTR __imp_?RCache@@3VCBackend@@A
	lea	eax, DWORD PTR _mProject$14[esp+480]
	push	eax
	call	DWORD PTR __imp_?set_xform_project@CBackend@@QAEXABU?$_matrix@M@@@Z
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	xmm2, DWORD PTR [esi]
	movss	xmm3, DWORD PTR [esi+4]
	subss	xmm2, DWORD PTR _Lpos$1$[esp+480]
	subss	xmm3, DWORD PTR _Lpos$2$[esp+480]
	movss	xmm4, DWORD PTR [esi+8]
	subss	xmm4, DWORD PTR _Lpos$3$[esp+480]
	movaps	xmm0, xmm2
	mulss	xmm0, xmm2

; 190  : 		T mag=_sqrt(T(1)/(x*x + y*y + z*z));

	movaps	xmm1, xmm3
	mulss	xmm1, xmm3
	addss	xmm1, xmm0
	movaps	xmm0, xmm4
	mulss	xmm0, xmm4
	addss	xmm1, xmm0
	movss	xmm0, DWORD PTR __real@3f800000
	divss	xmm0, xmm1
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h

; 764  :             return (float)sqrt(_X);

	sqrtss	xmm5, xmm0
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 191  : 		x *= mag;

	movaps	xmm6, xmm5
	movaps	xmm7, xmm5
	mulss	xmm6, xmm3
	mulss	xmm7, xmm2
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h

; 676  :             return (float)fabs(_X);

	movaps	xmm0, xmm6
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 192  : 		y *= mag;

	mulss	xmm5, xmm4
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h

; 676  :             return (float)fabs(_X);

	andps	xmm0, DWORD PTR __xmm@7fffffff7fffffff7fffffff7fffffff
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp

; 272  : 			if(1-_abs(v_D.y)<EPS)	v_N.set(1,0,0);

	comiss	xmm0, DWORD PTR __real@3f7fff58
	jbe	SHORT $LN34@calculate
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 23   : 	ICF	SelfRef	set(T _x, T _y, T _z)					{ x = _x;		y = _y;		z = _z;		return *this;	};

	movss	xmm0, DWORD PTR __real@3f800000
	xorps	xmm1, xmm1
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp

; 272  : 			if(1-_abs(v_D.y)<EPS)	v_N.set(1,0,0);

	jmp	SHORT $LN35@calculate
$LN34@calculate:
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 23   : 	ICF	SelfRef	set(T _x, T _y, T _z)					{ x = _x;		y = _y;		z = _z;		return *this;	};

	movss	xmm1, DWORD PTR __real@3f800000
	xorps	xmm0, xmm0
$LN35@calculate:

; 274  : 		y = v1.z  * v2.x  - v1.x  * v2.z ;

	movaps	xmm3, xmm5
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp

; 276  : 			mView.build_camera		(Lpos,C.C,v_N);

	lea	eax, DWORD PTR _v_N$9[esp+480]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 274  : 		y = v1.z  * v2.x  - v1.x  * v2.z ;

	mulss	xmm3, xmm0
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp

; 276  : 			mView.build_camera		(Lpos,C.C,v_N);

	lea	ecx, DWORD PTR _mView$10[esp+480]
	push	eax
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 274  : 		y = v1.z  * v2.x  - v1.x  * v2.z ;

	movaps	xmm2, xmm6
	movaps	xmm4, xmm5
	mulss	xmm2, xmm0
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp

; 276  : 			mView.build_camera		(Lpos,C.C,v_N);

	lea	eax, DWORD PTR _Lpos$3[esp+484]
	push	esi
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 274  : 		y = v1.z  * v2.x  - v1.x  * v2.z ;

	xorps	xmm3, DWORD PTR __xmm@80000000800000008000000080000000

; 275  : 		z = v1.x  * v2.y  - v1.y  * v2.x ;

	movaps	xmm0, xmm7
	mulss	xmm0, xmm1
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp

; 276  : 			mView.build_camera		(Lpos,C.C,v_N);

	push	eax
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 273  : 		x = v1.y  * v2.z  - v1.z  * v2.y ;

	mulss	xmm4, xmm1

; 275  : 		z = v1.x  * v2.y  - v1.y  * v2.x ;

	subss	xmm2, xmm0

; 273  : 		x = v1.y  * v2.z  - v1.z  * v2.y ;

	movaps	xmm0, xmm5
	mulss	xmm0, xmm3
	mulss	xmm5, xmm4

; 275  : 		z = v1.x  * v2.y  - v1.y  * v2.x ;

	movaps	xmm1, xmm2

; 274  : 		y = v1.z  * v2.x  - v1.x  * v2.z ;

	mulss	xmm2, xmm7

; 275  : 		z = v1.x  * v2.y  - v1.y  * v2.x ;

	mulss	xmm1, xmm6

; 274  : 		y = v1.z  * v2.x  - v1.x  * v2.z ;

	mulss	xmm7, xmm3
	subss	xmm5, xmm2

; 275  : 		z = v1.x  * v2.y  - v1.y  * v2.x ;

	mulss	xmm6, xmm4
	subss	xmm1, xmm0
	movss	DWORD PTR _v_N$9[esp+496], xmm5
	subss	xmm7, xmm6
	movss	DWORD PTR _v_N$9[esp+492], xmm1
	movss	DWORD PTR _v_N$9[esp+500], xmm7
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp

; 276  : 			mView.build_camera		(Lpos,C.C,v_N);

	call	?build_camera@?$_matrix@M@@QAEAAU1@ABU?$_vector3@M@@00@Z ; _matrix<float>::build_camera

; 277  : 			RCache.set_xform_view	(mView);

	mov	ecx, DWORD PTR __imp_?RCache@@3VCBackend@@A
	lea	eax, DWORD PTR _mView$10[esp+480]
	push	eax
	call	DWORD PTR __imp_?set_xform_view@CBackend@@QAEXABU?$_matrix@M@@@Z
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 85   : 		m[0][0] = A.m[0][0] * B.m[0][0] + A.m[1][0] * B.m[0][1] + A.m[2][0] * B.m[0][2] + A.m[3][0] * B.m[0][3];

	movss	xmm6, DWORD PTR _mView$10[esp+492]
	movss	xmm5, DWORD PTR _mView$10[esp+488]
	movss	xmm2, DWORD PTR _mProjectR$7[esp+528]
	movss	xmm0, DWORD PTR _mProjectR$7[esp+512]
	movss	xmm4, DWORD PTR _mView$10[esp+480]
	movss	xmm3, DWORD PTR _mView$10[esp+484]
	movss	xmm1, DWORD PTR _mProjectR$7[esp+480]
	mulss	xmm2, xmm6
	mulss	xmm0, xmm5
	mulss	xmm1, xmm4
	addss	xmm2, xmm0
	movss	xmm0, DWORD PTR _mProjectR$7[esp+496]
	mulss	xmm0, xmm3
	addss	xmm1, xmm0

; 86   : 		m[0][1] = A.m[0][1] * B.m[0][0] + A.m[1][1] * B.m[0][1] + A.m[2][1] * B.m[0][2] + A.m[3][1] * B.m[0][3];

	movss	xmm0, DWORD PTR _mProjectR$7[esp+516]
	mulss	xmm0, xmm5
	addss	xmm2, xmm1
	movss	xmm1, DWORD PTR _mProjectR$7[esp+484]
	mulss	xmm1, xmm4
	movss	DWORD PTR _mCombineR$12[esp+480], xmm2
	movss	xmm2, DWORD PTR _mProjectR$7[esp+532]
	mulss	xmm2, xmm6
	addss	xmm2, xmm0
	movss	xmm0, DWORD PTR _mProjectR$7[esp+500]
	mulss	xmm0, xmm3
	addss	xmm1, xmm0

; 87   : 		m[0][2] = A.m[0][2] * B.m[0][0] + A.m[1][2] * B.m[0][1] + A.m[2][2] * B.m[0][2] + A.m[3][2] * B.m[0][3];

	movss	xmm0, DWORD PTR _mProjectR$7[esp+520]
	mulss	xmm0, xmm5
	addss	xmm2, xmm1
	movss	xmm1, DWORD PTR _mProjectR$7[esp+488]
	mulss	xmm1, xmm4
	movss	DWORD PTR _mCombineR$12[esp+484], xmm2
	movss	xmm2, DWORD PTR _mProjectR$7[esp+536]
	mulss	xmm2, xmm6
	addss	xmm2, xmm0
	movss	xmm0, DWORD PTR _mProjectR$7[esp+504]
	mulss	xmm0, xmm3
	addss	xmm1, xmm0

; 88   : 		m[0][3] = A.m[0][3] * B.m[0][0] + A.m[1][3] * B.m[0][1] + A.m[2][3] * B.m[0][2] + A.m[3][3] * B.m[0][3];

	movss	xmm0, DWORD PTR _mProjectR$7[esp+524]
	mulss	xmm0, xmm5
	addss	xmm2, xmm1
	movss	xmm1, DWORD PTR _mProjectR$7[esp+492]
	movss	DWORD PTR _mCombineR$12[esp+488], xmm2
	movss	xmm2, DWORD PTR _mProjectR$7[esp+540]
	mulss	xmm2, xmm6
	addss	xmm2, xmm0
	movss	xmm7, DWORD PTR _mProjectR$7[esp+508]
	mulss	xmm1, xmm4
	movaps	xmm0, xmm7
	mulss	xmm0, xmm3

; 89   : 
; 90   : 		m[1][0] = A.m[0][0] * B.m[1][0] + A.m[1][0] * B.m[1][1] + A.m[2][0] * B.m[1][2] + A.m[3][0] * B.m[1][3];

	movss	xmm6, DWORD PTR _mView$10[esp+508]
	movss	xmm5, DWORD PTR _mView$10[esp+504]
	addss	xmm1, xmm0
	movss	xmm4, DWORD PTR _mView$10[esp+496]
	movss	xmm0, DWORD PTR _mProjectR$7[esp+512]
	movss	xmm3, DWORD PTR _mView$10[esp+500]
	mulss	xmm0, xmm5
	addss	xmm2, xmm1
	movss	xmm1, DWORD PTR _mProjectR$7[esp+480]
	mulss	xmm1, xmm4
	movss	DWORD PTR _mCombineR$12[esp+492], xmm2
	movss	xmm2, DWORD PTR _mProjectR$7[esp+528]
	mulss	xmm2, xmm6
	addss	xmm2, xmm0
	movss	xmm0, DWORD PTR _mProjectR$7[esp+496]
	mulss	xmm0, xmm3
	addss	xmm1, xmm0

; 91   : 		m[1][1] = A.m[0][1] * B.m[1][0] + A.m[1][1] * B.m[1][1] + A.m[2][1] * B.m[1][2] + A.m[3][1] * B.m[1][3];

	movss	xmm0, DWORD PTR _mProjectR$7[esp+516]
	mulss	xmm0, xmm5
	addss	xmm2, xmm1
	movss	xmm1, DWORD PTR _mProjectR$7[esp+484]
	mulss	xmm1, xmm4
	movss	DWORD PTR _mCombineR$12[esp+496], xmm2
	movss	xmm2, DWORD PTR _mProjectR$7[esp+532]
	mulss	xmm2, xmm6
	addss	xmm2, xmm0
	movss	xmm0, DWORD PTR _mProjectR$7[esp+500]
	mulss	xmm0, xmm3
	addss	xmm1, xmm0

; 92   : 		m[1][2] = A.m[0][2] * B.m[1][0] + A.m[1][2] * B.m[1][1] + A.m[2][2] * B.m[1][2] + A.m[3][2] * B.m[1][3];

	movss	xmm0, DWORD PTR _mProjectR$7[esp+520]
	mulss	xmm0, xmm5
	addss	xmm2, xmm1
	movss	xmm1, DWORD PTR _mProjectR$7[esp+488]
	mulss	xmm1, xmm4
	movss	DWORD PTR _mCombineR$12[esp+500], xmm2
	movss	xmm2, DWORD PTR _mProjectR$7[esp+536]
	mulss	xmm2, xmm6
	addss	xmm2, xmm0
	movss	xmm0, DWORD PTR _mProjectR$7[esp+504]
	mulss	xmm0, xmm3
	addss	xmm1, xmm0

; 93   : 		m[1][3] = A.m[0][3] * B.m[1][0] + A.m[1][3] * B.m[1][1] + A.m[2][3] * B.m[1][2] + A.m[3][3] * B.m[1][3];

	movss	xmm0, DWORD PTR _mProjectR$7[esp+524]
	mulss	xmm0, xmm5

; 94   : 
; 95   : 		m[2][0] = A.m[0][0] * B.m[2][0] + A.m[1][0] * B.m[2][1] + A.m[2][0] * B.m[2][2] + A.m[3][0] * B.m[2][3];

	movss	xmm5, DWORD PTR _mView$10[esp+520]
	addss	xmm2, xmm1
	movss	xmm1, DWORD PTR _mProjectR$7[esp+492]
	mulss	xmm1, xmm4
	movss	xmm4, DWORD PTR _mView$10[esp+512]
	movss	DWORD PTR _mCombineR$12[esp+504], xmm2
	movss	xmm2, DWORD PTR _mProjectR$7[esp+540]
	mulss	xmm2, xmm6
	movss	xmm6, DWORD PTR _mView$10[esp+524]
	addss	xmm2, xmm0
	movaps	xmm0, xmm7
	mulss	xmm0, xmm3
	movss	xmm3, DWORD PTR _mView$10[esp+516]
	addss	xmm1, xmm0
	movss	xmm0, DWORD PTR _mProjectR$7[esp+512]
	mulss	xmm0, xmm5
	addss	xmm2, xmm1
	movss	xmm1, DWORD PTR _mProjectR$7[esp+480]
	mulss	xmm1, xmm4
	movss	DWORD PTR _mCombineR$12[esp+508], xmm2
	movss	xmm2, DWORD PTR _mProjectR$7[esp+528]
	mulss	xmm2, xmm6
	addss	xmm2, xmm0
	movss	xmm0, DWORD PTR _mProjectR$7[esp+496]
	mulss	xmm0, xmm3
	addss	xmm1, xmm0

; 96   : 		m[2][1] = A.m[0][1] * B.m[2][0] + A.m[1][1] * B.m[2][1] + A.m[2][1] * B.m[2][2] + A.m[3][1] * B.m[2][3];

	movss	xmm0, DWORD PTR _mProjectR$7[esp+516]
	mulss	xmm0, xmm5
	addss	xmm2, xmm1
	movss	xmm1, DWORD PTR _mProjectR$7[esp+484]
	movss	DWORD PTR _mCombineR$12[esp+512], xmm2
	movss	xmm2, DWORD PTR _mProjectR$7[esp+532]
	mulss	xmm2, xmm6
	addss	xmm2, xmm0
	movss	xmm0, DWORD PTR _mProjectR$7[esp+500]
	mulss	xmm1, xmm4
	mulss	xmm0, xmm3
	addss	xmm1, xmm0

; 97   : 		m[2][2] = A.m[0][2] * B.m[2][0] + A.m[1][2] * B.m[2][1] + A.m[2][2] * B.m[2][2] + A.m[3][2] * B.m[2][3];

	movss	xmm0, DWORD PTR _mProjectR$7[esp+520]
	mulss	xmm0, xmm5
	addss	xmm2, xmm1
	movss	xmm1, DWORD PTR _mProjectR$7[esp+488]
	mulss	xmm1, xmm4
	movss	DWORD PTR _mCombineR$12[esp+516], xmm2
	movss	xmm2, DWORD PTR _mProjectR$7[esp+536]
	mulss	xmm2, xmm6
	addss	xmm2, xmm0
	movss	xmm0, DWORD PTR _mProjectR$7[esp+504]
	mulss	xmm0, xmm3
	addss	xmm1, xmm0
	addss	xmm2, xmm1
	movss	DWORD PTR _mCombineR$12[esp+520], xmm2

; 98   : 		m[2][3] = A.m[0][3] * B.m[2][0] + A.m[1][3] * B.m[2][1] + A.m[2][3] * B.m[2][2] + A.m[3][3] * B.m[2][3];

	movss	xmm2, DWORD PTR _mProjectR$7[esp+540]
	mulss	xmm2, xmm6
	movss	xmm6, DWORD PTR _mProjectR$7[esp+524]
	movaps	xmm0, xmm6
	mulss	xmm0, xmm5
	movss	xmm5, DWORD PTR _mProjectR$7[esp+492]
	movaps	xmm1, xmm5
	mulss	xmm1, xmm4
	addss	xmm2, xmm0
	movaps	xmm0, xmm7

; 99   : 
; 100  : 		m[3][0] = A.m[0][0] * B.m[3][0] + A.m[1][0] * B.m[3][1] + A.m[2][0] * B.m[3][2] + A.m[3][0] * B.m[3][3];

	movss	xmm4, DWORD PTR _mProjectR$7[esp+496]
	mulss	xmm0, xmm3
	addss	xmm1, xmm0
	movss	xmm0, DWORD PTR _mProjectR$7[esp+512]
	addss	xmm2, xmm1
	movss	xmm1, DWORD PTR _mProjectR$7[esp+528]
	mulss	xmm1, DWORD PTR _mView$10[esp+540]
	movss	DWORD PTR _mCombineR$12[esp+524], xmm2
	movss	xmm2, DWORD PTR _mView$10[esp+536]
	mulss	xmm0, xmm2
	addss	xmm1, xmm0
	movss	xmm0, DWORD PTR _mProjectR$7[esp+480]
	movss	DWORD PTR _mProjectR$1$[esp+480], xmm1
	movss	xmm1, DWORD PTR _mView$10[esp+528]
	mulss	xmm0, xmm1
	movss	DWORD PTR _mProjectR$3$[esp+480], xmm0
	movss	xmm0, DWORD PTR _mView$10[esp+532]
	movss	xmm3, DWORD PTR _mProjectR$3$[esp+480]
	mulss	xmm4, xmm0
	addss	xmm3, xmm4

; 101  : 		m[3][1] = A.m[0][1] * B.m[3][0] + A.m[1][1] * B.m[3][1] + A.m[2][1] * B.m[3][2] + A.m[3][1] * B.m[3][3];

	movss	xmm4, DWORD PTR _mProjectR$7[esp+532]
	mulss	xmm4, DWORD PTR _mView$10[esp+540]
	movss	DWORD PTR _mProjectR$3$[esp+480], xmm3
	movss	xmm3, DWORD PTR _mProjectR$1$[esp+480]
	addss	xmm3, DWORD PTR _mProjectR$3$[esp+480]
	movss	DWORD PTR _mProjectR$5$[esp+480], xmm4
	movss	xmm4, DWORD PTR _mProjectR$7[esp+516]
	mulss	xmm4, xmm2
	movss	DWORD PTR _mCombineR$12[esp+528], xmm3
	movss	xmm3, DWORD PTR _mProjectR$5$[esp+480]
	addss	xmm3, xmm4
	movss	xmm4, DWORD PTR _mProjectR$7[esp+484]
	mulss	xmm4, xmm1
	movss	DWORD PTR _mProjectR$7$[esp+480], xmm4
	movss	xmm4, DWORD PTR _mProjectR$7[esp+500]
	mulss	xmm4, xmm0
	movss	DWORD PTR _mProjectR$5$[esp+480], xmm3
	movss	xmm3, DWORD PTR _mProjectR$7$[esp+480]
	addss	xmm3, xmm4

; 102  : 		m[3][2] = A.m[0][2] * B.m[3][0] + A.m[1][2] * B.m[3][1] + A.m[2][2] * B.m[3][2] + A.m[3][2] * B.m[3][3];

	movss	xmm4, DWORD PTR _mProjectR$7[esp+536]
	mulss	xmm4, DWORD PTR _mView$10[esp+540]
	movss	DWORD PTR _mProjectR$7$[esp+480], xmm3
	movss	xmm3, DWORD PTR _mProjectR$5$[esp+480]
	addss	xmm3, DWORD PTR _mProjectR$7$[esp+480]
	movss	DWORD PTR _mProjectR$9$[esp+480], xmm4
	movss	xmm4, DWORD PTR _mProjectR$7[esp+520]
	mulss	xmm4, xmm2
	movss	DWORD PTR _mCombineR$12[esp+532], xmm3
	movss	xmm3, DWORD PTR _mProjectR$9$[esp+480]
	addss	xmm3, xmm4
	movss	xmm4, DWORD PTR _mProjectR$7[esp+488]
	mulss	xmm4, xmm1
	movss	DWORD PTR _mProjectR$9$[esp+480], xmm3
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp

; 285  : 			int		s_x			=	slot_id%slot_line;

	mov	eax, DWORD PTR _slot_id$1$[esp+480]
	mov	ecx, 6
	cdq
	idiv	ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 102  : 		m[3][2] = A.m[0][2] * B.m[3][0] + A.m[1][2] * B.m[3][1] + A.m[2][2] * B.m[3][2] + A.m[3][2] * B.m[3][3];

	movss	DWORD PTR _mProjectR$11$[esp+480], xmm4
	movss	xmm4, DWORD PTR _mProjectR$7[esp+504]
	movss	xmm3, DWORD PTR _mProjectR$11$[esp+480]
	mulss	xmm4, xmm0
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp

; 287  : 			D3DVIEWPORT9 VP		=	{s_x*S_size,s_y*S_size,S_size,S_size,0,1 };

	mov	DWORD PTR _VP$11[esp+488], 85		; 00000055H
	imul	eax, eax, 85
	imul	ecx, edx, 85

; 288  : 			CHK_DX					(HW.pDevice->SetViewport(&VP));

	lea	edx, DWORD PTR _VP$11[esp+480]
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 102  : 		m[3][2] = A.m[0][2] * B.m[3][0] + A.m[1][2] * B.m[3][1] + A.m[2][2] * B.m[3][2] + A.m[3][2] * B.m[3][3];

	addss	xmm3, xmm4

; 103  : 		m[3][3] = A.m[0][3] * B.m[3][0] + A.m[1][3] * B.m[3][1] + A.m[2][3] * B.m[3][2] + A.m[3][3] * B.m[3][3];

	mulss	xmm6, xmm2
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp

; 287  : 			D3DVIEWPORT9 VP		=	{s_x*S_size,s_y*S_size,S_size,S_size,0,1 };

	mov	DWORD PTR _VP$11[esp+492], 85		; 00000055H
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 103  : 		m[3][3] = A.m[0][3] * B.m[3][0] + A.m[1][3] * B.m[3][1] + A.m[2][3] * B.m[3][2] + A.m[3][3] * B.m[3][3];

	movss	xmm4, DWORD PTR _mProjectR$7[esp+540]
	mulss	xmm4, DWORD PTR _mView$10[esp+540]
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp

; 287  : 			D3DVIEWPORT9 VP		=	{s_x*S_size,s_y*S_size,S_size,S_size,0,1 };

	mov	DWORD PTR _VP$11[esp+484], eax

; 288  : 			CHK_DX					(HW.pDevice->SetViewport(&VP));

	mov	eax, DWORD PTR __imp_?HW@@3VCHW@@A
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 103  : 		m[3][3] = A.m[0][3] * B.m[3][0] + A.m[1][3] * B.m[3][1] + A.m[2][3] * B.m[3][2] + A.m[3][3] * B.m[3][3];

	mulss	xmm5, xmm1
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp

; 287  : 			D3DVIEWPORT9 VP		=	{s_x*S_size,s_y*S_size,S_size,S_size,0,1 };

	mov	DWORD PTR _VP$11[esp+480], ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 103  : 		m[3][3] = A.m[0][3] * B.m[3][0] + A.m[1][3] * B.m[3][1] + A.m[2][3] * B.m[3][2] + A.m[3][3] * B.m[3][3];

	mulss	xmm7, xmm0
	addss	xmm4, xmm6
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp

; 287  : 			D3DVIEWPORT9 VP		=	{s_x*S_size,s_y*S_size,S_size,S_size,0,1 };

	mov	DWORD PTR _VP$11[esp+496], 0
	mov	DWORD PTR _VP$11[esp+500], 1065353216	; 3f800000H

; 288  : 			CHK_DX					(HW.pDevice->SetViewport(&VP));

	mov	eax, DWORD PTR [eax+8]
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 103  : 		m[3][3] = A.m[0][3] * B.m[3][0] + A.m[1][3] * B.m[3][1] + A.m[2][3] * B.m[3][2] + A.m[3][3] * B.m[3][3];

	addss	xmm5, xmm7
	movss	DWORD PTR _mProjectR$11$[esp+480], xmm3
	movss	xmm3, DWORD PTR _mProjectR$9$[esp+480]
	addss	xmm3, DWORD PTR _mProjectR$11$[esp+480]
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp

; 288  : 			CHK_DX					(HW.pDevice->SetViewport(&VP));

	mov	ecx, DWORD PTR [eax]
	push	edx
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 103  : 		m[3][3] = A.m[0][3] * B.m[3][0] + A.m[1][3] * B.m[3][1] + A.m[2][3] * B.m[3][2] + A.m[3][3] * B.m[3][3];

	addss	xmm4, xmm5
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp

; 288  : 			CHK_DX					(HW.pDevice->SetViewport(&VP));

	push	eax
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 102  : 		m[3][2] = A.m[0][2] * B.m[3][0] + A.m[1][2] * B.m[3][1] + A.m[2][2] * B.m[3][2] + A.m[3][2] * B.m[3][3];

	movss	DWORD PTR _mCombineR$12[esp+544], xmm3

; 103  : 		m[3][3] = A.m[0][3] * B.m[3][0] + A.m[1][3] * B.m[3][1] + A.m[2][3] * B.m[3][2] + A.m[3][3] * B.m[3][3];

	movss	DWORD PTR _mCombineR$12[esp+548], xmm4
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp

; 288  : 			CHK_DX					(HW.pDevice->SetViewport(&VP));

	call	DWORD PTR [ecx+188]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	eax, DWORD PTR [ebx+24]
	sub	eax, DWORD PTR [ebx+20]
	sar	eax, 2
	imul	eax, eax, 678152731
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp

; 291  : 			for (u32 n_it=0; n_it<C.nodes.size(); n_it++)

	mov	DWORD PTR _n_it$1$[esp+480], 0
	test	eax, eax
	je	SHORT $LN17@calculate
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 273  : 		x = v1.y  * v2.z  - v1.z  * v2.y ;

	xor	ecx, ecx
	mov	DWORD PTR tv4826[esp+480], ecx
	npad	5
$LL18@calculate:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 119  :         _Ptr += _Off;

	mov	esi, DWORD PTR [ebx+20]
	add	esi, ecx
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp

; 295  : 				RCache.set_Element		(V->shader->E[SE_R1_LMODELS]);

	mov	ecx, DWORD PTR __imp_?RCache@@3VCBackend@@A
	push	0
	mov	edi, DWORD PTR [esi+8]
	mov	eax, DWORD PTR [edi+64]
	add	eax, 24					; 00000018H
	push	eax
	call	DWORD PTR __imp_?set_Element@CBackend@@QAEXAAV?$resptr_core@UShaderElement@@V?$resptr_base@UShaderElement@@@@@@I@Z

; 296  : 				RCache.set_xform_world	(N.Matrix);

	mov	ecx, DWORD PTR __imp_?RCache@@3VCBackend@@A
	lea	eax, DWORD PTR [esi+12]
	push	eax
	call	DWORD PTR __imp_?set_xform_world@CBackend@@QAEXABU?$_matrix@M@@@Z

; 297  : 				V->Render				(-1.0f);

	mov	eax, DWORD PTR [edi]
	fld	DWORD PTR __real@bf800000
	push	ecx
	mov	ecx, edi
	fstp	DWORD PTR [esp]
	call	DWORD PTR [eax]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	eax, DWORD PTR [ebx+24]
	sub	eax, DWORD PTR [ebx+20]
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp

; 291  : 			for (u32 n_it=0; n_it<C.nodes.size(); n_it++)

	mov	edx, DWORD PTR _n_it$1$[esp+480]
	mov	ecx, DWORD PTR tv4826[esp+480]
	inc	edx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	sar	eax, 2
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp

; 291  : 			for (u32 n_it=0; n_it<C.nodes.size(); n_it++)

	add	ecx, 76					; 0000004cH
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	imul	eax, eax, 678152731
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp

; 291  : 			for (u32 n_it=0; n_it<C.nodes.size(); n_it++)

	mov	DWORD PTR _n_it$1$[esp+480], edx
	mov	DWORD PTR tv4826[esp+480], ecx
	cmp	edx, eax
	jb	SHORT $LL18@calculate
	mov	edi, DWORD PTR _this$1$[esp+480]
$LN17@calculate:

; 301  : 			shadows.push_back		(shadow());

	push	92					; 0000005cH
	lea	eax, DWORD PTR $T13[esp+484]
	push	0
	push	eax
	call	_memset
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 730  :         if (_Mylast != _My_data._Myend) {

	mov	edx, DWORD PTR [edi+32]
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp

; 301  : 			shadows.push_back		(shadow());

	lea	eax, DWORD PTR [edi+28]
	add	esp, 12					; 0000000cH
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 730  :         if (_Mylast != _My_data._Myend) {

	cmp	edx, DWORD PTR [eax+8]
	je	SHORT $LN199@calculate
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	ecx, 23					; 00000017H
	lea	esi, DWORD PTR $T13[esp+480]
	mov	edi, edx
	rep movsd
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 716  :         ++_Mylast;

	add	DWORD PTR [eax+4], 92			; 0000005cH

; 731  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

	mov	edi, DWORD PTR _this$1$[esp+480]
	jmp	SHORT $LN198@calculate
$LN199@calculate:

; 732  :         }
; 733  : 
; 734  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	lea	ecx, DWORD PTR $T13[esp+480]
	push	ecx
	push	edx
	mov	ecx, eax
	call	??$_Emplace_reallocate@Ushadow@CLightShadows@@@?$vector@Ushadow@CLightShadows@@V?$xalloc@Ushadow@CLightShadows@@@@@std@@QAEPAUshadow@CLightShadows@@QAU23@$$QAU23@@Z ; std::vector<CLightShadows::shadow,xalloc<CLightShadows::shadow> >::_Emplace_reallocate<CLightShadows::shadow>
$LN198@calculate:
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp

; 302  : 			shadows.back().O		=	C.O;

	mov	ecx, DWORD PTR [edi+32]

; 303  : 			shadows.back().slot		=	slot_id;
; 304  : 			shadows.back().C		=	C.C;
; 305  : 			shadows.back().M		=	mCombineR;

	lea	esi, DWORD PTR _mCombineR$12[esp+480]
	mov	eax, DWORD PTR [ebx]

; 306  : 			shadows.back().L		=	L.source;

	mov	edx, DWORD PTR $T8[esp+480]
	mov	DWORD PTR [ecx-92], eax
	mov	eax, DWORD PTR [edi+32]
	mov	ecx, DWORD PTR _slot_id$1$[esp+480]
	mov	DWORD PTR [eax-88], ecx
	mov	ecx, DWORD PTR [edi+32]
	mov	eax, DWORD PTR [ebx+4]
	mov	DWORD PTR [ecx-84], eax
	mov	eax, DWORD PTR [ebx+8]
	mov	DWORD PTR [ecx-80], eax
	mov	eax, DWORD PTR [ebx+12]
	mov	DWORD PTR [ecx-76], eax
	mov	ecx, 16					; 00000010H
	mov	edi, DWORD PTR [edi+32]
	sub	edi, 72					; 00000048H

; 307  : 			shadows.back().E		=	L.energy;
; 308  : #ifdef DEBUG
; 309  : 			shadows.back().dbg_HAT	=	p_hat;
; 310  : #endif
; 311  : 			slot_id	++;

	inc	DWORD PTR _slot_id$1$[esp+480]
	rep movsd
	mov	edi, DWORD PTR _this$1$[esp+480]
	mov	esi, DWORD PTR tv4816[esp+480]
	mov	ecx, DWORD PTR [edi+32]
	mov	eax, DWORD PTR [esi+edx]
	mov	DWORD PTR [ecx-8], eax
	mov	eax, DWORD PTR [edi+32]
	fld	DWORD PTR [esi+edx+4]
	mov	edx, esi
	fstp	DWORD PTR [eax-4]
$LN354@calculate:

; 199  : 		for (u32 l_it=0; (l_it<lights.size()) && (slot_id<slot_max); l_it++)

	mov	ecx, DWORD PTR _l_it$1$[esp+480]
$LN5@calculate:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	eax, DWORD PTR _lights$1$[esp+480]
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp

; 199  : 		for (u32 l_it=0; (l_it<lights.size()) && (slot_id<slot_max); l_it++)

	inc	ecx
	add	edx, 24					; 00000018H
	mov	DWORD PTR _l_it$1$[esp+480], ecx
	mov	DWORD PTR tv4816[esp+480], edx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	esi, DWORD PTR [eax]
	mov	eax, DWORD PTR [eax+4]
	sub	eax, esi
	mov	DWORD PTR $T8[esp+480], esi
	sar	eax, 3
	imul	eax, eax, -1431655765
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp

; 199  : 		for (u32 l_it=0; (l_it<lights.size()) && (slot_id<slot_max); l_it++)

	cmp	ecx, eax
	jb	$LL7@calculate
$LN2@calculate:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	edx, DWORD PTR [edi+20]
	mov	eax, edx
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp

; 189  : 	for (u32 o_it=0; o_it<casters.size(); o_it++)

	mov	ebx, DWORD PTR _o_it$1$[esp+480]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	ecx, DWORD PTR [edi+16]
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp

; 189  : 	for (u32 o_it=0; o_it<casters.size(); o_it++)

	inc	ebx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	sub	eax, ecx
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp

; 189  : 	for (u32 o_it=0; o_it<casters.size(); o_it++)

	mov	DWORD PTR _o_it$1$[esp+480], ebx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	sar	eax, 2
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp

; 189  : 	for (u32 o_it=0; o_it<casters.size(); o_it++)

	cmp	ebx, eax
	jb	$LL4@calculate
$LN3@calculate:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	sub	edx, ecx
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp

; 316  : 	for (u32 cs=0; cs<casters.size(); cs++)

	xor	ebx, ebx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	sar	edx, 2
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp

; 316  : 	for (u32 cs=0; cs<casters.size(); cs++)

	test	edx, edx
	je	SHORT $LN20@calculate
$LL21@calculate:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 119  :         _Ptr += _Off;

	lea	eax, DWORD PTR [ecx+ebx*4]

; 730  :         if (_Mylast != _My_data._Myend) {

	mov	ecx, DWORD PTR [edi+8]
	cmp	ecx, DWORD PTR [edi+12]
	je	SHORT $LN243@calculate

; 713  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax

; 716  :         ++_Mylast;

	add	DWORD PTR [edi+8], 4

; 731  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

	jmp	SHORT $LN19@calculate
$LN243@calculate:

; 732  :         }
; 733  : 
; 734  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	push	eax
	push	ecx
	lea	ecx, DWORD PTR [edi+4]
	call	??$_Emplace_reallocate@ABQAUcaster@CLightShadows@@@?$vector@PAUcaster@CLightShadows@@V?$xalloc@PAUcaster@CLightShadows@@@@@std@@QAEPAPAUcaster@CLightShadows@@QAPAU23@ABQAU23@@Z ; std::vector<CLightShadows::caster *,xalloc<CLightShadows::caster *> >::_Emplace_reallocate<CLightShadows::caster * const &>
$LN19@calculate:

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	eax, DWORD PTR [edi+20]
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp

; 316  : 	for (u32 cs=0; cs<casters.size(); cs++)

	inc	ebx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	ecx, DWORD PTR [edi+16]
	sub	eax, ecx
	sar	eax, 2
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp

; 316  : 	for (u32 cs=0; cs<casters.size(); cs++)

	cmp	ebx, eax
	jb	SHORT $LL21@calculate
$LN20@calculate:

; 317  : 		casters_pool.push_back(casters[cs]);
; 318  : 	casters.clear	();
; 319  : 	
; 320  : 	// Blur
; 321  : 	if (bRTS)

	cmp	DWORD PTR _bRTS$1$[esp+480], 0
	mov	DWORD PTR [edi+20], ecx
	je	$LN36@calculate
; File I:\Vitalya\mine\NSProjectX\xrEngine\shader.h

; 67   : 	u32					stride()	const { return _get()->vb_stride; }

	mov	eax, DWORD PTR [edi+104]
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp

; 325  : 		FVF::TL4uv* pv				= (FVF::TL4uv*) RCache.Vertex.Lock	(4,geom_Blur.stride(),Offset);

	lea	ecx, DWORD PTR _Offset$6[esp+480]
	push	ecx
	mov	ecx, DWORD PTR __imp_?RCache@@3VCBackend@@A
	push	DWORD PTR [eax+20]
	push	4
	call	DWORD PTR __imp_?Lock@_VertexStream@@QAEPAXIIAAI@Z
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector4.h

; 17   : 	IC	SelfRef 	set(T _x, T _y, T _z, T _w=1)		{ x=_x;		y=_y;		z=_z;		w=_w;		return *this; }

	mov	DWORD PTR [eax], 925353388		; 3727c5acH
	mov	DWORD PTR [eax+4], 1140850688		; 44000000H
	mov	DWORD PTR [eax+8], 925353388		; 3727c5acH
	mov	DWORD PTR [eax+12], 1065353216		; 3f800000H
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp

; 563  : 	pv->p.set(EPS,			float(_h+EPS),	EPS,1.f); pv->color=_c; pv->uv[0].set(p0.x-kw,p1.y-kh);pv->uv[1].set(p0.x+kw,p1.y+kh);pv->uv[2].set(p0.x+kw,p1.y-kh);pv->uv[3].set(p0.x-kw,p1.y+kh);pv++;

	mov	DWORD PTR [eax+16], -1
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector2.h

; 15   : 	IC SelfRef set(float _u, float _v)				{ x=T(_u); y=T(_v);				return *this;	}

	mov	DWORD PTR [eax+20], -1174405120		; ba000000H
	mov	DWORD PTR [eax+24], 1065345024		; 3f7fe000H
	mov	DWORD PTR [eax+28], 991952896		; 3b200000H
	mov	DWORD PTR [eax+32], 1065373696		; 3f805000H
	mov	DWORD PTR [eax+36], 991952896		; 3b200000H
	mov	DWORD PTR [eax+40], 1065345024		; 3f7fe000H
	mov	DWORD PTR [eax+44], -1174405120		; ba000000H
	mov	DWORD PTR [eax+48], 1065373696		; 3f805000H
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector4.h

; 17   : 	IC	SelfRef 	set(T _x, T _y, T _z, T _w=1)		{ x=_x;		y=_y;		z=_z;		w=_w;		return *this; }

	mov	DWORD PTR [eax+52], 925353388		; 3727c5acH
	mov	DWORD PTR [eax+56], 925353388		; 3727c5acH
	mov	DWORD PTR [eax+60], 925353388		; 3727c5acH
	mov	DWORD PTR [eax+64], 1065353216		; 3f800000H
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp

; 564  : 	pv->p.set(EPS,			EPS,			EPS,1.f); pv->color=_c; pv->uv[0].set(p0.x-kw,p0.y-kh);pv->uv[1].set(p0.x+kw,p0.y+kh);pv->uv[2].set(p0.x+kw,p0.y-kh);pv->uv[3].set(p0.x-kw,p0.y+kh);pv++;

	mov	DWORD PTR [eax+68], -1
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector2.h

; 15   : 	IC SelfRef set(float _u, float _v)				{ x=T(_u); y=T(_v);				return *this;	}

	mov	DWORD PTR [eax+72], -1174405120		; ba000000H
	mov	DWORD PTR [eax+76], -1174405120		; ba000000H
	mov	DWORD PTR [eax+80], 991952896		; 3b200000H
	mov	DWORD PTR [eax+84], 991952896		; 3b200000H
	mov	DWORD PTR [eax+88], 991952896		; 3b200000H
	mov	DWORD PTR [eax+92], -1174405120		; ba000000H
	mov	DWORD PTR [eax+96], -1174405120		; ba000000H
	mov	DWORD PTR [eax+100], 991952896		; 3b200000H
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector4.h

; 17   : 	IC	SelfRef 	set(T _x, T _y, T _z, T _w=1)		{ x=_x;		y=_y;		z=_z;		w=_w;		return *this; }

	mov	DWORD PTR [eax+104], 1140850688		; 44000000H
	mov	DWORD PTR [eax+108], 1140850688		; 44000000H
	mov	DWORD PTR [eax+112], 925353388		; 3727c5acH
	mov	DWORD PTR [eax+116], 1065353216		; 3f800000H
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp

; 565  : 	pv->p.set(float(_w+EPS),float(_h+EPS),	EPS,1.f); pv->color=_c; pv->uv[0].set(p1.x-kw,p1.y-kh);pv->uv[1].set(p1.x+kw,p1.y+kh);pv->uv[2].set(p1.x+kw,p1.y-kh);pv->uv[3].set(p1.x-kw,p1.y+kh);pv++;

	mov	DWORD PTR [eax+120], -1
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector2.h

; 15   : 	IC SelfRef set(float _u, float _v)				{ x=T(_u); y=T(_v);				return *this;	}

	mov	DWORD PTR [eax+124], 1065345024		; 3f7fe000H
	mov	DWORD PTR [eax+128], 1065345024		; 3f7fe000H
	mov	DWORD PTR [eax+132], 1065373696		; 3f805000H
	mov	DWORD PTR [eax+136], 1065373696		; 3f805000H
	mov	DWORD PTR [eax+140], 1065373696		; 3f805000H
	mov	DWORD PTR [eax+144], 1065345024		; 3f7fe000H
	mov	DWORD PTR [eax+148], 1065345024		; 3f7fe000H
	mov	DWORD PTR [eax+152], 1065373696		; 3f805000H
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector4.h

; 17   : 	IC	SelfRef 	set(T _x, T _y, T _z, T _w=1)		{ x=_x;		y=_y;		z=_z;		w=_w;		return *this; }

	mov	DWORD PTR [eax+156], 1140850688		; 44000000H
	mov	DWORD PTR [eax+160], 925353388		; 3727c5acH
	mov	DWORD PTR [eax+164], 925353388		; 3727c5acH
	mov	DWORD PTR [eax+168], 1065353216		; 3f800000H
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp

; 566  : 	pv->p.set(float(_w+EPS),EPS,			EPS,1.f); pv->color=_c; pv->uv[0].set(p1.x-kw,p0.y-kh);pv->uv[1].set(p1.x+kw,p0.y+kh);pv->uv[2].set(p1.x+kw,p0.y-kh);pv->uv[3].set(p1.x-kw,p0.y+kh);pv++;

	mov	DWORD PTR [eax+172], -1
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector2.h

; 15   : 	IC SelfRef set(float _u, float _v)				{ x=T(_u); y=T(_v);				return *this;	}

	mov	DWORD PTR [eax+176], 1065345024		; 3f7fe000H
	mov	DWORD PTR [eax+180], -1174405120	; ba000000H
	mov	DWORD PTR [eax+184], 1065373696		; 3f805000H
	mov	DWORD PTR [eax+188], 991952896		; 3b200000H
	mov	DWORD PTR [eax+192], 1065373696		; 3f805000H
	mov	DWORD PTR [eax+196], -1174405120	; ba000000H
	mov	DWORD PTR [eax+200], 1065345024		; 3f7fe000H
	mov	DWORD PTR [eax+204], 991952896		; 3b200000H
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp

; 327  : 		RCache.Vertex.Unlock		(4,geom_Blur.stride());

	mov	eax, DWORD PTR [edi+104]
	mov	ecx, DWORD PTR __imp_?RCache@@3VCBackend@@A
	push	DWORD PTR [eax+20]
	push	4
	call	DWORD PTR __imp_?Unlock@_VertexStream@@QAEXII@Z

; 328  : 		
; 329  : 		// Actual rendering (pass0, temp2real)
; 330  : 		RCache.set_RT				(RT->pRT	);

	mov	eax, DWORD PTR [edi+88]
	mov	ecx, DWORD PTR __imp_?RCache@@3VCBackend@@A
	push	0
	push	DWORD PTR [eax+16]
	call	DWORD PTR __imp_?set_RT@CBackend@@QAEXPAUIDirect3DSurface9@@I@Z

; 331  : 		RCache.set_ZB				(RImplementation.Target->pTempZB	);

	mov	eax, DWORD PTR ?RImplementation@@3VCRender@@A+1012
	mov	ecx, DWORD PTR __imp_?RCache@@3VCBackend@@A
	push	DWORD PTR [eax+104]
	call	DWORD PTR __imp_?set_ZB@CBackend@@QAEXPAUIDirect3DSurface9@@@Z

; 332  : 		RCache.set_Shader			(sh_BlurTR	);

	mov	ecx, DWORD PTR __imp_?RCache@@3VCBackend@@A
	lea	eax, DWORD PTR [edi+96]
	push	0
	push	eax
	call	DWORD PTR __imp_?set_Shader@CBackend@@QAEXAAV?$resptr_core@UShader@@Uresptrcode_shader@@@@I@Z
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 70   : 	T &					operator*() const												{	return *p_;	}

	mov	edi, DWORD PTR [edi+104]
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp

; 333  : 		RCache.set_Geometry			(geom_Blur	);

	mov	esi, DWORD PTR __imp_?RCache@@3VCBackend@@A
; File I:\Vitalya\mine\NSProjectX\xrEngine\R_Backend_Runtime.h

; 224  : 	set_Format(_geom->dcl._get()->dcl);

	mov	eax, DWORD PTR [edi+8]
	mov	edx, DWORD PTR [eax+8]

; 131  : 	if (decl != _decl)

	cmp	DWORD PTR [esi+592], edx
	je	SHORT $LN310@calculate

; 132  : 	{
; 133  : 		PGO(Msg("PGO:v_format:%x", _decl));
; 134  : #ifdef DEBUG
; 135  : 		stat.decl++;
; 136  : #endif
; 137  : 		decl = _decl;

	mov	DWORD PTR [esi+592], edx

; 138  : 		CHK_DX(HW.pDevice->SetVertexDeclaration(decl));

	mov	eax, DWORD PTR __imp_?HW@@3VCHW@@A
	push	edx
	mov	eax, DWORD PTR [eax+8]
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+348]
$LN310@calculate:

; 225  : 	set_Vertices(_geom->vb, _geom->vb_stride);

	mov	ebx, DWORD PTR [edi+12]
	mov	edx, DWORD PTR [edi+20]

; 172  : 	if ((vb != _vb) || (vb_stride != _vb_stride))

	cmp	DWORD PTR [esi+596], ebx
	jne	SHORT $LN314@calculate
	cmp	DWORD PTR [esi+604], edx
	je	SHORT $LN313@calculate
$LN314@calculate:

; 173  : 	{
; 174  : 		PGO(Msg("PGO:VB:%x,%d", _vb, _vb_stride));
; 175  : #ifdef DEBUG
; 176  : 		stat.vb++;
; 177  : #endif
; 178  : 		vb = _vb;

	mov	DWORD PTR [esi+596], ebx

; 179  : 		vb_stride = _vb_stride;

	mov	DWORD PTR [esi+604], edx

; 180  : 		CHK_DX(HW.pDevice->SetStreamSource(0, vb, 0, vb_stride));

	mov	eax, DWORD PTR __imp_?HW@@3VCHW@@A
	push	edx
	push	0
	push	ebx
	mov	eax, DWORD PTR [eax+8]
	push	0
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+400]
$LN313@calculate:

; 226  : 	set_Indices(_geom->ib);

	mov	edx, DWORD PTR [edi+16]

; 186  : 	if (ib != _ib)

	cmp	DWORD PTR [esi+600], edx
	je	SHORT $LN317@calculate

; 187  : 	{
; 188  : 		PGO(Msg("PGO:IB:%x", _ib));
; 189  : #ifdef DEBUG
; 190  : 		stat.ib++;
; 191  : #endif
; 192  : 		ib = _ib;

	mov	DWORD PTR [esi+600], edx

; 193  : 		CHK_DX(HW.pDevice->SetIndices(ib));

	mov	eax, DWORD PTR __imp_?HW@@3VCHW@@A
	push	edx
	mov	eax, DWORD PTR [eax+8]
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+416]
$LN317@calculate:
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp

; 334  : 		RCache.Render				(D3DPT_TRIANGLELIST,Offset,0,4,0,2);

	mov	eax, DWORD PTR __imp_?RCache@@3VCBackend@@A
	mov	esi, DWORD PTR _Offset$6[esp+480]
; File I:\Vitalya\mine\NSProjectX\xrEngine\R_Backend_Runtime.h

; 202  : 	constants.flush();

	lea	ecx, DWORD PTR [eax+608]
	inc	DWORD PTR [eax+9024]
	add	DWORD PTR [eax+9020], 4
	add	DWORD PTR [eax+9016], 2
; File I:\Vitalya\mine\NSProjectX\xrEngine\r_constants_cache.h

; 172  : 		if (a_pixel.b_dirty || a_vertex.b_dirty)	flush_cache();

	cmp	DWORD PTR [ecx+4112], 0
	jne	SHORT $LN323@calculate
	cmp	DWORD PTR [ecx+8240], 0
	je	SHORT $LN322@calculate
$LN323@calculate:
	call	DWORD PTR __imp_?flush_cache@R_constants@@QAEXXZ
$LN322@calculate:
; File I:\Vitalya\mine\NSProjectX\xrEngine\R_Backend_Runtime.h

; 203  : 	CHK_DX(HW.pDevice->DrawIndexedPrimitive(T, baseV, startV, countV, startI, PC));

	mov	eax, DWORD PTR __imp_?HW@@3VCHW@@A
	push	2
	push	0
	push	4
	mov	eax, DWORD PTR [eax+8]
	push	0
	push	esi
	push	4
	mov	ecx, DWORD PTR [eax]
	push	eax
	call	DWORD PTR [ecx+328]
$LN36@calculate:
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp

; 338  : 	HW.pDevice->SetRenderState				(D3DRS_ZENABLE, D3DZB_TRUE);

	mov	eax, DWORD PTR __imp_?HW@@3VCHW@@A
	push	1
	push	7
	mov	eax, DWORD PTR [eax+8]
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+228]
; File I:\Vitalya\mine\NSProjectX\xrCore\FTimer.h

; 174  : 	ICF void	End				()		{	if (!g_bEnableStatGather) return;	accum += T.GetElapsed_ticks();	}

	mov	eax, DWORD PTR __imp_?g_bEnableStatGather@@3HA
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp

; 339  : 	Device.Statistic->RenderDUMP_Scalc.End	();

	mov	ecx, DWORD PTR __imp_?Device@@3VCRenderDevice@@A
; File I:\Vitalya\mine\NSProjectX\xrCore\FTimer.h

; 174  : 	ICF void	End				()		{	if (!g_bEnableStatGather) return;	accum += T.GetElapsed_ticks();	}

	cmp	DWORD PTR [eax], 0
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp

; 339  : 	Device.Statistic->RenderDUMP_Scalc.End	();

	mov	esi, DWORD PTR [ecx+436]
; File I:\Vitalya\mine\NSProjectX\xrCore\FTimer.h

; 174  : 	ICF void	End				()		{	if (!g_bEnableStatGather) return;	accum += T.GetElapsed_ticks();	}

	je	SHORT $LN325@calculate
	lea	ecx, DWORD PTR [esi+2576]
	call	DWORD PTR __imp_?GetElapsed_ticks@CTimer@@QBE_KXZ
	add	DWORD PTR [esi+2632], eax
	adc	DWORD PTR [esi+2636], edx
	mov	ecx, DWORD PTR __imp_?Device@@3VCRenderDevice@@A
$LN325@calculate:
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp

; 341  : 	RCache.set_xform_project	(Device.mProject);

	lea	eax, DWORD PTR [ecx+600]
	mov	ecx, DWORD PTR __imp_?RCache@@3VCBackend@@A
	push	eax
	call	DWORD PTR __imp_?set_xform_project@CBackend@@QAEXABU?$_matrix@M@@@Z

; 342  : 	RCache.set_xform_view		(Device.mView);

	mov	eax, DWORD PTR __imp_?Device@@3VCRenderDevice@@A
	mov	ecx, DWORD PTR __imp_?RCache@@3VCBackend@@A
	add	eax, 536				; 00000218H
	push	eax
	call	DWORD PTR __imp_?set_xform_view@CBackend@@QAEXABU?$_matrix@M@@@Z
$LN1@calculate:

; 343  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?calculate@CLightShadows@@QAEXXZ ENDP			; CLightShadows::calculate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp
_TEXT	SEGMENT
_D$1$ = -16						; size = 4
_C$1 = -12						; size = 12
_cs$2 = 8						; size = 4
_O$ = 8							; size = 4
?set_object@CLightShadows@@QAEXPAVIRenderable@@@Z PROC	; CLightShadows::set_object
; _this$ = ecx

; 85   : {

	sub	esp, 16					; 00000010H
	push	ebx

; 86   : 	if (0==O)	current		= 0;

	mov	ebx, DWORD PTR _O$[esp+16]
	push	ebp
	push	edi
	mov	edi, ecx
	test	ebx, ebx
	je	$LN5@set_object

; 87   : 	else 
; 88   : 	{
; 89   : 		if (!O->renderable_ShadowGenerate()	|| RImplementation.val_bHUD || ((CROS_impl*)O->renderable_ROS())->shadow_gen_frame==Device.dwFrame)

	mov	eax, DWORD PTR [ebx]
	mov	ecx, ebx
	call	DWORD PTR [eax+8]
	test	eax, eax
	je	$LN5@set_object
	cmp	DWORD PTR ?RImplementation@@3VCRender@@A+268, 0
	jne	$LN5@set_object
	mov	ebp, DWORD PTR __imp_?renderable_ROS@IRenderable@@QAEPAVIRender_ObjectSpecific@@XZ
	mov	ecx, ebx
	call	ebp
	mov	ecx, DWORD PTR __imp_?Device@@3VCRenderDevice@@A
	mov	eax, DWORD PTR [eax+1920]
	cmp	eax, DWORD PTR [ecx+244]
	je	$LN5@set_object

; 90   : 		{
; 91   : 			current		= 0;
; 92   : 			return;
; 93   : 		}
; 94   : 
; 95   : 		Fvector		C;	O->renderable.xform.transform_tiny		(C,O->renderable.visual->vis.sphere.P);

	mov	eax, DWORD PTR [ebx+68]
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 499  : 		dest.x = v.x*_11 + v.y*_21 + v.z*_31 + _41;

	movss	xmm1, DWORD PTR [eax+12]
	movss	xmm5, DWORD PTR [eax+8]
	movaps	xmm4, xmm1
	mulss	xmm4, DWORD PTR [ebx+20]
	movaps	xmm0, xmm5
	mulss	xmm0, DWORD PTR [ebx+4]

; 500  : 		dest.y = v.x*_12 + v.y*_22 + v.z*_32 + _42;

	movaps	xmm3, xmm5
	movss	xmm2, DWORD PTR [eax+16]
	mulss	xmm3, DWORD PTR [ebx+8]
	addss	xmm4, xmm0

; 501  : 		dest.z = v.x*_13 + v.y*_23 + v.z*_33 + _43;

	mulss	xmm5, DWORD PTR [ebx+12]
	movaps	xmm0, xmm2
	mulss	xmm0, DWORD PTR [ebx+36]
	addss	xmm0, DWORD PTR [ebx+52]
	addss	xmm4, xmm0
	movaps	xmm0, xmm1
	mulss	xmm0, DWORD PTR [ebx+24]
	mulss	xmm1, DWORD PTR [ebx+28]
	addss	xmm3, xmm0
	movss	DWORD PTR _C$1[esp+28], xmm4
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 287  : 	{	return (x-v.x)*(x-v.x) + (y-v.y)*(y-v.y) + (z-v.z)*(z-v.z);	}

	subss	xmm4, DWORD PTR [ecx+488]
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 500  : 		dest.y = v.x*_12 + v.y*_22 + v.z*_32 + _42;

	movaps	xmm0, xmm2

; 501  : 		dest.z = v.x*_13 + v.y*_23 + v.z*_33 + _43;

	addss	xmm5, xmm1
	mulss	xmm0, DWORD PTR [ebx+40]
	mulss	xmm2, DWORD PTR [ebx+44]
	addss	xmm0, DWORD PTR [ebx+56]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 287  : 	{	return (x-v.x)*(x-v.x) + (y-v.y)*(y-v.y) + (z-v.z)*(z-v.z);	}

	mulss	xmm4, xmm4
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 501  : 		dest.z = v.x*_13 + v.y*_23 + v.z*_33 + _43;

	addss	xmm2, DWORD PTR [ebx+60]
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp

; 100  : 		float		_priority		= (D/S_distance)*(S_ideal_size/(R+EPS));

	movss	xmm1, DWORD PTR __real@3daaaaab
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 500  : 		dest.y = v.x*_12 + v.y*_22 + v.z*_32 + _42;

	addss	xmm3, xmm0
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp

; 96   : 		float		R				= O->renderable.visual->vis.sphere.R;

	movss	xmm0, DWORD PTR [eax+20]
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 501  : 		dest.z = v.x*_13 + v.y*_23 + v.z*_33 + _43;

	addss	xmm5, xmm2
	movss	DWORD PTR _C$1[esp+32], xmm3
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 287  : 	{	return (x-v.x)*(x-v.x) + (y-v.y)*(y-v.y) + (z-v.z)*(z-v.z);	}

	subss	xmm3, DWORD PTR [ecx+492]
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 501  : 		dest.z = v.x*_13 + v.y*_23 + v.z*_33 + _43;

	movss	DWORD PTR _C$1[esp+36], xmm5
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 287  : 	{	return (x-v.x)*(x-v.x) + (y-v.y)*(y-v.y) + (z-v.z)*(z-v.z);	}

	subss	xmm5, DWORD PTR [ecx+496]
	mulss	xmm3, xmm3
	mulss	xmm5, xmm5
	addss	xmm4, xmm3
	addss	xmm4, xmm5
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h

; 764  :             return (float)sqrt(_X);

	sqrtss	xmm2, xmm4
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp

; 97   : 		float		D				= C.distance_to(Device.vCameraPosition)+R;

	addss	xmm2, xmm0

; 100  : 		float		_priority		= (D/S_distance)*(S_ideal_size/(R+EPS));

	addss	xmm0, DWORD PTR __real@3727c5ac
	movss	DWORD PTR _D$1$[esp+28], xmm2
	divss	xmm1, xmm0

; 101  : 		if (_priority<1.f)		current	= O;

	movss	xmm0, DWORD PTR __real@3f800000
	mulss	xmm1, xmm2
	comiss	xmm0, xmm1
	jbe	$LN5@set_object
	push	esi
	mov	DWORD PTR [edi], ebx

; 102  : 		else					current = 0;
; 103  : 		
; 104  : 		if (current)
; 105  : 		{
; 106  : 			((CROS_impl*)O->renderable_ROS())->shadow_gen_frame	=	Device.dwFrame;

	mov	ecx, ebx
	mov	esi, DWORD PTR __imp_?Device@@3VCRenderDevice@@A
	call	ebp
	lea	ecx, DWORD PTR [eax+1920]
	mov	eax, DWORD PTR [esi+244]
	mov	DWORD PTR [ecx], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1531 :         return _My_data._Myfirst == _My_data._Mylast;

	mov	eax, DWORD PTR [edi+4]
	cmp	eax, DWORD PTR [edi+8]
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp

; 110  : 			if (casters_pool.empty())	cs	= xr_new<caster> ();

	jne	SHORT $LN9@set_object
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h

; 68   : 	T* ptr	= (T*)Memory.mem_alloc(sizeof(T));

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	32					; 00000020H
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z

; 69   : 	return new (ptr) T();

	mov	esi, eax
	xor	eax, eax
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	mov	DWORD PTR [esi+12], eax
	mov	DWORD PTR [esi+16], eax
	mov	DWORD PTR [esi+20], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [esi+24], eax
	mov	DWORD PTR [esi+28], eax
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp

; 110  : 			if (casters_pool.empty())	cs	= xr_new<caster> ();

	jmp	SHORT $LN10@set_object
$LN9@set_object:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1611 :         return _My_data._Mylast[-1];

	mov	eax, DWORD PTR [edi+8]
	add	eax, -4					; fffffffcH
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp

; 112  : 				cs	= casters_pool.back	();

	mov	esi, DWORD PTR [eax]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1390 :         --_Mylast;

	mov	DWORD PTR [edi+8], eax
$LN10@set_object:
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp

; 117  : 			casters.push_back	(cs);

	lea	eax, DWORD PTR _cs$2[esp+28]
	mov	DWORD PTR _cs$2[esp+28], esi
	push	eax
	lea	ecx, DWORD PTR [edi+16]
	call	?push_back@?$vector@PAUcaster@CLightShadows@@V?$xalloc@PAUcaster@CLightShadows@@@@@std@@QAEXABQAUcaster@CLightShadows@@@Z ; std::vector<CLightShadows::caster *,xalloc<CLightShadows::caster *> >::push_back

; 118  : 			cs->O				= current;

	mov	eax, DWORD PTR [edi]

; 119  : 			cs->C				= C;
; 120  : 			cs->D				= D;

	movss	xmm0, DWORD PTR _D$1$[esp+32]
	mov	DWORD PTR [esi], eax
	mov	eax, DWORD PTR _C$1[esp+32]
	mov	DWORD PTR [esi+4], eax
	mov	eax, DWORD PTR _C$1[esp+36]
	mov	DWORD PTR [esi+8], eax
	mov	eax, DWORD PTR _C$1[esp+40]
	mov	DWORD PTR [esi+12], eax
	movss	DWORD PTR [esi+16], xmm0

; 121  : 			cs->nodes.clear		();

	mov	eax, DWORD PTR [esi+20]
	mov	DWORD PTR [esi+24], eax
	pop	esi
	pop	edi

; 122  : 		}
; 123  : 	}
; 124  : }

	pop	ebp
	pop	ebx
	add	esp, 16					; 00000010H
	ret	4
$LN5@set_object:
	mov	DWORD PTR [edi], 0
	pop	edi
	pop	ebp
	pop	ebx
	add	esp, 16					; 00000010H
	ret	4
?set_object@CLightShadows@@QAEXPAVIRenderable@@@Z ENDP	; CLightShadows::set_object
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp
_TEXT	SEGMENT
_ptr$1$ = -4						; size = 4
_it$1$ = -4						; size = 4
??1CLightShadows@@QAE@XZ PROC				; CLightShadows::~CLightShadows
; _this$ = ecx

; 59   : {

	push	ecx
	push	ebx
	push	ebp
	push	esi
	mov	esi, ecx
	push	edi
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 46   : 	ICF		void		_set	(T * rhs) 							{	if (0!=rhs) rhs->dwReference++;	_dec(); p_ = rhs;											}

	lea	ecx, DWORD PTR [esi+116]
	call	DWORD PTR __imp_?_dec@?$resptr_base@UShader@@@@IAEXXZ
	lea	ecx, DWORD PTR [esi+120]
	mov	DWORD PTR [esi+116], 0
	call	DWORD PTR __imp_?_dec@?$resptr_base@USGeometry@@@@IAEXXZ
	lea	ecx, DWORD PTR [esi+104]
	mov	DWORD PTR [esi+120], 0
	call	DWORD PTR __imp_?_dec@?$resptr_base@USGeometry@@@@IAEXXZ
	lea	ecx, DWORD PTR [esi+112]
	mov	DWORD PTR [esi+104], 0
	call	DWORD PTR __imp_?_dec@?$resptr_base@USGeometry@@@@IAEXXZ
	lea	ecx, DWORD PTR [esi+100]
	mov	DWORD PTR [esi+112], 0
	call	DWORD PTR __imp_?_dec@?$resptr_base@UShader@@@@IAEXXZ
	lea	ecx, DWORD PTR [esi+96]
	mov	DWORD PTR [esi+100], 0
	call	DWORD PTR __imp_?_dec@?$resptr_base@UShader@@@@IAEXXZ
	lea	ecx, DWORD PTR [esi+108]
	mov	DWORD PTR [esi+96], 0
	call	DWORD PTR __imp_?_dec@?$resptr_base@UShader@@@@IAEXXZ
	lea	ecx, DWORD PTR [esi+92]
	mov	DWORD PTR [esi+108], 0
	call	DWORD PTR __imp_?_dec@?$resptr_base@VCRT@@@@IAEXXZ
	lea	ecx, DWORD PTR [esi+88]
	mov	DWORD PTR [esi+92], 0
	call	DWORD PTR __imp_?_dec@?$resptr_base@VCRT@@@@IAEXXZ
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp

; 74   : 	for (u32 it=0; it<casters_pool.size(); it++)

	mov	ebx, DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
	xor	ebp, ebp
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 46   : 	ICF		void		_set	(T * rhs) 							{	if (0!=rhs) rhs->dwReference++;	_dec(); p_ = rhs;											}

	mov	DWORD PTR [esi+88], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	eax, DWORD PTR [esi+8]
	mov	ecx, DWORD PTR [esi+4]
	sub	eax, ecx
	sar	eax, 2
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp

; 74   : 	for (u32 it=0; it<casters_pool.size(); it++)

	test	eax, eax
	je	SHORT $LN3@CLightShad
	npad	2
$LL4@CLightShad:
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h

; 151  : 	if (ptr) 

	mov	edi, DWORD PTR [ecx+ebp*4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 119  :         _Ptr += _Off;

	lea	eax, DWORD PTR [ecx+ebp*4]
	mov	DWORD PTR _ptr$1$[esp+20], eax
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h

; 151  : 	if (ptr) 

	test	edi, edi
	je	SHORT $LN2@CLightShad
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [edi+20]
	test	eax, eax
	je	SHORT $LN90@CLightShad
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	ebx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1756 :             _Myend   = nullptr;

	mov	eax, DWORD PTR _ptr$1$[esp+20]
	mov	DWORD PTR [edi+20], 0
	mov	DWORD PTR [edi+24], 0
	mov	DWORD PTR [edi+28], 0
	mov	edi, DWORD PTR [eax]
$LN90@CLightShad:
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h

; 144  : 		Memory.mem_free	(ptr);

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	edi
	call	ebx

; 154  : 		ptr = nullptr;

	mov	eax, DWORD PTR _ptr$1$[esp+20]
	mov	DWORD PTR [eax], 0
$LN2@CLightShad:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	eax, DWORD PTR [esi+8]
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp

; 74   : 	for (u32 it=0; it<casters_pool.size(); it++)

	inc	ebp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	ecx, DWORD PTR [esi+4]
	sub	eax, ecx
	sar	eax, 2
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp

; 74   : 	for (u32 it=0; it<casters_pool.size(); it++)

	cmp	ebp, eax
	jb	SHORT $LL4@CLightShad
$LN3@CLightShad:

; 75   : 		xr_delete(casters_pool[it]);
; 76   : 	casters_pool.clear		();

	mov	DWORD PTR [esi+8], ecx

; 79   : 	for (u32 it=0; it<cache.size(); it++)

	xor	edx, edx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	eax, DWORD PTR [esi+56]
	mov	ecx, DWORD PTR [esi+52]
	sub	eax, ecx
	sar	eax, 2
	imul	eax, eax, -1171354717
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp

; 79   : 	for (u32 it=0; it<cache.size(); it++)

	mov	DWORD PTR _it$1$[esp+20], edx
	test	eax, eax
	je	SHORT $LN6@CLightShad
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h

; 154  : 		ptr = nullptr;

	xor	ebp, ebp
	npad	4
$LL7@CLightShad:
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	eax, DWORD PTR [ecx+ebp+36]
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp

; 80   : 		xr_free	(cache[it].tris);

	lea	edi, DWORD PTR [ecx+ebp]
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	test	eax, eax
	je	SHORT $LN5@CLightShad
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	ebx
	mov	edx, DWORD PTR _it$1$[esp+20]
	mov	DWORD PTR [edi+36], 0
$LN5@CLightShad:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	eax, DWORD PTR [esi+56]
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp

; 79   : 	for (u32 it=0; it<cache.size(); it++)

	inc	edx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	ecx, DWORD PTR [esi+52]
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp

; 79   : 	for (u32 it=0; it<cache.size(); it++)

	add	ebp, 44					; 0000002cH
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	sub	eax, ecx
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp

; 79   : 	for (u32 it=0; it<cache.size(); it++)

	mov	DWORD PTR _it$1$[esp+20], edx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	sar	eax, 2
	imul	eax, eax, -1171354717
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp

; 79   : 	for (u32 it=0; it<cache.size(); it++)

	cmp	edx, eax
	jb	SHORT $LL7@CLightShad
$LN6@CLightShad:

; 81   : 	cache.clear				();

	mov	DWORD PTR [esi+56], ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 64   : 						~resptr_core	()												{	_dec();						}

	lea	ecx, DWORD PTR [esi+120]
	call	DWORD PTR __imp_?_dec@?$resptr_base@USGeometry@@@@IAEXXZ
	lea	ecx, DWORD PTR [esi+116]
	call	DWORD PTR __imp_?_dec@?$resptr_base@UShader@@@@IAEXXZ
	lea	ecx, DWORD PTR [esi+112]
	call	DWORD PTR __imp_?_dec@?$resptr_base@USGeometry@@@@IAEXXZ
	lea	ecx, DWORD PTR [esi+108]
	call	DWORD PTR __imp_?_dec@?$resptr_base@UShader@@@@IAEXXZ
	lea	ecx, DWORD PTR [esi+104]
	call	DWORD PTR __imp_?_dec@?$resptr_base@USGeometry@@@@IAEXXZ
	lea	ecx, DWORD PTR [esi+100]
	call	DWORD PTR __imp_?_dec@?$resptr_base@UShader@@@@IAEXXZ
	lea	ecx, DWORD PTR [esi+96]
	call	DWORD PTR __imp_?_dec@?$resptr_base@UShader@@@@IAEXXZ
	lea	ecx, DWORD PTR [esi+92]
	call	DWORD PTR __imp_?_dec@?$resptr_base@VCRT@@@@IAEXXZ
	lea	ecx, DWORD PTR [esi+88]
	call	DWORD PTR __imp_?_dec@?$resptr_base@VCRT@@@@IAEXXZ
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp

; 82   : }

	lea	ecx, DWORD PTR [esi+64]
	call	DWORD PTR __imp_??1xrXRC@@QAE@XZ
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [esi+52]
	test	eax, eax
	je	SHORT $LN144@CLightShad
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	ebx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi+52], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+56], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+60], 0
$LN144@CLightShad:

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [esi+40]
	test	eax, eax
	je	SHORT $LN156@CLightShad
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	ebx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi+40], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+44], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+48], 0
$LN156@CLightShad:

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [esi+28]
	test	eax, eax
	je	SHORT $LN168@CLightShad
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	ebx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi+28], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+32], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+36], 0
$LN168@CLightShad:

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [esi+16]
	test	eax, eax
	je	SHORT $LN180@CLightShad
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	ebx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi+16], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+20], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+24], 0
$LN180@CLightShad:

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN192@CLightShad
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	ebx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi+4], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+8], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+12], 0
$LN192@CLightShad:
	pop	edi
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp

; 82   : }

	pop	esi
	pop	ebp
	pop	ebx
	pop	ecx
	ret	0
??1CLightShadows@@QAE@XZ ENDP				; CLightShadows::~CLightShadows
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp
_TEXT	SEGMENT
$T1 = -264						; size = 4
_this$1$ = -260						; size = 4
_RTtemp2$ = -256					; size = 128
_RTname2$ = -128					; size = 128
??0CLightShadows@@QAE@XZ PROC				; CLightShadows::CLightShadows
; _this$ = ecx

; 35   : {

	sub	esp, 264				; 00000108H
	push	ebx
	push	ebp
	push	esi
	mov	esi, ecx
	push	edi
	mov	DWORD PTR _this$1$[esp+280], esi
	lea	ecx, DWORD PTR [esi+64]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	mov	DWORD PTR [esi+16], 0
	mov	DWORD PTR [esi+20], 0
	mov	DWORD PTR [esi+24], 0
	mov	DWORD PTR [esi+28], 0
	mov	DWORD PTR [esi+32], 0
	mov	DWORD PTR [esi+36], 0
	mov	DWORD PTR [esi+40], 0
	mov	DWORD PTR [esi+44], 0
	mov	DWORD PTR [esi+48], 0
	mov	DWORD PTR [esi+52], 0
	mov	DWORD PTR [esi+56], 0
	mov	DWORD PTR [esi+60], 0
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp

; 35   : {

	call	DWORD PTR __imp_??0xrXRC@@QAE@XZ
	lea	edi, DWORD PTR [esi+88]
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 61   : 						resptr_core		()												{	p_ = 0;						}

	mov	DWORD PTR [esi+92], 0
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp

; 35   : {

	lea	ebp, DWORD PTR [esi+92]
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 61   : 						resptr_core		()												{	p_ = 0;						}

	mov	DWORD PTR [edi], 0
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp

; 35   : {

	lea	ebx, DWORD PTR [esi+108]
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 61   : 						resptr_core		()												{	p_ = 0;						}

	mov	DWORD PTR [esi+96], 0

; 46   : 	ICF		void		_set	(T * rhs) 							{	if (0!=rhs) rhs->dwReference++;	_dec(); p_ = rhs;											}

	mov	ecx, edi

; 61   : 						resptr_core		()												{	p_ = 0;						}

	mov	DWORD PTR [esi+100], 0
	mov	DWORD PTR [esi+104], 0
	mov	DWORD PTR [ebx], 0
	mov	DWORD PTR [esi+112], 0
	mov	DWORD PTR [esi+116], 0
	mov	DWORD PTR [esi+120], 0
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp

; 36   : 	current	= 0;

	mov	DWORD PTR [esi], 0
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 62   : 						resptr_core		(T * p, bool add_ref = true) 					{	p_ = p;	if(add_ref)	_inc(); }

	mov	DWORD PTR $T1[esp+280], 0

; 46   : 	ICF		void		_set	(T * rhs) 							{	if (0!=rhs) rhs->dwReference++;	_dec(); p_ = rhs;											}

	call	DWORD PTR __imp_?_dec@?$resptr_base@VCRT@@@@IAEXXZ

; 64   : 						~resptr_core	()												{	_dec();						}

	lea	ecx, DWORD PTR $T1[esp+280]

; 46   : 	ICF		void		_set	(T * rhs) 							{	if (0!=rhs) rhs->dwReference++;	_dec(); p_ = rhs;											}

	mov	DWORD PTR [edi], 0

; 64   : 						~resptr_core	()												{	_dec();						}

	call	DWORD PTR __imp_?_dec@?$resptr_base@VCRT@@@@IAEXXZ
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp

; 41   : 	string128 RTname2;		strconcat(sizeof(RTname2),RTname2,RTname,",",RTname);

	mov	esi, DWORD PTR __imp_?strconcat@@YAPADHPADPBD11@Z
	lea	eax, DWORD PTR _RTname2$[esp+280]
	push	OFFSET ??_C@_0N@MGAGAIMH@$user$shadow@
	push	OFFSET ??_C@_01IHBHIGKO@?0@
	push	OFFSET ??_C@_0N@MGAGAIMH@$user$shadow@
	push	eax
	push	128					; 00000080H
	call	esi

; 42   : 	string128 RTtemp2;		strconcat(sizeof(RTtemp2),RTtemp2,RTtemp,",",RTtemp);

	push	OFFSET ??_C@_0L@GLCIELMM@$user$temp@
	push	OFFSET ??_C@_01IHBHIGKO@?0@
	push	OFFSET ??_C@_0L@GLCIELMM@$user$temp@
	lea	eax, DWORD PTR _RTtemp2$[esp+312]
	push	eax
	push	128					; 00000080H
	call	esi

; 43   : 
; 44   : 	// 
; 45   : 	RT.create				(RTname,S_rt_size,S_rt_size,S_rtf);

	mov	esi, DWORD PTR __imp_?create@resptrcode_crt@@QAEXPBDIIW4_D3DFORMAT@@@Z
	add	esp, 40					; 00000028H
	mov	ecx, edi
	push	21					; 00000015H
	push	512					; 00000200H
	push	512					; 00000200H
	push	OFFSET ??_C@_0N@MGAGAIMH@$user$shadow@
	call	esi

; 46   : 	RT_temp.create			(RTtemp,S_rt_size,S_rt_size,S_rtf);

	push	21					; 00000015H
	push	512					; 00000200H
	push	512					; 00000200H
	push	OFFSET ??_C@_0L@GLCIELMM@$user$temp@
	mov	ecx, ebp
	call	esi

; 47   : 	sh_World.create			("effects\\shadow_world",	RTname);

	mov	esi, DWORD PTR __imp_?create@resptrcode_shader@@QAEXPBD000@Z
	mov	ecx, ebx
	push	0
	push	0
	push	OFFSET ??_C@_0N@MGAGAIMH@$user$shadow@
	push	OFFSET ??_C@_0BF@CDILBIKA@effects?2shadow_world@
	call	esi

; 48   : 	geom_World.create		(FVF::F_LIT,	RCache.Vertex.Buffer(), NULL);

	mov	eax, DWORD PTR __imp_?RCache@@3VCBackend@@A
	push	0
	push	DWORD PTR [eax]
	mov	ebx, DWORD PTR _this$1$[esp+288]
	mov	edi, DWORD PTR __imp_?create@resptrcode_geom@@QAEXIPAUIDirect3DVertexBuffer9@@PAUIDirect3DIndexBuffer9@@@Z
	push	322					; 00000142H
	lea	ecx, DWORD PTR [ebx+112]
	call	edi

; 49   : 	sh_BlurTR.create		("blur4",		RTtemp2);

	push	0
	push	0
	lea	eax, DWORD PTR _RTtemp2$[esp+288]
	push	eax
	push	OFFSET ??_C@_05OHHNHFCG@blur4@
	lea	ecx, DWORD PTR [ebx+96]
	call	esi

; 50   : 	sh_BlurRT.create		("blur4",		RTname2);

	push	0
	push	0
	lea	eax, DWORD PTR _RTname2$[esp+288]
	push	eax
	push	OFFSET ??_C@_05OHHNHFCG@blur4@
	lea	ecx, DWORD PTR [ebx+100]
	call	esi

; 51   : 	geom_Blur.create		(FVF::F_TL4uv,	RCache.Vertex.Buffer(), RCache.QuadIB);

	mov	eax, DWORD PTR __imp_?RCache@@3VCBackend@@A
	lea	ecx, DWORD PTR [ebx+104]
	push	DWORD PTR [eax+40]
	push	DWORD PTR [eax]
	push	1092					; 00000444H
	call	edi

; 52   : 
; 53   : 	// Debug
; 54   : 	sh_Screen.create		("effects\\screen_set",RTname);

	push	0
	push	0
	push	OFFSET ??_C@_0N@MGAGAIMH@$user$shadow@
	push	OFFSET ??_C@_0BD@KGPINAGD@effects?2screen_set@
	lea	ecx, DWORD PTR [ebx+116]
	call	esi

; 55   : 	geom_Screen.create		(FVF::F_TL,		RCache.Vertex.Buffer(), RCache.QuadIB);

	mov	eax, DWORD PTR __imp_?RCache@@3VCBackend@@A
	lea	ecx, DWORD PTR [ebx+120]
	push	DWORD PTR [eax+40]
	push	DWORD PTR [eax]
	push	324					; 00000144H
	call	edi

; 56   : }

	pop	edi
	pop	esi
	pop	ebp
	mov	eax, ebx
	pop	ebx
	add	esp, 264				; 00000108H
	ret	0
??0CLightShadows@@QAE@XZ ENDP				; CLightShadows::CLightShadows
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??1?$xr_vector@PAUcaster@CLightShadows@@V?$xalloc@PAUcaster@CLightShadows@@@@@@QAE@XZ
_TEXT	SEGMENT
??1?$xr_vector@PAUcaster@CLightShadows@@V?$xalloc@PAUcaster@CLightShadows@@@@@@QAE@XZ PROC ; xr_vector<CLightShadows::caster *,xalloc<CLightShadows::caster *> >::~xr_vector<CLightShadows::caster *,xalloc<CLightShadows::caster *> >, COMDAT
; _this$ = ecx

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	push	esi
	mov	esi, ecx
	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN6@xr_vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+4], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+8], 0
$LN6@xr_vector:
	pop	esi
	ret	0
??1?$xr_vector@PAUcaster@CLightShadows@@V?$xalloc@PAUcaster@CLightShadows@@@@@@QAE@XZ ENDP ; xr_vector<CLightShadows::caster *,xalloc<CLightShadows::caster *> >::~xr_vector<CLightShadows::caster *,xalloc<CLightShadows::caster *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??1?$xr_vector@Ushadow@CLightShadows@@V?$xalloc@Ushadow@CLightShadows@@@@@@QAE@XZ
_TEXT	SEGMENT
??1?$xr_vector@Ushadow@CLightShadows@@V?$xalloc@Ushadow@CLightShadows@@@@@@QAE@XZ PROC ; xr_vector<CLightShadows::shadow,xalloc<CLightShadows::shadow> >::~xr_vector<CLightShadows::shadow,xalloc<CLightShadows::shadow> >, COMDAT
; _this$ = ecx

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	push	esi
	mov	esi, ecx
	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN6@xr_vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+4], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+8], 0
$LN6@xr_vector:
	pop	esi
	ret	0
??1?$xr_vector@Ushadow@CLightShadows@@V?$xalloc@Ushadow@CLightShadows@@@@@@QAE@XZ ENDP ; xr_vector<CLightShadows::shadow,xalloc<CLightShadows::shadow> >::~xr_vector<CLightShadows::shadow,xalloc<CLightShadows::shadow> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??1?$xr_vector@Utess_tri@CLightShadows@@V?$xalloc@Utess_tri@CLightShadows@@@@@@QAE@XZ
_TEXT	SEGMENT
??1?$xr_vector@Utess_tri@CLightShadows@@V?$xalloc@Utess_tri@CLightShadows@@@@@@QAE@XZ PROC ; xr_vector<CLightShadows::tess_tri,xalloc<CLightShadows::tess_tri> >::~xr_vector<CLightShadows::tess_tri,xalloc<CLightShadows::tess_tri> >, COMDAT
; _this$ = ecx

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	push	esi
	mov	esi, ecx
	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN6@xr_vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+4], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+8], 0
$LN6@xr_vector:
	pop	esi
	ret	0
??1?$xr_vector@Utess_tri@CLightShadows@@V?$xalloc@Utess_tri@CLightShadows@@@@@@QAE@XZ ENDP ; xr_vector<CLightShadows::tess_tri,xalloc<CLightShadows::tess_tri> >::~xr_vector<CLightShadows::tess_tri,xalloc<CLightShadows::tess_tri> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??1?$xr_vector@Ucache_item@CLightShadows@@V?$xalloc@Ucache_item@CLightShadows@@@@@@QAE@XZ
_TEXT	SEGMENT
??1?$xr_vector@Ucache_item@CLightShadows@@V?$xalloc@Ucache_item@CLightShadows@@@@@@QAE@XZ PROC ; xr_vector<CLightShadows::cache_item,xalloc<CLightShadows::cache_item> >::~xr_vector<CLightShadows::cache_item,xalloc<CLightShadows::cache_item> >, COMDAT
; _this$ = ecx

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	push	esi
	mov	esi, ecx
	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN6@xr_vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+4], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+8], 0
$LN6@xr_vector:
	pop	esi
	ret	0
??1?$xr_vector@Ucache_item@CLightShadows@@V?$xalloc@Ucache_item@CLightShadows@@@@@@QAE@XZ ENDP ; xr_vector<CLightShadows::cache_item,xalloc<CLightShadows::cache_item> >::~xr_vector<CLightShadows::cache_item,xalloc<CLightShadows::cache_item> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp
;	COMDAT ?PLC_energy@@YAMAAU?$_vector3@M@@0PAVlight@@M@Z
_TEXT	SEGMENT
_sqD$1 = -4						; size = 4
_D$2 = 8						; size = 4
_D$3 = 8						; size = 4
_L$ = 8							; size = 4
_E$ = 12						; size = 4
?PLC_energy@@YAMAAU?$_vector3@M@@0PAVlight@@M@Z PROC	; PLC_energy, COMDAT
; _P$ = ecx
; _N$ = edx

; 135  : {

	push	ecx

; 136  : 	Fvector Ldir;
; 137  : 	if (L->flags.type==IRender_Light::DIRECT)

	mov	eax, DWORD PTR _L$[esp]
	test	BYTE PTR [eax+60], 15			; 0000000fH
	jne	SHORT $LN2@PLC_energy
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	movss	xmm0, DWORD PTR [eax+76]
	mulss	xmm0, DWORD PTR [edx]
	movss	xmm1, DWORD PTR [eax+80]
	mulss	xmm1, DWORD PTR [edx+4]
	addss	xmm1, xmm0
	movss	xmm0, DWORD PTR [eax+84]
	mulss	xmm0, DWORD PTR [edx+8]
	addss	xmm1, xmm0
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp

; 142  : 		if( D <=0 )						return 0;

	xorps	xmm0, xmm0
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	xorps	xmm1, DWORD PTR __xmm@80000000800000008000000080000000
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp

; 142  : 		if( D <=0 )						return 0;

	comiss	xmm0, xmm1
	movss	DWORD PTR _D$3[esp], xmm1
	jae	$LN31@PLC_energy

; 143  : 		
; 144  : 		// Trace Light
; 145  : 		float A		= D*E;

	fld	DWORD PTR _D$3[esp]
	fmul	DWORD PTR _E$[esp]

; 162  : 		return A;
; 163  : 	}
; 164  : }

	pop	ecx
	ret	0
$LN2@PLC_energy:
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 287  : 	{	return (x-v.x)*(x-v.x) + (y-v.y)*(y-v.y) + (z-v.z)*(z-v.z);	}

	movss	xmm6, DWORD PTR [ecx+4]
	movss	xmm7, DWORD PTR [ecx]
	movaps	xmm1, xmm6
	movss	xmm3, DWORD PTR [eax+68]
	movaps	xmm2, xmm7
	movss	xmm4, DWORD PTR [eax+64]
	subss	xmm1, xmm3
	movss	xmm0, DWORD PTR [ecx+8]
	subss	xmm2, xmm4
	movss	xmm5, DWORD PTR [eax+72]
	subss	xmm0, xmm5
	mulss	xmm1, xmm1
	mulss	xmm2, xmm2
	mulss	xmm0, xmm0
	addss	xmm2, xmm1
	addss	xmm2, xmm0
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp

; 150  : 		if (sqD > (L->range*L->range))	return 0;

	movss	xmm0, DWORD PTR [eax+100]
	mulss	xmm0, xmm0
	comiss	xmm2, xmm0
	movss	DWORD PTR _sqD$1[esp+4], xmm2
	ja	$LN31@PLC_energy
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	subss	xmm5, DWORD PTR [ecx+8]
	subss	xmm4, xmm7
	subss	xmm3, xmm6
	movaps	xmm0, xmm4

; 200  : 		T magnitude=x*x + y*y + z*z;

	movaps	xmm1, xmm3

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	mulss	xmm0, xmm4

; 200  : 		T magnitude=x*x + y*y + z*z;

	mulss	xmm1, xmm3
	addss	xmm1, xmm0
	movaps	xmm0, xmm5
	mulss	xmm0, xmm5
	addss	xmm1, xmm0

; 201  : 		if (magnitude> std::numeric_limits<T>::min()) {

	comiss	xmm1, DWORD PTR __real@00800000
	jbe	SHORT $LN17@PLC_energy

; 202  : 			magnitude=_sqrt(1/magnitude);

	movss	xmm0, DWORD PTR __real@3f800000
	divss	xmm0, xmm1
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h

; 764  :             return (float)sqrt(_X);

	sqrtss	xmm0, xmm0
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 202  : 			magnitude=_sqrt(1/magnitude);

	mulss	xmm4, xmm0

; 203  : 			x *= magnitude;

	mulss	xmm3, xmm0

; 204  : 			y *= magnitude;

	mulss	xmm5, xmm0
$LN17@PLC_energy:

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	mulss	xmm3, DWORD PTR [edx+4]
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp

; 156  : 		if( D <=0 )						return 0;

	xorps	xmm0, xmm0
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	mulss	xmm4, DWORD PTR [edx]
	mulss	xmm5, DWORD PTR [edx+8]
	addss	xmm3, xmm4
	addss	xmm3, xmm5
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp

; 156  : 		if( D <=0 )						return 0;

	comiss	xmm0, xmm3
	movss	DWORD PTR _D$2[esp], xmm3
	jae	SHORT $LN31@PLC_energy

; 161  : 		float A		= D * E * att;

	fld	DWORD PTR _D$2[esp]
	fmul	DWORD PTR _E$[esp]
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h

; 764  :             return (float)sqrt(_X);

	fld	DWORD PTR _sqD$1[esp+4]
	fsqrt
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp

; 160  : 		float att	= 1-(1/(1+R));

	fadd	DWORD PTR __real@3f800000

; 161  : 		float A		= D * E * att;

	fdivr	ST(0), ST(1)
	fsubp	ST(1), ST(0)

; 162  : 		return A;
; 163  : 	}
; 164  : }

	pop	ecx
	ret	0
$LN31@PLC_energy:

; 156  : 		if( D <=0 )						return 0;

	fldz

; 162  : 		return A;
; 163  : 	}
; 164  : }

	pop	ecx
	ret	0
?PLC_energy@@YAMAAU?$_vector3@M@@0PAVlight@@M@Z ENDP	; PLC_energy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\vector.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\vector.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp
;	COMDAT ?PLC_calc@@YAHAAU?$_vector3@M@@0PAVlight@@M0@Z
_TEXT	SEGMENT
_a$2 = 8						; size = 4
_L$ = 8							; size = 4
_energy$ = 12						; size = 4
_O$ = 16						; size = 4
?PLC_calc@@YAHAAU?$_vector3@M@@0PAVlight@@M0@Z PROC	; PLC_calc, COMDAT
; _P$ = ecx
; _N$ = edx

; 137  : 	if (L->flags.type==IRender_Light::DIRECT)

	mov	eax, DWORD PTR _L$[esp-4]
	movss	xmm5, DWORD PTR __real@3f800000
	test	BYTE PTR [eax+60], 15			; 0000000fH
	jne	SHORT $LN4@PLC_calc
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	movss	xmm0, DWORD PTR [eax+76]
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp

; 142  : 		if( D <=0 )						return 0;

	xorps	xmm3, xmm3
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	movss	xmm2, DWORD PTR [eax+80]
	mulss	xmm2, DWORD PTR [edx+4]
	mulss	xmm0, DWORD PTR [edx]
	addss	xmm2, xmm0
	movss	xmm0, DWORD PTR [eax+84]
	mulss	xmm0, DWORD PTR [edx+8]
	addss	xmm2, xmm0
	xorps	xmm2, DWORD PTR __xmm@80000000800000008000000080000000
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp

; 142  : 		if( D <=0 )						return 0;

	comiss	xmm3, xmm2
	jb	SHORT $LN6@PLC_calc
	movaps	xmm2, xmm3
	jmp	$LN5@PLC_calc
$LN6@PLC_calc:

; 143  : 		
; 144  : 		// Trace Light
; 145  : 		float A		= D*E;

	mulss	xmm2, DWORD PTR _energy$[esp-4]

; 146  : 		return A;

	jmp	$LN5@PLC_calc
$LN4@PLC_calc:
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 287  : 	{	return (x-v.x)*(x-v.x) + (y-v.y)*(y-v.y) + (z-v.z)*(z-v.z);	}

	movss	xmm7, DWORD PTR [ecx+4]
	movss	xmm2, DWORD PTR [eax+68]
	movaps	xmm1, xmm7
	movss	xmm3, DWORD PTR [eax+64]
	subss	xmm1, xmm2
	movss	xmm6, DWORD PTR [ecx]
	movss	xmm0, DWORD PTR [ecx+8]
	subss	xmm6, xmm3
	movss	xmm4, DWORD PTR [eax+72]
	subss	xmm0, xmm4
	mulss	xmm1, xmm1
	mulss	xmm6, xmm6
	mulss	xmm0, xmm0
	addss	xmm6, xmm1
	addss	xmm6, xmm0
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp

; 150  : 		if (sqD > (L->range*L->range))	return 0;

	movss	xmm0, DWORD PTR [eax+100]
	mulss	xmm0, xmm0
	comiss	xmm6, xmm0
	jbe	SHORT $LN7@PLC_calc
	xorps	xmm3, xmm3
	movaps	xmm2, xmm3
	jmp	$LN5@PLC_calc
$LN7@PLC_calc:
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	subss	xmm3, DWORD PTR [ecx]
	subss	xmm4, DWORD PTR [ecx+8]
	subss	xmm2, xmm7

; 200  : 		T magnitude=x*x + y*y + z*z;

	movaps	xmm0, xmm3
	mulss	xmm0, xmm3

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movaps	xmm1, xmm2
	mulss	xmm1, xmm2

; 200  : 		T magnitude=x*x + y*y + z*z;

	addss	xmm1, xmm0
	movaps	xmm0, xmm4
	mulss	xmm0, xmm4
	addss	xmm1, xmm0

; 201  : 		if (magnitude> std::numeric_limits<T>::min()) {

	comiss	xmm1, DWORD PTR __real@00800000
	jbe	SHORT $LN19@PLC_calc

; 202  : 			magnitude=_sqrt(1/magnitude);

	movaps	xmm0, xmm5
	divss	xmm0, xmm1
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h

; 764  :             return (float)sqrt(_X);

	sqrtss	xmm0, xmm0
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 202  : 			magnitude=_sqrt(1/magnitude);

	mulss	xmm3, xmm0

; 203  : 			x *= magnitude;

	mulss	xmm2, xmm0

; 204  : 			y *= magnitude;

	mulss	xmm4, xmm0
$LN19@PLC_calc:

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	mulss	xmm2, DWORD PTR [edx+4]
	mulss	xmm3, DWORD PTR [edx]
	mulss	xmm4, DWORD PTR [edx+8]
	addss	xmm2, xmm3
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp

; 156  : 		if( D <=0 )						return 0;

	xorps	xmm3, xmm3
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	addss	xmm2, xmm4
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp

; 156  : 		if( D <=0 )						return 0;

	comiss	xmm3, xmm2
	jb	SHORT $LN8@PLC_calc
	movaps	xmm2, xmm3
	jmp	SHORT $LN5@PLC_calc
$LN8@PLC_calc:
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h

; 764  :             return (float)sqrt(_X);

	sqrtss	xmm0, xmm6
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp

; 161  : 		float A		= D * E * att;

	mulss	xmm2, DWORD PTR _energy$[esp-4]
	addss	xmm0, xmm5
	movaps	xmm1, xmm2
	divss	xmm1, xmm0
	subss	xmm2, xmm1
$LN5@PLC_calc:

; 169  : 	float	C1		= clampr(Device.vCameraPosition.distance_to_sqr(P)/S_distance2,	0.f,1.f);

	mov	eax, DWORD PTR __imp_?Device@@3VCRenderDevice@@A
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 287  : 	{	return (x-v.x)*(x-v.x) + (y-v.y)*(y-v.y) + (z-v.z)*(z-v.z);	}

	movss	xmm4, DWORD PTR [ecx+4]
	movss	xmm7, DWORD PTR [ecx]
	movss	xmm1, DWORD PTR [eax+492]
	movss	xmm6, DWORD PTR [eax+488]
	subss	xmm1, xmm4
	movss	xmm0, DWORD PTR [eax+496]
	subss	xmm6, xmm7
	subss	xmm0, DWORD PTR [ecx+8]
	mulss	xmm1, xmm1
	mulss	xmm6, xmm6
	mulss	xmm0, xmm0
	addss	xmm6, xmm1
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp

; 169  : 	float	C1		= clampr(Device.vCameraPosition.distance_to_sqr(P)/S_distance2,	0.f,1.f);

	addss	xmm6, xmm0
	mulss	xmm6, DWORD PTR __real@39e38e39
; File I:\Vitalya\mine\NSProjectX\xrCore\vector.h

; 96   : 	if		( val<_low	)	return _low; 

	comiss	xmm3, xmm6
	jbe	SHORT $LN36@PLC_calc
	movaps	xmm6, xmm3
	jmp	SHORT $LN38@PLC_calc
$LN36@PLC_calc:

; 97   : 	else if	( val>_high )	return _high;

	comiss	xmm6, xmm5
	jbe	SHORT $LN38@PLC_calc
	movaps	xmm6, xmm5
$LN38@PLC_calc:
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 287  : 	{	return (x-v.x)*(x-v.x) + (y-v.y)*(y-v.y) + (z-v.z)*(z-v.z);	}

	mov	eax, DWORD PTR _O$[esp-4]
	movss	xmm1, DWORD PTR [eax+4]
	movss	xmm0, DWORD PTR [eax+8]
	subss	xmm1, xmm4
	movss	xmm4, DWORD PTR [eax]
	subss	xmm0, DWORD PTR [ecx+8]
	subss	xmm4, xmm7
	mulss	xmm1, xmm1
	mulss	xmm0, xmm0
	mulss	xmm4, xmm4
	addss	xmm4, xmm1
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp

; 170  : 	float	C2		= clampr(O.distance_to_sqr(P)/S_fade2,							0.f,1.f);

	addss	xmm4, xmm0
	mulss	xmm4, DWORD PTR __real@3d4a4588
; File I:\Vitalya\mine\NSProjectX\xrCore\vector.h

; 96   : 	if		( val<_low	)	return _low; 

	comiss	xmm3, xmm4
	ja	SHORT $LN47@PLC_calc

; 97   : 	else if	( val>_high )	return _high;

	comiss	xmm4, xmm5
	jbe	SHORT $LN46@PLC_calc
	movaps	xmm3, xmm5
	jmp	SHORT $LN47@PLC_calc
$LN46@PLC_calc:

; 98   : 	else					return val;

	movaps	xmm3, xmm4
$LN47@PLC_calc:
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp

; 172  : 	return			iCeil(255.f*A);

	movss	xmm0, DWORD PTR __real@437f0000
	movaps	xmm1, xmm5
	subss	xmm1, xmm6
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h

; 105  :     int exponent	= (127 + 31) - ((a >> 23) & 0xFF);

	mov	ecx, 158				; 0000009eH
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp

; 171  : 	float	A		= 1.f-1.5f*E*(1.f-C1)*(1.f-C2);

	subss	xmm5, xmm3
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h

; 109  :         int imask	=	(!(((( (1<<(exponent)))-1)>>8)&a));

	mov	edx, 1
	push	esi
	push	edi
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp

; 172  : 	return			iCeil(255.f*A);

	mulss	xmm1, xmm2
	mulss	xmm5, DWORD PTR __real@43bf4000
	mulss	xmm1, xmm5
	subss	xmm0, xmm1
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h

; 104  :     int a			= (*(const int*)(&x));

	movss	DWORD PTR _a$2[esp+4], xmm0

; 105  :     int exponent	= (127 + 31) - ((a >> 23) & 0xFF);

	mov	edi, DWORD PTR _a$2[esp+4]
	mov	eax, edi
	sar	eax, 23					; 00000017H
	movzx	eax, al
	sub	ecx, eax

; 106  :     int r			= (((u32)(a) << 8) | (1U << 31)) >> exponent;

	mov	eax, edi
	or	eax, -8388608				; ff800000H

; 112  :         a			=	~((a-1)>>31);		/* change sign */

	lea	esi, DWORD PTR [edi-1]
	shl	eax, 8
	shr	eax, cl
	sub	ecx, 96					; 00000060H
	shl	edx, cl
	dec	edx
	sar	esi, 31					; 0000001fH
	sar	edx, 8
	not	esi
	and	edx, edi
	neg	edx
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp

; 172  : 	return			iCeil(255.f*A);

	pop	edi
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h

; 109  :         int imask	=	(!(((( (1<<(exponent)))-1)>>8)&a));

	sbb	edx, edx

; 110  :         exponent	-=	(31-127)+32;

	add	ecx, 64					; 00000040H
	inc	edx

; 111  :         exponent	>>=	31;

	sar	ecx, 31					; 0000001fH

; 112  :         a			=	~((a-1)>>31);		/* change sign */

	and	edx, esi

; 113  :         r			-=	(imask&a);

	sub	eax, edx

; 114  :         r			&=	exponent;

	and	eax, ecx
	xor	eax, esi

; 115  :         r			^=	a;
; 116  :         r			=	-r;                 /* change sign */

	neg	eax
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp

; 172  : 	return			iCeil(255.f*A);

	pop	esi

; 173  : }

	ret	0
?PLC_calc@@YAHAAU?$_vector3@M@@0PAVlight@@M0@Z ENDP	; PLC_calc
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp
;	COMDAT ?cache_search@@YA_NABUcache_item@CLightShadows@@0@Z
_TEXT	SEGMENT
_A$ = 8							; size = 4
_B$ = 12						; size = 4
?cache_search@@YA_NABUcache_item@CLightShadows@@0@Z PROC ; cache_search, COMDAT

; 349  : 	if (A.O < B.O)	return true;

	mov	eax, DWORD PTR _A$[esp-4]
	mov	ecx, DWORD PTR _B$[esp-4]
	mov	edx, DWORD PTR [eax]
	cmp	edx, DWORD PTR [ecx]
	jb	SHORT $LN7@cache_sear

; 350  : 	if (A.O > B.O)	return false;

	ja	SHORT $LN5@cache_sear

; 351  : 	if (A.L < B.L)	return true;

	mov	eax, DWORD PTR [eax+16]
	cmp	eax, DWORD PTR [ecx+16]
	jb	SHORT $LN7@cache_sear
$LN5@cache_sear:

; 352  : 	if (A.L > B.L)	return false;
; 353  : 	return			false;	// eq

	xor	al, al

; 354  : }

	ret	0
$LN7@cache_sear:

; 351  : 	if (A.L < B.L)	return true;

	mov	al, 1

; 354  : }

	ret	0
?cache_search@@YA_NABUcache_item@CLightShadows@@0@Z ENDP ; cache_search
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@Utess_tri@CLightShadows@@@std@@@std@@@std@@QBEAAUtess_tri@CLightShadows@@XZ
_TEXT	SEGMENT
??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@Utess_tri@CLightShadows@@@std@@@std@@@std@@QBEAAUtess_tri@CLightShadows@@XZ PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CLightShadows::tess_tri> > >::operator*, COMDAT
; _this$ = ecx

; 261  :         return const_cast<reference>(_Mybase::operator*());

	mov	eax, DWORD PTR [ecx]

; 262  :     }

	ret	0
??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@Utess_tri@CLightShadows@@@std@@@std@@@std@@QBEAAUtess_tri@CLightShadows@@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CLightShadows::tess_tri> > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@Ucache_item@CLightShadows@@@std@@@std@@@std@@QBE?AV01@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@Ucache_item@CLightShadows@@@std@@@std@@@std@@QBE?AV01@H@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CLightShadows::cache_item> > >::operator+, COMDAT
; _this$ = ecx

; 119  :         _Ptr += _Off;

	imul	edx, DWORD PTR __Off$[esp-4], 44
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	add	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx

; 303  :         _Vector_iterator _Tmp = *this;
; 304  :         _Tmp += _Off; // TRANSITION, LLVM-49342
; 305  :         return _Tmp;
; 306  :     }

	ret	8
??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@Ucache_item@CLightShadows@@@std@@@std@@@std@@QBE?AV01@H@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CLightShadows::cache_item> > >::operator+
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??C?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@Ucache_item@CLightShadows@@@std@@@std@@@std@@QBEPAUcache_item@CLightShadows@@XZ
_TEXT	SEGMENT
??C?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@Ucache_item@CLightShadows@@@std@@@std@@@std@@QBEPAUcache_item@CLightShadows@@XZ PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CLightShadows::cache_item> > >::operator->, COMDAT
; _this$ = ecx

; 265  : #if _ITERATOR_DEBUG_LEVEL != 0
; 266  :         const auto _Mycont = static_cast<const _Myvec*>(this->_Getcont());
; 267  :         _STL_VERIFY(this->_Ptr, "can't dereference value-initialized vector iterator");
; 268  :         _STL_VERIFY(_Mycont->_Myfirst <= this->_Ptr && this->_Ptr < _Mycont->_Mylast,
; 269  :             "can't dereference out of range vector iterator");
; 270  : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 271  : 
; 272  :         return this->_Ptr;

	mov	eax, DWORD PTR [ecx]

; 273  :     }

	ret	0
??C?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@Ucache_item@CLightShadows@@@std@@@std@@@std@@QBEPAUcache_item@CLightShadows@@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CLightShadows::cache_item> > >::operator->
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@Ucache_item@CLightShadows@@@std@@@std@@@std@@QBEAAUcache_item@CLightShadows@@XZ
_TEXT	SEGMENT
??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@Ucache_item@CLightShadows@@@std@@@std@@@std@@QBEAAUcache_item@CLightShadows@@XZ PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CLightShadows::cache_item> > >::operator*, COMDAT
; _this$ = ecx

; 261  :         return const_cast<reference>(_Mybase::operator*());

	mov	eax, DWORD PTR [ecx]

; 262  :     }

	ret	0
??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@Ucache_item@CLightShadows@@@std@@@std@@@std@@QBEAAUcache_item@CLightShadows@@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CLightShadows::cache_item> > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@Ucache_item@CLightShadows@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@Ucache_item@CLightShadows@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CLightShadows::cache_item> > >::operator==, COMDAT
; _this$ = ecx

; 149  :         _Compat(_Right);
; 150  :         return _Ptr == _Right._Ptr;

	mov	eax, DWORD PTR __Right$[esp-4]
	mov	ecx, DWORD PTR [ecx]
	cmp	ecx, DWORD PTR [eax]
	sete	al

; 151  :     }

	ret	4
??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@Ucache_item@CLightShadows@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CLightShadows::cache_item> > >::operator==
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ??A?$xr_vector@Ucache_item@CLightShadows@@V?$xalloc@Ucache_item@CLightShadows@@@@@@QAEAAUcache_item@CLightShadows@@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$xr_vector@Ucache_item@CLightShadows@@V?$xalloc@Ucache_item@CLightShadows@@@@@@QAEAAUcache_item@CLightShadows@@I@Z PROC ; xr_vector<CLightShadows::cache_item,xalloc<CLightShadows::cache_item> >::operator[], COMDAT
; _this$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 119  :         _Ptr += _Off;

	imul	eax, DWORD PTR __Pos$[esp-4], 44
	add	eax, DWORD PTR [ecx]
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 138  : 	reference operator[]		(size_type _Pos)					{ {VERIFY(_Pos<size());} return (*(begin() + _Pos)); }

	ret	4
??A?$xr_vector@Ucache_item@CLightShadows@@V?$xalloc@Ucache_item@CLightShadows@@@@@@QAEAAUcache_item@CLightShadows@@I@Z ENDP ; xr_vector<CLightShadows::cache_item,xalloc<CLightShadows::cache_item> >::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?clear@?$xr_vector@Ucache_item@CLightShadows@@V?$xalloc@Ucache_item@CLightShadows@@@@@@QAEXXZ
_TEXT	SEGMENT
?clear@?$xr_vector@Ucache_item@CLightShadows@@V?$xalloc@Ucache_item@CLightShadows@@@@@@QAEXXZ PROC ; xr_vector<CLightShadows::cache_item,xalloc<CLightShadows::cache_item> >::clear, COMDAT
; _this$ = ecx

; 132  : 	void	clear				()									{ clear_and_free	();			}

	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [ecx+4], eax
	ret	0
?clear@?$xr_vector@Ucache_item@CLightShadows@@V?$xalloc@Ucache_item@CLightShadows@@@@@@QAEXXZ ENDP ; xr_vector<CLightShadows::cache_item,xalloc<CLightShadows::cache_item> >::clear
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?size@?$xr_vector@Ucache_item@CLightShadows@@V?$xalloc@Ucache_item@CLightShadows@@@@@@QBEIXZ
_TEXT	SEGMENT
?size@?$xr_vector@Ucache_item@CLightShadows@@V?$xalloc@Ucache_item@CLightShadows@@@@@@QBEIXZ PROC ; xr_vector<CLightShadows::cache_item,xalloc<CLightShadows::cache_item> >::size, COMDAT
; _this$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	eax, DWORD PTR [ecx+4]
	sub	eax, DWORD PTR [ecx]
	sar	eax, 2
	imul	eax, eax, -1171354717
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 125  : 	u32		size				() const							{ return (u32)inherited::size();} 

	ret	0
?size@?$xr_vector@Ucache_item@CLightShadows@@V?$xalloc@Ucache_item@CLightShadows@@@@@@QBEIXZ ENDP ; xr_vector<CLightShadows::cache_item,xalloc<CLightShadows::cache_item> >::size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ??0?$xr_vector@Ucache_item@CLightShadows@@V?$xalloc@Ucache_item@CLightShadows@@@@@@QAE@XZ
_TEXT	SEGMENT
??0?$xr_vector@Ucache_item@CLightShadows@@V?$xalloc@Ucache_item@CLightShadows@@@@@@QAE@XZ PROC ; xr_vector<CLightShadows::cache_item,xalloc<CLightShadows::cache_item> >::xr_vector<CLightShadows::cache_item,xalloc<CLightShadows::cache_item> >, COMDAT
; _this$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx], 0
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 122  : 			xr_vector			()									: inherited	()					{}

	mov	eax, ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 122  : 			xr_vector			()									: inherited	()					{}

	ret	0
??0?$xr_vector@Ucache_item@CLightShadows@@V?$xalloc@Ucache_item@CLightShadows@@@@@@QAE@XZ ENDP ; xr_vector<CLightShadows::cache_item,xalloc<CLightShadows::cache_item> >::xr_vector<CLightShadows::cache_item,xalloc<CLightShadows::cache_item> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?end@?$vector@Ucache_item@CLightShadows@@V?$xalloc@Ucache_item@CLightShadows@@@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@Ucache_item@CLightShadows@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@Ucache_item@CLightShadows@@V?$xalloc@Ucache_item@CLightShadows@@@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@Ucache_item@CLightShadows@@@std@@@std@@@2@XZ PROC ; std::vector<CLightShadows::cache_item,xalloc<CLightShadows::cache_item> >::end, COMDAT
; _this$ = ecx

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	ecx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax], ecx

; 1472 :         auto& _My_data = _Mypair._Myval2;
; 1473 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));
; 1474 :     }

	ret	4
?end@?$vector@Ucache_item@CLightShadows@@V?$xalloc@Ucache_item@CLightShadows@@@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@Ucache_item@CLightShadows@@@std@@@std@@@2@XZ ENDP ; std::vector<CLightShadows::cache_item,xalloc<CLightShadows::cache_item> >::end
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?begin@?$vector@Ucache_item@CLightShadows@@V?$xalloc@Ucache_item@CLightShadows@@@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@Ucache_item@CLightShadows@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@Ucache_item@CLightShadows@@V?$xalloc@Ucache_item@CLightShadows@@@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@Ucache_item@CLightShadows@@@std@@@std@@@2@XZ PROC ; std::vector<CLightShadows::cache_item,xalloc<CLightShadows::cache_item> >::begin, COMDAT
; _this$ = ecx

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	ecx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], ecx

; 1462 :         auto& _My_data = _Mypair._Myval2;
; 1463 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));
; 1464 :     }

	ret	4
?begin@?$vector@Ucache_item@CLightShadows@@V?$xalloc@Ucache_item@CLightShadows@@@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@Ucache_item@CLightShadows@@@std@@@std@@@2@XZ ENDP ; std::vector<CLightShadows::cache_item,xalloc<CLightShadows::cache_item> >::begin
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?erase@?$vector@Ucache_item@CLightShadows@@V?$xalloc@Ucache_item@CLightShadows@@@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@Ucache_item@CLightShadows@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@Ucache_item@CLightShadows@@@std@@@std@@@2@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?erase@?$vector@Ucache_item@CLightShadows@@V?$xalloc@Ucache_item@CLightShadows@@@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@Ucache_item@CLightShadows@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@Ucache_item@CLightShadows@@@std@@@std@@@2@@Z PROC ; std::vector<CLightShadows::cache_item,xalloc<CLightShadows::cache_item> >::erase, COMDAT
; _this$ = ecx

; 1394 :         is_nothrow_move_assignable_v<value_type>) /* strengthened */ {

	push	esi
	push	edi

; 1395 :         const pointer _Whereptr = _Where._Ptr;

	mov	edi, DWORD PTR __Where$[esp+4]
	mov	esi, ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility

; 4065 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	mov	eax, DWORD PTR [esi+4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1397 :         pointer& _Mylast        = _My_data._Mylast;

	lea	edx, DWORD PTR [edi+44]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility

; 4065 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	sub	eax, edx

; 4066 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	push	eax
	push	edx
	push	edi
	call	_memmove
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	eax, DWORD PTR ___$ReturnUdt$[esp+16]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility

; 4066 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	add	esp, 12					; 0000000cH
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1408 :         --_Mylast;

	add	DWORD PTR [esi+4], -44			; ffffffd4H

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	DWORD PTR [eax], edi

; 1409 :         return iterator(_Whereptr, _STD addressof(_My_data));

	pop	edi
	pop	esi

; 1410 :     }

	ret	8
?erase@?$vector@Ucache_item@CLightShadows@@V?$xalloc@Ucache_item@CLightShadows@@@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@Ucache_item@CLightShadows@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@Ucache_item@CLightShadows@@@std@@@std@@@2@@Z ENDP ; std::vector<CLightShadows::cache_item,xalloc<CLightShadows::cache_item> >::erase
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?insert@?$vector@Ucache_item@CLightShadows@@V?$xalloc@Ucache_item@CLightShadows@@@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@Ucache_item@CLightShadows@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@Ucache_item@CLightShadows@@@std@@@std@@@2@ABUcache_item@CLightShadows@@@Z
_TEXT	SEGMENT
__Obj$1 = -48						; size = 48
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
__Val$ = 16						; size = 4
?insert@?$vector@Ucache_item@CLightShadows@@V?$xalloc@Ucache_item@CLightShadows@@@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@Ucache_item@CLightShadows@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@Ucache_item@CLightShadows@@@std@@@std@@@2@ABUcache_item@CLightShadows@@@Z PROC ; std::vector<CLightShadows::cache_item,xalloc<CLightShadows::cache_item> >::insert, COMDAT
; _this$ = ecx

; 828  :     _CONSTEXPR20_CONTAINER iterator insert(const_iterator _Where, const _Ty& _Val) { // insert _Val at _Where

	sub	esp, 52					; 00000034H
	mov	eax, ecx

; 801  :         const pointer _Oldlast  = _My_data._Mylast;

	mov	edx, DWORD PTR [eax+4]

; 828  :     _CONSTEXPR20_CONTAINER iterator insert(const_iterator _Where, const _Ty& _Val) { // insert _Val at _Where

	push	ebx

; 799  :         const pointer _Whereptr = _Where._Ptr;

	mov	ebx, DWORD PTR __Where$[esp+52]

; 828  :     _CONSTEXPR20_CONTAINER iterator insert(const_iterator _Where, const _Ty& _Val) { // insert _Val at _Where

	push	esi
	push	edi

; 808  :         if (_Oldlast != _My_data._Myend) {

	cmp	edx, DWORD PTR [eax+8]
	je	SHORT $LN4@insert

; 809  :             if (_Whereptr == _Oldlast) { // at back, provide strong guarantee

	mov	esi, DWORD PTR __Val$[esp+60]
	mov	ecx, 11					; 0000000bH
	cmp	ebx, edx
	jne	SHORT $LN5@insert
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	edi, edx
	rep movsd
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 716  :         ++_Mylast;

	add	DWORD PTR [eax+4], 44			; 0000002cH

; 829  :         return emplace(_Where, _Val);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp+60]
	mov	DWORD PTR [eax], ebx

; 830  :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 52					; 00000034H
	ret	12					; 0000000cH
$LN5@insert:
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	lea	edi, DWORD PTR __Obj$1[esp+68]
	rep movsd
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 816  :                 _Alty_traits::construct(_Al, _Unfancy(_Oldlast), _STD move(_Oldlast[-1]));

	lea	esi, DWORD PTR [edx-44]
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	edi, edx
	mov	ecx, 11					; 0000000bH
	rep movsd
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 817  :                 ++_My_data._Mylast;

	add	DWORD PTR [eax+4], 44			; 0000002cH
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility

; 4254 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	mov	eax, edx
	sub	eax, ebx
	sub	eax, 44					; 0000002cH

; 4255 :     auto _Result                = _CSTD memmove(_Dest_ch - _Count, _First_ch, _Count);

	push	eax
	sub	edx, eax
	push	ebx
	push	edx
	call	_memmove
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 829  :         return emplace(_Where, _Val);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp+72]

; 819  :                 *_Whereptr = _STD move(_Obj._Get_value());

	lea	esi, DWORD PTR __Obj$1[esp+80]
	mov	ecx, 11					; 0000000bH
	mov	edi, ebx
	rep movsd
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility

; 4255 :     auto _Result                = _CSTD memmove(_Dest_ch - _Count, _First_ch, _Count);

	add	esp, 12					; 0000000cH
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 829  :         return emplace(_Where, _Val);

	mov	DWORD PTR [eax], ebx

; 830  :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 52					; 00000034H
	ret	12					; 0000000cH
$LN4@insert:

; 825  :         return _Make_iterator(_Emplace_reallocate(_Whereptr, _STD forward<_Valty>(_Val)...));

	push	DWORD PTR __Val$[esp+60]
	push	ebx
	call	??$_Emplace_reallocate@ABUcache_item@CLightShadows@@@?$vector@Ucache_item@CLightShadows@@V?$xalloc@Ucache_item@CLightShadows@@@@@std@@QAEPAUcache_item@CLightShadows@@QAU23@ABU23@@Z ; std::vector<CLightShadows::cache_item,xalloc<CLightShadows::cache_item> >::_Emplace_reallocate<CLightShadows::cache_item const &>

; 829  :         return emplace(_Where, _Val);

	mov	ecx, DWORD PTR ___$ReturnUdt$[esp+60]

; 830  :     }

	pop	edi
	pop	esi
	pop	ebx
	mov	DWORD PTR [ecx], eax
	mov	eax, ecx
	add	esp, 52					; 00000034H
	ret	12					; 0000000cH
?insert@?$vector@Ucache_item@CLightShadows@@V?$xalloc@Ucache_item@CLightShadows@@@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@Ucache_item@CLightShadows@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@Ucache_item@CLightShadows@@@std@@@std@@@2@ABUcache_item@CLightShadows@@@Z ENDP ; std::vector<CLightShadows::cache_item,xalloc<CLightShadows::cache_item> >::insert
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??1?$vector@Ucache_item@CLightShadows@@V?$xalloc@Ucache_item@CLightShadows@@@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@Ucache_item@CLightShadows@@V?$xalloc@Ucache_item@CLightShadows@@@@@std@@QAE@XZ PROC ; std::vector<CLightShadows::cache_item,xalloc<CLightShadows::cache_item> >::~vector<CLightShadows::cache_item,xalloc<CLightShadows::cache_item> >, COMDAT
; _this$ = ecx

; 698  :     _CONSTEXPR20_CONTAINER ~vector() noexcept {

	push	esi
	mov	esi, ecx

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN4@vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+4], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+8], 0
$LN4@vector:
	pop	esi

; 699  :         _Tidy();
; 700  : #if _ITERATOR_DEBUG_LEVEL != 0
; 701  :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 702  :         _Delete_plain_internal(_Alproxy, _STD exchange(_Mypair._Myval2._Myproxy, nullptr));
; 703  : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 704  :     }

	ret	0
??1?$vector@Ucache_item@CLightShadows@@V?$xalloc@Ucache_item@CLightShadows@@@@@std@@QAE@XZ ENDP ; std::vector<CLightShadows::cache_item,xalloc<CLightShadows::cache_item> >::~vector<CLightShadows::cache_item,xalloc<CLightShadows::cache_item> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?clear@?$xr_vector@Utess_tri@CLightShadows@@V?$xalloc@Utess_tri@CLightShadows@@@@@@QAEXXZ
_TEXT	SEGMENT
?clear@?$xr_vector@Utess_tri@CLightShadows@@V?$xalloc@Utess_tri@CLightShadows@@@@@@QAEXXZ PROC ; xr_vector<CLightShadows::tess_tri,xalloc<CLightShadows::tess_tri> >::clear, COMDAT
; _this$ = ecx

; 132  : 	void	clear				()									{ clear_and_free	();			}

	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [ecx+4], eax
	ret	0
?clear@?$xr_vector@Utess_tri@CLightShadows@@V?$xalloc@Utess_tri@CLightShadows@@@@@@QAEXXZ ENDP ; xr_vector<CLightShadows::tess_tri,xalloc<CLightShadows::tess_tri> >::clear
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?size@?$xr_vector@Utess_tri@CLightShadows@@V?$xalloc@Utess_tri@CLightShadows@@@@@@QBEIXZ
_TEXT	SEGMENT
?size@?$xr_vector@Utess_tri@CLightShadows@@V?$xalloc@Utess_tri@CLightShadows@@@@@@QBEIXZ PROC ; xr_vector<CLightShadows::tess_tri,xalloc<CLightShadows::tess_tri> >::size, COMDAT
; _this$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	eax, DWORD PTR [ecx+4]
	sub	eax, DWORD PTR [ecx]
	sar	eax, 4
	imul	eax, eax, -1431655765
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 125  : 	u32		size				() const							{ return (u32)inherited::size();} 

	ret	0
?size@?$xr_vector@Utess_tri@CLightShadows@@V?$xalloc@Utess_tri@CLightShadows@@@@@@QBEIXZ ENDP ; xr_vector<CLightShadows::tess_tri,xalloc<CLightShadows::tess_tri> >::size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ??0?$xr_vector@Utess_tri@CLightShadows@@V?$xalloc@Utess_tri@CLightShadows@@@@@@QAE@XZ
_TEXT	SEGMENT
??0?$xr_vector@Utess_tri@CLightShadows@@V?$xalloc@Utess_tri@CLightShadows@@@@@@QAE@XZ PROC ; xr_vector<CLightShadows::tess_tri,xalloc<CLightShadows::tess_tri> >::xr_vector<CLightShadows::tess_tri,xalloc<CLightShadows::tess_tri> >, COMDAT
; _this$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx], 0
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 122  : 			xr_vector			()									: inherited	()					{}

	mov	eax, ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 122  : 			xr_vector			()									: inherited	()					{}

	ret	0
??0?$xr_vector@Utess_tri@CLightShadows@@V?$xalloc@Utess_tri@CLightShadows@@@@@@QAE@XZ ENDP ; xr_vector<CLightShadows::tess_tri,xalloc<CLightShadows::tess_tri> >::xr_vector<CLightShadows::tess_tri,xalloc<CLightShadows::tess_tri> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?back@?$vector@Utess_tri@CLightShadows@@V?$xalloc@Utess_tri@CLightShadows@@@@@std@@QAEAAUtess_tri@CLightShadows@@XZ
_TEXT	SEGMENT
?back@?$vector@Utess_tri@CLightShadows@@V?$xalloc@Utess_tri@CLightShadows@@@@@std@@QAEAAUtess_tri@CLightShadows@@XZ PROC ; std::vector<CLightShadows::tess_tri,xalloc<CLightShadows::tess_tri> >::back, COMDAT
; _this$ = ecx

; 1606 :         auto& _My_data = _Mypair._Myval2;
; 1607 : #if _CONTAINER_DEBUG_LEVEL > 0
; 1608 :         _STL_VERIFY(_My_data._Myfirst != _My_data._Mylast, "back() called on empty vector");
; 1609 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 1610 : 
; 1611 :         return _My_data._Mylast[-1];

	mov	eax, DWORD PTR [ecx+4]
	sub	eax, 48					; 00000030H

; 1612 :     }

	ret	0
?back@?$vector@Utess_tri@CLightShadows@@V?$xalloc@Utess_tri@CLightShadows@@@@@std@@QAEAAUtess_tri@CLightShadows@@XZ ENDP ; std::vector<CLightShadows::tess_tri,xalloc<CLightShadows::tess_tri> >::back
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?begin@?$vector@Utess_tri@CLightShadows@@V?$xalloc@Utess_tri@CLightShadows@@@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@Utess_tri@CLightShadows@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@Utess_tri@CLightShadows@@V?$xalloc@Utess_tri@CLightShadows@@@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@Utess_tri@CLightShadows@@@std@@@std@@@2@XZ PROC ; std::vector<CLightShadows::tess_tri,xalloc<CLightShadows::tess_tri> >::begin, COMDAT
; _this$ = ecx

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	ecx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], ecx

; 1462 :         auto& _My_data = _Mypair._Myval2;
; 1463 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));
; 1464 :     }

	ret	4
?begin@?$vector@Utess_tri@CLightShadows@@V?$xalloc@Utess_tri@CLightShadows@@@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@Utess_tri@CLightShadows@@@std@@@std@@@2@XZ ENDP ; std::vector<CLightShadows::tess_tri,xalloc<CLightShadows::tess_tri> >::begin
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?push_back@?$vector@Utess_tri@CLightShadows@@V?$xalloc@Utess_tri@CLightShadows@@@@@std@@QAEX$$QAUtess_tri@CLightShadows@@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?push_back@?$vector@Utess_tri@CLightShadows@@V?$xalloc@Utess_tri@CLightShadows@@@@@std@@QAEX$$QAUtess_tri@CLightShadows@@@Z PROC ; std::vector<CLightShadows::tess_tri,xalloc<CLightShadows::tess_tri> >::push_back, COMDAT
; _this$ = ecx

; 746  :     _CONSTEXPR20_CONTAINER void push_back(_Ty&& _Val) {

	mov	eax, ecx

; 730  :         if (_Mylast != _My_data._Myend) {

	mov	edx, DWORD PTR [eax+4]
	cmp	edx, DWORD PTR [eax+8]
	je	SHORT $LN4@push_back
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	push	esi
	mov	esi, DWORD PTR __Val$[esp]
	mov	ecx, 12					; 0000000cH
	push	edi
	mov	edi, edx
	rep movsd
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 716  :         ++_Mylast;

	add	DWORD PTR [eax+4], 48			; 00000030H
	pop	edi
	pop	esi

; 747  :         // insert by moving into element at end, provide strong guarantee
; 748  :         emplace_back(_STD move(_Val));
; 749  :     }

	ret	4
$LN4@push_back:

; 734  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	push	DWORD PTR __Val$[esp-4]
	push	edx
	call	??$_Emplace_reallocate@Utess_tri@CLightShadows@@@?$vector@Utess_tri@CLightShadows@@V?$xalloc@Utess_tri@CLightShadows@@@@@std@@QAEPAUtess_tri@CLightShadows@@QAU23@$$QAU23@@Z ; std::vector<CLightShadows::tess_tri,xalloc<CLightShadows::tess_tri> >::_Emplace_reallocate<CLightShadows::tess_tri>

; 747  :         // insert by moving into element at end, provide strong guarantee
; 748  :         emplace_back(_STD move(_Val));
; 749  :     }

	ret	4
?push_back@?$vector@Utess_tri@CLightShadows@@V?$xalloc@Utess_tri@CLightShadows@@@@@std@@QAEX$$QAUtess_tri@CLightShadows@@@Z ENDP ; std::vector<CLightShadows::tess_tri,xalloc<CLightShadows::tess_tri> >::push_back
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??$emplace_back@Utess_tri@CLightShadows@@@?$vector@Utess_tri@CLightShadows@@V?$xalloc@Utess_tri@CLightShadows@@@@@std@@QAE?A_T$$QAUtess_tri@CLightShadows@@@Z
_TEXT	SEGMENT
_<_Val_0>$ = 8						; size = 4
??$emplace_back@Utess_tri@CLightShadows@@@?$vector@Utess_tri@CLightShadows@@V?$xalloc@Utess_tri@CLightShadows@@@@@std@@QAE?A_T$$QAUtess_tri@CLightShadows@@@Z PROC ; std::vector<CLightShadows::tess_tri,xalloc<CLightShadows::tess_tri> >::emplace_back<CLightShadows::tess_tri>, COMDAT
; _this$ = ecx

; 726  :     _CONSTEXPR20_CONTAINER decltype(auto) emplace_back(_Valty&&... _Val) {

	mov	eax, ecx

; 727  :         // insert by perfectly forwarding into element at end, provide strong guarantee
; 728  :         auto& _My_data   = _Mypair._Myval2;
; 729  :         pointer& _Mylast = _My_data._Mylast;
; 730  :         if (_Mylast != _My_data._Myend) {

	mov	edx, DWORD PTR [eax+4]
	cmp	edx, DWORD PTR [eax+8]
	je	SHORT $LN2@emplace_ba
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	push	esi
	mov	esi, DWORD PTR _<_Val_0>$[esp]
	mov	ecx, 12					; 0000000cH
	push	edi
	mov	edi, edx
	rep movsd
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 716  :         ++_Mylast;

	add	DWORD PTR [eax+4], 48			; 00000030H
	pop	edi
	pop	esi

; 735  : #if _HAS_CXX17
; 736  :         return _Result;
; 737  : #else // ^^^ _HAS_CXX17 ^^^ // vvv !_HAS_CXX17 vvv
; 738  :         (void) _Result;
; 739  : #endif // _HAS_CXX17
; 740  :     }

	ret	4
$LN2@emplace_ba:

; 731  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);
; 732  :         }
; 733  : 
; 734  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	push	DWORD PTR _<_Val_0>$[esp-4]
	push	edx
	call	??$_Emplace_reallocate@Utess_tri@CLightShadows@@@?$vector@Utess_tri@CLightShadows@@V?$xalloc@Utess_tri@CLightShadows@@@@@std@@QAEPAUtess_tri@CLightShadows@@QAU23@$$QAU23@@Z ; std::vector<CLightShadows::tess_tri,xalloc<CLightShadows::tess_tri> >::_Emplace_reallocate<CLightShadows::tess_tri>

; 735  : #if _HAS_CXX17
; 736  :         return _Result;
; 737  : #else // ^^^ _HAS_CXX17 ^^^ // vvv !_HAS_CXX17 vvv
; 738  :         (void) _Result;
; 739  : #endif // _HAS_CXX17
; 740  :     }

	ret	4
??$emplace_back@Utess_tri@CLightShadows@@@?$vector@Utess_tri@CLightShadows@@V?$xalloc@Utess_tri@CLightShadows@@@@@std@@QAE?A_T$$QAUtess_tri@CLightShadows@@@Z ENDP ; std::vector<CLightShadows::tess_tri,xalloc<CLightShadows::tess_tri> >::emplace_back<CLightShadows::tess_tri>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??$_Emplace_back_with_unused_capacity@Utess_tri@CLightShadows@@@?$vector@Utess_tri@CLightShadows@@V?$xalloc@Utess_tri@CLightShadows@@@@@std@@AAE?A_T$$QAUtess_tri@CLightShadows@@@Z
_TEXT	SEGMENT
_<_Val_0>$ = 8						; size = 4
??$_Emplace_back_with_unused_capacity@Utess_tri@CLightShadows@@@?$vector@Utess_tri@CLightShadows@@V?$xalloc@Utess_tri@CLightShadows@@@@@std@@AAE?A_T$$QAUtess_tri@CLightShadows@@@Z PROC ; std::vector<CLightShadows::tess_tri,xalloc<CLightShadows::tess_tri> >::_Emplace_back_with_unused_capacity<CLightShadows::tess_tri>, COMDAT
; _this$ = ecx

; 708  :     _CONSTEXPR20_CONTAINER decltype(auto) _Emplace_back_with_unused_capacity(_Valty&&... _Val) {

	mov	eax, ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	ecx, 12					; 0000000cH
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 708  :     _CONSTEXPR20_CONTAINER decltype(auto) _Emplace_back_with_unused_capacity(_Valty&&... _Val) {

	push	esi
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	esi, DWORD PTR _<_Val_0>$[esp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 708  :     _CONSTEXPR20_CONTAINER decltype(auto) _Emplace_back_with_unused_capacity(_Valty&&... _Val) {

	push	edi
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	edi, DWORD PTR [eax+4]
	rep movsd
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 716  :         ++_Mylast;

	add	DWORD PTR [eax+4], 48			; 00000030H
	pop	edi
	pop	esi

; 717  : #if _HAS_CXX17
; 718  :         return _Result;
; 719  : #else // ^^^ _HAS_CXX17 ^^^ // vvv !_HAS_CXX17 vvv
; 720  :         (void) _Result;
; 721  : #endif // _HAS_CXX17
; 722  :     }

	ret	4
??$_Emplace_back_with_unused_capacity@Utess_tri@CLightShadows@@@?$vector@Utess_tri@CLightShadows@@V?$xalloc@Utess_tri@CLightShadows@@@@@std@@AAE?A_T$$QAUtess_tri@CLightShadows@@@Z ENDP ; std::vector<CLightShadows::tess_tri,xalloc<CLightShadows::tess_tri> >::_Emplace_back_with_unused_capacity<CLightShadows::tess_tri>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??1?$vector@Utess_tri@CLightShadows@@V?$xalloc@Utess_tri@CLightShadows@@@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@Utess_tri@CLightShadows@@V?$xalloc@Utess_tri@CLightShadows@@@@@std@@QAE@XZ PROC ; std::vector<CLightShadows::tess_tri,xalloc<CLightShadows::tess_tri> >::~vector<CLightShadows::tess_tri,xalloc<CLightShadows::tess_tri> >, COMDAT
; _this$ = ecx

; 698  :     _CONSTEXPR20_CONTAINER ~vector() noexcept {

	push	esi
	mov	esi, ecx

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN4@vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+4], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+8], 0
$LN4@vector:
	pop	esi

; 699  :         _Tidy();
; 700  : #if _ITERATOR_DEBUG_LEVEL != 0
; 701  :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 702  :         _Delete_plain_internal(_Alproxy, _STD exchange(_Mypair._Myval2._Myproxy, nullptr));
; 703  : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 704  :     }

	ret	0
??1?$vector@Utess_tri@CLightShadows@@V?$xalloc@Utess_tri@CLightShadows@@@@@std@@QAE@XZ ENDP ; std::vector<CLightShadows::tess_tri,xalloc<CLightShadows::tess_tri> >::~vector<CLightShadows::tess_tri,xalloc<CLightShadows::tess_tri> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ??A?$xr_vector@Ushadow@CLightShadows@@V?$xalloc@Ushadow@CLightShadows@@@@@@QAEAAUshadow@CLightShadows@@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$xr_vector@Ushadow@CLightShadows@@V?$xalloc@Ushadow@CLightShadows@@@@@@QAEAAUshadow@CLightShadows@@I@Z PROC ; xr_vector<CLightShadows::shadow,xalloc<CLightShadows::shadow> >::operator[], COMDAT
; _this$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 119  :         _Ptr += _Off;

	imul	eax, DWORD PTR __Pos$[esp-4], 92
	add	eax, DWORD PTR [ecx]
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 138  : 	reference operator[]		(size_type _Pos)					{ {VERIFY(_Pos<size());} return (*(begin() + _Pos)); }

	ret	4
??A?$xr_vector@Ushadow@CLightShadows@@V?$xalloc@Ushadow@CLightShadows@@@@@@QAEAAUshadow@CLightShadows@@I@Z ENDP ; xr_vector<CLightShadows::shadow,xalloc<CLightShadows::shadow> >::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?clear@?$xr_vector@Ushadow@CLightShadows@@V?$xalloc@Ushadow@CLightShadows@@@@@@QAEXXZ
_TEXT	SEGMENT
?clear@?$xr_vector@Ushadow@CLightShadows@@V?$xalloc@Ushadow@CLightShadows@@@@@@QAEXXZ PROC ; xr_vector<CLightShadows::shadow,xalloc<CLightShadows::shadow> >::clear, COMDAT
; _this$ = ecx

; 132  : 	void	clear				()									{ clear_and_free	();			}

	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [ecx+4], eax
	ret	0
?clear@?$xr_vector@Ushadow@CLightShadows@@V?$xalloc@Ushadow@CLightShadows@@@@@@QAEXXZ ENDP ; xr_vector<CLightShadows::shadow,xalloc<CLightShadows::shadow> >::clear
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?size@?$xr_vector@Ushadow@CLightShadows@@V?$xalloc@Ushadow@CLightShadows@@@@@@QBEIXZ
_TEXT	SEGMENT
?size@?$xr_vector@Ushadow@CLightShadows@@V?$xalloc@Ushadow@CLightShadows@@@@@@QBEIXZ PROC ; xr_vector<CLightShadows::shadow,xalloc<CLightShadows::shadow> >::size, COMDAT
; _this$ = ecx

; 125  : 	u32		size				() const							{ return (u32)inherited::size();} 

	push	esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	esi, DWORD PTR [ecx+4]
	mov	eax, -1307163959			; b21642c9H
	sub	esi, DWORD PTR [ecx]
	imul	esi
	add	edx, esi
	sar	edx, 6
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 125  : 	u32		size				() const							{ return (u32)inherited::size();} 

	pop	esi
	ret	0
?size@?$xr_vector@Ushadow@CLightShadows@@V?$xalloc@Ushadow@CLightShadows@@@@@@QBEIXZ ENDP ; xr_vector<CLightShadows::shadow,xalloc<CLightShadows::shadow> >::size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ??0?$xr_vector@Ushadow@CLightShadows@@V?$xalloc@Ushadow@CLightShadows@@@@@@QAE@XZ
_TEXT	SEGMENT
??0?$xr_vector@Ushadow@CLightShadows@@V?$xalloc@Ushadow@CLightShadows@@@@@@QAE@XZ PROC ; xr_vector<CLightShadows::shadow,xalloc<CLightShadows::shadow> >::xr_vector<CLightShadows::shadow,xalloc<CLightShadows::shadow> >, COMDAT
; _this$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx], 0
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 122  : 			xr_vector			()									: inherited	()					{}

	mov	eax, ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 122  : 			xr_vector			()									: inherited	()					{}

	ret	0
??0?$xr_vector@Ushadow@CLightShadows@@V?$xalloc@Ushadow@CLightShadows@@@@@@QAE@XZ ENDP ; xr_vector<CLightShadows::shadow,xalloc<CLightShadows::shadow> >::xr_vector<CLightShadows::shadow,xalloc<CLightShadows::shadow> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?back@?$vector@Ushadow@CLightShadows@@V?$xalloc@Ushadow@CLightShadows@@@@@std@@QAEAAUshadow@CLightShadows@@XZ
_TEXT	SEGMENT
?back@?$vector@Ushadow@CLightShadows@@V?$xalloc@Ushadow@CLightShadows@@@@@std@@QAEAAUshadow@CLightShadows@@XZ PROC ; std::vector<CLightShadows::shadow,xalloc<CLightShadows::shadow> >::back, COMDAT
; _this$ = ecx

; 1606 :         auto& _My_data = _Mypair._Myval2;
; 1607 : #if _CONTAINER_DEBUG_LEVEL > 0
; 1608 :         _STL_VERIFY(_My_data._Myfirst != _My_data._Mylast, "back() called on empty vector");
; 1609 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 1610 : 
; 1611 :         return _My_data._Mylast[-1];

	mov	eax, DWORD PTR [ecx+4]
	sub	eax, 92					; 0000005cH

; 1612 :     }

	ret	0
?back@?$vector@Ushadow@CLightShadows@@V?$xalloc@Ushadow@CLightShadows@@@@@std@@QAEAAUshadow@CLightShadows@@XZ ENDP ; std::vector<CLightShadows::shadow,xalloc<CLightShadows::shadow> >::back
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?push_back@?$vector@Ushadow@CLightShadows@@V?$xalloc@Ushadow@CLightShadows@@@@@std@@QAEX$$QAUshadow@CLightShadows@@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?push_back@?$vector@Ushadow@CLightShadows@@V?$xalloc@Ushadow@CLightShadows@@@@@std@@QAEX$$QAUshadow@CLightShadows@@@Z PROC ; std::vector<CLightShadows::shadow,xalloc<CLightShadows::shadow> >::push_back, COMDAT
; _this$ = ecx

; 746  :     _CONSTEXPR20_CONTAINER void push_back(_Ty&& _Val) {

	mov	eax, ecx

; 730  :         if (_Mylast != _My_data._Myend) {

	mov	edx, DWORD PTR [eax+4]
	cmp	edx, DWORD PTR [eax+8]
	je	SHORT $LN4@push_back
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	push	esi
	mov	esi, DWORD PTR __Val$[esp]
	mov	ecx, 23					; 00000017H
	push	edi
	mov	edi, edx
	rep movsd
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 716  :         ++_Mylast;

	add	DWORD PTR [eax+4], 92			; 0000005cH
	pop	edi
	pop	esi

; 747  :         // insert by moving into element at end, provide strong guarantee
; 748  :         emplace_back(_STD move(_Val));
; 749  :     }

	ret	4
$LN4@push_back:

; 734  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	push	DWORD PTR __Val$[esp-4]
	push	edx
	call	??$_Emplace_reallocate@Ushadow@CLightShadows@@@?$vector@Ushadow@CLightShadows@@V?$xalloc@Ushadow@CLightShadows@@@@@std@@QAEPAUshadow@CLightShadows@@QAU23@$$QAU23@@Z ; std::vector<CLightShadows::shadow,xalloc<CLightShadows::shadow> >::_Emplace_reallocate<CLightShadows::shadow>

; 747  :         // insert by moving into element at end, provide strong guarantee
; 748  :         emplace_back(_STD move(_Val));
; 749  :     }

	ret	4
?push_back@?$vector@Ushadow@CLightShadows@@V?$xalloc@Ushadow@CLightShadows@@@@@std@@QAEX$$QAUshadow@CLightShadows@@@Z ENDP ; std::vector<CLightShadows::shadow,xalloc<CLightShadows::shadow> >::push_back
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??$emplace_back@Ushadow@CLightShadows@@@?$vector@Ushadow@CLightShadows@@V?$xalloc@Ushadow@CLightShadows@@@@@std@@QAE?A_T$$QAUshadow@CLightShadows@@@Z
_TEXT	SEGMENT
_<_Val_0>$ = 8						; size = 4
??$emplace_back@Ushadow@CLightShadows@@@?$vector@Ushadow@CLightShadows@@V?$xalloc@Ushadow@CLightShadows@@@@@std@@QAE?A_T$$QAUshadow@CLightShadows@@@Z PROC ; std::vector<CLightShadows::shadow,xalloc<CLightShadows::shadow> >::emplace_back<CLightShadows::shadow>, COMDAT
; _this$ = ecx

; 726  :     _CONSTEXPR20_CONTAINER decltype(auto) emplace_back(_Valty&&... _Val) {

	mov	eax, ecx

; 727  :         // insert by perfectly forwarding into element at end, provide strong guarantee
; 728  :         auto& _My_data   = _Mypair._Myval2;
; 729  :         pointer& _Mylast = _My_data._Mylast;
; 730  :         if (_Mylast != _My_data._Myend) {

	mov	edx, DWORD PTR [eax+4]
	cmp	edx, DWORD PTR [eax+8]
	je	SHORT $LN2@emplace_ba
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	push	esi
	mov	esi, DWORD PTR _<_Val_0>$[esp]
	mov	ecx, 23					; 00000017H
	push	edi
	mov	edi, edx
	rep movsd
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 716  :         ++_Mylast;

	add	DWORD PTR [eax+4], 92			; 0000005cH
	pop	edi
	pop	esi

; 735  : #if _HAS_CXX17
; 736  :         return _Result;
; 737  : #else // ^^^ _HAS_CXX17 ^^^ // vvv !_HAS_CXX17 vvv
; 738  :         (void) _Result;
; 739  : #endif // _HAS_CXX17
; 740  :     }

	ret	4
$LN2@emplace_ba:

; 731  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);
; 732  :         }
; 733  : 
; 734  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	push	DWORD PTR _<_Val_0>$[esp-4]
	push	edx
	call	??$_Emplace_reallocate@Ushadow@CLightShadows@@@?$vector@Ushadow@CLightShadows@@V?$xalloc@Ushadow@CLightShadows@@@@@std@@QAEPAUshadow@CLightShadows@@QAU23@$$QAU23@@Z ; std::vector<CLightShadows::shadow,xalloc<CLightShadows::shadow> >::_Emplace_reallocate<CLightShadows::shadow>

; 735  : #if _HAS_CXX17
; 736  :         return _Result;
; 737  : #else // ^^^ _HAS_CXX17 ^^^ // vvv !_HAS_CXX17 vvv
; 738  :         (void) _Result;
; 739  : #endif // _HAS_CXX17
; 740  :     }

	ret	4
??$emplace_back@Ushadow@CLightShadows@@@?$vector@Ushadow@CLightShadows@@V?$xalloc@Ushadow@CLightShadows@@@@@std@@QAE?A_T$$QAUshadow@CLightShadows@@@Z ENDP ; std::vector<CLightShadows::shadow,xalloc<CLightShadows::shadow> >::emplace_back<CLightShadows::shadow>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??$_Emplace_back_with_unused_capacity@Ushadow@CLightShadows@@@?$vector@Ushadow@CLightShadows@@V?$xalloc@Ushadow@CLightShadows@@@@@std@@AAE?A_T$$QAUshadow@CLightShadows@@@Z
_TEXT	SEGMENT
_<_Val_0>$ = 8						; size = 4
??$_Emplace_back_with_unused_capacity@Ushadow@CLightShadows@@@?$vector@Ushadow@CLightShadows@@V?$xalloc@Ushadow@CLightShadows@@@@@std@@AAE?A_T$$QAUshadow@CLightShadows@@@Z PROC ; std::vector<CLightShadows::shadow,xalloc<CLightShadows::shadow> >::_Emplace_back_with_unused_capacity<CLightShadows::shadow>, COMDAT
; _this$ = ecx

; 708  :     _CONSTEXPR20_CONTAINER decltype(auto) _Emplace_back_with_unused_capacity(_Valty&&... _Val) {

	mov	eax, ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	ecx, 23					; 00000017H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 708  :     _CONSTEXPR20_CONTAINER decltype(auto) _Emplace_back_with_unused_capacity(_Valty&&... _Val) {

	push	esi
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	esi, DWORD PTR _<_Val_0>$[esp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 708  :     _CONSTEXPR20_CONTAINER decltype(auto) _Emplace_back_with_unused_capacity(_Valty&&... _Val) {

	push	edi
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	edi, DWORD PTR [eax+4]
	rep movsd
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 716  :         ++_Mylast;

	add	DWORD PTR [eax+4], 92			; 0000005cH
	pop	edi
	pop	esi

; 717  : #if _HAS_CXX17
; 718  :         return _Result;
; 719  : #else // ^^^ _HAS_CXX17 ^^^ // vvv !_HAS_CXX17 vvv
; 720  :         (void) _Result;
; 721  : #endif // _HAS_CXX17
; 722  :     }

	ret	4
??$_Emplace_back_with_unused_capacity@Ushadow@CLightShadows@@@?$vector@Ushadow@CLightShadows@@V?$xalloc@Ushadow@CLightShadows@@@@@std@@AAE?A_T$$QAUshadow@CLightShadows@@@Z ENDP ; std::vector<CLightShadows::shadow,xalloc<CLightShadows::shadow> >::_Emplace_back_with_unused_capacity<CLightShadows::shadow>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??1?$vector@Ushadow@CLightShadows@@V?$xalloc@Ushadow@CLightShadows@@@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@Ushadow@CLightShadows@@V?$xalloc@Ushadow@CLightShadows@@@@@std@@QAE@XZ PROC ; std::vector<CLightShadows::shadow,xalloc<CLightShadows::shadow> >::~vector<CLightShadows::shadow,xalloc<CLightShadows::shadow> >, COMDAT
; _this$ = ecx

; 698  :     _CONSTEXPR20_CONTAINER ~vector() noexcept {

	push	esi
	mov	esi, ecx

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN4@vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+4], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+8], 0
$LN4@vector:
	pop	esi

; 699  :         _Tidy();
; 700  : #if _ITERATOR_DEBUG_LEVEL != 0
; 701  :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 702  :         _Delete_plain_internal(_Alproxy, _STD exchange(_Mypair._Myval2._Myproxy, nullptr));
; 703  : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 704  :     }

	ret	0
??1?$vector@Ushadow@CLightShadows@@V?$xalloc@Ushadow@CLightShadows@@@@@std@@QAE@XZ ENDP ; std::vector<CLightShadows::shadow,xalloc<CLightShadows::shadow> >::~vector<CLightShadows::shadow,xalloc<CLightShadows::shadow> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ??A?$xr_vector@PAUcaster@CLightShadows@@V?$xalloc@PAUcaster@CLightShadows@@@@@@QAEAAPAUcaster@CLightShadows@@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$xr_vector@PAUcaster@CLightShadows@@V?$xalloc@PAUcaster@CLightShadows@@@@@@QAEAAPAUcaster@CLightShadows@@I@Z PROC ; xr_vector<CLightShadows::caster *,xalloc<CLightShadows::caster *> >::operator[], COMDAT
; _this$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 119  :         _Ptr += _Off;

	mov	ecx, DWORD PTR [ecx]
	mov	eax, DWORD PTR __Pos$[esp-4]
	lea	eax, DWORD PTR [ecx+eax*4]
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 138  : 	reference operator[]		(size_type _Pos)					{ {VERIFY(_Pos<size());} return (*(begin() + _Pos)); }

	ret	4
??A?$xr_vector@PAUcaster@CLightShadows@@V?$xalloc@PAUcaster@CLightShadows@@@@@@QAEAAPAUcaster@CLightShadows@@I@Z ENDP ; xr_vector<CLightShadows::caster *,xalloc<CLightShadows::caster *> >::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?clear@?$xr_vector@PAUcaster@CLightShadows@@V?$xalloc@PAUcaster@CLightShadows@@@@@@QAEXXZ
_TEXT	SEGMENT
?clear@?$xr_vector@PAUcaster@CLightShadows@@V?$xalloc@PAUcaster@CLightShadows@@@@@@QAEXXZ PROC ; xr_vector<CLightShadows::caster *,xalloc<CLightShadows::caster *> >::clear, COMDAT
; _this$ = ecx

; 132  : 	void	clear				()									{ clear_and_free	();			}

	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [ecx+4], eax
	ret	0
?clear@?$xr_vector@PAUcaster@CLightShadows@@V?$xalloc@PAUcaster@CLightShadows@@@@@@QAEXXZ ENDP ; xr_vector<CLightShadows::caster *,xalloc<CLightShadows::caster *> >::clear
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?size@?$xr_vector@PAUcaster@CLightShadows@@V?$xalloc@PAUcaster@CLightShadows@@@@@@QBEIXZ
_TEXT	SEGMENT
?size@?$xr_vector@PAUcaster@CLightShadows@@V?$xalloc@PAUcaster@CLightShadows@@@@@@QBEIXZ PROC ; xr_vector<CLightShadows::caster *,xalloc<CLightShadows::caster *> >::size, COMDAT
; _this$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	eax, DWORD PTR [ecx+4]
	sub	eax, DWORD PTR [ecx]
	sar	eax, 2
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 125  : 	u32		size				() const							{ return (u32)inherited::size();} 

	ret	0
?size@?$xr_vector@PAUcaster@CLightShadows@@V?$xalloc@PAUcaster@CLightShadows@@@@@@QBEIXZ ENDP ; xr_vector<CLightShadows::caster *,xalloc<CLightShadows::caster *> >::size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ??0?$xr_vector@PAUcaster@CLightShadows@@V?$xalloc@PAUcaster@CLightShadows@@@@@@QAE@XZ
_TEXT	SEGMENT
??0?$xr_vector@PAUcaster@CLightShadows@@V?$xalloc@PAUcaster@CLightShadows@@@@@@QAE@XZ PROC ; xr_vector<CLightShadows::caster *,xalloc<CLightShadows::caster *> >::xr_vector<CLightShadows::caster *,xalloc<CLightShadows::caster *> >, COMDAT
; _this$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx], 0
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 122  : 			xr_vector			()									: inherited	()					{}

	mov	eax, ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 122  : 			xr_vector			()									: inherited	()					{}

	ret	0
??0?$xr_vector@PAUcaster@CLightShadows@@V?$xalloc@PAUcaster@CLightShadows@@@@@@QAE@XZ ENDP ; xr_vector<CLightShadows::caster *,xalloc<CLightShadows::caster *> >::xr_vector<CLightShadows::caster *,xalloc<CLightShadows::caster *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?back@?$vector@PAUcaster@CLightShadows@@V?$xalloc@PAUcaster@CLightShadows@@@@@std@@QAEAAPAUcaster@CLightShadows@@XZ
_TEXT	SEGMENT
?back@?$vector@PAUcaster@CLightShadows@@V?$xalloc@PAUcaster@CLightShadows@@@@@std@@QAEAAPAUcaster@CLightShadows@@XZ PROC ; std::vector<CLightShadows::caster *,xalloc<CLightShadows::caster *> >::back, COMDAT
; _this$ = ecx

; 1606 :         auto& _My_data = _Mypair._Myval2;
; 1607 : #if _CONTAINER_DEBUG_LEVEL > 0
; 1608 :         _STL_VERIFY(_My_data._Myfirst != _My_data._Mylast, "back() called on empty vector");
; 1609 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 1610 : 
; 1611 :         return _My_data._Mylast[-1];

	mov	eax, DWORD PTR [ecx+4]
	sub	eax, 4

; 1612 :     }

	ret	0
?back@?$vector@PAUcaster@CLightShadows@@V?$xalloc@PAUcaster@CLightShadows@@@@@std@@QAEAAPAUcaster@CLightShadows@@XZ ENDP ; std::vector<CLightShadows::caster *,xalloc<CLightShadows::caster *> >::back
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?empty@?$vector@PAUcaster@CLightShadows@@V?$xalloc@PAUcaster@CLightShadows@@@@@std@@QBE_NXZ
_TEXT	SEGMENT
?empty@?$vector@PAUcaster@CLightShadows@@V?$xalloc@PAUcaster@CLightShadows@@@@@std@@QBE_NXZ PROC ; std::vector<CLightShadows::caster *,xalloc<CLightShadows::caster *> >::empty, COMDAT
; _this$ = ecx

; 1530 :         auto& _My_data = _Mypair._Myval2;
; 1531 :         return _My_data._Myfirst == _My_data._Mylast;

	mov	eax, DWORD PTR [ecx]
	cmp	eax, DWORD PTR [ecx+4]
	sete	al

; 1532 :     }

	ret	0
?empty@?$vector@PAUcaster@CLightShadows@@V?$xalloc@PAUcaster@CLightShadows@@@@@std@@QBE_NXZ ENDP ; std::vector<CLightShadows::caster *,xalloc<CLightShadows::caster *> >::empty
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?pop_back@?$vector@PAUcaster@CLightShadows@@V?$xalloc@PAUcaster@CLightShadows@@@@@std@@QAEXXZ
_TEXT	SEGMENT
?pop_back@?$vector@PAUcaster@CLightShadows@@V?$xalloc@PAUcaster@CLightShadows@@@@@std@@QAEXXZ PROC ; std::vector<CLightShadows::caster *,xalloc<CLightShadows::caster *> >::pop_back, COMDAT
; _this$ = ecx

; 1381 :         auto& _My_data   = _Mypair._Myval2;
; 1382 :         pointer& _Mylast = _My_data._Mylast;
; 1383 : 
; 1384 : #if _ITERATOR_DEBUG_LEVEL == 2
; 1385 :         _STL_VERIFY(_My_data._Myfirst != _Mylast, "vector empty before pop");
; 1386 : #endif // _ITERATOR_DEBUG_LEVEL == 2
; 1387 : 
; 1388 :         _Orphan_range(_Mylast - 1, _Mylast);
; 1389 :         _Alty_traits::destroy(_Getal(), _Unfancy(_Mylast - 1));
; 1390 :         --_Mylast;

	add	DWORD PTR [ecx+4], -4			; fffffffcH

; 1391 :     }

	ret	0
?pop_back@?$vector@PAUcaster@CLightShadows@@V?$xalloc@PAUcaster@CLightShadows@@@@@std@@QAEXXZ ENDP ; std::vector<CLightShadows::caster *,xalloc<CLightShadows::caster *> >::pop_back
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?push_back@?$vector@PAUcaster@CLightShadows@@V?$xalloc@PAUcaster@CLightShadows@@@@@std@@QAEXABQAUcaster@CLightShadows@@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?push_back@?$vector@PAUcaster@CLightShadows@@V?$xalloc@PAUcaster@CLightShadows@@@@@std@@QAEXABQAUcaster@CLightShadows@@@Z PROC ; std::vector<CLightShadows::caster *,xalloc<CLightShadows::caster *> >::push_back, COMDAT
; _this$ = ecx

; 730  :         if (_Mylast != _My_data._Myend) {

	mov	edx, DWORD PTR [ecx+4]
	cmp	edx, DWORD PTR [ecx+8]
	je	SHORT $LN4@push_back

; 713  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

	mov	eax, DWORD PTR __Val$[esp-4]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edx], eax

; 714  :         _Orphan_range(_Mylast, _Mylast);
; 715  :         _Ty& _Result = *_Mylast;
; 716  :         ++_Mylast;

	add	DWORD PTR [ecx+4], 4

; 743  :         emplace_back(_Val);
; 744  :     }

	ret	4
$LN4@push_back:

; 734  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	push	DWORD PTR __Val$[esp-4]
	push	edx
	call	??$_Emplace_reallocate@ABQAUcaster@CLightShadows@@@?$vector@PAUcaster@CLightShadows@@V?$xalloc@PAUcaster@CLightShadows@@@@@std@@QAEPAPAUcaster@CLightShadows@@QAPAU23@ABQAU23@@Z ; std::vector<CLightShadows::caster *,xalloc<CLightShadows::caster *> >::_Emplace_reallocate<CLightShadows::caster * const &>

; 743  :         emplace_back(_Val);
; 744  :     }

	ret	4
?push_back@?$vector@PAUcaster@CLightShadows@@V?$xalloc@PAUcaster@CLightShadows@@@@@std@@QAEXABQAUcaster@CLightShadows@@@Z ENDP ; std::vector<CLightShadows::caster *,xalloc<CLightShadows::caster *> >::push_back
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??$emplace_back@ABQAUcaster@CLightShadows@@@?$vector@PAUcaster@CLightShadows@@V?$xalloc@PAUcaster@CLightShadows@@@@@std@@QAE?A_TABQAUcaster@CLightShadows@@@Z
_TEXT	SEGMENT
_<_Val_0>$ = 8						; size = 4
??$emplace_back@ABQAUcaster@CLightShadows@@@?$vector@PAUcaster@CLightShadows@@V?$xalloc@PAUcaster@CLightShadows@@@@@std@@QAE?A_TABQAUcaster@CLightShadows@@@Z PROC ; std::vector<CLightShadows::caster *,xalloc<CLightShadows::caster *> >::emplace_back<CLightShadows::caster * const &>, COMDAT
; _this$ = ecx

; 727  :         // insert by perfectly forwarding into element at end, provide strong guarantee
; 728  :         auto& _My_data   = _Mypair._Myval2;
; 729  :         pointer& _Mylast = _My_data._Mylast;
; 730  :         if (_Mylast != _My_data._Myend) {

	mov	edx, DWORD PTR [ecx+4]
	cmp	edx, DWORD PTR [ecx+8]
	je	SHORT $LN2@emplace_ba

; 713  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

	mov	eax, DWORD PTR _<_Val_0>$[esp-4]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edx], eax

; 714  :         _Orphan_range(_Mylast, _Mylast);
; 715  :         _Ty& _Result = *_Mylast;
; 716  :         ++_Mylast;

	add	DWORD PTR [ecx+4], 4

; 735  : #if _HAS_CXX17
; 736  :         return _Result;
; 737  : #else // ^^^ _HAS_CXX17 ^^^ // vvv !_HAS_CXX17 vvv
; 738  :         (void) _Result;
; 739  : #endif // _HAS_CXX17
; 740  :     }

	ret	4
$LN2@emplace_ba:

; 731  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);
; 732  :         }
; 733  : 
; 734  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	push	DWORD PTR _<_Val_0>$[esp-4]
	push	edx
	call	??$_Emplace_reallocate@ABQAUcaster@CLightShadows@@@?$vector@PAUcaster@CLightShadows@@V?$xalloc@PAUcaster@CLightShadows@@@@@std@@QAEPAPAUcaster@CLightShadows@@QAPAU23@ABQAU23@@Z ; std::vector<CLightShadows::caster *,xalloc<CLightShadows::caster *> >::_Emplace_reallocate<CLightShadows::caster * const &>

; 735  : #if _HAS_CXX17
; 736  :         return _Result;
; 737  : #else // ^^^ _HAS_CXX17 ^^^ // vvv !_HAS_CXX17 vvv
; 738  :         (void) _Result;
; 739  : #endif // _HAS_CXX17
; 740  :     }

	ret	4
??$emplace_back@ABQAUcaster@CLightShadows@@@?$vector@PAUcaster@CLightShadows@@V?$xalloc@PAUcaster@CLightShadows@@@@@std@@QAE?A_TABQAUcaster@CLightShadows@@@Z ENDP ; std::vector<CLightShadows::caster *,xalloc<CLightShadows::caster *> >::emplace_back<CLightShadows::caster * const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??$_Emplace_back_with_unused_capacity@ABQAUcaster@CLightShadows@@@?$vector@PAUcaster@CLightShadows@@V?$xalloc@PAUcaster@CLightShadows@@@@@std@@AAE?A_TABQAUcaster@CLightShadows@@@Z
_TEXT	SEGMENT
_<_Val_0>$ = 8						; size = 4
??$_Emplace_back_with_unused_capacity@ABQAUcaster@CLightShadows@@@?$vector@PAUcaster@CLightShadows@@V?$xalloc@PAUcaster@CLightShadows@@@@@std@@AAE?A_TABQAUcaster@CLightShadows@@@Z PROC ; std::vector<CLightShadows::caster *,xalloc<CLightShadows::caster *> >::_Emplace_back_with_unused_capacity<CLightShadows::caster * const &>, COMDAT
; _this$ = ecx

; 709  :         // insert by perfectly forwarding into element at end, provide strong guarantee
; 710  :         auto& _My_data   = _Mypair._Myval2;
; 711  :         pointer& _Mylast = _My_data._Mylast;
; 712  :         _STL_INTERNAL_CHECK(_Mylast != _My_data._Myend); // check that we have unused capacity
; 713  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _<_Val_0>$[esp-4]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edx], eax

; 714  :         _Orphan_range(_Mylast, _Mylast);
; 715  :         _Ty& _Result = *_Mylast;
; 716  :         ++_Mylast;

	add	DWORD PTR [ecx+4], 4

; 717  : #if _HAS_CXX17
; 718  :         return _Result;
; 719  : #else // ^^^ _HAS_CXX17 ^^^ // vvv !_HAS_CXX17 vvv
; 720  :         (void) _Result;
; 721  : #endif // _HAS_CXX17
; 722  :     }

	ret	4
??$_Emplace_back_with_unused_capacity@ABQAUcaster@CLightShadows@@@?$vector@PAUcaster@CLightShadows@@V?$xalloc@PAUcaster@CLightShadows@@@@@std@@AAE?A_TABQAUcaster@CLightShadows@@@Z ENDP ; std::vector<CLightShadows::caster *,xalloc<CLightShadows::caster *> >::_Emplace_back_with_unused_capacity<CLightShadows::caster * const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??1?$vector@PAUcaster@CLightShadows@@V?$xalloc@PAUcaster@CLightShadows@@@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@PAUcaster@CLightShadows@@V?$xalloc@PAUcaster@CLightShadows@@@@@std@@QAE@XZ PROC ; std::vector<CLightShadows::caster *,xalloc<CLightShadows::caster *> >::~vector<CLightShadows::caster *,xalloc<CLightShadows::caster *> >, COMDAT
; _this$ = ecx

; 698  :     _CONSTEXPR20_CONTAINER ~vector() noexcept {

	push	esi
	mov	esi, ecx

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN4@vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+4], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+8], 0
$LN4@vector:
	pop	esi

; 699  :         _Tidy();
; 700  : #if _ITERATOR_DEBUG_LEVEL != 0
; 701  :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 702  :         _Delete_plain_internal(_Alproxy, _STD exchange(_Mypair._Myval2._Myproxy, nullptr));
; 703  : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 704  :     }

	ret	0
??1?$vector@PAUcaster@CLightShadows@@V?$xalloc@PAUcaster@CLightShadows@@@@@std@@QAE@XZ ENDP ; std::vector<CLightShadows::caster *,xalloc<CLightShadows::caster *> >::~vector<CLightShadows::caster *,xalloc<CLightShadows::caster *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ??A?$xr_vector@U_MatrixItem@R_dsgraph@@V?$xalloc@U_MatrixItem@R_dsgraph@@@@@@QAEAAU_MatrixItem@R_dsgraph@@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$xr_vector@U_MatrixItem@R_dsgraph@@V?$xalloc@U_MatrixItem@R_dsgraph@@@@@@QAEAAU_MatrixItem@R_dsgraph@@I@Z PROC ; xr_vector<R_dsgraph::_MatrixItem,xalloc<R_dsgraph::_MatrixItem> >::operator[], COMDAT
; _this$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 119  :         _Ptr += _Off;

	imul	eax, DWORD PTR __Pos$[esp-4], 76
	add	eax, DWORD PTR [ecx]
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 138  : 	reference operator[]		(size_type _Pos)					{ {VERIFY(_Pos<size());} return (*(begin() + _Pos)); }

	ret	4
??A?$xr_vector@U_MatrixItem@R_dsgraph@@V?$xalloc@U_MatrixItem@R_dsgraph@@@@@@QAEAAU_MatrixItem@R_dsgraph@@I@Z ENDP ; xr_vector<R_dsgraph::_MatrixItem,xalloc<R_dsgraph::_MatrixItem> >::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?clear@?$xr_vector@U_MatrixItem@R_dsgraph@@V?$xalloc@U_MatrixItem@R_dsgraph@@@@@@QAEXXZ
_TEXT	SEGMENT
?clear@?$xr_vector@U_MatrixItem@R_dsgraph@@V?$xalloc@U_MatrixItem@R_dsgraph@@@@@@QAEXXZ PROC ; xr_vector<R_dsgraph::_MatrixItem,xalloc<R_dsgraph::_MatrixItem> >::clear, COMDAT
; _this$ = ecx

; 132  : 	void	clear				()									{ clear_and_free	();			}

	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [ecx+4], eax
	ret	0
?clear@?$xr_vector@U_MatrixItem@R_dsgraph@@V?$xalloc@U_MatrixItem@R_dsgraph@@@@@@QAEXXZ ENDP ; xr_vector<R_dsgraph::_MatrixItem,xalloc<R_dsgraph::_MatrixItem> >::clear
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?size@?$xr_vector@U_MatrixItem@R_dsgraph@@V?$xalloc@U_MatrixItem@R_dsgraph@@@@@@QBEIXZ
_TEXT	SEGMENT
?size@?$xr_vector@U_MatrixItem@R_dsgraph@@V?$xalloc@U_MatrixItem@R_dsgraph@@@@@@QBEIXZ PROC ; xr_vector<R_dsgraph::_MatrixItem,xalloc<R_dsgraph::_MatrixItem> >::size, COMDAT
; _this$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	eax, DWORD PTR [ecx+4]
	sub	eax, DWORD PTR [ecx]
	sar	eax, 2
	imul	eax, eax, 678152731
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 125  : 	u32		size				() const							{ return (u32)inherited::size();} 

	ret	0
?size@?$xr_vector@U_MatrixItem@R_dsgraph@@V?$xalloc@U_MatrixItem@R_dsgraph@@@@@@QBEIXZ ENDP ; xr_vector<R_dsgraph::_MatrixItem,xalloc<R_dsgraph::_MatrixItem> >::size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?empty@?$vector@U_MatrixItem@R_dsgraph@@V?$xalloc@U_MatrixItem@R_dsgraph@@@@@std@@QBE_NXZ
_TEXT	SEGMENT
?empty@?$vector@U_MatrixItem@R_dsgraph@@V?$xalloc@U_MatrixItem@R_dsgraph@@@@@std@@QBE_NXZ PROC ; std::vector<R_dsgraph::_MatrixItem,xalloc<R_dsgraph::_MatrixItem> >::empty, COMDAT
; _this$ = ecx

; 1530 :         auto& _My_data = _Mypair._Myval2;
; 1531 :         return _My_data._Myfirst == _My_data._Mylast;

	mov	eax, DWORD PTR [ecx]
	cmp	eax, DWORD PTR [ecx+4]
	sete	al

; 1532 :     }

	ret	0
?empty@?$vector@U_MatrixItem@R_dsgraph@@V?$xalloc@U_MatrixItem@R_dsgraph@@@@@std@@QBE_NXZ ENDP ; std::vector<R_dsgraph::_MatrixItem,xalloc<R_dsgraph::_MatrixItem> >::empty
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?push_back@?$vector@U_MatrixItem@R_dsgraph@@V?$xalloc@U_MatrixItem@R_dsgraph@@@@@std@@QAEXABU_MatrixItem@R_dsgraph@@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?push_back@?$vector@U_MatrixItem@R_dsgraph@@V?$xalloc@U_MatrixItem@R_dsgraph@@@@@std@@QAEXABU_MatrixItem@R_dsgraph@@@Z PROC ; std::vector<R_dsgraph::_MatrixItem,xalloc<R_dsgraph::_MatrixItem> >::push_back, COMDAT
; _this$ = ecx

; 742  :     _CONSTEXPR20_CONTAINER void push_back(const _Ty& _Val) { // insert element at end, provide strong guarantee

	mov	eax, ecx

; 730  :         if (_Mylast != _My_data._Myend) {

	mov	edx, DWORD PTR [eax+4]
	cmp	edx, DWORD PTR [eax+8]
	je	SHORT $LN4@push_back
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	push	esi
	mov	esi, DWORD PTR __Val$[esp]
	mov	ecx, 19					; 00000013H
	push	edi
	mov	edi, edx
	rep movsd
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 716  :         ++_Mylast;

	add	DWORD PTR [eax+4], 76			; 0000004cH
	pop	edi
	pop	esi

; 743  :         emplace_back(_Val);
; 744  :     }

	ret	4
$LN4@push_back:

; 734  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	push	DWORD PTR __Val$[esp-4]
	push	edx
	call	??$_Emplace_reallocate@ABU_MatrixItem@R_dsgraph@@@?$vector@U_MatrixItem@R_dsgraph@@V?$xalloc@U_MatrixItem@R_dsgraph@@@@@std@@QAEPAU_MatrixItem@R_dsgraph@@QAU23@ABU23@@Z ; std::vector<R_dsgraph::_MatrixItem,xalloc<R_dsgraph::_MatrixItem> >::_Emplace_reallocate<R_dsgraph::_MatrixItem const &>

; 743  :         emplace_back(_Val);
; 744  :     }

	ret	4
?push_back@?$vector@U_MatrixItem@R_dsgraph@@V?$xalloc@U_MatrixItem@R_dsgraph@@@@@std@@QAEXABU_MatrixItem@R_dsgraph@@@Z ENDP ; std::vector<R_dsgraph::_MatrixItem,xalloc<R_dsgraph::_MatrixItem> >::push_back
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??$emplace_back@ABU_MatrixItem@R_dsgraph@@@?$vector@U_MatrixItem@R_dsgraph@@V?$xalloc@U_MatrixItem@R_dsgraph@@@@@std@@QAE?A_TABU_MatrixItem@R_dsgraph@@@Z
_TEXT	SEGMENT
_<_Val_0>$ = 8						; size = 4
??$emplace_back@ABU_MatrixItem@R_dsgraph@@@?$vector@U_MatrixItem@R_dsgraph@@V?$xalloc@U_MatrixItem@R_dsgraph@@@@@std@@QAE?A_TABU_MatrixItem@R_dsgraph@@@Z PROC ; std::vector<R_dsgraph::_MatrixItem,xalloc<R_dsgraph::_MatrixItem> >::emplace_back<R_dsgraph::_MatrixItem const &>, COMDAT
; _this$ = ecx

; 726  :     _CONSTEXPR20_CONTAINER decltype(auto) emplace_back(_Valty&&... _Val) {

	mov	eax, ecx

; 727  :         // insert by perfectly forwarding into element at end, provide strong guarantee
; 728  :         auto& _My_data   = _Mypair._Myval2;
; 729  :         pointer& _Mylast = _My_data._Mylast;
; 730  :         if (_Mylast != _My_data._Myend) {

	mov	edx, DWORD PTR [eax+4]
	cmp	edx, DWORD PTR [eax+8]
	je	SHORT $LN2@emplace_ba
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	push	esi
	mov	esi, DWORD PTR _<_Val_0>$[esp]
	mov	ecx, 19					; 00000013H
	push	edi
	mov	edi, edx
	rep movsd
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 716  :         ++_Mylast;

	add	DWORD PTR [eax+4], 76			; 0000004cH
	pop	edi
	pop	esi

; 735  : #if _HAS_CXX17
; 736  :         return _Result;
; 737  : #else // ^^^ _HAS_CXX17 ^^^ // vvv !_HAS_CXX17 vvv
; 738  :         (void) _Result;
; 739  : #endif // _HAS_CXX17
; 740  :     }

	ret	4
$LN2@emplace_ba:

; 731  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);
; 732  :         }
; 733  : 
; 734  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	push	DWORD PTR _<_Val_0>$[esp-4]
	push	edx
	call	??$_Emplace_reallocate@ABU_MatrixItem@R_dsgraph@@@?$vector@U_MatrixItem@R_dsgraph@@V?$xalloc@U_MatrixItem@R_dsgraph@@@@@std@@QAEPAU_MatrixItem@R_dsgraph@@QAU23@ABU23@@Z ; std::vector<R_dsgraph::_MatrixItem,xalloc<R_dsgraph::_MatrixItem> >::_Emplace_reallocate<R_dsgraph::_MatrixItem const &>

; 735  : #if _HAS_CXX17
; 736  :         return _Result;
; 737  : #else // ^^^ _HAS_CXX17 ^^^ // vvv !_HAS_CXX17 vvv
; 738  :         (void) _Result;
; 739  : #endif // _HAS_CXX17
; 740  :     }

	ret	4
??$emplace_back@ABU_MatrixItem@R_dsgraph@@@?$vector@U_MatrixItem@R_dsgraph@@V?$xalloc@U_MatrixItem@R_dsgraph@@@@@std@@QAE?A_TABU_MatrixItem@R_dsgraph@@@Z ENDP ; std::vector<R_dsgraph::_MatrixItem,xalloc<R_dsgraph::_MatrixItem> >::emplace_back<R_dsgraph::_MatrixItem const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??$_Emplace_back_with_unused_capacity@ABU_MatrixItem@R_dsgraph@@@?$vector@U_MatrixItem@R_dsgraph@@V?$xalloc@U_MatrixItem@R_dsgraph@@@@@std@@AAE?A_TABU_MatrixItem@R_dsgraph@@@Z
_TEXT	SEGMENT
_<_Val_0>$ = 8						; size = 4
??$_Emplace_back_with_unused_capacity@ABU_MatrixItem@R_dsgraph@@@?$vector@U_MatrixItem@R_dsgraph@@V?$xalloc@U_MatrixItem@R_dsgraph@@@@@std@@AAE?A_TABU_MatrixItem@R_dsgraph@@@Z PROC ; std::vector<R_dsgraph::_MatrixItem,xalloc<R_dsgraph::_MatrixItem> >::_Emplace_back_with_unused_capacity<R_dsgraph::_MatrixItem const &>, COMDAT
; _this$ = ecx

; 708  :     _CONSTEXPR20_CONTAINER decltype(auto) _Emplace_back_with_unused_capacity(_Valty&&... _Val) {

	mov	eax, ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	ecx, 19					; 00000013H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 708  :     _CONSTEXPR20_CONTAINER decltype(auto) _Emplace_back_with_unused_capacity(_Valty&&... _Val) {

	push	esi
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	esi, DWORD PTR _<_Val_0>$[esp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 708  :     _CONSTEXPR20_CONTAINER decltype(auto) _Emplace_back_with_unused_capacity(_Valty&&... _Val) {

	push	edi
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	edi, DWORD PTR [eax+4]
	rep movsd
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 716  :         ++_Mylast;

	add	DWORD PTR [eax+4], 76			; 0000004cH
	pop	edi
	pop	esi

; 717  : #if _HAS_CXX17
; 718  :         return _Result;
; 719  : #else // ^^^ _HAS_CXX17 ^^^ // vvv !_HAS_CXX17 vvv
; 720  :         (void) _Result;
; 721  : #endif // _HAS_CXX17
; 722  :     }

	ret	4
??$_Emplace_back_with_unused_capacity@ABU_MatrixItem@R_dsgraph@@@?$vector@U_MatrixItem@R_dsgraph@@V?$xalloc@U_MatrixItem@R_dsgraph@@@@@std@@AAE?A_TABU_MatrixItem@R_dsgraph@@@Z ENDP ; std::vector<R_dsgraph::_MatrixItem,xalloc<R_dsgraph::_MatrixItem> >::_Emplace_back_with_unused_capacity<R_dsgraph::_MatrixItem const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_plane.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_plane.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_plane.h
;	COMDAT ?build_unit_normal@?$_plane@M@@QAEAAV1@ABU?$_vector3@M@@0@Z
_TEXT	SEGMENT
__p$ = 8						; size = 4
__n$ = 12						; size = 4
?build_unit_normal@?$_plane@M@@QAEAAV1@ABU?$_vector3@M@@0@Z PROC ; _plane<float>::build_unit_normal, COMDAT
; _this$ = ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 24   : 	ICF SelfRef	set(const _vector3<float> &v)			{ x = T(v.x);	y = T(v.y);	z = T(v.z);	return *this;	};

	mov	eax, DWORD PTR __n$[esp-4]
	movss	xmm1, DWORD PTR [eax]
	movss	DWORD PTR [ecx], xmm1
	movss	xmm2, DWORD PTR [eax+4]
	movss	DWORD PTR [ecx+4], xmm2
	movss	xmm0, DWORD PTR [eax+8]

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	mov	eax, DWORD PTR __p$[esp-4]

; 24   : 	ICF SelfRef	set(const _vector3<float> &v)			{ x = T(v.x);	y = T(v.y);	z = T(v.z);	return *this;	};

	movss	DWORD PTR [ecx+8], xmm0

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	mulss	xmm2, DWORD PTR [eax+4]
	mulss	xmm1, DWORD PTR [eax]
	mulss	xmm0, DWORD PTR [eax+8]
; File I:\Vitalya\mine\NSProjectX\xrCore\_plane.h

; 48   : 		return *this;

	mov	eax, ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	addss	xmm2, xmm1
	addss	xmm2, xmm0
	xorps	xmm2, DWORD PTR __xmm@80000000800000008000000080000000
; File I:\Vitalya\mine\NSProjectX\xrCore\_plane.h

; 47   : 		d			= - n.set(_n).dotproduct(_p);

	movss	DWORD PTR [ecx+12], xmm2

; 49   : 	}

	ret	8
?build_unit_normal@?$_plane@M@@QAEAAV1@ABU?$_vector3@M@@0@Z ENDP ; _plane<float>::build_unit_normal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@Ucache_item@CLightShadows@@@std@@@std@@@std@@QAE@PAUcache_item@CLightShadows@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
___param0$ = 8						; size = 4
___param1$dead$ = 12					; size = 4
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@Ucache_item@CLightShadows@@@std@@@std@@@std@@QAE@PAUcache_item@CLightShadows@@PBU_Container_base0@1@@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CLightShadows::cache_item> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<CLightShadows::cache_item> > >, COMDAT
; _this$ = ecx

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	eax, DWORD PTR ___param0$[esp-4]
	mov	DWORD PTR [ecx], eax
	mov	eax, ecx
	ret	8
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@Ucache_item@CLightShadows@@@std@@@std@@@std@@QAE@PAUcache_item@CLightShadows@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CLightShadows::cache_item> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<CLightShadows::cache_item> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@Utess_tri@CLightShadows@@@std@@@std@@@std@@QAE@PAUtess_tri@CLightShadows@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
___param0$ = 8						; size = 4
___param1$dead$ = 12					; size = 4
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@Utess_tri@CLightShadows@@@std@@@std@@@std@@QAE@PAUtess_tri@CLightShadows@@PBU_Container_base0@1@@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CLightShadows::tess_tri> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<CLightShadows::tess_tri> > >, COMDAT
; _this$ = ecx

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	eax, DWORD PTR ___param0$[esp-4]
	mov	DWORD PTR [ecx], eax
	mov	eax, ecx
	ret	8
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@Utess_tri@CLightShadows@@@std@@@std@@@std@@QAE@PAUtess_tri@CLightShadows@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CLightShadows::tess_tri> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<CLightShadows::tess_tri> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U_MatrixItem@R_dsgraph@@@std@@@std@@@std@@QBE?AV01@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U_MatrixItem@R_dsgraph@@@std@@@std@@@std@@QBE?AV01@H@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<R_dsgraph::_MatrixItem> > >::operator+, COMDAT
; _this$ = ecx

; 119  :         _Ptr += _Off;

	imul	edx, DWORD PTR __Off$[esp-4], 76
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	add	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx

; 303  :         _Vector_iterator _Tmp = *this;
; 304  :         _Tmp += _Off; // TRANSITION, LLVM-49342
; 305  :         return _Tmp;
; 306  :     }

	ret	8
??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U_MatrixItem@R_dsgraph@@@std@@@std@@@std@@QBE?AV01@H@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<R_dsgraph::_MatrixItem> > >::operator+
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUcaster@CLightShadows@@@std@@@std@@@std@@QBE?AV01@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUcaster@CLightShadows@@@std@@@std@@@std@@QBE?AV01@H@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CLightShadows::caster *> > >::operator+, COMDAT
; _this$ = ecx

; 119  :         _Ptr += _Off;

	mov	eax, DWORD PTR __Off$[esp-4]
	mov	ecx, DWORD PTR [ecx]
	lea	ecx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 303  :         _Vector_iterator _Tmp = *this;
; 304  :         _Tmp += _Off; // TRANSITION, LLVM-49342
; 305  :         return _Tmp;
; 306  :     }

	ret	8
??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUcaster@CLightShadows@@@std@@@std@@@std@@QBE?AV01@H@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CLightShadows::caster *> > >::operator+
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUcaster@CLightShadows@@@std@@@std@@@std@@QBEAAPAUcaster@CLightShadows@@XZ
_TEXT	SEGMENT
??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUcaster@CLightShadows@@@std@@@std@@@std@@QBEAAPAUcaster@CLightShadows@@XZ PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CLightShadows::caster *> > >::operator*, COMDAT
; _this$ = ecx

; 261  :         return const_cast<reference>(_Mybase::operator*());

	mov	eax, DWORD PTR [ecx]

; 262  :     }

	ret	0
??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUcaster@CLightShadows@@@std@@@std@@@std@@QBEAAPAUcaster@CLightShadows@@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CLightShadows::caster *> > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@Ushadow@CLightShadows@@@std@@@std@@@std@@QBE?AV01@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@Ushadow@CLightShadows@@@std@@@std@@@std@@QBE?AV01@H@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CLightShadows::shadow> > >::operator+, COMDAT
; _this$ = ecx

; 119  :         _Ptr += _Off;

	imul	edx, DWORD PTR __Off$[esp-4], 92
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	add	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx

; 303  :         _Vector_iterator _Tmp = *this;
; 304  :         _Tmp += _Off; // TRANSITION, LLVM-49342
; 305  :         return _Tmp;
; 306  :     }

	ret	8
??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@Ushadow@CLightShadows@@@std@@@std@@@std@@QBE?AV01@H@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CLightShadows::shadow> > >::operator+
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@Ushadow@CLightShadows@@@std@@@std@@@std@@QBEAAUshadow@CLightShadows@@XZ
_TEXT	SEGMENT
??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@Ushadow@CLightShadows@@@std@@@std@@@std@@QBEAAUshadow@CLightShadows@@XZ PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CLightShadows::shadow> > >::operator*, COMDAT
; _this$ = ecx

; 261  :         return const_cast<reference>(_Mybase::operator*());

	mov	eax, DWORD PTR [ecx]

; 262  :     }

	ret	0
??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@Ushadow@CLightShadows@@@std@@@std@@@std@@QBEAAUshadow@CLightShadows@@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CLightShadows::shadow> > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@Utess_tri@CLightShadows@@@std@@@std@@@std@@QBEABUtess_tri@CLightShadows@@XZ
_TEXT	SEGMENT
??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@Utess_tri@CLightShadows@@@std@@@std@@@std@@QBEABUtess_tri@CLightShadows@@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CLightShadows::tess_tri> > >::operator*, COMDAT
; _this$ = ecx

; 46   : #if _ITERATOR_DEBUG_LEVEL != 0
; 47   :         const auto _Mycont = static_cast<const _Myvec*>(this->_Getcont());
; 48   :         _STL_VERIFY(_Ptr, "can't dereference value-initialized vector iterator");
; 49   :         _STL_VERIFY(
; 50   :             _Mycont->_Myfirst <= _Ptr && _Ptr < _Mycont->_Mylast, "can't dereference out of range vector iterator");
; 51   : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 52   : 
; 53   :         return *_Ptr;

	mov	eax, DWORD PTR [ecx]

; 54   :     }

	ret	0
??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@Utess_tri@CLightShadows@@@std@@@std@@@std@@QBEABUtess_tri@CLightShadows@@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CLightShadows::tess_tri> > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@Utess_tri@CLightShadows@@@std@@@std@@@std@@QAE@PAUtess_tri@CLightShadows@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Pvector$dead$ = 12					; size = 4
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@Utess_tri@CLightShadows@@@std@@@std@@@std@@QAE@PAUtess_tri@CLightShadows@@PBU_Container_base0@1@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CLightShadows::tess_tri> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CLightShadows::tess_tri> > >, COMDAT
; _this$ = ecx

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	eax, DWORD PTR __Parg$[esp-4]
	mov	DWORD PTR [ecx], eax

; 42   :         this->_Adopt(_Pvector);
; 43   :     }

	mov	eax, ecx
	ret	8
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@Utess_tri@CLightShadows@@@std@@@std@@@std@@QAE@PAUtess_tri@CLightShadows@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CLightShadows::tess_tri> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CLightShadows::tess_tri> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@Ucache_item@CLightShadows@@@std@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@Ucache_item@CLightShadows@@@std@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CLightShadows::cache_item> > >::operator+=, COMDAT
; _this$ = ecx

; 119  :         _Ptr += _Off;

	imul	eax, DWORD PTR __Off$[esp-4], 44
	add	DWORD PTR [ecx], eax

; 298  :         _Mybase::operator+=(_Off);
; 299  :         return *this;

	mov	eax, ecx

; 300  :     }

	ret	4
??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@Ucache_item@CLightShadows@@@std@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CLightShadows::cache_item> > >::operator+=
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@Ucache_item@CLightShadows@@@std@@@std@@@std@@QBEXABV12@@Z
_TEXT	SEGMENT
__Right$dead$ = 8					; size = 4
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@Ucache_item@CLightShadows@@@std@@@std@@@std@@QBEXABV12@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CLightShadows::cache_item> > >::_Compat, COMDAT
; _this$dead$ = ecx

; 182  :         // test for compatible iterator pair
; 183  : #if _ITERATOR_DEBUG_LEVEL == 0
; 184  :         (void) _Right;
; 185  : #else // ^^^ _ITERATOR_DEBUG_LEVEL == 0 ^^^ // vvv _ITERATOR_DEBUG_LEVEL != 0 vvv
; 186  :         _STL_VERIFY(this->_Getcont() == _Right._Getcont(), "vector iterators incompatible");
; 187  : #endif // _ITERATOR_DEBUG_LEVEL == 0
; 188  :     }

	ret	4
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@Ucache_item@CLightShadows@@@std@@@std@@@std@@QBEXABV12@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CLightShadows::cache_item> > >::_Compat
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@Ucache_item@CLightShadows@@@std@@@std@@@std@@QBEABUcache_item@CLightShadows@@XZ
_TEXT	SEGMENT
??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@Ucache_item@CLightShadows@@@std@@@std@@@std@@QBEABUcache_item@CLightShadows@@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CLightShadows::cache_item> > >::operator*, COMDAT
; _this$ = ecx

; 46   : #if _ITERATOR_DEBUG_LEVEL != 0
; 47   :         const auto _Mycont = static_cast<const _Myvec*>(this->_Getcont());
; 48   :         _STL_VERIFY(_Ptr, "can't dereference value-initialized vector iterator");
; 49   :         _STL_VERIFY(
; 50   :             _Mycont->_Myfirst <= _Ptr && _Ptr < _Mycont->_Mylast, "can't dereference out of range vector iterator");
; 51   : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 52   : 
; 53   :         return *_Ptr;

	mov	eax, DWORD PTR [ecx]

; 54   :     }

	ret	0
??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@Ucache_item@CLightShadows@@@std@@@std@@@std@@QBEABUcache_item@CLightShadows@@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CLightShadows::cache_item> > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@Ucache_item@CLightShadows@@@std@@@std@@@std@@QAE@PAUcache_item@CLightShadows@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Pvector$dead$ = 12					; size = 4
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@Ucache_item@CLightShadows@@@std@@@std@@@std@@QAE@PAUcache_item@CLightShadows@@PBU_Container_base0@1@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CLightShadows::cache_item> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CLightShadows::cache_item> > >, COMDAT
; _this$ = ecx

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	eax, DWORD PTR __Parg$[esp-4]
	mov	DWORD PTR [ecx], eax

; 42   :         this->_Adopt(_Pvector);
; 43   :     }

	mov	eax, ecx
	ret	8
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@Ucache_item@CLightShadows@@@std@@@std@@@std@@QAE@PAUcache_item@CLightShadows@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CLightShadows::cache_item> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CLightShadows::cache_item> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?clear_and_free@?$xr_vector@Ucache_item@CLightShadows@@V?$xalloc@Ucache_item@CLightShadows@@@@@@QAEXXZ
_TEXT	SEGMENT
?clear_and_free@?$xr_vector@Ucache_item@CLightShadows@@V?$xalloc@Ucache_item@CLightShadows@@@@@@QAEXXZ PROC ; xr_vector<CLightShadows::cache_item,xalloc<CLightShadows::cache_item> >::clear_and_free, COMDAT
; _this$ = ecx

; 127  : 	void	clear_and_free		()									{ inherited::clear();			}

	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [ecx+4], eax
	ret	0
?clear_and_free@?$xr_vector@Ucache_item@CLightShadows@@V?$xalloc@Ucache_item@CLightShadows@@@@@@QAEXXZ ENDP ; xr_vector<CLightShadows::cache_item,xalloc<CLightShadows::cache_item> >::clear_and_free
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Getal@?$vector@Ucache_item@CLightShadows@@V?$xalloc@Ucache_item@CLightShadows@@@@@std@@AAEAAV?$xalloc@Ucache_item@CLightShadows@@@@XZ
_TEXT	SEGMENT
?_Getal@?$vector@Ucache_item@CLightShadows@@V?$xalloc@Ucache_item@CLightShadows@@@@@std@@AAEAAV?$xalloc@Ucache_item@CLightShadows@@@@XZ PROC ; std::vector<CLightShadows::cache_item,xalloc<CLightShadows::cache_item> >::_Getal, COMDAT
; _this$ = ecx

; 1805 :         return _Mypair._Get_first();

	mov	eax, ecx

; 1806 :     }

	ret	0
?_Getal@?$vector@Ucache_item@CLightShadows@@V?$xalloc@Ucache_item@CLightShadows@@@@@std@@AAEAAV?$xalloc@Ucache_item@CLightShadows@@@@XZ ENDP ; std::vector<CLightShadows::cache_item,xalloc<CLightShadows::cache_item> >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Orphan_range@?$vector@Ucache_item@CLightShadows@@V?$xalloc@Ucache_item@CLightShadows@@@@@std@@ABEXPAUcache_item@CLightShadows@@0@Z
_TEXT	SEGMENT
___formal$dead$ = 8					; size = 4
___formal$dead$ = 12					; size = 4
?_Orphan_range@?$vector@Ucache_item@CLightShadows@@V?$xalloc@Ucache_item@CLightShadows@@@@@std@@ABEXPAUcache_item@CLightShadows@@0@Z PROC ; std::vector<CLightShadows::cache_item,xalloc<CLightShadows::cache_item> >::_Orphan_range, COMDAT
; _this$dead$ = ecx

; 1801 :     _CONSTEXPR20_CONTAINER void _Orphan_range(pointer, pointer) const {}

	ret	8
?_Orphan_range@?$vector@Ucache_item@CLightShadows@@V?$xalloc@Ucache_item@CLightShadows@@@@@std@@ABEXPAUcache_item@CLightShadows@@0@Z ENDP ; std::vector<CLightShadows::cache_item,xalloc<CLightShadows::cache_item> >::_Orphan_range
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Tidy@?$vector@Ucache_item@CLightShadows@@V?$xalloc@Ucache_item@CLightShadows@@@@@std@@AAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@Ucache_item@CLightShadows@@V?$xalloc@Ucache_item@CLightShadows@@@@@std@@AAEXXZ PROC ; std::vector<CLightShadows::cache_item,xalloc<CLightShadows::cache_item> >::_Tidy, COMDAT
; _this$ = ecx

; 1742 :     _CONSTEXPR20_CONTAINER void _Tidy() noexcept { // free all storage

	push	esi
	mov	esi, ecx

; 1743 :         auto& _My_data    = _Mypair._Myval2;
; 1744 :         pointer& _Myfirst = _My_data._Myfirst;
; 1745 :         pointer& _Mylast  = _My_data._Mylast;
; 1746 :         pointer& _Myend   = _My_data._Myend;
; 1747 : 
; 1748 :         _My_data._Orphan_all();
; 1749 : 
; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN2@Tidy
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+4], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+8], 0
$LN2@Tidy:

; 1757 :         }
; 1758 :     }

	pop	esi
	ret	0
?_Tidy@?$vector@Ucache_item@CLightShadows@@V?$xalloc@Ucache_item@CLightShadows@@@@@std@@AAEXXZ ENDP ; std::vector<CLightShadows::cache_item,xalloc<CLightShadows::cache_item> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?size@?$vector@Ucache_item@CLightShadows@@V?$xalloc@Ucache_item@CLightShadows@@@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@Ucache_item@CLightShadows@@V?$xalloc@Ucache_item@CLightShadows@@@@@std@@QBEIXZ PROC ; std::vector<CLightShadows::cache_item,xalloc<CLightShadows::cache_item> >::size, COMDAT
; _this$ = ecx

; 1535 :         auto& _My_data = _Mypair._Myval2;
; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	eax, DWORD PTR [ecx+4]
	sub	eax, DWORD PTR [ecx]
	sar	eax, 2
	imul	eax, eax, -1171354717

; 1537 :     }

	ret	0
?size@?$vector@Ucache_item@CLightShadows@@V?$xalloc@Ucache_item@CLightShadows@@@@@std@@QBEIXZ ENDP ; std::vector<CLightShadows::cache_item,xalloc<CLightShadows::cache_item> >::size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0?$vector@Ucache_item@CLightShadows@@V?$xalloc@Ucache_item@CLightShadows@@@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@Ucache_item@CLightShadows@@V?$xalloc@Ucache_item@CLightShadows@@@@@std@@QAE@XZ PROC ; std::vector<CLightShadows::cache_item,xalloc<CLightShadows::cache_item> >::vector<CLightShadows::cache_item,xalloc<CLightShadows::cache_item> >, COMDAT
; _this$ = ecx

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx], 0

; 464  :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 465  :     }

	mov	eax, ecx

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0

; 464  :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 465  :     }

	ret	0
??0?$vector@Ucache_item@CLightShadows@@V?$xalloc@Ucache_item@CLightShadows@@@@@std@@QAE@XZ ENDP ; std::vector<CLightShadows::cache_item,xalloc<CLightShadows::cache_item> >::vector<CLightShadows::cache_item,xalloc<CLightShadows::cache_item> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?clear_and_free@?$xr_vector@Utess_tri@CLightShadows@@V?$xalloc@Utess_tri@CLightShadows@@@@@@QAEXXZ
_TEXT	SEGMENT
?clear_and_free@?$xr_vector@Utess_tri@CLightShadows@@V?$xalloc@Utess_tri@CLightShadows@@@@@@QAEXXZ PROC ; xr_vector<CLightShadows::tess_tri,xalloc<CLightShadows::tess_tri> >::clear_and_free, COMDAT
; _this$ = ecx

; 127  : 	void	clear_and_free		()									{ inherited::clear();			}

	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [ecx+4], eax
	ret	0
?clear_and_free@?$xr_vector@Utess_tri@CLightShadows@@V?$xalloc@Utess_tri@CLightShadows@@@@@@QAEXXZ ENDP ; xr_vector<CLightShadows::tess_tri,xalloc<CLightShadows::tess_tri> >::clear_and_free
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Getal@?$vector@Utess_tri@CLightShadows@@V?$xalloc@Utess_tri@CLightShadows@@@@@std@@AAEAAV?$xalloc@Utess_tri@CLightShadows@@@@XZ
_TEXT	SEGMENT
?_Getal@?$vector@Utess_tri@CLightShadows@@V?$xalloc@Utess_tri@CLightShadows@@@@@std@@AAEAAV?$xalloc@Utess_tri@CLightShadows@@@@XZ PROC ; std::vector<CLightShadows::tess_tri,xalloc<CLightShadows::tess_tri> >::_Getal, COMDAT
; _this$ = ecx

; 1805 :         return _Mypair._Get_first();

	mov	eax, ecx

; 1806 :     }

	ret	0
?_Getal@?$vector@Utess_tri@CLightShadows@@V?$xalloc@Utess_tri@CLightShadows@@@@@std@@AAEAAV?$xalloc@Utess_tri@CLightShadows@@@@XZ ENDP ; std::vector<CLightShadows::tess_tri,xalloc<CLightShadows::tess_tri> >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Orphan_range@?$vector@Utess_tri@CLightShadows@@V?$xalloc@Utess_tri@CLightShadows@@@@@std@@ABEXPAUtess_tri@CLightShadows@@0@Z
_TEXT	SEGMENT
___formal$dead$ = 8					; size = 4
___formal$dead$ = 12					; size = 4
?_Orphan_range@?$vector@Utess_tri@CLightShadows@@V?$xalloc@Utess_tri@CLightShadows@@@@@std@@ABEXPAUtess_tri@CLightShadows@@0@Z PROC ; std::vector<CLightShadows::tess_tri,xalloc<CLightShadows::tess_tri> >::_Orphan_range, COMDAT
; _this$dead$ = ecx

; 1801 :     _CONSTEXPR20_CONTAINER void _Orphan_range(pointer, pointer) const {}

	ret	8
?_Orphan_range@?$vector@Utess_tri@CLightShadows@@V?$xalloc@Utess_tri@CLightShadows@@@@@std@@ABEXPAUtess_tri@CLightShadows@@0@Z ENDP ; std::vector<CLightShadows::tess_tri,xalloc<CLightShadows::tess_tri> >::_Orphan_range
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Tidy@?$vector@Utess_tri@CLightShadows@@V?$xalloc@Utess_tri@CLightShadows@@@@@std@@AAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@Utess_tri@CLightShadows@@V?$xalloc@Utess_tri@CLightShadows@@@@@std@@AAEXXZ PROC ; std::vector<CLightShadows::tess_tri,xalloc<CLightShadows::tess_tri> >::_Tidy, COMDAT
; _this$ = ecx

; 1742 :     _CONSTEXPR20_CONTAINER void _Tidy() noexcept { // free all storage

	push	esi
	mov	esi, ecx

; 1743 :         auto& _My_data    = _Mypair._Myval2;
; 1744 :         pointer& _Myfirst = _My_data._Myfirst;
; 1745 :         pointer& _Mylast  = _My_data._Mylast;
; 1746 :         pointer& _Myend   = _My_data._Myend;
; 1747 : 
; 1748 :         _My_data._Orphan_all();
; 1749 : 
; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN2@Tidy
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+4], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+8], 0
$LN2@Tidy:

; 1757 :         }
; 1758 :     }

	pop	esi
	ret	0
?_Tidy@?$vector@Utess_tri@CLightShadows@@V?$xalloc@Utess_tri@CLightShadows@@@@@std@@AAEXXZ ENDP ; std::vector<CLightShadows::tess_tri,xalloc<CLightShadows::tess_tri> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?size@?$vector@Utess_tri@CLightShadows@@V?$xalloc@Utess_tri@CLightShadows@@@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@Utess_tri@CLightShadows@@V?$xalloc@Utess_tri@CLightShadows@@@@@std@@QBEIXZ PROC ; std::vector<CLightShadows::tess_tri,xalloc<CLightShadows::tess_tri> >::size, COMDAT
; _this$ = ecx

; 1535 :         auto& _My_data = _Mypair._Myval2;
; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	eax, DWORD PTR [ecx+4]
	sub	eax, DWORD PTR [ecx]
	sar	eax, 4
	imul	eax, eax, -1431655765

; 1537 :     }

	ret	0
?size@?$vector@Utess_tri@CLightShadows@@V?$xalloc@Utess_tri@CLightShadows@@@@@std@@QBEIXZ ENDP ; std::vector<CLightShadows::tess_tri,xalloc<CLightShadows::tess_tri> >::size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0?$vector@Utess_tri@CLightShadows@@V?$xalloc@Utess_tri@CLightShadows@@@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@Utess_tri@CLightShadows@@V?$xalloc@Utess_tri@CLightShadows@@@@@std@@QAE@XZ PROC ; std::vector<CLightShadows::tess_tri,xalloc<CLightShadows::tess_tri> >::vector<CLightShadows::tess_tri,xalloc<CLightShadows::tess_tri> >, COMDAT
; _this$ = ecx

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx], 0

; 464  :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 465  :     }

	mov	eax, ecx

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0

; 464  :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 465  :     }

	ret	0
??0?$vector@Utess_tri@CLightShadows@@V?$xalloc@Utess_tri@CLightShadows@@@@@std@@QAE@XZ ENDP ; std::vector<CLightShadows::tess_tri,xalloc<CLightShadows::tess_tri> >::vector<CLightShadows::tess_tri,xalloc<CLightShadows::tess_tri> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?clear_and_free@?$xr_vector@Ushadow@CLightShadows@@V?$xalloc@Ushadow@CLightShadows@@@@@@QAEXXZ
_TEXT	SEGMENT
?clear_and_free@?$xr_vector@Ushadow@CLightShadows@@V?$xalloc@Ushadow@CLightShadows@@@@@@QAEXXZ PROC ; xr_vector<CLightShadows::shadow,xalloc<CLightShadows::shadow> >::clear_and_free, COMDAT
; _this$ = ecx

; 127  : 	void	clear_and_free		()									{ inherited::clear();			}

	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [ecx+4], eax
	ret	0
?clear_and_free@?$xr_vector@Ushadow@CLightShadows@@V?$xalloc@Ushadow@CLightShadows@@@@@@QAEXXZ ENDP ; xr_vector<CLightShadows::shadow,xalloc<CLightShadows::shadow> >::clear_and_free
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Getal@?$vector@Ushadow@CLightShadows@@V?$xalloc@Ushadow@CLightShadows@@@@@std@@AAEAAV?$xalloc@Ushadow@CLightShadows@@@@XZ
_TEXT	SEGMENT
?_Getal@?$vector@Ushadow@CLightShadows@@V?$xalloc@Ushadow@CLightShadows@@@@@std@@AAEAAV?$xalloc@Ushadow@CLightShadows@@@@XZ PROC ; std::vector<CLightShadows::shadow,xalloc<CLightShadows::shadow> >::_Getal, COMDAT
; _this$ = ecx

; 1805 :         return _Mypair._Get_first();

	mov	eax, ecx

; 1806 :     }

	ret	0
?_Getal@?$vector@Ushadow@CLightShadows@@V?$xalloc@Ushadow@CLightShadows@@@@@std@@AAEAAV?$xalloc@Ushadow@CLightShadows@@@@XZ ENDP ; std::vector<CLightShadows::shadow,xalloc<CLightShadows::shadow> >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Orphan_range@?$vector@Ushadow@CLightShadows@@V?$xalloc@Ushadow@CLightShadows@@@@@std@@ABEXPAUshadow@CLightShadows@@0@Z
_TEXT	SEGMENT
___formal$dead$ = 8					; size = 4
___formal$dead$ = 12					; size = 4
?_Orphan_range@?$vector@Ushadow@CLightShadows@@V?$xalloc@Ushadow@CLightShadows@@@@@std@@ABEXPAUshadow@CLightShadows@@0@Z PROC ; std::vector<CLightShadows::shadow,xalloc<CLightShadows::shadow> >::_Orphan_range, COMDAT
; _this$dead$ = ecx

; 1801 :     _CONSTEXPR20_CONTAINER void _Orphan_range(pointer, pointer) const {}

	ret	8
?_Orphan_range@?$vector@Ushadow@CLightShadows@@V?$xalloc@Ushadow@CLightShadows@@@@@std@@ABEXPAUshadow@CLightShadows@@0@Z ENDP ; std::vector<CLightShadows::shadow,xalloc<CLightShadows::shadow> >::_Orphan_range
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Tidy@?$vector@Ushadow@CLightShadows@@V?$xalloc@Ushadow@CLightShadows@@@@@std@@AAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@Ushadow@CLightShadows@@V?$xalloc@Ushadow@CLightShadows@@@@@std@@AAEXXZ PROC ; std::vector<CLightShadows::shadow,xalloc<CLightShadows::shadow> >::_Tidy, COMDAT
; _this$ = ecx

; 1742 :     _CONSTEXPR20_CONTAINER void _Tidy() noexcept { // free all storage

	push	esi
	mov	esi, ecx

; 1743 :         auto& _My_data    = _Mypair._Myval2;
; 1744 :         pointer& _Myfirst = _My_data._Myfirst;
; 1745 :         pointer& _Mylast  = _My_data._Mylast;
; 1746 :         pointer& _Myend   = _My_data._Myend;
; 1747 : 
; 1748 :         _My_data._Orphan_all();
; 1749 : 
; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN2@Tidy
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+4], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+8], 0
$LN2@Tidy:

; 1757 :         }
; 1758 :     }

	pop	esi
	ret	0
?_Tidy@?$vector@Ushadow@CLightShadows@@V?$xalloc@Ushadow@CLightShadows@@@@@std@@AAEXXZ ENDP ; std::vector<CLightShadows::shadow,xalloc<CLightShadows::shadow> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?size@?$vector@Ushadow@CLightShadows@@V?$xalloc@Ushadow@CLightShadows@@@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@Ushadow@CLightShadows@@V?$xalloc@Ushadow@CLightShadows@@@@@std@@QBEIXZ PROC ; std::vector<CLightShadows::shadow,xalloc<CLightShadows::shadow> >::size, COMDAT
; _this$ = ecx

; 1534 :     _NODISCARD _CONSTEXPR20_CONTAINER size_type size() const noexcept {

	push	esi

; 1535 :         auto& _My_data = _Mypair._Myval2;
; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	esi, DWORD PTR [ecx+4]
	mov	eax, -1307163959			; b21642c9H
	sub	esi, DWORD PTR [ecx]
	imul	esi
	add	edx, esi
	sar	edx, 6
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	pop	esi

; 1537 :     }

	ret	0
?size@?$vector@Ushadow@CLightShadows@@V?$xalloc@Ushadow@CLightShadows@@@@@std@@QBEIXZ ENDP ; std::vector<CLightShadows::shadow,xalloc<CLightShadows::shadow> >::size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?begin@?$vector@Ushadow@CLightShadows@@V?$xalloc@Ushadow@CLightShadows@@@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@Ushadow@CLightShadows@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@Ushadow@CLightShadows@@V?$xalloc@Ushadow@CLightShadows@@@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@Ushadow@CLightShadows@@@std@@@std@@@2@XZ PROC ; std::vector<CLightShadows::shadow,xalloc<CLightShadows::shadow> >::begin, COMDAT
; _this$ = ecx

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	ecx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], ecx

; 1462 :         auto& _My_data = _Mypair._Myval2;
; 1463 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));
; 1464 :     }

	ret	4
?begin@?$vector@Ushadow@CLightShadows@@V?$xalloc@Ushadow@CLightShadows@@@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@Ushadow@CLightShadows@@@std@@@std@@@2@XZ ENDP ; std::vector<CLightShadows::shadow,xalloc<CLightShadows::shadow> >::begin
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0?$vector@Ushadow@CLightShadows@@V?$xalloc@Ushadow@CLightShadows@@@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@Ushadow@CLightShadows@@V?$xalloc@Ushadow@CLightShadows@@@@@std@@QAE@XZ PROC ; std::vector<CLightShadows::shadow,xalloc<CLightShadows::shadow> >::vector<CLightShadows::shadow,xalloc<CLightShadows::shadow> >, COMDAT
; _this$ = ecx

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx], 0

; 464  :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 465  :     }

	mov	eax, ecx

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0

; 464  :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 465  :     }

	ret	0
??0?$vector@Ushadow@CLightShadows@@V?$xalloc@Ushadow@CLightShadows@@@@@std@@QAE@XZ ENDP ; std::vector<CLightShadows::shadow,xalloc<CLightShadows::shadow> >::vector<CLightShadows::shadow,xalloc<CLightShadows::shadow> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?clear_and_free@?$xr_vector@PAUcaster@CLightShadows@@V?$xalloc@PAUcaster@CLightShadows@@@@@@QAEXXZ
_TEXT	SEGMENT
?clear_and_free@?$xr_vector@PAUcaster@CLightShadows@@V?$xalloc@PAUcaster@CLightShadows@@@@@@QAEXXZ PROC ; xr_vector<CLightShadows::caster *,xalloc<CLightShadows::caster *> >::clear_and_free, COMDAT
; _this$ = ecx

; 127  : 	void	clear_and_free		()									{ inherited::clear();			}

	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [ecx+4], eax
	ret	0
?clear_and_free@?$xr_vector@PAUcaster@CLightShadows@@V?$xalloc@PAUcaster@CLightShadows@@@@@@QAEXXZ ENDP ; xr_vector<CLightShadows::caster *,xalloc<CLightShadows::caster *> >::clear_and_free
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Getal@?$vector@PAUcaster@CLightShadows@@V?$xalloc@PAUcaster@CLightShadows@@@@@std@@AAEAAV?$xalloc@PAUcaster@CLightShadows@@@@XZ
_TEXT	SEGMENT
?_Getal@?$vector@PAUcaster@CLightShadows@@V?$xalloc@PAUcaster@CLightShadows@@@@@std@@AAEAAV?$xalloc@PAUcaster@CLightShadows@@@@XZ PROC ; std::vector<CLightShadows::caster *,xalloc<CLightShadows::caster *> >::_Getal, COMDAT
; _this$ = ecx

; 1805 :         return _Mypair._Get_first();

	mov	eax, ecx

; 1806 :     }

	ret	0
?_Getal@?$vector@PAUcaster@CLightShadows@@V?$xalloc@PAUcaster@CLightShadows@@@@@std@@AAEAAV?$xalloc@PAUcaster@CLightShadows@@@@XZ ENDP ; std::vector<CLightShadows::caster *,xalloc<CLightShadows::caster *> >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Orphan_range@?$vector@PAUcaster@CLightShadows@@V?$xalloc@PAUcaster@CLightShadows@@@@@std@@ABEXPAPAUcaster@CLightShadows@@0@Z
_TEXT	SEGMENT
___formal$dead$ = 8					; size = 4
___formal$dead$ = 12					; size = 4
?_Orphan_range@?$vector@PAUcaster@CLightShadows@@V?$xalloc@PAUcaster@CLightShadows@@@@@std@@ABEXPAPAUcaster@CLightShadows@@0@Z PROC ; std::vector<CLightShadows::caster *,xalloc<CLightShadows::caster *> >::_Orphan_range, COMDAT
; _this$dead$ = ecx

; 1801 :     _CONSTEXPR20_CONTAINER void _Orphan_range(pointer, pointer) const {}

	ret	8
?_Orphan_range@?$vector@PAUcaster@CLightShadows@@V?$xalloc@PAUcaster@CLightShadows@@@@@std@@ABEXPAPAUcaster@CLightShadows@@0@Z ENDP ; std::vector<CLightShadows::caster *,xalloc<CLightShadows::caster *> >::_Orphan_range
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Tidy@?$vector@PAUcaster@CLightShadows@@V?$xalloc@PAUcaster@CLightShadows@@@@@std@@AAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@PAUcaster@CLightShadows@@V?$xalloc@PAUcaster@CLightShadows@@@@@std@@AAEXXZ PROC ; std::vector<CLightShadows::caster *,xalloc<CLightShadows::caster *> >::_Tidy, COMDAT
; _this$ = ecx

; 1742 :     _CONSTEXPR20_CONTAINER void _Tidy() noexcept { // free all storage

	push	esi
	mov	esi, ecx

; 1743 :         auto& _My_data    = _Mypair._Myval2;
; 1744 :         pointer& _Myfirst = _My_data._Myfirst;
; 1745 :         pointer& _Mylast  = _My_data._Mylast;
; 1746 :         pointer& _Myend   = _My_data._Myend;
; 1747 : 
; 1748 :         _My_data._Orphan_all();
; 1749 : 
; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN2@Tidy
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+4], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+8], 0
$LN2@Tidy:

; 1757 :         }
; 1758 :     }

	pop	esi
	ret	0
?_Tidy@?$vector@PAUcaster@CLightShadows@@V?$xalloc@PAUcaster@CLightShadows@@@@@std@@AAEXXZ ENDP ; std::vector<CLightShadows::caster *,xalloc<CLightShadows::caster *> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?size@?$vector@PAUcaster@CLightShadows@@V?$xalloc@PAUcaster@CLightShadows@@@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@PAUcaster@CLightShadows@@V?$xalloc@PAUcaster@CLightShadows@@@@@std@@QBEIXZ PROC ; std::vector<CLightShadows::caster *,xalloc<CLightShadows::caster *> >::size, COMDAT
; _this$ = ecx

; 1535 :         auto& _My_data = _Mypair._Myval2;
; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	eax, DWORD PTR [ecx+4]
	sub	eax, DWORD PTR [ecx]
	sar	eax, 2

; 1537 :     }

	ret	0
?size@?$vector@PAUcaster@CLightShadows@@V?$xalloc@PAUcaster@CLightShadows@@@@@std@@QBEIXZ ENDP ; std::vector<CLightShadows::caster *,xalloc<CLightShadows::caster *> >::size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?begin@?$vector@PAUcaster@CLightShadows@@V?$xalloc@PAUcaster@CLightShadows@@@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUcaster@CLightShadows@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@PAUcaster@CLightShadows@@V?$xalloc@PAUcaster@CLightShadows@@@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUcaster@CLightShadows@@@std@@@std@@@2@XZ PROC ; std::vector<CLightShadows::caster *,xalloc<CLightShadows::caster *> >::begin, COMDAT
; _this$ = ecx

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	ecx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], ecx

; 1462 :         auto& _My_data = _Mypair._Myval2;
; 1463 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));
; 1464 :     }

	ret	4
?begin@?$vector@PAUcaster@CLightShadows@@V?$xalloc@PAUcaster@CLightShadows@@@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUcaster@CLightShadows@@@std@@@std@@@2@XZ ENDP ; std::vector<CLightShadows::caster *,xalloc<CLightShadows::caster *> >::begin
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0?$vector@PAUcaster@CLightShadows@@V?$xalloc@PAUcaster@CLightShadows@@@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@PAUcaster@CLightShadows@@V?$xalloc@PAUcaster@CLightShadows@@@@@std@@QAE@XZ PROC ; std::vector<CLightShadows::caster *,xalloc<CLightShadows::caster *> >::vector<CLightShadows::caster *,xalloc<CLightShadows::caster *> >, COMDAT
; _this$ = ecx

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx], 0

; 464  :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 465  :     }

	mov	eax, ecx

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0

; 464  :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 465  :     }

	ret	0
??0?$vector@PAUcaster@CLightShadows@@V?$xalloc@PAUcaster@CLightShadows@@@@@std@@QAE@XZ ENDP ; std::vector<CLightShadows::caster *,xalloc<CLightShadows::caster *> >::vector<CLightShadows::caster *,xalloc<CLightShadows::caster *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?clear_and_free@?$xr_vector@U_MatrixItem@R_dsgraph@@V?$xalloc@U_MatrixItem@R_dsgraph@@@@@@QAEXXZ
_TEXT	SEGMENT
?clear_and_free@?$xr_vector@U_MatrixItem@R_dsgraph@@V?$xalloc@U_MatrixItem@R_dsgraph@@@@@@QAEXXZ PROC ; xr_vector<R_dsgraph::_MatrixItem,xalloc<R_dsgraph::_MatrixItem> >::clear_and_free, COMDAT
; _this$ = ecx

; 127  : 	void	clear_and_free		()									{ inherited::clear();			}

	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [ecx+4], eax
	ret	0
?clear_and_free@?$xr_vector@U_MatrixItem@R_dsgraph@@V?$xalloc@U_MatrixItem@R_dsgraph@@@@@@QAEXXZ ENDP ; xr_vector<R_dsgraph::_MatrixItem,xalloc<R_dsgraph::_MatrixItem> >::clear_and_free
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Getal@?$vector@U_MatrixItem@R_dsgraph@@V?$xalloc@U_MatrixItem@R_dsgraph@@@@@std@@AAEAAV?$xalloc@U_MatrixItem@R_dsgraph@@@@XZ
_TEXT	SEGMENT
?_Getal@?$vector@U_MatrixItem@R_dsgraph@@V?$xalloc@U_MatrixItem@R_dsgraph@@@@@std@@AAEAAV?$xalloc@U_MatrixItem@R_dsgraph@@@@XZ PROC ; std::vector<R_dsgraph::_MatrixItem,xalloc<R_dsgraph::_MatrixItem> >::_Getal, COMDAT
; _this$ = ecx

; 1805 :         return _Mypair._Get_first();

	mov	eax, ecx

; 1806 :     }

	ret	0
?_Getal@?$vector@U_MatrixItem@R_dsgraph@@V?$xalloc@U_MatrixItem@R_dsgraph@@@@@std@@AAEAAV?$xalloc@U_MatrixItem@R_dsgraph@@@@XZ ENDP ; std::vector<R_dsgraph::_MatrixItem,xalloc<R_dsgraph::_MatrixItem> >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Orphan_range@?$vector@U_MatrixItem@R_dsgraph@@V?$xalloc@U_MatrixItem@R_dsgraph@@@@@std@@ABEXPAU_MatrixItem@R_dsgraph@@0@Z
_TEXT	SEGMENT
___formal$dead$ = 8					; size = 4
___formal$dead$ = 12					; size = 4
?_Orphan_range@?$vector@U_MatrixItem@R_dsgraph@@V?$xalloc@U_MatrixItem@R_dsgraph@@@@@std@@ABEXPAU_MatrixItem@R_dsgraph@@0@Z PROC ; std::vector<R_dsgraph::_MatrixItem,xalloc<R_dsgraph::_MatrixItem> >::_Orphan_range, COMDAT
; _this$dead$ = ecx

; 1801 :     _CONSTEXPR20_CONTAINER void _Orphan_range(pointer, pointer) const {}

	ret	8
?_Orphan_range@?$vector@U_MatrixItem@R_dsgraph@@V?$xalloc@U_MatrixItem@R_dsgraph@@@@@std@@ABEXPAU_MatrixItem@R_dsgraph@@0@Z ENDP ; std::vector<R_dsgraph::_MatrixItem,xalloc<R_dsgraph::_MatrixItem> >::_Orphan_range
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?size@?$vector@U_MatrixItem@R_dsgraph@@V?$xalloc@U_MatrixItem@R_dsgraph@@@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@U_MatrixItem@R_dsgraph@@V?$xalloc@U_MatrixItem@R_dsgraph@@@@@std@@QBEIXZ PROC ; std::vector<R_dsgraph::_MatrixItem,xalloc<R_dsgraph::_MatrixItem> >::size, COMDAT
; _this$ = ecx

; 1535 :         auto& _My_data = _Mypair._Myval2;
; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	eax, DWORD PTR [ecx+4]
	sub	eax, DWORD PTR [ecx]
	sar	eax, 2
	imul	eax, eax, 678152731

; 1537 :     }

	ret	0
?size@?$vector@U_MatrixItem@R_dsgraph@@V?$xalloc@U_MatrixItem@R_dsgraph@@@@@std@@QBEIXZ ENDP ; std::vector<R_dsgraph::_MatrixItem,xalloc<R_dsgraph::_MatrixItem> >::size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?begin@?$vector@U_MatrixItem@R_dsgraph@@V?$xalloc@U_MatrixItem@R_dsgraph@@@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U_MatrixItem@R_dsgraph@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@U_MatrixItem@R_dsgraph@@V?$xalloc@U_MatrixItem@R_dsgraph@@@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U_MatrixItem@R_dsgraph@@@std@@@std@@@2@XZ PROC ; std::vector<R_dsgraph::_MatrixItem,xalloc<R_dsgraph::_MatrixItem> >::begin, COMDAT
; _this$ = ecx

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	ecx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], ecx

; 1462 :         auto& _My_data = _Mypair._Myval2;
; 1463 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));
; 1464 :     }

	ret	4
?begin@?$vector@U_MatrixItem@R_dsgraph@@V?$xalloc@U_MatrixItem@R_dsgraph@@@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U_MatrixItem@R_dsgraph@@@std@@@std@@@2@XZ ENDP ; std::vector<R_dsgraph::_MatrixItem,xalloc<R_dsgraph::_MatrixItem> >::begin
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@Ushadow@CLightShadows@@@std@@@std@@@std@@QAE@PAUshadow@CLightShadows@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
___param0$ = 8						; size = 4
___param1$dead$ = 12					; size = 4
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@Ushadow@CLightShadows@@@std@@@std@@@std@@QAE@PAUshadow@CLightShadows@@PBU_Container_base0@1@@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CLightShadows::shadow> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<CLightShadows::shadow> > >, COMDAT
; _this$ = ecx

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	eax, DWORD PTR ___param0$[esp-4]
	mov	DWORD PTR [ecx], eax
	mov	eax, ecx
	ret	8
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@Ushadow@CLightShadows@@@std@@@std@@@std@@QAE@PAUshadow@CLightShadows@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CLightShadows::shadow> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<CLightShadows::shadow> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUcaster@CLightShadows@@@std@@@std@@@std@@QAE@PAPAUcaster@CLightShadows@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
___param0$ = 8						; size = 4
___param1$dead$ = 12					; size = 4
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUcaster@CLightShadows@@@std@@@std@@@std@@QAE@PAPAUcaster@CLightShadows@@PBU_Container_base0@1@@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CLightShadows::caster *> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<CLightShadows::caster *> > >, COMDAT
; _this$ = ecx

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	eax, DWORD PTR ___param0$[esp-4]
	mov	DWORD PTR [ecx], eax
	mov	eax, ecx
	ret	8
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUcaster@CLightShadows@@@std@@@std@@@std@@QAE@PAPAUcaster@CLightShadows@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CLightShadows::caster *> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<CLightShadows::caster *> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U_MatrixItem@R_dsgraph@@@std@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U_MatrixItem@R_dsgraph@@@std@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<R_dsgraph::_MatrixItem> > >::operator+=, COMDAT
; _this$ = ecx

; 119  :         _Ptr += _Off;

	imul	eax, DWORD PTR __Off$[esp-4], 76
	add	DWORD PTR [ecx], eax

; 298  :         _Mybase::operator+=(_Off);
; 299  :         return *this;

	mov	eax, ecx

; 300  :     }

	ret	4
??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U_MatrixItem@R_dsgraph@@@std@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<R_dsgraph::_MatrixItem> > >::operator+=
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUcaster@CLightShadows@@@std@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUcaster@CLightShadows@@@std@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CLightShadows::caster *> > >::operator+=, COMDAT
; _this$ = ecx

; 119  :         _Ptr += _Off;

	mov	eax, DWORD PTR __Off$[esp-4]
	shl	eax, 2
	add	DWORD PTR [ecx], eax

; 298  :         _Mybase::operator+=(_Off);
; 299  :         return *this;

	mov	eax, ecx

; 300  :     }

	ret	4
??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUcaster@CLightShadows@@@std@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CLightShadows::caster *> > >::operator+=
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUcaster@CLightShadows@@@std@@@std@@@std@@QBEABQAUcaster@CLightShadows@@XZ
_TEXT	SEGMENT
??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUcaster@CLightShadows@@@std@@@std@@@std@@QBEABQAUcaster@CLightShadows@@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CLightShadows::caster *> > >::operator*, COMDAT
; _this$ = ecx

; 46   : #if _ITERATOR_DEBUG_LEVEL != 0
; 47   :         const auto _Mycont = static_cast<const _Myvec*>(this->_Getcont());
; 48   :         _STL_VERIFY(_Ptr, "can't dereference value-initialized vector iterator");
; 49   :         _STL_VERIFY(
; 50   :             _Mycont->_Myfirst <= _Ptr && _Ptr < _Mycont->_Mylast, "can't dereference out of range vector iterator");
; 51   : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 52   : 
; 53   :         return *_Ptr;

	mov	eax, DWORD PTR [ecx]

; 54   :     }

	ret	0
??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUcaster@CLightShadows@@@std@@@std@@@std@@QBEABQAUcaster@CLightShadows@@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CLightShadows::caster *> > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUcaster@CLightShadows@@@std@@@std@@@std@@QAE@PAPAUcaster@CLightShadows@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Pvector$dead$ = 12					; size = 4
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUcaster@CLightShadows@@@std@@@std@@@std@@QAE@PAPAUcaster@CLightShadows@@PBU_Container_base0@1@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CLightShadows::caster *> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CLightShadows::caster *> > >, COMDAT
; _this$ = ecx

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	eax, DWORD PTR __Parg$[esp-4]
	mov	DWORD PTR [ecx], eax

; 42   :         this->_Adopt(_Pvector);
; 43   :     }

	mov	eax, ecx
	ret	8
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUcaster@CLightShadows@@@std@@@std@@@std@@QAE@PAPAUcaster@CLightShadows@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CLightShadows::caster *> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CLightShadows::caster *> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@Ushadow@CLightShadows@@@std@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@Ushadow@CLightShadows@@@std@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CLightShadows::shadow> > >::operator+=, COMDAT
; _this$ = ecx

; 119  :         _Ptr += _Off;

	imul	eax, DWORD PTR __Off$[esp-4], 92
	add	DWORD PTR [ecx], eax

; 298  :         _Mybase::operator+=(_Off);
; 299  :         return *this;

	mov	eax, ecx

; 300  :     }

	ret	4
??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@Ushadow@CLightShadows@@@std@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CLightShadows::shadow> > >::operator+=
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@Ushadow@CLightShadows@@@std@@@std@@@std@@QBEABUshadow@CLightShadows@@XZ
_TEXT	SEGMENT
??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@Ushadow@CLightShadows@@@std@@@std@@@std@@QBEABUshadow@CLightShadows@@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CLightShadows::shadow> > >::operator*, COMDAT
; _this$ = ecx

; 46   : #if _ITERATOR_DEBUG_LEVEL != 0
; 47   :         const auto _Mycont = static_cast<const _Myvec*>(this->_Getcont());
; 48   :         _STL_VERIFY(_Ptr, "can't dereference value-initialized vector iterator");
; 49   :         _STL_VERIFY(
; 50   :             _Mycont->_Myfirst <= _Ptr && _Ptr < _Mycont->_Mylast, "can't dereference out of range vector iterator");
; 51   : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 52   : 
; 53   :         return *_Ptr;

	mov	eax, DWORD PTR [ecx]

; 54   :     }

	ret	0
??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@Ushadow@CLightShadows@@@std@@@std@@@std@@QBEABUshadow@CLightShadows@@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CLightShadows::shadow> > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@Ushadow@CLightShadows@@@std@@@std@@@std@@QAE@PAUshadow@CLightShadows@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Pvector$dead$ = 12					; size = 4
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@Ushadow@CLightShadows@@@std@@@std@@@std@@QAE@PAUshadow@CLightShadows@@PBU_Container_base0@1@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CLightShadows::shadow> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CLightShadows::shadow> > >, COMDAT
; _this$ = ecx

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	eax, DWORD PTR __Parg$[esp-4]
	mov	DWORD PTR [ecx], eax

; 42   :         this->_Adopt(_Pvector);
; 43   :     }

	mov	eax, ecx
	ret	8
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@Ushadow@CLightShadows@@@std@@@std@@@std@@QAE@PAUshadow@CLightShadows@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CLightShadows::shadow> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CLightShadows::shadow> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@Ucache_item@CLightShadows@@@std@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@Ucache_item@CLightShadows@@@std@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CLightShadows::cache_item> > >::operator+=, COMDAT
; _this$ = ecx

; 118  :         _Verify_offset(_Off);
; 119  :         _Ptr += _Off;

	imul	eax, DWORD PTR __Off$[esp-4], 44
	add	DWORD PTR [ecx], eax

; 120  :         return *this;

	mov	eax, ecx

; 121  :     }

	ret	4
??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@Ucache_item@CLightShadows@@@std@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CLightShadows::cache_item> > >::operator+=
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$xalloc@Ucache_item@CLightShadows@@@@V?$_Vector_val@U?$_Simple_types@Ucache_item@CLightShadows@@@std@@@std@@$00@std@@QAEAAV?$xalloc@Ucache_item@CLightShadows@@@@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@V?$xalloc@Ucache_item@CLightShadows@@@@V?$_Vector_val@U?$_Simple_types@Ucache_item@CLightShadows@@@std@@@std@@$00@std@@QAEAAV?$xalloc@Ucache_item@CLightShadows@@@@XZ PROC ; std::_Compressed_pair<xalloc<CLightShadows::cache_item>,std::_Vector_val<std::_Simple_types<CLightShadows::cache_item> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 1339 :         return *this;

	mov	eax, ecx

; 1340 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$xalloc@Ucache_item@CLightShadows@@@@V?$_Vector_val@U?$_Simple_types@Ucache_item@CLightShadows@@@std@@@std@@$00@std@@QAEAAV?$xalloc@Ucache_item@CLightShadows@@@@XZ ENDP ; std::_Compressed_pair<xalloc<CLightShadows::cache_item>,std::_Vector_val<std::_Simple_types<CLightShadows::cache_item> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Destroy@?$vector@Ucache_item@CLightShadows@@V?$xalloc@Ucache_item@CLightShadows@@@@@std@@AAEXPAUcache_item@CLightShadows@@0@Z
_TEXT	SEGMENT
__First$dead$ = 8					; size = 4
__Last$dead$ = 12					; size = 4
?_Destroy@?$vector@Ucache_item@CLightShadows@@V?$xalloc@Ucache_item@CLightShadows@@@@@std@@AAEXPAUcache_item@CLightShadows@@0@Z PROC ; std::vector<CLightShadows::cache_item,xalloc<CLightShadows::cache_item> >::_Destroy, COMDAT
; _this$dead$ = ecx

; 1666 :         // destroy [_First, _Last) using allocator
; 1667 :         _Destroy_range(_First, _Last, _Getal());
; 1668 :     }

	ret	8
?_Destroy@?$vector@Ucache_item@CLightShadows@@V?$xalloc@Ucache_item@CLightShadows@@@@@std@@AAEXPAUcache_item@CLightShadows@@0@Z ENDP ; std::vector<CLightShadows::cache_item,xalloc<CLightShadows::cache_item> >::_Destroy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?clear@?$vector@Ucache_item@CLightShadows@@V?$xalloc@Ucache_item@CLightShadows@@@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$vector@Ucache_item@CLightShadows@@V?$xalloc@Ucache_item@CLightShadows@@@@@std@@QAEXXZ PROC ; std::vector<CLightShadows::cache_item,xalloc<CLightShadows::cache_item> >::clear, COMDAT
; _this$ = ecx

; 1437 :         auto& _My_data    = _Mypair._Myval2;
; 1438 :         pointer& _Myfirst = _My_data._Myfirst;
; 1439 :         pointer& _Mylast  = _My_data._Mylast;
; 1440 : 
; 1441 :         _My_data._Orphan_all();
; 1442 :         _Destroy(_Myfirst, _Mylast);
; 1443 :         _Mylast = _Myfirst;

	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [ecx+4], eax

; 1444 :     }

	ret	0
?clear@?$vector@Ucache_item@CLightShadows@@V?$xalloc@Ucache_item@CLightShadows@@@@@std@@QAEXXZ ENDP ; std::vector<CLightShadows::cache_item,xalloc<CLightShadows::cache_item> >::clear
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?deallocate@?$xalloc@Ucache_item@CLightShadows@@@@QBEXPAUcache_item@CLightShadows@@I@Z
_TEXT	SEGMENT
_p$ = 8							; size = 4
_n$dead$ = 12						; size = 4
?deallocate@?$xalloc@Ucache_item@CLightShadows@@@@QBEXPAUcache_item@CLightShadows@@I@Z PROC ; xalloc<CLightShadows::cache_item>::deallocate, COMDAT
; _this$dead$ = ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	eax, DWORD PTR _p$[esp-4]
	test	eax, eax
	je	SHORT $LN4@deallocate
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN4@deallocate:
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 82   : 							void					deallocate		(pointer p, size_type n) const			{	xr_free	(p);				}

	ret	8
?deallocate@?$xalloc@Ucache_item@CLightShadows@@@@QBEXPAUcache_item@CLightShadows@@I@Z ENDP ; xalloc<CLightShadows::cache_item>::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$xalloc@Utess_tri@CLightShadows@@@@V?$_Vector_val@U?$_Simple_types@Utess_tri@CLightShadows@@@std@@@std@@$00@std@@QAEAAV?$xalloc@Utess_tri@CLightShadows@@@@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@V?$xalloc@Utess_tri@CLightShadows@@@@V?$_Vector_val@U?$_Simple_types@Utess_tri@CLightShadows@@@std@@@std@@$00@std@@QAEAAV?$xalloc@Utess_tri@CLightShadows@@@@XZ PROC ; std::_Compressed_pair<xalloc<CLightShadows::tess_tri>,std::_Vector_val<std::_Simple_types<CLightShadows::tess_tri> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 1339 :         return *this;

	mov	eax, ecx

; 1340 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$xalloc@Utess_tri@CLightShadows@@@@V?$_Vector_val@U?$_Simple_types@Utess_tri@CLightShadows@@@std@@@std@@$00@std@@QAEAAV?$xalloc@Utess_tri@CLightShadows@@@@XZ ENDP ; std::_Compressed_pair<xalloc<CLightShadows::tess_tri>,std::_Vector_val<std::_Simple_types<CLightShadows::tess_tri> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Destroy@?$vector@Utess_tri@CLightShadows@@V?$xalloc@Utess_tri@CLightShadows@@@@@std@@AAEXPAUtess_tri@CLightShadows@@0@Z
_TEXT	SEGMENT
__First$dead$ = 8					; size = 4
__Last$dead$ = 12					; size = 4
?_Destroy@?$vector@Utess_tri@CLightShadows@@V?$xalloc@Utess_tri@CLightShadows@@@@@std@@AAEXPAUtess_tri@CLightShadows@@0@Z PROC ; std::vector<CLightShadows::tess_tri,xalloc<CLightShadows::tess_tri> >::_Destroy, COMDAT
; _this$dead$ = ecx

; 1666 :         // destroy [_First, _Last) using allocator
; 1667 :         _Destroy_range(_First, _Last, _Getal());
; 1668 :     }

	ret	8
?_Destroy@?$vector@Utess_tri@CLightShadows@@V?$xalloc@Utess_tri@CLightShadows@@@@@std@@AAEXPAUtess_tri@CLightShadows@@0@Z ENDP ; std::vector<CLightShadows::tess_tri,xalloc<CLightShadows::tess_tri> >::_Destroy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?clear@?$vector@Utess_tri@CLightShadows@@V?$xalloc@Utess_tri@CLightShadows@@@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$vector@Utess_tri@CLightShadows@@V?$xalloc@Utess_tri@CLightShadows@@@@@std@@QAEXXZ PROC ; std::vector<CLightShadows::tess_tri,xalloc<CLightShadows::tess_tri> >::clear, COMDAT
; _this$ = ecx

; 1437 :         auto& _My_data    = _Mypair._Myval2;
; 1438 :         pointer& _Myfirst = _My_data._Myfirst;
; 1439 :         pointer& _Mylast  = _My_data._Mylast;
; 1440 : 
; 1441 :         _My_data._Orphan_all();
; 1442 :         _Destroy(_Myfirst, _Mylast);
; 1443 :         _Mylast = _Myfirst;

	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [ecx+4], eax

; 1444 :     }

	ret	0
?clear@?$vector@Utess_tri@CLightShadows@@V?$xalloc@Utess_tri@CLightShadows@@@@@std@@QAEXXZ ENDP ; std::vector<CLightShadows::tess_tri,xalloc<CLightShadows::tess_tri> >::clear
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?deallocate@?$xalloc@Utess_tri@CLightShadows@@@@QBEXPAUtess_tri@CLightShadows@@I@Z
_TEXT	SEGMENT
_p$ = 8							; size = 4
_n$dead$ = 12						; size = 4
?deallocate@?$xalloc@Utess_tri@CLightShadows@@@@QBEXPAUtess_tri@CLightShadows@@I@Z PROC ; xalloc<CLightShadows::tess_tri>::deallocate, COMDAT
; _this$dead$ = ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	eax, DWORD PTR _p$[esp-4]
	test	eax, eax
	je	SHORT $LN4@deallocate
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN4@deallocate:
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 82   : 							void					deallocate		(pointer p, size_type n) const			{	xr_free	(p);				}

	ret	8
?deallocate@?$xalloc@Utess_tri@CLightShadows@@@@QBEXPAUtess_tri@CLightShadows@@I@Z ENDP ; xalloc<CLightShadows::tess_tri>::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$xalloc@Ushadow@CLightShadows@@@@V?$_Vector_val@U?$_Simple_types@Ushadow@CLightShadows@@@std@@@std@@$00@std@@QAEAAV?$xalloc@Ushadow@CLightShadows@@@@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@V?$xalloc@Ushadow@CLightShadows@@@@V?$_Vector_val@U?$_Simple_types@Ushadow@CLightShadows@@@std@@@std@@$00@std@@QAEAAV?$xalloc@Ushadow@CLightShadows@@@@XZ PROC ; std::_Compressed_pair<xalloc<CLightShadows::shadow>,std::_Vector_val<std::_Simple_types<CLightShadows::shadow> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 1339 :         return *this;

	mov	eax, ecx

; 1340 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$xalloc@Ushadow@CLightShadows@@@@V?$_Vector_val@U?$_Simple_types@Ushadow@CLightShadows@@@std@@@std@@$00@std@@QAEAAV?$xalloc@Ushadow@CLightShadows@@@@XZ ENDP ; std::_Compressed_pair<xalloc<CLightShadows::shadow>,std::_Vector_val<std::_Simple_types<CLightShadows::shadow> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Destroy@?$vector@Ushadow@CLightShadows@@V?$xalloc@Ushadow@CLightShadows@@@@@std@@AAEXPAUshadow@CLightShadows@@0@Z
_TEXT	SEGMENT
__First$dead$ = 8					; size = 4
__Last$dead$ = 12					; size = 4
?_Destroy@?$vector@Ushadow@CLightShadows@@V?$xalloc@Ushadow@CLightShadows@@@@@std@@AAEXPAUshadow@CLightShadows@@0@Z PROC ; std::vector<CLightShadows::shadow,xalloc<CLightShadows::shadow> >::_Destroy, COMDAT
; _this$dead$ = ecx

; 1666 :         // destroy [_First, _Last) using allocator
; 1667 :         _Destroy_range(_First, _Last, _Getal());
; 1668 :     }

	ret	8
?_Destroy@?$vector@Ushadow@CLightShadows@@V?$xalloc@Ushadow@CLightShadows@@@@@std@@AAEXPAUshadow@CLightShadows@@0@Z ENDP ; std::vector<CLightShadows::shadow,xalloc<CLightShadows::shadow> >::_Destroy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?clear@?$vector@Ushadow@CLightShadows@@V?$xalloc@Ushadow@CLightShadows@@@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$vector@Ushadow@CLightShadows@@V?$xalloc@Ushadow@CLightShadows@@@@@std@@QAEXXZ PROC ; std::vector<CLightShadows::shadow,xalloc<CLightShadows::shadow> >::clear, COMDAT
; _this$ = ecx

; 1437 :         auto& _My_data    = _Mypair._Myval2;
; 1438 :         pointer& _Myfirst = _My_data._Myfirst;
; 1439 :         pointer& _Mylast  = _My_data._Mylast;
; 1440 : 
; 1441 :         _My_data._Orphan_all();
; 1442 :         _Destroy(_Myfirst, _Mylast);
; 1443 :         _Mylast = _Myfirst;

	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [ecx+4], eax

; 1444 :     }

	ret	0
?clear@?$vector@Ushadow@CLightShadows@@V?$xalloc@Ushadow@CLightShadows@@@@@std@@QAEXXZ ENDP ; std::vector<CLightShadows::shadow,xalloc<CLightShadows::shadow> >::clear
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?deallocate@?$xalloc@Ushadow@CLightShadows@@@@QBEXPAUshadow@CLightShadows@@I@Z
_TEXT	SEGMENT
_p$ = 8							; size = 4
_n$dead$ = 12						; size = 4
?deallocate@?$xalloc@Ushadow@CLightShadows@@@@QBEXPAUshadow@CLightShadows@@I@Z PROC ; xalloc<CLightShadows::shadow>::deallocate, COMDAT
; _this$dead$ = ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	eax, DWORD PTR _p$[esp-4]
	test	eax, eax
	je	SHORT $LN4@deallocate
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN4@deallocate:
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 82   : 							void					deallocate		(pointer p, size_type n) const			{	xr_free	(p);				}

	ret	8
?deallocate@?$xalloc@Ushadow@CLightShadows@@@@QBEXPAUshadow@CLightShadows@@I@Z ENDP ; xalloc<CLightShadows::shadow>::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$xalloc@PAUcaster@CLightShadows@@@@V?$_Vector_val@U?$_Simple_types@PAUcaster@CLightShadows@@@std@@@std@@$00@std@@QAEAAV?$xalloc@PAUcaster@CLightShadows@@@@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@V?$xalloc@PAUcaster@CLightShadows@@@@V?$_Vector_val@U?$_Simple_types@PAUcaster@CLightShadows@@@std@@@std@@$00@std@@QAEAAV?$xalloc@PAUcaster@CLightShadows@@@@XZ PROC ; std::_Compressed_pair<xalloc<CLightShadows::caster *>,std::_Vector_val<std::_Simple_types<CLightShadows::caster *> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 1339 :         return *this;

	mov	eax, ecx

; 1340 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$xalloc@PAUcaster@CLightShadows@@@@V?$_Vector_val@U?$_Simple_types@PAUcaster@CLightShadows@@@std@@@std@@$00@std@@QAEAAV?$xalloc@PAUcaster@CLightShadows@@@@XZ ENDP ; std::_Compressed_pair<xalloc<CLightShadows::caster *>,std::_Vector_val<std::_Simple_types<CLightShadows::caster *> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Destroy@?$vector@PAUcaster@CLightShadows@@V?$xalloc@PAUcaster@CLightShadows@@@@@std@@AAEXPAPAUcaster@CLightShadows@@0@Z
_TEXT	SEGMENT
__First$dead$ = 8					; size = 4
__Last$dead$ = 12					; size = 4
?_Destroy@?$vector@PAUcaster@CLightShadows@@V?$xalloc@PAUcaster@CLightShadows@@@@@std@@AAEXPAPAUcaster@CLightShadows@@0@Z PROC ; std::vector<CLightShadows::caster *,xalloc<CLightShadows::caster *> >::_Destroy, COMDAT
; _this$dead$ = ecx

; 1666 :         // destroy [_First, _Last) using allocator
; 1667 :         _Destroy_range(_First, _Last, _Getal());
; 1668 :     }

	ret	8
?_Destroy@?$vector@PAUcaster@CLightShadows@@V?$xalloc@PAUcaster@CLightShadows@@@@@std@@AAEXPAPAUcaster@CLightShadows@@0@Z ENDP ; std::vector<CLightShadows::caster *,xalloc<CLightShadows::caster *> >::_Destroy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?clear@?$vector@PAUcaster@CLightShadows@@V?$xalloc@PAUcaster@CLightShadows@@@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$vector@PAUcaster@CLightShadows@@V?$xalloc@PAUcaster@CLightShadows@@@@@std@@QAEXXZ PROC ; std::vector<CLightShadows::caster *,xalloc<CLightShadows::caster *> >::clear, COMDAT
; _this$ = ecx

; 1437 :         auto& _My_data    = _Mypair._Myval2;
; 1438 :         pointer& _Myfirst = _My_data._Myfirst;
; 1439 :         pointer& _Mylast  = _My_data._Mylast;
; 1440 : 
; 1441 :         _My_data._Orphan_all();
; 1442 :         _Destroy(_Myfirst, _Mylast);
; 1443 :         _Mylast = _Myfirst;

	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [ecx+4], eax

; 1444 :     }

	ret	0
?clear@?$vector@PAUcaster@CLightShadows@@V?$xalloc@PAUcaster@CLightShadows@@@@@std@@QAEXXZ ENDP ; std::vector<CLightShadows::caster *,xalloc<CLightShadows::caster *> >::clear
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?deallocate@?$xalloc@PAUcaster@CLightShadows@@@@QBEXPAPAUcaster@CLightShadows@@I@Z
_TEXT	SEGMENT
_p$ = 8							; size = 4
_n$dead$ = 12						; size = 4
?deallocate@?$xalloc@PAUcaster@CLightShadows@@@@QBEXPAPAUcaster@CLightShadows@@I@Z PROC ; xalloc<CLightShadows::caster *>::deallocate, COMDAT
; _this$dead$ = ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	eax, DWORD PTR _p$[esp-4]
	test	eax, eax
	je	SHORT $LN4@deallocate
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN4@deallocate:
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 82   : 							void					deallocate		(pointer p, size_type n) const			{	xr_free	(p);				}

	ret	8
?deallocate@?$xalloc@PAUcaster@CLightShadows@@@@QBEXPAPAUcaster@CLightShadows@@I@Z ENDP ; xalloc<CLightShadows::caster *>::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$xalloc@U_MatrixItem@R_dsgraph@@@@V?$_Vector_val@U?$_Simple_types@U_MatrixItem@R_dsgraph@@@std@@@std@@$00@std@@QAEAAV?$xalloc@U_MatrixItem@R_dsgraph@@@@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@V?$xalloc@U_MatrixItem@R_dsgraph@@@@V?$_Vector_val@U?$_Simple_types@U_MatrixItem@R_dsgraph@@@std@@@std@@$00@std@@QAEAAV?$xalloc@U_MatrixItem@R_dsgraph@@@@XZ PROC ; std::_Compressed_pair<xalloc<R_dsgraph::_MatrixItem>,std::_Vector_val<std::_Simple_types<R_dsgraph::_MatrixItem> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 1339 :         return *this;

	mov	eax, ecx

; 1340 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$xalloc@U_MatrixItem@R_dsgraph@@@@V?$_Vector_val@U?$_Simple_types@U_MatrixItem@R_dsgraph@@@std@@@std@@$00@std@@QAEAAV?$xalloc@U_MatrixItem@R_dsgraph@@@@XZ ENDP ; std::_Compressed_pair<xalloc<R_dsgraph::_MatrixItem>,std::_Vector_val<std::_Simple_types<R_dsgraph::_MatrixItem> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?clear@?$vector@U_MatrixItem@R_dsgraph@@V?$xalloc@U_MatrixItem@R_dsgraph@@@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$vector@U_MatrixItem@R_dsgraph@@V?$xalloc@U_MatrixItem@R_dsgraph@@@@@std@@QAEXXZ PROC ; std::vector<R_dsgraph::_MatrixItem,xalloc<R_dsgraph::_MatrixItem> >::clear, COMDAT
; _this$ = ecx

; 1437 :         auto& _My_data    = _Mypair._Myval2;
; 1438 :         pointer& _Myfirst = _My_data._Myfirst;
; 1439 :         pointer& _Mylast  = _My_data._Mylast;
; 1440 : 
; 1441 :         _My_data._Orphan_all();
; 1442 :         _Destroy(_Myfirst, _Mylast);
; 1443 :         _Mylast = _Myfirst;

	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [ecx+4], eax

; 1444 :     }

	ret	0
?clear@?$vector@U_MatrixItem@R_dsgraph@@V?$xalloc@U_MatrixItem@R_dsgraph@@@@@std@@QAEXXZ ENDP ; std::vector<R_dsgraph::_MatrixItem,xalloc<R_dsgraph::_MatrixItem> >::clear
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U_MatrixItem@R_dsgraph@@@std@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U_MatrixItem@R_dsgraph@@@std@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<R_dsgraph::_MatrixItem> > >::operator+=, COMDAT
; _this$ = ecx

; 118  :         _Verify_offset(_Off);
; 119  :         _Ptr += _Off;

	imul	eax, DWORD PTR __Off$[esp-4], 76
	add	DWORD PTR [ecx], eax

; 120  :         return *this;

	mov	eax, ecx

; 121  :     }

	ret	4
??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U_MatrixItem@R_dsgraph@@@std@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<R_dsgraph::_MatrixItem> > >::operator+=
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUcaster@CLightShadows@@@std@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUcaster@CLightShadows@@@std@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CLightShadows::caster *> > >::operator+=, COMDAT
; _this$ = ecx

; 118  :         _Verify_offset(_Off);
; 119  :         _Ptr += _Off;

	mov	eax, DWORD PTR __Off$[esp-4]
	shl	eax, 2
	add	DWORD PTR [ecx], eax

; 120  :         return *this;

	mov	eax, ecx

; 121  :     }

	ret	4
??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUcaster@CLightShadows@@@std@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CLightShadows::caster *> > >::operator+=
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@Ushadow@CLightShadows@@@std@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@Ushadow@CLightShadows@@@std@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CLightShadows::shadow> > >::operator+=, COMDAT
; _this$ = ecx

; 118  :         _Verify_offset(_Off);
; 119  :         _Ptr += _Off;

	imul	eax, DWORD PTR __Off$[esp-4], 92
	add	DWORD PTR [ecx], eax

; 120  :         return *this;

	mov	eax, ecx

; 121  :     }

	ret	4
??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@Ushadow@CLightShadows@@@std@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CLightShadows::shadow> > >::operator+=
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Verify_offset@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@Ucache_item@CLightShadows@@@std@@@std@@@std@@QBEXH@Z
_TEXT	SEGMENT
__Off$dead$ = 8						; size = 4
?_Verify_offset@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@Ucache_item@CLightShadows@@@std@@@std@@@std@@QBEXH@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CLightShadows::cache_item> > >::_Verify_offset, COMDAT
; _this$dead$ = ecx

; 102  : #if _ITERATOR_DEBUG_LEVEL == 0
; 103  :         (void) _Off;
; 104  : #else // ^^^ _ITERATOR_DEBUG_LEVEL == 0 ^^^ // vvv _ITERATOR_DEBUG_LEVEL != 0 vvv
; 105  :         const auto _Mycont = static_cast<const _Myvec*>(this->_Getcont());
; 106  :         _STL_VERIFY(_Off == 0 || _Ptr, "cannot seek value-initialized vector iterator");
; 107  :         if (_Off < 0) {
; 108  :             _STL_VERIFY(_Off >= _Mycont->_Myfirst - _Ptr, "cannot seek vector iterator before begin");
; 109  :         }
; 110  : 
; 111  :         if (_Off > 0) {
; 112  :             _STL_VERIFY(_Off <= _Mycont->_Mylast - _Ptr, "cannot seek vector iterator after end");
; 113  :         }
; 114  : #endif // _ITERATOR_DEBUG_LEVEL == 0
; 115  :     }

	ret	4
?_Verify_offset@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@Ucache_item@CLightShadows@@@std@@@std@@@std@@QBEXH@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CLightShadows::cache_item> > >::_Verify_offset
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Destroy@?$vector@U_MatrixItem@R_dsgraph@@V?$xalloc@U_MatrixItem@R_dsgraph@@@@@std@@AAEXPAU_MatrixItem@R_dsgraph@@0@Z
_TEXT	SEGMENT
__First$dead$ = 8					; size = 4
__Last$dead$ = 12					; size = 4
?_Destroy@?$vector@U_MatrixItem@R_dsgraph@@V?$xalloc@U_MatrixItem@R_dsgraph@@@@@std@@AAEXPAU_MatrixItem@R_dsgraph@@0@Z PROC ; std::vector<R_dsgraph::_MatrixItem,xalloc<R_dsgraph::_MatrixItem> >::_Destroy, COMDAT
; _this$dead$ = ecx

; 1666 :         // destroy [_First, _Last) using allocator
; 1667 :         _Destroy_range(_First, _Last, _Getal());
; 1668 :     }

	ret	8
?_Destroy@?$vector@U_MatrixItem@R_dsgraph@@V?$xalloc@U_MatrixItem@R_dsgraph@@@@@std@@AAEXPAU_MatrixItem@R_dsgraph@@0@Z ENDP ; std::vector<R_dsgraph::_MatrixItem,xalloc<R_dsgraph::_MatrixItem> >::_Destroy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Verify_offset@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U_MatrixItem@R_dsgraph@@@std@@@std@@@std@@QBEXH@Z
_TEXT	SEGMENT
__Off$dead$ = 8						; size = 4
?_Verify_offset@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U_MatrixItem@R_dsgraph@@@std@@@std@@@std@@QBEXH@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<R_dsgraph::_MatrixItem> > >::_Verify_offset, COMDAT
; _this$dead$ = ecx

; 102  : #if _ITERATOR_DEBUG_LEVEL == 0
; 103  :         (void) _Off;
; 104  : #else // ^^^ _ITERATOR_DEBUG_LEVEL == 0 ^^^ // vvv _ITERATOR_DEBUG_LEVEL != 0 vvv
; 105  :         const auto _Mycont = static_cast<const _Myvec*>(this->_Getcont());
; 106  :         _STL_VERIFY(_Off == 0 || _Ptr, "cannot seek value-initialized vector iterator");
; 107  :         if (_Off < 0) {
; 108  :             _STL_VERIFY(_Off >= _Mycont->_Myfirst - _Ptr, "cannot seek vector iterator before begin");
; 109  :         }
; 110  : 
; 111  :         if (_Off > 0) {
; 112  :             _STL_VERIFY(_Off <= _Mycont->_Mylast - _Ptr, "cannot seek vector iterator after end");
; 113  :         }
; 114  : #endif // _ITERATOR_DEBUG_LEVEL == 0
; 115  :     }

	ret	4
?_Verify_offset@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U_MatrixItem@R_dsgraph@@@std@@@std@@@std@@QBEXH@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<R_dsgraph::_MatrixItem> > >::_Verify_offset
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Verify_offset@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUcaster@CLightShadows@@@std@@@std@@@std@@QBEXH@Z
_TEXT	SEGMENT
__Off$dead$ = 8						; size = 4
?_Verify_offset@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUcaster@CLightShadows@@@std@@@std@@@std@@QBEXH@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CLightShadows::caster *> > >::_Verify_offset, COMDAT
; _this$dead$ = ecx

; 102  : #if _ITERATOR_DEBUG_LEVEL == 0
; 103  :         (void) _Off;
; 104  : #else // ^^^ _ITERATOR_DEBUG_LEVEL == 0 ^^^ // vvv _ITERATOR_DEBUG_LEVEL != 0 vvv
; 105  :         const auto _Mycont = static_cast<const _Myvec*>(this->_Getcont());
; 106  :         _STL_VERIFY(_Off == 0 || _Ptr, "cannot seek value-initialized vector iterator");
; 107  :         if (_Off < 0) {
; 108  :             _STL_VERIFY(_Off >= _Mycont->_Myfirst - _Ptr, "cannot seek vector iterator before begin");
; 109  :         }
; 110  : 
; 111  :         if (_Off > 0) {
; 112  :             _STL_VERIFY(_Off <= _Mycont->_Mylast - _Ptr, "cannot seek vector iterator after end");
; 113  :         }
; 114  : #endif // _ITERATOR_DEBUG_LEVEL == 0
; 115  :     }

	ret	4
?_Verify_offset@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUcaster@CLightShadows@@@std@@@std@@@std@@QBEXH@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CLightShadows::caster *> > >::_Verify_offset
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Verify_offset@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@Ushadow@CLightShadows@@@std@@@std@@@std@@QBEXH@Z
_TEXT	SEGMENT
__Off$dead$ = 8						; size = 4
?_Verify_offset@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@Ushadow@CLightShadows@@@std@@@std@@@std@@QBEXH@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CLightShadows::shadow> > >::_Verify_offset, COMDAT
; _this$dead$ = ecx

; 102  : #if _ITERATOR_DEBUG_LEVEL == 0
; 103  :         (void) _Off;
; 104  : #else // ^^^ _ITERATOR_DEBUG_LEVEL == 0 ^^^ // vvv _ITERATOR_DEBUG_LEVEL != 0 vvv
; 105  :         const auto _Mycont = static_cast<const _Myvec*>(this->_Getcont());
; 106  :         _STL_VERIFY(_Off == 0 || _Ptr, "cannot seek value-initialized vector iterator");
; 107  :         if (_Off < 0) {
; 108  :             _STL_VERIFY(_Off >= _Mycont->_Myfirst - _Ptr, "cannot seek vector iterator before begin");
; 109  :         }
; 110  : 
; 111  :         if (_Off > 0) {
; 112  :             _STL_VERIFY(_Off <= _Mycont->_Mylast - _Ptr, "cannot seek vector iterator after end");
; 113  :         }
; 114  : #endif // _ITERATOR_DEBUG_LEVEL == 0
; 115  :     }

	ret	4
?_Verify_offset@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@Ushadow@CLightShadows@@@std@@@std@@@std@@QBEXH@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CLightShadows::shadow> > >::_Verify_offset
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
;	COMDAT ??$xr_delete@Ucaster@CLightShadows@@@@YAXAAPAUcaster@CLightShadows@@@Z
_TEXT	SEGMENT
??$xr_delete@Ucaster@CLightShadows@@@@YAXAAPAUcaster@CLightShadows@@@Z PROC ; xr_delete<CLightShadows::caster>, COMDAT
; _ptr$ = ecx

; 150  : {

	push	esi
	push	edi
	mov	edi, ecx

; 151  : 	if (ptr) 

	mov	esi, DWORD PTR [edi]
	test	esi, esi
	je	SHORT $LN2@xr_delete
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [esi+20]
	test	eax, eax
	je	SHORT $LN16@xr_delete
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi+20], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+24], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+28], 0
	mov	esi, DWORD PTR [edi]
$LN16@xr_delete:
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h

; 144  : 		Memory.mem_free	(ptr);

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	esi
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z

; 152  : 	{
; 153  : 		xr_special_free<is_polymorphic<T>::result,T>()(ptr);
; 154  : 		ptr = nullptr;

	mov	DWORD PTR [edi], 0
$LN2@xr_delete:

; 155  : 	}
; 156  : }

	pop	edi
	pop	esi
	ret	0
??$xr_delete@Ucaster@CLightShadows@@@@YAXAAPAUcaster@CLightShadows@@@Z ENDP ; xr_delete<CLightShadows::caster>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
;	COMDAT ??$xr_free@Utess_tri@CLightShadows@@@@YAXAAPAUtess_tri@CLightShadows@@@Z
_TEXT	SEGMENT
??$xr_free@Utess_tri@CLightShadows@@@@YAXAAPAUtess_tri@CLightShadows@@@Z PROC ; xr_free<CLightShadows::tess_tri>, COMDAT
; _P$ = ecx

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	push	esi
	mov	esi, ecx
	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN2@xr_free
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
	mov	DWORD PTR [esi], 0
$LN2@xr_free:
	pop	esi
	ret	0
??$xr_free@Utess_tri@CLightShadows@@@@YAXAAPAUtess_tri@CLightShadows@@@Z ENDP ; xr_free<CLightShadows::tess_tri>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
;	COMDAT ??$xr_new@Ucaster@CLightShadows@@@@YAPAUcaster@CLightShadows@@XZ
_TEXT	SEGMENT
??$xr_new@Ucaster@CLightShadows@@@@YAPAUcaster@CLightShadows@@XZ PROC ; xr_new<CLightShadows::caster>, COMDAT

; 68   : 	T* ptr	= (T*)Memory.mem_alloc(sizeof(T));

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	32					; 00000020H
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z

; 69   : 	return new (ptr) T();

	xor	ecx, ecx
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], ecx
	mov	DWORD PTR [eax+16], ecx
	mov	DWORD PTR [eax+20], ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [eax+24], ecx
	mov	DWORD PTR [eax+28], ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h

; 70   : }

	ret	0
??$xr_new@Ucaster@CLightShadows@@@@YAPAUcaster@CLightShadows@@XZ ENDP ; xr_new<CLightShadows::caster>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$lower_bound@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@Ucache_item@CLightShadows@@@std@@@std@@@std@@Ucache_item@CLightShadows@@P6A_NABU34@0@Z@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@Ucache_item@CLightShadows@@@std@@@std@@@0@V10@V10@ABUcache_item@CLightShadows@@P6A_N22@Z@Z
_TEXT	SEGMENT
__Val$1$ = -8						; size = 4
___$ReturnUdt$1$ = -4					; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Pred$dead$ = 16					; size = 4
??$lower_bound@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@Ucache_item@CLightShadows@@@std@@@std@@@std@@Ucache_item@CLightShadows@@P6A_NABU34@0@Z@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@Ucache_item@CLightShadows@@@std@@@std@@@0@V10@V10@ABUcache_item@CLightShadows@@P6A_N22@Z@Z PROC ; std::lower_bound<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CLightShadows::cache_item> > >,CLightShadows::cache_item,bool (__cdecl*)(CLightShadows::cache_item const &,CLightShadows::cache_item const &)>, COMDAT
; ___$ReturnUdt$ = ecx
; __Val$ = edx

; 5807 : _NODISCARD _CONSTEXPR20 _FwdIt lower_bound(_FwdIt _First, const _FwdIt _Last, const _Ty& _Val, _Pr _Pred) {

	sub	esp, 8

; 1525 :         return _Last - _First; // assume the iterator will do debug checking

	mov	eax, DWORD PTR __Last$[esp+4]

; 5807 : _NODISCARD _CONSTEXPR20 _FwdIt lower_bound(_FwdIt _First, const _FwdIt _Last, const _Ty& _Val, _Pr _Pred) {

	push	ebx
	push	ebp
	push	edi

; 5808 :     // find first element not before _Val
; 5809 :     _Adl_verify_range(_First, _Last);
; 5810 :     auto _UFirst                = _Get_unwrapped(_First);

	mov	edi, DWORD PTR __First$[esp+16]
	mov	ebx, edx

; 1525 :         return _Last - _First; // assume the iterator will do debug checking

	sub	eax, edi

; 5807 : _NODISCARD _CONSTEXPR20 _FwdIt lower_bound(_FwdIt _First, const _FwdIt _Last, const _Ty& _Val, _Pr _Pred) {

	mov	DWORD PTR __Val$1$[esp+20], ebx

; 1525 :         return _Last - _First; // assume the iterator will do debug checking

	sar	eax, 2

; 5807 : _NODISCARD _CONSTEXPR20 _FwdIt lower_bound(_FwdIt _First, const _FwdIt _Last, const _Ty& _Val, _Pr _Pred) {

	mov	ebp, ecx

; 1525 :         return _Last - _First; // assume the iterator will do debug checking

	imul	edx, eax, -1171354717

; 5807 : _NODISCARD _CONSTEXPR20 _FwdIt lower_bound(_FwdIt _First, const _FwdIt _Last, const _Ty& _Val, _Pr _Pred) {

	mov	DWORD PTR ___$ReturnUdt$1$[esp+20], ebp

; 5811 :     _Iter_diff_t<_FwdIt> _Count = _STD distance(_UFirst, _Get_unwrapped(_Last));
; 5812 : 
; 5813 :     while (0 < _Count) { // divide and conquer, find half that contains answer

	test	edx, edx
	jle	SHORT $LN23@lower_boun
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp

; 349  : 	if (A.O < B.O)	return true;

	mov	ebx, DWORD PTR [ebx]
	mov	ebp, DWORD PTR __Val$1$[esp+20]
	push	esi
$LL2@lower_boun:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility

; 5814 :         const _Iter_diff_t<_FwdIt> _Count2 = _Count / 2;

	mov	ecx, edx
	shr	ecx, 1

; 1497 :         _Where += _Off;

	imul	esi, ecx, 44
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp

; 349  : 	if (A.O < B.O)	return true;

	cmp	DWORD PTR [esi+edi], ebx
	jb	SHORT $LN22@lower_boun

; 350  : 	if (A.O > B.O)	return false;

	ja	SHORT $LN4@lower_boun

; 351  : 	if (A.L < B.L)	return true;

	mov	eax, DWORD PTR [esi+edi+16]
	cmp	eax, DWORD PTR [ebp+16]
	jb	SHORT $LN22@lower_boun
$LN4@lower_boun:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility

; 5820 :             _Count = _Count2;

	mov	edx, ecx
	jmp	SHORT $LN5@lower_boun
$LN22@lower_boun:

; 5815 :         const auto _UMid                   = _STD next(_UFirst, _Count2);
; 5816 :         if (_Pred(*_UMid, _Val)) { // try top half
; 5817 :             _UFirst = _Next_iter(_UMid);
; 5818 :             _Count -= _Count2 + 1;

	or	eax, -1
	add	edi, 44					; 0000002cH
	sub	eax, ecx
	add	edi, esi
	add	edx, eax
$LN5@lower_boun:

; 5811 :     _Iter_diff_t<_FwdIt> _Count = _STD distance(_UFirst, _Get_unwrapped(_Last));
; 5812 : 
; 5813 :     while (0 < _Count) { // divide and conquer, find half that contains answer

	test	edx, edx
	jg	SHORT $LL2@lower_boun

; 5821 :         }
; 5822 :     }
; 5823 : 
; 5824 :     _Seek_wrapped(_First, _UFirst);
; 5825 :     return _First;

	mov	ebp, DWORD PTR ___$ReturnUdt$1$[esp+24]
	pop	esi
$LN23@lower_boun:

; 5826 : }

	mov	DWORD PTR [ebp], edi
	mov	eax, ebp
	pop	edi
	pop	ebp
	pop	ebx
	add	esp, 8
	ret	0
??$lower_bound@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@Ucache_item@CLightShadows@@@std@@@std@@@std@@Ucache_item@CLightShadows@@P6A_NABU34@0@Z@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@Ucache_item@CLightShadows@@@std@@@std@@@0@V10@V10@ABUcache_item@CLightShadows@@P6A_N22@Z@Z ENDP ; std::lower_bound<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CLightShadows::cache_item> > >,CLightShadows::cache_item,bool (__cdecl*)(CLightShadows::cache_item const &,CLightShadows::cache_item const &)>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_Get_unwrapped@AAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@Ucache_item@CLightShadows@@@std@@@std@@@std@@@std@@YA?A_TAAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@Ucache_item@CLightShadows@@@std@@@std@@@0@@Z
_TEXT	SEGMENT
??$_Get_unwrapped@AAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@Ucache_item@CLightShadows@@@std@@@std@@@std@@@std@@YA?A_TAAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@Ucache_item@CLightShadows@@@std@@@std@@@0@@Z PROC ; std::_Get_unwrapped<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CLightShadows::cache_item> > > &>, COMDAT
; __It$ = ecx

; 1275 :     // unwrap an iterator previously subjected to _Adl_verify_range or otherwise validated
; 1276 :     if constexpr (is_pointer_v<decay_t<_Iter>>) { // special-case pointers and arrays
; 1277 :         return _It + 0;
; 1278 :     } else if constexpr (_Unwrappable_v<_Iter>) {
; 1279 :         return static_cast<_Iter&&>(_It)._Unwrapped();

	mov	eax, DWORD PTR [ecx]

; 1280 :     } else {
; 1281 :         return static_cast<_Iter&&>(_It);
; 1282 :     }
; 1283 : }

	ret	0
??$_Get_unwrapped@AAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@Ucache_item@CLightShadows@@@std@@@std@@@std@@@std@@YA?A_TAAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@Ucache_item@CLightShadows@@@std@@@std@@@0@@Z ENDP ; std::_Get_unwrapped<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CLightShadows::cache_item> > > &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_Get_unwrapped@ABV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@Ucache_item@CLightShadows@@@std@@@std@@@std@@@std@@YA?A_TABV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@Ucache_item@CLightShadows@@@std@@@std@@@0@@Z
_TEXT	SEGMENT
??$_Get_unwrapped@ABV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@Ucache_item@CLightShadows@@@std@@@std@@@std@@@std@@YA?A_TABV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@Ucache_item@CLightShadows@@@std@@@std@@@0@@Z PROC ; std::_Get_unwrapped<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CLightShadows::cache_item> > > const &>, COMDAT
; __It$ = ecx

; 1275 :     // unwrap an iterator previously subjected to _Adl_verify_range or otherwise validated
; 1276 :     if constexpr (is_pointer_v<decay_t<_Iter>>) { // special-case pointers and arrays
; 1277 :         return _It + 0;
; 1278 :     } else if constexpr (_Unwrappable_v<_Iter>) {
; 1279 :         return static_cast<_Iter&&>(_It)._Unwrapped();

	mov	eax, DWORD PTR [ecx]

; 1280 :     } else {
; 1281 :         return static_cast<_Iter&&>(_It);
; 1282 :     }
; 1283 : }

	ret	0
??$_Get_unwrapped@ABV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@Ucache_item@CLightShadows@@@std@@@std@@@std@@@std@@YA?A_TABV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@Ucache_item@CLightShadows@@@std@@@std@@@0@@Z ENDP ; std::_Get_unwrapped<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CLightShadows::cache_item> > > const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
;	COMDAT ??$xr_alloc@Utess_tri@CLightShadows@@@@YAPAUtess_tri@CLightShadows@@I@Z
_TEXT	SEGMENT
??$xr_alloc@Utess_tri@CLightShadows@@@@YAPAUtess_tri@CLightShadows@@I@Z PROC ; xr_alloc<CLightShadows::tess_tri>, COMDAT
; _count$ = ecx

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	lea	eax, DWORD PTR [ecx+ecx*2]
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	shl	eax, 4
	push	eax
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
	ret	0
??$xr_alloc@Utess_tri@CLightShadows@@@@YAPAUtess_tri@CLightShadows@@I@Z ENDP ; xr_alloc<CLightShadows::tess_tri>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef
;	COMDAT ??$addressof@V?$_Vector_val@U?$_Simple_types@Ucache_item@CLightShadows@@@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@Ucache_item@CLightShadows@@@std@@@0@AAV10@@Z
_TEXT	SEGMENT
??$addressof@V?$_Vector_val@U?$_Simple_types@Ucache_item@CLightShadows@@@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@Ucache_item@CLightShadows@@@std@@@0@AAV10@@Z PROC ; std::addressof<std::_Vector_val<std::_Simple_types<CLightShadows::cache_item> > >, COMDAT
; __Val$ = ecx

; 253  :     return __builtin_addressof(_Val);

	mov	eax, ecx

; 254  : }

	ret	0
??$addressof@V?$_Vector_val@U?$_Simple_types@Ucache_item@CLightShadows@@@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@Ucache_item@CLightShadows@@@std@@@0@AAV10@@Z ENDP ; std::addressof<std::_Vector_val<std::_Simple_types<CLightShadows::cache_item> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_Move_unchecked@PAUcache_item@CLightShadows@@PAU12@@std@@YAPAUcache_item@CLightShadows@@PAU12@00@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
??$_Move_unchecked@PAUcache_item@CLightShadows@@PAU12@@std@@YAPAUcache_item@CLightShadows@@PAU12@00@Z PROC ; std::_Move_unchecked<CLightShadows::cache_item *,CLightShadows::cache_item *>, COMDAT
; __First$ = ecx
; __Last$ = edx

; 4308 : _CONSTEXPR20 _OutIt _Move_unchecked(_InIt _First, _InIt _Last, _OutIt _Dest) {

	push	esi

; 4066 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	esi, DWORD PTR __Dest$[esp]

; 4308 : _CONSTEXPR20 _OutIt _Move_unchecked(_InIt _First, _InIt _Last, _OutIt _Dest) {

	push	edi
	mov	edi, edx

; 4065 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	sub	edi, ecx

; 4066 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	push	edi
	push	ecx
	push	esi
	call	_memmove
	add	esp, 12					; 0000000cH

; 4067 :     if constexpr (is_pointer_v<_OutCtgIt>) {
; 4068 :         return reinterpret_cast<_OutCtgIt>(_Dest_ch + _Count);

	lea	eax, DWORD PTR [edi+esi]

; 4309 :     // move [_First, _Last) to [_Dest, ...)
; 4310 :     // note: _Move_unchecked has callers other than the move family
; 4311 :     if constexpr (_Ptr_move_cat<_InIt, _OutIt>::_Trivially_copyable) {
; 4312 : #ifdef __cpp_lib_is_constant_evaluated
; 4313 :         if (!_STD is_constant_evaluated())
; 4314 : #endif // __cpp_lib_is_constant_evaluated
; 4315 :         {
; 4316 :             return _Copy_memmove(_First, _Last, _Dest);

	pop	edi
	pop	esi

; 4317 :         }
; 4318 :     }
; 4319 : 
; 4320 :     for (; _First != _Last; ++_Dest, (void) ++_First) {
; 4321 :         *_Dest = _STD move(*_First);
; 4322 :     }
; 4323 : 
; 4324 :     return _Dest;
; 4325 : }

	ret	0
??$_Move_unchecked@PAUcache_item@CLightShadows@@PAU12@@std@@YAPAUcache_item@CLightShadows@@PAU12@00@Z ENDP ; std::_Move_unchecked<CLightShadows::cache_item *,CLightShadows::cache_item *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef
;	COMDAT ??$_Unfancy@Ucache_item@CLightShadows@@@std@@YAPAUcache_item@CLightShadows@@PAU12@@Z
_TEXT	SEGMENT
??$_Unfancy@Ucache_item@CLightShadows@@@std@@YAPAUcache_item@CLightShadows@@PAU12@@Z PROC ; std::_Unfancy<CLightShadows::cache_item>, COMDAT
; __Ptr$ = ecx

; 266  :     return _Ptr;

	mov	eax, ecx

; 267  : }

	ret	0
??$_Unfancy@Ucache_item@CLightShadows@@@std@@YAPAUcache_item@CLightShadows@@PAU12@@Z ENDP ; std::_Unfancy<CLightShadows::cache_item>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$destroy@Ucache_item@CLightShadows@@@?$_Normal_allocator_traits@V?$xalloc@Ucache_item@CLightShadows@@@@@std@@SAXAAV?$xalloc@Ucache_item@CLightShadows@@@@PAUcache_item@CLightShadows@@@Z
_TEXT	SEGMENT
??$destroy@Ucache_item@CLightShadows@@@?$_Normal_allocator_traits@V?$xalloc@Ucache_item@CLightShadows@@@@@std@@SAXAAV?$xalloc@Ucache_item@CLightShadows@@@@PAUcache_item@CLightShadows@@@Z PROC ; std::_Normal_allocator_traits<xalloc<CLightShadows::cache_item> >::destroy<CLightShadows::cache_item>, COMDAT
; __Al$dead$ = ecx
; __Ptr$dead$ = edx

; 579  :         if constexpr (_Uses_default_destroy<_Alloc, _Ty*>::value) {
; 580  : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 581  :             _STD destroy_at(_Ptr);
; 582  : #else // __cpp_lib_constexpr_dynamic_alloc
; 583  :             _Ptr->~_Ty();
; 584  : #endif // __cpp_lib_constexpr_dynamic_alloc
; 585  :         } else {
; 586  :             _Al.destroy(_Ptr);
; 587  :         }
; 588  :     }

	ret	0
??$destroy@Ucache_item@CLightShadows@@@?$_Normal_allocator_traits@V?$xalloc@Ucache_item@CLightShadows@@@@@std@@SAXAAV?$xalloc@Ucache_item@CLightShadows@@@@PAUcache_item@CLightShadows@@@Z ENDP ; std::_Normal_allocator_traits<xalloc<CLightShadows::cache_item> >::destroy<CLightShadows::cache_item>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??$emplace@ABUcache_item@CLightShadows@@@?$vector@Ucache_item@CLightShadows@@V?$xalloc@Ucache_item@CLightShadows@@@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@Ucache_item@CLightShadows@@@std@@@std@@@1@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@Ucache_item@CLightShadows@@@std@@@std@@@1@ABUcache_item@CLightShadows@@@Z
_TEXT	SEGMENT
__Obj$1 = -48						; size = 48
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
_<_Val_0>$ = 16						; size = 4
??$emplace@ABUcache_item@CLightShadows@@@?$vector@Ucache_item@CLightShadows@@V?$xalloc@Ucache_item@CLightShadows@@@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@Ucache_item@CLightShadows@@@std@@@std@@@1@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@Ucache_item@CLightShadows@@@std@@@std@@@1@ABUcache_item@CLightShadows@@@Z PROC ; std::vector<CLightShadows::cache_item,xalloc<CLightShadows::cache_item> >::emplace<CLightShadows::cache_item const &>, COMDAT
; _this$ = ecx

; 797  :     _CONSTEXPR20_CONTAINER iterator emplace(const_iterator _Where, _Valty&&... _Val) {

	sub	esp, 52					; 00000034H
	mov	eax, ecx

; 798  :         // insert by perfectly forwarding _Val at _Where
; 799  :         const pointer _Whereptr = _Where._Ptr;
; 800  :         auto& _My_data          = _Mypair._Myval2;
; 801  :         const pointer _Oldlast  = _My_data._Mylast;

	mov	edx, DWORD PTR [eax+4]
	push	ebx
	mov	ebx, DWORD PTR __Where$[esp+52]
	push	esi
	push	edi

; 802  : #if _ITERATOR_DEBUG_LEVEL == 2
; 803  :         _STL_VERIFY(
; 804  :             _Where._Getcont() == _STD addressof(_My_data) && _Whereptr >= _My_data._Myfirst && _Oldlast >= _Whereptr,
; 805  :             "vector emplace iterator outside range");
; 806  : #endif // _ITERATOR_DEBUG_LEVEL == 2
; 807  : 
; 808  :         if (_Oldlast != _My_data._Myend) {

	cmp	edx, DWORD PTR [eax+8]
	je	SHORT $LN2@emplace

; 809  :             if (_Whereptr == _Oldlast) { // at back, provide strong guarantee

	mov	esi, DWORD PTR _<_Val_0>$[esp+60]
	mov	ecx, 11					; 0000000bH
	cmp	ebx, edx
	jne	SHORT $LN3@emplace
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	edi, edx
	rep movsd
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 716  :         ++_Mylast;

	add	DWORD PTR [eax+4], 44			; 0000002cH

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	eax, DWORD PTR ___$ReturnUdt$[esp+60]
	mov	DWORD PTR [eax], ebx

; 826  :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 52					; 00000034H
	ret	12					; 0000000cH
$LN3@emplace:
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	lea	edi, DWORD PTR __Obj$1[esp+68]
	rep movsd
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 816  :                 _Alty_traits::construct(_Al, _Unfancy(_Oldlast), _STD move(_Oldlast[-1]));

	lea	esi, DWORD PTR [edx-44]
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	edi, edx
	mov	ecx, 11					; 0000000bH
	rep movsd
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 817  :                 ++_My_data._Mylast;

	add	DWORD PTR [eax+4], 44			; 0000002cH
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility

; 4254 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	mov	eax, edx
	sub	eax, ebx
	sub	eax, 44					; 0000002cH

; 4255 :     auto _Result                = _CSTD memmove(_Dest_ch - _Count, _First_ch, _Count);

	push	eax
	sub	edx, eax
	push	ebx
	push	edx
	call	_memmove
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	eax, DWORD PTR ___$ReturnUdt$[esp+72]

; 819  :                 *_Whereptr = _STD move(_Obj._Get_value());

	lea	esi, DWORD PTR __Obj$1[esp+80]
	mov	ecx, 11					; 0000000bH
	mov	edi, ebx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility

; 4255 :     auto _Result                = _CSTD memmove(_Dest_ch - _Count, _First_ch, _Count);

	add	esp, 12					; 0000000cH
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 819  :                 *_Whereptr = _STD move(_Obj._Get_value());

	rep movsd

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	DWORD PTR [eax], ebx

; 826  :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 52					; 00000034H
	ret	12					; 0000000cH
$LN2@emplace:

; 820  :             }
; 821  : 
; 822  :             return _Make_iterator(_Whereptr);
; 823  :         }
; 824  : 
; 825  :         return _Make_iterator(_Emplace_reallocate(_Whereptr, _STD forward<_Valty>(_Val)...));

	push	DWORD PTR _<_Val_0>$[esp+60]
	push	ebx
	call	??$_Emplace_reallocate@ABUcache_item@CLightShadows@@@?$vector@Ucache_item@CLightShadows@@V?$xalloc@Ucache_item@CLightShadows@@@@@std@@QAEPAUcache_item@CLightShadows@@QAU23@ABU23@@Z ; std::vector<CLightShadows::cache_item,xalloc<CLightShadows::cache_item> >::_Emplace_reallocate<CLightShadows::cache_item const &>

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	ecx, DWORD PTR ___$ReturnUdt$[esp+60]

; 826  :     }

	pop	edi
	pop	esi
	pop	ebx

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	DWORD PTR [ecx], eax

; 820  :             }
; 821  : 
; 822  :             return _Make_iterator(_Whereptr);
; 823  :         }
; 824  : 
; 825  :         return _Make_iterator(_Emplace_reallocate(_Whereptr, _STD forward<_Valty>(_Val)...));

	mov	eax, ecx

; 826  :     }

	add	esp, 52					; 00000034H
	ret	12					; 0000000cH
??$emplace@ABUcache_item@CLightShadows@@@?$vector@Ucache_item@CLightShadows@@V?$xalloc@Ucache_item@CLightShadows@@@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@Ucache_item@CLightShadows@@@std@@@std@@@1@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@Ucache_item@CLightShadows@@@std@@@std@@@1@ABUcache_item@CLightShadows@@@Z ENDP ; std::vector<CLightShadows::cache_item,xalloc<CLightShadows::cache_item> >::emplace<CLightShadows::cache_item const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??$_Emplace_back_with_unused_capacity@ABUcache_item@CLightShadows@@@?$vector@Ucache_item@CLightShadows@@V?$xalloc@Ucache_item@CLightShadows@@@@@std@@AAE?A_TABUcache_item@CLightShadows@@@Z
_TEXT	SEGMENT
_<_Val_0>$ = 8						; size = 4
??$_Emplace_back_with_unused_capacity@ABUcache_item@CLightShadows@@@?$vector@Ucache_item@CLightShadows@@V?$xalloc@Ucache_item@CLightShadows@@@@@std@@AAE?A_TABUcache_item@CLightShadows@@@Z PROC ; std::vector<CLightShadows::cache_item,xalloc<CLightShadows::cache_item> >::_Emplace_back_with_unused_capacity<CLightShadows::cache_item const &>, COMDAT
; _this$ = ecx

; 708  :     _CONSTEXPR20_CONTAINER decltype(auto) _Emplace_back_with_unused_capacity(_Valty&&... _Val) {

	mov	eax, ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	ecx, 11					; 0000000bH
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 708  :     _CONSTEXPR20_CONTAINER decltype(auto) _Emplace_back_with_unused_capacity(_Valty&&... _Val) {

	push	esi
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	esi, DWORD PTR _<_Val_0>$[esp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 708  :     _CONSTEXPR20_CONTAINER decltype(auto) _Emplace_back_with_unused_capacity(_Valty&&... _Val) {

	push	edi
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	edi, DWORD PTR [eax+4]
	rep movsd
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 716  :         ++_Mylast;

	add	DWORD PTR [eax+4], 44			; 0000002cH
	pop	edi
	pop	esi

; 717  : #if _HAS_CXX17
; 718  :         return _Result;
; 719  : #else // ^^^ _HAS_CXX17 ^^^ // vvv !_HAS_CXX17 vvv
; 720  :         (void) _Result;
; 721  : #endif // _HAS_CXX17
; 722  :     }

	ret	4
??$_Emplace_back_with_unused_capacity@ABUcache_item@CLightShadows@@@?$vector@Ucache_item@CLightShadows@@V?$xalloc@Ucache_item@CLightShadows@@@@@std@@AAE?A_TABUcache_item@CLightShadows@@@Z ENDP ; std::vector<CLightShadows::cache_item,xalloc<CLightShadows::cache_item> >::_Emplace_back_with_unused_capacity<CLightShadows::cache_item const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef
;	COMDAT ??$addressof@V?$_Vector_val@U?$_Simple_types@Utess_tri@CLightShadows@@@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@Utess_tri@CLightShadows@@@std@@@0@AAV10@@Z
_TEXT	SEGMENT
??$addressof@V?$_Vector_val@U?$_Simple_types@Utess_tri@CLightShadows@@@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@Utess_tri@CLightShadows@@@std@@@0@AAV10@@Z PROC ; std::addressof<std::_Vector_val<std::_Simple_types<CLightShadows::tess_tri> > >, COMDAT
; __Val$ = ecx

; 253  :     return __builtin_addressof(_Val);

	mov	eax, ecx

; 254  : }

	ret	0
??$addressof@V?$_Vector_val@U?$_Simple_types@Utess_tri@CLightShadows@@@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@Utess_tri@CLightShadows@@@std@@@0@AAV10@@Z ENDP ; std::addressof<std::_Vector_val<std::_Simple_types<CLightShadows::tess_tri> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\type_traits
;	COMDAT ??$move@AAUtess_tri@CLightShadows@@@std@@YA$$QAUtess_tri@CLightShadows@@AAU12@@Z
_TEXT	SEGMENT
??$move@AAUtess_tri@CLightShadows@@@std@@YA$$QAUtess_tri@CLightShadows@@AAU12@@Z PROC ; std::move<CLightShadows::tess_tri &>, COMDAT
; __Arg$ = ecx

; 1397 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

	mov	eax, ecx

; 1398 : }

	ret	0
??$move@AAUtess_tri@CLightShadows@@@std@@YA$$QAUtess_tri@CLightShadows@@AAU12@@Z ENDP ; std::move<CLightShadows::tess_tri &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\type_traits
;	COMDAT ??$forward@Utess_tri@CLightShadows@@@std@@YA$$QAUtess_tri@CLightShadows@@AAU12@@Z
_TEXT	SEGMENT
??$forward@Utess_tri@CLightShadows@@@std@@YA$$QAUtess_tri@CLightShadows@@AAU12@@Z PROC ; std::forward<CLightShadows::tess_tri>, COMDAT
; __Arg$ = ecx

; 1386 :     return static_cast<_Ty&&>(_Arg);

	mov	eax, ecx

; 1387 : }

	ret	0
??$forward@Utess_tri@CLightShadows@@@std@@YA$$QAUtess_tri@CLightShadows@@AAU12@@Z ENDP ; std::forward<CLightShadows::tess_tri>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef
;	COMDAT ??$_Unfancy@Utess_tri@CLightShadows@@@std@@YAPAUtess_tri@CLightShadows@@PAU12@@Z
_TEXT	SEGMENT
??$_Unfancy@Utess_tri@CLightShadows@@@std@@YAPAUtess_tri@CLightShadows@@PAU12@@Z PROC ; std::_Unfancy<CLightShadows::tess_tri>, COMDAT
; __Ptr$ = ecx

; 266  :     return _Ptr;

	mov	eax, ecx

; 267  : }

	ret	0
??$_Unfancy@Utess_tri@CLightShadows@@@std@@YAPAUtess_tri@CLightShadows@@PAU12@@Z ENDP ; std::_Unfancy<CLightShadows::tess_tri>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$construct@Utess_tri@CLightShadows@@U12@@?$_Normal_allocator_traits@V?$xalloc@Utess_tri@CLightShadows@@@@@std@@SAXAAV?$xalloc@Utess_tri@CLightShadows@@@@PAUtess_tri@CLightShadows@@$$QAU34@@Z
_TEXT	SEGMENT
_<_Args_0>$ = 8						; size = 4
??$construct@Utess_tri@CLightShadows@@U12@@?$_Normal_allocator_traits@V?$xalloc@Utess_tri@CLightShadows@@@@@std@@SAXAAV?$xalloc@Utess_tri@CLightShadows@@@@PAUtess_tri@CLightShadows@@$$QAU34@@Z PROC ; std::_Normal_allocator_traits<xalloc<CLightShadows::tess_tri> >::construct<CLightShadows::tess_tri,CLightShadows::tess_tri>, COMDAT
; __Al$dead$ = ecx
; __Ptr$ = edx

; 564  :     static _CONSTEXPR20_DYNALLOC void construct(_Alloc& _Al, _Ty* _Ptr, _Types&&... _Args) {

	push	esi
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	esi, DWORD PTR _<_Args_0>$[esp]
	mov	ecx, 12					; 0000000cH
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 564  :     static _CONSTEXPR20_DYNALLOC void construct(_Alloc& _Al, _Ty* _Ptr, _Types&&... _Args) {

	push	edi
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	edi, edx
	rep movsd
	pop	edi
	pop	esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 575  :     }

	ret	0
??$construct@Utess_tri@CLightShadows@@U12@@?$_Normal_allocator_traits@V?$xalloc@Utess_tri@CLightShadows@@@@@std@@SAXAAV?$xalloc@Utess_tri@CLightShadows@@@@PAUtess_tri@CLightShadows@@$$QAU34@@Z ENDP ; std::_Normal_allocator_traits<xalloc<CLightShadows::tess_tri> >::construct<CLightShadows::tess_tri,CLightShadows::tess_tri>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??$_Emplace_reallocate@Utess_tri@CLightShadows@@@?$vector@Utess_tri@CLightShadows@@V?$xalloc@Utess_tri@CLightShadows@@@@@std@@QAEPAUtess_tri@CLightShadows@@QAU23@$$QAU23@@Z
_TEXT	SEGMENT
__Backout$2 = -48					; size = 12
__Oldsize$1$ = -36					; size = 4
__UFirst$3 = -32					; size = 4
__Newvec$ = -28						; size = 4
tv446 = -24						; size = 4
_this$1$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Whereptr$ = 8						; size = 4
__ULast$1$ = 12						; size = 4
_<_Val_0>$ = 12						; size = 4
??$_Emplace_reallocate@Utess_tri@CLightShadows@@@?$vector@Utess_tri@CLightShadows@@V?$xalloc@Utess_tri@CLightShadows@@@@@std@@QAEPAUtess_tri@CLightShadows@@QAU23@$$QAU23@@Z PROC ; std::vector<CLightShadows::tess_tri,xalloc<CLightShadows::tess_tri> >::_Emplace_reallocate<CLightShadows::tess_tri>, COMDAT
; _this$ = ecx

; 752  :     _CONSTEXPR20_CONTAINER pointer _Emplace_reallocate(const pointer _Whereptr, _Valty&&... _Val) {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Emplace_reallocate@Utess_tri@CLightShadows@@@?$vector@Utess_tri@CLightShadows@@V?$xalloc@Utess_tri@CLightShadows@@@@@std@@QAEPAUtess_tri@CLightShadows@@QAU23@$$QAU23@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 36					; 00000024H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$1$[ebp], ecx

; 753  :         // reallocate and insert by perfectly forwarding _Val at _Whereptr
; 754  :         _Alty& _Al        = _Getal();
; 755  :         auto& _My_data    = _Mypair._Myval2;
; 756  :         pointer& _Myfirst = _My_data._Myfirst;
; 757  :         pointer& _Mylast  = _My_data._Mylast;
; 758  : 
; 759  :         _STL_INTERNAL_CHECK(_Mylast == _My_data._Myend); // check that we have no unused capacity
; 760  : 
; 761  :         const auto _Whereoff = static_cast<size_type>(_Whereptr - _Myfirst);

	mov	ebx, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Whereptr$[ebp]
	sub	edx, ebx
	mov	eax, 715827883				; 2aaaaaabH
	imul	edx
	sar	edx, 3
	mov	edi, edx
	shr	edi, 31					; 0000001fH
	add	edi, edx

; 762  :         const auto _Oldsize  = static_cast<size_type>(_Mylast - _Myfirst);

	mov	eax, DWORD PTR [ecx+4]
	sub	eax, ebx
	sar	eax, 4
	imul	eax, eax, -1431655765
	mov	DWORD PTR __Oldsize$1$[ebp], eax

; 763  : 
; 764  :         if (_Oldsize == max_size()) {

	cmp	eax, 89478485				; 05555555H
	je	$LN58@Emplace_re

; 766  :         }
; 767  : 
; 768  :         const size_type _Newsize     = _Oldsize + 1;

	lea	esi, DWORD PTR [eax+1]

; 1546 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	eax, DWORD PTR [ecx+8]
	sub	eax, ebx
	sar	eax, 4
	imul	edx, eax, -1431655765

; 1675 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	ecx, edx
	shr	ecx, 1
	mov	eax, 89478485				; 05555555H
	sub	eax, ecx
	cmp	edx, eax
	jbe	SHORT $LN12@Emplace_re

; 1676 :             return _Max; // geometric growth would overflow

	mov	ebx, 89478485				; 05555555H
	jmp	SHORT $LN13@Emplace_re
$LN12@Emplace_re:

; 1677 :         }
; 1678 : 
; 1679 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	lea	ebx, DWORD PTR [ecx+edx]

; 1680 : 
; 1681 :         if (_Geometric < _Newsize) {

	cmp	ebx, esi
	cmovb	ebx, esi
$LN13@Emplace_re:
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	lea	eax, DWORD PTR [ebx+ebx*2]
	shl	eax, 4
	push	eax
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 771  :         const pointer _Newvec           = _Al.allocate(_Newcapacity);

	mov	edx, eax
	mov	DWORD PTR __Newvec$[ebp], edx

; 772  :         const pointer _Constructed_last = _Newvec + _Whereoff + 1;
; 773  :         pointer _Constructed_first      = _Constructed_last;
; 774  : 
; 775  :         _TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 776  :         _Alty_traits::construct(_Al, _Unfancy(_Newvec + _Whereoff), _STD forward<_Valty>(_Val)...);

	lea	eax, DWORD PTR [edi+edi*2]
	shl	eax, 4
	add	eax, edx
	mov	DWORD PTR tv446[ebp], eax
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	ecx, 12					; 0000000cH
	mov	esi, DWORD PTR _<_Val_0>$[ebp]
	mov	edi, eax
	rep movsd
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 779  :         if (_Whereptr == _Mylast) { // at back, provide strong guarantee

	mov	esi, DWORD PTR _this$1$[ebp]
	mov	ecx, DWORD PTR [esi+4]
	mov	DWORD PTR __ULast$1$[ebp], ecx
	mov	eax, DWORD PTR [esi]
	mov	edi, DWORD PTR __Whereptr$[ebp]
	cmp	edi, ecx
	jne	SHORT $LN4@Emplace_re
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1703 :     auto _UFirst      = _Get_unwrapped(_First);

	mov	DWORD PTR __UFirst$3[ebp], eax

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	DWORD PTR __Backout$2[ebp], edx
	mov	DWORD PTR __Backout$2[ebp+4], edx
	mov	DWORD PTR __Backout$2[ebp+8], esi
	npad	5
$LL32@Emplace_re:

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	eax, ecx
	je	SHORT $LN31@Emplace_re
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	ecx, 12					; 0000000cH
	mov	esi, eax
	mov	edi, edx
	rep movsd
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1621 :         ++_Last;

	add	edx, 48					; 00000030H
	mov	DWORD PTR __Backout$2[ebp+4], edx

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	add	eax, 48					; 00000030H
	mov	DWORD PTR __UFirst$3[ebp], eax
	mov	ecx, DWORD PTR __ULast$1$[ebp]
	jmp	SHORT $LL32@Emplace_re
$LN31@Emplace_re:

; 1625 :         _First = _Last;

	mov	DWORD PTR __Backout$2[ebp], edx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 781  :         } else { // provide basic guarantee

	mov	esi, DWORD PTR _this$1$[ebp]
	jmp	SHORT $LN5@Emplace_re
$LN4@Emplace_re:

; 782  :             _Umove(_Myfirst, _Whereptr, _Newvec);

	push	edx
	push	edi
	push	eax
	call	?_Umove@?$vector@Utess_tri@CLightShadows@@V?$xalloc@Utess_tri@CLightShadows@@@@@std@@AAEPAUtess_tri@CLightShadows@@PAU34@00@Z ; std::vector<CLightShadows::tess_tri,xalloc<CLightShadows::tess_tri> >::_Umove

; 783  :             _Constructed_first = _Newvec;
; 784  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

	mov	ecx, DWORD PTR tv446[ebp]
	lea	eax, DWORD PTR [ecx+48]
	push	eax
	push	DWORD PTR [esi+4]
	push	edi
	call	?_Umove@?$vector@Utess_tri@CLightShadows@@V?$xalloc@Utess_tri@CLightShadows@@@@@std@@AAEPAUtess_tri@CLightShadows@@PAU34@00@Z ; std::vector<CLightShadows::tess_tri,xalloc<CLightShadows::tess_tri> >::_Umove
$LN5@Emplace_re:
	mov	DWORD PTR __$EHRec$[ebp+12], -1

; 1732 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN50@Emplace_re
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	push	eax
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN50@Emplace_re:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1737 :         _Myfirst = _Newvec;

	mov	eax, DWORD PTR __Newvec$[ebp]
	mov	DWORD PTR [esi], eax

; 1738 :         _Mylast  = _Newvec + _Newsize;

	mov	ecx, DWORD PTR __Oldsize$1$[ebp]
	lea	ecx, DWORD PTR [ecx+ecx*2]
	add	ecx, 3
	shl	ecx, 4
	add	ecx, eax
	mov	DWORD PTR [esi+4], ecx

; 1739 :         _Myend   = _Newvec + _Newcapacity;

	lea	ecx, DWORD PTR [ebx+ebx*2]
	shl	ecx, 4
	add	ecx, eax
	mov	DWORD PTR [esi+8], ecx

; 790  :         _CATCH_END
; 791  : 
; 792  :         _Change_array(_Newvec, _Newsize, _Newcapacity);
; 793  :         return _Newvec + _Whereoff;

	mov	eax, DWORD PTR tv446[ebp]

; 794  :     }

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
__catch$??$_Emplace_reallocate@Utess_tri@CLightShadows@@@?$vector@Utess_tri@CLightShadows@@V?$xalloc@Utess_tri@CLightShadows@@@@@std@@QAEPAUtess_tri@CLightShadows@@QAU23@$$QAU23@@Z$0:

; 785  :         }
; 786  :         _CATCH_ALL
; 787  :         _Destroy(_Constructed_first, _Constructed_last);
; 788  :         _Al.deallocate(_Newvec, _Newcapacity);

	push	ecx
	push	DWORD PTR __Newvec$[ebp]
	call	?deallocate@?$xalloc@Utess_tri@CLightShadows@@@@QBEXPAUtess_tri@CLightShadows@@I@Z ; xalloc<CLightShadows::tess_tri>::deallocate

; 789  :         _RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$LN58@Emplace_re:

; 765  :             _Xlength();

	call	?_Xlength@?$vector@Utess_tri@CLightShadows@@V?$xalloc@Utess_tri@CLightShadows@@@@@std@@CAXXZ ; std::vector<CLightShadows::tess_tri,xalloc<CLightShadows::tess_tri> >::_Xlength
$LN56@Emplace_re:
	int	3
	int	3
	int	3
	int	3
	int	3
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Emplace_reallocate@Utess_tri@CLightShadows@@@?$vector@Utess_tri@CLightShadows@@V?$xalloc@Utess_tri@CLightShadows@@@@@std@@QAEPAUtess_tri@CLightShadows@@QAU23@$$QAU23@@Z:
	npad	1
	npad	1
	mov	eax, OFFSET __ehfuncinfo$??$_Emplace_reallocate@Utess_tri@CLightShadows@@@?$vector@Utess_tri@CLightShadows@@V?$xalloc@Utess_tri@CLightShadows@@@@@std@@QAEPAUtess_tri@CLightShadows@@QAU23@$$QAU23@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Emplace_reallocate@Utess_tri@CLightShadows@@@?$vector@Utess_tri@CLightShadows@@V?$xalloc@Utess_tri@CLightShadows@@@@@std@@QAEPAUtess_tri@CLightShadows@@QAU23@$$QAU23@@Z ENDP ; std::vector<CLightShadows::tess_tri,xalloc<CLightShadows::tess_tri> >::_Emplace_reallocate<CLightShadows::tess_tri>
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\type_traits
;	COMDAT ??$move@AAUshadow@CLightShadows@@@std@@YA$$QAUshadow@CLightShadows@@AAU12@@Z
_TEXT	SEGMENT
??$move@AAUshadow@CLightShadows@@@std@@YA$$QAUshadow@CLightShadows@@AAU12@@Z PROC ; std::move<CLightShadows::shadow &>, COMDAT
; __Arg$ = ecx

; 1397 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

	mov	eax, ecx

; 1398 : }

	ret	0
??$move@AAUshadow@CLightShadows@@@std@@YA$$QAUshadow@CLightShadows@@AAU12@@Z ENDP ; std::move<CLightShadows::shadow &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\type_traits
;	COMDAT ??$forward@Ushadow@CLightShadows@@@std@@YA$$QAUshadow@CLightShadows@@AAU12@@Z
_TEXT	SEGMENT
??$forward@Ushadow@CLightShadows@@@std@@YA$$QAUshadow@CLightShadows@@AAU12@@Z PROC ; std::forward<CLightShadows::shadow>, COMDAT
; __Arg$ = ecx

; 1386 :     return static_cast<_Ty&&>(_Arg);

	mov	eax, ecx

; 1387 : }

	ret	0
??$forward@Ushadow@CLightShadows@@@std@@YA$$QAUshadow@CLightShadows@@AAU12@@Z ENDP ; std::forward<CLightShadows::shadow>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef
;	COMDAT ??$_Unfancy@Ushadow@CLightShadows@@@std@@YAPAUshadow@CLightShadows@@PAU12@@Z
_TEXT	SEGMENT
??$_Unfancy@Ushadow@CLightShadows@@@std@@YAPAUshadow@CLightShadows@@PAU12@@Z PROC ; std::_Unfancy<CLightShadows::shadow>, COMDAT
; __Ptr$ = ecx

; 266  :     return _Ptr;

	mov	eax, ecx

; 267  : }

	ret	0
??$_Unfancy@Ushadow@CLightShadows@@@std@@YAPAUshadow@CLightShadows@@PAU12@@Z ENDP ; std::_Unfancy<CLightShadows::shadow>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$construct@Ushadow@CLightShadows@@U12@@?$_Normal_allocator_traits@V?$xalloc@Ushadow@CLightShadows@@@@@std@@SAXAAV?$xalloc@Ushadow@CLightShadows@@@@PAUshadow@CLightShadows@@$$QAU34@@Z
_TEXT	SEGMENT
_<_Args_0>$ = 8						; size = 4
??$construct@Ushadow@CLightShadows@@U12@@?$_Normal_allocator_traits@V?$xalloc@Ushadow@CLightShadows@@@@@std@@SAXAAV?$xalloc@Ushadow@CLightShadows@@@@PAUshadow@CLightShadows@@$$QAU34@@Z PROC ; std::_Normal_allocator_traits<xalloc<CLightShadows::shadow> >::construct<CLightShadows::shadow,CLightShadows::shadow>, COMDAT
; __Al$dead$ = ecx
; __Ptr$ = edx

; 564  :     static _CONSTEXPR20_DYNALLOC void construct(_Alloc& _Al, _Ty* _Ptr, _Types&&... _Args) {

	push	esi
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	esi, DWORD PTR _<_Args_0>$[esp]
	mov	ecx, 23					; 00000017H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 564  :     static _CONSTEXPR20_DYNALLOC void construct(_Alloc& _Al, _Ty* _Ptr, _Types&&... _Args) {

	push	edi
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	edi, edx
	rep movsd
	pop	edi
	pop	esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 575  :     }

	ret	0
??$construct@Ushadow@CLightShadows@@U12@@?$_Normal_allocator_traits@V?$xalloc@Ushadow@CLightShadows@@@@@std@@SAXAAV?$xalloc@Ushadow@CLightShadows@@@@PAUshadow@CLightShadows@@$$QAU34@@Z ENDP ; std::_Normal_allocator_traits<xalloc<CLightShadows::shadow> >::construct<CLightShadows::shadow,CLightShadows::shadow>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??$_Emplace_reallocate@Ushadow@CLightShadows@@@?$vector@Ushadow@CLightShadows@@V?$xalloc@Ushadow@CLightShadows@@@@@std@@QAEPAUshadow@CLightShadows@@QAU23@$$QAU23@@Z
_TEXT	SEGMENT
__Backout$2 = -52					; size = 12
__Newvec$ = -40						; size = 4
__Newsize$1$ = -36					; size = 4
__UFirst$3 = -32					; size = 4
tv460 = -28						; size = 4
__Newcapacity$1$ = -24					; size = 4
_this$1$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Whereptr$ = 8						; size = 4
__ULast$1$ = 12						; size = 4
_<_Val_0>$ = 12						; size = 4
??$_Emplace_reallocate@Ushadow@CLightShadows@@@?$vector@Ushadow@CLightShadows@@V?$xalloc@Ushadow@CLightShadows@@@@@std@@QAEPAUshadow@CLightShadows@@QAU23@$$QAU23@@Z PROC ; std::vector<CLightShadows::shadow,xalloc<CLightShadows::shadow> >::_Emplace_reallocate<CLightShadows::shadow>, COMDAT
; _this$ = ecx

; 752  :     _CONSTEXPR20_CONTAINER pointer _Emplace_reallocate(const pointer _Whereptr, _Valty&&... _Val) {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Emplace_reallocate@Ushadow@CLightShadows@@@?$vector@Ushadow@CLightShadows@@V?$xalloc@Ushadow@CLightShadows@@@@@std@@QAEPAUshadow@CLightShadows@@QAU23@$$QAU23@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 40					; 00000028H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	edi, ecx
	mov	DWORD PTR _this$1$[ebp], edi

; 753  :         // reallocate and insert by perfectly forwarding _Val at _Whereptr
; 754  :         _Alty& _Al        = _Getal();
; 755  :         auto& _My_data    = _Mypair._Myval2;
; 756  :         pointer& _Myfirst = _My_data._Myfirst;
; 757  :         pointer& _Mylast  = _My_data._Mylast;
; 758  : 
; 759  :         _STL_INTERNAL_CHECK(_Mylast == _My_data._Myend); // check that we have no unused capacity
; 760  : 
; 761  :         const auto _Whereoff = static_cast<size_type>(_Whereptr - _Myfirst);

	mov	esi, DWORD PTR __Whereptr$[ebp]
	sub	esi, DWORD PTR [edi]
	mov	eax, -1307163959			; b21642c9H
	imul	esi
	add	edx, esi
	sar	edx, 6
	mov	esi, edx
	shr	esi, 31					; 0000001fH
	add	esi, edx

; 762  :         const auto _Oldsize  = static_cast<size_type>(_Mylast - _Myfirst);

	mov	ecx, DWORD PTR [edi+4]
	sub	ecx, DWORD PTR [edi]
	mov	eax, -1307163959			; b21642c9H
	imul	ecx
	add	edx, ecx
	sar	edx, 6
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx

; 763  : 
; 764  :         if (_Oldsize == max_size()) {

	cmp	eax, 46684427				; 02c8590bH
	je	$LN59@Emplace_re

; 766  :         }
; 767  : 
; 768  :         const size_type _Newsize     = _Oldsize + 1;

	lea	ebx, DWORD PTR [eax+1]
	mov	DWORD PTR __Newsize$1$[ebp], ebx

; 1546 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	ecx, DWORD PTR [edi+8]
	sub	ecx, DWORD PTR [edi]
	mov	eax, -1307163959			; b21642c9H
	imul	ecx
	add	edx, ecx
	sar	edx, 6
	mov	ecx, edx
	shr	ecx, 31					; 0000001fH
	add	ecx, edx

; 1675 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	edx, ecx
	shr	edx, 1
	mov	eax, 46684427				; 02c8590bH
	sub	eax, edx
	cmp	ecx, eax
	jbe	SHORT $LN12@Emplace_re

; 1676 :             return _Max; // geometric growth would overflow

	mov	eax, 46684427				; 02c8590bH
	jmp	SHORT $LN57@Emplace_re
$LN12@Emplace_re:

; 1677 :         }
; 1678 : 
; 1679 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	lea	eax, DWORD PTR [edx+ecx]

; 1680 : 
; 1681 :         if (_Geometric < _Newsize) {

	cmp	eax, ebx
	cmovb	eax, ebx
$LN57@Emplace_re:
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	mov	DWORD PTR __Newcapacity$1$[ebp], eax
	imul	eax, eax, 92
	push	eax
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 771  :         const pointer _Newvec           = _Al.allocate(_Newcapacity);

	mov	ebx, eax
	mov	DWORD PTR __Newvec$[ebp], ebx

; 772  :         const pointer _Constructed_last = _Newvec + _Whereoff + 1;
; 773  :         pointer _Constructed_first      = _Constructed_last;
; 774  : 
; 775  :         _TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 776  :         _Alty_traits::construct(_Al, _Unfancy(_Newvec + _Whereoff), _STD forward<_Valty>(_Val)...);

	imul	eax, esi, 92
	add	eax, ebx
	mov	DWORD PTR tv460[ebp], eax
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	ecx, 23					; 00000017H
	mov	esi, DWORD PTR _<_Val_0>$[ebp]
	mov	edi, eax
	rep movsd
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 779  :         if (_Whereptr == _Mylast) { // at back, provide strong guarantee

	mov	esi, DWORD PTR _this$1$[ebp]
	mov	ecx, DWORD PTR [esi+4]
	mov	DWORD PTR __ULast$1$[ebp], ecx
	mov	eax, DWORD PTR [esi]
	mov	edi, DWORD PTR __Whereptr$[ebp]
	cmp	edi, ecx
	jne	SHORT $LN4@Emplace_re
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1703 :     auto _UFirst      = _Get_unwrapped(_First);

	mov	DWORD PTR __UFirst$3[ebp], eax

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	DWORD PTR __Backout$2[ebp], ebx
	mov	edx, ebx
	mov	DWORD PTR __Backout$2[ebp+4], edx
	mov	DWORD PTR __Backout$2[ebp+8], esi
$LL32@Emplace_re:

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	eax, ecx
	je	SHORT $LN31@Emplace_re
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	ecx, 23					; 00000017H
	mov	esi, eax
	mov	edi, edx
	rep movsd
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1621 :         ++_Last;

	add	edx, 92					; 0000005cH
	mov	DWORD PTR __Backout$2[ebp+4], edx

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	add	eax, 92					; 0000005cH
	mov	DWORD PTR __UFirst$3[ebp], eax
	mov	ecx, DWORD PTR __ULast$1$[ebp]
	jmp	SHORT $LL32@Emplace_re
$LN31@Emplace_re:

; 1625 :         _First = _Last;

	mov	DWORD PTR __Backout$2[ebp], edx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 781  :         } else { // provide basic guarantee

	mov	esi, DWORD PTR _this$1$[ebp]
	jmp	SHORT $LN5@Emplace_re
$LN4@Emplace_re:

; 782  :             _Umove(_Myfirst, _Whereptr, _Newvec);

	push	ebx
	push	edi
	push	eax
	call	?_Umove@?$vector@Ushadow@CLightShadows@@V?$xalloc@Ushadow@CLightShadows@@@@@std@@AAEPAUshadow@CLightShadows@@PAU34@00@Z ; std::vector<CLightShadows::shadow,xalloc<CLightShadows::shadow> >::_Umove

; 783  :             _Constructed_first = _Newvec;
; 784  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

	mov	ecx, DWORD PTR tv460[ebp]
	lea	eax, DWORD PTR [ecx+92]
	push	eax
	push	DWORD PTR [esi+4]
	push	edi
	call	?_Umove@?$vector@Ushadow@CLightShadows@@V?$xalloc@Ushadow@CLightShadows@@@@@std@@AAEPAUshadow@CLightShadows@@PAU34@00@Z ; std::vector<CLightShadows::shadow,xalloc<CLightShadows::shadow> >::_Umove
$LN5@Emplace_re:
	mov	DWORD PTR __$EHRec$[ebp+12], -1

; 1732 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN50@Emplace_re
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	push	eax
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN50@Emplace_re:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1737 :         _Myfirst = _Newvec;

	mov	DWORD PTR [esi], ebx

; 1738 :         _Mylast  = _Newvec + _Newsize;

	imul	ecx, DWORD PTR __Newsize$1$[ebp], 92
	add	ecx, ebx
	mov	DWORD PTR [esi+4], ecx

; 1739 :         _Myend   = _Newvec + _Newcapacity;

	imul	ecx, DWORD PTR __Newcapacity$1$[ebp], 92
	add	ecx, ebx
	mov	DWORD PTR [esi+8], ecx

; 790  :         _CATCH_END
; 791  : 
; 792  :         _Change_array(_Newvec, _Newsize, _Newcapacity);
; 793  :         return _Newvec + _Whereoff;

	mov	eax, DWORD PTR tv460[ebp]

; 794  :     }

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
__catch$??$_Emplace_reallocate@Ushadow@CLightShadows@@@?$vector@Ushadow@CLightShadows@@V?$xalloc@Ushadow@CLightShadows@@@@@std@@QAEPAUshadow@CLightShadows@@QAU23@$$QAU23@@Z$0:

; 785  :         }
; 786  :         _CATCH_ALL
; 787  :         _Destroy(_Constructed_first, _Constructed_last);
; 788  :         _Al.deallocate(_Newvec, _Newcapacity);

	push	ecx
	push	DWORD PTR __Newvec$[ebp]
	call	?deallocate@?$xalloc@Ushadow@CLightShadows@@@@QBEXPAUshadow@CLightShadows@@I@Z ; xalloc<CLightShadows::shadow>::deallocate

; 789  :         _RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$LN59@Emplace_re:

; 765  :             _Xlength();

	call	?_Xlength@?$vector@Ushadow@CLightShadows@@V?$xalloc@Ushadow@CLightShadows@@@@@std@@CAXXZ ; std::vector<CLightShadows::shadow,xalloc<CLightShadows::shadow> >::_Xlength
$LN56@Emplace_re:
	int	3
	int	3
	int	3
	int	3
	int	3
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Emplace_reallocate@Ushadow@CLightShadows@@@?$vector@Ushadow@CLightShadows@@V?$xalloc@Ushadow@CLightShadows@@@@@std@@QAEPAUshadow@CLightShadows@@QAU23@$$QAU23@@Z:
	npad	1
	npad	1
	mov	eax, OFFSET __ehfuncinfo$??$_Emplace_reallocate@Ushadow@CLightShadows@@@?$vector@Ushadow@CLightShadows@@V?$xalloc@Ushadow@CLightShadows@@@@@std@@QAEPAUshadow@CLightShadows@@QAU23@$$QAU23@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Emplace_reallocate@Ushadow@CLightShadows@@@?$vector@Ushadow@CLightShadows@@V?$xalloc@Ushadow@CLightShadows@@@@@std@@QAEPAUshadow@CLightShadows@@QAU23@$$QAU23@@Z ENDP ; std::vector<CLightShadows::shadow,xalloc<CLightShadows::shadow> >::_Emplace_reallocate<CLightShadows::shadow>
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef
;	COMDAT ??$_Unfancy@PAUcaster@CLightShadows@@@std@@YAPAPAUcaster@CLightShadows@@PAPAU12@@Z
_TEXT	SEGMENT
??$_Unfancy@PAUcaster@CLightShadows@@@std@@YAPAPAUcaster@CLightShadows@@PAPAU12@@Z PROC ; std::_Unfancy<CLightShadows::caster *>, COMDAT
; __Ptr$ = ecx

; 266  :     return _Ptr;

	mov	eax, ecx

; 267  : }

	ret	0
??$_Unfancy@PAUcaster@CLightShadows@@@std@@YAPAPAUcaster@CLightShadows@@PAPAU12@@Z ENDP ; std::_Unfancy<CLightShadows::caster *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$destroy@PAUcaster@CLightShadows@@@?$_Normal_allocator_traits@V?$xalloc@PAUcaster@CLightShadows@@@@@std@@SAXAAV?$xalloc@PAUcaster@CLightShadows@@@@PAPAUcaster@CLightShadows@@@Z
_TEXT	SEGMENT
??$destroy@PAUcaster@CLightShadows@@@?$_Normal_allocator_traits@V?$xalloc@PAUcaster@CLightShadows@@@@@std@@SAXAAV?$xalloc@PAUcaster@CLightShadows@@@@PAPAUcaster@CLightShadows@@@Z PROC ; std::_Normal_allocator_traits<xalloc<CLightShadows::caster *> >::destroy<CLightShadows::caster *>, COMDAT
; __Al$dead$ = ecx
; __Ptr$dead$ = edx

; 579  :         if constexpr (_Uses_default_destroy<_Alloc, _Ty*>::value) {
; 580  : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 581  :             _STD destroy_at(_Ptr);
; 582  : #else // __cpp_lib_constexpr_dynamic_alloc
; 583  :             _Ptr->~_Ty();
; 584  : #endif // __cpp_lib_constexpr_dynamic_alloc
; 585  :         } else {
; 586  :             _Al.destroy(_Ptr);
; 587  :         }
; 588  :     }

	ret	0
??$destroy@PAUcaster@CLightShadows@@@?$_Normal_allocator_traits@V?$xalloc@PAUcaster@CLightShadows@@@@@std@@SAXAAV?$xalloc@PAUcaster@CLightShadows@@@@PAPAUcaster@CLightShadows@@@Z ENDP ; std::_Normal_allocator_traits<xalloc<CLightShadows::caster *> >::destroy<CLightShadows::caster *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\type_traits
;	COMDAT ??$forward@ABQAUcaster@CLightShadows@@@std@@YAABQAUcaster@CLightShadows@@ABQAU12@@Z
_TEXT	SEGMENT
??$forward@ABQAUcaster@CLightShadows@@@std@@YAABQAUcaster@CLightShadows@@ABQAU12@@Z PROC ; std::forward<CLightShadows::caster * const &>, COMDAT
; __Arg$ = ecx

; 1386 :     return static_cast<_Ty&&>(_Arg);

	mov	eax, ecx

; 1387 : }

	ret	0
??$forward@ABQAUcaster@CLightShadows@@@std@@YAABQAUcaster@CLightShadows@@ABQAU12@@Z ENDP ; std::forward<CLightShadows::caster * const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$construct@PAUcaster@CLightShadows@@ABQAU12@@?$_Normal_allocator_traits@V?$xalloc@PAUcaster@CLightShadows@@@@@std@@SAXAAV?$xalloc@PAUcaster@CLightShadows@@@@PAPAUcaster@CLightShadows@@ABQAU34@@Z
_TEXT	SEGMENT
_<_Args_0>$ = 8						; size = 4
??$construct@PAUcaster@CLightShadows@@ABQAU12@@?$_Normal_allocator_traits@V?$xalloc@PAUcaster@CLightShadows@@@@@std@@SAXAAV?$xalloc@PAUcaster@CLightShadows@@@@PAPAUcaster@CLightShadows@@ABQAU34@@Z PROC ; std::_Normal_allocator_traits<xalloc<CLightShadows::caster *> >::construct<CLightShadows::caster *,CLightShadows::caster * const &>, COMDAT
; __Al$dead$ = ecx
; __Ptr$ = edx

; 565  :         if constexpr (_Uses_default_construct<_Alloc, _Ty*, _Types...>::value) {
; 566  :             (void) _Al; // TRANSITION, DevCom-1004719
; 567  : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 568  :             _STD construct_at(_Ptr, _STD forward<_Types>(_Args)...);
; 569  : #else // __cpp_lib_constexpr_dynamic_alloc
; 570  :             ::new (static_cast<void*>(_Ptr)) _Ty(_STD forward<_Types>(_Args)...);
; 571  : #endif // __cpp_lib_constexpr_dynamic_alloc
; 572  :         } else {
; 573  :             _Al.construct(_Ptr, _STD forward<_Types>(_Args)...);

	mov	eax, DWORD PTR _<_Args_0>$[esp-4]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edx], eax

; 574  :         }
; 575  :     }

	ret	0
??$construct@PAUcaster@CLightShadows@@ABQAU12@@?$_Normal_allocator_traits@V?$xalloc@PAUcaster@CLightShadows@@@@@std@@SAXAAV?$xalloc@PAUcaster@CLightShadows@@@@PAPAUcaster@CLightShadows@@ABQAU34@@Z ENDP ; std::_Normal_allocator_traits<xalloc<CLightShadows::caster *> >::construct<CLightShadows::caster *,CLightShadows::caster * const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??$_Emplace_reallocate@ABQAUcaster@CLightShadows@@@?$vector@PAUcaster@CLightShadows@@V?$xalloc@PAUcaster@CLightShadows@@@@@std@@QAEPAPAUcaster@CLightShadows@@QAPAU23@ABQAU23@@Z
_TEXT	SEGMENT
__Backout$2 = -76					; size = 12
__Backout$3 = -64					; size = 12
__Backout$4 = -52					; size = 12
__UFirst$5 = -40					; size = 4
__UFirst$6 = -36					; size = 4
__UFirst$7 = -32					; size = 4
__Newvec$ = -28						; size = 4
__Newcapacity$1$ = -24					; size = 4
__Newsize$1$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
tv555 = 8						; size = 4
__Whereptr$ = 8						; size = 4
_<_Val_0>$ = 12						; size = 4
??$_Emplace_reallocate@ABQAUcaster@CLightShadows@@@?$vector@PAUcaster@CLightShadows@@V?$xalloc@PAUcaster@CLightShadows@@@@@std@@QAEPAPAUcaster@CLightShadows@@QAPAU23@ABQAU23@@Z PROC ; std::vector<CLightShadows::caster *,xalloc<CLightShadows::caster *> >::_Emplace_reallocate<CLightShadows::caster * const &>, COMDAT
; _this$ = ecx

; 752  :     _CONSTEXPR20_CONTAINER pointer _Emplace_reallocate(const pointer _Whereptr, _Valty&&... _Val) {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Emplace_reallocate@ABQAUcaster@CLightShadows@@@?$vector@PAUcaster@CLightShadows@@V?$xalloc@PAUcaster@CLightShadows@@@@@std@@QAEPAPAUcaster@CLightShadows@@QAPAU23@ABQAU23@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	edi, ecx

; 753  :         // reallocate and insert by perfectly forwarding _Val at _Whereptr
; 754  :         _Alty& _Al        = _Getal();
; 755  :         auto& _My_data    = _Mypair._Myval2;
; 756  :         pointer& _Myfirst = _My_data._Myfirst;
; 757  :         pointer& _Mylast  = _My_data._Mylast;
; 758  : 
; 759  :         _STL_INTERNAL_CHECK(_Mylast == _My_data._Myend); // check that we have no unused capacity
; 760  : 
; 761  :         const auto _Whereoff = static_cast<size_type>(_Whereptr - _Myfirst);

	mov	edx, DWORD PTR [edi]
	mov	esi, DWORD PTR __Whereptr$[ebp]
	mov	ebx, esi
	sub	ebx, edx
	sar	ebx, 2

; 762  :         const auto _Oldsize  = static_cast<size_type>(_Mylast - _Myfirst);

	mov	eax, DWORD PTR [edi+4]
	sub	eax, edx
	sar	eax, 2

; 763  : 
; 764  :         if (_Oldsize == max_size()) {

	cmp	eax, 1073741823				; 3fffffffH
	je	$LN83@Emplace_re

; 766  :         }
; 767  : 
; 768  :         const size_type _Newsize     = _Oldsize + 1;

	inc	eax
	mov	DWORD PTR __Newsize$1$[ebp], eax

; 1546 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	ecx, DWORD PTR [edi+8]
	sub	ecx, edx
	sar	ecx, 2

; 1675 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	edx, ecx
	shr	edx, 1
	mov	eax, 1073741823				; 3fffffffH
	sub	eax, edx
	cmp	ecx, eax
	jbe	SHORT $LN12@Emplace_re

; 1676 :             return _Max; // geometric growth would overflow

	mov	eax, 1073741823				; 3fffffffH
	jmp	SHORT $LN81@Emplace_re
$LN12@Emplace_re:

; 1677 :         }
; 1678 : 
; 1679 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	lea	eax, DWORD PTR [edx+ecx]

; 1680 : 
; 1681 :         if (_Geometric < _Newsize) {

	cmp	eax, DWORD PTR __Newsize$1$[ebp]
	cmovb	eax, DWORD PTR __Newsize$1$[ebp]
$LN81@Emplace_re:
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	mov	DWORD PTR __Newcapacity$1$[ebp], eax
	shl	eax, 2
	push	eax
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 771  :         const pointer _Newvec           = _Al.allocate(_Newcapacity);

	mov	edx, eax
	mov	DWORD PTR __Newvec$[ebp], edx

; 772  :         const pointer _Constructed_last = _Newvec + _Whereoff + 1;
; 773  :         pointer _Constructed_first      = _Constructed_last;
; 774  : 
; 775  :         _TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 776  :         _Alty_traits::construct(_Al, _Unfancy(_Newvec + _Whereoff), _STD forward<_Valty>(_Val)...);

	lea	ecx, DWORD PTR [edx+ebx*4]
	mov	DWORD PTR tv555[ebp], ecx
	mov	eax, DWORD PTR _<_Val_0>$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax

; 777  :         _Constructed_first = _Newvec + _Whereoff;
; 778  : 
; 779  :         if (_Whereptr == _Mylast) { // at back, provide strong guarantee

	mov	ebx, DWORD PTR [edi+4]
	mov	ecx, DWORD PTR [edi]
	cmp	esi, ebx
	jne	SHORT $LN4@Emplace_re
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1703 :     auto _UFirst      = _Get_unwrapped(_First);

	mov	DWORD PTR __UFirst$7[ebp], ecx

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	DWORD PTR __Backout$4[ebp], edx
	mov	DWORD PTR __Backout$4[ebp+4], edx
	mov	DWORD PTR __Backout$4[ebp+8], edi
	npad	1
$LL28@Emplace_re:

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	ecx, ebx
	je	SHORT $LN27@Emplace_re

; 1620 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax

; 1621 :         ++_Last;

	add	edx, 4
	mov	DWORD PTR __Backout$4[ebp+4], edx

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	add	ecx, 4
	mov	DWORD PTR __UFirst$7[ebp], ecx
	jmp	SHORT $LL28@Emplace_re
$LN27@Emplace_re:

; 1625 :         _First = _Last;

	mov	DWORD PTR __Backout$4[ebp], edx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 781  :         } else { // provide basic guarantee

	mov	ebx, DWORD PTR tv555[ebp]
	jmp	SHORT $LN5@Emplace_re
$LN4@Emplace_re:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1703 :     auto _UFirst      = _Get_unwrapped(_First);

	mov	DWORD PTR __UFirst$6[ebp], ecx

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	DWORD PTR __Backout$3[ebp], edx
	mov	DWORD PTR __Backout$3[ebp+4], edx
	mov	DWORD PTR __Backout$3[ebp+8], edi
	npad	6
$LL41@Emplace_re:

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	ecx, esi
	je	SHORT $LN40@Emplace_re

; 1620 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax

; 1621 :         ++_Last;

	add	edx, 4
	mov	DWORD PTR __Backout$3[ebp+4], edx

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	add	ecx, 4
	mov	DWORD PTR __UFirst$6[ebp], ecx
	jmp	SHORT $LL41@Emplace_re
$LN40@Emplace_re:

; 1625 :         _First = _Last;

	mov	DWORD PTR __Backout$3[ebp], edx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 784  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

	mov	ebx, DWORD PTR tv555[ebp]
	lea	ecx, DWORD PTR [ebx+4]

; 1646 :         return _Uninitialized_move(_First, _Last, _Dest, _Getal());

	mov	edx, DWORD PTR [edi+4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1703 :     auto _UFirst      = _Get_unwrapped(_First);

	mov	DWORD PTR __UFirst$5[ebp], esi

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	DWORD PTR __Backout$2[ebp], ecx
	mov	DWORD PTR __Backout$2[ebp+4], ecx
	mov	DWORD PTR __Backout$2[ebp+8], edi
	npad	2
$LL54@Emplace_re:

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	esi, edx
	je	SHORT $LN53@Emplace_re

; 1620 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [ecx], eax

; 1621 :         ++_Last;

	add	ecx, 4
	mov	DWORD PTR __Backout$2[ebp+4], ecx

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	add	esi, 4
	mov	DWORD PTR __UFirst$5[ebp], esi
	jmp	SHORT $LL54@Emplace_re
$LN53@Emplace_re:

; 1625 :         _First = _Last;

	mov	DWORD PTR __Backout$2[ebp], ecx
$LN5@Emplace_re:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
	mov	DWORD PTR __$EHRec$[ebp+12], -1

; 1732 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [edi]
	test	eax, eax
	je	SHORT $LN68@Emplace_re
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	push	eax
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN68@Emplace_re:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1737 :         _Myfirst = _Newvec;

	mov	eax, DWORD PTR __Newvec$[ebp]
	mov	DWORD PTR [edi], eax

; 1738 :         _Mylast  = _Newvec + _Newsize;

	mov	ecx, DWORD PTR __Newsize$1$[ebp]
	lea	ecx, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR [edi+4], ecx

; 1739 :         _Myend   = _Newvec + _Newcapacity;

	mov	ecx, DWORD PTR __Newcapacity$1$[ebp]
	lea	ecx, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR [edi+8], ecx

; 790  :         _CATCH_END
; 791  : 
; 792  :         _Change_array(_Newvec, _Newsize, _Newcapacity);
; 793  :         return _Newvec + _Whereoff;

	mov	eax, ebx

; 794  :     }

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
__catch$??$_Emplace_reallocate@ABQAUcaster@CLightShadows@@@?$vector@PAUcaster@CLightShadows@@V?$xalloc@PAUcaster@CLightShadows@@@@@std@@QAEPAPAUcaster@CLightShadows@@QAPAU23@ABQAU23@@Z$0:

; 785  :         }
; 786  :         _CATCH_ALL
; 787  :         _Destroy(_Constructed_first, _Constructed_last);
; 788  :         _Al.deallocate(_Newvec, _Newcapacity);

	push	ecx
	push	DWORD PTR __Newvec$[ebp]
	call	?deallocate@?$xalloc@PAUcaster@CLightShadows@@@@QBEXPAPAUcaster@CLightShadows@@I@Z ; xalloc<CLightShadows::caster *>::deallocate

; 789  :         _RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$LN83@Emplace_re:

; 765  :             _Xlength();

	call	?_Xlength@?$vector@PAUcaster@CLightShadows@@V?$xalloc@PAUcaster@CLightShadows@@@@@std@@CAXXZ ; std::vector<CLightShadows::caster *,xalloc<CLightShadows::caster *> >::_Xlength
$LN80@Emplace_re:
	int	3
	int	3
	int	3
	int	3
	int	3
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Emplace_reallocate@ABQAUcaster@CLightShadows@@@?$vector@PAUcaster@CLightShadows@@V?$xalloc@PAUcaster@CLightShadows@@@@@std@@QAEPAPAUcaster@CLightShadows@@QAPAU23@ABQAU23@@Z:
	npad	1
	npad	1
	mov	eax, OFFSET __ehfuncinfo$??$_Emplace_reallocate@ABQAUcaster@CLightShadows@@@?$vector@PAUcaster@CLightShadows@@V?$xalloc@PAUcaster@CLightShadows@@@@@std@@QAEPAPAUcaster@CLightShadows@@QAPAU23@ABQAU23@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Emplace_reallocate@ABQAUcaster@CLightShadows@@@?$vector@PAUcaster@CLightShadows@@V?$xalloc@PAUcaster@CLightShadows@@@@@std@@QAEPAPAUcaster@CLightShadows@@QAPAU23@ABQAU23@@Z ENDP ; std::vector<CLightShadows::caster *,xalloc<CLightShadows::caster *> >::_Emplace_reallocate<CLightShadows::caster * const &>
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$construct@U_MatrixItem@R_dsgraph@@ABU12@@?$_Normal_allocator_traits@V?$xalloc@U_MatrixItem@R_dsgraph@@@@@std@@SAXAAV?$xalloc@U_MatrixItem@R_dsgraph@@@@PAU_MatrixItem@R_dsgraph@@ABU34@@Z
_TEXT	SEGMENT
_<_Args_0>$ = 8						; size = 4
??$construct@U_MatrixItem@R_dsgraph@@ABU12@@?$_Normal_allocator_traits@V?$xalloc@U_MatrixItem@R_dsgraph@@@@@std@@SAXAAV?$xalloc@U_MatrixItem@R_dsgraph@@@@PAU_MatrixItem@R_dsgraph@@ABU34@@Z PROC ; std::_Normal_allocator_traits<xalloc<R_dsgraph::_MatrixItem> >::construct<R_dsgraph::_MatrixItem,R_dsgraph::_MatrixItem const &>, COMDAT
; __Al$dead$ = ecx
; __Ptr$ = edx

; 564  :     static _CONSTEXPR20_DYNALLOC void construct(_Alloc& _Al, _Ty* _Ptr, _Types&&... _Args) {

	push	esi
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	esi, DWORD PTR _<_Args_0>$[esp]
	mov	ecx, 19					; 00000013H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 564  :     static _CONSTEXPR20_DYNALLOC void construct(_Alloc& _Al, _Ty* _Ptr, _Types&&... _Args) {

	push	edi
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	edi, edx
	rep movsd
	pop	edi
	pop	esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 575  :     }

	ret	0
??$construct@U_MatrixItem@R_dsgraph@@ABU12@@?$_Normal_allocator_traits@V?$xalloc@U_MatrixItem@R_dsgraph@@@@@std@@SAXAAV?$xalloc@U_MatrixItem@R_dsgraph@@@@PAU_MatrixItem@R_dsgraph@@ABU34@@Z ENDP ; std::_Normal_allocator_traits<xalloc<R_dsgraph::_MatrixItem> >::construct<R_dsgraph::_MatrixItem,R_dsgraph::_MatrixItem const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??$_Emplace_reallocate@ABU_MatrixItem@R_dsgraph@@@?$vector@U_MatrixItem@R_dsgraph@@V?$xalloc@U_MatrixItem@R_dsgraph@@@@@std@@QAEPAU_MatrixItem@R_dsgraph@@QAU23@ABU23@@Z
_TEXT	SEGMENT
__Backout$2 = -48					; size = 12
__Oldsize$1$ = -36					; size = 4
__UFirst$3 = -32					; size = 4
__Newvec$ = -28						; size = 4
__Newcapacity$1$ = -24					; size = 4
tv474 = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Whereptr$ = 8						; size = 4
__ULast$1$ = 12						; size = 4
_<_Val_0>$ = 12						; size = 4
??$_Emplace_reallocate@ABU_MatrixItem@R_dsgraph@@@?$vector@U_MatrixItem@R_dsgraph@@V?$xalloc@U_MatrixItem@R_dsgraph@@@@@std@@QAEPAU_MatrixItem@R_dsgraph@@QAU23@ABU23@@Z PROC ; std::vector<R_dsgraph::_MatrixItem,xalloc<R_dsgraph::_MatrixItem> >::_Emplace_reallocate<R_dsgraph::_MatrixItem const &>, COMDAT
; _this$ = ecx

; 752  :     _CONSTEXPR20_CONTAINER pointer _Emplace_reallocate(const pointer _Whereptr, _Valty&&... _Val) {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Emplace_reallocate@ABU_MatrixItem@R_dsgraph@@@?$vector@U_MatrixItem@R_dsgraph@@V?$xalloc@U_MatrixItem@R_dsgraph@@@@@std@@QAEPAU_MatrixItem@R_dsgraph@@QAU23@ABU23@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 36					; 00000024H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	ebx, ecx

; 753  :         // reallocate and insert by perfectly forwarding _Val at _Whereptr
; 754  :         _Alty& _Al        = _Getal();
; 755  :         auto& _My_data    = _Mypair._Myval2;
; 756  :         pointer& _Myfirst = _My_data._Myfirst;
; 757  :         pointer& _Mylast  = _My_data._Mylast;
; 758  : 
; 759  :         _STL_INTERNAL_CHECK(_Mylast == _My_data._Myend); // check that we have no unused capacity
; 760  : 
; 761  :         const auto _Whereoff = static_cast<size_type>(_Whereptr - _Myfirst);

	mov	ecx, DWORD PTR [ebx]
	mov	edx, DWORD PTR __Whereptr$[ebp]
	sub	edx, ecx
	mov	eax, 1808407283				; 6bca1af3H
	imul	edx
	sar	edx, 5
	mov	esi, edx
	shr	esi, 31					; 0000001fH
	add	esi, edx

; 762  :         const auto _Oldsize  = static_cast<size_type>(_Mylast - _Myfirst);

	mov	eax, DWORD PTR [ebx+4]
	sub	eax, ecx
	sar	eax, 2
	imul	eax, eax, 678152731
	mov	DWORD PTR __Oldsize$1$[ebp], eax

; 763  : 
; 764  :         if (_Oldsize == max_size()) {

	cmp	eax, 56512727				; 035e50d7H
	je	$LN59@Emplace_re

; 766  :         }
; 767  : 
; 768  :         const size_type _Newsize     = _Oldsize + 1;

	lea	edi, DWORD PTR [eax+1]

; 1546 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	eax, DWORD PTR [ebx+8]
	sub	eax, ecx
	sar	eax, 2
	imul	edx, eax, 678152731

; 1675 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	ecx, edx
	shr	ecx, 1
	mov	eax, 56512727				; 035e50d7H
	sub	eax, ecx
	cmp	edx, eax
	jbe	SHORT $LN12@Emplace_re

; 1676 :             return _Max; // geometric growth would overflow

	mov	eax, 56512727				; 035e50d7H
	jmp	SHORT $LN57@Emplace_re
$LN12@Emplace_re:

; 1677 :         }
; 1678 : 
; 1679 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	lea	eax, DWORD PTR [ecx+edx]

; 1680 : 
; 1681 :         if (_Geometric < _Newsize) {

	cmp	eax, edi
	cmovb	eax, edi
$LN57@Emplace_re:
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	mov	DWORD PTR __Newcapacity$1$[ebp], eax
	imul	eax, eax, 76
	push	eax
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 771  :         const pointer _Newvec           = _Al.allocate(_Newcapacity);

	mov	edx, eax
	mov	DWORD PTR __Newvec$[ebp], edx

; 772  :         const pointer _Constructed_last = _Newvec + _Whereoff + 1;
; 773  :         pointer _Constructed_first      = _Constructed_last;
; 774  : 
; 775  :         _TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 776  :         _Alty_traits::construct(_Al, _Unfancy(_Newvec + _Whereoff), _STD forward<_Valty>(_Val)...);

	imul	eax, esi, 76
	add	eax, edx
	mov	DWORD PTR tv474[ebp], eax
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	ecx, 19					; 00000013H
	mov	esi, DWORD PTR _<_Val_0>$[ebp]
	mov	edi, eax
	rep movsd
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 779  :         if (_Whereptr == _Mylast) { // at back, provide strong guarantee

	mov	ecx, DWORD PTR [ebx+4]
	mov	DWORD PTR __ULast$1$[ebp], ecx
	mov	eax, DWORD PTR [ebx]
	mov	esi, DWORD PTR __Whereptr$[ebp]
	cmp	esi, ecx
	jne	SHORT $LN4@Emplace_re
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1703 :     auto _UFirst      = _Get_unwrapped(_First);

	mov	DWORD PTR __UFirst$3[ebp], eax

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	DWORD PTR __Backout$2[ebp], edx
	mov	DWORD PTR __Backout$2[ebp+4], edx
	mov	DWORD PTR __Backout$2[ebp+8], ebx
$LL32@Emplace_re:

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	eax, ecx
	je	SHORT $LN31@Emplace_re
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	ecx, 19					; 00000013H
	mov	esi, eax
	mov	edi, edx
	rep movsd
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1621 :         ++_Last;

	add	edx, 76					; 0000004cH
	mov	DWORD PTR __Backout$2[ebp+4], edx

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	add	eax, 76					; 0000004cH
	mov	DWORD PTR __UFirst$3[ebp], eax
	mov	ecx, DWORD PTR __ULast$1$[ebp]
	jmp	SHORT $LL32@Emplace_re
$LN31@Emplace_re:

; 1625 :         _First = _Last;

	mov	DWORD PTR __Backout$2[ebp], edx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 781  :         } else { // provide basic guarantee

	mov	edi, DWORD PTR tv474[ebp]
	jmp	SHORT $LN5@Emplace_re
$LN4@Emplace_re:

; 782  :             _Umove(_Myfirst, _Whereptr, _Newvec);

	push	edx
	push	esi
	push	eax
	call	?_Umove@?$vector@U_MatrixItem@R_dsgraph@@V?$xalloc@U_MatrixItem@R_dsgraph@@@@@std@@AAEPAU_MatrixItem@R_dsgraph@@PAU34@00@Z ; std::vector<R_dsgraph::_MatrixItem,xalloc<R_dsgraph::_MatrixItem> >::_Umove

; 783  :             _Constructed_first = _Newvec;
; 784  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

	mov	edi, DWORD PTR tv474[ebp]
	lea	eax, DWORD PTR [edi+76]
	push	eax
	push	DWORD PTR [ebx+4]
	push	esi
	call	?_Umove@?$vector@U_MatrixItem@R_dsgraph@@V?$xalloc@U_MatrixItem@R_dsgraph@@@@@std@@AAEPAU_MatrixItem@R_dsgraph@@PAU34@00@Z ; std::vector<R_dsgraph::_MatrixItem,xalloc<R_dsgraph::_MatrixItem> >::_Umove
$LN5@Emplace_re:
	mov	DWORD PTR __$EHRec$[ebp+12], -1

; 1732 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [ebx]
	test	eax, eax
	je	SHORT $LN50@Emplace_re
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	push	eax
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN50@Emplace_re:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1737 :         _Myfirst = _Newvec;

	mov	eax, DWORD PTR __Newvec$[ebp]
	mov	DWORD PTR [ebx], eax

; 1738 :         _Mylast  = _Newvec + _Newsize;

	mov	ecx, DWORD PTR __Oldsize$1$[ebp]
	inc	ecx
	imul	ecx, ecx, 76
	add	ecx, eax
	mov	DWORD PTR [ebx+4], ecx

; 1739 :         _Myend   = _Newvec + _Newcapacity;

	imul	ecx, DWORD PTR __Newcapacity$1$[ebp], 76
	add	ecx, eax
	mov	DWORD PTR [ebx+8], ecx

; 790  :         _CATCH_END
; 791  : 
; 792  :         _Change_array(_Newvec, _Newsize, _Newcapacity);
; 793  :         return _Newvec + _Whereoff;

	mov	eax, edi

; 794  :     }

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
__catch$??$_Emplace_reallocate@ABU_MatrixItem@R_dsgraph@@@?$vector@U_MatrixItem@R_dsgraph@@V?$xalloc@U_MatrixItem@R_dsgraph@@@@@std@@QAEPAU_MatrixItem@R_dsgraph@@QAU23@ABU23@@Z$0:

; 785  :         }
; 786  :         _CATCH_ALL
; 787  :         _Destroy(_Constructed_first, _Constructed_last);
; 788  :         _Al.deallocate(_Newvec, _Newcapacity);

	push	ecx
	push	DWORD PTR __Newvec$[ebp]
	call	?deallocate@?$xalloc@U_MatrixItem@R_dsgraph@@@@QBEXPAU_MatrixItem@R_dsgraph@@I@Z ; xalloc<R_dsgraph::_MatrixItem>::deallocate

; 789  :         _RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$LN59@Emplace_re:

; 765  :             _Xlength();

	call	?_Xlength@?$vector@U_MatrixItem@R_dsgraph@@V?$xalloc@U_MatrixItem@R_dsgraph@@@@@std@@CAXXZ ; std::vector<R_dsgraph::_MatrixItem,xalloc<R_dsgraph::_MatrixItem> >::_Xlength
$LN56@Emplace_re:
	int	3
	int	3
	int	3
	int	3
	int	3
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Emplace_reallocate@ABU_MatrixItem@R_dsgraph@@@?$vector@U_MatrixItem@R_dsgraph@@V?$xalloc@U_MatrixItem@R_dsgraph@@@@@std@@QAEPAU_MatrixItem@R_dsgraph@@QAU23@ABU23@@Z:
	npad	1
	npad	1
	mov	eax, OFFSET __ehfuncinfo$??$_Emplace_reallocate@ABU_MatrixItem@R_dsgraph@@@?$vector@U_MatrixItem@R_dsgraph@@V?$xalloc@U_MatrixItem@R_dsgraph@@@@@std@@QAEPAU_MatrixItem@R_dsgraph@@QAU23@ABU23@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Emplace_reallocate@ABU_MatrixItem@R_dsgraph@@@?$vector@U_MatrixItem@R_dsgraph@@V?$xalloc@U_MatrixItem@R_dsgraph@@@@@std@@QAEPAU_MatrixItem@R_dsgraph@@QAU23@ABU23@@Z ENDP ; std::vector<R_dsgraph::_MatrixItem,xalloc<R_dsgraph::_MatrixItem> >::_Emplace_reallocate<R_dsgraph::_MatrixItem const &>
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$?0$$V@?$_Compressed_pair@V?$xalloc@Ucache_item@CLightShadows@@@@V?$_Vector_val@U?$_Simple_types@Ucache_item@CLightShadows@@@std@@@std@@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$?0$$V@?$_Compressed_pair@V?$xalloc@Ucache_item@CLightShadows@@@@V?$_Vector_val@U?$_Simple_types@Ucache_item@CLightShadows@@@std@@@std@@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<xalloc<CLightShadows::cache_item>,std::_Vector_val<std::_Simple_types<CLightShadows::cache_item> >,1>::_Compressed_pair<xalloc<CLightShadows::cache_item>,std::_Vector_val<std::_Simple_types<CLightShadows::cache_item> >,1><>, COMDAT
; _this$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1331 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	eax, ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1331 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	ret	4
??$?0$$V@?$_Compressed_pair@V?$xalloc@Ucache_item@CLightShadows@@@@V?$_Vector_val@U?$_Simple_types@Ucache_item@CLightShadows@@@std@@@std@@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<xalloc<CLightShadows::cache_item>,std::_Vector_val<std::_Simple_types<CLightShadows::cache_item> >,1>::_Compressed_pair<xalloc<CLightShadows::cache_item>,std::_Vector_val<std::_Simple_types<CLightShadows::cache_item> >,1><>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$?0$$V@?$_Compressed_pair@V?$xalloc@Utess_tri@CLightShadows@@@@V?$_Vector_val@U?$_Simple_types@Utess_tri@CLightShadows@@@std@@@std@@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$?0$$V@?$_Compressed_pair@V?$xalloc@Utess_tri@CLightShadows@@@@V?$_Vector_val@U?$_Simple_types@Utess_tri@CLightShadows@@@std@@@std@@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<xalloc<CLightShadows::tess_tri>,std::_Vector_val<std::_Simple_types<CLightShadows::tess_tri> >,1>::_Compressed_pair<xalloc<CLightShadows::tess_tri>,std::_Vector_val<std::_Simple_types<CLightShadows::tess_tri> >,1><>, COMDAT
; _this$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1331 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	eax, ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1331 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	ret	4
??$?0$$V@?$_Compressed_pair@V?$xalloc@Utess_tri@CLightShadows@@@@V?$_Vector_val@U?$_Simple_types@Utess_tri@CLightShadows@@@std@@@std@@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<xalloc<CLightShadows::tess_tri>,std::_Vector_val<std::_Simple_types<CLightShadows::tess_tri> >,1>::_Compressed_pair<xalloc<CLightShadows::tess_tri>,std::_Vector_val<std::_Simple_types<CLightShadows::tess_tri> >,1><>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef
;	COMDAT ??$addressof@V?$_Vector_val@U?$_Simple_types@Ushadow@CLightShadows@@@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@Ushadow@CLightShadows@@@std@@@0@AAV10@@Z
_TEXT	SEGMENT
??$addressof@V?$_Vector_val@U?$_Simple_types@Ushadow@CLightShadows@@@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@Ushadow@CLightShadows@@@std@@@0@AAV10@@Z PROC ; std::addressof<std::_Vector_val<std::_Simple_types<CLightShadows::shadow> > >, COMDAT
; __Val$ = ecx

; 253  :     return __builtin_addressof(_Val);

	mov	eax, ecx

; 254  : }

	ret	0
??$addressof@V?$_Vector_val@U?$_Simple_types@Ushadow@CLightShadows@@@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@Ushadow@CLightShadows@@@std@@@0@AAV10@@Z ENDP ; std::addressof<std::_Vector_val<std::_Simple_types<CLightShadows::shadow> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$?0$$V@?$_Compressed_pair@V?$xalloc@Ushadow@CLightShadows@@@@V?$_Vector_val@U?$_Simple_types@Ushadow@CLightShadows@@@std@@@std@@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$?0$$V@?$_Compressed_pair@V?$xalloc@Ushadow@CLightShadows@@@@V?$_Vector_val@U?$_Simple_types@Ushadow@CLightShadows@@@std@@@std@@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<xalloc<CLightShadows::shadow>,std::_Vector_val<std::_Simple_types<CLightShadows::shadow> >,1>::_Compressed_pair<xalloc<CLightShadows::shadow>,std::_Vector_val<std::_Simple_types<CLightShadows::shadow> >,1><>, COMDAT
; _this$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1331 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	eax, ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1331 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	ret	4
??$?0$$V@?$_Compressed_pair@V?$xalloc@Ushadow@CLightShadows@@@@V?$_Vector_val@U?$_Simple_types@Ushadow@CLightShadows@@@std@@@std@@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<xalloc<CLightShadows::shadow>,std::_Vector_val<std::_Simple_types<CLightShadows::shadow> >,1>::_Compressed_pair<xalloc<CLightShadows::shadow>,std::_Vector_val<std::_Simple_types<CLightShadows::shadow> >,1><>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef
;	COMDAT ??$addressof@V?$_Vector_val@U?$_Simple_types@PAUcaster@CLightShadows@@@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@PAUcaster@CLightShadows@@@std@@@0@AAV10@@Z
_TEXT	SEGMENT
??$addressof@V?$_Vector_val@U?$_Simple_types@PAUcaster@CLightShadows@@@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@PAUcaster@CLightShadows@@@std@@@0@AAV10@@Z PROC ; std::addressof<std::_Vector_val<std::_Simple_types<CLightShadows::caster *> > >, COMDAT
; __Val$ = ecx

; 253  :     return __builtin_addressof(_Val);

	mov	eax, ecx

; 254  : }

	ret	0
??$addressof@V?$_Vector_val@U?$_Simple_types@PAUcaster@CLightShadows@@@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@PAUcaster@CLightShadows@@@std@@@0@AAV10@@Z ENDP ; std::addressof<std::_Vector_val<std::_Simple_types<CLightShadows::caster *> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$?0$$V@?$_Compressed_pair@V?$xalloc@PAUcaster@CLightShadows@@@@V?$_Vector_val@U?$_Simple_types@PAUcaster@CLightShadows@@@std@@@std@@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$?0$$V@?$_Compressed_pair@V?$xalloc@PAUcaster@CLightShadows@@@@V?$_Vector_val@U?$_Simple_types@PAUcaster@CLightShadows@@@std@@@std@@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<xalloc<CLightShadows::caster *>,std::_Vector_val<std::_Simple_types<CLightShadows::caster *> >,1>::_Compressed_pair<xalloc<CLightShadows::caster *>,std::_Vector_val<std::_Simple_types<CLightShadows::caster *> >,1><>, COMDAT
; _this$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1331 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	eax, ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1331 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	ret	4
??$?0$$V@?$_Compressed_pair@V?$xalloc@PAUcaster@CLightShadows@@@@V?$_Vector_val@U?$_Simple_types@PAUcaster@CLightShadows@@@std@@@std@@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<xalloc<CLightShadows::caster *>,std::_Vector_val<std::_Simple_types<CLightShadows::caster *> >,1>::_Compressed_pair<xalloc<CLightShadows::caster *>,std::_Vector_val<std::_Simple_types<CLightShadows::caster *> >,1><>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Destroy_range@V?$xalloc@Ucache_item@CLightShadows@@@@@std@@YAXPAUcache_item@CLightShadows@@QAU12@AAV?$xalloc@Ucache_item@CLightShadows@@@@@Z
_TEXT	SEGMENT
__Al$dead$ = 8						; size = 4
??$_Destroy_range@V?$xalloc@Ucache_item@CLightShadows@@@@@std@@YAXPAUcache_item@CLightShadows@@QAU12@AAV?$xalloc@Ucache_item@CLightShadows@@@@@Z PROC ; std::_Destroy_range<xalloc<CLightShadows::cache_item> >, COMDAT
; __First$dead$ = ecx
; __Last$dead$ = edx

; 901  :     // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
; 902  :     using _Ty = typename _Alloc::value_type;
; 903  :     if constexpr (!conjunction_v<is_trivially_destructible<_Ty>, _Uses_default_destroy<_Alloc, _Ty*>>) {
; 904  :         for (; _First != _Last; ++_First) {
; 905  :             allocator_traits<_Alloc>::destroy(_Al, _Unfancy(_First));
; 906  :         }
; 907  :     }
; 908  : }

	ret	0
??$_Destroy_range@V?$xalloc@Ucache_item@CLightShadows@@@@@std@@YAXPAUcache_item@CLightShadows@@QAU12@AAV?$xalloc@Ucache_item@CLightShadows@@@@@Z ENDP ; std::_Destroy_range<xalloc<CLightShadows::cache_item> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
;	COMDAT ??$xr_free@Ucache_item@CLightShadows@@@@YAXAAPAUcache_item@CLightShadows@@@Z
_TEXT	SEGMENT
??$xr_free@Ucache_item@CLightShadows@@@@YAXAAPAUcache_item@CLightShadows@@@Z PROC ; xr_free<CLightShadows::cache_item>, COMDAT
; _P$ = ecx

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	push	esi
	mov	esi, ecx
	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN2@xr_free
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
	mov	DWORD PTR [esi], 0
$LN2@xr_free:
	pop	esi
	ret	0
??$xr_free@Ucache_item@CLightShadows@@@@YAXAAPAUcache_item@CLightShadows@@@Z ENDP ; xr_free<CLightShadows::cache_item>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Destroy_range@V?$xalloc@Utess_tri@CLightShadows@@@@@std@@YAXPAUtess_tri@CLightShadows@@QAU12@AAV?$xalloc@Utess_tri@CLightShadows@@@@@Z
_TEXT	SEGMENT
__Al$dead$ = 8						; size = 4
??$_Destroy_range@V?$xalloc@Utess_tri@CLightShadows@@@@@std@@YAXPAUtess_tri@CLightShadows@@QAU12@AAV?$xalloc@Utess_tri@CLightShadows@@@@@Z PROC ; std::_Destroy_range<xalloc<CLightShadows::tess_tri> >, COMDAT
; __First$dead$ = ecx
; __Last$dead$ = edx

; 901  :     // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
; 902  :     using _Ty = typename _Alloc::value_type;
; 903  :     if constexpr (!conjunction_v<is_trivially_destructible<_Ty>, _Uses_default_destroy<_Alloc, _Ty*>>) {
; 904  :         for (; _First != _Last; ++_First) {
; 905  :             allocator_traits<_Alloc>::destroy(_Al, _Unfancy(_First));
; 906  :         }
; 907  :     }
; 908  : }

	ret	0
??$_Destroy_range@V?$xalloc@Utess_tri@CLightShadows@@@@@std@@YAXPAUtess_tri@CLightShadows@@QAU12@AAV?$xalloc@Utess_tri@CLightShadows@@@@@Z ENDP ; std::_Destroy_range<xalloc<CLightShadows::tess_tri> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Destroy_range@V?$xalloc@Ushadow@CLightShadows@@@@@std@@YAXPAUshadow@CLightShadows@@QAU12@AAV?$xalloc@Ushadow@CLightShadows@@@@@Z
_TEXT	SEGMENT
__Al$dead$ = 8						; size = 4
??$_Destroy_range@V?$xalloc@Ushadow@CLightShadows@@@@@std@@YAXPAUshadow@CLightShadows@@QAU12@AAV?$xalloc@Ushadow@CLightShadows@@@@@Z PROC ; std::_Destroy_range<xalloc<CLightShadows::shadow> >, COMDAT
; __First$dead$ = ecx
; __Last$dead$ = edx

; 901  :     // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
; 902  :     using _Ty = typename _Alloc::value_type;
; 903  :     if constexpr (!conjunction_v<is_trivially_destructible<_Ty>, _Uses_default_destroy<_Alloc, _Ty*>>) {
; 904  :         for (; _First != _Last; ++_First) {
; 905  :             allocator_traits<_Alloc>::destroy(_Al, _Unfancy(_First));
; 906  :         }
; 907  :     }
; 908  : }

	ret	0
??$_Destroy_range@V?$xalloc@Ushadow@CLightShadows@@@@@std@@YAXPAUshadow@CLightShadows@@QAU12@AAV?$xalloc@Ushadow@CLightShadows@@@@@Z ENDP ; std::_Destroy_range<xalloc<CLightShadows::shadow> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
;	COMDAT ??$xr_free@Ushadow@CLightShadows@@@@YAXAAPAUshadow@CLightShadows@@@Z
_TEXT	SEGMENT
??$xr_free@Ushadow@CLightShadows@@@@YAXAAPAUshadow@CLightShadows@@@Z PROC ; xr_free<CLightShadows::shadow>, COMDAT
; _P$ = ecx

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	push	esi
	mov	esi, ecx
	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN2@xr_free
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
	mov	DWORD PTR [esi], 0
$LN2@xr_free:
	pop	esi
	ret	0
??$xr_free@Ushadow@CLightShadows@@@@YAXAAPAUshadow@CLightShadows@@@Z ENDP ; xr_free<CLightShadows::shadow>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Destroy_range@V?$xalloc@PAUcaster@CLightShadows@@@@@std@@YAXPAPAUcaster@CLightShadows@@QAPAU12@AAV?$xalloc@PAUcaster@CLightShadows@@@@@Z
_TEXT	SEGMENT
__Al$dead$ = 8						; size = 4
??$_Destroy_range@V?$xalloc@PAUcaster@CLightShadows@@@@@std@@YAXPAPAUcaster@CLightShadows@@QAPAU12@AAV?$xalloc@PAUcaster@CLightShadows@@@@@Z PROC ; std::_Destroy_range<xalloc<CLightShadows::caster *> >, COMDAT
; __First$dead$ = ecx
; __Last$dead$ = edx

; 901  :     // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
; 902  :     using _Ty = typename _Alloc::value_type;
; 903  :     if constexpr (!conjunction_v<is_trivially_destructible<_Ty>, _Uses_default_destroy<_Alloc, _Ty*>>) {
; 904  :         for (; _First != _Last; ++_First) {
; 905  :             allocator_traits<_Alloc>::destroy(_Al, _Unfancy(_First));
; 906  :         }
; 907  :     }
; 908  : }

	ret	0
??$_Destroy_range@V?$xalloc@PAUcaster@CLightShadows@@@@@std@@YAXPAPAUcaster@CLightShadows@@QAPAU12@AAV?$xalloc@PAUcaster@CLightShadows@@@@@Z ENDP ; std::_Destroy_range<xalloc<CLightShadows::caster *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
;	COMDAT ??$xr_free@PAUcaster@CLightShadows@@@@YAXAAPAPAUcaster@CLightShadows@@@Z
_TEXT	SEGMENT
??$xr_free@PAUcaster@CLightShadows@@@@YAXAAPAPAUcaster@CLightShadows@@@Z PROC ; xr_free<CLightShadows::caster *>, COMDAT
; _P$ = ecx

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	push	esi
	mov	esi, ecx
	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN2@xr_free
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
	mov	DWORD PTR [esi], 0
$LN2@xr_free:
	pop	esi
	ret	0
??$xr_free@PAUcaster@CLightShadows@@@@YAXAAPAPAUcaster@CLightShadows@@@Z ENDP ; xr_free<CLightShadows::caster *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Destroy_range@V?$xalloc@U_MatrixItem@R_dsgraph@@@@@std@@YAXPAU_MatrixItem@R_dsgraph@@QAU12@AAV?$xalloc@U_MatrixItem@R_dsgraph@@@@@Z
_TEXT	SEGMENT
__Al$dead$ = 8						; size = 4
??$_Destroy_range@V?$xalloc@U_MatrixItem@R_dsgraph@@@@@std@@YAXPAU_MatrixItem@R_dsgraph@@QAU12@AAV?$xalloc@U_MatrixItem@R_dsgraph@@@@@Z PROC ; std::_Destroy_range<xalloc<R_dsgraph::_MatrixItem> >, COMDAT
; __First$dead$ = ecx
; __Last$dead$ = edx

; 901  :     // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
; 902  :     using _Ty = typename _Alloc::value_type;
; 903  :     if constexpr (!conjunction_v<is_trivially_destructible<_Ty>, _Uses_default_destroy<_Alloc, _Ty*>>) {
; 904  :         for (; _First != _Last; ++_First) {
; 905  :             allocator_traits<_Alloc>::destroy(_Al, _Unfancy(_First));
; 906  :         }
; 907  :     }
; 908  : }

	ret	0
??$_Destroy_range@V?$xalloc@U_MatrixItem@R_dsgraph@@@@@std@@YAXPAU_MatrixItem@R_dsgraph@@QAU12@AAV?$xalloc@U_MatrixItem@R_dsgraph@@@@@Z ENDP ; std::_Destroy_range<xalloc<R_dsgraph::_MatrixItem> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0caster@CLightShadows@@QAE@XZ
_TEXT	SEGMENT
??0caster@CLightShadows@@QAE@XZ PROC			; CLightShadows::caster::caster, COMDAT
; _this$ = ecx

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx+20], 0
	mov	eax, ecx
	mov	DWORD PTR [ecx+24], 0
	mov	DWORD PTR [ecx+28], 0
	ret	0
??0caster@CLightShadows@@QAE@XZ ENDP			; CLightShadows::caster::caster
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??1?$xr_vector@U_MatrixItem@R_dsgraph@@V?$xalloc@U_MatrixItem@R_dsgraph@@@@@@QAE@XZ
_TEXT	SEGMENT
??1?$xr_vector@U_MatrixItem@R_dsgraph@@V?$xalloc@U_MatrixItem@R_dsgraph@@@@@@QAE@XZ PROC ; xr_vector<R_dsgraph::_MatrixItem,xalloc<R_dsgraph::_MatrixItem> >::~xr_vector<R_dsgraph::_MatrixItem,xalloc<R_dsgraph::_MatrixItem> >, COMDAT
; _this$ = ecx

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	push	esi
	mov	esi, ecx
	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN6@xr_vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+4], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+8], 0
$LN6@xr_vector:
	pop	esi
	ret	0
??1?$xr_vector@U_MatrixItem@R_dsgraph@@V?$xalloc@U_MatrixItem@R_dsgraph@@@@@@QAE@XZ ENDP ; xr_vector<R_dsgraph::_MatrixItem,xalloc<R_dsgraph::_MatrixItem> >::~xr_vector<R_dsgraph::_MatrixItem,xalloc<R_dsgraph::_MatrixItem> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??1?$_Alloc_temporary2@V?$xalloc@Ucache_item@CLightShadows@@@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Alloc_temporary2@V?$xalloc@Ucache_item@CLightShadows@@@@@std@@QAE@XZ PROC ; std::_Alloc_temporary2<xalloc<CLightShadows::cache_item> >::~_Alloc_temporary2<xalloc<CLightShadows::cache_item> >, COMDAT
; _this$ = ecx

; 1941 :         _Traits::destroy(_Al, _STD addressof(_Get_value()));
; 1942 :     }

	ret	0
??1?$_Alloc_temporary2@V?$xalloc@Ucache_item@CLightShadows@@@@@std@@QAE@XZ ENDP ; std::_Alloc_temporary2<xalloc<CLightShadows::cache_item> >::~_Alloc_temporary2<xalloc<CLightShadows::cache_item> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Get_value@?$_Alloc_temporary2@V?$xalloc@Ucache_item@CLightShadows@@@@@std@@QAEAAUcache_item@CLightShadows@@XZ
_TEXT	SEGMENT
?_Get_value@?$_Alloc_temporary2@V?$xalloc@Ucache_item@CLightShadows@@@@@std@@QAEAAUcache_item@CLightShadows@@XZ PROC ; std::_Alloc_temporary2<xalloc<CLightShadows::cache_item> >::_Get_value, COMDAT
; _this$ = ecx

; 1922 :         return _Value;

	lea	eax, DWORD PTR [ecx+4]

; 1923 :     }

	ret	0
?_Get_value@?$_Alloc_temporary2@V?$xalloc@Ucache_item@CLightShadows@@@@@std@@QAEAAUcache_item@CLightShadows@@XZ ENDP ; std::_Alloc_temporary2<xalloc<CLightShadows::cache_item> >::_Get_value
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
;	COMDAT ??R?$xr_special_free@$0A@Ucaster@CLightShadows@@@@QAEXAAPAUcaster@CLightShadows@@@Z
_TEXT	SEGMENT
_ptr$ = 8						; size = 4
??R?$xr_special_free@$0A@Ucaster@CLightShadows@@@@QAEXAAPAUcaster@CLightShadows@@@Z PROC ; xr_special_free<0,CLightShadows::caster>::operator(), COMDAT
; _this$dead$ = ecx

; 142  : 	{

	push	ebx
	mov	ebx, DWORD PTR _ptr$[esp]
	push	esi

; 143  : 		ptr->~T			();

	mov	esi, DWORD PTR [ebx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [esi+20]
	test	eax, eax
	je	SHORT $LN13@operator
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi+20], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+24], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+28], 0
	mov	esi, DWORD PTR [ebx]
$LN13@operator:
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h

; 144  : 		Memory.mem_free	(ptr);

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	esi
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
	pop	esi
	pop	ebx

; 145  : 	}

	ret	4
??R?$xr_special_free@$0A@Ucaster@CLightShadows@@@@QAEXAAPAUcaster@CLightShadows@@@Z ENDP ; xr_special_free<0,CLightShadows::caster>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Unwrapped@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@Ucache_item@CLightShadows@@@std@@@std@@@std@@QBEPAUcache_item@CLightShadows@@XZ
_TEXT	SEGMENT
?_Unwrapped@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@Ucache_item@CLightShadows@@@std@@@std@@@std@@QBEPAUcache_item@CLightShadows@@XZ PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CLightShadows::cache_item> > >::_Unwrapped, COMDAT
; _this$ = ecx

; 328  :         return _Unfancy(this->_Ptr);

	mov	eax, DWORD PTR [ecx]

; 329  :     }

	ret	0
?_Unwrapped@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@Ucache_item@CLightShadows@@@std@@@std@@@std@@QBEPAUcache_item@CLightShadows@@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CLightShadows::cache_item> > >::_Unwrapped
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@Ucache_item@CLightShadows@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Vector_val@U?$_Simple_types@Ucache_item@CLightShadows@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<std::_Simple_types<CLightShadows::cache_item> >::_Vector_val<std::_Simple_types<CLightShadows::cache_item> >, COMDAT
; _this$ = ecx

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx], 0
	mov	eax, ecx
	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0
	ret	0
??0?$_Vector_val@U?$_Simple_types@Ucache_item@CLightShadows@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<std::_Simple_types<CLightShadows::cache_item> >::_Vector_val<std::_Simple_types<CLightShadows::cache_item> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Make_iterator@?$vector@Ucache_item@CLightShadows@@V?$xalloc@Ucache_item@CLightShadows@@@@@std@@AAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@Ucache_item@CLightShadows@@@std@@@std@@@2@QAUcache_item@CLightShadows@@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Ptr$ = 12						; size = 4
?_Make_iterator@?$vector@Ucache_item@CLightShadows@@V?$xalloc@Ucache_item@CLightShadows@@@@@std@@AAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@Ucache_item@CLightShadows@@@std@@@std@@@2@QAUcache_item@CLightShadows@@@Z PROC ; std::vector<CLightShadows::cache_item,xalloc<CLightShadows::cache_item> >::_Make_iterator, COMDAT
; _this$dead$ = ecx

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 1813 :         return iterator(_Ptr, _STD addressof(_Mypair._Myval2));
; 1814 :     }

	ret	8
?_Make_iterator@?$vector@Ucache_item@CLightShadows@@V?$xalloc@Ucache_item@CLightShadows@@@@@std@@AAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@Ucache_item@CLightShadows@@@std@@@std@@@2@QAUcache_item@CLightShadows@@@Z ENDP ; std::vector<CLightShadows::cache_item,xalloc<CLightShadows::cache_item> >::_Make_iterator
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?destroy@?$xalloc@Ucache_item@CLightShadows@@@@QAEXPAUcache_item@CLightShadows@@@Z
_TEXT	SEGMENT
_p$dead$ = 8						; size = 4
?destroy@?$xalloc@Ucache_item@CLightShadows@@@@QAEXPAUcache_item@CLightShadows@@@Z PROC ; xalloc<CLightShadows::cache_item>::destroy, COMDAT
; _this$dead$ = ecx

; 85   : 							void					destroy			(pointer p)								{	std::_Destroy_in_place(p);			}

	ret	4
?destroy@?$xalloc@Ucache_item@CLightShadows@@@@QAEXPAUcache_item@CLightShadows@@@Z ENDP ; xalloc<CLightShadows::cache_item>::destroy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ??0?$xalloc@Ucache_item@CLightShadows@@@@QAE@XZ
_TEXT	SEGMENT
??0?$xalloc@Ucache_item@CLightShadows@@@@QAE@XZ PROC	; xalloc<CLightShadows::cache_item>::xalloc<CLightShadows::cache_item>, COMDAT
; _this$ = ecx

; 76   : 													xalloc			()										{	}

	mov	eax, ecx
	ret	0
??0?$xalloc@Ucache_item@CLightShadows@@@@QAE@XZ ENDP	; xalloc<CLightShadows::cache_item>::xalloc<CLightShadows::cache_item>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@Utess_tri@CLightShadows@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Vector_val@U?$_Simple_types@Utess_tri@CLightShadows@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<std::_Simple_types<CLightShadows::tess_tri> >::_Vector_val<std::_Simple_types<CLightShadows::tess_tri> >, COMDAT
; _this$ = ecx

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx], 0
	mov	eax, ecx
	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0
	ret	0
??0?$_Vector_val@U?$_Simple_types@Utess_tri@CLightShadows@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<std::_Simple_types<CLightShadows::tess_tri> >::_Vector_val<std::_Simple_types<CLightShadows::tess_tri> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Xlength@?$vector@Utess_tri@CLightShadows@@V?$xalloc@Utess_tri@CLightShadows@@@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@Utess_tri@CLightShadows@@V?$xalloc@Utess_tri@CLightShadows@@@@@std@@CAXXZ PROC ; std::vector<CLightShadows::tess_tri,xalloc<CLightShadows::tess_tri> >::_Xlength, COMDAT

; 1761 :         _Xlength_error("vector too long");

	push	OFFSET ??_C@_0BA@FOIKENOD@vector?5too?5long@
	call	DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN3@Xlength:
	int	3
?_Xlength@?$vector@Utess_tri@CLightShadows@@V?$xalloc@Utess_tri@CLightShadows@@@@@std@@CAXXZ ENDP ; std::vector<CLightShadows::tess_tri,xalloc<CLightShadows::tess_tri> >::_Xlength
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Change_array@?$vector@Utess_tri@CLightShadows@@V?$xalloc@Utess_tri@CLightShadows@@@@@std@@AAEXQAUtess_tri@CLightShadows@@II@Z
_TEXT	SEGMENT
__Newvec$ = 8						; size = 4
__Newsize$ = 12						; size = 4
__Newcapacity$ = 16					; size = 4
?_Change_array@?$vector@Utess_tri@CLightShadows@@V?$xalloc@Utess_tri@CLightShadows@@@@@std@@AAEXQAUtess_tri@CLightShadows@@II@Z PROC ; std::vector<CLightShadows::tess_tri,xalloc<CLightShadows::tess_tri> >::_Change_array, COMDAT
; _this$ = ecx

; 1723 :         const pointer _Newvec, const size_type _Newsize, const size_type _Newcapacity) {

	push	esi
	mov	esi, ecx

; 1724 :         // orphan all iterators, discard old array, acquire new array
; 1725 :         auto& _My_data    = _Mypair._Myval2;
; 1726 :         pointer& _Myfirst = _My_data._Myfirst;
; 1727 :         pointer& _Mylast  = _My_data._Mylast;
; 1728 :         pointer& _Myend   = _My_data._Myend;
; 1729 : 
; 1730 :         _My_data._Orphan_all();
; 1731 : 
; 1732 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN7@Change_arr
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN7@Change_arr:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1738 :         _Mylast  = _Newvec + _Newsize;

	mov	eax, DWORD PTR __Newsize$[esp]
	mov	ecx, DWORD PTR __Newvec$[esp]
	mov	DWORD PTR [esi], ecx
	lea	eax, DWORD PTR [eax+eax*2]
	shl	eax, 4
	add	eax, ecx
	mov	DWORD PTR [esi+4], eax

; 1739 :         _Myend   = _Newvec + _Newcapacity;

	mov	eax, DWORD PTR __Newcapacity$[esp]
	lea	eax, DWORD PTR [eax+eax*2]
	shl	eax, 4
	add	eax, ecx
	mov	DWORD PTR [esi+8], eax
	pop	esi

; 1740 :     }

	ret	12					; 0000000cH
?_Change_array@?$vector@Utess_tri@CLightShadows@@V?$xalloc@Utess_tri@CLightShadows@@@@@std@@AAEXQAUtess_tri@CLightShadows@@II@Z ENDP ; std::vector<CLightShadows::tess_tri,xalloc<CLightShadows::tess_tri> >::_Change_array
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Calculate_growth@?$vector@Utess_tri@CLightShadows@@V?$xalloc@Utess_tri@CLightShadows@@@@@std@@ABEII@Z
_TEXT	SEGMENT
__Newsize$ = 8						; size = 4
?_Calculate_growth@?$vector@Utess_tri@CLightShadows@@V?$xalloc@Utess_tri@CLightShadows@@@@@std@@ABEII@Z PROC ; std::vector<CLightShadows::tess_tri,xalloc<CLightShadows::tess_tri> >::_Calculate_growth, COMDAT
; _this$ = ecx

; 1546 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx]

; 1671 :         // given _Oldcapacity and _Newsize, calculate geometric growth
; 1672 :         const size_type _Oldcapacity = capacity();
; 1673 :         const auto _Max              = max_size();
; 1674 : 
; 1675 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	ecx, 89478485				; 05555555H

; 1546 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	sar	eax, 4

; 1670 :     _CONSTEXPR20_CONTAINER size_type _Calculate_growth(const size_type _Newsize) const {

	push	esi

; 1546 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	imul	esi, eax, -1431655765

; 1671 :         // given _Oldcapacity and _Newsize, calculate geometric growth
; 1672 :         const size_type _Oldcapacity = capacity();
; 1673 :         const auto _Max              = max_size();
; 1674 : 
; 1675 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	edx, esi
	shr	edx, 1
	sub	ecx, edx
	cmp	esi, ecx
	jbe	SHORT $LN2@Calculate_

; 1676 :             return _Max; // geometric growth would overflow

	mov	eax, 89478485				; 05555555H
	pop	esi

; 1682 :             return _Newsize; // geometric growth would be insufficient
; 1683 :         }
; 1684 : 
; 1685 :         return _Geometric; // geometric growth is sufficient
; 1686 :     }

	ret	4
$LN2@Calculate_:

; 1677 :         }
; 1678 : 
; 1679 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	lea	eax, DWORD PTR [edx+esi]

; 1680 : 
; 1681 :         if (_Geometric < _Newsize) {

	cmp	eax, DWORD PTR __Newsize$[esp]
	pop	esi
	cmovb	eax, DWORD PTR __Newsize$[esp-4]

; 1682 :             return _Newsize; // geometric growth would be insufficient
; 1683 :         }
; 1684 : 
; 1685 :         return _Geometric; // geometric growth is sufficient
; 1686 :     }

	ret	4
?_Calculate_growth@?$vector@Utess_tri@CLightShadows@@V?$xalloc@Utess_tri@CLightShadows@@@@@std@@ABEII@Z ENDP ; std::vector<CLightShadows::tess_tri,xalloc<CLightShadows::tess_tri> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Umove_if_noexcept@?$vector@Utess_tri@CLightShadows@@V?$xalloc@Utess_tri@CLightShadows@@@@@std@@AAEXPAUtess_tri@CLightShadows@@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
?_Umove_if_noexcept@?$vector@Utess_tri@CLightShadows@@V?$xalloc@Utess_tri@CLightShadows@@@@@std@@AAEXPAUtess_tri@CLightShadows@@00@Z PROC ; std::vector<CLightShadows::tess_tri,xalloc<CLightShadows::tess_tri> >::_Umove_if_noexcept, COMDAT
; _this$dead$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1703 :     auto _UFirst      = _Get_unwrapped(_First);

	mov	eax, DWORD PTR __First$[esp-4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1659 :     _CONSTEXPR20_CONTAINER void _Umove_if_noexcept(pointer _First, pointer _Last, pointer _Dest) {

	push	ebx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	mov	ebx, DWORD PTR __Last$[esp]
	cmp	eax, ebx
	je	SHORT $LN7@Umove_if_n

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	edx, DWORD PTR __Dest$[esp]
	push	esi
	sub	edx, eax
	push	edi
$LL8@Umove_if_n:
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	lea	edi, DWORD PTR [edx+eax]
	mov	esi, eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	add	eax, 48					; 00000030H
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	ecx, 12					; 0000000cH
	rep movsd
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	eax, ebx
	jne	SHORT $LL8@Umove_if_n
	pop	edi
	pop	esi
$LN7@Umove_if_n:
	pop	ebx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1663 :     }

	ret	12					; 0000000cH
?_Umove_if_noexcept@?$vector@Utess_tri@CLightShadows@@V?$xalloc@Utess_tri@CLightShadows@@@@@std@@AAEXPAUtess_tri@CLightShadows@@00@Z ENDP ; std::vector<CLightShadows::tess_tri,xalloc<CLightShadows::tess_tri> >::_Umove_if_noexcept
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Umove@?$vector@Utess_tri@CLightShadows@@V?$xalloc@Utess_tri@CLightShadows@@@@@std@@AAEPAUtess_tri@CLightShadows@@PAU34@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
?_Umove@?$vector@Utess_tri@CLightShadows@@V?$xalloc@Utess_tri@CLightShadows@@@@@std@@AAEPAUtess_tri@CLightShadows@@PAU34@00@Z PROC ; std::vector<CLightShadows::tess_tri,xalloc<CLightShadows::tess_tri> >::_Umove, COMDAT
; _this$dead$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	mov	edx, DWORD PTR __First$[esp-4]

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	eax, DWORD PTR __Dest$[esp-4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1644 :     _CONSTEXPR20_CONTAINER pointer _Umove(pointer _First, pointer _Last, pointer _Dest) {

	push	ebx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	mov	ebx, DWORD PTR __Last$[esp]
	cmp	edx, ebx
	je	SHORT $LN5@Umove
	push	esi
	push	edi
$LL6@Umove:
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	esi, edx
	mov	edi, eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1621 :         ++_Last;

	add	edx, 48					; 00000030H
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	ecx, 12					; 0000000cH
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1621 :         ++_Last;

	add	eax, 48					; 00000030H
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	rep movsd
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	edx, ebx
	jne	SHORT $LL6@Umove
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1646 :         return _Uninitialized_move(_First, _Last, _Dest, _Getal());

	pop	edi
	pop	esi
$LN5@Umove:

; 1647 :     }

	pop	ebx
	ret	12					; 0000000cH
?_Umove@?$vector@Utess_tri@CLightShadows@@V?$xalloc@Utess_tri@CLightShadows@@@@@std@@AAEPAUtess_tri@CLightShadows@@PAU34@00@Z ENDP ; std::vector<CLightShadows::tess_tri,xalloc<CLightShadows::tess_tri> >::_Umove
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?max_size@?$vector@Utess_tri@CLightShadows@@V?$xalloc@Utess_tri@CLightShadows@@@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@Utess_tri@CLightShadows@@V?$xalloc@Utess_tri@CLightShadows@@@@@std@@QBEIXZ PROC ; std::vector<CLightShadows::tess_tri,xalloc<CLightShadows::tess_tri> >::max_size, COMDAT
; _this$dead$ = ecx

; 1540 :         return (_STD min)(

	mov	eax, 89478485				; 05555555H

; 1541 :             static_cast<size_type>((numeric_limits<difference_type>::max)()), _Alty_traits::max_size(_Getal()));
; 1542 :     }

	ret	0
?max_size@?$vector@Utess_tri@CLightShadows@@V?$xalloc@Utess_tri@CLightShadows@@@@@std@@QBEIXZ ENDP ; std::vector<CLightShadows::tess_tri,xalloc<CLightShadows::tess_tri> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?construct@?$xalloc@Utess_tri@CLightShadows@@@@QAEXPAUtess_tri@CLightShadows@@ABU23@@Z
_TEXT	SEGMENT
_p$ = 8							; size = 4
__Val$ = 12						; size = 4
?construct@?$xalloc@Utess_tri@CLightShadows@@@@QAEXPAUtess_tri@CLightShadows@@ABU23@@Z PROC ; xalloc<CLightShadows::tess_tri>::construct, COMDAT
; _this$dead$ = ecx

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	push	esi
	mov	esi, DWORD PTR __Val$[esp]
	mov	ecx, 12					; 0000000cH
	push	edi
	mov	edi, DWORD PTR _p$[esp+4]
	rep movsd
	pop	edi
	pop	esi
	ret	8
?construct@?$xalloc@Utess_tri@CLightShadows@@@@QAEXPAUtess_tri@CLightShadows@@ABU23@@Z ENDP ; xalloc<CLightShadows::tess_tri>::construct
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?allocate@?$xalloc@Utess_tri@CLightShadows@@@@QBEPAUtess_tri@CLightShadows@@IPBX@Z
_TEXT	SEGMENT
_n$ = 8							; size = 4
_p$dead$ = 12						; size = 4
?allocate@?$xalloc@Utess_tri@CLightShadows@@@@QBEPAUtess_tri@CLightShadows@@IPBX@Z PROC ; xalloc<CLightShadows::tess_tri>::allocate, COMDAT
; _this$dead$ = ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	mov	eax, DWORD PTR _n$[esp-4]
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	lea	eax, DWORD PTR [eax+eax*2]
	shl	eax, 4
	push	eax
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 80   : 							pointer					allocate		(size_type n, const void* p=0) const	{	return xr_alloc<T>((u32)n);	}

	ret	8
?allocate@?$xalloc@Utess_tri@CLightShadows@@@@QBEPAUtess_tri@CLightShadows@@IPBX@Z ENDP ; xalloc<CLightShadows::tess_tri>::allocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ??0?$xalloc@Utess_tri@CLightShadows@@@@QAE@XZ
_TEXT	SEGMENT
??0?$xalloc@Utess_tri@CLightShadows@@@@QAE@XZ PROC	; xalloc<CLightShadows::tess_tri>::xalloc<CLightShadows::tess_tri>, COMDAT
; _this$ = ecx

; 76   : 													xalloc			()										{	}

	mov	eax, ecx
	ret	0
??0?$xalloc@Utess_tri@CLightShadows@@@@QAE@XZ ENDP	; xalloc<CLightShadows::tess_tri>::xalloc<CLightShadows::tess_tri>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@Ushadow@CLightShadows@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Vector_val@U?$_Simple_types@Ushadow@CLightShadows@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<std::_Simple_types<CLightShadows::shadow> >::_Vector_val<std::_Simple_types<CLightShadows::shadow> >, COMDAT
; _this$ = ecx

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx], 0
	mov	eax, ecx
	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0
	ret	0
??0?$_Vector_val@U?$_Simple_types@Ushadow@CLightShadows@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<std::_Simple_types<CLightShadows::shadow> >::_Vector_val<std::_Simple_types<CLightShadows::shadow> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Xlength@?$vector@Ushadow@CLightShadows@@V?$xalloc@Ushadow@CLightShadows@@@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@Ushadow@CLightShadows@@V?$xalloc@Ushadow@CLightShadows@@@@@std@@CAXXZ PROC ; std::vector<CLightShadows::shadow,xalloc<CLightShadows::shadow> >::_Xlength, COMDAT

; 1761 :         _Xlength_error("vector too long");

	push	OFFSET ??_C@_0BA@FOIKENOD@vector?5too?5long@
	call	DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN3@Xlength:
	int	3
?_Xlength@?$vector@Ushadow@CLightShadows@@V?$xalloc@Ushadow@CLightShadows@@@@@std@@CAXXZ ENDP ; std::vector<CLightShadows::shadow,xalloc<CLightShadows::shadow> >::_Xlength
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Change_array@?$vector@Ushadow@CLightShadows@@V?$xalloc@Ushadow@CLightShadows@@@@@std@@AAEXQAUshadow@CLightShadows@@II@Z
_TEXT	SEGMENT
__Newvec$ = 8						; size = 4
__Newsize$ = 12						; size = 4
__Newcapacity$ = 16					; size = 4
?_Change_array@?$vector@Ushadow@CLightShadows@@V?$xalloc@Ushadow@CLightShadows@@@@@std@@AAEXQAUshadow@CLightShadows@@II@Z PROC ; std::vector<CLightShadows::shadow,xalloc<CLightShadows::shadow> >::_Change_array, COMDAT
; _this$ = ecx

; 1723 :         const pointer _Newvec, const size_type _Newsize, const size_type _Newcapacity) {

	push	esi
	mov	esi, ecx

; 1724 :         // orphan all iterators, discard old array, acquire new array
; 1725 :         auto& _My_data    = _Mypair._Myval2;
; 1726 :         pointer& _Myfirst = _My_data._Myfirst;
; 1727 :         pointer& _Mylast  = _My_data._Mylast;
; 1728 :         pointer& _Myend   = _My_data._Myend;
; 1729 : 
; 1730 :         _My_data._Orphan_all();
; 1731 : 
; 1732 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN7@Change_arr
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN7@Change_arr:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1738 :         _Mylast  = _Newvec + _Newsize;

	imul	eax, DWORD PTR __Newsize$[esp], 92
	mov	ecx, DWORD PTR __Newvec$[esp]
	mov	DWORD PTR [esi], ecx
	add	eax, ecx
	mov	DWORD PTR [esi+4], eax

; 1739 :         _Myend   = _Newvec + _Newcapacity;

	imul	eax, DWORD PTR __Newcapacity$[esp], 92
	add	eax, ecx
	mov	DWORD PTR [esi+8], eax
	pop	esi

; 1740 :     }

	ret	12					; 0000000cH
?_Change_array@?$vector@Ushadow@CLightShadows@@V?$xalloc@Ushadow@CLightShadows@@@@@std@@AAEXQAUshadow@CLightShadows@@II@Z ENDP ; std::vector<CLightShadows::shadow,xalloc<CLightShadows::shadow> >::_Change_array
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Calculate_growth@?$vector@Ushadow@CLightShadows@@V?$xalloc@Ushadow@CLightShadows@@@@@std@@ABEII@Z
_TEXT	SEGMENT
__Newsize$ = 8						; size = 4
?_Calculate_growth@?$vector@Ushadow@CLightShadows@@V?$xalloc@Ushadow@CLightShadows@@@@@std@@ABEII@Z PROC ; std::vector<CLightShadows::shadow,xalloc<CLightShadows::shadow> >::_Calculate_growth, COMDAT
; _this$ = ecx

; 1670 :     _CONSTEXPR20_CONTAINER size_type _Calculate_growth(const size_type _Newsize) const {

	push	esi

; 1546 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	esi, DWORD PTR [ecx+8]
	mov	eax, -1307163959			; b21642c9H
	sub	esi, DWORD PTR [ecx]

; 1671 :         // given _Oldcapacity and _Newsize, calculate geometric growth
; 1672 :         const size_type _Oldcapacity = capacity();
; 1673 :         const auto _Max              = max_size();
; 1674 : 
; 1675 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	ecx, 46684427				; 02c8590bH

; 1546 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	imul	esi
	add	edx, esi
	sar	edx, 6
	mov	esi, edx
	shr	esi, 31					; 0000001fH
	add	esi, edx

; 1671 :         // given _Oldcapacity and _Newsize, calculate geometric growth
; 1672 :         const size_type _Oldcapacity = capacity();
; 1673 :         const auto _Max              = max_size();
; 1674 : 
; 1675 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	edx, esi
	shr	edx, 1
	sub	ecx, edx
	cmp	esi, ecx
	jbe	SHORT $LN2@Calculate_

; 1676 :             return _Max; // geometric growth would overflow

	mov	eax, 46684427				; 02c8590bH
	pop	esi

; 1682 :             return _Newsize; // geometric growth would be insufficient
; 1683 :         }
; 1684 : 
; 1685 :         return _Geometric; // geometric growth is sufficient
; 1686 :     }

	ret	4
$LN2@Calculate_:

; 1677 :         }
; 1678 : 
; 1679 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	lea	eax, DWORD PTR [edx+esi]

; 1680 : 
; 1681 :         if (_Geometric < _Newsize) {

	cmp	eax, DWORD PTR __Newsize$[esp]
	pop	esi
	cmovb	eax, DWORD PTR __Newsize$[esp-4]

; 1682 :             return _Newsize; // geometric growth would be insufficient
; 1683 :         }
; 1684 : 
; 1685 :         return _Geometric; // geometric growth is sufficient
; 1686 :     }

	ret	4
?_Calculate_growth@?$vector@Ushadow@CLightShadows@@V?$xalloc@Ushadow@CLightShadows@@@@@std@@ABEII@Z ENDP ; std::vector<CLightShadows::shadow,xalloc<CLightShadows::shadow> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Umove_if_noexcept@?$vector@Ushadow@CLightShadows@@V?$xalloc@Ushadow@CLightShadows@@@@@std@@AAEXPAUshadow@CLightShadows@@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
?_Umove_if_noexcept@?$vector@Ushadow@CLightShadows@@V?$xalloc@Ushadow@CLightShadows@@@@@std@@AAEXPAUshadow@CLightShadows@@00@Z PROC ; std::vector<CLightShadows::shadow,xalloc<CLightShadows::shadow> >::_Umove_if_noexcept, COMDAT
; _this$dead$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1703 :     auto _UFirst      = _Get_unwrapped(_First);

	mov	eax, DWORD PTR __First$[esp-4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1659 :     _CONSTEXPR20_CONTAINER void _Umove_if_noexcept(pointer _First, pointer _Last, pointer _Dest) {

	push	ebx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	mov	ebx, DWORD PTR __Last$[esp]
	cmp	eax, ebx
	je	SHORT $LN7@Umove_if_n

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	edx, DWORD PTR __Dest$[esp]
	push	esi
	sub	edx, eax
	push	edi
$LL8@Umove_if_n:
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	lea	edi, DWORD PTR [edx+eax]
	mov	esi, eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	add	eax, 92					; 0000005cH
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	ecx, 23					; 00000017H
	rep movsd
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	eax, ebx
	jne	SHORT $LL8@Umove_if_n
	pop	edi
	pop	esi
$LN7@Umove_if_n:
	pop	ebx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1663 :     }

	ret	12					; 0000000cH
?_Umove_if_noexcept@?$vector@Ushadow@CLightShadows@@V?$xalloc@Ushadow@CLightShadows@@@@@std@@AAEXPAUshadow@CLightShadows@@00@Z ENDP ; std::vector<CLightShadows::shadow,xalloc<CLightShadows::shadow> >::_Umove_if_noexcept
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Umove@?$vector@Ushadow@CLightShadows@@V?$xalloc@Ushadow@CLightShadows@@@@@std@@AAEPAUshadow@CLightShadows@@PAU34@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
?_Umove@?$vector@Ushadow@CLightShadows@@V?$xalloc@Ushadow@CLightShadows@@@@@std@@AAEPAUshadow@CLightShadows@@PAU34@00@Z PROC ; std::vector<CLightShadows::shadow,xalloc<CLightShadows::shadow> >::_Umove, COMDAT
; _this$dead$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	mov	edx, DWORD PTR __First$[esp-4]

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	eax, DWORD PTR __Dest$[esp-4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1644 :     _CONSTEXPR20_CONTAINER pointer _Umove(pointer _First, pointer _Last, pointer _Dest) {

	push	ebx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	mov	ebx, DWORD PTR __Last$[esp]
	cmp	edx, ebx
	je	SHORT $LN5@Umove
	push	esi
	push	edi
$LL6@Umove:
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	esi, edx
	mov	edi, eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1621 :         ++_Last;

	add	edx, 92					; 0000005cH
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	ecx, 23					; 00000017H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1621 :         ++_Last;

	add	eax, 92					; 0000005cH
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	rep movsd
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	edx, ebx
	jne	SHORT $LL6@Umove
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1646 :         return _Uninitialized_move(_First, _Last, _Dest, _Getal());

	pop	edi
	pop	esi
$LN5@Umove:

; 1647 :     }

	pop	ebx
	ret	12					; 0000000cH
?_Umove@?$vector@Ushadow@CLightShadows@@V?$xalloc@Ushadow@CLightShadows@@@@@std@@AAEPAUshadow@CLightShadows@@PAU34@00@Z ENDP ; std::vector<CLightShadows::shadow,xalloc<CLightShadows::shadow> >::_Umove
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?max_size@?$vector@Ushadow@CLightShadows@@V?$xalloc@Ushadow@CLightShadows@@@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@Ushadow@CLightShadows@@V?$xalloc@Ushadow@CLightShadows@@@@@std@@QBEIXZ PROC ; std::vector<CLightShadows::shadow,xalloc<CLightShadows::shadow> >::max_size, COMDAT
; _this$dead$ = ecx

; 1540 :         return (_STD min)(

	mov	eax, 46684427				; 02c8590bH

; 1541 :             static_cast<size_type>((numeric_limits<difference_type>::max)()), _Alty_traits::max_size(_Getal()));
; 1542 :     }

	ret	0
?max_size@?$vector@Ushadow@CLightShadows@@V?$xalloc@Ushadow@CLightShadows@@@@@std@@QBEIXZ ENDP ; std::vector<CLightShadows::shadow,xalloc<CLightShadows::shadow> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?construct@?$xalloc@Ushadow@CLightShadows@@@@QAEXPAUshadow@CLightShadows@@ABU23@@Z
_TEXT	SEGMENT
_p$ = 8							; size = 4
__Val$ = 12						; size = 4
?construct@?$xalloc@Ushadow@CLightShadows@@@@QAEXPAUshadow@CLightShadows@@ABU23@@Z PROC ; xalloc<CLightShadows::shadow>::construct, COMDAT
; _this$dead$ = ecx

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	push	esi
	mov	esi, DWORD PTR __Val$[esp]
	mov	ecx, 23					; 00000017H
	push	edi
	mov	edi, DWORD PTR _p$[esp+4]
	rep movsd
	pop	edi
	pop	esi
	ret	8
?construct@?$xalloc@Ushadow@CLightShadows@@@@QAEXPAUshadow@CLightShadows@@ABU23@@Z ENDP ; xalloc<CLightShadows::shadow>::construct
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?allocate@?$xalloc@Ushadow@CLightShadows@@@@QBEPAUshadow@CLightShadows@@IPBX@Z
_TEXT	SEGMENT
_n$ = 8							; size = 4
_p$dead$ = 12						; size = 4
?allocate@?$xalloc@Ushadow@CLightShadows@@@@QBEPAUshadow@CLightShadows@@IPBX@Z PROC ; xalloc<CLightShadows::shadow>::allocate, COMDAT
; _this$dead$ = ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	imul	eax, DWORD PTR _n$[esp-4], 92
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 80   : 							pointer					allocate		(size_type n, const void* p=0) const	{	return xr_alloc<T>((u32)n);	}

	ret	8
?allocate@?$xalloc@Ushadow@CLightShadows@@@@QBEPAUshadow@CLightShadows@@IPBX@Z ENDP ; xalloc<CLightShadows::shadow>::allocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ??0?$xalloc@Ushadow@CLightShadows@@@@QAE@XZ
_TEXT	SEGMENT
??0?$xalloc@Ushadow@CLightShadows@@@@QAE@XZ PROC	; xalloc<CLightShadows::shadow>::xalloc<CLightShadows::shadow>, COMDAT
; _this$ = ecx

; 76   : 													xalloc			()										{	}

	mov	eax, ecx
	ret	0
??0?$xalloc@Ushadow@CLightShadows@@@@QAE@XZ ENDP	; xalloc<CLightShadows::shadow>::xalloc<CLightShadows::shadow>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@PAUcaster@CLightShadows@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Vector_val@U?$_Simple_types@PAUcaster@CLightShadows@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<std::_Simple_types<CLightShadows::caster *> >::_Vector_val<std::_Simple_types<CLightShadows::caster *> >, COMDAT
; _this$ = ecx

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx], 0
	mov	eax, ecx
	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0
	ret	0
??0?$_Vector_val@U?$_Simple_types@PAUcaster@CLightShadows@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<std::_Simple_types<CLightShadows::caster *> >::_Vector_val<std::_Simple_types<CLightShadows::caster *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Xlength@?$vector@PAUcaster@CLightShadows@@V?$xalloc@PAUcaster@CLightShadows@@@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@PAUcaster@CLightShadows@@V?$xalloc@PAUcaster@CLightShadows@@@@@std@@CAXXZ PROC ; std::vector<CLightShadows::caster *,xalloc<CLightShadows::caster *> >::_Xlength, COMDAT

; 1761 :         _Xlength_error("vector too long");

	push	OFFSET ??_C@_0BA@FOIKENOD@vector?5too?5long@
	call	DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN3@Xlength:
	int	3
?_Xlength@?$vector@PAUcaster@CLightShadows@@V?$xalloc@PAUcaster@CLightShadows@@@@@std@@CAXXZ ENDP ; std::vector<CLightShadows::caster *,xalloc<CLightShadows::caster *> >::_Xlength
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Change_array@?$vector@PAUcaster@CLightShadows@@V?$xalloc@PAUcaster@CLightShadows@@@@@std@@AAEXQAPAUcaster@CLightShadows@@II@Z
_TEXT	SEGMENT
__Newvec$ = 8						; size = 4
__Newsize$ = 12						; size = 4
__Newcapacity$ = 16					; size = 4
?_Change_array@?$vector@PAUcaster@CLightShadows@@V?$xalloc@PAUcaster@CLightShadows@@@@@std@@AAEXQAPAUcaster@CLightShadows@@II@Z PROC ; std::vector<CLightShadows::caster *,xalloc<CLightShadows::caster *> >::_Change_array, COMDAT
; _this$ = ecx

; 1723 :         const pointer _Newvec, const size_type _Newsize, const size_type _Newcapacity) {

	push	esi
	mov	esi, ecx

; 1724 :         // orphan all iterators, discard old array, acquire new array
; 1725 :         auto& _My_data    = _Mypair._Myval2;
; 1726 :         pointer& _Myfirst = _My_data._Myfirst;
; 1727 :         pointer& _Mylast  = _My_data._Mylast;
; 1728 :         pointer& _Myend   = _My_data._Myend;
; 1729 : 
; 1730 :         _My_data._Orphan_all();
; 1731 : 
; 1732 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN7@Change_arr
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN7@Change_arr:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1737 :         _Myfirst = _Newvec;

	mov	ecx, DWORD PTR __Newvec$[esp]

; 1738 :         _Mylast  = _Newvec + _Newsize;

	mov	eax, DWORD PTR __Newsize$[esp]
	mov	DWORD PTR [esi], ecx
	lea	eax, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR [esi+4], eax

; 1739 :         _Myend   = _Newvec + _Newcapacity;

	mov	eax, DWORD PTR __Newcapacity$[esp]
	lea	eax, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR [esi+8], eax
	pop	esi

; 1740 :     }

	ret	12					; 0000000cH
?_Change_array@?$vector@PAUcaster@CLightShadows@@V?$xalloc@PAUcaster@CLightShadows@@@@@std@@AAEXQAPAUcaster@CLightShadows@@II@Z ENDP ; std::vector<CLightShadows::caster *,xalloc<CLightShadows::caster *> >::_Change_array
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Calculate_growth@?$vector@PAUcaster@CLightShadows@@V?$xalloc@PAUcaster@CLightShadows@@@@@std@@ABEII@Z
_TEXT	SEGMENT
__Newsize$ = 8						; size = 4
?_Calculate_growth@?$vector@PAUcaster@CLightShadows@@V?$xalloc@PAUcaster@CLightShadows@@@@@std@@ABEII@Z PROC ; std::vector<CLightShadows::caster *,xalloc<CLightShadows::caster *> >::_Calculate_growth, COMDAT
; _this$ = ecx

; 1546 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	edx, DWORD PTR [ecx+8]
	sub	edx, DWORD PTR [ecx]

; 1671 :         // given _Oldcapacity and _Newsize, calculate geometric growth
; 1672 :         const size_type _Oldcapacity = capacity();
; 1673 :         const auto _Max              = max_size();
; 1674 : 
; 1675 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	ecx, 1073741823				; 3fffffffH

; 1546 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	sar	edx, 2

; 1670 :     _CONSTEXPR20_CONTAINER size_type _Calculate_growth(const size_type _Newsize) const {

	push	esi

; 1671 :         // given _Oldcapacity and _Newsize, calculate geometric growth
; 1672 :         const size_type _Oldcapacity = capacity();
; 1673 :         const auto _Max              = max_size();
; 1674 : 
; 1675 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	esi, edx
	shr	esi, 1
	sub	ecx, esi
	cmp	edx, ecx
	jbe	SHORT $LN2@Calculate_

; 1676 :             return _Max; // geometric growth would overflow

	mov	eax, 1073741823				; 3fffffffH
	pop	esi

; 1682 :             return _Newsize; // geometric growth would be insufficient
; 1683 :         }
; 1684 : 
; 1685 :         return _Geometric; // geometric growth is sufficient
; 1686 :     }

	ret	4
$LN2@Calculate_:

; 1677 :         }
; 1678 : 
; 1679 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	lea	eax, DWORD PTR [esi+edx]

; 1680 : 
; 1681 :         if (_Geometric < _Newsize) {

	cmp	eax, DWORD PTR __Newsize$[esp]
	pop	esi
	cmovb	eax, DWORD PTR __Newsize$[esp-4]

; 1682 :             return _Newsize; // geometric growth would be insufficient
; 1683 :         }
; 1684 : 
; 1685 :         return _Geometric; // geometric growth is sufficient
; 1686 :     }

	ret	4
?_Calculate_growth@?$vector@PAUcaster@CLightShadows@@V?$xalloc@PAUcaster@CLightShadows@@@@@std@@ABEII@Z ENDP ; std::vector<CLightShadows::caster *,xalloc<CLightShadows::caster *> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Umove_if_noexcept@?$vector@PAUcaster@CLightShadows@@V?$xalloc@PAUcaster@CLightShadows@@@@@std@@AAEXPAPAUcaster@CLightShadows@@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
?_Umove_if_noexcept@?$vector@PAUcaster@CLightShadows@@V?$xalloc@PAUcaster@CLightShadows@@@@@std@@AAEXPAPAUcaster@CLightShadows@@00@Z PROC ; std::vector<CLightShadows::caster *,xalloc<CLightShadows::caster *> >::_Umove_if_noexcept, COMDAT
; _this$dead$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1703 :     auto _UFirst      = _Get_unwrapped(_First);

	mov	eax, DWORD PTR __First$[esp-4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1659 :     _CONSTEXPR20_CONTAINER void _Umove_if_noexcept(pointer _First, pointer _Last, pointer _Dest) {

	push	esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	mov	esi, DWORD PTR __Last$[esp]
	cmp	eax, esi
	je	SHORT $LN7@Umove_if_n

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	edx, DWORD PTR __Dest$[esp]
	sub	edx, eax
$LL8@Umove_if_n:

; 1620 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx+eax], ecx

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	add	eax, 4
	cmp	eax, esi
	jne	SHORT $LL8@Umove_if_n
$LN7@Umove_if_n:
	pop	esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1663 :     }

	ret	12					; 0000000cH
?_Umove_if_noexcept@?$vector@PAUcaster@CLightShadows@@V?$xalloc@PAUcaster@CLightShadows@@@@@std@@AAEXPAPAUcaster@CLightShadows@@00@Z ENDP ; std::vector<CLightShadows::caster *,xalloc<CLightShadows::caster *> >::_Umove_if_noexcept
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Umove@?$vector@PAUcaster@CLightShadows@@V?$xalloc@PAUcaster@CLightShadows@@@@@std@@AAEPAPAUcaster@CLightShadows@@PAPAU34@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
?_Umove@?$vector@PAUcaster@CLightShadows@@V?$xalloc@PAUcaster@CLightShadows@@@@@std@@AAEPAPAUcaster@CLightShadows@@PAPAU34@00@Z PROC ; std::vector<CLightShadows::caster *,xalloc<CLightShadows::caster *> >::_Umove, COMDAT
; _this$dead$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	mov	ecx, DWORD PTR __First$[esp-4]

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	eax, DWORD PTR __Dest$[esp-4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1644 :     _CONSTEXPR20_CONTAINER pointer _Umove(pointer _First, pointer _Last, pointer _Dest) {

	push	esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	mov	esi, DWORD PTR __Last$[esp]
	cmp	ecx, esi
	je	SHORT $LN5@Umove
$LL6@Umove:

; 1620 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

	mov	edx, DWORD PTR [ecx]

; 1621 :         ++_Last;

	add	ecx, 4
	mov	DWORD PTR [eax], edx
	add	eax, 4

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	ecx, esi
	jne	SHORT $LL6@Umove
$LN5@Umove:
	pop	esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1647 :     }

	ret	12					; 0000000cH
?_Umove@?$vector@PAUcaster@CLightShadows@@V?$xalloc@PAUcaster@CLightShadows@@@@@std@@AAEPAPAUcaster@CLightShadows@@PAPAU34@00@Z ENDP ; std::vector<CLightShadows::caster *,xalloc<CLightShadows::caster *> >::_Umove
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?max_size@?$vector@PAUcaster@CLightShadows@@V?$xalloc@PAUcaster@CLightShadows@@@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@PAUcaster@CLightShadows@@V?$xalloc@PAUcaster@CLightShadows@@@@@std@@QBEIXZ PROC ; std::vector<CLightShadows::caster *,xalloc<CLightShadows::caster *> >::max_size, COMDAT
; _this$dead$ = ecx

; 1540 :         return (_STD min)(

	mov	eax, 1073741823				; 3fffffffH

; 1541 :             static_cast<size_type>((numeric_limits<difference_type>::max)()), _Alty_traits::max_size(_Getal()));
; 1542 :     }

	ret	0
?max_size@?$vector@PAUcaster@CLightShadows@@V?$xalloc@PAUcaster@CLightShadows@@@@@std@@QBEIXZ ENDP ; std::vector<CLightShadows::caster *,xalloc<CLightShadows::caster *> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?destroy@?$xalloc@PAUcaster@CLightShadows@@@@QAEXPAPAUcaster@CLightShadows@@@Z
_TEXT	SEGMENT
_p$dead$ = 8						; size = 4
?destroy@?$xalloc@PAUcaster@CLightShadows@@@@QAEXPAPAUcaster@CLightShadows@@@Z PROC ; xalloc<CLightShadows::caster *>::destroy, COMDAT
; _this$dead$ = ecx

; 85   : 							void					destroy			(pointer p)								{	std::_Destroy_in_place(p);			}

	ret	4
?destroy@?$xalloc@PAUcaster@CLightShadows@@@@QAEXPAPAUcaster@CLightShadows@@@Z ENDP ; xalloc<CLightShadows::caster *>::destroy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?construct@?$xalloc@PAUcaster@CLightShadows@@@@QAEXPAPAUcaster@CLightShadows@@ABQAU23@@Z
_TEXT	SEGMENT
_p$ = 8							; size = 4
__Val$ = 12						; size = 4
?construct@?$xalloc@PAUcaster@CLightShadows@@@@QAEXPAPAUcaster@CLightShadows@@ABQAU23@@Z PROC ; xalloc<CLightShadows::caster *>::construct, COMDAT
; _this$dead$ = ecx

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	eax, DWORD PTR __Val$[esp-4]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR _p$[esp-4]
	mov	DWORD PTR [eax], ecx
	ret	8
?construct@?$xalloc@PAUcaster@CLightShadows@@@@QAEXPAPAUcaster@CLightShadows@@ABQAU23@@Z ENDP ; xalloc<CLightShadows::caster *>::construct
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?allocate@?$xalloc@PAUcaster@CLightShadows@@@@QBEPAPAUcaster@CLightShadows@@IPBX@Z
_TEXT	SEGMENT
_n$ = 8							; size = 4
_p$dead$ = 12						; size = 4
?allocate@?$xalloc@PAUcaster@CLightShadows@@@@QBEPAPAUcaster@CLightShadows@@IPBX@Z PROC ; xalloc<CLightShadows::caster *>::allocate, COMDAT
; _this$dead$ = ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	mov	eax, DWORD PTR _n$[esp-4]
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	shl	eax, 2
	push	eax
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 80   : 							pointer					allocate		(size_type n, const void* p=0) const	{	return xr_alloc<T>((u32)n);	}

	ret	8
?allocate@?$xalloc@PAUcaster@CLightShadows@@@@QBEPAPAUcaster@CLightShadows@@IPBX@Z ENDP ; xalloc<CLightShadows::caster *>::allocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ??0?$xalloc@PAUcaster@CLightShadows@@@@QAE@XZ
_TEXT	SEGMENT
??0?$xalloc@PAUcaster@CLightShadows@@@@QAE@XZ PROC	; xalloc<CLightShadows::caster *>::xalloc<CLightShadows::caster *>, COMDAT
; _this$ = ecx

; 76   : 													xalloc			()										{	}

	mov	eax, ecx
	ret	0
??0?$xalloc@PAUcaster@CLightShadows@@@@QAE@XZ ENDP	; xalloc<CLightShadows::caster *>::xalloc<CLightShadows::caster *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ??0?$xr_vector@U_MatrixItem@R_dsgraph@@V?$xalloc@U_MatrixItem@R_dsgraph@@@@@@QAE@XZ
_TEXT	SEGMENT
??0?$xr_vector@U_MatrixItem@R_dsgraph@@V?$xalloc@U_MatrixItem@R_dsgraph@@@@@@QAE@XZ PROC ; xr_vector<R_dsgraph::_MatrixItem,xalloc<R_dsgraph::_MatrixItem> >::xr_vector<R_dsgraph::_MatrixItem,xalloc<R_dsgraph::_MatrixItem> >, COMDAT
; _this$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx], 0
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 122  : 			xr_vector			()									: inherited	()					{}

	mov	eax, ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 122  : 			xr_vector			()									: inherited	()					{}

	ret	0
??0?$xr_vector@U_MatrixItem@R_dsgraph@@V?$xalloc@U_MatrixItem@R_dsgraph@@@@@@QAE@XZ ENDP ; xr_vector<R_dsgraph::_MatrixItem,xalloc<R_dsgraph::_MatrixItem> >::xr_vector<R_dsgraph::_MatrixItem,xalloc<R_dsgraph::_MatrixItem> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Xlength@?$vector@U_MatrixItem@R_dsgraph@@V?$xalloc@U_MatrixItem@R_dsgraph@@@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@U_MatrixItem@R_dsgraph@@V?$xalloc@U_MatrixItem@R_dsgraph@@@@@std@@CAXXZ PROC ; std::vector<R_dsgraph::_MatrixItem,xalloc<R_dsgraph::_MatrixItem> >::_Xlength, COMDAT

; 1761 :         _Xlength_error("vector too long");

	push	OFFSET ??_C@_0BA@FOIKENOD@vector?5too?5long@
	call	DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN3@Xlength:
	int	3
?_Xlength@?$vector@U_MatrixItem@R_dsgraph@@V?$xalloc@U_MatrixItem@R_dsgraph@@@@@std@@CAXXZ ENDP ; std::vector<R_dsgraph::_MatrixItem,xalloc<R_dsgraph::_MatrixItem> >::_Xlength
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Change_array@?$vector@U_MatrixItem@R_dsgraph@@V?$xalloc@U_MatrixItem@R_dsgraph@@@@@std@@AAEXQAU_MatrixItem@R_dsgraph@@II@Z
_TEXT	SEGMENT
__Newvec$ = 8						; size = 4
__Newsize$ = 12						; size = 4
__Newcapacity$ = 16					; size = 4
?_Change_array@?$vector@U_MatrixItem@R_dsgraph@@V?$xalloc@U_MatrixItem@R_dsgraph@@@@@std@@AAEXQAU_MatrixItem@R_dsgraph@@II@Z PROC ; std::vector<R_dsgraph::_MatrixItem,xalloc<R_dsgraph::_MatrixItem> >::_Change_array, COMDAT
; _this$ = ecx

; 1723 :         const pointer _Newvec, const size_type _Newsize, const size_type _Newcapacity) {

	push	esi
	mov	esi, ecx

; 1724 :         // orphan all iterators, discard old array, acquire new array
; 1725 :         auto& _My_data    = _Mypair._Myval2;
; 1726 :         pointer& _Myfirst = _My_data._Myfirst;
; 1727 :         pointer& _Mylast  = _My_data._Mylast;
; 1728 :         pointer& _Myend   = _My_data._Myend;
; 1729 : 
; 1730 :         _My_data._Orphan_all();
; 1731 : 
; 1732 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN7@Change_arr
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN7@Change_arr:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1738 :         _Mylast  = _Newvec + _Newsize;

	imul	eax, DWORD PTR __Newsize$[esp], 76
	mov	ecx, DWORD PTR __Newvec$[esp]
	mov	DWORD PTR [esi], ecx
	add	eax, ecx
	mov	DWORD PTR [esi+4], eax

; 1739 :         _Myend   = _Newvec + _Newcapacity;

	imul	eax, DWORD PTR __Newcapacity$[esp], 76
	add	eax, ecx
	mov	DWORD PTR [esi+8], eax
	pop	esi

; 1740 :     }

	ret	12					; 0000000cH
?_Change_array@?$vector@U_MatrixItem@R_dsgraph@@V?$xalloc@U_MatrixItem@R_dsgraph@@@@@std@@AAEXQAU_MatrixItem@R_dsgraph@@II@Z ENDP ; std::vector<R_dsgraph::_MatrixItem,xalloc<R_dsgraph::_MatrixItem> >::_Change_array
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Calculate_growth@?$vector@U_MatrixItem@R_dsgraph@@V?$xalloc@U_MatrixItem@R_dsgraph@@@@@std@@ABEII@Z
_TEXT	SEGMENT
__Newsize$ = 8						; size = 4
?_Calculate_growth@?$vector@U_MatrixItem@R_dsgraph@@V?$xalloc@U_MatrixItem@R_dsgraph@@@@@std@@ABEII@Z PROC ; std::vector<R_dsgraph::_MatrixItem,xalloc<R_dsgraph::_MatrixItem> >::_Calculate_growth, COMDAT
; _this$ = ecx

; 1546 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx]

; 1671 :         // given _Oldcapacity and _Newsize, calculate geometric growth
; 1672 :         const size_type _Oldcapacity = capacity();
; 1673 :         const auto _Max              = max_size();
; 1674 : 
; 1675 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	ecx, 56512727				; 035e50d7H

; 1546 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	sar	eax, 2

; 1670 :     _CONSTEXPR20_CONTAINER size_type _Calculate_growth(const size_type _Newsize) const {

	push	esi

; 1546 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	imul	esi, eax, 678152731

; 1671 :         // given _Oldcapacity and _Newsize, calculate geometric growth
; 1672 :         const size_type _Oldcapacity = capacity();
; 1673 :         const auto _Max              = max_size();
; 1674 : 
; 1675 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	edx, esi
	shr	edx, 1
	sub	ecx, edx
	cmp	esi, ecx
	jbe	SHORT $LN2@Calculate_

; 1676 :             return _Max; // geometric growth would overflow

	mov	eax, 56512727				; 035e50d7H
	pop	esi

; 1682 :             return _Newsize; // geometric growth would be insufficient
; 1683 :         }
; 1684 : 
; 1685 :         return _Geometric; // geometric growth is sufficient
; 1686 :     }

	ret	4
$LN2@Calculate_:

; 1677 :         }
; 1678 : 
; 1679 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	lea	eax, DWORD PTR [edx+esi]

; 1680 : 
; 1681 :         if (_Geometric < _Newsize) {

	cmp	eax, DWORD PTR __Newsize$[esp]
	pop	esi
	cmovb	eax, DWORD PTR __Newsize$[esp-4]

; 1682 :             return _Newsize; // geometric growth would be insufficient
; 1683 :         }
; 1684 : 
; 1685 :         return _Geometric; // geometric growth is sufficient
; 1686 :     }

	ret	4
?_Calculate_growth@?$vector@U_MatrixItem@R_dsgraph@@V?$xalloc@U_MatrixItem@R_dsgraph@@@@@std@@ABEII@Z ENDP ; std::vector<R_dsgraph::_MatrixItem,xalloc<R_dsgraph::_MatrixItem> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Umove_if_noexcept@?$vector@U_MatrixItem@R_dsgraph@@V?$xalloc@U_MatrixItem@R_dsgraph@@@@@std@@AAEXPAU_MatrixItem@R_dsgraph@@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
?_Umove_if_noexcept@?$vector@U_MatrixItem@R_dsgraph@@V?$xalloc@U_MatrixItem@R_dsgraph@@@@@std@@AAEXPAU_MatrixItem@R_dsgraph@@00@Z PROC ; std::vector<R_dsgraph::_MatrixItem,xalloc<R_dsgraph::_MatrixItem> >::_Umove_if_noexcept, COMDAT
; _this$dead$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1703 :     auto _UFirst      = _Get_unwrapped(_First);

	mov	eax, DWORD PTR __First$[esp-4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1659 :     _CONSTEXPR20_CONTAINER void _Umove_if_noexcept(pointer _First, pointer _Last, pointer _Dest) {

	push	ebx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	mov	ebx, DWORD PTR __Last$[esp]
	cmp	eax, ebx
	je	SHORT $LN7@Umove_if_n

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	edx, DWORD PTR __Dest$[esp]
	push	esi
	sub	edx, eax
	push	edi
$LL8@Umove_if_n:
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	lea	edi, DWORD PTR [edx+eax]
	mov	esi, eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	add	eax, 76					; 0000004cH
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	ecx, 19					; 00000013H
	rep movsd
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	eax, ebx
	jne	SHORT $LL8@Umove_if_n
	pop	edi
	pop	esi
$LN7@Umove_if_n:
	pop	ebx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1663 :     }

	ret	12					; 0000000cH
?_Umove_if_noexcept@?$vector@U_MatrixItem@R_dsgraph@@V?$xalloc@U_MatrixItem@R_dsgraph@@@@@std@@AAEXPAU_MatrixItem@R_dsgraph@@00@Z ENDP ; std::vector<R_dsgraph::_MatrixItem,xalloc<R_dsgraph::_MatrixItem> >::_Umove_if_noexcept
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Umove@?$vector@U_MatrixItem@R_dsgraph@@V?$xalloc@U_MatrixItem@R_dsgraph@@@@@std@@AAEPAU_MatrixItem@R_dsgraph@@PAU34@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
?_Umove@?$vector@U_MatrixItem@R_dsgraph@@V?$xalloc@U_MatrixItem@R_dsgraph@@@@@std@@AAEPAU_MatrixItem@R_dsgraph@@PAU34@00@Z PROC ; std::vector<R_dsgraph::_MatrixItem,xalloc<R_dsgraph::_MatrixItem> >::_Umove, COMDAT
; _this$dead$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	mov	edx, DWORD PTR __First$[esp-4]

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	eax, DWORD PTR __Dest$[esp-4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1644 :     _CONSTEXPR20_CONTAINER pointer _Umove(pointer _First, pointer _Last, pointer _Dest) {

	push	ebx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	mov	ebx, DWORD PTR __Last$[esp]
	cmp	edx, ebx
	je	SHORT $LN5@Umove
	push	esi
	push	edi
$LL6@Umove:
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	esi, edx
	mov	edi, eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1621 :         ++_Last;

	add	edx, 76					; 0000004cH
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	ecx, 19					; 00000013H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1621 :         ++_Last;

	add	eax, 76					; 0000004cH
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	rep movsd
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	edx, ebx
	jne	SHORT $LL6@Umove
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1646 :         return _Uninitialized_move(_First, _Last, _Dest, _Getal());

	pop	edi
	pop	esi
$LN5@Umove:

; 1647 :     }

	pop	ebx
	ret	12					; 0000000cH
?_Umove@?$vector@U_MatrixItem@R_dsgraph@@V?$xalloc@U_MatrixItem@R_dsgraph@@@@@std@@AAEPAU_MatrixItem@R_dsgraph@@PAU34@00@Z ENDP ; std::vector<R_dsgraph::_MatrixItem,xalloc<R_dsgraph::_MatrixItem> >::_Umove
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?max_size@?$vector@U_MatrixItem@R_dsgraph@@V?$xalloc@U_MatrixItem@R_dsgraph@@@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@U_MatrixItem@R_dsgraph@@V?$xalloc@U_MatrixItem@R_dsgraph@@@@@std@@QBEIXZ PROC ; std::vector<R_dsgraph::_MatrixItem,xalloc<R_dsgraph::_MatrixItem> >::max_size, COMDAT
; _this$dead$ = ecx

; 1540 :         return (_STD min)(

	mov	eax, 56512727				; 035e50d7H

; 1541 :             static_cast<size_type>((numeric_limits<difference_type>::max)()), _Alty_traits::max_size(_Getal()));
; 1542 :     }

	ret	0
?max_size@?$vector@U_MatrixItem@R_dsgraph@@V?$xalloc@U_MatrixItem@R_dsgraph@@@@@std@@QBEIXZ ENDP ; std::vector<R_dsgraph::_MatrixItem,xalloc<R_dsgraph::_MatrixItem> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??1?$vector@U_MatrixItem@R_dsgraph@@V?$xalloc@U_MatrixItem@R_dsgraph@@@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@U_MatrixItem@R_dsgraph@@V?$xalloc@U_MatrixItem@R_dsgraph@@@@@std@@QAE@XZ PROC ; std::vector<R_dsgraph::_MatrixItem,xalloc<R_dsgraph::_MatrixItem> >::~vector<R_dsgraph::_MatrixItem,xalloc<R_dsgraph::_MatrixItem> >, COMDAT
; _this$ = ecx

; 698  :     _CONSTEXPR20_CONTAINER ~vector() noexcept {

	push	esi
	mov	esi, ecx

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN4@vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+4], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+8], 0
$LN4@vector:
	pop	esi

; 699  :         _Tidy();
; 700  : #if _ITERATOR_DEBUG_LEVEL != 0
; 701  :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 702  :         _Delete_plain_internal(_Alproxy, _STD exchange(_Mypair._Myval2._Myproxy, nullptr));
; 703  : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 704  :     }

	ret	0
??1?$vector@U_MatrixItem@R_dsgraph@@V?$xalloc@U_MatrixItem@R_dsgraph@@@@@std@@QAE@XZ ENDP ; std::vector<R_dsgraph::_MatrixItem,xalloc<R_dsgraph::_MatrixItem> >::~vector<R_dsgraph::_MatrixItem,xalloc<R_dsgraph::_MatrixItem> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?construct@?$xalloc@U_MatrixItem@R_dsgraph@@@@QAEXPAU_MatrixItem@R_dsgraph@@ABU23@@Z
_TEXT	SEGMENT
_p$ = 8							; size = 4
__Val$ = 12						; size = 4
?construct@?$xalloc@U_MatrixItem@R_dsgraph@@@@QAEXPAU_MatrixItem@R_dsgraph@@ABU23@@Z PROC ; xalloc<R_dsgraph::_MatrixItem>::construct, COMDAT
; _this$dead$ = ecx

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	push	esi
	mov	esi, DWORD PTR __Val$[esp]
	mov	ecx, 19					; 00000013H
	push	edi
	mov	edi, DWORD PTR _p$[esp+4]
	rep movsd
	pop	edi
	pop	esi
	ret	8
?construct@?$xalloc@U_MatrixItem@R_dsgraph@@@@QAEXPAU_MatrixItem@R_dsgraph@@ABU23@@Z ENDP ; xalloc<R_dsgraph::_MatrixItem>::construct
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?deallocate@?$xalloc@U_MatrixItem@R_dsgraph@@@@QBEXPAU_MatrixItem@R_dsgraph@@I@Z
_TEXT	SEGMENT
_p$ = 8							; size = 4
_n$dead$ = 12						; size = 4
?deallocate@?$xalloc@U_MatrixItem@R_dsgraph@@@@QBEXPAU_MatrixItem@R_dsgraph@@I@Z PROC ; xalloc<R_dsgraph::_MatrixItem>::deallocate, COMDAT
; _this$dead$ = ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	eax, DWORD PTR _p$[esp-4]
	test	eax, eax
	je	SHORT $LN4@deallocate
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN4@deallocate:
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 82   : 							void					deallocate		(pointer p, size_type n) const			{	xr_free	(p);				}

	ret	8
?deallocate@?$xalloc@U_MatrixItem@R_dsgraph@@@@QBEXPAU_MatrixItem@R_dsgraph@@I@Z ENDP ; xalloc<R_dsgraph::_MatrixItem>::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?allocate@?$xalloc@U_MatrixItem@R_dsgraph@@@@QBEPAU_MatrixItem@R_dsgraph@@IPBX@Z
_TEXT	SEGMENT
_n$ = 8							; size = 4
_p$dead$ = 12						; size = 4
?allocate@?$xalloc@U_MatrixItem@R_dsgraph@@@@QBEPAU_MatrixItem@R_dsgraph@@IPBX@Z PROC ; xalloc<R_dsgraph::_MatrixItem>::allocate, COMDAT
; _this$dead$ = ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	imul	eax, DWORD PTR _n$[esp-4], 76
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 80   : 							pointer					allocate		(size_type n, const void* p=0) const	{	return xr_alloc<T>((u32)n);	}

	ret	8
?allocate@?$xalloc@U_MatrixItem@R_dsgraph@@@@QBEPAU_MatrixItem@R_dsgraph@@IPBX@Z ENDP ; xalloc<R_dsgraph::_MatrixItem>::allocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??_Gcaster@CLightShadows@@QAEPAXI@Z
_TEXT	SEGMENT
___flags$dead$ = 8					; size = 4
??_Gcaster@CLightShadows@@QAEPAXI@Z PROC		; CLightShadows::caster::`scalar deleting destructor', COMDAT
; _this$ = ecx

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	push	esi
	mov	esi, ecx
	mov	eax, DWORD PTR [esi+20]
	test	eax, eax
	je	SHORT $LN18@scalar
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi+20], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+24], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+28], 0
$LN18@scalar:
	mov	eax, esi
	pop	esi
	ret	4
??_Gcaster@CLightShadows@@QAEPAXI@Z ENDP		; CLightShadows::caster::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??1caster@CLightShadows@@QAE@XZ
_TEXT	SEGMENT
??1caster@CLightShadows@@QAE@XZ PROC			; CLightShadows::caster::~caster, COMDAT
; _this$ = ecx

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	push	esi
	mov	esi, ecx
	mov	eax, DWORD PTR [esi+20]
	test	eax, eax
	je	SHORT $LN8@caster
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi+20], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+24], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+28], 0
$LN8@caster:
	pop	esi
	ret	0
??1caster@CLightShadows@@QAE@XZ ENDP			; CLightShadows::caster::~caster
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Getal@?$vector@Utess_tri@CLightShadows@@V?$xalloc@Utess_tri@CLightShadows@@@@@std@@ABEABV?$xalloc@Utess_tri@CLightShadows@@@@XZ
_TEXT	SEGMENT
?_Getal@?$vector@Utess_tri@CLightShadows@@V?$xalloc@Utess_tri@CLightShadows@@@@@std@@ABEABV?$xalloc@Utess_tri@CLightShadows@@@@XZ PROC ; std::vector<CLightShadows::tess_tri,xalloc<CLightShadows::tess_tri> >::_Getal, COMDAT
; _this$ = ecx

; 1809 :         return _Mypair._Get_first();

	mov	eax, ecx

; 1810 :     }

	ret	0
?_Getal@?$vector@Utess_tri@CLightShadows@@V?$xalloc@Utess_tri@CLightShadows@@@@@std@@ABEABV?$xalloc@Utess_tri@CLightShadows@@@@XZ ENDP ; std::vector<CLightShadows::tess_tri,xalloc<CLightShadows::tess_tri> >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Umove_if_noexcept1@?$vector@Utess_tri@CLightShadows@@V?$xalloc@Utess_tri@CLightShadows@@@@@std@@AAEXPAUtess_tri@CLightShadows@@00U?$integral_constant@_N$00@2@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
?_Umove_if_noexcept1@?$vector@Utess_tri@CLightShadows@@V?$xalloc@Utess_tri@CLightShadows@@@@@std@@AAEXPAUtess_tri@CLightShadows@@00U?$integral_constant@_N$00@2@@Z PROC ; std::vector<CLightShadows::tess_tri,xalloc<CLightShadows::tess_tri> >::_Umove_if_noexcept1, COMDAT
; _this$dead$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1703 :     auto _UFirst      = _Get_unwrapped(_First);

	mov	eax, DWORD PTR __First$[esp-4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1649 :     _CONSTEXPR20_CONTAINER void _Umove_if_noexcept1(pointer _First, pointer _Last, pointer _Dest, true_type) {

	push	ebx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	mov	ebx, DWORD PTR __Last$[esp]
	cmp	eax, ebx
	je	SHORT $LN5@Umove_if_n

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	edx, DWORD PTR __Dest$[esp]
	push	esi
	sub	edx, eax
	push	edi
$LL6@Umove_if_n:
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	lea	edi, DWORD PTR [edx+eax]
	mov	esi, eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	add	eax, 48					; 00000030H
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	ecx, 12					; 0000000cH
	rep movsd
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	eax, ebx
	jne	SHORT $LL6@Umove_if_n
	pop	edi
	pop	esi
$LN5@Umove_if_n:
	pop	ebx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1652 :     }

	ret	16					; 00000010H
?_Umove_if_noexcept1@?$vector@Utess_tri@CLightShadows@@V?$xalloc@Utess_tri@CLightShadows@@@@@std@@AAEXPAUtess_tri@CLightShadows@@00U?$integral_constant@_N$00@2@@Z ENDP ; std::vector<CLightShadows::tess_tri,xalloc<CLightShadows::tess_tri> >::_Umove_if_noexcept1
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?capacity@?$vector@Utess_tri@CLightShadows@@V?$xalloc@Utess_tri@CLightShadows@@@@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@Utess_tri@CLightShadows@@V?$xalloc@Utess_tri@CLightShadows@@@@@std@@QBEIXZ PROC ; std::vector<CLightShadows::tess_tri,xalloc<CLightShadows::tess_tri> >::capacity, COMDAT
; _this$ = ecx

; 1545 :         auto& _My_data = _Mypair._Myval2;
; 1546 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx]
	sar	eax, 4
	imul	eax, eax, -1431655765

; 1547 :     }

	ret	0
?capacity@?$vector@Utess_tri@CLightShadows@@V?$xalloc@Utess_tri@CLightShadows@@@@@std@@QBEIXZ ENDP ; std::vector<CLightShadows::tess_tri,xalloc<CLightShadows::tess_tri> >::capacity
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?max_size@?$_Normal_allocator_traits@V?$xalloc@Utess_tri@CLightShadows@@@@@std@@SAIABV?$xalloc@Utess_tri@CLightShadows@@@@@Z
_TEXT	SEGMENT
?max_size@?$_Normal_allocator_traits@V?$xalloc@Utess_tri@CLightShadows@@@@@std@@SAIABV?$xalloc@Utess_tri@CLightShadows@@@@@Z PROC ; std::_Normal_allocator_traits<xalloc<CLightShadows::tess_tri> >::max_size, COMDAT
; __Al$dead$ = ecx

; 591  :         if constexpr (_Has_max_size<_Alloc>::value) {
; 592  :             return _Al.max_size();

	mov	eax, 89478485				; 05555555H

; 593  :         } else {
; 594  :             return (numeric_limits<size_type>::max)() / sizeof(value_type);
; 595  :         }
; 596  :     }

	ret	0
?max_size@?$_Normal_allocator_traits@V?$xalloc@Utess_tri@CLightShadows@@@@@std@@SAIABV?$xalloc@Utess_tri@CLightShadows@@@@@Z ENDP ; std::_Normal_allocator_traits<xalloc<CLightShadows::tess_tri> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Getal@?$vector@Ushadow@CLightShadows@@V?$xalloc@Ushadow@CLightShadows@@@@@std@@ABEABV?$xalloc@Ushadow@CLightShadows@@@@XZ
_TEXT	SEGMENT
?_Getal@?$vector@Ushadow@CLightShadows@@V?$xalloc@Ushadow@CLightShadows@@@@@std@@ABEABV?$xalloc@Ushadow@CLightShadows@@@@XZ PROC ; std::vector<CLightShadows::shadow,xalloc<CLightShadows::shadow> >::_Getal, COMDAT
; _this$ = ecx

; 1809 :         return _Mypair._Get_first();

	mov	eax, ecx

; 1810 :     }

	ret	0
?_Getal@?$vector@Ushadow@CLightShadows@@V?$xalloc@Ushadow@CLightShadows@@@@@std@@ABEABV?$xalloc@Ushadow@CLightShadows@@@@XZ ENDP ; std::vector<CLightShadows::shadow,xalloc<CLightShadows::shadow> >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Umove_if_noexcept1@?$vector@Ushadow@CLightShadows@@V?$xalloc@Ushadow@CLightShadows@@@@@std@@AAEXPAUshadow@CLightShadows@@00U?$integral_constant@_N$00@2@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
?_Umove_if_noexcept1@?$vector@Ushadow@CLightShadows@@V?$xalloc@Ushadow@CLightShadows@@@@@std@@AAEXPAUshadow@CLightShadows@@00U?$integral_constant@_N$00@2@@Z PROC ; std::vector<CLightShadows::shadow,xalloc<CLightShadows::shadow> >::_Umove_if_noexcept1, COMDAT
; _this$dead$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1703 :     auto _UFirst      = _Get_unwrapped(_First);

	mov	eax, DWORD PTR __First$[esp-4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1649 :     _CONSTEXPR20_CONTAINER void _Umove_if_noexcept1(pointer _First, pointer _Last, pointer _Dest, true_type) {

	push	ebx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	mov	ebx, DWORD PTR __Last$[esp]
	cmp	eax, ebx
	je	SHORT $LN5@Umove_if_n

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	edx, DWORD PTR __Dest$[esp]
	push	esi
	sub	edx, eax
	push	edi
$LL6@Umove_if_n:
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	lea	edi, DWORD PTR [edx+eax]
	mov	esi, eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	add	eax, 92					; 0000005cH
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	ecx, 23					; 00000017H
	rep movsd
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	eax, ebx
	jne	SHORT $LL6@Umove_if_n
	pop	edi
	pop	esi
$LN5@Umove_if_n:
	pop	ebx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1652 :     }

	ret	16					; 00000010H
?_Umove_if_noexcept1@?$vector@Ushadow@CLightShadows@@V?$xalloc@Ushadow@CLightShadows@@@@@std@@AAEXPAUshadow@CLightShadows@@00U?$integral_constant@_N$00@2@@Z ENDP ; std::vector<CLightShadows::shadow,xalloc<CLightShadows::shadow> >::_Umove_if_noexcept1
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?capacity@?$vector@Ushadow@CLightShadows@@V?$xalloc@Ushadow@CLightShadows@@@@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@Ushadow@CLightShadows@@V?$xalloc@Ushadow@CLightShadows@@@@@std@@QBEIXZ PROC ; std::vector<CLightShadows::shadow,xalloc<CLightShadows::shadow> >::capacity, COMDAT
; _this$ = ecx

; 1544 :     _NODISCARD _CONSTEXPR20_CONTAINER size_type capacity() const noexcept {

	push	esi

; 1545 :         auto& _My_data = _Mypair._Myval2;
; 1546 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	esi, DWORD PTR [ecx+8]
	mov	eax, -1307163959			; b21642c9H
	sub	esi, DWORD PTR [ecx]
	imul	esi
	add	edx, esi
	sar	edx, 6
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	pop	esi

; 1547 :     }

	ret	0
?capacity@?$vector@Ushadow@CLightShadows@@V?$xalloc@Ushadow@CLightShadows@@@@@std@@QBEIXZ ENDP ; std::vector<CLightShadows::shadow,xalloc<CLightShadows::shadow> >::capacity
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?max_size@?$_Normal_allocator_traits@V?$xalloc@Ushadow@CLightShadows@@@@@std@@SAIABV?$xalloc@Ushadow@CLightShadows@@@@@Z
_TEXT	SEGMENT
?max_size@?$_Normal_allocator_traits@V?$xalloc@Ushadow@CLightShadows@@@@@std@@SAIABV?$xalloc@Ushadow@CLightShadows@@@@@Z PROC ; std::_Normal_allocator_traits<xalloc<CLightShadows::shadow> >::max_size, COMDAT
; __Al$dead$ = ecx

; 591  :         if constexpr (_Has_max_size<_Alloc>::value) {
; 592  :             return _Al.max_size();

	mov	eax, 46684427				; 02c8590bH

; 593  :         } else {
; 594  :             return (numeric_limits<size_type>::max)() / sizeof(value_type);
; 595  :         }
; 596  :     }

	ret	0
?max_size@?$_Normal_allocator_traits@V?$xalloc@Ushadow@CLightShadows@@@@@std@@SAIABV?$xalloc@Ushadow@CLightShadows@@@@@Z ENDP ; std::_Normal_allocator_traits<xalloc<CLightShadows::shadow> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Getal@?$vector@PAUcaster@CLightShadows@@V?$xalloc@PAUcaster@CLightShadows@@@@@std@@ABEABV?$xalloc@PAUcaster@CLightShadows@@@@XZ
_TEXT	SEGMENT
?_Getal@?$vector@PAUcaster@CLightShadows@@V?$xalloc@PAUcaster@CLightShadows@@@@@std@@ABEABV?$xalloc@PAUcaster@CLightShadows@@@@XZ PROC ; std::vector<CLightShadows::caster *,xalloc<CLightShadows::caster *> >::_Getal, COMDAT
; _this$ = ecx

; 1809 :         return _Mypair._Get_first();

	mov	eax, ecx

; 1810 :     }

	ret	0
?_Getal@?$vector@PAUcaster@CLightShadows@@V?$xalloc@PAUcaster@CLightShadows@@@@@std@@ABEABV?$xalloc@PAUcaster@CLightShadows@@@@XZ ENDP ; std::vector<CLightShadows::caster *,xalloc<CLightShadows::caster *> >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Umove_if_noexcept1@?$vector@PAUcaster@CLightShadows@@V?$xalloc@PAUcaster@CLightShadows@@@@@std@@AAEXPAPAUcaster@CLightShadows@@00U?$integral_constant@_N$00@2@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
?_Umove_if_noexcept1@?$vector@PAUcaster@CLightShadows@@V?$xalloc@PAUcaster@CLightShadows@@@@@std@@AAEXPAPAUcaster@CLightShadows@@00U?$integral_constant@_N$00@2@@Z PROC ; std::vector<CLightShadows::caster *,xalloc<CLightShadows::caster *> >::_Umove_if_noexcept1, COMDAT
; _this$dead$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1703 :     auto _UFirst      = _Get_unwrapped(_First);

	mov	eax, DWORD PTR __First$[esp-4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1649 :     _CONSTEXPR20_CONTAINER void _Umove_if_noexcept1(pointer _First, pointer _Last, pointer _Dest, true_type) {

	push	esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	mov	esi, DWORD PTR __Last$[esp]
	cmp	eax, esi
	je	SHORT $LN5@Umove_if_n

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	edx, DWORD PTR __Dest$[esp]
	sub	edx, eax
$LL6@Umove_if_n:

; 1620 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx+eax], ecx

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	add	eax, 4
	cmp	eax, esi
	jne	SHORT $LL6@Umove_if_n
$LN5@Umove_if_n:
	pop	esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1652 :     }

	ret	16					; 00000010H
?_Umove_if_noexcept1@?$vector@PAUcaster@CLightShadows@@V?$xalloc@PAUcaster@CLightShadows@@@@@std@@AAEXPAPAUcaster@CLightShadows@@00U?$integral_constant@_N$00@2@@Z ENDP ; std::vector<CLightShadows::caster *,xalloc<CLightShadows::caster *> >::_Umove_if_noexcept1
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?capacity@?$vector@PAUcaster@CLightShadows@@V?$xalloc@PAUcaster@CLightShadows@@@@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@PAUcaster@CLightShadows@@V?$xalloc@PAUcaster@CLightShadows@@@@@std@@QBEIXZ PROC ; std::vector<CLightShadows::caster *,xalloc<CLightShadows::caster *> >::capacity, COMDAT
; _this$ = ecx

; 1545 :         auto& _My_data = _Mypair._Myval2;
; 1546 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx]
	sar	eax, 2

; 1547 :     }

	ret	0
?capacity@?$vector@PAUcaster@CLightShadows@@V?$xalloc@PAUcaster@CLightShadows@@@@@std@@QBEIXZ ENDP ; std::vector<CLightShadows::caster *,xalloc<CLightShadows::caster *> >::capacity
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?max_size@?$_Normal_allocator_traits@V?$xalloc@PAUcaster@CLightShadows@@@@@std@@SAIABV?$xalloc@PAUcaster@CLightShadows@@@@@Z
_TEXT	SEGMENT
?max_size@?$_Normal_allocator_traits@V?$xalloc@PAUcaster@CLightShadows@@@@@std@@SAIABV?$xalloc@PAUcaster@CLightShadows@@@@@Z PROC ; std::_Normal_allocator_traits<xalloc<CLightShadows::caster *> >::max_size, COMDAT
; __Al$dead$ = ecx

; 591  :         if constexpr (_Has_max_size<_Alloc>::value) {
; 592  :             return _Al.max_size();

	mov	eax, 1073741823				; 3fffffffH

; 593  :         } else {
; 594  :             return (numeric_limits<size_type>::max)() / sizeof(value_type);
; 595  :         }
; 596  :     }

	ret	0
?max_size@?$_Normal_allocator_traits@V?$xalloc@PAUcaster@CLightShadows@@@@@std@@SAIABV?$xalloc@PAUcaster@CLightShadows@@@@@Z ENDP ; std::_Normal_allocator_traits<xalloc<CLightShadows::caster *> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Getal@?$vector@U_MatrixItem@R_dsgraph@@V?$xalloc@U_MatrixItem@R_dsgraph@@@@@std@@ABEABV?$xalloc@U_MatrixItem@R_dsgraph@@@@XZ
_TEXT	SEGMENT
?_Getal@?$vector@U_MatrixItem@R_dsgraph@@V?$xalloc@U_MatrixItem@R_dsgraph@@@@@std@@ABEABV?$xalloc@U_MatrixItem@R_dsgraph@@@@XZ PROC ; std::vector<R_dsgraph::_MatrixItem,xalloc<R_dsgraph::_MatrixItem> >::_Getal, COMDAT
; _this$ = ecx

; 1809 :         return _Mypair._Get_first();

	mov	eax, ecx

; 1810 :     }

	ret	0
?_Getal@?$vector@U_MatrixItem@R_dsgraph@@V?$xalloc@U_MatrixItem@R_dsgraph@@@@@std@@ABEABV?$xalloc@U_MatrixItem@R_dsgraph@@@@XZ ENDP ; std::vector<R_dsgraph::_MatrixItem,xalloc<R_dsgraph::_MatrixItem> >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Tidy@?$vector@U_MatrixItem@R_dsgraph@@V?$xalloc@U_MatrixItem@R_dsgraph@@@@@std@@AAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@U_MatrixItem@R_dsgraph@@V?$xalloc@U_MatrixItem@R_dsgraph@@@@@std@@AAEXXZ PROC ; std::vector<R_dsgraph::_MatrixItem,xalloc<R_dsgraph::_MatrixItem> >::_Tidy, COMDAT
; _this$ = ecx

; 1742 :     _CONSTEXPR20_CONTAINER void _Tidy() noexcept { // free all storage

	push	esi
	mov	esi, ecx

; 1743 :         auto& _My_data    = _Mypair._Myval2;
; 1744 :         pointer& _Myfirst = _My_data._Myfirst;
; 1745 :         pointer& _Mylast  = _My_data._Mylast;
; 1746 :         pointer& _Myend   = _My_data._Myend;
; 1747 : 
; 1748 :         _My_data._Orphan_all();
; 1749 : 
; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN2@Tidy
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+4], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+8], 0
$LN2@Tidy:

; 1757 :         }
; 1758 :     }

	pop	esi
	ret	0
?_Tidy@?$vector@U_MatrixItem@R_dsgraph@@V?$xalloc@U_MatrixItem@R_dsgraph@@@@@std@@AAEXXZ ENDP ; std::vector<R_dsgraph::_MatrixItem,xalloc<R_dsgraph::_MatrixItem> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Umove_if_noexcept1@?$vector@U_MatrixItem@R_dsgraph@@V?$xalloc@U_MatrixItem@R_dsgraph@@@@@std@@AAEXPAU_MatrixItem@R_dsgraph@@00U?$integral_constant@_N$00@2@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
?_Umove_if_noexcept1@?$vector@U_MatrixItem@R_dsgraph@@V?$xalloc@U_MatrixItem@R_dsgraph@@@@@std@@AAEXPAU_MatrixItem@R_dsgraph@@00U?$integral_constant@_N$00@2@@Z PROC ; std::vector<R_dsgraph::_MatrixItem,xalloc<R_dsgraph::_MatrixItem> >::_Umove_if_noexcept1, COMDAT
; _this$dead$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1703 :     auto _UFirst      = _Get_unwrapped(_First);

	mov	eax, DWORD PTR __First$[esp-4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1649 :     _CONSTEXPR20_CONTAINER void _Umove_if_noexcept1(pointer _First, pointer _Last, pointer _Dest, true_type) {

	push	ebx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	mov	ebx, DWORD PTR __Last$[esp]
	cmp	eax, ebx
	je	SHORT $LN5@Umove_if_n

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	edx, DWORD PTR __Dest$[esp]
	push	esi
	sub	edx, eax
	push	edi
$LL6@Umove_if_n:
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	lea	edi, DWORD PTR [edx+eax]
	mov	esi, eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	add	eax, 76					; 0000004cH
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	ecx, 19					; 00000013H
	rep movsd
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	eax, ebx
	jne	SHORT $LL6@Umove_if_n
	pop	edi
	pop	esi
$LN5@Umove_if_n:
	pop	ebx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1652 :     }

	ret	16					; 00000010H
?_Umove_if_noexcept1@?$vector@U_MatrixItem@R_dsgraph@@V?$xalloc@U_MatrixItem@R_dsgraph@@@@@std@@AAEXPAU_MatrixItem@R_dsgraph@@00U?$integral_constant@_N$00@2@@Z ENDP ; std::vector<R_dsgraph::_MatrixItem,xalloc<R_dsgraph::_MatrixItem> >::_Umove_if_noexcept1
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?capacity@?$vector@U_MatrixItem@R_dsgraph@@V?$xalloc@U_MatrixItem@R_dsgraph@@@@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@U_MatrixItem@R_dsgraph@@V?$xalloc@U_MatrixItem@R_dsgraph@@@@@std@@QBEIXZ PROC ; std::vector<R_dsgraph::_MatrixItem,xalloc<R_dsgraph::_MatrixItem> >::capacity, COMDAT
; _this$ = ecx

; 1545 :         auto& _My_data = _Mypair._Myval2;
; 1546 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx]
	sar	eax, 2
	imul	eax, eax, 678152731

; 1547 :     }

	ret	0
?capacity@?$vector@U_MatrixItem@R_dsgraph@@V?$xalloc@U_MatrixItem@R_dsgraph@@@@@std@@QBEIXZ ENDP ; std::vector<R_dsgraph::_MatrixItem,xalloc<R_dsgraph::_MatrixItem> >::capacity
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0?$vector@U_MatrixItem@R_dsgraph@@V?$xalloc@U_MatrixItem@R_dsgraph@@@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@U_MatrixItem@R_dsgraph@@V?$xalloc@U_MatrixItem@R_dsgraph@@@@@std@@QAE@XZ PROC ; std::vector<R_dsgraph::_MatrixItem,xalloc<R_dsgraph::_MatrixItem> >::vector<R_dsgraph::_MatrixItem,xalloc<R_dsgraph::_MatrixItem> >, COMDAT
; _this$ = ecx

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx], 0

; 464  :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 465  :     }

	mov	eax, ecx

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0

; 464  :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 465  :     }

	ret	0
??0?$vector@U_MatrixItem@R_dsgraph@@V?$xalloc@U_MatrixItem@R_dsgraph@@@@@std@@QAE@XZ ENDP ; std::vector<R_dsgraph::_MatrixItem,xalloc<R_dsgraph::_MatrixItem> >::vector<R_dsgraph::_MatrixItem,xalloc<R_dsgraph::_MatrixItem> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?max_size@?$_Normal_allocator_traits@V?$xalloc@U_MatrixItem@R_dsgraph@@@@@std@@SAIABV?$xalloc@U_MatrixItem@R_dsgraph@@@@@Z
_TEXT	SEGMENT
?max_size@?$_Normal_allocator_traits@V?$xalloc@U_MatrixItem@R_dsgraph@@@@@std@@SAIABV?$xalloc@U_MatrixItem@R_dsgraph@@@@@Z PROC ; std::_Normal_allocator_traits<xalloc<R_dsgraph::_MatrixItem> >::max_size, COMDAT
; __Al$dead$ = ecx

; 591  :         if constexpr (_Has_max_size<_Alloc>::value) {
; 592  :             return _Al.max_size();

	mov	eax, 56512727				; 035e50d7H

; 593  :         } else {
; 594  :             return (numeric_limits<size_type>::max)() / sizeof(value_type);
; 595  :         }
; 596  :     }

	ret	0
?max_size@?$_Normal_allocator_traits@V?$xalloc@U_MatrixItem@R_dsgraph@@@@@std@@SAIABV?$xalloc@U_MatrixItem@R_dsgraph@@@@@Z ENDP ; std::_Normal_allocator_traits<xalloc<R_dsgraph::_MatrixItem> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$xalloc@Utess_tri@CLightShadows@@@@V?$_Vector_val@U?$_Simple_types@Utess_tri@CLightShadows@@@std@@@std@@$00@std@@QBEABV?$xalloc@Utess_tri@CLightShadows@@@@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@V?$xalloc@Utess_tri@CLightShadows@@@@V?$_Vector_val@U?$_Simple_types@Utess_tri@CLightShadows@@@std@@@std@@$00@std@@QBEABV?$xalloc@Utess_tri@CLightShadows@@@@XZ PROC ; std::_Compressed_pair<xalloc<CLightShadows::tess_tri>,std::_Vector_val<std::_Simple_types<CLightShadows::tess_tri> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 1343 :         return *this;

	mov	eax, ecx

; 1344 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$xalloc@Utess_tri@CLightShadows@@@@V?$_Vector_val@U?$_Simple_types@Utess_tri@CLightShadows@@@std@@@std@@$00@std@@QBEABV?$xalloc@Utess_tri@CLightShadows@@@@XZ ENDP ; std::_Compressed_pair<xalloc<CLightShadows::tess_tri>,std::_Vector_val<std::_Simple_types<CLightShadows::tess_tri> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?max_size@?$xalloc@Utess_tri@CLightShadows@@@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$xalloc@Utess_tri@CLightShadows@@@@QBEIXZ PROC ; xalloc<CLightShadows::tess_tri>::max_size, COMDAT
; _this$dead$ = ecx

; 86   : 							size_type				max_size		() const								{	size_type _Count = (size_type)(-1) / sizeof (T);	return (0 < _Count ? _Count : 1);	}

	mov	eax, 89478485				; 05555555H
	ret	0
?max_size@?$xalloc@Utess_tri@CLightShadows@@@@QBEIXZ ENDP ; xalloc<CLightShadows::tess_tri>::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$xalloc@Ushadow@CLightShadows@@@@V?$_Vector_val@U?$_Simple_types@Ushadow@CLightShadows@@@std@@@std@@$00@std@@QBEABV?$xalloc@Ushadow@CLightShadows@@@@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@V?$xalloc@Ushadow@CLightShadows@@@@V?$_Vector_val@U?$_Simple_types@Ushadow@CLightShadows@@@std@@@std@@$00@std@@QBEABV?$xalloc@Ushadow@CLightShadows@@@@XZ PROC ; std::_Compressed_pair<xalloc<CLightShadows::shadow>,std::_Vector_val<std::_Simple_types<CLightShadows::shadow> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 1343 :         return *this;

	mov	eax, ecx

; 1344 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$xalloc@Ushadow@CLightShadows@@@@V?$_Vector_val@U?$_Simple_types@Ushadow@CLightShadows@@@std@@@std@@$00@std@@QBEABV?$xalloc@Ushadow@CLightShadows@@@@XZ ENDP ; std::_Compressed_pair<xalloc<CLightShadows::shadow>,std::_Vector_val<std::_Simple_types<CLightShadows::shadow> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?max_size@?$xalloc@Ushadow@CLightShadows@@@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$xalloc@Ushadow@CLightShadows@@@@QBEIXZ PROC	; xalloc<CLightShadows::shadow>::max_size, COMDAT
; _this$dead$ = ecx

; 86   : 							size_type				max_size		() const								{	size_type _Count = (size_type)(-1) / sizeof (T);	return (0 < _Count ? _Count : 1);	}

	mov	eax, 46684427				; 02c8590bH
	ret	0
?max_size@?$xalloc@Ushadow@CLightShadows@@@@QBEIXZ ENDP	; xalloc<CLightShadows::shadow>::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$xalloc@PAUcaster@CLightShadows@@@@V?$_Vector_val@U?$_Simple_types@PAUcaster@CLightShadows@@@std@@@std@@$00@std@@QBEABV?$xalloc@PAUcaster@CLightShadows@@@@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@V?$xalloc@PAUcaster@CLightShadows@@@@V?$_Vector_val@U?$_Simple_types@PAUcaster@CLightShadows@@@std@@@std@@$00@std@@QBEABV?$xalloc@PAUcaster@CLightShadows@@@@XZ PROC ; std::_Compressed_pair<xalloc<CLightShadows::caster *>,std::_Vector_val<std::_Simple_types<CLightShadows::caster *> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 1343 :         return *this;

	mov	eax, ecx

; 1344 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$xalloc@PAUcaster@CLightShadows@@@@V?$_Vector_val@U?$_Simple_types@PAUcaster@CLightShadows@@@std@@@std@@$00@std@@QBEABV?$xalloc@PAUcaster@CLightShadows@@@@XZ ENDP ; std::_Compressed_pair<xalloc<CLightShadows::caster *>,std::_Vector_val<std::_Simple_types<CLightShadows::caster *> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?max_size@?$xalloc@PAUcaster@CLightShadows@@@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$xalloc@PAUcaster@CLightShadows@@@@QBEIXZ PROC ; xalloc<CLightShadows::caster *>::max_size, COMDAT
; _this$dead$ = ecx

; 86   : 							size_type				max_size		() const								{	size_type _Count = (size_type)(-1) / sizeof (T);	return (0 < _Count ? _Count : 1);	}

	mov	eax, 1073741823				; 3fffffffH
	ret	0
?max_size@?$xalloc@PAUcaster@CLightShadows@@@@QBEIXZ ENDP ; xalloc<CLightShadows::caster *>::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$xalloc@U_MatrixItem@R_dsgraph@@@@V?$_Vector_val@U?$_Simple_types@U_MatrixItem@R_dsgraph@@@std@@@std@@$00@std@@QBEABV?$xalloc@U_MatrixItem@R_dsgraph@@@@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@V?$xalloc@U_MatrixItem@R_dsgraph@@@@V?$_Vector_val@U?$_Simple_types@U_MatrixItem@R_dsgraph@@@std@@@std@@$00@std@@QBEABV?$xalloc@U_MatrixItem@R_dsgraph@@@@XZ PROC ; std::_Compressed_pair<xalloc<R_dsgraph::_MatrixItem>,std::_Vector_val<std::_Simple_types<R_dsgraph::_MatrixItem> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 1343 :         return *this;

	mov	eax, ecx

; 1344 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$xalloc@U_MatrixItem@R_dsgraph@@@@V?$_Vector_val@U?$_Simple_types@U_MatrixItem@R_dsgraph@@@std@@@std@@$00@std@@QBEABV?$xalloc@U_MatrixItem@R_dsgraph@@@@XZ ENDP ; std::_Compressed_pair<xalloc<R_dsgraph::_MatrixItem>,std::_Vector_val<std::_Simple_types<R_dsgraph::_MatrixItem> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?max_size@?$xalloc@U_MatrixItem@R_dsgraph@@@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$xalloc@U_MatrixItem@R_dsgraph@@@@QBEIXZ PROC ; xalloc<R_dsgraph::_MatrixItem>::max_size, COMDAT
; _this$dead$ = ecx

; 86   : 							size_type				max_size		() const								{	size_type _Count = (size_type)(-1) / sizeof (T);	return (0 < _Count ? _Count : 1);	}

	mov	eax, 56512727				; 035e50d7H
	ret	0
?max_size@?$xalloc@U_MatrixItem@R_dsgraph@@@@QBEIXZ ENDP ; xalloc<R_dsgraph::_MatrixItem>::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_Adl_verify_range@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@Ucache_item@CLightShadows@@@std@@@std@@@std@@V12@@std@@YAXABV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@Ucache_item@CLightShadows@@@std@@@std@@@0@0@Z
_TEXT	SEGMENT
??$_Adl_verify_range@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@Ucache_item@CLightShadows@@@std@@@std@@@std@@V12@@std@@YAXABV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@Ucache_item@CLightShadows@@@std@@@std@@@0@0@Z PROC ; std::_Adl_verify_range<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CLightShadows::cache_item> > >,std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CLightShadows::cache_item> > > >, COMDAT
; __First$dead$ = ecx
; __Last$dead$ = edx

; 1259 :     // check that [_First, _Last) forms an iterator range
; 1260 :     if constexpr (_Range_verifiable_v<_Iter, _Sentinel>) {
; 1261 :         _Verify_range(_First, _Last);
; 1262 :     }
; 1263 : }

	ret	0
??$_Adl_verify_range@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@Ucache_item@CLightShadows@@@std@@@std@@@std@@V12@@std@@YAXABV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@Ucache_item@CLightShadows@@@std@@@std@@@0@0@Z ENDP ; std::_Adl_verify_range<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CLightShadows::cache_item> > >,std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CLightShadows::cache_item> > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$distance@PAUcache_item@CLightShadows@@@std@@YAHPAUcache_item@CLightShadows@@0@Z
_TEXT	SEGMENT
??$distance@PAUcache_item@CLightShadows@@@std@@YAHPAUcache_item@CLightShadows@@0@Z PROC ; std::distance<CLightShadows::cache_item *>, COMDAT
; __First$ = ecx
; __Last$ = edx

; 1524 :     if constexpr (_Is_random_iter_v<_InIt>) {
; 1525 :         return _Last - _First; // assume the iterator will do debug checking

	sub	edx, ecx
	sar	edx, 2
	imul	eax, edx, -1171354717

; 1526 :     } else {
; 1527 :         _Adl_verify_range(_First, _Last);
; 1528 :         auto _UFirst             = _Get_unwrapped(_First);
; 1529 :         const auto _ULast        = _Get_unwrapped(_Last);
; 1530 :         _Iter_diff_t<_InIt> _Off = 0;
; 1531 :         for (; _UFirst != _ULast; ++_UFirst) {
; 1532 :             ++_Off;
; 1533 :         }
; 1534 : 
; 1535 :         return _Off;
; 1536 :     }
; 1537 : }

	ret	0
??$distance@PAUcache_item@CLightShadows@@@std@@YAHPAUcache_item@CLightShadows@@0@Z ENDP ; std::distance<CLightShadows::cache_item *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$next@PAUcache_item@CLightShadows@@@std@@YAPAUcache_item@CLightShadows@@PAU12@H@Z
_TEXT	SEGMENT
??$next@PAUcache_item@CLightShadows@@@std@@YAPAUcache_item@CLightShadows@@PAU12@H@Z PROC ; std::next<CLightShadows::cache_item *>, COMDAT
; __First$ = ecx
; __Off$ = edx

; 1497 :         _Where += _Off;

	imul	eax, edx, 44
	add	eax, ecx

; 1546 :     static_assert(_Is_input_iter_v<_InIt>, "next requires input iterator");
; 1547 : 
; 1548 :     _STD advance(_First, _Off);
; 1549 :     return _First;
; 1550 : }

	ret	0
??$next@PAUcache_item@CLightShadows@@@std@@YAPAUcache_item@CLightShadows@@PAU12@H@Z ENDP ; std::next<CLightShadows::cache_item *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_Next_iter@PAUcache_item@CLightShadows@@@std@@YAPAUcache_item@CLightShadows@@PAU12@@Z
_TEXT	SEGMENT
??$_Next_iter@PAUcache_item@CLightShadows@@@std@@YAPAUcache_item@CLightShadows@@PAU12@@Z PROC ; std::_Next_iter<CLightShadows::cache_item *>, COMDAT
; __First$ = ecx

; 1541 :     return ++_First;

	lea	eax, DWORD PTR [ecx+44]

; 1542 : }

	ret	0
??$_Next_iter@PAUcache_item@CLightShadows@@@std@@YAPAUcache_item@CLightShadows@@PAU12@@Z ENDP ; std::_Next_iter<CLightShadows::cache_item *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_Seek_wrapped@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@Ucache_item@CLightShadows@@@std@@@std@@@std@@AAPAUcache_item@CLightShadows@@@std@@YAXAAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@Ucache_item@CLightShadows@@@std@@@std@@@0@AAPAUcache_item@CLightShadows@@@Z
_TEXT	SEGMENT
??$_Seek_wrapped@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@Ucache_item@CLightShadows@@@std@@@std@@@std@@AAPAUcache_item@CLightShadows@@@std@@YAXAAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@Ucache_item@CLightShadows@@@std@@@std@@@0@AAPAUcache_item@CLightShadows@@@Z PROC ; std::_Seek_wrapped<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CLightShadows::cache_item> > >,CLightShadows::cache_item * &>, COMDAT
; __It$ = ecx
; __UIt$ = edx

; 1375 :     if constexpr (_Wrapped_seekable_v<_Iter, _UIter>) {
; 1376 :         _It._Seek_to(_STD forward<_UIter>(_UIt));

	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax

; 1377 :     } else {
; 1378 :         _It = _STD forward<_UIter>(_UIt);
; 1379 :     }
; 1380 : }

	ret	0
??$_Seek_wrapped@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@Ucache_item@CLightShadows@@@std@@@std@@@std@@AAPAUcache_item@CLightShadows@@@std@@YAXAAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@Ucache_item@CLightShadows@@@std@@@std@@@0@AAPAUcache_item@CLightShadows@@@Z ENDP ; std::_Seek_wrapped<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CLightShadows::cache_item> > >,CLightShadows::cache_item * &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_Copy_memmove@PAUcache_item@CLightShadows@@PAU12@@std@@YAPAUcache_item@CLightShadows@@PAU12@00@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
??$_Copy_memmove@PAUcache_item@CLightShadows@@PAU12@@std@@YAPAUcache_item@CLightShadows@@PAU12@00@Z PROC ; std::_Copy_memmove<CLightShadows::cache_item *,CLightShadows::cache_item *>, COMDAT
; __First$ = ecx
; __Last$ = edx

; 4058 : _OutCtgIt _Copy_memmove(_CtgIt _First, _CtgIt _Last, _OutCtgIt _Dest) {

	push	esi

; 4059 :     auto _FirstPtr              = _To_address(_First);
; 4060 :     auto _LastPtr               = _To_address(_Last);
; 4061 :     auto _DestPtr               = _To_address(_Dest);
; 4062 :     const char* const _First_ch = const_cast<const char*>(reinterpret_cast<const volatile char*>(_FirstPtr));
; 4063 :     const char* const _Last_ch  = const_cast<const char*>(reinterpret_cast<const volatile char*>(_LastPtr));
; 4064 :     char* const _Dest_ch        = const_cast<char*>(reinterpret_cast<const volatile char*>(_DestPtr));
; 4065 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);
; 4066 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	esi, DWORD PTR __Dest$[esp]
	push	edi
	mov	edi, edx
	sub	edi, ecx
	push	edi
	push	ecx
	push	esi
	call	_memmove
	add	esp, 12					; 0000000cH

; 4067 :     if constexpr (is_pointer_v<_OutCtgIt>) {
; 4068 :         return reinterpret_cast<_OutCtgIt>(_Dest_ch + _Count);

	lea	eax, DWORD PTR [edi+esi]
	pop	edi
	pop	esi

; 4069 :     } else {
; 4070 :         return _Dest + (_LastPtr - _FirstPtr);
; 4071 :     }
; 4072 : }

	ret	0
??$_Copy_memmove@PAUcache_item@CLightShadows@@PAU12@@std@@YAPAUcache_item@CLightShadows@@PAU12@00@Z ENDP ; std::_Copy_memmove<CLightShadows::cache_item *,CLightShadows::cache_item *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_To_address@PAUcache_item@CLightShadows@@@std@@YA?A_PABQAUcache_item@CLightShadows@@@Z
_TEXT	SEGMENT
??$_To_address@PAUcache_item@CLightShadows@@@std@@YA?A_PABQAUcache_item@CLightShadows@@@Z PROC ; std::_To_address<CLightShadows::cache_item *>, COMDAT
; __Val$ = ecx

; 3981 :     _STL_INTERNAL_STATIC_ASSERT(is_pointer_v<_Iter>);
; 3982 :     return _Val;

	mov	eax, DWORD PTR [ecx]

; 3983 : }

	ret	0
??$_To_address@PAUcache_item@CLightShadows@@@std@@YA?A_PABQAUcache_item@CLightShadows@@@Z ENDP ; std::_To_address<CLightShadows::cache_item *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\type_traits
;	COMDAT ??$move@AAUcache_item@CLightShadows@@@std@@YA$$QAUcache_item@CLightShadows@@AAU12@@Z
_TEXT	SEGMENT
??$move@AAUcache_item@CLightShadows@@@std@@YA$$QAUcache_item@CLightShadows@@AAU12@@Z PROC ; std::move<CLightShadows::cache_item &>, COMDAT
; __Arg$ = ecx

; 1397 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

	mov	eax, ecx

; 1398 : }

	ret	0
??$move@AAUcache_item@CLightShadows@@@std@@YA$$QAUcache_item@CLightShadows@@AAU12@@Z ENDP ; std::move<CLightShadows::cache_item &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\type_traits
;	COMDAT ??$forward@ABUcache_item@CLightShadows@@@std@@YAABUcache_item@CLightShadows@@ABU12@@Z
_TEXT	SEGMENT
??$forward@ABUcache_item@CLightShadows@@@std@@YAABUcache_item@CLightShadows@@ABU12@@Z PROC ; std::forward<CLightShadows::cache_item const &>, COMDAT
; __Arg$ = ecx

; 1386 :     return static_cast<_Ty&&>(_Arg);

	mov	eax, ecx

; 1387 : }

	ret	0
??$forward@ABUcache_item@CLightShadows@@@std@@YAABUcache_item@CLightShadows@@ABU12@@Z ENDP ; std::forward<CLightShadows::cache_item const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$construct@Ucache_item@CLightShadows@@ABU12@@?$_Normal_allocator_traits@V?$xalloc@Ucache_item@CLightShadows@@@@@std@@SAXAAV?$xalloc@Ucache_item@CLightShadows@@@@PAUcache_item@CLightShadows@@ABU34@@Z
_TEXT	SEGMENT
_<_Args_0>$ = 8						; size = 4
??$construct@Ucache_item@CLightShadows@@ABU12@@?$_Normal_allocator_traits@V?$xalloc@Ucache_item@CLightShadows@@@@@std@@SAXAAV?$xalloc@Ucache_item@CLightShadows@@@@PAUcache_item@CLightShadows@@ABU34@@Z PROC ; std::_Normal_allocator_traits<xalloc<CLightShadows::cache_item> >::construct<CLightShadows::cache_item,CLightShadows::cache_item const &>, COMDAT
; __Al$dead$ = ecx
; __Ptr$ = edx

; 564  :     static _CONSTEXPR20_DYNALLOC void construct(_Alloc& _Al, _Ty* _Ptr, _Types&&... _Args) {

	push	esi
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	esi, DWORD PTR _<_Args_0>$[esp]
	mov	ecx, 11					; 0000000bH
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 564  :     static _CONSTEXPR20_DYNALLOC void construct(_Alloc& _Al, _Ty* _Ptr, _Types&&... _Args) {

	push	edi
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	edi, edx
	rep movsd
	pop	edi
	pop	esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 575  :     }

	ret	0
??$construct@Ucache_item@CLightShadows@@ABU12@@?$_Normal_allocator_traits@V?$xalloc@Ucache_item@CLightShadows@@@@@std@@SAXAAV?$xalloc@Ucache_item@CLightShadows@@@@PAUcache_item@CLightShadows@@ABU34@@Z ENDP ; std::_Normal_allocator_traits<xalloc<CLightShadows::cache_item> >::construct<CLightShadows::cache_item,CLightShadows::cache_item const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$?0ABUcache_item@CLightShadows@@@?$_Alloc_temporary2@V?$xalloc@Ucache_item@CLightShadows@@@@@std@@QAE@AAV?$xalloc@Ucache_item@CLightShadows@@@@ABUcache_item@CLightShadows@@@Z
_TEXT	SEGMENT
__Al_$ = 8						; size = 4
_<_Vals_0>$ = 12					; size = 4
??$?0ABUcache_item@CLightShadows@@@?$_Alloc_temporary2@V?$xalloc@Ucache_item@CLightShadows@@@@@std@@QAE@AAV?$xalloc@Ucache_item@CLightShadows@@@@ABUcache_item@CLightShadows@@@Z PROC ; std::_Alloc_temporary2<xalloc<CLightShadows::cache_item> >::_Alloc_temporary2<xalloc<CLightShadows::cache_item> ><CLightShadows::cache_item const &>, COMDAT
; _this$ = ecx

; 1933 :         : _Al(_Al_) {

	mov	eax, DWORD PTR __Al_$[esp-4]
	mov	edx, ecx
	push	esi
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	esi, DWORD PTR _<_Vals_0>$[esp]
	mov	ecx, 11					; 0000000bH
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1933 :         : _Al(_Al_) {

	push	edi
	mov	DWORD PTR [edx], eax

; 1934 :         _Traits::construct(_Al, _STD addressof(_Get_value()), _STD forward<_Args>(_Vals)...);

	lea	edi, DWORD PTR [edx+4]
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	rep movsd
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1935 :     }

	pop	edi
	mov	eax, edx
	pop	esi
	ret	8
??$?0ABUcache_item@CLightShadows@@@?$_Alloc_temporary2@V?$xalloc@Ucache_item@CLightShadows@@@@@std@@QAE@AAV?$xalloc@Ucache_item@CLightShadows@@@@ABUcache_item@CLightShadows@@@Z ENDP ; std::_Alloc_temporary2<xalloc<CLightShadows::cache_item> >::_Alloc_temporary2<xalloc<CLightShadows::cache_item> ><CLightShadows::cache_item const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef
;	COMDAT ??$addressof@Ucache_item@CLightShadows@@@std@@YAPAUcache_item@CLightShadows@@AAU12@@Z
_TEXT	SEGMENT
??$addressof@Ucache_item@CLightShadows@@@std@@YAPAUcache_item@CLightShadows@@AAU12@@Z PROC ; std::addressof<CLightShadows::cache_item>, COMDAT
; __Val$ = ecx

; 253  :     return __builtin_addressof(_Val);

	mov	eax, ecx

; 254  : }

	ret	0
??$addressof@Ucache_item@CLightShadows@@@std@@YAPAUcache_item@CLightShadows@@AAU12@@Z ENDP ; std::addressof<CLightShadows::cache_item>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$construct@Ucache_item@CLightShadows@@U12@@?$_Normal_allocator_traits@V?$xalloc@Ucache_item@CLightShadows@@@@@std@@SAXAAV?$xalloc@Ucache_item@CLightShadows@@@@PAUcache_item@CLightShadows@@$$QAU34@@Z
_TEXT	SEGMENT
_<_Args_0>$ = 8						; size = 4
??$construct@Ucache_item@CLightShadows@@U12@@?$_Normal_allocator_traits@V?$xalloc@Ucache_item@CLightShadows@@@@@std@@SAXAAV?$xalloc@Ucache_item@CLightShadows@@@@PAUcache_item@CLightShadows@@$$QAU34@@Z PROC ; std::_Normal_allocator_traits<xalloc<CLightShadows::cache_item> >::construct<CLightShadows::cache_item,CLightShadows::cache_item>, COMDAT
; __Al$dead$ = ecx
; __Ptr$ = edx

; 564  :     static _CONSTEXPR20_DYNALLOC void construct(_Alloc& _Al, _Ty* _Ptr, _Types&&... _Args) {

	push	esi
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	esi, DWORD PTR _<_Args_0>$[esp]
	mov	ecx, 11					; 0000000bH
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 564  :     static _CONSTEXPR20_DYNALLOC void construct(_Alloc& _Al, _Ty* _Ptr, _Types&&... _Args) {

	push	edi
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	edi, edx
	rep movsd
	pop	edi
	pop	esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 575  :     }

	ret	0
??$construct@Ucache_item@CLightShadows@@U12@@?$_Normal_allocator_traits@V?$xalloc@Ucache_item@CLightShadows@@@@@std@@SAXAAV?$xalloc@Ucache_item@CLightShadows@@@@PAUcache_item@CLightShadows@@$$QAU34@@Z ENDP ; std::_Normal_allocator_traits<xalloc<CLightShadows::cache_item> >::construct<CLightShadows::cache_item,CLightShadows::cache_item>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_Move_backward_unchecked@PAUcache_item@CLightShadows@@PAU12@@std@@YAPAUcache_item@CLightShadows@@PAU12@00@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
??$_Move_backward_unchecked@PAUcache_item@CLightShadows@@PAU12@@std@@YAPAUcache_item@CLightShadows@@PAU12@00@Z PROC ; std::_Move_backward_unchecked<CLightShadows::cache_item *,CLightShadows::cache_item *>, COMDAT
; __First$ = ecx
; __Last$ = edx

; 4255 :     auto _Result                = _CSTD memmove(_Dest_ch - _Count, _First_ch, _Count);

	mov	eax, DWORD PTR __Dest$[esp-4]
	sub	edx, ecx
	push	edx
	push	ecx
	sub	eax, edx
	push	eax
	call	_memmove
	add	esp, 12					; 0000000cH

; 4351 :     // move [_First, _Last) backwards to [..., _Dest)
; 4352 :     // note: _Move_backward_unchecked has callers other than the move_backward family
; 4353 :     if constexpr (_Ptr_move_cat<_BidIt1, _BidIt2>::_Trivially_copyable) {
; 4354 : #ifdef __cpp_lib_is_constant_evaluated
; 4355 :         if (!_STD is_constant_evaluated())
; 4356 : #endif // __cpp_lib_is_constant_evaluated
; 4357 :         {
; 4358 :             return _Copy_backward_memmove(_First, _Last, _Dest);
; 4359 :         }
; 4360 :     }
; 4361 : 
; 4362 :     while (_First != _Last) {
; 4363 :         *--_Dest = _STD move(*--_Last);
; 4364 :     }
; 4365 : 
; 4366 :     return _Dest;
; 4367 : }

	ret	0
??$_Move_backward_unchecked@PAUcache_item@CLightShadows@@PAU12@@std@@YAPAUcache_item@CLightShadows@@PAU12@00@Z ENDP ; std::_Move_backward_unchecked<CLightShadows::cache_item *,CLightShadows::cache_item *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??$_Emplace_reallocate@ABUcache_item@CLightShadows@@@?$vector@Ucache_item@CLightShadows@@V?$xalloc@Ucache_item@CLightShadows@@@@@std@@QAEPAUcache_item@CLightShadows@@QAU23@ABU23@@Z
_TEXT	SEGMENT
__Backout$2 = -48					; size = 12
__Oldsize$1$ = -36					; size = 4
__UFirst$3 = -32					; size = 4
__Newvec$ = -28						; size = 4
__Newcapacity$1$ = -24					; size = 4
tv474 = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Whereptr$ = 8						; size = 4
__ULast$1$ = 12						; size = 4
_<_Val_0>$ = 12						; size = 4
??$_Emplace_reallocate@ABUcache_item@CLightShadows@@@?$vector@Ucache_item@CLightShadows@@V?$xalloc@Ucache_item@CLightShadows@@@@@std@@QAEPAUcache_item@CLightShadows@@QAU23@ABU23@@Z PROC ; std::vector<CLightShadows::cache_item,xalloc<CLightShadows::cache_item> >::_Emplace_reallocate<CLightShadows::cache_item const &>, COMDAT
; _this$ = ecx

; 752  :     _CONSTEXPR20_CONTAINER pointer _Emplace_reallocate(const pointer _Whereptr, _Valty&&... _Val) {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Emplace_reallocate@ABUcache_item@CLightShadows@@@?$vector@Ucache_item@CLightShadows@@V?$xalloc@Ucache_item@CLightShadows@@@@@std@@QAEPAUcache_item@CLightShadows@@QAU23@ABU23@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 36					; 00000024H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	ebx, ecx

; 753  :         // reallocate and insert by perfectly forwarding _Val at _Whereptr
; 754  :         _Alty& _Al        = _Getal();
; 755  :         auto& _My_data    = _Mypair._Myval2;
; 756  :         pointer& _Myfirst = _My_data._Myfirst;
; 757  :         pointer& _Mylast  = _My_data._Mylast;
; 758  : 
; 759  :         _STL_INTERNAL_CHECK(_Mylast == _My_data._Myend); // check that we have no unused capacity
; 760  : 
; 761  :         const auto _Whereoff = static_cast<size_type>(_Whereptr - _Myfirst);

	mov	ecx, DWORD PTR [ebx]
	mov	edx, DWORD PTR __Whereptr$[ebp]
	sub	edx, ecx
	mov	eax, 780903145				; 2e8ba2e9H
	imul	edx
	sar	edx, 3
	mov	esi, edx
	shr	esi, 31					; 0000001fH
	add	esi, edx

; 762  :         const auto _Oldsize  = static_cast<size_type>(_Mylast - _Myfirst);

	mov	eax, DWORD PTR [ebx+4]
	sub	eax, ecx
	sar	eax, 2
	imul	eax, eax, -1171354717
	mov	DWORD PTR __Oldsize$1$[ebp], eax

; 763  : 
; 764  :         if (_Oldsize == max_size()) {

	cmp	eax, 97612893				; 05d1745dH
	je	$LN59@Emplace_re

; 766  :         }
; 767  : 
; 768  :         const size_type _Newsize     = _Oldsize + 1;

	lea	edi, DWORD PTR [eax+1]

; 1546 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	eax, DWORD PTR [ebx+8]
	sub	eax, ecx
	sar	eax, 2
	imul	edx, eax, -1171354717

; 1675 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	ecx, edx
	shr	ecx, 1
	mov	eax, 97612893				; 05d1745dH
	sub	eax, ecx
	cmp	edx, eax
	jbe	SHORT $LN12@Emplace_re

; 1676 :             return _Max; // geometric growth would overflow

	mov	eax, 97612893				; 05d1745dH
	jmp	SHORT $LN57@Emplace_re
$LN12@Emplace_re:

; 1677 :         }
; 1678 : 
; 1679 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	lea	eax, DWORD PTR [ecx+edx]

; 1680 : 
; 1681 :         if (_Geometric < _Newsize) {

	cmp	eax, edi
	cmovb	eax, edi
$LN57@Emplace_re:
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	mov	DWORD PTR __Newcapacity$1$[ebp], eax
	imul	eax, eax, 44
	push	eax
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 771  :         const pointer _Newvec           = _Al.allocate(_Newcapacity);

	mov	edx, eax
	mov	DWORD PTR __Newvec$[ebp], edx

; 772  :         const pointer _Constructed_last = _Newvec + _Whereoff + 1;
; 773  :         pointer _Constructed_first      = _Constructed_last;
; 774  : 
; 775  :         _TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 776  :         _Alty_traits::construct(_Al, _Unfancy(_Newvec + _Whereoff), _STD forward<_Valty>(_Val)...);

	imul	eax, esi, 44
	add	eax, edx
	mov	DWORD PTR tv474[ebp], eax
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	ecx, 11					; 0000000bH
	mov	esi, DWORD PTR _<_Val_0>$[ebp]
	mov	edi, eax
	rep movsd
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 779  :         if (_Whereptr == _Mylast) { // at back, provide strong guarantee

	mov	ecx, DWORD PTR [ebx+4]
	mov	DWORD PTR __ULast$1$[ebp], ecx
	mov	eax, DWORD PTR [ebx]
	mov	esi, DWORD PTR __Whereptr$[ebp]
	cmp	esi, ecx
	jne	SHORT $LN4@Emplace_re
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1703 :     auto _UFirst      = _Get_unwrapped(_First);

	mov	DWORD PTR __UFirst$3[ebp], eax

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	DWORD PTR __Backout$2[ebp], edx
	mov	DWORD PTR __Backout$2[ebp+4], edx
	mov	DWORD PTR __Backout$2[ebp+8], ebx
$LL32@Emplace_re:

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	eax, ecx
	je	SHORT $LN31@Emplace_re
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	ecx, 11					; 0000000bH
	mov	esi, eax
	mov	edi, edx
	rep movsd
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1621 :         ++_Last;

	add	edx, 44					; 0000002cH
	mov	DWORD PTR __Backout$2[ebp+4], edx

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	add	eax, 44					; 0000002cH
	mov	DWORD PTR __UFirst$3[ebp], eax
	mov	ecx, DWORD PTR __ULast$1$[ebp]
	jmp	SHORT $LL32@Emplace_re
$LN31@Emplace_re:

; 1625 :         _First = _Last;

	mov	DWORD PTR __Backout$2[ebp], edx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 781  :         } else { // provide basic guarantee

	mov	edi, DWORD PTR tv474[ebp]
	jmp	SHORT $LN5@Emplace_re
$LN4@Emplace_re:

; 782  :             _Umove(_Myfirst, _Whereptr, _Newvec);

	push	edx
	push	esi
	push	eax
	call	?_Umove@?$vector@Ucache_item@CLightShadows@@V?$xalloc@Ucache_item@CLightShadows@@@@@std@@AAEPAUcache_item@CLightShadows@@PAU34@00@Z ; std::vector<CLightShadows::cache_item,xalloc<CLightShadows::cache_item> >::_Umove

; 783  :             _Constructed_first = _Newvec;
; 784  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

	mov	edi, DWORD PTR tv474[ebp]
	lea	eax, DWORD PTR [edi+44]
	push	eax
	push	DWORD PTR [ebx+4]
	push	esi
	call	?_Umove@?$vector@Ucache_item@CLightShadows@@V?$xalloc@Ucache_item@CLightShadows@@@@@std@@AAEPAUcache_item@CLightShadows@@PAU34@00@Z ; std::vector<CLightShadows::cache_item,xalloc<CLightShadows::cache_item> >::_Umove
$LN5@Emplace_re:
	mov	DWORD PTR __$EHRec$[ebp+12], -1

; 1732 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [ebx]
	test	eax, eax
	je	SHORT $LN50@Emplace_re
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	push	eax
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN50@Emplace_re:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1737 :         _Myfirst = _Newvec;

	mov	eax, DWORD PTR __Newvec$[ebp]
	mov	DWORD PTR [ebx], eax

; 1738 :         _Mylast  = _Newvec + _Newsize;

	mov	ecx, DWORD PTR __Oldsize$1$[ebp]
	inc	ecx
	imul	ecx, ecx, 44
	add	ecx, eax
	mov	DWORD PTR [ebx+4], ecx

; 1739 :         _Myend   = _Newvec + _Newcapacity;

	imul	ecx, DWORD PTR __Newcapacity$1$[ebp], 44
	add	ecx, eax
	mov	DWORD PTR [ebx+8], ecx

; 790  :         _CATCH_END
; 791  : 
; 792  :         _Change_array(_Newvec, _Newsize, _Newcapacity);
; 793  :         return _Newvec + _Whereoff;

	mov	eax, edi

; 794  :     }

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
__catch$??$_Emplace_reallocate@ABUcache_item@CLightShadows@@@?$vector@Ucache_item@CLightShadows@@V?$xalloc@Ucache_item@CLightShadows@@@@@std@@QAEPAUcache_item@CLightShadows@@QAU23@ABU23@@Z$0:

; 785  :         }
; 786  :         _CATCH_ALL
; 787  :         _Destroy(_Constructed_first, _Constructed_last);
; 788  :         _Al.deallocate(_Newvec, _Newcapacity);

	push	ecx
	push	DWORD PTR __Newvec$[ebp]
	call	?deallocate@?$xalloc@Ucache_item@CLightShadows@@@@QBEXPAUcache_item@CLightShadows@@I@Z ; xalloc<CLightShadows::cache_item>::deallocate

; 789  :         _RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$LN59@Emplace_re:

; 765  :             _Xlength();

	call	?_Xlength@?$vector@Ucache_item@CLightShadows@@V?$xalloc@Ucache_item@CLightShadows@@@@@std@@CAXXZ ; std::vector<CLightShadows::cache_item,xalloc<CLightShadows::cache_item> >::_Xlength
$LN56@Emplace_re:
	int	3
	int	3
	int	3
	int	3
	int	3
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Emplace_reallocate@ABUcache_item@CLightShadows@@@?$vector@Ucache_item@CLightShadows@@V?$xalloc@Ucache_item@CLightShadows@@@@@std@@QAEPAUcache_item@CLightShadows@@QAU23@ABU23@@Z:
	npad	1
	npad	1
	mov	eax, OFFSET __ehfuncinfo$??$_Emplace_reallocate@ABUcache_item@CLightShadows@@@?$vector@Ucache_item@CLightShadows@@V?$xalloc@Ucache_item@CLightShadows@@@@@std@@QAEPAUcache_item@CLightShadows@@QAU23@ABU23@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Emplace_reallocate@ABUcache_item@CLightShadows@@@?$vector@Ucache_item@CLightShadows@@V?$xalloc@Ucache_item@CLightShadows@@@@@std@@QAEPAUcache_item@CLightShadows@@QAU23@ABU23@@Z ENDP ; std::vector<CLightShadows::cache_item,xalloc<CLightShadows::cache_item> >::_Emplace_reallocate<CLightShadows::cache_item const &>
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$destroy@Utess_tri@CLightShadows@@@?$_Normal_allocator_traits@V?$xalloc@Utess_tri@CLightShadows@@@@@std@@SAXAAV?$xalloc@Utess_tri@CLightShadows@@@@PAUtess_tri@CLightShadows@@@Z
_TEXT	SEGMENT
??$destroy@Utess_tri@CLightShadows@@@?$_Normal_allocator_traits@V?$xalloc@Utess_tri@CLightShadows@@@@@std@@SAXAAV?$xalloc@Utess_tri@CLightShadows@@@@PAUtess_tri@CLightShadows@@@Z PROC ; std::_Normal_allocator_traits<xalloc<CLightShadows::tess_tri> >::destroy<CLightShadows::tess_tri>, COMDAT
; __Al$dead$ = ecx
; __Ptr$dead$ = edx

; 579  :         if constexpr (_Uses_default_destroy<_Alloc, _Ty*>::value) {
; 580  : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 581  :             _STD destroy_at(_Ptr);
; 582  : #else // __cpp_lib_constexpr_dynamic_alloc
; 583  :             _Ptr->~_Ty();
; 584  : #endif // __cpp_lib_constexpr_dynamic_alloc
; 585  :         } else {
; 586  :             _Al.destroy(_Ptr);
; 587  :         }
; 588  :     }

	ret	0
??$destroy@Utess_tri@CLightShadows@@@?$_Normal_allocator_traits@V?$xalloc@Utess_tri@CLightShadows@@@@@std@@SAXAAV?$xalloc@Utess_tri@CLightShadows@@@@PAUtess_tri@CLightShadows@@@Z ENDP ; std::_Normal_allocator_traits<xalloc<CLightShadows::tess_tri> >::destroy<CLightShadows::tess_tri>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$destroy@Ushadow@CLightShadows@@@?$_Normal_allocator_traits@V?$xalloc@Ushadow@CLightShadows@@@@@std@@SAXAAV?$xalloc@Ushadow@CLightShadows@@@@PAUshadow@CLightShadows@@@Z
_TEXT	SEGMENT
??$destroy@Ushadow@CLightShadows@@@?$_Normal_allocator_traits@V?$xalloc@Ushadow@CLightShadows@@@@@std@@SAXAAV?$xalloc@Ushadow@CLightShadows@@@@PAUshadow@CLightShadows@@@Z PROC ; std::_Normal_allocator_traits<xalloc<CLightShadows::shadow> >::destroy<CLightShadows::shadow>, COMDAT
; __Al$dead$ = ecx
; __Ptr$dead$ = edx

; 579  :         if constexpr (_Uses_default_destroy<_Alloc, _Ty*>::value) {
; 580  : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 581  :             _STD destroy_at(_Ptr);
; 582  : #else // __cpp_lib_constexpr_dynamic_alloc
; 583  :             _Ptr->~_Ty();
; 584  : #endif // __cpp_lib_constexpr_dynamic_alloc
; 585  :         } else {
; 586  :             _Al.destroy(_Ptr);
; 587  :         }
; 588  :     }

	ret	0
??$destroy@Ushadow@CLightShadows@@@?$_Normal_allocator_traits@V?$xalloc@Ushadow@CLightShadows@@@@@std@@SAXAAV?$xalloc@Ushadow@CLightShadows@@@@PAUshadow@CLightShadows@@@Z ENDP ; std::_Normal_allocator_traits<xalloc<CLightShadows::shadow> >::destroy<CLightShadows::shadow>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$destroy@U_MatrixItem@R_dsgraph@@@?$_Normal_allocator_traits@V?$xalloc@U_MatrixItem@R_dsgraph@@@@@std@@SAXAAV?$xalloc@U_MatrixItem@R_dsgraph@@@@PAU_MatrixItem@R_dsgraph@@@Z
_TEXT	SEGMENT
??$destroy@U_MatrixItem@R_dsgraph@@@?$_Normal_allocator_traits@V?$xalloc@U_MatrixItem@R_dsgraph@@@@@std@@SAXAAV?$xalloc@U_MatrixItem@R_dsgraph@@@@PAU_MatrixItem@R_dsgraph@@@Z PROC ; std::_Normal_allocator_traits<xalloc<R_dsgraph::_MatrixItem> >::destroy<R_dsgraph::_MatrixItem>, COMDAT
; __Al$dead$ = ecx
; __Ptr$dead$ = edx

; 579  :         if constexpr (_Uses_default_destroy<_Alloc, _Ty*>::value) {
; 580  : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 581  :             _STD destroy_at(_Ptr);
; 582  : #else // __cpp_lib_constexpr_dynamic_alloc
; 583  :             _Ptr->~_Ty();
; 584  : #endif // __cpp_lib_constexpr_dynamic_alloc
; 585  :         } else {
; 586  :             _Al.destroy(_Ptr);
; 587  :         }
; 588  :     }

	ret	0
??$destroy@U_MatrixItem@R_dsgraph@@@?$_Normal_allocator_traits@V?$xalloc@U_MatrixItem@R_dsgraph@@@@@std@@SAXAAV?$xalloc@U_MatrixItem@R_dsgraph@@@@PAU_MatrixItem@R_dsgraph@@@Z ENDP ; std::_Normal_allocator_traits<xalloc<R_dsgraph::_MatrixItem> >::destroy<R_dsgraph::_MatrixItem>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Destroy_in_place@PAUcache_item@CLightShadows@@@std@@YAXAAPAUcache_item@CLightShadows@@@Z
_TEXT	SEGMENT
??$_Destroy_in_place@PAUcache_item@CLightShadows@@@std@@YAXAAPAUcache_item@CLightShadows@@@Z PROC ; std::_Destroy_in_place<CLightShadows::cache_item *>, COMDAT
; __Obj$dead$ = ecx

; 295  :     if constexpr (is_array_v<_Ty>) {
; 296  :         _Destroy_range(_Obj, _Obj + extent_v<_Ty>);
; 297  :     } else {
; 298  :         _Obj.~_Ty();
; 299  :     }
; 300  : }

	ret	0
??$_Destroy_in_place@PAUcache_item@CLightShadows@@@std@@YAXAAPAUcache_item@CLightShadows@@@Z ENDP ; std::_Destroy_in_place<CLightShadows::cache_item *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Uninitialized_move@PAUtess_tri@CLightShadows@@V?$xalloc@Utess_tri@CLightShadows@@@@@std@@YAPAUtess_tri@CLightShadows@@QAU12@0PAU12@AAV?$xalloc@Utess_tri@CLightShadows@@@@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Al$dead$ = 12						; size = 4
??$_Uninitialized_move@PAUtess_tri@CLightShadows@@V?$xalloc@Utess_tri@CLightShadows@@@@@std@@YAPAUtess_tri@CLightShadows@@QAU12@0PAU12@AAV?$xalloc@Utess_tri@CLightShadows@@@@@Z PROC ; std::_Uninitialized_move<CLightShadows::tess_tri *,xalloc<CLightShadows::tess_tri> >, COMDAT
; __First$ = ecx
; __Last$ = edx

; 1699 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

	push	ebx
	mov	ebx, edx
	mov	eax, ecx

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	edx, DWORD PTR __Dest$[esp]

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	eax, ebx
	je	SHORT $LN20@Uninitiali
	push	esi
	push	edi
	npad	1
$LL4@Uninitiali:
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	esi, eax
	mov	edi, edx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1621 :         ++_Last;

	add	eax, 48					; 00000030H
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	ecx, 12					; 0000000cH
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1621 :         ++_Last;

	add	edx, 48					; 00000030H
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	rep movsd
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	eax, ebx
	jne	SHORT $LL4@Uninitiali

; 1718 :         _Backout._Emplace_back(_STD move(*_UFirst));
; 1719 :     }
; 1720 : 
; 1721 :     return _Backout._Release();

	pop	edi
	pop	esi
$LN20@Uninitiali:

; 1722 : }

	mov	eax, edx
	pop	ebx
	ret	0
??$_Uninitialized_move@PAUtess_tri@CLightShadows@@V?$xalloc@Utess_tri@CLightShadows@@@@@std@@YAPAUtess_tri@CLightShadows@@QAU12@0PAU12@AAV?$xalloc@Utess_tri@CLightShadows@@@@@Z ENDP ; std::_Uninitialized_move<CLightShadows::tess_tri *,xalloc<CLightShadows::tess_tri> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_Get_unwrapped@ABQAUtess_tri@CLightShadows@@@std@@YA?A_TABQAUtess_tri@CLightShadows@@@Z
_TEXT	SEGMENT
??$_Get_unwrapped@ABQAUtess_tri@CLightShadows@@@std@@YA?A_TABQAUtess_tri@CLightShadows@@@Z PROC ; std::_Get_unwrapped<CLightShadows::tess_tri * const &>, COMDAT
; __It$ = ecx

; 1275 :     // unwrap an iterator previously subjected to _Adl_verify_range or otherwise validated
; 1276 :     if constexpr (is_pointer_v<decay_t<_Iter>>) { // special-case pointers and arrays
; 1277 :         return _It + 0;

	mov	eax, DWORD PTR [ecx]

; 1278 :     } else if constexpr (_Unwrappable_v<_Iter>) {
; 1279 :         return static_cast<_Iter&&>(_It)._Unwrapped();
; 1280 :     } else {
; 1281 :         return static_cast<_Iter&&>(_It);
; 1282 :     }
; 1283 : }

	ret	0
??$_Get_unwrapped@ABQAUtess_tri@CLightShadows@@@std@@YA?A_TABQAUtess_tri@CLightShadows@@@Z ENDP ; std::_Get_unwrapped<CLightShadows::tess_tri * const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Uninitialized_move@PAUshadow@CLightShadows@@V?$xalloc@Ushadow@CLightShadows@@@@@std@@YAPAUshadow@CLightShadows@@QAU12@0PAU12@AAV?$xalloc@Ushadow@CLightShadows@@@@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Al$dead$ = 12						; size = 4
??$_Uninitialized_move@PAUshadow@CLightShadows@@V?$xalloc@Ushadow@CLightShadows@@@@@std@@YAPAUshadow@CLightShadows@@QAU12@0PAU12@AAV?$xalloc@Ushadow@CLightShadows@@@@@Z PROC ; std::_Uninitialized_move<CLightShadows::shadow *,xalloc<CLightShadows::shadow> >, COMDAT
; __First$ = ecx
; __Last$ = edx

; 1699 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

	push	ebx
	mov	ebx, edx
	mov	eax, ecx

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	edx, DWORD PTR __Dest$[esp]

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	eax, ebx
	je	SHORT $LN20@Uninitiali
	push	esi
	push	edi
	npad	1
$LL4@Uninitiali:
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	esi, eax
	mov	edi, edx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1621 :         ++_Last;

	add	eax, 92					; 0000005cH
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	ecx, 23					; 00000017H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1621 :         ++_Last;

	add	edx, 92					; 0000005cH
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	rep movsd
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	eax, ebx
	jne	SHORT $LL4@Uninitiali

; 1718 :         _Backout._Emplace_back(_STD move(*_UFirst));
; 1719 :     }
; 1720 : 
; 1721 :     return _Backout._Release();

	pop	edi
	pop	esi
$LN20@Uninitiali:

; 1722 : }

	mov	eax, edx
	pop	ebx
	ret	0
??$_Uninitialized_move@PAUshadow@CLightShadows@@V?$xalloc@Ushadow@CLightShadows@@@@@std@@YAPAUshadow@CLightShadows@@QAU12@0PAU12@AAV?$xalloc@Ushadow@CLightShadows@@@@@Z ENDP ; std::_Uninitialized_move<CLightShadows::shadow *,xalloc<CLightShadows::shadow> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_Get_unwrapped@ABQAUshadow@CLightShadows@@@std@@YA?A_TABQAUshadow@CLightShadows@@@Z
_TEXT	SEGMENT
??$_Get_unwrapped@ABQAUshadow@CLightShadows@@@std@@YA?A_TABQAUshadow@CLightShadows@@@Z PROC ; std::_Get_unwrapped<CLightShadows::shadow * const &>, COMDAT
; __It$ = ecx

; 1275 :     // unwrap an iterator previously subjected to _Adl_verify_range or otherwise validated
; 1276 :     if constexpr (is_pointer_v<decay_t<_Iter>>) { // special-case pointers and arrays
; 1277 :         return _It + 0;

	mov	eax, DWORD PTR [ecx]

; 1278 :     } else if constexpr (_Unwrappable_v<_Iter>) {
; 1279 :         return static_cast<_Iter&&>(_It)._Unwrapped();
; 1280 :     } else {
; 1281 :         return static_cast<_Iter&&>(_It);
; 1282 :     }
; 1283 : }

	ret	0
??$_Get_unwrapped@ABQAUshadow@CLightShadows@@@std@@YA?A_TABQAUshadow@CLightShadows@@@Z ENDP ; std::_Get_unwrapped<CLightShadows::shadow * const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
;	COMDAT ??$xr_alloc@Ushadow@CLightShadows@@@@YAPAUshadow@CLightShadows@@I@Z
_TEXT	SEGMENT
??$xr_alloc@Ushadow@CLightShadows@@@@YAPAUshadow@CLightShadows@@I@Z PROC ; xr_alloc<CLightShadows::shadow>, COMDAT
; _count$ = ecx

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	imul	eax, ecx, 92
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
	ret	0
??$xr_alloc@Ushadow@CLightShadows@@@@YAPAUshadow@CLightShadows@@I@Z ENDP ; xr_alloc<CLightShadows::shadow>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Uninitialized_move@PAPAUcaster@CLightShadows@@V?$xalloc@PAUcaster@CLightShadows@@@@@std@@YAPAPAUcaster@CLightShadows@@QAPAU12@0PAPAU12@AAV?$xalloc@PAUcaster@CLightShadows@@@@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Al$dead$ = 12						; size = 4
??$_Uninitialized_move@PAPAUcaster@CLightShadows@@V?$xalloc@PAUcaster@CLightShadows@@@@@std@@YAPAPAUcaster@CLightShadows@@QAPAU12@0PAPAU12@AAV?$xalloc@PAUcaster@CLightShadows@@@@@Z PROC ; std::_Uninitialized_move<CLightShadows::caster * *,xalloc<CLightShadows::caster *> >, COMDAT
; __First$ = ecx
; __Last$ = edx

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	eax, DWORD PTR __Dest$[esp-4]

; 1699 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

	push	esi
	mov	esi, edx

; 1700 :     // move [_First, _Last) to raw _Dest, using _Al
; 1701 :     // note: only called internally from elsewhere in the STL
; 1702 :     using _Ptrval     = typename _Alloc::value_type*;
; 1703 :     auto _UFirst      = _Get_unwrapped(_First);
; 1704 :     const auto _ULast = _Get_unwrapped(_Last);
; 1705 :     if constexpr (conjunction_v<bool_constant<_Ptr_move_cat<decltype(_UFirst), _Ptrval>::_Really_trivial>,
; 1706 :                       _Uses_default_construct<_Alloc, _Ptrval, decltype(_STD move(*_UFirst))>>) {
; 1707 : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 1708 :         if (!_STD is_constant_evaluated())
; 1709 : #endif // __cpp_lib_constexpr_dynamic_alloc
; 1710 :         {
; 1711 :             _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));
; 1712 :             return _Dest + (_ULast - _UFirst);
; 1713 :         }
; 1714 :     }
; 1715 : 
; 1716 :     _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	ecx, esi
	je	SHORT $LN3@Uninitiali
	npad	5
$LL4@Uninitiali:

; 1620 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

	mov	edx, DWORD PTR [ecx]

; 1621 :         ++_Last;

	add	ecx, 4
	mov	DWORD PTR [eax], edx
	add	eax, 4

; 1700 :     // move [_First, _Last) to raw _Dest, using _Al
; 1701 :     // note: only called internally from elsewhere in the STL
; 1702 :     using _Ptrval     = typename _Alloc::value_type*;
; 1703 :     auto _UFirst      = _Get_unwrapped(_First);
; 1704 :     const auto _ULast = _Get_unwrapped(_Last);
; 1705 :     if constexpr (conjunction_v<bool_constant<_Ptr_move_cat<decltype(_UFirst), _Ptrval>::_Really_trivial>,
; 1706 :                       _Uses_default_construct<_Alloc, _Ptrval, decltype(_STD move(*_UFirst))>>) {
; 1707 : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 1708 :         if (!_STD is_constant_evaluated())
; 1709 : #endif // __cpp_lib_constexpr_dynamic_alloc
; 1710 :         {
; 1711 :             _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));
; 1712 :             return _Dest + (_ULast - _UFirst);
; 1713 :         }
; 1714 :     }
; 1715 : 
; 1716 :     _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	ecx, esi
	jne	SHORT $LL4@Uninitiali
$LN3@Uninitiali:
	pop	esi

; 1718 :         _Backout._Emplace_back(_STD move(*_UFirst));
; 1719 :     }
; 1720 : 
; 1721 :     return _Backout._Release();
; 1722 : }

	ret	0
??$_Uninitialized_move@PAPAUcaster@CLightShadows@@V?$xalloc@PAUcaster@CLightShadows@@@@@std@@YAPAPAUcaster@CLightShadows@@QAPAU12@0PAPAU12@AAV?$xalloc@PAUcaster@CLightShadows@@@@@Z ENDP ; std::_Uninitialized_move<CLightShadows::caster * *,xalloc<CLightShadows::caster *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_Get_unwrapped@ABQAPAUcaster@CLightShadows@@@std@@YA?A_TABQAPAUcaster@CLightShadows@@@Z
_TEXT	SEGMENT
??$_Get_unwrapped@ABQAPAUcaster@CLightShadows@@@std@@YA?A_TABQAPAUcaster@CLightShadows@@@Z PROC ; std::_Get_unwrapped<CLightShadows::caster * * const &>, COMDAT
; __It$ = ecx

; 1275 :     // unwrap an iterator previously subjected to _Adl_verify_range or otherwise validated
; 1276 :     if constexpr (is_pointer_v<decay_t<_Iter>>) { // special-case pointers and arrays
; 1277 :         return _It + 0;

	mov	eax, DWORD PTR [ecx]

; 1278 :     } else if constexpr (_Unwrappable_v<_Iter>) {
; 1279 :         return static_cast<_Iter&&>(_It)._Unwrapped();
; 1280 :     } else {
; 1281 :         return static_cast<_Iter&&>(_It);
; 1282 :     }
; 1283 : }

	ret	0
??$_Get_unwrapped@ABQAPAUcaster@CLightShadows@@@std@@YA?A_TABQAPAUcaster@CLightShadows@@@Z ENDP ; std::_Get_unwrapped<CLightShadows::caster * * const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Destroy_in_place@PAPAUcaster@CLightShadows@@@std@@YAXAAPAPAUcaster@CLightShadows@@@Z
_TEXT	SEGMENT
??$_Destroy_in_place@PAPAUcaster@CLightShadows@@@std@@YAXAAPAPAUcaster@CLightShadows@@@Z PROC ; std::_Destroy_in_place<CLightShadows::caster * *>, COMDAT
; __Obj$dead$ = ecx

; 295  :     if constexpr (is_array_v<_Ty>) {
; 296  :         _Destroy_range(_Obj, _Obj + extent_v<_Ty>);
; 297  :     } else {
; 298  :         _Obj.~_Ty();
; 299  :     }
; 300  : }

	ret	0
??$_Destroy_in_place@PAPAUcaster@CLightShadows@@@std@@YAXAAPAPAUcaster@CLightShadows@@@Z ENDP ; std::_Destroy_in_place<CLightShadows::caster * *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
;	COMDAT ??$xr_alloc@PAUcaster@CLightShadows@@@@YAPAPAUcaster@CLightShadows@@I@Z
_TEXT	SEGMENT
??$xr_alloc@PAUcaster@CLightShadows@@@@YAPAPAUcaster@CLightShadows@@I@Z PROC ; xr_alloc<CLightShadows::caster *>, COMDAT
; _count$ = ecx

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	lea	eax, DWORD PTR [ecx*4]
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
	ret	0
??$xr_alloc@PAUcaster@CLightShadows@@@@YAPAPAUcaster@CLightShadows@@I@Z ENDP ; xr_alloc<CLightShadows::caster *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Uninitialized_move@PAU_MatrixItem@R_dsgraph@@V?$xalloc@U_MatrixItem@R_dsgraph@@@@@std@@YAPAU_MatrixItem@R_dsgraph@@QAU12@0PAU12@AAV?$xalloc@U_MatrixItem@R_dsgraph@@@@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Al$dead$ = 12						; size = 4
??$_Uninitialized_move@PAU_MatrixItem@R_dsgraph@@V?$xalloc@U_MatrixItem@R_dsgraph@@@@@std@@YAPAU_MatrixItem@R_dsgraph@@QAU12@0PAU12@AAV?$xalloc@U_MatrixItem@R_dsgraph@@@@@Z PROC ; std::_Uninitialized_move<R_dsgraph::_MatrixItem *,xalloc<R_dsgraph::_MatrixItem> >, COMDAT
; __First$ = ecx
; __Last$ = edx

; 1699 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

	push	ebx
	mov	ebx, edx
	mov	eax, ecx

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	edx, DWORD PTR __Dest$[esp]

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	eax, ebx
	je	SHORT $LN20@Uninitiali
	push	esi
	push	edi
	npad	1
$LL4@Uninitiali:
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	esi, eax
	mov	edi, edx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1621 :         ++_Last;

	add	eax, 76					; 0000004cH
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	ecx, 19					; 00000013H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1621 :         ++_Last;

	add	edx, 76					; 0000004cH
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	rep movsd
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	eax, ebx
	jne	SHORT $LL4@Uninitiali

; 1718 :         _Backout._Emplace_back(_STD move(*_UFirst));
; 1719 :     }
; 1720 : 
; 1721 :     return _Backout._Release();

	pop	edi
	pop	esi
$LN20@Uninitiali:

; 1722 : }

	mov	eax, edx
	pop	ebx
	ret	0
??$_Uninitialized_move@PAU_MatrixItem@R_dsgraph@@V?$xalloc@U_MatrixItem@R_dsgraph@@@@@std@@YAPAU_MatrixItem@R_dsgraph@@QAU12@0PAU12@AAV?$xalloc@U_MatrixItem@R_dsgraph@@@@@Z ENDP ; std::_Uninitialized_move<R_dsgraph::_MatrixItem *,xalloc<R_dsgraph::_MatrixItem> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
;	COMDAT ??$xr_free@U_MatrixItem@R_dsgraph@@@@YAXAAPAU_MatrixItem@R_dsgraph@@@Z
_TEXT	SEGMENT
??$xr_free@U_MatrixItem@R_dsgraph@@@@YAXAAPAU_MatrixItem@R_dsgraph@@@Z PROC ; xr_free<R_dsgraph::_MatrixItem>, COMDAT
; _P$ = ecx

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	push	esi
	mov	esi, ecx
	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN2@xr_free
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
	mov	DWORD PTR [esi], 0
$LN2@xr_free:
	pop	esi
	ret	0
??$xr_free@U_MatrixItem@R_dsgraph@@@@YAXAAPAU_MatrixItem@R_dsgraph@@@Z ENDP ; xr_free<R_dsgraph::_MatrixItem>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
;	COMDAT ??$xr_alloc@U_MatrixItem@R_dsgraph@@@@YAPAU_MatrixItem@R_dsgraph@@I@Z
_TEXT	SEGMENT
??$xr_alloc@U_MatrixItem@R_dsgraph@@@@YAPAU_MatrixItem@R_dsgraph@@I@Z PROC ; xr_alloc<R_dsgraph::_MatrixItem>, COMDAT
; _count$ = ecx

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	imul	eax, ecx, 76
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
	ret	0
??$xr_alloc@U_MatrixItem@R_dsgraph@@@@YAPAU_MatrixItem@R_dsgraph@@I@Z ENDP ; xr_alloc<R_dsgraph::_MatrixItem>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$?0$$V@?$_Compressed_pair@V?$xalloc@U_MatrixItem@R_dsgraph@@@@V?$_Vector_val@U?$_Simple_types@U_MatrixItem@R_dsgraph@@@std@@@std@@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$?0$$V@?$_Compressed_pair@V?$xalloc@U_MatrixItem@R_dsgraph@@@@V?$_Vector_val@U?$_Simple_types@U_MatrixItem@R_dsgraph@@@std@@@std@@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<xalloc<R_dsgraph::_MatrixItem>,std::_Vector_val<std::_Simple_types<R_dsgraph::_MatrixItem> >,1>::_Compressed_pair<xalloc<R_dsgraph::_MatrixItem>,std::_Vector_val<std::_Simple_types<R_dsgraph::_MatrixItem> >,1><>, COMDAT
; _this$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1331 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	eax, ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1331 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	ret	4
??$?0$$V@?$_Compressed_pair@V?$xalloc@U_MatrixItem@R_dsgraph@@@@V?$_Vector_val@U?$_Simple_types@U_MatrixItem@R_dsgraph@@@std@@@std@@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<xalloc<R_dsgraph::_MatrixItem>,std::_Vector_val<std::_Simple_types<R_dsgraph::_MatrixItem> >,1>::_Compressed_pair<xalloc<R_dsgraph::_MatrixItem>,std::_Vector_val<std::_Simple_types<R_dsgraph::_MatrixItem> >,1><>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Release@?$_Uninitialized_backout_al@V?$xalloc@U_MatrixItem@R_dsgraph@@@@@std@@QAEPAU_MatrixItem@R_dsgraph@@XZ
_TEXT	SEGMENT
?_Release@?$_Uninitialized_backout_al@V?$xalloc@U_MatrixItem@R_dsgraph@@@@@std@@QAEPAU_MatrixItem@R_dsgraph@@XZ PROC ; std::_Uninitialized_backout_al<xalloc<R_dsgraph::_MatrixItem> >::_Release, COMDAT
; _this$ = ecx

; 1625 :         _First = _Last;

	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [ecx], eax

; 1626 :         return _Last;
; 1627 :     }

	ret	0
?_Release@?$_Uninitialized_backout_al@V?$xalloc@U_MatrixItem@R_dsgraph@@@@@std@@QAEPAU_MatrixItem@R_dsgraph@@XZ ENDP ; std::_Uninitialized_backout_al<xalloc<R_dsgraph::_MatrixItem> >::_Release
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??1?$_Uninitialized_backout_al@V?$xalloc@U_MatrixItem@R_dsgraph@@@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Uninitialized_backout_al@V?$xalloc@U_MatrixItem@R_dsgraph@@@@@std@@QAE@XZ PROC ; std::_Uninitialized_backout_al<xalloc<R_dsgraph::_MatrixItem> >::~_Uninitialized_backout_al<xalloc<R_dsgraph::_MatrixItem> >, COMDAT
; _this$ = ecx

; 1615 :         _Destroy_range(_First, _Last, _Al);
; 1616 :     }

	ret	0
??1?$_Uninitialized_backout_al@V?$xalloc@U_MatrixItem@R_dsgraph@@@@@std@@QAE@XZ ENDP ; std::_Uninitialized_backout_al<xalloc<R_dsgraph::_MatrixItem> >::~_Uninitialized_backout_al<xalloc<R_dsgraph::_MatrixItem> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??0?$_Uninitialized_backout_al@V?$xalloc@U_MatrixItem@R_dsgraph@@@@@std@@QAE@PAU_MatrixItem@R_dsgraph@@AAV?$xalloc@U_MatrixItem@R_dsgraph@@@@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Al_$ = 12						; size = 4
??0?$_Uninitialized_backout_al@V?$xalloc@U_MatrixItem@R_dsgraph@@@@@std@@QAE@PAU_MatrixItem@R_dsgraph@@AAV?$xalloc@U_MatrixItem@R_dsgraph@@@@@Z PROC ; std::_Uninitialized_backout_al<xalloc<R_dsgraph::_MatrixItem> >::_Uninitialized_backout_al<xalloc<R_dsgraph::_MatrixItem> >, COMDAT
; _this$ = ecx

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	eax, DWORD PTR __Dest$[esp-4]
	mov	DWORD PTR [ecx], eax
	mov	DWORD PTR [ecx+4], eax
	mov	eax, DWORD PTR __Al_$[esp-4]
	mov	DWORD PTR [ecx+8], eax
	mov	eax, ecx
	ret	8
??0?$_Uninitialized_backout_al@V?$xalloc@U_MatrixItem@R_dsgraph@@@@@std@@QAE@PAU_MatrixItem@R_dsgraph@@AAV?$xalloc@U_MatrixItem@R_dsgraph@@@@@Z ENDP ; std::_Uninitialized_backout_al<xalloc<R_dsgraph::_MatrixItem> >::_Uninitialized_backout_al<xalloc<R_dsgraph::_MatrixItem> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Release@?$_Uninitialized_backout_al@V?$xalloc@PAUcaster@CLightShadows@@@@@std@@QAEPAPAUcaster@CLightShadows@@XZ
_TEXT	SEGMENT
?_Release@?$_Uninitialized_backout_al@V?$xalloc@PAUcaster@CLightShadows@@@@@std@@QAEPAPAUcaster@CLightShadows@@XZ PROC ; std::_Uninitialized_backout_al<xalloc<CLightShadows::caster *> >::_Release, COMDAT
; _this$ = ecx

; 1625 :         _First = _Last;

	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [ecx], eax

; 1626 :         return _Last;
; 1627 :     }

	ret	0
?_Release@?$_Uninitialized_backout_al@V?$xalloc@PAUcaster@CLightShadows@@@@@std@@QAEPAPAUcaster@CLightShadows@@XZ ENDP ; std::_Uninitialized_backout_al<xalloc<CLightShadows::caster *> >::_Release
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??1?$_Uninitialized_backout_al@V?$xalloc@PAUcaster@CLightShadows@@@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Uninitialized_backout_al@V?$xalloc@PAUcaster@CLightShadows@@@@@std@@QAE@XZ PROC ; std::_Uninitialized_backout_al<xalloc<CLightShadows::caster *> >::~_Uninitialized_backout_al<xalloc<CLightShadows::caster *> >, COMDAT
; _this$ = ecx

; 1615 :         _Destroy_range(_First, _Last, _Al);
; 1616 :     }

	ret	0
??1?$_Uninitialized_backout_al@V?$xalloc@PAUcaster@CLightShadows@@@@@std@@QAE@XZ ENDP ; std::_Uninitialized_backout_al<xalloc<CLightShadows::caster *> >::~_Uninitialized_backout_al<xalloc<CLightShadows::caster *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??0?$_Uninitialized_backout_al@V?$xalloc@PAUcaster@CLightShadows@@@@@std@@QAE@PAPAUcaster@CLightShadows@@AAV?$xalloc@PAUcaster@CLightShadows@@@@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Al_$ = 12						; size = 4
??0?$_Uninitialized_backout_al@V?$xalloc@PAUcaster@CLightShadows@@@@@std@@QAE@PAPAUcaster@CLightShadows@@AAV?$xalloc@PAUcaster@CLightShadows@@@@@Z PROC ; std::_Uninitialized_backout_al<xalloc<CLightShadows::caster *> >::_Uninitialized_backout_al<xalloc<CLightShadows::caster *> >, COMDAT
; _this$ = ecx

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	eax, DWORD PTR __Dest$[esp-4]
	mov	DWORD PTR [ecx], eax
	mov	DWORD PTR [ecx+4], eax
	mov	eax, DWORD PTR __Al_$[esp-4]
	mov	DWORD PTR [ecx+8], eax
	mov	eax, ecx
	ret	8
??0?$_Uninitialized_backout_al@V?$xalloc@PAUcaster@CLightShadows@@@@@std@@QAE@PAPAUcaster@CLightShadows@@AAV?$xalloc@PAUcaster@CLightShadows@@@@@Z ENDP ; std::_Uninitialized_backout_al<xalloc<CLightShadows::caster *> >::_Uninitialized_backout_al<xalloc<CLightShadows::caster *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Release@?$_Uninitialized_backout_al@V?$xalloc@Ushadow@CLightShadows@@@@@std@@QAEPAUshadow@CLightShadows@@XZ
_TEXT	SEGMENT
?_Release@?$_Uninitialized_backout_al@V?$xalloc@Ushadow@CLightShadows@@@@@std@@QAEPAUshadow@CLightShadows@@XZ PROC ; std::_Uninitialized_backout_al<xalloc<CLightShadows::shadow> >::_Release, COMDAT
; _this$ = ecx

; 1625 :         _First = _Last;

	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [ecx], eax

; 1626 :         return _Last;
; 1627 :     }

	ret	0
?_Release@?$_Uninitialized_backout_al@V?$xalloc@Ushadow@CLightShadows@@@@@std@@QAEPAUshadow@CLightShadows@@XZ ENDP ; std::_Uninitialized_backout_al<xalloc<CLightShadows::shadow> >::_Release
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??1?$_Uninitialized_backout_al@V?$xalloc@Ushadow@CLightShadows@@@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Uninitialized_backout_al@V?$xalloc@Ushadow@CLightShadows@@@@@std@@QAE@XZ PROC ; std::_Uninitialized_backout_al<xalloc<CLightShadows::shadow> >::~_Uninitialized_backout_al<xalloc<CLightShadows::shadow> >, COMDAT
; _this$ = ecx

; 1615 :         _Destroy_range(_First, _Last, _Al);
; 1616 :     }

	ret	0
??1?$_Uninitialized_backout_al@V?$xalloc@Ushadow@CLightShadows@@@@@std@@QAE@XZ ENDP ; std::_Uninitialized_backout_al<xalloc<CLightShadows::shadow> >::~_Uninitialized_backout_al<xalloc<CLightShadows::shadow> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??0?$_Uninitialized_backout_al@V?$xalloc@Ushadow@CLightShadows@@@@@std@@QAE@PAUshadow@CLightShadows@@AAV?$xalloc@Ushadow@CLightShadows@@@@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Al_$ = 12						; size = 4
??0?$_Uninitialized_backout_al@V?$xalloc@Ushadow@CLightShadows@@@@@std@@QAE@PAUshadow@CLightShadows@@AAV?$xalloc@Ushadow@CLightShadows@@@@@Z PROC ; std::_Uninitialized_backout_al<xalloc<CLightShadows::shadow> >::_Uninitialized_backout_al<xalloc<CLightShadows::shadow> >, COMDAT
; _this$ = ecx

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	eax, DWORD PTR __Dest$[esp-4]
	mov	DWORD PTR [ecx], eax
	mov	DWORD PTR [ecx+4], eax
	mov	eax, DWORD PTR __Al_$[esp-4]
	mov	DWORD PTR [ecx+8], eax
	mov	eax, ecx
	ret	8
??0?$_Uninitialized_backout_al@V?$xalloc@Ushadow@CLightShadows@@@@@std@@QAE@PAUshadow@CLightShadows@@AAV?$xalloc@Ushadow@CLightShadows@@@@@Z ENDP ; std::_Uninitialized_backout_al<xalloc<CLightShadows::shadow> >::_Uninitialized_backout_al<xalloc<CLightShadows::shadow> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Release@?$_Uninitialized_backout_al@V?$xalloc@Utess_tri@CLightShadows@@@@@std@@QAEPAUtess_tri@CLightShadows@@XZ
_TEXT	SEGMENT
?_Release@?$_Uninitialized_backout_al@V?$xalloc@Utess_tri@CLightShadows@@@@@std@@QAEPAUtess_tri@CLightShadows@@XZ PROC ; std::_Uninitialized_backout_al<xalloc<CLightShadows::tess_tri> >::_Release, COMDAT
; _this$ = ecx

; 1625 :         _First = _Last;

	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [ecx], eax

; 1626 :         return _Last;
; 1627 :     }

	ret	0
?_Release@?$_Uninitialized_backout_al@V?$xalloc@Utess_tri@CLightShadows@@@@@std@@QAEPAUtess_tri@CLightShadows@@XZ ENDP ; std::_Uninitialized_backout_al<xalloc<CLightShadows::tess_tri> >::_Release
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??1?$_Uninitialized_backout_al@V?$xalloc@Utess_tri@CLightShadows@@@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Uninitialized_backout_al@V?$xalloc@Utess_tri@CLightShadows@@@@@std@@QAE@XZ PROC ; std::_Uninitialized_backout_al<xalloc<CLightShadows::tess_tri> >::~_Uninitialized_backout_al<xalloc<CLightShadows::tess_tri> >, COMDAT
; _this$ = ecx

; 1615 :         _Destroy_range(_First, _Last, _Al);
; 1616 :     }

	ret	0
??1?$_Uninitialized_backout_al@V?$xalloc@Utess_tri@CLightShadows@@@@@std@@QAE@XZ ENDP ; std::_Uninitialized_backout_al<xalloc<CLightShadows::tess_tri> >::~_Uninitialized_backout_al<xalloc<CLightShadows::tess_tri> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??0?$_Uninitialized_backout_al@V?$xalloc@Utess_tri@CLightShadows@@@@@std@@QAE@PAUtess_tri@CLightShadows@@AAV?$xalloc@Utess_tri@CLightShadows@@@@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Al_$ = 12						; size = 4
??0?$_Uninitialized_backout_al@V?$xalloc@Utess_tri@CLightShadows@@@@@std@@QAE@PAUtess_tri@CLightShadows@@AAV?$xalloc@Utess_tri@CLightShadows@@@@@Z PROC ; std::_Uninitialized_backout_al<xalloc<CLightShadows::tess_tri> >::_Uninitialized_backout_al<xalloc<CLightShadows::tess_tri> >, COMDAT
; _this$ = ecx

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	eax, DWORD PTR __Dest$[esp-4]
	mov	DWORD PTR [ecx], eax
	mov	DWORD PTR [ecx+4], eax
	mov	eax, DWORD PTR __Al_$[esp-4]
	mov	DWORD PTR [ecx+8], eax
	mov	eax, ecx
	ret	8
??0?$_Uninitialized_backout_al@V?$xalloc@Utess_tri@CLightShadows@@@@@std@@QAE@PAUtess_tri@CLightShadows@@AAV?$xalloc@Utess_tri@CLightShadows@@@@@Z ENDP ; std::_Uninitialized_backout_al<xalloc<CLightShadows::tess_tri> >::_Uninitialized_backout_al<xalloc<CLightShadows::tess_tri> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Seek_to@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@Ucache_item@CLightShadows@@@std@@@std@@@std@@QAEXPBUcache_item@CLightShadows@@@Z
_TEXT	SEGMENT
__It$ = 8						; size = 4
?_Seek_to@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@Ucache_item@CLightShadows@@@std@@@std@@@std@@QAEXPBUcache_item@CLightShadows@@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CLightShadows::cache_item> > >::_Seek_to, COMDAT
; _this$ = ecx

; 205  :         _Ptr = _Refancy<_Tptr>(const_cast<value_type*>(_It));

	mov	eax, DWORD PTR __It$[esp-4]
	mov	DWORD PTR [ecx], eax

; 206  :     }

	ret	4
?_Seek_to@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@Ucache_item@CLightShadows@@@std@@@std@@@std@@QAEXPBUcache_item@CLightShadows@@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CLightShadows::cache_item> > >::_Seek_to
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Xlength@?$vector@Ucache_item@CLightShadows@@V?$xalloc@Ucache_item@CLightShadows@@@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@Ucache_item@CLightShadows@@V?$xalloc@Ucache_item@CLightShadows@@@@@std@@CAXXZ PROC ; std::vector<CLightShadows::cache_item,xalloc<CLightShadows::cache_item> >::_Xlength, COMDAT

; 1761 :         _Xlength_error("vector too long");

	push	OFFSET ??_C@_0BA@FOIKENOD@vector?5too?5long@
	call	DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN3@Xlength:
	int	3
?_Xlength@?$vector@Ucache_item@CLightShadows@@V?$xalloc@Ucache_item@CLightShadows@@@@@std@@CAXXZ ENDP ; std::vector<CLightShadows::cache_item,xalloc<CLightShadows::cache_item> >::_Xlength
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Change_array@?$vector@Ucache_item@CLightShadows@@V?$xalloc@Ucache_item@CLightShadows@@@@@std@@AAEXQAUcache_item@CLightShadows@@II@Z
_TEXT	SEGMENT
__Newvec$ = 8						; size = 4
__Newsize$ = 12						; size = 4
__Newcapacity$ = 16					; size = 4
?_Change_array@?$vector@Ucache_item@CLightShadows@@V?$xalloc@Ucache_item@CLightShadows@@@@@std@@AAEXQAUcache_item@CLightShadows@@II@Z PROC ; std::vector<CLightShadows::cache_item,xalloc<CLightShadows::cache_item> >::_Change_array, COMDAT
; _this$ = ecx

; 1723 :         const pointer _Newvec, const size_type _Newsize, const size_type _Newcapacity) {

	push	esi
	mov	esi, ecx

; 1724 :         // orphan all iterators, discard old array, acquire new array
; 1725 :         auto& _My_data    = _Mypair._Myval2;
; 1726 :         pointer& _Myfirst = _My_data._Myfirst;
; 1727 :         pointer& _Mylast  = _My_data._Mylast;
; 1728 :         pointer& _Myend   = _My_data._Myend;
; 1729 : 
; 1730 :         _My_data._Orphan_all();
; 1731 : 
; 1732 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN7@Change_arr
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN7@Change_arr:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1738 :         _Mylast  = _Newvec + _Newsize;

	imul	eax, DWORD PTR __Newsize$[esp], 44
	mov	ecx, DWORD PTR __Newvec$[esp]
	mov	DWORD PTR [esi], ecx
	add	eax, ecx
	mov	DWORD PTR [esi+4], eax

; 1739 :         _Myend   = _Newvec + _Newcapacity;

	imul	eax, DWORD PTR __Newcapacity$[esp], 44
	add	eax, ecx
	mov	DWORD PTR [esi+8], eax
	pop	esi

; 1740 :     }

	ret	12					; 0000000cH
?_Change_array@?$vector@Ucache_item@CLightShadows@@V?$xalloc@Ucache_item@CLightShadows@@@@@std@@AAEXQAUcache_item@CLightShadows@@II@Z ENDP ; std::vector<CLightShadows::cache_item,xalloc<CLightShadows::cache_item> >::_Change_array
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Calculate_growth@?$vector@Ucache_item@CLightShadows@@V?$xalloc@Ucache_item@CLightShadows@@@@@std@@ABEII@Z
_TEXT	SEGMENT
__Newsize$ = 8						; size = 4
?_Calculate_growth@?$vector@Ucache_item@CLightShadows@@V?$xalloc@Ucache_item@CLightShadows@@@@@std@@ABEII@Z PROC ; std::vector<CLightShadows::cache_item,xalloc<CLightShadows::cache_item> >::_Calculate_growth, COMDAT
; _this$ = ecx

; 1546 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx]

; 1671 :         // given _Oldcapacity and _Newsize, calculate geometric growth
; 1672 :         const size_type _Oldcapacity = capacity();
; 1673 :         const auto _Max              = max_size();
; 1674 : 
; 1675 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	ecx, 97612893				; 05d1745dH

; 1546 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	sar	eax, 2

; 1670 :     _CONSTEXPR20_CONTAINER size_type _Calculate_growth(const size_type _Newsize) const {

	push	esi

; 1546 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	imul	esi, eax, -1171354717

; 1671 :         // given _Oldcapacity and _Newsize, calculate geometric growth
; 1672 :         const size_type _Oldcapacity = capacity();
; 1673 :         const auto _Max              = max_size();
; 1674 : 
; 1675 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	edx, esi
	shr	edx, 1
	sub	ecx, edx
	cmp	esi, ecx
	jbe	SHORT $LN2@Calculate_

; 1676 :             return _Max; // geometric growth would overflow

	mov	eax, 97612893				; 05d1745dH
	pop	esi

; 1682 :             return _Newsize; // geometric growth would be insufficient
; 1683 :         }
; 1684 : 
; 1685 :         return _Geometric; // geometric growth is sufficient
; 1686 :     }

	ret	4
$LN2@Calculate_:

; 1677 :         }
; 1678 : 
; 1679 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	lea	eax, DWORD PTR [edx+esi]

; 1680 : 
; 1681 :         if (_Geometric < _Newsize) {

	cmp	eax, DWORD PTR __Newsize$[esp]
	pop	esi
	cmovb	eax, DWORD PTR __Newsize$[esp-4]

; 1682 :             return _Newsize; // geometric growth would be insufficient
; 1683 :         }
; 1684 : 
; 1685 :         return _Geometric; // geometric growth is sufficient
; 1686 :     }

	ret	4
?_Calculate_growth@?$vector@Ucache_item@CLightShadows@@V?$xalloc@Ucache_item@CLightShadows@@@@@std@@ABEII@Z ENDP ; std::vector<CLightShadows::cache_item,xalloc<CLightShadows::cache_item> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Umove_if_noexcept@?$vector@Ucache_item@CLightShadows@@V?$xalloc@Ucache_item@CLightShadows@@@@@std@@AAEXPAUcache_item@CLightShadows@@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
?_Umove_if_noexcept@?$vector@Ucache_item@CLightShadows@@V?$xalloc@Ucache_item@CLightShadows@@@@@std@@AAEXPAUcache_item@CLightShadows@@00@Z PROC ; std::vector<CLightShadows::cache_item,xalloc<CLightShadows::cache_item> >::_Umove_if_noexcept, COMDAT
; _this$dead$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1703 :     auto _UFirst      = _Get_unwrapped(_First);

	mov	eax, DWORD PTR __First$[esp-4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1659 :     _CONSTEXPR20_CONTAINER void _Umove_if_noexcept(pointer _First, pointer _Last, pointer _Dest) {

	push	ebx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	mov	ebx, DWORD PTR __Last$[esp]
	cmp	eax, ebx
	je	SHORT $LN7@Umove_if_n

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	edx, DWORD PTR __Dest$[esp]
	push	esi
	sub	edx, eax
	push	edi
$LL8@Umove_if_n:
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	lea	edi, DWORD PTR [edx+eax]
	mov	esi, eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	add	eax, 44					; 0000002cH
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	ecx, 11					; 0000000bH
	rep movsd
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	eax, ebx
	jne	SHORT $LL8@Umove_if_n
	pop	edi
	pop	esi
$LN7@Umove_if_n:
	pop	ebx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1663 :     }

	ret	12					; 0000000cH
?_Umove_if_noexcept@?$vector@Ucache_item@CLightShadows@@V?$xalloc@Ucache_item@CLightShadows@@@@@std@@AAEXPAUcache_item@CLightShadows@@00@Z ENDP ; std::vector<CLightShadows::cache_item,xalloc<CLightShadows::cache_item> >::_Umove_if_noexcept
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Umove@?$vector@Ucache_item@CLightShadows@@V?$xalloc@Ucache_item@CLightShadows@@@@@std@@AAEPAUcache_item@CLightShadows@@PAU34@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
?_Umove@?$vector@Ucache_item@CLightShadows@@V?$xalloc@Ucache_item@CLightShadows@@@@@std@@AAEPAUcache_item@CLightShadows@@PAU34@00@Z PROC ; std::vector<CLightShadows::cache_item,xalloc<CLightShadows::cache_item> >::_Umove, COMDAT
; _this$dead$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	mov	edx, DWORD PTR __First$[esp-4]

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	eax, DWORD PTR __Dest$[esp-4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1644 :     _CONSTEXPR20_CONTAINER pointer _Umove(pointer _First, pointer _Last, pointer _Dest) {

	push	ebx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	mov	ebx, DWORD PTR __Last$[esp]
	cmp	edx, ebx
	je	SHORT $LN5@Umove
	push	esi
	push	edi
$LL6@Umove:
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	esi, edx
	mov	edi, eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1621 :         ++_Last;

	add	edx, 44					; 0000002cH
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	ecx, 11					; 0000000bH
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1621 :         ++_Last;

	add	eax, 44					; 0000002cH
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	rep movsd
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	edx, ebx
	jne	SHORT $LL6@Umove
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1646 :         return _Uninitialized_move(_First, _Last, _Dest, _Getal());

	pop	edi
	pop	esi
$LN5@Umove:

; 1647 :     }

	pop	ebx
	ret	12					; 0000000cH
?_Umove@?$vector@Ucache_item@CLightShadows@@V?$xalloc@Ucache_item@CLightShadows@@@@@std@@AAEPAUcache_item@CLightShadows@@PAU34@00@Z ENDP ; std::vector<CLightShadows::cache_item,xalloc<CLightShadows::cache_item> >::_Umove
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?max_size@?$vector@Ucache_item@CLightShadows@@V?$xalloc@Ucache_item@CLightShadows@@@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@Ucache_item@CLightShadows@@V?$xalloc@Ucache_item@CLightShadows@@@@@std@@QBEIXZ PROC ; std::vector<CLightShadows::cache_item,xalloc<CLightShadows::cache_item> >::max_size, COMDAT
; _this$dead$ = ecx

; 1540 :         return (_STD min)(

	mov	eax, 97612893				; 05d1745dH

; 1541 :             static_cast<size_type>((numeric_limits<difference_type>::max)()), _Alty_traits::max_size(_Getal()));
; 1542 :     }

	ret	0
?max_size@?$vector@Ucache_item@CLightShadows@@V?$xalloc@Ucache_item@CLightShadows@@@@@std@@QBEIXZ ENDP ; std::vector<CLightShadows::cache_item,xalloc<CLightShadows::cache_item> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?construct@?$xalloc@Ucache_item@CLightShadows@@@@QAEXPAUcache_item@CLightShadows@@ABU23@@Z
_TEXT	SEGMENT
_p$ = 8							; size = 4
__Val$ = 12						; size = 4
?construct@?$xalloc@Ucache_item@CLightShadows@@@@QAEXPAUcache_item@CLightShadows@@ABU23@@Z PROC ; xalloc<CLightShadows::cache_item>::construct, COMDAT
; _this$dead$ = ecx

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	push	esi
	mov	esi, DWORD PTR __Val$[esp]
	mov	ecx, 11					; 0000000bH
	push	edi
	mov	edi, DWORD PTR _p$[esp+4]
	rep movsd
	pop	edi
	pop	esi
	ret	8
?construct@?$xalloc@Ucache_item@CLightShadows@@@@QAEXPAUcache_item@CLightShadows@@ABU23@@Z ENDP ; xalloc<CLightShadows::cache_item>::construct
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?allocate@?$xalloc@Ucache_item@CLightShadows@@@@QBEPAUcache_item@CLightShadows@@IPBX@Z
_TEXT	SEGMENT
_n$ = 8							; size = 4
_p$dead$ = 12						; size = 4
?allocate@?$xalloc@Ucache_item@CLightShadows@@@@QBEPAUcache_item@CLightShadows@@IPBX@Z PROC ; xalloc<CLightShadows::cache_item>::allocate, COMDAT
; _this$dead$ = ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	imul	eax, DWORD PTR _n$[esp-4], 44
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 80   : 							pointer					allocate		(size_type n, const void* p=0) const	{	return xr_alloc<T>((u32)n);	}

	ret	8
?allocate@?$xalloc@Ucache_item@CLightShadows@@@@QBEPAUcache_item@CLightShadows@@IPBX@Z ENDP ; xalloc<CLightShadows::cache_item>::allocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?destroy@?$xalloc@Utess_tri@CLightShadows@@@@QAEXPAUtess_tri@CLightShadows@@@Z
_TEXT	SEGMENT
_p$dead$ = 8						; size = 4
?destroy@?$xalloc@Utess_tri@CLightShadows@@@@QAEXPAUtess_tri@CLightShadows@@@Z PROC ; xalloc<CLightShadows::tess_tri>::destroy, COMDAT
; _this$dead$ = ecx

; 85   : 							void					destroy			(pointer p)								{	std::_Destroy_in_place(p);			}

	ret	4
?destroy@?$xalloc@Utess_tri@CLightShadows@@@@QAEXPAUtess_tri@CLightShadows@@@Z ENDP ; xalloc<CLightShadows::tess_tri>::destroy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?destroy@?$xalloc@Ushadow@CLightShadows@@@@QAEXPAUshadow@CLightShadows@@@Z
_TEXT	SEGMENT
_p$dead$ = 8						; size = 4
?destroy@?$xalloc@Ushadow@CLightShadows@@@@QAEXPAUshadow@CLightShadows@@@Z PROC ; xalloc<CLightShadows::shadow>::destroy, COMDAT
; _this$dead$ = ecx

; 85   : 							void					destroy			(pointer p)								{	std::_Destroy_in_place(p);			}

	ret	4
?destroy@?$xalloc@Ushadow@CLightShadows@@@@QAEXPAUshadow@CLightShadows@@@Z ENDP ; xalloc<CLightShadows::shadow>::destroy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?destroy@?$xalloc@U_MatrixItem@R_dsgraph@@@@QAEXPAU_MatrixItem@R_dsgraph@@@Z
_TEXT	SEGMENT
_p$dead$ = 8						; size = 4
?destroy@?$xalloc@U_MatrixItem@R_dsgraph@@@@QAEXPAU_MatrixItem@R_dsgraph@@@Z PROC ; xalloc<R_dsgraph::_MatrixItem>::destroy, COMDAT
; _this$dead$ = ecx

; 85   : 							void					destroy			(pointer p)								{	std::_Destroy_in_place(p);			}

	ret	4
?destroy@?$xalloc@U_MatrixItem@R_dsgraph@@@@QAEXPAU_MatrixItem@R_dsgraph@@@Z ENDP ; xalloc<R_dsgraph::_MatrixItem>::destroy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ??0?$xalloc@U_MatrixItem@R_dsgraph@@@@QAE@XZ
_TEXT	SEGMENT
??0?$xalloc@U_MatrixItem@R_dsgraph@@@@QAE@XZ PROC	; xalloc<R_dsgraph::_MatrixItem>::xalloc<R_dsgraph::_MatrixItem>, COMDAT
; _this$ = ecx

; 76   : 													xalloc			()										{	}

	mov	eax, ecx
	ret	0
??0?$xalloc@U_MatrixItem@R_dsgraph@@@@QAE@XZ ENDP	; xalloc<R_dsgraph::_MatrixItem>::xalloc<R_dsgraph::_MatrixItem>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@U_MatrixItem@R_dsgraph@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Vector_val@U?$_Simple_types@U_MatrixItem@R_dsgraph@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<std::_Simple_types<R_dsgraph::_MatrixItem> >::_Vector_val<std::_Simple_types<R_dsgraph::_MatrixItem> >, COMDAT
; _this$ = ecx

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx], 0
	mov	eax, ecx
	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0
	ret	0
??0?$_Vector_val@U?$_Simple_types@U_MatrixItem@R_dsgraph@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<std::_Simple_types<R_dsgraph::_MatrixItem> >::_Vector_val<std::_Simple_types<R_dsgraph::_MatrixItem> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Getal@?$vector@Ucache_item@CLightShadows@@V?$xalloc@Ucache_item@CLightShadows@@@@@std@@ABEABV?$xalloc@Ucache_item@CLightShadows@@@@XZ
_TEXT	SEGMENT
?_Getal@?$vector@Ucache_item@CLightShadows@@V?$xalloc@Ucache_item@CLightShadows@@@@@std@@ABEABV?$xalloc@Ucache_item@CLightShadows@@@@XZ PROC ; std::vector<CLightShadows::cache_item,xalloc<CLightShadows::cache_item> >::_Getal, COMDAT
; _this$ = ecx

; 1809 :         return _Mypair._Get_first();

	mov	eax, ecx

; 1810 :     }

	ret	0
?_Getal@?$vector@Ucache_item@CLightShadows@@V?$xalloc@Ucache_item@CLightShadows@@@@@std@@ABEABV?$xalloc@Ucache_item@CLightShadows@@@@XZ ENDP ; std::vector<CLightShadows::cache_item,xalloc<CLightShadows::cache_item> >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Umove_if_noexcept1@?$vector@Ucache_item@CLightShadows@@V?$xalloc@Ucache_item@CLightShadows@@@@@std@@AAEXPAUcache_item@CLightShadows@@00U?$integral_constant@_N$00@2@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
?_Umove_if_noexcept1@?$vector@Ucache_item@CLightShadows@@V?$xalloc@Ucache_item@CLightShadows@@@@@std@@AAEXPAUcache_item@CLightShadows@@00U?$integral_constant@_N$00@2@@Z PROC ; std::vector<CLightShadows::cache_item,xalloc<CLightShadows::cache_item> >::_Umove_if_noexcept1, COMDAT
; _this$dead$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1703 :     auto _UFirst      = _Get_unwrapped(_First);

	mov	eax, DWORD PTR __First$[esp-4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1649 :     _CONSTEXPR20_CONTAINER void _Umove_if_noexcept1(pointer _First, pointer _Last, pointer _Dest, true_type) {

	push	ebx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	mov	ebx, DWORD PTR __Last$[esp]
	cmp	eax, ebx
	je	SHORT $LN5@Umove_if_n

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	edx, DWORD PTR __Dest$[esp]
	push	esi
	sub	edx, eax
	push	edi
$LL6@Umove_if_n:
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	lea	edi, DWORD PTR [edx+eax]
	mov	esi, eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	add	eax, 44					; 0000002cH
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	ecx, 11					; 0000000bH
	rep movsd
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	eax, ebx
	jne	SHORT $LL6@Umove_if_n
	pop	edi
	pop	esi
$LN5@Umove_if_n:
	pop	ebx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1652 :     }

	ret	16					; 00000010H
?_Umove_if_noexcept1@?$vector@Ucache_item@CLightShadows@@V?$xalloc@Ucache_item@CLightShadows@@@@@std@@AAEXPAUcache_item@CLightShadows@@00U?$integral_constant@_N$00@2@@Z ENDP ; std::vector<CLightShadows::cache_item,xalloc<CLightShadows::cache_item> >::_Umove_if_noexcept1
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?capacity@?$vector@Ucache_item@CLightShadows@@V?$xalloc@Ucache_item@CLightShadows@@@@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@Ucache_item@CLightShadows@@V?$xalloc@Ucache_item@CLightShadows@@@@@std@@QBEIXZ PROC ; std::vector<CLightShadows::cache_item,xalloc<CLightShadows::cache_item> >::capacity, COMDAT
; _this$ = ecx

; 1545 :         auto& _My_data = _Mypair._Myval2;
; 1546 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx]
	sar	eax, 2
	imul	eax, eax, -1171354717

; 1547 :     }

	ret	0
?capacity@?$vector@Ucache_item@CLightShadows@@V?$xalloc@Ucache_item@CLightShadows@@@@@std@@QBEIXZ ENDP ; std::vector<CLightShadows::cache_item,xalloc<CLightShadows::cache_item> >::capacity
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?max_size@?$_Normal_allocator_traits@V?$xalloc@Ucache_item@CLightShadows@@@@@std@@SAIABV?$xalloc@Ucache_item@CLightShadows@@@@@Z
_TEXT	SEGMENT
?max_size@?$_Normal_allocator_traits@V?$xalloc@Ucache_item@CLightShadows@@@@@std@@SAIABV?$xalloc@Ucache_item@CLightShadows@@@@@Z PROC ; std::_Normal_allocator_traits<xalloc<CLightShadows::cache_item> >::max_size, COMDAT
; __Al$dead$ = ecx

; 591  :         if constexpr (_Has_max_size<_Alloc>::value) {
; 592  :             return _Al.max_size();

	mov	eax, 97612893				; 05d1745dH

; 593  :         } else {
; 594  :             return (numeric_limits<size_type>::max)() / sizeof(value_type);
; 595  :         }
; 596  :     }

	ret	0
?max_size@?$_Normal_allocator_traits@V?$xalloc@Ucache_item@CLightShadows@@@@@std@@SAIABV?$xalloc@Ucache_item@CLightShadows@@@@@Z ENDP ; std::_Normal_allocator_traits<xalloc<CLightShadows::cache_item> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$xalloc@Ucache_item@CLightShadows@@@@V?$_Vector_val@U?$_Simple_types@Ucache_item@CLightShadows@@@std@@@std@@$00@std@@QBEABV?$xalloc@Ucache_item@CLightShadows@@@@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@V?$xalloc@Ucache_item@CLightShadows@@@@V?$_Vector_val@U?$_Simple_types@Ucache_item@CLightShadows@@@std@@@std@@$00@std@@QBEABV?$xalloc@Ucache_item@CLightShadows@@@@XZ PROC ; std::_Compressed_pair<xalloc<CLightShadows::cache_item>,std::_Vector_val<std::_Simple_types<CLightShadows::cache_item> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 1343 :         return *this;

	mov	eax, ecx

; 1344 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$xalloc@Ucache_item@CLightShadows@@@@V?$_Vector_val@U?$_Simple_types@Ucache_item@CLightShadows@@@std@@@std@@$00@std@@QBEABV?$xalloc@Ucache_item@CLightShadows@@@@XZ ENDP ; std::_Compressed_pair<xalloc<CLightShadows::cache_item>,std::_Vector_val<std::_Simple_types<CLightShadows::cache_item> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?max_size@?$xalloc@Ucache_item@CLightShadows@@@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$xalloc@Ucache_item@CLightShadows@@@@QBEIXZ PROC ; xalloc<CLightShadows::cache_item>::max_size, COMDAT
; _this$dead$ = ecx

; 86   : 							size_type				max_size		() const								{	size_type _Count = (size_type)(-1) / sizeof (T);	return (0 < _Count ? _Count : 1);	}

	mov	eax, 97612893				; 05d1745dH
	ret	0
?max_size@?$xalloc@Ucache_item@CLightShadows@@@@QBEIXZ ENDP ; xalloc<CLightShadows::cache_item>::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$advance@PAUcache_item@CLightShadows@@H@std@@YAXAAPAUcache_item@CLightShadows@@H@Z
_TEXT	SEGMENT
??$advance@PAUcache_item@CLightShadows@@H@std@@YAXAAPAUcache_item@CLightShadows@@H@Z PROC ; std::advance<CLightShadows::cache_item *,int>, COMDAT
; __Where$ = ecx
; __Off$ = edx

; 1496 :     if constexpr (_Is_random_iter_v<_InIt>) {
; 1497 :         _Where += _Off;

	imul	eax, edx, 44
	add	DWORD PTR [ecx], eax

; 1498 :     } else {
; 1499 :         if constexpr (is_signed_v<_Diff> && !_Is_bidi_iter_v<_InIt>) {
; 1500 :             _STL_ASSERT(_Off >= 0, "negative advance of non-bidirectional iterator");
; 1501 :         }
; 1502 : 
; 1503 :         decltype(auto) _UWhere      = _Get_unwrapped_n(_STD move(_Where), _Off);
; 1504 :         constexpr bool _Need_rewrap = !is_reference_v<decltype(_Get_unwrapped_n(_STD move(_Where), _Off))>;
; 1505 : 
; 1506 :         if constexpr (is_signed_v<_Diff> && _Is_bidi_iter_v<_InIt>) {
; 1507 :             for (; _Off < 0; ++_Off) {
; 1508 :                 --_UWhere;
; 1509 :             }
; 1510 :         }
; 1511 : 
; 1512 :         for (; 0 < _Off; --_Off) {
; 1513 :             ++_UWhere;
; 1514 :         }
; 1515 : 
; 1516 :         if constexpr (_Need_rewrap) {
; 1517 :             _Seek_wrapped(_Where, _STD move(_UWhere));
; 1518 :         }
; 1519 :     }
; 1520 : }

	ret	0
??$advance@PAUcache_item@CLightShadows@@H@std@@YAXAAPAUcache_item@CLightShadows@@H@Z ENDP ; std::advance<CLightShadows::cache_item *,int>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\type_traits
;	COMDAT ??$forward@AAPAUcache_item@CLightShadows@@@std@@YAAAPAUcache_item@CLightShadows@@AAPAU12@@Z
_TEXT	SEGMENT
??$forward@AAPAUcache_item@CLightShadows@@@std@@YAAAPAUcache_item@CLightShadows@@AAPAU12@@Z PROC ; std::forward<CLightShadows::cache_item * &>, COMDAT
; __Arg$ = ecx

; 1386 :     return static_cast<_Ty&&>(_Arg);

	mov	eax, ecx

; 1387 : }

	ret	0
??$forward@AAPAUcache_item@CLightShadows@@@std@@YAAAPAUcache_item@CLightShadows@@AAPAU12@@Z ENDP ; std::forward<CLightShadows::cache_item * &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\type_traits
;	COMDAT ??$forward@Ucache_item@CLightShadows@@@std@@YA$$QAUcache_item@CLightShadows@@AAU12@@Z
_TEXT	SEGMENT
??$forward@Ucache_item@CLightShadows@@@std@@YA$$QAUcache_item@CLightShadows@@AAU12@@Z PROC ; std::forward<CLightShadows::cache_item>, COMDAT
; __Arg$ = ecx

; 1386 :     return static_cast<_Ty&&>(_Arg);

	mov	eax, ecx

; 1387 : }

	ret	0
??$forward@Ucache_item@CLightShadows@@@std@@YA$$QAUcache_item@CLightShadows@@AAU12@@Z ENDP ; std::forward<CLightShadows::cache_item>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_Copy_backward_memmove@PAUcache_item@CLightShadows@@PAU12@@std@@YAPAUcache_item@CLightShadows@@PAU12@00@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
??$_Copy_backward_memmove@PAUcache_item@CLightShadows@@PAU12@@std@@YAPAUcache_item@CLightShadows@@PAU12@00@Z PROC ; std::_Copy_backward_memmove<CLightShadows::cache_item *,CLightShadows::cache_item *>, COMDAT
; __First$ = ecx
; __Last$ = edx

; 4247 :     // implement copy_backward-like function as memmove
; 4248 :     auto _FirstPtr              = _To_address(_First);
; 4249 :     auto _LastPtr               = _To_address(_Last);
; 4250 :     auto _DestPtr               = _To_address(_Dest);
; 4251 :     const char* const _First_ch = const_cast<const char*>(reinterpret_cast<const volatile char*>(_FirstPtr));
; 4252 :     const char* const _Last_ch  = const_cast<const char*>(reinterpret_cast<const volatile char*>(_LastPtr));
; 4253 :     char* const _Dest_ch        = const_cast<char*>(reinterpret_cast<const volatile char*>(_DestPtr));
; 4254 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);
; 4255 :     auto _Result                = _CSTD memmove(_Dest_ch - _Count, _First_ch, _Count);

	mov	eax, DWORD PTR __Dest$[esp-4]
	sub	edx, ecx
	push	edx
	push	ecx
	sub	eax, edx
	push	eax
	call	_memmove
	add	esp, 12					; 0000000cH

; 4256 :     if constexpr (is_pointer_v<_CtgIt2>) {
; 4257 :         return static_cast<_CtgIt2>(_Result);
; 4258 :     } else {
; 4259 :         return _Dest - (_LastPtr - _FirstPtr);
; 4260 :     }
; 4261 : }

	ret	0
??$_Copy_backward_memmove@PAUcache_item@CLightShadows@@PAU12@@std@@YAPAUcache_item@CLightShadows@@PAU12@00@Z ENDP ; std::_Copy_backward_memmove<CLightShadows::cache_item *,CLightShadows::cache_item *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Emplace_back@Utess_tri@CLightShadows@@@?$_Uninitialized_backout_al@V?$xalloc@Utess_tri@CLightShadows@@@@@std@@QAEX$$QAUtess_tri@CLightShadows@@@Z
_TEXT	SEGMENT
_<_Vals_0>$ = 8						; size = 4
??$_Emplace_back@Utess_tri@CLightShadows@@@?$_Uninitialized_backout_al@V?$xalloc@Utess_tri@CLightShadows@@@@@std@@QAEX$$QAUtess_tri@CLightShadows@@@Z PROC ; std::_Uninitialized_backout_al<xalloc<CLightShadows::tess_tri> >::_Emplace_back<CLightShadows::tess_tri>, COMDAT
; _this$ = ecx

; 1619 :     _CONSTEXPR20_DYNALLOC void _Emplace_back(_Types&&... _Vals) { // construct a new element at *_Last and increment

	mov	eax, ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	ecx, 12					; 0000000cH
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1619 :     _CONSTEXPR20_DYNALLOC void _Emplace_back(_Types&&... _Vals) { // construct a new element at *_Last and increment

	push	esi
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	esi, DWORD PTR _<_Vals_0>$[esp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1619 :     _CONSTEXPR20_DYNALLOC void _Emplace_back(_Types&&... _Vals) { // construct a new element at *_Last and increment

	push	edi
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	edi, DWORD PTR [eax+4]
	rep movsd
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1621 :         ++_Last;

	add	DWORD PTR [eax+4], 48			; 00000030H
	pop	edi
	pop	esi

; 1622 :     }

	ret	4
??$_Emplace_back@Utess_tri@CLightShadows@@@?$_Uninitialized_backout_al@V?$xalloc@Utess_tri@CLightShadows@@@@@std@@QAEX$$QAUtess_tri@CLightShadows@@@Z ENDP ; std::_Uninitialized_backout_al<xalloc<CLightShadows::tess_tri> >::_Emplace_back<CLightShadows::tess_tri>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Emplace_back@Ushadow@CLightShadows@@@?$_Uninitialized_backout_al@V?$xalloc@Ushadow@CLightShadows@@@@@std@@QAEX$$QAUshadow@CLightShadows@@@Z
_TEXT	SEGMENT
_<_Vals_0>$ = 8						; size = 4
??$_Emplace_back@Ushadow@CLightShadows@@@?$_Uninitialized_backout_al@V?$xalloc@Ushadow@CLightShadows@@@@@std@@QAEX$$QAUshadow@CLightShadows@@@Z PROC ; std::_Uninitialized_backout_al<xalloc<CLightShadows::shadow> >::_Emplace_back<CLightShadows::shadow>, COMDAT
; _this$ = ecx

; 1619 :     _CONSTEXPR20_DYNALLOC void _Emplace_back(_Types&&... _Vals) { // construct a new element at *_Last and increment

	mov	eax, ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	ecx, 23					; 00000017H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1619 :     _CONSTEXPR20_DYNALLOC void _Emplace_back(_Types&&... _Vals) { // construct a new element at *_Last and increment

	push	esi
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	esi, DWORD PTR _<_Vals_0>$[esp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1619 :     _CONSTEXPR20_DYNALLOC void _Emplace_back(_Types&&... _Vals) { // construct a new element at *_Last and increment

	push	edi
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	edi, DWORD PTR [eax+4]
	rep movsd
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1621 :         ++_Last;

	add	DWORD PTR [eax+4], 92			; 0000005cH
	pop	edi
	pop	esi

; 1622 :     }

	ret	4
??$_Emplace_back@Ushadow@CLightShadows@@@?$_Uninitialized_backout_al@V?$xalloc@Ushadow@CLightShadows@@@@@std@@QAEX$$QAUshadow@CLightShadows@@@Z ENDP ; std::_Uninitialized_backout_al<xalloc<CLightShadows::shadow> >::_Emplace_back<CLightShadows::shadow>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\type_traits
;	COMDAT ??$move@AAPAUcaster@CLightShadows@@@std@@YA$$QAPAUcaster@CLightShadows@@AAPAU12@@Z
_TEXT	SEGMENT
??$move@AAPAUcaster@CLightShadows@@@std@@YA$$QAPAUcaster@CLightShadows@@AAPAU12@@Z PROC ; std::move<CLightShadows::caster * &>, COMDAT
; __Arg$ = ecx

; 1397 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

	mov	eax, ecx

; 1398 : }

	ret	0
??$move@AAPAUcaster@CLightShadows@@@std@@YA$$QAPAUcaster@CLightShadows@@AAPAU12@@Z ENDP ; std::move<CLightShadows::caster * &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Emplace_back@PAUcaster@CLightShadows@@@?$_Uninitialized_backout_al@V?$xalloc@PAUcaster@CLightShadows@@@@@std@@QAEX$$QAPAUcaster@CLightShadows@@@Z
_TEXT	SEGMENT
_<_Vals_0>$ = 8						; size = 4
??$_Emplace_back@PAUcaster@CLightShadows@@@?$_Uninitialized_backout_al@V?$xalloc@PAUcaster@CLightShadows@@@@@std@@QAEX$$QAPAUcaster@CLightShadows@@@Z PROC ; std::_Uninitialized_backout_al<xalloc<CLightShadows::caster *> >::_Emplace_back<CLightShadows::caster *>, COMDAT
; _this$ = ecx

; 1620 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _<_Vals_0>$[esp-4]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edx], eax

; 1621 :         ++_Last;

	add	DWORD PTR [ecx+4], 4

; 1622 :     }

	ret	4
??$_Emplace_back@PAUcaster@CLightShadows@@@?$_Uninitialized_backout_al@V?$xalloc@PAUcaster@CLightShadows@@@@@std@@QAEX$$QAPAUcaster@CLightShadows@@@Z ENDP ; std::_Uninitialized_backout_al<xalloc<CLightShadows::caster *> >::_Emplace_back<CLightShadows::caster *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Emplace_back@U_MatrixItem@R_dsgraph@@@?$_Uninitialized_backout_al@V?$xalloc@U_MatrixItem@R_dsgraph@@@@@std@@QAEX$$QAU_MatrixItem@R_dsgraph@@@Z
_TEXT	SEGMENT
_<_Vals_0>$ = 8						; size = 4
??$_Emplace_back@U_MatrixItem@R_dsgraph@@@?$_Uninitialized_backout_al@V?$xalloc@U_MatrixItem@R_dsgraph@@@@@std@@QAEX$$QAU_MatrixItem@R_dsgraph@@@Z PROC ; std::_Uninitialized_backout_al<xalloc<R_dsgraph::_MatrixItem> >::_Emplace_back<R_dsgraph::_MatrixItem>, COMDAT
; _this$ = ecx

; 1619 :     _CONSTEXPR20_DYNALLOC void _Emplace_back(_Types&&... _Vals) { // construct a new element at *_Last and increment

	mov	eax, ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	ecx, 19					; 00000013H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1619 :     _CONSTEXPR20_DYNALLOC void _Emplace_back(_Types&&... _Vals) { // construct a new element at *_Last and increment

	push	esi
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	esi, DWORD PTR _<_Vals_0>$[esp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1619 :     _CONSTEXPR20_DYNALLOC void _Emplace_back(_Types&&... _Vals) { // construct a new element at *_Last and increment

	push	edi
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	edi, DWORD PTR [eax+4]
	rep movsd
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1621 :         ++_Last;

	add	DWORD PTR [eax+4], 76			; 0000004cH
	pop	edi
	pop	esi

; 1622 :     }

	ret	4
??$_Emplace_back@U_MatrixItem@R_dsgraph@@@?$_Uninitialized_backout_al@V?$xalloc@U_MatrixItem@R_dsgraph@@@@@std@@QAEX$$QAU_MatrixItem@R_dsgraph@@@Z ENDP ; std::_Uninitialized_backout_al<xalloc<R_dsgraph::_MatrixItem> >::_Emplace_back<R_dsgraph::_MatrixItem>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Refancy@PAUcache_item@CLightShadows@@$0A@@std@@YAPAUcache_item@CLightShadows@@PAU12@@Z
_TEXT	SEGMENT
??$_Refancy@PAUcache_item@CLightShadows@@$0A@@std@@YAPAUcache_item@CLightShadows@@PAU12@@Z PROC ; std::_Refancy<CLightShadows::cache_item *,0>, COMDAT
; __Ptr$ = ecx

; 287  :     return _Ptr;

	mov	eax, ecx

; 288  : }

	ret	0
??$_Refancy@PAUcache_item@CLightShadows@@$0A@@std@@YAPAUcache_item@CLightShadows@@PAU12@@Z ENDP ; std::_Refancy<CLightShadows::cache_item *,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Uninitialized_move@PAUcache_item@CLightShadows@@V?$xalloc@Ucache_item@CLightShadows@@@@@std@@YAPAUcache_item@CLightShadows@@QAU12@0PAU12@AAV?$xalloc@Ucache_item@CLightShadows@@@@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Al$dead$ = 12						; size = 4
??$_Uninitialized_move@PAUcache_item@CLightShadows@@V?$xalloc@Ucache_item@CLightShadows@@@@@std@@YAPAUcache_item@CLightShadows@@QAU12@0PAU12@AAV?$xalloc@Ucache_item@CLightShadows@@@@@Z PROC ; std::_Uninitialized_move<CLightShadows::cache_item *,xalloc<CLightShadows::cache_item> >, COMDAT
; __First$ = ecx
; __Last$ = edx

; 1699 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

	push	ebx
	mov	ebx, edx
	mov	eax, ecx

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	edx, DWORD PTR __Dest$[esp]

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	eax, ebx
	je	SHORT $LN20@Uninitiali
	push	esi
	push	edi
	npad	1
$LL4@Uninitiali:
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	esi, eax
	mov	edi, edx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1621 :         ++_Last;

	add	eax, 44					; 0000002cH
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	ecx, 11					; 0000000bH
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1621 :         ++_Last;

	add	edx, 44					; 0000002cH
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	rep movsd
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	eax, ebx
	jne	SHORT $LL4@Uninitiali

; 1718 :         _Backout._Emplace_back(_STD move(*_UFirst));
; 1719 :     }
; 1720 : 
; 1721 :     return _Backout._Release();

	pop	edi
	pop	esi
$LN20@Uninitiali:

; 1722 : }

	mov	eax, edx
	pop	ebx
	ret	0
??$_Uninitialized_move@PAUcache_item@CLightShadows@@V?$xalloc@Ucache_item@CLightShadows@@@@@std@@YAPAUcache_item@CLightShadows@@QAU12@0PAU12@AAV?$xalloc@Ucache_item@CLightShadows@@@@@Z ENDP ; std::_Uninitialized_move<CLightShadows::cache_item *,xalloc<CLightShadows::cache_item> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_Get_unwrapped@ABQAUcache_item@CLightShadows@@@std@@YA?A_TABQAUcache_item@CLightShadows@@@Z
_TEXT	SEGMENT
??$_Get_unwrapped@ABQAUcache_item@CLightShadows@@@std@@YA?A_TABQAUcache_item@CLightShadows@@@Z PROC ; std::_Get_unwrapped<CLightShadows::cache_item * const &>, COMDAT
; __It$ = ecx

; 1275 :     // unwrap an iterator previously subjected to _Adl_verify_range or otherwise validated
; 1276 :     if constexpr (is_pointer_v<decay_t<_Iter>>) { // special-case pointers and arrays
; 1277 :         return _It + 0;

	mov	eax, DWORD PTR [ecx]

; 1278 :     } else if constexpr (_Unwrappable_v<_Iter>) {
; 1279 :         return static_cast<_Iter&&>(_It)._Unwrapped();
; 1280 :     } else {
; 1281 :         return static_cast<_Iter&&>(_It);
; 1282 :     }
; 1283 : }

	ret	0
??$_Get_unwrapped@ABQAUcache_item@CLightShadows@@@std@@YA?A_TABQAUcache_item@CLightShadows@@@Z ENDP ; std::_Get_unwrapped<CLightShadows::cache_item * const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
;	COMDAT ??$xr_alloc@Ucache_item@CLightShadows@@@@YAPAUcache_item@CLightShadows@@I@Z
_TEXT	SEGMENT
??$xr_alloc@Ucache_item@CLightShadows@@@@YAPAUcache_item@CLightShadows@@I@Z PROC ; xr_alloc<CLightShadows::cache_item>, COMDAT
; _count$ = ecx

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	imul	eax, ecx, 44
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
	ret	0
??$xr_alloc@Ucache_item@CLightShadows@@@@YAPAUcache_item@CLightShadows@@I@Z ENDP ; xr_alloc<CLightShadows::cache_item>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Destroy_in_place@PAUtess_tri@CLightShadows@@@std@@YAXAAPAUtess_tri@CLightShadows@@@Z
_TEXT	SEGMENT
??$_Destroy_in_place@PAUtess_tri@CLightShadows@@@std@@YAXAAPAUtess_tri@CLightShadows@@@Z PROC ; std::_Destroy_in_place<CLightShadows::tess_tri *>, COMDAT
; __Obj$dead$ = ecx

; 295  :     if constexpr (is_array_v<_Ty>) {
; 296  :         _Destroy_range(_Obj, _Obj + extent_v<_Ty>);
; 297  :     } else {
; 298  :         _Obj.~_Ty();
; 299  :     }
; 300  : }

	ret	0
??$_Destroy_in_place@PAUtess_tri@CLightShadows@@@std@@YAXAAPAUtess_tri@CLightShadows@@@Z ENDP ; std::_Destroy_in_place<CLightShadows::tess_tri *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Destroy_in_place@PAUshadow@CLightShadows@@@std@@YAXAAPAUshadow@CLightShadows@@@Z
_TEXT	SEGMENT
??$_Destroy_in_place@PAUshadow@CLightShadows@@@std@@YAXAAPAUshadow@CLightShadows@@@Z PROC ; std::_Destroy_in_place<CLightShadows::shadow *>, COMDAT
; __Obj$dead$ = ecx

; 295  :     if constexpr (is_array_v<_Ty>) {
; 296  :         _Destroy_range(_Obj, _Obj + extent_v<_Ty>);
; 297  :     } else {
; 298  :         _Obj.~_Ty();
; 299  :     }
; 300  : }

	ret	0
??$_Destroy_in_place@PAUshadow@CLightShadows@@@std@@YAXAAPAUshadow@CLightShadows@@@Z ENDP ; std::_Destroy_in_place<CLightShadows::shadow *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Release@?$_Uninitialized_backout_al@V?$xalloc@Ucache_item@CLightShadows@@@@@std@@QAEPAUcache_item@CLightShadows@@XZ
_TEXT	SEGMENT
?_Release@?$_Uninitialized_backout_al@V?$xalloc@Ucache_item@CLightShadows@@@@@std@@QAEPAUcache_item@CLightShadows@@XZ PROC ; std::_Uninitialized_backout_al<xalloc<CLightShadows::cache_item> >::_Release, COMDAT
; _this$ = ecx

; 1625 :         _First = _Last;

	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [ecx], eax

; 1626 :         return _Last;
; 1627 :     }

	ret	0
?_Release@?$_Uninitialized_backout_al@V?$xalloc@Ucache_item@CLightShadows@@@@@std@@QAEPAUcache_item@CLightShadows@@XZ ENDP ; std::_Uninitialized_backout_al<xalloc<CLightShadows::cache_item> >::_Release
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??1?$_Uninitialized_backout_al@V?$xalloc@Ucache_item@CLightShadows@@@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Uninitialized_backout_al@V?$xalloc@Ucache_item@CLightShadows@@@@@std@@QAE@XZ PROC ; std::_Uninitialized_backout_al<xalloc<CLightShadows::cache_item> >::~_Uninitialized_backout_al<xalloc<CLightShadows::cache_item> >, COMDAT
; _this$ = ecx

; 1615 :         _Destroy_range(_First, _Last, _Al);
; 1616 :     }

	ret	0
??1?$_Uninitialized_backout_al@V?$xalloc@Ucache_item@CLightShadows@@@@@std@@QAE@XZ ENDP ; std::_Uninitialized_backout_al<xalloc<CLightShadows::cache_item> >::~_Uninitialized_backout_al<xalloc<CLightShadows::cache_item> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??0?$_Uninitialized_backout_al@V?$xalloc@Ucache_item@CLightShadows@@@@@std@@QAE@PAUcache_item@CLightShadows@@AAV?$xalloc@Ucache_item@CLightShadows@@@@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Al_$ = 12						; size = 4
??0?$_Uninitialized_backout_al@V?$xalloc@Ucache_item@CLightShadows@@@@@std@@QAE@PAUcache_item@CLightShadows@@AAV?$xalloc@Ucache_item@CLightShadows@@@@@Z PROC ; std::_Uninitialized_backout_al<xalloc<CLightShadows::cache_item> >::_Uninitialized_backout_al<xalloc<CLightShadows::cache_item> >, COMDAT
; _this$ = ecx

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	eax, DWORD PTR __Dest$[esp-4]
	mov	DWORD PTR [ecx], eax
	mov	DWORD PTR [ecx+4], eax
	mov	eax, DWORD PTR __Al_$[esp-4]
	mov	DWORD PTR [ecx+8], eax
	mov	eax, ecx
	ret	8
??0?$_Uninitialized_backout_al@V?$xalloc@Ucache_item@CLightShadows@@@@@std@@QAE@PAUcache_item@CLightShadows@@AAV?$xalloc@Ucache_item@CLightShadows@@@@@Z ENDP ; std::_Uninitialized_backout_al<xalloc<CLightShadows::cache_item> >::_Uninitialized_backout_al<xalloc<CLightShadows::cache_item> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\type_traits
;	COMDAT ??$forward@PAUcaster@CLightShadows@@@std@@YA$$QAPAUcaster@CLightShadows@@AAPAU12@@Z
_TEXT	SEGMENT
??$forward@PAUcaster@CLightShadows@@@std@@YA$$QAPAUcaster@CLightShadows@@AAPAU12@@Z PROC ; std::forward<CLightShadows::caster *>, COMDAT
; __Arg$ = ecx

; 1386 :     return static_cast<_Ty&&>(_Arg);

	mov	eax, ecx

; 1387 : }

	ret	0
??$forward@PAUcaster@CLightShadows@@@std@@YA$$QAPAUcaster@CLightShadows@@AAPAU12@@Z ENDP ; std::forward<CLightShadows::caster *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$construct@PAUcaster@CLightShadows@@PAU12@@?$_Normal_allocator_traits@V?$xalloc@PAUcaster@CLightShadows@@@@@std@@SAXAAV?$xalloc@PAUcaster@CLightShadows@@@@PAPAUcaster@CLightShadows@@$$QAPAU34@@Z
_TEXT	SEGMENT
_<_Args_0>$ = 8						; size = 4
??$construct@PAUcaster@CLightShadows@@PAU12@@?$_Normal_allocator_traits@V?$xalloc@PAUcaster@CLightShadows@@@@@std@@SAXAAV?$xalloc@PAUcaster@CLightShadows@@@@PAPAUcaster@CLightShadows@@$$QAPAU34@@Z PROC ; std::_Normal_allocator_traits<xalloc<CLightShadows::caster *> >::construct<CLightShadows::caster *,CLightShadows::caster *>, COMDAT
; __Al$dead$ = ecx
; __Ptr$ = edx

; 565  :         if constexpr (_Uses_default_construct<_Alloc, _Ty*, _Types...>::value) {
; 566  :             (void) _Al; // TRANSITION, DevCom-1004719
; 567  : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 568  :             _STD construct_at(_Ptr, _STD forward<_Types>(_Args)...);
; 569  : #else // __cpp_lib_constexpr_dynamic_alloc
; 570  :             ::new (static_cast<void*>(_Ptr)) _Ty(_STD forward<_Types>(_Args)...);
; 571  : #endif // __cpp_lib_constexpr_dynamic_alloc
; 572  :         } else {
; 573  :             _Al.construct(_Ptr, _STD forward<_Types>(_Args)...);

	mov	eax, DWORD PTR _<_Args_0>$[esp-4]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edx], eax

; 574  :         }
; 575  :     }

	ret	0
??$construct@PAUcaster@CLightShadows@@PAU12@@?$_Normal_allocator_traits@V?$xalloc@PAUcaster@CLightShadows@@@@@std@@SAXAAV?$xalloc@PAUcaster@CLightShadows@@@@PAPAUcaster@CLightShadows@@$$QAPAU34@@Z ENDP ; std::_Normal_allocator_traits<xalloc<CLightShadows::caster *> >::construct<CLightShadows::caster *,CLightShadows::caster *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$construct@U_MatrixItem@R_dsgraph@@U12@@?$_Normal_allocator_traits@V?$xalloc@U_MatrixItem@R_dsgraph@@@@@std@@SAXAAV?$xalloc@U_MatrixItem@R_dsgraph@@@@PAU_MatrixItem@R_dsgraph@@$$QAU34@@Z
_TEXT	SEGMENT
_<_Args_0>$ = 8						; size = 4
??$construct@U_MatrixItem@R_dsgraph@@U12@@?$_Normal_allocator_traits@V?$xalloc@U_MatrixItem@R_dsgraph@@@@@std@@SAXAAV?$xalloc@U_MatrixItem@R_dsgraph@@@@PAU_MatrixItem@R_dsgraph@@$$QAU34@@Z PROC ; std::_Normal_allocator_traits<xalloc<R_dsgraph::_MatrixItem> >::construct<R_dsgraph::_MatrixItem,R_dsgraph::_MatrixItem>, COMDAT
; __Al$dead$ = ecx
; __Ptr$ = edx

; 564  :     static _CONSTEXPR20_DYNALLOC void construct(_Alloc& _Al, _Ty* _Ptr, _Types&&... _Args) {

	push	esi
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	esi, DWORD PTR _<_Args_0>$[esp]
	mov	ecx, 19					; 00000013H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 564  :     static _CONSTEXPR20_DYNALLOC void construct(_Alloc& _Al, _Ty* _Ptr, _Types&&... _Args) {

	push	edi
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	edi, edx
	rep movsd
	pop	edi
	pop	esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 575  :     }

	ret	0
??$construct@U_MatrixItem@R_dsgraph@@U12@@?$_Normal_allocator_traits@V?$xalloc@U_MatrixItem@R_dsgraph@@@@@std@@SAXAAV?$xalloc@U_MatrixItem@R_dsgraph@@@@PAU_MatrixItem@R_dsgraph@@$$QAU34@@Z ENDP ; std::_Normal_allocator_traits<xalloc<R_dsgraph::_MatrixItem> >::construct<R_dsgraph::_MatrixItem,R_dsgraph::_MatrixItem>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Emplace_back@Ucache_item@CLightShadows@@@?$_Uninitialized_backout_al@V?$xalloc@Ucache_item@CLightShadows@@@@@std@@QAEX$$QAUcache_item@CLightShadows@@@Z
_TEXT	SEGMENT
_<_Vals_0>$ = 8						; size = 4
??$_Emplace_back@Ucache_item@CLightShadows@@@?$_Uninitialized_backout_al@V?$xalloc@Ucache_item@CLightShadows@@@@@std@@QAEX$$QAUcache_item@CLightShadows@@@Z PROC ; std::_Uninitialized_backout_al<xalloc<CLightShadows::cache_item> >::_Emplace_back<CLightShadows::cache_item>, COMDAT
; _this$ = ecx

; 1619 :     _CONSTEXPR20_DYNALLOC void _Emplace_back(_Types&&... _Vals) { // construct a new element at *_Last and increment

	mov	eax, ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	ecx, 11					; 0000000bH
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1619 :     _CONSTEXPR20_DYNALLOC void _Emplace_back(_Types&&... _Vals) { // construct a new element at *_Last and increment

	push	esi
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	esi, DWORD PTR _<_Vals_0>$[esp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1619 :     _CONSTEXPR20_DYNALLOC void _Emplace_back(_Types&&... _Vals) { // construct a new element at *_Last and increment

	push	edi
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	edi, DWORD PTR [eax+4]
	rep movsd
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1621 :         ++_Last;

	add	DWORD PTR [eax+4], 44			; 0000002cH
	pop	edi
	pop	esi

; 1622 :     }

	ret	4
??$_Emplace_back@Ucache_item@CLightShadows@@@?$_Uninitialized_backout_al@V?$xalloc@Ucache_item@CLightShadows@@@@@std@@QAEX$$QAUcache_item@CLightShadows@@@Z ENDP ; std::_Uninitialized_backout_al<xalloc<CLightShadows::cache_item> >::_Emplace_back<CLightShadows::cache_item>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\lightShadows.h
;	COMDAT ??0cache_item@CLightShadows@@QAE@XZ
_TEXT	SEGMENT
??0cache_item@CLightShadows@@QAE@XZ PROC		; CLightShadows::cache_item::cache_item, COMDAT
; _this$ = ecx

; 48   : 		cache_item()		{ O=0; L=0; tris=0; }

	mov	DWORD PTR [ecx], 0
	mov	eax, ecx
	mov	DWORD PTR [ecx+16], 0
	mov	DWORD PTR [ecx+36], 0
	ret	0
??0cache_item@CLightShadows@@QAE@XZ ENDP		; CLightShadows::cache_item::cache_item
_TEXT	ENDS
END
