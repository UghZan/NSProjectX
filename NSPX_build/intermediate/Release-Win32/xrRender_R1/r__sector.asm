; Listing generated by Microsoft (R) Optimizing Compiler Version 19.29.30146.0 

	TITLE	i:\vitalya\mine\nsprojectx\nspx_build\intermediate\release-win32\xrrender_r1\r__sector.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	??_C@_0P@KFFENJEF@CPortal?3?3Setup@		; `string'
PUBLIC	??_C@_0DJ@FDLNFKJF@I?3?2Vitalya?2mine?2NSProjectX?2laye@ ; `string'
PUBLIC	??_C@_0BI@JPKPOFID@Invalid?5portal?5detected@	; `string'
PUBLIC	??_C@_04KDBHFCMN@_cnt@				; `string'
PUBLIC	??_C@_0O@JCOHLFIM@CSector?3?3load@		; `string'
PUBLIC	??_C@_0M@PEPFIJMN@0?$DN?$DN?$CIsize?$CG1?$CJ@	; `string'
PUBLIC	??_C@_07MIJPMMAB@size?$DN?$DN4@			; `string'
PUBLIC	??_R2CPortal@@8					; CPortal::`RTTI Base Class Array'
PUBLIC	??_R2IRender_Portal@@8				; IRender_Portal::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CPortal@@8			; CPortal::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@IRender_Portal@@8			; IRender_Portal::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R3IRender_Portal@@8				; IRender_Portal::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R0?AVIRender_Portal@@@8			; IRender_Portal `RTTI Type Descriptor'
PUBLIC	??_R3CPortal@@8					; CPortal::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R0?AVCPortal@@@8				; CPortal `RTTI Type Descriptor'
PUBLIC	??_R4CPortal@@6B@				; CPortal::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCSector@@@8				; CSector `RTTI Type Descriptor'
PUBLIC	??_R1A@?0A@EA@CSector@@8			; CSector::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVIRender_Sector@@@8			; IRender_Sector `RTTI Type Descriptor'
PUBLIC	??_R2IRender_Sector@@8				; IRender_Sector::`RTTI Base Class Array'
PUBLIC	??_R3IRender_Sector@@8				; IRender_Sector::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R1A@?0A@EA@IRender_Sector@@8			; IRender_Sector::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R2CSector@@8					; CSector::`RTTI Base Class Array'
PUBLIC	??_R3CSector@@8					; CSector::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R4CSector@@6B@				; CSector::`RTTI Complete Object Locator'
PUBLIC	??_7CSector@@6B@				; CSector::`vftable'
PUBLIC	??_7CPortal@@6B@				; CPortal::`vftable'
EXTRN	__imp_??0IRender_Portal@@QAE@XZ:PROC
EXTRN	__imp_?g_dedicated_server@@3_NA:BYTE
EXTRN	__imp_?CreateFromPortal@CFrustum@@QAEXPAV?$svector@U?$_vector3@M@@$0DA@@@AAU?$_vector3@M@@1AAU?$_matrix@M@@@Z:PROC
EXTRN	__imp_??_7IRender_Sector@@6B@:QWORD
EXTRN	__imp_??1IRender_Sector@@UAE@XZ:PROC
EXTRN	__imp_?m24r@FPU@@YAXXZ:PROC
EXTRN	__imp_?m64r@FPU@@YAXXZ:PROC
EXTRN	__imp_??_7IRender_Portal@@6B@:QWORD
EXTRN	__imp_??1IRender_Portal@@UAE@XZ:PROC
;	COMDAT ?ignore_always@?O@??load@CSector@@QAEXAAVIReader@@@Z@4_NA
_BSS	SEGMENT
?ignore_always@?O@??load@CSector@@QAEXAAVIReader@@@Z@4_NA DB 01H DUP (?) ; `CSector::load'::`14'::ignore_always
_BSS	ENDS
;	COMDAT ?ignore_always@?3??load@CSector@@QAEXAAVIReader@@@Z@4_NA
_BSS	SEGMENT
?ignore_always@?3??load@CSector@@QAEXAAVIReader@@@Z@4_NA DB 01H DUP (?) ; `CSector::load'::`4'::ignore_always
_BSS	ENDS
;	COMDAT ?ignore_always@?9??Setup@CPortal@@QAEXPAU?$_vector3@M@@HPAVCSector@@1@Z@4_NA
_BSS	SEGMENT
?ignore_always@?9??Setup@CPortal@@QAEXPAU?$_vector3@M@@HPAVCSector@@1@Z@4_NA DB 01H DUP (?) ; `CPortal::Setup'::`10'::ignore_always
_BSS	ENDS
;	COMDAT ??_7CPortal@@6B@
CONST	SEGMENT
??_7CPortal@@6B@ DD FLAT:??_R4CPortal@@6B@		; CPortal::`vftable'
	DD	FLAT:??_ECPortal@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_7CSector@@6B@
CONST	SEGMENT
??_7CSector@@6B@ DD FLAT:??_R4CSector@@6B@		; CSector::`vftable'
	DD	FLAT:??_ECSector@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_R4CSector@@6B@
rdata$r	SEGMENT
??_R4CSector@@6B@ DD 00H				; CSector::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCSector@@@8
	DD	FLAT:??_R3CSector@@8
rdata$r	ENDS
;	COMDAT ??_R3CSector@@8
rdata$r	SEGMENT
??_R3CSector@@8 DD 00H					; CSector::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2CSector@@8
rdata$r	ENDS
;	COMDAT ??_R2CSector@@8
rdata$r	SEGMENT
??_R2CSector@@8 DD FLAT:??_R1A@?0A@EA@CSector@@8	; CSector::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@IRender_Sector@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@IRender_Sector@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@IRender_Sector@@8 DD FLAT:??_R0?AVIRender_Sector@@@8 ; IRender_Sector::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3IRender_Sector@@8
rdata$r	ENDS
;	COMDAT ??_R3IRender_Sector@@8
rdata$r	SEGMENT
??_R3IRender_Sector@@8 DD 00H				; IRender_Sector::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2IRender_Sector@@8
rdata$r	ENDS
;	COMDAT ??_R2IRender_Sector@@8
rdata$r	SEGMENT
??_R2IRender_Sector@@8 DD FLAT:??_R1A@?0A@EA@IRender_Sector@@8 ; IRender_Sector::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R0?AVIRender_Sector@@@8
data$rs	SEGMENT
??_R0?AVIRender_Sector@@@8 DD FLAT:??_7type_info@@6B@	; IRender_Sector `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVIRender_Sector@@', 00H
data$rs	ENDS
;	COMDAT ??_R1A@?0A@EA@CSector@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CSector@@8 DD FLAT:??_R0?AVCSector@@@8	; CSector::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CSector@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCSector@@@8
data$rs	SEGMENT
??_R0?AVCSector@@@8 DD FLAT:??_7type_info@@6B@		; CSector `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCSector@@', 00H
data$rs	ENDS
;	COMDAT ??_R4CPortal@@6B@
rdata$r	SEGMENT
??_R4CPortal@@6B@ DD 00H				; CPortal::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCPortal@@@8
	DD	FLAT:??_R3CPortal@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCPortal@@@8
data$rs	SEGMENT
??_R0?AVCPortal@@@8 DD FLAT:??_7type_info@@6B@		; CPortal `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCPortal@@', 00H
data$rs	ENDS
;	COMDAT ??_R3CPortal@@8
rdata$r	SEGMENT
??_R3CPortal@@8 DD 00H					; CPortal::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2CPortal@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVIRender_Portal@@@8
data$rs	SEGMENT
??_R0?AVIRender_Portal@@@8 DD FLAT:??_7type_info@@6B@	; IRender_Portal `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVIRender_Portal@@', 00H
data$rs	ENDS
;	COMDAT ??_R3IRender_Portal@@8
rdata$r	SEGMENT
??_R3IRender_Portal@@8 DD 00H				; IRender_Portal::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2IRender_Portal@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@IRender_Portal@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@IRender_Portal@@8 DD FLAT:??_R0?AVIRender_Portal@@@8 ; IRender_Portal::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3IRender_Portal@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@CPortal@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CPortal@@8 DD FLAT:??_R0?AVCPortal@@@8	; CPortal::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CPortal@@8
rdata$r	ENDS
;	COMDAT ??_R2IRender_Portal@@8
rdata$r	SEGMENT
??_R2IRender_Portal@@8 DD FLAT:??_R1A@?0A@EA@IRender_Portal@@8 ; IRender_Portal::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R2CPortal@@8
rdata$r	SEGMENT
??_R2CPortal@@8 DD FLAT:??_R1A@?0A@EA@CPortal@@8	; CPortal::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@IRender_Portal@@8
rdata$r	ENDS
;	COMDAT ??_C@_07MIJPMMAB@size?$DN?$DN4@
CONST	SEGMENT
??_C@_07MIJPMMAB@size?$DN?$DN4@ DB 'size==4', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@PEPFIJMN@0?$DN?$DN?$CIsize?$CG1?$CJ@
CONST	SEGMENT
??_C@_0M@PEPFIJMN@0?$DN?$DN?$CIsize?$CG1?$CJ@ DB '0==(size&1)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@JCOHLFIM@CSector?3?3load@
CONST	SEGMENT
??_C@_0O@JCOHLFIM@CSector?3?3load@ DB 'CSector::load', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04KDBHFCMN@_cnt@
CONST	SEGMENT
??_C@_04KDBHFCMN@_cnt@ DB '_cnt', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@JPKPOFID@Invalid?5portal?5detected@
CONST	SEGMENT
??_C@_0BI@JPKPOFID@Invalid?5portal?5detected@ DB 'Invalid portal detected'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0DJ@FDLNFKJF@I?3?2Vitalya?2mine?2NSProjectX?2laye@
CONST	SEGMENT
??_C@_0DJ@FDLNFKJF@I?3?2Vitalya?2mine?2NSProjectX?2laye@ DB 'I:\Vitalya\m'
	DB	'ine\NSProjectX\layers\xrRender\r__sector.cpp', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@KFFENJEF@CPortal?3?3Setup@
CONST	SEGMENT
??_C@_0P@KFFENJEF@CPortal?3?3Setup@ DB 'CPortal::Setup', 00H ; `string'
PUBLIC	??_GCSector@@UAEPAXI@Z				; CSector::`scalar deleting destructor'
PUBLIC	??1?$xr_vector@PAVCPortal@@V?$xalloc@PAVCPortal@@@@@@QAE@XZ ; xr_vector<CPortal *,xalloc<CPortal *> >::~xr_vector<CPortal *,xalloc<CPortal *> >
PUBLIC	??1?$vector@PAVCPortal@@V?$xalloc@PAVCPortal@@@@@std@@QAE@XZ ; std::vector<CPortal *,xalloc<CPortal *> >::~vector<CPortal *,xalloc<CPortal *> >
PUBLIC	?_Tidy@?$vector@PAVCPortal@@V?$xalloc@PAVCPortal@@@@@std@@AAEXXZ ; std::vector<CPortal *,xalloc<CPortal *> >::_Tidy
PUBLIC	?_Getal@?$vector@PAVCPortal@@V?$xalloc@PAVCPortal@@@@@std@@AAEAAV?$xalloc@PAVCPortal@@@@XZ ; std::vector<CPortal *,xalloc<CPortal *> >::_Getal
PUBLIC	?_Get_first@?$_Compressed_pair@V?$xalloc@PAVCPortal@@@@V?$_Vector_val@U?$_Simple_types@PAVCPortal@@@std@@@std@@$00@std@@QAEAAV?$xalloc@PAVCPortal@@@@XZ ; std::_Compressed_pair<xalloc<CPortal *>,std::_Vector_val<std::_Simple_types<CPortal *> >,1>::_Get_first
PUBLIC	?deallocate@?$xalloc@PAVCPortal@@@@QBEXPAPAVCPortal@@I@Z ; xalloc<CPortal *>::deallocate
PUBLIC	??$xr_free@PAVCPortal@@@@YAXAAPAPAVCPortal@@@Z	; xr_free<CPortal *>
PUBLIC	?_Destroy@?$vector@PAVCPortal@@V?$xalloc@PAVCPortal@@@@@std@@AAEXPAPAVCPortal@@0@Z ; std::vector<CPortal *,xalloc<CPortal *> >::_Destroy
PUBLIC	??$_Destroy_range@V?$xalloc@PAVCPortal@@@@@std@@YAXPAPAVCPortal@@QAPAV1@AAV?$xalloc@PAVCPortal@@@@@Z ; std::_Destroy_range<xalloc<CPortal *> >
PUBLIC	??$_Unfancy@PAVCPortal@@@std@@YAPAPAVCPortal@@PAPAV1@@Z ; std::_Unfancy<CPortal *>
PUBLIC	??$destroy@PAVCPortal@@@?$_Normal_allocator_traits@V?$xalloc@PAVCPortal@@@@@std@@SAXAAV?$xalloc@PAVCPortal@@@@PAPAVCPortal@@@Z ; std::_Normal_allocator_traits<xalloc<CPortal *> >::destroy<CPortal *>
PUBLIC	?destroy@?$xalloc@PAVCPortal@@@@QAEXPAPAVCPortal@@@Z ; xalloc<CPortal *>::destroy
PUBLIC	??$_Destroy_in_place@PAPAVCPortal@@@std@@YAXAAPAPAVCPortal@@@Z ; std::_Destroy_in_place<CPortal * *>
PUBLIC	??1?$xr_vector@VCFrustum@@V?$xalloc@VCFrustum@@@@@@QAE@XZ ; xr_vector<CFrustum,xalloc<CFrustum> >::~xr_vector<CFrustum,xalloc<CFrustum> >
PUBLIC	??1?$vector@VCFrustum@@V?$xalloc@VCFrustum@@@@@std@@QAE@XZ ; std::vector<CFrustum,xalloc<CFrustum> >::~vector<CFrustum,xalloc<CFrustum> >
PUBLIC	?_Tidy@?$vector@VCFrustum@@V?$xalloc@VCFrustum@@@@@std@@AAEXXZ ; std::vector<CFrustum,xalloc<CFrustum> >::_Tidy
PUBLIC	?_Getal@?$vector@VCFrustum@@V?$xalloc@VCFrustum@@@@@std@@AAEAAV?$xalloc@VCFrustum@@@@XZ ; std::vector<CFrustum,xalloc<CFrustum> >::_Getal
PUBLIC	?_Get_first@?$_Compressed_pair@V?$xalloc@VCFrustum@@@@V?$_Vector_val@U?$_Simple_types@VCFrustum@@@std@@@std@@$00@std@@QAEAAV?$xalloc@VCFrustum@@@@XZ ; std::_Compressed_pair<xalloc<CFrustum>,std::_Vector_val<std::_Simple_types<CFrustum> >,1>::_Get_first
PUBLIC	?deallocate@?$xalloc@VCFrustum@@@@QBEXPAVCFrustum@@I@Z ; xalloc<CFrustum>::deallocate
PUBLIC	??$xr_free@VCFrustum@@@@YAXAAPAVCFrustum@@@Z	; xr_free<CFrustum>
PUBLIC	?_Destroy@?$vector@VCFrustum@@V?$xalloc@VCFrustum@@@@@std@@AAEXPAVCFrustum@@0@Z ; std::vector<CFrustum,xalloc<CFrustum> >::_Destroy
PUBLIC	??$_Destroy_range@V?$xalloc@VCFrustum@@@@@std@@YAXPAVCFrustum@@QAV1@AAV?$xalloc@VCFrustum@@@@@Z ; std::_Destroy_range<xalloc<CFrustum> >
PUBLIC	??$_Unfancy@VCFrustum@@@std@@YAPAVCFrustum@@PAV1@@Z ; std::_Unfancy<CFrustum>
PUBLIC	??$destroy@VCFrustum@@@?$_Normal_allocator_traits@V?$xalloc@VCFrustum@@@@@std@@SAXAAV?$xalloc@VCFrustum@@@@PAVCFrustum@@@Z ; std::_Normal_allocator_traits<xalloc<CFrustum> >::destroy<CFrustum>
PUBLIC	?destroy@?$xalloc@VCFrustum@@@@QAEXPAVCFrustum@@@Z ; xalloc<CFrustum>::destroy
PUBLIC	??$_Destroy_in_place@PAVCFrustum@@@std@@YAXAAPAVCFrustum@@@Z ; std::_Destroy_in_place<CFrustum *>
PUBLIC	??1?$xr_vector@U_scissor@@V?$xalloc@U_scissor@@@@@@QAE@XZ ; xr_vector<_scissor,xalloc<_scissor> >::~xr_vector<_scissor,xalloc<_scissor> >
PUBLIC	??1?$vector@U_scissor@@V?$xalloc@U_scissor@@@@@std@@QAE@XZ ; std::vector<_scissor,xalloc<_scissor> >::~vector<_scissor,xalloc<_scissor> >
PUBLIC	?_Tidy@?$vector@U_scissor@@V?$xalloc@U_scissor@@@@@std@@AAEXXZ ; std::vector<_scissor,xalloc<_scissor> >::_Tidy
PUBLIC	?_Getal@?$vector@U_scissor@@V?$xalloc@U_scissor@@@@@std@@AAEAAV?$xalloc@U_scissor@@@@XZ ; std::vector<_scissor,xalloc<_scissor> >::_Getal
PUBLIC	?_Get_first@?$_Compressed_pair@V?$xalloc@U_scissor@@@@V?$_Vector_val@U?$_Simple_types@U_scissor@@@std@@@std@@$00@std@@QAEAAV?$xalloc@U_scissor@@@@XZ ; std::_Compressed_pair<xalloc<_scissor>,std::_Vector_val<std::_Simple_types<_scissor> >,1>::_Get_first
PUBLIC	?deallocate@?$xalloc@U_scissor@@@@QBEXPAU_scissor@@I@Z ; xalloc<_scissor>::deallocate
PUBLIC	??$xr_free@U_scissor@@@@YAXAAPAU_scissor@@@Z	; xr_free<_scissor>
PUBLIC	?_Destroy@?$vector@U_scissor@@V?$xalloc@U_scissor@@@@@std@@AAEXPAU_scissor@@0@Z ; std::vector<_scissor,xalloc<_scissor> >::_Destroy
PUBLIC	??$_Destroy_range@V?$xalloc@U_scissor@@@@@std@@YAXPAU_scissor@@QAU1@AAV?$xalloc@U_scissor@@@@@Z ; std::_Destroy_range<xalloc<_scissor> >
PUBLIC	??$_Unfancy@U_scissor@@@std@@YAPAU_scissor@@PAU1@@Z ; std::_Unfancy<_scissor>
PUBLIC	??$destroy@U_scissor@@@?$_Normal_allocator_traits@V?$xalloc@U_scissor@@@@@std@@SAXAAV?$xalloc@U_scissor@@@@PAU_scissor@@@Z ; std::_Normal_allocator_traits<xalloc<_scissor> >::destroy<_scissor>
PUBLIC	?destroy@?$xalloc@U_scissor@@@@QAEXPAU_scissor@@@Z ; xalloc<_scissor>::destroy
PUBLIC	??$_Destroy_in_place@PAU_scissor@@@std@@YAXAAPAU_scissor@@@Z ; std::_Destroy_in_place<_scissor *>
PUBLIC	?getSector@CPortal@@QAEPAVCSector@@PAV2@@Z	; CPortal::getSector
PUBLIC	?getSectorBack@CPortal@@QAEPAVCSector@@ABU?$_vector3@M@@@Z ; CPortal::getSectorBack
PUBLIC	?getPoly@CPortal@@QAEAAV?$svector@U?$_vector3@M@@$07@@XZ ; CPortal::getPoly
PUBLIC	?assign@?$svector@U?$_vector3@M@@$0DA@@@QAEXPAU?$_vector3@M@@H@Z ; svector<_vector3<float>,48>::assign
PUBLIC	??$_Destroy_in_place@PAPAVIRender_Sector@@@std@@YAXAAPAPAVIRender_Sector@@@Z ; std::_Destroy_in_place<IRender_Sector * *>
PUBLIC	??$construct@VCFrustum@@V1@@?$_Normal_allocator_traits@V?$xalloc@VCFrustum@@@@@std@@SAXAAV?$xalloc@VCFrustum@@@@PAVCFrustum@@$$QAV3@@Z ; std::_Normal_allocator_traits<xalloc<CFrustum> >::construct<CFrustum,CFrustum>
PUBLIC	??$forward@VCFrustum@@@std@@YA$$QAVCFrustum@@AAV1@@Z ; std::forward<CFrustum>
PUBLIC	??$construct@U_scissor@@U1@@?$_Normal_allocator_traits@V?$xalloc@U_scissor@@@@@std@@SAXAAV?$xalloc@U_scissor@@@@PAU_scissor@@$$QAU3@@Z ; std::_Normal_allocator_traits<xalloc<_scissor> >::construct<_scissor,_scissor>
PUBLIC	??$forward@U_scissor@@@std@@YA$$QAU_scissor@@AAU1@@Z ; std::forward<_scissor>
PUBLIC	?destroy@?$xalloc@PAVIRender_Sector@@@@QAEXPAPAVIRender_Sector@@@Z ; xalloc<IRender_Sector *>::destroy
PUBLIC	??$_Emplace_back@VCFrustum@@@?$_Uninitialized_backout_al@V?$xalloc@VCFrustum@@@@@std@@QAEX$$QAVCFrustum@@@Z ; std::_Uninitialized_backout_al<xalloc<CFrustum> >::_Emplace_back<CFrustum>
PUBLIC	??$move@AAVCFrustum@@@std@@YA$$QAVCFrustum@@AAV1@@Z ; std::move<CFrustum &>
PUBLIC	??$_Emplace_back@U_scissor@@@?$_Uninitialized_backout_al@V?$xalloc@U_scissor@@@@@std@@QAEX$$QAU_scissor@@@Z ; std::_Uninitialized_backout_al<xalloc<_scissor> >::_Emplace_back<_scissor>
PUBLIC	??$move@AAU_scissor@@@std@@YA$$QAU_scissor@@AAU1@@Z ; std::move<_scissor &>
PUBLIC	??$_Emplace_back@PAVIRender_Sector@@@?$_Uninitialized_backout_al@V?$xalloc@PAVIRender_Sector@@@@@std@@QAEX$$QAPAVIRender_Sector@@@Z ; std::_Uninitialized_backout_al<xalloc<IRender_Sector *> >::_Emplace_back<IRender_Sector *>
PUBLIC	??$destroy@PAVIRender_Sector@@@?$_Normal_allocator_traits@V?$xalloc@PAVIRender_Sector@@@@@std@@SAXAAV?$xalloc@PAVIRender_Sector@@@@PAPAVIRender_Sector@@@Z ; std::_Normal_allocator_traits<xalloc<IRender_Sector *> >::destroy<IRender_Sector *>
PUBLIC	??$construct@PAVCPortal@@PAV1@@?$_Normal_allocator_traits@V?$xalloc@PAVCPortal@@@@@std@@SAXAAV?$xalloc@PAVCPortal@@@@PAPAVCPortal@@$$QAPAV3@@Z ; std::_Normal_allocator_traits<xalloc<CPortal *> >::construct<CPortal *,CPortal *>
PUBLIC	??$forward@PAVCPortal@@@std@@YA$$QAPAVCPortal@@AAPAV1@@Z ; std::forward<CPortal *>
PUBLIC	??0?$_Uninitialized_backout_al@V?$xalloc@PAVIRender_Sector@@@@@std@@QAE@PAPAVIRender_Sector@@AAV?$xalloc@PAVIRender_Sector@@@@@Z ; std::_Uninitialized_backout_al<xalloc<IRender_Sector *> >::_Uninitialized_backout_al<xalloc<IRender_Sector *> >
PUBLIC	??1?$_Uninitialized_backout_al@V?$xalloc@PAVIRender_Sector@@@@@std@@QAE@XZ ; std::_Uninitialized_backout_al<xalloc<IRender_Sector *> >::~_Uninitialized_backout_al<xalloc<IRender_Sector *> >
PUBLIC	?_Release@?$_Uninitialized_backout_al@V?$xalloc@PAVIRender_Sector@@@@@std@@QAEPAPAVIRender_Sector@@XZ ; std::_Uninitialized_backout_al<xalloc<IRender_Sector *> >::_Release
PUBLIC	??0?$_Uninitialized_backout_al@V?$xalloc@U_scissor@@@@@std@@QAE@PAU_scissor@@AAV?$xalloc@U_scissor@@@@@Z ; std::_Uninitialized_backout_al<xalloc<_scissor> >::_Uninitialized_backout_al<xalloc<_scissor> >
PUBLIC	??1?$_Uninitialized_backout_al@V?$xalloc@U_scissor@@@@@std@@QAE@XZ ; std::_Uninitialized_backout_al<xalloc<_scissor> >::~_Uninitialized_backout_al<xalloc<_scissor> >
PUBLIC	?_Release@?$_Uninitialized_backout_al@V?$xalloc@U_scissor@@@@@std@@QAEPAU_scissor@@XZ ; std::_Uninitialized_backout_al<xalloc<_scissor> >::_Release
PUBLIC	??0?$_Uninitialized_backout_al@V?$xalloc@VCFrustum@@@@@std@@QAE@PAVCFrustum@@AAV?$xalloc@VCFrustum@@@@@Z ; std::_Uninitialized_backout_al<xalloc<CFrustum> >::_Uninitialized_backout_al<xalloc<CFrustum> >
PUBLIC	??1?$_Uninitialized_backout_al@V?$xalloc@VCFrustum@@@@@std@@QAE@XZ ; std::_Uninitialized_backout_al<xalloc<CFrustum> >::~_Uninitialized_backout_al<xalloc<CFrustum> >
PUBLIC	?_Release@?$_Uninitialized_backout_al@V?$xalloc@VCFrustum@@@@@std@@QAEPAVCFrustum@@XZ ; std::_Uninitialized_backout_al<xalloc<CFrustum> >::_Release
PUBLIC	??$xr_alloc@VCFrustum@@@@YAPAVCFrustum@@I@Z	; xr_alloc<CFrustum>
PUBLIC	??$_Get_unwrapped@ABQAVCFrustum@@@std@@YA?A_TABQAVCFrustum@@@Z ; std::_Get_unwrapped<CFrustum * const &>
PUBLIC	??$_Uninitialized_move@PAVCFrustum@@V?$xalloc@VCFrustum@@@@@std@@YAPAVCFrustum@@QAV1@0PAV1@AAV?$xalloc@VCFrustum@@@@@Z ; std::_Uninitialized_move<CFrustum *,xalloc<CFrustum> >
PUBLIC	??$xr_alloc@U_scissor@@@@YAPAU_scissor@@I@Z	; xr_alloc<_scissor>
PUBLIC	??$_Get_unwrapped@ABQAU_scissor@@@std@@YA?A_TABQAU_scissor@@@Z ; std::_Get_unwrapped<_scissor * const &>
PUBLIC	??$_Uninitialized_move@PAU_scissor@@V?$xalloc@U_scissor@@@@@std@@YAPAU_scissor@@QAU1@0PAU1@AAV?$xalloc@U_scissor@@@@@Z ; std::_Uninitialized_move<_scissor *,xalloc<_scissor> >
PUBLIC	??$xr_alloc@PAVIRender_Sector@@@@YAPAPAVIRender_Sector@@I@Z ; xr_alloc<IRender_Sector *>
PUBLIC	??$xr_free@PAVIRender_Sector@@@@YAXAAPAPAVIRender_Sector@@@Z ; xr_free<IRender_Sector *>
PUBLIC	??$_Get_unwrapped@ABQAPAVIRender_Sector@@@std@@YA?A_TABQAPAVIRender_Sector@@@Z ; std::_Get_unwrapped<IRender_Sector * * const &>
PUBLIC	??$_Uninitialized_move@PAPAVIRender_Sector@@V?$xalloc@PAVIRender_Sector@@@@@std@@YAPAPAVIRender_Sector@@QAPAV1@0PAPAV1@AAV?$xalloc@PAVIRender_Sector@@@@@Z ; std::_Uninitialized_move<IRender_Sector * *,xalloc<IRender_Sector *> >
PUBLIC	??$_Destroy_range@V?$xalloc@PAVIRender_Sector@@@@@std@@YAXPAPAVIRender_Sector@@QAPAV1@AAV?$xalloc@PAVIRender_Sector@@@@@Z ; std::_Destroy_range<xalloc<IRender_Sector *> >
PUBLIC	??$_Emplace_back@PAVCPortal@@@?$_Uninitialized_backout_al@V?$xalloc@PAVCPortal@@@@@std@@QAEX$$QAPAVCPortal@@@Z ; std::_Uninitialized_backout_al<xalloc<CPortal *> >::_Emplace_back<CPortal *>
PUBLIC	??$move@AAPAVCPortal@@@std@@YA$$QAPAVCPortal@@AAPAV1@@Z ; std::move<CPortal * &>
PUBLIC	?max_size@?$xalloc@VCFrustum@@@@QBEIXZ		; xalloc<CFrustum>::max_size
PUBLIC	?_Get_first@?$_Compressed_pair@V?$xalloc@VCFrustum@@@@V?$_Vector_val@U?$_Simple_types@VCFrustum@@@std@@@std@@$00@std@@QBEABV?$xalloc@VCFrustum@@@@XZ ; std::_Compressed_pair<xalloc<CFrustum>,std::_Vector_val<std::_Simple_types<CFrustum> >,1>::_Get_first
PUBLIC	?max_size@?$xalloc@U_scissor@@@@QBEIXZ		; xalloc<_scissor>::max_size
PUBLIC	?_Get_first@?$_Compressed_pair@V?$xalloc@U_scissor@@@@V?$_Vector_val@U?$_Simple_types@U_scissor@@@std@@@std@@$00@std@@QBEABV?$xalloc@U_scissor@@@@XZ ; std::_Compressed_pair<xalloc<_scissor>,std::_Vector_val<std::_Simple_types<_scissor> >,1>::_Get_first
PUBLIC	?max_size@?$xalloc@PAVIRender_Sector@@@@QBEIXZ	; xalloc<IRender_Sector *>::max_size
PUBLIC	?_Get_first@?$_Compressed_pair@V?$xalloc@PAVIRender_Sector@@@@V?$_Vector_val@U?$_Simple_types@PAVIRender_Sector@@@std@@@std@@$00@std@@QBEABV?$xalloc@PAVIRender_Sector@@@@XZ ; std::_Compressed_pair<xalloc<IRender_Sector *>,std::_Vector_val<std::_Simple_types<IRender_Sector *> >,1>::_Get_first
PUBLIC	?max_size@?$_Normal_allocator_traits@V?$xalloc@VCFrustum@@@@@std@@SAIABV?$xalloc@VCFrustum@@@@@Z ; std::_Normal_allocator_traits<xalloc<CFrustum> >::max_size
PUBLIC	?capacity@?$vector@VCFrustum@@V?$xalloc@VCFrustum@@@@@std@@QBEIXZ ; std::vector<CFrustum,xalloc<CFrustum> >::capacity
PUBLIC	?_Umove_if_noexcept1@?$vector@VCFrustum@@V?$xalloc@VCFrustum@@@@@std@@AAEXPAVCFrustum@@00U?$integral_constant@_N$00@2@@Z ; std::vector<CFrustum,xalloc<CFrustum> >::_Umove_if_noexcept1
PUBLIC	?_Getal@?$vector@VCFrustum@@V?$xalloc@VCFrustum@@@@@std@@ABEABV?$xalloc@VCFrustum@@@@XZ ; std::vector<CFrustum,xalloc<CFrustum> >::_Getal
PUBLIC	?max_size@?$_Normal_allocator_traits@V?$xalloc@U_scissor@@@@@std@@SAIABV?$xalloc@U_scissor@@@@@Z ; std::_Normal_allocator_traits<xalloc<_scissor> >::max_size
PUBLIC	?capacity@?$vector@U_scissor@@V?$xalloc@U_scissor@@@@@std@@QBEIXZ ; std::vector<_scissor,xalloc<_scissor> >::capacity
PUBLIC	?_Umove_if_noexcept1@?$vector@U_scissor@@V?$xalloc@U_scissor@@@@@std@@AAEXPAU_scissor@@00U?$integral_constant@_N$00@2@@Z ; std::vector<_scissor,xalloc<_scissor> >::_Umove_if_noexcept1
PUBLIC	?_Getal@?$vector@U_scissor@@V?$xalloc@U_scissor@@@@@std@@ABEABV?$xalloc@U_scissor@@@@XZ ; std::vector<_scissor,xalloc<_scissor> >::_Getal
PUBLIC	?max_size@?$_Normal_allocator_traits@V?$xalloc@PAVIRender_Sector@@@@@std@@SAIABV?$xalloc@PAVIRender_Sector@@@@@Z ; std::_Normal_allocator_traits<xalloc<IRender_Sector *> >::max_size
PUBLIC	?capacity@?$vector@PAVIRender_Sector@@V?$xalloc@PAVIRender_Sector@@@@@std@@QBEIXZ ; std::vector<IRender_Sector *,xalloc<IRender_Sector *> >::capacity
PUBLIC	?_Umove_if_noexcept1@?$vector@PAVIRender_Sector@@V?$xalloc@PAVIRender_Sector@@@@@std@@AAEXPAPAVIRender_Sector@@00U?$integral_constant@_N$00@2@@Z ; std::vector<IRender_Sector *,xalloc<IRender_Sector *> >::_Umove_if_noexcept1
PUBLIC	?_Getal@?$vector@PAVIRender_Sector@@V?$xalloc@PAVIRender_Sector@@@@@std@@ABEABV?$xalloc@PAVIRender_Sector@@@@XZ ; std::vector<IRender_Sector *,xalloc<IRender_Sector *> >::_Getal
PUBLIC	?construct@?$xalloc@PAVCPortal@@@@QAEXPAPAVCPortal@@ABQAV2@@Z ; xalloc<CPortal *>::construct
PUBLIC	?_Umove@?$vector@PAVCPortal@@V?$xalloc@PAVCPortal@@@@@std@@AAEPAPAVCPortal@@PAPAV3@00@Z ; std::vector<CPortal *,xalloc<CPortal *> >::_Umove
PUBLIC	?_Calculate_growth@?$vector@PAVCPortal@@V?$xalloc@PAVCPortal@@@@@std@@ABEII@Z ; std::vector<CPortal *,xalloc<CPortal *> >::_Calculate_growth
PUBLIC	?allocate@?$xalloc@VCFrustum@@@@QBEPAVCFrustum@@IPBX@Z ; xalloc<CFrustum>::allocate
PUBLIC	?construct@?$xalloc@VCFrustum@@@@QAEXPAVCFrustum@@ABV2@@Z ; xalloc<CFrustum>::construct
PUBLIC	?max_size@?$vector@VCFrustum@@V?$xalloc@VCFrustum@@@@@std@@QBEIXZ ; std::vector<CFrustum,xalloc<CFrustum> >::max_size
PUBLIC	?_Umove@?$vector@VCFrustum@@V?$xalloc@VCFrustum@@@@@std@@AAEPAVCFrustum@@PAV3@00@Z ; std::vector<CFrustum,xalloc<CFrustum> >::_Umove
PUBLIC	?_Umove_if_noexcept@?$vector@VCFrustum@@V?$xalloc@VCFrustum@@@@@std@@AAEXPAVCFrustum@@00@Z ; std::vector<CFrustum,xalloc<CFrustum> >::_Umove_if_noexcept
PUBLIC	?_Calculate_growth@?$vector@VCFrustum@@V?$xalloc@VCFrustum@@@@@std@@ABEII@Z ; std::vector<CFrustum,xalloc<CFrustum> >::_Calculate_growth
PUBLIC	?_Change_array@?$vector@VCFrustum@@V?$xalloc@VCFrustum@@@@@std@@AAEXQAVCFrustum@@II@Z ; std::vector<CFrustum,xalloc<CFrustum> >::_Change_array
PUBLIC	?_Xlength@?$vector@VCFrustum@@V?$xalloc@VCFrustum@@@@@std@@CAXXZ ; std::vector<CFrustum,xalloc<CFrustum> >::_Xlength
PUBLIC	?allocate@?$xalloc@U_scissor@@@@QBEPAU_scissor@@IPBX@Z ; xalloc<_scissor>::allocate
PUBLIC	?construct@?$xalloc@U_scissor@@@@QAEXPAU_scissor@@ABU2@@Z ; xalloc<_scissor>::construct
PUBLIC	?max_size@?$vector@U_scissor@@V?$xalloc@U_scissor@@@@@std@@QBEIXZ ; std::vector<_scissor,xalloc<_scissor> >::max_size
PUBLIC	?_Umove@?$vector@U_scissor@@V?$xalloc@U_scissor@@@@@std@@AAEPAU_scissor@@PAU3@00@Z ; std::vector<_scissor,xalloc<_scissor> >::_Umove
PUBLIC	?_Umove_if_noexcept@?$vector@U_scissor@@V?$xalloc@U_scissor@@@@@std@@AAEXPAU_scissor@@00@Z ; std::vector<_scissor,xalloc<_scissor> >::_Umove_if_noexcept
PUBLIC	?_Calculate_growth@?$vector@U_scissor@@V?$xalloc@U_scissor@@@@@std@@ABEII@Z ; std::vector<_scissor,xalloc<_scissor> >::_Calculate_growth
PUBLIC	?_Change_array@?$vector@U_scissor@@V?$xalloc@U_scissor@@@@@std@@AAEXQAU_scissor@@II@Z ; std::vector<_scissor,xalloc<_scissor> >::_Change_array
PUBLIC	?_Xlength@?$vector@U_scissor@@V?$xalloc@U_scissor@@@@@std@@CAXXZ ; std::vector<_scissor,xalloc<_scissor> >::_Xlength
PUBLIC	?allocate@?$xalloc@PAVIRender_Sector@@@@QBEPAPAVIRender_Sector@@IPBX@Z ; xalloc<IRender_Sector *>::allocate
PUBLIC	?deallocate@?$xalloc@PAVIRender_Sector@@@@QBEXPAPAVIRender_Sector@@I@Z ; xalloc<IRender_Sector *>::deallocate
PUBLIC	?construct@?$xalloc@PAVIRender_Sector@@@@QAEXPAPAVIRender_Sector@@ABQAV2@@Z ; xalloc<IRender_Sector *>::construct
PUBLIC	?max_size@?$vector@PAVIRender_Sector@@V?$xalloc@PAVIRender_Sector@@@@@std@@QBEIXZ ; std::vector<IRender_Sector *,xalloc<IRender_Sector *> >::max_size
PUBLIC	?_Umove@?$vector@PAVIRender_Sector@@V?$xalloc@PAVIRender_Sector@@@@@std@@AAEPAPAVIRender_Sector@@PAPAV3@00@Z ; std::vector<IRender_Sector *,xalloc<IRender_Sector *> >::_Umove
PUBLIC	?_Umove_if_noexcept@?$vector@PAVIRender_Sector@@V?$xalloc@PAVIRender_Sector@@@@@std@@AAEXPAPAVIRender_Sector@@00@Z ; std::vector<IRender_Sector *,xalloc<IRender_Sector *> >::_Umove_if_noexcept
PUBLIC	?_Destroy@?$vector@PAVIRender_Sector@@V?$xalloc@PAVIRender_Sector@@@@@std@@AAEXPAPAVIRender_Sector@@0@Z ; std::vector<IRender_Sector *,xalloc<IRender_Sector *> >::_Destroy
PUBLIC	?_Calculate_growth@?$vector@PAVIRender_Sector@@V?$xalloc@PAVIRender_Sector@@@@@std@@ABEII@Z ; std::vector<IRender_Sector *,xalloc<IRender_Sector *> >::_Calculate_growth
PUBLIC	?_Change_array@?$vector@PAVIRender_Sector@@V?$xalloc@PAVIRender_Sector@@@@@std@@AAEXQAPAVIRender_Sector@@II@Z ; std::vector<IRender_Sector *,xalloc<IRender_Sector *> >::_Change_array
PUBLIC	?_Xlength@?$vector@PAVIRender_Sector@@V?$xalloc@PAVIRender_Sector@@@@@std@@CAXXZ ; std::vector<IRender_Sector *,xalloc<IRender_Sector *> >::_Xlength
PUBLIC	??0?$_Uninitialized_backout_al@V?$xalloc@PAVCPortal@@@@@std@@QAE@PAPAVCPortal@@AAV?$xalloc@PAVCPortal@@@@@Z ; std::_Uninitialized_backout_al<xalloc<CPortal *> >::_Uninitialized_backout_al<xalloc<CPortal *> >
PUBLIC	??1?$_Uninitialized_backout_al@V?$xalloc@PAVCPortal@@@@@std@@QAE@XZ ; std::_Uninitialized_backout_al<xalloc<CPortal *> >::~_Uninitialized_backout_al<xalloc<CPortal *> >
PUBLIC	?_Release@?$_Uninitialized_backout_al@V?$xalloc@PAVCPortal@@@@@std@@QAEPAPAVCPortal@@XZ ; std::_Uninitialized_backout_al<xalloc<CPortal *> >::_Release
PUBLIC	??$_Get_unwrapped@ABQAPAVCPortal@@@std@@YA?A_TABQAPAVCPortal@@@Z ; std::_Get_unwrapped<CPortal * * const &>
PUBLIC	??$_Uninitialized_move@PAPAVCPortal@@V?$xalloc@PAVCPortal@@@@@std@@YAPAPAVCPortal@@QAPAV1@0PAPAV1@AAV?$xalloc@PAVCPortal@@@@@Z ; std::_Uninitialized_move<CPortal * *,xalloc<CPortal *> >
PUBLIC	??$xr_alloc@PAVCPortal@@@@YAPAPAVCPortal@@I@Z	; xr_alloc<CPortal *>
PUBLIC	??$addressof@V?$_Vector_val@U?$_Simple_types@PAVCPortal@@@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@PAVCPortal@@@std@@@0@AAV10@@Z ; std::addressof<std::_Vector_val<std::_Simple_types<CPortal *> > >
PUBLIC	??$_Emplace_reallocate@ABQAVCPortal@@@?$vector@PAVCPortal@@V?$xalloc@PAVCPortal@@@@@std@@QAEPAPAVCPortal@@QAPAV2@ABQAV2@@Z ; std::vector<CPortal *,xalloc<CPortal *> >::_Emplace_reallocate<CPortal * const &>
PUBLIC	??$construct@PAVCPortal@@ABQAV1@@?$_Normal_allocator_traits@V?$xalloc@PAVCPortal@@@@@std@@SAXAAV?$xalloc@PAVCPortal@@@@PAPAVCPortal@@ABQAV3@@Z ; std::_Normal_allocator_traits<xalloc<CPortal *> >::construct<CPortal *,CPortal * const &>
PUBLIC	??$forward@ABQAVCPortal@@@std@@YAABQAVCPortal@@ABQAV1@@Z ; std::forward<CPortal * const &>
PUBLIC	??$_Emplace_reallocate@ABVCFrustum@@@?$vector@VCFrustum@@V?$xalloc@VCFrustum@@@@@std@@QAEPAVCFrustum@@QAV2@ABV2@@Z ; std::vector<CFrustum,xalloc<CFrustum> >::_Emplace_reallocate<CFrustum const &>
PUBLIC	??$construct@VCFrustum@@ABV1@@?$_Normal_allocator_traits@V?$xalloc@VCFrustum@@@@@std@@SAXAAV?$xalloc@VCFrustum@@@@PAVCFrustum@@ABV3@@Z ; std::_Normal_allocator_traits<xalloc<CFrustum> >::construct<CFrustum,CFrustum const &>
PUBLIC	??$forward@ABVCFrustum@@@std@@YAABVCFrustum@@ABV1@@Z ; std::forward<CFrustum const &>
PUBLIC	??$_Emplace_reallocate@ABU_scissor@@@?$vector@U_scissor@@V?$xalloc@U_scissor@@@@@std@@QAEPAU_scissor@@QAU2@ABU2@@Z ; std::vector<_scissor,xalloc<_scissor> >::_Emplace_reallocate<_scissor const &>
PUBLIC	??$construct@U_scissor@@ABU1@@?$_Normal_allocator_traits@V?$xalloc@U_scissor@@@@@std@@SAXAAV?$xalloc@U_scissor@@@@PAU_scissor@@ABU3@@Z ; std::_Normal_allocator_traits<xalloc<_scissor> >::construct<_scissor,_scissor const &>
PUBLIC	??$forward@ABU_scissor@@@std@@YAABU_scissor@@ABU1@@Z ; std::forward<_scissor const &>
PUBLIC	??$_Emplace_reallocate@PAVIRender_Sector@@@?$vector@PAVIRender_Sector@@V?$xalloc@PAVIRender_Sector@@@@@std@@QAEPAPAVIRender_Sector@@QAPAV2@$$QAPAV2@@Z ; std::vector<IRender_Sector *,xalloc<IRender_Sector *> >::_Emplace_reallocate<IRender_Sector *>
PUBLIC	??$construct@PAVIRender_Sector@@PAV1@@?$_Normal_allocator_traits@V?$xalloc@PAVIRender_Sector@@@@@std@@SAXAAV?$xalloc@PAVIRender_Sector@@@@PAPAVIRender_Sector@@$$QAPAV3@@Z ; std::_Normal_allocator_traits<xalloc<IRender_Sector *> >::construct<IRender_Sector *,IRender_Sector *>
PUBLIC	??$_Unfancy@PAVIRender_Sector@@@std@@YAPAPAVIRender_Sector@@PAPAV1@@Z ; std::_Unfancy<IRender_Sector *>
PUBLIC	??$forward@PAVIRender_Sector@@@std@@YA$$QAPAVIRender_Sector@@AAPAV1@@Z ; std::forward<IRender_Sector *>
PUBLIC	??$move@AAPAVIRender_Sector@@@std@@YA$$QAPAVIRender_Sector@@AAPAV1@@Z ; std::move<IRender_Sector * &>
PUBLIC	?_Verify_offset@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPortal@@@std@@@std@@@std@@QBEXH@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CPortal *> > >::_Verify_offset
PUBLIC	?max_size@?$xalloc@PAVCPortal@@@@QBEIXZ		; xalloc<CPortal *>::max_size
PUBLIC	?_Umove_if_noexcept1@?$vector@PAVCPortal@@V?$xalloc@PAVCPortal@@@@@std@@AAEXPAPAVCPortal@@00U?$integral_constant@_N$00@2@@Z ; std::vector<CPortal *,xalloc<CPortal *> >::_Umove_if_noexcept1
PUBLIC	?_Get_first@?$_Compressed_pair@V?$xalloc@PAVCPortal@@@@V?$_Vector_val@U?$_Simple_types@PAVCPortal@@@std@@@std@@$00@std@@QBEABV?$xalloc@PAVCPortal@@@@XZ ; std::_Compressed_pair<xalloc<CPortal *>,std::_Vector_val<std::_Simple_types<CPortal *> >,1>::_Get_first
PUBLIC	??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPortal@@@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CPortal *> > >::operator+=
PUBLIC	?allocate@?$xalloc@PAVCPortal@@@@QBEPAPAVCPortal@@IPBX@Z ; xalloc<CPortal *>::allocate
PUBLIC	?max_size@?$_Normal_allocator_traits@V?$xalloc@PAVCPortal@@@@@std@@SAIABV?$xalloc@PAVCPortal@@@@@Z ; std::_Normal_allocator_traits<xalloc<CPortal *> >::max_size
PUBLIC	?_Umove_if_noexcept@?$vector@PAVCPortal@@V?$xalloc@PAVCPortal@@@@@std@@AAEXPAPAVCPortal@@00@Z ; std::vector<CPortal *,xalloc<CPortal *> >::_Umove_if_noexcept
PUBLIC	?_Change_array@?$vector@PAVCPortal@@V?$xalloc@PAVCPortal@@@@@std@@AAEXQAPAVCPortal@@II@Z ; std::vector<CPortal *,xalloc<CPortal *> >::_Change_array
PUBLIC	?_Getal@?$vector@PAVCPortal@@V?$xalloc@PAVCPortal@@@@@std@@ABEABV?$xalloc@PAVCPortal@@@@XZ ; std::vector<CPortal *,xalloc<CPortal *> >::_Getal
PUBLIC	?clear@?$vector@VCFrustum@@V?$xalloc@VCFrustum@@@@@std@@QAEXXZ ; std::vector<CFrustum,xalloc<CFrustum> >::clear
PUBLIC	?clear@?$vector@U_scissor@@V?$xalloc@U_scissor@@@@@std@@QAEXXZ ; std::vector<_scissor,xalloc<_scissor> >::clear
PUBLIC	?_Get_first@?$_Compressed_pair@V?$xalloc@PAVIRender_Sector@@@@V?$_Vector_val@U?$_Simple_types@PAVIRender_Sector@@@std@@@std@@$00@std@@QAEAAV?$xalloc@PAVIRender_Sector@@@@XZ ; std::_Compressed_pair<xalloc<IRender_Sector *>,std::_Vector_val<std::_Simple_types<IRender_Sector *> >,1>::_Get_first
PUBLIC	??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPortal@@@std@@@std@@@std@@QAE@PAPAVCPortal@@PBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CPortal *> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CPortal *> > >
PUBLIC	??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPortal@@@std@@@std@@@std@@QBEABQAVCPortal@@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CPortal *> > >::operator*
PUBLIC	??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPortal@@@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CPortal *> > >::operator+=
PUBLIC	??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPortal@@@std@@@std@@@std@@QAE@PAPAVCPortal@@PBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CPortal *> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<CPortal *> > >
PUBLIC	?_Reallocate_exactly@?$vector@PAVCPortal@@V?$xalloc@PAVCPortal@@@@@std@@AAEXI@Z ; std::vector<CPortal *,xalloc<CPortal *> >::_Reallocate_exactly
PUBLIC	?begin@?$vector@PAVCPortal@@V?$xalloc@PAVCPortal@@@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPortal@@@std@@@std@@@2@XZ ; std::vector<CPortal *,xalloc<CPortal *> >::begin
PUBLIC	?size@?$vector@PAVCPortal@@V?$xalloc@PAVCPortal@@@@@std@@QBEIXZ ; std::vector<CPortal *,xalloc<CPortal *> >::size
PUBLIC	?max_size@?$vector@PAVCPortal@@V?$xalloc@PAVCPortal@@@@@std@@QBEIXZ ; std::vector<CPortal *,xalloc<CPortal *> >::max_size
PUBLIC	?capacity@?$vector@PAVCPortal@@V?$xalloc@PAVCPortal@@@@@std@@QBEIXZ ; std::vector<CPortal *,xalloc<CPortal *> >::capacity
PUBLIC	?_Xlength@?$vector@PAVCPortal@@V?$xalloc@PAVCPortal@@@@@std@@CAXXZ ; std::vector<CPortal *,xalloc<CPortal *> >::_Xlength
PUBLIC	?_Orphan_range@?$vector@PAVCPortal@@V?$xalloc@PAVCPortal@@@@@std@@ABEXPAPAVCPortal@@0@Z ; std::vector<CPortal *,xalloc<CPortal *> >::_Orphan_range
PUBLIC	?_Orphan_range@?$vector@VCFrustum@@V?$xalloc@VCFrustum@@@@@std@@ABEXPAVCFrustum@@0@Z ; std::vector<CFrustum,xalloc<CFrustum> >::_Orphan_range
PUBLIC	?clear_and_free@?$xr_vector@VCFrustum@@V?$xalloc@VCFrustum@@@@@@QAEXXZ ; xr_vector<CFrustum,xalloc<CFrustum> >::clear_and_free
PUBLIC	?_Orphan_range@?$vector@U_scissor@@V?$xalloc@U_scissor@@@@@std@@ABEXPAU_scissor@@0@Z ; std::vector<_scissor,xalloc<_scissor> >::_Orphan_range
PUBLIC	?clear_and_free@?$xr_vector@U_scissor@@V?$xalloc@U_scissor@@@@@@QAEXXZ ; xr_vector<_scissor,xalloc<_scissor> >::clear_and_free
PUBLIC	?_Orphan_range@?$vector@PAVIRender_Sector@@V?$xalloc@PAVIRender_Sector@@@@@std@@ABEXPAPAVIRender_Sector@@0@Z ; std::vector<IRender_Sector *,xalloc<IRender_Sector *> >::_Orphan_range
PUBLIC	?_Getal@?$vector@PAVIRender_Sector@@V?$xalloc@PAVIRender_Sector@@@@@std@@AAEAAV?$xalloc@PAVIRender_Sector@@@@XZ ; std::vector<IRender_Sector *,xalloc<IRender_Sector *> >::_Getal
PUBLIC	??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPortal@@@std@@@std@@@std@@QBEAAPAVCPortal@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CPortal *> > >::operator*
PUBLIC	??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPortal@@@std@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CPortal *> > >::operator+
PUBLIC	?build@?$_plane@M@@QAEAAV1@ABU?$_vector3@M@@0@Z	; _plane<float>::build
PUBLIC	?invalidate@?$_box2@M@@QAEAAV1@XZ		; _box2<float>::invalidate
PUBLIC	??0?$svector@U?$_vector3@M@@$07@@QAE@XZ		; svector<_vector3<float>,8>::svector<_vector3<float>,8>
PUBLIC	?begin@?$svector@U?$_vector3@M@@$07@@QAEPAU?$_vector3@M@@XZ ; svector<_vector3<float>,8>::begin
PUBLIC	?size@?$svector@U?$_vector3@M@@$07@@QBEIXZ	; svector<_vector3<float>,8>::size
PUBLIC	??A?$svector@U?$_vector3@M@@$07@@QAEAAU?$_vector3@M@@I@Z ; svector<_vector3<float>,8>::operator[]
PUBLIC	?assign@?$svector@U?$_vector3@M@@$07@@QAEXPAU?$_vector3@M@@H@Z ; svector<_vector3<float>,8>::assign
PUBLIC	??$_Emplace_back_with_unused_capacity@ABQAVCPortal@@@?$vector@PAVCPortal@@V?$xalloc@PAVCPortal@@@@@std@@AAE?A_TABQAVCPortal@@@Z ; std::vector<CPortal *,xalloc<CPortal *> >::_Emplace_back_with_unused_capacity<CPortal * const &>
PUBLIC	??$emplace_back@ABQAVCPortal@@@?$vector@PAVCPortal@@V?$xalloc@PAVCPortal@@@@@std@@QAE?A_TABQAVCPortal@@@Z ; std::vector<CPortal *,xalloc<CPortal *> >::emplace_back<CPortal * const &>
PUBLIC	?push_back@?$vector@PAVCPortal@@V?$xalloc@PAVCPortal@@@@@std@@QAEXABQAVCPortal@@@Z ; std::vector<CPortal *,xalloc<CPortal *> >::push_back
PUBLIC	?reserve@?$vector@PAVCPortal@@V?$xalloc@PAVCPortal@@@@@std@@QAEXI@Z ; std::vector<CPortal *,xalloc<CPortal *> >::reserve
PUBLIC	?size@?$xr_vector@PAVCPortal@@V?$xalloc@PAVCPortal@@@@@@QBEIXZ ; xr_vector<CPortal *,xalloc<CPortal *> >::size
PUBLIC	??A?$xr_vector@PAVCPortal@@V?$xalloc@PAVCPortal@@@@@@QAEAAPAVCPortal@@I@Z ; xr_vector<CPortal *,xalloc<CPortal *> >::operator[]
PUBLIC	??$_Emplace_back_with_unused_capacity@ABVCFrustum@@@?$vector@VCFrustum@@V?$xalloc@VCFrustum@@@@@std@@AAE?A_TABVCFrustum@@@Z ; std::vector<CFrustum,xalloc<CFrustum> >::_Emplace_back_with_unused_capacity<CFrustum const &>
PUBLIC	??$emplace_back@ABVCFrustum@@@?$vector@VCFrustum@@V?$xalloc@VCFrustum@@@@@std@@QAE?A_TABVCFrustum@@@Z ; std::vector<CFrustum,xalloc<CFrustum> >::emplace_back<CFrustum const &>
PUBLIC	?push_back@?$vector@VCFrustum@@V?$xalloc@VCFrustum@@@@@std@@QAEXABVCFrustum@@@Z ; std::vector<CFrustum,xalloc<CFrustum> >::push_back
PUBLIC	?clear@?$xr_vector@VCFrustum@@V?$xalloc@VCFrustum@@@@@@QAEXXZ ; xr_vector<CFrustum,xalloc<CFrustum> >::clear
PUBLIC	??$_Emplace_back_with_unused_capacity@ABU_scissor@@@?$vector@U_scissor@@V?$xalloc@U_scissor@@@@@std@@AAE?A_TABU_scissor@@@Z ; std::vector<_scissor,xalloc<_scissor> >::_Emplace_back_with_unused_capacity<_scissor const &>
PUBLIC	??$emplace_back@ABU_scissor@@@?$vector@U_scissor@@V?$xalloc@U_scissor@@@@@std@@QAE?A_TABU_scissor@@@Z ; std::vector<_scissor,xalloc<_scissor> >::emplace_back<_scissor const &>
PUBLIC	?push_back@?$vector@U_scissor@@V?$xalloc@U_scissor@@@@@std@@QAEXABU_scissor@@@Z ; std::vector<_scissor,xalloc<_scissor> >::push_back
PUBLIC	?clear@?$xr_vector@U_scissor@@V?$xalloc@U_scissor@@@@@@QAEXXZ ; xr_vector<_scissor,xalloc<_scissor> >::clear
PUBLIC	??$_Emplace_back_with_unused_capacity@PAVIRender_Sector@@@?$vector@PAVIRender_Sector@@V?$xalloc@PAVIRender_Sector@@@@@std@@AAE?A_T$$QAPAVIRender_Sector@@@Z ; std::vector<IRender_Sector *,xalloc<IRender_Sector *> >::_Emplace_back_with_unused_capacity<IRender_Sector *>
PUBLIC	??$emplace_back@PAVIRender_Sector@@@?$vector@PAVIRender_Sector@@V?$xalloc@PAVIRender_Sector@@@@@std@@QAE?A_T$$QAPAVIRender_Sector@@@Z ; std::vector<IRender_Sector *,xalloc<IRender_Sector *> >::emplace_back<IRender_Sector *>
PUBLIC	?push_back@?$vector@PAVIRender_Sector@@V?$xalloc@PAVIRender_Sector@@@@@std@@QAEX$$QAPAVIRender_Sector@@@Z ; std::vector<IRender_Sector *,xalloc<IRender_Sector *> >::push_back
PUBLIC	?load@CSector@@QAEXAAVIReader@@@Z		; CSector::load
PUBLIC	?traverse@CSector@@QAEXAAVCFrustum@@AAU_scissor@@@Z ; CSector::traverse
PUBLIC	??1CSector@@UAE@XZ				; CSector::~CSector
PUBLIC	?Setup@CPortal@@QAEXPAU?$_vector3@M@@HPAVCSector@@1@Z ; CPortal::Setup
PUBLIC	??1CPortal@@UAE@XZ				; CPortal::~CPortal
PUBLIC	??_GCPortal@@UAEPAXI@Z				; CPortal::`scalar deleting destructor'
PUBLIC	??0CPortal@@QAE@XZ				; CPortal::CPortal
EXTRN	??_ECSector@@UAEPAXI@Z:PROC			; CSector::`vector deleting destructor'
EXTRN	??_ECPortal@@UAEPAXI@Z:PROC			; CPortal::`vector deleting destructor'
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?_Reallocate_exactly@?$vector@PAVCPortal@@V?$xalloc@PAVCPortal@@@@@std@@AAEXI@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Reallocate_exactly@?$vector@PAVCPortal@@V?$xalloc@PAVCPortal@@@@@std@@AAEXI@Z
	DD	01H
	DD	FLAT:__tryblocktable$?_Reallocate_exactly@?$vector@PAVCPortal@@V?$xalloc@PAVCPortal@@@@@std@@AAEXI@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
__unwindtable$?_Reallocate_exactly@?$vector@PAVCPortal@@V?$xalloc@PAVCPortal@@@@@std@@AAEXI@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?_Reallocate_exactly@?$vector@PAVCPortal@@V?$xalloc@PAVCPortal@@@@@std@@AAEXI@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Reallocate_exactly@?$vector@PAVCPortal@@V?$xalloc@PAVCPortal@@@@@std@@AAEXI@Z$2
__catchsym$?_Reallocate_exactly@?$vector@PAVCPortal@@V?$xalloc@PAVCPortal@@@@@std@@AAEXI@Z$2 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Reallocate_exactly@?$vector@PAVCPortal@@V?$xalloc@PAVCPortal@@@@@std@@AAEXI@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$_Emplace_reallocate@PAVIRender_Sector@@@?$vector@PAVIRender_Sector@@V?$xalloc@PAVIRender_Sector@@@@@std@@QAEPAPAVIRender_Sector@@QAPAV2@$$QAPAV2@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Emplace_reallocate@PAVIRender_Sector@@@?$vector@PAVIRender_Sector@@V?$xalloc@PAVIRender_Sector@@@@@std@@QAEPAPAVIRender_Sector@@QAPAV2@$$QAPAV2@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Emplace_reallocate@PAVIRender_Sector@@@?$vector@PAVIRender_Sector@@V?$xalloc@PAVIRender_Sector@@@@@std@@QAEPAPAVIRender_Sector@@QAPAV2@$$QAPAV2@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
__unwindtable$??$_Emplace_reallocate@PAVIRender_Sector@@@?$vector@PAVIRender_Sector@@V?$xalloc@PAVIRender_Sector@@@@@std@@QAEPAPAVIRender_Sector@@QAPAV2@$$QAPAV2@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Emplace_reallocate@PAVIRender_Sector@@@?$vector@PAVIRender_Sector@@V?$xalloc@PAVIRender_Sector@@@@@std@@QAEPAPAVIRender_Sector@@QAPAV2@$$QAPAV2@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Emplace_reallocate@PAVIRender_Sector@@@?$vector@PAVIRender_Sector@@V?$xalloc@PAVIRender_Sector@@@@@std@@QAEPAPAVIRender_Sector@@QAPAV2@$$QAPAV2@@Z$2
__catchsym$??$_Emplace_reallocate@PAVIRender_Sector@@@?$vector@PAVIRender_Sector@@V?$xalloc@PAVIRender_Sector@@@@@std@@QAEPAPAVIRender_Sector@@QAPAV2@$$QAPAV2@@Z$2 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Emplace_reallocate@PAVIRender_Sector@@@?$vector@PAVIRender_Sector@@V?$xalloc@PAVIRender_Sector@@@@@std@@QAEPAPAVIRender_Sector@@QAPAV2@$$QAPAV2@@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$_Emplace_reallocate@ABU_scissor@@@?$vector@U_scissor@@V?$xalloc@U_scissor@@@@@std@@QAEPAU_scissor@@QAU2@ABU2@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Emplace_reallocate@ABU_scissor@@@?$vector@U_scissor@@V?$xalloc@U_scissor@@@@@std@@QAEPAU_scissor@@QAU2@ABU2@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Emplace_reallocate@ABU_scissor@@@?$vector@U_scissor@@V?$xalloc@U_scissor@@@@@std@@QAEPAU_scissor@@QAU2@ABU2@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
__unwindtable$??$_Emplace_reallocate@ABU_scissor@@@?$vector@U_scissor@@V?$xalloc@U_scissor@@@@@std@@QAEPAU_scissor@@QAU2@ABU2@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Emplace_reallocate@ABU_scissor@@@?$vector@U_scissor@@V?$xalloc@U_scissor@@@@@std@@QAEPAU_scissor@@QAU2@ABU2@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Emplace_reallocate@ABU_scissor@@@?$vector@U_scissor@@V?$xalloc@U_scissor@@@@@std@@QAEPAU_scissor@@QAU2@ABU2@@Z$2
__catchsym$??$_Emplace_reallocate@ABU_scissor@@@?$vector@U_scissor@@V?$xalloc@U_scissor@@@@@std@@QAEPAU_scissor@@QAU2@ABU2@@Z$2 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Emplace_reallocate@ABU_scissor@@@?$vector@U_scissor@@V?$xalloc@U_scissor@@@@@std@@QAEPAU_scissor@@QAU2@ABU2@@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$_Emplace_reallocate@ABVCFrustum@@@?$vector@VCFrustum@@V?$xalloc@VCFrustum@@@@@std@@QAEPAVCFrustum@@QAV2@ABV2@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Emplace_reallocate@ABVCFrustum@@@?$vector@VCFrustum@@V?$xalloc@VCFrustum@@@@@std@@QAEPAVCFrustum@@QAV2@ABV2@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Emplace_reallocate@ABVCFrustum@@@?$vector@VCFrustum@@V?$xalloc@VCFrustum@@@@@std@@QAEPAVCFrustum@@QAV2@ABV2@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
__unwindtable$??$_Emplace_reallocate@ABVCFrustum@@@?$vector@VCFrustum@@V?$xalloc@VCFrustum@@@@@std@@QAEPAVCFrustum@@QAV2@ABV2@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Emplace_reallocate@ABVCFrustum@@@?$vector@VCFrustum@@V?$xalloc@VCFrustum@@@@@std@@QAEPAVCFrustum@@QAV2@ABV2@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Emplace_reallocate@ABVCFrustum@@@?$vector@VCFrustum@@V?$xalloc@VCFrustum@@@@@std@@QAEPAVCFrustum@@QAV2@ABV2@@Z$2
__catchsym$??$_Emplace_reallocate@ABVCFrustum@@@?$vector@VCFrustum@@V?$xalloc@VCFrustum@@@@@std@@QAEPAVCFrustum@@QAV2@ABV2@@Z$2 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Emplace_reallocate@ABVCFrustum@@@?$vector@VCFrustum@@V?$xalloc@VCFrustum@@@@@std@@QAEPAVCFrustum@@QAV2@ABV2@@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$_Emplace_reallocate@ABQAVCPortal@@@?$vector@PAVCPortal@@V?$xalloc@PAVCPortal@@@@@std@@QAEPAPAVCPortal@@QAPAV2@ABQAV2@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Emplace_reallocate@ABQAVCPortal@@@?$vector@PAVCPortal@@V?$xalloc@PAVCPortal@@@@@std@@QAEPAPAVCPortal@@QAPAV2@ABQAV2@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Emplace_reallocate@ABQAVCPortal@@@?$vector@PAVCPortal@@V?$xalloc@PAVCPortal@@@@@std@@QAEPAPAVCPortal@@QAPAV2@ABQAV2@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
__unwindtable$??$_Emplace_reallocate@ABQAVCPortal@@@?$vector@PAVCPortal@@V?$xalloc@PAVCPortal@@@@@std@@QAEPAPAVCPortal@@QAPAV2@ABQAV2@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Emplace_reallocate@ABQAVCPortal@@@?$vector@PAVCPortal@@V?$xalloc@PAVCPortal@@@@@std@@QAEPAPAVCPortal@@QAPAV2@ABQAV2@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Emplace_reallocate@ABQAVCPortal@@@?$vector@PAVCPortal@@V?$xalloc@PAVCPortal@@@@@std@@QAEPAPAVCPortal@@QAPAV2@ABQAV2@@Z$2
__catchsym$??$_Emplace_reallocate@ABQAVCPortal@@@?$vector@PAVCPortal@@V?$xalloc@PAVCPortal@@@@@std@@QAEPAPAVCPortal@@QAPAV2@ABQAV2@@Z$2 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Emplace_reallocate@ABQAVCPortal@@@?$vector@PAVCPortal@@V?$xalloc@PAVCPortal@@@@@std@@QAEPAPAVCPortal@@QAPAV2@ABQAV2@@Z$0
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__sector.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\FixedVector.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__sector.cpp
_TEXT	SEGMENT
??0CPortal@@QAE@XZ PROC					; CPortal::CPortal
; _this$ = ecx

; 16   : {

	mov	DWORD PTR [ecx], OFFSET ??_7CPortal@@6B@

; 20   : }

	mov	eax, ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\FixedVector.h

; 21   : 	svector() : count(0) 

	mov	DWORD PTR [ecx+100], 0
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__sector.cpp

; 20   : }

	ret	0
??0CPortal@@QAE@XZ ENDP					; CPortal::CPortal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__sector.cpp
; File I:\Vitalya\mine\NSProjectX\xrEngine\render.h
;	COMDAT ??_GCPortal@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCPortal@@UAEPAXI@Z PROC				; CPortal::`scalar deleting destructor', COMDAT
; _this$ = ecx
	test	BYTE PTR ___flags$[esp-4], 1
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__sector.cpp

; 23   : {

	push	esi
	mov	esi, ecx
	mov	DWORD PTR [esi], OFFSET ??_7CPortal@@6B@
; File I:\Vitalya\mine\NSProjectX\xrEngine\render.h

; 99   : 	virtual ~IRender_Portal() {};

	mov	eax, DWORD PTR __imp_??_7IRender_Portal@@6B@
	mov	DWORD PTR [esi], eax
	je	SHORT $LN8@scalar
	push	152					; 00000098H
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN8@scalar:
	mov	eax, esi
	pop	esi
	ret	4
??_GCPortal@@UAEPAXI@Z ENDP				; CPortal::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__sector.cpp
; File I:\Vitalya\mine\NSProjectX\xrEngine\render.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__sector.cpp
_TEXT	SEGMENT
??1CPortal@@UAE@XZ PROC					; CPortal::~CPortal
; _this$ = ecx

; 23   : {

	mov	DWORD PTR [ecx], OFFSET ??_7CPortal@@6B@
; File I:\Vitalya\mine\NSProjectX\xrEngine\render.h

; 99   : 	virtual ~IRender_Portal() {};

	mov	eax, DWORD PTR __imp_??_7IRender_Portal@@6B@
	mov	DWORD PTR [ecx], eax
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__sector.cpp

; 27   : }

	ret	0
??1CPortal@@UAE@XZ ENDP					; CPortal::~CPortal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__sector.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__sector.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__sector.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__sector.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__sector.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__sector.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_std_extensions.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_std_extensions.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_std_extensions.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_std_extensions.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_std_extensions.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__sector.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__sector.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h
; File I:\Vitalya\mine\NSProjectX\xrCore\FixedVector.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h
; File I:\Vitalya\mine\NSProjectX\xrCore\FixedVector.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__sector.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h
; File I:\Vitalya\mine\NSProjectX\xrCore\FixedVector.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\FixedVector.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\FixedVector.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h
; File I:\Vitalya\mine\NSProjectX\xrCore\FixedVector.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__sector.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__sector.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\FixedVector.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__sector.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__sector.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__sector.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__sector.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__sector.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_plane.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_plane.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__sector.cpp
_TEXT	SEGMENT
_N$$sroa$527$1$ = -20					; size = 4
_BB$2$ = -20						; size = 4
_N$$sroa$581$1$ = -16					; size = 4
$T1 = -16						; size = 4
_N$$sroa$583$1$ = -12					; size = 4
$T2 = -12						; size = 4
_this$1$ = -8						; size = 4
$T3 = -4						; size = 4
tv1601 = -4						; size = 4
tv1549 = -4						; size = 4
tv766 = -4						; size = 4
_V$ = 8							; size = 4
_vcnt$ = 12						; size = 4
_face$ = 16						; size = 4
_back$ = 20						; size = 4
?Setup@CPortal@@QAEXPAU?$_vector3@M@@HPAVCSector@@1@Z PROC ; CPortal::Setup
; _this$ = ecx

; 66   : {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	sub	esp, 24					; 00000018H
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 23   : 	ICF	SelfRef	set(T _x, T _y, T _z)					{ x = _x;		y = _y;		z = _z;		return *this;	};

	movss	xmm3, DWORD PTR __real@ff7fffff
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__sector.cpp

; 66   : {

	mov	edx, ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 23   : 	ICF	SelfRef	set(T _x, T _y, T _z)					{ x = _x;		y = _y;		z = _z;		return *this;	};

	movss	xmm6, DWORD PTR __real@7f7fffff
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h

; 37   : 	IC	SelfRef	invalidate	()								{ min.set(type_max(T),type_max(T),type_max(T)); max.set(type_min(T),type_min(T),type_min(T));	return *this;	}

	movaps	xmm0, xmm3
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__sector.cpp

; 66   : {

	push	esi

; 70   : 	for (int v=0; v<vcnt; v++)

	mov	esi, DWORD PTR _vcnt$[ebp]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 23   : 	ICF	SelfRef	set(T _x, T _y, T _z)					{ x = _x;		y = _y;		z = _z;		return *this;	};

	movaps	xmm2, xmm6
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__sector.cpp

; 66   : {

	mov	DWORD PTR _this$1$[esp+28], edx
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 23   : 	ICF	SelfRef	set(T _x, T _y, T _z)					{ x = _x;		y = _y;		z = _z;		return *this;	};

	movaps	xmm4, xmm6
	movss	DWORD PTR _BB$2$[esp+28], xmm2
	movaps	xmm7, xmm3
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h

; 37   : 	IC	SelfRef	invalidate	()								{ min.set(type_max(T),type_max(T),type_max(T)); max.set(type_min(T),type_min(T),type_min(T));	return *this;	}

	movss	DWORD PTR $T1[esp+28], xmm6
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 23   : 	ICF	SelfRef	set(T _x, T _y, T _z)					{ x = _x;		y = _y;		z = _z;		return *this;	};

	movaps	xmm5, xmm3
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h

; 37   : 	IC	SelfRef	invalidate	()								{ min.set(type_max(T),type_max(T),type_max(T)); max.set(type_min(T),type_min(T),type_min(T));	return *this;	}

	movss	DWORD PTR $T3[esp+28], xmm0
	movss	DWORD PTR $T2[esp+28], xmm3
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__sector.cpp

; 66   : {

	push	edi

; 70   : 	for (int v=0; v<vcnt; v++)

	test	esi, esi
	jle	$LN3@Setup
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 23   : 	ICF	SelfRef	set(T _x, T _y, T _z)					{ x = _x;		y = _y;		z = _z;		return *this;	};

	mov	eax, DWORD PTR _V$[ebp]
	mov	ecx, esi
	add	eax, 8
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__sector.cpp

; 70   : 	for (int v=0; v<vcnt; v++)

	jmp	SHORT $LN4@Setup
	npad	3
$LL145@Setup:
	movss	xmm2, DWORD PTR _BB$2$[esp+32]
$LN4@Setup:
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 53   : 	IC	SelfRef	min(const Self &v)						{ x = _min(x,v.x);	y = _min(y,v.y);	z = _min(z,v.z);			return *this;	}

	movss	xmm0, DWORD PTR [eax-8]
; File I:\Vitalya\mine\NSProjectX\xrCore\_std_extensions.h

; 93   : template <class T>	IC T		_min	(T a, T b)	{ return a<b?a:b;	}

	comiss	xmm0, xmm6
	ja	SHORT $LN39@Setup
	movaps	xmm6, xmm0
$LN39@Setup:
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 53   : 	IC	SelfRef	min(const Self &v)						{ x = _min(x,v.x);	y = _min(y,v.y);	z = _min(z,v.z);			return *this;	}

	movss	xmm1, DWORD PTR [eax-4]
; File I:\Vitalya\mine\NSProjectX\xrCore\_std_extensions.h

; 93   : template <class T>	IC T		_min	(T a, T b)	{ return a<b?a:b;	}

	comiss	xmm1, xmm2
	jbe	SHORT $LN42@Setup
	movss	DWORD PTR _BB$2$[esp+32], xmm2
	jmp	SHORT $LN43@Setup
$LN42@Setup:
	movss	DWORD PTR _BB$2$[esp+32], xmm1
$LN43@Setup:
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 53   : 	IC	SelfRef	min(const Self &v)						{ x = _min(x,v.x);	y = _min(y,v.y);	z = _min(z,v.z);			return *this;	}

	movss	xmm2, DWORD PTR [eax]
; File I:\Vitalya\mine\NSProjectX\xrCore\_std_extensions.h

; 93   : template <class T>	IC T		_min	(T a, T b)	{ return a<b?a:b;	}

	comiss	xmm2, xmm4
	ja	SHORT $LN47@Setup
	movaps	xmm4, xmm2
$LN47@Setup:

; 94   : template <class T>	IC T		_max	(T a, T b)	{ return a>b?a:b;	}

	comiss	xmm3, xmm0
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 53   : 	IC	SelfRef	min(const Self &v)						{ x = _min(x,v.x);	y = _min(y,v.y);	z = _min(z,v.z);			return *this;	}

	movss	DWORD PTR $T1[esp+32], xmm4
; File I:\Vitalya\mine\NSProjectX\xrCore\_std_extensions.h

; 94   : template <class T>	IC T		_max	(T a, T b)	{ return a>b?a:b;	}

	ja	SHORT $LN53@Setup
	movaps	xmm3, xmm0
$LN53@Setup:
	comiss	xmm7, xmm1
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 55   : 	IC	SelfRef	max(const Self &v)						{ x = _max(x,v.x);	y = _max(y,v.y);	z = _max(z,v.z);			return *this;	}

	movaps	xmm0, xmm3
	movss	DWORD PTR $T3[esp+32], xmm0
; File I:\Vitalya\mine\NSProjectX\xrCore\_std_extensions.h

; 94   : template <class T>	IC T		_max	(T a, T b)	{ return a>b?a:b;	}

	ja	SHORT $LN57@Setup
	movaps	xmm7, xmm1
$LN57@Setup:
	comiss	xmm5, xmm2
	ja	SHORT $LN61@Setup
	movaps	xmm5, xmm2
$LN61@Setup:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__sector.cpp

; 70   : 	for (int v=0; v<vcnt; v++)

	add	eax, 12					; 0000000cH
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 55   : 	IC	SelfRef	max(const Self &v)						{ x = _max(x,v.x);	y = _max(y,v.y);	z = _max(z,v.z);			return *this;	}

	movss	DWORD PTR $T2[esp+32], xmm5
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__sector.cpp

; 70   : 	for (int v=0; v<vcnt; v++)

	sub	ecx, 1
	jne	SHORT $LL145@Setup
	movaps	xmm3, xmm7
$LN3@Setup:
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h

; 99   : 		C.z = (min.z + max.z) * 0.5f;

	movss	xmm5, DWORD PTR $T1[esp+32]
; File I:\Vitalya\mine\NSProjectX\xrCore\FixedVector.h

; 65   : 	IC void		assign(iterator p, int c) { VERIFY(c>0 && c<dim); CopyMemory(array,p,c*sizeof(value_type)); count=c; }

	lea	eax, DWORD PTR [esi+esi*2]
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h

; 99   : 		C.z = (min.z + max.z) * 0.5f;

	addss	xmm5, DWORD PTR $T2[esp+32]
	movaps	xmm2, xmm0
; File I:\Vitalya\mine\NSProjectX\xrCore\FixedVector.h

; 65   : 	IC void		assign(iterator p, int c) { VERIFY(c>0 && c<dim); CopyMemory(array,p,c*sizeof(value_type)); count=c; }

	shl	eax, 2
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h

; 97   : 		C.x = (min.x + max.x) * 0.5f;

	movss	xmm0, DWORD PTR __real@3f000000
	addss	xmm2, xmm6

; 98   : 		C.y = (min.y + max.y) * 0.5f;

	movaps	xmm1, xmm3
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__sector.cpp

; 75   : 	poly.assign			(V,vcnt);

	lea	edi, DWORD PTR [edx+4]
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h

; 98   : 		C.y = (min.y + max.y) * 0.5f;

	addss	xmm1, DWORD PTR _BB$2$[esp+32]

; 99   : 		C.z = (min.z + max.z) * 0.5f;

	mulss	xmm5, xmm0
; File I:\Vitalya\mine\NSProjectX\xrCore\FixedVector.h

; 65   : 	IC void		assign(iterator p, int c) { VERIFY(c>0 && c<dim); CopyMemory(array,p,c*sizeof(value_type)); count=c; }

	push	eax
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h

; 97   : 		C.x = (min.x + max.x) * 0.5f;

	mulss	xmm2, xmm0

; 98   : 		C.y = (min.y + max.y) * 0.5f;

	mulss	xmm1, xmm0
	movss	DWORD PTR [edx+128], xmm2
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 287  : 	{	return (x-v.x)*(x-v.x) + (y-v.y)*(y-v.y) + (z-v.z)*(z-v.z);	}

	subss	xmm2, DWORD PTR $T3[esp+36]
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h

; 98   : 		C.y = (min.y + max.y) * 0.5f;

	movss	DWORD PTR [edx+132], xmm1
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 287  : 	{	return (x-v.x)*(x-v.x) + (y-v.y)*(y-v.y) + (z-v.z)*(z-v.z);	}

	subss	xmm1, xmm3
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h

; 99   : 		C.z = (min.z + max.z) * 0.5f;

	movss	DWORD PTR [edx+136], xmm5
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 287  : 	{	return (x-v.x)*(x-v.x) + (y-v.y)*(y-v.y) + (z-v.z)*(z-v.z);	}

	subss	xmm5, DWORD PTR $T2[esp+36]
; File I:\Vitalya\mine\NSProjectX\xrCore\FixedVector.h

; 65   : 	IC void		assign(iterator p, int c) { VERIFY(c>0 && c<dim); CopyMemory(array,p,c*sizeof(value_type)); count=c; }

	push	DWORD PTR _V$[ebp]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 287  : 	{	return (x-v.x)*(x-v.x) + (y-v.y)*(y-v.y) + (z-v.z)*(z-v.z);	}

	mulss	xmm2, xmm2
; File I:\Vitalya\mine\NSProjectX\xrCore\FixedVector.h

; 65   : 	IC void		assign(iterator p, int c) { VERIFY(c>0 && c<dim); CopyMemory(array,p,c*sizeof(value_type)); count=c; }

	push	edi
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 287  : 	{	return (x-v.x)*(x-v.x) + (y-v.y)*(y-v.y) + (z-v.z)*(z-v.z);	}

	mulss	xmm1, xmm1
	mulss	xmm5, xmm5
	addss	xmm2, xmm1
	addss	xmm2, xmm5
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h

; 764  :             return (float)sqrt(_X);

	sqrtss	xmm0, xmm2
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h

; 116  : 		R = C.distance_to	(max);

	movss	DWORD PTR [edx+140], xmm0
; File I:\Vitalya\mine\NSProjectX\xrCore\FixedVector.h

; 65   : 	IC void		assign(iterator p, int c) { VERIFY(c>0 && c<dim); CopyMemory(array,p,c*sizeof(value_type)); count=c; }

	call	_memcpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__sector.cpp

; 76   : 	pFace				= face; 

	mov	ecx, DWORD PTR _this$1$[esp+44]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 23   : 	ICF	SelfRef	set(T _x, T _y, T _z)					{ x = _x;		y = _y;		z = _z;		return *this;	};

	xorps	xmm0, xmm0
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__sector.cpp

; 76   : 	pFace				= face; 

	mov	eax, DWORD PTR _face$[ebp]
; File I:\Vitalya\mine\NSProjectX\xrCore\FixedVector.h

; 65   : 	IC void		assign(iterator p, int c) { VERIFY(c>0 && c<dim); CopyMemory(array,p,c*sizeof(value_type)); count=c; }

	add	esp, 12					; 0000000cH
	mov	DWORD PTR [edi+96], esi
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 23   : 	ICF	SelfRef	set(T _x, T _y, T _z)					{ x = _x;		y = _y;		z = _z;		return *this;	};

	movss	DWORD PTR _N$$sroa$527$1$[esp+32], xmm0
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__sector.cpp

; 76   : 	pFace				= face; 

	mov	DWORD PTR [ecx+104], eax

; 77   : 	pBack				= back;

	mov	eax, DWORD PTR _back$[ebp]
	mov	DWORD PTR [ecx+108], eax

; 78   : 	marker				= 0xffffffff; 

	mov	DWORD PTR [ecx+144], -1
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 23   : 	ICF	SelfRef	set(T _x, T _y, T _z)					{ x = _x;		y = _y;		z = _z;		return *this;	};

	movss	DWORD PTR _N$$sroa$581$1$[esp+32], xmm0
	movss	DWORD PTR _N$$sroa$583$1$[esp+32], xmm0
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__sector.cpp

; 83   : 	FPU::m64r();

	call	DWORD PTR __imp_?m64r@FPU@@YAXXZ

; 85   : 	for (int i=2; i<vcnt; i++) {

	mov	ecx, DWORD PTR _vcnt$[ebp]
	xor	esi, esi
	cmp	ecx, 2
	jle	$LN10@Setup

; 71   : 		BB.modify		(V[v]);
; 72   : 	BB.getsphere		(S.P,S.R);

	mov	eax, DWORD PTR _this$1$[esp+32]
	add	eax, 32					; 00000020H
	add	ecx, -2					; fffffffeH
	npad	3
$LL7@Setup:
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	xmm2, DWORD PTR [eax]
	movss	xmm1, DWORD PTR [eax+4]
	subss	xmm1, DWORD PTR [eax-8]
	subss	xmm2, DWORD PTR [eax-12]
	movss	xmm5, DWORD PTR [eax-12]
	movss	xmm3, DWORD PTR [eax-8]
	subss	xmm5, DWORD PTR [edi+4]
	subss	xmm3, DWORD PTR [edi+8]
	movss	xmm4, DWORD PTR [eax-4]
	movaps	xmm7, xmm1
	subss	xmm4, DWORD PTR [eax-16]
	movss	xmm6, DWORD PTR [eax-16]

; 273  : 		x = v1.y  * v2.z  - v1.z  * v2.y ;

	movaps	xmm0, xmm2

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	subss	xmm6, DWORD PTR [edi]

; 273  : 		x = v1.y  * v2.z  - v1.z  * v2.y ;

	mulss	xmm0, xmm3

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	mulss	xmm7, xmm5

; 274  : 		y = v1.z  * v2.x  - v1.x  * v2.z ;

	mulss	xmm1, xmm6
	subss	xmm7, xmm0
	mulss	xmm2, xmm6
	movaps	xmm0, xmm4

; 275  : 		z = v1.x  * v2.y  - v1.y  * v2.x ;

	mulss	xmm4, xmm5
	mulss	xmm0, xmm3
	subss	xmm2, xmm4
	subss	xmm0, xmm1
	movaps	xmm1, xmm0
	movss	DWORD PTR tv1549[esp+32], xmm0
	mulss	xmm1, xmm0

; 167  : 		return x*x + y*y + z*z;

	movaps	xmm0, xmm7
	mulss	xmm0, xmm7
	addss	xmm1, xmm0
	movaps	xmm0, xmm2
	mulss	xmm0, xmm2
	addss	xmm1, xmm0
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h

; 764  :             return (float)sqrt(_X);

	sqrtss	xmm0, xmm1
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__sector.cpp

; 88   : 		if (m>EPS_S)	{

	comiss	xmm0, DWORD PTR __real@33d6bf95
	jbe	SHORT $LN5@Setup
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 45   : 	ICF SelfRef	div(T s)								{ x/=s;		y/=s;    z/=s;				return *this;	};

	movss	xmm1, DWORD PTR __real@3f800000
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__sector.cpp

; 90   : 			_cnt		++			;

	inc	esi
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 45   : 	ICF SelfRef	div(T s)								{ x/=s;		y/=s;    z/=s;				return *this;	};

	divss	xmm1, xmm0
	movaps	xmm0, xmm1
	mulss	xmm0, xmm7
	addss	xmm0, DWORD PTR _N$$sroa$527$1$[esp+32]

; 29   : 	ICF	SelfRef	add(const Self &v)						{ x+=v.x;	y+=v.y;		z+=v.z;			return *this;	};

	movss	DWORD PTR _N$$sroa$527$1$[esp+32], xmm0

; 45   : 	ICF SelfRef	div(T s)								{ x/=s;		y/=s;    z/=s;				return *this;	};

	movaps	xmm0, xmm1
	mulss	xmm0, DWORD PTR tv1549[esp+32]
	mulss	xmm1, xmm2

; 29   : 	ICF	SelfRef	add(const Self &v)						{ x+=v.x;	y+=v.y;		z+=v.z;			return *this;	};

	addss	xmm0, DWORD PTR _N$$sroa$581$1$[esp+32]
	addss	xmm1, DWORD PTR _N$$sroa$583$1$[esp+32]
	movss	DWORD PTR _N$$sroa$581$1$[esp+32], xmm0
	movss	DWORD PTR _N$$sroa$583$1$[esp+32], xmm1
$LN5@Setup:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__sector.cpp

; 85   : 	for (int i=2; i<vcnt; i++) {

	add	eax, 12					; 0000000cH
	sub	ecx, 1
	jne	$LL7@Setup
$LN10@Setup:

; 91   : 		}
; 92   : 	}
; 93   : 	R_ASSERT2	(_cnt, "Invalid portal detected");

	cmp	BYTE PTR ?ignore_always@?9??Setup@CPortal@@QAEXPAU?$_vector3@M@@HPAVCSector@@1@Z@4_NA, 0
	jne	SHORT $LN8@Setup
	test	esi, esi
	jne	SHORT $LN8@Setup
	mov	ecx, DWORD PTR __imp_?Debug@@3VxrDebug@@A
	push	OFFSET ?ignore_always@?9??Setup@CPortal@@QAEXPAU?$_vector3@M@@HPAVCSector@@1@Z@4_NA
	push	OFFSET ??_C@_0P@KFFENJEF@CPortal?3?3Setup@
	push	93					; 0000005dH
	push	OFFSET ??_C@_0DJ@FDLNFKJF@I?3?2Vitalya?2mine?2NSProjectX?2laye@
	push	OFFSET ??_C@_0BI@JPKPOFID@Invalid?5portal?5detected@
	push	OFFSET ??_C@_04KDBHFCMN@_cnt@
	call	DWORD PTR __imp_?fail@xrDebug@@QAEXPBD00H0AA_N@Z
$LN8@Setup:

; 94   : 	N.div		(float(_cnt));

	mov	DWORD PTR tv1601[esp+32], esi
	fild	DWORD PTR tv1601[esp+32]
	test	esi, esi
	jns	SHORT $LN146@Setup
	fadd	DWORD PTR __real@4f800000
$LN146@Setup:
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 45   : 	ICF SelfRef	div(T s)								{ x/=s;		y/=s;    z/=s;				return *this;	};

	fld1
	fdivrp	ST(1), ST(0)

; 215  : 		x = v.x*mag;

	mov	eax, DWORD PTR _this$1$[esp+32]

; 45   : 	ICF SelfRef	div(T s)								{ x/=s;		y/=s;    z/=s;				return *this;	};

	fstp	DWORD PTR tv766[esp+32]
	movss	xmm5, DWORD PTR tv766[esp+32]
	movaps	xmm3, xmm5
	movaps	xmm4, xmm5
	mulss	xmm3, DWORD PTR _N$$sroa$527$1$[esp+32]
	mulss	xmm4, DWORD PTR _N$$sroa$581$1$[esp+32]
	mulss	xmm5, DWORD PTR _N$$sroa$583$1$[esp+32]

; 214  : 		T mag=_sqrt(1/(v.x*v.x + v.y*v.y + v.z*v.z));

	movaps	xmm0, xmm3
	mulss	xmm0, xmm3
; File I:\Vitalya\mine\NSProjectX\xrCore\_plane.h

; 41   : 		d			= - n.normalize(_n).dotproduct(_p);

	movaps	xmm1, xmm4
	mulss	xmm1, xmm4
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 214  : 		T mag=_sqrt(1/(v.x*v.x + v.y*v.y + v.z*v.z));

	addss	xmm1, xmm0
	movaps	xmm0, xmm5
	mulss	xmm0, xmm5
	addss	xmm1, xmm0
	movss	xmm0, DWORD PTR __real@3f800000
	divss	xmm0, xmm1
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h

; 764  :             return (float)sqrt(_X);

	sqrtss	xmm2, xmm0
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 214  : 		T mag=_sqrt(1/(v.x*v.x + v.y*v.y + v.z*v.z));

	movaps	xmm1, xmm2

; 215  : 		x = v.x*mag;

	movaps	xmm0, xmm2
	mulss	xmm0, xmm4
	mulss	xmm1, xmm3

; 216  : 		y = v.y*mag;

	movss	DWORD PTR [eax+116], xmm0
	mulss	xmm2, xmm5
	movss	DWORD PTR [eax+112], xmm1

; 217  : 		z = v.z*mag;

	movss	DWORD PTR [eax+120], xmm2

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	mulss	xmm0, DWORD PTR [edi+4]
	mulss	xmm1, DWORD PTR [edi]
	mulss	xmm2, DWORD PTR [edi+8]
	addss	xmm0, xmm1
	addss	xmm0, xmm2
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
; File I:\Vitalya\mine\NSProjectX\xrCore\_plane.h

; 41   : 		d			= - n.normalize(_n).dotproduct(_p);

	movss	DWORD PTR [eax+124], xmm0
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__sector.cpp

; 96   : 	FPU::m24r	();

	call	DWORD PTR __imp_?m24r@FPU@@YAXXZ

; 97   : 
; 98   : 	/*
; 99   : 	if (_abs(1-P.n.magnitude())<EPS)
; 100  : 	Debug.fatal		(DEBUG_INFO,"Degenerated portal found at {%3.2f,%3.2f,%3.2f}.",VPUSH(poly[0]));
; 101  : 	*/
; 102  : }

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?Setup@CPortal@@QAEXPAU?$_vector3@M@@HPAVCSector@@1@Z ENDP ; CPortal::Setup
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__sector.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__sector.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__sector.cpp
_TEXT	SEGMENT
??1CSector@@UAE@XZ PROC					; CSector::~CSector
; _this$ = ecx

; 106  : {

	push	esi
	mov	esi, ecx
	push	edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	edi, DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__sector.cpp

; 106  : {

	mov	DWORD PTR [esi], OFFSET ??_7CSector@@6B@
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [esi+32]
	test	eax, eax
	je	SHORT $LN8@CSector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi+32], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+36], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+40], 0
$LN8@CSector:

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [esi+20]
	test	eax, eax
	je	SHORT $LN20@CSector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi+20], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+24], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+28], 0
$LN20@CSector:

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [esi+8]
	test	eax, eax
	je	SHORT $LN41@CSector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi+8], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+12], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+16], 0
$LN41@CSector:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__sector.cpp

; 107  : }

	mov	eax, DWORD PTR __imp_??_7IRender_Sector@@6B@
	pop	edi
	mov	DWORD PTR [esi], eax
	pop	esi
	ret	0
??1CSector@@UAE@XZ ENDP					; CSector::~CSector
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__sector.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__sector.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__sector.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__sector.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\FixedVector.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__sector.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__sector.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__sector.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_plane.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_plane.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__sector.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__sector.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__sector.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__sector.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__sector.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__sector.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__sector.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__sector.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\FixedVector.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__sector.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\FixedVector.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__sector.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector2.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__sector.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector2.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__sector.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector2.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__sector.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector2.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__sector.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector4.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__sector.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector4.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__sector.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector4.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__sector.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__sector.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__sector.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__sector.cpp
_TEXT	SEGMENT
_P$1$ = -1480						; size = 4
_pSector$1$ = -1476					; size = 4
_this$1$ = -1472					; size = 4
_ssa$1$ = -1468						; size = 4
_depth$3 = -1468					; size = 4
_I$1$ = -1464						; size = 4
$T4 = -1464						; size = 4
_scissor$5 = -1460					; size = 20
_scissor$2$ = -1440					; size = 4
_scissor$1$ = -1436					; size = 4
_scissor$3$ = -1432					; size = 4
_scissor$4$ = -1428					; size = 4
$T6 = -1424						; size = 8
_Clip$7 = -1416						; size = 244
_S$ = -1168						; size = 580
_D$ = -584						; size = 580
_F$ = 8							; size = 4
_R_scissor$ = 12					; size = 4
?traverse@CSector@@QAEXAAVCFrustum@@AAU_scissor@@@Z PROC ; CSector::traverse
; _this$ = ecx

; 114  : {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	sub	esp, 1480				; 000005c8H

; 115  : 	// Register traversal process
; 116  : 	if (r_marker	!=	PortalTraverser.i_marker)	{

	mov	eax, DWORD PTR ?PortalTraverser@@3VCPortalTraverser@@A
	push	esi
	push	edi
	mov	edi, ecx
	mov	DWORD PTR _this$1$[esp+1488], edi
	cmp	DWORD PTR [edi+64], eax
	je	SHORT $LN382@traverse

; 117  : 		r_marker							=	PortalTraverser.i_marker;

	mov	DWORD PTR [edi+64], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 730  :         if (_Mylast != _My_data._Myend) {

	mov	eax, DWORD PTR ?PortalTraverser@@3VCPortalTraverser@@A+156
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__sector.cpp

; 118  : 		PortalTraverser.r_sectors.push_back	(this);

	mov	DWORD PTR $T4[esp+1488], edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 730  :         if (_Mylast != _My_data._Myend) {

	cmp	eax, DWORD PTR ?PortalTraverser@@3VCPortalTraverser@@A+160
	je	SHORT $LN47@traverse

; 713  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

	mov	DWORD PTR [eax], edi

; 716  :         ++_Mylast;

	add	DWORD PTR ?PortalTraverser@@3VCPortalTraverser@@A+156, 4

; 731  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

	jmp	SHORT $LN46@traverse
$LN47@traverse:

; 732  :         }
; 733  : 
; 734  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	lea	ecx, DWORD PTR $T4[esp+1488]
	push	ecx
	push	eax
	mov	ecx, OFFSET ?PortalTraverser@@3VCPortalTraverser@@A+152
	call	??$_Emplace_reallocate@PAVIRender_Sector@@@?$vector@PAVIRender_Sector@@V?$xalloc@PAVIRender_Sector@@@@@std@@QAEPAPAVIRender_Sector@@QAPAV2@$$QAPAV2@@Z ; std::vector<IRender_Sector *,xalloc<IRender_Sector *> >::_Emplace_reallocate<IRender_Sector *>
$LN46@traverse:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__sector.cpp

; 119  : 		r_frustums.clear					();

	mov	eax, DWORD PTR [edi+20]
	mov	DWORD PTR [edi+24], eax

; 120  : 		r_scissors.clear					();

	mov	eax, DWORD PTR [edi+32]
	mov	DWORD PTR [edi+36], eax
$LN382@traverse:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 730  :         if (_Mylast != _My_data._Myend) {

	mov	edx, DWORD PTR [edi+24]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__sector.cpp

; 122  : 	r_frustums.push_back		(F);

	lea	eax, DWORD PTR [edi+20]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 730  :         if (_Mylast != _My_data._Myend) {

	cmp	edx, DWORD PTR [eax+8]
	je	SHORT $LN54@traverse
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	esi, DWORD PTR _F$[ebp]
	mov	ecx, 61					; 0000003dH
	mov	edi, edx
	rep movsd
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 716  :         ++_Mylast;

	add	DWORD PTR [eax+4], 244			; 000000f4H

; 731  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

	mov	edi, DWORD PTR _this$1$[esp+1488]
	jmp	SHORT $LN53@traverse
$LN54@traverse:

; 732  :         }
; 733  : 
; 734  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	push	DWORD PTR _F$[ebp]
	mov	ecx, eax
	push	edx
	call	??$_Emplace_reallocate@ABVCFrustum@@@?$vector@VCFrustum@@V?$xalloc@VCFrustum@@@@@std@@QAEPAVCFrustum@@QAV2@ABV2@@Z ; std::vector<CFrustum,xalloc<CFrustum> >::_Emplace_reallocate<CFrustum const &>
$LN53@traverse:

; 730  :         if (_Mylast != _My_data._Myend) {

	mov	edx, DWORD PTR [edi+36]
	mov	ecx, DWORD PTR _R_scissor$[ebp]
	cmp	edx, DWORD PTR [edi+40]
	je	SHORT $LN65@traverse
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], eax
	mov	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+8], eax
	mov	eax, DWORD PTR [ecx+12]
	mov	DWORD PTR [edx+12], eax
	mov	eax, DWORD PTR [ecx+16]
	mov	DWORD PTR [edx+16], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 716  :         ++_Mylast;

	add	DWORD PTR [edi+36], 20			; 00000014H

; 731  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

	jmp	SHORT $LN64@traverse
$LN65@traverse:

; 732  :         }
; 733  : 
; 734  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	push	ecx
	push	edx
	lea	ecx, DWORD PTR [edi+32]
	call	??$_Emplace_reallocate@ABU_scissor@@@?$vector@U_scissor@@V?$xalloc@U_scissor@@@@@std@@QAEPAU_scissor@@QAU2@ABU2@@Z ; std::vector<_scissor,xalloc<_scissor> >::_Emplace_reallocate<_scissor const &>
$LN64@traverse:

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	eax, DWORD PTR [edi+12]
	mov	ecx, DWORD PTR [edi+8]
	sub	eax, ecx
	sar	eax, 2
; File I:\Vitalya\mine\NSProjectX\xrCore\FixedVector.h

; 21   : 	svector() : count(0) 

	mov	DWORD PTR _S$[esp+2064], 0
	mov	DWORD PTR _D$[esp+2064], 0
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__sector.cpp

; 127  : 	for	(u32 I=0; I<m_portals.size(); I++)

	mov	DWORD PTR _I$1$[esp+1488], 0
	test	eax, eax
	je	$LN3@traverse
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1535 :         auto& _My_data = _Mypair._Myval2;

	xor	edi, edi
	npad	14
$LL4@traverse:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__sector.cpp

; 129  : 		if (m_portals[I]->marker == PortalTraverser.i_marker) continue;

	mov	edi, DWORD PTR [ecx+edi*4]
	mov	eax, DWORD PTR [edi+144]
	cmp	eax, DWORD PTR ?PortalTraverser@@3VCPortalTraverser@@A
	je	$LN2@traverse

; 130  : 
; 131  : 		CPortal* PORTAL = m_portals[I];
; 132  : 		CSector* pSector;
; 133  : 
; 134  : 		// Select sector (allow intersecting portals to be finely classified)
; 135  : 		if (PORTAL->bDualRender) {

	cmp	DWORD PTR [edi+148], 0
	je	SHORT $LN10@traverse
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__sector.h

; 37   : 	CSector*						getSector		(CSector* pFrom)	{ return pFrom==pFace?pBack:pFace; }

	mov	eax, DWORD PTR [edi+104]
	mov	DWORD PTR _pSector$1$[esp+1488], eax
	cmp	DWORD PTR _this$1$[esp+1488], eax
	jne	SHORT $LN13@traverse
	mov	eax, DWORD PTR [edi+108]
	mov	DWORD PTR _pSector$1$[esp+1488], eax
	jmp	SHORT $LN13@traverse
$LN10@traverse:
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	movss	xmm0, DWORD PTR [edi+112]
	mulss	xmm0, DWORD PTR ?PortalTraverser@@3VCPortalTraverser@@A+8
	movss	xmm1, DWORD PTR [edi+116]
	mulss	xmm1, DWORD PTR ?PortalTraverser@@3VCPortalTraverser@@A+12
; File I:\Vitalya\mine\NSProjectX\xrCore\_plane.h

; 57   : 		return n.dotproduct(v)+d;

	addss	xmm1, xmm0
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	movss	xmm0, DWORD PTR [edi+120]
	mulss	xmm0, DWORD PTR ?PortalTraverser@@3VCPortalTraverser@@A+16
; File I:\Vitalya\mine\NSProjectX\xrCore\_plane.h

; 57   : 		return n.dotproduct(v)+d;

	addss	xmm0, DWORD PTR [edi+124]
	addss	xmm1, xmm0
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__sector.h

; 39   : 	CSector*						getSectorBack	(const Fvector& V)	{ if (P.classify(V)>0) return pBack; else return pFace;	}

	comiss	xmm1, DWORD PTR __real@00000000
	jbe	SHORT $LN120@traverse
	mov	eax, DWORD PTR [edi+108]
	jmp	SHORT $LN391@traverse
$LN120@traverse:
	mov	eax, DWORD PTR [edi+104]
$LN391@traverse:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__sector.cpp

; 139  : 			if (pSector==this)								continue;

	mov	DWORD PTR _pSector$1$[esp+1488], eax
	cmp	eax, DWORD PTR _this$1$[esp+1488]
	je	$LN2@traverse

; 140  : 			if (pSector==PortalTraverser.i_start)			continue;

	cmp	eax, DWORD PTR ?PortalTraverser@@3VCPortalTraverser@@A+148
	je	$LN2@traverse
$LN13@traverse:

; 141  : 		}
; 142  : 
; 143  : 		// Early-out sphere
; 144  : 		if (!F.testSphere_dirty(PORTAL->S.P,PORTAL->S.R))	continue;

	fld	DWORD PTR [edi+140]
	lea	esi, DWORD PTR [edi+128]
	push	ecx
	mov	ecx, DWORD PTR _F$[ebp]
	fstp	DWORD PTR [esp]
	push	esi
	call	DWORD PTR __imp_?testSphere_dirty@CFrustum@@QBEHAAU?$_vector3@M@@M@Z
	test	eax, eax
	je	$LN2@traverse

; 145  : 
; 146  : 		// SSA	(if required)
; 147  : 		if (PortalTraverser.i_options&CPortalTraverser::VQ_SSA)

	mov	eax, DWORD PTR ?PortalTraverser@@3VCPortalTraverser@@A+4
	test	al, 2
	je	$LN19@traverse
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	xmm5, DWORD PTR [esi]
	movss	xmm2, DWORD PTR [esi+4]
	subss	xmm5, DWORD PTR ?PortalTraverser@@3VCPortalTraverser@@A+8
	subss	xmm2, DWORD PTR ?PortalTraverser@@3VCPortalTraverser@@A+12
	movss	xmm3, DWORD PTR [esi+8]
	subss	xmm3, DWORD PTR ?PortalTraverser@@3VCPortalTraverser@@A+16

; 45   : 	ICF SelfRef	div(T s)								{ x/=s;		y/=s;    z/=s;				return *this;	};

	movss	xmm1, DWORD PTR __real@3f800000

; 167  : 		return x*x + y*y + z*z;

	movaps	xmm0, xmm5
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__sector.cpp

; 151  : 			float R				=	PORTAL->S.R	;

	movss	xmm6, DWORD PTR [edi+140]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 167  : 		return x*x + y*y + z*z;

	mulss	xmm0, xmm5
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__sector.cpp

; 151  : 			float R				=	PORTAL->S.R	;

	movaps	xmm4, xmm2
	mulss	xmm4, xmm2

; 153  : 			float ssa			=	R*R/distSQ;

	mulss	xmm6, xmm6
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 167  : 		return x*x + y*y + z*z;

	addss	xmm4, xmm0
	movaps	xmm0, xmm3
	mulss	xmm0, xmm3
	addss	xmm4, xmm0
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h

; 764  :             return (float)sqrt(_X);

	sqrtss	xmm0, xmm4
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__sector.cpp

; 153  : 			float ssa			=	R*R/distSQ;

	divss	xmm6, xmm4
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 45   : 	ICF SelfRef	div(T s)								{ x/=s;		y/=s;    z/=s;				return *this;	};

	divss	xmm1, xmm0
	movaps	xmm0, xmm1
	movaps	xmm7, xmm1
	mulss	xmm7, xmm2
	mulss	xmm0, xmm5

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	mulss	xmm7, DWORD PTR [edi+116]
	mulss	xmm0, DWORD PTR [edi+112]

; 45   : 	ICF SelfRef	div(T s)								{ x/=s;		y/=s;    z/=s;				return *this;	};

	mulss	xmm1, xmm3

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	addss	xmm7, xmm0
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__sector.cpp

; 156  : 			if (ssa<r_ssaDISCARD)	continue;

	movss	xmm0, DWORD PTR ?r_ssaDISCARD@@3MA
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	mulss	xmm1, DWORD PTR [edi+120]
	addss	xmm7, xmm1
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h

; 676  :             return (float)fabs(_X);

	andps	xmm7, DWORD PTR __xmm@7fffffff7fffffff7fffffff7fffffff
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__sector.cpp

; 155  : 			ssa					*=	_abs(PORTAL->P.n.dotproduct(dir2portal));

	mulss	xmm7, xmm6

; 156  : 			if (ssa<r_ssaDISCARD)	continue;

	comiss	xmm0, xmm7
	movss	DWORD PTR _ssa$1$[esp+1488], xmm7
	ja	$LN2@traverse

; 157  : 
; 158  : 			if (PortalTraverser.i_options&CPortalTraverser::VQ_FADE)	{

	test	al, 8
	je	SHORT $LN19@traverse

; 159  : 				if (ssa<r_ssaLOD_A)	PortalTraverser.fade_portal			(PORTAL,ssa);

	movss	xmm0, DWORD PTR ?r_ssaLOD_A@@3MA
	comiss	xmm0, xmm7
	jbe	SHORT $LN151@traverse
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 730  :         if (_Mylast != _My_data._Myend) {

	mov	ecx, DWORD PTR ?PortalTraverser@@3VCPortalTraverser@@A+168
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 186  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

	mov	DWORD PTR $T6[esp+1488], edi
	movss	DWORD PTR $T6[esp+1492], xmm7
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 730  :         if (_Mylast != _My_data._Myend) {

	cmp	ecx, DWORD PTR ?PortalTraverser@@3VCPortalTraverser@@A+172
	je	SHORT $LN152@traverse

; 713  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

	mov	eax, DWORD PTR $T6[esp+1492]
	mov	DWORD PTR [ecx], edi
	mov	DWORD PTR [ecx+4], eax

; 716  :         ++_Mylast;

	add	DWORD PTR ?PortalTraverser@@3VCPortalTraverser@@A+168, 8

; 731  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

	jmp	SHORT $LN151@traverse
$LN152@traverse:

; 732  :         }
; 733  : 
; 734  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	lea	eax, DWORD PTR $T6[esp+1488]
	push	eax
	push	ecx
	mov	ecx, OFFSET ?PortalTraverser@@3VCPortalTraverser@@A+164
	call	??$_Emplace_reallocate@U?$pair@PAVCPortal@@M@std@@@?$vector@U?$pair@PAVCPortal@@M@std@@V?$xalloc@U?$pair@PAVCPortal@@M@std@@@@@std@@QAEPAU?$pair@PAVCPortal@@M@1@QAU21@$$QAU21@@Z ; std::vector<std::pair<CPortal *,float>,xalloc<std::pair<CPortal *,float> > >::_Emplace_reallocate<std::pair<CPortal *,float> >
	movss	xmm7, DWORD PTR _ssa$1$[esp+1488]
$LN151@traverse:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__sector.cpp

; 160  : 				if (ssa<r_ssaLOD_B)	continue							;

	movss	xmm0, DWORD PTR ?r_ssaLOD_B@@3MA
	comiss	xmm0, xmm7
	ja	$LN2@traverse
$LN19@traverse:

; 166  : 		S.assign			(&*POLY.begin(),POLY.size()); D.clear();

	mov	esi, DWORD PTR [edi+100]
	lea	ecx, DWORD PTR [edi+4]
; File I:\Vitalya\mine\NSProjectX\xrCore\FixedVector.h

; 65   : 	IC void		assign(iterator p, int c) { VERIFY(c>0 && c<dim); CopyMemory(array,p,c*sizeof(value_type)); count=c; }

	lea	eax, DWORD PTR [esi+esi*2]
	shl	eax, 2
	push	eax
	push	ecx
	lea	eax, DWORD PTR _S$[esp+1496]
	push	eax
	call	_memcpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__sector.cpp

; 167  : 		sPoly* P			= F.ClipPoly(S,D);

	mov	ecx, DWORD PTR _F$[ebp]
	lea	eax, DWORD PTR _D$[esp+1500]
; File I:\Vitalya\mine\NSProjectX\xrCore\FixedVector.h

; 65   : 	IC void		assign(iterator p, int c) { VERIFY(c>0 && c<dim); CopyMemory(array,p,c*sizeof(value_type)); count=c; }

	add	esp, 12					; 0000000cH
	mov	DWORD PTR _S$[esp+2064], esi
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__sector.cpp

; 166  : 		S.assign			(&*POLY.begin(),POLY.size()); D.clear();

	mov	DWORD PTR _D$[esp+2064], 0

; 167  : 		sPoly* P			= F.ClipPoly(S,D);

	push	eax
	lea	eax, DWORD PTR _S$[esp+1492]
	push	eax
	call	DWORD PTR __imp_?ClipPoly@CFrustum@@QBEPAV?$svector@U?$_vector3@M@@$0DA@@@AAV2@0@Z
	mov	DWORD PTR _P$1$[esp+1488], eax

; 168  : 		if (0==P)			continue;

	test	eax, eax
	je	$LN2@traverse

; 169  : 
; 170  : 		// Scissor and optimized HOM-testing
; 171  : 		_scissor			scissor	;
; 172  : 		if (PortalTraverser.i_options&CPortalTraverser::VQ_SCISSOR && (!PORTAL->bDualRender))

	mov	edx, DWORD PTR ?PortalTraverser@@3VCPortalTraverser@@A+4
	test	dl, 4
	je	$LN21@traverse
	cmp	DWORD PTR [edi+148], 0
	jne	$LN21@traverse
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector2.h

; 15   : 	IC SelfRef set(float _u, float _v)				{ x=T(_u); y=T(_v);				return *this;	}

	movss	xmm5, DWORD PTR __real@7f7fffff
	movss	xmm2, DWORD PTR __real@ff7fffff
	movaps	xmm4, xmm5
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__sector.cpp

; 177  : 			for		(u32 vit=0; vit<p.size(); vit++)	{

	mov	ecx, DWORD PTR [eax+576]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector2.h

; 15   : 	IC SelfRef set(float _u, float _v)				{ x=T(_u); y=T(_v);				return *this;	}

	movaps	xmm0, xmm5
	movss	DWORD PTR _scissor$1$[esp+1488], xmm4
	movaps	xmm1, xmm2
	movss	DWORD PTR _scissor$4$[esp+1488], xmm0
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__sector.cpp

; 175  : 			Fbox2	bb;	bb.invalidate(); float depth = flt_max;

	movaps	xmm7, xmm5
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector2.h

; 15   : 	IC SelfRef set(float _u, float _v)				{ x=T(_u); y=T(_v);				return *this;	}

	movss	DWORD PTR _scissor$3$[esp+1488], xmm2
	movss	DWORD PTR _scissor$2$[esp+1488], xmm1
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__sector.cpp

; 175  : 			Fbox2	bb;	bb.invalidate(); float depth = flt_max;

	movss	DWORD PTR _depth$3[esp+1488], xmm7

; 177  : 			for		(u32 vit=0; vit<p.size(); vit++)	{

	test	ecx, ecx
	je	$LN28@traverse
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector2.h

; 15   : 	IC SelfRef set(float _u, float _v)				{ x=T(_u); y=T(_v);				return *this;	}

	add	eax, 8
	npad	2
$LL7@traverse:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__sector.cpp

; 182  : 				t.x = v.x*M._11 + v.y*M._21 + v.z*M._31 + M._41;

	movss	xmm4, DWORD PTR [eax-4]
	movss	xmm6, DWORD PTR [eax-8]

; 185  : 				t.w = v.x*M._14 + v.y*M._24 + v.z*M._34 + M._44;

	movaps	xmm0, xmm4
	mulss	xmm0, DWORD PTR ?PortalTraverser@@3VCPortalTraverser@@A+112
	movaps	xmm1, xmm6
	mulss	xmm1, DWORD PTR ?PortalTraverser@@3VCPortalTraverser@@A+96
	movaps	xmm5, xmm6
	movss	xmm3, DWORD PTR [eax]
	mulss	xmm5, DWORD PTR ?PortalTraverser@@3VCPortalTraverser@@A+84
	addss	xmm1, xmm0
	movss	xmm2, DWORD PTR __real@3f800000
	movaps	xmm0, xmm3
	mulss	xmm0, DWORD PTR ?PortalTraverser@@3VCPortalTraverser@@A+128
	addss	xmm1, xmm0
	movaps	xmm0, xmm4
	mulss	xmm0, DWORD PTR ?PortalTraverser@@3VCPortalTraverser@@A+100
	addss	xmm1, DWORD PTR ?PortalTraverser@@3VCPortalTraverser@@A+144
	addss	xmm5, xmm0
	movaps	xmm0, xmm3
	mulss	xmm0, DWORD PTR ?PortalTraverser@@3VCPortalTraverser@@A+116
	divss	xmm2, xmm1
	addss	xmm5, xmm0
	movaps	xmm1, xmm6
	mulss	xmm1, DWORD PTR ?PortalTraverser@@3VCPortalTraverser@@A+88
	movaps	xmm0, xmm4
	mulss	xmm0, DWORD PTR ?PortalTraverser@@3VCPortalTraverser@@A+104
	mulss	xmm6, DWORD PTR ?PortalTraverser@@3VCPortalTraverser@@A+92
	mulss	xmm4, DWORD PTR ?PortalTraverser@@3VCPortalTraverser@@A+108
	addss	xmm1, xmm0
	addss	xmm5, DWORD PTR ?PortalTraverser@@3VCPortalTraverser@@A+132
	movaps	xmm0, xmm3
	mulss	xmm3, DWORD PTR ?PortalTraverser@@3VCPortalTraverser@@A+124
	mulss	xmm0, DWORD PTR ?PortalTraverser@@3VCPortalTraverser@@A+120
	addss	xmm6, xmm4
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector4.h

; 33   : 	IC  SelfRef		mul(T s)							{ x*=s;		y*=s;		z*=s;		w*=s;		return *this; }

	movss	xmm4, DWORD PTR _scissor$1$[esp+1488]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__sector.cpp

; 186  : 				t.mul	(1.f/t.w);

	mulss	xmm5, xmm2
	addss	xmm1, xmm0
	addss	xmm6, xmm3
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector4.h

; 33   : 	IC  SelfRef		mul(T s)							{ x*=s;		y*=s;		z*=s;		w*=s;		return *this; }

	comiss	xmm4, xmm5
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__sector.cpp

; 183  : 				t.y = v.x*M._12 + v.y*M._22 + v.z*M._32 + M._42;

	addss	xmm1, DWORD PTR ?PortalTraverser@@3VCPortalTraverser@@A+136

; 184  : 				t.z = v.x*M._13 + v.y*M._23 + v.z*M._33 + M._43;

	addss	xmm6, DWORD PTR ?PortalTraverser@@3VCPortalTraverser@@A+140
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector4.h

; 33   : 	IC  SelfRef		mul(T s)							{ x*=s;		y*=s;		z*=s;		w*=s;		return *this; }

	mulss	xmm1, xmm2
	mulss	xmm6, xmm2
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__sector.cpp

; 188  : 				if (t.x < bb.min.x)	bb.min.x	= t.x; 

	jbe	SHORT $LN23@traverse
	movaps	xmm4, xmm5
	movss	DWORD PTR _scissor$1$[esp+1488], xmm4
$LN23@traverse:

; 189  : 				if (t.x > bb.max.x) bb.max.x	= t.x;

	movss	xmm2, DWORD PTR _scissor$3$[esp+1488]
	comiss	xmm5, xmm2
	jbe	SHORT $LN24@traverse
	movaps	xmm2, xmm5
	movss	DWORD PTR _scissor$3$[esp+1488], xmm2
$LN24@traverse:

; 190  : 				if (t.y < bb.min.y)	bb.min.y	= t.y; 

	movss	xmm0, DWORD PTR _scissor$4$[esp+1488]
	comiss	xmm0, xmm1
	jbe	SHORT $LN25@traverse
	movaps	xmm0, xmm1
	movss	DWORD PTR _scissor$4$[esp+1488], xmm0
$LN25@traverse:

; 191  : 				if (t.y > bb.max.y) bb.max.y	= t.y;

	comiss	xmm1, DWORD PTR _scissor$2$[esp+1488]
	jbe	SHORT $LN386@traverse
	movss	DWORD PTR _scissor$2$[esp+1488], xmm1
	jmp	SHORT $LN26@traverse
$LN386@traverse:
	movss	xmm1, DWORD PTR _scissor$2$[esp+1488]
$LN26@traverse:

; 192  : 				if (t.z < depth)	depth		= t.z;

	comiss	xmm7, xmm6
	jbe	SHORT $LN5@traverse
	movaps	xmm7, xmm6
$LN5@traverse:

; 177  : 			for		(u32 vit=0; vit<p.size(); vit++)	{

	add	eax, 12					; 0000000cH
	sub	ecx, 1
	jne	$LL7@traverse

; 193  : 			}
; 194  : 			// Msg	("bb(%s): (%f,%f)-(%f,%f), d=%f", PORTAL->bDualRender?"true":"false",bb.min.x, bb.min.y, bb.max.x, bb.max.y,depth);
; 195  : 			if (depth<EPS)	{

	movss	xmm3, DWORD PTR __real@3727c5ac
	comiss	xmm3, xmm7
	movss	DWORD PTR _depth$3[esp+1488], xmm7
	jbe	SHORT $LN28@traverse

; 196  : 				scissor	= R_scissor;

	mov	esi, DWORD PTR _R_scissor$[ebp]
	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR _scissor$5[esp+1488], eax
	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR _scissor$5[esp+1492], eax
	mov	eax, DWORD PTR [esi+8]
	mov	DWORD PTR _scissor$5[esp+1496], eax
	mov	eax, DWORD PTR [esi+12]
	mov	DWORD PTR _scissor$5[esp+1500], eax
	mov	eax, DWORD PTR [esi+16]

; 197  : 
; 198  : 				// Cull by HOM (slower algo)
; 199  : 				if  (
; 200  : 					(PortalTraverser.i_options&CPortalTraverser::VQ_HOM) && 

	mov	esi, DWORD PTR _P$1$[esp+1488]
	mov	DWORD PTR _scissor$5[esp+1504], eax
	test	dl, 1
	je	$LN42@traverse
$LN396@traverse:

; 228  : 				(!RImplementation.HOM.visible(*P))
; 229  : 				)	continue;
; 230  : 		}
; 231  : 
; 232  : 		// Create _new_ frustum and recurse
; 233  : 		CFrustum				Clip;
; 234  : 		Clip.CreateFromPortal	(P, PORTAL->P.n, PortalTraverser.i_vBase,PortalTraverser.i_mXFORM);

	push	esi
	mov	ecx, OFFSET ?RImplementation@@3VCRender@@A+712
	call	?visible@CHOM@@QAEHAAV?$svector@U?$_vector3@M@@$0DA@@@@Z ; CHOM::visible
	test	eax, eax
	je	$LN2@traverse
	jmp	$LN42@traverse
$LN28@traverse:

; 201  : 					(!RImplementation.HOM.visible(*P))
; 202  : 					)	continue;
; 203  : 			} else {
; 204  : 				// perform intersection (this is just to be sure, it is probably clipped in 3D already)
; 205  : 				if (bb.min.x > R_scissor.min.x)	scissor.min.x = bb.min.x; else scissor.min.x = R_scissor.min.x;

	mov	esi, DWORD PTR _R_scissor$[ebp]
	movss	xmm3, DWORD PTR [esi]
	comiss	xmm4, xmm3
	ja	SHORT $LN392@traverse
	movaps	xmm4, xmm3
$LN392@traverse:

; 206  : 				if (bb.min.y > R_scissor.min.y)	scissor.min.y = bb.min.y; else scissor.min.y = R_scissor.min.y;

	movss	xmm3, DWORD PTR [esi+4]
	comiss	xmm0, xmm3
	movss	DWORD PTR _scissor$5[esp+1488], xmm4
	ja	SHORT $LN393@traverse
	movaps	xmm0, xmm3
$LN393@traverse:

; 207  : 				if (bb.max.x < R_scissor.max.x) scissor.max.x = bb.max.x; else scissor.max.x = R_scissor.max.x;

	movss	xmm3, DWORD PTR [esi+8]
	comiss	xmm3, xmm2
	movss	DWORD PTR _scissor$5[esp+1492], xmm0
	ja	SHORT $LN394@traverse
	movaps	xmm2, xmm3
$LN394@traverse:

; 208  : 				if (bb.max.y < R_scissor.max.y) scissor.max.y = bb.max.y; else scissor.max.y = R_scissor.max.y;

	movss	xmm3, DWORD PTR [esi+12]
	comiss	xmm3, xmm1
	movss	DWORD PTR _scissor$5[esp+1496], xmm2
	ja	SHORT $LN395@traverse
	movaps	xmm1, xmm3
$LN395@traverse:

; 209  : 				scissor.depth	= depth;
; 210  : 
; 211  : 				// Msg	("scissor: (%f,%f)-(%f,%f)", scissor.min.x, scissor.min.y, scissor.max.x, scissor.max.y);
; 212  : 				// Check if box is non-empty
; 213  : 				if (scissor.min.x >= scissor.max.x)	continue;

	comiss	xmm4, xmm2
	movss	DWORD PTR _scissor$5[esp+1500], xmm1
	movss	DWORD PTR _scissor$5[esp+1504], xmm7
	jae	$LN2@traverse

; 214  : 				if (scissor.min.y >= scissor.max.y)	continue;

	comiss	xmm0, xmm1
	jae	$LN2@traverse

; 218  : 					(PortalTraverser.i_options&CPortalTraverser::VQ_HOM) && 

	test	dl, 1
	je	SHORT $LN390@traverse
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp

; 282  : 	if (!bEnabled)		return TRUE;

	cmp	DWORD PTR ?RImplementation@@3VCRender@@A+744, 0
	je	SHORT $LN390@traverse

; 283  : 	return Raster.test	(B.min.x,B.min.y,B.max.x,B.max.y,depth);

	fld	DWORD PTR _depth$3[esp+1488]
	sub	esp, 20					; 00000014H
	fstp	DWORD PTR [esp+16]
	fld	DWORD PTR _scissor$5[esp+1520]
	fstp	DWORD PTR [esp+12]
	fld	DWORD PTR _scissor$5[esp+1516]
	fstp	DWORD PTR [esp+8]
	fld	DWORD PTR _scissor$5[esp+1512]
	fstp	DWORD PTR [esp+4]
	fld	DWORD PTR _scissor$5[esp+1508]
	fstp	DWORD PTR [esp]
	call	?test@occRasterizer@@QAEHMMMMM@Z	; occRasterizer::test
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__sector.cpp

; 218  : 					(PortalTraverser.i_options&CPortalTraverser::VQ_HOM) && 

	test	eax, eax
	je	SHORT $LN2@traverse
$LN390@traverse:

; 228  : 				(!RImplementation.HOM.visible(*P))
; 229  : 				)	continue;
; 230  : 		}
; 231  : 
; 232  : 		// Create _new_ frustum and recurse
; 233  : 		CFrustum				Clip;
; 234  : 		Clip.CreateFromPortal	(P, PORTAL->P.n, PortalTraverser.i_vBase,PortalTraverser.i_mXFORM);

	mov	esi, DWORD PTR _P$1$[esp+1488]
$LN42@traverse:
	push	OFFSET ?PortalTraverser@@3VCPortalTraverser@@A+20
	push	OFFSET ?PortalTraverser@@3VCPortalTraverser@@A+8
	lea	eax, DWORD PTR [edi+112]
	push	eax
	push	esi
	lea	ecx, DWORD PTR _Clip$7[esp+1504]
	call	DWORD PTR __imp_?CreateFromPortal@CFrustum@@QAEXPAV?$svector@U?$_vector3@M@@$0DA@@@AAU?$_vector3@M@@1AAU?$_matrix@M@@@Z

; 235  : 		PORTAL->marker			= PortalTraverser.i_marker;

	mov	eax, DWORD PTR ?PortalTraverser@@3VCPortalTraverser@@A

; 236  : 		PORTAL->bDualRender		= FALSE;
; 237  : 		pSector->traverse		(Clip,scissor);

	mov	ecx, DWORD PTR _pSector$1$[esp+1488]
	mov	DWORD PTR [edi+144], eax
	lea	eax, DWORD PTR _scissor$5[esp+1488]
	push	eax
	lea	eax, DWORD PTR _Clip$7[esp+1492]
	mov	DWORD PTR [edi+148], 0
	push	eax
	call	?traverse@CSector@@QAEXAAVCFrustum@@AAU_scissor@@@Z ; CSector::traverse
$LN2@traverse:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	eax, DWORD PTR _this$1$[esp+1488]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__sector.cpp

; 127  : 	for	(u32 I=0; I<m_portals.size(); I++)

	mov	edi, DWORD PTR _I$1$[esp+1488]
	inc	edi
	mov	DWORD PTR _I$1$[esp+1488], edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	ecx, DWORD PTR [eax+8]
	mov	eax, DWORD PTR [eax+12]
	sub	eax, ecx
	sar	eax, 2
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__sector.cpp

; 127  : 	for	(u32 I=0; I<m_portals.size(); I++)

	cmp	edi, eax
	jb	$LL4@traverse
$LN3@traverse:

; 238  : 	}
; 239  : }

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	8
$LN21@traverse:

; 219  : 					(!RImplementation.HOM.visible(scissor,depth))
; 220  : 					)	continue;
; 221  : 			}
; 222  : 		} else {
; 223  : 			scissor	= R_scissor;

	mov	ecx, DWORD PTR _R_scissor$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR _scissor$5[esp+1488], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR _scissor$5[esp+1492], eax
	mov	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR _scissor$5[esp+1496], eax
	mov	eax, DWORD PTR [ecx+12]
	mov	DWORD PTR _scissor$5[esp+1500], eax
	mov	eax, DWORD PTR [ecx+16]
	mov	DWORD PTR _scissor$5[esp+1504], eax

; 224  : 
; 225  : 			// Cull by HOM (slower algo)
; 226  : 			if  (
; 227  : 				(PortalTraverser.i_options&CPortalTraverser::VQ_HOM) && 

	test	dl, 1
	je	$LN390@traverse
	mov	esi, DWORD PTR _P$1$[esp+1488]

; 228  : 				(!RImplementation.HOM.visible(*P))
; 229  : 				)	continue;
; 230  : 		}
; 231  : 
; 232  : 		// Create _new_ frustum and recurse
; 233  : 		CFrustum				Clip;
; 234  : 		Clip.CreateFromPortal	(P, PORTAL->P.n, PortalTraverser.i_vBase,PortalTraverser.i_mXFORM);

	jmp	$LN396@traverse
?traverse@CSector@@QAEXAAVCFrustum@@AAU_scissor@@@Z ENDP ; CSector::traverse
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__sector.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__sector.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__sector.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__sector.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__sector.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__sector.cpp
_TEXT	SEGMENT
_P$1 = 8						; size = 4
_fs$ = 8						; size = 4
?load@CSector@@QAEXAAVIReader@@@Z PROC			; CSector::load
; _this$ = ecx

; 242  : {

	push	ebx

; 243  : 	// Assign portal polygons
; 244  : 	u32 size			= fs.find_chunk(fsP_Portals); R_ASSERT(0==(size&1));

	mov	ebx, DWORD PTR _fs$[esp]
	push	ebp
	push	esi
	push	edi
	push	0
	mov	ebp, ecx
	mov	ecx, ebx
	push	1
	call	DWORD PTR __imp_?find_chunk@?$IReaderBase@VIReader@@@@QAEIIPAH@Z
	cmp	BYTE PTR ?ignore_always@?3??load@CSector@@QAEXAAVIReader@@@Z@4_NA, 0
	mov	edi, eax
	jne	SHORT $LN2@load
	test	edi, 1
	je	SHORT $LN2@load
	mov	ecx, DWORD PTR __imp_?Debug@@3VxrDebug@@A
	push	OFFSET ?ignore_always@?3??load@CSector@@QAEXAAVIReader@@@Z@4_NA
	push	OFFSET ??_C@_0O@JCOHLFIM@CSector?3?3load@
	push	244					; 000000f4H
	push	OFFSET ??_C@_0DJ@FDLNFKJF@I?3?2Vitalya?2mine?2NSProjectX?2laye@
	push	OFFSET ??_C@_0M@PEPFIJMN@0?$DN?$DN?$CIsize?$CG1?$CJ@
	call	DWORD PTR __imp_?fail@xrDebug@@QAEXPBD0H0AA_N@Z
$LN2@load:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1546 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	eax, DWORD PTR [ebp+16]
	sub	eax, DWORD PTR [ebp+8]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__sector.cpp

; 245  : 	u32 count			= size/2;

	shr	edi, 1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1546 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	sar	eax, 2

; 1358 :         if (_Newcapacity > capacity()) { // something to do (reserve() never shrinks)

	cmp	edi, eax
	jbe	SHORT $LN73@load

; 1359 :             if (_Newcapacity > max_size()) {

	cmp	edi, 1073741823				; 3fffffffH
	ja	$LN79@load

; 1361 :             }
; 1362 : 
; 1363 :             _Reallocate_exactly(_Newcapacity);

	push	edi
	lea	ecx, DWORD PTR [ebp+8]
	call	?_Reallocate_exactly@?$vector@PAVCPortal@@V?$xalloc@PAVCPortal@@@@@std@@AAEXI@Z ; std::vector<CPortal *,xalloc<CPortal *> >::_Reallocate_exactly
$LN73@load:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__sector.cpp

; 247  : 	while (count) {

	test	edi, edi
	je	SHORT $LN6@load
$LL5@load:

; 248  : 		u16 ID		= fs.r_u16();

	mov	ecx, ebx
	call	DWORD PTR __imp_?r_u16@?$IReaderBase@VIReader@@@@QAEGXZ
	movzx	ecx, ax

; 249  : 		CPortal* P	= (CPortal*)RImplementation.getPortal	(ID);

	mov	eax, DWORD PTR ?RImplementation@@3VCRender@@A+660
	mov	ecx, DWORD PTR [eax+ecx*4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 730  :         if (_Mylast != _My_data._Myend) {

	mov	eax, DWORD PTR [ebp+12]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__sector.cpp

; 249  : 		CPortal* P	= (CPortal*)RImplementation.getPortal	(ID);

	mov	DWORD PTR _P$1[esp+12], ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 730  :         if (_Mylast != _My_data._Myend) {

	cmp	eax, DWORD PTR [ebp+16]
	je	SHORT $LN47@load

; 713  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

	mov	DWORD PTR [eax], ecx

; 714  :         _Orphan_range(_Mylast, _Mylast);
; 715  :         _Ty& _Result = *_Mylast;
; 716  :         ++_Mylast;

	add	DWORD PTR [ebp+12], 4

; 731  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

	jmp	SHORT $LN46@load
$LN47@load:

; 732  :         }
; 733  : 
; 734  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	lea	ecx, DWORD PTR _P$1[esp+12]
	push	ecx
	push	eax
	lea	ecx, DWORD PTR [ebp+8]
	call	??$_Emplace_reallocate@ABQAVCPortal@@@?$vector@PAVCPortal@@V?$xalloc@PAVCPortal@@@@@std@@QAEPAPAVCPortal@@QAPAV2@ABQAV2@@Z ; std::vector<CPortal *,xalloc<CPortal *> >::_Emplace_reallocate<CPortal * const &>
$LN46@load:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__sector.cpp

; 251  : 		count--;

	sub	edi, 1
	jne	SHORT $LL5@load
$LN6@load:

; 252  : 	}
; 253  : 
; 254  : 	if	(g_dedicated_server)	m_root	= 0;

	mov	eax, DWORD PTR __imp_?g_dedicated_server@@3_NA
	cmp	BYTE PTR [eax], 0
	je	SHORT $LN11@load

; 260  : }

	pop	edi
	pop	esi
	mov	DWORD PTR [ebp+4], 0
	pop	ebp
	pop	ebx
	ret	4
$LN11@load:

; 255  : 	else {
; 256  : 		// Assign visual
; 257  : 		size	= fs.find_chunk(fsP_Root);	R_ASSERT(size==4);

	push	0
	push	2
	mov	ecx, ebx
	call	DWORD PTR __imp_?find_chunk@?$IReaderBase@VIReader@@@@QAEIIPAH@Z
	cmp	BYTE PTR ?ignore_always@?O@??load@CSector@@QAEXAAVIReader@@@Z@4_NA, 0
	jne	SHORT $LN7@load
	cmp	eax, 4
	je	SHORT $LN7@load
	mov	ecx, DWORD PTR __imp_?Debug@@3VxrDebug@@A
	push	OFFSET ?ignore_always@?O@??load@CSector@@QAEXAAVIReader@@@Z@4_NA
	push	OFFSET ??_C@_0O@JCOHLFIM@CSector?3?3load@
	push	257					; 00000101H
	push	OFFSET ??_C@_0DJ@FDLNFKJF@I?3?2Vitalya?2mine?2NSProjectX?2laye@
	push	OFFSET ??_C@_07MIJPMMAB@size?$DN?$DN4@
	call	DWORD PTR __imp_?fail@xrDebug@@QAEXPBD0H0AA_N@Z
$LN7@load:

; 258  : 		m_root	= RImplementation.getVisual	(fs.r_u32());

	mov	ecx, ebx
	call	DWORD PTR __imp_?r_u32@?$IReaderBase@VIReader@@@@QAEIXZ
	mov	ecx, DWORD PTR ?RImplementation@@3VCRender@@A+944
	pop	edi

; 260  : }

	pop	esi
	mov	eax, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR [ebp+4], eax
	pop	ebp
	pop	ebx
	ret	4
$LN79@load:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1360 :                 _Xlength();

	call	?_Xlength@?$vector@PAVCPortal@@V?$xalloc@PAVCPortal@@@@@std@@CAXXZ ; std::vector<CPortal *,xalloc<CPortal *> >::_Xlength
$LN77@load:
	int	3
?load@CSector@@QAEXAAVIReader@@@Z ENDP			; CSector::load
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?push_back@?$vector@PAVIRender_Sector@@V?$xalloc@PAVIRender_Sector@@@@@std@@QAEX$$QAPAVIRender_Sector@@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?push_back@?$vector@PAVIRender_Sector@@V?$xalloc@PAVIRender_Sector@@@@@std@@QAEX$$QAPAVIRender_Sector@@@Z PROC ; std::vector<IRender_Sector *,xalloc<IRender_Sector *> >::push_back, COMDAT
; _this$ = ecx

; 730  :         if (_Mylast != _My_data._Myend) {

	mov	edx, DWORD PTR [ecx+4]
	cmp	edx, DWORD PTR [ecx+8]
	je	SHORT $LN4@push_back

; 713  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

	mov	eax, DWORD PTR __Val$[esp-4]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edx], eax

; 714  :         _Orphan_range(_Mylast, _Mylast);
; 715  :         _Ty& _Result = *_Mylast;
; 716  :         ++_Mylast;

	add	DWORD PTR [ecx+4], 4

; 747  :         // insert by moving into element at end, provide strong guarantee
; 748  :         emplace_back(_STD move(_Val));
; 749  :     }

	ret	4
$LN4@push_back:

; 734  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	push	DWORD PTR __Val$[esp-4]
	push	edx
	call	??$_Emplace_reallocate@PAVIRender_Sector@@@?$vector@PAVIRender_Sector@@V?$xalloc@PAVIRender_Sector@@@@@std@@QAEPAPAVIRender_Sector@@QAPAV2@$$QAPAV2@@Z ; std::vector<IRender_Sector *,xalloc<IRender_Sector *> >::_Emplace_reallocate<IRender_Sector *>

; 747  :         // insert by moving into element at end, provide strong guarantee
; 748  :         emplace_back(_STD move(_Val));
; 749  :     }

	ret	4
?push_back@?$vector@PAVIRender_Sector@@V?$xalloc@PAVIRender_Sector@@@@@std@@QAEX$$QAPAVIRender_Sector@@@Z ENDP ; std::vector<IRender_Sector *,xalloc<IRender_Sector *> >::push_back
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??$emplace_back@PAVIRender_Sector@@@?$vector@PAVIRender_Sector@@V?$xalloc@PAVIRender_Sector@@@@@std@@QAE?A_T$$QAPAVIRender_Sector@@@Z
_TEXT	SEGMENT
_<_Val_0>$ = 8						; size = 4
??$emplace_back@PAVIRender_Sector@@@?$vector@PAVIRender_Sector@@V?$xalloc@PAVIRender_Sector@@@@@std@@QAE?A_T$$QAPAVIRender_Sector@@@Z PROC ; std::vector<IRender_Sector *,xalloc<IRender_Sector *> >::emplace_back<IRender_Sector *>, COMDAT
; _this$ = ecx

; 727  :         // insert by perfectly forwarding into element at end, provide strong guarantee
; 728  :         auto& _My_data   = _Mypair._Myval2;
; 729  :         pointer& _Mylast = _My_data._Mylast;
; 730  :         if (_Mylast != _My_data._Myend) {

	mov	edx, DWORD PTR [ecx+4]
	cmp	edx, DWORD PTR [ecx+8]
	je	SHORT $LN2@emplace_ba

; 713  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

	mov	eax, DWORD PTR _<_Val_0>$[esp-4]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edx], eax

; 714  :         _Orphan_range(_Mylast, _Mylast);
; 715  :         _Ty& _Result = *_Mylast;
; 716  :         ++_Mylast;

	add	DWORD PTR [ecx+4], 4

; 735  : #if _HAS_CXX17
; 736  :         return _Result;
; 737  : #else // ^^^ _HAS_CXX17 ^^^ // vvv !_HAS_CXX17 vvv
; 738  :         (void) _Result;
; 739  : #endif // _HAS_CXX17
; 740  :     }

	ret	4
$LN2@emplace_ba:

; 731  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);
; 732  :         }
; 733  : 
; 734  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	push	DWORD PTR _<_Val_0>$[esp-4]
	push	edx
	call	??$_Emplace_reallocate@PAVIRender_Sector@@@?$vector@PAVIRender_Sector@@V?$xalloc@PAVIRender_Sector@@@@@std@@QAEPAPAVIRender_Sector@@QAPAV2@$$QAPAV2@@Z ; std::vector<IRender_Sector *,xalloc<IRender_Sector *> >::_Emplace_reallocate<IRender_Sector *>

; 735  : #if _HAS_CXX17
; 736  :         return _Result;
; 737  : #else // ^^^ _HAS_CXX17 ^^^ // vvv !_HAS_CXX17 vvv
; 738  :         (void) _Result;
; 739  : #endif // _HAS_CXX17
; 740  :     }

	ret	4
??$emplace_back@PAVIRender_Sector@@@?$vector@PAVIRender_Sector@@V?$xalloc@PAVIRender_Sector@@@@@std@@QAE?A_T$$QAPAVIRender_Sector@@@Z ENDP ; std::vector<IRender_Sector *,xalloc<IRender_Sector *> >::emplace_back<IRender_Sector *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??$_Emplace_back_with_unused_capacity@PAVIRender_Sector@@@?$vector@PAVIRender_Sector@@V?$xalloc@PAVIRender_Sector@@@@@std@@AAE?A_T$$QAPAVIRender_Sector@@@Z
_TEXT	SEGMENT
_<_Val_0>$ = 8						; size = 4
??$_Emplace_back_with_unused_capacity@PAVIRender_Sector@@@?$vector@PAVIRender_Sector@@V?$xalloc@PAVIRender_Sector@@@@@std@@AAE?A_T$$QAPAVIRender_Sector@@@Z PROC ; std::vector<IRender_Sector *,xalloc<IRender_Sector *> >::_Emplace_back_with_unused_capacity<IRender_Sector *>, COMDAT
; _this$ = ecx

; 709  :         // insert by perfectly forwarding into element at end, provide strong guarantee
; 710  :         auto& _My_data   = _Mypair._Myval2;
; 711  :         pointer& _Mylast = _My_data._Mylast;
; 712  :         _STL_INTERNAL_CHECK(_Mylast != _My_data._Myend); // check that we have unused capacity
; 713  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _<_Val_0>$[esp-4]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edx], eax

; 714  :         _Orphan_range(_Mylast, _Mylast);
; 715  :         _Ty& _Result = *_Mylast;
; 716  :         ++_Mylast;

	add	DWORD PTR [ecx+4], 4

; 717  : #if _HAS_CXX17
; 718  :         return _Result;
; 719  : #else // ^^^ _HAS_CXX17 ^^^ // vvv !_HAS_CXX17 vvv
; 720  :         (void) _Result;
; 721  : #endif // _HAS_CXX17
; 722  :     }

	ret	4
??$_Emplace_back_with_unused_capacity@PAVIRender_Sector@@@?$vector@PAVIRender_Sector@@V?$xalloc@PAVIRender_Sector@@@@@std@@AAE?A_T$$QAPAVIRender_Sector@@@Z ENDP ; std::vector<IRender_Sector *,xalloc<IRender_Sector *> >::_Emplace_back_with_unused_capacity<IRender_Sector *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?clear@?$xr_vector@U_scissor@@V?$xalloc@U_scissor@@@@@@QAEXXZ
_TEXT	SEGMENT
?clear@?$xr_vector@U_scissor@@V?$xalloc@U_scissor@@@@@@QAEXXZ PROC ; xr_vector<_scissor,xalloc<_scissor> >::clear, COMDAT
; _this$ = ecx

; 132  : 	void	clear				()									{ clear_and_free	();			}

	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [ecx+4], eax
	ret	0
?clear@?$xr_vector@U_scissor@@V?$xalloc@U_scissor@@@@@@QAEXXZ ENDP ; xr_vector<_scissor,xalloc<_scissor> >::clear
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?push_back@?$vector@U_scissor@@V?$xalloc@U_scissor@@@@@std@@QAEXABU_scissor@@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?push_back@?$vector@U_scissor@@V?$xalloc@U_scissor@@@@@std@@QAEXABU_scissor@@@Z PROC ; std::vector<_scissor,xalloc<_scissor> >::push_back, COMDAT
; _this$ = ecx

; 742  :     _CONSTEXPR20_CONTAINER void push_back(const _Ty& _Val) { // insert element at end, provide strong guarantee

	push	esi

; 730  :         if (_Mylast != _My_data._Myend) {

	mov	esi, DWORD PTR [ecx+4]
	cmp	esi, DWORD PTR [ecx+8]
	je	SHORT $LN4@push_back
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	edx, DWORD PTR __Val$[esp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [esi], eax
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [esi+4], eax
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR [esi+8], eax
	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR [esi+12], eax
	mov	eax, DWORD PTR [edx+16]
	mov	DWORD PTR [esi+16], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 716  :         ++_Mylast;

	add	DWORD PTR [ecx+4], 20			; 00000014H
	pop	esi

; 743  :         emplace_back(_Val);
; 744  :     }

	ret	4
$LN4@push_back:

; 734  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	push	DWORD PTR __Val$[esp]
	push	esi
	call	??$_Emplace_reallocate@ABU_scissor@@@?$vector@U_scissor@@V?$xalloc@U_scissor@@@@@std@@QAEPAU_scissor@@QAU2@ABU2@@Z ; std::vector<_scissor,xalloc<_scissor> >::_Emplace_reallocate<_scissor const &>
	pop	esi

; 743  :         emplace_back(_Val);
; 744  :     }

	ret	4
?push_back@?$vector@U_scissor@@V?$xalloc@U_scissor@@@@@std@@QAEXABU_scissor@@@Z ENDP ; std::vector<_scissor,xalloc<_scissor> >::push_back
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??$emplace_back@ABU_scissor@@@?$vector@U_scissor@@V?$xalloc@U_scissor@@@@@std@@QAE?A_TABU_scissor@@@Z
_TEXT	SEGMENT
_<_Val_0>$ = 8						; size = 4
??$emplace_back@ABU_scissor@@@?$vector@U_scissor@@V?$xalloc@U_scissor@@@@@std@@QAE?A_TABU_scissor@@@Z PROC ; std::vector<_scissor,xalloc<_scissor> >::emplace_back<_scissor const &>, COMDAT
; _this$ = ecx

; 726  :     _CONSTEXPR20_CONTAINER decltype(auto) emplace_back(_Valty&&... _Val) {

	push	esi

; 727  :         // insert by perfectly forwarding into element at end, provide strong guarantee
; 728  :         auto& _My_data   = _Mypair._Myval2;
; 729  :         pointer& _Mylast = _My_data._Mylast;
; 730  :         if (_Mylast != _My_data._Myend) {

	mov	esi, DWORD PTR [ecx+4]
	cmp	esi, DWORD PTR [ecx+8]
	je	SHORT $LN2@emplace_ba
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	edx, DWORD PTR _<_Val_0>$[esp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [esi], eax
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [esi+4], eax
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR [esi+8], eax
	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR [esi+12], eax
	mov	eax, DWORD PTR [edx+16]
	mov	DWORD PTR [esi+16], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 716  :         ++_Mylast;

	add	DWORD PTR [ecx+4], 20			; 00000014H
	pop	esi

; 735  : #if _HAS_CXX17
; 736  :         return _Result;
; 737  : #else // ^^^ _HAS_CXX17 ^^^ // vvv !_HAS_CXX17 vvv
; 738  :         (void) _Result;
; 739  : #endif // _HAS_CXX17
; 740  :     }

	ret	4
$LN2@emplace_ba:

; 731  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);
; 732  :         }
; 733  : 
; 734  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	push	DWORD PTR _<_Val_0>$[esp]
	push	esi
	call	??$_Emplace_reallocate@ABU_scissor@@@?$vector@U_scissor@@V?$xalloc@U_scissor@@@@@std@@QAEPAU_scissor@@QAU2@ABU2@@Z ; std::vector<_scissor,xalloc<_scissor> >::_Emplace_reallocate<_scissor const &>
	pop	esi

; 735  : #if _HAS_CXX17
; 736  :         return _Result;
; 737  : #else // ^^^ _HAS_CXX17 ^^^ // vvv !_HAS_CXX17 vvv
; 738  :         (void) _Result;
; 739  : #endif // _HAS_CXX17
; 740  :     }

	ret	4
??$emplace_back@ABU_scissor@@@?$vector@U_scissor@@V?$xalloc@U_scissor@@@@@std@@QAE?A_TABU_scissor@@@Z ENDP ; std::vector<_scissor,xalloc<_scissor> >::emplace_back<_scissor const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??$_Emplace_back_with_unused_capacity@ABU_scissor@@@?$vector@U_scissor@@V?$xalloc@U_scissor@@@@@std@@AAE?A_TABU_scissor@@@Z
_TEXT	SEGMENT
_<_Val_0>$ = 8						; size = 4
??$_Emplace_back_with_unused_capacity@ABU_scissor@@@?$vector@U_scissor@@V?$xalloc@U_scissor@@@@@std@@AAE?A_TABU_scissor@@@Z PROC ; std::vector<_scissor,xalloc<_scissor> >::_Emplace_back_with_unused_capacity<_scissor const &>, COMDAT
; _this$ = ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	edx, DWORD PTR _<_Val_0>$[esp-4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 708  :     _CONSTEXPR20_CONTAINER decltype(auto) _Emplace_back_with_unused_capacity(_Valty&&... _Val) {

	push	esi
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	esi, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [esi], eax
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [esi+4], eax
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR [esi+8], eax
	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR [esi+12], eax
	mov	eax, DWORD PTR [edx+16]
	mov	DWORD PTR [esi+16], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 716  :         ++_Mylast;

	add	DWORD PTR [ecx+4], 20			; 00000014H
	pop	esi

; 717  : #if _HAS_CXX17
; 718  :         return _Result;
; 719  : #else // ^^^ _HAS_CXX17 ^^^ // vvv !_HAS_CXX17 vvv
; 720  :         (void) _Result;
; 721  : #endif // _HAS_CXX17
; 722  :     }

	ret	4
??$_Emplace_back_with_unused_capacity@ABU_scissor@@@?$vector@U_scissor@@V?$xalloc@U_scissor@@@@@std@@AAE?A_TABU_scissor@@@Z ENDP ; std::vector<_scissor,xalloc<_scissor> >::_Emplace_back_with_unused_capacity<_scissor const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?clear@?$xr_vector@VCFrustum@@V?$xalloc@VCFrustum@@@@@@QAEXXZ
_TEXT	SEGMENT
?clear@?$xr_vector@VCFrustum@@V?$xalloc@VCFrustum@@@@@@QAEXXZ PROC ; xr_vector<CFrustum,xalloc<CFrustum> >::clear, COMDAT
; _this$ = ecx

; 132  : 	void	clear				()									{ clear_and_free	();			}

	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [ecx+4], eax
	ret	0
?clear@?$xr_vector@VCFrustum@@V?$xalloc@VCFrustum@@@@@@QAEXXZ ENDP ; xr_vector<CFrustum,xalloc<CFrustum> >::clear
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?push_back@?$vector@VCFrustum@@V?$xalloc@VCFrustum@@@@@std@@QAEXABVCFrustum@@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?push_back@?$vector@VCFrustum@@V?$xalloc@VCFrustum@@@@@std@@QAEXABVCFrustum@@@Z PROC ; std::vector<CFrustum,xalloc<CFrustum> >::push_back, COMDAT
; _this$ = ecx

; 742  :     _CONSTEXPR20_CONTAINER void push_back(const _Ty& _Val) { // insert element at end, provide strong guarantee

	mov	eax, ecx

; 730  :         if (_Mylast != _My_data._Myend) {

	mov	edx, DWORD PTR [eax+4]
	cmp	edx, DWORD PTR [eax+8]
	je	SHORT $LN4@push_back
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	push	esi
	mov	esi, DWORD PTR __Val$[esp]
	mov	ecx, 61					; 0000003dH
	push	edi
	mov	edi, edx
	rep movsd
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 716  :         ++_Mylast;

	add	DWORD PTR [eax+4], 244			; 000000f4H
	pop	edi
	pop	esi

; 743  :         emplace_back(_Val);
; 744  :     }

	ret	4
$LN4@push_back:

; 734  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	push	DWORD PTR __Val$[esp-4]
	push	edx
	call	??$_Emplace_reallocate@ABVCFrustum@@@?$vector@VCFrustum@@V?$xalloc@VCFrustum@@@@@std@@QAEPAVCFrustum@@QAV2@ABV2@@Z ; std::vector<CFrustum,xalloc<CFrustum> >::_Emplace_reallocate<CFrustum const &>

; 743  :         emplace_back(_Val);
; 744  :     }

	ret	4
?push_back@?$vector@VCFrustum@@V?$xalloc@VCFrustum@@@@@std@@QAEXABVCFrustum@@@Z ENDP ; std::vector<CFrustum,xalloc<CFrustum> >::push_back
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??$emplace_back@ABVCFrustum@@@?$vector@VCFrustum@@V?$xalloc@VCFrustum@@@@@std@@QAE?A_TABVCFrustum@@@Z
_TEXT	SEGMENT
_<_Val_0>$ = 8						; size = 4
??$emplace_back@ABVCFrustum@@@?$vector@VCFrustum@@V?$xalloc@VCFrustum@@@@@std@@QAE?A_TABVCFrustum@@@Z PROC ; std::vector<CFrustum,xalloc<CFrustum> >::emplace_back<CFrustum const &>, COMDAT
; _this$ = ecx

; 726  :     _CONSTEXPR20_CONTAINER decltype(auto) emplace_back(_Valty&&... _Val) {

	mov	eax, ecx

; 727  :         // insert by perfectly forwarding into element at end, provide strong guarantee
; 728  :         auto& _My_data   = _Mypair._Myval2;
; 729  :         pointer& _Mylast = _My_data._Mylast;
; 730  :         if (_Mylast != _My_data._Myend) {

	mov	edx, DWORD PTR [eax+4]
	cmp	edx, DWORD PTR [eax+8]
	je	SHORT $LN2@emplace_ba
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	push	esi
	mov	esi, DWORD PTR _<_Val_0>$[esp]
	mov	ecx, 61					; 0000003dH
	push	edi
	mov	edi, edx
	rep movsd
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 716  :         ++_Mylast;

	add	DWORD PTR [eax+4], 244			; 000000f4H
	pop	edi
	pop	esi

; 735  : #if _HAS_CXX17
; 736  :         return _Result;
; 737  : #else // ^^^ _HAS_CXX17 ^^^ // vvv !_HAS_CXX17 vvv
; 738  :         (void) _Result;
; 739  : #endif // _HAS_CXX17
; 740  :     }

	ret	4
$LN2@emplace_ba:

; 731  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);
; 732  :         }
; 733  : 
; 734  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	push	DWORD PTR _<_Val_0>$[esp-4]
	push	edx
	call	??$_Emplace_reallocate@ABVCFrustum@@@?$vector@VCFrustum@@V?$xalloc@VCFrustum@@@@@std@@QAEPAVCFrustum@@QAV2@ABV2@@Z ; std::vector<CFrustum,xalloc<CFrustum> >::_Emplace_reallocate<CFrustum const &>

; 735  : #if _HAS_CXX17
; 736  :         return _Result;
; 737  : #else // ^^^ _HAS_CXX17 ^^^ // vvv !_HAS_CXX17 vvv
; 738  :         (void) _Result;
; 739  : #endif // _HAS_CXX17
; 740  :     }

	ret	4
??$emplace_back@ABVCFrustum@@@?$vector@VCFrustum@@V?$xalloc@VCFrustum@@@@@std@@QAE?A_TABVCFrustum@@@Z ENDP ; std::vector<CFrustum,xalloc<CFrustum> >::emplace_back<CFrustum const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??$_Emplace_back_with_unused_capacity@ABVCFrustum@@@?$vector@VCFrustum@@V?$xalloc@VCFrustum@@@@@std@@AAE?A_TABVCFrustum@@@Z
_TEXT	SEGMENT
_<_Val_0>$ = 8						; size = 4
??$_Emplace_back_with_unused_capacity@ABVCFrustum@@@?$vector@VCFrustum@@V?$xalloc@VCFrustum@@@@@std@@AAE?A_TABVCFrustum@@@Z PROC ; std::vector<CFrustum,xalloc<CFrustum> >::_Emplace_back_with_unused_capacity<CFrustum const &>, COMDAT
; _this$ = ecx

; 708  :     _CONSTEXPR20_CONTAINER decltype(auto) _Emplace_back_with_unused_capacity(_Valty&&... _Val) {

	mov	eax, ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	ecx, 61					; 0000003dH
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 708  :     _CONSTEXPR20_CONTAINER decltype(auto) _Emplace_back_with_unused_capacity(_Valty&&... _Val) {

	push	esi
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	esi, DWORD PTR _<_Val_0>$[esp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 708  :     _CONSTEXPR20_CONTAINER decltype(auto) _Emplace_back_with_unused_capacity(_Valty&&... _Val) {

	push	edi
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	edi, DWORD PTR [eax+4]
	rep movsd
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 716  :         ++_Mylast;

	add	DWORD PTR [eax+4], 244			; 000000f4H
	pop	edi
	pop	esi

; 717  : #if _HAS_CXX17
; 718  :         return _Result;
; 719  : #else // ^^^ _HAS_CXX17 ^^^ // vvv !_HAS_CXX17 vvv
; 720  :         (void) _Result;
; 721  : #endif // _HAS_CXX17
; 722  :     }

	ret	4
??$_Emplace_back_with_unused_capacity@ABVCFrustum@@@?$vector@VCFrustum@@V?$xalloc@VCFrustum@@@@@std@@AAE?A_TABVCFrustum@@@Z ENDP ; std::vector<CFrustum,xalloc<CFrustum> >::_Emplace_back_with_unused_capacity<CFrustum const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ??A?$xr_vector@PAVCPortal@@V?$xalloc@PAVCPortal@@@@@@QAEAAPAVCPortal@@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$xr_vector@PAVCPortal@@V?$xalloc@PAVCPortal@@@@@@QAEAAPAVCPortal@@I@Z PROC ; xr_vector<CPortal *,xalloc<CPortal *> >::operator[], COMDAT
; _this$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 119  :         _Ptr += _Off;

	mov	ecx, DWORD PTR [ecx]
	mov	eax, DWORD PTR __Pos$[esp-4]
	lea	eax, DWORD PTR [ecx+eax*4]
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 138  : 	reference operator[]		(size_type _Pos)					{ {VERIFY(_Pos<size());} return (*(begin() + _Pos)); }

	ret	4
??A?$xr_vector@PAVCPortal@@V?$xalloc@PAVCPortal@@@@@@QAEAAPAVCPortal@@I@Z ENDP ; xr_vector<CPortal *,xalloc<CPortal *> >::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?size@?$xr_vector@PAVCPortal@@V?$xalloc@PAVCPortal@@@@@@QBEIXZ
_TEXT	SEGMENT
?size@?$xr_vector@PAVCPortal@@V?$xalloc@PAVCPortal@@@@@@QBEIXZ PROC ; xr_vector<CPortal *,xalloc<CPortal *> >::size, COMDAT
; _this$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	eax, DWORD PTR [ecx+4]
	sub	eax, DWORD PTR [ecx]
	sar	eax, 2
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 125  : 	u32		size				() const							{ return (u32)inherited::size();} 

	ret	0
?size@?$xr_vector@PAVCPortal@@V?$xalloc@PAVCPortal@@@@@@QBEIXZ ENDP ; xr_vector<CPortal *,xalloc<CPortal *> >::size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?reserve@?$vector@PAVCPortal@@V?$xalloc@PAVCPortal@@@@@std@@QAEXI@Z
_TEXT	SEGMENT
__Newcapacity$ = 8					; size = 4
?reserve@?$vector@PAVCPortal@@V?$xalloc@PAVCPortal@@@@@std@@QAEXI@Z PROC ; std::vector<CPortal *,xalloc<CPortal *> >::reserve, COMDAT
; _this$ = ecx

; 1546 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx]

; 1357 :         // increase capacity to _Newcapacity (without geometric growth), provide strong guarantee
; 1358 :         if (_Newcapacity > capacity()) { // something to do (reserve() never shrinks)

	mov	edx, DWORD PTR __Newcapacity$[esp-4]

; 1546 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	sar	eax, 2

; 1357 :         // increase capacity to _Newcapacity (without geometric growth), provide strong guarantee
; 1358 :         if (_Newcapacity > capacity()) { // something to do (reserve() never shrinks)

	cmp	edx, eax
	jbe	SHORT $LN2@reserve

; 1359 :             if (_Newcapacity > max_size()) {

	cmp	edx, 1073741823				; 3fffffffH
	ja	SHORT $LN9@reserve

; 1361 :             }
; 1362 : 
; 1363 :             _Reallocate_exactly(_Newcapacity);

	mov	DWORD PTR __Newcapacity$[esp-4], edx
	jmp	?_Reallocate_exactly@?$vector@PAVCPortal@@V?$xalloc@PAVCPortal@@@@@std@@AAEXI@Z ; std::vector<CPortal *,xalloc<CPortal *> >::_Reallocate_exactly
$LN2@reserve:

; 1364 :         }
; 1365 :     }

	ret	4
$LN9@reserve:

; 1360 :                 _Xlength();

	call	?_Xlength@?$vector@PAVCPortal@@V?$xalloc@PAVCPortal@@@@@std@@CAXXZ ; std::vector<CPortal *,xalloc<CPortal *> >::_Xlength
$LN7@reserve:
	int	3
?reserve@?$vector@PAVCPortal@@V?$xalloc@PAVCPortal@@@@@std@@QAEXI@Z ENDP ; std::vector<CPortal *,xalloc<CPortal *> >::reserve
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?push_back@?$vector@PAVCPortal@@V?$xalloc@PAVCPortal@@@@@std@@QAEXABQAVCPortal@@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?push_back@?$vector@PAVCPortal@@V?$xalloc@PAVCPortal@@@@@std@@QAEXABQAVCPortal@@@Z PROC ; std::vector<CPortal *,xalloc<CPortal *> >::push_back, COMDAT
; _this$ = ecx

; 730  :         if (_Mylast != _My_data._Myend) {

	mov	edx, DWORD PTR [ecx+4]
	cmp	edx, DWORD PTR [ecx+8]
	je	SHORT $LN4@push_back

; 713  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

	mov	eax, DWORD PTR __Val$[esp-4]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edx], eax

; 714  :         _Orphan_range(_Mylast, _Mylast);
; 715  :         _Ty& _Result = *_Mylast;
; 716  :         ++_Mylast;

	add	DWORD PTR [ecx+4], 4

; 743  :         emplace_back(_Val);
; 744  :     }

	ret	4
$LN4@push_back:

; 734  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	push	DWORD PTR __Val$[esp-4]
	push	edx
	call	??$_Emplace_reallocate@ABQAVCPortal@@@?$vector@PAVCPortal@@V?$xalloc@PAVCPortal@@@@@std@@QAEPAPAVCPortal@@QAPAV2@ABQAV2@@Z ; std::vector<CPortal *,xalloc<CPortal *> >::_Emplace_reallocate<CPortal * const &>

; 743  :         emplace_back(_Val);
; 744  :     }

	ret	4
?push_back@?$vector@PAVCPortal@@V?$xalloc@PAVCPortal@@@@@std@@QAEXABQAVCPortal@@@Z ENDP ; std::vector<CPortal *,xalloc<CPortal *> >::push_back
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??$emplace_back@ABQAVCPortal@@@?$vector@PAVCPortal@@V?$xalloc@PAVCPortal@@@@@std@@QAE?A_TABQAVCPortal@@@Z
_TEXT	SEGMENT
_<_Val_0>$ = 8						; size = 4
??$emplace_back@ABQAVCPortal@@@?$vector@PAVCPortal@@V?$xalloc@PAVCPortal@@@@@std@@QAE?A_TABQAVCPortal@@@Z PROC ; std::vector<CPortal *,xalloc<CPortal *> >::emplace_back<CPortal * const &>, COMDAT
; _this$ = ecx

; 727  :         // insert by perfectly forwarding into element at end, provide strong guarantee
; 728  :         auto& _My_data   = _Mypair._Myval2;
; 729  :         pointer& _Mylast = _My_data._Mylast;
; 730  :         if (_Mylast != _My_data._Myend) {

	mov	edx, DWORD PTR [ecx+4]
	cmp	edx, DWORD PTR [ecx+8]
	je	SHORT $LN2@emplace_ba

; 713  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

	mov	eax, DWORD PTR _<_Val_0>$[esp-4]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edx], eax

; 714  :         _Orphan_range(_Mylast, _Mylast);
; 715  :         _Ty& _Result = *_Mylast;
; 716  :         ++_Mylast;

	add	DWORD PTR [ecx+4], 4

; 735  : #if _HAS_CXX17
; 736  :         return _Result;
; 737  : #else // ^^^ _HAS_CXX17 ^^^ // vvv !_HAS_CXX17 vvv
; 738  :         (void) _Result;
; 739  : #endif // _HAS_CXX17
; 740  :     }

	ret	4
$LN2@emplace_ba:

; 731  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);
; 732  :         }
; 733  : 
; 734  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	push	DWORD PTR _<_Val_0>$[esp-4]
	push	edx
	call	??$_Emplace_reallocate@ABQAVCPortal@@@?$vector@PAVCPortal@@V?$xalloc@PAVCPortal@@@@@std@@QAEPAPAVCPortal@@QAPAV2@ABQAV2@@Z ; std::vector<CPortal *,xalloc<CPortal *> >::_Emplace_reallocate<CPortal * const &>

; 735  : #if _HAS_CXX17
; 736  :         return _Result;
; 737  : #else // ^^^ _HAS_CXX17 ^^^ // vvv !_HAS_CXX17 vvv
; 738  :         (void) _Result;
; 739  : #endif // _HAS_CXX17
; 740  :     }

	ret	4
??$emplace_back@ABQAVCPortal@@@?$vector@PAVCPortal@@V?$xalloc@PAVCPortal@@@@@std@@QAE?A_TABQAVCPortal@@@Z ENDP ; std::vector<CPortal *,xalloc<CPortal *> >::emplace_back<CPortal * const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??$_Emplace_back_with_unused_capacity@ABQAVCPortal@@@?$vector@PAVCPortal@@V?$xalloc@PAVCPortal@@@@@std@@AAE?A_TABQAVCPortal@@@Z
_TEXT	SEGMENT
_<_Val_0>$ = 8						; size = 4
??$_Emplace_back_with_unused_capacity@ABQAVCPortal@@@?$vector@PAVCPortal@@V?$xalloc@PAVCPortal@@@@@std@@AAE?A_TABQAVCPortal@@@Z PROC ; std::vector<CPortal *,xalloc<CPortal *> >::_Emplace_back_with_unused_capacity<CPortal * const &>, COMDAT
; _this$ = ecx

; 709  :         // insert by perfectly forwarding into element at end, provide strong guarantee
; 710  :         auto& _My_data   = _Mypair._Myval2;
; 711  :         pointer& _Mylast = _My_data._Mylast;
; 712  :         _STL_INTERNAL_CHECK(_Mylast != _My_data._Myend); // check that we have unused capacity
; 713  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _<_Val_0>$[esp-4]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edx], eax

; 714  :         _Orphan_range(_Mylast, _Mylast);
; 715  :         _Ty& _Result = *_Mylast;
; 716  :         ++_Mylast;

	add	DWORD PTR [ecx+4], 4

; 717  : #if _HAS_CXX17
; 718  :         return _Result;
; 719  : #else // ^^^ _HAS_CXX17 ^^^ // vvv !_HAS_CXX17 vvv
; 720  :         (void) _Result;
; 721  : #endif // _HAS_CXX17
; 722  :     }

	ret	4
??$_Emplace_back_with_unused_capacity@ABQAVCPortal@@@?$vector@PAVCPortal@@V?$xalloc@PAVCPortal@@@@@std@@AAE?A_TABQAVCPortal@@@Z ENDP ; std::vector<CPortal *,xalloc<CPortal *> >::_Emplace_back_with_unused_capacity<CPortal * const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\FixedVector.h
;	COMDAT ?assign@?$svector@U?$_vector3@M@@$07@@QAEXPAU?$_vector3@M@@H@Z
_TEXT	SEGMENT
_p$ = 8							; size = 4
_c$ = 12						; size = 4
?assign@?$svector@U?$_vector3@M@@$07@@QAEXPAU?$_vector3@M@@H@Z PROC ; svector<_vector3<float>,8>::assign, COMDAT
; _this$ = ecx

; 65   : 	IC void		assign(iterator p, int c) { VERIFY(c>0 && c<dim); CopyMemory(array,p,c*sizeof(value_type)); count=c; }

	push	esi
	mov	esi, DWORD PTR _c$[esp]
	push	edi
	mov	edi, ecx
	lea	eax, DWORD PTR [esi+esi*2]
	shl	eax, 2
	push	eax
	push	DWORD PTR _p$[esp+8]
	push	edi
	call	_memcpy
	add	esp, 12					; 0000000cH
	mov	DWORD PTR [edi+96], esi
	pop	edi
	pop	esi
	ret	8
?assign@?$svector@U?$_vector3@M@@$07@@QAEXPAU?$_vector3@M@@H@Z ENDP ; svector<_vector3<float>,8>::assign
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\FixedVector.h
;	COMDAT ??A?$svector@U?$_vector3@M@@$07@@QAEAAU?$_vector3@M@@I@Z
_TEXT	SEGMENT
_id$ = 8						; size = 4
??A?$svector@U?$_vector3@M@@$07@@QAEAAU?$_vector3@M@@I@Z PROC ; svector<_vector3<float>,8>::operator[], COMDAT
; _this$ = ecx

; 38   : 	IC reference		operator[] (u32 id)			{ VERIFY(id<count); return array[id];	}

	mov	eax, DWORD PTR _id$[esp-4]
	lea	eax, DWORD PTR [eax+eax*2]
	lea	eax, DWORD PTR [ecx+eax*4]
	ret	4
??A?$svector@U?$_vector3@M@@$07@@QAEAAU?$_vector3@M@@I@Z ENDP ; svector<_vector3<float>,8>::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\FixedVector.h
;	COMDAT ?size@?$svector@U?$_vector3@M@@$07@@QBEIXZ
_TEXT	SEGMENT
?size@?$svector@U?$_vector3@M@@$07@@QBEIXZ PROC		; svector<_vector3<float>,8>::size, COMDAT
; _this$ = ecx

; 30   : 	IC u32		size()		const			{ return count;							}

	mov	eax, DWORD PTR [ecx+96]
	ret	0
?size@?$svector@U?$_vector3@M@@$07@@QBEIXZ ENDP		; svector<_vector3<float>,8>::size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\FixedVector.h
;	COMDAT ?begin@?$svector@U?$_vector3@M@@$07@@QAEPAU?$_vector3@M@@XZ
_TEXT	SEGMENT
?begin@?$svector@U?$_vector3@M@@$07@@QAEPAU?$_vector3@M@@XZ PROC ; svector<_vector3<float>,8>::begin, COMDAT
; _this$ = ecx

; 26   : 	IC iterator	begin()						{ return array;							}

	mov	eax, ecx
	ret	0
?begin@?$svector@U?$_vector3@M@@$07@@QAEPAU?$_vector3@M@@XZ ENDP ; svector<_vector3<float>,8>::begin
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\FixedVector.h
;	COMDAT ??0?$svector@U?$_vector3@M@@$07@@QAE@XZ
_TEXT	SEGMENT
??0?$svector@U?$_vector3@M@@$07@@QAE@XZ PROC		; svector<_vector3<float>,8>::svector<_vector3<float>,8>, COMDAT
; _this$ = ecx

; 21   : 	svector() : count(0) 

	mov	DWORD PTR [ecx+96], 0

; 22   : 	{}

	mov	eax, ecx
	ret	0
??0?$svector@U?$_vector3@M@@$07@@QAE@XZ ENDP		; svector<_vector3<float>,8>::svector<_vector3<float>,8>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox2.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector2.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox2.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector2.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox2.h
;	COMDAT ?invalidate@?$_box2@M@@QAEAAV1@XZ
_TEXT	SEGMENT
?invalidate@?$_box2@M@@QAEAAV1@XZ PROC			; _box2<float>::invalidate, COMDAT
; _this$ = ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector2.h

; 15   : 	IC SelfRef set(float _u, float _v)				{ x=T(_u); y=T(_v);				return *this;	}

	mov	DWORD PTR [ecx], 2139095039		; 7f7fffffH
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox2.h

; 30   : 	IC	SelfRef	invalidate	()							{ min.set(type_max(T),type_max(T)); max.set(type_min(T),type_min(T)); return *this;	}

	mov	eax, ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector2.h

; 15   : 	IC SelfRef set(float _u, float _v)				{ x=T(_u); y=T(_v);				return *this;	}

	mov	DWORD PTR [ecx+4], 2139095039		; 7f7fffffH
	mov	DWORD PTR [ecx+8], -8388609		; ff7fffffH
	mov	DWORD PTR [ecx+12], -8388609		; ff7fffffH
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox2.h

; 30   : 	IC	SelfRef	invalidate	()							{ min.set(type_max(T),type_max(T)); max.set(type_min(T),type_min(T)); return *this;	}

	ret	0
?invalidate@?$_box2@M@@QAEAAV1@XZ ENDP			; _box2<float>::invalidate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_plane.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_plane.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_plane.h
;	COMDAT ?build@?$_plane@M@@QAEAAV1@ABU?$_vector3@M@@0@Z
_TEXT	SEGMENT
__p$ = 8						; size = 4
__n$ = 12						; size = 4
?build@?$_plane@M@@QAEAAV1@ABU?$_vector3@M@@0@Z PROC	; _plane<float>::build, COMDAT
; _this$ = ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 214  : 		T mag=_sqrt(1/(v.x*v.x + v.y*v.y + v.z*v.z));

	mov	eax, DWORD PTR __n$[esp-4]
	movss	xmm3, DWORD PTR [eax]
	movss	xmm2, DWORD PTR [eax+4]
	movaps	xmm1, xmm3
	movss	xmm0, DWORD PTR [eax+8]
	mulss	xmm1, xmm3
	mulss	xmm0, xmm0
	mulss	xmm2, xmm2
	addss	xmm1, xmm2
	addss	xmm1, xmm0
	movss	xmm0, DWORD PTR __real@3f800000
	divss	xmm0, xmm1
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h

; 764  :             return (float)sqrt(_X);

	sqrtss	xmm1, xmm0
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 215  : 		x = v.x*mag;

	mulss	xmm3, xmm1

; 216  : 		y = v.y*mag;

	movaps	xmm0, xmm1
	movss	DWORD PTR [ecx], xmm3
	mulss	xmm0, DWORD PTR [eax+4]
	movss	DWORD PTR [ecx+4], xmm0

; 217  : 		z = v.z*mag;

	mulss	xmm1, DWORD PTR [eax+8]

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	mov	eax, DWORD PTR __p$[esp-4]

; 217  : 		z = v.z*mag;

	movss	DWORD PTR [ecx+8], xmm1

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	mulss	xmm0, DWORD PTR [eax+4]
	mulss	xmm3, DWORD PTR [eax]
	mulss	xmm1, DWORD PTR [eax+8]
; File I:\Vitalya\mine\NSProjectX\xrCore\_plane.h

; 42   : 		return *this;

	mov	eax, ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	addss	xmm0, xmm3
	addss	xmm0, xmm1
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
; File I:\Vitalya\mine\NSProjectX\xrCore\_plane.h

; 41   : 		d			= - n.normalize(_n).dotproduct(_p);

	movss	DWORD PTR [ecx+12], xmm0

; 43   : 	}

	ret	8
?build@?$_plane@M@@QAEAAV1@ABU?$_vector3@M@@0@Z ENDP	; _plane<float>::build
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPortal@@@std@@@std@@@std@@QBE?AV01@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPortal@@@std@@@std@@@std@@QBE?AV01@H@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CPortal *> > >::operator+, COMDAT
; _this$ = ecx

; 119  :         _Ptr += _Off;

	mov	eax, DWORD PTR __Off$[esp-4]
	mov	ecx, DWORD PTR [ecx]
	lea	ecx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 303  :         _Vector_iterator _Tmp = *this;
; 304  :         _Tmp += _Off; // TRANSITION, LLVM-49342
; 305  :         return _Tmp;
; 306  :     }

	ret	8
??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPortal@@@std@@@std@@@std@@QBE?AV01@H@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CPortal *> > >::operator+
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPortal@@@std@@@std@@@std@@QBEAAPAVCPortal@@XZ
_TEXT	SEGMENT
??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPortal@@@std@@@std@@@std@@QBEAAPAVCPortal@@XZ PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CPortal *> > >::operator*, COMDAT
; _this$ = ecx

; 261  :         return const_cast<reference>(_Mybase::operator*());

	mov	eax, DWORD PTR [ecx]

; 262  :     }

	ret	0
??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPortal@@@std@@@std@@@std@@QBEAAPAVCPortal@@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CPortal *> > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Getal@?$vector@PAVIRender_Sector@@V?$xalloc@PAVIRender_Sector@@@@@std@@AAEAAV?$xalloc@PAVIRender_Sector@@@@XZ
_TEXT	SEGMENT
?_Getal@?$vector@PAVIRender_Sector@@V?$xalloc@PAVIRender_Sector@@@@@std@@AAEAAV?$xalloc@PAVIRender_Sector@@@@XZ PROC ; std::vector<IRender_Sector *,xalloc<IRender_Sector *> >::_Getal, COMDAT
; _this$ = ecx

; 1805 :         return _Mypair._Get_first();

	mov	eax, ecx

; 1806 :     }

	ret	0
?_Getal@?$vector@PAVIRender_Sector@@V?$xalloc@PAVIRender_Sector@@@@@std@@AAEAAV?$xalloc@PAVIRender_Sector@@@@XZ ENDP ; std::vector<IRender_Sector *,xalloc<IRender_Sector *> >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Orphan_range@?$vector@PAVIRender_Sector@@V?$xalloc@PAVIRender_Sector@@@@@std@@ABEXPAPAVIRender_Sector@@0@Z
_TEXT	SEGMENT
___formal$dead$ = 8					; size = 4
___formal$dead$ = 12					; size = 4
?_Orphan_range@?$vector@PAVIRender_Sector@@V?$xalloc@PAVIRender_Sector@@@@@std@@ABEXPAPAVIRender_Sector@@0@Z PROC ; std::vector<IRender_Sector *,xalloc<IRender_Sector *> >::_Orphan_range, COMDAT
; _this$dead$ = ecx

; 1801 :     _CONSTEXPR20_CONTAINER void _Orphan_range(pointer, pointer) const {}

	ret	8
?_Orphan_range@?$vector@PAVIRender_Sector@@V?$xalloc@PAVIRender_Sector@@@@@std@@ABEXPAPAVIRender_Sector@@0@Z ENDP ; std::vector<IRender_Sector *,xalloc<IRender_Sector *> >::_Orphan_range
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?clear_and_free@?$xr_vector@U_scissor@@V?$xalloc@U_scissor@@@@@@QAEXXZ
_TEXT	SEGMENT
?clear_and_free@?$xr_vector@U_scissor@@V?$xalloc@U_scissor@@@@@@QAEXXZ PROC ; xr_vector<_scissor,xalloc<_scissor> >::clear_and_free, COMDAT
; _this$ = ecx

; 127  : 	void	clear_and_free		()									{ inherited::clear();			}

	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [ecx+4], eax
	ret	0
?clear_and_free@?$xr_vector@U_scissor@@V?$xalloc@U_scissor@@@@@@QAEXXZ ENDP ; xr_vector<_scissor,xalloc<_scissor> >::clear_and_free
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Orphan_range@?$vector@U_scissor@@V?$xalloc@U_scissor@@@@@std@@ABEXPAU_scissor@@0@Z
_TEXT	SEGMENT
___formal$dead$ = 8					; size = 4
___formal$dead$ = 12					; size = 4
?_Orphan_range@?$vector@U_scissor@@V?$xalloc@U_scissor@@@@@std@@ABEXPAU_scissor@@0@Z PROC ; std::vector<_scissor,xalloc<_scissor> >::_Orphan_range, COMDAT
; _this$dead$ = ecx

; 1801 :     _CONSTEXPR20_CONTAINER void _Orphan_range(pointer, pointer) const {}

	ret	8
?_Orphan_range@?$vector@U_scissor@@V?$xalloc@U_scissor@@@@@std@@ABEXPAU_scissor@@0@Z ENDP ; std::vector<_scissor,xalloc<_scissor> >::_Orphan_range
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?clear_and_free@?$xr_vector@VCFrustum@@V?$xalloc@VCFrustum@@@@@@QAEXXZ
_TEXT	SEGMENT
?clear_and_free@?$xr_vector@VCFrustum@@V?$xalloc@VCFrustum@@@@@@QAEXXZ PROC ; xr_vector<CFrustum,xalloc<CFrustum> >::clear_and_free, COMDAT
; _this$ = ecx

; 127  : 	void	clear_and_free		()									{ inherited::clear();			}

	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [ecx+4], eax
	ret	0
?clear_and_free@?$xr_vector@VCFrustum@@V?$xalloc@VCFrustum@@@@@@QAEXXZ ENDP ; xr_vector<CFrustum,xalloc<CFrustum> >::clear_and_free
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Orphan_range@?$vector@VCFrustum@@V?$xalloc@VCFrustum@@@@@std@@ABEXPAVCFrustum@@0@Z
_TEXT	SEGMENT
___formal$dead$ = 8					; size = 4
___formal$dead$ = 12					; size = 4
?_Orphan_range@?$vector@VCFrustum@@V?$xalloc@VCFrustum@@@@@std@@ABEXPAVCFrustum@@0@Z PROC ; std::vector<CFrustum,xalloc<CFrustum> >::_Orphan_range, COMDAT
; _this$dead$ = ecx

; 1801 :     _CONSTEXPR20_CONTAINER void _Orphan_range(pointer, pointer) const {}

	ret	8
?_Orphan_range@?$vector@VCFrustum@@V?$xalloc@VCFrustum@@@@@std@@ABEXPAVCFrustum@@0@Z ENDP ; std::vector<CFrustum,xalloc<CFrustum> >::_Orphan_range
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Orphan_range@?$vector@PAVCPortal@@V?$xalloc@PAVCPortal@@@@@std@@ABEXPAPAVCPortal@@0@Z
_TEXT	SEGMENT
___formal$dead$ = 8					; size = 4
___formal$dead$ = 12					; size = 4
?_Orphan_range@?$vector@PAVCPortal@@V?$xalloc@PAVCPortal@@@@@std@@ABEXPAPAVCPortal@@0@Z PROC ; std::vector<CPortal *,xalloc<CPortal *> >::_Orphan_range, COMDAT
; _this$dead$ = ecx

; 1801 :     _CONSTEXPR20_CONTAINER void _Orphan_range(pointer, pointer) const {}

	ret	8
?_Orphan_range@?$vector@PAVCPortal@@V?$xalloc@PAVCPortal@@@@@std@@ABEXPAPAVCPortal@@0@Z ENDP ; std::vector<CPortal *,xalloc<CPortal *> >::_Orphan_range
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Xlength@?$vector@PAVCPortal@@V?$xalloc@PAVCPortal@@@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@PAVCPortal@@V?$xalloc@PAVCPortal@@@@@std@@CAXXZ PROC ; std::vector<CPortal *,xalloc<CPortal *> >::_Xlength, COMDAT

; 1761 :         _Xlength_error("vector too long");

	push	OFFSET ??_C@_0BA@FOIKENOD@vector?5too?5long@
	call	DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN3@Xlength:
	int	3
?_Xlength@?$vector@PAVCPortal@@V?$xalloc@PAVCPortal@@@@@std@@CAXXZ ENDP ; std::vector<CPortal *,xalloc<CPortal *> >::_Xlength
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?capacity@?$vector@PAVCPortal@@V?$xalloc@PAVCPortal@@@@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@PAVCPortal@@V?$xalloc@PAVCPortal@@@@@std@@QBEIXZ PROC ; std::vector<CPortal *,xalloc<CPortal *> >::capacity, COMDAT
; _this$ = ecx

; 1545 :         auto& _My_data = _Mypair._Myval2;
; 1546 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx]
	sar	eax, 2

; 1547 :     }

	ret	0
?capacity@?$vector@PAVCPortal@@V?$xalloc@PAVCPortal@@@@@std@@QBEIXZ ENDP ; std::vector<CPortal *,xalloc<CPortal *> >::capacity
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?max_size@?$vector@PAVCPortal@@V?$xalloc@PAVCPortal@@@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@PAVCPortal@@V?$xalloc@PAVCPortal@@@@@std@@QBEIXZ PROC ; std::vector<CPortal *,xalloc<CPortal *> >::max_size, COMDAT
; _this$dead$ = ecx

; 1540 :         return (_STD min)(

	mov	eax, 1073741823				; 3fffffffH

; 1541 :             static_cast<size_type>((numeric_limits<difference_type>::max)()), _Alty_traits::max_size(_Getal()));
; 1542 :     }

	ret	0
?max_size@?$vector@PAVCPortal@@V?$xalloc@PAVCPortal@@@@@std@@QBEIXZ ENDP ; std::vector<CPortal *,xalloc<CPortal *> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?size@?$vector@PAVCPortal@@V?$xalloc@PAVCPortal@@@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@PAVCPortal@@V?$xalloc@PAVCPortal@@@@@std@@QBEIXZ PROC ; std::vector<CPortal *,xalloc<CPortal *> >::size, COMDAT
; _this$ = ecx

; 1535 :         auto& _My_data = _Mypair._Myval2;
; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	eax, DWORD PTR [ecx+4]
	sub	eax, DWORD PTR [ecx]
	sar	eax, 2

; 1537 :     }

	ret	0
?size@?$vector@PAVCPortal@@V?$xalloc@PAVCPortal@@@@@std@@QBEIXZ ENDP ; std::vector<CPortal *,xalloc<CPortal *> >::size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?begin@?$vector@PAVCPortal@@V?$xalloc@PAVCPortal@@@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPortal@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@PAVCPortal@@V?$xalloc@PAVCPortal@@@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPortal@@@std@@@std@@@2@XZ PROC ; std::vector<CPortal *,xalloc<CPortal *> >::begin, COMDAT
; _this$ = ecx

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	ecx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], ecx

; 1462 :         auto& _My_data = _Mypair._Myval2;
; 1463 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));
; 1464 :     }

	ret	4
?begin@?$vector@PAVCPortal@@V?$xalloc@PAVCPortal@@@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPortal@@@std@@@std@@@2@XZ ENDP ; std::vector<CPortal *,xalloc<CPortal *> >::begin
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Reallocate_exactly@?$vector@PAVCPortal@@V?$xalloc@PAVCPortal@@@@@std@@AAEXI@Z
_TEXT	SEGMENT
__Backout$2 = -40					; size = 12
__Newvec$ = -28						; size = 4
__Size$1$ = -24						; size = 4
__UFirst$3 = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Newcapacity$ = 8					; size = 4
?_Reallocate_exactly@?$vector@PAVCPortal@@V?$xalloc@PAVCPortal@@@@@std@@AAEXI@Z PROC ; std::vector<CPortal *,xalloc<CPortal *> >::_Reallocate_exactly, COMDAT
; _this$ = ecx

; 1286 :     _CONSTEXPR20_CONTAINER void _Reallocate_exactly(const size_type _Newcapacity) {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Reallocate_exactly@?$vector@PAVCPortal@@V?$xalloc@PAVCPortal@@@@@std@@AAEXI@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 28					; 0000001cH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	esi, ecx

; 1287 :         // set capacity to _Newcapacity (without geometric growth), provide strong guarantee
; 1288 :         auto& _My_data    = _Mypair._Myval2;
; 1289 :         pointer& _Myfirst = _My_data._Myfirst;
; 1290 :         pointer& _Mylast  = _My_data._Mylast;
; 1291 : 
; 1292 :         const auto _Size = static_cast<size_type>(_Mylast - _Myfirst);

	mov	eax, DWORD PTR [esi+4]
	sub	eax, DWORD PTR [esi]
	sar	eax, 2
	mov	DWORD PTR __Size$1$[ebp], eax
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	mov	eax, DWORD PTR __Newcapacity$[ebp]
	shl	eax, 2
	push	eax
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1294 :         const pointer _Newvec = _Getal().allocate(_Newcapacity);

	mov	ebx, eax
	mov	DWORD PTR __Newvec$[ebp], ebx

; 1295 : 
; 1296 :         _TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 1297 :         _Umove_if_noexcept(_Myfirst, _Mylast, _Newvec);

	mov	edi, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1703 :     auto _UFirst      = _Get_unwrapped(_First);

	mov	DWORD PTR __UFirst$3[ebp], ecx

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	DWORD PTR __Backout$2[ebp], ebx
	mov	edx, ebx
	mov	DWORD PTR __Backout$2[ebp+4], edx
	mov	DWORD PTR __Backout$2[ebp+8], esi
$LL19@Reallocate:

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	ecx, edi
	je	SHORT $LN18@Reallocate

; 1620 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax

; 1621 :         ++_Last;

	add	edx, 4
	mov	DWORD PTR __Backout$2[ebp+4], edx

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	add	ecx, 4
	mov	DWORD PTR __UFirst$3[ebp], ecx
	jmp	SHORT $LL19@Reallocate
$LN18@Reallocate:

; 1625 :         _First = _Last;

	mov	DWORD PTR __Backout$2[ebp], edx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
	mov	DWORD PTR __$EHRec$[ebp+12], -1

; 1732 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN33@Reallocate
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	push	eax
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN33@Reallocate:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1737 :         _Myfirst = _Newvec;

	mov	DWORD PTR [esi], ebx

; 1738 :         _Mylast  = _Newvec + _Newsize;

	mov	eax, DWORD PTR __Size$1$[ebp]
	lea	eax, DWORD PTR [ebx+eax*4]
	mov	DWORD PTR [esi+4], eax

; 1739 :         _Myend   = _Newvec + _Newcapacity;

	mov	eax, DWORD PTR __Newcapacity$[ebp]
	lea	eax, DWORD PTR [ebx+eax*4]
	mov	DWORD PTR [esi+8], eax

; 1301 :         _CATCH_END
; 1302 : 
; 1303 :         _Change_array(_Newvec, _Size, _Newcapacity);
; 1304 :     }

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
__catch$?_Reallocate_exactly@?$vector@PAVCPortal@@V?$xalloc@PAVCPortal@@@@@std@@AAEXI@Z$0:

; 1298 :         _CATCH_ALL
; 1299 :         _Getal().deallocate(_Newvec, _Newcapacity);

	push	ecx
	push	DWORD PTR __Newvec$[ebp]
	call	?deallocate@?$xalloc@PAVCPortal@@@@QBEXPAPAVCPortal@@I@Z ; xalloc<CPortal *>::deallocate

; 1300 :         _RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$LN39@Reallocate:
	int	3
	int	3
	int	3
	int	3
	int	3
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Reallocate_exactly@?$vector@PAVCPortal@@V?$xalloc@PAVCPortal@@@@@std@@AAEXI@Z:
	npad	1
	npad	1
	mov	eax, OFFSET __ehfuncinfo$?_Reallocate_exactly@?$vector@PAVCPortal@@V?$xalloc@PAVCPortal@@@@@std@@AAEXI@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Reallocate_exactly@?$vector@PAVCPortal@@V?$xalloc@PAVCPortal@@@@@std@@AAEXI@Z ENDP ; std::vector<CPortal *,xalloc<CPortal *> >::_Reallocate_exactly
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPortal@@@std@@@std@@@std@@QAE@PAPAVCPortal@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
___param0$ = 8						; size = 4
___param1$dead$ = 12					; size = 4
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPortal@@@std@@@std@@@std@@QAE@PAPAVCPortal@@PBU_Container_base0@1@@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CPortal *> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<CPortal *> > >, COMDAT
; _this$ = ecx

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	eax, DWORD PTR ___param0$[esp-4]
	mov	DWORD PTR [ecx], eax
	mov	eax, ecx
	ret	8
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPortal@@@std@@@std@@@std@@QAE@PAPAVCPortal@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CPortal *> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<CPortal *> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPortal@@@std@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPortal@@@std@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CPortal *> > >::operator+=, COMDAT
; _this$ = ecx

; 119  :         _Ptr += _Off;

	mov	eax, DWORD PTR __Off$[esp-4]
	shl	eax, 2
	add	DWORD PTR [ecx], eax

; 298  :         _Mybase::operator+=(_Off);
; 299  :         return *this;

	mov	eax, ecx

; 300  :     }

	ret	4
??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPortal@@@std@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CPortal *> > >::operator+=
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPortal@@@std@@@std@@@std@@QBEABQAVCPortal@@XZ
_TEXT	SEGMENT
??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPortal@@@std@@@std@@@std@@QBEABQAVCPortal@@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CPortal *> > >::operator*, COMDAT
; _this$ = ecx

; 46   : #if _ITERATOR_DEBUG_LEVEL != 0
; 47   :         const auto _Mycont = static_cast<const _Myvec*>(this->_Getcont());
; 48   :         _STL_VERIFY(_Ptr, "can't dereference value-initialized vector iterator");
; 49   :         _STL_VERIFY(
; 50   :             _Mycont->_Myfirst <= _Ptr && _Ptr < _Mycont->_Mylast, "can't dereference out of range vector iterator");
; 51   : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 52   : 
; 53   :         return *_Ptr;

	mov	eax, DWORD PTR [ecx]

; 54   :     }

	ret	0
??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPortal@@@std@@@std@@@std@@QBEABQAVCPortal@@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CPortal *> > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPortal@@@std@@@std@@@std@@QAE@PAPAVCPortal@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Pvector$dead$ = 12					; size = 4
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPortal@@@std@@@std@@@std@@QAE@PAPAVCPortal@@PBU_Container_base0@1@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CPortal *> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CPortal *> > >, COMDAT
; _this$ = ecx

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	eax, DWORD PTR __Parg$[esp-4]
	mov	DWORD PTR [ecx], eax

; 42   :         this->_Adopt(_Pvector);
; 43   :     }

	mov	eax, ecx
	ret	8
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPortal@@@std@@@std@@@std@@QAE@PAPAVCPortal@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CPortal *> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CPortal *> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$xalloc@PAVIRender_Sector@@@@V?$_Vector_val@U?$_Simple_types@PAVIRender_Sector@@@std@@@std@@$00@std@@QAEAAV?$xalloc@PAVIRender_Sector@@@@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@V?$xalloc@PAVIRender_Sector@@@@V?$_Vector_val@U?$_Simple_types@PAVIRender_Sector@@@std@@@std@@$00@std@@QAEAAV?$xalloc@PAVIRender_Sector@@@@XZ PROC ; std::_Compressed_pair<xalloc<IRender_Sector *>,std::_Vector_val<std::_Simple_types<IRender_Sector *> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 1339 :         return *this;

	mov	eax, ecx

; 1340 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$xalloc@PAVIRender_Sector@@@@V?$_Vector_val@U?$_Simple_types@PAVIRender_Sector@@@std@@@std@@$00@std@@QAEAAV?$xalloc@PAVIRender_Sector@@@@XZ ENDP ; std::_Compressed_pair<xalloc<IRender_Sector *>,std::_Vector_val<std::_Simple_types<IRender_Sector *> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?clear@?$vector@U_scissor@@V?$xalloc@U_scissor@@@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$vector@U_scissor@@V?$xalloc@U_scissor@@@@@std@@QAEXXZ PROC ; std::vector<_scissor,xalloc<_scissor> >::clear, COMDAT
; _this$ = ecx

; 1437 :         auto& _My_data    = _Mypair._Myval2;
; 1438 :         pointer& _Myfirst = _My_data._Myfirst;
; 1439 :         pointer& _Mylast  = _My_data._Mylast;
; 1440 : 
; 1441 :         _My_data._Orphan_all();
; 1442 :         _Destroy(_Myfirst, _Mylast);
; 1443 :         _Mylast = _Myfirst;

	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [ecx+4], eax

; 1444 :     }

	ret	0
?clear@?$vector@U_scissor@@V?$xalloc@U_scissor@@@@@std@@QAEXXZ ENDP ; std::vector<_scissor,xalloc<_scissor> >::clear
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?clear@?$vector@VCFrustum@@V?$xalloc@VCFrustum@@@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$vector@VCFrustum@@V?$xalloc@VCFrustum@@@@@std@@QAEXXZ PROC ; std::vector<CFrustum,xalloc<CFrustum> >::clear, COMDAT
; _this$ = ecx

; 1437 :         auto& _My_data    = _Mypair._Myval2;
; 1438 :         pointer& _Myfirst = _My_data._Myfirst;
; 1439 :         pointer& _Mylast  = _My_data._Mylast;
; 1440 : 
; 1441 :         _My_data._Orphan_all();
; 1442 :         _Destroy(_Myfirst, _Mylast);
; 1443 :         _Mylast = _Myfirst;

	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [ecx+4], eax

; 1444 :     }

	ret	0
?clear@?$vector@VCFrustum@@V?$xalloc@VCFrustum@@@@@std@@QAEXXZ ENDP ; std::vector<CFrustum,xalloc<CFrustum> >::clear
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Getal@?$vector@PAVCPortal@@V?$xalloc@PAVCPortal@@@@@std@@ABEABV?$xalloc@PAVCPortal@@@@XZ
_TEXT	SEGMENT
?_Getal@?$vector@PAVCPortal@@V?$xalloc@PAVCPortal@@@@@std@@ABEABV?$xalloc@PAVCPortal@@@@XZ PROC ; std::vector<CPortal *,xalloc<CPortal *> >::_Getal, COMDAT
; _this$ = ecx

; 1809 :         return _Mypair._Get_first();

	mov	eax, ecx

; 1810 :     }

	ret	0
?_Getal@?$vector@PAVCPortal@@V?$xalloc@PAVCPortal@@@@@std@@ABEABV?$xalloc@PAVCPortal@@@@XZ ENDP ; std::vector<CPortal *,xalloc<CPortal *> >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Change_array@?$vector@PAVCPortal@@V?$xalloc@PAVCPortal@@@@@std@@AAEXQAPAVCPortal@@II@Z
_TEXT	SEGMENT
__Newvec$ = 8						; size = 4
__Newsize$ = 12						; size = 4
__Newcapacity$ = 16					; size = 4
?_Change_array@?$vector@PAVCPortal@@V?$xalloc@PAVCPortal@@@@@std@@AAEXQAPAVCPortal@@II@Z PROC ; std::vector<CPortal *,xalloc<CPortal *> >::_Change_array, COMDAT
; _this$ = ecx

; 1723 :         const pointer _Newvec, const size_type _Newsize, const size_type _Newcapacity) {

	push	esi
	mov	esi, ecx

; 1724 :         // orphan all iterators, discard old array, acquire new array
; 1725 :         auto& _My_data    = _Mypair._Myval2;
; 1726 :         pointer& _Myfirst = _My_data._Myfirst;
; 1727 :         pointer& _Mylast  = _My_data._Mylast;
; 1728 :         pointer& _Myend   = _My_data._Myend;
; 1729 : 
; 1730 :         _My_data._Orphan_all();
; 1731 : 
; 1732 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN7@Change_arr
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN7@Change_arr:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1737 :         _Myfirst = _Newvec;

	mov	ecx, DWORD PTR __Newvec$[esp]

; 1738 :         _Mylast  = _Newvec + _Newsize;

	mov	eax, DWORD PTR __Newsize$[esp]
	mov	DWORD PTR [esi], ecx
	lea	eax, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR [esi+4], eax

; 1739 :         _Myend   = _Newvec + _Newcapacity;

	mov	eax, DWORD PTR __Newcapacity$[esp]
	lea	eax, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR [esi+8], eax
	pop	esi

; 1740 :     }

	ret	12					; 0000000cH
?_Change_array@?$vector@PAVCPortal@@V?$xalloc@PAVCPortal@@@@@std@@AAEXQAPAVCPortal@@II@Z ENDP ; std::vector<CPortal *,xalloc<CPortal *> >::_Change_array
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Umove_if_noexcept@?$vector@PAVCPortal@@V?$xalloc@PAVCPortal@@@@@std@@AAEXPAPAVCPortal@@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
?_Umove_if_noexcept@?$vector@PAVCPortal@@V?$xalloc@PAVCPortal@@@@@std@@AAEXPAPAVCPortal@@00@Z PROC ; std::vector<CPortal *,xalloc<CPortal *> >::_Umove_if_noexcept, COMDAT
; _this$dead$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1703 :     auto _UFirst      = _Get_unwrapped(_First);

	mov	eax, DWORD PTR __First$[esp-4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1659 :     _CONSTEXPR20_CONTAINER void _Umove_if_noexcept(pointer _First, pointer _Last, pointer _Dest) {

	push	esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	mov	esi, DWORD PTR __Last$[esp]
	cmp	eax, esi
	je	SHORT $LN7@Umove_if_n

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	edx, DWORD PTR __Dest$[esp]
	sub	edx, eax
$LL8@Umove_if_n:

; 1620 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx+eax], ecx

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	add	eax, 4
	cmp	eax, esi
	jne	SHORT $LL8@Umove_if_n
$LN7@Umove_if_n:
	pop	esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1663 :     }

	ret	12					; 0000000cH
?_Umove_if_noexcept@?$vector@PAVCPortal@@V?$xalloc@PAVCPortal@@@@@std@@AAEXPAPAVCPortal@@00@Z ENDP ; std::vector<CPortal *,xalloc<CPortal *> >::_Umove_if_noexcept
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?max_size@?$_Normal_allocator_traits@V?$xalloc@PAVCPortal@@@@@std@@SAIABV?$xalloc@PAVCPortal@@@@@Z
_TEXT	SEGMENT
?max_size@?$_Normal_allocator_traits@V?$xalloc@PAVCPortal@@@@@std@@SAIABV?$xalloc@PAVCPortal@@@@@Z PROC ; std::_Normal_allocator_traits<xalloc<CPortal *> >::max_size, COMDAT
; __Al$dead$ = ecx

; 591  :         if constexpr (_Has_max_size<_Alloc>::value) {
; 592  :             return _Al.max_size();

	mov	eax, 1073741823				; 3fffffffH

; 593  :         } else {
; 594  :             return (numeric_limits<size_type>::max)() / sizeof(value_type);
; 595  :         }
; 596  :     }

	ret	0
?max_size@?$_Normal_allocator_traits@V?$xalloc@PAVCPortal@@@@@std@@SAIABV?$xalloc@PAVCPortal@@@@@Z ENDP ; std::_Normal_allocator_traits<xalloc<CPortal *> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?allocate@?$xalloc@PAVCPortal@@@@QBEPAPAVCPortal@@IPBX@Z
_TEXT	SEGMENT
_n$ = 8							; size = 4
_p$dead$ = 12						; size = 4
?allocate@?$xalloc@PAVCPortal@@@@QBEPAPAVCPortal@@IPBX@Z PROC ; xalloc<CPortal *>::allocate, COMDAT
; _this$dead$ = ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	mov	eax, DWORD PTR _n$[esp-4]
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	shl	eax, 2
	push	eax
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 80   : 							pointer					allocate		(size_type n, const void* p=0) const	{	return xr_alloc<T>((u32)n);	}

	ret	8
?allocate@?$xalloc@PAVCPortal@@@@QBEPAPAVCPortal@@IPBX@Z ENDP ; xalloc<CPortal *>::allocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPortal@@@std@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPortal@@@std@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CPortal *> > >::operator+=, COMDAT
; _this$ = ecx

; 118  :         _Verify_offset(_Off);
; 119  :         _Ptr += _Off;

	mov	eax, DWORD PTR __Off$[esp-4]
	shl	eax, 2
	add	DWORD PTR [ecx], eax

; 120  :         return *this;

	mov	eax, ecx

; 121  :     }

	ret	4
??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPortal@@@std@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CPortal *> > >::operator+=
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$xalloc@PAVCPortal@@@@V?$_Vector_val@U?$_Simple_types@PAVCPortal@@@std@@@std@@$00@std@@QBEABV?$xalloc@PAVCPortal@@@@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@V?$xalloc@PAVCPortal@@@@V?$_Vector_val@U?$_Simple_types@PAVCPortal@@@std@@@std@@$00@std@@QBEABV?$xalloc@PAVCPortal@@@@XZ PROC ; std::_Compressed_pair<xalloc<CPortal *>,std::_Vector_val<std::_Simple_types<CPortal *> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 1343 :         return *this;

	mov	eax, ecx

; 1344 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$xalloc@PAVCPortal@@@@V?$_Vector_val@U?$_Simple_types@PAVCPortal@@@std@@@std@@$00@std@@QBEABV?$xalloc@PAVCPortal@@@@XZ ENDP ; std::_Compressed_pair<xalloc<CPortal *>,std::_Vector_val<std::_Simple_types<CPortal *> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Umove_if_noexcept1@?$vector@PAVCPortal@@V?$xalloc@PAVCPortal@@@@@std@@AAEXPAPAVCPortal@@00U?$integral_constant@_N$00@2@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
?_Umove_if_noexcept1@?$vector@PAVCPortal@@V?$xalloc@PAVCPortal@@@@@std@@AAEXPAPAVCPortal@@00U?$integral_constant@_N$00@2@@Z PROC ; std::vector<CPortal *,xalloc<CPortal *> >::_Umove_if_noexcept1, COMDAT
; _this$dead$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1703 :     auto _UFirst      = _Get_unwrapped(_First);

	mov	eax, DWORD PTR __First$[esp-4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1649 :     _CONSTEXPR20_CONTAINER void _Umove_if_noexcept1(pointer _First, pointer _Last, pointer _Dest, true_type) {

	push	esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	mov	esi, DWORD PTR __Last$[esp]
	cmp	eax, esi
	je	SHORT $LN5@Umove_if_n

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	edx, DWORD PTR __Dest$[esp]
	sub	edx, eax
$LL6@Umove_if_n:

; 1620 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx+eax], ecx

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	add	eax, 4
	cmp	eax, esi
	jne	SHORT $LL6@Umove_if_n
$LN5@Umove_if_n:
	pop	esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1652 :     }

	ret	16					; 00000010H
?_Umove_if_noexcept1@?$vector@PAVCPortal@@V?$xalloc@PAVCPortal@@@@@std@@AAEXPAPAVCPortal@@00U?$integral_constant@_N$00@2@@Z ENDP ; std::vector<CPortal *,xalloc<CPortal *> >::_Umove_if_noexcept1
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?max_size@?$xalloc@PAVCPortal@@@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$xalloc@PAVCPortal@@@@QBEIXZ PROC		; xalloc<CPortal *>::max_size, COMDAT
; _this$dead$ = ecx

; 86   : 							size_type				max_size		() const								{	size_type _Count = (size_type)(-1) / sizeof (T);	return (0 < _Count ? _Count : 1);	}

	mov	eax, 1073741823				; 3fffffffH
	ret	0
?max_size@?$xalloc@PAVCPortal@@@@QBEIXZ ENDP		; xalloc<CPortal *>::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Verify_offset@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPortal@@@std@@@std@@@std@@QBEXH@Z
_TEXT	SEGMENT
__Off$dead$ = 8						; size = 4
?_Verify_offset@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPortal@@@std@@@std@@@std@@QBEXH@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CPortal *> > >::_Verify_offset, COMDAT
; _this$dead$ = ecx

; 102  : #if _ITERATOR_DEBUG_LEVEL == 0
; 103  :         (void) _Off;
; 104  : #else // ^^^ _ITERATOR_DEBUG_LEVEL == 0 ^^^ // vvv _ITERATOR_DEBUG_LEVEL != 0 vvv
; 105  :         const auto _Mycont = static_cast<const _Myvec*>(this->_Getcont());
; 106  :         _STL_VERIFY(_Off == 0 || _Ptr, "cannot seek value-initialized vector iterator");
; 107  :         if (_Off < 0) {
; 108  :             _STL_VERIFY(_Off >= _Mycont->_Myfirst - _Ptr, "cannot seek vector iterator before begin");
; 109  :         }
; 110  : 
; 111  :         if (_Off > 0) {
; 112  :             _STL_VERIFY(_Off <= _Mycont->_Mylast - _Ptr, "cannot seek vector iterator after end");
; 113  :         }
; 114  : #endif // _ITERATOR_DEBUG_LEVEL == 0
; 115  :     }

	ret	4
?_Verify_offset@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPortal@@@std@@@std@@@std@@QBEXH@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CPortal *> > >::_Verify_offset
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\type_traits
;	COMDAT ??$move@AAPAVIRender_Sector@@@std@@YA$$QAPAVIRender_Sector@@AAPAV1@@Z
_TEXT	SEGMENT
??$move@AAPAVIRender_Sector@@@std@@YA$$QAPAVIRender_Sector@@AAPAV1@@Z PROC ; std::move<IRender_Sector * &>, COMDAT
; __Arg$ = ecx

; 1397 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

	mov	eax, ecx

; 1398 : }

	ret	0
??$move@AAPAVIRender_Sector@@@std@@YA$$QAPAVIRender_Sector@@AAPAV1@@Z ENDP ; std::move<IRender_Sector * &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\type_traits
;	COMDAT ??$forward@PAVIRender_Sector@@@std@@YA$$QAPAVIRender_Sector@@AAPAV1@@Z
_TEXT	SEGMENT
??$forward@PAVIRender_Sector@@@std@@YA$$QAPAVIRender_Sector@@AAPAV1@@Z PROC ; std::forward<IRender_Sector *>, COMDAT
; __Arg$ = ecx

; 1386 :     return static_cast<_Ty&&>(_Arg);

	mov	eax, ecx

; 1387 : }

	ret	0
??$forward@PAVIRender_Sector@@@std@@YA$$QAPAVIRender_Sector@@AAPAV1@@Z ENDP ; std::forward<IRender_Sector *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef
;	COMDAT ??$_Unfancy@PAVIRender_Sector@@@std@@YAPAPAVIRender_Sector@@PAPAV1@@Z
_TEXT	SEGMENT
??$_Unfancy@PAVIRender_Sector@@@std@@YAPAPAVIRender_Sector@@PAPAV1@@Z PROC ; std::_Unfancy<IRender_Sector *>, COMDAT
; __Ptr$ = ecx

; 266  :     return _Ptr;

	mov	eax, ecx

; 267  : }

	ret	0
??$_Unfancy@PAVIRender_Sector@@@std@@YAPAPAVIRender_Sector@@PAPAV1@@Z ENDP ; std::_Unfancy<IRender_Sector *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$construct@PAVIRender_Sector@@PAV1@@?$_Normal_allocator_traits@V?$xalloc@PAVIRender_Sector@@@@@std@@SAXAAV?$xalloc@PAVIRender_Sector@@@@PAPAVIRender_Sector@@$$QAPAV3@@Z
_TEXT	SEGMENT
_<_Args_0>$ = 8						; size = 4
??$construct@PAVIRender_Sector@@PAV1@@?$_Normal_allocator_traits@V?$xalloc@PAVIRender_Sector@@@@@std@@SAXAAV?$xalloc@PAVIRender_Sector@@@@PAPAVIRender_Sector@@$$QAPAV3@@Z PROC ; std::_Normal_allocator_traits<xalloc<IRender_Sector *> >::construct<IRender_Sector *,IRender_Sector *>, COMDAT
; __Al$dead$ = ecx
; __Ptr$ = edx

; 565  :         if constexpr (_Uses_default_construct<_Alloc, _Ty*, _Types...>::value) {
; 566  :             (void) _Al; // TRANSITION, DevCom-1004719
; 567  : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 568  :             _STD construct_at(_Ptr, _STD forward<_Types>(_Args)...);
; 569  : #else // __cpp_lib_constexpr_dynamic_alloc
; 570  :             ::new (static_cast<void*>(_Ptr)) _Ty(_STD forward<_Types>(_Args)...);
; 571  : #endif // __cpp_lib_constexpr_dynamic_alloc
; 572  :         } else {
; 573  :             _Al.construct(_Ptr, _STD forward<_Types>(_Args)...);

	mov	eax, DWORD PTR _<_Args_0>$[esp-4]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edx], eax

; 574  :         }
; 575  :     }

	ret	0
??$construct@PAVIRender_Sector@@PAV1@@?$_Normal_allocator_traits@V?$xalloc@PAVIRender_Sector@@@@@std@@SAXAAV?$xalloc@PAVIRender_Sector@@@@PAPAVIRender_Sector@@$$QAPAV3@@Z ENDP ; std::_Normal_allocator_traits<xalloc<IRender_Sector *> >::construct<IRender_Sector *,IRender_Sector *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??$_Emplace_reallocate@PAVIRender_Sector@@@?$vector@PAVIRender_Sector@@V?$xalloc@PAVIRender_Sector@@@@@std@@QAEPAPAVIRender_Sector@@QAPAV2@$$QAPAV2@@Z
_TEXT	SEGMENT
__Backout$2 = -76					; size = 12
__Backout$3 = -64					; size = 12
__Backout$4 = -52					; size = 12
__UFirst$5 = -40					; size = 4
__UFirst$6 = -36					; size = 4
__UFirst$7 = -32					; size = 4
__Newvec$ = -28						; size = 4
__Newcapacity$1$ = -24					; size = 4
__Newsize$1$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
tv555 = 8						; size = 4
__Whereptr$ = 8						; size = 4
_<_Val_0>$ = 12						; size = 4
??$_Emplace_reallocate@PAVIRender_Sector@@@?$vector@PAVIRender_Sector@@V?$xalloc@PAVIRender_Sector@@@@@std@@QAEPAPAVIRender_Sector@@QAPAV2@$$QAPAV2@@Z PROC ; std::vector<IRender_Sector *,xalloc<IRender_Sector *> >::_Emplace_reallocate<IRender_Sector *>, COMDAT
; _this$ = ecx

; 752  :     _CONSTEXPR20_CONTAINER pointer _Emplace_reallocate(const pointer _Whereptr, _Valty&&... _Val) {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Emplace_reallocate@PAVIRender_Sector@@@?$vector@PAVIRender_Sector@@V?$xalloc@PAVIRender_Sector@@@@@std@@QAEPAPAVIRender_Sector@@QAPAV2@$$QAPAV2@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	edi, ecx

; 753  :         // reallocate and insert by perfectly forwarding _Val at _Whereptr
; 754  :         _Alty& _Al        = _Getal();
; 755  :         auto& _My_data    = _Mypair._Myval2;
; 756  :         pointer& _Myfirst = _My_data._Myfirst;
; 757  :         pointer& _Mylast  = _My_data._Mylast;
; 758  : 
; 759  :         _STL_INTERNAL_CHECK(_Mylast == _My_data._Myend); // check that we have no unused capacity
; 760  : 
; 761  :         const auto _Whereoff = static_cast<size_type>(_Whereptr - _Myfirst);

	mov	edx, DWORD PTR [edi]
	mov	esi, DWORD PTR __Whereptr$[ebp]
	mov	ebx, esi
	sub	ebx, edx
	sar	ebx, 2

; 762  :         const auto _Oldsize  = static_cast<size_type>(_Mylast - _Myfirst);

	mov	eax, DWORD PTR [edi+4]
	sub	eax, edx
	sar	eax, 2

; 763  : 
; 764  :         if (_Oldsize == max_size()) {

	cmp	eax, 1073741823				; 3fffffffH
	je	$LN83@Emplace_re

; 766  :         }
; 767  : 
; 768  :         const size_type _Newsize     = _Oldsize + 1;

	inc	eax
	mov	DWORD PTR __Newsize$1$[ebp], eax

; 1546 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	ecx, DWORD PTR [edi+8]
	sub	ecx, edx
	sar	ecx, 2

; 1675 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	edx, ecx
	shr	edx, 1
	mov	eax, 1073741823				; 3fffffffH
	sub	eax, edx
	cmp	ecx, eax
	jbe	SHORT $LN12@Emplace_re

; 1676 :             return _Max; // geometric growth would overflow

	mov	eax, 1073741823				; 3fffffffH
	jmp	SHORT $LN81@Emplace_re
$LN12@Emplace_re:

; 1677 :         }
; 1678 : 
; 1679 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	lea	eax, DWORD PTR [edx+ecx]

; 1680 : 
; 1681 :         if (_Geometric < _Newsize) {

	cmp	eax, DWORD PTR __Newsize$1$[ebp]
	cmovb	eax, DWORD PTR __Newsize$1$[ebp]
$LN81@Emplace_re:
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	mov	DWORD PTR __Newcapacity$1$[ebp], eax
	shl	eax, 2
	push	eax
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 771  :         const pointer _Newvec           = _Al.allocate(_Newcapacity);

	mov	edx, eax
	mov	DWORD PTR __Newvec$[ebp], edx

; 772  :         const pointer _Constructed_last = _Newvec + _Whereoff + 1;
; 773  :         pointer _Constructed_first      = _Constructed_last;
; 774  : 
; 775  :         _TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 776  :         _Alty_traits::construct(_Al, _Unfancy(_Newvec + _Whereoff), _STD forward<_Valty>(_Val)...);

	lea	ecx, DWORD PTR [edx+ebx*4]
	mov	DWORD PTR tv555[ebp], ecx
	mov	eax, DWORD PTR _<_Val_0>$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax

; 777  :         _Constructed_first = _Newvec + _Whereoff;
; 778  : 
; 779  :         if (_Whereptr == _Mylast) { // at back, provide strong guarantee

	mov	ebx, DWORD PTR [edi+4]
	mov	ecx, DWORD PTR [edi]
	cmp	esi, ebx
	jne	SHORT $LN4@Emplace_re
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1703 :     auto _UFirst      = _Get_unwrapped(_First);

	mov	DWORD PTR __UFirst$7[ebp], ecx

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	DWORD PTR __Backout$4[ebp], edx
	mov	DWORD PTR __Backout$4[ebp+4], edx
	mov	DWORD PTR __Backout$4[ebp+8], edi
	npad	1
$LL28@Emplace_re:

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	ecx, ebx
	je	SHORT $LN27@Emplace_re

; 1620 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax

; 1621 :         ++_Last;

	add	edx, 4
	mov	DWORD PTR __Backout$4[ebp+4], edx

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	add	ecx, 4
	mov	DWORD PTR __UFirst$7[ebp], ecx
	jmp	SHORT $LL28@Emplace_re
$LN27@Emplace_re:

; 1625 :         _First = _Last;

	mov	DWORD PTR __Backout$4[ebp], edx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 781  :         } else { // provide basic guarantee

	mov	ebx, DWORD PTR tv555[ebp]
	jmp	SHORT $LN5@Emplace_re
$LN4@Emplace_re:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1703 :     auto _UFirst      = _Get_unwrapped(_First);

	mov	DWORD PTR __UFirst$6[ebp], ecx

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	DWORD PTR __Backout$3[ebp], edx
	mov	DWORD PTR __Backout$3[ebp+4], edx
	mov	DWORD PTR __Backout$3[ebp+8], edi
	npad	6
$LL41@Emplace_re:

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	ecx, esi
	je	SHORT $LN40@Emplace_re

; 1620 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax

; 1621 :         ++_Last;

	add	edx, 4
	mov	DWORD PTR __Backout$3[ebp+4], edx

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	add	ecx, 4
	mov	DWORD PTR __UFirst$6[ebp], ecx
	jmp	SHORT $LL41@Emplace_re
$LN40@Emplace_re:

; 1625 :         _First = _Last;

	mov	DWORD PTR __Backout$3[ebp], edx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 784  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

	mov	ebx, DWORD PTR tv555[ebp]
	lea	ecx, DWORD PTR [ebx+4]

; 1646 :         return _Uninitialized_move(_First, _Last, _Dest, _Getal());

	mov	edx, DWORD PTR [edi+4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1703 :     auto _UFirst      = _Get_unwrapped(_First);

	mov	DWORD PTR __UFirst$5[ebp], esi

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	DWORD PTR __Backout$2[ebp], ecx
	mov	DWORD PTR __Backout$2[ebp+4], ecx
	mov	DWORD PTR __Backout$2[ebp+8], edi
	npad	2
$LL54@Emplace_re:

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	esi, edx
	je	SHORT $LN53@Emplace_re

; 1620 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [ecx], eax

; 1621 :         ++_Last;

	add	ecx, 4
	mov	DWORD PTR __Backout$2[ebp+4], ecx

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	add	esi, 4
	mov	DWORD PTR __UFirst$5[ebp], esi
	jmp	SHORT $LL54@Emplace_re
$LN53@Emplace_re:

; 1625 :         _First = _Last;

	mov	DWORD PTR __Backout$2[ebp], ecx
$LN5@Emplace_re:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
	mov	DWORD PTR __$EHRec$[ebp+12], -1

; 1732 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [edi]
	test	eax, eax
	je	SHORT $LN68@Emplace_re
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	push	eax
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN68@Emplace_re:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1737 :         _Myfirst = _Newvec;

	mov	eax, DWORD PTR __Newvec$[ebp]
	mov	DWORD PTR [edi], eax

; 1738 :         _Mylast  = _Newvec + _Newsize;

	mov	ecx, DWORD PTR __Newsize$1$[ebp]
	lea	ecx, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR [edi+4], ecx

; 1739 :         _Myend   = _Newvec + _Newcapacity;

	mov	ecx, DWORD PTR __Newcapacity$1$[ebp]
	lea	ecx, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR [edi+8], ecx

; 790  :         _CATCH_END
; 791  : 
; 792  :         _Change_array(_Newvec, _Newsize, _Newcapacity);
; 793  :         return _Newvec + _Whereoff;

	mov	eax, ebx

; 794  :     }

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
__catch$??$_Emplace_reallocate@PAVIRender_Sector@@@?$vector@PAVIRender_Sector@@V?$xalloc@PAVIRender_Sector@@@@@std@@QAEPAPAVIRender_Sector@@QAPAV2@$$QAPAV2@@Z$0:

; 785  :         }
; 786  :         _CATCH_ALL
; 787  :         _Destroy(_Constructed_first, _Constructed_last);
; 788  :         _Al.deallocate(_Newvec, _Newcapacity);

	push	ecx
	push	DWORD PTR __Newvec$[ebp]
	call	?deallocate@?$xalloc@PAVIRender_Sector@@@@QBEXPAPAVIRender_Sector@@I@Z ; xalloc<IRender_Sector *>::deallocate

; 789  :         _RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$LN83@Emplace_re:

; 765  :             _Xlength();

	call	?_Xlength@?$vector@PAVIRender_Sector@@V?$xalloc@PAVIRender_Sector@@@@@std@@CAXXZ ; std::vector<IRender_Sector *,xalloc<IRender_Sector *> >::_Xlength
$LN80@Emplace_re:
	int	3
	int	3
	int	3
	int	3
	int	3
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Emplace_reallocate@PAVIRender_Sector@@@?$vector@PAVIRender_Sector@@V?$xalloc@PAVIRender_Sector@@@@@std@@QAEPAPAVIRender_Sector@@QAPAV2@$$QAPAV2@@Z:
	npad	1
	npad	1
	mov	eax, OFFSET __ehfuncinfo$??$_Emplace_reallocate@PAVIRender_Sector@@@?$vector@PAVIRender_Sector@@V?$xalloc@PAVIRender_Sector@@@@@std@@QAEPAPAVIRender_Sector@@QAPAV2@$$QAPAV2@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Emplace_reallocate@PAVIRender_Sector@@@?$vector@PAVIRender_Sector@@V?$xalloc@PAVIRender_Sector@@@@@std@@QAEPAPAVIRender_Sector@@QAPAV2@$$QAPAV2@@Z ENDP ; std::vector<IRender_Sector *,xalloc<IRender_Sector *> >::_Emplace_reallocate<IRender_Sector *>
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\type_traits
;	COMDAT ??$forward@ABU_scissor@@@std@@YAABU_scissor@@ABU1@@Z
_TEXT	SEGMENT
??$forward@ABU_scissor@@@std@@YAABU_scissor@@ABU1@@Z PROC ; std::forward<_scissor const &>, COMDAT
; __Arg$ = ecx

; 1386 :     return static_cast<_Ty&&>(_Arg);

	mov	eax, ecx

; 1387 : }

	ret	0
??$forward@ABU_scissor@@@std@@YAABU_scissor@@ABU1@@Z ENDP ; std::forward<_scissor const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$construct@U_scissor@@ABU1@@?$_Normal_allocator_traits@V?$xalloc@U_scissor@@@@@std@@SAXAAV?$xalloc@U_scissor@@@@PAU_scissor@@ABU3@@Z
_TEXT	SEGMENT
_<_Args_0>$ = 8						; size = 4
??$construct@U_scissor@@ABU1@@?$_Normal_allocator_traits@V?$xalloc@U_scissor@@@@@std@@SAXAAV?$xalloc@U_scissor@@@@PAU_scissor@@ABU3@@Z PROC ; std::_Normal_allocator_traits<xalloc<_scissor> >::construct<_scissor,_scissor const &>, COMDAT
; __Al$dead$ = ecx
; __Ptr$ = edx
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	ecx, DWORD PTR _<_Args_0>$[esp-4]
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], eax
	mov	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+8], eax
	mov	eax, DWORD PTR [ecx+12]
	mov	DWORD PTR [edx+12], eax
	mov	eax, DWORD PTR [ecx+16]
	mov	DWORD PTR [edx+16], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 575  :     }

	ret	0
??$construct@U_scissor@@ABU1@@?$_Normal_allocator_traits@V?$xalloc@U_scissor@@@@@std@@SAXAAV?$xalloc@U_scissor@@@@PAU_scissor@@ABU3@@Z ENDP ; std::_Normal_allocator_traits<xalloc<_scissor> >::construct<_scissor,_scissor const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??$_Emplace_reallocate@ABU_scissor@@@?$vector@U_scissor@@V?$xalloc@U_scissor@@@@@std@@QAEPAU_scissor@@QAU2@ABU2@@Z
_TEXT	SEGMENT
__Backout$2 = -44					; size = 12
__Newvec$ = -32						; size = 4
__Oldsize$1$ = -28					; size = 4
__UFirst$3 = -24					; size = 4
tv437 = -20						; size = 4
__Whereoff$1$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Whereptr$ = 8						; size = 4
__ULast$1$ = 12						; size = 4
_<_Val_0>$ = 12						; size = 4
??$_Emplace_reallocate@ABU_scissor@@@?$vector@U_scissor@@V?$xalloc@U_scissor@@@@@std@@QAEPAU_scissor@@QAU2@ABU2@@Z PROC ; std::vector<_scissor,xalloc<_scissor> >::_Emplace_reallocate<_scissor const &>, COMDAT
; _this$ = ecx

; 752  :     _CONSTEXPR20_CONTAINER pointer _Emplace_reallocate(const pointer _Whereptr, _Valty&&... _Val) {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Emplace_reallocate@ABU_scissor@@@?$vector@U_scissor@@V?$xalloc@U_scissor@@@@@std@@QAEPAU_scissor@@QAU2@ABU2@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 32					; 00000020H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	edi, ecx

; 753  :         // reallocate and insert by perfectly forwarding _Val at _Whereptr
; 754  :         _Alty& _Al        = _Getal();
; 755  :         auto& _My_data    = _Mypair._Myval2;
; 756  :         pointer& _Myfirst = _My_data._Myfirst;
; 757  :         pointer& _Mylast  = _My_data._Mylast;
; 758  : 
; 759  :         _STL_INTERNAL_CHECK(_Mylast == _My_data._Myend); // check that we have no unused capacity
; 760  : 
; 761  :         const auto _Whereoff = static_cast<size_type>(_Whereptr - _Myfirst);

	mov	ecx, DWORD PTR [edi]
	mov	edx, DWORD PTR __Whereptr$[ebp]
	sub	edx, ecx
	mov	eax, 1717986919				; 66666667H
	imul	edx
	sar	edx, 3
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	mov	DWORD PTR __Whereoff$1$[ebp], eax

; 762  :         const auto _Oldsize  = static_cast<size_type>(_Mylast - _Myfirst);

	mov	eax, DWORD PTR [edi+4]
	sub	eax, ecx
	sar	eax, 2
	imul	eax, eax, -858993459
	mov	DWORD PTR __Oldsize$1$[ebp], eax

; 763  : 
; 764  :         if (_Oldsize == max_size()) {

	cmp	eax, 214748364				; 0cccccccH
	je	$LN58@Emplace_re

; 766  :         }
; 767  : 
; 768  :         const size_type _Newsize     = _Oldsize + 1;

	lea	ebx, DWORD PTR [eax+1]

; 1546 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	eax, DWORD PTR [edi+8]
	sub	eax, ecx
	sar	eax, 2
	imul	edx, eax, -858993459

; 1675 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	ecx, edx
	shr	ecx, 1
	mov	eax, 214748364				; 0cccccccH
	sub	eax, ecx
	cmp	edx, eax
	jbe	SHORT $LN12@Emplace_re

; 1676 :             return _Max; // geometric growth would overflow

	mov	esi, 214748364				; 0cccccccH
	jmp	SHORT $LN13@Emplace_re
$LN12@Emplace_re:

; 1677 :         }
; 1678 : 
; 1679 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	lea	esi, DWORD PTR [ecx+edx]

; 1680 : 
; 1681 :         if (_Geometric < _Newsize) {

	cmp	esi, ebx
	cmovb	esi, ebx
$LN13@Emplace_re:
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	lea	eax, DWORD PTR [esi+esi*4]
	shl	eax, 2
	push	eax
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 771  :         const pointer _Newvec           = _Al.allocate(_Newcapacity);

	mov	ebx, eax
	mov	DWORD PTR __Newvec$[ebp], ebx

; 772  :         const pointer _Constructed_last = _Newvec + _Whereoff + 1;
; 773  :         pointer _Constructed_first      = _Constructed_last;
; 774  : 
; 775  :         _TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 776  :         _Alty_traits::construct(_Al, _Unfancy(_Newvec + _Whereoff), _STD forward<_Valty>(_Val)...);

	mov	eax, DWORD PTR __Whereoff$1$[ebp]
	lea	ecx, DWORD PTR [eax+eax*4]
	lea	edx, DWORD PTR [ebx+ecx*4]
	mov	DWORD PTR tv437[ebp], edx
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	ecx, DWORD PTR _<_Val_0>$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], eax
	mov	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+8], eax
	mov	eax, DWORD PTR [ecx+12]
	mov	DWORD PTR [edx+12], eax
	mov	eax, DWORD PTR [ecx+16]
	mov	DWORD PTR [edx+16], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 779  :         if (_Whereptr == _Mylast) { // at back, provide strong guarantee

	mov	eax, DWORD PTR [edi+4]
	mov	DWORD PTR __ULast$1$[ebp], eax
	mov	ecx, DWORD PTR [edi]
	mov	edx, DWORD PTR __Whereptr$[ebp]
	cmp	edx, eax
	jne	SHORT $LN4@Emplace_re
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1703 :     auto _UFirst      = _Get_unwrapped(_First);

	mov	DWORD PTR __UFirst$3[ebp], ecx

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	DWORD PTR __Backout$2[ebp], ebx
	mov	edx, ebx
	mov	DWORD PTR __Backout$2[ebp+4], edx
	mov	DWORD PTR __Backout$2[ebp+8], edi
$LL32@Emplace_re:

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	ecx, eax
	je	SHORT $LN31@Emplace_re
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], eax
	mov	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+8], eax
	mov	eax, DWORD PTR [ecx+12]
	mov	DWORD PTR [edx+12], eax
	mov	eax, DWORD PTR [ecx+16]
	mov	DWORD PTR [edx+16], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1621 :         ++_Last;

	add	edx, 20					; 00000014H
	mov	DWORD PTR __Backout$2[ebp+4], edx

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	add	ecx, 20					; 00000014H
	mov	DWORD PTR __UFirst$3[ebp], ecx
	mov	eax, DWORD PTR __ULast$1$[ebp]
	jmp	SHORT $LL32@Emplace_re
$LN31@Emplace_re:

; 1625 :         _First = _Last;

	mov	DWORD PTR __Backout$2[ebp], edx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 781  :         } else { // provide basic guarantee

	jmp	SHORT $LN5@Emplace_re
$LN4@Emplace_re:

; 782  :             _Umove(_Myfirst, _Whereptr, _Newvec);

	push	ebx
	push	edx
	push	ecx
	call	?_Umove@?$vector@U_scissor@@V?$xalloc@U_scissor@@@@@std@@AAEPAU_scissor@@PAU3@00@Z ; std::vector<_scissor,xalloc<_scissor> >::_Umove

; 783  :             _Constructed_first = _Newvec;
; 784  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

	mov	ecx, DWORD PTR tv437[ebp]
	lea	eax, DWORD PTR [ecx+20]
	push	eax
	push	DWORD PTR [edi+4]
	push	DWORD PTR __Whereptr$[ebp]
	call	?_Umove@?$vector@U_scissor@@V?$xalloc@U_scissor@@@@@std@@AAEPAU_scissor@@PAU3@00@Z ; std::vector<_scissor,xalloc<_scissor> >::_Umove
$LN5@Emplace_re:
	mov	DWORD PTR __$EHRec$[ebp+12], -1

; 1732 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [edi]
	test	eax, eax
	je	SHORT $LN50@Emplace_re
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	push	eax
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN50@Emplace_re:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1737 :         _Myfirst = _Newvec;

	mov	DWORD PTR [edi], ebx

; 1738 :         _Mylast  = _Newvec + _Newsize;

	mov	eax, DWORD PTR __Oldsize$1$[ebp]
	inc	eax
	lea	ecx, DWORD PTR [eax+eax*4]
	lea	ecx, DWORD PTR [ebx+ecx*4]
	mov	DWORD PTR [edi+4], ecx

; 1739 :         _Myend   = _Newvec + _Newcapacity;

	lea	ecx, DWORD PTR [esi+esi*4]
	lea	ecx, DWORD PTR [ebx+ecx*4]
	mov	DWORD PTR [edi+8], ecx

; 790  :         _CATCH_END
; 791  : 
; 792  :         _Change_array(_Newvec, _Newsize, _Newcapacity);
; 793  :         return _Newvec + _Whereoff;

	mov	eax, DWORD PTR tv437[ebp]

; 794  :     }

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
__catch$??$_Emplace_reallocate@ABU_scissor@@@?$vector@U_scissor@@V?$xalloc@U_scissor@@@@@std@@QAEPAU_scissor@@QAU2@ABU2@@Z$0:

; 785  :         }
; 786  :         _CATCH_ALL
; 787  :         _Destroy(_Constructed_first, _Constructed_last);
; 788  :         _Al.deallocate(_Newvec, _Newcapacity);

	push	ecx
	push	DWORD PTR __Newvec$[ebp]
	call	?deallocate@?$xalloc@U_scissor@@@@QBEXPAU_scissor@@I@Z ; xalloc<_scissor>::deallocate

; 789  :         _RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$LN58@Emplace_re:

; 765  :             _Xlength();

	call	?_Xlength@?$vector@U_scissor@@V?$xalloc@U_scissor@@@@@std@@CAXXZ ; std::vector<_scissor,xalloc<_scissor> >::_Xlength
$LN56@Emplace_re:
	int	3
	int	3
	int	3
	int	3
	int	3
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Emplace_reallocate@ABU_scissor@@@?$vector@U_scissor@@V?$xalloc@U_scissor@@@@@std@@QAEPAU_scissor@@QAU2@ABU2@@Z:
	npad	1
	npad	1
	mov	eax, OFFSET __ehfuncinfo$??$_Emplace_reallocate@ABU_scissor@@@?$vector@U_scissor@@V?$xalloc@U_scissor@@@@@std@@QAEPAU_scissor@@QAU2@ABU2@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Emplace_reallocate@ABU_scissor@@@?$vector@U_scissor@@V?$xalloc@U_scissor@@@@@std@@QAEPAU_scissor@@QAU2@ABU2@@Z ENDP ; std::vector<_scissor,xalloc<_scissor> >::_Emplace_reallocate<_scissor const &>
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\type_traits
;	COMDAT ??$forward@ABVCFrustum@@@std@@YAABVCFrustum@@ABV1@@Z
_TEXT	SEGMENT
??$forward@ABVCFrustum@@@std@@YAABVCFrustum@@ABV1@@Z PROC ; std::forward<CFrustum const &>, COMDAT
; __Arg$ = ecx

; 1386 :     return static_cast<_Ty&&>(_Arg);

	mov	eax, ecx

; 1387 : }

	ret	0
??$forward@ABVCFrustum@@@std@@YAABVCFrustum@@ABV1@@Z ENDP ; std::forward<CFrustum const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$construct@VCFrustum@@ABV1@@?$_Normal_allocator_traits@V?$xalloc@VCFrustum@@@@@std@@SAXAAV?$xalloc@VCFrustum@@@@PAVCFrustum@@ABV3@@Z
_TEXT	SEGMENT
_<_Args_0>$ = 8						; size = 4
??$construct@VCFrustum@@ABV1@@?$_Normal_allocator_traits@V?$xalloc@VCFrustum@@@@@std@@SAXAAV?$xalloc@VCFrustum@@@@PAVCFrustum@@ABV3@@Z PROC ; std::_Normal_allocator_traits<xalloc<CFrustum> >::construct<CFrustum,CFrustum const &>, COMDAT
; __Al$dead$ = ecx
; __Ptr$ = edx

; 564  :     static _CONSTEXPR20_DYNALLOC void construct(_Alloc& _Al, _Ty* _Ptr, _Types&&... _Args) {

	push	esi
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	esi, DWORD PTR _<_Args_0>$[esp]
	mov	ecx, 61					; 0000003dH
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 564  :     static _CONSTEXPR20_DYNALLOC void construct(_Alloc& _Al, _Ty* _Ptr, _Types&&... _Args) {

	push	edi
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	edi, edx
	rep movsd
	pop	edi
	pop	esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 575  :     }

	ret	0
??$construct@VCFrustum@@ABV1@@?$_Normal_allocator_traits@V?$xalloc@VCFrustum@@@@@std@@SAXAAV?$xalloc@VCFrustum@@@@PAVCFrustum@@ABV3@@Z ENDP ; std::_Normal_allocator_traits<xalloc<CFrustum> >::construct<CFrustum,CFrustum const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??$_Emplace_reallocate@ABVCFrustum@@@?$vector@VCFrustum@@V?$xalloc@VCFrustum@@@@@std@@QAEPAVCFrustum@@QAV2@ABV2@@Z
_TEXT	SEGMENT
__Backout$2 = -48					; size = 12
__Oldsize$1$ = -36					; size = 4
__UFirst$3 = -32					; size = 4
__Newvec$ = -28						; size = 4
__Newcapacity$1$ = -24					; size = 4
tv474 = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Whereptr$ = 8						; size = 4
__ULast$1$ = 12						; size = 4
_<_Val_0>$ = 12						; size = 4
??$_Emplace_reallocate@ABVCFrustum@@@?$vector@VCFrustum@@V?$xalloc@VCFrustum@@@@@std@@QAEPAVCFrustum@@QAV2@ABV2@@Z PROC ; std::vector<CFrustum,xalloc<CFrustum> >::_Emplace_reallocate<CFrustum const &>, COMDAT
; _this$ = ecx

; 752  :     _CONSTEXPR20_CONTAINER pointer _Emplace_reallocate(const pointer _Whereptr, _Valty&&... _Val) {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Emplace_reallocate@ABVCFrustum@@@?$vector@VCFrustum@@V?$xalloc@VCFrustum@@@@@std@@QAEPAVCFrustum@@QAV2@ABV2@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 36					; 00000024H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	ebx, ecx

; 753  :         // reallocate and insert by perfectly forwarding _Val at _Whereptr
; 754  :         _Alty& _Al        = _Getal();
; 755  :         auto& _My_data    = _Mypair._Myval2;
; 756  :         pointer& _Myfirst = _My_data._Myfirst;
; 757  :         pointer& _Mylast  = _My_data._Mylast;
; 758  : 
; 759  :         _STL_INTERNAL_CHECK(_Mylast == _My_data._Myend); // check that we have no unused capacity
; 760  : 
; 761  :         const auto _Whereoff = static_cast<size_type>(_Whereptr - _Myfirst);

	mov	ecx, DWORD PTR [ebx]
	mov	edx, DWORD PTR __Whereptr$[ebp]
	sub	edx, ecx
	mov	eax, 1126548799				; 4325c53fH
	imul	edx
	sar	edx, 6
	mov	esi, edx
	shr	esi, 31					; 0000001fH
	add	esi, edx

; 762  :         const auto _Oldsize  = static_cast<size_type>(_Mylast - _Myfirst);

	mov	eax, DWORD PTR [ebx+4]
	sub	eax, ecx
	sar	eax, 2
	imul	eax, eax, -1056139499
	mov	DWORD PTR __Oldsize$1$[ebp], eax

; 763  : 
; 764  :         if (_Oldsize == max_size()) {

	cmp	eax, 17602324				; 010c9714H
	je	$LN59@Emplace_re

; 766  :         }
; 767  : 
; 768  :         const size_type _Newsize     = _Oldsize + 1;

	lea	edi, DWORD PTR [eax+1]

; 1546 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	eax, DWORD PTR [ebx+8]
	sub	eax, ecx
	sar	eax, 2
	imul	edx, eax, -1056139499

; 1675 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	ecx, edx
	shr	ecx, 1
	mov	eax, 17602324				; 010c9714H
	sub	eax, ecx
	cmp	edx, eax
	jbe	SHORT $LN12@Emplace_re

; 1676 :             return _Max; // geometric growth would overflow

	mov	eax, 17602324				; 010c9714H
	jmp	SHORT $LN57@Emplace_re
$LN12@Emplace_re:

; 1677 :         }
; 1678 : 
; 1679 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	lea	eax, DWORD PTR [ecx+edx]

; 1680 : 
; 1681 :         if (_Geometric < _Newsize) {

	cmp	eax, edi
	cmovb	eax, edi
$LN57@Emplace_re:
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	mov	DWORD PTR __Newcapacity$1$[ebp], eax
	imul	eax, eax, 244
	push	eax
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 771  :         const pointer _Newvec           = _Al.allocate(_Newcapacity);

	mov	edx, eax
	mov	DWORD PTR __Newvec$[ebp], edx

; 772  :         const pointer _Constructed_last = _Newvec + _Whereoff + 1;
; 773  :         pointer _Constructed_first      = _Constructed_last;
; 774  : 
; 775  :         _TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 776  :         _Alty_traits::construct(_Al, _Unfancy(_Newvec + _Whereoff), _STD forward<_Valty>(_Val)...);

	imul	eax, esi, 244
	add	eax, edx
	mov	DWORD PTR tv474[ebp], eax
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	ecx, 61					; 0000003dH
	mov	esi, DWORD PTR _<_Val_0>$[ebp]
	mov	edi, eax
	rep movsd
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 779  :         if (_Whereptr == _Mylast) { // at back, provide strong guarantee

	mov	ecx, DWORD PTR [ebx+4]
	mov	DWORD PTR __ULast$1$[ebp], ecx
	mov	eax, DWORD PTR [ebx]
	mov	esi, DWORD PTR __Whereptr$[ebp]
	cmp	esi, ecx
	jne	SHORT $LN4@Emplace_re
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1703 :     auto _UFirst      = _Get_unwrapped(_First);

	mov	DWORD PTR __UFirst$3[ebp], eax

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	DWORD PTR __Backout$2[ebp], edx
	mov	DWORD PTR __Backout$2[ebp+4], edx
	mov	DWORD PTR __Backout$2[ebp+8], ebx
	npad	6
$LL32@Emplace_re:

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	eax, ecx
	je	SHORT $LN31@Emplace_re
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	ecx, 61					; 0000003dH
	mov	esi, eax
	mov	edi, edx
	rep movsd
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1621 :         ++_Last;

	add	edx, 244				; 000000f4H
	mov	DWORD PTR __Backout$2[ebp+4], edx

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	add	eax, 244				; 000000f4H
	mov	DWORD PTR __UFirst$3[ebp], eax
	mov	ecx, DWORD PTR __ULast$1$[ebp]
	jmp	SHORT $LL32@Emplace_re
$LN31@Emplace_re:

; 1625 :         _First = _Last;

	mov	DWORD PTR __Backout$2[ebp], edx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 781  :         } else { // provide basic guarantee

	mov	edi, DWORD PTR tv474[ebp]
	jmp	SHORT $LN5@Emplace_re
$LN4@Emplace_re:

; 782  :             _Umove(_Myfirst, _Whereptr, _Newvec);

	push	edx
	push	esi
	push	eax
	call	?_Umove@?$vector@VCFrustum@@V?$xalloc@VCFrustum@@@@@std@@AAEPAVCFrustum@@PAV3@00@Z ; std::vector<CFrustum,xalloc<CFrustum> >::_Umove

; 783  :             _Constructed_first = _Newvec;
; 784  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

	mov	edi, DWORD PTR tv474[ebp]
	lea	eax, DWORD PTR [edi+244]
	push	eax
	push	DWORD PTR [ebx+4]
	push	esi
	call	?_Umove@?$vector@VCFrustum@@V?$xalloc@VCFrustum@@@@@std@@AAEPAVCFrustum@@PAV3@00@Z ; std::vector<CFrustum,xalloc<CFrustum> >::_Umove
$LN5@Emplace_re:
	mov	DWORD PTR __$EHRec$[ebp+12], -1

; 1732 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [ebx]
	test	eax, eax
	je	SHORT $LN50@Emplace_re
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	push	eax
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN50@Emplace_re:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1737 :         _Myfirst = _Newvec;

	mov	eax, DWORD PTR __Newvec$[ebp]
	mov	DWORD PTR [ebx], eax

; 1738 :         _Mylast  = _Newvec + _Newsize;

	mov	ecx, DWORD PTR __Oldsize$1$[ebp]
	inc	ecx
	imul	ecx, ecx, 244
	add	ecx, eax
	mov	DWORD PTR [ebx+4], ecx

; 1739 :         _Myend   = _Newvec + _Newcapacity;

	imul	ecx, DWORD PTR __Newcapacity$1$[ebp], 244
	add	ecx, eax
	mov	DWORD PTR [ebx+8], ecx

; 790  :         _CATCH_END
; 791  : 
; 792  :         _Change_array(_Newvec, _Newsize, _Newcapacity);
; 793  :         return _Newvec + _Whereoff;

	mov	eax, edi

; 794  :     }

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
__catch$??$_Emplace_reallocate@ABVCFrustum@@@?$vector@VCFrustum@@V?$xalloc@VCFrustum@@@@@std@@QAEPAVCFrustum@@QAV2@ABV2@@Z$0:

; 785  :         }
; 786  :         _CATCH_ALL
; 787  :         _Destroy(_Constructed_first, _Constructed_last);
; 788  :         _Al.deallocate(_Newvec, _Newcapacity);

	push	ecx
	push	DWORD PTR __Newvec$[ebp]
	call	?deallocate@?$xalloc@VCFrustum@@@@QBEXPAVCFrustum@@I@Z ; xalloc<CFrustum>::deallocate

; 789  :         _RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$LN59@Emplace_re:

; 765  :             _Xlength();

	call	?_Xlength@?$vector@VCFrustum@@V?$xalloc@VCFrustum@@@@@std@@CAXXZ ; std::vector<CFrustum,xalloc<CFrustum> >::_Xlength
$LN56@Emplace_re:
	int	3
	int	3
	int	3
	int	3
	int	3
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Emplace_reallocate@ABVCFrustum@@@?$vector@VCFrustum@@V?$xalloc@VCFrustum@@@@@std@@QAEPAVCFrustum@@QAV2@ABV2@@Z:
	npad	1
	npad	1
	mov	eax, OFFSET __ehfuncinfo$??$_Emplace_reallocate@ABVCFrustum@@@?$vector@VCFrustum@@V?$xalloc@VCFrustum@@@@@std@@QAEPAVCFrustum@@QAV2@ABV2@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Emplace_reallocate@ABVCFrustum@@@?$vector@VCFrustum@@V?$xalloc@VCFrustum@@@@@std@@QAEPAVCFrustum@@QAV2@ABV2@@Z ENDP ; std::vector<CFrustum,xalloc<CFrustum> >::_Emplace_reallocate<CFrustum const &>
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\type_traits
;	COMDAT ??$forward@ABQAVCPortal@@@std@@YAABQAVCPortal@@ABQAV1@@Z
_TEXT	SEGMENT
??$forward@ABQAVCPortal@@@std@@YAABQAVCPortal@@ABQAV1@@Z PROC ; std::forward<CPortal * const &>, COMDAT
; __Arg$ = ecx

; 1386 :     return static_cast<_Ty&&>(_Arg);

	mov	eax, ecx

; 1387 : }

	ret	0
??$forward@ABQAVCPortal@@@std@@YAABQAVCPortal@@ABQAV1@@Z ENDP ; std::forward<CPortal * const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$construct@PAVCPortal@@ABQAV1@@?$_Normal_allocator_traits@V?$xalloc@PAVCPortal@@@@@std@@SAXAAV?$xalloc@PAVCPortal@@@@PAPAVCPortal@@ABQAV3@@Z
_TEXT	SEGMENT
_<_Args_0>$ = 8						; size = 4
??$construct@PAVCPortal@@ABQAV1@@?$_Normal_allocator_traits@V?$xalloc@PAVCPortal@@@@@std@@SAXAAV?$xalloc@PAVCPortal@@@@PAPAVCPortal@@ABQAV3@@Z PROC ; std::_Normal_allocator_traits<xalloc<CPortal *> >::construct<CPortal *,CPortal * const &>, COMDAT
; __Al$dead$ = ecx
; __Ptr$ = edx

; 565  :         if constexpr (_Uses_default_construct<_Alloc, _Ty*, _Types...>::value) {
; 566  :             (void) _Al; // TRANSITION, DevCom-1004719
; 567  : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 568  :             _STD construct_at(_Ptr, _STD forward<_Types>(_Args)...);
; 569  : #else // __cpp_lib_constexpr_dynamic_alloc
; 570  :             ::new (static_cast<void*>(_Ptr)) _Ty(_STD forward<_Types>(_Args)...);
; 571  : #endif // __cpp_lib_constexpr_dynamic_alloc
; 572  :         } else {
; 573  :             _Al.construct(_Ptr, _STD forward<_Types>(_Args)...);

	mov	eax, DWORD PTR _<_Args_0>$[esp-4]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edx], eax

; 574  :         }
; 575  :     }

	ret	0
??$construct@PAVCPortal@@ABQAV1@@?$_Normal_allocator_traits@V?$xalloc@PAVCPortal@@@@@std@@SAXAAV?$xalloc@PAVCPortal@@@@PAPAVCPortal@@ABQAV3@@Z ENDP ; std::_Normal_allocator_traits<xalloc<CPortal *> >::construct<CPortal *,CPortal * const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??$_Emplace_reallocate@ABQAVCPortal@@@?$vector@PAVCPortal@@V?$xalloc@PAVCPortal@@@@@std@@QAEPAPAVCPortal@@QAPAV2@ABQAV2@@Z
_TEXT	SEGMENT
__Backout$2 = -76					; size = 12
__Backout$3 = -64					; size = 12
__Backout$4 = -52					; size = 12
__UFirst$5 = -40					; size = 4
__UFirst$6 = -36					; size = 4
__UFirst$7 = -32					; size = 4
__Newvec$ = -28						; size = 4
__Newcapacity$1$ = -24					; size = 4
__Newsize$1$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
tv555 = 8						; size = 4
__Whereptr$ = 8						; size = 4
_<_Val_0>$ = 12						; size = 4
??$_Emplace_reallocate@ABQAVCPortal@@@?$vector@PAVCPortal@@V?$xalloc@PAVCPortal@@@@@std@@QAEPAPAVCPortal@@QAPAV2@ABQAV2@@Z PROC ; std::vector<CPortal *,xalloc<CPortal *> >::_Emplace_reallocate<CPortal * const &>, COMDAT
; _this$ = ecx

; 752  :     _CONSTEXPR20_CONTAINER pointer _Emplace_reallocate(const pointer _Whereptr, _Valty&&... _Val) {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Emplace_reallocate@ABQAVCPortal@@@?$vector@PAVCPortal@@V?$xalloc@PAVCPortal@@@@@std@@QAEPAPAVCPortal@@QAPAV2@ABQAV2@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	edi, ecx

; 753  :         // reallocate and insert by perfectly forwarding _Val at _Whereptr
; 754  :         _Alty& _Al        = _Getal();
; 755  :         auto& _My_data    = _Mypair._Myval2;
; 756  :         pointer& _Myfirst = _My_data._Myfirst;
; 757  :         pointer& _Mylast  = _My_data._Mylast;
; 758  : 
; 759  :         _STL_INTERNAL_CHECK(_Mylast == _My_data._Myend); // check that we have no unused capacity
; 760  : 
; 761  :         const auto _Whereoff = static_cast<size_type>(_Whereptr - _Myfirst);

	mov	edx, DWORD PTR [edi]
	mov	esi, DWORD PTR __Whereptr$[ebp]
	mov	ebx, esi
	sub	ebx, edx
	sar	ebx, 2

; 762  :         const auto _Oldsize  = static_cast<size_type>(_Mylast - _Myfirst);

	mov	eax, DWORD PTR [edi+4]
	sub	eax, edx
	sar	eax, 2

; 763  : 
; 764  :         if (_Oldsize == max_size()) {

	cmp	eax, 1073741823				; 3fffffffH
	je	$LN83@Emplace_re

; 766  :         }
; 767  : 
; 768  :         const size_type _Newsize     = _Oldsize + 1;

	inc	eax
	mov	DWORD PTR __Newsize$1$[ebp], eax

; 1546 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	ecx, DWORD PTR [edi+8]
	sub	ecx, edx
	sar	ecx, 2

; 1675 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	edx, ecx
	shr	edx, 1
	mov	eax, 1073741823				; 3fffffffH
	sub	eax, edx
	cmp	ecx, eax
	jbe	SHORT $LN12@Emplace_re

; 1676 :             return _Max; // geometric growth would overflow

	mov	eax, 1073741823				; 3fffffffH
	jmp	SHORT $LN81@Emplace_re
$LN12@Emplace_re:

; 1677 :         }
; 1678 : 
; 1679 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	lea	eax, DWORD PTR [edx+ecx]

; 1680 : 
; 1681 :         if (_Geometric < _Newsize) {

	cmp	eax, DWORD PTR __Newsize$1$[ebp]
	cmovb	eax, DWORD PTR __Newsize$1$[ebp]
$LN81@Emplace_re:
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	mov	DWORD PTR __Newcapacity$1$[ebp], eax
	shl	eax, 2
	push	eax
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 771  :         const pointer _Newvec           = _Al.allocate(_Newcapacity);

	mov	edx, eax
	mov	DWORD PTR __Newvec$[ebp], edx

; 772  :         const pointer _Constructed_last = _Newvec + _Whereoff + 1;
; 773  :         pointer _Constructed_first      = _Constructed_last;
; 774  : 
; 775  :         _TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 776  :         _Alty_traits::construct(_Al, _Unfancy(_Newvec + _Whereoff), _STD forward<_Valty>(_Val)...);

	lea	ecx, DWORD PTR [edx+ebx*4]
	mov	DWORD PTR tv555[ebp], ecx
	mov	eax, DWORD PTR _<_Val_0>$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax

; 777  :         _Constructed_first = _Newvec + _Whereoff;
; 778  : 
; 779  :         if (_Whereptr == _Mylast) { // at back, provide strong guarantee

	mov	ebx, DWORD PTR [edi+4]
	mov	ecx, DWORD PTR [edi]
	cmp	esi, ebx
	jne	SHORT $LN4@Emplace_re
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1703 :     auto _UFirst      = _Get_unwrapped(_First);

	mov	DWORD PTR __UFirst$7[ebp], ecx

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	DWORD PTR __Backout$4[ebp], edx
	mov	DWORD PTR __Backout$4[ebp+4], edx
	mov	DWORD PTR __Backout$4[ebp+8], edi
	npad	1
$LL28@Emplace_re:

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	ecx, ebx
	je	SHORT $LN27@Emplace_re

; 1620 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax

; 1621 :         ++_Last;

	add	edx, 4
	mov	DWORD PTR __Backout$4[ebp+4], edx

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	add	ecx, 4
	mov	DWORD PTR __UFirst$7[ebp], ecx
	jmp	SHORT $LL28@Emplace_re
$LN27@Emplace_re:

; 1625 :         _First = _Last;

	mov	DWORD PTR __Backout$4[ebp], edx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 781  :         } else { // provide basic guarantee

	mov	ebx, DWORD PTR tv555[ebp]
	jmp	SHORT $LN5@Emplace_re
$LN4@Emplace_re:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1703 :     auto _UFirst      = _Get_unwrapped(_First);

	mov	DWORD PTR __UFirst$6[ebp], ecx

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	DWORD PTR __Backout$3[ebp], edx
	mov	DWORD PTR __Backout$3[ebp+4], edx
	mov	DWORD PTR __Backout$3[ebp+8], edi
	npad	6
$LL41@Emplace_re:

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	ecx, esi
	je	SHORT $LN40@Emplace_re

; 1620 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax

; 1621 :         ++_Last;

	add	edx, 4
	mov	DWORD PTR __Backout$3[ebp+4], edx

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	add	ecx, 4
	mov	DWORD PTR __UFirst$6[ebp], ecx
	jmp	SHORT $LL41@Emplace_re
$LN40@Emplace_re:

; 1625 :         _First = _Last;

	mov	DWORD PTR __Backout$3[ebp], edx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 784  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

	mov	ebx, DWORD PTR tv555[ebp]
	lea	ecx, DWORD PTR [ebx+4]

; 1646 :         return _Uninitialized_move(_First, _Last, _Dest, _Getal());

	mov	edx, DWORD PTR [edi+4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1703 :     auto _UFirst      = _Get_unwrapped(_First);

	mov	DWORD PTR __UFirst$5[ebp], esi

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	DWORD PTR __Backout$2[ebp], ecx
	mov	DWORD PTR __Backout$2[ebp+4], ecx
	mov	DWORD PTR __Backout$2[ebp+8], edi
	npad	2
$LL54@Emplace_re:

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	esi, edx
	je	SHORT $LN53@Emplace_re

; 1620 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [ecx], eax

; 1621 :         ++_Last;

	add	ecx, 4
	mov	DWORD PTR __Backout$2[ebp+4], ecx

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	add	esi, 4
	mov	DWORD PTR __UFirst$5[ebp], esi
	jmp	SHORT $LL54@Emplace_re
$LN53@Emplace_re:

; 1625 :         _First = _Last;

	mov	DWORD PTR __Backout$2[ebp], ecx
$LN5@Emplace_re:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
	mov	DWORD PTR __$EHRec$[ebp+12], -1

; 1732 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [edi]
	test	eax, eax
	je	SHORT $LN68@Emplace_re
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	push	eax
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN68@Emplace_re:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1737 :         _Myfirst = _Newvec;

	mov	eax, DWORD PTR __Newvec$[ebp]
	mov	DWORD PTR [edi], eax

; 1738 :         _Mylast  = _Newvec + _Newsize;

	mov	ecx, DWORD PTR __Newsize$1$[ebp]
	lea	ecx, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR [edi+4], ecx

; 1739 :         _Myend   = _Newvec + _Newcapacity;

	mov	ecx, DWORD PTR __Newcapacity$1$[ebp]
	lea	ecx, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR [edi+8], ecx

; 790  :         _CATCH_END
; 791  : 
; 792  :         _Change_array(_Newvec, _Newsize, _Newcapacity);
; 793  :         return _Newvec + _Whereoff;

	mov	eax, ebx

; 794  :     }

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
__catch$??$_Emplace_reallocate@ABQAVCPortal@@@?$vector@PAVCPortal@@V?$xalloc@PAVCPortal@@@@@std@@QAEPAPAVCPortal@@QAPAV2@ABQAV2@@Z$0:

; 785  :         }
; 786  :         _CATCH_ALL
; 787  :         _Destroy(_Constructed_first, _Constructed_last);
; 788  :         _Al.deallocate(_Newvec, _Newcapacity);

	push	ecx
	push	DWORD PTR __Newvec$[ebp]
	call	?deallocate@?$xalloc@PAVCPortal@@@@QBEXPAPAVCPortal@@I@Z ; xalloc<CPortal *>::deallocate

; 789  :         _RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$LN83@Emplace_re:

; 765  :             _Xlength();

	call	?_Xlength@?$vector@PAVCPortal@@V?$xalloc@PAVCPortal@@@@@std@@CAXXZ ; std::vector<CPortal *,xalloc<CPortal *> >::_Xlength
$LN80@Emplace_re:
	int	3
	int	3
	int	3
	int	3
	int	3
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Emplace_reallocate@ABQAVCPortal@@@?$vector@PAVCPortal@@V?$xalloc@PAVCPortal@@@@@std@@QAEPAPAVCPortal@@QAPAV2@ABQAV2@@Z:
	npad	1
	npad	1
	mov	eax, OFFSET __ehfuncinfo$??$_Emplace_reallocate@ABQAVCPortal@@@?$vector@PAVCPortal@@V?$xalloc@PAVCPortal@@@@@std@@QAEPAPAVCPortal@@QAPAV2@ABQAV2@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Emplace_reallocate@ABQAVCPortal@@@?$vector@PAVCPortal@@V?$xalloc@PAVCPortal@@@@@std@@QAEPAPAVCPortal@@QAPAV2@ABQAV2@@Z ENDP ; std::vector<CPortal *,xalloc<CPortal *> >::_Emplace_reallocate<CPortal * const &>
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef
;	COMDAT ??$addressof@V?$_Vector_val@U?$_Simple_types@PAVCPortal@@@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@PAVCPortal@@@std@@@0@AAV10@@Z
_TEXT	SEGMENT
??$addressof@V?$_Vector_val@U?$_Simple_types@PAVCPortal@@@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@PAVCPortal@@@std@@@0@AAV10@@Z PROC ; std::addressof<std::_Vector_val<std::_Simple_types<CPortal *> > >, COMDAT
; __Val$ = ecx

; 253  :     return __builtin_addressof(_Val);

	mov	eax, ecx

; 254  : }

	ret	0
??$addressof@V?$_Vector_val@U?$_Simple_types@PAVCPortal@@@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@PAVCPortal@@@std@@@0@AAV10@@Z ENDP ; std::addressof<std::_Vector_val<std::_Simple_types<CPortal *> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
;	COMDAT ??$xr_alloc@PAVCPortal@@@@YAPAPAVCPortal@@I@Z
_TEXT	SEGMENT
??$xr_alloc@PAVCPortal@@@@YAPAPAVCPortal@@I@Z PROC	; xr_alloc<CPortal *>, COMDAT
; _count$ = ecx

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	lea	eax, DWORD PTR [ecx*4]
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
	ret	0
??$xr_alloc@PAVCPortal@@@@YAPAPAVCPortal@@I@Z ENDP	; xr_alloc<CPortal *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Uninitialized_move@PAPAVCPortal@@V?$xalloc@PAVCPortal@@@@@std@@YAPAPAVCPortal@@QAPAV1@0PAPAV1@AAV?$xalloc@PAVCPortal@@@@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Al$dead$ = 12						; size = 4
??$_Uninitialized_move@PAPAVCPortal@@V?$xalloc@PAVCPortal@@@@@std@@YAPAPAVCPortal@@QAPAV1@0PAPAV1@AAV?$xalloc@PAVCPortal@@@@@Z PROC ; std::_Uninitialized_move<CPortal * *,xalloc<CPortal *> >, COMDAT
; __First$ = ecx
; __Last$ = edx

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	eax, DWORD PTR __Dest$[esp-4]

; 1699 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

	push	esi
	mov	esi, edx

; 1700 :     // move [_First, _Last) to raw _Dest, using _Al
; 1701 :     // note: only called internally from elsewhere in the STL
; 1702 :     using _Ptrval     = typename _Alloc::value_type*;
; 1703 :     auto _UFirst      = _Get_unwrapped(_First);
; 1704 :     const auto _ULast = _Get_unwrapped(_Last);
; 1705 :     if constexpr (conjunction_v<bool_constant<_Ptr_move_cat<decltype(_UFirst), _Ptrval>::_Really_trivial>,
; 1706 :                       _Uses_default_construct<_Alloc, _Ptrval, decltype(_STD move(*_UFirst))>>) {
; 1707 : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 1708 :         if (!_STD is_constant_evaluated())
; 1709 : #endif // __cpp_lib_constexpr_dynamic_alloc
; 1710 :         {
; 1711 :             _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));
; 1712 :             return _Dest + (_ULast - _UFirst);
; 1713 :         }
; 1714 :     }
; 1715 : 
; 1716 :     _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	ecx, esi
	je	SHORT $LN3@Uninitiali
	npad	5
$LL4@Uninitiali:

; 1620 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

	mov	edx, DWORD PTR [ecx]

; 1621 :         ++_Last;

	add	ecx, 4
	mov	DWORD PTR [eax], edx
	add	eax, 4

; 1700 :     // move [_First, _Last) to raw _Dest, using _Al
; 1701 :     // note: only called internally from elsewhere in the STL
; 1702 :     using _Ptrval     = typename _Alloc::value_type*;
; 1703 :     auto _UFirst      = _Get_unwrapped(_First);
; 1704 :     const auto _ULast = _Get_unwrapped(_Last);
; 1705 :     if constexpr (conjunction_v<bool_constant<_Ptr_move_cat<decltype(_UFirst), _Ptrval>::_Really_trivial>,
; 1706 :                       _Uses_default_construct<_Alloc, _Ptrval, decltype(_STD move(*_UFirst))>>) {
; 1707 : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 1708 :         if (!_STD is_constant_evaluated())
; 1709 : #endif // __cpp_lib_constexpr_dynamic_alloc
; 1710 :         {
; 1711 :             _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));
; 1712 :             return _Dest + (_ULast - _UFirst);
; 1713 :         }
; 1714 :     }
; 1715 : 
; 1716 :     _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	ecx, esi
	jne	SHORT $LL4@Uninitiali
$LN3@Uninitiali:
	pop	esi

; 1718 :         _Backout._Emplace_back(_STD move(*_UFirst));
; 1719 :     }
; 1720 : 
; 1721 :     return _Backout._Release();
; 1722 : }

	ret	0
??$_Uninitialized_move@PAPAVCPortal@@V?$xalloc@PAVCPortal@@@@@std@@YAPAPAVCPortal@@QAPAV1@0PAPAV1@AAV?$xalloc@PAVCPortal@@@@@Z ENDP ; std::_Uninitialized_move<CPortal * *,xalloc<CPortal *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_Get_unwrapped@ABQAPAVCPortal@@@std@@YA?A_TABQAPAVCPortal@@@Z
_TEXT	SEGMENT
??$_Get_unwrapped@ABQAPAVCPortal@@@std@@YA?A_TABQAPAVCPortal@@@Z PROC ; std::_Get_unwrapped<CPortal * * const &>, COMDAT
; __It$ = ecx

; 1275 :     // unwrap an iterator previously subjected to _Adl_verify_range or otherwise validated
; 1276 :     if constexpr (is_pointer_v<decay_t<_Iter>>) { // special-case pointers and arrays
; 1277 :         return _It + 0;

	mov	eax, DWORD PTR [ecx]

; 1278 :     } else if constexpr (_Unwrappable_v<_Iter>) {
; 1279 :         return static_cast<_Iter&&>(_It)._Unwrapped();
; 1280 :     } else {
; 1281 :         return static_cast<_Iter&&>(_It);
; 1282 :     }
; 1283 : }

	ret	0
??$_Get_unwrapped@ABQAPAVCPortal@@@std@@YA?A_TABQAPAVCPortal@@@Z ENDP ; std::_Get_unwrapped<CPortal * * const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Release@?$_Uninitialized_backout_al@V?$xalloc@PAVCPortal@@@@@std@@QAEPAPAVCPortal@@XZ
_TEXT	SEGMENT
?_Release@?$_Uninitialized_backout_al@V?$xalloc@PAVCPortal@@@@@std@@QAEPAPAVCPortal@@XZ PROC ; std::_Uninitialized_backout_al<xalloc<CPortal *> >::_Release, COMDAT
; _this$ = ecx

; 1625 :         _First = _Last;

	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [ecx], eax

; 1626 :         return _Last;
; 1627 :     }

	ret	0
?_Release@?$_Uninitialized_backout_al@V?$xalloc@PAVCPortal@@@@@std@@QAEPAPAVCPortal@@XZ ENDP ; std::_Uninitialized_backout_al<xalloc<CPortal *> >::_Release
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??1?$_Uninitialized_backout_al@V?$xalloc@PAVCPortal@@@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Uninitialized_backout_al@V?$xalloc@PAVCPortal@@@@@std@@QAE@XZ PROC ; std::_Uninitialized_backout_al<xalloc<CPortal *> >::~_Uninitialized_backout_al<xalloc<CPortal *> >, COMDAT
; _this$ = ecx

; 1615 :         _Destroy_range(_First, _Last, _Al);
; 1616 :     }

	ret	0
??1?$_Uninitialized_backout_al@V?$xalloc@PAVCPortal@@@@@std@@QAE@XZ ENDP ; std::_Uninitialized_backout_al<xalloc<CPortal *> >::~_Uninitialized_backout_al<xalloc<CPortal *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??0?$_Uninitialized_backout_al@V?$xalloc@PAVCPortal@@@@@std@@QAE@PAPAVCPortal@@AAV?$xalloc@PAVCPortal@@@@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Al_$ = 12						; size = 4
??0?$_Uninitialized_backout_al@V?$xalloc@PAVCPortal@@@@@std@@QAE@PAPAVCPortal@@AAV?$xalloc@PAVCPortal@@@@@Z PROC ; std::_Uninitialized_backout_al<xalloc<CPortal *> >::_Uninitialized_backout_al<xalloc<CPortal *> >, COMDAT
; _this$ = ecx

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	eax, DWORD PTR __Dest$[esp-4]
	mov	DWORD PTR [ecx], eax
	mov	DWORD PTR [ecx+4], eax
	mov	eax, DWORD PTR __Al_$[esp-4]
	mov	DWORD PTR [ecx+8], eax
	mov	eax, ecx
	ret	8
??0?$_Uninitialized_backout_al@V?$xalloc@PAVCPortal@@@@@std@@QAE@PAPAVCPortal@@AAV?$xalloc@PAVCPortal@@@@@Z ENDP ; std::_Uninitialized_backout_al<xalloc<CPortal *> >::_Uninitialized_backout_al<xalloc<CPortal *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Xlength@?$vector@PAVIRender_Sector@@V?$xalloc@PAVIRender_Sector@@@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@PAVIRender_Sector@@V?$xalloc@PAVIRender_Sector@@@@@std@@CAXXZ PROC ; std::vector<IRender_Sector *,xalloc<IRender_Sector *> >::_Xlength, COMDAT

; 1761 :         _Xlength_error("vector too long");

	push	OFFSET ??_C@_0BA@FOIKENOD@vector?5too?5long@
	call	DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN3@Xlength:
	int	3
?_Xlength@?$vector@PAVIRender_Sector@@V?$xalloc@PAVIRender_Sector@@@@@std@@CAXXZ ENDP ; std::vector<IRender_Sector *,xalloc<IRender_Sector *> >::_Xlength
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Change_array@?$vector@PAVIRender_Sector@@V?$xalloc@PAVIRender_Sector@@@@@std@@AAEXQAPAVIRender_Sector@@II@Z
_TEXT	SEGMENT
__Newvec$ = 8						; size = 4
__Newsize$ = 12						; size = 4
__Newcapacity$ = 16					; size = 4
?_Change_array@?$vector@PAVIRender_Sector@@V?$xalloc@PAVIRender_Sector@@@@@std@@AAEXQAPAVIRender_Sector@@II@Z PROC ; std::vector<IRender_Sector *,xalloc<IRender_Sector *> >::_Change_array, COMDAT
; _this$ = ecx

; 1723 :         const pointer _Newvec, const size_type _Newsize, const size_type _Newcapacity) {

	push	esi
	mov	esi, ecx

; 1724 :         // orphan all iterators, discard old array, acquire new array
; 1725 :         auto& _My_data    = _Mypair._Myval2;
; 1726 :         pointer& _Myfirst = _My_data._Myfirst;
; 1727 :         pointer& _Mylast  = _My_data._Mylast;
; 1728 :         pointer& _Myend   = _My_data._Myend;
; 1729 : 
; 1730 :         _My_data._Orphan_all();
; 1731 : 
; 1732 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN7@Change_arr
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN7@Change_arr:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1737 :         _Myfirst = _Newvec;

	mov	ecx, DWORD PTR __Newvec$[esp]

; 1738 :         _Mylast  = _Newvec + _Newsize;

	mov	eax, DWORD PTR __Newsize$[esp]
	mov	DWORD PTR [esi], ecx
	lea	eax, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR [esi+4], eax

; 1739 :         _Myend   = _Newvec + _Newcapacity;

	mov	eax, DWORD PTR __Newcapacity$[esp]
	lea	eax, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR [esi+8], eax
	pop	esi

; 1740 :     }

	ret	12					; 0000000cH
?_Change_array@?$vector@PAVIRender_Sector@@V?$xalloc@PAVIRender_Sector@@@@@std@@AAEXQAPAVIRender_Sector@@II@Z ENDP ; std::vector<IRender_Sector *,xalloc<IRender_Sector *> >::_Change_array
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Calculate_growth@?$vector@PAVIRender_Sector@@V?$xalloc@PAVIRender_Sector@@@@@std@@ABEII@Z
_TEXT	SEGMENT
__Newsize$ = 8						; size = 4
?_Calculate_growth@?$vector@PAVIRender_Sector@@V?$xalloc@PAVIRender_Sector@@@@@std@@ABEII@Z PROC ; std::vector<IRender_Sector *,xalloc<IRender_Sector *> >::_Calculate_growth, COMDAT
; _this$ = ecx

; 1546 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	edx, DWORD PTR [ecx+8]
	sub	edx, DWORD PTR [ecx]

; 1671 :         // given _Oldcapacity and _Newsize, calculate geometric growth
; 1672 :         const size_type _Oldcapacity = capacity();
; 1673 :         const auto _Max              = max_size();
; 1674 : 
; 1675 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	ecx, 1073741823				; 3fffffffH

; 1546 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	sar	edx, 2

; 1670 :     _CONSTEXPR20_CONTAINER size_type _Calculate_growth(const size_type _Newsize) const {

	push	esi

; 1671 :         // given _Oldcapacity and _Newsize, calculate geometric growth
; 1672 :         const size_type _Oldcapacity = capacity();
; 1673 :         const auto _Max              = max_size();
; 1674 : 
; 1675 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	esi, edx
	shr	esi, 1
	sub	ecx, esi
	cmp	edx, ecx
	jbe	SHORT $LN2@Calculate_

; 1676 :             return _Max; // geometric growth would overflow

	mov	eax, 1073741823				; 3fffffffH
	pop	esi

; 1682 :             return _Newsize; // geometric growth would be insufficient
; 1683 :         }
; 1684 : 
; 1685 :         return _Geometric; // geometric growth is sufficient
; 1686 :     }

	ret	4
$LN2@Calculate_:

; 1677 :         }
; 1678 : 
; 1679 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	lea	eax, DWORD PTR [esi+edx]

; 1680 : 
; 1681 :         if (_Geometric < _Newsize) {

	cmp	eax, DWORD PTR __Newsize$[esp]
	pop	esi
	cmovb	eax, DWORD PTR __Newsize$[esp-4]

; 1682 :             return _Newsize; // geometric growth would be insufficient
; 1683 :         }
; 1684 : 
; 1685 :         return _Geometric; // geometric growth is sufficient
; 1686 :     }

	ret	4
?_Calculate_growth@?$vector@PAVIRender_Sector@@V?$xalloc@PAVIRender_Sector@@@@@std@@ABEII@Z ENDP ; std::vector<IRender_Sector *,xalloc<IRender_Sector *> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Destroy@?$vector@PAVIRender_Sector@@V?$xalloc@PAVIRender_Sector@@@@@std@@AAEXPAPAVIRender_Sector@@0@Z
_TEXT	SEGMENT
__First$dead$ = 8					; size = 4
__Last$dead$ = 12					; size = 4
?_Destroy@?$vector@PAVIRender_Sector@@V?$xalloc@PAVIRender_Sector@@@@@std@@AAEXPAPAVIRender_Sector@@0@Z PROC ; std::vector<IRender_Sector *,xalloc<IRender_Sector *> >::_Destroy, COMDAT
; _this$dead$ = ecx

; 1666 :         // destroy [_First, _Last) using allocator
; 1667 :         _Destroy_range(_First, _Last, _Getal());
; 1668 :     }

	ret	8
?_Destroy@?$vector@PAVIRender_Sector@@V?$xalloc@PAVIRender_Sector@@@@@std@@AAEXPAPAVIRender_Sector@@0@Z ENDP ; std::vector<IRender_Sector *,xalloc<IRender_Sector *> >::_Destroy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Umove_if_noexcept@?$vector@PAVIRender_Sector@@V?$xalloc@PAVIRender_Sector@@@@@std@@AAEXPAPAVIRender_Sector@@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
?_Umove_if_noexcept@?$vector@PAVIRender_Sector@@V?$xalloc@PAVIRender_Sector@@@@@std@@AAEXPAPAVIRender_Sector@@00@Z PROC ; std::vector<IRender_Sector *,xalloc<IRender_Sector *> >::_Umove_if_noexcept, COMDAT
; _this$dead$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1703 :     auto _UFirst      = _Get_unwrapped(_First);

	mov	eax, DWORD PTR __First$[esp-4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1659 :     _CONSTEXPR20_CONTAINER void _Umove_if_noexcept(pointer _First, pointer _Last, pointer _Dest) {

	push	esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	mov	esi, DWORD PTR __Last$[esp]
	cmp	eax, esi
	je	SHORT $LN7@Umove_if_n

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	edx, DWORD PTR __Dest$[esp]
	sub	edx, eax
$LL8@Umove_if_n:

; 1620 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx+eax], ecx

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	add	eax, 4
	cmp	eax, esi
	jne	SHORT $LL8@Umove_if_n
$LN7@Umove_if_n:
	pop	esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1663 :     }

	ret	12					; 0000000cH
?_Umove_if_noexcept@?$vector@PAVIRender_Sector@@V?$xalloc@PAVIRender_Sector@@@@@std@@AAEXPAPAVIRender_Sector@@00@Z ENDP ; std::vector<IRender_Sector *,xalloc<IRender_Sector *> >::_Umove_if_noexcept
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Umove@?$vector@PAVIRender_Sector@@V?$xalloc@PAVIRender_Sector@@@@@std@@AAEPAPAVIRender_Sector@@PAPAV3@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
?_Umove@?$vector@PAVIRender_Sector@@V?$xalloc@PAVIRender_Sector@@@@@std@@AAEPAPAVIRender_Sector@@PAPAV3@00@Z PROC ; std::vector<IRender_Sector *,xalloc<IRender_Sector *> >::_Umove, COMDAT
; _this$dead$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	mov	ecx, DWORD PTR __First$[esp-4]

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	eax, DWORD PTR __Dest$[esp-4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1644 :     _CONSTEXPR20_CONTAINER pointer _Umove(pointer _First, pointer _Last, pointer _Dest) {

	push	esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	mov	esi, DWORD PTR __Last$[esp]
	cmp	ecx, esi
	je	SHORT $LN5@Umove
$LL6@Umove:

; 1620 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

	mov	edx, DWORD PTR [ecx]

; 1621 :         ++_Last;

	add	ecx, 4
	mov	DWORD PTR [eax], edx
	add	eax, 4

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	ecx, esi
	jne	SHORT $LL6@Umove
$LN5@Umove:
	pop	esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1647 :     }

	ret	12					; 0000000cH
?_Umove@?$vector@PAVIRender_Sector@@V?$xalloc@PAVIRender_Sector@@@@@std@@AAEPAPAVIRender_Sector@@PAPAV3@00@Z ENDP ; std::vector<IRender_Sector *,xalloc<IRender_Sector *> >::_Umove
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?max_size@?$vector@PAVIRender_Sector@@V?$xalloc@PAVIRender_Sector@@@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@PAVIRender_Sector@@V?$xalloc@PAVIRender_Sector@@@@@std@@QBEIXZ PROC ; std::vector<IRender_Sector *,xalloc<IRender_Sector *> >::max_size, COMDAT
; _this$dead$ = ecx

; 1540 :         return (_STD min)(

	mov	eax, 1073741823				; 3fffffffH

; 1541 :             static_cast<size_type>((numeric_limits<difference_type>::max)()), _Alty_traits::max_size(_Getal()));
; 1542 :     }

	ret	0
?max_size@?$vector@PAVIRender_Sector@@V?$xalloc@PAVIRender_Sector@@@@@std@@QBEIXZ ENDP ; std::vector<IRender_Sector *,xalloc<IRender_Sector *> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?construct@?$xalloc@PAVIRender_Sector@@@@QAEXPAPAVIRender_Sector@@ABQAV2@@Z
_TEXT	SEGMENT
_p$ = 8							; size = 4
__Val$ = 12						; size = 4
?construct@?$xalloc@PAVIRender_Sector@@@@QAEXPAPAVIRender_Sector@@ABQAV2@@Z PROC ; xalloc<IRender_Sector *>::construct, COMDAT
; _this$dead$ = ecx

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	eax, DWORD PTR __Val$[esp-4]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR _p$[esp-4]
	mov	DWORD PTR [eax], ecx
	ret	8
?construct@?$xalloc@PAVIRender_Sector@@@@QAEXPAPAVIRender_Sector@@ABQAV2@@Z ENDP ; xalloc<IRender_Sector *>::construct
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?deallocate@?$xalloc@PAVIRender_Sector@@@@QBEXPAPAVIRender_Sector@@I@Z
_TEXT	SEGMENT
_p$ = 8							; size = 4
_n$dead$ = 12						; size = 4
?deallocate@?$xalloc@PAVIRender_Sector@@@@QBEXPAPAVIRender_Sector@@I@Z PROC ; xalloc<IRender_Sector *>::deallocate, COMDAT
; _this$dead$ = ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	eax, DWORD PTR _p$[esp-4]
	test	eax, eax
	je	SHORT $LN4@deallocate
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN4@deallocate:
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 82   : 							void					deallocate		(pointer p, size_type n) const			{	xr_free	(p);				}

	ret	8
?deallocate@?$xalloc@PAVIRender_Sector@@@@QBEXPAPAVIRender_Sector@@I@Z ENDP ; xalloc<IRender_Sector *>::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?allocate@?$xalloc@PAVIRender_Sector@@@@QBEPAPAVIRender_Sector@@IPBX@Z
_TEXT	SEGMENT
_n$ = 8							; size = 4
_p$dead$ = 12						; size = 4
?allocate@?$xalloc@PAVIRender_Sector@@@@QBEPAPAVIRender_Sector@@IPBX@Z PROC ; xalloc<IRender_Sector *>::allocate, COMDAT
; _this$dead$ = ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	mov	eax, DWORD PTR _n$[esp-4]
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	shl	eax, 2
	push	eax
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 80   : 							pointer					allocate		(size_type n, const void* p=0) const	{	return xr_alloc<T>((u32)n);	}

	ret	8
?allocate@?$xalloc@PAVIRender_Sector@@@@QBEPAPAVIRender_Sector@@IPBX@Z ENDP ; xalloc<IRender_Sector *>::allocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Xlength@?$vector@U_scissor@@V?$xalloc@U_scissor@@@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@U_scissor@@V?$xalloc@U_scissor@@@@@std@@CAXXZ PROC ; std::vector<_scissor,xalloc<_scissor> >::_Xlength, COMDAT

; 1761 :         _Xlength_error("vector too long");

	push	OFFSET ??_C@_0BA@FOIKENOD@vector?5too?5long@
	call	DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN3@Xlength:
	int	3
?_Xlength@?$vector@U_scissor@@V?$xalloc@U_scissor@@@@@std@@CAXXZ ENDP ; std::vector<_scissor,xalloc<_scissor> >::_Xlength
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Change_array@?$vector@U_scissor@@V?$xalloc@U_scissor@@@@@std@@AAEXQAU_scissor@@II@Z
_TEXT	SEGMENT
__Newvec$ = 8						; size = 4
__Newsize$ = 12						; size = 4
__Newcapacity$ = 16					; size = 4
?_Change_array@?$vector@U_scissor@@V?$xalloc@U_scissor@@@@@std@@AAEXQAU_scissor@@II@Z PROC ; std::vector<_scissor,xalloc<_scissor> >::_Change_array, COMDAT
; _this$ = ecx

; 1723 :         const pointer _Newvec, const size_type _Newsize, const size_type _Newcapacity) {

	push	esi
	mov	esi, ecx

; 1724 :         // orphan all iterators, discard old array, acquire new array
; 1725 :         auto& _My_data    = _Mypair._Myval2;
; 1726 :         pointer& _Myfirst = _My_data._Myfirst;
; 1727 :         pointer& _Mylast  = _My_data._Mylast;
; 1728 :         pointer& _Myend   = _My_data._Myend;
; 1729 : 
; 1730 :         _My_data._Orphan_all();
; 1731 : 
; 1732 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN7@Change_arr
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN7@Change_arr:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1737 :         _Myfirst = _Newvec;

	mov	ecx, DWORD PTR __Newvec$[esp]

; 1738 :         _Mylast  = _Newvec + _Newsize;

	mov	eax, DWORD PTR __Newsize$[esp]
	mov	DWORD PTR [esi], ecx
	lea	eax, DWORD PTR [eax+eax*4]
	lea	eax, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR [esi+4], eax

; 1739 :         _Myend   = _Newvec + _Newcapacity;

	mov	eax, DWORD PTR __Newcapacity$[esp]
	lea	eax, DWORD PTR [eax+eax*4]
	lea	eax, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR [esi+8], eax
	pop	esi

; 1740 :     }

	ret	12					; 0000000cH
?_Change_array@?$vector@U_scissor@@V?$xalloc@U_scissor@@@@@std@@AAEXQAU_scissor@@II@Z ENDP ; std::vector<_scissor,xalloc<_scissor> >::_Change_array
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Calculate_growth@?$vector@U_scissor@@V?$xalloc@U_scissor@@@@@std@@ABEII@Z
_TEXT	SEGMENT
__Newsize$ = 8						; size = 4
?_Calculate_growth@?$vector@U_scissor@@V?$xalloc@U_scissor@@@@@std@@ABEII@Z PROC ; std::vector<_scissor,xalloc<_scissor> >::_Calculate_growth, COMDAT
; _this$ = ecx

; 1546 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx]

; 1671 :         // given _Oldcapacity and _Newsize, calculate geometric growth
; 1672 :         const size_type _Oldcapacity = capacity();
; 1673 :         const auto _Max              = max_size();
; 1674 : 
; 1675 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	ecx, 214748364				; 0cccccccH

; 1546 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	sar	eax, 2

; 1670 :     _CONSTEXPR20_CONTAINER size_type _Calculate_growth(const size_type _Newsize) const {

	push	esi

; 1546 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	imul	esi, eax, -858993459

; 1671 :         // given _Oldcapacity and _Newsize, calculate geometric growth
; 1672 :         const size_type _Oldcapacity = capacity();
; 1673 :         const auto _Max              = max_size();
; 1674 : 
; 1675 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	edx, esi
	shr	edx, 1
	sub	ecx, edx
	cmp	esi, ecx
	jbe	SHORT $LN2@Calculate_

; 1676 :             return _Max; // geometric growth would overflow

	mov	eax, 214748364				; 0cccccccH
	pop	esi

; 1682 :             return _Newsize; // geometric growth would be insufficient
; 1683 :         }
; 1684 : 
; 1685 :         return _Geometric; // geometric growth is sufficient
; 1686 :     }

	ret	4
$LN2@Calculate_:

; 1677 :         }
; 1678 : 
; 1679 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	lea	eax, DWORD PTR [edx+esi]

; 1680 : 
; 1681 :         if (_Geometric < _Newsize) {

	cmp	eax, DWORD PTR __Newsize$[esp]
	pop	esi
	cmovb	eax, DWORD PTR __Newsize$[esp-4]

; 1682 :             return _Newsize; // geometric growth would be insufficient
; 1683 :         }
; 1684 : 
; 1685 :         return _Geometric; // geometric growth is sufficient
; 1686 :     }

	ret	4
?_Calculate_growth@?$vector@U_scissor@@V?$xalloc@U_scissor@@@@@std@@ABEII@Z ENDP ; std::vector<_scissor,xalloc<_scissor> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Umove_if_noexcept@?$vector@U_scissor@@V?$xalloc@U_scissor@@@@@std@@AAEXPAU_scissor@@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
?_Umove_if_noexcept@?$vector@U_scissor@@V?$xalloc@U_scissor@@@@@std@@AAEXPAU_scissor@@00@Z PROC ; std::vector<_scissor,xalloc<_scissor> >::_Umove_if_noexcept, COMDAT
; _this$dead$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1703 :     auto _UFirst      = _Get_unwrapped(_First);

	mov	eax, DWORD PTR __First$[esp-4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1659 :     _CONSTEXPR20_CONTAINER void _Umove_if_noexcept(pointer _First, pointer _Last, pointer _Dest) {

	push	esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	mov	esi, DWORD PTR __Last$[esp]
	cmp	eax, esi
	je	SHORT $LN7@Umove_if_n

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	edx, DWORD PTR __Dest$[esp]
	sub	edx, eax
$LL8@Umove_if_n:
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx+eax], ecx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+eax+4], ecx
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR [edx+eax+8], ecx
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR [edx+eax+12], ecx
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR [edx+eax+16], ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	add	eax, 20					; 00000014H
	cmp	eax, esi
	jne	SHORT $LL8@Umove_if_n
$LN7@Umove_if_n:
	pop	esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1663 :     }

	ret	12					; 0000000cH
?_Umove_if_noexcept@?$vector@U_scissor@@V?$xalloc@U_scissor@@@@@std@@AAEXPAU_scissor@@00@Z ENDP ; std::vector<_scissor,xalloc<_scissor> >::_Umove_if_noexcept
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Umove@?$vector@U_scissor@@V?$xalloc@U_scissor@@@@@std@@AAEPAU_scissor@@PAU3@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
?_Umove@?$vector@U_scissor@@V?$xalloc@U_scissor@@@@@std@@AAEPAU_scissor@@PAU3@00@Z PROC ; std::vector<_scissor,xalloc<_scissor> >::_Umove, COMDAT
; _this$dead$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	mov	ecx, DWORD PTR __First$[esp-4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1644 :     _CONSTEXPR20_CONTAINER pointer _Umove(pointer _First, pointer _Last, pointer _Dest) {

	push	esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	esi, DWORD PTR __Dest$[esp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1644 :     _CONSTEXPR20_CONTAINER pointer _Umove(pointer _First, pointer _Last, pointer _Dest) {

	push	edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	mov	edi, DWORD PTR __Last$[esp+4]
	cmp	ecx, edi
	je	SHORT $LN22@Umove
$LL6@Umove:
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [esi], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [esi+4], eax
	mov	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR [esi+8], eax
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR [esi+12], edx
	mov	edx, DWORD PTR [ecx+16]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1621 :         ++_Last;

	add	ecx, 20					; 00000014H
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	DWORD PTR [esi+16], edx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1621 :         ++_Last;

	add	esi, 20					; 00000014H

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	ecx, edi
	jne	SHORT $LL6@Umove
$LN22@Umove:
	pop	edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1647 :     }

	mov	eax, esi
	pop	esi
	ret	12					; 0000000cH
?_Umove@?$vector@U_scissor@@V?$xalloc@U_scissor@@@@@std@@AAEPAU_scissor@@PAU3@00@Z ENDP ; std::vector<_scissor,xalloc<_scissor> >::_Umove
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?max_size@?$vector@U_scissor@@V?$xalloc@U_scissor@@@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@U_scissor@@V?$xalloc@U_scissor@@@@@std@@QBEIXZ PROC ; std::vector<_scissor,xalloc<_scissor> >::max_size, COMDAT
; _this$dead$ = ecx

; 1540 :         return (_STD min)(

	mov	eax, 214748364				; 0cccccccH

; 1541 :             static_cast<size_type>((numeric_limits<difference_type>::max)()), _Alty_traits::max_size(_Getal()));
; 1542 :     }

	ret	0
?max_size@?$vector@U_scissor@@V?$xalloc@U_scissor@@@@@std@@QBEIXZ ENDP ; std::vector<_scissor,xalloc<_scissor> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?construct@?$xalloc@U_scissor@@@@QAEXPAU_scissor@@ABU2@@Z
_TEXT	SEGMENT
_p$ = 8							; size = 4
__Val$ = 12						; size = 4
?construct@?$xalloc@U_scissor@@@@QAEXPAU_scissor@@ABU2@@Z PROC ; xalloc<_scissor>::construct, COMDAT
; _this$dead$ = ecx

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	edx, DWORD PTR __Val$[esp-4]
	mov	ecx, DWORD PTR _p$[esp-4]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+4], eax
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR [ecx+8], eax
	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR [ecx+12], eax
	mov	eax, DWORD PTR [edx+16]
	mov	DWORD PTR [ecx+16], eax
	ret	8
?construct@?$xalloc@U_scissor@@@@QAEXPAU_scissor@@ABU2@@Z ENDP ; xalloc<_scissor>::construct
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?allocate@?$xalloc@U_scissor@@@@QBEPAU_scissor@@IPBX@Z
_TEXT	SEGMENT
_n$ = 8							; size = 4
_p$dead$ = 12						; size = 4
?allocate@?$xalloc@U_scissor@@@@QBEPAU_scissor@@IPBX@Z PROC ; xalloc<_scissor>::allocate, COMDAT
; _this$dead$ = ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	mov	eax, DWORD PTR _n$[esp-4]
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	lea	eax, DWORD PTR [eax+eax*4]
	shl	eax, 2
	push	eax
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 80   : 							pointer					allocate		(size_type n, const void* p=0) const	{	return xr_alloc<T>((u32)n);	}

	ret	8
?allocate@?$xalloc@U_scissor@@@@QBEPAU_scissor@@IPBX@Z ENDP ; xalloc<_scissor>::allocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Xlength@?$vector@VCFrustum@@V?$xalloc@VCFrustum@@@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@VCFrustum@@V?$xalloc@VCFrustum@@@@@std@@CAXXZ PROC ; std::vector<CFrustum,xalloc<CFrustum> >::_Xlength, COMDAT

; 1761 :         _Xlength_error("vector too long");

	push	OFFSET ??_C@_0BA@FOIKENOD@vector?5too?5long@
	call	DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN3@Xlength:
	int	3
?_Xlength@?$vector@VCFrustum@@V?$xalloc@VCFrustum@@@@@std@@CAXXZ ENDP ; std::vector<CFrustum,xalloc<CFrustum> >::_Xlength
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Change_array@?$vector@VCFrustum@@V?$xalloc@VCFrustum@@@@@std@@AAEXQAVCFrustum@@II@Z
_TEXT	SEGMENT
__Newvec$ = 8						; size = 4
__Newsize$ = 12						; size = 4
__Newcapacity$ = 16					; size = 4
?_Change_array@?$vector@VCFrustum@@V?$xalloc@VCFrustum@@@@@std@@AAEXQAVCFrustum@@II@Z PROC ; std::vector<CFrustum,xalloc<CFrustum> >::_Change_array, COMDAT
; _this$ = ecx

; 1723 :         const pointer _Newvec, const size_type _Newsize, const size_type _Newcapacity) {

	push	esi
	mov	esi, ecx

; 1724 :         // orphan all iterators, discard old array, acquire new array
; 1725 :         auto& _My_data    = _Mypair._Myval2;
; 1726 :         pointer& _Myfirst = _My_data._Myfirst;
; 1727 :         pointer& _Mylast  = _My_data._Mylast;
; 1728 :         pointer& _Myend   = _My_data._Myend;
; 1729 : 
; 1730 :         _My_data._Orphan_all();
; 1731 : 
; 1732 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN7@Change_arr
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN7@Change_arr:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1738 :         _Mylast  = _Newvec + _Newsize;

	imul	eax, DWORD PTR __Newsize$[esp], 244
	mov	ecx, DWORD PTR __Newvec$[esp]
	mov	DWORD PTR [esi], ecx
	add	eax, ecx
	mov	DWORD PTR [esi+4], eax

; 1739 :         _Myend   = _Newvec + _Newcapacity;

	imul	eax, DWORD PTR __Newcapacity$[esp], 244
	add	eax, ecx
	mov	DWORD PTR [esi+8], eax
	pop	esi

; 1740 :     }

	ret	12					; 0000000cH
?_Change_array@?$vector@VCFrustum@@V?$xalloc@VCFrustum@@@@@std@@AAEXQAVCFrustum@@II@Z ENDP ; std::vector<CFrustum,xalloc<CFrustum> >::_Change_array
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Calculate_growth@?$vector@VCFrustum@@V?$xalloc@VCFrustum@@@@@std@@ABEII@Z
_TEXT	SEGMENT
__Newsize$ = 8						; size = 4
?_Calculate_growth@?$vector@VCFrustum@@V?$xalloc@VCFrustum@@@@@std@@ABEII@Z PROC ; std::vector<CFrustum,xalloc<CFrustum> >::_Calculate_growth, COMDAT
; _this$ = ecx

; 1546 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx]

; 1671 :         // given _Oldcapacity and _Newsize, calculate geometric growth
; 1672 :         const size_type _Oldcapacity = capacity();
; 1673 :         const auto _Max              = max_size();
; 1674 : 
; 1675 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	ecx, 17602324				; 010c9714H

; 1546 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	sar	eax, 2

; 1670 :     _CONSTEXPR20_CONTAINER size_type _Calculate_growth(const size_type _Newsize) const {

	push	esi

; 1546 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	imul	esi, eax, -1056139499

; 1671 :         // given _Oldcapacity and _Newsize, calculate geometric growth
; 1672 :         const size_type _Oldcapacity = capacity();
; 1673 :         const auto _Max              = max_size();
; 1674 : 
; 1675 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	edx, esi
	shr	edx, 1
	sub	ecx, edx
	cmp	esi, ecx
	jbe	SHORT $LN2@Calculate_

; 1676 :             return _Max; // geometric growth would overflow

	mov	eax, 17602324				; 010c9714H
	pop	esi

; 1682 :             return _Newsize; // geometric growth would be insufficient
; 1683 :         }
; 1684 : 
; 1685 :         return _Geometric; // geometric growth is sufficient
; 1686 :     }

	ret	4
$LN2@Calculate_:

; 1677 :         }
; 1678 : 
; 1679 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	lea	eax, DWORD PTR [edx+esi]

; 1680 : 
; 1681 :         if (_Geometric < _Newsize) {

	cmp	eax, DWORD PTR __Newsize$[esp]
	pop	esi
	cmovb	eax, DWORD PTR __Newsize$[esp-4]

; 1682 :             return _Newsize; // geometric growth would be insufficient
; 1683 :         }
; 1684 : 
; 1685 :         return _Geometric; // geometric growth is sufficient
; 1686 :     }

	ret	4
?_Calculate_growth@?$vector@VCFrustum@@V?$xalloc@VCFrustum@@@@@std@@ABEII@Z ENDP ; std::vector<CFrustum,xalloc<CFrustum> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Umove_if_noexcept@?$vector@VCFrustum@@V?$xalloc@VCFrustum@@@@@std@@AAEXPAVCFrustum@@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
?_Umove_if_noexcept@?$vector@VCFrustum@@V?$xalloc@VCFrustum@@@@@std@@AAEXPAVCFrustum@@00@Z PROC ; std::vector<CFrustum,xalloc<CFrustum> >::_Umove_if_noexcept, COMDAT
; _this$dead$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1703 :     auto _UFirst      = _Get_unwrapped(_First);

	mov	eax, DWORD PTR __First$[esp-4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1659 :     _CONSTEXPR20_CONTAINER void _Umove_if_noexcept(pointer _First, pointer _Last, pointer _Dest) {

	push	ebx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	mov	ebx, DWORD PTR __Last$[esp]
	cmp	eax, ebx
	je	SHORT $LN7@Umove_if_n

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	edx, DWORD PTR __Dest$[esp]
	push	esi
	sub	edx, eax
	push	edi
$LL8@Umove_if_n:
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	lea	edi, DWORD PTR [edx+eax]
	mov	esi, eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	add	eax, 244				; 000000f4H
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	ecx, 61					; 0000003dH
	rep movsd
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	eax, ebx
	jne	SHORT $LL8@Umove_if_n
	pop	edi
	pop	esi
$LN7@Umove_if_n:
	pop	ebx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1663 :     }

	ret	12					; 0000000cH
?_Umove_if_noexcept@?$vector@VCFrustum@@V?$xalloc@VCFrustum@@@@@std@@AAEXPAVCFrustum@@00@Z ENDP ; std::vector<CFrustum,xalloc<CFrustum> >::_Umove_if_noexcept
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Umove@?$vector@VCFrustum@@V?$xalloc@VCFrustum@@@@@std@@AAEPAVCFrustum@@PAV3@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
?_Umove@?$vector@VCFrustum@@V?$xalloc@VCFrustum@@@@@std@@AAEPAVCFrustum@@PAV3@00@Z PROC ; std::vector<CFrustum,xalloc<CFrustum> >::_Umove, COMDAT
; _this$dead$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	mov	edx, DWORD PTR __First$[esp-4]

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	eax, DWORD PTR __Dest$[esp-4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1644 :     _CONSTEXPR20_CONTAINER pointer _Umove(pointer _First, pointer _Last, pointer _Dest) {

	push	ebx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	mov	ebx, DWORD PTR __Last$[esp]
	cmp	edx, ebx
	je	SHORT $LN5@Umove
	push	esi
	push	edi
$LL6@Umove:
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	esi, edx
	mov	edi, eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1621 :         ++_Last;

	add	edx, 244				; 000000f4H
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	ecx, 61					; 0000003dH
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1621 :         ++_Last;

	add	eax, 244				; 000000f4H
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	rep movsd
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	edx, ebx
	jne	SHORT $LL6@Umove
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1646 :         return _Uninitialized_move(_First, _Last, _Dest, _Getal());

	pop	edi
	pop	esi
$LN5@Umove:

; 1647 :     }

	pop	ebx
	ret	12					; 0000000cH
?_Umove@?$vector@VCFrustum@@V?$xalloc@VCFrustum@@@@@std@@AAEPAVCFrustum@@PAV3@00@Z ENDP ; std::vector<CFrustum,xalloc<CFrustum> >::_Umove
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?max_size@?$vector@VCFrustum@@V?$xalloc@VCFrustum@@@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@VCFrustum@@V?$xalloc@VCFrustum@@@@@std@@QBEIXZ PROC ; std::vector<CFrustum,xalloc<CFrustum> >::max_size, COMDAT
; _this$dead$ = ecx

; 1540 :         return (_STD min)(

	mov	eax, 17602324				; 010c9714H

; 1541 :             static_cast<size_type>((numeric_limits<difference_type>::max)()), _Alty_traits::max_size(_Getal()));
; 1542 :     }

	ret	0
?max_size@?$vector@VCFrustum@@V?$xalloc@VCFrustum@@@@@std@@QBEIXZ ENDP ; std::vector<CFrustum,xalloc<CFrustum> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?construct@?$xalloc@VCFrustum@@@@QAEXPAVCFrustum@@ABV2@@Z
_TEXT	SEGMENT
_p$ = 8							; size = 4
__Val$ = 12						; size = 4
?construct@?$xalloc@VCFrustum@@@@QAEXPAVCFrustum@@ABV2@@Z PROC ; xalloc<CFrustum>::construct, COMDAT
; _this$dead$ = ecx

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	push	esi
	mov	esi, DWORD PTR __Val$[esp]
	mov	ecx, 61					; 0000003dH
	push	edi
	mov	edi, DWORD PTR _p$[esp+4]
	rep movsd
	pop	edi
	pop	esi
	ret	8
?construct@?$xalloc@VCFrustum@@@@QAEXPAVCFrustum@@ABV2@@Z ENDP ; xalloc<CFrustum>::construct
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?allocate@?$xalloc@VCFrustum@@@@QBEPAVCFrustum@@IPBX@Z
_TEXT	SEGMENT
_n$ = 8							; size = 4
_p$dead$ = 12						; size = 4
?allocate@?$xalloc@VCFrustum@@@@QBEPAVCFrustum@@IPBX@Z PROC ; xalloc<CFrustum>::allocate, COMDAT
; _this$dead$ = ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	imul	eax, DWORD PTR _n$[esp-4], 244
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 80   : 							pointer					allocate		(size_type n, const void* p=0) const	{	return xr_alloc<T>((u32)n);	}

	ret	8
?allocate@?$xalloc@VCFrustum@@@@QBEPAVCFrustum@@IPBX@Z ENDP ; xalloc<CFrustum>::allocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Calculate_growth@?$vector@PAVCPortal@@V?$xalloc@PAVCPortal@@@@@std@@ABEII@Z
_TEXT	SEGMENT
__Newsize$ = 8						; size = 4
?_Calculate_growth@?$vector@PAVCPortal@@V?$xalloc@PAVCPortal@@@@@std@@ABEII@Z PROC ; std::vector<CPortal *,xalloc<CPortal *> >::_Calculate_growth, COMDAT
; _this$ = ecx

; 1546 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	edx, DWORD PTR [ecx+8]
	sub	edx, DWORD PTR [ecx]

; 1671 :         // given _Oldcapacity and _Newsize, calculate geometric growth
; 1672 :         const size_type _Oldcapacity = capacity();
; 1673 :         const auto _Max              = max_size();
; 1674 : 
; 1675 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	ecx, 1073741823				; 3fffffffH

; 1546 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	sar	edx, 2

; 1670 :     _CONSTEXPR20_CONTAINER size_type _Calculate_growth(const size_type _Newsize) const {

	push	esi

; 1671 :         // given _Oldcapacity and _Newsize, calculate geometric growth
; 1672 :         const size_type _Oldcapacity = capacity();
; 1673 :         const auto _Max              = max_size();
; 1674 : 
; 1675 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	esi, edx
	shr	esi, 1
	sub	ecx, esi
	cmp	edx, ecx
	jbe	SHORT $LN2@Calculate_

; 1676 :             return _Max; // geometric growth would overflow

	mov	eax, 1073741823				; 3fffffffH
	pop	esi

; 1682 :             return _Newsize; // geometric growth would be insufficient
; 1683 :         }
; 1684 : 
; 1685 :         return _Geometric; // geometric growth is sufficient
; 1686 :     }

	ret	4
$LN2@Calculate_:

; 1677 :         }
; 1678 : 
; 1679 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	lea	eax, DWORD PTR [esi+edx]

; 1680 : 
; 1681 :         if (_Geometric < _Newsize) {

	cmp	eax, DWORD PTR __Newsize$[esp]
	pop	esi
	cmovb	eax, DWORD PTR __Newsize$[esp-4]

; 1682 :             return _Newsize; // geometric growth would be insufficient
; 1683 :         }
; 1684 : 
; 1685 :         return _Geometric; // geometric growth is sufficient
; 1686 :     }

	ret	4
?_Calculate_growth@?$vector@PAVCPortal@@V?$xalloc@PAVCPortal@@@@@std@@ABEII@Z ENDP ; std::vector<CPortal *,xalloc<CPortal *> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Umove@?$vector@PAVCPortal@@V?$xalloc@PAVCPortal@@@@@std@@AAEPAPAVCPortal@@PAPAV3@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
?_Umove@?$vector@PAVCPortal@@V?$xalloc@PAVCPortal@@@@@std@@AAEPAPAVCPortal@@PAPAV3@00@Z PROC ; std::vector<CPortal *,xalloc<CPortal *> >::_Umove, COMDAT
; _this$dead$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	mov	ecx, DWORD PTR __First$[esp-4]

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	eax, DWORD PTR __Dest$[esp-4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1644 :     _CONSTEXPR20_CONTAINER pointer _Umove(pointer _First, pointer _Last, pointer _Dest) {

	push	esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	mov	esi, DWORD PTR __Last$[esp]
	cmp	ecx, esi
	je	SHORT $LN5@Umove
$LL6@Umove:

; 1620 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

	mov	edx, DWORD PTR [ecx]

; 1621 :         ++_Last;

	add	ecx, 4
	mov	DWORD PTR [eax], edx
	add	eax, 4

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	ecx, esi
	jne	SHORT $LL6@Umove
$LN5@Umove:
	pop	esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1647 :     }

	ret	12					; 0000000cH
?_Umove@?$vector@PAVCPortal@@V?$xalloc@PAVCPortal@@@@@std@@AAEPAPAVCPortal@@PAPAV3@00@Z ENDP ; std::vector<CPortal *,xalloc<CPortal *> >::_Umove
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?construct@?$xalloc@PAVCPortal@@@@QAEXPAPAVCPortal@@ABQAV2@@Z
_TEXT	SEGMENT
_p$ = 8							; size = 4
__Val$ = 12						; size = 4
?construct@?$xalloc@PAVCPortal@@@@QAEXPAPAVCPortal@@ABQAV2@@Z PROC ; xalloc<CPortal *>::construct, COMDAT
; _this$dead$ = ecx

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	eax, DWORD PTR __Val$[esp-4]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR _p$[esp-4]
	mov	DWORD PTR [eax], ecx
	ret	8
?construct@?$xalloc@PAVCPortal@@@@QAEXPAPAVCPortal@@ABQAV2@@Z ENDP ; xalloc<CPortal *>::construct
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Getal@?$vector@PAVIRender_Sector@@V?$xalloc@PAVIRender_Sector@@@@@std@@ABEABV?$xalloc@PAVIRender_Sector@@@@XZ
_TEXT	SEGMENT
?_Getal@?$vector@PAVIRender_Sector@@V?$xalloc@PAVIRender_Sector@@@@@std@@ABEABV?$xalloc@PAVIRender_Sector@@@@XZ PROC ; std::vector<IRender_Sector *,xalloc<IRender_Sector *> >::_Getal, COMDAT
; _this$ = ecx

; 1809 :         return _Mypair._Get_first();

	mov	eax, ecx

; 1810 :     }

	ret	0
?_Getal@?$vector@PAVIRender_Sector@@V?$xalloc@PAVIRender_Sector@@@@@std@@ABEABV?$xalloc@PAVIRender_Sector@@@@XZ ENDP ; std::vector<IRender_Sector *,xalloc<IRender_Sector *> >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Umove_if_noexcept1@?$vector@PAVIRender_Sector@@V?$xalloc@PAVIRender_Sector@@@@@std@@AAEXPAPAVIRender_Sector@@00U?$integral_constant@_N$00@2@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
?_Umove_if_noexcept1@?$vector@PAVIRender_Sector@@V?$xalloc@PAVIRender_Sector@@@@@std@@AAEXPAPAVIRender_Sector@@00U?$integral_constant@_N$00@2@@Z PROC ; std::vector<IRender_Sector *,xalloc<IRender_Sector *> >::_Umove_if_noexcept1, COMDAT
; _this$dead$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1703 :     auto _UFirst      = _Get_unwrapped(_First);

	mov	eax, DWORD PTR __First$[esp-4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1649 :     _CONSTEXPR20_CONTAINER void _Umove_if_noexcept1(pointer _First, pointer _Last, pointer _Dest, true_type) {

	push	esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	mov	esi, DWORD PTR __Last$[esp]
	cmp	eax, esi
	je	SHORT $LN5@Umove_if_n

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	edx, DWORD PTR __Dest$[esp]
	sub	edx, eax
$LL6@Umove_if_n:

; 1620 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx+eax], ecx

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	add	eax, 4
	cmp	eax, esi
	jne	SHORT $LL6@Umove_if_n
$LN5@Umove_if_n:
	pop	esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1652 :     }

	ret	16					; 00000010H
?_Umove_if_noexcept1@?$vector@PAVIRender_Sector@@V?$xalloc@PAVIRender_Sector@@@@@std@@AAEXPAPAVIRender_Sector@@00U?$integral_constant@_N$00@2@@Z ENDP ; std::vector<IRender_Sector *,xalloc<IRender_Sector *> >::_Umove_if_noexcept1
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?capacity@?$vector@PAVIRender_Sector@@V?$xalloc@PAVIRender_Sector@@@@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@PAVIRender_Sector@@V?$xalloc@PAVIRender_Sector@@@@@std@@QBEIXZ PROC ; std::vector<IRender_Sector *,xalloc<IRender_Sector *> >::capacity, COMDAT
; _this$ = ecx

; 1545 :         auto& _My_data = _Mypair._Myval2;
; 1546 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx]
	sar	eax, 2

; 1547 :     }

	ret	0
?capacity@?$vector@PAVIRender_Sector@@V?$xalloc@PAVIRender_Sector@@@@@std@@QBEIXZ ENDP ; std::vector<IRender_Sector *,xalloc<IRender_Sector *> >::capacity
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?max_size@?$_Normal_allocator_traits@V?$xalloc@PAVIRender_Sector@@@@@std@@SAIABV?$xalloc@PAVIRender_Sector@@@@@Z
_TEXT	SEGMENT
?max_size@?$_Normal_allocator_traits@V?$xalloc@PAVIRender_Sector@@@@@std@@SAIABV?$xalloc@PAVIRender_Sector@@@@@Z PROC ; std::_Normal_allocator_traits<xalloc<IRender_Sector *> >::max_size, COMDAT
; __Al$dead$ = ecx

; 591  :         if constexpr (_Has_max_size<_Alloc>::value) {
; 592  :             return _Al.max_size();

	mov	eax, 1073741823				; 3fffffffH

; 593  :         } else {
; 594  :             return (numeric_limits<size_type>::max)() / sizeof(value_type);
; 595  :         }
; 596  :     }

	ret	0
?max_size@?$_Normal_allocator_traits@V?$xalloc@PAVIRender_Sector@@@@@std@@SAIABV?$xalloc@PAVIRender_Sector@@@@@Z ENDP ; std::_Normal_allocator_traits<xalloc<IRender_Sector *> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Getal@?$vector@U_scissor@@V?$xalloc@U_scissor@@@@@std@@ABEABV?$xalloc@U_scissor@@@@XZ
_TEXT	SEGMENT
?_Getal@?$vector@U_scissor@@V?$xalloc@U_scissor@@@@@std@@ABEABV?$xalloc@U_scissor@@@@XZ PROC ; std::vector<_scissor,xalloc<_scissor> >::_Getal, COMDAT
; _this$ = ecx

; 1809 :         return _Mypair._Get_first();

	mov	eax, ecx

; 1810 :     }

	ret	0
?_Getal@?$vector@U_scissor@@V?$xalloc@U_scissor@@@@@std@@ABEABV?$xalloc@U_scissor@@@@XZ ENDP ; std::vector<_scissor,xalloc<_scissor> >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Umove_if_noexcept1@?$vector@U_scissor@@V?$xalloc@U_scissor@@@@@std@@AAEXPAU_scissor@@00U?$integral_constant@_N$00@2@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
?_Umove_if_noexcept1@?$vector@U_scissor@@V?$xalloc@U_scissor@@@@@std@@AAEXPAU_scissor@@00U?$integral_constant@_N$00@2@@Z PROC ; std::vector<_scissor,xalloc<_scissor> >::_Umove_if_noexcept1, COMDAT
; _this$dead$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1703 :     auto _UFirst      = _Get_unwrapped(_First);

	mov	eax, DWORD PTR __First$[esp-4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1649 :     _CONSTEXPR20_CONTAINER void _Umove_if_noexcept1(pointer _First, pointer _Last, pointer _Dest, true_type) {

	push	esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	mov	esi, DWORD PTR __Last$[esp]
	cmp	eax, esi
	je	SHORT $LN5@Umove_if_n

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	edx, DWORD PTR __Dest$[esp]
	sub	edx, eax
$LL6@Umove_if_n:
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx+eax], ecx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+eax+4], ecx
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR [edx+eax+8], ecx
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR [edx+eax+12], ecx
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR [edx+eax+16], ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	add	eax, 20					; 00000014H
	cmp	eax, esi
	jne	SHORT $LL6@Umove_if_n
$LN5@Umove_if_n:
	pop	esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1652 :     }

	ret	16					; 00000010H
?_Umove_if_noexcept1@?$vector@U_scissor@@V?$xalloc@U_scissor@@@@@std@@AAEXPAU_scissor@@00U?$integral_constant@_N$00@2@@Z ENDP ; std::vector<_scissor,xalloc<_scissor> >::_Umove_if_noexcept1
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?capacity@?$vector@U_scissor@@V?$xalloc@U_scissor@@@@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@U_scissor@@V?$xalloc@U_scissor@@@@@std@@QBEIXZ PROC ; std::vector<_scissor,xalloc<_scissor> >::capacity, COMDAT
; _this$ = ecx

; 1545 :         auto& _My_data = _Mypair._Myval2;
; 1546 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx]
	sar	eax, 2
	imul	eax, eax, -858993459

; 1547 :     }

	ret	0
?capacity@?$vector@U_scissor@@V?$xalloc@U_scissor@@@@@std@@QBEIXZ ENDP ; std::vector<_scissor,xalloc<_scissor> >::capacity
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?max_size@?$_Normal_allocator_traits@V?$xalloc@U_scissor@@@@@std@@SAIABV?$xalloc@U_scissor@@@@@Z
_TEXT	SEGMENT
?max_size@?$_Normal_allocator_traits@V?$xalloc@U_scissor@@@@@std@@SAIABV?$xalloc@U_scissor@@@@@Z PROC ; std::_Normal_allocator_traits<xalloc<_scissor> >::max_size, COMDAT
; __Al$dead$ = ecx

; 591  :         if constexpr (_Has_max_size<_Alloc>::value) {
; 592  :             return _Al.max_size();

	mov	eax, 214748364				; 0cccccccH

; 593  :         } else {
; 594  :             return (numeric_limits<size_type>::max)() / sizeof(value_type);
; 595  :         }
; 596  :     }

	ret	0
?max_size@?$_Normal_allocator_traits@V?$xalloc@U_scissor@@@@@std@@SAIABV?$xalloc@U_scissor@@@@@Z ENDP ; std::_Normal_allocator_traits<xalloc<_scissor> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Getal@?$vector@VCFrustum@@V?$xalloc@VCFrustum@@@@@std@@ABEABV?$xalloc@VCFrustum@@@@XZ
_TEXT	SEGMENT
?_Getal@?$vector@VCFrustum@@V?$xalloc@VCFrustum@@@@@std@@ABEABV?$xalloc@VCFrustum@@@@XZ PROC ; std::vector<CFrustum,xalloc<CFrustum> >::_Getal, COMDAT
; _this$ = ecx

; 1809 :         return _Mypair._Get_first();

	mov	eax, ecx

; 1810 :     }

	ret	0
?_Getal@?$vector@VCFrustum@@V?$xalloc@VCFrustum@@@@@std@@ABEABV?$xalloc@VCFrustum@@@@XZ ENDP ; std::vector<CFrustum,xalloc<CFrustum> >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Umove_if_noexcept1@?$vector@VCFrustum@@V?$xalloc@VCFrustum@@@@@std@@AAEXPAVCFrustum@@00U?$integral_constant@_N$00@2@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
?_Umove_if_noexcept1@?$vector@VCFrustum@@V?$xalloc@VCFrustum@@@@@std@@AAEXPAVCFrustum@@00U?$integral_constant@_N$00@2@@Z PROC ; std::vector<CFrustum,xalloc<CFrustum> >::_Umove_if_noexcept1, COMDAT
; _this$dead$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1703 :     auto _UFirst      = _Get_unwrapped(_First);

	mov	eax, DWORD PTR __First$[esp-4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1649 :     _CONSTEXPR20_CONTAINER void _Umove_if_noexcept1(pointer _First, pointer _Last, pointer _Dest, true_type) {

	push	ebx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	mov	ebx, DWORD PTR __Last$[esp]
	cmp	eax, ebx
	je	SHORT $LN5@Umove_if_n

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	edx, DWORD PTR __Dest$[esp]
	push	esi
	sub	edx, eax
	push	edi
$LL6@Umove_if_n:
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	lea	edi, DWORD PTR [edx+eax]
	mov	esi, eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	add	eax, 244				; 000000f4H
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	ecx, 61					; 0000003dH
	rep movsd
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	eax, ebx
	jne	SHORT $LL6@Umove_if_n
	pop	edi
	pop	esi
$LN5@Umove_if_n:
	pop	ebx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1652 :     }

	ret	16					; 00000010H
?_Umove_if_noexcept1@?$vector@VCFrustum@@V?$xalloc@VCFrustum@@@@@std@@AAEXPAVCFrustum@@00U?$integral_constant@_N$00@2@@Z ENDP ; std::vector<CFrustum,xalloc<CFrustum> >::_Umove_if_noexcept1
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?capacity@?$vector@VCFrustum@@V?$xalloc@VCFrustum@@@@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@VCFrustum@@V?$xalloc@VCFrustum@@@@@std@@QBEIXZ PROC ; std::vector<CFrustum,xalloc<CFrustum> >::capacity, COMDAT
; _this$ = ecx

; 1545 :         auto& _My_data = _Mypair._Myval2;
; 1546 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx]
	sar	eax, 2
	imul	eax, eax, -1056139499

; 1547 :     }

	ret	0
?capacity@?$vector@VCFrustum@@V?$xalloc@VCFrustum@@@@@std@@QBEIXZ ENDP ; std::vector<CFrustum,xalloc<CFrustum> >::capacity
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?max_size@?$_Normal_allocator_traits@V?$xalloc@VCFrustum@@@@@std@@SAIABV?$xalloc@VCFrustum@@@@@Z
_TEXT	SEGMENT
?max_size@?$_Normal_allocator_traits@V?$xalloc@VCFrustum@@@@@std@@SAIABV?$xalloc@VCFrustum@@@@@Z PROC ; std::_Normal_allocator_traits<xalloc<CFrustum> >::max_size, COMDAT
; __Al$dead$ = ecx

; 591  :         if constexpr (_Has_max_size<_Alloc>::value) {
; 592  :             return _Al.max_size();

	mov	eax, 17602324				; 010c9714H

; 593  :         } else {
; 594  :             return (numeric_limits<size_type>::max)() / sizeof(value_type);
; 595  :         }
; 596  :     }

	ret	0
?max_size@?$_Normal_allocator_traits@V?$xalloc@VCFrustum@@@@@std@@SAIABV?$xalloc@VCFrustum@@@@@Z ENDP ; std::_Normal_allocator_traits<xalloc<CFrustum> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$xalloc@PAVIRender_Sector@@@@V?$_Vector_val@U?$_Simple_types@PAVIRender_Sector@@@std@@@std@@$00@std@@QBEABV?$xalloc@PAVIRender_Sector@@@@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@V?$xalloc@PAVIRender_Sector@@@@V?$_Vector_val@U?$_Simple_types@PAVIRender_Sector@@@std@@@std@@$00@std@@QBEABV?$xalloc@PAVIRender_Sector@@@@XZ PROC ; std::_Compressed_pair<xalloc<IRender_Sector *>,std::_Vector_val<std::_Simple_types<IRender_Sector *> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 1343 :         return *this;

	mov	eax, ecx

; 1344 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$xalloc@PAVIRender_Sector@@@@V?$_Vector_val@U?$_Simple_types@PAVIRender_Sector@@@std@@@std@@$00@std@@QBEABV?$xalloc@PAVIRender_Sector@@@@XZ ENDP ; std::_Compressed_pair<xalloc<IRender_Sector *>,std::_Vector_val<std::_Simple_types<IRender_Sector *> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?max_size@?$xalloc@PAVIRender_Sector@@@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$xalloc@PAVIRender_Sector@@@@QBEIXZ PROC	; xalloc<IRender_Sector *>::max_size, COMDAT
; _this$dead$ = ecx

; 86   : 							size_type				max_size		() const								{	size_type _Count = (size_type)(-1) / sizeof (T);	return (0 < _Count ? _Count : 1);	}

	mov	eax, 1073741823				; 3fffffffH
	ret	0
?max_size@?$xalloc@PAVIRender_Sector@@@@QBEIXZ ENDP	; xalloc<IRender_Sector *>::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$xalloc@U_scissor@@@@V?$_Vector_val@U?$_Simple_types@U_scissor@@@std@@@std@@$00@std@@QBEABV?$xalloc@U_scissor@@@@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@V?$xalloc@U_scissor@@@@V?$_Vector_val@U?$_Simple_types@U_scissor@@@std@@@std@@$00@std@@QBEABV?$xalloc@U_scissor@@@@XZ PROC ; std::_Compressed_pair<xalloc<_scissor>,std::_Vector_val<std::_Simple_types<_scissor> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 1343 :         return *this;

	mov	eax, ecx

; 1344 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$xalloc@U_scissor@@@@V?$_Vector_val@U?$_Simple_types@U_scissor@@@std@@@std@@$00@std@@QBEABV?$xalloc@U_scissor@@@@XZ ENDP ; std::_Compressed_pair<xalloc<_scissor>,std::_Vector_val<std::_Simple_types<_scissor> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?max_size@?$xalloc@U_scissor@@@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$xalloc@U_scissor@@@@QBEIXZ PROC		; xalloc<_scissor>::max_size, COMDAT
; _this$dead$ = ecx

; 86   : 							size_type				max_size		() const								{	size_type _Count = (size_type)(-1) / sizeof (T);	return (0 < _Count ? _Count : 1);	}

	mov	eax, 214748364				; 0cccccccH
	ret	0
?max_size@?$xalloc@U_scissor@@@@QBEIXZ ENDP		; xalloc<_scissor>::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$xalloc@VCFrustum@@@@V?$_Vector_val@U?$_Simple_types@VCFrustum@@@std@@@std@@$00@std@@QBEABV?$xalloc@VCFrustum@@@@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@V?$xalloc@VCFrustum@@@@V?$_Vector_val@U?$_Simple_types@VCFrustum@@@std@@@std@@$00@std@@QBEABV?$xalloc@VCFrustum@@@@XZ PROC ; std::_Compressed_pair<xalloc<CFrustum>,std::_Vector_val<std::_Simple_types<CFrustum> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 1343 :         return *this;

	mov	eax, ecx

; 1344 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$xalloc@VCFrustum@@@@V?$_Vector_val@U?$_Simple_types@VCFrustum@@@std@@@std@@$00@std@@QBEABV?$xalloc@VCFrustum@@@@XZ ENDP ; std::_Compressed_pair<xalloc<CFrustum>,std::_Vector_val<std::_Simple_types<CFrustum> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?max_size@?$xalloc@VCFrustum@@@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$xalloc@VCFrustum@@@@QBEIXZ PROC		; xalloc<CFrustum>::max_size, COMDAT
; _this$dead$ = ecx

; 86   : 							size_type				max_size		() const								{	size_type _Count = (size_type)(-1) / sizeof (T);	return (0 < _Count ? _Count : 1);	}

	mov	eax, 17602324				; 010c9714H
	ret	0
?max_size@?$xalloc@VCFrustum@@@@QBEIXZ ENDP		; xalloc<CFrustum>::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\type_traits
;	COMDAT ??$move@AAPAVCPortal@@@std@@YA$$QAPAVCPortal@@AAPAV1@@Z
_TEXT	SEGMENT
??$move@AAPAVCPortal@@@std@@YA$$QAPAVCPortal@@AAPAV1@@Z PROC ; std::move<CPortal * &>, COMDAT
; __Arg$ = ecx

; 1397 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

	mov	eax, ecx

; 1398 : }

	ret	0
??$move@AAPAVCPortal@@@std@@YA$$QAPAVCPortal@@AAPAV1@@Z ENDP ; std::move<CPortal * &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Emplace_back@PAVCPortal@@@?$_Uninitialized_backout_al@V?$xalloc@PAVCPortal@@@@@std@@QAEX$$QAPAVCPortal@@@Z
_TEXT	SEGMENT
_<_Vals_0>$ = 8						; size = 4
??$_Emplace_back@PAVCPortal@@@?$_Uninitialized_backout_al@V?$xalloc@PAVCPortal@@@@@std@@QAEX$$QAPAVCPortal@@@Z PROC ; std::_Uninitialized_backout_al<xalloc<CPortal *> >::_Emplace_back<CPortal *>, COMDAT
; _this$ = ecx

; 1620 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _<_Vals_0>$[esp-4]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edx], eax

; 1621 :         ++_Last;

	add	DWORD PTR [ecx+4], 4

; 1622 :     }

	ret	4
??$_Emplace_back@PAVCPortal@@@?$_Uninitialized_backout_al@V?$xalloc@PAVCPortal@@@@@std@@QAEX$$QAPAVCPortal@@@Z ENDP ; std::_Uninitialized_backout_al<xalloc<CPortal *> >::_Emplace_back<CPortal *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Destroy_range@V?$xalloc@PAVIRender_Sector@@@@@std@@YAXPAPAVIRender_Sector@@QAPAV1@AAV?$xalloc@PAVIRender_Sector@@@@@Z
_TEXT	SEGMENT
__Al$dead$ = 8						; size = 4
??$_Destroy_range@V?$xalloc@PAVIRender_Sector@@@@@std@@YAXPAPAVIRender_Sector@@QAPAV1@AAV?$xalloc@PAVIRender_Sector@@@@@Z PROC ; std::_Destroy_range<xalloc<IRender_Sector *> >, COMDAT
; __First$dead$ = ecx
; __Last$dead$ = edx

; 901  :     // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
; 902  :     using _Ty = typename _Alloc::value_type;
; 903  :     if constexpr (!conjunction_v<is_trivially_destructible<_Ty>, _Uses_default_destroy<_Alloc, _Ty*>>) {
; 904  :         for (; _First != _Last; ++_First) {
; 905  :             allocator_traits<_Alloc>::destroy(_Al, _Unfancy(_First));
; 906  :         }
; 907  :     }
; 908  : }

	ret	0
??$_Destroy_range@V?$xalloc@PAVIRender_Sector@@@@@std@@YAXPAPAVIRender_Sector@@QAPAV1@AAV?$xalloc@PAVIRender_Sector@@@@@Z ENDP ; std::_Destroy_range<xalloc<IRender_Sector *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Uninitialized_move@PAPAVIRender_Sector@@V?$xalloc@PAVIRender_Sector@@@@@std@@YAPAPAVIRender_Sector@@QAPAV1@0PAPAV1@AAV?$xalloc@PAVIRender_Sector@@@@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Al$dead$ = 12						; size = 4
??$_Uninitialized_move@PAPAVIRender_Sector@@V?$xalloc@PAVIRender_Sector@@@@@std@@YAPAPAVIRender_Sector@@QAPAV1@0PAPAV1@AAV?$xalloc@PAVIRender_Sector@@@@@Z PROC ; std::_Uninitialized_move<IRender_Sector * *,xalloc<IRender_Sector *> >, COMDAT
; __First$ = ecx
; __Last$ = edx

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	eax, DWORD PTR __Dest$[esp-4]

; 1699 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

	push	esi
	mov	esi, edx

; 1700 :     // move [_First, _Last) to raw _Dest, using _Al
; 1701 :     // note: only called internally from elsewhere in the STL
; 1702 :     using _Ptrval     = typename _Alloc::value_type*;
; 1703 :     auto _UFirst      = _Get_unwrapped(_First);
; 1704 :     const auto _ULast = _Get_unwrapped(_Last);
; 1705 :     if constexpr (conjunction_v<bool_constant<_Ptr_move_cat<decltype(_UFirst), _Ptrval>::_Really_trivial>,
; 1706 :                       _Uses_default_construct<_Alloc, _Ptrval, decltype(_STD move(*_UFirst))>>) {
; 1707 : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 1708 :         if (!_STD is_constant_evaluated())
; 1709 : #endif // __cpp_lib_constexpr_dynamic_alloc
; 1710 :         {
; 1711 :             _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));
; 1712 :             return _Dest + (_ULast - _UFirst);
; 1713 :         }
; 1714 :     }
; 1715 : 
; 1716 :     _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	ecx, esi
	je	SHORT $LN3@Uninitiali
	npad	5
$LL4@Uninitiali:

; 1620 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

	mov	edx, DWORD PTR [ecx]

; 1621 :         ++_Last;

	add	ecx, 4
	mov	DWORD PTR [eax], edx
	add	eax, 4

; 1700 :     // move [_First, _Last) to raw _Dest, using _Al
; 1701 :     // note: only called internally from elsewhere in the STL
; 1702 :     using _Ptrval     = typename _Alloc::value_type*;
; 1703 :     auto _UFirst      = _Get_unwrapped(_First);
; 1704 :     const auto _ULast = _Get_unwrapped(_Last);
; 1705 :     if constexpr (conjunction_v<bool_constant<_Ptr_move_cat<decltype(_UFirst), _Ptrval>::_Really_trivial>,
; 1706 :                       _Uses_default_construct<_Alloc, _Ptrval, decltype(_STD move(*_UFirst))>>) {
; 1707 : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 1708 :         if (!_STD is_constant_evaluated())
; 1709 : #endif // __cpp_lib_constexpr_dynamic_alloc
; 1710 :         {
; 1711 :             _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));
; 1712 :             return _Dest + (_ULast - _UFirst);
; 1713 :         }
; 1714 :     }
; 1715 : 
; 1716 :     _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	ecx, esi
	jne	SHORT $LL4@Uninitiali
$LN3@Uninitiali:
	pop	esi

; 1718 :         _Backout._Emplace_back(_STD move(*_UFirst));
; 1719 :     }
; 1720 : 
; 1721 :     return _Backout._Release();
; 1722 : }

	ret	0
??$_Uninitialized_move@PAPAVIRender_Sector@@V?$xalloc@PAVIRender_Sector@@@@@std@@YAPAPAVIRender_Sector@@QAPAV1@0PAPAV1@AAV?$xalloc@PAVIRender_Sector@@@@@Z ENDP ; std::_Uninitialized_move<IRender_Sector * *,xalloc<IRender_Sector *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_Get_unwrapped@ABQAPAVIRender_Sector@@@std@@YA?A_TABQAPAVIRender_Sector@@@Z
_TEXT	SEGMENT
??$_Get_unwrapped@ABQAPAVIRender_Sector@@@std@@YA?A_TABQAPAVIRender_Sector@@@Z PROC ; std::_Get_unwrapped<IRender_Sector * * const &>, COMDAT
; __It$ = ecx

; 1275 :     // unwrap an iterator previously subjected to _Adl_verify_range or otherwise validated
; 1276 :     if constexpr (is_pointer_v<decay_t<_Iter>>) { // special-case pointers and arrays
; 1277 :         return _It + 0;

	mov	eax, DWORD PTR [ecx]

; 1278 :     } else if constexpr (_Unwrappable_v<_Iter>) {
; 1279 :         return static_cast<_Iter&&>(_It)._Unwrapped();
; 1280 :     } else {
; 1281 :         return static_cast<_Iter&&>(_It);
; 1282 :     }
; 1283 : }

	ret	0
??$_Get_unwrapped@ABQAPAVIRender_Sector@@@std@@YA?A_TABQAPAVIRender_Sector@@@Z ENDP ; std::_Get_unwrapped<IRender_Sector * * const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
;	COMDAT ??$xr_free@PAVIRender_Sector@@@@YAXAAPAPAVIRender_Sector@@@Z
_TEXT	SEGMENT
??$xr_free@PAVIRender_Sector@@@@YAXAAPAPAVIRender_Sector@@@Z PROC ; xr_free<IRender_Sector *>, COMDAT
; _P$ = ecx

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	push	esi
	mov	esi, ecx
	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN2@xr_free
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
	mov	DWORD PTR [esi], 0
$LN2@xr_free:
	pop	esi
	ret	0
??$xr_free@PAVIRender_Sector@@@@YAXAAPAPAVIRender_Sector@@@Z ENDP ; xr_free<IRender_Sector *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
;	COMDAT ??$xr_alloc@PAVIRender_Sector@@@@YAPAPAVIRender_Sector@@I@Z
_TEXT	SEGMENT
??$xr_alloc@PAVIRender_Sector@@@@YAPAPAVIRender_Sector@@I@Z PROC ; xr_alloc<IRender_Sector *>, COMDAT
; _count$ = ecx

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	lea	eax, DWORD PTR [ecx*4]
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
	ret	0
??$xr_alloc@PAVIRender_Sector@@@@YAPAPAVIRender_Sector@@I@Z ENDP ; xr_alloc<IRender_Sector *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Uninitialized_move@PAU_scissor@@V?$xalloc@U_scissor@@@@@std@@YAPAU_scissor@@QAU1@0PAU1@AAV?$xalloc@U_scissor@@@@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Al$dead$ = 12						; size = 4
??$_Uninitialized_move@PAU_scissor@@V?$xalloc@U_scissor@@@@@std@@YAPAU_scissor@@QAU1@0PAU1@AAV?$xalloc@U_scissor@@@@@Z PROC ; std::_Uninitialized_move<_scissor *,xalloc<_scissor> >, COMDAT
; __First$ = ecx
; __Last$ = edx

; 1699 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

	push	esi

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	esi, DWORD PTR __Dest$[esp]

; 1699 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

	push	edi
	mov	edi, edx

; 1700 :     // move [_First, _Last) to raw _Dest, using _Al
; 1701 :     // note: only called internally from elsewhere in the STL
; 1702 :     using _Ptrval     = typename _Alloc::value_type*;
; 1703 :     auto _UFirst      = _Get_unwrapped(_First);
; 1704 :     const auto _ULast = _Get_unwrapped(_Last);
; 1705 :     if constexpr (conjunction_v<bool_constant<_Ptr_move_cat<decltype(_UFirst), _Ptrval>::_Really_trivial>,
; 1706 :                       _Uses_default_construct<_Alloc, _Ptrval, decltype(_STD move(*_UFirst))>>) {
; 1707 : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 1708 :         if (!_STD is_constant_evaluated())
; 1709 : #endif // __cpp_lib_constexpr_dynamic_alloc
; 1710 :         {
; 1711 :             _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));
; 1712 :             return _Dest + (_ULast - _UFirst);
; 1713 :         }
; 1714 :     }
; 1715 : 
; 1716 :     _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	ecx, edi
	je	SHORT $LN20@Uninitiali
	npad	4
$LL4@Uninitiali:
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [esi], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [esi+4], eax
	mov	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR [esi+8], eax
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR [esi+12], edx
	mov	edx, DWORD PTR [ecx+16]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1621 :         ++_Last;

	add	ecx, 20					; 00000014H
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	DWORD PTR [esi+16], edx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1621 :         ++_Last;

	add	esi, 20					; 00000014H

; 1700 :     // move [_First, _Last) to raw _Dest, using _Al
; 1701 :     // note: only called internally from elsewhere in the STL
; 1702 :     using _Ptrval     = typename _Alloc::value_type*;
; 1703 :     auto _UFirst      = _Get_unwrapped(_First);
; 1704 :     const auto _ULast = _Get_unwrapped(_Last);
; 1705 :     if constexpr (conjunction_v<bool_constant<_Ptr_move_cat<decltype(_UFirst), _Ptrval>::_Really_trivial>,
; 1706 :                       _Uses_default_construct<_Alloc, _Ptrval, decltype(_STD move(*_UFirst))>>) {
; 1707 : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 1708 :         if (!_STD is_constant_evaluated())
; 1709 : #endif // __cpp_lib_constexpr_dynamic_alloc
; 1710 :         {
; 1711 :             _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));
; 1712 :             return _Dest + (_ULast - _UFirst);
; 1713 :         }
; 1714 :     }
; 1715 : 
; 1716 :     _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	ecx, edi
	jne	SHORT $LL4@Uninitiali
$LN20@Uninitiali:
	pop	edi

; 1718 :         _Backout._Emplace_back(_STD move(*_UFirst));
; 1719 :     }
; 1720 : 
; 1721 :     return _Backout._Release();
; 1722 : }

	mov	eax, esi
	pop	esi
	ret	0
??$_Uninitialized_move@PAU_scissor@@V?$xalloc@U_scissor@@@@@std@@YAPAU_scissor@@QAU1@0PAU1@AAV?$xalloc@U_scissor@@@@@Z ENDP ; std::_Uninitialized_move<_scissor *,xalloc<_scissor> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_Get_unwrapped@ABQAU_scissor@@@std@@YA?A_TABQAU_scissor@@@Z
_TEXT	SEGMENT
??$_Get_unwrapped@ABQAU_scissor@@@std@@YA?A_TABQAU_scissor@@@Z PROC ; std::_Get_unwrapped<_scissor * const &>, COMDAT
; __It$ = ecx

; 1275 :     // unwrap an iterator previously subjected to _Adl_verify_range or otherwise validated
; 1276 :     if constexpr (is_pointer_v<decay_t<_Iter>>) { // special-case pointers and arrays
; 1277 :         return _It + 0;

	mov	eax, DWORD PTR [ecx]

; 1278 :     } else if constexpr (_Unwrappable_v<_Iter>) {
; 1279 :         return static_cast<_Iter&&>(_It)._Unwrapped();
; 1280 :     } else {
; 1281 :         return static_cast<_Iter&&>(_It);
; 1282 :     }
; 1283 : }

	ret	0
??$_Get_unwrapped@ABQAU_scissor@@@std@@YA?A_TABQAU_scissor@@@Z ENDP ; std::_Get_unwrapped<_scissor * const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
;	COMDAT ??$xr_alloc@U_scissor@@@@YAPAU_scissor@@I@Z
_TEXT	SEGMENT
??$xr_alloc@U_scissor@@@@YAPAU_scissor@@I@Z PROC	; xr_alloc<_scissor>, COMDAT
; _count$ = ecx

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	lea	eax, DWORD PTR [ecx+ecx*4]
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	shl	eax, 2
	push	eax
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
	ret	0
??$xr_alloc@U_scissor@@@@YAPAU_scissor@@I@Z ENDP	; xr_alloc<_scissor>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Uninitialized_move@PAVCFrustum@@V?$xalloc@VCFrustum@@@@@std@@YAPAVCFrustum@@QAV1@0PAV1@AAV?$xalloc@VCFrustum@@@@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Al$dead$ = 12						; size = 4
??$_Uninitialized_move@PAVCFrustum@@V?$xalloc@VCFrustum@@@@@std@@YAPAVCFrustum@@QAV1@0PAV1@AAV?$xalloc@VCFrustum@@@@@Z PROC ; std::_Uninitialized_move<CFrustum *,xalloc<CFrustum> >, COMDAT
; __First$ = ecx
; __Last$ = edx

; 1699 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

	push	ebx
	mov	ebx, edx
	mov	eax, ecx

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	edx, DWORD PTR __Dest$[esp]

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	eax, ebx
	je	SHORT $LN20@Uninitiali
	push	esi
	push	edi
	npad	1
$LL4@Uninitiali:
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	esi, eax
	mov	edi, edx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1621 :         ++_Last;

	add	eax, 244				; 000000f4H
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	ecx, 61					; 0000003dH
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1621 :         ++_Last;

	add	edx, 244				; 000000f4H
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	rep movsd
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	eax, ebx
	jne	SHORT $LL4@Uninitiali

; 1718 :         _Backout._Emplace_back(_STD move(*_UFirst));
; 1719 :     }
; 1720 : 
; 1721 :     return _Backout._Release();

	pop	edi
	pop	esi
$LN20@Uninitiali:

; 1722 : }

	mov	eax, edx
	pop	ebx
	ret	0
??$_Uninitialized_move@PAVCFrustum@@V?$xalloc@VCFrustum@@@@@std@@YAPAVCFrustum@@QAV1@0PAV1@AAV?$xalloc@VCFrustum@@@@@Z ENDP ; std::_Uninitialized_move<CFrustum *,xalloc<CFrustum> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_Get_unwrapped@ABQAVCFrustum@@@std@@YA?A_TABQAVCFrustum@@@Z
_TEXT	SEGMENT
??$_Get_unwrapped@ABQAVCFrustum@@@std@@YA?A_TABQAVCFrustum@@@Z PROC ; std::_Get_unwrapped<CFrustum * const &>, COMDAT
; __It$ = ecx

; 1275 :     // unwrap an iterator previously subjected to _Adl_verify_range or otherwise validated
; 1276 :     if constexpr (is_pointer_v<decay_t<_Iter>>) { // special-case pointers and arrays
; 1277 :         return _It + 0;

	mov	eax, DWORD PTR [ecx]

; 1278 :     } else if constexpr (_Unwrappable_v<_Iter>) {
; 1279 :         return static_cast<_Iter&&>(_It)._Unwrapped();
; 1280 :     } else {
; 1281 :         return static_cast<_Iter&&>(_It);
; 1282 :     }
; 1283 : }

	ret	0
??$_Get_unwrapped@ABQAVCFrustum@@@std@@YA?A_TABQAVCFrustum@@@Z ENDP ; std::_Get_unwrapped<CFrustum * const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
;	COMDAT ??$xr_alloc@VCFrustum@@@@YAPAVCFrustum@@I@Z
_TEXT	SEGMENT
??$xr_alloc@VCFrustum@@@@YAPAVCFrustum@@I@Z PROC	; xr_alloc<CFrustum>, COMDAT
; _count$ = ecx

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	imul	eax, ecx, 244
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
	ret	0
??$xr_alloc@VCFrustum@@@@YAPAVCFrustum@@I@Z ENDP	; xr_alloc<CFrustum>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Release@?$_Uninitialized_backout_al@V?$xalloc@VCFrustum@@@@@std@@QAEPAVCFrustum@@XZ
_TEXT	SEGMENT
?_Release@?$_Uninitialized_backout_al@V?$xalloc@VCFrustum@@@@@std@@QAEPAVCFrustum@@XZ PROC ; std::_Uninitialized_backout_al<xalloc<CFrustum> >::_Release, COMDAT
; _this$ = ecx

; 1625 :         _First = _Last;

	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [ecx], eax

; 1626 :         return _Last;
; 1627 :     }

	ret	0
?_Release@?$_Uninitialized_backout_al@V?$xalloc@VCFrustum@@@@@std@@QAEPAVCFrustum@@XZ ENDP ; std::_Uninitialized_backout_al<xalloc<CFrustum> >::_Release
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??1?$_Uninitialized_backout_al@V?$xalloc@VCFrustum@@@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Uninitialized_backout_al@V?$xalloc@VCFrustum@@@@@std@@QAE@XZ PROC ; std::_Uninitialized_backout_al<xalloc<CFrustum> >::~_Uninitialized_backout_al<xalloc<CFrustum> >, COMDAT
; _this$ = ecx

; 1615 :         _Destroy_range(_First, _Last, _Al);
; 1616 :     }

	ret	0
??1?$_Uninitialized_backout_al@V?$xalloc@VCFrustum@@@@@std@@QAE@XZ ENDP ; std::_Uninitialized_backout_al<xalloc<CFrustum> >::~_Uninitialized_backout_al<xalloc<CFrustum> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??0?$_Uninitialized_backout_al@V?$xalloc@VCFrustum@@@@@std@@QAE@PAVCFrustum@@AAV?$xalloc@VCFrustum@@@@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Al_$ = 12						; size = 4
??0?$_Uninitialized_backout_al@V?$xalloc@VCFrustum@@@@@std@@QAE@PAVCFrustum@@AAV?$xalloc@VCFrustum@@@@@Z PROC ; std::_Uninitialized_backout_al<xalloc<CFrustum> >::_Uninitialized_backout_al<xalloc<CFrustum> >, COMDAT
; _this$ = ecx

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	eax, DWORD PTR __Dest$[esp-4]
	mov	DWORD PTR [ecx], eax
	mov	DWORD PTR [ecx+4], eax
	mov	eax, DWORD PTR __Al_$[esp-4]
	mov	DWORD PTR [ecx+8], eax
	mov	eax, ecx
	ret	8
??0?$_Uninitialized_backout_al@V?$xalloc@VCFrustum@@@@@std@@QAE@PAVCFrustum@@AAV?$xalloc@VCFrustum@@@@@Z ENDP ; std::_Uninitialized_backout_al<xalloc<CFrustum> >::_Uninitialized_backout_al<xalloc<CFrustum> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Release@?$_Uninitialized_backout_al@V?$xalloc@U_scissor@@@@@std@@QAEPAU_scissor@@XZ
_TEXT	SEGMENT
?_Release@?$_Uninitialized_backout_al@V?$xalloc@U_scissor@@@@@std@@QAEPAU_scissor@@XZ PROC ; std::_Uninitialized_backout_al<xalloc<_scissor> >::_Release, COMDAT
; _this$ = ecx

; 1625 :         _First = _Last;

	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [ecx], eax

; 1626 :         return _Last;
; 1627 :     }

	ret	0
?_Release@?$_Uninitialized_backout_al@V?$xalloc@U_scissor@@@@@std@@QAEPAU_scissor@@XZ ENDP ; std::_Uninitialized_backout_al<xalloc<_scissor> >::_Release
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??1?$_Uninitialized_backout_al@V?$xalloc@U_scissor@@@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Uninitialized_backout_al@V?$xalloc@U_scissor@@@@@std@@QAE@XZ PROC ; std::_Uninitialized_backout_al<xalloc<_scissor> >::~_Uninitialized_backout_al<xalloc<_scissor> >, COMDAT
; _this$ = ecx

; 1615 :         _Destroy_range(_First, _Last, _Al);
; 1616 :     }

	ret	0
??1?$_Uninitialized_backout_al@V?$xalloc@U_scissor@@@@@std@@QAE@XZ ENDP ; std::_Uninitialized_backout_al<xalloc<_scissor> >::~_Uninitialized_backout_al<xalloc<_scissor> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??0?$_Uninitialized_backout_al@V?$xalloc@U_scissor@@@@@std@@QAE@PAU_scissor@@AAV?$xalloc@U_scissor@@@@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Al_$ = 12						; size = 4
??0?$_Uninitialized_backout_al@V?$xalloc@U_scissor@@@@@std@@QAE@PAU_scissor@@AAV?$xalloc@U_scissor@@@@@Z PROC ; std::_Uninitialized_backout_al<xalloc<_scissor> >::_Uninitialized_backout_al<xalloc<_scissor> >, COMDAT
; _this$ = ecx

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	eax, DWORD PTR __Dest$[esp-4]
	mov	DWORD PTR [ecx], eax
	mov	DWORD PTR [ecx+4], eax
	mov	eax, DWORD PTR __Al_$[esp-4]
	mov	DWORD PTR [ecx+8], eax
	mov	eax, ecx
	ret	8
??0?$_Uninitialized_backout_al@V?$xalloc@U_scissor@@@@@std@@QAE@PAU_scissor@@AAV?$xalloc@U_scissor@@@@@Z ENDP ; std::_Uninitialized_backout_al<xalloc<_scissor> >::_Uninitialized_backout_al<xalloc<_scissor> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Release@?$_Uninitialized_backout_al@V?$xalloc@PAVIRender_Sector@@@@@std@@QAEPAPAVIRender_Sector@@XZ
_TEXT	SEGMENT
?_Release@?$_Uninitialized_backout_al@V?$xalloc@PAVIRender_Sector@@@@@std@@QAEPAPAVIRender_Sector@@XZ PROC ; std::_Uninitialized_backout_al<xalloc<IRender_Sector *> >::_Release, COMDAT
; _this$ = ecx

; 1625 :         _First = _Last;

	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [ecx], eax

; 1626 :         return _Last;
; 1627 :     }

	ret	0
?_Release@?$_Uninitialized_backout_al@V?$xalloc@PAVIRender_Sector@@@@@std@@QAEPAPAVIRender_Sector@@XZ ENDP ; std::_Uninitialized_backout_al<xalloc<IRender_Sector *> >::_Release
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??1?$_Uninitialized_backout_al@V?$xalloc@PAVIRender_Sector@@@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Uninitialized_backout_al@V?$xalloc@PAVIRender_Sector@@@@@std@@QAE@XZ PROC ; std::_Uninitialized_backout_al<xalloc<IRender_Sector *> >::~_Uninitialized_backout_al<xalloc<IRender_Sector *> >, COMDAT
; _this$ = ecx

; 1615 :         _Destroy_range(_First, _Last, _Al);
; 1616 :     }

	ret	0
??1?$_Uninitialized_backout_al@V?$xalloc@PAVIRender_Sector@@@@@std@@QAE@XZ ENDP ; std::_Uninitialized_backout_al<xalloc<IRender_Sector *> >::~_Uninitialized_backout_al<xalloc<IRender_Sector *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??0?$_Uninitialized_backout_al@V?$xalloc@PAVIRender_Sector@@@@@std@@QAE@PAPAVIRender_Sector@@AAV?$xalloc@PAVIRender_Sector@@@@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Al_$ = 12						; size = 4
??0?$_Uninitialized_backout_al@V?$xalloc@PAVIRender_Sector@@@@@std@@QAE@PAPAVIRender_Sector@@AAV?$xalloc@PAVIRender_Sector@@@@@Z PROC ; std::_Uninitialized_backout_al<xalloc<IRender_Sector *> >::_Uninitialized_backout_al<xalloc<IRender_Sector *> >, COMDAT
; _this$ = ecx

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	eax, DWORD PTR __Dest$[esp-4]
	mov	DWORD PTR [ecx], eax
	mov	DWORD PTR [ecx+4], eax
	mov	eax, DWORD PTR __Al_$[esp-4]
	mov	DWORD PTR [ecx+8], eax
	mov	eax, ecx
	ret	8
??0?$_Uninitialized_backout_al@V?$xalloc@PAVIRender_Sector@@@@@std@@QAE@PAPAVIRender_Sector@@AAV?$xalloc@PAVIRender_Sector@@@@@Z ENDP ; std::_Uninitialized_backout_al<xalloc<IRender_Sector *> >::_Uninitialized_backout_al<xalloc<IRender_Sector *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\type_traits
;	COMDAT ??$forward@PAVCPortal@@@std@@YA$$QAPAVCPortal@@AAPAV1@@Z
_TEXT	SEGMENT
??$forward@PAVCPortal@@@std@@YA$$QAPAVCPortal@@AAPAV1@@Z PROC ; std::forward<CPortal *>, COMDAT
; __Arg$ = ecx

; 1386 :     return static_cast<_Ty&&>(_Arg);

	mov	eax, ecx

; 1387 : }

	ret	0
??$forward@PAVCPortal@@@std@@YA$$QAPAVCPortal@@AAPAV1@@Z ENDP ; std::forward<CPortal *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$construct@PAVCPortal@@PAV1@@?$_Normal_allocator_traits@V?$xalloc@PAVCPortal@@@@@std@@SAXAAV?$xalloc@PAVCPortal@@@@PAPAVCPortal@@$$QAPAV3@@Z
_TEXT	SEGMENT
_<_Args_0>$ = 8						; size = 4
??$construct@PAVCPortal@@PAV1@@?$_Normal_allocator_traits@V?$xalloc@PAVCPortal@@@@@std@@SAXAAV?$xalloc@PAVCPortal@@@@PAPAVCPortal@@$$QAPAV3@@Z PROC ; std::_Normal_allocator_traits<xalloc<CPortal *> >::construct<CPortal *,CPortal *>, COMDAT
; __Al$dead$ = ecx
; __Ptr$ = edx

; 565  :         if constexpr (_Uses_default_construct<_Alloc, _Ty*, _Types...>::value) {
; 566  :             (void) _Al; // TRANSITION, DevCom-1004719
; 567  : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 568  :             _STD construct_at(_Ptr, _STD forward<_Types>(_Args)...);
; 569  : #else // __cpp_lib_constexpr_dynamic_alloc
; 570  :             ::new (static_cast<void*>(_Ptr)) _Ty(_STD forward<_Types>(_Args)...);
; 571  : #endif // __cpp_lib_constexpr_dynamic_alloc
; 572  :         } else {
; 573  :             _Al.construct(_Ptr, _STD forward<_Types>(_Args)...);

	mov	eax, DWORD PTR _<_Args_0>$[esp-4]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edx], eax

; 574  :         }
; 575  :     }

	ret	0
??$construct@PAVCPortal@@PAV1@@?$_Normal_allocator_traits@V?$xalloc@PAVCPortal@@@@@std@@SAXAAV?$xalloc@PAVCPortal@@@@PAPAVCPortal@@$$QAPAV3@@Z ENDP ; std::_Normal_allocator_traits<xalloc<CPortal *> >::construct<CPortal *,CPortal *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$destroy@PAVIRender_Sector@@@?$_Normal_allocator_traits@V?$xalloc@PAVIRender_Sector@@@@@std@@SAXAAV?$xalloc@PAVIRender_Sector@@@@PAPAVIRender_Sector@@@Z
_TEXT	SEGMENT
??$destroy@PAVIRender_Sector@@@?$_Normal_allocator_traits@V?$xalloc@PAVIRender_Sector@@@@@std@@SAXAAV?$xalloc@PAVIRender_Sector@@@@PAPAVIRender_Sector@@@Z PROC ; std::_Normal_allocator_traits<xalloc<IRender_Sector *> >::destroy<IRender_Sector *>, COMDAT
; __Al$dead$ = ecx
; __Ptr$dead$ = edx

; 579  :         if constexpr (_Uses_default_destroy<_Alloc, _Ty*>::value) {
; 580  : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 581  :             _STD destroy_at(_Ptr);
; 582  : #else // __cpp_lib_constexpr_dynamic_alloc
; 583  :             _Ptr->~_Ty();
; 584  : #endif // __cpp_lib_constexpr_dynamic_alloc
; 585  :         } else {
; 586  :             _Al.destroy(_Ptr);
; 587  :         }
; 588  :     }

	ret	0
??$destroy@PAVIRender_Sector@@@?$_Normal_allocator_traits@V?$xalloc@PAVIRender_Sector@@@@@std@@SAXAAV?$xalloc@PAVIRender_Sector@@@@PAPAVIRender_Sector@@@Z ENDP ; std::_Normal_allocator_traits<xalloc<IRender_Sector *> >::destroy<IRender_Sector *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Emplace_back@PAVIRender_Sector@@@?$_Uninitialized_backout_al@V?$xalloc@PAVIRender_Sector@@@@@std@@QAEX$$QAPAVIRender_Sector@@@Z
_TEXT	SEGMENT
_<_Vals_0>$ = 8						; size = 4
??$_Emplace_back@PAVIRender_Sector@@@?$_Uninitialized_backout_al@V?$xalloc@PAVIRender_Sector@@@@@std@@QAEX$$QAPAVIRender_Sector@@@Z PROC ; std::_Uninitialized_backout_al<xalloc<IRender_Sector *> >::_Emplace_back<IRender_Sector *>, COMDAT
; _this$ = ecx

; 1620 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _<_Vals_0>$[esp-4]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edx], eax

; 1621 :         ++_Last;

	add	DWORD PTR [ecx+4], 4

; 1622 :     }

	ret	4
??$_Emplace_back@PAVIRender_Sector@@@?$_Uninitialized_backout_al@V?$xalloc@PAVIRender_Sector@@@@@std@@QAEX$$QAPAVIRender_Sector@@@Z ENDP ; std::_Uninitialized_backout_al<xalloc<IRender_Sector *> >::_Emplace_back<IRender_Sector *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\type_traits
;	COMDAT ??$move@AAU_scissor@@@std@@YA$$QAU_scissor@@AAU1@@Z
_TEXT	SEGMENT
??$move@AAU_scissor@@@std@@YA$$QAU_scissor@@AAU1@@Z PROC ; std::move<_scissor &>, COMDAT
; __Arg$ = ecx

; 1397 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

	mov	eax, ecx

; 1398 : }

	ret	0
??$move@AAU_scissor@@@std@@YA$$QAU_scissor@@AAU1@@Z ENDP ; std::move<_scissor &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Emplace_back@U_scissor@@@?$_Uninitialized_backout_al@V?$xalloc@U_scissor@@@@@std@@QAEX$$QAU_scissor@@@Z
_TEXT	SEGMENT
_<_Vals_0>$ = 8						; size = 4
??$_Emplace_back@U_scissor@@@?$_Uninitialized_backout_al@V?$xalloc@U_scissor@@@@@std@@QAEX$$QAU_scissor@@@Z PROC ; std::_Uninitialized_backout_al<xalloc<_scissor> >::_Emplace_back<_scissor>, COMDAT
; _this$ = ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	edx, DWORD PTR _<_Vals_0>$[esp-4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1619 :     _CONSTEXPR20_DYNALLOC void _Emplace_back(_Types&&... _Vals) { // construct a new element at *_Last and increment

	push	esi
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	esi, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [esi], eax
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [esi+4], eax
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR [esi+8], eax
	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR [esi+12], eax
	mov	eax, DWORD PTR [edx+16]
	mov	DWORD PTR [esi+16], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1621 :         ++_Last;

	add	DWORD PTR [ecx+4], 20			; 00000014H
	pop	esi

; 1622 :     }

	ret	4
??$_Emplace_back@U_scissor@@@?$_Uninitialized_backout_al@V?$xalloc@U_scissor@@@@@std@@QAEX$$QAU_scissor@@@Z ENDP ; std::_Uninitialized_backout_al<xalloc<_scissor> >::_Emplace_back<_scissor>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\type_traits
;	COMDAT ??$move@AAVCFrustum@@@std@@YA$$QAVCFrustum@@AAV1@@Z
_TEXT	SEGMENT
??$move@AAVCFrustum@@@std@@YA$$QAVCFrustum@@AAV1@@Z PROC ; std::move<CFrustum &>, COMDAT
; __Arg$ = ecx

; 1397 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

	mov	eax, ecx

; 1398 : }

	ret	0
??$move@AAVCFrustum@@@std@@YA$$QAVCFrustum@@AAV1@@Z ENDP ; std::move<CFrustum &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Emplace_back@VCFrustum@@@?$_Uninitialized_backout_al@V?$xalloc@VCFrustum@@@@@std@@QAEX$$QAVCFrustum@@@Z
_TEXT	SEGMENT
_<_Vals_0>$ = 8						; size = 4
??$_Emplace_back@VCFrustum@@@?$_Uninitialized_backout_al@V?$xalloc@VCFrustum@@@@@std@@QAEX$$QAVCFrustum@@@Z PROC ; std::_Uninitialized_backout_al<xalloc<CFrustum> >::_Emplace_back<CFrustum>, COMDAT
; _this$ = ecx

; 1619 :     _CONSTEXPR20_DYNALLOC void _Emplace_back(_Types&&... _Vals) { // construct a new element at *_Last and increment

	mov	eax, ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	ecx, 61					; 0000003dH
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1619 :     _CONSTEXPR20_DYNALLOC void _Emplace_back(_Types&&... _Vals) { // construct a new element at *_Last and increment

	push	esi
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	esi, DWORD PTR _<_Vals_0>$[esp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1619 :     _CONSTEXPR20_DYNALLOC void _Emplace_back(_Types&&... _Vals) { // construct a new element at *_Last and increment

	push	edi
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	edi, DWORD PTR [eax+4]
	rep movsd
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1621 :         ++_Last;

	add	DWORD PTR [eax+4], 244			; 000000f4H
	pop	edi
	pop	esi

; 1622 :     }

	ret	4
??$_Emplace_back@VCFrustum@@@?$_Uninitialized_backout_al@V?$xalloc@VCFrustum@@@@@std@@QAEX$$QAVCFrustum@@@Z ENDP ; std::_Uninitialized_backout_al<xalloc<CFrustum> >::_Emplace_back<CFrustum>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?destroy@?$xalloc@PAVIRender_Sector@@@@QAEXPAPAVIRender_Sector@@@Z
_TEXT	SEGMENT
_p$dead$ = 8						; size = 4
?destroy@?$xalloc@PAVIRender_Sector@@@@QAEXPAPAVIRender_Sector@@@Z PROC ; xalloc<IRender_Sector *>::destroy, COMDAT
; _this$dead$ = ecx

; 85   : 							void					destroy			(pointer p)								{	std::_Destroy_in_place(p);			}

	ret	4
?destroy@?$xalloc@PAVIRender_Sector@@@@QAEXPAPAVIRender_Sector@@@Z ENDP ; xalloc<IRender_Sector *>::destroy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\type_traits
;	COMDAT ??$forward@U_scissor@@@std@@YA$$QAU_scissor@@AAU1@@Z
_TEXT	SEGMENT
??$forward@U_scissor@@@std@@YA$$QAU_scissor@@AAU1@@Z PROC ; std::forward<_scissor>, COMDAT
; __Arg$ = ecx

; 1386 :     return static_cast<_Ty&&>(_Arg);

	mov	eax, ecx

; 1387 : }

	ret	0
??$forward@U_scissor@@@std@@YA$$QAU_scissor@@AAU1@@Z ENDP ; std::forward<_scissor>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$construct@U_scissor@@U1@@?$_Normal_allocator_traits@V?$xalloc@U_scissor@@@@@std@@SAXAAV?$xalloc@U_scissor@@@@PAU_scissor@@$$QAU3@@Z
_TEXT	SEGMENT
_<_Args_0>$ = 8						; size = 4
??$construct@U_scissor@@U1@@?$_Normal_allocator_traits@V?$xalloc@U_scissor@@@@@std@@SAXAAV?$xalloc@U_scissor@@@@PAU_scissor@@$$QAU3@@Z PROC ; std::_Normal_allocator_traits<xalloc<_scissor> >::construct<_scissor,_scissor>, COMDAT
; __Al$dead$ = ecx
; __Ptr$ = edx
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	ecx, DWORD PTR _<_Args_0>$[esp-4]
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], eax
	mov	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+8], eax
	mov	eax, DWORD PTR [ecx+12]
	mov	DWORD PTR [edx+12], eax
	mov	eax, DWORD PTR [ecx+16]
	mov	DWORD PTR [edx+16], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 575  :     }

	ret	0
??$construct@U_scissor@@U1@@?$_Normal_allocator_traits@V?$xalloc@U_scissor@@@@@std@@SAXAAV?$xalloc@U_scissor@@@@PAU_scissor@@$$QAU3@@Z ENDP ; std::_Normal_allocator_traits<xalloc<_scissor> >::construct<_scissor,_scissor>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\type_traits
;	COMDAT ??$forward@VCFrustum@@@std@@YA$$QAVCFrustum@@AAV1@@Z
_TEXT	SEGMENT
??$forward@VCFrustum@@@std@@YA$$QAVCFrustum@@AAV1@@Z PROC ; std::forward<CFrustum>, COMDAT
; __Arg$ = ecx

; 1386 :     return static_cast<_Ty&&>(_Arg);

	mov	eax, ecx

; 1387 : }

	ret	0
??$forward@VCFrustum@@@std@@YA$$QAVCFrustum@@AAV1@@Z ENDP ; std::forward<CFrustum>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$construct@VCFrustum@@V1@@?$_Normal_allocator_traits@V?$xalloc@VCFrustum@@@@@std@@SAXAAV?$xalloc@VCFrustum@@@@PAVCFrustum@@$$QAV3@@Z
_TEXT	SEGMENT
_<_Args_0>$ = 8						; size = 4
??$construct@VCFrustum@@V1@@?$_Normal_allocator_traits@V?$xalloc@VCFrustum@@@@@std@@SAXAAV?$xalloc@VCFrustum@@@@PAVCFrustum@@$$QAV3@@Z PROC ; std::_Normal_allocator_traits<xalloc<CFrustum> >::construct<CFrustum,CFrustum>, COMDAT
; __Al$dead$ = ecx
; __Ptr$ = edx

; 564  :     static _CONSTEXPR20_DYNALLOC void construct(_Alloc& _Al, _Ty* _Ptr, _Types&&... _Args) {

	push	esi
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	esi, DWORD PTR _<_Args_0>$[esp]
	mov	ecx, 61					; 0000003dH
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 564  :     static _CONSTEXPR20_DYNALLOC void construct(_Alloc& _Al, _Ty* _Ptr, _Types&&... _Args) {

	push	edi
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	edi, edx
	rep movsd
	pop	edi
	pop	esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 575  :     }

	ret	0
??$construct@VCFrustum@@V1@@?$_Normal_allocator_traits@V?$xalloc@VCFrustum@@@@@std@@SAXAAV?$xalloc@VCFrustum@@@@PAVCFrustum@@$$QAV3@@Z ENDP ; std::_Normal_allocator_traits<xalloc<CFrustum> >::construct<CFrustum,CFrustum>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Destroy_in_place@PAPAVIRender_Sector@@@std@@YAXAAPAPAVIRender_Sector@@@Z
_TEXT	SEGMENT
??$_Destroy_in_place@PAPAVIRender_Sector@@@std@@YAXAAPAPAVIRender_Sector@@@Z PROC ; std::_Destroy_in_place<IRender_Sector * *>, COMDAT
; __Obj$dead$ = ecx

; 295  :     if constexpr (is_array_v<_Ty>) {
; 296  :         _Destroy_range(_Obj, _Obj + extent_v<_Ty>);
; 297  :     } else {
; 298  :         _Obj.~_Ty();
; 299  :     }
; 300  : }

	ret	0
??$_Destroy_in_place@PAPAVIRender_Sector@@@std@@YAXAAPAPAVIRender_Sector@@@Z ENDP ; std::_Destroy_in_place<IRender_Sector * *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\FixedVector.h
;	COMDAT ?assign@?$svector@U?$_vector3@M@@$0DA@@@QAEXPAU?$_vector3@M@@H@Z
_TEXT	SEGMENT
_p$ = 8							; size = 4
_c$ = 12						; size = 4
?assign@?$svector@U?$_vector3@M@@$0DA@@@QAEXPAU?$_vector3@M@@H@Z PROC ; svector<_vector3<float>,48>::assign, COMDAT
; _this$ = ecx

; 65   : 	IC void		assign(iterator p, int c) { VERIFY(c>0 && c<dim); CopyMemory(array,p,c*sizeof(value_type)); count=c; }

	push	esi
	mov	esi, DWORD PTR _c$[esp]
	push	edi
	mov	edi, ecx
	lea	eax, DWORD PTR [esi+esi*2]
	shl	eax, 2
	push	eax
	push	DWORD PTR _p$[esp+8]
	push	edi
	call	_memcpy
	add	esp, 12					; 0000000cH
	mov	DWORD PTR [edi+576], esi
	pop	edi
	pop	esi
	ret	8
?assign@?$svector@U?$_vector3@M@@$0DA@@@QAEXPAU?$_vector3@M@@H@Z ENDP ; svector<_vector3<float>,48>::assign
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__sector.h
;	COMDAT ?getPoly@CPortal@@QAEAAV?$svector@U?$_vector3@M@@$07@@XZ
_TEXT	SEGMENT
?getPoly@CPortal@@QAEAAV?$svector@U?$_vector3@M@@$07@@XZ PROC ; CPortal::getPoly, COMDAT
; _this$ = ecx

; 34   : 	svector<Fvector,8>&				getPoly()							{ return poly;		}

	lea	eax, DWORD PTR [ecx+4]
	ret	0
?getPoly@CPortal@@QAEAAV?$svector@U?$_vector3@M@@$07@@XZ ENDP ; CPortal::getPoly
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__sector.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_plane.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_plane.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__sector.h
;	COMDAT ?getSectorBack@CPortal@@QAEPAVCSector@@ABU?$_vector3@M@@@Z
_TEXT	SEGMENT
_V$ = 8							; size = 4
?getSectorBack@CPortal@@QAEPAVCSector@@ABU?$_vector3@M@@@Z PROC ; CPortal::getSectorBack, COMDAT
; _this$ = ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	mov	eax, DWORD PTR _V$[esp-4]
	movss	xmm0, DWORD PTR [ecx+112]
	movss	xmm1, DWORD PTR [ecx+116]
	mulss	xmm0, DWORD PTR [eax]
	mulss	xmm1, DWORD PTR [eax+4]
; File I:\Vitalya\mine\NSProjectX\xrCore\_plane.h

; 57   : 		return n.dotproduct(v)+d;

	addss	xmm1, xmm0
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	movss	xmm0, DWORD PTR [ecx+120]
	mulss	xmm0, DWORD PTR [eax+8]
; File I:\Vitalya\mine\NSProjectX\xrCore\_plane.h

; 57   : 		return n.dotproduct(v)+d;

	addss	xmm0, DWORD PTR [ecx+124]
	addss	xmm1, xmm0
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__sector.h

; 39   : 	CSector*						getSectorBack	(const Fvector& V)	{ if (P.classify(V)>0) return pBack; else return pFace;	}

	comiss	xmm1, DWORD PTR __real@00000000
	jbe	SHORT $LN2@getSectorB
	mov	eax, DWORD PTR [ecx+108]
	ret	4
$LN2@getSectorB:
	mov	eax, DWORD PTR [ecx+104]
	ret	4
?getSectorBack@CPortal@@QAEPAVCSector@@ABU?$_vector3@M@@@Z ENDP ; CPortal::getSectorBack
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__sector.h
;	COMDAT ?getSector@CPortal@@QAEPAVCSector@@PAV2@@Z
_TEXT	SEGMENT
_pFrom$ = 8						; size = 4
?getSector@CPortal@@QAEPAVCSector@@PAV2@@Z PROC		; CPortal::getSector, COMDAT
; _this$ = ecx

; 37   : 	CSector*						getSector		(CSector* pFrom)	{ return pFrom==pFace?pBack:pFace; }

	mov	eax, DWORD PTR [ecx+104]
	cmp	DWORD PTR _pFrom$[esp-4], eax
	jne	SHORT $LN4@getSector
	mov	eax, DWORD PTR [ecx+108]
$LN4@getSector:
	ret	4
?getSector@CPortal@@QAEPAVCSector@@PAV2@@Z ENDP		; CPortal::getSector
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Destroy_in_place@PAU_scissor@@@std@@YAXAAPAU_scissor@@@Z
_TEXT	SEGMENT
??$_Destroy_in_place@PAU_scissor@@@std@@YAXAAPAU_scissor@@@Z PROC ; std::_Destroy_in_place<_scissor *>, COMDAT
; __Obj$dead$ = ecx

; 295  :     if constexpr (is_array_v<_Ty>) {
; 296  :         _Destroy_range(_Obj, _Obj + extent_v<_Ty>);
; 297  :     } else {
; 298  :         _Obj.~_Ty();
; 299  :     }
; 300  : }

	ret	0
??$_Destroy_in_place@PAU_scissor@@@std@@YAXAAPAU_scissor@@@Z ENDP ; std::_Destroy_in_place<_scissor *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?destroy@?$xalloc@U_scissor@@@@QAEXPAU_scissor@@@Z
_TEXT	SEGMENT
_p$dead$ = 8						; size = 4
?destroy@?$xalloc@U_scissor@@@@QAEXPAU_scissor@@@Z PROC	; xalloc<_scissor>::destroy, COMDAT
; _this$dead$ = ecx

; 85   : 							void					destroy			(pointer p)								{	std::_Destroy_in_place(p);			}

	ret	4
?destroy@?$xalloc@U_scissor@@@@QAEXPAU_scissor@@@Z ENDP	; xalloc<_scissor>::destroy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$destroy@U_scissor@@@?$_Normal_allocator_traits@V?$xalloc@U_scissor@@@@@std@@SAXAAV?$xalloc@U_scissor@@@@PAU_scissor@@@Z
_TEXT	SEGMENT
??$destroy@U_scissor@@@?$_Normal_allocator_traits@V?$xalloc@U_scissor@@@@@std@@SAXAAV?$xalloc@U_scissor@@@@PAU_scissor@@@Z PROC ; std::_Normal_allocator_traits<xalloc<_scissor> >::destroy<_scissor>, COMDAT
; __Al$dead$ = ecx
; __Ptr$dead$ = edx

; 579  :         if constexpr (_Uses_default_destroy<_Alloc, _Ty*>::value) {
; 580  : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 581  :             _STD destroy_at(_Ptr);
; 582  : #else // __cpp_lib_constexpr_dynamic_alloc
; 583  :             _Ptr->~_Ty();
; 584  : #endif // __cpp_lib_constexpr_dynamic_alloc
; 585  :         } else {
; 586  :             _Al.destroy(_Ptr);
; 587  :         }
; 588  :     }

	ret	0
??$destroy@U_scissor@@@?$_Normal_allocator_traits@V?$xalloc@U_scissor@@@@@std@@SAXAAV?$xalloc@U_scissor@@@@PAU_scissor@@@Z ENDP ; std::_Normal_allocator_traits<xalloc<_scissor> >::destroy<_scissor>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef
;	COMDAT ??$_Unfancy@U_scissor@@@std@@YAPAU_scissor@@PAU1@@Z
_TEXT	SEGMENT
??$_Unfancy@U_scissor@@@std@@YAPAU_scissor@@PAU1@@Z PROC ; std::_Unfancy<_scissor>, COMDAT
; __Ptr$ = ecx

; 266  :     return _Ptr;

	mov	eax, ecx

; 267  : }

	ret	0
??$_Unfancy@U_scissor@@@std@@YAPAU_scissor@@PAU1@@Z ENDP ; std::_Unfancy<_scissor>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Destroy_range@V?$xalloc@U_scissor@@@@@std@@YAXPAU_scissor@@QAU1@AAV?$xalloc@U_scissor@@@@@Z
_TEXT	SEGMENT
__Al$dead$ = 8						; size = 4
??$_Destroy_range@V?$xalloc@U_scissor@@@@@std@@YAXPAU_scissor@@QAU1@AAV?$xalloc@U_scissor@@@@@Z PROC ; std::_Destroy_range<xalloc<_scissor> >, COMDAT
; __First$dead$ = ecx
; __Last$dead$ = edx

; 901  :     // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
; 902  :     using _Ty = typename _Alloc::value_type;
; 903  :     if constexpr (!conjunction_v<is_trivially_destructible<_Ty>, _Uses_default_destroy<_Alloc, _Ty*>>) {
; 904  :         for (; _First != _Last; ++_First) {
; 905  :             allocator_traits<_Alloc>::destroy(_Al, _Unfancy(_First));
; 906  :         }
; 907  :     }
; 908  : }

	ret	0
??$_Destroy_range@V?$xalloc@U_scissor@@@@@std@@YAXPAU_scissor@@QAU1@AAV?$xalloc@U_scissor@@@@@Z ENDP ; std::_Destroy_range<xalloc<_scissor> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Destroy@?$vector@U_scissor@@V?$xalloc@U_scissor@@@@@std@@AAEXPAU_scissor@@0@Z
_TEXT	SEGMENT
__First$dead$ = 8					; size = 4
__Last$dead$ = 12					; size = 4
?_Destroy@?$vector@U_scissor@@V?$xalloc@U_scissor@@@@@std@@AAEXPAU_scissor@@0@Z PROC ; std::vector<_scissor,xalloc<_scissor> >::_Destroy, COMDAT
; _this$dead$ = ecx

; 1666 :         // destroy [_First, _Last) using allocator
; 1667 :         _Destroy_range(_First, _Last, _Getal());
; 1668 :     }

	ret	8
?_Destroy@?$vector@U_scissor@@V?$xalloc@U_scissor@@@@@std@@AAEXPAU_scissor@@0@Z ENDP ; std::vector<_scissor,xalloc<_scissor> >::_Destroy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
;	COMDAT ??$xr_free@U_scissor@@@@YAXAAPAU_scissor@@@Z
_TEXT	SEGMENT
??$xr_free@U_scissor@@@@YAXAAPAU_scissor@@@Z PROC	; xr_free<_scissor>, COMDAT
; _P$ = ecx

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	push	esi
	mov	esi, ecx
	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN2@xr_free
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
	mov	DWORD PTR [esi], 0
$LN2@xr_free:
	pop	esi
	ret	0
??$xr_free@U_scissor@@@@YAXAAPAU_scissor@@@Z ENDP	; xr_free<_scissor>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?deallocate@?$xalloc@U_scissor@@@@QBEXPAU_scissor@@I@Z
_TEXT	SEGMENT
_p$ = 8							; size = 4
_n$dead$ = 12						; size = 4
?deallocate@?$xalloc@U_scissor@@@@QBEXPAU_scissor@@I@Z PROC ; xalloc<_scissor>::deallocate, COMDAT
; _this$dead$ = ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	eax, DWORD PTR _p$[esp-4]
	test	eax, eax
	je	SHORT $LN4@deallocate
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN4@deallocate:
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 82   : 							void					deallocate		(pointer p, size_type n) const			{	xr_free	(p);				}

	ret	8
?deallocate@?$xalloc@U_scissor@@@@QBEXPAU_scissor@@I@Z ENDP ; xalloc<_scissor>::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$xalloc@U_scissor@@@@V?$_Vector_val@U?$_Simple_types@U_scissor@@@std@@@std@@$00@std@@QAEAAV?$xalloc@U_scissor@@@@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@V?$xalloc@U_scissor@@@@V?$_Vector_val@U?$_Simple_types@U_scissor@@@std@@@std@@$00@std@@QAEAAV?$xalloc@U_scissor@@@@XZ PROC ; std::_Compressed_pair<xalloc<_scissor>,std::_Vector_val<std::_Simple_types<_scissor> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 1339 :         return *this;

	mov	eax, ecx

; 1340 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$xalloc@U_scissor@@@@V?$_Vector_val@U?$_Simple_types@U_scissor@@@std@@@std@@$00@std@@QAEAAV?$xalloc@U_scissor@@@@XZ ENDP ; std::_Compressed_pair<xalloc<_scissor>,std::_Vector_val<std::_Simple_types<_scissor> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Getal@?$vector@U_scissor@@V?$xalloc@U_scissor@@@@@std@@AAEAAV?$xalloc@U_scissor@@@@XZ
_TEXT	SEGMENT
?_Getal@?$vector@U_scissor@@V?$xalloc@U_scissor@@@@@std@@AAEAAV?$xalloc@U_scissor@@@@XZ PROC ; std::vector<_scissor,xalloc<_scissor> >::_Getal, COMDAT
; _this$ = ecx

; 1805 :         return _Mypair._Get_first();

	mov	eax, ecx

; 1806 :     }

	ret	0
?_Getal@?$vector@U_scissor@@V?$xalloc@U_scissor@@@@@std@@AAEAAV?$xalloc@U_scissor@@@@XZ ENDP ; std::vector<_scissor,xalloc<_scissor> >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Tidy@?$vector@U_scissor@@V?$xalloc@U_scissor@@@@@std@@AAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@U_scissor@@V?$xalloc@U_scissor@@@@@std@@AAEXXZ PROC ; std::vector<_scissor,xalloc<_scissor> >::_Tidy, COMDAT
; _this$ = ecx

; 1742 :     _CONSTEXPR20_CONTAINER void _Tidy() noexcept { // free all storage

	push	esi
	mov	esi, ecx

; 1743 :         auto& _My_data    = _Mypair._Myval2;
; 1744 :         pointer& _Myfirst = _My_data._Myfirst;
; 1745 :         pointer& _Mylast  = _My_data._Mylast;
; 1746 :         pointer& _Myend   = _My_data._Myend;
; 1747 : 
; 1748 :         _My_data._Orphan_all();
; 1749 : 
; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN2@Tidy
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+4], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+8], 0
$LN2@Tidy:

; 1757 :         }
; 1758 :     }

	pop	esi
	ret	0
?_Tidy@?$vector@U_scissor@@V?$xalloc@U_scissor@@@@@std@@AAEXXZ ENDP ; std::vector<_scissor,xalloc<_scissor> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??1?$vector@U_scissor@@V?$xalloc@U_scissor@@@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@U_scissor@@V?$xalloc@U_scissor@@@@@std@@QAE@XZ PROC ; std::vector<_scissor,xalloc<_scissor> >::~vector<_scissor,xalloc<_scissor> >, COMDAT
; _this$ = ecx

; 698  :     _CONSTEXPR20_CONTAINER ~vector() noexcept {

	push	esi
	mov	esi, ecx

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN4@vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+4], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+8], 0
$LN4@vector:
	pop	esi

; 699  :         _Tidy();
; 700  : #if _ITERATOR_DEBUG_LEVEL != 0
; 701  :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 702  :         _Delete_plain_internal(_Alproxy, _STD exchange(_Mypair._Myval2._Myproxy, nullptr));
; 703  : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 704  :     }

	ret	0
??1?$vector@U_scissor@@V?$xalloc@U_scissor@@@@@std@@QAE@XZ ENDP ; std::vector<_scissor,xalloc<_scissor> >::~vector<_scissor,xalloc<_scissor> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??1?$xr_vector@U_scissor@@V?$xalloc@U_scissor@@@@@@QAE@XZ
_TEXT	SEGMENT
??1?$xr_vector@U_scissor@@V?$xalloc@U_scissor@@@@@@QAE@XZ PROC ; xr_vector<_scissor,xalloc<_scissor> >::~xr_vector<_scissor,xalloc<_scissor> >, COMDAT
; _this$ = ecx

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	push	esi
	mov	esi, ecx
	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN6@xr_vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+4], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+8], 0
$LN6@xr_vector:
	pop	esi
	ret	0
??1?$xr_vector@U_scissor@@V?$xalloc@U_scissor@@@@@@QAE@XZ ENDP ; xr_vector<_scissor,xalloc<_scissor> >::~xr_vector<_scissor,xalloc<_scissor> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Destroy_in_place@PAVCFrustum@@@std@@YAXAAPAVCFrustum@@@Z
_TEXT	SEGMENT
??$_Destroy_in_place@PAVCFrustum@@@std@@YAXAAPAVCFrustum@@@Z PROC ; std::_Destroy_in_place<CFrustum *>, COMDAT
; __Obj$dead$ = ecx

; 295  :     if constexpr (is_array_v<_Ty>) {
; 296  :         _Destroy_range(_Obj, _Obj + extent_v<_Ty>);
; 297  :     } else {
; 298  :         _Obj.~_Ty();
; 299  :     }
; 300  : }

	ret	0
??$_Destroy_in_place@PAVCFrustum@@@std@@YAXAAPAVCFrustum@@@Z ENDP ; std::_Destroy_in_place<CFrustum *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?destroy@?$xalloc@VCFrustum@@@@QAEXPAVCFrustum@@@Z
_TEXT	SEGMENT
_p$dead$ = 8						; size = 4
?destroy@?$xalloc@VCFrustum@@@@QAEXPAVCFrustum@@@Z PROC	; xalloc<CFrustum>::destroy, COMDAT
; _this$dead$ = ecx

; 85   : 							void					destroy			(pointer p)								{	std::_Destroy_in_place(p);			}

	ret	4
?destroy@?$xalloc@VCFrustum@@@@QAEXPAVCFrustum@@@Z ENDP	; xalloc<CFrustum>::destroy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$destroy@VCFrustum@@@?$_Normal_allocator_traits@V?$xalloc@VCFrustum@@@@@std@@SAXAAV?$xalloc@VCFrustum@@@@PAVCFrustum@@@Z
_TEXT	SEGMENT
??$destroy@VCFrustum@@@?$_Normal_allocator_traits@V?$xalloc@VCFrustum@@@@@std@@SAXAAV?$xalloc@VCFrustum@@@@PAVCFrustum@@@Z PROC ; std::_Normal_allocator_traits<xalloc<CFrustum> >::destroy<CFrustum>, COMDAT
; __Al$dead$ = ecx
; __Ptr$dead$ = edx

; 579  :         if constexpr (_Uses_default_destroy<_Alloc, _Ty*>::value) {
; 580  : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 581  :             _STD destroy_at(_Ptr);
; 582  : #else // __cpp_lib_constexpr_dynamic_alloc
; 583  :             _Ptr->~_Ty();
; 584  : #endif // __cpp_lib_constexpr_dynamic_alloc
; 585  :         } else {
; 586  :             _Al.destroy(_Ptr);
; 587  :         }
; 588  :     }

	ret	0
??$destroy@VCFrustum@@@?$_Normal_allocator_traits@V?$xalloc@VCFrustum@@@@@std@@SAXAAV?$xalloc@VCFrustum@@@@PAVCFrustum@@@Z ENDP ; std::_Normal_allocator_traits<xalloc<CFrustum> >::destroy<CFrustum>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef
;	COMDAT ??$_Unfancy@VCFrustum@@@std@@YAPAVCFrustum@@PAV1@@Z
_TEXT	SEGMENT
??$_Unfancy@VCFrustum@@@std@@YAPAVCFrustum@@PAV1@@Z PROC ; std::_Unfancy<CFrustum>, COMDAT
; __Ptr$ = ecx

; 266  :     return _Ptr;

	mov	eax, ecx

; 267  : }

	ret	0
??$_Unfancy@VCFrustum@@@std@@YAPAVCFrustum@@PAV1@@Z ENDP ; std::_Unfancy<CFrustum>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Destroy_range@V?$xalloc@VCFrustum@@@@@std@@YAXPAVCFrustum@@QAV1@AAV?$xalloc@VCFrustum@@@@@Z
_TEXT	SEGMENT
__Al$dead$ = 8						; size = 4
??$_Destroy_range@V?$xalloc@VCFrustum@@@@@std@@YAXPAVCFrustum@@QAV1@AAV?$xalloc@VCFrustum@@@@@Z PROC ; std::_Destroy_range<xalloc<CFrustum> >, COMDAT
; __First$dead$ = ecx
; __Last$dead$ = edx

; 901  :     // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
; 902  :     using _Ty = typename _Alloc::value_type;
; 903  :     if constexpr (!conjunction_v<is_trivially_destructible<_Ty>, _Uses_default_destroy<_Alloc, _Ty*>>) {
; 904  :         for (; _First != _Last; ++_First) {
; 905  :             allocator_traits<_Alloc>::destroy(_Al, _Unfancy(_First));
; 906  :         }
; 907  :     }
; 908  : }

	ret	0
??$_Destroy_range@V?$xalloc@VCFrustum@@@@@std@@YAXPAVCFrustum@@QAV1@AAV?$xalloc@VCFrustum@@@@@Z ENDP ; std::_Destroy_range<xalloc<CFrustum> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Destroy@?$vector@VCFrustum@@V?$xalloc@VCFrustum@@@@@std@@AAEXPAVCFrustum@@0@Z
_TEXT	SEGMENT
__First$dead$ = 8					; size = 4
__Last$dead$ = 12					; size = 4
?_Destroy@?$vector@VCFrustum@@V?$xalloc@VCFrustum@@@@@std@@AAEXPAVCFrustum@@0@Z PROC ; std::vector<CFrustum,xalloc<CFrustum> >::_Destroy, COMDAT
; _this$dead$ = ecx

; 1666 :         // destroy [_First, _Last) using allocator
; 1667 :         _Destroy_range(_First, _Last, _Getal());
; 1668 :     }

	ret	8
?_Destroy@?$vector@VCFrustum@@V?$xalloc@VCFrustum@@@@@std@@AAEXPAVCFrustum@@0@Z ENDP ; std::vector<CFrustum,xalloc<CFrustum> >::_Destroy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
;	COMDAT ??$xr_free@VCFrustum@@@@YAXAAPAVCFrustum@@@Z
_TEXT	SEGMENT
??$xr_free@VCFrustum@@@@YAXAAPAVCFrustum@@@Z PROC	; xr_free<CFrustum>, COMDAT
; _P$ = ecx

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	push	esi
	mov	esi, ecx
	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN2@xr_free
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
	mov	DWORD PTR [esi], 0
$LN2@xr_free:
	pop	esi
	ret	0
??$xr_free@VCFrustum@@@@YAXAAPAVCFrustum@@@Z ENDP	; xr_free<CFrustum>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?deallocate@?$xalloc@VCFrustum@@@@QBEXPAVCFrustum@@I@Z
_TEXT	SEGMENT
_p$ = 8							; size = 4
_n$dead$ = 12						; size = 4
?deallocate@?$xalloc@VCFrustum@@@@QBEXPAVCFrustum@@I@Z PROC ; xalloc<CFrustum>::deallocate, COMDAT
; _this$dead$ = ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	eax, DWORD PTR _p$[esp-4]
	test	eax, eax
	je	SHORT $LN4@deallocate
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN4@deallocate:
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 82   : 							void					deallocate		(pointer p, size_type n) const			{	xr_free	(p);				}

	ret	8
?deallocate@?$xalloc@VCFrustum@@@@QBEXPAVCFrustum@@I@Z ENDP ; xalloc<CFrustum>::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$xalloc@VCFrustum@@@@V?$_Vector_val@U?$_Simple_types@VCFrustum@@@std@@@std@@$00@std@@QAEAAV?$xalloc@VCFrustum@@@@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@V?$xalloc@VCFrustum@@@@V?$_Vector_val@U?$_Simple_types@VCFrustum@@@std@@@std@@$00@std@@QAEAAV?$xalloc@VCFrustum@@@@XZ PROC ; std::_Compressed_pair<xalloc<CFrustum>,std::_Vector_val<std::_Simple_types<CFrustum> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 1339 :         return *this;

	mov	eax, ecx

; 1340 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$xalloc@VCFrustum@@@@V?$_Vector_val@U?$_Simple_types@VCFrustum@@@std@@@std@@$00@std@@QAEAAV?$xalloc@VCFrustum@@@@XZ ENDP ; std::_Compressed_pair<xalloc<CFrustum>,std::_Vector_val<std::_Simple_types<CFrustum> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Getal@?$vector@VCFrustum@@V?$xalloc@VCFrustum@@@@@std@@AAEAAV?$xalloc@VCFrustum@@@@XZ
_TEXT	SEGMENT
?_Getal@?$vector@VCFrustum@@V?$xalloc@VCFrustum@@@@@std@@AAEAAV?$xalloc@VCFrustum@@@@XZ PROC ; std::vector<CFrustum,xalloc<CFrustum> >::_Getal, COMDAT
; _this$ = ecx

; 1805 :         return _Mypair._Get_first();

	mov	eax, ecx

; 1806 :     }

	ret	0
?_Getal@?$vector@VCFrustum@@V?$xalloc@VCFrustum@@@@@std@@AAEAAV?$xalloc@VCFrustum@@@@XZ ENDP ; std::vector<CFrustum,xalloc<CFrustum> >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Tidy@?$vector@VCFrustum@@V?$xalloc@VCFrustum@@@@@std@@AAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@VCFrustum@@V?$xalloc@VCFrustum@@@@@std@@AAEXXZ PROC ; std::vector<CFrustum,xalloc<CFrustum> >::_Tidy, COMDAT
; _this$ = ecx

; 1742 :     _CONSTEXPR20_CONTAINER void _Tidy() noexcept { // free all storage

	push	esi
	mov	esi, ecx

; 1743 :         auto& _My_data    = _Mypair._Myval2;
; 1744 :         pointer& _Myfirst = _My_data._Myfirst;
; 1745 :         pointer& _Mylast  = _My_data._Mylast;
; 1746 :         pointer& _Myend   = _My_data._Myend;
; 1747 : 
; 1748 :         _My_data._Orphan_all();
; 1749 : 
; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN2@Tidy
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+4], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+8], 0
$LN2@Tidy:

; 1757 :         }
; 1758 :     }

	pop	esi
	ret	0
?_Tidy@?$vector@VCFrustum@@V?$xalloc@VCFrustum@@@@@std@@AAEXXZ ENDP ; std::vector<CFrustum,xalloc<CFrustum> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??1?$vector@VCFrustum@@V?$xalloc@VCFrustum@@@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@VCFrustum@@V?$xalloc@VCFrustum@@@@@std@@QAE@XZ PROC ; std::vector<CFrustum,xalloc<CFrustum> >::~vector<CFrustum,xalloc<CFrustum> >, COMDAT
; _this$ = ecx

; 698  :     _CONSTEXPR20_CONTAINER ~vector() noexcept {

	push	esi
	mov	esi, ecx

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN4@vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+4], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+8], 0
$LN4@vector:
	pop	esi

; 699  :         _Tidy();
; 700  : #if _ITERATOR_DEBUG_LEVEL != 0
; 701  :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 702  :         _Delete_plain_internal(_Alproxy, _STD exchange(_Mypair._Myval2._Myproxy, nullptr));
; 703  : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 704  :     }

	ret	0
??1?$vector@VCFrustum@@V?$xalloc@VCFrustum@@@@@std@@QAE@XZ ENDP ; std::vector<CFrustum,xalloc<CFrustum> >::~vector<CFrustum,xalloc<CFrustum> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??1?$xr_vector@VCFrustum@@V?$xalloc@VCFrustum@@@@@@QAE@XZ
_TEXT	SEGMENT
??1?$xr_vector@VCFrustum@@V?$xalloc@VCFrustum@@@@@@QAE@XZ PROC ; xr_vector<CFrustum,xalloc<CFrustum> >::~xr_vector<CFrustum,xalloc<CFrustum> >, COMDAT
; _this$ = ecx

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	push	esi
	mov	esi, ecx
	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN6@xr_vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+4], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+8], 0
$LN6@xr_vector:
	pop	esi
	ret	0
??1?$xr_vector@VCFrustum@@V?$xalloc@VCFrustum@@@@@@QAE@XZ ENDP ; xr_vector<CFrustum,xalloc<CFrustum> >::~xr_vector<CFrustum,xalloc<CFrustum> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Destroy_in_place@PAPAVCPortal@@@std@@YAXAAPAPAVCPortal@@@Z
_TEXT	SEGMENT
??$_Destroy_in_place@PAPAVCPortal@@@std@@YAXAAPAPAVCPortal@@@Z PROC ; std::_Destroy_in_place<CPortal * *>, COMDAT
; __Obj$dead$ = ecx

; 295  :     if constexpr (is_array_v<_Ty>) {
; 296  :         _Destroy_range(_Obj, _Obj + extent_v<_Ty>);
; 297  :     } else {
; 298  :         _Obj.~_Ty();
; 299  :     }
; 300  : }

	ret	0
??$_Destroy_in_place@PAPAVCPortal@@@std@@YAXAAPAPAVCPortal@@@Z ENDP ; std::_Destroy_in_place<CPortal * *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?destroy@?$xalloc@PAVCPortal@@@@QAEXPAPAVCPortal@@@Z
_TEXT	SEGMENT
_p$dead$ = 8						; size = 4
?destroy@?$xalloc@PAVCPortal@@@@QAEXPAPAVCPortal@@@Z PROC ; xalloc<CPortal *>::destroy, COMDAT
; _this$dead$ = ecx

; 85   : 							void					destroy			(pointer p)								{	std::_Destroy_in_place(p);			}

	ret	4
?destroy@?$xalloc@PAVCPortal@@@@QAEXPAPAVCPortal@@@Z ENDP ; xalloc<CPortal *>::destroy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$destroy@PAVCPortal@@@?$_Normal_allocator_traits@V?$xalloc@PAVCPortal@@@@@std@@SAXAAV?$xalloc@PAVCPortal@@@@PAPAVCPortal@@@Z
_TEXT	SEGMENT
??$destroy@PAVCPortal@@@?$_Normal_allocator_traits@V?$xalloc@PAVCPortal@@@@@std@@SAXAAV?$xalloc@PAVCPortal@@@@PAPAVCPortal@@@Z PROC ; std::_Normal_allocator_traits<xalloc<CPortal *> >::destroy<CPortal *>, COMDAT
; __Al$dead$ = ecx
; __Ptr$dead$ = edx

; 579  :         if constexpr (_Uses_default_destroy<_Alloc, _Ty*>::value) {
; 580  : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 581  :             _STD destroy_at(_Ptr);
; 582  : #else // __cpp_lib_constexpr_dynamic_alloc
; 583  :             _Ptr->~_Ty();
; 584  : #endif // __cpp_lib_constexpr_dynamic_alloc
; 585  :         } else {
; 586  :             _Al.destroy(_Ptr);
; 587  :         }
; 588  :     }

	ret	0
??$destroy@PAVCPortal@@@?$_Normal_allocator_traits@V?$xalloc@PAVCPortal@@@@@std@@SAXAAV?$xalloc@PAVCPortal@@@@PAPAVCPortal@@@Z ENDP ; std::_Normal_allocator_traits<xalloc<CPortal *> >::destroy<CPortal *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef
;	COMDAT ??$_Unfancy@PAVCPortal@@@std@@YAPAPAVCPortal@@PAPAV1@@Z
_TEXT	SEGMENT
??$_Unfancy@PAVCPortal@@@std@@YAPAPAVCPortal@@PAPAV1@@Z PROC ; std::_Unfancy<CPortal *>, COMDAT
; __Ptr$ = ecx

; 266  :     return _Ptr;

	mov	eax, ecx

; 267  : }

	ret	0
??$_Unfancy@PAVCPortal@@@std@@YAPAPAVCPortal@@PAPAV1@@Z ENDP ; std::_Unfancy<CPortal *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Destroy_range@V?$xalloc@PAVCPortal@@@@@std@@YAXPAPAVCPortal@@QAPAV1@AAV?$xalloc@PAVCPortal@@@@@Z
_TEXT	SEGMENT
__Al$dead$ = 8						; size = 4
??$_Destroy_range@V?$xalloc@PAVCPortal@@@@@std@@YAXPAPAVCPortal@@QAPAV1@AAV?$xalloc@PAVCPortal@@@@@Z PROC ; std::_Destroy_range<xalloc<CPortal *> >, COMDAT
; __First$dead$ = ecx
; __Last$dead$ = edx

; 901  :     // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
; 902  :     using _Ty = typename _Alloc::value_type;
; 903  :     if constexpr (!conjunction_v<is_trivially_destructible<_Ty>, _Uses_default_destroy<_Alloc, _Ty*>>) {
; 904  :         for (; _First != _Last; ++_First) {
; 905  :             allocator_traits<_Alloc>::destroy(_Al, _Unfancy(_First));
; 906  :         }
; 907  :     }
; 908  : }

	ret	0
??$_Destroy_range@V?$xalloc@PAVCPortal@@@@@std@@YAXPAPAVCPortal@@QAPAV1@AAV?$xalloc@PAVCPortal@@@@@Z ENDP ; std::_Destroy_range<xalloc<CPortal *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Destroy@?$vector@PAVCPortal@@V?$xalloc@PAVCPortal@@@@@std@@AAEXPAPAVCPortal@@0@Z
_TEXT	SEGMENT
__First$dead$ = 8					; size = 4
__Last$dead$ = 12					; size = 4
?_Destroy@?$vector@PAVCPortal@@V?$xalloc@PAVCPortal@@@@@std@@AAEXPAPAVCPortal@@0@Z PROC ; std::vector<CPortal *,xalloc<CPortal *> >::_Destroy, COMDAT
; _this$dead$ = ecx

; 1666 :         // destroy [_First, _Last) using allocator
; 1667 :         _Destroy_range(_First, _Last, _Getal());
; 1668 :     }

	ret	8
?_Destroy@?$vector@PAVCPortal@@V?$xalloc@PAVCPortal@@@@@std@@AAEXPAPAVCPortal@@0@Z ENDP ; std::vector<CPortal *,xalloc<CPortal *> >::_Destroy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
;	COMDAT ??$xr_free@PAVCPortal@@@@YAXAAPAPAVCPortal@@@Z
_TEXT	SEGMENT
??$xr_free@PAVCPortal@@@@YAXAAPAPAVCPortal@@@Z PROC	; xr_free<CPortal *>, COMDAT
; _P$ = ecx

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	push	esi
	mov	esi, ecx
	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN2@xr_free
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
	mov	DWORD PTR [esi], 0
$LN2@xr_free:
	pop	esi
	ret	0
??$xr_free@PAVCPortal@@@@YAXAAPAPAVCPortal@@@Z ENDP	; xr_free<CPortal *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?deallocate@?$xalloc@PAVCPortal@@@@QBEXPAPAVCPortal@@I@Z
_TEXT	SEGMENT
_p$ = 8							; size = 4
_n$dead$ = 12						; size = 4
?deallocate@?$xalloc@PAVCPortal@@@@QBEXPAPAVCPortal@@I@Z PROC ; xalloc<CPortal *>::deallocate, COMDAT
; _this$dead$ = ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	eax, DWORD PTR _p$[esp-4]
	test	eax, eax
	je	SHORT $LN4@deallocate
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN4@deallocate:
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 82   : 							void					deallocate		(pointer p, size_type n) const			{	xr_free	(p);				}

	ret	8
?deallocate@?$xalloc@PAVCPortal@@@@QBEXPAPAVCPortal@@I@Z ENDP ; xalloc<CPortal *>::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$xalloc@PAVCPortal@@@@V?$_Vector_val@U?$_Simple_types@PAVCPortal@@@std@@@std@@$00@std@@QAEAAV?$xalloc@PAVCPortal@@@@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@V?$xalloc@PAVCPortal@@@@V?$_Vector_val@U?$_Simple_types@PAVCPortal@@@std@@@std@@$00@std@@QAEAAV?$xalloc@PAVCPortal@@@@XZ PROC ; std::_Compressed_pair<xalloc<CPortal *>,std::_Vector_val<std::_Simple_types<CPortal *> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 1339 :         return *this;

	mov	eax, ecx

; 1340 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$xalloc@PAVCPortal@@@@V?$_Vector_val@U?$_Simple_types@PAVCPortal@@@std@@@std@@$00@std@@QAEAAV?$xalloc@PAVCPortal@@@@XZ ENDP ; std::_Compressed_pair<xalloc<CPortal *>,std::_Vector_val<std::_Simple_types<CPortal *> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Getal@?$vector@PAVCPortal@@V?$xalloc@PAVCPortal@@@@@std@@AAEAAV?$xalloc@PAVCPortal@@@@XZ
_TEXT	SEGMENT
?_Getal@?$vector@PAVCPortal@@V?$xalloc@PAVCPortal@@@@@std@@AAEAAV?$xalloc@PAVCPortal@@@@XZ PROC ; std::vector<CPortal *,xalloc<CPortal *> >::_Getal, COMDAT
; _this$ = ecx

; 1805 :         return _Mypair._Get_first();

	mov	eax, ecx

; 1806 :     }

	ret	0
?_Getal@?$vector@PAVCPortal@@V?$xalloc@PAVCPortal@@@@@std@@AAEAAV?$xalloc@PAVCPortal@@@@XZ ENDP ; std::vector<CPortal *,xalloc<CPortal *> >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Tidy@?$vector@PAVCPortal@@V?$xalloc@PAVCPortal@@@@@std@@AAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@PAVCPortal@@V?$xalloc@PAVCPortal@@@@@std@@AAEXXZ PROC ; std::vector<CPortal *,xalloc<CPortal *> >::_Tidy, COMDAT
; _this$ = ecx

; 1742 :     _CONSTEXPR20_CONTAINER void _Tidy() noexcept { // free all storage

	push	esi
	mov	esi, ecx

; 1743 :         auto& _My_data    = _Mypair._Myval2;
; 1744 :         pointer& _Myfirst = _My_data._Myfirst;
; 1745 :         pointer& _Mylast  = _My_data._Mylast;
; 1746 :         pointer& _Myend   = _My_data._Myend;
; 1747 : 
; 1748 :         _My_data._Orphan_all();
; 1749 : 
; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN2@Tidy
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+4], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+8], 0
$LN2@Tidy:

; 1757 :         }
; 1758 :     }

	pop	esi
	ret	0
?_Tidy@?$vector@PAVCPortal@@V?$xalloc@PAVCPortal@@@@@std@@AAEXXZ ENDP ; std::vector<CPortal *,xalloc<CPortal *> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??1?$vector@PAVCPortal@@V?$xalloc@PAVCPortal@@@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@PAVCPortal@@V?$xalloc@PAVCPortal@@@@@std@@QAE@XZ PROC ; std::vector<CPortal *,xalloc<CPortal *> >::~vector<CPortal *,xalloc<CPortal *> >, COMDAT
; _this$ = ecx

; 698  :     _CONSTEXPR20_CONTAINER ~vector() noexcept {

	push	esi
	mov	esi, ecx

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN4@vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+4], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+8], 0
$LN4@vector:
	pop	esi

; 699  :         _Tidy();
; 700  : #if _ITERATOR_DEBUG_LEVEL != 0
; 701  :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 702  :         _Delete_plain_internal(_Alproxy, _STD exchange(_Mypair._Myval2._Myproxy, nullptr));
; 703  : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 704  :     }

	ret	0
??1?$vector@PAVCPortal@@V?$xalloc@PAVCPortal@@@@@std@@QAE@XZ ENDP ; std::vector<CPortal *,xalloc<CPortal *> >::~vector<CPortal *,xalloc<CPortal *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??1?$xr_vector@PAVCPortal@@V?$xalloc@PAVCPortal@@@@@@QAE@XZ
_TEXT	SEGMENT
??1?$xr_vector@PAVCPortal@@V?$xalloc@PAVCPortal@@@@@@QAE@XZ PROC ; xr_vector<CPortal *,xalloc<CPortal *> >::~xr_vector<CPortal *,xalloc<CPortal *> >, COMDAT
; _this$ = ecx

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	push	esi
	mov	esi, ecx
	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN6@xr_vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+4], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+8], 0
$LN6@xr_vector:
	pop	esi
	ret	0
??1?$xr_vector@PAVCPortal@@V?$xalloc@PAVCPortal@@@@@@QAE@XZ ENDP ; xr_vector<CPortal *,xalloc<CPortal *> >::~xr_vector<CPortal *,xalloc<CPortal *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__sector.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__sector.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrEngine\render.h
;	COMDAT ??_GCSector@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCSector@@UAEPAXI@Z PROC				; CSector::`scalar deleting destructor', COMDAT
; _this$ = ecx
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__sector.cpp

; 106  : {

	push	esi
	mov	esi, ecx
	push	edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	edi, DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__sector.cpp

; 106  : {

	mov	DWORD PTR [esi], OFFSET ??_7CSector@@6B@
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [esi+32]
	test	eax, eax
	je	SHORT $LN11@scalar
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi+32], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+36], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+40], 0
$LN11@scalar:

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [esi+20]
	test	eax, eax
	je	SHORT $LN23@scalar
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi+20], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+24], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+28], 0
$LN23@scalar:

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [esi+8]
	test	eax, eax
	je	SHORT $LN35@scalar
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi+8], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+12], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+16], 0
$LN35@scalar:
	test	BYTE PTR ___flags$[esp+4], 1
; File I:\Vitalya\mine\NSProjectX\xrEngine\render.h

; 106  : 	virtual ~IRender_Sector() {};

	mov	eax, DWORD PTR __imp_??_7IRender_Sector@@6B@
	mov	DWORD PTR [esi], eax
	je	SHORT $LN44@scalar
	push	68					; 00000044H
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN44@scalar:
	pop	edi
	mov	eax, esi
	pop	esi
	ret	4
??_GCSector@@UAEPAXI@Z ENDP				; CSector::`scalar deleting destructor'
_TEXT	ENDS
END
