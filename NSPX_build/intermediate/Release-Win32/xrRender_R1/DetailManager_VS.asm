; Listing generated by Microsoft (R) Optimizing Compiler Version 19.29.30146.0 

	TITLE	i:\vitalya\mine\nsprojectx\nspx_build\intermediate\release-win32\xrrender_r1\detailmanager_vs.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	??_C@_0CI@EMGBNKCM@?$CK?5?$FLDETAILS?$FN?5VertexConsts?$CI?$CFd?$CJ?0?5B@ ; `string'
PUBLIC	??_C@_0BL@GGFJBNPE@?$CK?5?$FLDETAILS?$FN?5?$CFd?5v?$CI?$CFd?$CJ?0?5?$CFd?5p@ ; `string'
PUBLIC	??_C@_0BI@LGPMLEDD@CDetailManager?3?3hw_Load@	; `string'
PUBLIC	??_C@_0EA@DCNLPIGP@I?3?2Vitalya?2mine?2NSProjectX?2laye@ ; `string'
PUBLIC	??_C@_0FB@FADLPKOG@HW?4pDevice?9?$DOCreateVertexBuffer?$CI@ ; `string'
PUBLIC	??_C@_0FL@CHIPGLIE@HW?4pDevice?9?$DOCreateIndexBuffer?$CId@ ; `string'
PUBLIC	??_C@_0CI@ODFBHGNM@?$CK?5?$FLDETAILS?$FN?5Batch?$CI?$CFd?$CJ?0?5VB?$CI?$CFdK?$CJ?0@ ; `string'
PUBLIC	??_C@_0BP@HAPAOFJ@hw_VB?9?$DOLock?$CI0?00?0?$CIvoid?$CK?$CK?$CJ?$CGpV?00?$CJ@ ; `string'
PUBLIC	??_C@_0BA@PDGMGFKF@hw_VB?9?$DOUnlock?$CI?$CJ@	; `string'
PUBLIC	??_C@_0CB@OEKFILAI@hw_IB?9?$DOLock?$CI0?00?0?$CIvoid?$CK?$CK?$CJ?$CI?$CGpI?$CJ?00@ ; `string'
PUBLIC	??_C@_0BA@GABLBGEK@hw_IB?9?$DOUnlock?$CI?$CJ@	; `string'
PUBLIC	??_C@_0M@LFGFJOHH@details?2set@			; `string'
PUBLIC	??_C@_06CJANOHJB@consts@			; `string'
PUBLIC	??_C@_04LJEDCPFL@wave@				; `string'
PUBLIC	??_C@_05DLLGNFME@dir2D@				; `string'
PUBLIC	??_C@_05HIFJDKLD@array@				; `string'
PUBLIC	??_C@_05FLFNBNJM@xform@				; `string'
EXTRN	__imp_?get_ConstantCache_Vertex@CBackend@@QAEAAVR_constant_array@@XZ:PROC
EXTRN	__imp_?set_Element@CBackend@@QAEXAAV?$resptr_core@UShaderElement@@V?$resptr_base@UShaderElement@@@@@@I@Z:PROC
EXTRN	__imp_?set@R_constants@@QAEXPAUR_constant@@ABU?$_matrix@M@@@Z:PROC
EXTRN	__imp_?set_c@CBackend@@QAEXPAUR_constant@@ABU?$_matrix@M@@@Z:PROC
EXTRN	__imp_?set_c@CBackend@@QAEXPAUR_constant@@ABU?$_vector4@M@@@Z:PROC
EXTRN	__imp_?set@R_constants@@QAEXPAUR_constant@@ABU?$_vector4@M@@@Z:PROC
EXTRN	__imp_?set@R_constants@@QAEXPAUR_constant@@MMMM@Z:PROC
EXTRN	__imp_?set_c@CBackend@@QAEXPAUR_constant@@MMMM@Z:PROC
EXTRN	__imp_?create@resptrcode_geom@@QAEXPAU_D3DVERTEXELEMENT9@@PAUIDirect3DVertexBuffer9@@PAUIDirect3DIndexBuffer9@@@Z:PROC
EXTRN	__imp_?get@R_constant_table@@QAE?AV?$resptr_core@UR_constant@@V?$resptr_base@UR_constant@@@@@@PBD@Z:PROC
EXTRN	__imp_?create@resptrcode_shader@@QAEXPBD000@Z:PROC
EXTRN	__imp_?_dec@?$resptr_base@UShader@@@@IAEXXZ:PROC
EXTRN	__imp_?error@xrDebug@@QAEXJPBD0H0AA_N@Z:PROC
EXTRN	__imp_?Msg@@YAXPBDZZ:PROC
;	COMDAT ?ignore_always@?CH@??hw_Load@CDetailManager@@QAEXXZ@4_NA
_BSS	SEGMENT
?ignore_always@?CH@??hw_Load@CDetailManager@@QAEXXZ@4_NA DB 01H DUP (?) ; `CDetailManager::hw_Load'::`39'::ignore_always
_BSS	ENDS
;	COMDAT ?ignore_always@?BO@??hw_Load@CDetailManager@@QAEXXZ@4_NA
_BSS	SEGMENT
?ignore_always@?BO@??hw_Load@CDetailManager@@QAEXXZ@4_NA DB 01H DUP (?) ; `CDetailManager::hw_Load'::`30'::ignore_always
_BSS	ENDS
;	COMDAT ?ignore_always@?BJ@??hw_Load@CDetailManager@@QAEXXZ@4_NA
_BSS	SEGMENT
?ignore_always@?BJ@??hw_Load@CDetailManager@@QAEXXZ@4_NA DB 01H DUP (?) ; `CDetailManager::hw_Load'::`25'::ignore_always
_BSS	ENDS
;	COMDAT ?ignore_always@?P@??hw_Load@CDetailManager@@QAEXXZ@4_NA
_BSS	SEGMENT
?ignore_always@?P@??hw_Load@CDetailManager@@QAEXXZ@4_NA DB 01H DUP (?) ; `CDetailManager::hw_Load'::`15'::ignore_always
_BSS	ENDS
;	COMDAT ?ignore_always@?9??hw_Load@CDetailManager@@QAEXXZ@4_NA
_BSS	SEGMENT
?ignore_always@?9??hw_Load@CDetailManager@@QAEXXZ@4_NA DB 01H DUP (?) ; `CDetailManager::hw_Load'::`10'::ignore_always
_BSS	ENDS
;	COMDAT ?ignore_always@?5??hw_Load@CDetailManager@@QAEXXZ@4_NA
_BSS	SEGMENT
?ignore_always@?5??hw_Load@CDetailManager@@QAEXXZ@4_NA DB 01H DUP (?) ; `CDetailManager::hw_Load'::`6'::ignore_always
_BSS	ENDS
;	COMDAT ??_C@_05FLFNBNJM@xform@
CONST	SEGMENT
??_C@_05FLFNBNJM@xform@ DB 'xform', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05HIFJDKLD@array@
CONST	SEGMENT
??_C@_05HIFJDKLD@array@ DB 'array', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05DLLGNFME@dir2D@
CONST	SEGMENT
??_C@_05DLLGNFME@dir2D@ DB 'dir2D', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04LJEDCPFL@wave@
CONST	SEGMENT
??_C@_04LJEDCPFL@wave@ DB 'wave', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_06CJANOHJB@consts@
CONST	SEGMENT
??_C@_06CJANOHJB@consts@ DB 'consts', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@LFGFJOHH@details?2set@
CONST	SEGMENT
??_C@_0M@LFGFJOHH@details?2set@ DB 'details\set', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@GABLBGEK@hw_IB?9?$DOUnlock?$CI?$CJ@
CONST	SEGMENT
??_C@_0BA@GABLBGEK@hw_IB?9?$DOUnlock?$CI?$CJ@ DB 'hw_IB->Unlock()', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@OEKFILAI@hw_IB?9?$DOLock?$CI0?00?0?$CIvoid?$CK?$CK?$CJ?$CI?$CGpI?$CJ?00@
CONST	SEGMENT
??_C@_0CB@OEKFILAI@hw_IB?9?$DOLock?$CI0?00?0?$CIvoid?$CK?$CK?$CJ?$CI?$CGpI?$CJ?00@ DB 'h'
	DB	'w_IB->Lock(0,0,(void**)(&pI),0)', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@PDGMGFKF@hw_VB?9?$DOUnlock?$CI?$CJ@
CONST	SEGMENT
??_C@_0BA@PDGMGFKF@hw_VB?9?$DOUnlock?$CI?$CJ@ DB 'hw_VB->Unlock()', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@HAPAOFJ@hw_VB?9?$DOLock?$CI0?00?0?$CIvoid?$CK?$CK?$CJ?$CGpV?00?$CJ@
CONST	SEGMENT
??_C@_0BP@HAPAOFJ@hw_VB?9?$DOLock?$CI0?00?0?$CIvoid?$CK?$CK?$CJ?$CGpV?00?$CJ@ DB 'h'
	DB	'w_VB->Lock(0,0,(void**)&pV,0)', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@ODFBHGNM@?$CK?5?$FLDETAILS?$FN?5Batch?$CI?$CFd?$CJ?0?5VB?$CI?$CFdK?$CJ?0@
CONST	SEGMENT
??_C@_0CI@ODFBHGNM@?$CK?5?$FLDETAILS?$FN?5Batch?$CI?$CFd?$CJ?0?5VB?$CI?$CFdK?$CJ?0@ DB '*'
	DB	' [DETAILS] Batch(%d), VB(%dK), IB(%dK)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0FL@CHIPGLIE@HW?4pDevice?9?$DOCreateIndexBuffer?$CId@
CONST	SEGMENT
??_C@_0FL@CHIPGLIE@HW?4pDevice?9?$DOCreateIndexBuffer?$CId@ DB 'HW.pDevic'
	DB	'e->CreateIndexBuffer(dwIndices*2,dwUsage,D3DFMT_INDEX16,D3DPO'
	DB	'OL_MANAGED,&hw_IB,0)', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0FB@FADLPKOG@HW?4pDevice?9?$DOCreateVertexBuffer?$CI@
CONST	SEGMENT
??_C@_0FB@FADLPKOG@HW?4pDevice?9?$DOCreateVertexBuffer?$CI@ DB 'HW.pDevic'
	DB	'e->CreateVertexBuffer(dwVerts*vSize,dwUsage,0,D3DPOOL_MANAGED'
	DB	',&hw_VB,0)', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0EA@DCNLPIGP@I?3?2Vitalya?2mine?2NSProjectX?2laye@
CONST	SEGMENT
??_C@_0EA@DCNLPIGP@I?3?2Vitalya?2mine?2NSProjectX?2laye@ DB 'I:\Vitalya\m'
	DB	'ine\NSProjectX\layers\xrRender\DetailManager_VS.cpp', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@LGPMLEDD@CDetailManager?3?3hw_Load@
CONST	SEGMENT
??_C@_0BI@LGPMLEDD@CDetailManager?3?3hw_Load@ DB 'CDetailManager::hw_Load'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@GGFJBNPE@?$CK?5?$FLDETAILS?$FN?5?$CFd?5v?$CI?$CFd?$CJ?0?5?$CFd?5p@
CONST	SEGMENT
??_C@_0BL@GGFJBNPE@?$CK?5?$FLDETAILS?$FN?5?$CFd?5v?$CI?$CFd?$CJ?0?5?$CFd?5p@ DB '*'
	DB	' [DETAILS] %d v(%d), %d p', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@EMGBNKCM@?$CK?5?$FLDETAILS?$FN?5VertexConsts?$CI?$CFd?$CJ?0?5B@
CONST	SEGMENT
??_C@_0CI@EMGBNKCM@?$CK?5?$FLDETAILS?$FN?5VertexConsts?$CI?$CFd?$CJ?0?5B@ DB '*'
	DB	' [DETAILS] VertexConsts(%d), Batch(%d)', 00H ; `string'
PUBLIC	??0?$resptr_core@UShader@@Uresptrcode_shader@@@@QAE@XZ ; resptr_core<Shader,resptrcode_shader>::resptr_core<Shader,resptrcode_shader>
PUBLIC	??1?$resptr_core@UShader@@Uresptrcode_shader@@@@QAE@XZ ; resptr_core<Shader,resptrcode_shader>::~resptr_core<Shader,resptrcode_shader>
PUBLIC	??D?$resptr_core@VR_constant_table@@V?$resptr_base@VR_constant_table@@@@@@QBEAAVR_constant_table@@XZ ; resptr_core<R_constant_table,resptr_base<R_constant_table> >::operator*
PUBLIC	??A?$svector@V?$resptr_core@USPass@@V?$resptr_base@USPass@@@@@@$01@@QAEAAV?$resptr_core@USPass@@V?$resptr_base@USPass@@@@@@I@Z ; svector<resptr_core<SPass,resptr_base<SPass> >,2>::operator[]
PUBLIC	?set@?$_vector4@M@@QAEAAU1@MMMM@Z		; _vector4<float>::set
PUBLIC	?set@R_constant_array@@QAEXPAUR_constant@@AAUR_constant_load@@ABU?$_vector4@M@@@Z ; R_constant_array::set
PUBLIC	?dirty@?$R_constant_cache@U?$_vector4@M@@$0BAA@@@QAEXII@Z ; R_constant_cache<_vector4<float>,256>::dirty
PUBLIC	?access@?$R_constant_cache@U?$_vector4@M@@$0BAA@@@QAEPAU?$_vector4@M@@I@Z ; R_constant_cache<_vector4<float>,256>::access
PUBLIC	??A?$svector@U?$_vector4@M@@$0BAA@@@QAEAAU?$_vector4@M@@I@Z ; svector<_vector4<float>,256>::operator[]
PUBLIC	?set@?$_vector4@M@@QAEAAU1@ABU1@@Z		; _vector4<float>::set
PUBLIC	??D?$resptr_core@UR_constant@@V?$resptr_base@UR_constant@@@@@@QBEAAUR_constant@@XZ ; resptr_core<R_constant,resptr_base<R_constant> >::operator*
PUBLIC	??0?$resptr_core@UR_constant@@V?$resptr_base@UR_constant@@@@@@QAE@PAUR_constant@@_N@Z ; resptr_core<R_constant,resptr_base<R_constant> >::resptr_core<R_constant,resptr_base<R_constant> >
PUBLIC	?_inc@?$resptr_base@UR_constant@@@@IAEXXZ	; resptr_base<R_constant>::_inc
PUBLIC	?set@R_constant_array@@QAEXPAUR_constant@@AAUR_constant_load@@ABU?$_matrix@M@@@Z ; R_constant_array::set
PUBLIC	?apply_lmaterial@CRender@@QAEXXZ		; CRender::apply_lmaterial
PUBLIC	?get_array_f@R_constant_array@@QAEAAV?$R_constant_cache@U?$_vector4@M@@$0BAA@@@XZ ; R_constant_array::get_array_f
PUBLIC	?add@R_statistics_element@@QAEXI@Z		; R_statistics_element::add
PUBLIC	?magnitude_sqr@?$_vector4@M@@QAEMXZ		; _vector4<float>::magnitude_sqr
PUBLIC	?_set@?$resptr_base@UR_constant@@@@QAEXPAUR_constant@@@Z ; resptr_base<R_constant>::_set
PUBLIC	?_get@?$resptr_base@UR_constant@@@@QBEPAUR_constant@@XZ ; resptr_base<R_constant>::_get
PUBLIC	?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUSlotItem@CDetailManager@@@std@@@std@@@std@@QBEXABV12@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CDetailManager::SlotItem *> > >::_Compat
PUBLIC	?magnitude@?$_vector4@M@@QAEMXZ			; _vector4<float>::magnitude
PUBLIC	?_set@?$resptr_base@UR_constant@@@@QAEXABV1@@Z	; resptr_base<R_constant>::_set
PUBLIC	??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUSlotItem@CDetailManager@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CDetailManager::SlotItem *> > >::operator++
PUBLIC	??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUSlotItem@CDetailManager@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CDetailManager::SlotItem *> > >::operator==
PUBLIC	?mad@?$_vector3@M@@QAEAAU1@ABU1@M@Z		; _vector3<float>::mad
PUBLIC	?mul@?$_vector4@M@@QAEAAU1@M@Z			; _vector4<float>::mul
PUBLIC	?div@?$_vector4@M@@QAEAAU1@M@Z			; _vector4<float>::div
PUBLIC	?normalize@?$_vector4@M@@QAEAAU1@XZ		; _vector4<float>::normalize
PUBLIC	??C?$resptr_core@USPass@@V?$resptr_base@USPass@@@@@@QBEPAUSPass@@XZ ; resptr_core<SPass,resptr_base<SPass> >::operator->
PUBLIC	??C?$resptr_core@UShaderElement@@V?$resptr_base@UShaderElement@@@@@@QBEPAUShaderElement@@XZ ; resptr_core<ShaderElement,resptr_base<ShaderElement> >::operator->
PUBLIC	??C?$resptr_core@UShader@@Uresptrcode_shader@@@@QBEPAUShader@@XZ ; resptr_core<Shader,resptrcode_shader>::operator->
PUBLIC	??4?$resptr_core@UR_constant@@V?$resptr_base@UR_constant@@@@@@QAEAAV0@ABV0@@Z ; resptr_core<R_constant,resptr_base<R_constant> >::operator=
PUBLIC	??C?$resptr_core@UR_constant@@V?$resptr_base@UR_constant@@@@@@QBEPAUR_constant@@XZ ; resptr_core<R_constant,resptr_base<R_constant> >::operator->
PUBLIC	?empty@?$vector@PAV?$xr_vector@PAUSlotItem@CDetailManager@@V?$xalloc@PAUSlotItem@CDetailManager@@@@@@V?$xalloc@PAV?$xr_vector@PAUSlotItem@CDetailManager@@V?$xalloc@PAUSlotItem@CDetailManager@@@@@@@@@std@@QBE_NXZ ; std::vector<xr_vector<CDetailManager::SlotItem *,xalloc<CDetailManager::SlotItem *> > *,xalloc<xr_vector<CDetailManager::SlotItem *,xalloc<CDetailManager::SlotItem *> > *> >::empty
PUBLIC	??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUSlotItem@CDetailManager@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CDetailManager::SlotItem *> > >::operator!=
PUBLIC	??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUSlotItem@CDetailManager@@@std@@@std@@@std@@QAE?AV01@H@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CDetailManager::SlotItem *> > >::operator++
PUBLIC	?hw_Render_dump@CDetailManager@@QAEXV?$resptr_core@UR_constant@@V?$resptr_base@UR_constant@@@@@@III@Z ; CDetailManager::hw_Render_dump
PUBLIC	?QC@@YAFM@Z					; QC
PUBLIC	?hw_Load@CDetailManager@@QAEXXZ			; CDetailManager::hw_Load
PUBLIC	?hw_Unload@CDetailManager@@QAEXXZ		; CDetailManager::hw_Unload
PUBLIC	?hw_Render@CDetailManager@@QAEXXZ		; CDetailManager::hw_Render
?dwDecl@@3PAU_D3DVERTEXELEMENT9@@A DW 00H		; dwDecl
	DW	00H
	DB	02H
	DB	00H
	DB	00H
	DB	00H
	DW	00H
	DW	0cH
	DB	07H
	DB	00H
	DB	05H
	DB	00H
	DW	0ffH
	DW	00H
	DB	011H
	DB	00H
	DB	00H
	DB	00H
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_VS.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector4.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_VS.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector4.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_VS.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector4.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_VS.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_VS.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector4.h
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector4.h
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector4.h
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector4.h
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector4.h
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_VS.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector4.h
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector4.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_VS.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector4.h
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector4.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_VS.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector4.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_VS.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector4.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File I:\Vitalya\mine\NSProjectX\xrEngine\R_Backend_Runtime.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_VS.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector4.h
; File I:\Vitalya\mine\NSProjectX\xrEngine\R_Backend.h
; File I:\Vitalya\mine\NSProjectX\xrEngine\r_constants_cache.h
; File I:\Vitalya\mine\NSProjectX\xrEngine\R_Backend.h
; File I:\Vitalya\mine\NSProjectX\xrEngine\r_constants_cache.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector4.h
; File I:\Vitalya\mine\NSProjectX\xrEngine\r_constants_cache.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector4.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_VS.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector4.h
; File I:\Vitalya\mine\NSProjectX\xrEngine\R_Backend.h
; File I:\Vitalya\mine\NSProjectX\xrEngine\r_constants_cache.h
; File I:\Vitalya\mine\NSProjectX\xrEngine\R_Backend.h
; File I:\Vitalya\mine\NSProjectX\xrEngine\r_constants_cache.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_VS.cpp
; File I:\Vitalya\mine\NSProjectX\xrEngine\R_Backend.h
; File I:\Vitalya\mine\NSProjectX\xrEngine\r_constants_cache.h
; File I:\Vitalya\mine\NSProjectX\xrEngine\R_Backend.h
; File I:\Vitalya\mine\NSProjectX\xrEngine\r_constants_cache.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_VS.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_VS.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector4.h
; File I:\Vitalya\mine\NSProjectX\xrEngine\R_Backend.h
; File I:\Vitalya\mine\NSProjectX\xrEngine\r_constants_cache.h
; File I:\Vitalya\mine\NSProjectX\xrEngine\R_Backend.h
; File I:\Vitalya\mine\NSProjectX\xrEngine\r_constants_cache.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_VS.cpp
; File I:\Vitalya\mine\NSProjectX\xrEngine\R_Backend.h
; File I:\Vitalya\mine\NSProjectX\xrEngine\r_constants_cache.h
; File I:\Vitalya\mine\NSProjectX\xrEngine\R_Backend.h
; File I:\Vitalya\mine\NSProjectX\xrEngine\r_constants_cache.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_VS.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_VS.cpp
; File I:\Vitalya\mine\NSProjectX\xrEngine\R_Backend.h
; File I:\Vitalya\mine\NSProjectX\xrEngine\r_constants_cache.h
; File I:\Vitalya\mine\NSProjectX\xrEngine\R_Backend.h
; File I:\Vitalya\mine\NSProjectX\xrEngine\r_constants_cache.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector4.h
; File I:\Vitalya\mine\NSProjectX\xrEngine\r_constants_cache.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_VS.cpp
; File I:\Vitalya\mine\NSProjectX\xrEngine\R_Backend.h
; File I:\Vitalya\mine\NSProjectX\xrEngine\r_constants_cache.h
; File I:\Vitalya\mine\NSProjectX\xrEngine\R_Backend.h
; File I:\Vitalya\mine\NSProjectX\xrEngine\r_constants_cache.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_VS.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_VS.cpp
_TEXT	SEGMENT
tv879 = -80						; size = 4
_tm_rot1$ = -80						; size = 4
tv898 = -76						; size = 4
tv878 = -76						; size = 4
tv899 = -72						; size = 4
_tm_rot2$ = -72						; size = 4
_wave$ = -68						; size = 16
_data$1 = -52						; size = 16
_data$2 = -52						; size = 16
_dir1$ = -36						; size = 16
_dir2$ = -20						; size = 16
?hw_Render@CDetailManager@@QAEXXZ PROC			; CDetailManager::hw_Render
; _this$ = ecx

; 136  : {

	sub	esp, 84					; 00000054H

; 139  : 	float		tm_rot1		= (PI_MUL_2*Device.fTimeGlobal/swing_current.rot1);

	mov	eax, DWORD PTR __imp_?Device@@3VCRenderDevice@@A
	push	ebx
	push	ebp
	push	esi
	movss	xmm1, DWORD PTR [eax+472]
	mov	esi, ecx
	mulss	xmm1, DWORD PTR __real@40c90fdb
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector4.h

; 33   : 	IC  SelfRef		mul(T s)							{ x*=s;		y*=s;		z*=s;		w*=s;		return *this; }

	mov	DWORD PTR _dir1$[esp+100], 0

; 46   : 	IC	SelfRef		normalize()							{ return mul(1/magnitude());		}

	movss	xmm5, DWORD PTR __real@3f800000
	movaps	xmm2, xmm5
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 70   : 	T &					operator*() const												{	return *p_;	}

	mov	ebp, DWORD PTR [esi+701228]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_VS.cpp

; 139  : 	float		tm_rot1		= (PI_MUL_2*Device.fTimeGlobal/swing_current.rot1);

	movaps	xmm0, xmm1
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector4.h

; 33   : 	IC  SelfRef		mul(T s)							{ x*=s;		y*=s;		z*=s;		w*=s;		return *this; }

	mov	DWORD PTR _dir1$[esp+108], 0
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_VS.cpp

; 139  : 	float		tm_rot1		= (PI_MUL_2*Device.fTimeGlobal/swing_current.rot1);

	divss	xmm0, DWORD PTR [esi+1068]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector4.h

; 33   : 	IC  SelfRef		mul(T s)							{ x*=s;		y*=s;		z*=s;		w*=s;		return *this; }

	mov	DWORD PTR _dir2$[esp+100], 0
	mov	DWORD PTR _dir2$[esp+108], 0
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_VS.cpp

; 136  : {

	push	edi

; 143  : 
; 144  : 	// Setup geometry and DMA
; 145  : 	RCache.set_Geometry		(hw_Geom);

	mov	edi, DWORD PTR __imp_?RCache@@3VCBackend@@A
	divss	xmm1, DWORD PTR [esi+1072]
	movss	DWORD PTR _tm_rot1$[esp+100], xmm0
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h

; 653  :             return (float)cos(_X);

	fld	DWORD PTR _tm_rot1$[esp+100]
	fld	ST(0)
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_VS.cpp

; 140  : 	float		tm_rot2		= (PI_MUL_2*Device.fTimeGlobal/swing_current.rot2);

	movss	DWORD PTR _tm_rot2$[esp+100], xmm1
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h

; 653  :             return (float)cos(_X);

	fcos
	fstp	DWORD PTR tv878[esp+100]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector4.h

; 44   : 	IC	T			magnitude_sqr ()					{ return x*x + y*y + z*z + w*w;		}

	movss	xmm4, DWORD PTR tv878[esp+100]
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h

; 754  :             return (float)sin(_X);

	fsin
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector4.h

; 44   : 	IC	T			magnitude_sqr ()					{ return x*x + y*y + z*z + w*w;		}

	movaps	xmm0, xmm4
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h

; 754  :             return (float)sin(_X);

	fstp	DWORD PTR tv879[esp+100]

; 653  :             return (float)cos(_X);

	fld	DWORD PTR _tm_rot2$[esp+100]
	fld	ST(0)
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector4.h

; 17   : 	IC	SelfRef 	set(T _x, T _y, T _z, T _w=1)		{ x=_x;		y=_y;		z=_z;		w=_w;		return *this; }

	movss	xmm3, DWORD PTR tv879[esp+100]
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h

; 653  :             return (float)cos(_X);

	fcos
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector4.h

; 17   : 	IC	SelfRef 	set(T _x, T _y, T _z, T _w=1)		{ x=_x;		y=_y;		z=_z;		w=_w;		return *this; }

	movaps	xmm1, xmm3

; 44   : 	IC	T			magnitude_sqr ()					{ return x*x + y*y + z*z + w*w;		}

	mulss	xmm0, xmm4

; 17   : 	IC	SelfRef 	set(T _x, T _y, T _z, T _w=1)		{ x=_x;		y=_y;		z=_z;		w=_w;		return *this; }

	mulss	xmm1, xmm3
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h

; 653  :             return (float)cos(_X);

	fstp	DWORD PTR tv898[esp+100]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector4.h

; 44   : 	IC	T			magnitude_sqr ()					{ return x*x + y*y + z*z + w*w;		}

	addss	xmm1, xmm0
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h

; 754  :             return (float)sin(_X);

	fsin

; 764  :             return (float)sqrt(_X);

	sqrtss	xmm0, xmm1
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_VS.cpp

; 141  : 	dir1.set				(_sin(tm_rot1),0,_cos(tm_rot1),0).normalize().mul(swing_current.amp1);

	movss	xmm1, DWORD PTR [esi+1076]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector4.h

; 46   : 	IC	SelfRef		normalize()							{ return mul(1/magnitude());		}

	divss	xmm2, xmm0
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h

; 754  :             return (float)sin(_X);

	fstp	DWORD PTR tv899[esp+100]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector4.h

; 46   : 	IC	SelfRef		normalize()							{ return mul(1/magnitude());		}

	mulss	xmm3, xmm2

; 33   : 	IC  SelfRef		mul(T s)							{ x*=s;		y*=s;		z*=s;		w*=s;		return *this; }

	mulss	xmm4, xmm2

; 17   : 	IC	SelfRef 	set(T _x, T _y, T _z, T _w=1)		{ x=_x;		y=_y;		z=_z;		w=_w;		return *this; }

	movss	xmm2, DWORD PTR tv899[esp+100]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_VS.cpp

; 141  : 	dir1.set				(_sin(tm_rot1),0,_cos(tm_rot1),0).normalize().mul(swing_current.amp1);

	mulss	xmm3, xmm1
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector4.h

; 33   : 	IC  SelfRef		mul(T s)							{ x*=s;		y*=s;		z*=s;		w*=s;		return *this; }

	mulss	xmm4, xmm1

; 17   : 	IC	SelfRef 	set(T _x, T _y, T _z, T _w=1)		{ x=_x;		y=_y;		z=_z;		w=_w;		return *this; }

	movaps	xmm1, xmm2

; 33   : 	IC  SelfRef		mul(T s)							{ x*=s;		y*=s;		z*=s;		w*=s;		return *this; }

	movss	DWORD PTR _dir1$[esp+100], xmm3

; 44   : 	IC	T			magnitude_sqr ()					{ return x*x + y*y + z*z + w*w;		}

	movss	xmm3, DWORD PTR tv898[esp+100]
	movaps	xmm0, xmm3

; 17   : 	IC	SelfRef 	set(T _x, T _y, T _z, T _w=1)		{ x=_x;		y=_y;		z=_z;		w=_w;		return *this; }

	mulss	xmm1, xmm2

; 44   : 	IC	T			magnitude_sqr ()					{ return x*x + y*y + z*z + w*w;		}

	mulss	xmm0, xmm3

; 33   : 	IC  SelfRef		mul(T s)							{ x*=s;		y*=s;		z*=s;		w*=s;		return *this; }

	movss	DWORD PTR _dir1$[esp+108], xmm4

; 44   : 	IC	T			magnitude_sqr ()					{ return x*x + y*y + z*z + w*w;		}

	addss	xmm1, xmm0
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h

; 764  :             return (float)sqrt(_X);

	sqrtss	xmm0, xmm1
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector4.h

; 46   : 	IC	SelfRef		normalize()							{ return mul(1/magnitude());		}

	divss	xmm5, xmm0
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_VS.cpp

; 142  : 	dir2.set				(_sin(tm_rot2),0,_cos(tm_rot2),0).normalize().mul(swing_current.amp2);

	movss	xmm0, DWORD PTR [esi+1080]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector4.h

; 46   : 	IC	SelfRef		normalize()							{ return mul(1/magnitude());		}

	mulss	xmm2, xmm5

; 33   : 	IC  SelfRef		mul(T s)							{ x*=s;		y*=s;		z*=s;		w*=s;		return *this; }

	mulss	xmm3, xmm5
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_VS.cpp

; 142  : 	dir2.set				(_sin(tm_rot2),0,_cos(tm_rot2),0).normalize().mul(swing_current.amp2);

	mulss	xmm2, xmm0
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector4.h

; 33   : 	IC  SelfRef		mul(T s)							{ x*=s;		y*=s;		z*=s;		w*=s;		return *this; }

	mulss	xmm3, xmm0
	movss	DWORD PTR _dir2$[esp+100], xmm2
	movss	DWORD PTR _dir2$[esp+108], xmm3
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 48   : 	ICF		T *			_get	() const							{	return p_;																					}

	mov	eax, DWORD PTR [ebp+8]
; File I:\Vitalya\mine\NSProjectX\xrEngine\R_Backend_Runtime.h

; 224  : 	set_Format(_geom->dcl._get()->dcl);

	mov	edx, DWORD PTR [eax+8]

; 131  : 	if (decl != _decl)

	cmp	DWORD PTR [edi+592], edx
	je	SHORT $LN60@hw_Render

; 132  : 	{
; 133  : 		PGO(Msg("PGO:v_format:%x", _decl));
; 134  : #ifdef DEBUG
; 135  : 		stat.decl++;
; 136  : #endif
; 137  : 		decl = _decl;

	mov	DWORD PTR [edi+592], edx

; 138  : 		CHK_DX(HW.pDevice->SetVertexDeclaration(decl));

	mov	eax, DWORD PTR __imp_?HW@@3VCHW@@A
	push	edx
	mov	eax, DWORD PTR [eax+8]
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+348]
$LN60@hw_Render:

; 225  : 	set_Vertices(_geom->vb, _geom->vb_stride);

	mov	ebx, DWORD PTR [ebp+12]
	mov	edx, DWORD PTR [ebp+20]

; 172  : 	if ((vb != _vb) || (vb_stride != _vb_stride))

	cmp	DWORD PTR [edi+596], ebx
	jne	SHORT $LN64@hw_Render
	cmp	DWORD PTR [edi+604], edx
	je	SHORT $LN63@hw_Render
$LN64@hw_Render:

; 173  : 	{
; 174  : 		PGO(Msg("PGO:VB:%x,%d", _vb, _vb_stride));
; 175  : #ifdef DEBUG
; 176  : 		stat.vb++;
; 177  : #endif
; 178  : 		vb = _vb;

	mov	DWORD PTR [edi+596], ebx

; 179  : 		vb_stride = _vb_stride;

	mov	DWORD PTR [edi+604], edx

; 180  : 		CHK_DX(HW.pDevice->SetStreamSource(0, vb, 0, vb_stride));

	mov	eax, DWORD PTR __imp_?HW@@3VCHW@@A
	push	edx
	push	0
	push	ebx
	mov	eax, DWORD PTR [eax+8]
	push	0
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+400]
$LN63@hw_Render:

; 226  : 	set_Indices(_geom->ib);

	mov	edx, DWORD PTR [ebp+16]

; 186  : 	if (ib != _ib)

	cmp	DWORD PTR [edi+600], edx
	je	SHORT $LN67@hw_Render

; 187  : 	{
; 188  : 		PGO(Msg("PGO:IB:%x", _ib));
; 189  : #ifdef DEBUG
; 190  : 		stat.ib++;
; 191  : #endif
; 192  : 		ib = _ib;

	mov	DWORD PTR [edi+600], edx

; 193  : 		CHK_DX(HW.pDevice->SetIndices(ib));

	mov	eax, DWORD PTR __imp_?HW@@3VCHW@@A
	push	edx
	mov	eax, DWORD PTR [eax+8]
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+416]
$LN67@hw_Render:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_VS.cpp

; 150  : 	wave.set				(1.f/5.f,		1.f/7.f,	1.f/3.f,	Device.fTimeGlobal*swing_current.speed);

	mov	eax, DWORD PTR __imp_?Device@@3VCRenderDevice@@A

; 151  : 	RCache.set_c			(&*hwc_consts,	scale,		scale,		ps_r__Detail_l_aniso,	ps_r__Detail_l_ambient);				// consts

	mov	edi, DWORD PTR [esi+701244]
	movss	xmm0, DWORD PTR [eax+472]
	mulss	xmm0, DWORD PTR [esi+1084]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector4.h

; 17   : 	IC	SelfRef 	set(T _x, T _y, T _z, T _w=1)		{ x=_x;		y=_y;		z=_z;		w=_w;		return *this; }

	mov	DWORD PTR _wave$[esp+100], 1045220557	; 3e4ccccdH
	mov	DWORD PTR _wave$[esp+104], 1041385765	; 3e124925H
	mov	DWORD PTR _wave$[esp+108], 1051372203	; 3eaaaaabH
	movss	DWORD PTR _wave$[esp+112], xmm0
; File I:\Vitalya\mine\NSProjectX\xrEngine\R_Backend.h

; 191  : 	ICF	void						set_c(R_constant* C, float x, float y, float z, float w) { if (C)		constants.set(C, x, y, z, w); }

	test	edi, edi
	je	SHORT $LN80@hw_Render
; File I:\Vitalya\mine\NSProjectX\xrEngine\r_constants_cache.h

; 147  : 		if (C->destination & 1) { a_pixel.set(C, C->ps, A); a_pixel.b_dirty = TRUE; }

	movzx	eax, WORD PTR [edi+10]
; File I:\Vitalya\mine\NSProjectX\xrEngine\R_Backend.h

; 191  : 	ICF	void						set_c(R_constant* C, float x, float y, float z, float w) { if (C)		constants.set(C, x, y, z, w); }

	mov	ebx, DWORD PTR __imp_?RCache@@3VCBackend@@A
; File I:\Vitalya\mine\NSProjectX\xrEngine\r_constants_cache.h

; 147  : 		if (C->destination & 1) { a_pixel.set(C, C->ps, A); a_pixel.b_dirty = TRUE; }

	mov	ecx, eax
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector4.h

; 17   : 	IC	SelfRef 	set(T _x, T _y, T _z, T _w=1)		{ x=_x;		y=_y;		z=_z;		w=_w;		return *this; }

	mov	DWORD PTR _data$2[esp+100], 947912704	; 38800000H
	mov	DWORD PTR _data$2[esp+104], 947912704	; 38800000H
	mov	DWORD PTR _data$2[esp+108], 1048576000	; 3e800000H
	mov	DWORD PTR _data$2[esp+112], 1063675494	; 3f666666H
; File I:\Vitalya\mine\NSProjectX\xrEngine\r_constants_cache.h

; 147  : 		if (C->destination & 1) { a_pixel.set(C, C->ps, A); a_pixel.b_dirty = TRUE; }

	test	al, 1
	je	SHORT $LN79@hw_Render
	lea	eax, DWORD PTR _data$2[esp+100]
	push	eax
	lea	eax, DWORD PTR [edi+12]
	push	eax
	push	edi
	lea	ecx, DWORD PTR [ebx+608]
	call	?set@R_constant_array@@QAEXPAUR_constant@@AAUR_constant_load@@ABU?$_vector4@M@@@Z ; R_constant_array::set
	mov	DWORD PTR [ebx+4720], 1
	movzx	ecx, WORD PTR [edi+10]
$LN79@hw_Render:

; 148  : 		if (C->destination & 2) { a_vertex.set(C, C->vs, A); a_vertex.b_dirty = TRUE; }

	test	cl, 2
	je	SHORT $LN80@hw_Render
	lea	eax, DWORD PTR _data$2[esp+100]
	push	eax
	lea	eax, DWORD PTR [edi+16]
	push	eax
	push	edi
	lea	ecx, DWORD PTR [ebx+4736]
	call	?set@R_constant_array@@QAEXPAUR_constant@@AAUR_constant_load@@ABU?$_vector4@M@@@Z ; R_constant_array::set
	mov	DWORD PTR [ebx+8848], 1
$LN80@hw_Render:
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector4.h

; 38   : 	IC  SelfRef		div(T s)							{ x/=s;		y/=s;		z/=s;		w/=s;		return *this; }

	movss	xmm1, DWORD PTR __real@3e22f983
	movss	xmm0, DWORD PTR _wave$[esp+100]
	mulss	xmm0, xmm1
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_VS.cpp

; 152  : 	RCache.set_c			(&*hwc_wave,	wave.div(PI_MUL_2));	// wave

	mov	edi, DWORD PTR [esi+701248]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector4.h

; 38   : 	IC  SelfRef		div(T s)							{ x/=s;		y/=s;		z/=s;		w/=s;		return *this; }

	movss	DWORD PTR _wave$[esp+100], xmm0
	movss	xmm0, DWORD PTR _wave$[esp+104]
	mulss	xmm0, xmm1
	movss	DWORD PTR _wave$[esp+104], xmm0
	movss	xmm0, DWORD PTR _wave$[esp+108]
	mulss	xmm0, xmm1
	movss	DWORD PTR _wave$[esp+108], xmm0
	movss	xmm0, DWORD PTR _wave$[esp+112]
	mulss	xmm0, xmm1
	movss	DWORD PTR _wave$[esp+112], xmm0
; File I:\Vitalya\mine\NSProjectX\xrEngine\R_Backend.h

; 190  : 	ICF	void						set_c(R_constant* C, const Fvector4& A) { if (C)		constants.set(C, A); }

	test	edi, edi
	je	SHORT $LN89@hw_Render
; File I:\Vitalya\mine\NSProjectX\xrEngine\r_constants_cache.h

; 147  : 		if (C->destination & 1) { a_pixel.set(C, C->ps, A); a_pixel.b_dirty = TRUE; }

	movzx	eax, WORD PTR [edi+10]
; File I:\Vitalya\mine\NSProjectX\xrEngine\R_Backend.h

; 190  : 	ICF	void						set_c(R_constant* C, const Fvector4& A) { if (C)		constants.set(C, A); }

	mov	ebx, DWORD PTR __imp_?RCache@@3VCBackend@@A
; File I:\Vitalya\mine\NSProjectX\xrEngine\r_constants_cache.h

; 147  : 		if (C->destination & 1) { a_pixel.set(C, C->ps, A); a_pixel.b_dirty = TRUE; }

	mov	ecx, eax
	test	al, 1
	je	SHORT $LN88@hw_Render
	lea	eax, DWORD PTR _wave$[esp+100]
	push	eax
	lea	eax, DWORD PTR [edi+12]
	push	eax
	push	edi
	lea	ecx, DWORD PTR [ebx+608]
	call	?set@R_constant_array@@QAEXPAUR_constant@@AAUR_constant_load@@ABU?$_vector4@M@@@Z ; R_constant_array::set
	mov	DWORD PTR [ebx+4720], 1
	movzx	ecx, WORD PTR [edi+10]
$LN88@hw_Render:

; 148  : 		if (C->destination & 2) { a_vertex.set(C, C->vs, A); a_vertex.b_dirty = TRUE; }

	test	cl, 2
	je	SHORT $LN89@hw_Render
	lea	eax, DWORD PTR _wave$[esp+100]
	push	eax
	lea	eax, DWORD PTR [edi+16]
	push	eax
	push	edi
	lea	ecx, DWORD PTR [ebx+4736]
	call	?set@R_constant_array@@QAEXPAUR_constant@@AAUR_constant_load@@ABU?$_vector4@M@@@Z ; R_constant_array::set
	mov	DWORD PTR [ebx+8848], 1
$LN89@hw_Render:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_VS.cpp

; 153  : 	RCache.set_c			(&*hwc_wind,	dir1);																					// wind-dir

	mov	edi, DWORD PTR [esi+701252]
; File I:\Vitalya\mine\NSProjectX\xrEngine\R_Backend.h

; 190  : 	ICF	void						set_c(R_constant* C, const Fvector4& A) { if (C)		constants.set(C, A); }

	test	edi, edi
	je	SHORT $LN96@hw_Render
; File I:\Vitalya\mine\NSProjectX\xrEngine\r_constants_cache.h

; 147  : 		if (C->destination & 1) { a_pixel.set(C, C->ps, A); a_pixel.b_dirty = TRUE; }

	movzx	eax, WORD PTR [edi+10]
; File I:\Vitalya\mine\NSProjectX\xrEngine\R_Backend.h

; 190  : 	ICF	void						set_c(R_constant* C, const Fvector4& A) { if (C)		constants.set(C, A); }

	mov	ebx, DWORD PTR __imp_?RCache@@3VCBackend@@A
; File I:\Vitalya\mine\NSProjectX\xrEngine\r_constants_cache.h

; 147  : 		if (C->destination & 1) { a_pixel.set(C, C->ps, A); a_pixel.b_dirty = TRUE; }

	mov	ecx, eax
	test	al, 1
	je	SHORT $LN95@hw_Render
	lea	eax, DWORD PTR _dir1$[esp+100]
	push	eax
	lea	eax, DWORD PTR [edi+12]
	push	eax
	push	edi
	lea	ecx, DWORD PTR [ebx+608]
	call	?set@R_constant_array@@QAEXPAUR_constant@@AAUR_constant_load@@ABU?$_vector4@M@@@Z ; R_constant_array::set
	mov	DWORD PTR [ebx+4720], 1
	movzx	ecx, WORD PTR [edi+10]
$LN95@hw_Render:

; 148  : 		if (C->destination & 2) { a_vertex.set(C, C->vs, A); a_vertex.b_dirty = TRUE; }

	test	cl, 2
	je	SHORT $LN96@hw_Render
	lea	eax, DWORD PTR _dir1$[esp+100]
	push	eax
	lea	eax, DWORD PTR [edi+16]
	push	eax
	push	edi
	lea	ecx, DWORD PTR [ebx+4736]
	call	?set@R_constant_array@@QAEXPAUR_constant@@AAUR_constant_load@@ABU?$_vector4@M@@@Z ; R_constant_array::set
	mov	DWORD PTR [ebx+8848], 1
$LN96@hw_Render:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_VS.cpp

; 154  : 	hw_Render_dump			(&*hwc_array,	1, 0, c_hdr );

	push	ecx
	mov	ecx, DWORD PTR [esi+701256]
	push	0
	push	1
	push	ecx
	mov	eax, esp
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 62   : 						resptr_core		(T * p, bool add_ref = true) 					{	p_ = p;	if(add_ref)	_inc(); }

	mov	DWORD PTR [eax], ecx

; 43   : 	void				_inc	()									{	if (0==p_) return;	p_->dwReference++;														}

	test	ecx, ecx
	je	SHORT $LN101@hw_Render
	inc	DWORD PTR [ecx]
$LN101@hw_Render:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_VS.cpp

; 154  : 	hw_Render_dump			(&*hwc_array,	1, 0, c_hdr );

	mov	ecx, esi
	call	?hw_Render_dump@CDetailManager@@QAEXV?$resptr_core@UR_constant@@V?$resptr_base@UR_constant@@@@@@III@Z ; CDetailManager::hw_Render_dump

; 155  : 
; 156  : 	// Wave1
; 157  : 	wave.set				(1.f/3.f,		1.f/7.f,	1.f/5.f,	Device.fTimeGlobal*swing_current.speed);

	mov	eax, DWORD PTR __imp_?Device@@3VCRenderDevice@@A

; 158  : 	RCache.set_c			(&*hwc_wave,	wave.div(PI_MUL_2));	// wave

	mov	edi, DWORD PTR [esi+701248]
	movss	xmm0, DWORD PTR [eax+472]
	mulss	xmm0, DWORD PTR [esi+1084]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector4.h

; 38   : 	IC  SelfRef		div(T s)							{ x/=s;		y/=s;		z/=s;		w/=s;		return *this; }

	mov	DWORD PTR _wave$[esp+100], 1029262511	; 3d594cafH
	mov	DWORD PTR _wave$[esp+104], 1018839483	; 3cba41bbH
	mov	DWORD PTR _wave$[esp+108], 1023566134	; 3d026136H
	mulss	xmm0, DWORD PTR __real@3e22f983
	movss	DWORD PTR _wave$[esp+112], xmm0
; File I:\Vitalya\mine\NSProjectX\xrEngine\R_Backend.h

; 190  : 	ICF	void						set_c(R_constant* C, const Fvector4& A) { if (C)		constants.set(C, A); }

	test	edi, edi
	je	SHORT $LN228@hw_Render
; File I:\Vitalya\mine\NSProjectX\xrEngine\r_constants_cache.h

; 147  : 		if (C->destination & 1) { a_pixel.set(C, C->ps, A); a_pixel.b_dirty = TRUE; }

	movzx	eax, WORD PTR [edi+10]
; File I:\Vitalya\mine\NSProjectX\xrEngine\R_Backend.h

; 190  : 	ICF	void						set_c(R_constant* C, const Fvector4& A) { if (C)		constants.set(C, A); }

	mov	ebx, DWORD PTR __imp_?RCache@@3VCBackend@@A
; File I:\Vitalya\mine\NSProjectX\xrEngine\r_constants_cache.h

; 147  : 		if (C->destination & 1) { a_pixel.set(C, C->ps, A); a_pixel.b_dirty = TRUE; }

	mov	ecx, eax
	test	al, 1
	je	SHORT $LN112@hw_Render
	lea	eax, DWORD PTR _wave$[esp+100]
	push	eax
	lea	eax, DWORD PTR [edi+12]
	push	eax
	push	edi
	lea	ecx, DWORD PTR [ebx+608]
	call	?set@R_constant_array@@QAEXPAUR_constant@@AAUR_constant_load@@ABU?$_vector4@M@@@Z ; R_constant_array::set
	mov	DWORD PTR [ebx+4720], 1
	movzx	ecx, WORD PTR [edi+10]
$LN112@hw_Render:

; 148  : 		if (C->destination & 2) { a_vertex.set(C, C->vs, A); a_vertex.b_dirty = TRUE; }

	test	cl, 2
	je	SHORT $LN228@hw_Render
	lea	eax, DWORD PTR _wave$[esp+100]
	push	eax
	lea	eax, DWORD PTR [edi+16]
	push	eax
	push	edi
	lea	ecx, DWORD PTR [ebx+4736]
	call	?set@R_constant_array@@QAEXPAUR_constant@@AAUR_constant_load@@ABU?$_vector4@M@@@Z ; R_constant_array::set
	mov	DWORD PTR [ebx+8848], 1
$LN228@hw_Render:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_VS.cpp

; 159  : 	RCache.set_c			(&*hwc_wind,	dir2);																					// wind-dir

	mov	edi, DWORD PTR [esi+701252]
; File I:\Vitalya\mine\NSProjectX\xrEngine\R_Backend.h

; 190  : 	ICF	void						set_c(R_constant* C, const Fvector4& A) { if (C)		constants.set(C, A); }

	test	edi, edi
	je	SHORT $LN139@hw_Render
; File I:\Vitalya\mine\NSProjectX\xrEngine\r_constants_cache.h

; 147  : 		if (C->destination & 1) { a_pixel.set(C, C->ps, A); a_pixel.b_dirty = TRUE; }

	movzx	eax, WORD PTR [edi+10]
; File I:\Vitalya\mine\NSProjectX\xrEngine\R_Backend.h

; 190  : 	ICF	void						set_c(R_constant* C, const Fvector4& A) { if (C)		constants.set(C, A); }

	mov	ebx, DWORD PTR __imp_?RCache@@3VCBackend@@A
; File I:\Vitalya\mine\NSProjectX\xrEngine\r_constants_cache.h

; 147  : 		if (C->destination & 1) { a_pixel.set(C, C->ps, A); a_pixel.b_dirty = TRUE; }

	mov	ecx, eax
	test	al, 1
	je	SHORT $LN138@hw_Render
	lea	eax, DWORD PTR _dir2$[esp+100]
	push	eax
	lea	eax, DWORD PTR [edi+12]
	push	eax
	push	edi
	lea	ecx, DWORD PTR [ebx+608]
	call	?set@R_constant_array@@QAEXPAUR_constant@@AAUR_constant_load@@ABU?$_vector4@M@@@Z ; R_constant_array::set
	mov	DWORD PTR [ebx+4720], 1
	movzx	ecx, WORD PTR [edi+10]
$LN138@hw_Render:

; 148  : 		if (C->destination & 2) { a_vertex.set(C, C->vs, A); a_vertex.b_dirty = TRUE; }

	test	cl, 2
	je	SHORT $LN139@hw_Render
	lea	eax, DWORD PTR _dir2$[esp+100]
	push	eax
	lea	eax, DWORD PTR [edi+16]
	push	eax
	push	edi
	lea	ecx, DWORD PTR [ebx+4736]
	call	?set@R_constant_array@@QAEXPAUR_constant@@AAUR_constant_load@@ABU?$_vector4@M@@@Z ; R_constant_array::set
	mov	DWORD PTR [ebx+8848], 1
$LN139@hw_Render:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_VS.cpp

; 160  : 	hw_Render_dump			(&*hwc_array,	2, 0, c_hdr );

	push	ecx
	mov	ecx, DWORD PTR [esi+701256]
	push	0
	push	2
	push	ecx
	mov	eax, esp
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 62   : 						resptr_core		(T * p, bool add_ref = true) 					{	p_ = p;	if(add_ref)	_inc(); }

	mov	DWORD PTR [eax], ecx

; 43   : 	void				_inc	()									{	if (0==p_) return;	p_->dwReference++;														}

	test	ecx, ecx
	je	SHORT $LN163@hw_Render
	inc	DWORD PTR [ecx]
$LN163@hw_Render:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_VS.cpp

; 160  : 	hw_Render_dump			(&*hwc_array,	2, 0, c_hdr );

	mov	ecx, esi
	call	?hw_Render_dump@CDetailManager@@QAEXV?$resptr_core@UR_constant@@V?$resptr_base@UR_constant@@@@@@III@Z ; CDetailManager::hw_Render_dump

; 161  : 
; 162  : 	// Still
; 163  : 	RCache.set_c			(&*hwc_s_consts,scale,		scale,		scale,				1.f);

	mov	edi, DWORD PTR [esi+701260]
; File I:\Vitalya\mine\NSProjectX\xrEngine\R_Backend.h

; 191  : 	ICF	void						set_c(R_constant* C, float x, float y, float z, float w) { if (C)		constants.set(C, x, y, z, w); }

	test	edi, edi
	je	SHORT $LN229@hw_Render
; File I:\Vitalya\mine\NSProjectX\xrEngine\r_constants_cache.h

; 147  : 		if (C->destination & 1) { a_pixel.set(C, C->ps, A); a_pixel.b_dirty = TRUE; }

	movzx	eax, WORD PTR [edi+10]
; File I:\Vitalya\mine\NSProjectX\xrEngine\R_Backend.h

; 191  : 	ICF	void						set_c(R_constant* C, float x, float y, float z, float w) { if (C)		constants.set(C, x, y, z, w); }

	mov	ebx, DWORD PTR __imp_?RCache@@3VCBackend@@A
; File I:\Vitalya\mine\NSProjectX\xrEngine\r_constants_cache.h

; 147  : 		if (C->destination & 1) { a_pixel.set(C, C->ps, A); a_pixel.b_dirty = TRUE; }

	mov	ecx, eax
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector4.h

; 17   : 	IC	SelfRef 	set(T _x, T _y, T _z, T _w=1)		{ x=_x;		y=_y;		z=_z;		w=_w;		return *this; }

	mov	DWORD PTR _data$1[esp+100], 947912704	; 38800000H
	mov	DWORD PTR _data$1[esp+104], 947912704	; 38800000H
	mov	DWORD PTR _data$1[esp+108], 947912704	; 38800000H
	mov	DWORD PTR _data$1[esp+112], 1065353216	; 3f800000H
; File I:\Vitalya\mine\NSProjectX\xrEngine\r_constants_cache.h

; 147  : 		if (C->destination & 1) { a_pixel.set(C, C->ps, A); a_pixel.b_dirty = TRUE; }

	test	al, 1
	je	SHORT $LN174@hw_Render
	lea	eax, DWORD PTR _data$1[esp+100]
	push	eax
	lea	eax, DWORD PTR [edi+12]
	push	eax
	push	edi
	lea	ecx, DWORD PTR [ebx+608]
	call	?set@R_constant_array@@QAEXPAUR_constant@@AAUR_constant_load@@ABU?$_vector4@M@@@Z ; R_constant_array::set
	mov	DWORD PTR [ebx+4720], 1
	movzx	ecx, WORD PTR [edi+10]
$LN174@hw_Render:

; 148  : 		if (C->destination & 2) { a_vertex.set(C, C->vs, A); a_vertex.b_dirty = TRUE; }

	test	cl, 2
	je	SHORT $LN229@hw_Render
	lea	eax, DWORD PTR _data$1[esp+100]
	push	eax
	lea	eax, DWORD PTR [edi+16]
	push	eax
	push	edi
	lea	ecx, DWORD PTR [ebx+4736]
	call	?set@R_constant_array@@QAEXPAUR_constant@@AAUR_constant_load@@ABU?$_vector4@M@@@Z ; R_constant_array::set
	mov	DWORD PTR [ebx+8848], 1
$LN229@hw_Render:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_VS.cpp

; 164  : 	RCache.set_c			(&*hwc_s_xform,	Device.mFullTransform);

	mov	ebp, DWORD PTR __imp_?Device@@3VCRenderDevice@@A
	mov	edi, DWORD PTR [esi+701264]
	add	ebp, 664				; 00000298H
; File I:\Vitalya\mine\NSProjectX\xrEngine\R_Backend.h

; 189  : 	ICF	void						set_c(R_constant* C, const Fmatrix& A) { if (C)		constants.set(C, A); }

	test	edi, edi
	je	SHORT $LN220@hw_Render
; File I:\Vitalya\mine\NSProjectX\xrEngine\r_constants_cache.h

; 143  : 		if (C->destination & 1) { a_pixel.set(C, C->ps, A); a_pixel.b_dirty = TRUE; }

	movzx	eax, WORD PTR [edi+10]
; File I:\Vitalya\mine\NSProjectX\xrEngine\R_Backend.h

; 189  : 	ICF	void						set_c(R_constant* C, const Fmatrix& A) { if (C)		constants.set(C, A); }

	mov	ebx, DWORD PTR __imp_?RCache@@3VCBackend@@A
; File I:\Vitalya\mine\NSProjectX\xrEngine\r_constants_cache.h

; 143  : 		if (C->destination & 1) { a_pixel.set(C, C->ps, A); a_pixel.b_dirty = TRUE; }

	mov	ecx, eax
	test	al, 1
	je	SHORT $LN219@hw_Render
	push	ebp
	lea	eax, DWORD PTR [edi+12]
	push	eax
	push	edi
	lea	ecx, DWORD PTR [ebx+608]
	call	?set@R_constant_array@@QAEXPAUR_constant@@AAUR_constant_load@@ABU?$_matrix@M@@@Z ; R_constant_array::set
	mov	DWORD PTR [ebx+4720], 1
	movzx	ecx, WORD PTR [edi+10]
$LN219@hw_Render:

; 144  : 		if (C->destination & 2) { a_vertex.set(C, C->vs, A); a_vertex.b_dirty = TRUE; }

	test	cl, 2
	je	SHORT $LN220@hw_Render
	push	ebp
	lea	eax, DWORD PTR [edi+16]
	push	eax
	push	edi
	lea	ecx, DWORD PTR [ebx+4736]
	call	?set@R_constant_array@@QAEXPAUR_constant@@AAUR_constant_load@@ABU?$_matrix@M@@@Z ; R_constant_array::set
	mov	DWORD PTR [ebx+8848], 1
$LN220@hw_Render:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_VS.cpp

; 165  : 	hw_Render_dump			(&*hwc_s_array,	0, 1, c_hdr );

	push	ecx
	mov	ecx, DWORD PTR [esi+701268]
	push	1
	push	0
	push	ecx
	mov	eax, esp
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 62   : 						resptr_core		(T * p, bool add_ref = true) 					{	p_ = p;	if(add_ref)	_inc(); }

	mov	DWORD PTR [eax], ecx

; 43   : 	void				_inc	()									{	if (0==p_) return;	p_->dwReference++;														}

	test	ecx, ecx
	je	SHORT $LN225@hw_Render
	inc	DWORD PTR [ecx]
$LN225@hw_Render:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_VS.cpp

; 165  : 	hw_Render_dump			(&*hwc_s_array,	0, 1, c_hdr );

	mov	ecx, esi
	call	?hw_Render_dump@CDetailManager@@QAEXV?$resptr_core@UR_constant@@V?$resptr_base@UR_constant@@@@@@III@Z ; CDetailManager::hw_Render_dump

; 166  : }

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 84					; 00000054H
	ret	0
?hw_Render@CDetailManager@@QAEXXZ ENDP			; CDetailManager::hw_Render
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_VS.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_VS.cpp
_TEXT	SEGMENT
?hw_Unload@CDetailManager@@QAEXXZ PROC			; CDetailManager::hw_Unload
; _this$ = ecx

; 128  : {

	push	esi
	push	edi
	mov	edi, ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 46   : 	ICF		void		_set	(T * rhs) 							{	if (0!=rhs) rhs->dwReference++;	_dec(); p_ = rhs;											}

	lea	ecx, DWORD PTR [edi+701228]
	call	DWORD PTR __imp_?_dec@?$resptr_base@USGeometry@@@@IAEXXZ
	mov	DWORD PTR [edi+701228], 0
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_VS.cpp

; 131  : 	_RELEASE					(hw_IB);

	mov	ecx, DWORD PTR [edi+701240]
	test	ecx, ecx
	je	SHORT $LN2@hw_Unload
	mov	eax, DWORD PTR [ecx]
	push	ecx
	call	DWORD PTR [eax+8]
	mov	DWORD PTR [edi+701240], 0
$LN2@hw_Unload:

; 132  : 	_RELEASE					(hw_VB);

	mov	ecx, DWORD PTR [edi+701236]
	test	ecx, ecx
	je	SHORT $LN3@hw_Unload
	mov	eax, DWORD PTR [ecx]
	push	ecx
	call	DWORD PTR [eax+8]
	mov	DWORD PTR [edi+701236], 0
$LN3@hw_Unload:

; 133  : }

	pop	edi
	pop	esi
	ret	0
?hw_Unload@CDetailManager@@QAEXXZ ENDP			; CDetailManager::hw_Unload
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_VS.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\vector.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_VS.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_VS.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h
; File I:\Vitalya\mine\NSProjectX\xrCore\vector.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_VS.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_VS.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h
; File I:\Vitalya\mine\NSProjectX\xrCore\vector.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_VS.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_VS.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h
; File I:\Vitalya\mine\NSProjectX\xrCore\vector.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_VS.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_VS.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xrstring.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xrstring.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_VS.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xrstring.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xrstring.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_VS.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xrstring.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xrstring.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_VS.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xrstring.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xrstring.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_VS.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xrstring.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xrstring.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_VS.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xrstring.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xrstring.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_VS.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xrstring.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xrstring.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_VS.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_VS.cpp
_TEXT	SEGMENT
$T1 = -36						; size = 4
$T2 = -36						; size = 4
$T3 = -36						; size = 4
$T4 = -36						; size = 4
$T5 = -36						; size = 4
$T6 = -36						; size = 4
$T7 = -36						; size = 4
_pV$8 = -36						; size = 4
_T0$1$ = -32						; size = 4
_batch$1$ = -32						; size = 4
_pI$9 = -32						; size = 4
_T1$1$ = -28						; size = 4
_v$1$ = -28						; size = 4
_S$ = -24						; size = 4
_o$1$ = -20						; size = 4
tv3112 = -20						; size = 4
_o$2$ = -16						; size = 4
tv3114 = -16						; size = 4
_a$10 = -12						; size = 4
_a$11 = -12						; size = 4
_vP$1$ = -8						; size = 4
_a$12 = -8						; size = 4
_this$1$ = -4						; size = 4
_offset$13 = -4						; size = 2
?hw_Load@CDetailManager@@QAEXXZ PROC			; CDetailManager::hw_Load
; _this$ = ecx

; 40   : {

	sub	esp, 36					; 00000024H

; 41   : 	// Analyze batch-size
; 42   : 	hw_BatchSize	= (u32(HW.Caps.geometry.dwRegisters)-c_hdr)/c_size;

	mov	eax, DWORD PTR __imp_?HW@@3VCHW@@A
	push	ebp
	mov	ebp, ecx
	push	esi
	movzx	eax, WORD PTR [eax+52]
	sub	eax, 10					; 0000000aH
	mov	DWORD PTR _this$1$[esp+44], ebp
	shr	eax, 2
	mov	DWORD PTR [ebp+701232], eax
; File I:\Vitalya\mine\NSProjectX\xrCore\vector.h

; 92   : 	if( val<_low ) val = _low; else if( val>_high ) val = _high;

	cmp	eax, 64					; 00000040H
	jbe	SHORT $LN485@hw_Load
	mov	DWORD PTR [ebp+701232], 64		; 00000040H
	mov	eax, 64					; 00000040H
$LN485@hw_Load:
	push	ebx
	push	edi
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_VS.cpp

; 44   : 	Msg				("* [DETAILS] VertexConsts(%d), Batch(%d)",u32(HW.Caps.geometry.dwRegisters),hw_BatchSize);

	push	eax
	mov	eax, DWORD PTR __imp_?HW@@3VCHW@@A
	movzx	eax, WORD PTR [eax+52]
	push	eax
	push	OFFSET ??_C@_0CI@EMGBNKCM@?$CK?5?$FLDETAILS?$FN?5VertexConsts?$CI?$CFd?$CJ?0?5B@
	call	DWORD PTR __imp_?Msg@@YAXPBDZZ

; 45   : 
; 46   : 	// Pre-process objects
; 47   : 	u32			dwVerts		= 0;
; 48   : 	u32			dwIndices	= 0;
; 49   : 	for (u32 o=0; o<objects.size(); o++)

	mov	ebx, DWORD PTR [ebp+1392]
	add	esp, 12					; 0000000cH
	xor	esi, esi
	xor	edi, edi
	test	ebx, ebx
	je	SHORT $LN3@hw_Load

; 52   : 		dwVerts		+=	D.number_vertices*hw_BatchSize;

	lea	edx, DWORD PTR [ebp+1136]
$LL4@hw_Load:

; 50   : 	{
; 51   : 		CDetail& D	=	*objects[o];

	mov	ecx, DWORD PTR [edx]
	lea	edx, DWORD PTR [edx+4]

; 52   : 		dwVerts		+=	D.number_vertices*hw_BatchSize;

	mov	eax, DWORD PTR [ecx+64]
	imul	eax, DWORD PTR [ebp+701232]
	add	esi, eax

; 53   : 		dwIndices	+=	D.number_indices*hw_BatchSize;

	mov	eax, DWORD PTR [ecx+72]
	imul	eax, DWORD PTR [ebp+701232]
	add	edi, eax
	sub	ebx, 1
	jne	SHORT $LL4@hw_Load
$LN3@hw_Load:

; 54   : 	}
; 55   : 	u32			vSize		= sizeof(vertHW);
; 56   : 	Msg("* [DETAILS] %d v(%d), %d p",dwVerts,vSize,dwIndices/3);

	mov	ebx, DWORD PTR __imp_?Msg@@YAXPBDZZ
	mov	eax, -1431655765			; aaaaaaabH
	mul	edi
	shr	edx, 1
	push	edx
	push	20					; 00000014H
	push	esi
	push	OFFSET ??_C@_0BL@GGFJBNPE@?$CK?5?$FLDETAILS?$FN?5?$CFd?5v?$CI?$CFd?$CJ?0?5?$CFd?5p@
	call	ebx

; 57   : 
; 58   : 	// Determine POOL & USAGE
; 59   : 	u32 dwUsage		=	D3DUSAGE_WRITEONLY;
; 60   : 
; 61   : 	// Create VB/IB
; 62   : 	R_CHK			(HW.pDevice->CreateVertexBuffer(dwVerts*vSize,dwUsage,0,D3DPOOL_MANAGED,&hw_VB,0));

	mov	eax, DWORD PTR __imp_?HW@@3VCHW@@A
	lea	edx, DWORD PTR [ebp+701236]
	add	esp, 16					; 00000010H
	lea	esi, DWORD PTR [esi+esi*4]
	shl	esi, 2
	mov	ecx, DWORD PTR [eax+8]
	push	0
	push	edx
	push	1
	mov	eax, DWORD PTR [ecx]
	push	0
	push	8
	push	esi
	push	ecx
	call	DWORD PTR [eax+104]
	cmp	BYTE PTR ?ignore_always@?5??hw_Load@CDetailManager@@QAEXXZ@4_NA, 0
	jne	SHORT $LN5@hw_Load
	test	eax, eax
	jns	SHORT $LN5@hw_Load
	mov	ecx, DWORD PTR __imp_?Debug@@3VxrDebug@@A
	push	OFFSET ?ignore_always@?5??hw_Load@CDetailManager@@QAEXXZ@4_NA
	push	OFFSET ??_C@_0BI@LGPMLEDD@CDetailManager?3?3hw_Load@
	push	62					; 0000003eH
	push	OFFSET ??_C@_0EA@DCNLPIGP@I?3?2Vitalya?2mine?2NSProjectX?2laye@
	push	OFFSET ??_C@_0FB@FADLPKOG@HW?4pDevice?9?$DOCreateVertexBuffer?$CI@
	push	eax
	call	DWORD PTR __imp_?error@xrDebug@@QAEXJPBD0H0AA_N@Z
$LN5@hw_Load:

; 63   : 	R_CHK			(HW.pDevice->CreateIndexBuffer(dwIndices*2,dwUsage,D3DFMT_INDEX16,D3DPOOL_MANAGED,&hw_IB,0));

	mov	eax, DWORD PTR __imp_?HW@@3VCHW@@A
	lea	edx, DWORD PTR [ebp+701240]
	push	0
	push	edx
	push	1
	mov	ecx, DWORD PTR [eax+8]
	add	edi, edi
	push	101					; 00000065H
	push	8
	push	edi
	mov	eax, DWORD PTR [ecx]
	push	ecx
	call	DWORD PTR [eax+108]
	cmp	BYTE PTR ?ignore_always@?9??hw_Load@CDetailManager@@QAEXXZ@4_NA, 0
	jne	SHORT $LN8@hw_Load
	test	eax, eax
	jns	SHORT $LN8@hw_Load
	mov	ecx, DWORD PTR __imp_?Debug@@3VxrDebug@@A
	push	OFFSET ?ignore_always@?9??hw_Load@CDetailManager@@QAEXXZ@4_NA
	push	OFFSET ??_C@_0BI@LGPMLEDD@CDetailManager?3?3hw_Load@
	push	63					; 0000003fH
	push	OFFSET ??_C@_0EA@DCNLPIGP@I?3?2Vitalya?2mine?2NSProjectX?2laye@
	push	OFFSET ??_C@_0FL@CHIPGLIE@HW?4pDevice?9?$DOCreateIndexBuffer?$CId@
	push	eax
	call	DWORD PTR __imp_?error@xrDebug@@QAEXJPBD0H0AA_N@Z
$LN8@hw_Load:

; 64   : 	Msg("* [DETAILS] Batch(%d), VB(%dK), IB(%dK)",hw_BatchSize,(dwVerts*vSize)/1024, (dwIndices*2)/1024);

	shr	edi, 10					; 0000000aH
	push	edi
	shr	esi, 10					; 0000000aH
	push	esi
	push	DWORD PTR [ebp+701232]
	push	OFFSET ??_C@_0CI@ODFBHGNM@?$CK?5?$FLDETAILS?$FN?5Batch?$CI?$CFd?$CJ?0?5VB?$CI?$CFdK?$CJ?0@
	call	ebx

; 65   : 
; 66   : 	// Fill VB
; 67   : 	{
; 68   : 		vertHW*			pV;
; 69   : 		R_CHK			(hw_VB->Lock(0,0,(void**)&pV,0));

	mov	eax, DWORD PTR [ebp+701236]
	lea	edx, DWORD PTR _pV$8[esp+68]
	add	esp, 16					; 00000010H
	mov	ecx, DWORD PTR [eax]
	push	0
	push	edx
	push	0
	push	0
	push	eax
	call	DWORD PTR [ecx+44]
	cmp	BYTE PTR ?ignore_always@?P@??hw_Load@CDetailManager@@QAEXXZ@4_NA, 0
	jne	SHORT $LN11@hw_Load
	test	eax, eax
	jns	SHORT $LN11@hw_Load
	mov	ecx, DWORD PTR __imp_?Debug@@3VxrDebug@@A
	push	OFFSET ?ignore_always@?P@??hw_Load@CDetailManager@@QAEXXZ@4_NA
	push	OFFSET ??_C@_0BI@LGPMLEDD@CDetailManager?3?3hw_Load@
	push	69					; 00000045H
	push	OFFSET ??_C@_0EA@DCNLPIGP@I?3?2Vitalya?2mine?2NSProjectX?2laye@
	push	OFFSET ??_C@_0BP@HAPAOFJ@hw_VB?9?$DOLock?$CI0?00?0?$CIvoid?$CK?$CK?$CJ?$CGpV?00?$CJ@
	push	eax
	call	DWORD PTR __imp_?error@xrDebug@@QAEXJPBD0H0AA_N@Z
$LN11@hw_Load:

; 70   : 		for (o=0; o<objects.size(); o++)

	xor	edx, edx
	mov	DWORD PTR _o$1$[esp+52], edx
	cmp	DWORD PTR [ebp+1392], edx
	jbe	$LN25@hw_Load
	movss	xmm2, DWORD PTR __real@46800000
	lea	ecx, DWORD PTR [ebp+1136]
	mov	eax, DWORD PTR _pV$8[esp+52]
	mov	DWORD PTR tv3114[esp+52], ecx
	npad	3
$LL16@hw_Load:

; 71   : 		{
; 72   : 			CDetail& D		=	*objects[o];

	mov	ebx, DWORD PTR [ecx]

; 73   : 			for (u32 batch=0; batch<hw_BatchSize; batch++)

	xor	ecx, ecx
	mov	DWORD PTR _batch$1$[esp+52], ecx
	cmp	DWORD PTR [ebp+701232], ecx
	jbe	$LN14@hw_Load
$LL19@hw_Load:

; 76   : 				for (u32 v=0; v<D.number_vertices; v++)

	cmp	DWORD PTR [ebx+64], 0
	mov	DWORD PTR _v$1$[esp+52], 0
	jbe	$LN17@hw_Load

; 74   : 			{
; 75   : 				u32 mid	=	batch*c_size;

	xor	ebp, ebp
	npad	8
$LL22@hw_Load:

; 77   : 				{
; 78   : 					Fvector&	vP = D.vertices[v].P;

	mov	ecx, DWORD PTR [ebx+60]
	add	ecx, ebp
	mov	DWORD PTR _vP$1$[esp+52], ecx

; 79   : 					pV->x	=	vP.x;

	fld	DWORD PTR [ecx]
	fstp	DWORD PTR [eax]

; 80   : 					pV->y	=	vP.y;

	mov	eax, DWORD PTR _pV$8[esp+52]
	fld	DWORD PTR [ecx+4]
	fstp	DWORD PTR [eax+4]

; 81   : 					pV->z	=	vP.z;

	mov	eax, DWORD PTR _pV$8[esp+52]
	fld	DWORD PTR [ecx+8]
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h

; 84   :     int exponent	= (127 + 31) - ((a >> 23) & 0xFF);

	mov	ecx, 158				; 0000009eH
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_VS.cpp

; 81   : 					pV->z	=	vP.z;

	fstp	DWORD PTR [eax+8]

; 35   : 	int t=iFloor(v*float(quant)); clamp(t,-32768,32767);

	mov	eax, DWORD PTR [ebx+60]
	movss	xmm0, DWORD PTR [eax+ebp+12]
	mulss	xmm0, xmm2
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h

; 83   :     int a			= *(const int*)(&x);

	movss	DWORD PTR _a$11[esp+52], xmm0

; 84   :     int exponent	= (127 + 31) - ((a >> 23) & 0xFF);

	mov	esi, DWORD PTR _a$11[esp+52]
	mov	eax, esi
	sar	eax, 23					; 00000017H

; 85   :     int r			= (((u32)(a) << 8) | (1U << 31)) >> exponent;

	mov	edi, esi
	movzx	eax, al
	or	edi, -8388608				; ff800000H
	sub	ecx, eax
	shl	edi, 8
	shr	edi, cl

; 86   :     exponent		+= 31-127;
; 87   :     {
; 88   :         int imask	=	(!(((( (1<<(exponent)))-1)>>8)&a));

	mov	eax, 1
	sub	ecx, 96					; 00000060H

; 89   :         exponent	-=	(31-127)+32;
; 90   :         exponent	>>=	31;
; 91   :         a			>>=	31;

	mov	edx, esi
	shl	eax, cl
	dec	eax
	sar	edx, 31					; 0000001fH
	sar	eax, 8
	and	eax, esi
	neg	eax
	sbb	eax, eax
	inc	eax
	and	eax, edx

; 92   :         r			-=	(imask&a);

	sub	edi, eax
	lea	eax, DWORD PTR [ecx+64]
	sar	eax, 31					; 0000001fH

; 93   :         r			&=	exponent;

	and	edi, eax
	xor	edi, edx
; File I:\Vitalya\mine\NSProjectX\xrCore\vector.h

; 92   : 	if( val<_low ) val = _low; else if( val>_high ) val = _high;

	cmp	edi, -32768				; ffff8000H
	jge	SHORT $LN68@hw_Load
	mov	edi, -32768				; ffff8000H
	jmp	SHORT $LN70@hw_Load
$LN68@hw_Load:
	cmp	edi, 32767				; 00007fffH
	mov	eax, 32767				; 00007fffH
	cmovg	edi, eax
$LN70@hw_Load:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_VS.cpp

; 82   : 					pV->u	=	QC(D.vertices[v].u);

	mov	eax, DWORD PTR _pV$8[esp+52]
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h

; 84   :     int exponent	= (127 + 31) - ((a >> 23) & 0xFF);

	mov	ecx, 158				; 0000009eH
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_VS.cpp

; 82   : 					pV->u	=	QC(D.vertices[v].u);

	mov	WORD PTR [eax+12], di

; 35   : 	int t=iFloor(v*float(quant)); clamp(t,-32768,32767);

	mov	eax, DWORD PTR [ebx+60]
	movss	xmm0, DWORD PTR [eax+ebp+16]
	mulss	xmm0, xmm2
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h

; 83   :     int a			= *(const int*)(&x);

	movss	DWORD PTR _a$10[esp+52], xmm0

; 84   :     int exponent	= (127 + 31) - ((a >> 23) & 0xFF);

	mov	esi, DWORD PTR _a$10[esp+52]
	mov	eax, esi
	sar	eax, 23					; 00000017H

; 85   :     int r			= (((u32)(a) << 8) | (1U << 31)) >> exponent;

	mov	edi, esi
	movzx	eax, al
	or	edi, -8388608				; ff800000H
	sub	ecx, eax
	shl	edi, 8
	shr	edi, cl

; 86   :     exponent		+= 31-127;
; 87   :     {
; 88   :         int imask	=	(!(((( (1<<(exponent)))-1)>>8)&a));

	mov	eax, 1
	sub	ecx, 96					; 00000060H

; 89   :         exponent	-=	(31-127)+32;
; 90   :         exponent	>>=	31;
; 91   :         a			>>=	31;

	mov	edx, esi
	shl	eax, cl
	dec	eax
	sar	edx, 31					; 0000001fH
	sar	eax, 8
	and	eax, esi
	neg	eax
	sbb	eax, eax
	inc	eax
	and	eax, edx

; 92   :         r			-=	(imask&a);

	sub	edi, eax
	lea	eax, DWORD PTR [ecx+64]
	sar	eax, 31					; 0000001fH

; 93   :         r			&=	exponent;

	and	edi, eax
	xor	edi, edx
; File I:\Vitalya\mine\NSProjectX\xrCore\vector.h

; 92   : 	if( val<_low ) val = _low; else if( val>_high ) val = _high;

	cmp	edi, -32768				; ffff8000H
	jge	SHORT $LN77@hw_Load
	mov	edi, -32768				; ffff8000H
	jmp	SHORT $LN79@hw_Load
$LN77@hw_Load:
	cmp	edi, 32767				; 00007fffH
	mov	eax, 32767				; 00007fffH
	cmovg	edi, eax
$LN79@hw_Load:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_VS.cpp

; 83   : 					pV->v	=	QC(D.vertices[v].v);

	mov	eax, DWORD PTR _pV$8[esp+52]
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h

; 84   :     int exponent	= (127 + 31) - ((a >> 23) & 0xFF);

	mov	ecx, 158				; 0000009eH
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_VS.cpp

; 83   : 					pV->v	=	QC(D.vertices[v].v);

	mov	WORD PTR [eax+14], di

; 84   : 					pV->t	=	QC(vP.y/(D.bv_bb.max.y-D.bv_bb.min.y));

	mov	eax, DWORD PTR _vP$1$[esp+52]
	movss	xmm0, DWORD PTR [ebx+36]
	subss	xmm0, DWORD PTR [ebx+24]
	movss	xmm1, DWORD PTR [eax+4]
	divss	xmm1, xmm0

; 35   : 	int t=iFloor(v*float(quant)); clamp(t,-32768,32767);

	mulss	xmm1, xmm2
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h

; 83   :     int a			= *(const int*)(&x);

	movss	DWORD PTR _a$12[esp+52], xmm1

; 84   :     int exponent	= (127 + 31) - ((a >> 23) & 0xFF);

	mov	esi, DWORD PTR _a$12[esp+52]
	mov	eax, esi
	sar	eax, 23					; 00000017H

; 85   :     int r			= (((u32)(a) << 8) | (1U << 31)) >> exponent;

	mov	edi, esi
	movzx	eax, al
	or	edi, -8388608				; ff800000H
	sub	ecx, eax
	shl	edi, 8
	shr	edi, cl

; 86   :     exponent		+= 31-127;
; 87   :     {
; 88   :         int imask	=	(!(((( (1<<(exponent)))-1)>>8)&a));

	mov	eax, 1
	sub	ecx, 96					; 00000060H

; 89   :         exponent	-=	(31-127)+32;
; 90   :         exponent	>>=	31;
; 91   :         a			>>=	31;

	mov	edx, esi
	shl	eax, cl
	dec	eax
	sar	edx, 31					; 0000001fH
	sar	eax, 8
	and	eax, esi
	neg	eax
	sbb	eax, eax
	inc	eax
	and	eax, edx

; 92   :         r			-=	(imask&a);

	sub	edi, eax
	lea	eax, DWORD PTR [ecx+64]
	sar	eax, 31					; 0000001fH

; 93   :         r			&=	exponent;

	and	edi, eax
	xor	edi, edx
; File I:\Vitalya\mine\NSProjectX\xrCore\vector.h

; 92   : 	if( val<_low ) val = _low; else if( val>_high ) val = _high;

	cmp	edi, -32768				; ffff8000H
	jge	SHORT $LN86@hw_Load
	mov	edi, -32768				; ffff8000H
	jmp	SHORT $LN88@hw_Load
$LN86@hw_Load:
	cmp	edi, 32767				; 00007fffH
	mov	eax, 32767				; 00007fffH
	cmovg	edi, eax
$LN88@hw_Load:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_VS.cpp

; 84   : 					pV->t	=	QC(vP.y/(D.bv_bb.max.y-D.bv_bb.min.y));

	mov	eax, DWORD PTR _pV$8[esp+52]
	add	ebp, 20					; 00000014H

; 85   : 					pV->mid	=	short(mid);

	mov	edx, DWORD PTR _batch$1$[esp+52]
	mov	WORD PTR [eax+16], di
	mov	eax, DWORD PTR _pV$8[esp+52]
	lea	ecx, DWORD PTR [edx*4]
	mov	WORD PTR [eax+18], cx

; 86   : 					pV++;

	mov	eax, DWORD PTR _pV$8[esp+52]
	mov	ecx, DWORD PTR _v$1$[esp+52]
	add	eax, 20					; 00000014H
	inc	ecx
	mov	DWORD PTR _pV$8[esp+52], eax
	mov	DWORD PTR _v$1$[esp+52], ecx
	cmp	ecx, DWORD PTR [ebx+64]
	jb	$LL22@hw_Load
	mov	ebp, DWORD PTR _this$1$[esp+52]
$LN17@hw_Load:

; 73   : 			for (u32 batch=0; batch<hw_BatchSize; batch++)

	mov	ecx, DWORD PTR _batch$1$[esp+52]
	inc	ecx
	mov	DWORD PTR _batch$1$[esp+52], ecx
	cmp	ecx, DWORD PTR [ebp+701232]
	jb	$LL19@hw_Load
	mov	edx, DWORD PTR _o$1$[esp+52]
$LN14@hw_Load:

; 70   : 		for (o=0; o<objects.size(); o++)

	mov	ecx, DWORD PTR tv3114[esp+52]
	inc	edx
	add	ecx, 4
	mov	DWORD PTR _o$1$[esp+52], edx
	mov	DWORD PTR tv3114[esp+52], ecx
	cmp	edx, DWORD PTR [ebp+1392]
	jb	$LL16@hw_Load
$LN25@hw_Load:

; 87   : 				}
; 88   : 			}
; 89   : 		}
; 90   : 		R_CHK			(hw_VB->Unlock());

	mov	eax, DWORD PTR [ebp+701236]
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+48]
	cmp	BYTE PTR ?ignore_always@?BJ@??hw_Load@CDetailManager@@QAEXXZ@4_NA, 0
	mov	ebx, DWORD PTR __imp_?error@xrDebug@@QAEXJPBD0H0AA_N@Z
	jne	SHORT $LN23@hw_Load
	test	eax, eax
	jns	SHORT $LN23@hw_Load
	mov	ecx, DWORD PTR __imp_?Debug@@3VxrDebug@@A
	push	OFFSET ?ignore_always@?BJ@??hw_Load@CDetailManager@@QAEXXZ@4_NA
	push	OFFSET ??_C@_0BI@LGPMLEDD@CDetailManager?3?3hw_Load@
	push	90					; 0000005aH
	push	OFFSET ??_C@_0EA@DCNLPIGP@I?3?2Vitalya?2mine?2NSProjectX?2laye@
	push	OFFSET ??_C@_0BA@PDGMGFKF@hw_VB?9?$DOUnlock?$CI?$CJ@
	push	eax
	call	ebx
$LN23@hw_Load:

; 91   : 	}
; 92   : 
; 93   : 	// Fill IB
; 94   : 	{
; 95   : 		u16*			pI;
; 96   : 		R_CHK			(hw_IB->Lock(0,0,(void**)(&pI),0));

	mov	eax, DWORD PTR [ebp+701240]
	lea	edx, DWORD PTR _pI$9[esp+52]
	push	0
	push	edx
	push	0
	mov	ecx, DWORD PTR [eax]
	push	0
	push	eax
	call	DWORD PTR [ecx+44]
	cmp	BYTE PTR ?ignore_always@?BO@??hw_Load@CDetailManager@@QAEXXZ@4_NA, 0
	jne	SHORT $LN26@hw_Load
	test	eax, eax
	jns	SHORT $LN26@hw_Load
	mov	ecx, DWORD PTR __imp_?Debug@@3VxrDebug@@A
	push	OFFSET ?ignore_always@?BO@??hw_Load@CDetailManager@@QAEXXZ@4_NA
	push	OFFSET ??_C@_0BI@LGPMLEDD@CDetailManager?3?3hw_Load@
	push	96					; 00000060H
	push	OFFSET ??_C@_0EA@DCNLPIGP@I?3?2Vitalya?2mine?2NSProjectX?2laye@
	push	OFFSET ??_C@_0CB@OEKFILAI@hw_IB?9?$DOLock?$CI0?00?0?$CIvoid?$CK?$CK?$CJ?$CI?$CGpI?$CJ?00@
	push	eax
	call	ebx
$LN26@hw_Load:

; 97   : 		for (o=0; o<objects.size(); o++)

	xor	eax, eax
	mov	DWORD PTR _o$2$[esp+52], eax
	cmp	DWORD PTR [ebp+1392], eax
	jbe	$LN40@hw_Load
	mov	ecx, DWORD PTR _pI$9[esp+52]
	lea	edx, DWORD PTR [ebp+1136]
	mov	DWORD PTR tv3112[esp+52], edx
	npad	4
$LL31@hw_Load:

; 98   : 		{
; 99   : 			CDetail& D		=	*objects[o];

	mov	esi, DWORD PTR [edx]

; 100  : 			u16		offset	=	0;
; 101  : 			for (u32 batch=0; batch<hw_BatchSize; batch++)

	xor	ebx, ebx
	mov	DWORD PTR _offset$13[esp+52], 0
	cmp	DWORD PTR [ebp+701232], ebx
	jbe	SHORT $LN29@hw_Load
	mov	eax, DWORD PTR [esi+72]
	mov	di, WORD PTR _offset$13[esp+52]
	npad	4
$LL34@hw_Load:

; 102  : 			{
; 103  : 				for (u32 i=0; i<u32(D.number_indices); i++)

	xor	edx, edx
	test	eax, eax
	je	SHORT $LN490@hw_Load
$LL37@hw_Load:

; 104  : 					*pI++	=	u16(u16(D.indices[i]) + u16(offset));

	mov	eax, DWORD PTR [esi+68]
	mov	ax, WORD PTR [eax+edx*2]
	inc	edx
	add	ax, di
	mov	WORD PTR [ecx], ax
	mov	ecx, DWORD PTR _pI$9[esp+52]
	add	ecx, 2
	mov	DWORD PTR _pI$9[esp+52], ecx
	mov	eax, DWORD PTR [esi+72]
	cmp	edx, eax
	jb	SHORT $LL37@hw_Load
$LN490@hw_Load:

; 105  : 				offset		=	u16(offset+u16(D.number_vertices));

	add	di, WORD PTR [esi+64]
	inc	ebx
	cmp	ebx, DWORD PTR [ebp+701232]
	jb	SHORT $LL34@hw_Load
	mov	eax, DWORD PTR _o$2$[esp+52]
	mov	edx, DWORD PTR tv3112[esp+52]
$LN29@hw_Load:

; 97   : 		for (o=0; o<objects.size(); o++)

	inc	eax
	add	edx, 4
	mov	DWORD PTR _o$2$[esp+52], eax
	mov	DWORD PTR tv3112[esp+52], edx
	cmp	eax, DWORD PTR [ebp+1392]
	jb	SHORT $LL31@hw_Load
$LN40@hw_Load:

; 106  : 			}
; 107  : 		}
; 108  : 		R_CHK			(hw_IB->Unlock());

	mov	eax, DWORD PTR [ebp+701240]
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+48]
	cmp	BYTE PTR ?ignore_always@?CH@??hw_Load@CDetailManager@@QAEXXZ@4_NA, 0
	jne	SHORT $LN38@hw_Load
	test	eax, eax
	jns	SHORT $LN38@hw_Load
	mov	ecx, DWORD PTR __imp_?Debug@@3VxrDebug@@A
	push	OFFSET ?ignore_always@?CH@??hw_Load@CDetailManager@@QAEXXZ@4_NA
	push	OFFSET ??_C@_0BI@LGPMLEDD@CDetailManager?3?3hw_Load@
	push	108					; 0000006cH
	push	OFFSET ??_C@_0EA@DCNLPIGP@I?3?2Vitalya?2mine?2NSProjectX?2laye@
	push	OFFSET ??_C@_0BA@GABLBGEK@hw_IB?9?$DOUnlock?$CI?$CJ@
	push	eax
	call	DWORD PTR __imp_?error@xrDebug@@QAEXJPBD0H0AA_N@Z
$LN38@hw_Load:

; 112  : 	ref_shader		S;	S.create("details\\set");

	push	0
	push	0
	push	0
	push	OFFSET ??_C@_0M@LFGFJOHH@details?2set@
	lea	ecx, DWORD PTR _S$[esp+68]
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 61   : 						resptr_core		()												{	p_ = 0;						}

	mov	DWORD PTR _S$[esp+68], 0
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_VS.cpp

; 112  : 	ref_shader		S;	S.create("details\\set");

	call	DWORD PTR __imp_?create@resptrcode_shader@@QAEXPBD000@Z

; 113  : 	R_constant_table&	T0	= *(S->E[0]->passes[0]->constants);

	mov	eax, DWORD PTR _S$[esp+52]

; 114  : 	R_constant_table&	T1	= *(S->E[1]->passes[0]->constants);
; 115  : 	hwc_consts			= T0.get("consts");

	mov	ebx, DWORD PTR __imp_?get@R_constant_table@@QAE?AV?$resptr_core@UR_constant@@V?$resptr_base@UR_constant@@@@@@PBD@Z
	push	OFFSET ??_C@_06CJANOHJB@consts@
	mov	ecx, DWORD PTR [eax+8]
	mov	eax, DWORD PTR [eax+12]
	mov	ecx, DWORD PTR [ecx+12]
	mov	eax, DWORD PTR [eax+12]
	mov	ecx, DWORD PTR [ecx+20]
	mov	eax, DWORD PTR [eax+20]
	mov	DWORD PTR _T1$1$[esp+56], eax
	lea	eax, DWORD PTR $T7[esp+56]
	push	eax
	mov	DWORD PTR _T0$1$[esp+60], ecx
	call	ebx
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 47   : 	ICF		void		_set	(resptr_base<T> const & rhs)		{	T* prhs = rhs._get(); _set(prhs);															}

	mov	edi, DWORD PTR [eax]

; 46   : 	ICF		void		_set	(T * rhs) 							{	if (0!=rhs) rhs->dwReference++;	_dec(); p_ = rhs;											}

	test	edi, edi
	je	SHORT $LN112@hw_Load
	inc	DWORD PTR [edi]
$LN112@hw_Load:

; 44   : 	void				_dec	()									{	if (0==p_) return;	p_->dwReference--; if (0==p_->dwReference) xr_delete(p_);				}

	mov	eax, DWORD PTR [ebp+701244]
	mov	esi, DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
	test	eax, eax
	je	SHORT $LN119@hw_Load
	dec	DWORD PTR [eax]
	mov	ecx, DWORD PTR [ebp+701244]
	cmp	DWORD PTR [ecx], 0
	jne	SHORT $LN119@hw_Load
; File I:\Vitalya\mine\NSProjectX\xrCore\xrstring.h

; 50   : 	void				_dec		()								{	if (0==p_) return;	p_->dwReference--; 	if (0==p_->dwReference)	p_=0;						}

	mov	eax, DWORD PTR [ecx+4]
	test	eax, eax
	je	SHORT $LN132@hw_Load
	dec	DWORD PTR [eax]
	mov	eax, DWORD PTR [ecx+4]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN132@hw_Load
	mov	DWORD PTR [ecx+4], 0
$LN132@hw_Load:
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h

; 144  : 		Memory.mem_free	(ptr);

	push	DWORD PTR [ebp+701244]
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	esi
$LN119@hw_Load:
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 44   : 	void				_dec	()									{	if (0==p_) return;	p_->dwReference--; if (0==p_->dwReference) xr_delete(p_);				}

	mov	eax, DWORD PTR $T7[esp+52]

; 46   : 	ICF		void		_set	(T * rhs) 							{	if (0!=rhs) rhs->dwReference++;	_dec(); p_ = rhs;											}

	mov	DWORD PTR [ebp+701244], edi

; 44   : 	void				_dec	()									{	if (0==p_) return;	p_->dwReference--; if (0==p_->dwReference) xr_delete(p_);				}

	test	eax, eax
	je	SHORT $LN141@hw_Load
	dec	DWORD PTR [eax]
	mov	eax, DWORD PTR $T7[esp+52]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN141@hw_Load
; File I:\Vitalya\mine\NSProjectX\xrCore\xrstring.h

; 50   : 	void				_dec		()								{	if (0==p_) return;	p_->dwReference--; 	if (0==p_->dwReference)	p_=0;						}

	mov	ecx, DWORD PTR [eax+4]
	test	ecx, ecx
	je	SHORT $LN154@hw_Load
	dec	DWORD PTR [ecx]
	mov	ecx, DWORD PTR [eax+4]
	cmp	DWORD PTR [ecx], 0
	jne	SHORT $LN491@hw_Load
	mov	DWORD PTR [eax+4], 0
$LN491@hw_Load:
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h

; 144  : 		Memory.mem_free	(ptr);

	mov	eax, DWORD PTR $T7[esp+52]
$LN154@hw_Load:
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	esi
$LN141@hw_Load:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_VS.cpp

; 116  : 	hwc_wave			= T0.get("wave");

	mov	ecx, DWORD PTR _T0$1$[esp+52]
	lea	eax, DWORD PTR $T6[esp+52]
	push	OFFSET ??_C@_04LJEDCPFL@wave@
	push	eax
	call	ebx
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 47   : 	ICF		void		_set	(resptr_base<T> const & rhs)		{	T* prhs = rhs._get(); _set(prhs);															}

	mov	edi, DWORD PTR [eax]

; 46   : 	ICF		void		_set	(T * rhs) 							{	if (0!=rhs) rhs->dwReference++;	_dec(); p_ = rhs;											}

	test	edi, edi
	je	SHORT $LN161@hw_Load
	inc	DWORD PTR [edi]
$LN161@hw_Load:

; 44   : 	void				_dec	()									{	if (0==p_) return;	p_->dwReference--; if (0==p_->dwReference) xr_delete(p_);				}

	mov	eax, DWORD PTR [ebp+701248]
	test	eax, eax
	je	SHORT $LN168@hw_Load
	dec	DWORD PTR [eax]
	mov	ecx, DWORD PTR [ebp+701248]
	cmp	DWORD PTR [ecx], 0
	jne	SHORT $LN168@hw_Load
; File I:\Vitalya\mine\NSProjectX\xrCore\xrstring.h

; 50   : 	void				_dec		()								{	if (0==p_) return;	p_->dwReference--; 	if (0==p_->dwReference)	p_=0;						}

	mov	eax, DWORD PTR [ecx+4]
	test	eax, eax
	je	SHORT $LN181@hw_Load
	dec	DWORD PTR [eax]
	mov	eax, DWORD PTR [ecx+4]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN181@hw_Load
	mov	DWORD PTR [ecx+4], 0
$LN181@hw_Load:
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h

; 144  : 		Memory.mem_free	(ptr);

	push	DWORD PTR [ebp+701248]
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	esi
$LN168@hw_Load:
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 44   : 	void				_dec	()									{	if (0==p_) return;	p_->dwReference--; if (0==p_->dwReference) xr_delete(p_);				}

	mov	eax, DWORD PTR $T6[esp+52]

; 46   : 	ICF		void		_set	(T * rhs) 							{	if (0!=rhs) rhs->dwReference++;	_dec(); p_ = rhs;											}

	mov	DWORD PTR [ebp+701248], edi

; 44   : 	void				_dec	()									{	if (0==p_) return;	p_->dwReference--; if (0==p_->dwReference) xr_delete(p_);				}

	test	eax, eax
	je	SHORT $LN190@hw_Load
	dec	DWORD PTR [eax]
	mov	eax, DWORD PTR $T6[esp+52]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN190@hw_Load
; File I:\Vitalya\mine\NSProjectX\xrCore\xrstring.h

; 50   : 	void				_dec		()								{	if (0==p_) return;	p_->dwReference--; 	if (0==p_->dwReference)	p_=0;						}

	mov	ecx, DWORD PTR [eax+4]
	test	ecx, ecx
	je	SHORT $LN203@hw_Load
	dec	DWORD PTR [ecx]
	mov	ecx, DWORD PTR [eax+4]
	cmp	DWORD PTR [ecx], 0
	jne	SHORT $LN492@hw_Load
	mov	DWORD PTR [eax+4], 0
$LN492@hw_Load:
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h

; 144  : 		Memory.mem_free	(ptr);

	mov	eax, DWORD PTR $T6[esp+52]
$LN203@hw_Load:
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	esi
$LN190@hw_Load:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_VS.cpp

; 117  : 	hwc_wind			= T0.get("dir2D");

	mov	ecx, DWORD PTR _T0$1$[esp+52]
	lea	eax, DWORD PTR $T5[esp+52]
	push	OFFSET ??_C@_05DLLGNFME@dir2D@
	push	eax
	call	ebx
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 47   : 	ICF		void		_set	(resptr_base<T> const & rhs)		{	T* prhs = rhs._get(); _set(prhs);															}

	mov	edi, DWORD PTR [eax]

; 46   : 	ICF		void		_set	(T * rhs) 							{	if (0!=rhs) rhs->dwReference++;	_dec(); p_ = rhs;											}

	test	edi, edi
	je	SHORT $LN210@hw_Load
	inc	DWORD PTR [edi]
$LN210@hw_Load:

; 44   : 	void				_dec	()									{	if (0==p_) return;	p_->dwReference--; if (0==p_->dwReference) xr_delete(p_);				}

	mov	eax, DWORD PTR [ebp+701252]
	test	eax, eax
	je	SHORT $LN217@hw_Load
	dec	DWORD PTR [eax]
	mov	ecx, DWORD PTR [ebp+701252]
	cmp	DWORD PTR [ecx], 0
	jne	SHORT $LN217@hw_Load
; File I:\Vitalya\mine\NSProjectX\xrCore\xrstring.h

; 50   : 	void				_dec		()								{	if (0==p_) return;	p_->dwReference--; 	if (0==p_->dwReference)	p_=0;						}

	mov	eax, DWORD PTR [ecx+4]
	test	eax, eax
	je	SHORT $LN230@hw_Load
	dec	DWORD PTR [eax]
	mov	eax, DWORD PTR [ecx+4]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN230@hw_Load
	mov	DWORD PTR [ecx+4], 0
$LN230@hw_Load:
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h

; 144  : 		Memory.mem_free	(ptr);

	push	DWORD PTR [ebp+701252]
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	esi
$LN217@hw_Load:
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 44   : 	void				_dec	()									{	if (0==p_) return;	p_->dwReference--; if (0==p_->dwReference) xr_delete(p_);				}

	mov	eax, DWORD PTR $T5[esp+52]

; 46   : 	ICF		void		_set	(T * rhs) 							{	if (0!=rhs) rhs->dwReference++;	_dec(); p_ = rhs;											}

	mov	DWORD PTR [ebp+701252], edi

; 44   : 	void				_dec	()									{	if (0==p_) return;	p_->dwReference--; if (0==p_->dwReference) xr_delete(p_);				}

	test	eax, eax
	je	SHORT $LN239@hw_Load
	dec	DWORD PTR [eax]
	mov	eax, DWORD PTR $T5[esp+52]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN239@hw_Load
; File I:\Vitalya\mine\NSProjectX\xrCore\xrstring.h

; 50   : 	void				_dec		()								{	if (0==p_) return;	p_->dwReference--; 	if (0==p_->dwReference)	p_=0;						}

	mov	ecx, DWORD PTR [eax+4]
	test	ecx, ecx
	je	SHORT $LN252@hw_Load
	dec	DWORD PTR [ecx]
	mov	ecx, DWORD PTR [eax+4]
	cmp	DWORD PTR [ecx], 0
	jne	SHORT $LN493@hw_Load
	mov	DWORD PTR [eax+4], 0
$LN493@hw_Load:
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h

; 144  : 		Memory.mem_free	(ptr);

	mov	eax, DWORD PTR $T5[esp+52]
$LN252@hw_Load:
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	esi
$LN239@hw_Load:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_VS.cpp

; 118  : 	hwc_array			= T0.get("array");

	mov	ecx, DWORD PTR _T0$1$[esp+52]
	lea	eax, DWORD PTR $T4[esp+52]
	push	OFFSET ??_C@_05HIFJDKLD@array@
	push	eax
	call	ebx
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 47   : 	ICF		void		_set	(resptr_base<T> const & rhs)		{	T* prhs = rhs._get(); _set(prhs);															}

	mov	edi, DWORD PTR [eax]

; 46   : 	ICF		void		_set	(T * rhs) 							{	if (0!=rhs) rhs->dwReference++;	_dec(); p_ = rhs;											}

	test	edi, edi
	je	SHORT $LN259@hw_Load
	inc	DWORD PTR [edi]
$LN259@hw_Load:

; 44   : 	void				_dec	()									{	if (0==p_) return;	p_->dwReference--; if (0==p_->dwReference) xr_delete(p_);				}

	mov	eax, DWORD PTR [ebp+701256]
	test	eax, eax
	je	SHORT $LN266@hw_Load
	dec	DWORD PTR [eax]
	mov	ecx, DWORD PTR [ebp+701256]
	cmp	DWORD PTR [ecx], 0
	jne	SHORT $LN266@hw_Load
; File I:\Vitalya\mine\NSProjectX\xrCore\xrstring.h

; 50   : 	void				_dec		()								{	if (0==p_) return;	p_->dwReference--; 	if (0==p_->dwReference)	p_=0;						}

	mov	eax, DWORD PTR [ecx+4]
	test	eax, eax
	je	SHORT $LN279@hw_Load
	dec	DWORD PTR [eax]
	mov	eax, DWORD PTR [ecx+4]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN279@hw_Load
	mov	DWORD PTR [ecx+4], 0
$LN279@hw_Load:
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h

; 144  : 		Memory.mem_free	(ptr);

	push	DWORD PTR [ebp+701256]
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	esi
$LN266@hw_Load:
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 44   : 	void				_dec	()									{	if (0==p_) return;	p_->dwReference--; if (0==p_->dwReference) xr_delete(p_);				}

	mov	eax, DWORD PTR $T4[esp+52]

; 46   : 	ICF		void		_set	(T * rhs) 							{	if (0!=rhs) rhs->dwReference++;	_dec(); p_ = rhs;											}

	mov	DWORD PTR [ebp+701256], edi

; 44   : 	void				_dec	()									{	if (0==p_) return;	p_->dwReference--; if (0==p_->dwReference) xr_delete(p_);				}

	test	eax, eax
	je	SHORT $LN288@hw_Load
	dec	DWORD PTR [eax]
	mov	eax, DWORD PTR $T4[esp+52]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN288@hw_Load
; File I:\Vitalya\mine\NSProjectX\xrCore\xrstring.h

; 50   : 	void				_dec		()								{	if (0==p_) return;	p_->dwReference--; 	if (0==p_->dwReference)	p_=0;						}

	mov	ecx, DWORD PTR [eax+4]
	test	ecx, ecx
	je	SHORT $LN301@hw_Load
	dec	DWORD PTR [ecx]
	mov	ecx, DWORD PTR [eax+4]
	cmp	DWORD PTR [ecx], 0
	jne	SHORT $LN494@hw_Load
	mov	DWORD PTR [eax+4], 0
$LN494@hw_Load:
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h

; 144  : 		Memory.mem_free	(ptr);

	mov	eax, DWORD PTR $T4[esp+52]
$LN301@hw_Load:
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	esi
$LN288@hw_Load:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_VS.cpp

; 119  : 	hwc_s_consts		= T1.get("consts");

	mov	ecx, DWORD PTR _T1$1$[esp+52]
	lea	eax, DWORD PTR $T3[esp+52]
	push	OFFSET ??_C@_06CJANOHJB@consts@
	push	eax
	call	ebx
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 47   : 	ICF		void		_set	(resptr_base<T> const & rhs)		{	T* prhs = rhs._get(); _set(prhs);															}

	mov	edi, DWORD PTR [eax]

; 46   : 	ICF		void		_set	(T * rhs) 							{	if (0!=rhs) rhs->dwReference++;	_dec(); p_ = rhs;											}

	test	edi, edi
	je	SHORT $LN308@hw_Load
	inc	DWORD PTR [edi]
$LN308@hw_Load:

; 44   : 	void				_dec	()									{	if (0==p_) return;	p_->dwReference--; if (0==p_->dwReference) xr_delete(p_);				}

	mov	eax, DWORD PTR [ebp+701260]
	test	eax, eax
	je	SHORT $LN315@hw_Load
	dec	DWORD PTR [eax]
	mov	ecx, DWORD PTR [ebp+701260]
	cmp	DWORD PTR [ecx], 0
	jne	SHORT $LN315@hw_Load
; File I:\Vitalya\mine\NSProjectX\xrCore\xrstring.h

; 50   : 	void				_dec		()								{	if (0==p_) return;	p_->dwReference--; 	if (0==p_->dwReference)	p_=0;						}

	mov	eax, DWORD PTR [ecx+4]
	test	eax, eax
	je	SHORT $LN328@hw_Load
	dec	DWORD PTR [eax]
	mov	eax, DWORD PTR [ecx+4]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN328@hw_Load
	mov	DWORD PTR [ecx+4], 0
$LN328@hw_Load:
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h

; 144  : 		Memory.mem_free	(ptr);

	push	DWORD PTR [ebp+701260]
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	esi
$LN315@hw_Load:
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 44   : 	void				_dec	()									{	if (0==p_) return;	p_->dwReference--; if (0==p_->dwReference) xr_delete(p_);				}

	mov	eax, DWORD PTR $T3[esp+52]

; 46   : 	ICF		void		_set	(T * rhs) 							{	if (0!=rhs) rhs->dwReference++;	_dec(); p_ = rhs;											}

	mov	DWORD PTR [ebp+701260], edi

; 44   : 	void				_dec	()									{	if (0==p_) return;	p_->dwReference--; if (0==p_->dwReference) xr_delete(p_);				}

	test	eax, eax
	je	SHORT $LN337@hw_Load
	dec	DWORD PTR [eax]
	mov	eax, DWORD PTR $T3[esp+52]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN337@hw_Load
; File I:\Vitalya\mine\NSProjectX\xrCore\xrstring.h

; 50   : 	void				_dec		()								{	if (0==p_) return;	p_->dwReference--; 	if (0==p_->dwReference)	p_=0;						}

	mov	ecx, DWORD PTR [eax+4]
	test	ecx, ecx
	je	SHORT $LN350@hw_Load
	dec	DWORD PTR [ecx]
	mov	ecx, DWORD PTR [eax+4]
	cmp	DWORD PTR [ecx], 0
	jne	SHORT $LN495@hw_Load
	mov	DWORD PTR [eax+4], 0
$LN495@hw_Load:
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h

; 144  : 		Memory.mem_free	(ptr);

	mov	eax, DWORD PTR $T3[esp+52]
$LN350@hw_Load:
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	esi
$LN337@hw_Load:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_VS.cpp

; 120  : 	hwc_s_xform			= T1.get("xform");

	mov	ecx, DWORD PTR _T1$1$[esp+52]
	lea	eax, DWORD PTR $T2[esp+52]
	push	OFFSET ??_C@_05FLFNBNJM@xform@
	push	eax
	call	ebx
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 47   : 	ICF		void		_set	(resptr_base<T> const & rhs)		{	T* prhs = rhs._get(); _set(prhs);															}

	mov	edi, DWORD PTR [eax]

; 46   : 	ICF		void		_set	(T * rhs) 							{	if (0!=rhs) rhs->dwReference++;	_dec(); p_ = rhs;											}

	test	edi, edi
	je	SHORT $LN357@hw_Load
	inc	DWORD PTR [edi]
$LN357@hw_Load:

; 44   : 	void				_dec	()									{	if (0==p_) return;	p_->dwReference--; if (0==p_->dwReference) xr_delete(p_);				}

	mov	eax, DWORD PTR [ebp+701264]
	test	eax, eax
	je	SHORT $LN364@hw_Load
	dec	DWORD PTR [eax]
	mov	ecx, DWORD PTR [ebp+701264]
	cmp	DWORD PTR [ecx], 0
	jne	SHORT $LN364@hw_Load
; File I:\Vitalya\mine\NSProjectX\xrCore\xrstring.h

; 50   : 	void				_dec		()								{	if (0==p_) return;	p_->dwReference--; 	if (0==p_->dwReference)	p_=0;						}

	mov	eax, DWORD PTR [ecx+4]
	test	eax, eax
	je	SHORT $LN377@hw_Load
	dec	DWORD PTR [eax]
	mov	eax, DWORD PTR [ecx+4]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN377@hw_Load
	mov	DWORD PTR [ecx+4], 0
$LN377@hw_Load:
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h

; 144  : 		Memory.mem_free	(ptr);

	push	DWORD PTR [ebp+701264]
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	esi
$LN364@hw_Load:
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 44   : 	void				_dec	()									{	if (0==p_) return;	p_->dwReference--; if (0==p_->dwReference) xr_delete(p_);				}

	mov	eax, DWORD PTR $T2[esp+52]

; 46   : 	ICF		void		_set	(T * rhs) 							{	if (0!=rhs) rhs->dwReference++;	_dec(); p_ = rhs;											}

	mov	DWORD PTR [ebp+701264], edi

; 44   : 	void				_dec	()									{	if (0==p_) return;	p_->dwReference--; if (0==p_->dwReference) xr_delete(p_);				}

	test	eax, eax
	je	SHORT $LN386@hw_Load
	dec	DWORD PTR [eax]
	mov	eax, DWORD PTR $T2[esp+52]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN386@hw_Load
; File I:\Vitalya\mine\NSProjectX\xrCore\xrstring.h

; 50   : 	void				_dec		()								{	if (0==p_) return;	p_->dwReference--; 	if (0==p_->dwReference)	p_=0;						}

	mov	ecx, DWORD PTR [eax+4]
	test	ecx, ecx
	je	SHORT $LN399@hw_Load
	dec	DWORD PTR [ecx]
	mov	ecx, DWORD PTR [eax+4]
	cmp	DWORD PTR [ecx], 0
	jne	SHORT $LN496@hw_Load
	mov	DWORD PTR [eax+4], 0
$LN496@hw_Load:
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h

; 144  : 		Memory.mem_free	(ptr);

	mov	eax, DWORD PTR $T2[esp+52]
$LN399@hw_Load:
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	esi
$LN386@hw_Load:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_VS.cpp

; 121  : 	hwc_s_array			= T1.get("array");

	mov	ecx, DWORD PTR _T1$1$[esp+52]
	lea	eax, DWORD PTR $T1[esp+52]
	push	OFFSET ??_C@_05HIFJDKLD@array@
	push	eax
	call	ebx
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 47   : 	ICF		void		_set	(resptr_base<T> const & rhs)		{	T* prhs = rhs._get(); _set(prhs);															}

	mov	edi, DWORD PTR [eax]

; 46   : 	ICF		void		_set	(T * rhs) 							{	if (0!=rhs) rhs->dwReference++;	_dec(); p_ = rhs;											}

	test	edi, edi
	je	SHORT $LN406@hw_Load
	inc	DWORD PTR [edi]
$LN406@hw_Load:

; 44   : 	void				_dec	()									{	if (0==p_) return;	p_->dwReference--; if (0==p_->dwReference) xr_delete(p_);				}

	mov	eax, DWORD PTR [ebp+701268]
	test	eax, eax
	je	SHORT $LN413@hw_Load
	dec	DWORD PTR [eax]
	mov	ecx, DWORD PTR [ebp+701268]
	cmp	DWORD PTR [ecx], 0
	jne	SHORT $LN413@hw_Load
; File I:\Vitalya\mine\NSProjectX\xrCore\xrstring.h

; 50   : 	void				_dec		()								{	if (0==p_) return;	p_->dwReference--; 	if (0==p_->dwReference)	p_=0;						}

	mov	eax, DWORD PTR [ecx+4]
	test	eax, eax
	je	SHORT $LN426@hw_Load
	dec	DWORD PTR [eax]
	mov	eax, DWORD PTR [ecx+4]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN426@hw_Load
	mov	DWORD PTR [ecx+4], 0
$LN426@hw_Load:
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h

; 144  : 		Memory.mem_free	(ptr);

	push	DWORD PTR [ebp+701268]
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	esi
$LN413@hw_Load:
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 44   : 	void				_dec	()									{	if (0==p_) return;	p_->dwReference--; if (0==p_->dwReference) xr_delete(p_);				}

	mov	eax, DWORD PTR $T1[esp+52]

; 46   : 	ICF		void		_set	(T * rhs) 							{	if (0!=rhs) rhs->dwReference++;	_dec(); p_ = rhs;											}

	mov	DWORD PTR [ebp+701268], edi

; 44   : 	void				_dec	()									{	if (0==p_) return;	p_->dwReference--; if (0==p_->dwReference) xr_delete(p_);				}

	pop	edi
	pop	ebx
	test	eax, eax
	je	SHORT $LN435@hw_Load
	dec	DWORD PTR [eax]
	mov	eax, DWORD PTR $T1[esp+44]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN435@hw_Load
; File I:\Vitalya\mine\NSProjectX\xrCore\xrstring.h

; 50   : 	void				_dec		()								{	if (0==p_) return;	p_->dwReference--; 	if (0==p_->dwReference)	p_=0;						}

	mov	ecx, DWORD PTR [eax+4]
	test	ecx, ecx
	je	SHORT $LN448@hw_Load
	dec	DWORD PTR [ecx]
	mov	ecx, DWORD PTR [eax+4]
	cmp	DWORD PTR [ecx], 0
	jne	SHORT $LN497@hw_Load
	mov	DWORD PTR [eax+4], 0
$LN497@hw_Load:
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h

; 144  : 		Memory.mem_free	(ptr);

	mov	eax, DWORD PTR $T1[esp+44]
$LN448@hw_Load:
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	esi
$LN435@hw_Load:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_VS.cpp

; 124  : 	hw_Geom.create		(dwDecl, hw_VB, hw_IB);

	push	DWORD PTR [ebp+701240]
	lea	ecx, DWORD PTR [ebp+701228]
	push	DWORD PTR [ebp+701236]
	push	OFFSET ?dwDecl@@3PAU_D3DVERTEXELEMENT9@@A
	call	DWORD PTR __imp_?create@resptrcode_geom@@QAEXPAU_D3DVERTEXELEMENT9@@PAUIDirect3DVertexBuffer9@@PAUIDirect3DIndexBuffer9@@@Z
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 64   : 						~resptr_core	()												{	_dec();						}

	lea	ecx, DWORD PTR _S$[esp+44]
	call	DWORD PTR __imp_?_dec@?$resptr_base@UShader@@@@IAEXXZ
	pop	esi
	pop	ebp
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_VS.cpp

; 125  : }

	add	esp, 36					; 00000024H
	ret	0
?hw_Load@CDetailManager@@QAEXXZ ENDP			; CDetailManager::hw_Load
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_VS.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_VS.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h
; File I:\Vitalya\mine\NSProjectX\xrCore\vector.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_VS.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\vector.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_VS.cpp
_TEXT	SEGMENT
_a$1 = 8						; size = 4
_v$ = 8							; size = 4
?QC@@YAFM@Z PROC					; QC

; 35   : 	int t=iFloor(v*float(quant)); clamp(t,-32768,32767);

	movss	xmm0, DWORD PTR _v$[esp-4]
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h

; 84   :     int exponent	= (127 + 31) - ((a >> 23) & 0xFF);

	mov	ecx, 158				; 0000009eH
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_VS.cpp

; 35   : 	int t=iFloor(v*float(quant)); clamp(t,-32768,32767);

	mulss	xmm0, DWORD PTR __real@46800000
	push	esi
	push	edi
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h

; 83   :     int a			= *(const int*)(&x);

	movss	DWORD PTR _a$1[esp+4], xmm0

; 84   :     int exponent	= (127 + 31) - ((a >> 23) & 0xFF);

	mov	esi, DWORD PTR _a$1[esp+4]
	mov	eax, esi
	sar	eax, 23					; 00000017H

; 85   :     int r			= (((u32)(a) << 8) | (1U << 31)) >> exponent;

	mov	edi, esi
	movzx	eax, al
	or	edi, -8388608				; ff800000H
	sub	ecx, eax
	shl	edi, 8
	shr	edi, cl

; 86   :     exponent		+= 31-127;
; 87   :     {
; 88   :         int imask	=	(!(((( (1<<(exponent)))-1)>>8)&a));

	mov	eax, 1
	sub	ecx, 96					; 00000060H

; 89   :         exponent	-=	(31-127)+32;
; 90   :         exponent	>>=	31;
; 91   :         a			>>=	31;

	mov	edx, esi
	shl	eax, cl
	dec	eax
	sar	edx, 31					; 0000001fH
	sar	eax, 8
	and	eax, esi
	neg	eax
	sbb	eax, eax
	inc	eax
	and	eax, edx

; 92   :         r			-=	(imask&a);

	sub	edi, eax
	lea	eax, DWORD PTR [ecx+64]
	sar	eax, 31					; 0000001fH

; 93   :         r			&=	exponent;

	and	edi, eax
	xor	edi, edx
; File I:\Vitalya\mine\NSProjectX\xrCore\vector.h

; 92   : 	if( val<_low ) val = _low; else if( val>_high ) val = _high;

	cmp	edi, -32768				; ffff8000H
	jge	SHORT $LN6@QC
	pop	edi
	mov	eax, -32768				; ffff8000H
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_VS.cpp

; 37   : }

	pop	esi
	ret	0
$LN6@QC:
; File I:\Vitalya\mine\NSProjectX\xrCore\vector.h

; 92   : 	if( val<_low ) val = _low; else if( val>_high ) val = _high;

	mov	eax, 32767				; 00007fffH
	cmp	edi, eax
	cmovg	edi, eax
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_VS.cpp

; 36   : 	return short(t&0xffff);

	mov	ax, di
	pop	edi

; 37   : }

	pop	esi
	ret	0
?QC@@YAFM@Z ENDP					; QC
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_VS.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_VS.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_VS.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_VS.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_VS.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_VS.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_VS.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\FixedVector.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_VS.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\FixedVector.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_VS.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_VS.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_VS.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector4.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_VS.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector4.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_VS.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector4.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_VS.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector4.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_VS.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector4.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_VS.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector4.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_VS.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector4.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector4.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector4.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector4.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_VS.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_VS.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_VS.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector4.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector4.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector4.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_VS.cpp
; File I:\Vitalya\mine\NSProjectX\xrEngine\R_Backend.h
; File I:\Vitalya\mine\NSProjectX\xrEngine\r_constants_cache.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_VS.cpp
; File I:\Vitalya\mine\NSProjectX\xrEngine\R_Backend_Runtime.h
; File I:\Vitalya\mine\NSProjectX\xrEngine\r_constants_cache.h
; File I:\Vitalya\mine\NSProjectX\xrEngine\R_Backend_Runtime.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_VS.cpp
; File I:\Vitalya\mine\NSProjectX\xrEngine\R_Backend.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_VS.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_VS.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_VS.cpp
; File I:\Vitalya\mine\NSProjectX\xrEngine\R_Backend.h
; File I:\Vitalya\mine\NSProjectX\xrEngine\r_constants_cache.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_VS.cpp
; File I:\Vitalya\mine\NSProjectX\xrEngine\R_Backend_Runtime.h
; File I:\Vitalya\mine\NSProjectX\xrEngine\r_constants_cache.h
; File I:\Vitalya\mine\NSProjectX\xrEngine\R_Backend_Runtime.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_VS.cpp
; File I:\Vitalya\mine\NSProjectX\xrEngine\R_Backend.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_VS.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xrstring.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_VS.cpp
_TEXT	SEGMENT
_vOffset$1$ = -88					; size = 4
_iOffset$1$ = -84					; size = 4
_Object$1$ = -80					; size = 4
tv1714 = -76						; size = 4
_this$1$ = -72						; size = 4
__vI$1$ = -68						; size = 4
_vis$1$ = -64						; size = 4
tv1611 = -60						; size = 4
_O$1$ = -56						; size = 4
tv1708 = -52						; size = 4
_c_hemi$$sroa$644$1$ = -48				; size = 4
tv1711 = -44						; size = 4
_c_sun$$sroa$650$1$ = -40				; size = 4
_c_hemi$$sroa$643$1$ = -36				; size = 4
tv1712 = -32						; size = 4
_c_sun$$sroa$649$1$ = -28				; size = 4
_c_hemi$$sroa$642$1$ = -24				; size = 4
tv1713 = -20						; size = 4
_c_sun$$sroa$648$1$ = -16				; size = 4
_dwCNT_prims$1$ = -12					; size = 4
_c_storage$1$ = -8					; size = 4
_dwCNT_prims$1$ = -4					; size = 4
__vE$1$ = -4						; size = 4
_x_array$ = 8						; size = 4
_c_base$1$ = 12						; size = 4
_var_id$ = 12						; size = 4
_lod_id$ = 16						; size = 4
_c_offset$dead$ = 20					; size = 4
?hw_Render_dump@CDetailManager@@QAEXV?$resptr_core@UR_constant@@V?$resptr_base@UR_constant@@@@@@III@Z PROC ; CDetailManager::hw_Render_dump
; _this$ = ecx

; 168  : {

	sub	esp, 88					; 00000058H

; 169  : 	Device.Statistic->RenderDUMP_DT_Count	= 0;

	mov	eax, DWORD PTR __imp_?Device@@3VCRenderDevice@@A
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 23   : 	ICF	SelfRef	set(T _x, T _y, T _z)					{ x = _x;		y = _y;		z = _z;		return *this;	};

	movss	xmm0, DWORD PTR __real@3f000000
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_VS.cpp

; 168  : {

	push	ebx
	push	esi

; 169  : 	Device.Statistic->RenderDUMP_DT_Count	= 0;

	mov	eax, DWORD PTR [eax+436]

; 170  : 
; 171  : 	// Matrices and offsets
; 172  : 	u32		vOffset	=	0;

	xor	esi, esi
	mov	DWORD PTR _this$1$[esp+96], ecx
	mov	DWORD PTR _vOffset$1$[esp+96], esi

; 173  : 	u32		iOffset	=	0;

	mov	DWORD PTR _iOffset$1$[esp+96], esi
	mov	DWORD PTR [eax+2488], 0

; 174  : 
; 175  : 	vis_list& list	=	m_visibles	[var_id];

	mov	eax, DWORD PTR _var_id$[esp+92]

; 184  : 	for (u32 O=0; O<objects.size(); O++){

	mov	DWORD PTR _O$1$[esp+96], esi
	lea	ebx, DWORD PTR [eax+eax*2]
	mov	eax, DWORD PTR __imp_?g_pGamePersistent@@3PAVIGame_Persistent@@A
	mov	DWORD PTR tv1611[esp+96], ebx
	mov	eax, DWORD PTR [eax]
	mov	eax, DWORD PTR [eax+1116]
	mov	eax, DWORD PTR [eax+440]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 23   : 	ICF	SelfRef	set(T _x, T _y, T _z)					{ x = _x;		y = _y;		z = _z;		return *this;	};

	movss	xmm1, DWORD PTR [eax+148]
	mulss	xmm1, xmm0
	movss	DWORD PTR _c_sun$$sroa$650$1$[esp+96], xmm1

; 40   : 	ICF SelfRef	mul(T s)								{ x*=s;		y*=s;		z*=s;			return *this;	};

	movss	xmm1, DWORD PTR [eax+152]
	mulss	xmm1, xmm0
	movss	DWORD PTR _c_sun$$sroa$649$1$[esp+96], xmm1
	movss	xmm1, DWORD PTR [eax+156]
	mulss	xmm1, xmm0

; 23   : 	ICF	SelfRef	set(T _x, T _y, T _z)					{ x = _x;		y = _y;		z = _z;		return *this;	};

	movss	xmm0, DWORD PTR [eax+120]
	movss	DWORD PTR tv1711[esp+96], xmm0
	movss	xmm0, DWORD PTR [eax+124]
	movss	DWORD PTR tv1712[esp+96], xmm0
	movss	xmm0, DWORD PTR [eax+128]
	movss	DWORD PTR tv1713[esp+96], xmm0
	movss	xmm0, DWORD PTR [eax+132]
	movss	DWORD PTR _c_hemi$$sroa$644$1$[esp+96], xmm0
	movss	xmm0, DWORD PTR [eax+136]
	movss	DWORD PTR _c_hemi$$sroa$643$1$[esp+96], xmm0
	movss	xmm0, DWORD PTR [eax+140]

; 40   : 	ICF SelfRef	mul(T s)								{ x*=s;		y*=s;		z*=s;			return *this;	};

	movss	DWORD PTR _c_sun$$sroa$648$1$[esp+96], xmm1

; 23   : 	ICF	SelfRef	set(T _x, T _y, T _z)					{ x = _x;		y = _y;		z = _z;		return *this;	};

	movss	DWORD PTR _c_hemi$$sroa$642$1$[esp+96], xmm0
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_VS.cpp

; 184  : 	for (u32 O=0; O<objects.size(); O++){

	cmp	DWORD PTR [ecx+1392], esi
	jbe	$LN207@hw_Render_

; 169  : 	Device.Statistic->RenderDUMP_DT_Count	= 0;

	push	ebp
	push	edi
	xor	edx, edx
	lea	edi, DWORD PTR [ecx+1136]
	mov	DWORD PTR tv1714[esp+104], edx
	mov	DWORD PTR tv1708[esp+104], edi
$LL4@hw_Render_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 119  :         _Ptr += _Off;

	mov	ecx, DWORD PTR [ecx+ebx*4+1396]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_VS.cpp

; 185  : 		CDetail&	Object				= *objects	[O];

	mov	edi, DWORD PTR [edi]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 119  :         _Ptr += _Off;

	add	ecx, edx
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_VS.cpp

; 185  : 		CDetail&	Object				= *objects	[O];

	mov	DWORD PTR _Object$1$[esp+104], edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 119  :         _Ptr += _Off;

	mov	DWORD PTR _vis$1$[esp+104], ecx

; 1531 :         return _My_data._Myfirst == _My_data._Mylast;

	mov	eax, DWORD PTR [ecx]
	cmp	eax, DWORD PTR [ecx+4]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_VS.cpp

; 187  : 		if (!vis.empty()){

	je	$LN159@hw_Render_

; 189  : 			RCache.set_Element				(Object.shader->E[lod_id]);

	mov	eax, DWORD PTR [edi+56]
	mov	ecx, DWORD PTR _lod_id$[esp+100]
	push	0
	lea	eax, DWORD PTR [eax+ecx*4]
	mov	ecx, DWORD PTR __imp_?RCache@@3VCBackend@@A
	add	eax, 8
	push	eax
	call	DWORD PTR __imp_?set_Element@CBackend@@QAEXAAV?$resptr_core@UShaderElement@@V?$resptr_base@UShaderElement@@@@@@I@Z

; 191  : 			u32			c_base				= x_array->vs.index;

	mov	eax, DWORD PTR _x_array$[esp+100]

; 192  : 			Fvector4*	c_storage			= RCache.get_ConstantCache_Vertex().get_array_f().access(c_base);
; 193  : 
; 194  : 			u32 dwBatch	= 0;

	xor	ebp, ebp
	movzx	ebx, WORD PTR [eax+16]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	eax, DWORD PTR _vis$1$[esp+104]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_VS.cpp

; 191  : 			u32			c_base				= x_array->vs.index;

	mov	DWORD PTR _c_base$1$[esp+100], ebx
; File I:\Vitalya\mine\NSProjectX\xrCore\FixedVector.h

; 38   : 	IC reference		operator[] (u32 id)			{ VERIFY(id<count); return array[id];	}

	add	ebx, 296				; 00000128H
	shl	ebx, 4
	add	ebx, DWORD PTR __imp_?RCache@@3VCBackend@@A
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	ecx, DWORD PTR [eax+4]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_VS.cpp

; 189  : 			RCache.set_Element				(Object.shader->E[lod_id]);

	mov	eax, DWORD PTR [eax]
; File I:\Vitalya\mine\NSProjectX\xrCore\FixedVector.h

; 38   : 	IC reference		operator[] (u32 id)			{ VERIFY(id<count); return array[id];	}

	mov	DWORD PTR _c_storage$1$[esp+104], ebx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	DWORD PTR __vE$1$[esp+104], ecx
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_VS.cpp

; 189  : 			RCache.set_Element				(Object.shader->E[lod_id]);

	mov	DWORD PTR __vI$1$[esp+104], eax

; 198  : 			for (; _vI!=_vE; _vI++){

	cmp	eax, ecx
	je	$LN206@hw_Render_
$LL7@hw_Render_:

; 199  : 				SlotItemVec*	items		= *_vI;

	mov	esi, DWORD PTR [eax]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	edi, DWORD PTR [esi+4]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_VS.cpp

; 202  : 				for (; _iI!=_iE; _iI++){

	mov	esi, DWORD PTR [esi]
	cmp	esi, edi
	je	$LN5@hw_Render_
	npad	9
$LL10@hw_Render_:

; 203  : 					SlotItem&	Instance	= **_iI;

	mov	ecx, DWORD PTR [esi]

; 204  : 					u32			base		= dwBatch*4;

	lea	edx, DWORD PTR [ebp*4]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 137  : 		x += d.x*m;

	movss	xmm5, DWORD PTR _c_hemi$$sroa$644$1$[esp+104]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_VS.cpp

; 209  : 					c_storage[base+0].set	(M._11*scale,	M._21*scale,	M._31*scale,	M._41	);

	mov	eax, edx
	add	eax, eax

; 221  : #else
; 222  : 					// R2 only needs hemisphere
; 223  : 					float		h			= Instance.c_hemi;
; 224  : 					float		s			= Instance.c_sun;
; 225  : 					c_storage[base+3].set	(s,				s,				s,				h		);
; 226  : #endif
; 227  : 					dwBatch	++;

	inc	ebp
	movss	xmm4, DWORD PTR [ecx+4]
	movss	xmm1, DWORD PTR [ecx+56]
	movaps	xmm3, xmm4
	mulss	xmm3, DWORD PTR [ecx+24]
	movaps	xmm2, xmm4
	mulss	xmm2, DWORD PTR [ecx+40]
	movaps	xmm0, xmm4
	mulss	xmm0, DWORD PTR [ecx+8]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector4.h

; 17   : 	IC	SelfRef 	set(T _x, T _y, T _z, T _w=1)		{ x=_x;		y=_y;		z=_z;		w=_w;		return *this; }

	movss	DWORD PTR [ebx+eax*8+12], xmm1
	movss	DWORD PTR [ebx+eax*8+8], xmm2
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_VS.cpp

; 210  : 					c_storage[base+1].set	(M._12*scale,	M._22*scale,	M._32*scale,	M._42	);

	movaps	xmm2, xmm4
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector4.h

; 17   : 	IC	SelfRef 	set(T _x, T _y, T _z, T _w=1)		{ x=_x;		y=_y;		z=_z;		w=_w;		return *this; }

	movss	DWORD PTR [ebx+eax*8], xmm0
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_VS.cpp

; 210  : 					c_storage[base+1].set	(M._12*scale,	M._22*scale,	M._32*scale,	M._42	);

	movaps	xmm0, xmm4
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector4.h

; 17   : 	IC	SelfRef 	set(T _x, T _y, T _z, T _w=1)		{ x=_x;		y=_y;		z=_z;		w=_w;		return *this; }

	movss	DWORD PTR [ebx+eax*8+4], xmm3
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_VS.cpp

; 210  : 					c_storage[base+1].set	(M._12*scale,	M._22*scale,	M._32*scale,	M._42	);

	movaps	xmm3, xmm4
	mulss	xmm0, DWORD PTR [ecx+12]
	mulss	xmm2, DWORD PTR [ecx+44]
	mulss	xmm3, DWORD PTR [ecx+28]
	movss	xmm1, DWORD PTR [ecx+60]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector4.h

; 17   : 	IC	SelfRef 	set(T _x, T _y, T _z, T _w=1)		{ x=_x;		y=_y;		z=_z;		w=_w;		return *this; }

	movss	DWORD PTR [ebx+eax*8+16], xmm0
	movss	DWORD PTR [ebx+eax*8+28], xmm1
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_VS.cpp

; 211  : 					c_storage[base+2].set	(M._13*scale,	M._23*scale,	M._33*scale,	M._43	);

	movaps	xmm1, xmm4
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector4.h

; 17   : 	IC	SelfRef 	set(T _x, T _y, T _z, T _w=1)		{ x=_x;		y=_y;		z=_z;		w=_w;		return *this; }

	movss	DWORD PTR [ebx+eax*8+24], xmm2
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_VS.cpp

; 211  : 					c_storage[base+2].set	(M._13*scale,	M._23*scale,	M._33*scale,	M._43	);

	movaps	xmm2, xmm4
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector4.h

; 17   : 	IC	SelfRef 	set(T _x, T _y, T _z, T _w=1)		{ x=_x;		y=_y;		z=_z;		w=_w;		return *this; }

	movss	DWORD PTR [ebx+eax*8+20], xmm3
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_VS.cpp

; 211  : 					c_storage[base+2].set	(M._13*scale,	M._23*scale,	M._33*scale,	M._43	);

	lea	eax, DWORD PTR [edx+2]
	mulss	xmm1, DWORD PTR [ecx+48]
	shl	eax, 4
	mulss	xmm4, DWORD PTR [ecx+16]
	add	eax, ebx
	mulss	xmm2, DWORD PTR [ecx+32]
	movss	xmm0, DWORD PTR [ecx+64]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector4.h

; 17   : 	IC	SelfRef 	set(T _x, T _y, T _z, T _w=1)		{ x=_x;		y=_y;		z=_z;		w=_w;		return *this; }

	movss	DWORD PTR [eax+12], xmm0
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 137  : 		x += d.x*m;

	movss	xmm0, DWORD PTR _c_sun$$sroa$650$1$[esp+104]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector4.h

; 17   : 	IC	SelfRef 	set(T _x, T _y, T _z, T _w=1)		{ x=_x;		y=_y;		z=_z;		w=_w;		return *this; }

	movss	DWORD PTR [eax], xmm4
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 138  : 		y += d.y*m;

	movss	xmm4, DWORD PTR _c_hemi$$sroa$643$1$[esp+104]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector4.h

; 17   : 	IC	SelfRef 	set(T _x, T _y, T _z, T _w=1)		{ x=_x;		y=_y;		z=_z;		w=_w;		return *this; }

	movss	DWORD PTR [eax+8], xmm1
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 139  : 		z += d.z*m;

	movss	xmm1, DWORD PTR _c_hemi$$sroa$642$1$[esp+104]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector4.h

; 17   : 	IC	SelfRef 	set(T _x, T _y, T _z, T _w=1)		{ x=_x;		y=_y;		z=_z;		w=_w;		return *this; }

	movss	DWORD PTR [eax+4], xmm2
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_VS.cpp

; 220  : 					c_storage[base+3].set	(C.x,			C.y,			C.z,			1.f		);

	lea	eax, DWORD PTR [edx+3]
	movss	xmm2, DWORD PTR [ecx+76]
	movss	xmm3, DWORD PTR [ecx+80]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 137  : 		x += d.x*m;

	mulss	xmm5, xmm2
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_VS.cpp

; 220  : 					c_storage[base+3].set	(C.x,			C.y,			C.z,			1.f		);

	shl	eax, 4
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 137  : 		x += d.x*m;

	mulss	xmm0, xmm3
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_VS.cpp

; 220  : 					c_storage[base+3].set	(C.x,			C.y,			C.z,			1.f		);

	add	eax, ebx
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 137  : 		x += d.x*m;

	addss	xmm5, DWORD PTR tv1711[esp+104]

; 138  : 		y += d.y*m;

	mulss	xmm4, xmm2
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector4.h

; 17   : 	IC	SelfRef 	set(T _x, T _y, T _z, T _w=1)		{ x=_x;		y=_y;		z=_z;		w=_w;		return *this; }

	mov	DWORD PTR [eax+12], 1065353216		; 3f800000H
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 139  : 		z += d.z*m;

	mulss	xmm1, xmm2
	addss	xmm4, DWORD PTR tv1712[esp+104]

; 137  : 		x += d.x*m;

	addss	xmm5, xmm0

; 138  : 		y += d.y*m;

	movss	xmm0, DWORD PTR _c_sun$$sroa$649$1$[esp+104]

; 139  : 		z += d.z*m;

	addss	xmm1, DWORD PTR tv1713[esp+104]

; 138  : 		y += d.y*m;

	mulss	xmm0, xmm3
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector4.h

; 17   : 	IC	SelfRef 	set(T _x, T _y, T _z, T _w=1)		{ x=_x;		y=_y;		z=_z;		w=_w;		return *this; }

	movss	DWORD PTR [eax], xmm5
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 138  : 		y += d.y*m;

	addss	xmm4, xmm0

; 139  : 		z += d.z*m;

	movss	xmm0, DWORD PTR _c_sun$$sroa$648$1$[esp+104]
	mulss	xmm0, xmm3
	addss	xmm1, xmm0
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector4.h

; 17   : 	IC	SelfRef 	set(T _x, T _y, T _z, T _w=1)		{ x=_x;		y=_y;		z=_z;		w=_w;		return *this; }

	movss	DWORD PTR [eax+4], xmm4
	movss	DWORD PTR [eax+8], xmm1
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_VS.cpp

; 228  : 					if (dwBatch == hw_BatchSize)	{

	mov	eax, DWORD PTR _this$1$[esp+104]
	cmp	ebp, DWORD PTR [eax+701232]
	jne	$LN8@hw_Render_

; 229  : 						// flush
; 230  : 						Device.Statistic->RenderDUMP_DT_Count					+=	dwBatch;

	mov	eax, DWORD PTR __imp_?Device@@3VCRenderDevice@@A
	mov	eax, DWORD PTR [eax+436]
	add	DWORD PTR [eax+2488], ebp

; 231  : 						u32 dwCNT_verts			= dwBatch * Object.number_vertices;

	mov	eax, DWORD PTR _Object$1$[esp+104]

; 232  : 						u32 dwCNT_prims			= (dwBatch * Object.number_indices)/3;

	mov	ecx, DWORD PTR [eax+72]
	mov	ebx, DWORD PTR [eax+64]
	mov	eax, -1431655765			; aaaaaaabH
	imul	ecx, ebp
	imul	ebx, ebp
	mul	ecx

; 233  : 						RCache.get_ConstantCache_Vertex().b_dirty				=	TRUE;

	mov	eax, DWORD PTR __imp_?RCache@@3VCBackend@@A
	mov	ecx, edx
	shr	ecx, 1
	mov	DWORD PTR _dwCNT_prims$1$[esp+104], ecx
	mov	DWORD PTR [eax+8848], 1

; 234  : 						RCache.get_ConstantCache_Vertex().get_array_f().dirty	(c_base,c_base+dwBatch*4);

	mov	eax, DWORD PTR _c_base$1$[esp+100]
	lea	edx, DWORD PTR [eax+ebp*4]
; File I:\Vitalya\mine\NSProjectX\xrEngine\R_Backend.h

; 129  : 	IC	R_constant_array& get_ConstantCache_Vertex() { return constants.a_vertex; }

	mov	eax, DWORD PTR __imp_?RCache@@3VCBackend@@A
; File I:\Vitalya\mine\NSProjectX\xrEngine\r_constants_cache.h

; 21   : 	ICF void				dirty(u32 _lo, u32 _hi) { if (_lo < lo) lo = _lo; if (_hi > hi) hi = _hi; }

	mov	ebp, DWORD PTR _c_base$1$[esp+100]
	cmp	ebp, DWORD PTR [eax+8836]
	jae	SHORT $LN117@hw_Render_
	mov	DWORD PTR [eax+8836], ebp
$LN117@hw_Render_:
	cmp	edx, DWORD PTR [eax+8840]
	jbe	SHORT $LN118@hw_Render_
	mov	DWORD PTR [eax+8840], edx
$LN118@hw_Render_:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_VS.cpp

; 235  : 						RCache.Render			(D3DPT_TRIANGLELIST,vOffset, 0, dwCNT_verts,iOffset,dwCNT_prims);

	mov	eax, DWORD PTR __imp_?RCache@@3VCBackend@@A
; File I:\Vitalya\mine\NSProjectX\xrEngine\R_Backend_Runtime.h

; 201  : 	stat.polys += PC;

	add	DWORD PTR [eax+9016], ecx

; 202  : 	constants.flush();

	lea	ecx, DWORD PTR [eax+608]
	inc	DWORD PTR [eax+9024]
	add	DWORD PTR [eax+9020], ebx
; File I:\Vitalya\mine\NSProjectX\xrEngine\r_constants_cache.h

; 172  : 		if (a_pixel.b_dirty || a_vertex.b_dirty)	flush_cache();

	cmp	DWORD PTR [ecx+4112], 0
	jne	SHORT $LN124@hw_Render_
	cmp	DWORD PTR [ecx+8240], 0
	je	SHORT $LN123@hw_Render_
$LN124@hw_Render_:
	call	DWORD PTR __imp_?flush_cache@R_constants@@QAEXXZ
$LN123@hw_Render_:
; File I:\Vitalya\mine\NSProjectX\xrEngine\R_Backend_Runtime.h

; 203  : 	CHK_DX(HW.pDevice->DrawIndexedPrimitive(T, baseV, startV, countV, startI, PC));

	push	DWORD PTR _dwCNT_prims$1$[esp+104]
	mov	eax, DWORD PTR __imp_?HW@@3VCHW@@A
	push	DWORD PTR _iOffset$1$[esp+108]
	push	ebx
	mov	eax, DWORD PTR [eax+8]
	push	0
	push	DWORD PTR _vOffset$1$[esp+120]
	mov	ecx, DWORD PTR [eax]
	push	4
	push	eax
	call	DWORD PTR [ecx+328]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_VS.cpp

; 236  : 						RCache.stat.r.s_details.add	(dwCNT_verts);

	mov	eax, DWORD PTR __imp_?RCache@@3VCBackend@@A
; File I:\Vitalya\mine\NSProjectX\xrEngine\R_Backend.h

; 27   : 	ICF		void	add(u32 _verts) { verts += _verts; dips++; }

	add	DWORD PTR [eax+9072], ebx
	inc	DWORD PTR [eax+9076]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_VS.cpp

; 239  : 						dwBatch					= 0;

	xor	ebp, ebp
	mov	ebx, DWORD PTR _c_storage$1$[esp+104]
$LN8@hw_Render_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 74   :         ++_Ptr;

	add	esi, 4
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_VS.cpp

; 202  : 				for (; _iI!=_iE; _iI++){

	cmp	esi, edi
	jne	$LL10@hw_Render_
	mov	eax, DWORD PTR __vI$1$[esp+104]
	mov	ecx, DWORD PTR __vE$1$[esp+104]
$LN5@hw_Render_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 74   :         ++_Ptr;

	add	eax, 4
	mov	DWORD PTR __vI$1$[esp+104], eax
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_VS.cpp

; 198  : 			for (; _vI!=_vE; _vI++){

	cmp	eax, ecx
	jne	$LL7@hw_Render_

; 240  : 					}
; 241  : 				}
; 242  : 			}
; 243  : 			// flush if nessecary
; 244  : 			if (dwBatch)

	mov	edi, DWORD PTR _Object$1$[esp+104]
	test	ebp, ebp
	je	$LN209@hw_Render_

; 245  : 			{
; 246  : 				Device.Statistic->RenderDUMP_DT_Count	+= dwBatch;

	mov	eax, DWORD PTR __imp_?Device@@3VCRenderDevice@@A

; 247  : 				u32 dwCNT_verts			= dwBatch * Object.number_vertices;
; 248  : 				u32 dwCNT_prims			= (dwBatch * Object.number_indices)/3;
; 249  : 				RCache.get_ConstantCache_Vertex().b_dirty				=	TRUE;
; 250  : 				RCache.get_ConstantCache_Vertex().get_array_f().dirty	(c_base,c_base+dwBatch*4);

	mov	ebx, DWORD PTR _c_base$1$[esp+100]
	mov	eax, DWORD PTR [eax+436]
	add	DWORD PTR [eax+2488], ebp
	mov	eax, -1431655765			; aaaaaaabH
	mov	ecx, DWORD PTR [edi+72]
	mov	esi, DWORD PTR [edi+64]
	imul	ecx, ebp
	imul	esi, ebp
	mul	ecx
	mov	eax, DWORD PTR __imp_?RCache@@3VCBackend@@A
	mov	ecx, edx
	lea	edx, DWORD PTR [ebx+ebp*4]
	shr	ecx, 1
	mov	DWORD PTR _dwCNT_prims$1$[esp+104], ecx
	mov	DWORD PTR [eax+8848], 1
; File I:\Vitalya\mine\NSProjectX\xrEngine\R_Backend.h

; 129  : 	IC	R_constant_array& get_ConstantCache_Vertex() { return constants.a_vertex; }

	mov	eax, DWORD PTR __imp_?RCache@@3VCBackend@@A
; File I:\Vitalya\mine\NSProjectX\xrEngine\r_constants_cache.h

; 21   : 	ICF void				dirty(u32 _lo, u32 _hi) { if (_lo < lo) lo = _lo; if (_hi > hi) hi = _hi; }

	cmp	ebx, DWORD PTR [eax+8836]
	jae	SHORT $LN133@hw_Render_
	mov	DWORD PTR [eax+8836], ebx
$LN133@hw_Render_:
	cmp	edx, DWORD PTR [eax+8840]
	jbe	SHORT $LN134@hw_Render_
	mov	DWORD PTR [eax+8840], edx
$LN134@hw_Render_:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_VS.cpp

; 251  : 				RCache.Render				(D3DPT_TRIANGLELIST,vOffset,0,dwCNT_verts,iOffset,dwCNT_prims);

	mov	eax, DWORD PTR __imp_?RCache@@3VCBackend@@A
; File I:\Vitalya\mine\NSProjectX\xrEngine\R_Backend_Runtime.h

; 201  : 	stat.polys += PC;

	add	DWORD PTR [eax+9016], ecx

; 202  : 	constants.flush();

	lea	ecx, DWORD PTR [eax+608]
	inc	DWORD PTR [eax+9024]
	add	DWORD PTR [eax+9020], esi
; File I:\Vitalya\mine\NSProjectX\xrEngine\r_constants_cache.h

; 172  : 		if (a_pixel.b_dirty || a_vertex.b_dirty)	flush_cache();

	cmp	DWORD PTR [ecx+4112], 0
	jne	SHORT $LN140@hw_Render_
	cmp	DWORD PTR [ecx+8240], 0
	je	SHORT $LN139@hw_Render_
$LN140@hw_Render_:
	call	DWORD PTR __imp_?flush_cache@R_constants@@QAEXXZ
$LN139@hw_Render_:
; File I:\Vitalya\mine\NSProjectX\xrEngine\R_Backend_Runtime.h

; 203  : 	CHK_DX(HW.pDevice->DrawIndexedPrimitive(T, baseV, startV, countV, startI, PC));

	push	DWORD PTR _dwCNT_prims$1$[esp+104]
	mov	eax, DWORD PTR __imp_?HW@@3VCHW@@A
	push	DWORD PTR _iOffset$1$[esp+108]
	push	esi
	mov	eax, DWORD PTR [eax+8]
	push	0
	push	DWORD PTR _vOffset$1$[esp+120]
	mov	ecx, DWORD PTR [eax]
	push	4
	push	eax
	call	DWORD PTR [ecx+328]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_VS.cpp

; 252  : 				RCache.stat.r.s_details.add	(dwCNT_verts);

	mov	eax, DWORD PTR __imp_?RCache@@3VCBackend@@A
; File I:\Vitalya\mine\NSProjectX\xrEngine\R_Backend.h

; 27   : 	ICF		void	add(u32 _verts) { verts += _verts; dips++; }

	add	DWORD PTR [eax+9072], esi
	inc	DWORD PTR [eax+9076]
$LN209@hw_Render_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1414 :         const pointer _Firstptr = _First._Ptr;

	mov	esi, DWORD PTR _vOffset$1$[esp+104]
$LN206@hw_Render_:
	mov	ebp, DWORD PTR _vis$1$[esp+104]
	mov	ebx, DWORD PTR [ebp]

; 1415 :         const pointer _Lastptr  = _Last._Ptr;

	mov	eax, DWORD PTR [ebp+4]

; 1416 :         auto& _My_data          = _Mypair._Myval2;
; 1417 :         pointer& _Mylast        = _My_data._Mylast;
; 1418 : 
; 1419 : #if _ITERATOR_DEBUG_LEVEL == 2
; 1420 :         _STL_VERIFY(_First._Getcont() == _STD addressof(_My_data) && _Last._Getcont() == _STD addressof(_My_data)
; 1421 :                         && _Firstptr >= _My_data._Myfirst && _Lastptr >= _Firstptr && _Mylast >= _Lastptr,
; 1422 :             "vector erase iterator outside range");
; 1423 : #endif // _ITERATOR_DEBUG_LEVEL == 2
; 1424 : 
; 1425 :         if (_Firstptr != _Lastptr) { // something to do, invalidate iterators

	cmp	ebx, eax
	je	SHORT $LN210@hw_Render_
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility

; 4065 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	mov	esi, eax
	sub	esi, eax

; 4066 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	push	esi
	push	eax
	push	ebx
	call	_memmove

; 4067 :     if constexpr (is_pointer_v<_OutCtgIt>) {
; 4068 :         return reinterpret_cast<_OutCtgIt>(_Dest_ch + _Count);

	lea	eax, DWORD PTR [esi+ebx]
	add	esp, 12					; 0000000cH
	mov	esi, DWORD PTR _vOffset$1$[esp+104]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1430 :             _Mylast = _Newlast;

	mov	DWORD PTR [ebp+4], eax
$LN210@hw_Render_:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_VS.cpp

; 268  : 		vOffset		+=	hw_BatchSize * Object.number_vertices;

	mov	ebx, DWORD PTR tv1611[esp+104]
	mov	edx, DWORD PTR tv1714[esp+104]
$LN159@hw_Render_:
	mov	eax, DWORD PTR _this$1$[esp+104]
	add	edx, 12					; 0000000cH
	mov	DWORD PTR tv1714[esp+104], edx
	mov	ecx, DWORD PTR [eax+701232]
	mov	eax, DWORD PTR [edi+64]
	imul	eax, ecx
	add	esi, eax

; 269  : 		iOffset		+=	hw_BatchSize * Object.number_indices;

	mov	eax, DWORD PTR [edi+72]
	mov	edi, DWORD PTR tv1708[esp+104]
	imul	eax, ecx
	add	edi, 4
	mov	ecx, DWORD PTR _this$1$[esp+104]
	mov	DWORD PTR _vOffset$1$[esp+104], esi
	mov	DWORD PTR tv1708[esp+104], edi
	add	DWORD PTR _iOffset$1$[esp+104], eax
	mov	eax, DWORD PTR _O$1$[esp+104]
	inc	eax
	mov	DWORD PTR _O$1$[esp+104], eax
	cmp	eax, DWORD PTR [ecx+1392]
	jb	$LL4@hw_Render_
	pop	edi
	pop	ebp
$LN207@hw_Render_:
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 44   : 	void				_dec	()									{	if (0==p_) return;	p_->dwReference--; if (0==p_->dwReference) xr_delete(p_);				}

	mov	eax, DWORD PTR _x_array$[esp+92]
	pop	esi
	pop	ebx
	test	eax, eax
	je	SHORT $LN179@hw_Render_
	dec	DWORD PTR [eax]
	mov	eax, DWORD PTR _x_array$[esp+84]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN179@hw_Render_
; File I:\Vitalya\mine\NSProjectX\xrCore\xrstring.h

; 50   : 	void				_dec		()								{	if (0==p_) return;	p_->dwReference--; 	if (0==p_->dwReference)	p_=0;						}

	mov	ecx, DWORD PTR [eax+4]
	test	ecx, ecx
	je	SHORT $LN192@hw_Render_
	dec	DWORD PTR [ecx]
	mov	ecx, DWORD PTR [eax+4]
	cmp	DWORD PTR [ecx], 0
	jne	SHORT $LN208@hw_Render_
	mov	DWORD PTR [eax+4], 0
$LN208@hw_Render_:
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h

; 144  : 		Memory.mem_free	(ptr);

	mov	eax, DWORD PTR _x_array$[esp+84]
$LN192@hw_Render_:
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN179@hw_Render_:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_VS.cpp

; 271  : }

	add	esp, 88					; 00000058H
	ret	16					; 00000010H
?hw_Render_dump@CDetailManager@@QAEXV?$resptr_core@UR_constant@@V?$resptr_base@UR_constant@@@@@@III@Z ENDP ; CDetailManager::hw_Render_dump
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUSlotItem@CDetailManager@@@std@@@std@@@std@@QAE?AV01@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$dead$ = 12					; size = 4
??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUSlotItem@CDetailManager@@@std@@@std@@@std@@QAE?AV01@H@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CDetailManager::SlotItem *> > >::operator++, COMDAT
; _this$ = ecx

; 281  :         _Vector_iterator _Tmp = *this;

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx

; 74   :         ++_Ptr;

	add	edx, 4
	mov	DWORD PTR [ecx], edx

; 282  :         _Mybase::operator++();
; 283  :         return _Tmp;
; 284  :     }

	ret	8
??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUSlotItem@CDetailManager@@@std@@@std@@@std@@QAE?AV01@H@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CDetailManager::SlotItem *> > >::operator++
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUSlotItem@CDetailManager@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUSlotItem@CDetailManager@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CDetailManager::SlotItem *> > >::operator!=, COMDAT
; _this$ = ecx

; 160  :         return !(*this == _Right);

	mov	eax, DWORD PTR __Right$[esp-4]
	mov	ecx, DWORD PTR [ecx]
	cmp	ecx, DWORD PTR [eax]
	setne	al

; 161  :     }

	ret	4
??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUSlotItem@CDetailManager@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CDetailManager::SlotItem *> > >::operator!=
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?empty@?$vector@PAV?$xr_vector@PAUSlotItem@CDetailManager@@V?$xalloc@PAUSlotItem@CDetailManager@@@@@@V?$xalloc@PAV?$xr_vector@PAUSlotItem@CDetailManager@@V?$xalloc@PAUSlotItem@CDetailManager@@@@@@@@@std@@QBE_NXZ
_TEXT	SEGMENT
?empty@?$vector@PAV?$xr_vector@PAUSlotItem@CDetailManager@@V?$xalloc@PAUSlotItem@CDetailManager@@@@@@V?$xalloc@PAV?$xr_vector@PAUSlotItem@CDetailManager@@V?$xalloc@PAUSlotItem@CDetailManager@@@@@@@@@std@@QBE_NXZ PROC ; std::vector<xr_vector<CDetailManager::SlotItem *,xalloc<CDetailManager::SlotItem *> > *,xalloc<xr_vector<CDetailManager::SlotItem *,xalloc<CDetailManager::SlotItem *> > *> >::empty, COMDAT
; _this$ = ecx

; 1530 :         auto& _My_data = _Mypair._Myval2;
; 1531 :         return _My_data._Myfirst == _My_data._Mylast;

	mov	eax, DWORD PTR [ecx]
	cmp	eax, DWORD PTR [ecx+4]
	sete	al

; 1532 :     }

	ret	0
?empty@?$vector@PAV?$xr_vector@PAUSlotItem@CDetailManager@@V?$xalloc@PAUSlotItem@CDetailManager@@@@@@V?$xalloc@PAV?$xr_vector@PAUSlotItem@CDetailManager@@V?$xalloc@PAUSlotItem@CDetailManager@@@@@@@@@std@@QBE_NXZ ENDP ; std::vector<xr_vector<CDetailManager::SlotItem *,xalloc<CDetailManager::SlotItem *> > *,xalloc<xr_vector<CDetailManager::SlotItem *,xalloc<CDetailManager::SlotItem *> > *> >::empty
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
;	COMDAT ??C?$resptr_core@UR_constant@@V?$resptr_base@UR_constant@@@@@@QBEPAUR_constant@@XZ
_TEXT	SEGMENT
??C?$resptr_core@UR_constant@@V?$resptr_base@UR_constant@@@@@@QBEPAUR_constant@@XZ PROC ; resptr_core<R_constant,resptr_base<R_constant> >::operator->, COMDAT
; _this$ = ecx

; 71   : 	T *					operator->() const												{	return p_;	}

	mov	eax, DWORD PTR [ecx]
	ret	0
??C?$resptr_core@UR_constant@@V?$resptr_base@UR_constant@@@@@@QBEPAUR_constant@@XZ ENDP ; resptr_core<R_constant,resptr_base<R_constant> >::operator->
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xrstring.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
;	COMDAT ??4?$resptr_core@UR_constant@@V?$resptr_base@UR_constant@@@@@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT
_rhs$ = 8						; size = 4
??4?$resptr_core@UR_constant@@V?$resptr_base@UR_constant@@@@@@QAEAAV0@ABV0@@Z PROC ; resptr_core<R_constant,resptr_base<R_constant> >::operator=, COMDAT
; _this$ = ecx

; 47   : 	ICF		void		_set	(resptr_base<T> const & rhs)		{	T* prhs = rhs._get(); _set(prhs);															}

	mov	eax, DWORD PTR _rhs$[esp-4]

; 67   : 	self &				operator=		(const self & rhs)								{	_set(rhs);	return (self&)*this;	}

	push	esi
	push	edi
	mov	esi, ecx

; 47   : 	ICF		void		_set	(resptr_base<T> const & rhs)		{	T* prhs = rhs._get(); _set(prhs);															}

	mov	edi, DWORD PTR [eax]

; 46   : 	ICF		void		_set	(T * rhs) 							{	if (0!=rhs) rhs->dwReference++;	_dec(); p_ = rhs;											}

	test	edi, edi
	je	SHORT $LN6@operator
	inc	DWORD PTR [edi]
$LN6@operator:

; 44   : 	void				_dec	()									{	if (0==p_) return;	p_->dwReference--; if (0==p_->dwReference) xr_delete(p_);				}

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN29@operator
	dec	DWORD PTR [eax]
	mov	ecx, DWORD PTR [esi]
	cmp	DWORD PTR [ecx], 0
	jne	SHORT $LN29@operator
; File I:\Vitalya\mine\NSProjectX\xrCore\xrstring.h

; 50   : 	void				_dec		()								{	if (0==p_) return;	p_->dwReference--; 	if (0==p_->dwReference)	p_=0;						}

	mov	eax, DWORD PTR [ecx+4]
	test	eax, eax
	je	SHORT $LN26@operator
	dec	DWORD PTR [eax]
	mov	eax, DWORD PTR [ecx+4]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN26@operator
	mov	DWORD PTR [ecx+4], 0
$LN26@operator:
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h

; 144  : 		Memory.mem_free	(ptr);

	push	DWORD PTR [esi]
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN29@operator:
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 67   : 	self &				operator=		(const self & rhs)								{	_set(rhs);	return (self&)*this;	}

	mov	DWORD PTR [esi], edi
	mov	eax, esi
	pop	edi
	pop	esi
	ret	4
??4?$resptr_core@UR_constant@@V?$resptr_base@UR_constant@@@@@@QAEAAV0@ABV0@@Z ENDP ; resptr_core<R_constant,resptr_base<R_constant> >::operator=
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
;	COMDAT ??C?$resptr_core@UShader@@Uresptrcode_shader@@@@QBEPAUShader@@XZ
_TEXT	SEGMENT
??C?$resptr_core@UShader@@Uresptrcode_shader@@@@QBEPAUShader@@XZ PROC ; resptr_core<Shader,resptrcode_shader>::operator->, COMDAT
; _this$ = ecx

; 71   : 	T *					operator->() const												{	return p_;	}

	mov	eax, DWORD PTR [ecx]
	ret	0
??C?$resptr_core@UShader@@Uresptrcode_shader@@@@QBEPAUShader@@XZ ENDP ; resptr_core<Shader,resptrcode_shader>::operator->
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
;	COMDAT ??C?$resptr_core@UShaderElement@@V?$resptr_base@UShaderElement@@@@@@QBEPAUShaderElement@@XZ
_TEXT	SEGMENT
??C?$resptr_core@UShaderElement@@V?$resptr_base@UShaderElement@@@@@@QBEPAUShaderElement@@XZ PROC ; resptr_core<ShaderElement,resptr_base<ShaderElement> >::operator->, COMDAT
; _this$ = ecx

; 71   : 	T *					operator->() const												{	return p_;	}

	mov	eax, DWORD PTR [ecx]
	ret	0
??C?$resptr_core@UShaderElement@@V?$resptr_base@UShaderElement@@@@@@QBEPAUShaderElement@@XZ ENDP ; resptr_core<ShaderElement,resptr_base<ShaderElement> >::operator->
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
;	COMDAT ??C?$resptr_core@USPass@@V?$resptr_base@USPass@@@@@@QBEPAUSPass@@XZ
_TEXT	SEGMENT
??C?$resptr_core@USPass@@V?$resptr_base@USPass@@@@@@QBEPAUSPass@@XZ PROC ; resptr_core<SPass,resptr_base<SPass> >::operator->, COMDAT
; _this$ = ecx

; 71   : 	T *					operator->() const												{	return p_;	}

	mov	eax, DWORD PTR [ecx]
	ret	0
??C?$resptr_core@USPass@@V?$resptr_base@USPass@@@@@@QBEPAUSPass@@XZ ENDP ; resptr_core<SPass,resptr_base<SPass> >::operator->
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector4.h
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector4.h
;	COMDAT ?normalize@?$_vector4@M@@QAEAAU1@XZ
_TEXT	SEGMENT
?normalize@?$_vector4@M@@QAEAAU1@XZ PROC		; _vector4<float>::normalize, COMDAT
; _this$ = ecx

; 44   : 	IC	T			magnitude_sqr ()					{ return x*x + y*y + z*z + w*w;		}

	movss	xmm4, DWORD PTR [ecx+8]

; 46   : 	IC	SelfRef		normalize()							{ return mul(1/magnitude());		}

	mov	eax, ecx

; 44   : 	IC	T			magnitude_sqr ()					{ return x*x + y*y + z*z + w*w;		}

	movss	xmm5, DWORD PTR [ecx+12]
	movaps	xmm0, xmm4
	movss	xmm6, DWORD PTR [ecx+4]
	movaps	xmm2, xmm5
	movss	xmm3, DWORD PTR [ecx]
	mulss	xmm0, xmm4
	movaps	xmm1, xmm3
	mulss	xmm2, xmm5
	mulss	xmm1, xmm3
	addss	xmm2, xmm0
	movaps	xmm0, xmm6
	mulss	xmm0, xmm6
	addss	xmm1, xmm0
	addss	xmm2, xmm1

; 46   : 	IC	SelfRef		normalize()							{ return mul(1/magnitude());		}

	movss	xmm1, DWORD PTR __real@3f800000
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h

; 764  :             return (float)sqrt(_X);

	sqrtss	xmm0, xmm2
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector4.h

; 46   : 	IC	SelfRef		normalize()							{ return mul(1/magnitude());		}

	divss	xmm1, xmm0

; 33   : 	IC  SelfRef		mul(T s)							{ x*=s;		y*=s;		z*=s;		w*=s;		return *this; }

	mulss	xmm3, xmm1
	mulss	xmm6, xmm1
	mulss	xmm4, xmm1
	mulss	xmm5, xmm1
	movss	DWORD PTR [ecx], xmm3
	movss	DWORD PTR [ecx+4], xmm6
	movss	DWORD PTR [ecx+8], xmm4
	movss	DWORD PTR [ecx+12], xmm5

; 46   : 	IC	SelfRef		normalize()							{ return mul(1/magnitude());		}

	ret	0
?normalize@?$_vector4@M@@QAEAAU1@XZ ENDP		; _vector4<float>::normalize
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector4.h
;	COMDAT ?div@?$_vector4@M@@QAEAAU1@M@Z
_TEXT	SEGMENT
_s$dead$ = 8						; size = 4
?div@?$_vector4@M@@QAEAAU1@M@Z PROC			; _vector4<float>::div, COMDAT
; _this$ = ecx

; 38   : 	IC  SelfRef		div(T s)							{ x/=s;		y/=s;		z/=s;		w/=s;		return *this; }

	movss	xmm1, DWORD PTR __real@3e22f983
	mov	eax, ecx
	movss	xmm0, DWORD PTR [ecx]
	mulss	xmm0, xmm1
	movss	DWORD PTR [ecx], xmm0
	movss	xmm0, DWORD PTR [ecx+4]
	mulss	xmm0, xmm1
	movss	DWORD PTR [ecx+4], xmm0
	movss	xmm0, DWORD PTR [ecx+8]
	mulss	xmm0, xmm1
	movss	DWORD PTR [ecx+8], xmm0
	movss	xmm0, DWORD PTR [ecx+12]
	mulss	xmm0, xmm1
	movss	DWORD PTR [ecx+12], xmm0
	ret	4
?div@?$_vector4@M@@QAEAAU1@M@Z ENDP			; _vector4<float>::div
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector4.h
;	COMDAT ?mul@?$_vector4@M@@QAEAAU1@M@Z
_TEXT	SEGMENT
_s$ = 8							; size = 4
?mul@?$_vector4@M@@QAEAAU1@M@Z PROC			; _vector4<float>::mul, COMDAT
; _this$ = ecx

; 33   : 	IC  SelfRef		mul(T s)							{ x*=s;		y*=s;		z*=s;		w*=s;		return *this; }

	movss	xmm1, DWORD PTR _s$[esp-4]
	mov	eax, ecx
	movaps	xmm0, xmm1
	mulss	xmm0, DWORD PTR [ecx]
	movss	DWORD PTR [ecx], xmm0
	movaps	xmm0, xmm1
	mulss	xmm0, DWORD PTR [ecx+4]
	movss	DWORD PTR [ecx+4], xmm0
	movaps	xmm0, xmm1
	mulss	xmm0, DWORD PTR [ecx+8]
	mulss	xmm1, DWORD PTR [ecx+12]
	movss	DWORD PTR [ecx+8], xmm0
	movss	DWORD PTR [ecx+12], xmm1
	ret	4
?mul@?$_vector4@M@@QAEAAU1@M@Z ENDP			; _vector4<float>::mul
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
;	COMDAT ?mad@?$_vector3@M@@QAEAAU1@ABU1@M@Z
_TEXT	SEGMENT
_d$ = 8							; size = 4
_m$ = 12						; size = 4
?mad@?$_vector3@M@@QAEAAU1@ABU1@M@Z PROC		; _vector3<float>::mad, COMDAT
; _this$ = ecx

; 137  : 		x += d.x*m;

	mov	eax, DWORD PTR _d$[esp-4]
	movss	xmm1, DWORD PTR _m$[esp-4]
	movaps	xmm0, xmm1
	mulss	xmm0, DWORD PTR [eax]
	addss	xmm0, DWORD PTR [ecx]
	movss	DWORD PTR [ecx], xmm0

; 138  : 		y += d.y*m;

	movaps	xmm0, xmm1
	mulss	xmm0, DWORD PTR [eax+4]
	addss	xmm0, DWORD PTR [ecx+4]
	movss	DWORD PTR [ecx+4], xmm0

; 139  : 		z += d.z*m;

	mulss	xmm1, DWORD PTR [eax+8]

; 140  : 		return *this;	

	mov	eax, ecx
	addss	xmm1, DWORD PTR [ecx+8]
	movss	DWORD PTR [ecx+8], xmm1

; 141  : 	}

	ret	8
?mad@?$_vector3@M@@QAEAAU1@ABU1@M@Z ENDP		; _vector3<float>::mad
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUSlotItem@CDetailManager@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUSlotItem@CDetailManager@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CDetailManager::SlotItem *> > >::operator==, COMDAT
; _this$ = ecx

; 149  :         _Compat(_Right);
; 150  :         return _Ptr == _Right._Ptr;

	mov	eax, DWORD PTR __Right$[esp-4]
	mov	ecx, DWORD PTR [ecx]
	cmp	ecx, DWORD PTR [eax]
	sete	al

; 151  :     }

	ret	4
??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUSlotItem@CDetailManager@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CDetailManager::SlotItem *> > >::operator==
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUSlotItem@CDetailManager@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUSlotItem@CDetailManager@@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CDetailManager::SlotItem *> > >::operator++, COMDAT
; _this$ = ecx

; 68   : #if _ITERATOR_DEBUG_LEVEL != 0
; 69   :         const auto _Mycont = static_cast<const _Myvec*>(this->_Getcont());
; 70   :         _STL_VERIFY(_Ptr, "can't increment value-initialized vector iterator");
; 71   :         _STL_VERIFY(_Ptr < _Mycont->_Mylast, "can't increment vector iterator past end");
; 72   : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 73   : 
; 74   :         ++_Ptr;

	add	DWORD PTR [ecx], 4

; 75   :         return *this;

	mov	eax, ecx

; 76   :     }

	ret	0
??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUSlotItem@CDetailManager@@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CDetailManager::SlotItem *> > >::operator++
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xrstring.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
;	COMDAT ?_set@?$resptr_base@UR_constant@@@@QAEXABV1@@Z
_TEXT	SEGMENT
_rhs$ = 8						; size = 4
?_set@?$resptr_base@UR_constant@@@@QAEXABV1@@Z PROC	; resptr_base<R_constant>::_set, COMDAT
; _this$ = ecx

; 47   : 	ICF		void		_set	(resptr_base<T> const & rhs)		{	T* prhs = rhs._get(); _set(prhs);															}

	mov	eax, DWORD PTR _rhs$[esp-4]
	push	esi
	push	edi
	mov	edi, ecx
	mov	esi, DWORD PTR [eax]

; 46   : 	ICF		void		_set	(T * rhs) 							{	if (0!=rhs) rhs->dwReference++;	_dec(); p_ = rhs;											}

	test	esi, esi
	je	SHORT $LN4@set
	inc	DWORD PTR [esi]
$LN4@set:

; 44   : 	void				_dec	()									{	if (0==p_) return;	p_->dwReference--; if (0==p_->dwReference) xr_delete(p_);				}

	mov	eax, DWORD PTR [edi]
	test	eax, eax
	je	SHORT $LN27@set
	dec	DWORD PTR [eax]
	mov	ecx, DWORD PTR [edi]
	cmp	DWORD PTR [ecx], 0
	jne	SHORT $LN27@set
; File I:\Vitalya\mine\NSProjectX\xrCore\xrstring.h

; 50   : 	void				_dec		()								{	if (0==p_) return;	p_->dwReference--; 	if (0==p_->dwReference)	p_=0;						}

	mov	eax, DWORD PTR [ecx+4]
	test	eax, eax
	je	SHORT $LN24@set
	dec	DWORD PTR [eax]
	mov	eax, DWORD PTR [ecx+4]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN24@set
	mov	DWORD PTR [ecx+4], 0
$LN24@set:
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h

; 144  : 		Memory.mem_free	(ptr);

	push	DWORD PTR [edi]
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN27@set:
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 47   : 	ICF		void		_set	(resptr_base<T> const & rhs)		{	T* prhs = rhs._get(); _set(prhs);															}

	mov	DWORD PTR [edi], esi
	pop	edi
	pop	esi
	ret	4
?_set@?$resptr_base@UR_constant@@@@QAEXABV1@@Z ENDP	; resptr_base<R_constant>::_set
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector4.h
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector4.h
;	COMDAT ?magnitude@?$_vector4@M@@QAEMXZ
_TEXT	SEGMENT
?magnitude@?$_vector4@M@@QAEMXZ PROC			; _vector4<float>::magnitude, COMDAT
; _this$ = ecx

; 44   : 	IC	T			magnitude_sqr ()					{ return x*x + y*y + z*z + w*w;		}

	fld	DWORD PTR [ecx+4]
	fld	DWORD PTR [ecx]
	fld	DWORD PTR [ecx+8]
	fld	DWORD PTR [ecx+12]
	fmul	ST(0), ST(0)
	fxch	ST(1)
	fmul	ST(0), ST(0)
	faddp	ST(1), ST(0)
	fxch	ST(1)
	fmul	ST(0), ST(0)
	fxch	ST(2)
	fmul	ST(0), ST(0)
	faddp	ST(2), ST(0)
	faddp	ST(1), ST(0)
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h

; 764  :             return (float)sqrt(_X);

	fsqrt
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector4.h

; 45   : 	IC	T			magnitude()							{ return _sqrt(magnitude_sqr());	}

	ret	0
?magnitude@?$_vector4@M@@QAEMXZ ENDP			; _vector4<float>::magnitude
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUSlotItem@CDetailManager@@@std@@@std@@@std@@QBEXABV12@@Z
_TEXT	SEGMENT
__Right$dead$ = 8					; size = 4
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUSlotItem@CDetailManager@@@std@@@std@@@std@@QBEXABV12@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CDetailManager::SlotItem *> > >::_Compat, COMDAT
; _this$dead$ = ecx

; 182  :         // test for compatible iterator pair
; 183  : #if _ITERATOR_DEBUG_LEVEL == 0
; 184  :         (void) _Right;
; 185  : #else // ^^^ _ITERATOR_DEBUG_LEVEL == 0 ^^^ // vvv _ITERATOR_DEBUG_LEVEL != 0 vvv
; 186  :         _STL_VERIFY(this->_Getcont() == _Right._Getcont(), "vector iterators incompatible");
; 187  : #endif // _ITERATOR_DEBUG_LEVEL == 0
; 188  :     }

	ret	4
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUSlotItem@CDetailManager@@@std@@@std@@@std@@QBEXABV12@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CDetailManager::SlotItem *> > >::_Compat
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
;	COMDAT ?_get@?$resptr_base@UR_constant@@@@QBEPAUR_constant@@XZ
_TEXT	SEGMENT
?_get@?$resptr_base@UR_constant@@@@QBEPAUR_constant@@XZ PROC ; resptr_base<R_constant>::_get, COMDAT
; _this$ = ecx

; 48   : 	ICF		T *			_get	() const							{	return p_;																					}

	mov	eax, DWORD PTR [ecx]
	ret	0
?_get@?$resptr_base@UR_constant@@@@QBEPAUR_constant@@XZ ENDP ; resptr_base<R_constant>::_get
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xrstring.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
;	COMDAT ?_set@?$resptr_base@UR_constant@@@@QAEXPAUR_constant@@@Z
_TEXT	SEGMENT
_rhs$ = 8						; size = 4
?_set@?$resptr_base@UR_constant@@@@QAEXPAUR_constant@@@Z PROC ; resptr_base<R_constant>::_set, COMDAT
; _this$ = ecx

; 46   : 	ICF		void		_set	(T * rhs) 							{	if (0!=rhs) rhs->dwReference++;	_dec(); p_ = rhs;											}

	push	esi
	mov	esi, DWORD PTR _rhs$[esp]
	push	edi
	mov	edi, ecx
	test	esi, esi
	je	SHORT $LN2@set
	inc	DWORD PTR [esi]
$LN2@set:

; 44   : 	void				_dec	()									{	if (0==p_) return;	p_->dwReference--; if (0==p_->dwReference) xr_delete(p_);				}

	mov	eax, DWORD PTR [edi]
	test	eax, eax
	je	SHORT $LN25@set
	dec	DWORD PTR [eax]
	mov	ecx, DWORD PTR [edi]
	cmp	DWORD PTR [ecx], 0
	jne	SHORT $LN25@set
; File I:\Vitalya\mine\NSProjectX\xrCore\xrstring.h

; 50   : 	void				_dec		()								{	if (0==p_) return;	p_->dwReference--; 	if (0==p_->dwReference)	p_=0;						}

	mov	eax, DWORD PTR [ecx+4]
	test	eax, eax
	je	SHORT $LN22@set
	dec	DWORD PTR [eax]
	mov	eax, DWORD PTR [ecx+4]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN22@set
	mov	DWORD PTR [ecx+4], 0
$LN22@set:
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h

; 144  : 		Memory.mem_free	(ptr);

	push	DWORD PTR [edi]
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN25@set:
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 46   : 	ICF		void		_set	(T * rhs) 							{	if (0!=rhs) rhs->dwReference++;	_dec(); p_ = rhs;											}

	mov	DWORD PTR [edi], esi
	pop	edi
	pop	esi
	ret	4
?_set@?$resptr_base@UR_constant@@@@QAEXPAUR_constant@@@Z ENDP ; resptr_base<R_constant>::_set
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector4.h
;	COMDAT ?magnitude_sqr@?$_vector4@M@@QAEMXZ
_TEXT	SEGMENT
?magnitude_sqr@?$_vector4@M@@QAEMXZ PROC		; _vector4<float>::magnitude_sqr, COMDAT
; _this$ = ecx

; 44   : 	IC	T			magnitude_sqr ()					{ return x*x + y*y + z*z + w*w;		}

	fld	DWORD PTR [ecx+4]
	fld	DWORD PTR [ecx]
	fld	DWORD PTR [ecx+8]
	fld	DWORD PTR [ecx+12]
	fmul	ST(0), ST(0)
	fxch	ST(1)
	fmul	ST(0), ST(0)
	faddp	ST(1), ST(0)
	fxch	ST(1)
	fmul	ST(0), ST(0)
	fxch	ST(2)
	fmul	ST(0), ST(0)
	faddp	ST(2), ST(0)
	faddp	ST(1), ST(0)
	ret	0
?magnitude_sqr@?$_vector4@M@@QAEMXZ ENDP		; _vector4<float>::magnitude_sqr
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrEngine\R_Backend.h
;	COMDAT ?add@R_statistics_element@@QAEXI@Z
_TEXT	SEGMENT
__verts$ = 8						; size = 4
?add@R_statistics_element@@QAEXI@Z PROC			; R_statistics_element::add, COMDAT
; _this$ = ecx

; 27   : 	ICF		void	add(u32 _verts) { verts += _verts; dips++; }

	mov	eax, DWORD PTR __verts$[esp-4]
	add	DWORD PTR [ecx], eax
	inc	DWORD PTR [ecx+4]
	ret	4
?add@R_statistics_element@@QAEXI@Z ENDP			; R_statistics_element::add
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrEngine\r_constants_cache.h
;	COMDAT ?get_array_f@R_constant_array@@QAEAAV?$R_constant_cache@U?$_vector4@M@@$0BAA@@@XZ
_TEXT	SEGMENT
?get_array_f@R_constant_array@@QAEAAV?$R_constant_cache@U?$_vector4@M@@$0BAA@@@XZ PROC ; R_constant_array::get_array_f, COMDAT
; _this$ = ecx

; 38   : 	t_f& get_array_f() { return c_f; }

	mov	eax, ecx
	ret	0
?get_array_f@R_constant_array@@QAEAAV?$R_constant_cache@U?$_vector4@M@@$0BAA@@@XZ ENDP ; R_constant_array::get_array_f
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.h
;	COMDAT ?apply_lmaterial@CRender@@QAEXXZ
_TEXT	SEGMENT
?apply_lmaterial@CRender@@QAEXXZ PROC			; CRender::apply_lmaterial, COMDAT
; _this$dead$ = ecx

; 106  : 	IC void								apply_lmaterial			()				{};

	ret	0
?apply_lmaterial@CRender@@QAEXXZ ENDP			; CRender::apply_lmaterial
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrEngine\r_constants_cache.h
; File I:\Vitalya\mine\NSProjectX\xrCore\FixedVector.h
; File I:\Vitalya\mine\NSProjectX\xrEngine\r_constants_cache.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector4.h
; File I:\Vitalya\mine\NSProjectX\xrEngine\r_constants_cache.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector4.h
; File I:\Vitalya\mine\NSProjectX\xrEngine\r_constants_cache.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector4.h
; File I:\Vitalya\mine\NSProjectX\xrEngine\r_constants_cache.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector4.h
; File I:\Vitalya\mine\NSProjectX\xrEngine\r_constants_cache.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector4.h
; File I:\Vitalya\mine\NSProjectX\xrEngine\r_constants_cache.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector4.h
; File I:\Vitalya\mine\NSProjectX\xrEngine\r_constants_cache.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector4.h
; File I:\Vitalya\mine\NSProjectX\xrEngine\r_constants_cache.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector4.h
; File I:\Vitalya\mine\NSProjectX\xrEngine\r_constants_cache.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector4.h
; File I:\Vitalya\mine\NSProjectX\xrEngine\r_constants_cache.h
;	COMDAT ?set@R_constant_array@@QAEXPAUR_constant@@AAUR_constant_load@@ABU?$_matrix@M@@@Z
_TEXT	SEGMENT
_C$ = 8							; size = 4
_L$ = 12						; size = 4
_A$ = 16						; size = 4
?set@R_constant_array@@QAEXPAUR_constant@@AAUR_constant_load@@ABU?$_matrix@M@@@Z PROC ; R_constant_array::set, COMDAT
; _this$ = ecx

; 44   : 		VERIFY(RC_float == C->type);
; 45   : 		Fvector4* it = c_f.access(L.index);

	mov	eax, DWORD PTR _L$[esp-4]
	push	esi
	movzx	esi, WORD PTR [eax]

; 46   : 		switch (L.cls)

	movzx	eax, WORD PTR [eax+2]
; File I:\Vitalya\mine\NSProjectX\xrCore\FixedVector.h

; 38   : 	IC reference		operator[] (u32 id)			{ VERIFY(id<count); return array[id];	}

	mov	edx, esi
	shl	edx, 4
	add	edx, ecx
; File I:\Vitalya\mine\NSProjectX\xrEngine\r_constants_cache.h

; 46   : 		switch (L.cls)

	sub	eax, 2
	je	$LN7@set
	sub	eax, 1
	je	$LN8@set

; 58   : 			break;
; 59   : 		case RC_4x4:
; 60   : 			c_f.dirty(L.index, L.index + 4);

	lea	eax, DWORD PTR [esi+4]

; 21   : 	ICF void				dirty(u32 _lo, u32 _hi) { if (_lo < lo) lo = _lo; if (_hi > hi) hi = _hi; }

	cmp	esi, DWORD PTR [ecx+4100]
	jae	SHORT $LN38@set
	mov	DWORD PTR [ecx+4100], esi
$LN38@set:
	cmp	eax, DWORD PTR [ecx+4104]
	jbe	SHORT $LN39@set
	mov	DWORD PTR [ecx+4104], eax
$LN39@set:

; 61   : 			it[0].set(A._11, A._21, A._31, A._41);

	mov	eax, DWORD PTR _A$[esp]
	pop	esi
	movss	xmm0, DWORD PTR [eax+16]
	movss	xmm1, DWORD PTR [eax+32]
	movss	xmm2, DWORD PTR [eax+48]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector4.h

; 17   : 	IC	SelfRef 	set(T _x, T _y, T _z, T _w=1)		{ x=_x;		y=_y;		z=_z;		w=_w;		return *this; }

	fld	DWORD PTR [eax]
	fstp	DWORD PTR [edx]
	movss	DWORD PTR [edx+4], xmm0
	movss	DWORD PTR [edx+8], xmm1
	movss	DWORD PTR [edx+12], xmm2
; File I:\Vitalya\mine\NSProjectX\xrEngine\r_constants_cache.h

; 62   : 			it[1].set(A._12, A._22, A._32, A._42);

	movss	xmm0, DWORD PTR [eax+20]
	movss	xmm1, DWORD PTR [eax+36]
	movss	xmm2, DWORD PTR [eax+52]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector4.h

; 17   : 	IC	SelfRef 	set(T _x, T _y, T _z, T _w=1)		{ x=_x;		y=_y;		z=_z;		w=_w;		return *this; }

	fld	DWORD PTR [eax+4]
	fstp	DWORD PTR [edx+16]
	movss	DWORD PTR [edx+20], xmm0
	movss	DWORD PTR [edx+24], xmm1
	movss	DWORD PTR [edx+28], xmm2
; File I:\Vitalya\mine\NSProjectX\xrEngine\r_constants_cache.h

; 63   : 			it[2].set(A._13, A._23, A._33, A._43);

	movss	xmm0, DWORD PTR [eax+24]
	movss	xmm1, DWORD PTR [eax+40]
	movss	xmm2, DWORD PTR [eax+56]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector4.h

; 17   : 	IC	SelfRef 	set(T _x, T _y, T _z, T _w=1)		{ x=_x;		y=_y;		z=_z;		w=_w;		return *this; }

	fld	DWORD PTR [eax+8]
	fstp	DWORD PTR [edx+32]
	movss	DWORD PTR [edx+36], xmm0
	movss	DWORD PTR [edx+40], xmm1
	movss	DWORD PTR [edx+44], xmm2
; File I:\Vitalya\mine\NSProjectX\xrEngine\r_constants_cache.h

; 64   : 			it[3].set(A._14, A._24, A._34, A._44);

	movss	xmm0, DWORD PTR [eax+28]
	movss	xmm1, DWORD PTR [eax+44]
	movss	xmm2, DWORD PTR [eax+60]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector4.h

; 17   : 	IC	SelfRef 	set(T _x, T _y, T _z, T _w=1)		{ x=_x;		y=_y;		z=_z;		w=_w;		return *this; }

	fld	DWORD PTR [eax+12]
	fstp	DWORD PTR [edx+48]
	movss	DWORD PTR [edx+52], xmm0
	movss	DWORD PTR [edx+56], xmm1
	movss	DWORD PTR [edx+60], xmm2
; File I:\Vitalya\mine\NSProjectX\xrEngine\r_constants_cache.h

; 73   : 	}

	ret	12					; 0000000cH
$LN8@set:

; 52   : 			break;
; 53   : 		case RC_3x4:
; 54   : 			c_f.dirty(L.index, L.index + 3);

	lea	eax, DWORD PTR [esi+3]

; 21   : 	ICF void				dirty(u32 _lo, u32 _hi) { if (_lo < lo) lo = _lo; if (_hi > hi) hi = _hi; }

	cmp	esi, DWORD PTR [ecx+4100]
	jae	SHORT $LN28@set
	mov	DWORD PTR [ecx+4100], esi
$LN28@set:
	cmp	eax, DWORD PTR [ecx+4104]
	jbe	SHORT $LN29@set
	mov	DWORD PTR [ecx+4104], eax
$LN29@set:

; 55   : 			it[0].set(A._11, A._21, A._31, A._41);

	mov	eax, DWORD PTR _A$[esp]
	pop	esi
	movss	xmm0, DWORD PTR [eax+16]
	movss	xmm1, DWORD PTR [eax+32]
	movss	xmm2, DWORD PTR [eax+48]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector4.h

; 17   : 	IC	SelfRef 	set(T _x, T _y, T _z, T _w=1)		{ x=_x;		y=_y;		z=_z;		w=_w;		return *this; }

	fld	DWORD PTR [eax]
	fstp	DWORD PTR [edx]
	movss	DWORD PTR [edx+4], xmm0
	movss	DWORD PTR [edx+8], xmm1
	movss	DWORD PTR [edx+12], xmm2
; File I:\Vitalya\mine\NSProjectX\xrEngine\r_constants_cache.h

; 56   : 			it[1].set(A._12, A._22, A._32, A._42);

	movss	xmm0, DWORD PTR [eax+20]
	movss	xmm1, DWORD PTR [eax+36]
	movss	xmm2, DWORD PTR [eax+52]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector4.h

; 17   : 	IC	SelfRef 	set(T _x, T _y, T _z, T _w=1)		{ x=_x;		y=_y;		z=_z;		w=_w;		return *this; }

	fld	DWORD PTR [eax+4]
	fstp	DWORD PTR [edx+16]
	movss	DWORD PTR [edx+20], xmm0
	movss	DWORD PTR [edx+24], xmm1
	movss	DWORD PTR [edx+28], xmm2
; File I:\Vitalya\mine\NSProjectX\xrEngine\r_constants_cache.h

; 57   : 			it[2].set(A._13, A._23, A._33, A._43);

	movss	xmm0, DWORD PTR [eax+24]
	movss	xmm1, DWORD PTR [eax+40]
	movss	xmm2, DWORD PTR [eax+56]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector4.h

; 17   : 	IC	SelfRef 	set(T _x, T _y, T _z, T _w=1)		{ x=_x;		y=_y;		z=_z;		w=_w;		return *this; }

	fld	DWORD PTR [eax+8]
	fstp	DWORD PTR [edx+32]
	movss	DWORD PTR [edx+36], xmm0
	movss	DWORD PTR [edx+40], xmm1
	movss	DWORD PTR [edx+44], xmm2
; File I:\Vitalya\mine\NSProjectX\xrEngine\r_constants_cache.h

; 73   : 	}

	ret	12					; 0000000cH
$LN7@set:

; 47   : 		{
; 48   : 		case RC_2x4:
; 49   : 			c_f.dirty(L.index, L.index + 2);

	lea	eax, DWORD PTR [esi+2]

; 21   : 	ICF void				dirty(u32 _lo, u32 _hi) { if (_lo < lo) lo = _lo; if (_hi > hi) hi = _hi; }

	cmp	esi, DWORD PTR [ecx+4100]
	jae	SHORT $LN20@set
	mov	DWORD PTR [ecx+4100], esi
$LN20@set:
	cmp	eax, DWORD PTR [ecx+4104]
	jbe	SHORT $LN21@set
	mov	DWORD PTR [ecx+4104], eax
$LN21@set:

; 50   : 			it[0].set(A._11, A._21, A._31, A._41);

	mov	eax, DWORD PTR _A$[esp]
	pop	esi
	movss	xmm0, DWORD PTR [eax+16]
	movss	xmm1, DWORD PTR [eax+32]
	movss	xmm2, DWORD PTR [eax+48]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector4.h

; 17   : 	IC	SelfRef 	set(T _x, T _y, T _z, T _w=1)		{ x=_x;		y=_y;		z=_z;		w=_w;		return *this; }

	fld	DWORD PTR [eax]
	fstp	DWORD PTR [edx]
	movss	DWORD PTR [edx+4], xmm0
	movss	DWORD PTR [edx+8], xmm1
	movss	DWORD PTR [edx+12], xmm2
; File I:\Vitalya\mine\NSProjectX\xrEngine\r_constants_cache.h

; 51   : 			it[1].set(A._12, A._22, A._32, A._42);

	movss	xmm0, DWORD PTR [eax+20]
	movss	xmm1, DWORD PTR [eax+36]
	movss	xmm2, DWORD PTR [eax+52]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector4.h

; 17   : 	IC	SelfRef 	set(T _x, T _y, T _z, T _w=1)		{ x=_x;		y=_y;		z=_z;		w=_w;		return *this; }

	fld	DWORD PTR [eax+4]
	fstp	DWORD PTR [edx+16]
	movss	DWORD PTR [edx+20], xmm0
	movss	DWORD PTR [edx+24], xmm1
	movss	DWORD PTR [edx+28], xmm2
; File I:\Vitalya\mine\NSProjectX\xrEngine\r_constants_cache.h

; 73   : 	}

	ret	12					; 0000000cH
?set@R_constant_array@@QAEXPAUR_constant@@AAUR_constant_load@@ABU?$_matrix@M@@@Z ENDP ; R_constant_array::set
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
;	COMDAT ?_inc@?$resptr_base@UR_constant@@@@IAEXXZ
_TEXT	SEGMENT
?_inc@?$resptr_base@UR_constant@@@@IAEXXZ PROC		; resptr_base<R_constant>::_inc, COMDAT
; _this$ = ecx

; 43   : 	void				_inc	()									{	if (0==p_) return;	p_->dwReference++;														}

	mov	eax, DWORD PTR [ecx]
	test	eax, eax
	je	SHORT $LN1@inc
	inc	DWORD PTR [eax]
$LN1@inc:
	ret	0
?_inc@?$resptr_base@UR_constant@@@@IAEXXZ ENDP		; resptr_base<R_constant>::_inc
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
;	COMDAT ??0?$resptr_core@UR_constant@@V?$resptr_base@UR_constant@@@@@@QAE@PAUR_constant@@_N@Z
_TEXT	SEGMENT
_p$ = 8							; size = 4
_add_ref$dead$ = 12					; size = 1
??0?$resptr_core@UR_constant@@V?$resptr_base@UR_constant@@@@@@QAE@PAUR_constant@@_N@Z PROC ; resptr_core<R_constant,resptr_base<R_constant> >::resptr_core<R_constant,resptr_base<R_constant> >, COMDAT
; _this$ = ecx

; 62   : 						resptr_core		(T * p, bool add_ref = true) 					{	p_ = p;	if(add_ref)	_inc(); }

	mov	eax, DWORD PTR _p$[esp-4]
	mov	DWORD PTR [ecx], eax

; 43   : 	void				_inc	()									{	if (0==p_) return;	p_->dwReference++;														}

	test	eax, eax
	je	SHORT $LN7@resptr_cor
	inc	DWORD PTR [eax]
$LN7@resptr_cor:

; 62   : 						resptr_core		(T * p, bool add_ref = true) 					{	p_ = p;	if(add_ref)	_inc(); }

	mov	eax, ecx
	ret	8
??0?$resptr_core@UR_constant@@V?$resptr_base@UR_constant@@@@@@QAE@PAUR_constant@@_N@Z ENDP ; resptr_core<R_constant,resptr_base<R_constant> >::resptr_core<R_constant,resptr_base<R_constant> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
;	COMDAT ??D?$resptr_core@UR_constant@@V?$resptr_base@UR_constant@@@@@@QBEAAUR_constant@@XZ
_TEXT	SEGMENT
??D?$resptr_core@UR_constant@@V?$resptr_base@UR_constant@@@@@@QBEAAUR_constant@@XZ PROC ; resptr_core<R_constant,resptr_base<R_constant> >::operator*, COMDAT
; _this$ = ecx

; 70   : 	T &					operator*() const												{	return *p_;	}

	mov	eax, DWORD PTR [ecx]
	ret	0
??D?$resptr_core@UR_constant@@V?$resptr_base@UR_constant@@@@@@QBEAAUR_constant@@XZ ENDP ; resptr_core<R_constant,resptr_base<R_constant> >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector4.h
;	COMDAT ?set@?$_vector4@M@@QAEAAU1@ABU1@@Z
_TEXT	SEGMENT
_v$ = 8							; size = 4
?set@?$_vector4@M@@QAEAAU1@ABU1@@Z PROC			; _vector4<float>::set, COMDAT
; _this$ = ecx

; 18   : 	IC	SelfRef		set(const Self& v)					{ x=v.x;	y=v.y;		z=v.z;		w=v.w;		return *this; }

	mov	eax, DWORD PTR _v$[esp-4]
	fld	DWORD PTR [eax]
	fstp	DWORD PTR [ecx]
	fld	DWORD PTR [eax+4]
	fstp	DWORD PTR [ecx+4]
	fld	DWORD PTR [eax+8]
	fstp	DWORD PTR [ecx+8]
	fld	DWORD PTR [eax+12]
	mov	eax, ecx
	fstp	DWORD PTR [ecx+12]
	ret	4
?set@?$_vector4@M@@QAEAAU1@ABU1@@Z ENDP			; _vector4<float>::set
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\FixedVector.h
;	COMDAT ??A?$svector@U?$_vector4@M@@$0BAA@@@QAEAAU?$_vector4@M@@I@Z
_TEXT	SEGMENT
_id$ = 8						; size = 4
??A?$svector@U?$_vector4@M@@$0BAA@@@QAEAAU?$_vector4@M@@I@Z PROC ; svector<_vector4<float>,256>::operator[], COMDAT
; _this$ = ecx

; 38   : 	IC reference		operator[] (u32 id)			{ VERIFY(id<count); return array[id];	}

	mov	eax, DWORD PTR _id$[esp-4]
	shl	eax, 4
	add	eax, ecx
	ret	4
??A?$svector@U?$_vector4@M@@$0BAA@@@QAEAAU?$_vector4@M@@I@Z ENDP ; svector<_vector4<float>,256>::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrEngine\r_constants_cache.h
; File I:\Vitalya\mine\NSProjectX\xrCore\FixedVector.h
; File I:\Vitalya\mine\NSProjectX\xrEngine\r_constants_cache.h
;	COMDAT ?access@?$R_constant_cache@U?$_vector4@M@@$0BAA@@@QAEPAU?$_vector4@M@@I@Z
_TEXT	SEGMENT
_id$ = 8						; size = 4
?access@?$R_constant_cache@U?$_vector4@M@@$0BAA@@@QAEPAU?$_vector4@M@@I@Z PROC ; R_constant_cache<_vector4<float>,256>::access, COMDAT
; _this$ = ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\FixedVector.h

; 38   : 	IC reference		operator[] (u32 id)			{ VERIFY(id<count); return array[id];	}

	mov	eax, DWORD PTR _id$[esp-4]
	shl	eax, 4
	add	eax, ecx
; File I:\Vitalya\mine\NSProjectX\xrEngine\r_constants_cache.h

; 19   : 	ICF T* access(u32 id) { return &array[id]; }

	ret	4
?access@?$R_constant_cache@U?$_vector4@M@@$0BAA@@@QAEPAU?$_vector4@M@@I@Z ENDP ; R_constant_cache<_vector4<float>,256>::access
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrEngine\r_constants_cache.h
;	COMDAT ?dirty@?$R_constant_cache@U?$_vector4@M@@$0BAA@@@QAEXII@Z
_TEXT	SEGMENT
__lo$ = 8						; size = 4
__hi$ = 12						; size = 4
?dirty@?$R_constant_cache@U?$_vector4@M@@$0BAA@@@QAEXII@Z PROC ; R_constant_cache<_vector4<float>,256>::dirty, COMDAT
; _this$ = ecx

; 21   : 	ICF void				dirty(u32 _lo, u32 _hi) { if (_lo < lo) lo = _lo; if (_hi > hi) hi = _hi; }

	mov	eax, DWORD PTR __lo$[esp-4]
	cmp	eax, DWORD PTR [ecx+4100]
	jae	SHORT $LN2@dirty
	mov	DWORD PTR [ecx+4100], eax
$LN2@dirty:
	mov	eax, DWORD PTR __hi$[esp-4]
	cmp	eax, DWORD PTR [ecx+4104]
	jbe	SHORT $LN3@dirty
	mov	DWORD PTR [ecx+4104], eax
$LN3@dirty:
	ret	8
?dirty@?$R_constant_cache@U?$_vector4@M@@$0BAA@@@QAEXII@Z ENDP ; R_constant_cache<_vector4<float>,256>::dirty
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrEngine\r_constants_cache.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector4.h
; File I:\Vitalya\mine\NSProjectX\xrEngine\r_constants_cache.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector4.h
; File I:\Vitalya\mine\NSProjectX\xrEngine\r_constants_cache.h
; File I:\Vitalya\mine\NSProjectX\xrCore\FixedVector.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector4.h
; File I:\Vitalya\mine\NSProjectX\xrEngine\r_constants_cache.h
;	COMDAT ?set@R_constant_array@@QAEXPAUR_constant@@AAUR_constant_load@@ABU?$_vector4@M@@@Z
_TEXT	SEGMENT
_C$ = 8							; size = 4
_L$ = 12						; size = 4
_A$ = 16						; size = 4
?set@R_constant_array@@QAEXPAUR_constant@@AAUR_constant_load@@ABU?$_vector4@M@@@Z PROC ; R_constant_array::set, COMDAT
; _this$ = ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector4.h

; 18   : 	IC	SelfRef		set(const Self& v)					{ x=v.x;	y=v.y;		z=v.z;		w=v.w;		return *this; }

	mov	eax, DWORD PTR _A$[esp-4]
; File I:\Vitalya\mine\NSProjectX\xrEngine\r_constants_cache.h

; 76   : 	{

	push	esi

; 79   : 		c_f.access(L.index)->set(A);

	mov	esi, DWORD PTR _L$[esp]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector4.h

; 18   : 	IC	SelfRef		set(const Self& v)					{ x=v.x;	y=v.y;		z=v.z;		w=v.w;		return *this; }

	fld	DWORD PTR [eax]
; File I:\Vitalya\mine\NSProjectX\xrEngine\r_constants_cache.h

; 79   : 		c_f.access(L.index)->set(A);

	movzx	edx, WORD PTR [esi]
; File I:\Vitalya\mine\NSProjectX\xrCore\FixedVector.h

; 38   : 	IC reference		operator[] (u32 id)			{ VERIFY(id<count); return array[id];	}

	shl	edx, 4
	add	edx, ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector4.h

; 18   : 	IC	SelfRef		set(const Self& v)					{ x=v.x;	y=v.y;		z=v.z;		w=v.w;		return *this; }

	fstp	DWORD PTR [edx]
	fld	DWORD PTR [eax+4]
	fstp	DWORD PTR [edx+4]
	fld	DWORD PTR [eax+8]
	fstp	DWORD PTR [edx+8]
	fld	DWORD PTR [eax+12]
	fstp	DWORD PTR [edx+12]
; File I:\Vitalya\mine\NSProjectX\xrEngine\r_constants_cache.h

; 80   : 		c_f.dirty(L.index, L.index + 1);

	movzx	edx, WORD PTR [esi]
	pop	esi
	lea	eax, DWORD PTR [edx+1]

; 21   : 	ICF void				dirty(u32 _lo, u32 _hi) { if (_lo < lo) lo = _lo; if (_hi > hi) hi = _hi; }

	cmp	edx, DWORD PTR [ecx+4100]
	jae	SHORT $LN19@set
	mov	DWORD PTR [ecx+4100], edx
$LN19@set:
	cmp	eax, DWORD PTR [ecx+4104]
	jbe	SHORT $LN20@set
	mov	DWORD PTR [ecx+4104], eax
$LN20@set:

; 81   : 	}

	ret	12					; 0000000cH
?set@R_constant_array@@QAEXPAUR_constant@@AAUR_constant_load@@ABU?$_vector4@M@@@Z ENDP ; R_constant_array::set
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector4.h
;	COMDAT ?set@?$_vector4@M@@QAEAAU1@MMMM@Z
_TEXT	SEGMENT
__x$ = 8						; size = 4
__y$ = 12						; size = 4
__z$ = 16						; size = 4
__w$ = 20						; size = 4
?set@?$_vector4@M@@QAEAAU1@MMMM@Z PROC			; _vector4<float>::set, COMDAT
; _this$ = ecx

; 17   : 	IC	SelfRef 	set(T _x, T _y, T _z, T _w=1)		{ x=_x;		y=_y;		z=_z;		w=_w;		return *this; }

	movss	xmm0, DWORD PTR __x$[esp-4]
	mov	eax, ecx
	movss	DWORD PTR [ecx], xmm0
	movss	xmm0, DWORD PTR __y$[esp-4]
	movss	DWORD PTR [ecx+4], xmm0
	movss	xmm0, DWORD PTR __z$[esp-4]
	movss	DWORD PTR [ecx+8], xmm0
	movss	xmm0, DWORD PTR __w$[esp-4]
	movss	DWORD PTR [ecx+12], xmm0
	ret	16					; 00000010H
?set@?$_vector4@M@@QAEAAU1@MMMM@Z ENDP			; _vector4<float>::set
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\FixedVector.h
;	COMDAT ??A?$svector@V?$resptr_core@USPass@@V?$resptr_base@USPass@@@@@@$01@@QAEAAV?$resptr_core@USPass@@V?$resptr_base@USPass@@@@@@I@Z
_TEXT	SEGMENT
_id$ = 8						; size = 4
??A?$svector@V?$resptr_core@USPass@@V?$resptr_base@USPass@@@@@@$01@@QAEAAV?$resptr_core@USPass@@V?$resptr_base@USPass@@@@@@I@Z PROC ; svector<resptr_core<SPass,resptr_base<SPass> >,2>::operator[], COMDAT
; _this$ = ecx

; 38   : 	IC reference		operator[] (u32 id)			{ VERIFY(id<count); return array[id];	}

	mov	eax, DWORD PTR _id$[esp-4]
	lea	eax, DWORD PTR [ecx+eax*4]
	ret	4
??A?$svector@V?$resptr_core@USPass@@V?$resptr_base@USPass@@@@@@$01@@QAEAAV?$resptr_core@USPass@@V?$resptr_base@USPass@@@@@@I@Z ENDP ; svector<resptr_core<SPass,resptr_base<SPass> >,2>::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
;	COMDAT ??D?$resptr_core@VR_constant_table@@V?$resptr_base@VR_constant_table@@@@@@QBEAAVR_constant_table@@XZ
_TEXT	SEGMENT
??D?$resptr_core@VR_constant_table@@V?$resptr_base@VR_constant_table@@@@@@QBEAAVR_constant_table@@XZ PROC ; resptr_core<R_constant_table,resptr_base<R_constant_table> >::operator*, COMDAT
; _this$ = ecx

; 70   : 	T &					operator*() const												{	return *p_;	}

	mov	eax, DWORD PTR [ecx]
	ret	0
??D?$resptr_core@VR_constant_table@@V?$resptr_base@VR_constant_table@@@@@@QBEAAVR_constant_table@@XZ ENDP ; resptr_core<R_constant_table,resptr_base<R_constant_table> >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
;	COMDAT ??1?$resptr_core@UShader@@Uresptrcode_shader@@@@QAE@XZ
_TEXT	SEGMENT
??1?$resptr_core@UShader@@Uresptrcode_shader@@@@QAE@XZ PROC ; resptr_core<Shader,resptrcode_shader>::~resptr_core<Shader,resptrcode_shader>, COMDAT
; _this$ = ecx

; 64   : 						~resptr_core	()												{	_dec();						}

	jmp	DWORD PTR __imp_?_dec@?$resptr_base@UShader@@@@IAEXXZ
??1?$resptr_core@UShader@@Uresptrcode_shader@@@@QAE@XZ ENDP ; resptr_core<Shader,resptrcode_shader>::~resptr_core<Shader,resptrcode_shader>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
;	COMDAT ??0?$resptr_core@UShader@@Uresptrcode_shader@@@@QAE@XZ
_TEXT	SEGMENT
??0?$resptr_core@UShader@@Uresptrcode_shader@@@@QAE@XZ PROC ; resptr_core<Shader,resptrcode_shader>::resptr_core<Shader,resptrcode_shader>, COMDAT
; _this$ = ecx

; 61   : 						resptr_core		()												{	p_ = 0;						}

	mov	DWORD PTR [ecx], 0
	mov	eax, ecx
	ret	0
??0?$resptr_core@UShader@@Uresptrcode_shader@@@@QAE@XZ ENDP ; resptr_core<Shader,resptrcode_shader>::resptr_core<Shader,resptrcode_shader>
_TEXT	ENDS
END
