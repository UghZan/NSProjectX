; Listing generated by Microsoft (R) Optimizing Compiler Version 19.29.30146.0 

	TITLE	i:\vitalya\mine\nsprojectx\nspx_build\intermediate\release-win32\xrrender_r1\pslibrary.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	??_C@_0N@KDJLGDBP@particles?4xr@		; `string'
PUBLIC	??_C@_0M@FDPKAAFL@$game_data$@			; `string'
PUBLIC	??_C@_0CB@MNJHEPBF@PS?5Library?3?5Unsupported?5version@ ; `string'
PUBLIC	??_C@_0BG@PFJIIDDI@Can?8t?5find?5file?3?5?8?$CFs?8@ ; `string'
PUBLIC	??_C@_0BG@FKFOLPDI@CPSLibrary?3?3RenamePED@	; `string'
PUBLIC	??_C@_0DJ@NDCAIDJB@I?3?2Vitalya?2mine?2NSProjectX?2laye@ ; `string'
PUBLIC	??_C@_0BL@CHPGCBJE@src?$CG?$CGnew_name?$CG?$CGnew_name?$FL0?$FN@ ; `string'
PUBLIC	??_C@_0BG@FJNKGLFG@CPSLibrary?3?3RenamePGD@	; `string'
PUBLIC	??_C@_0BB@KDCDFEAK@CPSLibrary?3?3Load@		; `string'
PUBLIC	??_C@_0CA@JIEJDHOP@F?9?$DOfind_chunk?$CIPS_CHUNK_VERSION?$CJ@ ; `string'
PUBLIC	??_C@_0CF@EIJAPNAM@PS?5Library?5was?5succesfully?5relo@ ; `string'
;	COMDAT ?ignore_always@?3??Load@CPSLibrary@@QAE_NPBD@Z@4_NA
_BSS	SEGMENT
?ignore_always@?3??Load@CPSLibrary@@QAE_NPBD@Z@4_NA DB 01H DUP (?) ; `CPSLibrary::Load'::`4'::ignore_always
_BSS	ENDS
;	COMDAT ?ignore_always@?3??RenamePGD@CPSLibrary@@QAEXPAVCPGDef@PS@@PBD@Z@4_NA
_BSS	SEGMENT
?ignore_always@?3??RenamePGD@CPSLibrary@@QAEXPAVCPGDef@PS@@PBD@Z@4_NA DB 01H DUP (?) ; `CPSLibrary::RenamePGD'::`4'::ignore_always
_BSS	ENDS
;	COMDAT ?ignore_always@?3??RenamePED@CPSLibrary@@QAEXPAVCPEDef@PS@@PBD@Z@4_NA
_BSS	SEGMENT
?ignore_always@?3??RenamePED@CPSLibrary@@QAEXPAVCPEDef@PS@@PBD@Z@4_NA DB 01H DUP (?) ; `CPSLibrary::RenamePED'::`4'::ignore_always
_BSS	ENDS
;	COMDAT ??_C@_0CF@EIJAPNAM@PS?5Library?5was?5succesfully?5relo@
CONST	SEGMENT
??_C@_0CF@EIJAPNAM@PS?5Library?5was?5succesfully?5relo@ DB 'PS Library wa'
	DB	's succesfully reloaded.', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@JIEJDHOP@F?9?$DOfind_chunk?$CIPS_CHUNK_VERSION?$CJ@
CONST	SEGMENT
??_C@_0CA@JIEJDHOP@F?9?$DOfind_chunk?$CIPS_CHUNK_VERSION?$CJ@ DB 'F->find'
	DB	'_chunk(PS_CHUNK_VERSION)', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@KDCDFEAK@CPSLibrary?3?3Load@
CONST	SEGMENT
??_C@_0BB@KDCDFEAK@CPSLibrary?3?3Load@ DB 'CPSLibrary::Load', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@FJNKGLFG@CPSLibrary?3?3RenamePGD@
CONST	SEGMENT
??_C@_0BG@FJNKGLFG@CPSLibrary?3?3RenamePGD@ DB 'CPSLibrary::RenamePGD', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@CHPGCBJE@src?$CG?$CGnew_name?$CG?$CGnew_name?$FL0?$FN@
CONST	SEGMENT
??_C@_0BL@CHPGCBJE@src?$CG?$CGnew_name?$CG?$CGnew_name?$FL0?$FN@ DB 'src&'
	DB	'&new_name&&new_name[0]', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DJ@NDCAIDJB@I?3?2Vitalya?2mine?2NSProjectX?2laye@
CONST	SEGMENT
??_C@_0DJ@NDCAIDJB@I?3?2Vitalya?2mine?2NSProjectX?2laye@ DB 'I:\Vitalya\m'
	DB	'ine\NSProjectX\layers\xrRender\PSLibrary.cpp', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@FKFOLPDI@CPSLibrary?3?3RenamePED@
CONST	SEGMENT
??_C@_0BG@FKFOLPDI@CPSLibrary?3?3RenamePED@ DB 'CPSLibrary::RenamePED', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@PFJIIDDI@Can?8t?5find?5file?3?5?8?$CFs?8@
CONST	SEGMENT
??_C@_0BG@PFJIIDDI@Can?8t?5find?5file?3?5?8?$CFs?8@ DB 'Can''t find file:'
	DB	' ''%s''', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@MNJHEPBF@PS?5Library?3?5Unsupported?5version@
CONST	SEGMENT
??_C@_0CB@MNJHEPBF@PS?5Library?3?5Unsupported?5version@ DB 'PS Library: U'
	DB	'nsupported version.', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@FDPKAAFL@$game_data$@
CONST	SEGMENT
??_C@_0M@FDPKAAFL@$game_data$@ DB '$game_data$', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@KDJLGDBP@particles?4xr@
CONST	SEGMENT
??_C@_0N@KDJLGDBP@particles?4xr@ DB 'particles.xr', 00H	; `string'
PUBLIC	?Name@CPEDef@PS@@QBEPBDXZ			; PS::CPEDef::Name
PUBLIC	?xr_strcmp@@YAHABVshared_str@@PBD@Z		; xr_strcmp
PUBLIC	?begin@?$vector@PAVCPEDef@PS@@V?$xalloc@PAVCPEDef@PS@@@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPEDef@PS@@@std@@@std@@@2@XZ ; std::vector<PS::CPEDef *,xalloc<PS::CPEDef *> >::begin
PUBLIC	??$addressof@V?$_Vector_val@U?$_Simple_types@PAVCPEDef@PS@@@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@PAVCPEDef@PS@@@std@@@0@AAV10@@Z ; std::addressof<std::_Vector_val<std::_Simple_types<PS::CPEDef *> > >
PUBLIC	??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPEDef@PS@@@std@@@std@@@std@@QAE@PAPAVCPEDef@PS@@PBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<PS::CPEDef *> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<PS::CPEDef *> > >
PUBLIC	??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPEDef@PS@@@std@@@std@@@std@@QAE@PAPAVCPEDef@PS@@PBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<PS::CPEDef *> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<PS::CPEDef *> > >
PUBLIC	?end@?$vector@PAVCPEDef@PS@@V?$xalloc@PAVCPEDef@PS@@@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPEDef@PS@@@std@@@std@@@2@XZ ; std::vector<PS::CPEDef *,xalloc<PS::CPEDef *> >::end
PUBLIC	?begin@?$vector@PAVCPGDef@PS@@V?$xalloc@PAVCPGDef@PS@@@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPGDef@PS@@@std@@@std@@@2@XZ ; std::vector<PS::CPGDef *,xalloc<PS::CPGDef *> >::begin
PUBLIC	??$addressof@V?$_Vector_val@U?$_Simple_types@PAVCPGDef@PS@@@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@PAVCPGDef@PS@@@std@@@0@AAV10@@Z ; std::addressof<std::_Vector_val<std::_Simple_types<PS::CPGDef *> > >
PUBLIC	??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPGDef@PS@@@std@@@std@@@std@@QAE@PAPAVCPGDef@PS@@PBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<PS::CPGDef *> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<PS::CPGDef *> > >
PUBLIC	??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPGDef@PS@@@std@@@std@@@std@@QAE@PAPAVCPGDef@PS@@PBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<PS::CPGDef *> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<PS::CPGDef *> > >
PUBLIC	?end@?$vector@PAVCPGDef@PS@@V?$xalloc@PAVCPGDef@PS@@@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPGDef@PS@@@std@@@std@@@2@XZ ; std::vector<PS::CPGDef *,xalloc<PS::CPGDef *> >::end
PUBLIC	??$destroy@PAVCPGDef@PS@@@?$_Normal_allocator_traits@V?$xalloc@PAVCPGDef@PS@@@@@std@@SAXAAV?$xalloc@PAVCPGDef@PS@@@@PAPAVCPGDef@PS@@@Z ; std::_Normal_allocator_traits<xalloc<PS::CPGDef *> >::destroy<PS::CPGDef *>
PUBLIC	?destroy@?$xalloc@PAVCPGDef@PS@@@@QAEXPAPAVCPGDef@PS@@@Z ; xalloc<PS::CPGDef *>::destroy
PUBLIC	??$_Destroy_in_place@PAPAVCPGDef@PS@@@std@@YAXAAPAPAVCPGDef@PS@@@Z ; std::_Destroy_in_place<PS::CPGDef * *>
PUBLIC	??$_Unfancy@PAVCPGDef@PS@@@std@@YAPAPAVCPGDef@PS@@PAPAV12@@Z ; std::_Unfancy<PS::CPGDef *>
PUBLIC	?_Getal@?$vector@PAVCPGDef@PS@@V?$xalloc@PAVCPGDef@PS@@@@@std@@AAEAAV?$xalloc@PAVCPGDef@PS@@@@XZ ; std::vector<PS::CPGDef *,xalloc<PS::CPGDef *> >::_Getal
PUBLIC	?_Get_first@?$_Compressed_pair@V?$xalloc@PAVCPGDef@PS@@@@V?$_Vector_val@U?$_Simple_types@PAVCPGDef@PS@@@std@@@std@@$00@std@@QAEAAV?$xalloc@PAVCPGDef@PS@@@@XZ ; std::_Compressed_pair<xalloc<PS::CPGDef *>,std::_Vector_val<std::_Simple_types<PS::CPGDef *> >,1>::_Get_first
PUBLIC	??$destroy@PAVCPEDef@PS@@@?$_Normal_allocator_traits@V?$xalloc@PAVCPEDef@PS@@@@@std@@SAXAAV?$xalloc@PAVCPEDef@PS@@@@PAPAVCPEDef@PS@@@Z ; std::_Normal_allocator_traits<xalloc<PS::CPEDef *> >::destroy<PS::CPEDef *>
PUBLIC	?destroy@?$xalloc@PAVCPEDef@PS@@@@QAEXPAPAVCPEDef@PS@@@Z ; xalloc<PS::CPEDef *>::destroy
PUBLIC	??$_Destroy_in_place@PAPAVCPEDef@PS@@@std@@YAXAAPAPAVCPEDef@PS@@@Z ; std::_Destroy_in_place<PS::CPEDef * *>
PUBLIC	??$_Unfancy@PAVCPEDef@PS@@@std@@YAPAPAVCPEDef@PS@@PAPAV12@@Z ; std::_Unfancy<PS::CPEDef *>
PUBLIC	?_Getal@?$vector@PAVCPEDef@PS@@V?$xalloc@PAVCPEDef@PS@@@@@std@@AAEAAV?$xalloc@PAVCPEDef@PS@@@@XZ ; std::vector<PS::CPEDef *,xalloc<PS::CPEDef *> >::_Getal
PUBLIC	?_Get_first@?$_Compressed_pair@V?$xalloc@PAVCPEDef@PS@@@@V?$_Vector_val@U?$_Simple_types@PAVCPEDef@PS@@@std@@@std@@$00@std@@QAEAAV?$xalloc@PAVCPEDef@PS@@@@XZ ; std::_Compressed_pair<xalloc<PS::CPEDef *>,std::_Vector_val<std::_Simple_types<PS::CPEDef *> >,1>::_Get_first
PUBLIC	?_Destroy@?$vector@PAVCPGDef@PS@@V?$xalloc@PAVCPGDef@PS@@@@@std@@AAEXPAPAVCPGDef@PS@@0@Z ; std::vector<PS::CPGDef *,xalloc<PS::CPGDef *> >::_Destroy
PUBLIC	??$_Destroy_range@V?$xalloc@PAVCPGDef@PS@@@@@std@@YAXPAPAVCPGDef@PS@@QAPAV12@AAV?$xalloc@PAVCPGDef@PS@@@@@Z ; std::_Destroy_range<xalloc<PS::CPGDef *> >
PUBLIC	?_Destroy@?$vector@PAVCPEDef@PS@@V?$xalloc@PAVCPEDef@PS@@@@@std@@AAEXPAPAVCPEDef@PS@@0@Z ; std::vector<PS::CPEDef *,xalloc<PS::CPEDef *> >::_Destroy
PUBLIC	??$_Destroy_range@V?$xalloc@PAVCPEDef@PS@@@@@std@@YAXPAPAVCPEDef@PS@@QAPAV12@AAV?$xalloc@PAVCPEDef@PS@@@@@Z ; std::_Destroy_range<xalloc<PS::CPEDef *> >
PUBLIC	?deallocate@?$xalloc@PAVCPGDef@PS@@@@QBEXPAPAVCPGDef@PS@@I@Z ; xalloc<PS::CPGDef *>::deallocate
PUBLIC	??$xr_free@PAVCPGDef@PS@@@@YAXAAPAPAVCPGDef@PS@@@Z ; xr_free<PS::CPGDef *>
PUBLIC	?deallocate@?$xalloc@PAVCPEDef@PS@@@@QBEXPAPAVCPEDef@PS@@I@Z ; xalloc<PS::CPEDef *>::deallocate
PUBLIC	??$xr_free@PAVCPEDef@PS@@@@YAXAAPAPAVCPEDef@PS@@@Z ; xr_free<PS::CPEDef *>
PUBLIC	??$swap@PAVCPGDef@PS@@$0A@@std@@YAXAAPAVCPGDef@PS@@0@Z ; std::swap<PS::CPGDef *,0>
PUBLIC	??$_Med3_unchecked@PAPAVCPGDef@PS@@P6A_NPBV12@0@Z@std@@YAXPAPAVCPGDef@PS@@00P6A_NPBV12@1@Z@Z ; std::_Med3_unchecked<PS::CPGDef * *,bool (__cdecl*)(PS::CPGDef const *,PS::CPGDef const *)>
PUBLIC	??$_Pop_heap_hole_unchecked@PAPAVCPGDef@PS@@PAV12@P6A_NPBV12@0@Z@std@@YAXPAPAVCPGDef@PS@@00$$QAPAV12@P6A_NPBV12@2@Z@Z ; std::_Pop_heap_hole_unchecked<PS::CPGDef * *,PS::CPGDef *,bool (__cdecl*)(PS::CPGDef const *,PS::CPGDef const *)>
PUBLIC	??$_Push_heap_by_index@PAPAVCPGDef@PS@@PAV12@P6A_NPBV12@0@Z@std@@YAXPAPAVCPGDef@PS@@HH$$QAPAV12@P6A_NPBV12@2@Z@Z ; std::_Push_heap_by_index<PS::CPGDef * *,PS::CPGDef *,bool (__cdecl*)(PS::CPGDef const *,PS::CPGDef const *)>
PUBLIC	??$_Copy_backward_memmove@PAPAVCPGDef@PS@@PAPAV12@@std@@YAPAPAVCPGDef@PS@@PAPAV12@00@Z ; std::_Copy_backward_memmove<PS::CPGDef * *,PS::CPGDef * *>
PUBLIC	??$swap@PAVCPEDef@PS@@$0A@@std@@YAXAAPAVCPEDef@PS@@0@Z ; std::swap<PS::CPEDef *,0>
PUBLIC	??$_Med3_unchecked@PAPAVCPEDef@PS@@P6A_NPBV12@0@Z@std@@YAXPAPAVCPEDef@PS@@00P6A_NPBV12@1@Z@Z ; std::_Med3_unchecked<PS::CPEDef * *,bool (__cdecl*)(PS::CPEDef const *,PS::CPEDef const *)>
PUBLIC	??$_Pop_heap_hole_unchecked@PAPAVCPEDef@PS@@PAV12@P6A_NPBV12@0@Z@std@@YAXPAPAVCPEDef@PS@@00$$QAPAV12@P6A_NPBV12@2@Z@Z ; std::_Pop_heap_hole_unchecked<PS::CPEDef * *,PS::CPEDef *,bool (__cdecl*)(PS::CPEDef const *,PS::CPEDef const *)>
PUBLIC	??$_Push_heap_by_index@PAPAVCPEDef@PS@@PAV12@P6A_NPBV12@0@Z@std@@YAXPAPAVCPEDef@PS@@HH$$QAPAV12@P6A_NPBV12@2@Z@Z ; std::_Push_heap_by_index<PS::CPEDef * *,PS::CPEDef *,bool (__cdecl*)(PS::CPEDef const *,PS::CPEDef const *)>
PUBLIC	??$_Copy_backward_memmove@PAPAVCPEDef@PS@@PAPAV12@@std@@YAPAPAVCPEDef@PS@@PAPAV12@00@Z ; std::_Copy_backward_memmove<PS::CPEDef * *,PS::CPEDef * *>
PUBLIC	??$construct@PAVCPEDef@PS@@PAV12@@?$_Normal_allocator_traits@V?$xalloc@PAVCPEDef@PS@@@@@std@@SAXAAV?$xalloc@PAVCPEDef@PS@@@@PAPAVCPEDef@PS@@$$QAPAV34@@Z ; std::_Normal_allocator_traits<xalloc<PS::CPEDef *> >::construct<PS::CPEDef *,PS::CPEDef *>
PUBLIC	??$forward@PAVCPEDef@PS@@@std@@YA$$QAPAVCPEDef@PS@@AAPAV12@@Z ; std::forward<PS::CPEDef *>
PUBLIC	??$construct@PAVCPGDef@PS@@PAV12@@?$_Normal_allocator_traits@V?$xalloc@PAVCPGDef@PS@@@@@std@@SAXAAV?$xalloc@PAVCPGDef@PS@@@@PAPAVCPGDef@PS@@$$QAPAV34@@Z ; std::_Normal_allocator_traits<xalloc<PS::CPGDef *> >::construct<PS::CPGDef *,PS::CPGDef *>
PUBLIC	??$forward@PAVCPGDef@PS@@@std@@YA$$QAPAVCPGDef@PS@@AAPAV12@@Z ; std::forward<PS::CPGDef *>
PUBLIC	??$?0AAPAPAVCPGDef@PS@@AAPAPAV01@$0A@@?$pair@PAPAVCPGDef@PS@@PAPAV12@@std@@QAE@AAPAPAVCPGDef@PS@@0@Z ; std::pair<PS::CPGDef * *,PS::CPGDef * *>::pair<PS::CPGDef * *,PS::CPGDef * *><PS::CPGDef * * &,PS::CPGDef * * &,0>
PUBLIC	??$iter_swap@PAPAVCPGDef@PS@@PAPAV12@@std@@YAXPAPAVCPGDef@PS@@0@Z ; std::iter_swap<PS::CPGDef * *,PS::CPGDef * *>
PUBLIC	??$_Guess_median_unchecked@PAPAVCPGDef@PS@@P6A_NPBV12@0@Z@std@@YAXPAPAVCPGDef@PS@@00P6A_NPBV12@1@Z@Z ; std::_Guess_median_unchecked<PS::CPGDef * *,bool (__cdecl*)(PS::CPGDef const *,PS::CPGDef const *)>
PUBLIC	??$_Prev_iter@PAPAVCPGDef@PS@@@std@@YAPAPAVCPGDef@PS@@PAPAV12@@Z ; std::_Prev_iter<PS::CPGDef * *>
PUBLIC	??$_Pop_heap_unchecked@PAPAVCPGDef@PS@@P6A_NPBV12@0@Z@std@@YAXPAPAVCPGDef@PS@@0P6A_NPBV12@1@Z@Z ; std::_Pop_heap_unchecked<PS::CPGDef * *,bool (__cdecl*)(PS::CPGDef const *,PS::CPGDef const *)>
PUBLIC	??$_Pop_heap_hole_by_index@PAPAVCPGDef@PS@@PAV12@P6A_NPBV12@0@Z@std@@YAXPAPAVCPGDef@PS@@HH$$QAPAV12@P6A_NPBV12@2@Z@Z ; std::_Pop_heap_hole_by_index<PS::CPGDef * *,PS::CPGDef *,bool (__cdecl*)(PS::CPGDef const *,PS::CPGDef const *)>
PUBLIC	??$_Move_backward_unchecked@PAPAVCPGDef@PS@@PAPAV12@@std@@YAPAPAVCPGDef@PS@@PAPAV12@00@Z ; std::_Move_backward_unchecked<PS::CPGDef * *,PS::CPGDef * *>
PUBLIC	??$?0AAPAPAVCPEDef@PS@@AAPAPAV01@$0A@@?$pair@PAPAVCPEDef@PS@@PAPAV12@@std@@QAE@AAPAPAVCPEDef@PS@@0@Z ; std::pair<PS::CPEDef * *,PS::CPEDef * *>::pair<PS::CPEDef * *,PS::CPEDef * *><PS::CPEDef * * &,PS::CPEDef * * &,0>
PUBLIC	??$iter_swap@PAPAVCPEDef@PS@@PAPAV12@@std@@YAXPAPAVCPEDef@PS@@0@Z ; std::iter_swap<PS::CPEDef * *,PS::CPEDef * *>
PUBLIC	??$_Guess_median_unchecked@PAPAVCPEDef@PS@@P6A_NPBV12@0@Z@std@@YAXPAPAVCPEDef@PS@@00P6A_NPBV12@1@Z@Z ; std::_Guess_median_unchecked<PS::CPEDef * *,bool (__cdecl*)(PS::CPEDef const *,PS::CPEDef const *)>
PUBLIC	??$_Prev_iter@PAPAVCPEDef@PS@@@std@@YAPAPAVCPEDef@PS@@PAPAV12@@Z ; std::_Prev_iter<PS::CPEDef * *>
PUBLIC	??$_Pop_heap_unchecked@PAPAVCPEDef@PS@@P6A_NPBV12@0@Z@std@@YAXPAPAVCPEDef@PS@@0P6A_NPBV12@1@Z@Z ; std::_Pop_heap_unchecked<PS::CPEDef * *,bool (__cdecl*)(PS::CPEDef const *,PS::CPEDef const *)>
PUBLIC	??$_Pop_heap_hole_by_index@PAPAVCPEDef@PS@@PAV12@P6A_NPBV12@0@Z@std@@YAXPAPAVCPEDef@PS@@HH$$QAPAV12@P6A_NPBV12@2@Z@Z ; std::_Pop_heap_hole_by_index<PS::CPEDef * *,PS::CPEDef *,bool (__cdecl*)(PS::CPEDef const *,PS::CPEDef const *)>
PUBLIC	??$_Move_backward_unchecked@PAPAVCPEDef@PS@@PAPAV12@@std@@YAPAPAVCPEDef@PS@@PAPAV12@00@Z ; std::_Move_backward_unchecked<PS::CPEDef * *,PS::CPEDef * *>
PUBLIC	??$_Refancy@PAPAVCPEDef@PS@@$0A@@std@@YAPAPAVCPEDef@PS@@PAPAV12@@Z ; std::_Refancy<PS::CPEDef * *,0>
PUBLIC	??$_Refancy@PAPAVCPGDef@PS@@$0A@@std@@YAPAPAVCPGDef@PS@@PAPAV12@@Z ; std::_Refancy<PS::CPGDef * *,0>
PUBLIC	??$_Emplace_back@PAVCPEDef@PS@@@?$_Uninitialized_backout_al@V?$xalloc@PAVCPEDef@PS@@@@@std@@QAEX$$QAPAVCPEDef@PS@@@Z ; std::_Uninitialized_backout_al<xalloc<PS::CPEDef *> >::_Emplace_back<PS::CPEDef *>
PUBLIC	??$_Emplace_back@PAVCPGDef@PS@@@?$_Uninitialized_backout_al@V?$xalloc@PAVCPGDef@PS@@@@@std@@QAEX$$QAPAVCPGDef@PS@@@Z ; std::_Uninitialized_backout_al<xalloc<PS::CPGDef *> >::_Emplace_back<PS::CPGDef *>
PUBLIC	??$_Partition_by_median_guess_unchecked@PAPAVCPGDef@PS@@P6A_NPBV12@0@Z@std@@YA?AU?$pair@PAPAVCPGDef@PS@@PAPAV12@@0@PAPAVCPGDef@PS@@0P6A_NPBV23@1@Z@Z ; std::_Partition_by_median_guess_unchecked<PS::CPGDef * *,bool (__cdecl*)(PS::CPGDef const *,PS::CPGDef const *)>
PUBLIC	??$_Sort_heap_unchecked@PAPAVCPGDef@PS@@P6A_NPBV12@0@Z@std@@YAXPAPAVCPGDef@PS@@0P6A_NPBV12@1@Z@Z ; std::_Sort_heap_unchecked<PS::CPGDef * *,bool (__cdecl*)(PS::CPGDef const *,PS::CPGDef const *)>
PUBLIC	??$_Make_heap_unchecked@PAPAVCPGDef@PS@@P6A_NPBV12@0@Z@std@@YAXPAPAVCPGDef@PS@@0P6A_NPBV12@1@Z@Z ; std::_Make_heap_unchecked<PS::CPGDef * *,bool (__cdecl*)(PS::CPGDef const *,PS::CPGDef const *)>
PUBLIC	??$_Insertion_sort_unchecked@PAPAVCPGDef@PS@@P6A_NPBV12@0@Z@std@@YAPAPAVCPGDef@PS@@QAPAV12@0P6A_NPBV12@1@Z@Z ; std::_Insertion_sort_unchecked<PS::CPGDef * *,bool (__cdecl*)(PS::CPGDef const *,PS::CPGDef const *)>
PUBLIC	??$_Partition_by_median_guess_unchecked@PAPAVCPEDef@PS@@P6A_NPBV12@0@Z@std@@YA?AU?$pair@PAPAVCPEDef@PS@@PAPAV12@@0@PAPAVCPEDef@PS@@0P6A_NPBV23@1@Z@Z ; std::_Partition_by_median_guess_unchecked<PS::CPEDef * *,bool (__cdecl*)(PS::CPEDef const *,PS::CPEDef const *)>
PUBLIC	??$_Sort_heap_unchecked@PAPAVCPEDef@PS@@P6A_NPBV12@0@Z@std@@YAXPAPAVCPEDef@PS@@0P6A_NPBV12@1@Z@Z ; std::_Sort_heap_unchecked<PS::CPEDef * *,bool (__cdecl*)(PS::CPEDef const *,PS::CPEDef const *)>
PUBLIC	??$_Make_heap_unchecked@PAPAVCPEDef@PS@@P6A_NPBV12@0@Z@std@@YAXPAPAVCPEDef@PS@@0P6A_NPBV12@1@Z@Z ; std::_Make_heap_unchecked<PS::CPEDef * *,bool (__cdecl*)(PS::CPEDef const *,PS::CPEDef const *)>
PUBLIC	??$_Insertion_sort_unchecked@PAPAVCPEDef@PS@@P6A_NPBV12@0@Z@std@@YAPAPAVCPEDef@PS@@QAPAV12@0P6A_NPBV12@1@Z@Z ; std::_Insertion_sort_unchecked<PS::CPEDef * *,bool (__cdecl*)(PS::CPEDef const *,PS::CPEDef const *)>
PUBLIC	??$forward@AAPAPAVCPGDef@PS@@@std@@YAAAPAPAVCPGDef@PS@@AAPAPAV12@@Z ; std::forward<PS::CPGDef * * &>
PUBLIC	??$advance@PAPAVCPGDef@PS@@H@std@@YAXAAPAPAVCPGDef@PS@@H@Z ; std::advance<PS::CPGDef * *,int>
PUBLIC	??$forward@AAPAPAVCPEDef@PS@@@std@@YAAAPAPAVCPEDef@PS@@AAPAPAV12@@Z ; std::forward<PS::CPEDef * * &>
PUBLIC	??$advance@PAPAVCPEDef@PS@@H@std@@YAXAAPAPAVCPEDef@PS@@H@Z ; std::advance<PS::CPEDef * *,int>
PUBLIC	?_Seek_to@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPEDef@PS@@@std@@@std@@@std@@QAEXPBQAVCPEDef@PS@@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<PS::CPEDef *> > >::_Seek_to
PUBLIC	?_Seek_to@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPGDef@PS@@@std@@@std@@@std@@QAEXPBQAVCPGDef@PS@@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<PS::CPGDef *> > >::_Seek_to
PUBLIC	??0?$_Uninitialized_backout_al@V?$xalloc@PAVCPGDef@PS@@@@@std@@QAE@PAPAVCPGDef@PS@@AAV?$xalloc@PAVCPGDef@PS@@@@@Z ; std::_Uninitialized_backout_al<xalloc<PS::CPGDef *> >::_Uninitialized_backout_al<xalloc<PS::CPGDef *> >
PUBLIC	??1?$_Uninitialized_backout_al@V?$xalloc@PAVCPGDef@PS@@@@@std@@QAE@XZ ; std::_Uninitialized_backout_al<xalloc<PS::CPGDef *> >::~_Uninitialized_backout_al<xalloc<PS::CPGDef *> >
PUBLIC	?_Release@?$_Uninitialized_backout_al@V?$xalloc@PAVCPGDef@PS@@@@@std@@QAEPAPAVCPGDef@PS@@XZ ; std::_Uninitialized_backout_al<xalloc<PS::CPGDef *> >::_Release
PUBLIC	??0?$_Uninitialized_backout_al@V?$xalloc@PAVCPEDef@PS@@@@@std@@QAE@PAPAVCPEDef@PS@@AAV?$xalloc@PAVCPEDef@PS@@@@@Z ; std::_Uninitialized_backout_al<xalloc<PS::CPEDef *> >::_Uninitialized_backout_al<xalloc<PS::CPEDef *> >
PUBLIC	??1?$_Uninitialized_backout_al@V?$xalloc@PAVCPEDef@PS@@@@@std@@QAE@XZ ; std::_Uninitialized_backout_al<xalloc<PS::CPEDef *> >::~_Uninitialized_backout_al<xalloc<PS::CPEDef *> >
PUBLIC	?_Release@?$_Uninitialized_backout_al@V?$xalloc@PAVCPEDef@PS@@@@@std@@QAEPAPAVCPEDef@PS@@XZ ; std::_Uninitialized_backout_al<xalloc<PS::CPEDef *> >::_Release
PUBLIC	??$xr_alloc@PAVCPEDef@PS@@@@YAPAPAVCPEDef@PS@@I@Z ; xr_alloc<PS::CPEDef *>
PUBLIC	??$_Get_unwrapped@ABQAPAVCPEDef@PS@@@std@@YA?A_TABQAPAVCPEDef@PS@@@Z ; std::_Get_unwrapped<PS::CPEDef * * const &>
PUBLIC	??$_Uninitialized_move@PAPAVCPEDef@PS@@V?$xalloc@PAVCPEDef@PS@@@@@std@@YAPAPAVCPEDef@PS@@QAPAV12@0PAPAV12@AAV?$xalloc@PAVCPEDef@PS@@@@@Z ; std::_Uninitialized_move<PS::CPEDef * *,xalloc<PS::CPEDef *> >
PUBLIC	??$xr_alloc@PAVCPGDef@PS@@@@YAPAPAVCPGDef@PS@@I@Z ; xr_alloc<PS::CPGDef *>
PUBLIC	??$_Get_unwrapped@ABQAPAVCPGDef@PS@@@std@@YA?A_TABQAPAVCPGDef@PS@@@Z ; std::_Get_unwrapped<PS::CPGDef * * const &>
PUBLIC	??$_Uninitialized_move@PAPAVCPGDef@PS@@V?$xalloc@PAVCPGDef@PS@@@@@std@@YAPAPAVCPGDef@PS@@QAPAV12@0PAPAV12@AAV?$xalloc@PAVCPGDef@PS@@@@@Z ; std::_Uninitialized_move<PS::CPGDef * *,xalloc<PS::CPGDef *> >
PUBLIC	??$move@AAPAVCPEDef@PS@@@std@@YA$$QAPAVCPEDef@PS@@AAPAV12@@Z ; std::move<PS::CPEDef * &>
PUBLIC	??$_To_address@PAPAVCPEDef@PS@@@std@@YA?A_PABQAPAVCPEDef@PS@@@Z ; std::_To_address<PS::CPEDef * *>
PUBLIC	??$move@AAPAVCPGDef@PS@@@std@@YA$$QAPAVCPGDef@PS@@AAPAV12@@Z ; std::move<PS::CPGDef * &>
PUBLIC	??$_To_address@PAPAVCPGDef@PS@@@std@@YA?A_PABQAPAVCPGDef@PS@@@Z ; std::_To_address<PS::CPGDef * *>
PUBLIC	??$_Sort_unchecked@PAPAVCPGDef@PS@@P6A_NPBV12@0@Z@std@@YAXPAPAVCPGDef@PS@@0HP6A_NPBV12@1@Z@Z ; std::_Sort_unchecked<PS::CPGDef * *,bool (__cdecl*)(PS::CPGDef const *,PS::CPGDef const *)>
PUBLIC	??$_Pass_fn@P6A_NPBVCPGDef@PS@@0@Z$0A@@std@@YAP6A_NPBVCPGDef@PS@@0@ZP6A_N00@Z@Z ; std::_Pass_fn<bool (__cdecl*)(PS::CPGDef const *,PS::CPGDef const *),0>
PUBLIC	??$_Sort_unchecked@PAPAVCPEDef@PS@@P6A_NPBV12@0@Z@std@@YAXPAPAVCPEDef@PS@@0HP6A_NPBV12@1@Z@Z ; std::_Sort_unchecked<PS::CPEDef * *,bool (__cdecl*)(PS::CPEDef const *,PS::CPEDef const *)>
PUBLIC	??$_Pass_fn@P6A_NPBVCPEDef@PS@@0@Z$0A@@std@@YAP6A_NPBVCPEDef@PS@@0@ZP6A_N00@Z@Z ; std::_Pass_fn<bool (__cdecl*)(PS::CPEDef const *,PS::CPEDef const *),0>
PUBLIC	??$_Seek_wrapped@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPGDef@PS@@@std@@@std@@@std@@AAPAPAVCPGDef@PS@@@std@@YAXAAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPGDef@PS@@@std@@@std@@@0@AAPAPAVCPGDef@PS@@@Z ; std::_Seek_wrapped<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<PS::CPGDef *> > >,PS::CPGDef * * &>
PUBLIC	??$_Next_iter@PAPAVCPGDef@PS@@@std@@YAPAPAVCPGDef@PS@@PAPAV12@@Z ; std::_Next_iter<PS::CPGDef * *>
PUBLIC	??$next@PAPAVCPGDef@PS@@@std@@YAPAPAVCPGDef@PS@@PAPAV12@H@Z ; std::next<PS::CPGDef * *>
PUBLIC	??$distance@PAPAVCPGDef@PS@@@std@@YAHPAPAVCPGDef@PS@@0@Z ; std::distance<PS::CPGDef * *>
PUBLIC	??$_Adl_verify_range@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPGDef@PS@@@std@@@std@@@std@@V12@@std@@YAXABV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPGDef@PS@@@std@@@std@@@0@0@Z ; std::_Adl_verify_range<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<PS::CPGDef *> > >,std::_Vector_iterator<std::_Vector_val<std::_Simple_types<PS::CPGDef *> > > >
PUBLIC	??$_Seek_wrapped@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPEDef@PS@@@std@@@std@@@std@@AAPAPAVCPEDef@PS@@@std@@YAXAAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPEDef@PS@@@std@@@std@@@0@AAPAPAVCPEDef@PS@@@Z ; std::_Seek_wrapped<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<PS::CPEDef *> > >,PS::CPEDef * * &>
PUBLIC	??$_Next_iter@PAPAVCPEDef@PS@@@std@@YAPAPAVCPEDef@PS@@PAPAV12@@Z ; std::_Next_iter<PS::CPEDef * *>
PUBLIC	??$next@PAPAVCPEDef@PS@@@std@@YAPAPAVCPEDef@PS@@PAPAV12@H@Z ; std::next<PS::CPEDef * *>
PUBLIC	??$distance@PAPAVCPEDef@PS@@@std@@YAHPAPAVCPEDef@PS@@0@Z ; std::distance<PS::CPEDef * *>
PUBLIC	??$_Adl_verify_range@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPEDef@PS@@@std@@@std@@@std@@V12@@std@@YAXABV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPEDef@PS@@@std@@@std@@@0@0@Z ; std::_Adl_verify_range<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<PS::CPEDef *> > >,std::_Vector_iterator<std::_Vector_val<std::_Simple_types<PS::CPEDef *> > > >
PUBLIC	?max_size@?$xalloc@PAVCPEDef@PS@@@@QBEIXZ	; xalloc<PS::CPEDef *>::max_size
PUBLIC	?_Get_first@?$_Compressed_pair@V?$xalloc@PAVCPEDef@PS@@@@V?$_Vector_val@U?$_Simple_types@PAVCPEDef@PS@@@std@@@std@@$00@std@@QBEABV?$xalloc@PAVCPEDef@PS@@@@XZ ; std::_Compressed_pair<xalloc<PS::CPEDef *>,std::_Vector_val<std::_Simple_types<PS::CPEDef *> >,1>::_Get_first
PUBLIC	?max_size@?$xalloc@PAVCPGDef@PS@@@@QBEIXZ	; xalloc<PS::CPGDef *>::max_size
PUBLIC	?_Get_first@?$_Compressed_pair@V?$xalloc@PAVCPGDef@PS@@@@V?$_Vector_val@U?$_Simple_types@PAVCPGDef@PS@@@std@@@std@@$00@std@@QBEABV?$xalloc@PAVCPGDef@PS@@@@XZ ; std::_Compressed_pair<xalloc<PS::CPGDef *>,std::_Vector_val<std::_Simple_types<PS::CPGDef *> >,1>::_Get_first
PUBLIC	?max_size@?$_Normal_allocator_traits@V?$xalloc@PAVCPEDef@PS@@@@@std@@SAIABV?$xalloc@PAVCPEDef@PS@@@@@Z ; std::_Normal_allocator_traits<xalloc<PS::CPEDef *> >::max_size
PUBLIC	?capacity@?$vector@PAVCPEDef@PS@@V?$xalloc@PAVCPEDef@PS@@@@@std@@QBEIXZ ; std::vector<PS::CPEDef *,xalloc<PS::CPEDef *> >::capacity
PUBLIC	?_Umove_if_noexcept1@?$vector@PAVCPEDef@PS@@V?$xalloc@PAVCPEDef@PS@@@@@std@@AAEXPAPAVCPEDef@PS@@00U?$integral_constant@_N$00@2@@Z ; std::vector<PS::CPEDef *,xalloc<PS::CPEDef *> >::_Umove_if_noexcept1
PUBLIC	?_Getal@?$vector@PAVCPEDef@PS@@V?$xalloc@PAVCPEDef@PS@@@@@std@@ABEABV?$xalloc@PAVCPEDef@PS@@@@XZ ; std::vector<PS::CPEDef *,xalloc<PS::CPEDef *> >::_Getal
PUBLIC	?max_size@?$_Normal_allocator_traits@V?$xalloc@PAVCPGDef@PS@@@@@std@@SAIABV?$xalloc@PAVCPGDef@PS@@@@@Z ; std::_Normal_allocator_traits<xalloc<PS::CPGDef *> >::max_size
PUBLIC	?capacity@?$vector@PAVCPGDef@PS@@V?$xalloc@PAVCPGDef@PS@@@@@std@@QBEIXZ ; std::vector<PS::CPGDef *,xalloc<PS::CPGDef *> >::capacity
PUBLIC	?_Umove_if_noexcept1@?$vector@PAVCPGDef@PS@@V?$xalloc@PAVCPGDef@PS@@@@@std@@AAEXPAPAVCPGDef@PS@@00U?$integral_constant@_N$00@2@@Z ; std::vector<PS::CPGDef *,xalloc<PS::CPGDef *> >::_Umove_if_noexcept1
PUBLIC	?_Getal@?$vector@PAVCPGDef@PS@@V?$xalloc@PAVCPGDef@PS@@@@@std@@ABEABV?$xalloc@PAVCPGDef@PS@@@@XZ ; std::vector<PS::CPGDef *,xalloc<PS::CPGDef *> >::_Getal
PUBLIC	??_GCPEDef@PS@@QAEPAXI@Z			; PS::CPEDef::`scalar deleting destructor'
PUBLIC	??_GCPGDef@PS@@QAEPAXI@Z			; PS::CPGDef::`scalar deleting destructor'
PUBLIC	?allocate@?$xalloc@PAVCPEDef@PS@@@@QBEPAPAVCPEDef@PS@@IPBX@Z ; xalloc<PS::CPEDef *>::allocate
PUBLIC	?construct@?$xalloc@PAVCPEDef@PS@@@@QAEXPAPAVCPEDef@PS@@ABQAV23@@Z ; xalloc<PS::CPEDef *>::construct
PUBLIC	?max_size@?$vector@PAVCPEDef@PS@@V?$xalloc@PAVCPEDef@PS@@@@@std@@QBEIXZ ; std::vector<PS::CPEDef *,xalloc<PS::CPEDef *> >::max_size
PUBLIC	?_Umove@?$vector@PAVCPEDef@PS@@V?$xalloc@PAVCPEDef@PS@@@@@std@@AAEPAPAVCPEDef@PS@@PAPAV34@00@Z ; std::vector<PS::CPEDef *,xalloc<PS::CPEDef *> >::_Umove
PUBLIC	?_Umove_if_noexcept@?$vector@PAVCPEDef@PS@@V?$xalloc@PAVCPEDef@PS@@@@@std@@AAEXPAPAVCPEDef@PS@@00@Z ; std::vector<PS::CPEDef *,xalloc<PS::CPEDef *> >::_Umove_if_noexcept
PUBLIC	?_Calculate_growth@?$vector@PAVCPEDef@PS@@V?$xalloc@PAVCPEDef@PS@@@@@std@@ABEII@Z ; std::vector<PS::CPEDef *,xalloc<PS::CPEDef *> >::_Calculate_growth
PUBLIC	?_Change_array@?$vector@PAVCPEDef@PS@@V?$xalloc@PAVCPEDef@PS@@@@@std@@AAEXQAPAVCPEDef@PS@@II@Z ; std::vector<PS::CPEDef *,xalloc<PS::CPEDef *> >::_Change_array
PUBLIC	?_Xlength@?$vector@PAVCPEDef@PS@@V?$xalloc@PAVCPEDef@PS@@@@@std@@CAXXZ ; std::vector<PS::CPEDef *,xalloc<PS::CPEDef *> >::_Xlength
PUBLIC	?allocate@?$xalloc@PAVCPGDef@PS@@@@QBEPAPAVCPGDef@PS@@IPBX@Z ; xalloc<PS::CPGDef *>::allocate
PUBLIC	?construct@?$xalloc@PAVCPGDef@PS@@@@QAEXPAPAVCPGDef@PS@@ABQAV23@@Z ; xalloc<PS::CPGDef *>::construct
PUBLIC	?max_size@?$vector@PAVCPGDef@PS@@V?$xalloc@PAVCPGDef@PS@@@@@std@@QBEIXZ ; std::vector<PS::CPGDef *,xalloc<PS::CPGDef *> >::max_size
PUBLIC	?_Umove@?$vector@PAVCPGDef@PS@@V?$xalloc@PAVCPGDef@PS@@@@@std@@AAEPAPAVCPGDef@PS@@PAPAV34@00@Z ; std::vector<PS::CPGDef *,xalloc<PS::CPGDef *> >::_Umove
PUBLIC	?_Umove_if_noexcept@?$vector@PAVCPGDef@PS@@V?$xalloc@PAVCPGDef@PS@@@@@std@@AAEXPAPAVCPGDef@PS@@00@Z ; std::vector<PS::CPGDef *,xalloc<PS::CPGDef *> >::_Umove_if_noexcept
PUBLIC	?_Calculate_growth@?$vector@PAVCPGDef@PS@@V?$xalloc@PAVCPGDef@PS@@@@@std@@ABEII@Z ; std::vector<PS::CPGDef *,xalloc<PS::CPGDef *> >::_Calculate_growth
PUBLIC	?_Change_array@?$vector@PAVCPGDef@PS@@V?$xalloc@PAVCPGDef@PS@@@@@std@@AAEXQAPAVCPGDef@PS@@II@Z ; std::vector<PS::CPGDef *,xalloc<PS::CPGDef *> >::_Change_array
PUBLIC	?_Xlength@?$vector@PAVCPGDef@PS@@V?$xalloc@PAVCPGDef@PS@@@@@std@@CAXXZ ; std::vector<PS::CPGDef *,xalloc<PS::CPGDef *> >::_Xlength
PUBLIC	?_Unwrapped@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPEDef@PS@@@std@@@std@@@std@@QBEPAPAVCPEDef@PS@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<PS::CPEDef *> > >::_Unwrapped
PUBLIC	?_Unwrapped@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPGDef@PS@@@std@@@std@@@std@@QBEPAPAVCPGDef@PS@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<PS::CPGDef *> > >::_Unwrapped
PUBLIC	??R?$xr_special_free@$0A@VCPEDef@PS@@@@QAEXAAPAVCPEDef@PS@@@Z ; xr_special_free<0,PS::CPEDef>::operator()
PUBLIC	??R?$xr_special_free@$0A@VCPGDef@PS@@@@QAEXAAPAVCPGDef@PS@@@Z ; xr_special_free<0,PS::CPGDef>::operator()
PUBLIC	??$_Emplace_reallocate@ABQAVCPEDef@PS@@@?$vector@PAVCPEDef@PS@@V?$xalloc@PAVCPEDef@PS@@@@@std@@QAEPAPAVCPEDef@PS@@QAPAV23@ABQAV23@@Z ; std::vector<PS::CPEDef *,xalloc<PS::CPEDef *> >::_Emplace_reallocate<PS::CPEDef * const &>
PUBLIC	??$construct@PAVCPEDef@PS@@ABQAV12@@?$_Normal_allocator_traits@V?$xalloc@PAVCPEDef@PS@@@@@std@@SAXAAV?$xalloc@PAVCPEDef@PS@@@@PAPAVCPEDef@PS@@ABQAV34@@Z ; std::_Normal_allocator_traits<xalloc<PS::CPEDef *> >::construct<PS::CPEDef *,PS::CPEDef * const &>
PUBLIC	??$forward@ABQAVCPEDef@PS@@@std@@YAABQAVCPEDef@PS@@ABQAV12@@Z ; std::forward<PS::CPEDef * const &>
PUBLIC	??$_Emplace_reallocate@ABQAVCPGDef@PS@@@?$vector@PAVCPGDef@PS@@V?$xalloc@PAVCPGDef@PS@@@@@std@@QAEPAPAVCPGDef@PS@@QAPAV23@ABQAV23@@Z ; std::vector<PS::CPGDef *,xalloc<PS::CPGDef *> >::_Emplace_reallocate<PS::CPGDef * const &>
PUBLIC	??$construct@PAVCPGDef@PS@@ABQAV12@@?$_Normal_allocator_traits@V?$xalloc@PAVCPGDef@PS@@@@@std@@SAXAAV?$xalloc@PAVCPGDef@PS@@@@PAPAVCPGDef@PS@@ABQAV34@@Z ; std::_Normal_allocator_traits<xalloc<PS::CPGDef *> >::construct<PS::CPGDef *,PS::CPGDef * const &>
PUBLIC	??$forward@ABQAVCPGDef@PS@@@std@@YAABQAVCPGDef@PS@@ABQAV12@@Z ; std::forward<PS::CPGDef * const &>
PUBLIC	??$sort@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPGDef@PS@@@std@@@std@@@std@@P6A_NPBVCPGDef@PS@@0@Z@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPGDef@PS@@@std@@@std@@@0@0P6A_NPBVCPGDef@PS@@1@Z@Z ; std::sort<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<PS::CPGDef *> > >,bool (__cdecl*)(PS::CPGDef const *,PS::CPGDef const *)>
PUBLIC	??$sort@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPEDef@PS@@@std@@@std@@@std@@P6A_NPBVCPEDef@PS@@0@Z@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPEDef@PS@@@std@@@std@@@0@0P6A_NPBVCPEDef@PS@@1@Z@Z ; std::sort<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<PS::CPEDef *> > >,bool (__cdecl*)(PS::CPEDef const *,PS::CPEDef const *)>
PUBLIC	??$xr_new@VCPGDef@PS@@@@YAPAVCPGDef@PS@@XZ	; xr_new<PS::CPGDef>
PUBLIC	??$xr_new@VCPEDef@PS@@@@YAPAVCPEDef@PS@@XZ	; xr_new<PS::CPEDef>
PUBLIC	??$_Get_unwrapped@ABV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPGDef@PS@@@std@@@std@@@std@@@std@@YA?A_TABV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPGDef@PS@@@std@@@std@@@0@@Z ; std::_Get_unwrapped<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<PS::CPGDef *> > > const &>
PUBLIC	??$_Get_unwrapped@AAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPGDef@PS@@@std@@@std@@@std@@@std@@YA?A_TAAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPGDef@PS@@@std@@@std@@@0@@Z ; std::_Get_unwrapped<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<PS::CPGDef *> > > &>
PUBLIC	??$lower_bound@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPGDef@PS@@@std@@@std@@@std@@PBDP6A_NPBVCPGDef@PS@@PBD@Z@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPGDef@PS@@@std@@@std@@@0@V10@V10@ABQBDP6A_NPBVCPGDef@PS@@PBD@Z@Z ; std::lower_bound<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<PS::CPGDef *> > >,char const *,bool (__cdecl*)(PS::CPGDef const *,char const *)>
PUBLIC	??$_Get_unwrapped@ABV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPEDef@PS@@@std@@@std@@@std@@@std@@YA?A_TABV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPEDef@PS@@@std@@@std@@@0@@Z ; std::_Get_unwrapped<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<PS::CPEDef *> > > const &>
PUBLIC	??$_Get_unwrapped@AAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPEDef@PS@@@std@@@std@@@std@@@std@@YA?A_TAAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPEDef@PS@@@std@@@std@@@0@@Z ; std::_Get_unwrapped<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<PS::CPEDef *> > > &>
PUBLIC	??$lower_bound@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPEDef@PS@@@std@@@std@@@std@@PBDP6A_NPBVCPEDef@PS@@PBD@Z@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPEDef@PS@@@std@@@std@@@0@V10@V10@ABQBDP6A_NPBVCPEDef@PS@@PBD@Z@Z ; std::lower_bound<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<PS::CPEDef *> > >,char const *,bool (__cdecl*)(PS::CPEDef const *,char const *)>
PUBLIC	??$xr_delete@VCPGDef@PS@@@@YAXAAPAVCPGDef@PS@@@Z ; xr_delete<PS::CPGDef>
PUBLIC	??$xr_delete@VCPEDef@PS@@@@YAXAAPAVCPEDef@PS@@@Z ; xr_delete<PS::CPEDef>
PUBLIC	?clear@?$vector@PAVCPEDef@PS@@V?$xalloc@PAVCPEDef@PS@@@@@std@@QAEXXZ ; std::vector<PS::CPEDef *,xalloc<PS::CPEDef *> >::clear
PUBLIC	?clear@?$vector@PAVCPGDef@PS@@V?$xalloc@PAVCPGDef@PS@@@@@std@@QAEXXZ ; std::vector<PS::CPGDef *,xalloc<PS::CPGDef *> >::clear
PUBLIC	?_Orphan_range@?$vector@PAVCPEDef@PS@@V?$xalloc@PAVCPEDef@PS@@@@@std@@ABEXPAPAVCPEDef@PS@@0@Z ; std::vector<PS::CPEDef *,xalloc<PS::CPEDef *> >::_Orphan_range
PUBLIC	?clear_and_free@?$xr_vector@PAVCPEDef@PS@@V?$xalloc@PAVCPEDef@PS@@@@@@QAEXXZ ; xr_vector<PS::CPEDef *,xalloc<PS::CPEDef *> >::clear_and_free
PUBLIC	?_Orphan_range@?$vector@PAVCPGDef@PS@@V?$xalloc@PAVCPGDef@PS@@@@@std@@ABEXPAPAVCPGDef@PS@@0@Z ; std::vector<PS::CPGDef *,xalloc<PS::CPGDef *> >::_Orphan_range
PUBLIC	?clear_and_free@?$xr_vector@PAVCPGDef@PS@@V?$xalloc@PAVCPGDef@PS@@@@@@QAEXXZ ; xr_vector<PS::CPGDef *,xalloc<PS::CPGDef *> >::clear_and_free
PUBLIC	??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPEDef@PS@@@std@@@std@@@std@@QBEABQAVCPEDef@PS@@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<PS::CPEDef *> > >::operator*
PUBLIC	??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPEDef@PS@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<PS::CPEDef *> > >::operator++
PUBLIC	?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPEDef@PS@@@std@@@std@@@std@@QBEXABV12@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<PS::CPEDef *> > >::_Compat
PUBLIC	??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPGDef@PS@@@std@@@std@@@std@@QBEABQAVCPGDef@PS@@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<PS::CPGDef *> > >::operator*
PUBLIC	??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPGDef@PS@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<PS::CPGDef *> > >::operator++
PUBLIC	?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPGDef@PS@@@std@@@std@@@std@@QBEXABV12@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<PS::CPGDef *> > >::_Compat
PUBLIC	??$_Emplace_back_with_unused_capacity@ABQAVCPEDef@PS@@@?$vector@PAVCPEDef@PS@@V?$xalloc@PAVCPEDef@PS@@@@@std@@AAE?A_TABQAVCPEDef@PS@@@Z ; std::vector<PS::CPEDef *,xalloc<PS::CPEDef *> >::_Emplace_back_with_unused_capacity<PS::CPEDef * const &>
PUBLIC	??$emplace_back@ABQAVCPEDef@PS@@@?$vector@PAVCPEDef@PS@@V?$xalloc@PAVCPEDef@PS@@@@@std@@QAE?A_TABQAVCPEDef@PS@@@Z ; std::vector<PS::CPEDef *,xalloc<PS::CPEDef *> >::emplace_back<PS::CPEDef * const &>
PUBLIC	?push_back@?$vector@PAVCPEDef@PS@@V?$xalloc@PAVCPEDef@PS@@@@@std@@QAEXABQAVCPEDef@PS@@@Z ; std::vector<PS::CPEDef *,xalloc<PS::CPEDef *> >::push_back
PUBLIC	?clear@?$xr_vector@PAVCPEDef@PS@@V?$xalloc@PAVCPEDef@PS@@@@@@QAEXXZ ; xr_vector<PS::CPEDef *,xalloc<PS::CPEDef *> >::clear
PUBLIC	??$_Emplace_back_with_unused_capacity@ABQAVCPGDef@PS@@@?$vector@PAVCPGDef@PS@@V?$xalloc@PAVCPGDef@PS@@@@@std@@AAE?A_TABQAVCPGDef@PS@@@Z ; std::vector<PS::CPGDef *,xalloc<PS::CPGDef *> >::_Emplace_back_with_unused_capacity<PS::CPGDef * const &>
PUBLIC	??$emplace_back@ABQAVCPGDef@PS@@@?$vector@PAVCPGDef@PS@@V?$xalloc@PAVCPGDef@PS@@@@@std@@QAE?A_TABQAVCPGDef@PS@@@Z ; std::vector<PS::CPGDef *,xalloc<PS::CPGDef *> >::emplace_back<PS::CPGDef * const &>
PUBLIC	?push_back@?$vector@PAVCPGDef@PS@@V?$xalloc@PAVCPGDef@PS@@@@@std@@QAEXABQAVCPGDef@PS@@@Z ; std::vector<PS::CPGDef *,xalloc<PS::CPGDef *> >::push_back
PUBLIC	?clear@?$xr_vector@PAVCPGDef@PS@@V?$xalloc@PAVCPGDef@PS@@@@@@QAEXXZ ; xr_vector<PS::CPGDef *,xalloc<PS::CPGDef *> >::clear
PUBLIC	??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPEDef@PS@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<PS::CPEDef *> > >::operator==
PUBLIC	??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPEDef@PS@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<PS::CPEDef *> > >::operator!=
PUBLIC	??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPEDef@PS@@@std@@@std@@@std@@QBEAAPAVCPEDef@PS@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<PS::CPEDef *> > >::operator*
PUBLIC	??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPEDef@PS@@@std@@@std@@@std@@QAE?AV01@H@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<PS::CPEDef *> > >::operator++
PUBLIC	??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPGDef@PS@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<PS::CPGDef *> > >::operator==
PUBLIC	??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPGDef@PS@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<PS::CPGDef *> > >::operator!=
PUBLIC	??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPGDef@PS@@@std@@@std@@@std@@QBEAAPAVCPGDef@PS@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<PS::CPGDef *> > >::operator*
PUBLIC	??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPGDef@PS@@@std@@@std@@@std@@QAE?AV01@H@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<PS::CPGDef *> > >::operator++
PUBLIC	?Load@CPSLibrary@@QAE_NPBD@Z			; CPSLibrary::Load
PUBLIC	?FindPGD@CPSLibrary@@QAEPAVCPGDef@PS@@PBD@Z	; CPSLibrary::FindPGD
PUBLIC	?FindPGDIt@CPSLibrary@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPGDef@PS@@@std@@@std@@@std@@PBD@Z ; CPSLibrary::FindPGDIt
PUBLIC	?FindPED@CPSLibrary@@QAEPAVCPEDef@PS@@PBD@Z	; CPSLibrary::FindPED
PUBLIC	?FindPEDIt@CPSLibrary@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPEDef@PS@@@std@@@std@@@std@@PBD@Z ; CPSLibrary::FindPEDIt
PUBLIC	?OnDestroy@CPSLibrary@@QAEXXZ			; CPSLibrary::OnDestroy
PUBLIC	?OnCreate@CPSLibrary@@QAEXXZ			; CPSLibrary::OnCreate
PUBLIC	?pgd_find_pred@@YA_NPBVCPGDef@PS@@PBD@Z		; pgd_find_pred
PUBLIC	?ped_find_pred@@YA_NPBVCPEDef@PS@@PBD@Z		; ped_find_pred
PUBLIC	?pgd_sort_pred@@YA_NPBVCPGDef@PS@@0@Z		; pgd_sort_pred
PUBLIC	?ped_sort_pred@@YA_NPBVCPEDef@PS@@0@Z		; ped_sort_pred
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$_Emplace_reallocate@ABQAVCPGDef@PS@@@?$vector@PAVCPGDef@PS@@V?$xalloc@PAVCPGDef@PS@@@@@std@@QAEPAPAVCPGDef@PS@@QAPAV23@ABQAV23@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Emplace_reallocate@ABQAVCPGDef@PS@@@?$vector@PAVCPGDef@PS@@V?$xalloc@PAVCPGDef@PS@@@@@std@@QAEPAPAVCPGDef@PS@@QAPAV23@ABQAV23@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Emplace_reallocate@ABQAVCPGDef@PS@@@?$vector@PAVCPGDef@PS@@V?$xalloc@PAVCPGDef@PS@@@@@std@@QAEPAPAVCPGDef@PS@@QAPAV23@ABQAV23@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
__unwindtable$??$_Emplace_reallocate@ABQAVCPGDef@PS@@@?$vector@PAVCPGDef@PS@@V?$xalloc@PAVCPGDef@PS@@@@@std@@QAEPAPAVCPGDef@PS@@QAPAV23@ABQAV23@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Emplace_reallocate@ABQAVCPGDef@PS@@@?$vector@PAVCPGDef@PS@@V?$xalloc@PAVCPGDef@PS@@@@@std@@QAEPAPAVCPGDef@PS@@QAPAV23@ABQAV23@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Emplace_reallocate@ABQAVCPGDef@PS@@@?$vector@PAVCPGDef@PS@@V?$xalloc@PAVCPGDef@PS@@@@@std@@QAEPAPAVCPGDef@PS@@QAPAV23@ABQAV23@@Z$2
__catchsym$??$_Emplace_reallocate@ABQAVCPGDef@PS@@@?$vector@PAVCPGDef@PS@@V?$xalloc@PAVCPGDef@PS@@@@@std@@QAEPAPAVCPGDef@PS@@QAPAV23@ABQAV23@@Z$2 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Emplace_reallocate@ABQAVCPGDef@PS@@@?$vector@PAVCPGDef@PS@@V?$xalloc@PAVCPGDef@PS@@@@@std@@QAEPAPAVCPGDef@PS@@QAPAV23@ABQAV23@@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$_Emplace_reallocate@ABQAVCPEDef@PS@@@?$vector@PAVCPEDef@PS@@V?$xalloc@PAVCPEDef@PS@@@@@std@@QAEPAPAVCPEDef@PS@@QAPAV23@ABQAV23@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Emplace_reallocate@ABQAVCPEDef@PS@@@?$vector@PAVCPEDef@PS@@V?$xalloc@PAVCPEDef@PS@@@@@std@@QAEPAPAVCPEDef@PS@@QAPAV23@ABQAV23@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Emplace_reallocate@ABQAVCPEDef@PS@@@?$vector@PAVCPEDef@PS@@V?$xalloc@PAVCPEDef@PS@@@@@std@@QAEPAPAVCPEDef@PS@@QAPAV23@ABQAV23@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
__unwindtable$??$_Emplace_reallocate@ABQAVCPEDef@PS@@@?$vector@PAVCPEDef@PS@@V?$xalloc@PAVCPEDef@PS@@@@@std@@QAEPAPAVCPEDef@PS@@QAPAV23@ABQAV23@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Emplace_reallocate@ABQAVCPEDef@PS@@@?$vector@PAVCPEDef@PS@@V?$xalloc@PAVCPEDef@PS@@@@@std@@QAEPAPAVCPEDef@PS@@QAPAV23@ABQAV23@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Emplace_reallocate@ABQAVCPEDef@PS@@@?$vector@PAVCPEDef@PS@@V?$xalloc@PAVCPEDef@PS@@@@@std@@QAEPAPAVCPEDef@PS@@QAPAV23@ABQAV23@@Z$2
__catchsym$??$_Emplace_reallocate@ABQAVCPEDef@PS@@@?$vector@PAVCPEDef@PS@@V?$xalloc@PAVCPEDef@PS@@@@@std@@QAEPAPAVCPEDef@PS@@QAPAV23@ABQAV23@@Z$2 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Emplace_reallocate@ABQAVCPEDef@PS@@@?$vector@PAVCPEDef@PS@@V?$xalloc@PAVCPEDef@PS@@@@@std@@QAEPAPAVCPEDef@PS@@QAPAV23@ABQAV23@@Z$0
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\PSLibrary.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xrstring.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleEffectDef.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_std_extensions.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\PSLibrary.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_std_extensions.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\PSLibrary.cpp
_TEXT	SEGMENT
_a$ = 8							; size = 4
_b$ = 12						; size = 4
?ped_sort_pred@@YA_NPBVCPEDef@PS@@0@Z PROC		; ped_sort_pred
; File I:\Vitalya\mine\NSProjectX\xrCore\xrstring.h

; 65   : 	str_c				operator*	() const						{	return p_?p_->value:0;							}

	mov	eax, DWORD PTR _b$[esp-4]
	mov	ecx, DWORD PTR _a$[esp-4]
	mov	eax, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleEffectDef.h

; 108  :         IC LPCSTR			Name				()const{return *m_Name;}

	lea	ecx, DWORD PTR [eax+12]
	neg	eax
	sbb	eax, eax
	and	eax, ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\_std_extensions.h

; 183  : {	return (int)strcmp(S1,S2);  }

	lea	ecx, DWORD PTR [edx+12]
	neg	edx
	sbb	edx, edx
	and	edx, ecx
	npad	2
$LL17@ped_sort_p:
	mov	cl, BYTE PTR [edx]
	cmp	cl, BYTE PTR [eax]
	jne	SHORT $LN18@ped_sort_p
	test	cl, cl
	je	SHORT $LN19@ped_sort_p
	mov	cl, BYTE PTR [edx+1]
	cmp	cl, BYTE PTR [eax+1]
	jne	SHORT $LN18@ped_sort_p
	add	edx, 2
	add	eax, 2
	test	cl, cl
	jne	SHORT $LL17@ped_sort_p
$LN19@ped_sort_p:
	mov	eax, 0
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\PSLibrary.cpp

; 12   : bool ped_sort_pred	(const PS::CPEDef* a, 	const PS::CPEDef* b)	{	return xr_strcmp(a->Name(),b->Name())<0;}

	ret	0
$LN18@ped_sort_p:
; File I:\Vitalya\mine\NSProjectX\xrCore\_std_extensions.h

; 183  : {	return (int)strcmp(S1,S2);  }

	sbb	eax, eax
	or	eax, 1
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\PSLibrary.cpp

; 12   : bool ped_sort_pred	(const PS::CPEDef* a, 	const PS::CPEDef* b)	{	return xr_strcmp(a->Name(),b->Name())<0;}

	shr	eax, 31					; 0000001fH
	ret	0
?ped_sort_pred@@YA_NPBVCPEDef@PS@@0@Z ENDP		; ped_sort_pred
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\PSLibrary.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xrstring.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_std_extensions.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\PSLibrary.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_std_extensions.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\PSLibrary.cpp
_TEXT	SEGMENT
_a$ = 8							; size = 4
_b$ = 12						; size = 4
?pgd_sort_pred@@YA_NPBVCPGDef@PS@@0@Z PROC		; pgd_sort_pred
; File I:\Vitalya\mine\NSProjectX\xrCore\xrstring.h

; 73   : 	bool				equal		(const shared_str & rhs) const	{	return (p_ == rhs.p_);							}

	mov	eax, DWORD PTR _a$[esp-4]
	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR _b$[esp-4]
	mov	eax, DWORD PTR [eax]
	cmp	edx, eax

; 104  : 	if (a.equal(b))		return 0;

	je	SHORT $LN21@pgd_sort_p

; 65   : 	str_c				operator*	() const						{	return p_?p_->value:0;							}

	lea	ecx, DWORD PTR [eax+12]
	neg	eax
	sbb	eax, eax
	and	eax, ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\_std_extensions.h

; 183  : {	return (int)strcmp(S1,S2);  }

	lea	ecx, DWORD PTR [edx+12]
	neg	edx
	sbb	edx, edx
	and	edx, ecx
$LL19@pgd_sort_p:
	mov	cl, BYTE PTR [edx]
	cmp	cl, BYTE PTR [eax]
	jne	SHORT $LN20@pgd_sort_p
	test	cl, cl
	je	SHORT $LN21@pgd_sort_p
	mov	cl, BYTE PTR [edx+1]
	cmp	cl, BYTE PTR [eax+1]
	jne	SHORT $LN20@pgd_sort_p
	add	edx, 2
	add	eax, 2
	test	cl, cl
	jne	SHORT $LL19@pgd_sort_p
$LN21@pgd_sort_p:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\PSLibrary.cpp

; 13   : bool pgd_sort_pred	(const PS::CPGDef* a, 	const PS::CPGDef* b)	{	return xr_strcmp(a->m_Name,b->m_Name)<0;}

	mov	eax, 0
	ret	0
$LN20@pgd_sort_p:
; File I:\Vitalya\mine\NSProjectX\xrCore\_std_extensions.h

; 183  : {	return (int)strcmp(S1,S2);  }

	sbb	eax, eax
	or	eax, 1
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\PSLibrary.cpp

; 13   : bool pgd_sort_pred	(const PS::CPGDef* a, 	const PS::CPGDef* b)	{	return xr_strcmp(a->m_Name,b->m_Name)<0;}

	shr	eax, 31					; 0000001fH
	ret	0
?pgd_sort_pred@@YA_NPBVCPGDef@PS@@0@Z ENDP		; pgd_sort_pred
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\PSLibrary.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xrstring.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_std_extensions.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xrstring.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_std_extensions.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\PSLibrary.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_std_extensions.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\PSLibrary.cpp
_TEXT	SEGMENT
_a$ = 8							; size = 4
_b$ = 12						; size = 4
?ped_find_pred@@YA_NPBVCPEDef@PS@@PBD@Z PROC		; ped_find_pred
; File I:\Vitalya\mine\NSProjectX\xrCore\xrstring.h

; 65   : 	str_c				operator*	() const						{	return p_?p_->value:0;							}

	mov	eax, DWORD PTR _a$[esp-4]
; File I:\Vitalya\mine\NSProjectX\xrCore\_std_extensions.h

; 183  : {	return (int)strcmp(S1,S2);  }

	mov	edx, DWORD PTR _b$[esp-4]
; File I:\Vitalya\mine\NSProjectX\xrCore\xrstring.h

; 65   : 	str_c				operator*	() const						{	return p_?p_->value:0;							}

	mov	eax, DWORD PTR [eax]
; File I:\Vitalya\mine\NSProjectX\xrCore\_std_extensions.h

; 183  : {	return (int)strcmp(S1,S2);  }

	lea	ecx, DWORD PTR [eax+12]
	neg	eax
	sbb	eax, eax
	and	eax, ecx
$LL11@ped_find_p:
	mov	cl, BYTE PTR [eax]
	cmp	cl, BYTE PTR [edx]
	jne	SHORT $LN12@ped_find_p
	test	cl, cl
	je	SHORT $LN13@ped_find_p
	mov	cl, BYTE PTR [eax+1]
	cmp	cl, BYTE PTR [edx+1]
	jne	SHORT $LN12@ped_find_p
	add	eax, 2
	add	edx, 2
	test	cl, cl
	jne	SHORT $LL11@ped_find_p
$LN13@ped_find_p:
	mov	eax, 0
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\PSLibrary.cpp

; 15   : bool ped_find_pred	(const PS::CPEDef* a, 	LPCSTR b)				{	return xr_strcmp(a->Name(),b)<0;}

	ret	0
$LN12@ped_find_p:
; File I:\Vitalya\mine\NSProjectX\xrCore\_std_extensions.h

; 183  : {	return (int)strcmp(S1,S2);  }

	sbb	eax, eax
	or	eax, 1
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\PSLibrary.cpp

; 15   : bool ped_find_pred	(const PS::CPEDef* a, 	LPCSTR b)				{	return xr_strcmp(a->Name(),b)<0;}

	shr	eax, 31					; 0000001fH
	ret	0
?ped_find_pred@@YA_NPBVCPEDef@PS@@PBD@Z ENDP		; ped_find_pred
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\PSLibrary.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xrstring.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_std_extensions.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xrstring.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_std_extensions.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\PSLibrary.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_std_extensions.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\PSLibrary.cpp
_TEXT	SEGMENT
_a$ = 8							; size = 4
_b$ = 12						; size = 4
?pgd_find_pred@@YA_NPBVCPGDef@PS@@PBD@Z PROC		; pgd_find_pred
; File I:\Vitalya\mine\NSProjectX\xrCore\xrstring.h

; 65   : 	str_c				operator*	() const						{	return p_?p_->value:0;							}

	mov	eax, DWORD PTR _a$[esp-4]
; File I:\Vitalya\mine\NSProjectX\xrCore\_std_extensions.h

; 183  : {	return (int)strcmp(S1,S2);  }

	mov	edx, DWORD PTR _b$[esp-4]
; File I:\Vitalya\mine\NSProjectX\xrCore\xrstring.h

; 65   : 	str_c				operator*	() const						{	return p_?p_->value:0;							}

	mov	eax, DWORD PTR [eax]
; File I:\Vitalya\mine\NSProjectX\xrCore\_std_extensions.h

; 183  : {	return (int)strcmp(S1,S2);  }

	lea	ecx, DWORD PTR [eax+12]
	neg	eax
	sbb	eax, eax
	and	eax, ecx
$LL11@pgd_find_p:
	mov	cl, BYTE PTR [eax]
	cmp	cl, BYTE PTR [edx]
	jne	SHORT $LN12@pgd_find_p
	test	cl, cl
	je	SHORT $LN13@pgd_find_p
	mov	cl, BYTE PTR [eax+1]
	cmp	cl, BYTE PTR [edx+1]
	jne	SHORT $LN12@pgd_find_p
	add	eax, 2
	add	edx, 2
	test	cl, cl
	jne	SHORT $LL11@pgd_find_p
$LN13@pgd_find_p:
	mov	eax, 0
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\PSLibrary.cpp

; 16   : bool pgd_find_pred	(const PS::CPGDef* a, 	LPCSTR b)				{	return xr_strcmp(a->m_Name,b)<0;}

	ret	0
$LN12@pgd_find_p:
; File I:\Vitalya\mine\NSProjectX\xrCore\_std_extensions.h

; 183  : {	return (int)strcmp(S1,S2);  }

	sbb	eax, eax
	or	eax, 1
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\PSLibrary.cpp

; 16   : bool pgd_find_pred	(const PS::CPGDef* a, 	LPCSTR b)				{	return xr_strcmp(a->m_Name,b)<0;}

	shr	eax, 31					; 0000001fH
	ret	0
?pgd_find_pred@@YA_NPBVCPGDef@PS@@PBD@Z ENDP		; pgd_find_pred
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\PSLibrary.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\PSLibrary.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xrstring.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleEffectDef.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xrstring.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleEffectDef.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\PSLibrary.cpp
_TEXT	SEGMENT
_fn$ = -520						; size = 520
?OnCreate@CPSLibrary@@QAEXXZ PROC			; CPSLibrary::OnCreate
; _this$ = ecx

; 19   : {

	sub	esp, 520				; 00000208H

; 20   : 	string_path fn;
; 21   :     FS.update_path(fn,_game_data_,PSLIB_FILENAME);

	lea	eax, DWORD PTR _fn$[esp+520]
	push	ebx
	push	esi
	mov	ebx, ecx
	mov	ecx, DWORD PTR __imp_?xr_FS@@3PAVCLocatorAPI@@A
	push	OFFSET ??_C@_0N@KDJLGDBP@particles?4xr@
	push	OFFSET ??_C@_0M@FDPKAAFL@$game_data$@
	push	eax
	mov	ecx, DWORD PTR [ecx]
	call	DWORD PTR __imp_?update_path@CLocatorAPI@@QAEPBDAAY0CAI@DPBD1@Z

; 22   : 	if (FS.exist(fn)){

	mov	ecx, DWORD PTR __imp_?xr_FS@@3PAVCLocatorAPI@@A
	lea	eax, DWORD PTR _fn$[esp+528]
	push	eax
	mov	ecx, DWORD PTR [ecx]
	call	DWORD PTR __imp_?exist@CLocatorAPI@@QAEPBUfile@1@PBD@Z
	test	eax, eax
	lea	eax, DWORD PTR _fn$[esp+528]
	push	eax
	je	SHORT $LN5@OnCreate

; 23   :     	if (!Load(fn)) Msg("PS Library: Unsupported version.");

	mov	ecx, ebx
	call	?Load@CPSLibrary@@QAE_NPBD@Z		; CPSLibrary::Load
	test	al, al
	jne	SHORT $LN6@OnCreate
	push	OFFSET ??_C@_0CB@MNJHEPBF@PS?5Library?3?5Unsupported?5version@
	call	DWORD PTR __imp_?Msg@@YAXPBDZZ
	add	esp, 4

; 24   :     }else{

	jmp	SHORT $LN6@OnCreate
$LN5@OnCreate:

; 25   :     	Msg("Can't find file: '%s'",fn);

	push	OFFSET ??_C@_0BG@PFJIIDDI@Can?8t?5find?5file?3?5?8?$CFs?8@
	call	DWORD PTR __imp_?Msg@@YAXPBDZZ
	add	esp, 8
$LN6@OnCreate:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	esi, DWORD PTR [ebx]

; 150  :         return _Ptr == _Right._Ptr;

	cmp	esi, DWORD PTR [ebx+4]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\PSLibrary.cpp

; 27   : 	for (PS::PEDIt e_it = m_PEDs.begin(); e_it!=m_PEDs.end(); e_it++)

	je	SHORT $LN3@OnCreate
	push	ebp
	mov	ebp, DWORD PTR __imp_?create@resptrcode_shader@@QAEXPBD000@Z
	push	edi
	npad	6
$LL4@OnCreate:

; 28   :     	(*e_it)->CreateShader();

	mov	edi, DWORD PTR [esi]
; File I:\Vitalya\mine\NSProjectX\xrCore\xrstring.h

; 65   : 	str_c				operator*	() const						{	return p_?p_->value:0;							}

	mov	eax, DWORD PTR [edi+8]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleEffectDef.cpp

; 42   :     if (*m_ShaderName&&*m_TextureName)	

	lea	ecx, DWORD PTR [eax+12]
	neg	eax
	sbb	eax, eax
	and	eax, ecx
	je	SHORT $LN2@OnCreate
; File I:\Vitalya\mine\NSProjectX\xrCore\xrstring.h

; 65   : 	str_c				operator*	() const						{	return p_?p_->value:0;							}

	mov	edx, DWORD PTR [edi+12]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleEffectDef.cpp

; 42   :     if (*m_ShaderName&&*m_TextureName)	

	lea	ecx, DWORD PTR [edx+12]
	neg	edx
	sbb	edx, edx
	and	edx, ecx
	je	SHORT $LN2@OnCreate

; 43   :         m_CachedShader.create(*m_ShaderName,*m_TextureName);

	push	0
	push	0
	push	edx
	push	eax
	lea	ecx, DWORD PTR [edi+16]
	call	ebp
$LN2@OnCreate:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 74   :         ++_Ptr;

	add	esi, 4

; 150  :         return _Ptr == _Right._Ptr;

	cmp	esi, DWORD PTR [ebx+4]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\PSLibrary.cpp

; 27   : 	for (PS::PEDIt e_it = m_PEDs.begin(); e_it!=m_PEDs.end(); e_it++)

	jne	SHORT $LL4@OnCreate
	pop	edi
	pop	ebp
$LN3@OnCreate:
	pop	esi

; 29   : }

	pop	ebx
	add	esp, 520				; 00000208H
	ret	0
?OnCreate@CPSLibrary@@QAEXXZ ENDP			; CPSLibrary::OnCreate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\PSLibrary.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\PSLibrary.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleEffectDef.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\PSLibrary.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\PSLibrary.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleEffectDef.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xrstring.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\PSLibrary.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\PSLibrary.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\PSLibrary.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xrstring.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrstring.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\PSLibrary.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\PSLibrary.cpp
_TEXT	SEGMENT
?OnDestroy@CPSLibrary@@QAEXXZ PROC			; CPSLibrary::OnDestroy
; _this$ = ecx

; 32   : {

	push	ebx
	push	ebp
	mov	ebp, ecx
	push	esi
	push	edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	esi, DWORD PTR [ebp]

; 150  :         return _Ptr == _Right._Ptr;

	mov	edx, esi
	mov	eax, DWORD PTR [ebp+4]
	cmp	esi, eax
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\PSLibrary.cpp

; 33   : 	for (PS::PEDIt e_it = m_PEDs.begin(); e_it!=m_PEDs.end(); e_it++)

	je	$LN6@OnDestroy
	npad	10
$LL4@OnDestroy:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleEffectDef.cpp

; 47   :     m_CachedShader.destroy();

	mov	edi, DWORD PTR [esi]
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 46   : 	ICF		void		_set	(T * rhs) 							{	if (0!=rhs) rhs->dwReference++;	_dec(); p_ = rhs;											}

	lea	ecx, DWORD PTR [edi+16]
	call	DWORD PTR __imp_?_dec@?$resptr_base@UShader@@@@IAEXXZ
	mov	DWORD PTR [edi+16], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 74   :         ++_Ptr;

	add	esi, 4

; 150  :         return _Ptr == _Right._Ptr;

	mov	eax, DWORD PTR [ebp+4]
	cmp	esi, eax
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\PSLibrary.cpp

; 33   : 	for (PS::PEDIt e_it = m_PEDs.begin(); e_it!=m_PEDs.end(); e_it++)

	jne	SHORT $LL4@OnDestroy
	mov	esi, DWORD PTR [ebp]
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h

; 154  : 		ptr = nullptr;

	mov	edx, esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 150  :         return _Ptr == _Right._Ptr;

	cmp	esi, eax
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\PSLibrary.cpp

; 36   : 	for (e_it = m_PEDs.begin(); e_it!=m_PEDs.end(); e_it++)

	je	$LN6@OnDestroy
	mov	ebx, DWORD PTR __imp_??1CMemoryWriter@@UAE@XZ
	npad	1
$LL7@OnDestroy:
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h

; 151  : 	if (ptr) 

	mov	edi, DWORD PTR [esi]
	test	edi, edi
	je	SHORT $LN5@OnDestroy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleEffectDef.cpp

; 39   : }

	lea	ecx, DWORD PTR [edi+48]
	call	ebx
	lea	ecx, DWORD PTR [edi+16]
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 64   : 						~resptr_core	()												{	_dec();						}

	call	DWORD PTR __imp_?_dec@?$resptr_base@UShader@@@@IAEXXZ
; File I:\Vitalya\mine\NSProjectX\xrCore\xrstring.h

; 50   : 	void				_dec		()								{	if (0==p_) return;	p_->dwReference--; 	if (0==p_->dwReference)	p_=0;						}

	mov	eax, DWORD PTR [edi+12]
	test	eax, eax
	je	SHORT $LN75@OnDestroy
	dec	DWORD PTR [eax]
	mov	eax, DWORD PTR [edi+12]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN75@OnDestroy
	mov	DWORD PTR [edi+12], 0
$LN75@OnDestroy:
	mov	eax, DWORD PTR [edi+8]
	test	eax, eax
	je	SHORT $LN81@OnDestroy
	dec	DWORD PTR [eax]
	mov	eax, DWORD PTR [edi+8]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN81@OnDestroy
	mov	DWORD PTR [edi+8], 0
$LN81@OnDestroy:
	mov	eax, DWORD PTR [edi]
	test	eax, eax
	je	SHORT $LN87@OnDestroy
	dec	DWORD PTR [eax]
	mov	eax, DWORD PTR [edi]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN87@OnDestroy
	mov	DWORD PTR [edi], 0
$LN87@OnDestroy:
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h

; 144  : 		Memory.mem_free	(ptr);

	push	DWORD PTR [esi]
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z

; 154  : 		ptr = nullptr;

	mov	DWORD PTR [esi], 0
$LN5@OnDestroy:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 74   :         ++_Ptr;

	add	esi, 4

; 150  :         return _Ptr == _Right._Ptr;

	cmp	esi, DWORD PTR [ebp+4]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\PSLibrary.cpp

; 36   : 	for (e_it = m_PEDs.begin(); e_it!=m_PEDs.end(); e_it++)

	jne	SHORT $LL7@OnDestroy
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h

; 154  : 		ptr = nullptr;

	mov	edx, DWORD PTR [ebp]
$LN6@OnDestroy:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\PSLibrary.cpp

; 38   : 	m_PEDs.clear	();

	mov	DWORD PTR [ebp+4], edx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	ebx, DWORD PTR [ebp+12]

; 150  :         return _Ptr == _Right._Ptr;

	cmp	ebx, DWORD PTR [ebp+16]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\PSLibrary.cpp

; 40   : 	for (PS::PGDIt g_it = m_PGDs.begin(); g_it!=m_PGDs.end(); g_it++)

	je	$LN216@OnDestroy
	npad	9
$LL10@OnDestroy:
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h

; 151  : 	if (ptr) 

	mov	edi, DWORD PTR [ebx]
	test	edi, edi
	je	$LN8@OnDestroy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	esi, DWORD PTR [edi+12]

; 150  :         return _Ptr == _Right._Ptr;

	cmp	esi, DWORD PTR [edi+16]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp

; 20   :     for (EffectIt it=m_Effects.begin(); it!=m_Effects.end(); it++)

	je	$LN119@OnDestroy
$LL120@OnDestroy:
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h

; 151  : 	if (ptr) 

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN118@OnDestroy
; File I:\Vitalya\mine\NSProjectX\xrCore\xrstring.h

; 50   : 	void				_dec		()								{	if (0==p_) return;	p_->dwReference--; 	if (0==p_->dwReference)	p_=0;						}

	mov	ecx, DWORD PTR [eax+16]
	test	ecx, ecx
	je	SHORT $LN156@OnDestroy
	dec	DWORD PTR [ecx]
	mov	ecx, DWORD PTR [eax+16]
	cmp	DWORD PTR [ecx], 0
	jne	SHORT $LN156@OnDestroy
	mov	DWORD PTR [eax+16], 0
$LN156@OnDestroy:
	mov	ecx, DWORD PTR [eax+12]
	test	ecx, ecx
	je	SHORT $LN162@OnDestroy
	dec	DWORD PTR [ecx]
	mov	ecx, DWORD PTR [eax+12]
	cmp	DWORD PTR [ecx], 0
	jne	SHORT $LN162@OnDestroy
	mov	DWORD PTR [eax+12], 0
$LN162@OnDestroy:
	mov	ecx, DWORD PTR [eax+8]
	test	ecx, ecx
	je	SHORT $LN168@OnDestroy
	dec	DWORD PTR [ecx]
	mov	ecx, DWORD PTR [eax+8]
	cmp	DWORD PTR [ecx], 0
	jne	SHORT $LN168@OnDestroy
	mov	DWORD PTR [eax+8], 0
$LN168@OnDestroy:
	mov	ecx, DWORD PTR [eax+4]
	test	ecx, ecx
	je	SHORT $LN174@OnDestroy
	dec	DWORD PTR [ecx]
	mov	ecx, DWORD PTR [eax+4]
	cmp	DWORD PTR [ecx], 0
	jne	SHORT $LN174@OnDestroy
	mov	DWORD PTR [eax+4], 0
$LN174@OnDestroy:
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h

; 144  : 		Memory.mem_free	(ptr);

	push	DWORD PTR [esi]
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z

; 154  : 		ptr = nullptr;

	mov	DWORD PTR [esi], 0
$LN118@OnDestroy:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 74   :         ++_Ptr;

	add	esi, 4

; 150  :         return _Ptr == _Right._Ptr;

	cmp	esi, DWORD PTR [edi+16]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp

; 20   :     for (EffectIt it=m_Effects.begin(); it!=m_Effects.end(); it++)

	jne	$LL120@OnDestroy
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h

; 154  : 		ptr = nullptr;

	mov	esi, DWORD PTR [edi+12]
$LN119@OnDestroy:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp

; 22   :     m_Effects.clear	();

	mov	DWORD PTR [edi+16], esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	test	esi, esi
	je	SHORT $LN217@OnDestroy
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	esi
	mov	esi, DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
	call	esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [edi+12], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [edi+16], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [edi+20], 0
	jmp	SHORT $LN181@OnDestroy
$LN217@OnDestroy:

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	esi, DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN181@OnDestroy:
; File I:\Vitalya\mine\NSProjectX\xrCore\xrstring.h

; 50   : 	void				_dec		()								{	if (0==p_) return;	p_->dwReference--; 	if (0==p_->dwReference)	p_=0;						}

	mov	eax, DWORD PTR [edi]
	test	eax, eax
	je	SHORT $LN192@OnDestroy
	dec	DWORD PTR [eax]
	mov	eax, DWORD PTR [edi]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN192@OnDestroy
	mov	DWORD PTR [edi], 0
$LN192@OnDestroy:
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h

; 144  : 		Memory.mem_free	(ptr);

	push	DWORD PTR [ebx]
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	esi

; 154  : 		ptr = nullptr;

	mov	DWORD PTR [ebx], 0
$LN8@OnDestroy:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 74   :         ++_Ptr;

	add	ebx, 4

; 150  :         return _Ptr == _Right._Ptr;

	cmp	ebx, DWORD PTR [ebp+16]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\PSLibrary.cpp

; 40   : 	for (PS::PGDIt g_it = m_PGDs.begin(); g_it!=m_PGDs.end(); g_it++)

	jne	$LL10@OnDestroy
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h

; 154  : 		ptr = nullptr;

	mov	eax, DWORD PTR [ebp+12]
	pop	edi
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\PSLibrary.cpp

; 43   : }

	pop	esi
	mov	DWORD PTR [ebp+16], eax
	pop	ebp
	pop	ebx
	ret	0
$LN216@OnDestroy:
	pop	edi
	pop	esi
	mov	DWORD PTR [ebp+16], ebx
	pop	ebp
	pop	ebx
	ret	0
?OnDestroy@CPSLibrary@@QAEXXZ ENDP			; CPSLibrary::OnDestroy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\PSLibrary.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\PSLibrary.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
; File I:\Vitalya\mine\NSProjectX\xrCore\_std_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleEffectDef.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xrstring.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_std_extensions.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\PSLibrary.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\PSLibrary.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xrstring.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_std_extensions.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\PSLibrary.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\PSLibrary.cpp
_TEXT	SEGMENT
$T1 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__UMid$1$ = 12						; size = 4
_Name$ = 12						; size = 4
?FindPEDIt@CPSLibrary@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPEDef@PS@@@std@@@std@@@std@@PBD@Z PROC ; CPSLibrary::FindPEDIt
; _this$ = ecx

; 46   : {

	push	ecx
	push	edi

; 47   : 	if (!Name) return m_PEDs.end();

	mov	edi, DWORD PTR _Name$[esp+4]
	test	edi, edi
	jne	SHORT $LN2@FindPEDIt
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	eax, DWORD PTR ___$ReturnUdt$[esp+4]
	mov	ecx, DWORD PTR [ecx+4]
	pop	edi
	mov	DWORD PTR [eax], ecx
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\PSLibrary.cpp

; 57   : }

	pop	ecx
	ret	8
$LN2@FindPEDIt:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility

; 1525 :         return _Last - _First; // assume the iterator will do debug checking

	mov	edx, DWORD PTR [ecx+4]
	push	ebp

; 5810 :     auto _UFirst                = _Get_unwrapped(_First);

	mov	ebp, DWORD PTR [ecx]
	push	esi

; 1525 :         return _Last - _First; // assume the iterator will do debug checking

	mov	esi, edx
	mov	DWORD PTR $T1[esp+16], edx
	sub	esi, ebp
	sar	esi, 2

; 5813 :     while (0 < _Count) { // divide and conquer, find half that contains answer

	test	esi, esi
	jle	SHORT $LN27@FindPEDIt
	push	ebx
	npad	1
$LL26@FindPEDIt:

; 5814 :         const _Iter_diff_t<_FwdIt> _Count2 = _Count / 2;

	mov	ebx, esi
; File I:\Vitalya\mine\NSProjectX\xrCore\_std_extensions.h

; 183  : {	return (int)strcmp(S1,S2);  }

	mov	edx, edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility

; 5814 :         const _Iter_diff_t<_FwdIt> _Count2 = _Count / 2;

	shr	ebx, 1

; 1497 :         _Where += _Off;

	lea	eax, DWORD PTR [ebx*4]
	add	eax, ebp
	mov	DWORD PTR __UMid$1$[esp+16], eax
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleEffectDef.h

; 108  :         IC LPCSTR			Name				()const{return *m_Name;}

	mov	eax, DWORD PTR [eax]
; File I:\Vitalya\mine\NSProjectX\xrCore\xrstring.h

; 65   : 	str_c				operator*	() const						{	return p_?p_->value:0;							}

	mov	eax, DWORD PTR [eax]
; File I:\Vitalya\mine\NSProjectX\xrCore\_std_extensions.h

; 183  : {	return (int)strcmp(S1,S2);  }

	lea	ecx, DWORD PTR [eax+12]
	neg	eax
	sbb	eax, eax
	and	eax, ecx
$LL72@FindPEDIt:
	mov	cl, BYTE PTR [eax]
	cmp	cl, BYTE PTR [edx]
	jne	SHORT $LN73@FindPEDIt
	test	cl, cl
	je	SHORT $LN74@FindPEDIt
	mov	cl, BYTE PTR [eax+1]
	cmp	cl, BYTE PTR [edx+1]
	jne	SHORT $LN73@FindPEDIt
	add	eax, 2
	add	edx, 2
	test	cl, cl
	jne	SHORT $LL72@FindPEDIt
$LN74@FindPEDIt:
	xor	eax, eax
	jmp	SHORT $LN75@FindPEDIt
$LN73@FindPEDIt:
	sbb	eax, eax
	or	eax, 1
$LN75@FindPEDIt:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\PSLibrary.cpp

; 15   : bool ped_find_pred	(const PS::CPEDef* a, 	LPCSTR b)				{	return xr_strcmp(a->Name(),b)<0;}

	test	eax, eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility

; 5816 :         if (_Pred(*_UMid, _Val)) { // try top half

	jns	SHORT $LN28@FindPEDIt

; 5817 :             _UFirst = _Next_iter(_UMid);

	mov	ebp, DWORD PTR __UMid$1$[esp+16]

; 5818 :             _Count -= _Count2 + 1;

	or	eax, -1
	sub	eax, ebx
	add	ebp, 4
	add	esi, eax

; 5819 :         } else {

	jmp	SHORT $LN29@FindPEDIt
$LN28@FindPEDIt:

; 5820 :             _Count = _Count2;

	mov	esi, ebx
$LN29@FindPEDIt:

; 5811 :     _Iter_diff_t<_FwdIt> _Count = _STD distance(_UFirst, _Get_unwrapped(_Last));
; 5812 : 
; 5813 :     while (0 < _Count) { // divide and conquer, find half that contains answer

	test	esi, esi
	jg	SHORT $LL26@FindPEDIt
	mov	edx, DWORD PTR $T1[esp+20]
	pop	ebx
$LN27@FindPEDIt:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 150  :         return _Ptr == _Right._Ptr;

	cmp	ebp, edx
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\PSLibrary.cpp

; 54   : 	if (I==m_PEDs.end() || (0!=xr_strcmp((*I)->m_Name,Name)))	return m_PEDs.end();

	je	SHORT $LN5@FindPEDIt
	mov	eax, DWORD PTR [ebp]
; File I:\Vitalya\mine\NSProjectX\xrCore\xrstring.h

; 65   : 	str_c				operator*	() const						{	return p_?p_->value:0;							}

	mov	ecx, DWORD PTR [eax]
; File I:\Vitalya\mine\NSProjectX\xrCore\_std_extensions.h

; 183  : {	return (int)strcmp(S1,S2);  }

	lea	eax, DWORD PTR [ecx+12]
	neg	ecx
	sbb	ecx, ecx
	and	ecx, eax
$LL76@FindPEDIt:
	mov	al, BYTE PTR [ecx]
	cmp	al, BYTE PTR [edi]
	jne	SHORT $LN77@FindPEDIt
	test	al, al
	je	SHORT $LN78@FindPEDIt
	mov	al, BYTE PTR [ecx+1]
	cmp	al, BYTE PTR [edi+1]
	jne	SHORT $LN77@FindPEDIt
	add	ecx, 2
	add	edi, 2
	test	al, al
	jne	SHORT $LL76@FindPEDIt
$LN78@FindPEDIt:
	xor	eax, eax
	jmp	SHORT $LN79@FindPEDIt
$LN77@FindPEDIt:
	sbb	eax, eax
	or	eax, 1
$LN79@FindPEDIt:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\PSLibrary.cpp

; 54   : 	if (I==m_PEDs.end() || (0!=xr_strcmp((*I)->m_Name,Name)))	return m_PEDs.end();

	test	eax, eax
	jne	SHORT $LN5@FindPEDIt

; 55   : 	else														return I;

	mov	eax, DWORD PTR ___$ReturnUdt$[esp+12]
	pop	esi
	mov	DWORD PTR [eax], ebp
	pop	ebp
	pop	edi

; 57   : }

	pop	ecx
	ret	8
$LN5@FindPEDIt:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	eax, DWORD PTR ___$ReturnUdt$[esp+12]
	pop	esi
	pop	ebp
	pop	edi
	mov	DWORD PTR [eax], edx
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\PSLibrary.cpp

; 57   : }

	pop	ecx
	ret	8
?FindPEDIt@CPSLibrary@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPEDef@PS@@@std@@@std@@@std@@PBD@Z ENDP ; CPSLibrary::FindPEDIt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\PSLibrary.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\PSLibrary.cpp
_TEXT	SEGMENT
_it$ = 8						; size = 4
_Name$ = 8						; size = 4
?FindPED@CPSLibrary@@QAEPAVCPEDef@PS@@PBD@Z PROC	; CPSLibrary::FindPED
; _this$ = ecx

; 60   : {

	push	esi

; 61   : 	PS::PEDIt it = FindPEDIt(Name);

	push	DWORD PTR _Name$[esp]
	lea	eax, DWORD PTR _it$[esp+4]
	mov	esi, ecx
	push	eax
	call	?FindPEDIt@CPSLibrary@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPEDef@PS@@@std@@@std@@@std@@PBD@Z ; CPSLibrary::FindPEDIt
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 150  :         return _Ptr == _Right._Ptr;

	mov	eax, DWORD PTR _it$[esp]
	cmp	eax, DWORD PTR [esi+4]
	pop	esi
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\PSLibrary.cpp

; 62   :     return (it==m_PEDs.end())?0:*it;

	jne	SHORT $LN3@FindPED
	xor	eax, eax

; 63   : }

	ret	4
$LN3@FindPED:

; 62   :     return (it==m_PEDs.end())?0:*it;

	mov	eax, DWORD PTR [eax]

; 63   : }

	ret	4
?FindPED@CPSLibrary@@QAEPAVCPEDef@PS@@PBD@Z ENDP	; CPSLibrary::FindPED
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\PSLibrary.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\PSLibrary.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
; File I:\Vitalya\mine\NSProjectX\xrCore\_std_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\PSLibrary.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xrstring.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_std_extensions.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\PSLibrary.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\PSLibrary.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xrstring.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_std_extensions.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\PSLibrary.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\PSLibrary.cpp
_TEXT	SEGMENT
$T1 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__UMid$1$ = 12						; size = 4
_Name$ = 12						; size = 4
?FindPGDIt@CPSLibrary@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPGDef@PS@@@std@@@std@@@std@@PBD@Z PROC ; CPSLibrary::FindPGDIt
; _this$ = ecx

; 66   : {

	push	ecx
	push	edi

; 67   : 	if (!Name) return m_PGDs.end();

	mov	edi, DWORD PTR _Name$[esp+4]
	test	edi, edi
	jne	SHORT $LN2@FindPGDIt
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	eax, DWORD PTR ___$ReturnUdt$[esp+4]
	mov	ecx, DWORD PTR [ecx+16]
	pop	edi
	mov	DWORD PTR [eax], ecx
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\PSLibrary.cpp

; 77   : }

	pop	ecx
	ret	8
$LN2@FindPGDIt:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility

; 1525 :         return _Last - _First; // assume the iterator will do debug checking

	mov	edx, DWORD PTR [ecx+16]
	push	ebp

; 5810 :     auto _UFirst                = _Get_unwrapped(_First);

	mov	ebp, DWORD PTR [ecx+12]
	push	esi

; 1525 :         return _Last - _First; // assume the iterator will do debug checking

	mov	esi, edx
	mov	DWORD PTR $T1[esp+16], edx
	sub	esi, ebp
	sar	esi, 2

; 5813 :     while (0 < _Count) { // divide and conquer, find half that contains answer

	test	esi, esi
	jle	SHORT $LN27@FindPGDIt
	push	ebx
$LL26@FindPGDIt:

; 5814 :         const _Iter_diff_t<_FwdIt> _Count2 = _Count / 2;

	mov	ebx, esi
; File I:\Vitalya\mine\NSProjectX\xrCore\_std_extensions.h

; 183  : {	return (int)strcmp(S1,S2);  }

	mov	edx, edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility

; 5814 :         const _Iter_diff_t<_FwdIt> _Count2 = _Count / 2;

	shr	ebx, 1

; 1497 :         _Where += _Off;

	lea	eax, DWORD PTR [ebx*4]
	add	eax, ebp
	mov	DWORD PTR __UMid$1$[esp+16], eax
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\PSLibrary.cpp

; 16   : bool pgd_find_pred	(const PS::CPGDef* a, 	LPCSTR b)				{	return xr_strcmp(a->m_Name,b)<0;}

	mov	eax, DWORD PTR [eax]
; File I:\Vitalya\mine\NSProjectX\xrCore\xrstring.h

; 65   : 	str_c				operator*	() const						{	return p_?p_->value:0;							}

	mov	eax, DWORD PTR [eax]
; File I:\Vitalya\mine\NSProjectX\xrCore\_std_extensions.h

; 183  : {	return (int)strcmp(S1,S2);  }

	lea	ecx, DWORD PTR [eax+12]
	neg	eax
	sbb	eax, eax
	and	eax, ecx
$LL72@FindPGDIt:
	mov	cl, BYTE PTR [eax]
	cmp	cl, BYTE PTR [edx]
	jne	SHORT $LN73@FindPGDIt
	test	cl, cl
	je	SHORT $LN74@FindPGDIt
	mov	cl, BYTE PTR [eax+1]
	cmp	cl, BYTE PTR [edx+1]
	jne	SHORT $LN73@FindPGDIt
	add	eax, 2
	add	edx, 2
	test	cl, cl
	jne	SHORT $LL72@FindPGDIt
$LN74@FindPGDIt:
	xor	eax, eax
	jmp	SHORT $LN75@FindPGDIt
$LN73@FindPGDIt:
	sbb	eax, eax
	or	eax, 1
$LN75@FindPGDIt:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\PSLibrary.cpp

; 16   : bool pgd_find_pred	(const PS::CPGDef* a, 	LPCSTR b)				{	return xr_strcmp(a->m_Name,b)<0;}

	test	eax, eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility

; 5816 :         if (_Pred(*_UMid, _Val)) { // try top half

	jns	SHORT $LN28@FindPGDIt

; 5817 :             _UFirst = _Next_iter(_UMid);

	mov	ebp, DWORD PTR __UMid$1$[esp+16]

; 5818 :             _Count -= _Count2 + 1;

	or	eax, -1
	sub	eax, ebx
	add	ebp, 4
	add	esi, eax

; 5819 :         } else {

	jmp	SHORT $LN29@FindPGDIt
$LN28@FindPGDIt:

; 5820 :             _Count = _Count2;

	mov	esi, ebx
$LN29@FindPGDIt:

; 5811 :     _Iter_diff_t<_FwdIt> _Count = _STD distance(_UFirst, _Get_unwrapped(_Last));
; 5812 : 
; 5813 :     while (0 < _Count) { // divide and conquer, find half that contains answer

	test	esi, esi
	jg	SHORT $LL26@FindPGDIt
	mov	edx, DWORD PTR $T1[esp+20]
	pop	ebx
$LN27@FindPGDIt:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 150  :         return _Ptr == _Right._Ptr;

	cmp	ebp, edx
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\PSLibrary.cpp

; 74   : 	if (I==m_PGDs.end() || (0!=xr_strcmp((*I)->m_Name,Name)))	return m_PGDs.end();

	je	SHORT $LN5@FindPGDIt
	mov	eax, DWORD PTR [ebp]
; File I:\Vitalya\mine\NSProjectX\xrCore\xrstring.h

; 65   : 	str_c				operator*	() const						{	return p_?p_->value:0;							}

	mov	ecx, DWORD PTR [eax]
; File I:\Vitalya\mine\NSProjectX\xrCore\_std_extensions.h

; 183  : {	return (int)strcmp(S1,S2);  }

	lea	eax, DWORD PTR [ecx+12]
	neg	ecx
	sbb	ecx, ecx
	and	ecx, eax
$LL76@FindPGDIt:
	mov	al, BYTE PTR [ecx]
	cmp	al, BYTE PTR [edi]
	jne	SHORT $LN77@FindPGDIt
	test	al, al
	je	SHORT $LN78@FindPGDIt
	mov	al, BYTE PTR [ecx+1]
	cmp	al, BYTE PTR [edi+1]
	jne	SHORT $LN77@FindPGDIt
	add	ecx, 2
	add	edi, 2
	test	al, al
	jne	SHORT $LL76@FindPGDIt
$LN78@FindPGDIt:
	xor	eax, eax
	jmp	SHORT $LN79@FindPGDIt
$LN77@FindPGDIt:
	sbb	eax, eax
	or	eax, 1
$LN79@FindPGDIt:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\PSLibrary.cpp

; 74   : 	if (I==m_PGDs.end() || (0!=xr_strcmp((*I)->m_Name,Name)))	return m_PGDs.end();

	test	eax, eax
	jne	SHORT $LN5@FindPGDIt

; 75   : 	else														return I;

	mov	eax, DWORD PTR ___$ReturnUdt$[esp+12]
	pop	esi
	mov	DWORD PTR [eax], ebp
	pop	ebp
	pop	edi

; 77   : }

	pop	ecx
	ret	8
$LN5@FindPGDIt:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	eax, DWORD PTR ___$ReturnUdt$[esp+12]
	pop	esi
	pop	ebp
	pop	edi
	mov	DWORD PTR [eax], edx
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\PSLibrary.cpp

; 77   : }

	pop	ecx
	ret	8
?FindPGDIt@CPSLibrary@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPGDef@PS@@@std@@@std@@@std@@PBD@Z ENDP ; CPSLibrary::FindPGDIt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\PSLibrary.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\PSLibrary.cpp
_TEXT	SEGMENT
_it$ = 8						; size = 4
_Name$ = 8						; size = 4
?FindPGD@CPSLibrary@@QAEPAVCPGDef@PS@@PBD@Z PROC	; CPSLibrary::FindPGD
; _this$ = ecx

; 80   : {

	push	esi

; 81   : 	PS::PGDIt it = FindPGDIt(Name);

	push	DWORD PTR _Name$[esp]
	lea	eax, DWORD PTR _it$[esp+4]
	mov	esi, ecx
	push	eax
	call	?FindPGDIt@CPSLibrary@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPGDef@PS@@@std@@@std@@@std@@PBD@Z ; CPSLibrary::FindPGDIt
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 150  :         return _Ptr == _Right._Ptr;

	mov	eax, DWORD PTR _it$[esp]
	cmp	eax, DWORD PTR [esi+16]
	pop	esi
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\PSLibrary.cpp

; 82   :     return (it==m_PGDs.end())?0:*it;

	jne	SHORT $LN3@FindPGD
	xor	eax, eax

; 83   : }

	ret	4
$LN3@FindPGD:

; 82   :     return (it==m_PGDs.end())?0:*it;

	mov	eax, DWORD PTR [eax]

; 83   : }

	ret	4
?FindPGD@CPSLibrary@@QAEPAVCPGDef@PS@@PBD@Z ENDP	; CPSLibrary::FindPGD
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\PSLibrary.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleEffectDef.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xrstring.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleEffectDef.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector2.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleEffectDef.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleEffectDef.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\PSLibrary.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleEffectDef.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_flags.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\PSLibrary.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\PSLibrary.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\PSLibrary.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xrstring.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_flags.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\PSLibrary.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\PSLibrary.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\PSLibrary.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\PSLibrary.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xrstring.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrstring.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\PSLibrary.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\PSLibrary.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\PSLibrary.cpp
_TEXT	SEGMENT
_F$ = -16						; size = 4
_count$1$ = -12						; size = 4
_def$1 = -8						; size = 4
_def$2 = -8						; size = 4
_OBJ$2$ = -4						; size = 4
_OBJ$1$ = -4						; size = 4
_bRes$1$ = 8						; size = 1
$T3 = 8							; size = 4
_nm$ = 8						; size = 4
?Load@CPSLibrary@@QAE_NPBD@Z PROC			; CPSLibrary::Load
; _this$ = ecx

; 115  : {

	sub	esp, 16					; 00000010H
	push	ebx

; 116  : 	IReader*	F			= FS.r_open(nm);

	push	DWORD PTR _nm$[esp+16]
	mov	ebx, ecx
	mov	ecx, DWORD PTR __imp_?xr_FS@@3PAVCLocatorAPI@@A
	mov	ecx, DWORD PTR [ecx]
	call	DWORD PTR __imp_?r_open@CLocatorAPI@@QAEPAVIReader@@PBD@Z

; 117  : 	bool bRes 				= true;
; 118  :     R_ASSERT(F->find_chunk(PS_CHUNK_VERSION));

	cmp	BYTE PTR ?ignore_always@?3??Load@CPSLibrary@@QAE_NPBD@Z@4_NA, 0
	mov	DWORD PTR _F$[esp+20], eax
	mov	BYTE PTR _bRes$1$[esp+16], 1
	jne	SHORT $LN2@Load
	push	0
	push	1
	mov	ecx, eax
	call	DWORD PTR __imp_?find_chunk@?$IReaderBase@VIReader@@@@QAEIIPAH@Z
	test	eax, eax
	jne	SHORT $LN225@Load
	mov	ecx, DWORD PTR __imp_?Debug@@3VxrDebug@@A
	push	OFFSET ?ignore_always@?3??Load@CPSLibrary@@QAE_NPBD@Z@4_NA
	push	OFFSET ??_C@_0BB@KDCDFEAK@CPSLibrary?3?3Load@
	push	118					; 00000076H
	push	OFFSET ??_C@_0DJ@NDCAIDJB@I?3?2Vitalya?2mine?2NSProjectX?2laye@
	push	OFFSET ??_C@_0CA@JIEJDHOP@F?9?$DOfind_chunk?$CIPS_CHUNK_VERSION?$CJ@
	call	DWORD PTR __imp_?fail@xrDebug@@QAEXPBD0H0AA_N@Z
$LN225@Load:

; 119  :     u16 ver					= F->r_u16();

	mov	eax, DWORD PTR _F$[esp+20]
$LN2@Load:
	mov	ecx, eax
	call	DWORD PTR __imp_?r_u16@?$IReaderBase@VIReader@@@@QAEGXZ

; 120  :     if (ver!=PS_VERSION) return false;

	cmp	ax, 1
	je	SHORT $LN12@Load
	xor	al, al
	pop	ebx

; 158  : }

	add	esp, 16					; 00000010H
	ret	4
$LN12@Load:

; 121  :     // second generation
; 122  :     IReader* OBJ;
; 123  :     OBJ			 			= F->open_chunk(PS_CHUNK_SECONDGEN);

	mov	ecx, DWORD PTR _F$[esp+20]
	push	ebp
	push	esi
	mov	esi, DWORD PTR __imp_?open_chunk@IReader@@QAEPAV1@I@Z
	push	edi
	push	3
	call	esi
	mov	DWORD PTR _OBJ$1$[esp+32], eax

; 124  :     if (OBJ){

	test	eax, eax
	je	$LN13@Load

; 125  :         IReader* O   		= OBJ->open_chunk(0);

	push	0
	mov	ecx, eax
	call	esi
	mov	ebp, eax

; 126  :         for (int count=1; O; count++) {

	mov	DWORD PTR _count$1$[esp+32], 1
	test	ebp, ebp
	je	$LN211@Load
	npad	4
$LL7@Load:
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h

; 68   : 	T* ptr	= (T*)Memory.mem_alloc(sizeof(T));

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	128					; 00000080H
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z

; 69   : 	return new (ptr) T();

	mov	edi, eax
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleEffectDef.cpp

; 17   : {                                          

	lea	ecx, DWORD PTR [edi+48]
; File I:\Vitalya\mine\NSProjectX\xrCore\xrstring.h

; 57   : 						shared_str	()								{	p_ = 0;											}

	mov	DWORD PTR [edi], 0
	mov	DWORD PTR [edi+8], 0
	mov	DWORD PTR [edi+12], 0
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 61   : 						resptr_core		()												{	p_ = 0;						}

	mov	DWORD PTR [edi+16], 0
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleEffectDef.cpp

; 17   : {                                          

	call	DWORD PTR __imp_??0CMemoryWriter@@QAE@XZ
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 46   : 	ICF		void		_set	(T * rhs) 							{	if (0!=rhs) rhs->dwReference++;	_dec(); p_ = rhs;											}

	lea	ecx, DWORD PTR [edi+16]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector2.h

; 15   : 	IC SelfRef set(float _u, float _v)				{ x=T(_u); y=T(_v);				return *this;	}

	mov	DWORD PTR [edi+20], 1040187392		; 3e000000H
	mov	DWORD PTR [edi+24], 1056964608		; 3f000000H
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleEffectDef.h

; 42   : 			m_iFrameDimX 	= 8;

	mov	DWORD PTR [edi+36], 8

; 43   : 			m_iFrameCount 	= 16;

	mov	DWORD PTR [edi+40], 16			; 00000010H

; 44   : 			m_fSpeed		= 24.f;

	mov	DWORD PTR [edi+44], 1103101952		; 41c00000H
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleEffectDef.cpp

; 19   :     m_MaxParticles		= 0;

	mov	DWORD PTR [edi+88], 0
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 62   : 						resptr_core		(T * p, bool add_ref = true) 					{	p_ = p;	if(add_ref)	_inc(); }

	mov	DWORD PTR $T3[esp+28], 0

; 46   : 	ICF		void		_set	(T * rhs) 							{	if (0!=rhs) rhs->dwReference++;	_dec(); p_ = rhs;											}

	call	DWORD PTR __imp_?_dec@?$resptr_base@UShader@@@@IAEXXZ

; 64   : 						~resptr_core	()												{	_dec();						}

	lea	ecx, DWORD PTR $T3[esp+28]

; 46   : 	ICF		void		_set	(T * rhs) 							{	if (0!=rhs) rhs->dwReference++;	_dec(); p_ = rhs;											}

	mov	DWORD PTR [edi+16], 0

; 64   : 						~resptr_core	()												{	_dec();						}

	call	DWORD PTR __imp_?_dec@?$resptr_base@UShader@@@@IAEXXZ
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\PSLibrary.cpp

; 128  :             if (def->Load(*O)) m_PEDs.push_back(def);

	push	ebp
	mov	ecx, edi
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleEffectDef.cpp

; 21   : 	m_fTimeLimit		= 0.f;

	mov	DWORD PTR [edi+84], 0

; 22   :     // collision
; 23   :     m_fCollideOneMinusFriction 	= 1.f;

	mov	DWORD PTR [edi+116], 1065353216		; 3f800000H

; 24   :     m_fCollideResilience		= 0.f;

	mov	DWORD PTR [edi+120], 0

; 25   :     m_fCollideSqrCutoff			= 0.f;

	mov	DWORD PTR [edi+124], 0
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 23   : 	ICF	SelfRef	set(T _x, T _y, T _z)					{ x = _x;		y = _y;		z = _z;		return *this;	};

	mov	DWORD PTR [edi+92], 0
	mov	DWORD PTR [edi+96], 0
	mov	DWORD PTR [edi+100], 0
	mov	DWORD PTR [edi+104], -1077342245	; bfc90fdbH
	mov	DWORD PTR [edi+108], 0
	mov	DWORD PTR [edi+112], 0
; File I:\Vitalya\mine\NSProjectX\xrCore\_flags.h

; 15   :     IC	SelfRef	zero	()											{ flags=T(0);	return *this;	}

	mov	DWORD PTR [edi+4], 0
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\PSLibrary.cpp

; 127  :             PS::CPEDef*	def	= xr_new<PS::CPEDef>();

	mov	DWORD PTR _def$2[esp+36], edi

; 128  :             if (def->Load(*O)) m_PEDs.push_back(def);

	call	?Load@CPEDef@PS@@QAEHAAVIReader@@@Z	; PS::CPEDef::Load
	test	eax, eax
	je	SHORT $LN14@Load
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 730  :         if (_Mylast != _My_data._Myend) {

	mov	eax, DWORD PTR [ebx+4]
	cmp	eax, DWORD PTR [ebx+8]
	je	SHORT $LN64@Load

; 713  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

	mov	DWORD PTR [eax], edi

; 714  :         _Orphan_range(_Mylast, _Mylast);
; 715  :         _Ty& _Result = *_Mylast;
; 716  :         ++_Mylast;

	add	DWORD PTR [ebx+4], 4

; 731  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

	jmp	SHORT $LN63@Load
$LN64@Load:

; 732  :         }
; 733  : 
; 734  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	lea	ecx, DWORD PTR _def$2[esp+32]
	push	ecx
	push	eax
	mov	ecx, ebx
	call	??$_Emplace_reallocate@ABQAVCPEDef@PS@@@?$vector@PAVCPEDef@PS@@V?$xalloc@PAVCPEDef@PS@@@@@std@@QAEPAPAVCPEDef@PS@@QAPAV23@ABQAV23@@Z ; std::vector<PS::CPEDef *,xalloc<PS::CPEDef *> >::_Emplace_reallocate<PS::CPEDef * const &>
$LN63@Load:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\PSLibrary.cpp

; 128  :             if (def->Load(*O)) m_PEDs.push_back(def);

	mov	ecx, ebp
	call	DWORD PTR __imp_?close@IReader@@QAEXXZ

; 130  :             O->close();
; 131  :             if (!bRes)	break;
; 132  :             O 			= OBJ->open_chunk(count);

	mov	esi, DWORD PTR _count$1$[esp+32]
	mov	ecx, DWORD PTR _OBJ$1$[esp+32]
	push	esi
	call	DWORD PTR __imp_?open_chunk@IReader@@QAEPAV1@I@Z
	mov	ebp, eax
	mov	BYTE PTR _bRes$1$[esp+28], 1
	inc	esi
	mov	DWORD PTR _count$1$[esp+32], esi
	test	ebp, ebp
	jne	$LL7@Load

; 126  :         for (int count=1; O; count++) {

	jmp	SHORT $LN226@Load
$LN14@Load:

; 129  :             else{ bRes = false; xr_delete(def); }

	lea	ecx, DWORD PTR _def$2[esp+32]
	mov	BYTE PTR _bRes$1$[esp+28], 0
	call	??$xr_delete@VCPEDef@PS@@@@YAXAAPAVCPEDef@PS@@@Z ; xr_delete<PS::CPEDef>
	mov	ecx, ebp
	call	DWORD PTR __imp_?close@IReader@@QAEXXZ
$LN226@Load:

; 133  :         }
; 134  :         OBJ->close();

	mov	esi, DWORD PTR __imp_?open_chunk@IReader@@QAEPAV1@I@Z
$LN211@Load:
	mov	ecx, DWORD PTR _OBJ$1$[esp+32]
	call	DWORD PTR __imp_?close@IReader@@QAEXXZ
$LN13@Load:

; 135  :     }
; 136  :     // second generation
; 137  :     OBJ 					= F->open_chunk(PS_CHUNK_THIRDGEN);

	mov	ecx, DWORD PTR _F$[esp+32]
	push	4
	call	esi
	mov	DWORD PTR _OBJ$2$[esp+32], eax

; 138  :     if (OBJ){

	test	eax, eax
	je	$LN17@Load

; 139  :         IReader* O   		= OBJ->open_chunk(0);

	push	0
	mov	ecx, eax
	call	esi
	mov	ebp, eax

; 140  :         for (int count=1; O; count++) {

	mov	edi, 1
	test	ebp, ebp
	je	$LN212@Load
	mov	al, BYTE PTR _bRes$1$[esp+28]
	npad	3
$LL10@Load:
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h

; 68   : 	T* ptr	= (T*)Memory.mem_alloc(sizeof(T));

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	24					; 00000018H
	mov	BYTE PTR _bRes$1$[esp+32], al
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z

; 69   : 	return new (ptr) T();

	mov	esi, eax
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\PSLibrary.cpp

; 142  :             if (def->Load(*O)) m_PGDs.push_back(def);

	push	ebp
	mov	ecx, esi
	mov	DWORD PTR _def$1[esp+36], esi
; File I:\Vitalya\mine\NSProjectX\xrCore\xrstring.h

; 57   : 						shared_str	()								{	p_ = 0;											}

	mov	DWORD PTR [esi], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [esi+12], 0
	mov	DWORD PTR [esi+16], 0
	mov	DWORD PTR [esi+20], 0
; File I:\Vitalya\mine\NSProjectX\xrCore\_flags.h

; 15   :     IC	SelfRef	zero	()											{ flags=T(0);	return *this;	}

	mov	DWORD PTR [esi+4], 0
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp

; 15   :     m_fTimeLimit	= 0.f;

	mov	DWORD PTR [esi+8], 0
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\PSLibrary.cpp

; 142  :             if (def->Load(*O)) m_PGDs.push_back(def);

	call	?Load@CPGDef@PS@@QAEHAAVIReader@@@Z	; PS::CPGDef::Load
	test	eax, eax
	je	SHORT $LN18@Load
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 730  :         if (_Mylast != _My_data._Myend) {

	mov	eax, DWORD PTR [ebx+16]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\PSLibrary.cpp

; 142  :             if (def->Load(*O)) m_PGDs.push_back(def);

	lea	ecx, DWORD PTR [ebx+12]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 730  :         if (_Mylast != _My_data._Myend) {

	cmp	eax, DWORD PTR [ecx+8]
	je	SHORT $LN87@Load

; 713  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

	mov	DWORD PTR [eax], esi

; 714  :         _Orphan_range(_Mylast, _Mylast);
; 715  :         _Ty& _Result = *_Mylast;
; 716  :         ++_Mylast;

	add	DWORD PTR [ecx+4], 4

; 731  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

	jmp	SHORT $LN92@Load
$LN87@Load:

; 732  :         }
; 733  : 
; 734  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	lea	edx, DWORD PTR _def$1[esp+32]
	push	edx
	push	eax
	call	??$_Emplace_reallocate@ABQAVCPGDef@PS@@@?$vector@PAVCPGDef@PS@@V?$xalloc@PAVCPGDef@PS@@@@@std@@QAEPAPAVCPGDef@PS@@QAPAV23@ABQAV23@@Z ; std::vector<PS::CPGDef *,xalloc<PS::CPGDef *> >::_Emplace_reallocate<PS::CPGDef * const &>
$LN92@Load:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\PSLibrary.cpp

; 144  :             O->close();

	mov	ecx, ebp
	call	DWORD PTR __imp_?close@IReader@@QAEXXZ

; 145  :             if (!bRes) break;

	cmp	BYTE PTR _bRes$1$[esp+28], 0
	je	$LN212@Load

; 146  :             O 			= OBJ->open_chunk(count);

	mov	ecx, DWORD PTR _OBJ$2$[esp+32]
	push	edi
	call	DWORD PTR __imp_?open_chunk@IReader@@QAEPAV1@I@Z
	mov	ebp, eax
	inc	edi
	mov	al, BYTE PTR _bRes$1$[esp+28]
	mov	BYTE PTR _bRes$1$[esp+28], al
	test	ebp, ebp
	jne	$LL10@Load

; 140  :         for (int count=1; O; count++) {

	jmp	$LN212@Load
$LN18@Load:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	edi, DWORD PTR [esi+12]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp

; 20   :     for (EffectIt it=m_Effects.begin(); it!=m_Effects.end(); it++)

	mov	edx, DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\PSLibrary.cpp

; 143  :             else{ bRes = false; xr_delete(def); }

	mov	BYTE PTR _bRes$1$[esp+28], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 150  :         return _Ptr == _Right._Ptr;

	cmp	edi, DWORD PTR [esi+16]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp

; 20   :     for (EffectIt it=m_Effects.begin(); it!=m_Effects.end(); it++)

	je	$LN101@Load
	npad	8
$LL102@Load:
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h

; 151  : 	if (ptr) 

	mov	ecx, DWORD PTR [edi]
	test	ecx, ecx
	je	$LN100@Load
; File I:\Vitalya\mine\NSProjectX\xrCore\xrstring.h

; 50   : 	void				_dec		()								{	if (0==p_) return;	p_->dwReference--; 	if (0==p_->dwReference)	p_=0;						}

	mov	eax, DWORD PTR [ecx+16]
	test	eax, eax
	je	SHORT $LN138@Load
	dec	DWORD PTR [eax]
	mov	eax, DWORD PTR [ecx+16]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN138@Load
	mov	DWORD PTR [ecx+16], 0
$LN138@Load:
	mov	eax, DWORD PTR [ecx+12]
	test	eax, eax
	je	SHORT $LN144@Load
	dec	DWORD PTR [eax]
	mov	eax, DWORD PTR [ecx+12]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN144@Load
	mov	DWORD PTR [ecx+12], 0
$LN144@Load:
	mov	eax, DWORD PTR [ecx+8]
	test	eax, eax
	je	SHORT $LN150@Load
	dec	DWORD PTR [eax]
	mov	eax, DWORD PTR [ecx+8]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN150@Load
	mov	DWORD PTR [ecx+8], 0
$LN150@Load:
	mov	eax, DWORD PTR [ecx+4]
	test	eax, eax
	je	SHORT $LN156@Load
	dec	DWORD PTR [eax]
	mov	eax, DWORD PTR [ecx+4]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN156@Load
	mov	DWORD PTR [ecx+4], 0
$LN156@Load:
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h

; 144  : 		Memory.mem_free	(ptr);

	push	DWORD PTR [edi]
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	edx

; 154  : 		ptr = nullptr;

	mov	edx, DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
	mov	DWORD PTR [edi], 0
$LN100@Load:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 74   :         ++_Ptr;

	add	edi, 4

; 150  :         return _Ptr == _Right._Ptr;

	cmp	edi, DWORD PTR [esi+16]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp

; 20   :     for (EffectIt it=m_Effects.begin(); it!=m_Effects.end(); it++)

	jne	$LL102@Load
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h

; 154  : 		ptr = nullptr;

	mov	edi, DWORD PTR [esi+12]
$LN101@Load:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp

; 22   :     m_Effects.clear	();

	mov	DWORD PTR [esi+16], edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	test	edi, edi
	je	SHORT $LN163@Load
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	edi
	call	edx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi+12], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+16], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+20], 0
$LN163@Load:
; File I:\Vitalya\mine\NSProjectX\xrCore\xrstring.h

; 50   : 	void				_dec		()								{	if (0==p_) return;	p_->dwReference--; 	if (0==p_->dwReference)	p_=0;						}

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN174@Load
	dec	DWORD PTR [eax]
	mov	eax, DWORD PTR [esi]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN174@Load
	mov	DWORD PTR [esi], 0
$LN174@Load:
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h

; 144  : 		Memory.mem_free	(ptr);

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	esi
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
	mov	ecx, ebp
	call	DWORD PTR __imp_?close@IReader@@QAEXXZ
$LN212@Load:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\PSLibrary.cpp

; 148  :         OBJ->close();

	mov	ecx, DWORD PTR _OBJ$2$[esp+32]
	call	DWORD PTR __imp_?close@IReader@@QAEXXZ
$LN17@Load:

; 149  :     }
; 150  : 
; 151  :     // final
; 152  : 	FS.r_close			(F);

	mov	ecx, DWORD PTR __imp_?xr_FS@@3PAVCLocatorAPI@@A
	lea	eax, DWORD PTR _F$[esp+32]
	push	eax
	mov	ecx, DWORD PTR [ecx]
	call	DWORD PTR __imp_?r_close@CLocatorAPI@@QAEXAAPAVIReader@@@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 7079 :     const auto _ULast  = _Get_unwrapped(_Last);

	mov	edx, DWORD PTR [ebx+4]

; 7080 :     _Sort_unchecked(_UFirst, _ULast, _ULast - _UFirst, _Pass_fn(_Pred));

	mov	eax, edx
	mov	ecx, DWORD PTR [ebx]
	sub	eax, ecx
	sar	eax, 2
	push	OFFSET ?ped_sort_pred@@YA_NPBVCPEDef@PS@@0@Z ; ped_sort_pred
	push	eax
	call	??$_Sort_unchecked@PAPAVCPEDef@PS@@P6A_NPBV12@0@Z@std@@YAXPAPAVCPEDef@PS@@0HP6A_NPBV12@1@Z@Z ; std::_Sort_unchecked<PS::CPEDef * *,bool (__cdecl*)(PS::CPEDef const *,PS::CPEDef const *)>

; 7079 :     const auto _ULast  = _Get_unwrapped(_Last);

	mov	edx, DWORD PTR [ebx+16]

; 7080 :     _Sort_unchecked(_UFirst, _ULast, _ULast - _UFirst, _Pass_fn(_Pred));

	mov	esi, edx
	mov	ecx, DWORD PTR [ebx+12]
	sub	esi, ecx
	push	OFFSET ?pgd_sort_pred@@YA_NPBVCPGDef@PS@@0@Z ; pgd_sort_pred
	sar	esi, 2
	push	esi
	call	??$_Sort_unchecked@PAPAVCPGDef@PS@@P6A_NPBV12@0@Z@std@@YAXPAPAVCPGDef@PS@@0HP6A_NPBV12@1@Z@Z ; std::_Sort_unchecked<PS::CPGDef * *,bool (__cdecl*)(PS::CPGDef const *,PS::CPGDef const *)>
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\PSLibrary.cpp

; 157  :     return bRes;

	mov	al, BYTE PTR _bRes$1$[esp+44]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 7080 :     _Sort_unchecked(_UFirst, _ULast, _ULast - _UFirst, _Pass_fn(_Pred));

	add	esp, 16					; 00000010H
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\PSLibrary.cpp

; 157  :     return bRes;

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 158  : }

	add	esp, 16					; 00000010H
	ret	4
?Load@CPSLibrary@@QAE_NPBD@Z ENDP			; CPSLibrary::Load
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPGDef@PS@@@std@@@std@@@std@@QAE?AV01@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$dead$ = 12					; size = 4
??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPGDef@PS@@@std@@@std@@@std@@QAE?AV01@H@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<PS::CPGDef *> > >::operator++, COMDAT
; _this$ = ecx

; 281  :         _Vector_iterator _Tmp = *this;

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx

; 74   :         ++_Ptr;

	add	edx, 4
	mov	DWORD PTR [ecx], edx

; 282  :         _Mybase::operator++();
; 283  :         return _Tmp;
; 284  :     }

	ret	8
??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPGDef@PS@@@std@@@std@@@std@@QAE?AV01@H@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<PS::CPGDef *> > >::operator++
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPGDef@PS@@@std@@@std@@@std@@QBEAAPAVCPGDef@PS@@XZ
_TEXT	SEGMENT
??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPGDef@PS@@@std@@@std@@@std@@QBEAAPAVCPGDef@PS@@XZ PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<PS::CPGDef *> > >::operator*, COMDAT
; _this$ = ecx

; 261  :         return const_cast<reference>(_Mybase::operator*());

	mov	eax, DWORD PTR [ecx]

; 262  :     }

	ret	0
??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPGDef@PS@@@std@@@std@@@std@@QBEAAPAVCPGDef@PS@@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<PS::CPGDef *> > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPGDef@PS@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPGDef@PS@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<PS::CPGDef *> > >::operator!=, COMDAT
; _this$ = ecx

; 160  :         return !(*this == _Right);

	mov	eax, DWORD PTR __Right$[esp-4]
	mov	ecx, DWORD PTR [ecx]
	cmp	ecx, DWORD PTR [eax]
	setne	al

; 161  :     }

	ret	4
??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPGDef@PS@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<PS::CPGDef *> > >::operator!=
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPGDef@PS@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPGDef@PS@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<PS::CPGDef *> > >::operator==, COMDAT
; _this$ = ecx

; 149  :         _Compat(_Right);
; 150  :         return _Ptr == _Right._Ptr;

	mov	eax, DWORD PTR __Right$[esp-4]
	mov	ecx, DWORD PTR [ecx]
	cmp	ecx, DWORD PTR [eax]
	sete	al

; 151  :     }

	ret	4
??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPGDef@PS@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<PS::CPGDef *> > >::operator==
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPEDef@PS@@@std@@@std@@@std@@QAE?AV01@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$dead$ = 12					; size = 4
??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPEDef@PS@@@std@@@std@@@std@@QAE?AV01@H@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<PS::CPEDef *> > >::operator++, COMDAT
; _this$ = ecx

; 281  :         _Vector_iterator _Tmp = *this;

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx

; 74   :         ++_Ptr;

	add	edx, 4
	mov	DWORD PTR [ecx], edx

; 282  :         _Mybase::operator++();
; 283  :         return _Tmp;
; 284  :     }

	ret	8
??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPEDef@PS@@@std@@@std@@@std@@QAE?AV01@H@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<PS::CPEDef *> > >::operator++
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPEDef@PS@@@std@@@std@@@std@@QBEAAPAVCPEDef@PS@@XZ
_TEXT	SEGMENT
??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPEDef@PS@@@std@@@std@@@std@@QBEAAPAVCPEDef@PS@@XZ PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<PS::CPEDef *> > >::operator*, COMDAT
; _this$ = ecx

; 261  :         return const_cast<reference>(_Mybase::operator*());

	mov	eax, DWORD PTR [ecx]

; 262  :     }

	ret	0
??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPEDef@PS@@@std@@@std@@@std@@QBEAAPAVCPEDef@PS@@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<PS::CPEDef *> > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPEDef@PS@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPEDef@PS@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<PS::CPEDef *> > >::operator!=, COMDAT
; _this$ = ecx

; 160  :         return !(*this == _Right);

	mov	eax, DWORD PTR __Right$[esp-4]
	mov	ecx, DWORD PTR [ecx]
	cmp	ecx, DWORD PTR [eax]
	setne	al

; 161  :     }

	ret	4
??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPEDef@PS@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<PS::CPEDef *> > >::operator!=
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPEDef@PS@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPEDef@PS@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<PS::CPEDef *> > >::operator==, COMDAT
; _this$ = ecx

; 149  :         _Compat(_Right);
; 150  :         return _Ptr == _Right._Ptr;

	mov	eax, DWORD PTR __Right$[esp-4]
	mov	ecx, DWORD PTR [ecx]
	cmp	ecx, DWORD PTR [eax]
	sete	al

; 151  :     }

	ret	4
??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPEDef@PS@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<PS::CPEDef *> > >::operator==
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?clear@?$xr_vector@PAVCPGDef@PS@@V?$xalloc@PAVCPGDef@PS@@@@@@QAEXXZ
_TEXT	SEGMENT
?clear@?$xr_vector@PAVCPGDef@PS@@V?$xalloc@PAVCPGDef@PS@@@@@@QAEXXZ PROC ; xr_vector<PS::CPGDef *,xalloc<PS::CPGDef *> >::clear, COMDAT
; _this$ = ecx

; 132  : 	void	clear				()									{ clear_and_free	();			}

	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [ecx+4], eax
	ret	0
?clear@?$xr_vector@PAVCPGDef@PS@@V?$xalloc@PAVCPGDef@PS@@@@@@QAEXXZ ENDP ; xr_vector<PS::CPGDef *,xalloc<PS::CPGDef *> >::clear
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?push_back@?$vector@PAVCPGDef@PS@@V?$xalloc@PAVCPGDef@PS@@@@@std@@QAEXABQAVCPGDef@PS@@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?push_back@?$vector@PAVCPGDef@PS@@V?$xalloc@PAVCPGDef@PS@@@@@std@@QAEXABQAVCPGDef@PS@@@Z PROC ; std::vector<PS::CPGDef *,xalloc<PS::CPGDef *> >::push_back, COMDAT
; _this$ = ecx

; 730  :         if (_Mylast != _My_data._Myend) {

	mov	edx, DWORD PTR [ecx+4]
	cmp	edx, DWORD PTR [ecx+8]
	je	SHORT $LN4@push_back

; 713  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

	mov	eax, DWORD PTR __Val$[esp-4]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edx], eax

; 714  :         _Orphan_range(_Mylast, _Mylast);
; 715  :         _Ty& _Result = *_Mylast;
; 716  :         ++_Mylast;

	add	DWORD PTR [ecx+4], 4

; 743  :         emplace_back(_Val);
; 744  :     }

	ret	4
$LN4@push_back:

; 734  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	push	DWORD PTR __Val$[esp-4]
	push	edx
	call	??$_Emplace_reallocate@ABQAVCPGDef@PS@@@?$vector@PAVCPGDef@PS@@V?$xalloc@PAVCPGDef@PS@@@@@std@@QAEPAPAVCPGDef@PS@@QAPAV23@ABQAV23@@Z ; std::vector<PS::CPGDef *,xalloc<PS::CPGDef *> >::_Emplace_reallocate<PS::CPGDef * const &>

; 743  :         emplace_back(_Val);
; 744  :     }

	ret	4
?push_back@?$vector@PAVCPGDef@PS@@V?$xalloc@PAVCPGDef@PS@@@@@std@@QAEXABQAVCPGDef@PS@@@Z ENDP ; std::vector<PS::CPGDef *,xalloc<PS::CPGDef *> >::push_back
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??$emplace_back@ABQAVCPGDef@PS@@@?$vector@PAVCPGDef@PS@@V?$xalloc@PAVCPGDef@PS@@@@@std@@QAE?A_TABQAVCPGDef@PS@@@Z
_TEXT	SEGMENT
_<_Val_0>$ = 8						; size = 4
??$emplace_back@ABQAVCPGDef@PS@@@?$vector@PAVCPGDef@PS@@V?$xalloc@PAVCPGDef@PS@@@@@std@@QAE?A_TABQAVCPGDef@PS@@@Z PROC ; std::vector<PS::CPGDef *,xalloc<PS::CPGDef *> >::emplace_back<PS::CPGDef * const &>, COMDAT
; _this$ = ecx

; 727  :         // insert by perfectly forwarding into element at end, provide strong guarantee
; 728  :         auto& _My_data   = _Mypair._Myval2;
; 729  :         pointer& _Mylast = _My_data._Mylast;
; 730  :         if (_Mylast != _My_data._Myend) {

	mov	edx, DWORD PTR [ecx+4]
	cmp	edx, DWORD PTR [ecx+8]
	je	SHORT $LN2@emplace_ba

; 713  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

	mov	eax, DWORD PTR _<_Val_0>$[esp-4]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edx], eax

; 714  :         _Orphan_range(_Mylast, _Mylast);
; 715  :         _Ty& _Result = *_Mylast;
; 716  :         ++_Mylast;

	add	DWORD PTR [ecx+4], 4

; 735  : #if _HAS_CXX17
; 736  :         return _Result;
; 737  : #else // ^^^ _HAS_CXX17 ^^^ // vvv !_HAS_CXX17 vvv
; 738  :         (void) _Result;
; 739  : #endif // _HAS_CXX17
; 740  :     }

	ret	4
$LN2@emplace_ba:

; 731  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);
; 732  :         }
; 733  : 
; 734  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	push	DWORD PTR _<_Val_0>$[esp-4]
	push	edx
	call	??$_Emplace_reallocate@ABQAVCPGDef@PS@@@?$vector@PAVCPGDef@PS@@V?$xalloc@PAVCPGDef@PS@@@@@std@@QAEPAPAVCPGDef@PS@@QAPAV23@ABQAV23@@Z ; std::vector<PS::CPGDef *,xalloc<PS::CPGDef *> >::_Emplace_reallocate<PS::CPGDef * const &>

; 735  : #if _HAS_CXX17
; 736  :         return _Result;
; 737  : #else // ^^^ _HAS_CXX17 ^^^ // vvv !_HAS_CXX17 vvv
; 738  :         (void) _Result;
; 739  : #endif // _HAS_CXX17
; 740  :     }

	ret	4
??$emplace_back@ABQAVCPGDef@PS@@@?$vector@PAVCPGDef@PS@@V?$xalloc@PAVCPGDef@PS@@@@@std@@QAE?A_TABQAVCPGDef@PS@@@Z ENDP ; std::vector<PS::CPGDef *,xalloc<PS::CPGDef *> >::emplace_back<PS::CPGDef * const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??$_Emplace_back_with_unused_capacity@ABQAVCPGDef@PS@@@?$vector@PAVCPGDef@PS@@V?$xalloc@PAVCPGDef@PS@@@@@std@@AAE?A_TABQAVCPGDef@PS@@@Z
_TEXT	SEGMENT
_<_Val_0>$ = 8						; size = 4
??$_Emplace_back_with_unused_capacity@ABQAVCPGDef@PS@@@?$vector@PAVCPGDef@PS@@V?$xalloc@PAVCPGDef@PS@@@@@std@@AAE?A_TABQAVCPGDef@PS@@@Z PROC ; std::vector<PS::CPGDef *,xalloc<PS::CPGDef *> >::_Emplace_back_with_unused_capacity<PS::CPGDef * const &>, COMDAT
; _this$ = ecx

; 709  :         // insert by perfectly forwarding into element at end, provide strong guarantee
; 710  :         auto& _My_data   = _Mypair._Myval2;
; 711  :         pointer& _Mylast = _My_data._Mylast;
; 712  :         _STL_INTERNAL_CHECK(_Mylast != _My_data._Myend); // check that we have unused capacity
; 713  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _<_Val_0>$[esp-4]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edx], eax

; 714  :         _Orphan_range(_Mylast, _Mylast);
; 715  :         _Ty& _Result = *_Mylast;
; 716  :         ++_Mylast;

	add	DWORD PTR [ecx+4], 4

; 717  : #if _HAS_CXX17
; 718  :         return _Result;
; 719  : #else // ^^^ _HAS_CXX17 ^^^ // vvv !_HAS_CXX17 vvv
; 720  :         (void) _Result;
; 721  : #endif // _HAS_CXX17
; 722  :     }

	ret	4
??$_Emplace_back_with_unused_capacity@ABQAVCPGDef@PS@@@?$vector@PAVCPGDef@PS@@V?$xalloc@PAVCPGDef@PS@@@@@std@@AAE?A_TABQAVCPGDef@PS@@@Z ENDP ; std::vector<PS::CPGDef *,xalloc<PS::CPGDef *> >::_Emplace_back_with_unused_capacity<PS::CPGDef * const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?clear@?$xr_vector@PAVCPEDef@PS@@V?$xalloc@PAVCPEDef@PS@@@@@@QAEXXZ
_TEXT	SEGMENT
?clear@?$xr_vector@PAVCPEDef@PS@@V?$xalloc@PAVCPEDef@PS@@@@@@QAEXXZ PROC ; xr_vector<PS::CPEDef *,xalloc<PS::CPEDef *> >::clear, COMDAT
; _this$ = ecx

; 132  : 	void	clear				()									{ clear_and_free	();			}

	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [ecx+4], eax
	ret	0
?clear@?$xr_vector@PAVCPEDef@PS@@V?$xalloc@PAVCPEDef@PS@@@@@@QAEXXZ ENDP ; xr_vector<PS::CPEDef *,xalloc<PS::CPEDef *> >::clear
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?push_back@?$vector@PAVCPEDef@PS@@V?$xalloc@PAVCPEDef@PS@@@@@std@@QAEXABQAVCPEDef@PS@@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?push_back@?$vector@PAVCPEDef@PS@@V?$xalloc@PAVCPEDef@PS@@@@@std@@QAEXABQAVCPEDef@PS@@@Z PROC ; std::vector<PS::CPEDef *,xalloc<PS::CPEDef *> >::push_back, COMDAT
; _this$ = ecx

; 730  :         if (_Mylast != _My_data._Myend) {

	mov	edx, DWORD PTR [ecx+4]
	cmp	edx, DWORD PTR [ecx+8]
	je	SHORT $LN4@push_back

; 713  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

	mov	eax, DWORD PTR __Val$[esp-4]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edx], eax

; 714  :         _Orphan_range(_Mylast, _Mylast);
; 715  :         _Ty& _Result = *_Mylast;
; 716  :         ++_Mylast;

	add	DWORD PTR [ecx+4], 4

; 743  :         emplace_back(_Val);
; 744  :     }

	ret	4
$LN4@push_back:

; 734  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	push	DWORD PTR __Val$[esp-4]
	push	edx
	call	??$_Emplace_reallocate@ABQAVCPEDef@PS@@@?$vector@PAVCPEDef@PS@@V?$xalloc@PAVCPEDef@PS@@@@@std@@QAEPAPAVCPEDef@PS@@QAPAV23@ABQAV23@@Z ; std::vector<PS::CPEDef *,xalloc<PS::CPEDef *> >::_Emplace_reallocate<PS::CPEDef * const &>

; 743  :         emplace_back(_Val);
; 744  :     }

	ret	4
?push_back@?$vector@PAVCPEDef@PS@@V?$xalloc@PAVCPEDef@PS@@@@@std@@QAEXABQAVCPEDef@PS@@@Z ENDP ; std::vector<PS::CPEDef *,xalloc<PS::CPEDef *> >::push_back
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??$emplace_back@ABQAVCPEDef@PS@@@?$vector@PAVCPEDef@PS@@V?$xalloc@PAVCPEDef@PS@@@@@std@@QAE?A_TABQAVCPEDef@PS@@@Z
_TEXT	SEGMENT
_<_Val_0>$ = 8						; size = 4
??$emplace_back@ABQAVCPEDef@PS@@@?$vector@PAVCPEDef@PS@@V?$xalloc@PAVCPEDef@PS@@@@@std@@QAE?A_TABQAVCPEDef@PS@@@Z PROC ; std::vector<PS::CPEDef *,xalloc<PS::CPEDef *> >::emplace_back<PS::CPEDef * const &>, COMDAT
; _this$ = ecx

; 727  :         // insert by perfectly forwarding into element at end, provide strong guarantee
; 728  :         auto& _My_data   = _Mypair._Myval2;
; 729  :         pointer& _Mylast = _My_data._Mylast;
; 730  :         if (_Mylast != _My_data._Myend) {

	mov	edx, DWORD PTR [ecx+4]
	cmp	edx, DWORD PTR [ecx+8]
	je	SHORT $LN2@emplace_ba

; 713  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

	mov	eax, DWORD PTR _<_Val_0>$[esp-4]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edx], eax

; 714  :         _Orphan_range(_Mylast, _Mylast);
; 715  :         _Ty& _Result = *_Mylast;
; 716  :         ++_Mylast;

	add	DWORD PTR [ecx+4], 4

; 735  : #if _HAS_CXX17
; 736  :         return _Result;
; 737  : #else // ^^^ _HAS_CXX17 ^^^ // vvv !_HAS_CXX17 vvv
; 738  :         (void) _Result;
; 739  : #endif // _HAS_CXX17
; 740  :     }

	ret	4
$LN2@emplace_ba:

; 731  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);
; 732  :         }
; 733  : 
; 734  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	push	DWORD PTR _<_Val_0>$[esp-4]
	push	edx
	call	??$_Emplace_reallocate@ABQAVCPEDef@PS@@@?$vector@PAVCPEDef@PS@@V?$xalloc@PAVCPEDef@PS@@@@@std@@QAEPAPAVCPEDef@PS@@QAPAV23@ABQAV23@@Z ; std::vector<PS::CPEDef *,xalloc<PS::CPEDef *> >::_Emplace_reallocate<PS::CPEDef * const &>

; 735  : #if _HAS_CXX17
; 736  :         return _Result;
; 737  : #else // ^^^ _HAS_CXX17 ^^^ // vvv !_HAS_CXX17 vvv
; 738  :         (void) _Result;
; 739  : #endif // _HAS_CXX17
; 740  :     }

	ret	4
??$emplace_back@ABQAVCPEDef@PS@@@?$vector@PAVCPEDef@PS@@V?$xalloc@PAVCPEDef@PS@@@@@std@@QAE?A_TABQAVCPEDef@PS@@@Z ENDP ; std::vector<PS::CPEDef *,xalloc<PS::CPEDef *> >::emplace_back<PS::CPEDef * const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??$_Emplace_back_with_unused_capacity@ABQAVCPEDef@PS@@@?$vector@PAVCPEDef@PS@@V?$xalloc@PAVCPEDef@PS@@@@@std@@AAE?A_TABQAVCPEDef@PS@@@Z
_TEXT	SEGMENT
_<_Val_0>$ = 8						; size = 4
??$_Emplace_back_with_unused_capacity@ABQAVCPEDef@PS@@@?$vector@PAVCPEDef@PS@@V?$xalloc@PAVCPEDef@PS@@@@@std@@AAE?A_TABQAVCPEDef@PS@@@Z PROC ; std::vector<PS::CPEDef *,xalloc<PS::CPEDef *> >::_Emplace_back_with_unused_capacity<PS::CPEDef * const &>, COMDAT
; _this$ = ecx

; 709  :         // insert by perfectly forwarding into element at end, provide strong guarantee
; 710  :         auto& _My_data   = _Mypair._Myval2;
; 711  :         pointer& _Mylast = _My_data._Mylast;
; 712  :         _STL_INTERNAL_CHECK(_Mylast != _My_data._Myend); // check that we have unused capacity
; 713  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _<_Val_0>$[esp-4]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edx], eax

; 714  :         _Orphan_range(_Mylast, _Mylast);
; 715  :         _Ty& _Result = *_Mylast;
; 716  :         ++_Mylast;

	add	DWORD PTR [ecx+4], 4

; 717  : #if _HAS_CXX17
; 718  :         return _Result;
; 719  : #else // ^^^ _HAS_CXX17 ^^^ // vvv !_HAS_CXX17 vvv
; 720  :         (void) _Result;
; 721  : #endif // _HAS_CXX17
; 722  :     }

	ret	4
??$_Emplace_back_with_unused_capacity@ABQAVCPEDef@PS@@@?$vector@PAVCPEDef@PS@@V?$xalloc@PAVCPEDef@PS@@@@@std@@AAE?A_TABQAVCPEDef@PS@@@Z ENDP ; std::vector<PS::CPEDef *,xalloc<PS::CPEDef *> >::_Emplace_back_with_unused_capacity<PS::CPEDef * const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPGDef@PS@@@std@@@std@@@std@@QBEXABV12@@Z
_TEXT	SEGMENT
__Right$dead$ = 8					; size = 4
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPGDef@PS@@@std@@@std@@@std@@QBEXABV12@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<PS::CPGDef *> > >::_Compat, COMDAT
; _this$dead$ = ecx

; 182  :         // test for compatible iterator pair
; 183  : #if _ITERATOR_DEBUG_LEVEL == 0
; 184  :         (void) _Right;
; 185  : #else // ^^^ _ITERATOR_DEBUG_LEVEL == 0 ^^^ // vvv _ITERATOR_DEBUG_LEVEL != 0 vvv
; 186  :         _STL_VERIFY(this->_Getcont() == _Right._Getcont(), "vector iterators incompatible");
; 187  : #endif // _ITERATOR_DEBUG_LEVEL == 0
; 188  :     }

	ret	4
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPGDef@PS@@@std@@@std@@@std@@QBEXABV12@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<PS::CPGDef *> > >::_Compat
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPGDef@PS@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPGDef@PS@@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<PS::CPGDef *> > >::operator++, COMDAT
; _this$ = ecx

; 68   : #if _ITERATOR_DEBUG_LEVEL != 0
; 69   :         const auto _Mycont = static_cast<const _Myvec*>(this->_Getcont());
; 70   :         _STL_VERIFY(_Ptr, "can't increment value-initialized vector iterator");
; 71   :         _STL_VERIFY(_Ptr < _Mycont->_Mylast, "can't increment vector iterator past end");
; 72   : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 73   : 
; 74   :         ++_Ptr;

	add	DWORD PTR [ecx], 4

; 75   :         return *this;

	mov	eax, ecx

; 76   :     }

	ret	0
??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPGDef@PS@@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<PS::CPGDef *> > >::operator++
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPGDef@PS@@@std@@@std@@@std@@QBEABQAVCPGDef@PS@@XZ
_TEXT	SEGMENT
??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPGDef@PS@@@std@@@std@@@std@@QBEABQAVCPGDef@PS@@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<PS::CPGDef *> > >::operator*, COMDAT
; _this$ = ecx

; 46   : #if _ITERATOR_DEBUG_LEVEL != 0
; 47   :         const auto _Mycont = static_cast<const _Myvec*>(this->_Getcont());
; 48   :         _STL_VERIFY(_Ptr, "can't dereference value-initialized vector iterator");
; 49   :         _STL_VERIFY(
; 50   :             _Mycont->_Myfirst <= _Ptr && _Ptr < _Mycont->_Mylast, "can't dereference out of range vector iterator");
; 51   : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 52   : 
; 53   :         return *_Ptr;

	mov	eax, DWORD PTR [ecx]

; 54   :     }

	ret	0
??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPGDef@PS@@@std@@@std@@@std@@QBEABQAVCPGDef@PS@@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<PS::CPGDef *> > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPEDef@PS@@@std@@@std@@@std@@QBEXABV12@@Z
_TEXT	SEGMENT
__Right$dead$ = 8					; size = 4
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPEDef@PS@@@std@@@std@@@std@@QBEXABV12@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<PS::CPEDef *> > >::_Compat, COMDAT
; _this$dead$ = ecx

; 182  :         // test for compatible iterator pair
; 183  : #if _ITERATOR_DEBUG_LEVEL == 0
; 184  :         (void) _Right;
; 185  : #else // ^^^ _ITERATOR_DEBUG_LEVEL == 0 ^^^ // vvv _ITERATOR_DEBUG_LEVEL != 0 vvv
; 186  :         _STL_VERIFY(this->_Getcont() == _Right._Getcont(), "vector iterators incompatible");
; 187  : #endif // _ITERATOR_DEBUG_LEVEL == 0
; 188  :     }

	ret	4
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPEDef@PS@@@std@@@std@@@std@@QBEXABV12@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<PS::CPEDef *> > >::_Compat
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPEDef@PS@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPEDef@PS@@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<PS::CPEDef *> > >::operator++, COMDAT
; _this$ = ecx

; 68   : #if _ITERATOR_DEBUG_LEVEL != 0
; 69   :         const auto _Mycont = static_cast<const _Myvec*>(this->_Getcont());
; 70   :         _STL_VERIFY(_Ptr, "can't increment value-initialized vector iterator");
; 71   :         _STL_VERIFY(_Ptr < _Mycont->_Mylast, "can't increment vector iterator past end");
; 72   : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 73   : 
; 74   :         ++_Ptr;

	add	DWORD PTR [ecx], 4

; 75   :         return *this;

	mov	eax, ecx

; 76   :     }

	ret	0
??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPEDef@PS@@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<PS::CPEDef *> > >::operator++
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPEDef@PS@@@std@@@std@@@std@@QBEABQAVCPEDef@PS@@XZ
_TEXT	SEGMENT
??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPEDef@PS@@@std@@@std@@@std@@QBEABQAVCPEDef@PS@@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<PS::CPEDef *> > >::operator*, COMDAT
; _this$ = ecx

; 46   : #if _ITERATOR_DEBUG_LEVEL != 0
; 47   :         const auto _Mycont = static_cast<const _Myvec*>(this->_Getcont());
; 48   :         _STL_VERIFY(_Ptr, "can't dereference value-initialized vector iterator");
; 49   :         _STL_VERIFY(
; 50   :             _Mycont->_Myfirst <= _Ptr && _Ptr < _Mycont->_Mylast, "can't dereference out of range vector iterator");
; 51   : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 52   : 
; 53   :         return *_Ptr;

	mov	eax, DWORD PTR [ecx]

; 54   :     }

	ret	0
??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPEDef@PS@@@std@@@std@@@std@@QBEABQAVCPEDef@PS@@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<PS::CPEDef *> > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?clear_and_free@?$xr_vector@PAVCPGDef@PS@@V?$xalloc@PAVCPGDef@PS@@@@@@QAEXXZ
_TEXT	SEGMENT
?clear_and_free@?$xr_vector@PAVCPGDef@PS@@V?$xalloc@PAVCPGDef@PS@@@@@@QAEXXZ PROC ; xr_vector<PS::CPGDef *,xalloc<PS::CPGDef *> >::clear_and_free, COMDAT
; _this$ = ecx

; 127  : 	void	clear_and_free		()									{ inherited::clear();			}

	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [ecx+4], eax
	ret	0
?clear_and_free@?$xr_vector@PAVCPGDef@PS@@V?$xalloc@PAVCPGDef@PS@@@@@@QAEXXZ ENDP ; xr_vector<PS::CPGDef *,xalloc<PS::CPGDef *> >::clear_and_free
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Orphan_range@?$vector@PAVCPGDef@PS@@V?$xalloc@PAVCPGDef@PS@@@@@std@@ABEXPAPAVCPGDef@PS@@0@Z
_TEXT	SEGMENT
___formal$dead$ = 8					; size = 4
___formal$dead$ = 12					; size = 4
?_Orphan_range@?$vector@PAVCPGDef@PS@@V?$xalloc@PAVCPGDef@PS@@@@@std@@ABEXPAPAVCPGDef@PS@@0@Z PROC ; std::vector<PS::CPGDef *,xalloc<PS::CPGDef *> >::_Orphan_range, COMDAT
; _this$dead$ = ecx

; 1801 :     _CONSTEXPR20_CONTAINER void _Orphan_range(pointer, pointer) const {}

	ret	8
?_Orphan_range@?$vector@PAVCPGDef@PS@@V?$xalloc@PAVCPGDef@PS@@@@@std@@ABEXPAPAVCPGDef@PS@@0@Z ENDP ; std::vector<PS::CPGDef *,xalloc<PS::CPGDef *> >::_Orphan_range
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?clear_and_free@?$xr_vector@PAVCPEDef@PS@@V?$xalloc@PAVCPEDef@PS@@@@@@QAEXXZ
_TEXT	SEGMENT
?clear_and_free@?$xr_vector@PAVCPEDef@PS@@V?$xalloc@PAVCPEDef@PS@@@@@@QAEXXZ PROC ; xr_vector<PS::CPEDef *,xalloc<PS::CPEDef *> >::clear_and_free, COMDAT
; _this$ = ecx

; 127  : 	void	clear_and_free		()									{ inherited::clear();			}

	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [ecx+4], eax
	ret	0
?clear_and_free@?$xr_vector@PAVCPEDef@PS@@V?$xalloc@PAVCPEDef@PS@@@@@@QAEXXZ ENDP ; xr_vector<PS::CPEDef *,xalloc<PS::CPEDef *> >::clear_and_free
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Orphan_range@?$vector@PAVCPEDef@PS@@V?$xalloc@PAVCPEDef@PS@@@@@std@@ABEXPAPAVCPEDef@PS@@0@Z
_TEXT	SEGMENT
___formal$dead$ = 8					; size = 4
___formal$dead$ = 12					; size = 4
?_Orphan_range@?$vector@PAVCPEDef@PS@@V?$xalloc@PAVCPEDef@PS@@@@@std@@ABEXPAPAVCPEDef@PS@@0@Z PROC ; std::vector<PS::CPEDef *,xalloc<PS::CPEDef *> >::_Orphan_range, COMDAT
; _this$dead$ = ecx

; 1801 :     _CONSTEXPR20_CONTAINER void _Orphan_range(pointer, pointer) const {}

	ret	8
?_Orphan_range@?$vector@PAVCPEDef@PS@@V?$xalloc@PAVCPEDef@PS@@@@@std@@ABEXPAPAVCPEDef@PS@@0@Z ENDP ; std::vector<PS::CPEDef *,xalloc<PS::CPEDef *> >::_Orphan_range
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?clear@?$vector@PAVCPGDef@PS@@V?$xalloc@PAVCPGDef@PS@@@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$vector@PAVCPGDef@PS@@V?$xalloc@PAVCPGDef@PS@@@@@std@@QAEXXZ PROC ; std::vector<PS::CPGDef *,xalloc<PS::CPGDef *> >::clear, COMDAT
; _this$ = ecx

; 1437 :         auto& _My_data    = _Mypair._Myval2;
; 1438 :         pointer& _Myfirst = _My_data._Myfirst;
; 1439 :         pointer& _Mylast  = _My_data._Mylast;
; 1440 : 
; 1441 :         _My_data._Orphan_all();
; 1442 :         _Destroy(_Myfirst, _Mylast);
; 1443 :         _Mylast = _Myfirst;

	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [ecx+4], eax

; 1444 :     }

	ret	0
?clear@?$vector@PAVCPGDef@PS@@V?$xalloc@PAVCPGDef@PS@@@@@std@@QAEXXZ ENDP ; std::vector<PS::CPGDef *,xalloc<PS::CPGDef *> >::clear
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?clear@?$vector@PAVCPEDef@PS@@V?$xalloc@PAVCPEDef@PS@@@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$vector@PAVCPEDef@PS@@V?$xalloc@PAVCPEDef@PS@@@@@std@@QAEXXZ PROC ; std::vector<PS::CPEDef *,xalloc<PS::CPEDef *> >::clear, COMDAT
; _this$ = ecx

; 1437 :         auto& _My_data    = _Mypair._Myval2;
; 1438 :         pointer& _Myfirst = _My_data._Myfirst;
; 1439 :         pointer& _Mylast  = _My_data._Mylast;
; 1440 : 
; 1441 :         _My_data._Orphan_all();
; 1442 :         _Destroy(_Myfirst, _Mylast);
; 1443 :         _Mylast = _Myfirst;

	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [ecx+4], eax

; 1444 :     }

	ret	0
?clear@?$vector@PAVCPEDef@PS@@V?$xalloc@PAVCPEDef@PS@@@@@std@@QAEXXZ ENDP ; std::vector<PS::CPEDef *,xalloc<PS::CPEDef *> >::clear
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleEffectDef.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xrstring.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
;	COMDAT ??$xr_delete@VCPEDef@PS@@@@YAXAAPAVCPEDef@PS@@@Z
_TEXT	SEGMENT
??$xr_delete@VCPEDef@PS@@@@YAXAAPAVCPEDef@PS@@@Z PROC	; xr_delete<PS::CPEDef>, COMDAT
; _ptr$ = ecx

; 150  : {

	push	esi
	push	edi
	mov	edi, ecx

; 151  : 	if (ptr) 

	mov	esi, DWORD PTR [edi]
	test	esi, esi
	je	SHORT $LN2@xr_delete
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleEffectDef.cpp

; 39   : }

	lea	ecx, DWORD PTR [esi+48]
	call	DWORD PTR __imp_??1CMemoryWriter@@UAE@XZ
	lea	ecx, DWORD PTR [esi+16]
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 64   : 						~resptr_core	()												{	_dec();						}

	call	DWORD PTR __imp_?_dec@?$resptr_base@UShader@@@@IAEXXZ
; File I:\Vitalya\mine\NSProjectX\xrCore\xrstring.h

; 50   : 	void				_dec		()								{	if (0==p_) return;	p_->dwReference--; 	if (0==p_->dwReference)	p_=0;						}

	mov	eax, DWORD PTR [esi+12]
	test	eax, eax
	je	SHORT $LN17@xr_delete
	dec	DWORD PTR [eax]
	mov	eax, DWORD PTR [esi+12]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN17@xr_delete
	mov	DWORD PTR [esi+12], 0
$LN17@xr_delete:
	mov	eax, DWORD PTR [esi+8]
	test	eax, eax
	je	SHORT $LN23@xr_delete
	dec	DWORD PTR [eax]
	mov	eax, DWORD PTR [esi+8]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN23@xr_delete
	mov	DWORD PTR [esi+8], 0
$LN23@xr_delete:
	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN29@xr_delete
	dec	DWORD PTR [eax]
	mov	eax, DWORD PTR [esi]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN29@xr_delete
	mov	DWORD PTR [esi], 0
$LN29@xr_delete:
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h

; 144  : 		Memory.mem_free	(ptr);

	push	DWORD PTR [edi]
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z

; 152  : 	{
; 153  : 		xr_special_free<is_polymorphic<T>::result,T>()(ptr);
; 154  : 		ptr = nullptr;

	mov	DWORD PTR [edi], 0
$LN2@xr_delete:

; 155  : 	}
; 156  : }

	pop	edi
	pop	esi
	ret	0
??$xr_delete@VCPEDef@PS@@@@YAXAAPAVCPEDef@PS@@@Z ENDP	; xr_delete<PS::CPEDef>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xrstring.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrstring.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
;	COMDAT ??$xr_delete@VCPGDef@PS@@@@YAXAAPAVCPGDef@PS@@@Z
_TEXT	SEGMENT
??$xr_delete@VCPGDef@PS@@@@YAXAAPAVCPGDef@PS@@@Z PROC	; xr_delete<PS::CPGDef>, COMDAT
; _ptr$ = ecx

; 150  : {

	push	ebp
	mov	ebp, ecx
	push	edi

; 151  : 	if (ptr) 

	mov	edi, DWORD PTR [ebp]
	test	edi, edi
	je	$LN2@xr_delete
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	push	ebx
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp

; 20   :     for (EffectIt it=m_Effects.begin(); it!=m_Effects.end(); it++)

	mov	ebx, DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	push	esi
	mov	esi, DWORD PTR [edi+12]

; 150  :         return _Ptr == _Right._Ptr;

	cmp	esi, DWORD PTR [edi+16]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp

; 20   :     for (EffectIt it=m_Effects.begin(); it!=m_Effects.end(); it++)

	je	$LN11@xr_delete
$LL12@xr_delete:
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h

; 151  : 	if (ptr) 

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN10@xr_delete
; File I:\Vitalya\mine\NSProjectX\xrCore\xrstring.h

; 50   : 	void				_dec		()								{	if (0==p_) return;	p_->dwReference--; 	if (0==p_->dwReference)	p_=0;						}

	mov	ecx, DWORD PTR [eax+16]
	test	ecx, ecx
	je	SHORT $LN48@xr_delete
	dec	DWORD PTR [ecx]
	mov	ecx, DWORD PTR [eax+16]
	cmp	DWORD PTR [ecx], 0
	jne	SHORT $LN48@xr_delete
	mov	DWORD PTR [eax+16], 0
$LN48@xr_delete:
	mov	ecx, DWORD PTR [eax+12]
	test	ecx, ecx
	je	SHORT $LN54@xr_delete
	dec	DWORD PTR [ecx]
	mov	ecx, DWORD PTR [eax+12]
	cmp	DWORD PTR [ecx], 0
	jne	SHORT $LN54@xr_delete
	mov	DWORD PTR [eax+12], 0
$LN54@xr_delete:
	mov	ecx, DWORD PTR [eax+8]
	test	ecx, ecx
	je	SHORT $LN60@xr_delete
	dec	DWORD PTR [ecx]
	mov	ecx, DWORD PTR [eax+8]
	cmp	DWORD PTR [ecx], 0
	jne	SHORT $LN60@xr_delete
	mov	DWORD PTR [eax+8], 0
$LN60@xr_delete:
	mov	ecx, DWORD PTR [eax+4]
	test	ecx, ecx
	je	SHORT $LN66@xr_delete
	dec	DWORD PTR [ecx]
	mov	ecx, DWORD PTR [eax+4]
	cmp	DWORD PTR [ecx], 0
	jne	SHORT $LN66@xr_delete
	mov	DWORD PTR [eax+4], 0
$LN66@xr_delete:
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h

; 144  : 		Memory.mem_free	(ptr);

	push	DWORD PTR [esi]
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	ebx

; 154  : 		ptr = nullptr;

	mov	DWORD PTR [esi], 0
$LN10@xr_delete:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 74   :         ++_Ptr;

	add	esi, 4

; 150  :         return _Ptr == _Right._Ptr;

	cmp	esi, DWORD PTR [edi+16]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp

; 20   :     for (EffectIt it=m_Effects.begin(); it!=m_Effects.end(); it++)

	jne	SHORT $LL12@xr_delete
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h

; 154  : 		ptr = nullptr;

	mov	esi, DWORD PTR [edi+12]
$LN11@xr_delete:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp

; 22   :     m_Effects.clear	();

	mov	DWORD PTR [edi+16], esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	test	esi, esi
	je	SHORT $LN73@xr_delete
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	esi
	call	ebx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [edi+12], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [edi+16], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [edi+20], 0
$LN73@xr_delete:
; File I:\Vitalya\mine\NSProjectX\xrCore\xrstring.h

; 50   : 	void				_dec		()								{	if (0==p_) return;	p_->dwReference--; 	if (0==p_->dwReference)	p_=0;						}

	mov	eax, DWORD PTR [edi]
	test	eax, eax
	je	SHORT $LN84@xr_delete
	dec	DWORD PTR [eax]
	mov	eax, DWORD PTR [edi]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN84@xr_delete
	mov	DWORD PTR [edi], 0
$LN84@xr_delete:
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h

; 144  : 		Memory.mem_free	(ptr);

	push	DWORD PTR [ebp]
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	ebx

; 154  : 		ptr = nullptr;

	pop	esi
	mov	DWORD PTR [ebp], 0
	pop	ebx
$LN2@xr_delete:

; 155  : 	}
; 156  : }

	pop	edi
	pop	ebp
	ret	0
??$xr_delete@VCPGDef@PS@@@@YAXAAPAVCPGDef@PS@@@Z ENDP	; xr_delete<PS::CPGDef>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
; File I:\Vitalya\mine\NSProjectX\xrCore\_std_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleEffectDef.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
; File I:\Vitalya\mine\NSProjectX\xrCore\xrstring.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_std_extensions.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\PSLibrary.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$lower_bound@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPEDef@PS@@@std@@@std@@@std@@PBDP6A_NPBVCPEDef@PS@@PBD@Z@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPEDef@PS@@@std@@@std@@@0@V10@V10@ABQBDP6A_NPBVCPEDef@PS@@PBD@Z@Z
_TEXT	SEGMENT
tv176 = -8						; size = 4
___$ReturnUdt$1$ = -4					; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Pred$dead$ = 16					; size = 4
??$lower_bound@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPEDef@PS@@@std@@@std@@@std@@PBDP6A_NPBVCPEDef@PS@@PBD@Z@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPEDef@PS@@@std@@@std@@@0@V10@V10@ABQBDP6A_NPBVCPEDef@PS@@PBD@Z@Z PROC ; std::lower_bound<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<PS::CPEDef *> > >,char const *,bool (__cdecl*)(PS::CPEDef const *,char const *)>, COMDAT
; ___$ReturnUdt$ = ecx
; __Val$ = edx

; 5807 : _NODISCARD _CONSTEXPR20 _FwdIt lower_bound(_FwdIt _First, const _FwdIt _Last, const _Ty& _Val, _Pr _Pred) {

	sub	esp, 8
	push	ebx

; 5808 :     // find first element not before _Val
; 5809 :     _Adl_verify_range(_First, _Last);
; 5810 :     auto _UFirst                = _Get_unwrapped(_First);

	mov	ebx, DWORD PTR __First$[esp+8]
	mov	eax, ecx
	push	esi

; 1525 :         return _Last - _First; // assume the iterator will do debug checking

	mov	esi, DWORD PTR __Last$[esp+12]
	sub	esi, ebx

; 5807 : _NODISCARD _CONSTEXPR20 _FwdIt lower_bound(_FwdIt _First, const _FwdIt _Last, const _Ty& _Val, _Pr _Pred) {

	mov	DWORD PTR ___$ReturnUdt$1$[esp+16], eax

; 1525 :         return _Last - _First; // assume the iterator will do debug checking

	sar	esi, 2

; 5811 :     _Iter_diff_t<_FwdIt> _Count = _STD distance(_UFirst, _Get_unwrapped(_Last));
; 5812 : 
; 5813 :     while (0 < _Count) { // divide and conquer, find half that contains answer

	test	esi, esi
	jle	SHORT $LN30@lower_boun

; 5816 :         if (_Pred(*_UMid, _Val)) { // try top half

	mov	ecx, DWORD PTR [edx]
	push	ebp
	mov	DWORD PTR tv176[esp+20], ecx
	push	edi
$LL2@lower_boun:

; 5814 :         const _Iter_diff_t<_FwdIt> _Count2 = _Count / 2;

	mov	edi, esi
; File I:\Vitalya\mine\NSProjectX\xrCore\_std_extensions.h

; 183  : {	return (int)strcmp(S1,S2);  }

	mov	edx, ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility

; 5814 :         const _Iter_diff_t<_FwdIt> _Count2 = _Count / 2;

	shr	edi, 1
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleEffectDef.h

; 108  :         IC LPCSTR			Name				()const{return *m_Name;}

	mov	eax, DWORD PTR [ebx+edi*4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility

; 1497 :         _Where += _Off;

	lea	ebp, DWORD PTR [ebx+edi*4]
; File I:\Vitalya\mine\NSProjectX\xrCore\xrstring.h

; 65   : 	str_c				operator*	() const						{	return p_?p_->value:0;							}

	mov	eax, DWORD PTR [eax]
; File I:\Vitalya\mine\NSProjectX\xrCore\_std_extensions.h

; 183  : {	return (int)strcmp(S1,S2);  }

	lea	ecx, DWORD PTR [eax+12]
	neg	eax
	sbb	eax, eax
	and	eax, ecx
	npad	5
$LL26@lower_boun:
	mov	cl, BYTE PTR [eax]
	cmp	cl, BYTE PTR [edx]
	jne	SHORT $LN27@lower_boun
	test	cl, cl
	je	SHORT $LN28@lower_boun
	mov	cl, BYTE PTR [eax+1]
	cmp	cl, BYTE PTR [edx+1]
	jne	SHORT $LN27@lower_boun
	add	eax, 2
	add	edx, 2
	test	cl, cl
	jne	SHORT $LL26@lower_boun
$LN28@lower_boun:
	xor	eax, eax
	jmp	SHORT $LN29@lower_boun
$LN27@lower_boun:
	sbb	eax, eax
	or	eax, 1
$LN29@lower_boun:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\PSLibrary.cpp

; 15   : bool ped_find_pred	(const PS::CPEDef* a, 	LPCSTR b)				{	return xr_strcmp(a->Name(),b)<0;}

	test	eax, eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility

; 5816 :         if (_Pred(*_UMid, _Val)) { // try top half

	jns	SHORT $LN4@lower_boun

; 5817 :             _UFirst = _Next_iter(_UMid);
; 5818 :             _Count -= _Count2 + 1;

	or	eax, -1
	lea	ebx, DWORD PTR [ebp+4]
	sub	eax, edi
	add	esi, eax

; 5819 :         } else {

	jmp	SHORT $LN5@lower_boun
$LN4@lower_boun:

; 5820 :             _Count = _Count2;

	mov	esi, edi
$LN5@lower_boun:

; 5811 :     _Iter_diff_t<_FwdIt> _Count = _STD distance(_UFirst, _Get_unwrapped(_Last));
; 5812 : 
; 5813 :     while (0 < _Count) { // divide and conquer, find half that contains answer

	mov	ecx, DWORD PTR tv176[esp+24]
	test	esi, esi
	jg	SHORT $LL2@lower_boun

; 5821 :         }
; 5822 :     }
; 5823 : 
; 5824 :     _Seek_wrapped(_First, _UFirst);
; 5825 :     return _First;

	mov	eax, DWORD PTR ___$ReturnUdt$1$[esp+24]
	pop	edi
	pop	ebp
$LN30@lower_boun:

; 5826 : }

	pop	esi
	mov	DWORD PTR [eax], ebx
	pop	ebx
	add	esp, 8
	ret	0
??$lower_bound@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPEDef@PS@@@std@@@std@@@std@@PBDP6A_NPBVCPEDef@PS@@PBD@Z@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPEDef@PS@@@std@@@std@@@0@V10@V10@ABQBDP6A_NPBVCPEDef@PS@@PBD@Z@Z ENDP ; std::lower_bound<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<PS::CPEDef *> > >,char const *,bool (__cdecl*)(PS::CPEDef const *,char const *)>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_Get_unwrapped@AAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPEDef@PS@@@std@@@std@@@std@@@std@@YA?A_TAAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPEDef@PS@@@std@@@std@@@0@@Z
_TEXT	SEGMENT
??$_Get_unwrapped@AAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPEDef@PS@@@std@@@std@@@std@@@std@@YA?A_TAAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPEDef@PS@@@std@@@std@@@0@@Z PROC ; std::_Get_unwrapped<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<PS::CPEDef *> > > &>, COMDAT
; __It$ = ecx

; 1275 :     // unwrap an iterator previously subjected to _Adl_verify_range or otherwise validated
; 1276 :     if constexpr (is_pointer_v<decay_t<_Iter>>) { // special-case pointers and arrays
; 1277 :         return _It + 0;
; 1278 :     } else if constexpr (_Unwrappable_v<_Iter>) {
; 1279 :         return static_cast<_Iter&&>(_It)._Unwrapped();

	mov	eax, DWORD PTR [ecx]

; 1280 :     } else {
; 1281 :         return static_cast<_Iter&&>(_It);
; 1282 :     }
; 1283 : }

	ret	0
??$_Get_unwrapped@AAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPEDef@PS@@@std@@@std@@@std@@@std@@YA?A_TAAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPEDef@PS@@@std@@@std@@@0@@Z ENDP ; std::_Get_unwrapped<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<PS::CPEDef *> > > &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_Get_unwrapped@ABV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPEDef@PS@@@std@@@std@@@std@@@std@@YA?A_TABV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPEDef@PS@@@std@@@std@@@0@@Z
_TEXT	SEGMENT
??$_Get_unwrapped@ABV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPEDef@PS@@@std@@@std@@@std@@@std@@YA?A_TABV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPEDef@PS@@@std@@@std@@@0@@Z PROC ; std::_Get_unwrapped<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<PS::CPEDef *> > > const &>, COMDAT
; __It$ = ecx

; 1275 :     // unwrap an iterator previously subjected to _Adl_verify_range or otherwise validated
; 1276 :     if constexpr (is_pointer_v<decay_t<_Iter>>) { // special-case pointers and arrays
; 1277 :         return _It + 0;
; 1278 :     } else if constexpr (_Unwrappable_v<_Iter>) {
; 1279 :         return static_cast<_Iter&&>(_It)._Unwrapped();

	mov	eax, DWORD PTR [ecx]

; 1280 :     } else {
; 1281 :         return static_cast<_Iter&&>(_It);
; 1282 :     }
; 1283 : }

	ret	0
??$_Get_unwrapped@ABV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPEDef@PS@@@std@@@std@@@std@@@std@@YA?A_TABV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPEDef@PS@@@std@@@std@@@0@@Z ENDP ; std::_Get_unwrapped<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<PS::CPEDef *> > > const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
; File I:\Vitalya\mine\NSProjectX\xrCore\_std_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\PSLibrary.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
; File I:\Vitalya\mine\NSProjectX\xrCore\xrstring.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_std_extensions.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\PSLibrary.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$lower_bound@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPGDef@PS@@@std@@@std@@@std@@PBDP6A_NPBVCPGDef@PS@@PBD@Z@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPGDef@PS@@@std@@@std@@@0@V10@V10@ABQBDP6A_NPBVCPGDef@PS@@PBD@Z@Z
_TEXT	SEGMENT
tv176 = -8						; size = 4
___$ReturnUdt$1$ = -4					; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Pred$dead$ = 16					; size = 4
??$lower_bound@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPGDef@PS@@@std@@@std@@@std@@PBDP6A_NPBVCPGDef@PS@@PBD@Z@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPGDef@PS@@@std@@@std@@@0@V10@V10@ABQBDP6A_NPBVCPGDef@PS@@PBD@Z@Z PROC ; std::lower_bound<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<PS::CPGDef *> > >,char const *,bool (__cdecl*)(PS::CPGDef const *,char const *)>, COMDAT
; ___$ReturnUdt$ = ecx
; __Val$ = edx

; 5807 : _NODISCARD _CONSTEXPR20 _FwdIt lower_bound(_FwdIt _First, const _FwdIt _Last, const _Ty& _Val, _Pr _Pred) {

	sub	esp, 8
	push	ebx

; 5808 :     // find first element not before _Val
; 5809 :     _Adl_verify_range(_First, _Last);
; 5810 :     auto _UFirst                = _Get_unwrapped(_First);

	mov	ebx, DWORD PTR __First$[esp+8]
	mov	eax, ecx
	push	esi

; 1525 :         return _Last - _First; // assume the iterator will do debug checking

	mov	esi, DWORD PTR __Last$[esp+12]
	sub	esi, ebx

; 5807 : _NODISCARD _CONSTEXPR20 _FwdIt lower_bound(_FwdIt _First, const _FwdIt _Last, const _Ty& _Val, _Pr _Pred) {

	mov	DWORD PTR ___$ReturnUdt$1$[esp+16], eax

; 1525 :         return _Last - _First; // assume the iterator will do debug checking

	sar	esi, 2

; 5811 :     _Iter_diff_t<_FwdIt> _Count = _STD distance(_UFirst, _Get_unwrapped(_Last));
; 5812 : 
; 5813 :     while (0 < _Count) { // divide and conquer, find half that contains answer

	test	esi, esi
	jle	SHORT $LN30@lower_boun

; 5816 :         if (_Pred(*_UMid, _Val)) { // try top half

	mov	ecx, DWORD PTR [edx]
	push	ebp
	mov	DWORD PTR tv176[esp+20], ecx
	push	edi
$LL2@lower_boun:

; 5814 :         const _Iter_diff_t<_FwdIt> _Count2 = _Count / 2;

	mov	edi, esi
; File I:\Vitalya\mine\NSProjectX\xrCore\_std_extensions.h

; 183  : {	return (int)strcmp(S1,S2);  }

	mov	edx, ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility

; 5814 :         const _Iter_diff_t<_FwdIt> _Count2 = _Count / 2;

	shr	edi, 1
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\PSLibrary.cpp

; 16   : bool pgd_find_pred	(const PS::CPGDef* a, 	LPCSTR b)				{	return xr_strcmp(a->m_Name,b)<0;}

	mov	eax, DWORD PTR [ebx+edi*4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility

; 1497 :         _Where += _Off;

	lea	ebp, DWORD PTR [ebx+edi*4]
; File I:\Vitalya\mine\NSProjectX\xrCore\xrstring.h

; 65   : 	str_c				operator*	() const						{	return p_?p_->value:0;							}

	mov	eax, DWORD PTR [eax]
; File I:\Vitalya\mine\NSProjectX\xrCore\_std_extensions.h

; 183  : {	return (int)strcmp(S1,S2);  }

	lea	ecx, DWORD PTR [eax+12]
	neg	eax
	sbb	eax, eax
	and	eax, ecx
	npad	5
$LL26@lower_boun:
	mov	cl, BYTE PTR [eax]
	cmp	cl, BYTE PTR [edx]
	jne	SHORT $LN27@lower_boun
	test	cl, cl
	je	SHORT $LN28@lower_boun
	mov	cl, BYTE PTR [eax+1]
	cmp	cl, BYTE PTR [edx+1]
	jne	SHORT $LN27@lower_boun
	add	eax, 2
	add	edx, 2
	test	cl, cl
	jne	SHORT $LL26@lower_boun
$LN28@lower_boun:
	xor	eax, eax
	jmp	SHORT $LN29@lower_boun
$LN27@lower_boun:
	sbb	eax, eax
	or	eax, 1
$LN29@lower_boun:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\PSLibrary.cpp

; 16   : bool pgd_find_pred	(const PS::CPGDef* a, 	LPCSTR b)				{	return xr_strcmp(a->m_Name,b)<0;}

	test	eax, eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility

; 5816 :         if (_Pred(*_UMid, _Val)) { // try top half

	jns	SHORT $LN4@lower_boun

; 5817 :             _UFirst = _Next_iter(_UMid);
; 5818 :             _Count -= _Count2 + 1;

	or	eax, -1
	lea	ebx, DWORD PTR [ebp+4]
	sub	eax, edi
	add	esi, eax

; 5819 :         } else {

	jmp	SHORT $LN5@lower_boun
$LN4@lower_boun:

; 5820 :             _Count = _Count2;

	mov	esi, edi
$LN5@lower_boun:

; 5811 :     _Iter_diff_t<_FwdIt> _Count = _STD distance(_UFirst, _Get_unwrapped(_Last));
; 5812 : 
; 5813 :     while (0 < _Count) { // divide and conquer, find half that contains answer

	mov	ecx, DWORD PTR tv176[esp+24]
	test	esi, esi
	jg	SHORT $LL2@lower_boun

; 5821 :         }
; 5822 :     }
; 5823 : 
; 5824 :     _Seek_wrapped(_First, _UFirst);
; 5825 :     return _First;

	mov	eax, DWORD PTR ___$ReturnUdt$1$[esp+24]
	pop	edi
	pop	ebp
$LN30@lower_boun:

; 5826 : }

	pop	esi
	mov	DWORD PTR [eax], ebx
	pop	ebx
	add	esp, 8
	ret	0
??$lower_bound@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPGDef@PS@@@std@@@std@@@std@@PBDP6A_NPBVCPGDef@PS@@PBD@Z@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPGDef@PS@@@std@@@std@@@0@V10@V10@ABQBDP6A_NPBVCPGDef@PS@@PBD@Z@Z ENDP ; std::lower_bound<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<PS::CPGDef *> > >,char const *,bool (__cdecl*)(PS::CPGDef const *,char const *)>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_Get_unwrapped@AAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPGDef@PS@@@std@@@std@@@std@@@std@@YA?A_TAAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPGDef@PS@@@std@@@std@@@0@@Z
_TEXT	SEGMENT
??$_Get_unwrapped@AAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPGDef@PS@@@std@@@std@@@std@@@std@@YA?A_TAAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPGDef@PS@@@std@@@std@@@0@@Z PROC ; std::_Get_unwrapped<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<PS::CPGDef *> > > &>, COMDAT
; __It$ = ecx

; 1275 :     // unwrap an iterator previously subjected to _Adl_verify_range or otherwise validated
; 1276 :     if constexpr (is_pointer_v<decay_t<_Iter>>) { // special-case pointers and arrays
; 1277 :         return _It + 0;
; 1278 :     } else if constexpr (_Unwrappable_v<_Iter>) {
; 1279 :         return static_cast<_Iter&&>(_It)._Unwrapped();

	mov	eax, DWORD PTR [ecx]

; 1280 :     } else {
; 1281 :         return static_cast<_Iter&&>(_It);
; 1282 :     }
; 1283 : }

	ret	0
??$_Get_unwrapped@AAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPGDef@PS@@@std@@@std@@@std@@@std@@YA?A_TAAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPGDef@PS@@@std@@@std@@@0@@Z ENDP ; std::_Get_unwrapped<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<PS::CPGDef *> > > &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_Get_unwrapped@ABV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPGDef@PS@@@std@@@std@@@std@@@std@@YA?A_TABV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPGDef@PS@@@std@@@std@@@0@@Z
_TEXT	SEGMENT
??$_Get_unwrapped@ABV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPGDef@PS@@@std@@@std@@@std@@@std@@YA?A_TABV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPGDef@PS@@@std@@@std@@@0@@Z PROC ; std::_Get_unwrapped<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<PS::CPGDef *> > > const &>, COMDAT
; __It$ = ecx

; 1275 :     // unwrap an iterator previously subjected to _Adl_verify_range or otherwise validated
; 1276 :     if constexpr (is_pointer_v<decay_t<_Iter>>) { // special-case pointers and arrays
; 1277 :         return _It + 0;
; 1278 :     } else if constexpr (_Unwrappable_v<_Iter>) {
; 1279 :         return static_cast<_Iter&&>(_It)._Unwrapped();

	mov	eax, DWORD PTR [ecx]

; 1280 :     } else {
; 1281 :         return static_cast<_Iter&&>(_It);
; 1282 :     }
; 1283 : }

	ret	0
??$_Get_unwrapped@ABV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPGDef@PS@@@std@@@std@@@std@@@std@@YA?A_TABV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPGDef@PS@@@std@@@std@@@0@@Z ENDP ; std::_Get_unwrapped<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<PS::CPGDef *> > > const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleEffectDef.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xrstring.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleEffectDef.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector2.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleEffectDef.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleEffectDef.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleEffectDef.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleEffectDef.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_flags.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
;	COMDAT ??$xr_new@VCPEDef@PS@@@@YAPAVCPEDef@PS@@XZ
_TEXT	SEGMENT
$T1 = -4						; size = 4
??$xr_new@VCPEDef@PS@@@@YAPAVCPEDef@PS@@XZ PROC		; xr_new<PS::CPEDef>, COMDAT

; 67   : {

	push	ecx

; 68   : 	T* ptr	= (T*)Memory.mem_alloc(sizeof(T));

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	esi
	push	edi
	push	128					; 00000080H
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z

; 69   : 	return new (ptr) T();

	mov	edi, eax
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleEffectDef.cpp

; 17   : {                                          

	lea	ecx, DWORD PTR [edi+48]
; File I:\Vitalya\mine\NSProjectX\xrCore\xrstring.h

; 57   : 						shared_str	()								{	p_ = 0;											}

	mov	DWORD PTR [edi], 0
	mov	DWORD PTR [edi+8], 0
	mov	DWORD PTR [edi+12], 0
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 61   : 						resptr_core		()												{	p_ = 0;						}

	mov	DWORD PTR [edi+16], 0
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleEffectDef.cpp

; 17   : {                                          

	call	DWORD PTR __imp_??0CMemoryWriter@@QAE@XZ
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 46   : 	ICF		void		_set	(T * rhs) 							{	if (0!=rhs) rhs->dwReference++;	_dec(); p_ = rhs;											}

	lea	ecx, DWORD PTR [edi+16]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector2.h

; 15   : 	IC SelfRef set(float _u, float _v)				{ x=T(_u); y=T(_v);				return *this;	}

	mov	DWORD PTR [edi+20], 1040187392		; 3e000000H
	mov	DWORD PTR [edi+24], 1056964608		; 3f000000H
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleEffectDef.h

; 42   : 			m_iFrameDimX 	= 8;

	mov	DWORD PTR [edi+36], 8

; 43   : 			m_iFrameCount 	= 16;

	mov	DWORD PTR [edi+40], 16			; 00000010H

; 44   : 			m_fSpeed		= 24.f;

	mov	DWORD PTR [edi+44], 1103101952		; 41c00000H
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleEffectDef.cpp

; 19   :     m_MaxParticles		= 0;

	mov	DWORD PTR [edi+88], 0
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 62   : 						resptr_core		(T * p, bool add_ref = true) 					{	p_ = p;	if(add_ref)	_inc(); }

	mov	DWORD PTR $T1[esp+12], 0

; 46   : 	ICF		void		_set	(T * rhs) 							{	if (0!=rhs) rhs->dwReference++;	_dec(); p_ = rhs;											}

	call	DWORD PTR __imp_?_dec@?$resptr_base@UShader@@@@IAEXXZ

; 64   : 						~resptr_core	()												{	_dec();						}

	lea	ecx, DWORD PTR $T1[esp+12]

; 46   : 	ICF		void		_set	(T * rhs) 							{	if (0!=rhs) rhs->dwReference++;	_dec(); p_ = rhs;											}

	mov	DWORD PTR [edi+16], 0

; 64   : 						~resptr_core	()												{	_dec();						}

	call	DWORD PTR __imp_?_dec@?$resptr_base@UShader@@@@IAEXXZ
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleEffectDef.cpp

; 21   : 	m_fTimeLimit		= 0.f;

	mov	DWORD PTR [edi+84], 0
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h

; 69   : 	return new (ptr) T();

	mov	eax, edi
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleEffectDef.cpp

; 23   :     m_fCollideOneMinusFriction 	= 1.f;

	mov	DWORD PTR [edi+116], 1065353216		; 3f800000H

; 24   :     m_fCollideResilience		= 0.f;

	mov	DWORD PTR [edi+120], 0

; 25   :     m_fCollideSqrCutoff			= 0.f;

	mov	DWORD PTR [edi+124], 0
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 23   : 	ICF	SelfRef	set(T _x, T _y, T _z)					{ x = _x;		y = _y;		z = _z;		return *this;	};

	mov	DWORD PTR [edi+92], 0
	mov	DWORD PTR [edi+96], 0
	mov	DWORD PTR [edi+100], 0
	mov	DWORD PTR [edi+104], -1077342245	; bfc90fdbH
	mov	DWORD PTR [edi+108], 0
	mov	DWORD PTR [edi+112], 0
; File I:\Vitalya\mine\NSProjectX\xrCore\_flags.h

; 15   :     IC	SelfRef	zero	()											{ flags=T(0);	return *this;	}

	mov	DWORD PTR [edi+4], 0
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h

; 69   : 	return new (ptr) T();

	pop	edi
	pop	esi

; 70   : }

	pop	ecx
	ret	0
??$xr_new@VCPEDef@PS@@@@YAPAVCPEDef@PS@@XZ ENDP		; xr_new<PS::CPEDef>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xrstring.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_flags.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
;	COMDAT ??$xr_new@VCPGDef@PS@@@@YAPAVCPGDef@PS@@XZ
_TEXT	SEGMENT
??$xr_new@VCPGDef@PS@@@@YAPAVCPGDef@PS@@XZ PROC		; xr_new<PS::CPGDef>, COMDAT

; 68   : 	T* ptr	= (T*)Memory.mem_alloc(sizeof(T));

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	24					; 00000018H
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
; File I:\Vitalya\mine\NSProjectX\xrCore\xrstring.h

; 57   : 						shared_str	()								{	p_ = 0;											}

	mov	DWORD PTR [eax], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [eax+12], 0
	mov	DWORD PTR [eax+16], 0
	mov	DWORD PTR [eax+20], 0
; File I:\Vitalya\mine\NSProjectX\xrCore\_flags.h

; 15   :     IC	SelfRef	zero	()											{ flags=T(0);	return *this;	}

	mov	DWORD PTR [eax+4], 0
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp

; 15   :     m_fTimeLimit	= 0.f;

	mov	DWORD PTR [eax+8], 0
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h

; 70   : }

	ret	0
??$xr_new@VCPGDef@PS@@@@YAPAVCPGDef@PS@@XZ ENDP		; xr_new<PS::CPGDef>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
;	COMDAT ??$sort@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPEDef@PS@@@std@@@std@@@std@@P6A_NPBVCPEDef@PS@@0@Z@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPEDef@PS@@@std@@@std@@@0@0P6A_NPBVCPEDef@PS@@1@Z@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$sort@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPEDef@PS@@@std@@@std@@@std@@P6A_NPBVCPEDef@PS@@0@Z@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPEDef@PS@@@std@@@std@@@0@0P6A_NPBVCPEDef@PS@@1@Z@Z PROC ; std::sort<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<PS::CPEDef *> > >,bool (__cdecl*)(PS::CPEDef const *,PS::CPEDef const *)>, COMDAT
; __Pred$dead$ = ecx

; 7077 :     _Adl_verify_range(_First, _Last);
; 7078 :     const auto _UFirst = _Get_unwrapped(_First);
; 7079 :     const auto _ULast  = _Get_unwrapped(_Last);
; 7080 :     _Sort_unchecked(_UFirst, _ULast, _ULast - _UFirst, _Pass_fn(_Pred));

	mov	edx, DWORD PTR __Last$[esp-4]
	mov	eax, edx
	mov	ecx, DWORD PTR __First$[esp-4]
	sub	eax, ecx
	sar	eax, 2
	push	OFFSET ?ped_sort_pred@@YA_NPBVCPEDef@PS@@0@Z ; ped_sort_pred
	push	eax
	call	??$_Sort_unchecked@PAPAVCPEDef@PS@@P6A_NPBV12@0@Z@std@@YAXPAPAVCPEDef@PS@@0HP6A_NPBV12@1@Z@Z ; std::_Sort_unchecked<PS::CPEDef * *,bool (__cdecl*)(PS::CPEDef const *,PS::CPEDef const *)>
	add	esp, 8

; 7081 : }

	ret	0
??$sort@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPEDef@PS@@@std@@@std@@@std@@P6A_NPBVCPEDef@PS@@0@Z@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPEDef@PS@@@std@@@std@@@0@0P6A_NPBVCPEDef@PS@@1@Z@Z ENDP ; std::sort<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<PS::CPEDef *> > >,bool (__cdecl*)(PS::CPEDef const *,PS::CPEDef const *)>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
;	COMDAT ??$sort@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPGDef@PS@@@std@@@std@@@std@@P6A_NPBVCPGDef@PS@@0@Z@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPGDef@PS@@@std@@@std@@@0@0P6A_NPBVCPGDef@PS@@1@Z@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$sort@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPGDef@PS@@@std@@@std@@@std@@P6A_NPBVCPGDef@PS@@0@Z@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPGDef@PS@@@std@@@std@@@0@0P6A_NPBVCPGDef@PS@@1@Z@Z PROC ; std::sort<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<PS::CPGDef *> > >,bool (__cdecl*)(PS::CPGDef const *,PS::CPGDef const *)>, COMDAT
; __Pred$dead$ = ecx

; 7077 :     _Adl_verify_range(_First, _Last);
; 7078 :     const auto _UFirst = _Get_unwrapped(_First);
; 7079 :     const auto _ULast  = _Get_unwrapped(_Last);
; 7080 :     _Sort_unchecked(_UFirst, _ULast, _ULast - _UFirst, _Pass_fn(_Pred));

	mov	edx, DWORD PTR __Last$[esp-4]
	mov	eax, edx
	mov	ecx, DWORD PTR __First$[esp-4]
	sub	eax, ecx
	sar	eax, 2
	push	OFFSET ?pgd_sort_pred@@YA_NPBVCPGDef@PS@@0@Z ; pgd_sort_pred
	push	eax
	call	??$_Sort_unchecked@PAPAVCPGDef@PS@@P6A_NPBV12@0@Z@std@@YAXPAPAVCPGDef@PS@@0HP6A_NPBV12@1@Z@Z ; std::_Sort_unchecked<PS::CPGDef * *,bool (__cdecl*)(PS::CPGDef const *,PS::CPGDef const *)>
	add	esp, 8

; 7081 : }

	ret	0
??$sort@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPGDef@PS@@@std@@@std@@@std@@P6A_NPBVCPGDef@PS@@0@Z@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPGDef@PS@@@std@@@std@@@0@0P6A_NPBVCPGDef@PS@@1@Z@Z ENDP ; std::sort<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<PS::CPGDef *> > >,bool (__cdecl*)(PS::CPGDef const *,PS::CPGDef const *)>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\type_traits
;	COMDAT ??$forward@ABQAVCPGDef@PS@@@std@@YAABQAVCPGDef@PS@@ABQAV12@@Z
_TEXT	SEGMENT
??$forward@ABQAVCPGDef@PS@@@std@@YAABQAVCPGDef@PS@@ABQAV12@@Z PROC ; std::forward<PS::CPGDef * const &>, COMDAT
; __Arg$ = ecx

; 1386 :     return static_cast<_Ty&&>(_Arg);

	mov	eax, ecx

; 1387 : }

	ret	0
??$forward@ABQAVCPGDef@PS@@@std@@YAABQAVCPGDef@PS@@ABQAV12@@Z ENDP ; std::forward<PS::CPGDef * const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$construct@PAVCPGDef@PS@@ABQAV12@@?$_Normal_allocator_traits@V?$xalloc@PAVCPGDef@PS@@@@@std@@SAXAAV?$xalloc@PAVCPGDef@PS@@@@PAPAVCPGDef@PS@@ABQAV34@@Z
_TEXT	SEGMENT
_<_Args_0>$ = 8						; size = 4
??$construct@PAVCPGDef@PS@@ABQAV12@@?$_Normal_allocator_traits@V?$xalloc@PAVCPGDef@PS@@@@@std@@SAXAAV?$xalloc@PAVCPGDef@PS@@@@PAPAVCPGDef@PS@@ABQAV34@@Z PROC ; std::_Normal_allocator_traits<xalloc<PS::CPGDef *> >::construct<PS::CPGDef *,PS::CPGDef * const &>, COMDAT
; __Al$dead$ = ecx
; __Ptr$ = edx

; 565  :         if constexpr (_Uses_default_construct<_Alloc, _Ty*, _Types...>::value) {
; 566  :             (void) _Al; // TRANSITION, DevCom-1004719
; 567  : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 568  :             _STD construct_at(_Ptr, _STD forward<_Types>(_Args)...);
; 569  : #else // __cpp_lib_constexpr_dynamic_alloc
; 570  :             ::new (static_cast<void*>(_Ptr)) _Ty(_STD forward<_Types>(_Args)...);
; 571  : #endif // __cpp_lib_constexpr_dynamic_alloc
; 572  :         } else {
; 573  :             _Al.construct(_Ptr, _STD forward<_Types>(_Args)...);

	mov	eax, DWORD PTR _<_Args_0>$[esp-4]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edx], eax

; 574  :         }
; 575  :     }

	ret	0
??$construct@PAVCPGDef@PS@@ABQAV12@@?$_Normal_allocator_traits@V?$xalloc@PAVCPGDef@PS@@@@@std@@SAXAAV?$xalloc@PAVCPGDef@PS@@@@PAPAVCPGDef@PS@@ABQAV34@@Z ENDP ; std::_Normal_allocator_traits<xalloc<PS::CPGDef *> >::construct<PS::CPGDef *,PS::CPGDef * const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??$_Emplace_reallocate@ABQAVCPGDef@PS@@@?$vector@PAVCPGDef@PS@@V?$xalloc@PAVCPGDef@PS@@@@@std@@QAEPAPAVCPGDef@PS@@QAPAV23@ABQAV23@@Z
_TEXT	SEGMENT
__Backout$2 = -76					; size = 12
__Backout$3 = -64					; size = 12
__Backout$4 = -52					; size = 12
__UFirst$5 = -40					; size = 4
__UFirst$6 = -36					; size = 4
__UFirst$7 = -32					; size = 4
__Newvec$ = -28						; size = 4
__Newcapacity$1$ = -24					; size = 4
__Newsize$1$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
tv555 = 8						; size = 4
__Whereptr$ = 8						; size = 4
_<_Val_0>$ = 12						; size = 4
??$_Emplace_reallocate@ABQAVCPGDef@PS@@@?$vector@PAVCPGDef@PS@@V?$xalloc@PAVCPGDef@PS@@@@@std@@QAEPAPAVCPGDef@PS@@QAPAV23@ABQAV23@@Z PROC ; std::vector<PS::CPGDef *,xalloc<PS::CPGDef *> >::_Emplace_reallocate<PS::CPGDef * const &>, COMDAT
; _this$ = ecx

; 752  :     _CONSTEXPR20_CONTAINER pointer _Emplace_reallocate(const pointer _Whereptr, _Valty&&... _Val) {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Emplace_reallocate@ABQAVCPGDef@PS@@@?$vector@PAVCPGDef@PS@@V?$xalloc@PAVCPGDef@PS@@@@@std@@QAEPAPAVCPGDef@PS@@QAPAV23@ABQAV23@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	edi, ecx

; 753  :         // reallocate and insert by perfectly forwarding _Val at _Whereptr
; 754  :         _Alty& _Al        = _Getal();
; 755  :         auto& _My_data    = _Mypair._Myval2;
; 756  :         pointer& _Myfirst = _My_data._Myfirst;
; 757  :         pointer& _Mylast  = _My_data._Mylast;
; 758  : 
; 759  :         _STL_INTERNAL_CHECK(_Mylast == _My_data._Myend); // check that we have no unused capacity
; 760  : 
; 761  :         const auto _Whereoff = static_cast<size_type>(_Whereptr - _Myfirst);

	mov	edx, DWORD PTR [edi]
	mov	esi, DWORD PTR __Whereptr$[ebp]
	mov	ebx, esi
	sub	ebx, edx
	sar	ebx, 2

; 762  :         const auto _Oldsize  = static_cast<size_type>(_Mylast - _Myfirst);

	mov	eax, DWORD PTR [edi+4]
	sub	eax, edx
	sar	eax, 2

; 763  : 
; 764  :         if (_Oldsize == max_size()) {

	cmp	eax, 1073741823				; 3fffffffH
	je	$LN83@Emplace_re

; 766  :         }
; 767  : 
; 768  :         const size_type _Newsize     = _Oldsize + 1;

	inc	eax
	mov	DWORD PTR __Newsize$1$[ebp], eax

; 1546 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	ecx, DWORD PTR [edi+8]
	sub	ecx, edx
	sar	ecx, 2

; 1675 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	edx, ecx
	shr	edx, 1
	mov	eax, 1073741823				; 3fffffffH
	sub	eax, edx
	cmp	ecx, eax
	jbe	SHORT $LN12@Emplace_re

; 1676 :             return _Max; // geometric growth would overflow

	mov	eax, 1073741823				; 3fffffffH
	jmp	SHORT $LN81@Emplace_re
$LN12@Emplace_re:

; 1677 :         }
; 1678 : 
; 1679 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	lea	eax, DWORD PTR [edx+ecx]

; 1680 : 
; 1681 :         if (_Geometric < _Newsize) {

	cmp	eax, DWORD PTR __Newsize$1$[ebp]
	cmovb	eax, DWORD PTR __Newsize$1$[ebp]
$LN81@Emplace_re:
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	mov	DWORD PTR __Newcapacity$1$[ebp], eax
	shl	eax, 2
	push	eax
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 771  :         const pointer _Newvec           = _Al.allocate(_Newcapacity);

	mov	edx, eax
	mov	DWORD PTR __Newvec$[ebp], edx

; 772  :         const pointer _Constructed_last = _Newvec + _Whereoff + 1;
; 773  :         pointer _Constructed_first      = _Constructed_last;
; 774  : 
; 775  :         _TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 776  :         _Alty_traits::construct(_Al, _Unfancy(_Newvec + _Whereoff), _STD forward<_Valty>(_Val)...);

	lea	ecx, DWORD PTR [edx+ebx*4]
	mov	DWORD PTR tv555[ebp], ecx
	mov	eax, DWORD PTR _<_Val_0>$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax

; 777  :         _Constructed_first = _Newvec + _Whereoff;
; 778  : 
; 779  :         if (_Whereptr == _Mylast) { // at back, provide strong guarantee

	mov	ebx, DWORD PTR [edi+4]
	mov	ecx, DWORD PTR [edi]
	cmp	esi, ebx
	jne	SHORT $LN4@Emplace_re
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1703 :     auto _UFirst      = _Get_unwrapped(_First);

	mov	DWORD PTR __UFirst$7[ebp], ecx

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	DWORD PTR __Backout$4[ebp], edx
	mov	DWORD PTR __Backout$4[ebp+4], edx
	mov	DWORD PTR __Backout$4[ebp+8], edi
	npad	1
$LL28@Emplace_re:

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	ecx, ebx
	je	SHORT $LN27@Emplace_re

; 1620 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax

; 1621 :         ++_Last;

	add	edx, 4
	mov	DWORD PTR __Backout$4[ebp+4], edx

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	add	ecx, 4
	mov	DWORD PTR __UFirst$7[ebp], ecx
	jmp	SHORT $LL28@Emplace_re
$LN27@Emplace_re:

; 1625 :         _First = _Last;

	mov	DWORD PTR __Backout$4[ebp], edx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 781  :         } else { // provide basic guarantee

	mov	ebx, DWORD PTR tv555[ebp]
	jmp	SHORT $LN5@Emplace_re
$LN4@Emplace_re:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1703 :     auto _UFirst      = _Get_unwrapped(_First);

	mov	DWORD PTR __UFirst$6[ebp], ecx

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	DWORD PTR __Backout$3[ebp], edx
	mov	DWORD PTR __Backout$3[ebp+4], edx
	mov	DWORD PTR __Backout$3[ebp+8], edi
	npad	6
$LL41@Emplace_re:

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	ecx, esi
	je	SHORT $LN40@Emplace_re

; 1620 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax

; 1621 :         ++_Last;

	add	edx, 4
	mov	DWORD PTR __Backout$3[ebp+4], edx

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	add	ecx, 4
	mov	DWORD PTR __UFirst$6[ebp], ecx
	jmp	SHORT $LL41@Emplace_re
$LN40@Emplace_re:

; 1625 :         _First = _Last;

	mov	DWORD PTR __Backout$3[ebp], edx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 784  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

	mov	ebx, DWORD PTR tv555[ebp]
	lea	ecx, DWORD PTR [ebx+4]

; 1646 :         return _Uninitialized_move(_First, _Last, _Dest, _Getal());

	mov	edx, DWORD PTR [edi+4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1703 :     auto _UFirst      = _Get_unwrapped(_First);

	mov	DWORD PTR __UFirst$5[ebp], esi

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	DWORD PTR __Backout$2[ebp], ecx
	mov	DWORD PTR __Backout$2[ebp+4], ecx
	mov	DWORD PTR __Backout$2[ebp+8], edi
	npad	2
$LL54@Emplace_re:

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	esi, edx
	je	SHORT $LN53@Emplace_re

; 1620 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [ecx], eax

; 1621 :         ++_Last;

	add	ecx, 4
	mov	DWORD PTR __Backout$2[ebp+4], ecx

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	add	esi, 4
	mov	DWORD PTR __UFirst$5[ebp], esi
	jmp	SHORT $LL54@Emplace_re
$LN53@Emplace_re:

; 1625 :         _First = _Last;

	mov	DWORD PTR __Backout$2[ebp], ecx
$LN5@Emplace_re:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
	mov	DWORD PTR __$EHRec$[ebp+12], -1

; 1732 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [edi]
	test	eax, eax
	je	SHORT $LN68@Emplace_re
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	push	eax
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN68@Emplace_re:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1737 :         _Myfirst = _Newvec;

	mov	eax, DWORD PTR __Newvec$[ebp]
	mov	DWORD PTR [edi], eax

; 1738 :         _Mylast  = _Newvec + _Newsize;

	mov	ecx, DWORD PTR __Newsize$1$[ebp]
	lea	ecx, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR [edi+4], ecx

; 1739 :         _Myend   = _Newvec + _Newcapacity;

	mov	ecx, DWORD PTR __Newcapacity$1$[ebp]
	lea	ecx, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR [edi+8], ecx

; 790  :         _CATCH_END
; 791  : 
; 792  :         _Change_array(_Newvec, _Newsize, _Newcapacity);
; 793  :         return _Newvec + _Whereoff;

	mov	eax, ebx

; 794  :     }

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
__catch$??$_Emplace_reallocate@ABQAVCPGDef@PS@@@?$vector@PAVCPGDef@PS@@V?$xalloc@PAVCPGDef@PS@@@@@std@@QAEPAPAVCPGDef@PS@@QAPAV23@ABQAV23@@Z$0:

; 785  :         }
; 786  :         _CATCH_ALL
; 787  :         _Destroy(_Constructed_first, _Constructed_last);
; 788  :         _Al.deallocate(_Newvec, _Newcapacity);

	push	ecx
	push	DWORD PTR __Newvec$[ebp]
	call	?deallocate@?$xalloc@PAVCPGDef@PS@@@@QBEXPAPAVCPGDef@PS@@I@Z ; xalloc<PS::CPGDef *>::deallocate

; 789  :         _RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$LN83@Emplace_re:

; 765  :             _Xlength();

	call	?_Xlength@?$vector@PAVCPGDef@PS@@V?$xalloc@PAVCPGDef@PS@@@@@std@@CAXXZ ; std::vector<PS::CPGDef *,xalloc<PS::CPGDef *> >::_Xlength
$LN80@Emplace_re:
	int	3
	int	3
	int	3
	int	3
	int	3
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Emplace_reallocate@ABQAVCPGDef@PS@@@?$vector@PAVCPGDef@PS@@V?$xalloc@PAVCPGDef@PS@@@@@std@@QAEPAPAVCPGDef@PS@@QAPAV23@ABQAV23@@Z:
	npad	1
	npad	1
	mov	eax, OFFSET __ehfuncinfo$??$_Emplace_reallocate@ABQAVCPGDef@PS@@@?$vector@PAVCPGDef@PS@@V?$xalloc@PAVCPGDef@PS@@@@@std@@QAEPAPAVCPGDef@PS@@QAPAV23@ABQAV23@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Emplace_reallocate@ABQAVCPGDef@PS@@@?$vector@PAVCPGDef@PS@@V?$xalloc@PAVCPGDef@PS@@@@@std@@QAEPAPAVCPGDef@PS@@QAPAV23@ABQAV23@@Z ENDP ; std::vector<PS::CPGDef *,xalloc<PS::CPGDef *> >::_Emplace_reallocate<PS::CPGDef * const &>
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\type_traits
;	COMDAT ??$forward@ABQAVCPEDef@PS@@@std@@YAABQAVCPEDef@PS@@ABQAV12@@Z
_TEXT	SEGMENT
??$forward@ABQAVCPEDef@PS@@@std@@YAABQAVCPEDef@PS@@ABQAV12@@Z PROC ; std::forward<PS::CPEDef * const &>, COMDAT
; __Arg$ = ecx

; 1386 :     return static_cast<_Ty&&>(_Arg);

	mov	eax, ecx

; 1387 : }

	ret	0
??$forward@ABQAVCPEDef@PS@@@std@@YAABQAVCPEDef@PS@@ABQAV12@@Z ENDP ; std::forward<PS::CPEDef * const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$construct@PAVCPEDef@PS@@ABQAV12@@?$_Normal_allocator_traits@V?$xalloc@PAVCPEDef@PS@@@@@std@@SAXAAV?$xalloc@PAVCPEDef@PS@@@@PAPAVCPEDef@PS@@ABQAV34@@Z
_TEXT	SEGMENT
_<_Args_0>$ = 8						; size = 4
??$construct@PAVCPEDef@PS@@ABQAV12@@?$_Normal_allocator_traits@V?$xalloc@PAVCPEDef@PS@@@@@std@@SAXAAV?$xalloc@PAVCPEDef@PS@@@@PAPAVCPEDef@PS@@ABQAV34@@Z PROC ; std::_Normal_allocator_traits<xalloc<PS::CPEDef *> >::construct<PS::CPEDef *,PS::CPEDef * const &>, COMDAT
; __Al$dead$ = ecx
; __Ptr$ = edx

; 565  :         if constexpr (_Uses_default_construct<_Alloc, _Ty*, _Types...>::value) {
; 566  :             (void) _Al; // TRANSITION, DevCom-1004719
; 567  : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 568  :             _STD construct_at(_Ptr, _STD forward<_Types>(_Args)...);
; 569  : #else // __cpp_lib_constexpr_dynamic_alloc
; 570  :             ::new (static_cast<void*>(_Ptr)) _Ty(_STD forward<_Types>(_Args)...);
; 571  : #endif // __cpp_lib_constexpr_dynamic_alloc
; 572  :         } else {
; 573  :             _Al.construct(_Ptr, _STD forward<_Types>(_Args)...);

	mov	eax, DWORD PTR _<_Args_0>$[esp-4]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edx], eax

; 574  :         }
; 575  :     }

	ret	0
??$construct@PAVCPEDef@PS@@ABQAV12@@?$_Normal_allocator_traits@V?$xalloc@PAVCPEDef@PS@@@@@std@@SAXAAV?$xalloc@PAVCPEDef@PS@@@@PAPAVCPEDef@PS@@ABQAV34@@Z ENDP ; std::_Normal_allocator_traits<xalloc<PS::CPEDef *> >::construct<PS::CPEDef *,PS::CPEDef * const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??$_Emplace_reallocate@ABQAVCPEDef@PS@@@?$vector@PAVCPEDef@PS@@V?$xalloc@PAVCPEDef@PS@@@@@std@@QAEPAPAVCPEDef@PS@@QAPAV23@ABQAV23@@Z
_TEXT	SEGMENT
__Backout$2 = -76					; size = 12
__Backout$3 = -64					; size = 12
__Backout$4 = -52					; size = 12
__UFirst$5 = -40					; size = 4
__UFirst$6 = -36					; size = 4
__UFirst$7 = -32					; size = 4
__Newvec$ = -28						; size = 4
__Newcapacity$1$ = -24					; size = 4
__Newsize$1$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
tv555 = 8						; size = 4
__Whereptr$ = 8						; size = 4
_<_Val_0>$ = 12						; size = 4
??$_Emplace_reallocate@ABQAVCPEDef@PS@@@?$vector@PAVCPEDef@PS@@V?$xalloc@PAVCPEDef@PS@@@@@std@@QAEPAPAVCPEDef@PS@@QAPAV23@ABQAV23@@Z PROC ; std::vector<PS::CPEDef *,xalloc<PS::CPEDef *> >::_Emplace_reallocate<PS::CPEDef * const &>, COMDAT
; _this$ = ecx

; 752  :     _CONSTEXPR20_CONTAINER pointer _Emplace_reallocate(const pointer _Whereptr, _Valty&&... _Val) {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Emplace_reallocate@ABQAVCPEDef@PS@@@?$vector@PAVCPEDef@PS@@V?$xalloc@PAVCPEDef@PS@@@@@std@@QAEPAPAVCPEDef@PS@@QAPAV23@ABQAV23@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	edi, ecx

; 753  :         // reallocate and insert by perfectly forwarding _Val at _Whereptr
; 754  :         _Alty& _Al        = _Getal();
; 755  :         auto& _My_data    = _Mypair._Myval2;
; 756  :         pointer& _Myfirst = _My_data._Myfirst;
; 757  :         pointer& _Mylast  = _My_data._Mylast;
; 758  : 
; 759  :         _STL_INTERNAL_CHECK(_Mylast == _My_data._Myend); // check that we have no unused capacity
; 760  : 
; 761  :         const auto _Whereoff = static_cast<size_type>(_Whereptr - _Myfirst);

	mov	edx, DWORD PTR [edi]
	mov	esi, DWORD PTR __Whereptr$[ebp]
	mov	ebx, esi
	sub	ebx, edx
	sar	ebx, 2

; 762  :         const auto _Oldsize  = static_cast<size_type>(_Mylast - _Myfirst);

	mov	eax, DWORD PTR [edi+4]
	sub	eax, edx
	sar	eax, 2

; 763  : 
; 764  :         if (_Oldsize == max_size()) {

	cmp	eax, 1073741823				; 3fffffffH
	je	$LN83@Emplace_re

; 766  :         }
; 767  : 
; 768  :         const size_type _Newsize     = _Oldsize + 1;

	inc	eax
	mov	DWORD PTR __Newsize$1$[ebp], eax

; 1546 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	ecx, DWORD PTR [edi+8]
	sub	ecx, edx
	sar	ecx, 2

; 1675 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	edx, ecx
	shr	edx, 1
	mov	eax, 1073741823				; 3fffffffH
	sub	eax, edx
	cmp	ecx, eax
	jbe	SHORT $LN12@Emplace_re

; 1676 :             return _Max; // geometric growth would overflow

	mov	eax, 1073741823				; 3fffffffH
	jmp	SHORT $LN81@Emplace_re
$LN12@Emplace_re:

; 1677 :         }
; 1678 : 
; 1679 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	lea	eax, DWORD PTR [edx+ecx]

; 1680 : 
; 1681 :         if (_Geometric < _Newsize) {

	cmp	eax, DWORD PTR __Newsize$1$[ebp]
	cmovb	eax, DWORD PTR __Newsize$1$[ebp]
$LN81@Emplace_re:
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	mov	DWORD PTR __Newcapacity$1$[ebp], eax
	shl	eax, 2
	push	eax
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 771  :         const pointer _Newvec           = _Al.allocate(_Newcapacity);

	mov	edx, eax
	mov	DWORD PTR __Newvec$[ebp], edx

; 772  :         const pointer _Constructed_last = _Newvec + _Whereoff + 1;
; 773  :         pointer _Constructed_first      = _Constructed_last;
; 774  : 
; 775  :         _TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 776  :         _Alty_traits::construct(_Al, _Unfancy(_Newvec + _Whereoff), _STD forward<_Valty>(_Val)...);

	lea	ecx, DWORD PTR [edx+ebx*4]
	mov	DWORD PTR tv555[ebp], ecx
	mov	eax, DWORD PTR _<_Val_0>$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax

; 777  :         _Constructed_first = _Newvec + _Whereoff;
; 778  : 
; 779  :         if (_Whereptr == _Mylast) { // at back, provide strong guarantee

	mov	ebx, DWORD PTR [edi+4]
	mov	ecx, DWORD PTR [edi]
	cmp	esi, ebx
	jne	SHORT $LN4@Emplace_re
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1703 :     auto _UFirst      = _Get_unwrapped(_First);

	mov	DWORD PTR __UFirst$7[ebp], ecx

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	DWORD PTR __Backout$4[ebp], edx
	mov	DWORD PTR __Backout$4[ebp+4], edx
	mov	DWORD PTR __Backout$4[ebp+8], edi
	npad	1
$LL28@Emplace_re:

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	ecx, ebx
	je	SHORT $LN27@Emplace_re

; 1620 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax

; 1621 :         ++_Last;

	add	edx, 4
	mov	DWORD PTR __Backout$4[ebp+4], edx

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	add	ecx, 4
	mov	DWORD PTR __UFirst$7[ebp], ecx
	jmp	SHORT $LL28@Emplace_re
$LN27@Emplace_re:

; 1625 :         _First = _Last;

	mov	DWORD PTR __Backout$4[ebp], edx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 781  :         } else { // provide basic guarantee

	mov	ebx, DWORD PTR tv555[ebp]
	jmp	SHORT $LN5@Emplace_re
$LN4@Emplace_re:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1703 :     auto _UFirst      = _Get_unwrapped(_First);

	mov	DWORD PTR __UFirst$6[ebp], ecx

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	DWORD PTR __Backout$3[ebp], edx
	mov	DWORD PTR __Backout$3[ebp+4], edx
	mov	DWORD PTR __Backout$3[ebp+8], edi
	npad	6
$LL41@Emplace_re:

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	ecx, esi
	je	SHORT $LN40@Emplace_re

; 1620 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax

; 1621 :         ++_Last;

	add	edx, 4
	mov	DWORD PTR __Backout$3[ebp+4], edx

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	add	ecx, 4
	mov	DWORD PTR __UFirst$6[ebp], ecx
	jmp	SHORT $LL41@Emplace_re
$LN40@Emplace_re:

; 1625 :         _First = _Last;

	mov	DWORD PTR __Backout$3[ebp], edx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 784  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

	mov	ebx, DWORD PTR tv555[ebp]
	lea	ecx, DWORD PTR [ebx+4]

; 1646 :         return _Uninitialized_move(_First, _Last, _Dest, _Getal());

	mov	edx, DWORD PTR [edi+4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1703 :     auto _UFirst      = _Get_unwrapped(_First);

	mov	DWORD PTR __UFirst$5[ebp], esi

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	DWORD PTR __Backout$2[ebp], ecx
	mov	DWORD PTR __Backout$2[ebp+4], ecx
	mov	DWORD PTR __Backout$2[ebp+8], edi
	npad	2
$LL54@Emplace_re:

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	esi, edx
	je	SHORT $LN53@Emplace_re

; 1620 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [ecx], eax

; 1621 :         ++_Last;

	add	ecx, 4
	mov	DWORD PTR __Backout$2[ebp+4], ecx

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	add	esi, 4
	mov	DWORD PTR __UFirst$5[ebp], esi
	jmp	SHORT $LL54@Emplace_re
$LN53@Emplace_re:

; 1625 :         _First = _Last;

	mov	DWORD PTR __Backout$2[ebp], ecx
$LN5@Emplace_re:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
	mov	DWORD PTR __$EHRec$[ebp+12], -1

; 1732 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [edi]
	test	eax, eax
	je	SHORT $LN68@Emplace_re
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	push	eax
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN68@Emplace_re:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1737 :         _Myfirst = _Newvec;

	mov	eax, DWORD PTR __Newvec$[ebp]
	mov	DWORD PTR [edi], eax

; 1738 :         _Mylast  = _Newvec + _Newsize;

	mov	ecx, DWORD PTR __Newsize$1$[ebp]
	lea	ecx, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR [edi+4], ecx

; 1739 :         _Myend   = _Newvec + _Newcapacity;

	mov	ecx, DWORD PTR __Newcapacity$1$[ebp]
	lea	ecx, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR [edi+8], ecx

; 790  :         _CATCH_END
; 791  : 
; 792  :         _Change_array(_Newvec, _Newsize, _Newcapacity);
; 793  :         return _Newvec + _Whereoff;

	mov	eax, ebx

; 794  :     }

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
__catch$??$_Emplace_reallocate@ABQAVCPEDef@PS@@@?$vector@PAVCPEDef@PS@@V?$xalloc@PAVCPEDef@PS@@@@@std@@QAEPAPAVCPEDef@PS@@QAPAV23@ABQAV23@@Z$0:

; 785  :         }
; 786  :         _CATCH_ALL
; 787  :         _Destroy(_Constructed_first, _Constructed_last);
; 788  :         _Al.deallocate(_Newvec, _Newcapacity);

	push	ecx
	push	DWORD PTR __Newvec$[ebp]
	call	?deallocate@?$xalloc@PAVCPEDef@PS@@@@QBEXPAPAVCPEDef@PS@@I@Z ; xalloc<PS::CPEDef *>::deallocate

; 789  :         _RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$LN83@Emplace_re:

; 765  :             _Xlength();

	call	?_Xlength@?$vector@PAVCPEDef@PS@@V?$xalloc@PAVCPEDef@PS@@@@@std@@CAXXZ ; std::vector<PS::CPEDef *,xalloc<PS::CPEDef *> >::_Xlength
$LN80@Emplace_re:
	int	3
	int	3
	int	3
	int	3
	int	3
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Emplace_reallocate@ABQAVCPEDef@PS@@@?$vector@PAVCPEDef@PS@@V?$xalloc@PAVCPEDef@PS@@@@@std@@QAEPAPAVCPEDef@PS@@QAPAV23@ABQAV23@@Z:
	npad	1
	npad	1
	mov	eax, OFFSET __ehfuncinfo$??$_Emplace_reallocate@ABQAVCPEDef@PS@@@?$vector@PAVCPEDef@PS@@V?$xalloc@PAVCPEDef@PS@@@@@std@@QAEPAPAVCPEDef@PS@@QAPAV23@ABQAV23@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Emplace_reallocate@ABQAVCPEDef@PS@@@?$vector@PAVCPEDef@PS@@V?$xalloc@PAVCPEDef@PS@@@@@std@@QAEPAPAVCPEDef@PS@@QAPAV23@ABQAV23@@Z ENDP ; std::vector<PS::CPEDef *,xalloc<PS::CPEDef *> >::_Emplace_reallocate<PS::CPEDef * const &>
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xrstring.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrstring.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
;	COMDAT ??R?$xr_special_free@$0A@VCPGDef@PS@@@@QAEXAAPAVCPGDef@PS@@@Z
_TEXT	SEGMENT
_ptr$ = 8						; size = 4
??R?$xr_special_free@$0A@VCPGDef@PS@@@@QAEXAAPAVCPGDef@PS@@@Z PROC ; xr_special_free<0,PS::CPGDef>::operator(), COMDAT
; _this$dead$ = ecx

; 142  : 	{

	push	ebx
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp

; 20   :     for (EffectIt it=m_Effects.begin(); it!=m_Effects.end(); it++)

	mov	ebx, DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h

; 142  : 	{

	push	ebp

; 143  : 		ptr->~T			();

	mov	ebp, DWORD PTR _ptr$[esp+4]
	push	esi
	push	edi
	mov	edi, DWORD PTR [ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	esi, DWORD PTR [edi+12]

; 150  :         return _Ptr == _Right._Ptr;

	cmp	esi, DWORD PTR [edi+16]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp

; 20   :     for (EffectIt it=m_Effects.begin(); it!=m_Effects.end(); it++)

	je	$LN8@operator
	npad	3
$LL9@operator:
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h

; 151  : 	if (ptr) 

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN7@operator
; File I:\Vitalya\mine\NSProjectX\xrCore\xrstring.h

; 50   : 	void				_dec		()								{	if (0==p_) return;	p_->dwReference--; 	if (0==p_->dwReference)	p_=0;						}

	mov	ecx, DWORD PTR [eax+16]
	test	ecx, ecx
	je	SHORT $LN45@operator
	dec	DWORD PTR [ecx]
	mov	ecx, DWORD PTR [eax+16]
	cmp	DWORD PTR [ecx], 0
	jne	SHORT $LN45@operator
	mov	DWORD PTR [eax+16], 0
$LN45@operator:
	mov	ecx, DWORD PTR [eax+12]
	test	ecx, ecx
	je	SHORT $LN51@operator
	dec	DWORD PTR [ecx]
	mov	ecx, DWORD PTR [eax+12]
	cmp	DWORD PTR [ecx], 0
	jne	SHORT $LN51@operator
	mov	DWORD PTR [eax+12], 0
$LN51@operator:
	mov	ecx, DWORD PTR [eax+8]
	test	ecx, ecx
	je	SHORT $LN57@operator
	dec	DWORD PTR [ecx]
	mov	ecx, DWORD PTR [eax+8]
	cmp	DWORD PTR [ecx], 0
	jne	SHORT $LN57@operator
	mov	DWORD PTR [eax+8], 0
$LN57@operator:
	mov	ecx, DWORD PTR [eax+4]
	test	ecx, ecx
	je	SHORT $LN63@operator
	dec	DWORD PTR [ecx]
	mov	ecx, DWORD PTR [eax+4]
	cmp	DWORD PTR [ecx], 0
	jne	SHORT $LN63@operator
	mov	DWORD PTR [eax+4], 0
$LN63@operator:
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h

; 144  : 		Memory.mem_free	(ptr);

	push	DWORD PTR [esi]
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	ebx

; 154  : 		ptr = nullptr;

	mov	DWORD PTR [esi], 0
$LN7@operator:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 74   :         ++_Ptr;

	add	esi, 4

; 150  :         return _Ptr == _Right._Ptr;

	cmp	esi, DWORD PTR [edi+16]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp

; 20   :     for (EffectIt it=m_Effects.begin(); it!=m_Effects.end(); it++)

	jne	SHORT $LL9@operator
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h

; 154  : 		ptr = nullptr;

	mov	esi, DWORD PTR [edi+12]
$LN8@operator:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp

; 22   :     m_Effects.clear	();

	mov	DWORD PTR [edi+16], esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	test	esi, esi
	je	SHORT $LN70@operator
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	esi
	call	ebx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [edi+12], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [edi+16], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [edi+20], 0
$LN70@operator:
; File I:\Vitalya\mine\NSProjectX\xrCore\xrstring.h

; 50   : 	void				_dec		()								{	if (0==p_) return;	p_->dwReference--; 	if (0==p_->dwReference)	p_=0;						}

	mov	eax, DWORD PTR [edi]
	test	eax, eax
	je	SHORT $LN81@operator
	dec	DWORD PTR [eax]
	mov	eax, DWORD PTR [edi]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN81@operator
	mov	DWORD PTR [edi], 0
$LN81@operator:
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h

; 144  : 		Memory.mem_free	(ptr);

	push	DWORD PTR [ebp]
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	ebx
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 145  : 	}

	ret	4
??R?$xr_special_free@$0A@VCPGDef@PS@@@@QAEXAAPAVCPGDef@PS@@@Z ENDP ; xr_special_free<0,PS::CPGDef>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleEffectDef.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xrstring.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
;	COMDAT ??R?$xr_special_free@$0A@VCPEDef@PS@@@@QAEXAAPAVCPEDef@PS@@@Z
_TEXT	SEGMENT
_ptr$ = 8						; size = 4
??R?$xr_special_free@$0A@VCPEDef@PS@@@@QAEXAAPAVCPEDef@PS@@@Z PROC ; xr_special_free<0,PS::CPEDef>::operator(), COMDAT
; _this$dead$ = ecx

; 142  : 	{

	push	esi
	push	edi

; 143  : 		ptr->~T			();

	mov	edi, DWORD PTR _ptr$[esp+4]
	mov	esi, DWORD PTR [edi]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleEffectDef.cpp

; 39   : }

	lea	ecx, DWORD PTR [esi+48]
	call	DWORD PTR __imp_??1CMemoryWriter@@UAE@XZ
	lea	ecx, DWORD PTR [esi+16]
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 64   : 						~resptr_core	()												{	_dec();						}

	call	DWORD PTR __imp_?_dec@?$resptr_base@UShader@@@@IAEXXZ
; File I:\Vitalya\mine\NSProjectX\xrCore\xrstring.h

; 50   : 	void				_dec		()								{	if (0==p_) return;	p_->dwReference--; 	if (0==p_->dwReference)	p_=0;						}

	mov	eax, DWORD PTR [esi+12]
	test	eax, eax
	je	SHORT $LN14@operator
	dec	DWORD PTR [eax]
	mov	eax, DWORD PTR [esi+12]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN14@operator
	mov	DWORD PTR [esi+12], 0
$LN14@operator:
	mov	eax, DWORD PTR [esi+8]
	test	eax, eax
	je	SHORT $LN20@operator
	dec	DWORD PTR [eax]
	mov	eax, DWORD PTR [esi+8]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN20@operator
	mov	DWORD PTR [esi+8], 0
$LN20@operator:
	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN26@operator
	dec	DWORD PTR [eax]
	mov	eax, DWORD PTR [esi]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN26@operator
	mov	DWORD PTR [esi], 0
$LN26@operator:
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h

; 144  : 		Memory.mem_free	(ptr);

	push	DWORD PTR [edi]
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
	pop	edi
	pop	esi

; 145  : 	}

	ret	4
??R?$xr_special_free@$0A@VCPEDef@PS@@@@QAEXAAPAVCPEDef@PS@@@Z ENDP ; xr_special_free<0,PS::CPEDef>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Unwrapped@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPGDef@PS@@@std@@@std@@@std@@QBEPAPAVCPGDef@PS@@XZ
_TEXT	SEGMENT
?_Unwrapped@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPGDef@PS@@@std@@@std@@@std@@QBEPAPAVCPGDef@PS@@XZ PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<PS::CPGDef *> > >::_Unwrapped, COMDAT
; _this$ = ecx

; 328  :         return _Unfancy(this->_Ptr);

	mov	eax, DWORD PTR [ecx]

; 329  :     }

	ret	0
?_Unwrapped@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPGDef@PS@@@std@@@std@@@std@@QBEPAPAVCPGDef@PS@@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<PS::CPGDef *> > >::_Unwrapped
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Unwrapped@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPEDef@PS@@@std@@@std@@@std@@QBEPAPAVCPEDef@PS@@XZ
_TEXT	SEGMENT
?_Unwrapped@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPEDef@PS@@@std@@@std@@@std@@QBEPAPAVCPEDef@PS@@XZ PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<PS::CPEDef *> > >::_Unwrapped, COMDAT
; _this$ = ecx

; 328  :         return _Unfancy(this->_Ptr);

	mov	eax, DWORD PTR [ecx]

; 329  :     }

	ret	0
?_Unwrapped@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPEDef@PS@@@std@@@std@@@std@@QBEPAPAVCPEDef@PS@@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<PS::CPEDef *> > >::_Unwrapped
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Xlength@?$vector@PAVCPGDef@PS@@V?$xalloc@PAVCPGDef@PS@@@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@PAVCPGDef@PS@@V?$xalloc@PAVCPGDef@PS@@@@@std@@CAXXZ PROC ; std::vector<PS::CPGDef *,xalloc<PS::CPGDef *> >::_Xlength, COMDAT

; 1761 :         _Xlength_error("vector too long");

	push	OFFSET ??_C@_0BA@FOIKENOD@vector?5too?5long@
	call	DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN3@Xlength:
	int	3
?_Xlength@?$vector@PAVCPGDef@PS@@V?$xalloc@PAVCPGDef@PS@@@@@std@@CAXXZ ENDP ; std::vector<PS::CPGDef *,xalloc<PS::CPGDef *> >::_Xlength
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Change_array@?$vector@PAVCPGDef@PS@@V?$xalloc@PAVCPGDef@PS@@@@@std@@AAEXQAPAVCPGDef@PS@@II@Z
_TEXT	SEGMENT
__Newvec$ = 8						; size = 4
__Newsize$ = 12						; size = 4
__Newcapacity$ = 16					; size = 4
?_Change_array@?$vector@PAVCPGDef@PS@@V?$xalloc@PAVCPGDef@PS@@@@@std@@AAEXQAPAVCPGDef@PS@@II@Z PROC ; std::vector<PS::CPGDef *,xalloc<PS::CPGDef *> >::_Change_array, COMDAT
; _this$ = ecx

; 1723 :         const pointer _Newvec, const size_type _Newsize, const size_type _Newcapacity) {

	push	esi
	mov	esi, ecx

; 1724 :         // orphan all iterators, discard old array, acquire new array
; 1725 :         auto& _My_data    = _Mypair._Myval2;
; 1726 :         pointer& _Myfirst = _My_data._Myfirst;
; 1727 :         pointer& _Mylast  = _My_data._Mylast;
; 1728 :         pointer& _Myend   = _My_data._Myend;
; 1729 : 
; 1730 :         _My_data._Orphan_all();
; 1731 : 
; 1732 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN7@Change_arr
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN7@Change_arr:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1737 :         _Myfirst = _Newvec;

	mov	ecx, DWORD PTR __Newvec$[esp]

; 1738 :         _Mylast  = _Newvec + _Newsize;

	mov	eax, DWORD PTR __Newsize$[esp]
	mov	DWORD PTR [esi], ecx
	lea	eax, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR [esi+4], eax

; 1739 :         _Myend   = _Newvec + _Newcapacity;

	mov	eax, DWORD PTR __Newcapacity$[esp]
	lea	eax, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR [esi+8], eax
	pop	esi

; 1740 :     }

	ret	12					; 0000000cH
?_Change_array@?$vector@PAVCPGDef@PS@@V?$xalloc@PAVCPGDef@PS@@@@@std@@AAEXQAPAVCPGDef@PS@@II@Z ENDP ; std::vector<PS::CPGDef *,xalloc<PS::CPGDef *> >::_Change_array
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Calculate_growth@?$vector@PAVCPGDef@PS@@V?$xalloc@PAVCPGDef@PS@@@@@std@@ABEII@Z
_TEXT	SEGMENT
__Newsize$ = 8						; size = 4
?_Calculate_growth@?$vector@PAVCPGDef@PS@@V?$xalloc@PAVCPGDef@PS@@@@@std@@ABEII@Z PROC ; std::vector<PS::CPGDef *,xalloc<PS::CPGDef *> >::_Calculate_growth, COMDAT
; _this$ = ecx

; 1546 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	edx, DWORD PTR [ecx+8]
	sub	edx, DWORD PTR [ecx]

; 1671 :         // given _Oldcapacity and _Newsize, calculate geometric growth
; 1672 :         const size_type _Oldcapacity = capacity();
; 1673 :         const auto _Max              = max_size();
; 1674 : 
; 1675 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	ecx, 1073741823				; 3fffffffH

; 1546 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	sar	edx, 2

; 1670 :     _CONSTEXPR20_CONTAINER size_type _Calculate_growth(const size_type _Newsize) const {

	push	esi

; 1671 :         // given _Oldcapacity and _Newsize, calculate geometric growth
; 1672 :         const size_type _Oldcapacity = capacity();
; 1673 :         const auto _Max              = max_size();
; 1674 : 
; 1675 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	esi, edx
	shr	esi, 1
	sub	ecx, esi
	cmp	edx, ecx
	jbe	SHORT $LN2@Calculate_

; 1676 :             return _Max; // geometric growth would overflow

	mov	eax, 1073741823				; 3fffffffH
	pop	esi

; 1682 :             return _Newsize; // geometric growth would be insufficient
; 1683 :         }
; 1684 : 
; 1685 :         return _Geometric; // geometric growth is sufficient
; 1686 :     }

	ret	4
$LN2@Calculate_:

; 1677 :         }
; 1678 : 
; 1679 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	lea	eax, DWORD PTR [esi+edx]

; 1680 : 
; 1681 :         if (_Geometric < _Newsize) {

	cmp	eax, DWORD PTR __Newsize$[esp]
	pop	esi
	cmovb	eax, DWORD PTR __Newsize$[esp-4]

; 1682 :             return _Newsize; // geometric growth would be insufficient
; 1683 :         }
; 1684 : 
; 1685 :         return _Geometric; // geometric growth is sufficient
; 1686 :     }

	ret	4
?_Calculate_growth@?$vector@PAVCPGDef@PS@@V?$xalloc@PAVCPGDef@PS@@@@@std@@ABEII@Z ENDP ; std::vector<PS::CPGDef *,xalloc<PS::CPGDef *> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Umove_if_noexcept@?$vector@PAVCPGDef@PS@@V?$xalloc@PAVCPGDef@PS@@@@@std@@AAEXPAPAVCPGDef@PS@@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
?_Umove_if_noexcept@?$vector@PAVCPGDef@PS@@V?$xalloc@PAVCPGDef@PS@@@@@std@@AAEXPAPAVCPGDef@PS@@00@Z PROC ; std::vector<PS::CPGDef *,xalloc<PS::CPGDef *> >::_Umove_if_noexcept, COMDAT
; _this$dead$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1703 :     auto _UFirst      = _Get_unwrapped(_First);

	mov	eax, DWORD PTR __First$[esp-4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1659 :     _CONSTEXPR20_CONTAINER void _Umove_if_noexcept(pointer _First, pointer _Last, pointer _Dest) {

	push	esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	mov	esi, DWORD PTR __Last$[esp]
	cmp	eax, esi
	je	SHORT $LN7@Umove_if_n

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	edx, DWORD PTR __Dest$[esp]
	sub	edx, eax
$LL8@Umove_if_n:

; 1620 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx+eax], ecx

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	add	eax, 4
	cmp	eax, esi
	jne	SHORT $LL8@Umove_if_n
$LN7@Umove_if_n:
	pop	esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1663 :     }

	ret	12					; 0000000cH
?_Umove_if_noexcept@?$vector@PAVCPGDef@PS@@V?$xalloc@PAVCPGDef@PS@@@@@std@@AAEXPAPAVCPGDef@PS@@00@Z ENDP ; std::vector<PS::CPGDef *,xalloc<PS::CPGDef *> >::_Umove_if_noexcept
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Umove@?$vector@PAVCPGDef@PS@@V?$xalloc@PAVCPGDef@PS@@@@@std@@AAEPAPAVCPGDef@PS@@PAPAV34@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
?_Umove@?$vector@PAVCPGDef@PS@@V?$xalloc@PAVCPGDef@PS@@@@@std@@AAEPAPAVCPGDef@PS@@PAPAV34@00@Z PROC ; std::vector<PS::CPGDef *,xalloc<PS::CPGDef *> >::_Umove, COMDAT
; _this$dead$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	mov	ecx, DWORD PTR __First$[esp-4]

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	eax, DWORD PTR __Dest$[esp-4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1644 :     _CONSTEXPR20_CONTAINER pointer _Umove(pointer _First, pointer _Last, pointer _Dest) {

	push	esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	mov	esi, DWORD PTR __Last$[esp]
	cmp	ecx, esi
	je	SHORT $LN5@Umove
$LL6@Umove:

; 1620 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

	mov	edx, DWORD PTR [ecx]

; 1621 :         ++_Last;

	add	ecx, 4
	mov	DWORD PTR [eax], edx
	add	eax, 4

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	ecx, esi
	jne	SHORT $LL6@Umove
$LN5@Umove:
	pop	esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1647 :     }

	ret	12					; 0000000cH
?_Umove@?$vector@PAVCPGDef@PS@@V?$xalloc@PAVCPGDef@PS@@@@@std@@AAEPAPAVCPGDef@PS@@PAPAV34@00@Z ENDP ; std::vector<PS::CPGDef *,xalloc<PS::CPGDef *> >::_Umove
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?max_size@?$vector@PAVCPGDef@PS@@V?$xalloc@PAVCPGDef@PS@@@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@PAVCPGDef@PS@@V?$xalloc@PAVCPGDef@PS@@@@@std@@QBEIXZ PROC ; std::vector<PS::CPGDef *,xalloc<PS::CPGDef *> >::max_size, COMDAT
; _this$dead$ = ecx

; 1540 :         return (_STD min)(

	mov	eax, 1073741823				; 3fffffffH

; 1541 :             static_cast<size_type>((numeric_limits<difference_type>::max)()), _Alty_traits::max_size(_Getal()));
; 1542 :     }

	ret	0
?max_size@?$vector@PAVCPGDef@PS@@V?$xalloc@PAVCPGDef@PS@@@@@std@@QBEIXZ ENDP ; std::vector<PS::CPGDef *,xalloc<PS::CPGDef *> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?construct@?$xalloc@PAVCPGDef@PS@@@@QAEXPAPAVCPGDef@PS@@ABQAV23@@Z
_TEXT	SEGMENT
_p$ = 8							; size = 4
__Val$ = 12						; size = 4
?construct@?$xalloc@PAVCPGDef@PS@@@@QAEXPAPAVCPGDef@PS@@ABQAV23@@Z PROC ; xalloc<PS::CPGDef *>::construct, COMDAT
; _this$dead$ = ecx

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	eax, DWORD PTR __Val$[esp-4]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR _p$[esp-4]
	mov	DWORD PTR [eax], ecx
	ret	8
?construct@?$xalloc@PAVCPGDef@PS@@@@QAEXPAPAVCPGDef@PS@@ABQAV23@@Z ENDP ; xalloc<PS::CPGDef *>::construct
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?allocate@?$xalloc@PAVCPGDef@PS@@@@QBEPAPAVCPGDef@PS@@IPBX@Z
_TEXT	SEGMENT
_n$ = 8							; size = 4
_p$dead$ = 12						; size = 4
?allocate@?$xalloc@PAVCPGDef@PS@@@@QBEPAPAVCPGDef@PS@@IPBX@Z PROC ; xalloc<PS::CPGDef *>::allocate, COMDAT
; _this$dead$ = ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	mov	eax, DWORD PTR _n$[esp-4]
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	shl	eax, 2
	push	eax
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 80   : 							pointer					allocate		(size_type n, const void* p=0) const	{	return xr_alloc<T>((u32)n);	}

	ret	8
?allocate@?$xalloc@PAVCPGDef@PS@@@@QBEPAPAVCPGDef@PS@@IPBX@Z ENDP ; xalloc<PS::CPGDef *>::allocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Xlength@?$vector@PAVCPEDef@PS@@V?$xalloc@PAVCPEDef@PS@@@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@PAVCPEDef@PS@@V?$xalloc@PAVCPEDef@PS@@@@@std@@CAXXZ PROC ; std::vector<PS::CPEDef *,xalloc<PS::CPEDef *> >::_Xlength, COMDAT

; 1761 :         _Xlength_error("vector too long");

	push	OFFSET ??_C@_0BA@FOIKENOD@vector?5too?5long@
	call	DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN3@Xlength:
	int	3
?_Xlength@?$vector@PAVCPEDef@PS@@V?$xalloc@PAVCPEDef@PS@@@@@std@@CAXXZ ENDP ; std::vector<PS::CPEDef *,xalloc<PS::CPEDef *> >::_Xlength
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Change_array@?$vector@PAVCPEDef@PS@@V?$xalloc@PAVCPEDef@PS@@@@@std@@AAEXQAPAVCPEDef@PS@@II@Z
_TEXT	SEGMENT
__Newvec$ = 8						; size = 4
__Newsize$ = 12						; size = 4
__Newcapacity$ = 16					; size = 4
?_Change_array@?$vector@PAVCPEDef@PS@@V?$xalloc@PAVCPEDef@PS@@@@@std@@AAEXQAPAVCPEDef@PS@@II@Z PROC ; std::vector<PS::CPEDef *,xalloc<PS::CPEDef *> >::_Change_array, COMDAT
; _this$ = ecx

; 1723 :         const pointer _Newvec, const size_type _Newsize, const size_type _Newcapacity) {

	push	esi
	mov	esi, ecx

; 1724 :         // orphan all iterators, discard old array, acquire new array
; 1725 :         auto& _My_data    = _Mypair._Myval2;
; 1726 :         pointer& _Myfirst = _My_data._Myfirst;
; 1727 :         pointer& _Mylast  = _My_data._Mylast;
; 1728 :         pointer& _Myend   = _My_data._Myend;
; 1729 : 
; 1730 :         _My_data._Orphan_all();
; 1731 : 
; 1732 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN7@Change_arr
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN7@Change_arr:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1737 :         _Myfirst = _Newvec;

	mov	ecx, DWORD PTR __Newvec$[esp]

; 1738 :         _Mylast  = _Newvec + _Newsize;

	mov	eax, DWORD PTR __Newsize$[esp]
	mov	DWORD PTR [esi], ecx
	lea	eax, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR [esi+4], eax

; 1739 :         _Myend   = _Newvec + _Newcapacity;

	mov	eax, DWORD PTR __Newcapacity$[esp]
	lea	eax, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR [esi+8], eax
	pop	esi

; 1740 :     }

	ret	12					; 0000000cH
?_Change_array@?$vector@PAVCPEDef@PS@@V?$xalloc@PAVCPEDef@PS@@@@@std@@AAEXQAPAVCPEDef@PS@@II@Z ENDP ; std::vector<PS::CPEDef *,xalloc<PS::CPEDef *> >::_Change_array
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Calculate_growth@?$vector@PAVCPEDef@PS@@V?$xalloc@PAVCPEDef@PS@@@@@std@@ABEII@Z
_TEXT	SEGMENT
__Newsize$ = 8						; size = 4
?_Calculate_growth@?$vector@PAVCPEDef@PS@@V?$xalloc@PAVCPEDef@PS@@@@@std@@ABEII@Z PROC ; std::vector<PS::CPEDef *,xalloc<PS::CPEDef *> >::_Calculate_growth, COMDAT
; _this$ = ecx

; 1546 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	edx, DWORD PTR [ecx+8]
	sub	edx, DWORD PTR [ecx]

; 1671 :         // given _Oldcapacity and _Newsize, calculate geometric growth
; 1672 :         const size_type _Oldcapacity = capacity();
; 1673 :         const auto _Max              = max_size();
; 1674 : 
; 1675 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	ecx, 1073741823				; 3fffffffH

; 1546 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	sar	edx, 2

; 1670 :     _CONSTEXPR20_CONTAINER size_type _Calculate_growth(const size_type _Newsize) const {

	push	esi

; 1671 :         // given _Oldcapacity and _Newsize, calculate geometric growth
; 1672 :         const size_type _Oldcapacity = capacity();
; 1673 :         const auto _Max              = max_size();
; 1674 : 
; 1675 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	esi, edx
	shr	esi, 1
	sub	ecx, esi
	cmp	edx, ecx
	jbe	SHORT $LN2@Calculate_

; 1676 :             return _Max; // geometric growth would overflow

	mov	eax, 1073741823				; 3fffffffH
	pop	esi

; 1682 :             return _Newsize; // geometric growth would be insufficient
; 1683 :         }
; 1684 : 
; 1685 :         return _Geometric; // geometric growth is sufficient
; 1686 :     }

	ret	4
$LN2@Calculate_:

; 1677 :         }
; 1678 : 
; 1679 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	lea	eax, DWORD PTR [esi+edx]

; 1680 : 
; 1681 :         if (_Geometric < _Newsize) {

	cmp	eax, DWORD PTR __Newsize$[esp]
	pop	esi
	cmovb	eax, DWORD PTR __Newsize$[esp-4]

; 1682 :             return _Newsize; // geometric growth would be insufficient
; 1683 :         }
; 1684 : 
; 1685 :         return _Geometric; // geometric growth is sufficient
; 1686 :     }

	ret	4
?_Calculate_growth@?$vector@PAVCPEDef@PS@@V?$xalloc@PAVCPEDef@PS@@@@@std@@ABEII@Z ENDP ; std::vector<PS::CPEDef *,xalloc<PS::CPEDef *> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Umove_if_noexcept@?$vector@PAVCPEDef@PS@@V?$xalloc@PAVCPEDef@PS@@@@@std@@AAEXPAPAVCPEDef@PS@@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
?_Umove_if_noexcept@?$vector@PAVCPEDef@PS@@V?$xalloc@PAVCPEDef@PS@@@@@std@@AAEXPAPAVCPEDef@PS@@00@Z PROC ; std::vector<PS::CPEDef *,xalloc<PS::CPEDef *> >::_Umove_if_noexcept, COMDAT
; _this$dead$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1703 :     auto _UFirst      = _Get_unwrapped(_First);

	mov	eax, DWORD PTR __First$[esp-4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1659 :     _CONSTEXPR20_CONTAINER void _Umove_if_noexcept(pointer _First, pointer _Last, pointer _Dest) {

	push	esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	mov	esi, DWORD PTR __Last$[esp]
	cmp	eax, esi
	je	SHORT $LN7@Umove_if_n

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	edx, DWORD PTR __Dest$[esp]
	sub	edx, eax
$LL8@Umove_if_n:

; 1620 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx+eax], ecx

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	add	eax, 4
	cmp	eax, esi
	jne	SHORT $LL8@Umove_if_n
$LN7@Umove_if_n:
	pop	esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1663 :     }

	ret	12					; 0000000cH
?_Umove_if_noexcept@?$vector@PAVCPEDef@PS@@V?$xalloc@PAVCPEDef@PS@@@@@std@@AAEXPAPAVCPEDef@PS@@00@Z ENDP ; std::vector<PS::CPEDef *,xalloc<PS::CPEDef *> >::_Umove_if_noexcept
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Umove@?$vector@PAVCPEDef@PS@@V?$xalloc@PAVCPEDef@PS@@@@@std@@AAEPAPAVCPEDef@PS@@PAPAV34@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
?_Umove@?$vector@PAVCPEDef@PS@@V?$xalloc@PAVCPEDef@PS@@@@@std@@AAEPAPAVCPEDef@PS@@PAPAV34@00@Z PROC ; std::vector<PS::CPEDef *,xalloc<PS::CPEDef *> >::_Umove, COMDAT
; _this$dead$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	mov	ecx, DWORD PTR __First$[esp-4]

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	eax, DWORD PTR __Dest$[esp-4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1644 :     _CONSTEXPR20_CONTAINER pointer _Umove(pointer _First, pointer _Last, pointer _Dest) {

	push	esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	mov	esi, DWORD PTR __Last$[esp]
	cmp	ecx, esi
	je	SHORT $LN5@Umove
$LL6@Umove:

; 1620 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

	mov	edx, DWORD PTR [ecx]

; 1621 :         ++_Last;

	add	ecx, 4
	mov	DWORD PTR [eax], edx
	add	eax, 4

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	ecx, esi
	jne	SHORT $LL6@Umove
$LN5@Umove:
	pop	esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1647 :     }

	ret	12					; 0000000cH
?_Umove@?$vector@PAVCPEDef@PS@@V?$xalloc@PAVCPEDef@PS@@@@@std@@AAEPAPAVCPEDef@PS@@PAPAV34@00@Z ENDP ; std::vector<PS::CPEDef *,xalloc<PS::CPEDef *> >::_Umove
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?max_size@?$vector@PAVCPEDef@PS@@V?$xalloc@PAVCPEDef@PS@@@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@PAVCPEDef@PS@@V?$xalloc@PAVCPEDef@PS@@@@@std@@QBEIXZ PROC ; std::vector<PS::CPEDef *,xalloc<PS::CPEDef *> >::max_size, COMDAT
; _this$dead$ = ecx

; 1540 :         return (_STD min)(

	mov	eax, 1073741823				; 3fffffffH

; 1541 :             static_cast<size_type>((numeric_limits<difference_type>::max)()), _Alty_traits::max_size(_Getal()));
; 1542 :     }

	ret	0
?max_size@?$vector@PAVCPEDef@PS@@V?$xalloc@PAVCPEDef@PS@@@@@std@@QBEIXZ ENDP ; std::vector<PS::CPEDef *,xalloc<PS::CPEDef *> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?construct@?$xalloc@PAVCPEDef@PS@@@@QAEXPAPAVCPEDef@PS@@ABQAV23@@Z
_TEXT	SEGMENT
_p$ = 8							; size = 4
__Val$ = 12						; size = 4
?construct@?$xalloc@PAVCPEDef@PS@@@@QAEXPAPAVCPEDef@PS@@ABQAV23@@Z PROC ; xalloc<PS::CPEDef *>::construct, COMDAT
; _this$dead$ = ecx

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	eax, DWORD PTR __Val$[esp-4]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR _p$[esp-4]
	mov	DWORD PTR [eax], ecx
	ret	8
?construct@?$xalloc@PAVCPEDef@PS@@@@QAEXPAPAVCPEDef@PS@@ABQAV23@@Z ENDP ; xalloc<PS::CPEDef *>::construct
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?allocate@?$xalloc@PAVCPEDef@PS@@@@QBEPAPAVCPEDef@PS@@IPBX@Z
_TEXT	SEGMENT
_n$ = 8							; size = 4
_p$dead$ = 12						; size = 4
?allocate@?$xalloc@PAVCPEDef@PS@@@@QBEPAPAVCPEDef@PS@@IPBX@Z PROC ; xalloc<PS::CPEDef *>::allocate, COMDAT
; _this$dead$ = ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	mov	eax, DWORD PTR _n$[esp-4]
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	shl	eax, 2
	push	eax
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 80   : 							pointer					allocate		(size_type n, const void* p=0) const	{	return xr_alloc<T>((u32)n);	}

	ret	8
?allocate@?$xalloc@PAVCPEDef@PS@@@@QBEPAPAVCPEDef@PS@@IPBX@Z ENDP ; xalloc<PS::CPEDef *>::allocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xrstring.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrstring.h
;	COMDAT ??_GCPGDef@PS@@QAEPAXI@Z
_TEXT	SEGMENT
___flags$dead$ = 8					; size = 4
??_GCPGDef@PS@@QAEPAXI@Z PROC				; PS::CPGDef::`scalar deleting destructor', COMDAT
; _this$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	push	ebx
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp

; 20   :     for (EffectIt it=m_Effects.begin(); it!=m_Effects.end(); it++)

	mov	ebx, DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	push	esi
	push	edi
	mov	edi, ecx
	mov	esi, DWORD PTR [edi+12]

; 150  :         return _Ptr == _Right._Ptr;

	cmp	esi, DWORD PTR [edi+16]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp

; 20   :     for (EffectIt it=m_Effects.begin(); it!=m_Effects.end(); it++)

	je	$LN6@scalar
$LL7@scalar:
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h

; 151  : 	if (ptr) 

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN5@scalar
; File I:\Vitalya\mine\NSProjectX\xrCore\xrstring.h

; 50   : 	void				_dec		()								{	if (0==p_) return;	p_->dwReference--; 	if (0==p_->dwReference)	p_=0;						}

	mov	ecx, DWORD PTR [eax+16]
	test	ecx, ecx
	je	SHORT $LN43@scalar
	dec	DWORD PTR [ecx]
	mov	ecx, DWORD PTR [eax+16]
	cmp	DWORD PTR [ecx], 0
	jne	SHORT $LN43@scalar
	mov	DWORD PTR [eax+16], 0
$LN43@scalar:
	mov	ecx, DWORD PTR [eax+12]
	test	ecx, ecx
	je	SHORT $LN49@scalar
	dec	DWORD PTR [ecx]
	mov	ecx, DWORD PTR [eax+12]
	cmp	DWORD PTR [ecx], 0
	jne	SHORT $LN49@scalar
	mov	DWORD PTR [eax+12], 0
$LN49@scalar:
	mov	ecx, DWORD PTR [eax+8]
	test	ecx, ecx
	je	SHORT $LN55@scalar
	dec	DWORD PTR [ecx]
	mov	ecx, DWORD PTR [eax+8]
	cmp	DWORD PTR [ecx], 0
	jne	SHORT $LN55@scalar
	mov	DWORD PTR [eax+8], 0
$LN55@scalar:
	mov	ecx, DWORD PTR [eax+4]
	test	ecx, ecx
	je	SHORT $LN61@scalar
	dec	DWORD PTR [ecx]
	mov	ecx, DWORD PTR [eax+4]
	cmp	DWORD PTR [ecx], 0
	jne	SHORT $LN61@scalar
	mov	DWORD PTR [eax+4], 0
$LN61@scalar:
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h

; 144  : 		Memory.mem_free	(ptr);

	push	DWORD PTR [esi]
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	ebx

; 154  : 		ptr = nullptr;

	mov	DWORD PTR [esi], 0
$LN5@scalar:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 74   :         ++_Ptr;

	add	esi, 4

; 150  :         return _Ptr == _Right._Ptr;

	cmp	esi, DWORD PTR [edi+16]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp

; 20   :     for (EffectIt it=m_Effects.begin(); it!=m_Effects.end(); it++)

	jne	SHORT $LL7@scalar
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h

; 154  : 		ptr = nullptr;

	mov	esi, DWORD PTR [edi+12]
$LN6@scalar:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp

; 22   :     m_Effects.clear	();

	mov	DWORD PTR [edi+16], esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	test	esi, esi
	je	SHORT $LN68@scalar
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	esi
	call	ebx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [edi+12], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [edi+16], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [edi+20], 0
$LN68@scalar:
; File I:\Vitalya\mine\NSProjectX\xrCore\xrstring.h

; 50   : 	void				_dec		()								{	if (0==p_) return;	p_->dwReference--; 	if (0==p_->dwReference)	p_=0;						}

	mov	eax, DWORD PTR [edi]
	test	eax, eax
	je	SHORT $LN88@scalar
	dec	DWORD PTR [eax]
	mov	eax, DWORD PTR [edi]
	cmp	DWORD PTR [eax], 0
	mov	eax, edi
	jne	SHORT $LN79@scalar
	mov	DWORD PTR [edi], 0
	pop	edi
	pop	esi
	pop	ebx
	ret	4
$LN88@scalar:
	mov	eax, edi
$LN79@scalar:
	pop	edi
	pop	esi
	pop	ebx
	ret	4
??_GCPGDef@PS@@QAEPAXI@Z ENDP				; PS::CPGDef::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleEffectDef.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xrstring.h
;	COMDAT ??_GCPEDef@PS@@QAEPAXI@Z
_TEXT	SEGMENT
___flags$dead$ = 8					; size = 4
??_GCPEDef@PS@@QAEPAXI@Z PROC				; PS::CPEDef::`scalar deleting destructor', COMDAT
; _this$ = ecx
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleEffectDef.cpp

; 39   : }

	push	esi
	mov	esi, ecx
	lea	ecx, DWORD PTR [esi+48]
	call	DWORD PTR __imp_??1CMemoryWriter@@UAE@XZ
	lea	ecx, DWORD PTR [esi+16]
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 64   : 						~resptr_core	()												{	_dec();						}

	call	DWORD PTR __imp_?_dec@?$resptr_base@UShader@@@@IAEXXZ
; File I:\Vitalya\mine\NSProjectX\xrCore\xrstring.h

; 50   : 	void				_dec		()								{	if (0==p_) return;	p_->dwReference--; 	if (0==p_->dwReference)	p_=0;						}

	mov	eax, DWORD PTR [esi+12]
	test	eax, eax
	je	SHORT $LN12@scalar
	dec	DWORD PTR [eax]
	mov	eax, DWORD PTR [esi+12]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN12@scalar
	mov	DWORD PTR [esi+12], 0
$LN12@scalar:
	mov	eax, DWORD PTR [esi+8]
	test	eax, eax
	je	SHORT $LN18@scalar
	dec	DWORD PTR [eax]
	mov	eax, DWORD PTR [esi+8]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN18@scalar
	mov	DWORD PTR [esi+8], 0
$LN18@scalar:
	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN27@scalar
	dec	DWORD PTR [eax]
	mov	eax, DWORD PTR [esi]
	cmp	DWORD PTR [eax], 0
	mov	eax, esi
	jne	SHORT $LN24@scalar
	mov	DWORD PTR [esi], 0
	pop	esi
	ret	4
$LN27@scalar:
	mov	eax, esi
$LN24@scalar:
	pop	esi
	ret	4
??_GCPEDef@PS@@QAEPAXI@Z ENDP				; PS::CPEDef::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Getal@?$vector@PAVCPGDef@PS@@V?$xalloc@PAVCPGDef@PS@@@@@std@@ABEABV?$xalloc@PAVCPGDef@PS@@@@XZ
_TEXT	SEGMENT
?_Getal@?$vector@PAVCPGDef@PS@@V?$xalloc@PAVCPGDef@PS@@@@@std@@ABEABV?$xalloc@PAVCPGDef@PS@@@@XZ PROC ; std::vector<PS::CPGDef *,xalloc<PS::CPGDef *> >::_Getal, COMDAT
; _this$ = ecx

; 1809 :         return _Mypair._Get_first();

	mov	eax, ecx

; 1810 :     }

	ret	0
?_Getal@?$vector@PAVCPGDef@PS@@V?$xalloc@PAVCPGDef@PS@@@@@std@@ABEABV?$xalloc@PAVCPGDef@PS@@@@XZ ENDP ; std::vector<PS::CPGDef *,xalloc<PS::CPGDef *> >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Umove_if_noexcept1@?$vector@PAVCPGDef@PS@@V?$xalloc@PAVCPGDef@PS@@@@@std@@AAEXPAPAVCPGDef@PS@@00U?$integral_constant@_N$00@2@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
?_Umove_if_noexcept1@?$vector@PAVCPGDef@PS@@V?$xalloc@PAVCPGDef@PS@@@@@std@@AAEXPAPAVCPGDef@PS@@00U?$integral_constant@_N$00@2@@Z PROC ; std::vector<PS::CPGDef *,xalloc<PS::CPGDef *> >::_Umove_if_noexcept1, COMDAT
; _this$dead$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1703 :     auto _UFirst      = _Get_unwrapped(_First);

	mov	eax, DWORD PTR __First$[esp-4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1649 :     _CONSTEXPR20_CONTAINER void _Umove_if_noexcept1(pointer _First, pointer _Last, pointer _Dest, true_type) {

	push	esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	mov	esi, DWORD PTR __Last$[esp]
	cmp	eax, esi
	je	SHORT $LN5@Umove_if_n

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	edx, DWORD PTR __Dest$[esp]
	sub	edx, eax
$LL6@Umove_if_n:

; 1620 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx+eax], ecx

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	add	eax, 4
	cmp	eax, esi
	jne	SHORT $LL6@Umove_if_n
$LN5@Umove_if_n:
	pop	esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1652 :     }

	ret	16					; 00000010H
?_Umove_if_noexcept1@?$vector@PAVCPGDef@PS@@V?$xalloc@PAVCPGDef@PS@@@@@std@@AAEXPAPAVCPGDef@PS@@00U?$integral_constant@_N$00@2@@Z ENDP ; std::vector<PS::CPGDef *,xalloc<PS::CPGDef *> >::_Umove_if_noexcept1
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?capacity@?$vector@PAVCPGDef@PS@@V?$xalloc@PAVCPGDef@PS@@@@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@PAVCPGDef@PS@@V?$xalloc@PAVCPGDef@PS@@@@@std@@QBEIXZ PROC ; std::vector<PS::CPGDef *,xalloc<PS::CPGDef *> >::capacity, COMDAT
; _this$ = ecx

; 1545 :         auto& _My_data = _Mypair._Myval2;
; 1546 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx]
	sar	eax, 2

; 1547 :     }

	ret	0
?capacity@?$vector@PAVCPGDef@PS@@V?$xalloc@PAVCPGDef@PS@@@@@std@@QBEIXZ ENDP ; std::vector<PS::CPGDef *,xalloc<PS::CPGDef *> >::capacity
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?max_size@?$_Normal_allocator_traits@V?$xalloc@PAVCPGDef@PS@@@@@std@@SAIABV?$xalloc@PAVCPGDef@PS@@@@@Z
_TEXT	SEGMENT
?max_size@?$_Normal_allocator_traits@V?$xalloc@PAVCPGDef@PS@@@@@std@@SAIABV?$xalloc@PAVCPGDef@PS@@@@@Z PROC ; std::_Normal_allocator_traits<xalloc<PS::CPGDef *> >::max_size, COMDAT
; __Al$dead$ = ecx

; 591  :         if constexpr (_Has_max_size<_Alloc>::value) {
; 592  :             return _Al.max_size();

	mov	eax, 1073741823				; 3fffffffH

; 593  :         } else {
; 594  :             return (numeric_limits<size_type>::max)() / sizeof(value_type);
; 595  :         }
; 596  :     }

	ret	0
?max_size@?$_Normal_allocator_traits@V?$xalloc@PAVCPGDef@PS@@@@@std@@SAIABV?$xalloc@PAVCPGDef@PS@@@@@Z ENDP ; std::_Normal_allocator_traits<xalloc<PS::CPGDef *> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Getal@?$vector@PAVCPEDef@PS@@V?$xalloc@PAVCPEDef@PS@@@@@std@@ABEABV?$xalloc@PAVCPEDef@PS@@@@XZ
_TEXT	SEGMENT
?_Getal@?$vector@PAVCPEDef@PS@@V?$xalloc@PAVCPEDef@PS@@@@@std@@ABEABV?$xalloc@PAVCPEDef@PS@@@@XZ PROC ; std::vector<PS::CPEDef *,xalloc<PS::CPEDef *> >::_Getal, COMDAT
; _this$ = ecx

; 1809 :         return _Mypair._Get_first();

	mov	eax, ecx

; 1810 :     }

	ret	0
?_Getal@?$vector@PAVCPEDef@PS@@V?$xalloc@PAVCPEDef@PS@@@@@std@@ABEABV?$xalloc@PAVCPEDef@PS@@@@XZ ENDP ; std::vector<PS::CPEDef *,xalloc<PS::CPEDef *> >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Umove_if_noexcept1@?$vector@PAVCPEDef@PS@@V?$xalloc@PAVCPEDef@PS@@@@@std@@AAEXPAPAVCPEDef@PS@@00U?$integral_constant@_N$00@2@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
?_Umove_if_noexcept1@?$vector@PAVCPEDef@PS@@V?$xalloc@PAVCPEDef@PS@@@@@std@@AAEXPAPAVCPEDef@PS@@00U?$integral_constant@_N$00@2@@Z PROC ; std::vector<PS::CPEDef *,xalloc<PS::CPEDef *> >::_Umove_if_noexcept1, COMDAT
; _this$dead$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1703 :     auto _UFirst      = _Get_unwrapped(_First);

	mov	eax, DWORD PTR __First$[esp-4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1649 :     _CONSTEXPR20_CONTAINER void _Umove_if_noexcept1(pointer _First, pointer _Last, pointer _Dest, true_type) {

	push	esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	mov	esi, DWORD PTR __Last$[esp]
	cmp	eax, esi
	je	SHORT $LN5@Umove_if_n

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	edx, DWORD PTR __Dest$[esp]
	sub	edx, eax
$LL6@Umove_if_n:

; 1620 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx+eax], ecx

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	add	eax, 4
	cmp	eax, esi
	jne	SHORT $LL6@Umove_if_n
$LN5@Umove_if_n:
	pop	esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1652 :     }

	ret	16					; 00000010H
?_Umove_if_noexcept1@?$vector@PAVCPEDef@PS@@V?$xalloc@PAVCPEDef@PS@@@@@std@@AAEXPAPAVCPEDef@PS@@00U?$integral_constant@_N$00@2@@Z ENDP ; std::vector<PS::CPEDef *,xalloc<PS::CPEDef *> >::_Umove_if_noexcept1
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?capacity@?$vector@PAVCPEDef@PS@@V?$xalloc@PAVCPEDef@PS@@@@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@PAVCPEDef@PS@@V?$xalloc@PAVCPEDef@PS@@@@@std@@QBEIXZ PROC ; std::vector<PS::CPEDef *,xalloc<PS::CPEDef *> >::capacity, COMDAT
; _this$ = ecx

; 1545 :         auto& _My_data = _Mypair._Myval2;
; 1546 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx]
	sar	eax, 2

; 1547 :     }

	ret	0
?capacity@?$vector@PAVCPEDef@PS@@V?$xalloc@PAVCPEDef@PS@@@@@std@@QBEIXZ ENDP ; std::vector<PS::CPEDef *,xalloc<PS::CPEDef *> >::capacity
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?max_size@?$_Normal_allocator_traits@V?$xalloc@PAVCPEDef@PS@@@@@std@@SAIABV?$xalloc@PAVCPEDef@PS@@@@@Z
_TEXT	SEGMENT
?max_size@?$_Normal_allocator_traits@V?$xalloc@PAVCPEDef@PS@@@@@std@@SAIABV?$xalloc@PAVCPEDef@PS@@@@@Z PROC ; std::_Normal_allocator_traits<xalloc<PS::CPEDef *> >::max_size, COMDAT
; __Al$dead$ = ecx

; 591  :         if constexpr (_Has_max_size<_Alloc>::value) {
; 592  :             return _Al.max_size();

	mov	eax, 1073741823				; 3fffffffH

; 593  :         } else {
; 594  :             return (numeric_limits<size_type>::max)() / sizeof(value_type);
; 595  :         }
; 596  :     }

	ret	0
?max_size@?$_Normal_allocator_traits@V?$xalloc@PAVCPEDef@PS@@@@@std@@SAIABV?$xalloc@PAVCPEDef@PS@@@@@Z ENDP ; std::_Normal_allocator_traits<xalloc<PS::CPEDef *> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$xalloc@PAVCPGDef@PS@@@@V?$_Vector_val@U?$_Simple_types@PAVCPGDef@PS@@@std@@@std@@$00@std@@QBEABV?$xalloc@PAVCPGDef@PS@@@@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@V?$xalloc@PAVCPGDef@PS@@@@V?$_Vector_val@U?$_Simple_types@PAVCPGDef@PS@@@std@@@std@@$00@std@@QBEABV?$xalloc@PAVCPGDef@PS@@@@XZ PROC ; std::_Compressed_pair<xalloc<PS::CPGDef *>,std::_Vector_val<std::_Simple_types<PS::CPGDef *> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 1343 :         return *this;

	mov	eax, ecx

; 1344 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$xalloc@PAVCPGDef@PS@@@@V?$_Vector_val@U?$_Simple_types@PAVCPGDef@PS@@@std@@@std@@$00@std@@QBEABV?$xalloc@PAVCPGDef@PS@@@@XZ ENDP ; std::_Compressed_pair<xalloc<PS::CPGDef *>,std::_Vector_val<std::_Simple_types<PS::CPGDef *> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?max_size@?$xalloc@PAVCPGDef@PS@@@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$xalloc@PAVCPGDef@PS@@@@QBEIXZ PROC		; xalloc<PS::CPGDef *>::max_size, COMDAT
; _this$dead$ = ecx

; 86   : 							size_type				max_size		() const								{	size_type _Count = (size_type)(-1) / sizeof (T);	return (0 < _Count ? _Count : 1);	}

	mov	eax, 1073741823				; 3fffffffH
	ret	0
?max_size@?$xalloc@PAVCPGDef@PS@@@@QBEIXZ ENDP		; xalloc<PS::CPGDef *>::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$xalloc@PAVCPEDef@PS@@@@V?$_Vector_val@U?$_Simple_types@PAVCPEDef@PS@@@std@@@std@@$00@std@@QBEABV?$xalloc@PAVCPEDef@PS@@@@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@V?$xalloc@PAVCPEDef@PS@@@@V?$_Vector_val@U?$_Simple_types@PAVCPEDef@PS@@@std@@@std@@$00@std@@QBEABV?$xalloc@PAVCPEDef@PS@@@@XZ PROC ; std::_Compressed_pair<xalloc<PS::CPEDef *>,std::_Vector_val<std::_Simple_types<PS::CPEDef *> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 1343 :         return *this;

	mov	eax, ecx

; 1344 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$xalloc@PAVCPEDef@PS@@@@V?$_Vector_val@U?$_Simple_types@PAVCPEDef@PS@@@std@@@std@@$00@std@@QBEABV?$xalloc@PAVCPEDef@PS@@@@XZ ENDP ; std::_Compressed_pair<xalloc<PS::CPEDef *>,std::_Vector_val<std::_Simple_types<PS::CPEDef *> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?max_size@?$xalloc@PAVCPEDef@PS@@@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$xalloc@PAVCPEDef@PS@@@@QBEIXZ PROC		; xalloc<PS::CPEDef *>::max_size, COMDAT
; _this$dead$ = ecx

; 86   : 							size_type				max_size		() const								{	size_type _Count = (size_type)(-1) / sizeof (T);	return (0 < _Count ? _Count : 1);	}

	mov	eax, 1073741823				; 3fffffffH
	ret	0
?max_size@?$xalloc@PAVCPEDef@PS@@@@QBEIXZ ENDP		; xalloc<PS::CPEDef *>::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_Adl_verify_range@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPEDef@PS@@@std@@@std@@@std@@V12@@std@@YAXABV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPEDef@PS@@@std@@@std@@@0@0@Z
_TEXT	SEGMENT
??$_Adl_verify_range@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPEDef@PS@@@std@@@std@@@std@@V12@@std@@YAXABV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPEDef@PS@@@std@@@std@@@0@0@Z PROC ; std::_Adl_verify_range<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<PS::CPEDef *> > >,std::_Vector_iterator<std::_Vector_val<std::_Simple_types<PS::CPEDef *> > > >, COMDAT
; __First$dead$ = ecx
; __Last$dead$ = edx

; 1259 :     // check that [_First, _Last) forms an iterator range
; 1260 :     if constexpr (_Range_verifiable_v<_Iter, _Sentinel>) {
; 1261 :         _Verify_range(_First, _Last);
; 1262 :     }
; 1263 : }

	ret	0
??$_Adl_verify_range@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPEDef@PS@@@std@@@std@@@std@@V12@@std@@YAXABV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPEDef@PS@@@std@@@std@@@0@0@Z ENDP ; std::_Adl_verify_range<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<PS::CPEDef *> > >,std::_Vector_iterator<std::_Vector_val<std::_Simple_types<PS::CPEDef *> > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$distance@PAPAVCPEDef@PS@@@std@@YAHPAPAVCPEDef@PS@@0@Z
_TEXT	SEGMENT
??$distance@PAPAVCPEDef@PS@@@std@@YAHPAPAVCPEDef@PS@@0@Z PROC ; std::distance<PS::CPEDef * *>, COMDAT
; __First$ = ecx
; __Last$ = edx

; 1524 :     if constexpr (_Is_random_iter_v<_InIt>) {
; 1525 :         return _Last - _First; // assume the iterator will do debug checking

	sub	edx, ecx
	sar	edx, 2
	mov	eax, edx

; 1526 :     } else {
; 1527 :         _Adl_verify_range(_First, _Last);
; 1528 :         auto _UFirst             = _Get_unwrapped(_First);
; 1529 :         const auto _ULast        = _Get_unwrapped(_Last);
; 1530 :         _Iter_diff_t<_InIt> _Off = 0;
; 1531 :         for (; _UFirst != _ULast; ++_UFirst) {
; 1532 :             ++_Off;
; 1533 :         }
; 1534 : 
; 1535 :         return _Off;
; 1536 :     }
; 1537 : }

	ret	0
??$distance@PAPAVCPEDef@PS@@@std@@YAHPAPAVCPEDef@PS@@0@Z ENDP ; std::distance<PS::CPEDef * *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$next@PAPAVCPEDef@PS@@@std@@YAPAPAVCPEDef@PS@@PAPAV12@H@Z
_TEXT	SEGMENT
??$next@PAPAVCPEDef@PS@@@std@@YAPAPAVCPEDef@PS@@PAPAV12@H@Z PROC ; std::next<PS::CPEDef * *>, COMDAT
; __First$ = ecx
; __Off$ = edx

; 1497 :         _Where += _Off;

	lea	eax, DWORD PTR [ecx+edx*4]

; 1546 :     static_assert(_Is_input_iter_v<_InIt>, "next requires input iterator");
; 1547 : 
; 1548 :     _STD advance(_First, _Off);
; 1549 :     return _First;
; 1550 : }

	ret	0
??$next@PAPAVCPEDef@PS@@@std@@YAPAPAVCPEDef@PS@@PAPAV12@H@Z ENDP ; std::next<PS::CPEDef * *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_Next_iter@PAPAVCPEDef@PS@@@std@@YAPAPAVCPEDef@PS@@PAPAV12@@Z
_TEXT	SEGMENT
??$_Next_iter@PAPAVCPEDef@PS@@@std@@YAPAPAVCPEDef@PS@@PAPAV12@@Z PROC ; std::_Next_iter<PS::CPEDef * *>, COMDAT
; __First$ = ecx

; 1541 :     return ++_First;

	lea	eax, DWORD PTR [ecx+4]

; 1542 : }

	ret	0
??$_Next_iter@PAPAVCPEDef@PS@@@std@@YAPAPAVCPEDef@PS@@PAPAV12@@Z ENDP ; std::_Next_iter<PS::CPEDef * *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_Seek_wrapped@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPEDef@PS@@@std@@@std@@@std@@AAPAPAVCPEDef@PS@@@std@@YAXAAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPEDef@PS@@@std@@@std@@@0@AAPAPAVCPEDef@PS@@@Z
_TEXT	SEGMENT
??$_Seek_wrapped@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPEDef@PS@@@std@@@std@@@std@@AAPAPAVCPEDef@PS@@@std@@YAXAAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPEDef@PS@@@std@@@std@@@0@AAPAPAVCPEDef@PS@@@Z PROC ; std::_Seek_wrapped<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<PS::CPEDef *> > >,PS::CPEDef * * &>, COMDAT
; __It$ = ecx
; __UIt$ = edx

; 1375 :     if constexpr (_Wrapped_seekable_v<_Iter, _UIter>) {
; 1376 :         _It._Seek_to(_STD forward<_UIter>(_UIt));

	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax

; 1377 :     } else {
; 1378 :         _It = _STD forward<_UIter>(_UIt);
; 1379 :     }
; 1380 : }

	ret	0
??$_Seek_wrapped@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPEDef@PS@@@std@@@std@@@std@@AAPAPAVCPEDef@PS@@@std@@YAXAAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPEDef@PS@@@std@@@std@@@0@AAPAPAVCPEDef@PS@@@Z ENDP ; std::_Seek_wrapped<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<PS::CPEDef *> > >,PS::CPEDef * * &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_Adl_verify_range@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPGDef@PS@@@std@@@std@@@std@@V12@@std@@YAXABV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPGDef@PS@@@std@@@std@@@0@0@Z
_TEXT	SEGMENT
??$_Adl_verify_range@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPGDef@PS@@@std@@@std@@@std@@V12@@std@@YAXABV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPGDef@PS@@@std@@@std@@@0@0@Z PROC ; std::_Adl_verify_range<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<PS::CPGDef *> > >,std::_Vector_iterator<std::_Vector_val<std::_Simple_types<PS::CPGDef *> > > >, COMDAT
; __First$dead$ = ecx
; __Last$dead$ = edx

; 1259 :     // check that [_First, _Last) forms an iterator range
; 1260 :     if constexpr (_Range_verifiable_v<_Iter, _Sentinel>) {
; 1261 :         _Verify_range(_First, _Last);
; 1262 :     }
; 1263 : }

	ret	0
??$_Adl_verify_range@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPGDef@PS@@@std@@@std@@@std@@V12@@std@@YAXABV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPGDef@PS@@@std@@@std@@@0@0@Z ENDP ; std::_Adl_verify_range<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<PS::CPGDef *> > >,std::_Vector_iterator<std::_Vector_val<std::_Simple_types<PS::CPGDef *> > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$distance@PAPAVCPGDef@PS@@@std@@YAHPAPAVCPGDef@PS@@0@Z
_TEXT	SEGMENT
??$distance@PAPAVCPGDef@PS@@@std@@YAHPAPAVCPGDef@PS@@0@Z PROC ; std::distance<PS::CPGDef * *>, COMDAT
; __First$ = ecx
; __Last$ = edx

; 1524 :     if constexpr (_Is_random_iter_v<_InIt>) {
; 1525 :         return _Last - _First; // assume the iterator will do debug checking

	sub	edx, ecx
	sar	edx, 2
	mov	eax, edx

; 1526 :     } else {
; 1527 :         _Adl_verify_range(_First, _Last);
; 1528 :         auto _UFirst             = _Get_unwrapped(_First);
; 1529 :         const auto _ULast        = _Get_unwrapped(_Last);
; 1530 :         _Iter_diff_t<_InIt> _Off = 0;
; 1531 :         for (; _UFirst != _ULast; ++_UFirst) {
; 1532 :             ++_Off;
; 1533 :         }
; 1534 : 
; 1535 :         return _Off;
; 1536 :     }
; 1537 : }

	ret	0
??$distance@PAPAVCPGDef@PS@@@std@@YAHPAPAVCPGDef@PS@@0@Z ENDP ; std::distance<PS::CPGDef * *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$next@PAPAVCPGDef@PS@@@std@@YAPAPAVCPGDef@PS@@PAPAV12@H@Z
_TEXT	SEGMENT
??$next@PAPAVCPGDef@PS@@@std@@YAPAPAVCPGDef@PS@@PAPAV12@H@Z PROC ; std::next<PS::CPGDef * *>, COMDAT
; __First$ = ecx
; __Off$ = edx

; 1497 :         _Where += _Off;

	lea	eax, DWORD PTR [ecx+edx*4]

; 1546 :     static_assert(_Is_input_iter_v<_InIt>, "next requires input iterator");
; 1547 : 
; 1548 :     _STD advance(_First, _Off);
; 1549 :     return _First;
; 1550 : }

	ret	0
??$next@PAPAVCPGDef@PS@@@std@@YAPAPAVCPGDef@PS@@PAPAV12@H@Z ENDP ; std::next<PS::CPGDef * *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_Next_iter@PAPAVCPGDef@PS@@@std@@YAPAPAVCPGDef@PS@@PAPAV12@@Z
_TEXT	SEGMENT
??$_Next_iter@PAPAVCPGDef@PS@@@std@@YAPAPAVCPGDef@PS@@PAPAV12@@Z PROC ; std::_Next_iter<PS::CPGDef * *>, COMDAT
; __First$ = ecx

; 1541 :     return ++_First;

	lea	eax, DWORD PTR [ecx+4]

; 1542 : }

	ret	0
??$_Next_iter@PAPAVCPGDef@PS@@@std@@YAPAPAVCPGDef@PS@@PAPAV12@@Z ENDP ; std::_Next_iter<PS::CPGDef * *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_Seek_wrapped@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPGDef@PS@@@std@@@std@@@std@@AAPAPAVCPGDef@PS@@@std@@YAXAAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPGDef@PS@@@std@@@std@@@0@AAPAPAVCPGDef@PS@@@Z
_TEXT	SEGMENT
??$_Seek_wrapped@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPGDef@PS@@@std@@@std@@@std@@AAPAPAVCPGDef@PS@@@std@@YAXAAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPGDef@PS@@@std@@@std@@@0@AAPAPAVCPGDef@PS@@@Z PROC ; std::_Seek_wrapped<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<PS::CPGDef *> > >,PS::CPGDef * * &>, COMDAT
; __It$ = ecx
; __UIt$ = edx

; 1375 :     if constexpr (_Wrapped_seekable_v<_Iter, _UIter>) {
; 1376 :         _It._Seek_to(_STD forward<_UIter>(_UIt));

	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax

; 1377 :     } else {
; 1378 :         _It = _STD forward<_UIter>(_UIt);
; 1379 :     }
; 1380 : }

	ret	0
??$_Seek_wrapped@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPGDef@PS@@@std@@@std@@@std@@AAPAPAVCPGDef@PS@@@std@@YAXAAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPGDef@PS@@@std@@@std@@@0@AAPAPAVCPGDef@PS@@@Z ENDP ; std::_Seek_wrapped<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<PS::CPGDef *> > >,PS::CPGDef * * &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_Pass_fn@P6A_NPBVCPEDef@PS@@0@Z$0A@@std@@YAP6A_NPBVCPEDef@PS@@0@ZP6A_N00@Z@Z
_TEXT	SEGMENT
??$_Pass_fn@P6A_NPBVCPEDef@PS@@0@Z$0A@@std@@YAP6A_NPBVCPEDef@PS@@0@ZP6A_N00@Z@Z PROC ; std::_Pass_fn<bool (__cdecl*)(PS::CPEDef const *,PS::CPEDef const *),0>, COMDAT
; __Val$dead$ = ecx

; 253  :     return _Val;

	mov	eax, OFFSET ?ped_sort_pred@@YA_NPBVCPEDef@PS@@0@Z ; ped_sort_pred

; 254  : }

	ret	0
??$_Pass_fn@P6A_NPBVCPEDef@PS@@0@Z$0A@@std@@YAP6A_NPBVCPEDef@PS@@0@ZP6A_N00@Z@Z ENDP ; std::_Pass_fn<bool (__cdecl*)(PS::CPEDef const *,PS::CPEDef const *),0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
;	COMDAT ??$_Sort_unchecked@PAPAVCPEDef@PS@@P6A_NPBV12@0@Z@std@@YAXPAPAVCPEDef@PS@@0HP6A_NPBV12@1@Z@Z
_TEXT	SEGMENT
__Last$1$ = -28						; size = 4
__Hole$1$ = -24						; size = 4
__Val$1$ = -24						; size = 4
__Hole$1$ = -20						; size = 4
__Val$1$ = -20						; size = 4
__Mid$1$ = -16						; size = 4
__Max_sequence_non_leaf$1$ = -16			; size = 4
__First$1$ = -12					; size = 4
__Bottom$1$ = -12					; size = 4
tv742 = -8						; size = 4
__Val$1 = -8						; size = 4
__Mid$2 = -8						; size = 8
__Ideal$ = 8						; size = 4
__Pred$ = 12						; size = 4
??$_Sort_unchecked@PAPAVCPEDef@PS@@P6A_NPBV12@0@Z@std@@YAXPAPAVCPEDef@PS@@0HP6A_NPBV12@1@Z@Z PROC ; std::_Sort_unchecked<PS::CPEDef * *,bool (__cdecl*)(PS::CPEDef const *,PS::CPEDef const *)>, COMDAT
; __First$ = ecx
; __Last$ = edx

; 7046 : _CONSTEXPR20 void _Sort_unchecked(_RanIt _First, _RanIt _Last, _Iter_diff_t<_RanIt> _Ideal, _Pr _Pred) {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	sub	esp, 28					; 0000001cH
	push	ebx
	mov	ebx, edx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR __Last$1$[esp+36], ebx

; 7047 :     // order [_First, _Last)
; 7048 :     for (;;) {
; 7049 :         if (_Last - _First <= _ISORT_MAX) { // small

	mov	ecx, DWORD PTR __Pred$[ebp]
	mov	eax, ebx
	sub	eax, esi
	mov	DWORD PTR __First$1$[esp+36], esi
	and	eax, -4					; fffffffcH
	push	edi
	cmp	eax, 128				; 00000080H
	jle	SHORT $LN165@Sort_unche
	mov	edi, DWORD PTR __Ideal$[ebp]
	npad	4
$LL2@Sort_unche:

; 7050 :             _Insertion_sort_unchecked(_First, _Last, _Pred);
; 7051 :             return;
; 7052 :         }
; 7053 : 
; 7054 :         if (_Ideal <= 0) { // heap sort if too many divisions

	test	edi, edi
	jle	$LN166@Sort_unche

; 7055 :             _Make_heap_unchecked(_First, _Last, _Pred);
; 7056 :             _Sort_heap_unchecked(_First, _Last, _Pred);
; 7057 :             return;
; 7058 :         }
; 7059 : 
; 7060 :         // divide and conquer by quicksort
; 7061 :         auto _Mid = _Partition_by_median_guess_unchecked(_First, _Last, _Pred);

	push	ecx
	push	ebx
	mov	edx, esi
	lea	ecx, DWORD PTR __Mid$2[esp+48]
	call	??$_Partition_by_median_guess_unchecked@PAPAVCPEDef@PS@@P6A_NPBV12@0@Z@std@@YA?AU?$pair@PAPAVCPEDef@PS@@PAPAV12@@0@PAPAVCPEDef@PS@@0P6A_NPBV23@1@Z@Z ; std::_Partition_by_median_guess_unchecked<PS::CPEDef * *,bool (__cdecl*)(PS::CPEDef const *,PS::CPEDef const *)>

; 7062 : 
; 7063 :         _Ideal = (_Ideal >> 1) + (_Ideal >> 2); // allow 1.5 log2(N) divisions
; 7064 : 
; 7065 :         if (_Mid.first - _First < _Last - _Mid.second) { // loop on second half

	mov	edx, DWORD PTR __Mid$2[esp+48]
	mov	eax, edi
	sar	eax, 2
	mov	ecx, ebx
	sub	ecx, DWORD PTR __Mid$2[esp+52]
	add	esp, 8
	sar	edi, 1
	and	ecx, -4					; fffffffcH
	add	edi, eax
	mov	eax, edx
	sub	eax, esi
	and	eax, -4					; fffffffcH
	cmp	eax, ecx
	mov	eax, DWORD PTR __Pred$[ebp]
	push	eax
	push	edi
	jge	SHORT $LN7@Sort_unche

; 7066 :             _Sort_unchecked(_First, _Mid.first, _Ideal, _Pred);

	mov	ecx, esi
	call	??$_Sort_unchecked@PAPAVCPEDef@PS@@P6A_NPBV12@0@Z@std@@YAXPAPAVCPEDef@PS@@0HP6A_NPBV12@1@Z@Z ; std::_Sort_unchecked<PS::CPEDef * *,bool (__cdecl*)(PS::CPEDef const *,PS::CPEDef const *)>

; 7067 :             _First = _Mid.second;

	mov	esi, DWORD PTR __Mid$2[esp+52]
	mov	DWORD PTR __First$1$[esp+48], esi

; 7068 :         } else { // loop on first half

	jmp	SHORT $LN190@Sort_unche
$LN7@Sort_unche:

; 7069 :             _Sort_unchecked(_Mid.second, _Last, _Ideal, _Pred);

	mov	ecx, DWORD PTR __Mid$2[esp+52]
	mov	edx, ebx
	call	??$_Sort_unchecked@PAPAVCPEDef@PS@@P6A_NPBV12@0@Z@std@@YAXPAPAVCPEDef@PS@@0HP6A_NPBV12@1@Z@Z ; std::_Sort_unchecked<PS::CPEDef * *,bool (__cdecl*)(PS::CPEDef const *,PS::CPEDef const *)>

; 7070 :             _Last = _Mid.first;

	mov	ebx, DWORD PTR __Mid$2[esp+48]
	mov	DWORD PTR __Last$1$[esp+48], ebx
$LN190@Sort_unche:

; 7047 :     // order [_First, _Last)
; 7048 :     for (;;) {
; 7049 :         if (_Last - _First <= _ISORT_MAX) { // small

	mov	ecx, DWORD PTR __Pred$[ebp]
	mov	eax, ebx
	sub	eax, esi
	add	esp, 8
	and	eax, -4					; fffffffcH
	cmp	eax, 128				; 00000080H
	jg	SHORT $LL2@Sort_unche
$LN165@Sort_unche:

; 6921 :     if (_First != _Last) {

	cmp	esi, ebx
	je	$LN45@Sort_unche

; 6922 :         for (_BidIt _Mid = _First; ++_Mid != _Last;) { // order next element

	lea	ebx, DWORD PTR [esi+4]
	mov	DWORD PTR __Mid$1$[esp+40], ebx
	cmp	ebx, DWORD PTR __Last$1$[esp+40]
	je	$LN45@Sort_unche
	npad	1
$LL11@Sort_unche:

; 6923 :             _BidIt _Hole               = _Mid;
; 6924 :             _Iter_value_t<_BidIt> _Val = _STD move(*_Mid);
; 6925 : 
; 6926 :             if (_DEBUG_LT_PRED(_Pred, _Val, *_First)) { // found new earliest element, move to front

	push	DWORD PTR [esi]
	mov	edi, DWORD PTR [ebx]
	push	edi
	mov	DWORD PTR __Hole$1$[esp+48], ebx
	mov	DWORD PTR __Val$1$[esp+48], edi
	call	ecx
	add	esp, 8
	test	al, al
	je	$LN18@Sort_unche
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility

; 4254 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	mov	ecx, ebx

; 4255 :     auto _Result                = _CSTD memmove(_Dest_ch - _Count, _First_ch, _Count);

	mov	eax, ebx
	sub	ecx, esi
	push	ecx
	sub	eax, ecx
	add	eax, 4
	push	esi
	push	eax
	call	_memmove
	add	esp, 12					; 0000000cH
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 6928 :                 *_First = _STD move(_Val);

	mov	DWORD PTR [esi], edi

; 6929 :             } else { // look for insertion point after first

	jmp	$LN19@Sort_unche
$LN166@Sort_unche:

; 5547 :     _Diff _Bottom = _Last - _First;

	sub	ebx, esi
	mov	eax, ebx
	mov	DWORD PTR __Last$1$[esp+40], ebx
	sar	eax, 2

; 5548 :     for (_Diff _Hole = _Bottom >> 1; _Hole > 0;) { // shift for codegen

	mov	edx, eax
	mov	DWORD PTR __Bottom$1$[esp+40], eax
	sar	edx, 1
	test	edx, edx
	jle	$LN29@Sort_unche
	dec	eax
	mov	DWORD PTR tv742[esp+40], eax
	sar	eax, 1
	mov	DWORD PTR __Max_sequence_non_leaf$1$[esp+40], eax
	npad	3
$LL28@Sort_unche:

; 5549 :         // reheap top half, bottom to top
; 5550 :         --_Hole;
; 5551 :         _Iter_value_t<_RanIt> _Val = _STD move(*(_First + _Hole));

	mov	ebx, DWORD PTR [esi+edx*4-4]
	dec	edx
	mov	DWORD PTR __Val$1$[esp+40], ebx

; 5552 :         _Pop_heap_hole_by_index(_First, _Hole, _Bottom, _STD move(_Val), _Pred);

	mov	ebx, edx
	mov	DWORD PTR __Hole$1$[esp+40], edx

; 5381 :     _Diff _Idx       = _Hole;

	mov	edi, edx

; 5382 : 
; 5383 :     // Check whether _Idx can have a child before calculating that child's index, since
; 5384 :     // calculating the child's index can trigger integer overflows
; 5385 :     const _Diff _Max_sequence_non_leaf = (_Bottom - 1) >> 1; // shift for codegen
; 5386 :     while (_Idx < _Max_sequence_non_leaf) { // move _Hole down to larger child

	cmp	edx, eax
	jge	SHORT $LN34@Sort_unche
	npad	11
$LL33@Sort_unche:

; 5387 :         _Idx = 2 * _Idx + 2;
; 5388 :         if (_DEBUG_LT_PRED(_Pred, *(_First + _Idx), *(_First + (_Idx - 1)))) {

	push	DWORD PTR [esi+edi*8+4]
	lea	edi, DWORD PTR [edi*2+2]
	push	DWORD PTR [esi+edi*4]
	call	ecx
	add	esp, 8
	test	al, al
	je	SHORT $LN35@Sort_unche

; 5389 :             --_Idx;

	dec	edi
$LN35@Sort_unche:

; 5390 :         }
; 5391 :         *(_First + _Hole) = _STD move(*(_First + _Idx));

	mov	eax, DWORD PTR [esi+edi*4]
	mov	ecx, DWORD PTR __Pred$[ebp]
	mov	DWORD PTR [esi+ebx*4], eax

; 5392 :         _Hole             = _Idx;

	mov	ebx, edi
	mov	eax, DWORD PTR __Max_sequence_non_leaf$1$[esp+40]
	cmp	edi, eax
	jl	SHORT $LL33@Sort_unche
	mov	edx, DWORD PTR __Hole$1$[esp+40]
$LN34@Sort_unche:

; 5393 :     }
; 5394 : 
; 5395 :     if (_Idx == _Max_sequence_non_leaf && _Bottom % 2 == 0) { // only child at bottom, move _Hole down to it

	cmp	edi, eax
	jne	SHORT $LN36@Sort_unche
	mov	eax, DWORD PTR __Bottom$1$[esp+40]
	test	al, 1
	jne	SHORT $LN36@Sort_unche

; 5396 :         *(_First + _Hole) = _STD move(*(_First + (_Bottom - 1)));

	mov	eax, DWORD PTR [esi+eax*4-4]
	mov	DWORD PTR [esi+ebx*4], eax

; 5397 :         _Hole             = _Bottom - 1;

	mov	ebx, DWORD PTR tv742[esp+40]
$LN36@Sort_unche:

; 5268 :          _Top < _Hole && _DEBUG_LT_PRED(_Pred, *(_First + _Idx), _Val); //

	cmp	edx, ebx
	jge	SHORT $LN40@Sort_unche
	npad	6
$LL41@Sort_unche:
	push	DWORD PTR __Val$1$[esp+40]
	lea	edi, DWORD PTR [ebx-1]
	sar	edi, 1
	push	DWORD PTR [esi+edi*4]
	call	ecx
	mov	edx, DWORD PTR __Hole$1$[esp+48]
	add	esp, 8
	test	al, al
	je	SHORT $LN40@Sort_unche

; 5269 :          _Idx = (_Hole - 1) >> 1) { // shift for codegen
; 5270 :         // move _Hole up to parent
; 5271 :         *(_First + _Hole) = _STD move(*(_First + _Idx));

	mov	eax, DWORD PTR [esi+edi*4]
	mov	ecx, DWORD PTR __Pred$[ebp]
	mov	DWORD PTR [esi+ebx*4], eax

; 5272 :         _Hole             = _Idx;

	mov	ebx, edi
	cmp	edx, edi
	jl	SHORT $LL41@Sort_unche
$LN40@Sort_unche:

; 5273 :     }
; 5274 : 
; 5275 :     *(_First + _Hole) = _STD forward<_Ty>(_Val); // drop _Val into final hole

	mov	eax, DWORD PTR __Val$1$[esp+40]

; 5548 :     for (_Diff _Hole = _Bottom >> 1; _Hole > 0;) { // shift for codegen

	mov	ecx, DWORD PTR __Pred$[ebp]

; 5275 :     *(_First + _Hole) = _STD forward<_Ty>(_Val); // drop _Val into final hole

	mov	DWORD PTR [esi+ebx*4], eax

; 5548 :     for (_Diff _Hole = _Bottom >> 1; _Hole > 0;) { // shift for codegen

	mov	eax, DWORD PTR __Max_sequence_non_leaf$1$[esp+40]
	test	edx, edx
	jg	$LL28@Sort_unche
	mov	ebx, DWORD PTR __Last$1$[esp+40]
	mov	eax, DWORD PTR __Bottom$1$[esp+40]
$LN29@Sort_unche:

; 5774 :     for (; _Last - _First >= 2; --_Last) {

	cmp	eax, 2
	jl	$LN45@Sort_unche
	npad	1
$LL46@Sort_unche:

; 5419 :         _Iter_value_t<_RanIt> _Val = _STD move(*_Last);

	mov	eax, DWORD PTR [ebx+esi-4]

; 5410 :     _Pop_heap_hole_by_index(

	xor	edx, edx

; 5419 :         _Iter_value_t<_RanIt> _Val = _STD move(*_Last);

	mov	DWORD PTR __Val$1[esp+40], eax

; 5408 :     *_Dest      = _STD move(*_First);

	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [ebx+esi-4], eax

; 5409 :     using _Diff = _Iter_diff_t<_RanIt>;
; 5410 :     _Pop_heap_hole_by_index(

	lea	eax, DWORD PTR __Val$1[esp+40]
	push	ecx
	push	eax
	lea	eax, DWORD PTR [ebx-4]
	mov	ecx, esi
	sar	eax, 2
	push	eax
	call	??$_Pop_heap_hole_by_index@PAPAVCPEDef@PS@@PAV12@P6A_NPBV12@0@Z@std@@YAXPAPAVCPEDef@PS@@HH$$QAPAV12@P6A_NPBV12@2@Z@Z ; std::_Pop_heap_hole_by_index<PS::CPEDef * *,PS::CPEDef *,bool (__cdecl*)(PS::CPEDef const *,PS::CPEDef const *)>

; 5774 :     for (; _Last - _First >= 2; --_Last) {

	mov	ecx, DWORD PTR __Pred$[ebp]
	sub	ebx, 4
	mov	eax, ebx

; 5410 :     _Pop_heap_hole_by_index(

	add	esp, 12					; 0000000cH

; 5774 :     for (; _Last - _First >= 2; --_Last) {

	and	eax, -4					; fffffffcH
	cmp	eax, 8
	jge	SHORT $LL46@Sort_unche

; 7071 :         }
; 7072 :     }
; 7073 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN18@Sort_unche:

; 6930 :                 for (_BidIt _Prev = _Hole; _DEBUG_LT_PRED(_Pred, _Val, *--_Prev); _Hole = _Prev) {

	push	DWORD PTR [ebx-4]
	mov	eax, DWORD PTR __Pred$[ebp]
	lea	edi, DWORD PTR [ebx-4]
	push	DWORD PTR __Val$1$[esp+44]
	call	eax
	add	esp, 8
	test	al, al
	je	SHORT $LN15@Sort_unche
	mov	esi, DWORD PTR __Val$1$[esp+40]
	mov	ebx, DWORD PTR __Hole$1$[esp+40]
	npad	4
$LL16@Sort_unche:

; 6931 :                     *_Hole = _STD move(*_Prev); // move hole down

	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR [ebx], eax
	mov	ebx, edi
	push	DWORD PTR [edi-4]
	sub	edi, 4
	push	esi
	call	DWORD PTR __Pred$[ebp]
	add	esp, 8
	test	al, al
	jne	SHORT $LL16@Sort_unche
	mov	esi, DWORD PTR __First$1$[esp+40]
	mov	DWORD PTR __Hole$1$[esp+40], ebx
	mov	ebx, DWORD PTR __Mid$1$[esp+40]
$LN15@Sort_unche:

; 6932 :                 }
; 6933 : 
; 6934 :                 *_Hole = _STD move(_Val); // insert element in hole

	mov	ecx, DWORD PTR __Hole$1$[esp+40]
	mov	eax, DWORD PTR __Val$1$[esp+40]
	mov	DWORD PTR [ecx], eax
$LN19@Sort_unche:

; 6922 :         for (_BidIt _Mid = _First; ++_Mid != _Last;) { // order next element

	mov	ecx, DWORD PTR __Pred$[ebp]
	add	ebx, 4
	mov	DWORD PTR __Mid$1$[esp+40], ebx
	cmp	ebx, DWORD PTR __Last$1$[esp+40]
	jne	$LL11@Sort_unche
$LN45@Sort_unche:

; 7071 :         }
; 7072 :     }
; 7073 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Sort_unchecked@PAPAVCPEDef@PS@@P6A_NPBV12@0@Z@std@@YAXPAPAVCPEDef@PS@@0HP6A_NPBV12@1@Z@Z ENDP ; std::_Sort_unchecked<PS::CPEDef * *,bool (__cdecl*)(PS::CPEDef const *,PS::CPEDef const *)>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_Pass_fn@P6A_NPBVCPGDef@PS@@0@Z$0A@@std@@YAP6A_NPBVCPGDef@PS@@0@ZP6A_N00@Z@Z
_TEXT	SEGMENT
??$_Pass_fn@P6A_NPBVCPGDef@PS@@0@Z$0A@@std@@YAP6A_NPBVCPGDef@PS@@0@ZP6A_N00@Z@Z PROC ; std::_Pass_fn<bool (__cdecl*)(PS::CPGDef const *,PS::CPGDef const *),0>, COMDAT
; __Val$dead$ = ecx

; 253  :     return _Val;

	mov	eax, OFFSET ?pgd_sort_pred@@YA_NPBVCPGDef@PS@@0@Z ; pgd_sort_pred

; 254  : }

	ret	0
??$_Pass_fn@P6A_NPBVCPGDef@PS@@0@Z$0A@@std@@YAP6A_NPBVCPGDef@PS@@0@ZP6A_N00@Z@Z ENDP ; std::_Pass_fn<bool (__cdecl*)(PS::CPGDef const *,PS::CPGDef const *),0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
;	COMDAT ??$_Sort_unchecked@PAPAVCPGDef@PS@@P6A_NPBV12@0@Z@std@@YAXPAPAVCPGDef@PS@@0HP6A_NPBV12@1@Z@Z
_TEXT	SEGMENT
__Last$1$ = -28						; size = 4
__Hole$1$ = -24						; size = 4
__Val$1$ = -24						; size = 4
__Hole$1$ = -20						; size = 4
__Val$1$ = -20						; size = 4
__Mid$1$ = -16						; size = 4
__Max_sequence_non_leaf$1$ = -16			; size = 4
__First$1$ = -12					; size = 4
__Bottom$1$ = -12					; size = 4
tv742 = -8						; size = 4
__Val$1 = -8						; size = 4
__Mid$2 = -8						; size = 8
__Ideal$ = 8						; size = 4
__Pred$ = 12						; size = 4
??$_Sort_unchecked@PAPAVCPGDef@PS@@P6A_NPBV12@0@Z@std@@YAXPAPAVCPGDef@PS@@0HP6A_NPBV12@1@Z@Z PROC ; std::_Sort_unchecked<PS::CPGDef * *,bool (__cdecl*)(PS::CPGDef const *,PS::CPGDef const *)>, COMDAT
; __First$ = ecx
; __Last$ = edx

; 7046 : _CONSTEXPR20 void _Sort_unchecked(_RanIt _First, _RanIt _Last, _Iter_diff_t<_RanIt> _Ideal, _Pr _Pred) {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	sub	esp, 28					; 0000001cH
	push	ebx
	mov	ebx, edx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR __Last$1$[esp+36], ebx

; 7047 :     // order [_First, _Last)
; 7048 :     for (;;) {
; 7049 :         if (_Last - _First <= _ISORT_MAX) { // small

	mov	ecx, DWORD PTR __Pred$[ebp]
	mov	eax, ebx
	sub	eax, esi
	mov	DWORD PTR __First$1$[esp+36], esi
	and	eax, -4					; fffffffcH
	push	edi
	cmp	eax, 128				; 00000080H
	jle	SHORT $LN165@Sort_unche
	mov	edi, DWORD PTR __Ideal$[ebp]
	npad	4
$LL2@Sort_unche:

; 7050 :             _Insertion_sort_unchecked(_First, _Last, _Pred);
; 7051 :             return;
; 7052 :         }
; 7053 : 
; 7054 :         if (_Ideal <= 0) { // heap sort if too many divisions

	test	edi, edi
	jle	$LN166@Sort_unche

; 7055 :             _Make_heap_unchecked(_First, _Last, _Pred);
; 7056 :             _Sort_heap_unchecked(_First, _Last, _Pred);
; 7057 :             return;
; 7058 :         }
; 7059 : 
; 7060 :         // divide and conquer by quicksort
; 7061 :         auto _Mid = _Partition_by_median_guess_unchecked(_First, _Last, _Pred);

	push	ecx
	push	ebx
	mov	edx, esi
	lea	ecx, DWORD PTR __Mid$2[esp+48]
	call	??$_Partition_by_median_guess_unchecked@PAPAVCPGDef@PS@@P6A_NPBV12@0@Z@std@@YA?AU?$pair@PAPAVCPGDef@PS@@PAPAV12@@0@PAPAVCPGDef@PS@@0P6A_NPBV23@1@Z@Z ; std::_Partition_by_median_guess_unchecked<PS::CPGDef * *,bool (__cdecl*)(PS::CPGDef const *,PS::CPGDef const *)>

; 7062 : 
; 7063 :         _Ideal = (_Ideal >> 1) + (_Ideal >> 2); // allow 1.5 log2(N) divisions
; 7064 : 
; 7065 :         if (_Mid.first - _First < _Last - _Mid.second) { // loop on second half

	mov	edx, DWORD PTR __Mid$2[esp+48]
	mov	eax, edi
	sar	eax, 2
	mov	ecx, ebx
	sub	ecx, DWORD PTR __Mid$2[esp+52]
	add	esp, 8
	sar	edi, 1
	and	ecx, -4					; fffffffcH
	add	edi, eax
	mov	eax, edx
	sub	eax, esi
	and	eax, -4					; fffffffcH
	cmp	eax, ecx
	mov	eax, DWORD PTR __Pred$[ebp]
	push	eax
	push	edi
	jge	SHORT $LN7@Sort_unche

; 7066 :             _Sort_unchecked(_First, _Mid.first, _Ideal, _Pred);

	mov	ecx, esi
	call	??$_Sort_unchecked@PAPAVCPGDef@PS@@P6A_NPBV12@0@Z@std@@YAXPAPAVCPGDef@PS@@0HP6A_NPBV12@1@Z@Z ; std::_Sort_unchecked<PS::CPGDef * *,bool (__cdecl*)(PS::CPGDef const *,PS::CPGDef const *)>

; 7067 :             _First = _Mid.second;

	mov	esi, DWORD PTR __Mid$2[esp+52]
	mov	DWORD PTR __First$1$[esp+48], esi

; 7068 :         } else { // loop on first half

	jmp	SHORT $LN190@Sort_unche
$LN7@Sort_unche:

; 7069 :             _Sort_unchecked(_Mid.second, _Last, _Ideal, _Pred);

	mov	ecx, DWORD PTR __Mid$2[esp+52]
	mov	edx, ebx
	call	??$_Sort_unchecked@PAPAVCPGDef@PS@@P6A_NPBV12@0@Z@std@@YAXPAPAVCPGDef@PS@@0HP6A_NPBV12@1@Z@Z ; std::_Sort_unchecked<PS::CPGDef * *,bool (__cdecl*)(PS::CPGDef const *,PS::CPGDef const *)>

; 7070 :             _Last = _Mid.first;

	mov	ebx, DWORD PTR __Mid$2[esp+48]
	mov	DWORD PTR __Last$1$[esp+48], ebx
$LN190@Sort_unche:

; 7047 :     // order [_First, _Last)
; 7048 :     for (;;) {
; 7049 :         if (_Last - _First <= _ISORT_MAX) { // small

	mov	ecx, DWORD PTR __Pred$[ebp]
	mov	eax, ebx
	sub	eax, esi
	add	esp, 8
	and	eax, -4					; fffffffcH
	cmp	eax, 128				; 00000080H
	jg	SHORT $LL2@Sort_unche
$LN165@Sort_unche:

; 6921 :     if (_First != _Last) {

	cmp	esi, ebx
	je	$LN45@Sort_unche

; 6922 :         for (_BidIt _Mid = _First; ++_Mid != _Last;) { // order next element

	lea	ebx, DWORD PTR [esi+4]
	mov	DWORD PTR __Mid$1$[esp+40], ebx
	cmp	ebx, DWORD PTR __Last$1$[esp+40]
	je	$LN45@Sort_unche
	npad	1
$LL11@Sort_unche:

; 6923 :             _BidIt _Hole               = _Mid;
; 6924 :             _Iter_value_t<_BidIt> _Val = _STD move(*_Mid);
; 6925 : 
; 6926 :             if (_DEBUG_LT_PRED(_Pred, _Val, *_First)) { // found new earliest element, move to front

	push	DWORD PTR [esi]
	mov	edi, DWORD PTR [ebx]
	push	edi
	mov	DWORD PTR __Hole$1$[esp+48], ebx
	mov	DWORD PTR __Val$1$[esp+48], edi
	call	ecx
	add	esp, 8
	test	al, al
	je	$LN18@Sort_unche
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility

; 4254 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	mov	ecx, ebx

; 4255 :     auto _Result                = _CSTD memmove(_Dest_ch - _Count, _First_ch, _Count);

	mov	eax, ebx
	sub	ecx, esi
	push	ecx
	sub	eax, ecx
	add	eax, 4
	push	esi
	push	eax
	call	_memmove
	add	esp, 12					; 0000000cH
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 6928 :                 *_First = _STD move(_Val);

	mov	DWORD PTR [esi], edi

; 6929 :             } else { // look for insertion point after first

	jmp	$LN19@Sort_unche
$LN166@Sort_unche:

; 5547 :     _Diff _Bottom = _Last - _First;

	sub	ebx, esi
	mov	eax, ebx
	mov	DWORD PTR __Last$1$[esp+40], ebx
	sar	eax, 2

; 5548 :     for (_Diff _Hole = _Bottom >> 1; _Hole > 0;) { // shift for codegen

	mov	edx, eax
	mov	DWORD PTR __Bottom$1$[esp+40], eax
	sar	edx, 1
	test	edx, edx
	jle	$LN29@Sort_unche
	dec	eax
	mov	DWORD PTR tv742[esp+40], eax
	sar	eax, 1
	mov	DWORD PTR __Max_sequence_non_leaf$1$[esp+40], eax
	npad	3
$LL28@Sort_unche:

; 5549 :         // reheap top half, bottom to top
; 5550 :         --_Hole;
; 5551 :         _Iter_value_t<_RanIt> _Val = _STD move(*(_First + _Hole));

	mov	ebx, DWORD PTR [esi+edx*4-4]
	dec	edx
	mov	DWORD PTR __Val$1$[esp+40], ebx

; 5552 :         _Pop_heap_hole_by_index(_First, _Hole, _Bottom, _STD move(_Val), _Pred);

	mov	ebx, edx
	mov	DWORD PTR __Hole$1$[esp+40], edx

; 5381 :     _Diff _Idx       = _Hole;

	mov	edi, edx

; 5382 : 
; 5383 :     // Check whether _Idx can have a child before calculating that child's index, since
; 5384 :     // calculating the child's index can trigger integer overflows
; 5385 :     const _Diff _Max_sequence_non_leaf = (_Bottom - 1) >> 1; // shift for codegen
; 5386 :     while (_Idx < _Max_sequence_non_leaf) { // move _Hole down to larger child

	cmp	edx, eax
	jge	SHORT $LN34@Sort_unche
	npad	11
$LL33@Sort_unche:

; 5387 :         _Idx = 2 * _Idx + 2;
; 5388 :         if (_DEBUG_LT_PRED(_Pred, *(_First + _Idx), *(_First + (_Idx - 1)))) {

	push	DWORD PTR [esi+edi*8+4]
	lea	edi, DWORD PTR [edi*2+2]
	push	DWORD PTR [esi+edi*4]
	call	ecx
	add	esp, 8
	test	al, al
	je	SHORT $LN35@Sort_unche

; 5389 :             --_Idx;

	dec	edi
$LN35@Sort_unche:

; 5390 :         }
; 5391 :         *(_First + _Hole) = _STD move(*(_First + _Idx));

	mov	eax, DWORD PTR [esi+edi*4]
	mov	ecx, DWORD PTR __Pred$[ebp]
	mov	DWORD PTR [esi+ebx*4], eax

; 5392 :         _Hole             = _Idx;

	mov	ebx, edi
	mov	eax, DWORD PTR __Max_sequence_non_leaf$1$[esp+40]
	cmp	edi, eax
	jl	SHORT $LL33@Sort_unche
	mov	edx, DWORD PTR __Hole$1$[esp+40]
$LN34@Sort_unche:

; 5393 :     }
; 5394 : 
; 5395 :     if (_Idx == _Max_sequence_non_leaf && _Bottom % 2 == 0) { // only child at bottom, move _Hole down to it

	cmp	edi, eax
	jne	SHORT $LN36@Sort_unche
	mov	eax, DWORD PTR __Bottom$1$[esp+40]
	test	al, 1
	jne	SHORT $LN36@Sort_unche

; 5396 :         *(_First + _Hole) = _STD move(*(_First + (_Bottom - 1)));

	mov	eax, DWORD PTR [esi+eax*4-4]
	mov	DWORD PTR [esi+ebx*4], eax

; 5397 :         _Hole             = _Bottom - 1;

	mov	ebx, DWORD PTR tv742[esp+40]
$LN36@Sort_unche:

; 5268 :          _Top < _Hole && _DEBUG_LT_PRED(_Pred, *(_First + _Idx), _Val); //

	cmp	edx, ebx
	jge	SHORT $LN40@Sort_unche
	npad	6
$LL41@Sort_unche:
	push	DWORD PTR __Val$1$[esp+40]
	lea	edi, DWORD PTR [ebx-1]
	sar	edi, 1
	push	DWORD PTR [esi+edi*4]
	call	ecx
	mov	edx, DWORD PTR __Hole$1$[esp+48]
	add	esp, 8
	test	al, al
	je	SHORT $LN40@Sort_unche

; 5269 :          _Idx = (_Hole - 1) >> 1) { // shift for codegen
; 5270 :         // move _Hole up to parent
; 5271 :         *(_First + _Hole) = _STD move(*(_First + _Idx));

	mov	eax, DWORD PTR [esi+edi*4]
	mov	ecx, DWORD PTR __Pred$[ebp]
	mov	DWORD PTR [esi+ebx*4], eax

; 5272 :         _Hole             = _Idx;

	mov	ebx, edi
	cmp	edx, edi
	jl	SHORT $LL41@Sort_unche
$LN40@Sort_unche:

; 5273 :     }
; 5274 : 
; 5275 :     *(_First + _Hole) = _STD forward<_Ty>(_Val); // drop _Val into final hole

	mov	eax, DWORD PTR __Val$1$[esp+40]

; 5548 :     for (_Diff _Hole = _Bottom >> 1; _Hole > 0;) { // shift for codegen

	mov	ecx, DWORD PTR __Pred$[ebp]

; 5275 :     *(_First + _Hole) = _STD forward<_Ty>(_Val); // drop _Val into final hole

	mov	DWORD PTR [esi+ebx*4], eax

; 5548 :     for (_Diff _Hole = _Bottom >> 1; _Hole > 0;) { // shift for codegen

	mov	eax, DWORD PTR __Max_sequence_non_leaf$1$[esp+40]
	test	edx, edx
	jg	$LL28@Sort_unche
	mov	ebx, DWORD PTR __Last$1$[esp+40]
	mov	eax, DWORD PTR __Bottom$1$[esp+40]
$LN29@Sort_unche:

; 5774 :     for (; _Last - _First >= 2; --_Last) {

	cmp	eax, 2
	jl	$LN45@Sort_unche
	npad	1
$LL46@Sort_unche:

; 5419 :         _Iter_value_t<_RanIt> _Val = _STD move(*_Last);

	mov	eax, DWORD PTR [ebx+esi-4]

; 5410 :     _Pop_heap_hole_by_index(

	xor	edx, edx

; 5419 :         _Iter_value_t<_RanIt> _Val = _STD move(*_Last);

	mov	DWORD PTR __Val$1[esp+40], eax

; 5408 :     *_Dest      = _STD move(*_First);

	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [ebx+esi-4], eax

; 5409 :     using _Diff = _Iter_diff_t<_RanIt>;
; 5410 :     _Pop_heap_hole_by_index(

	lea	eax, DWORD PTR __Val$1[esp+40]
	push	ecx
	push	eax
	lea	eax, DWORD PTR [ebx-4]
	mov	ecx, esi
	sar	eax, 2
	push	eax
	call	??$_Pop_heap_hole_by_index@PAPAVCPGDef@PS@@PAV12@P6A_NPBV12@0@Z@std@@YAXPAPAVCPGDef@PS@@HH$$QAPAV12@P6A_NPBV12@2@Z@Z ; std::_Pop_heap_hole_by_index<PS::CPGDef * *,PS::CPGDef *,bool (__cdecl*)(PS::CPGDef const *,PS::CPGDef const *)>

; 5774 :     for (; _Last - _First >= 2; --_Last) {

	mov	ecx, DWORD PTR __Pred$[ebp]
	sub	ebx, 4
	mov	eax, ebx

; 5410 :     _Pop_heap_hole_by_index(

	add	esp, 12					; 0000000cH

; 5774 :     for (; _Last - _First >= 2; --_Last) {

	and	eax, -4					; fffffffcH
	cmp	eax, 8
	jge	SHORT $LL46@Sort_unche

; 7071 :         }
; 7072 :     }
; 7073 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN18@Sort_unche:

; 6930 :                 for (_BidIt _Prev = _Hole; _DEBUG_LT_PRED(_Pred, _Val, *--_Prev); _Hole = _Prev) {

	push	DWORD PTR [ebx-4]
	mov	eax, DWORD PTR __Pred$[ebp]
	lea	edi, DWORD PTR [ebx-4]
	push	DWORD PTR __Val$1$[esp+44]
	call	eax
	add	esp, 8
	test	al, al
	je	SHORT $LN15@Sort_unche
	mov	esi, DWORD PTR __Val$1$[esp+40]
	mov	ebx, DWORD PTR __Hole$1$[esp+40]
	npad	4
$LL16@Sort_unche:

; 6931 :                     *_Hole = _STD move(*_Prev); // move hole down

	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR [ebx], eax
	mov	ebx, edi
	push	DWORD PTR [edi-4]
	sub	edi, 4
	push	esi
	call	DWORD PTR __Pred$[ebp]
	add	esp, 8
	test	al, al
	jne	SHORT $LL16@Sort_unche
	mov	esi, DWORD PTR __First$1$[esp+40]
	mov	DWORD PTR __Hole$1$[esp+40], ebx
	mov	ebx, DWORD PTR __Mid$1$[esp+40]
$LN15@Sort_unche:

; 6932 :                 }
; 6933 : 
; 6934 :                 *_Hole = _STD move(_Val); // insert element in hole

	mov	ecx, DWORD PTR __Hole$1$[esp+40]
	mov	eax, DWORD PTR __Val$1$[esp+40]
	mov	DWORD PTR [ecx], eax
$LN19@Sort_unche:

; 6922 :         for (_BidIt _Mid = _First; ++_Mid != _Last;) { // order next element

	mov	ecx, DWORD PTR __Pred$[ebp]
	add	ebx, 4
	mov	DWORD PTR __Mid$1$[esp+40], ebx
	cmp	ebx, DWORD PTR __Last$1$[esp+40]
	jne	$LL11@Sort_unche
$LN45@Sort_unche:

; 7071 :         }
; 7072 :     }
; 7073 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Sort_unchecked@PAPAVCPGDef@PS@@P6A_NPBV12@0@Z@std@@YAXPAPAVCPGDef@PS@@0HP6A_NPBV12@1@Z@Z ENDP ; std::_Sort_unchecked<PS::CPGDef * *,bool (__cdecl*)(PS::CPGDef const *,PS::CPGDef const *)>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_To_address@PAPAVCPGDef@PS@@@std@@YA?A_PABQAPAVCPGDef@PS@@@Z
_TEXT	SEGMENT
??$_To_address@PAPAVCPGDef@PS@@@std@@YA?A_PABQAPAVCPGDef@PS@@@Z PROC ; std::_To_address<PS::CPGDef * *>, COMDAT
; __Val$ = ecx

; 3981 :     _STL_INTERNAL_STATIC_ASSERT(is_pointer_v<_Iter>);
; 3982 :     return _Val;

	mov	eax, DWORD PTR [ecx]

; 3983 : }

	ret	0
??$_To_address@PAPAVCPGDef@PS@@@std@@YA?A_PABQAPAVCPGDef@PS@@@Z ENDP ; std::_To_address<PS::CPGDef * *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\type_traits
;	COMDAT ??$move@AAPAVCPGDef@PS@@@std@@YA$$QAPAVCPGDef@PS@@AAPAV12@@Z
_TEXT	SEGMENT
??$move@AAPAVCPGDef@PS@@@std@@YA$$QAPAVCPGDef@PS@@AAPAV12@@Z PROC ; std::move<PS::CPGDef * &>, COMDAT
; __Arg$ = ecx

; 1397 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

	mov	eax, ecx

; 1398 : }

	ret	0
??$move@AAPAVCPGDef@PS@@@std@@YA$$QAPAVCPGDef@PS@@AAPAV12@@Z ENDP ; std::move<PS::CPGDef * &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_To_address@PAPAVCPEDef@PS@@@std@@YA?A_PABQAPAVCPEDef@PS@@@Z
_TEXT	SEGMENT
??$_To_address@PAPAVCPEDef@PS@@@std@@YA?A_PABQAPAVCPEDef@PS@@@Z PROC ; std::_To_address<PS::CPEDef * *>, COMDAT
; __Val$ = ecx

; 3981 :     _STL_INTERNAL_STATIC_ASSERT(is_pointer_v<_Iter>);
; 3982 :     return _Val;

	mov	eax, DWORD PTR [ecx]

; 3983 : }

	ret	0
??$_To_address@PAPAVCPEDef@PS@@@std@@YA?A_PABQAPAVCPEDef@PS@@@Z ENDP ; std::_To_address<PS::CPEDef * *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\type_traits
;	COMDAT ??$move@AAPAVCPEDef@PS@@@std@@YA$$QAPAVCPEDef@PS@@AAPAV12@@Z
_TEXT	SEGMENT
??$move@AAPAVCPEDef@PS@@@std@@YA$$QAPAVCPEDef@PS@@AAPAV12@@Z PROC ; std::move<PS::CPEDef * &>, COMDAT
; __Arg$ = ecx

; 1397 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

	mov	eax, ecx

; 1398 : }

	ret	0
??$move@AAPAVCPEDef@PS@@@std@@YA$$QAPAVCPEDef@PS@@AAPAV12@@Z ENDP ; std::move<PS::CPEDef * &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Uninitialized_move@PAPAVCPGDef@PS@@V?$xalloc@PAVCPGDef@PS@@@@@std@@YAPAPAVCPGDef@PS@@QAPAV12@0PAPAV12@AAV?$xalloc@PAVCPGDef@PS@@@@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Al$dead$ = 12						; size = 4
??$_Uninitialized_move@PAPAVCPGDef@PS@@V?$xalloc@PAVCPGDef@PS@@@@@std@@YAPAPAVCPGDef@PS@@QAPAV12@0PAPAV12@AAV?$xalloc@PAVCPGDef@PS@@@@@Z PROC ; std::_Uninitialized_move<PS::CPGDef * *,xalloc<PS::CPGDef *> >, COMDAT
; __First$ = ecx
; __Last$ = edx

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	eax, DWORD PTR __Dest$[esp-4]

; 1699 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

	push	esi
	mov	esi, edx

; 1700 :     // move [_First, _Last) to raw _Dest, using _Al
; 1701 :     // note: only called internally from elsewhere in the STL
; 1702 :     using _Ptrval     = typename _Alloc::value_type*;
; 1703 :     auto _UFirst      = _Get_unwrapped(_First);
; 1704 :     const auto _ULast = _Get_unwrapped(_Last);
; 1705 :     if constexpr (conjunction_v<bool_constant<_Ptr_move_cat<decltype(_UFirst), _Ptrval>::_Really_trivial>,
; 1706 :                       _Uses_default_construct<_Alloc, _Ptrval, decltype(_STD move(*_UFirst))>>) {
; 1707 : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 1708 :         if (!_STD is_constant_evaluated())
; 1709 : #endif // __cpp_lib_constexpr_dynamic_alloc
; 1710 :         {
; 1711 :             _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));
; 1712 :             return _Dest + (_ULast - _UFirst);
; 1713 :         }
; 1714 :     }
; 1715 : 
; 1716 :     _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	ecx, esi
	je	SHORT $LN3@Uninitiali
	npad	5
$LL4@Uninitiali:

; 1620 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

	mov	edx, DWORD PTR [ecx]

; 1621 :         ++_Last;

	add	ecx, 4
	mov	DWORD PTR [eax], edx
	add	eax, 4

; 1700 :     // move [_First, _Last) to raw _Dest, using _Al
; 1701 :     // note: only called internally from elsewhere in the STL
; 1702 :     using _Ptrval     = typename _Alloc::value_type*;
; 1703 :     auto _UFirst      = _Get_unwrapped(_First);
; 1704 :     const auto _ULast = _Get_unwrapped(_Last);
; 1705 :     if constexpr (conjunction_v<bool_constant<_Ptr_move_cat<decltype(_UFirst), _Ptrval>::_Really_trivial>,
; 1706 :                       _Uses_default_construct<_Alloc, _Ptrval, decltype(_STD move(*_UFirst))>>) {
; 1707 : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 1708 :         if (!_STD is_constant_evaluated())
; 1709 : #endif // __cpp_lib_constexpr_dynamic_alloc
; 1710 :         {
; 1711 :             _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));
; 1712 :             return _Dest + (_ULast - _UFirst);
; 1713 :         }
; 1714 :     }
; 1715 : 
; 1716 :     _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	ecx, esi
	jne	SHORT $LL4@Uninitiali
$LN3@Uninitiali:
	pop	esi

; 1718 :         _Backout._Emplace_back(_STD move(*_UFirst));
; 1719 :     }
; 1720 : 
; 1721 :     return _Backout._Release();
; 1722 : }

	ret	0
??$_Uninitialized_move@PAPAVCPGDef@PS@@V?$xalloc@PAVCPGDef@PS@@@@@std@@YAPAPAVCPGDef@PS@@QAPAV12@0PAPAV12@AAV?$xalloc@PAVCPGDef@PS@@@@@Z ENDP ; std::_Uninitialized_move<PS::CPGDef * *,xalloc<PS::CPGDef *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_Get_unwrapped@ABQAPAVCPGDef@PS@@@std@@YA?A_TABQAPAVCPGDef@PS@@@Z
_TEXT	SEGMENT
??$_Get_unwrapped@ABQAPAVCPGDef@PS@@@std@@YA?A_TABQAPAVCPGDef@PS@@@Z PROC ; std::_Get_unwrapped<PS::CPGDef * * const &>, COMDAT
; __It$ = ecx

; 1275 :     // unwrap an iterator previously subjected to _Adl_verify_range or otherwise validated
; 1276 :     if constexpr (is_pointer_v<decay_t<_Iter>>) { // special-case pointers and arrays
; 1277 :         return _It + 0;

	mov	eax, DWORD PTR [ecx]

; 1278 :     } else if constexpr (_Unwrappable_v<_Iter>) {
; 1279 :         return static_cast<_Iter&&>(_It)._Unwrapped();
; 1280 :     } else {
; 1281 :         return static_cast<_Iter&&>(_It);
; 1282 :     }
; 1283 : }

	ret	0
??$_Get_unwrapped@ABQAPAVCPGDef@PS@@@std@@YA?A_TABQAPAVCPGDef@PS@@@Z ENDP ; std::_Get_unwrapped<PS::CPGDef * * const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
;	COMDAT ??$xr_alloc@PAVCPGDef@PS@@@@YAPAPAVCPGDef@PS@@I@Z
_TEXT	SEGMENT
??$xr_alloc@PAVCPGDef@PS@@@@YAPAPAVCPGDef@PS@@I@Z PROC	; xr_alloc<PS::CPGDef *>, COMDAT
; _count$ = ecx

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	lea	eax, DWORD PTR [ecx*4]
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
	ret	0
??$xr_alloc@PAVCPGDef@PS@@@@YAPAPAVCPGDef@PS@@I@Z ENDP	; xr_alloc<PS::CPGDef *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Uninitialized_move@PAPAVCPEDef@PS@@V?$xalloc@PAVCPEDef@PS@@@@@std@@YAPAPAVCPEDef@PS@@QAPAV12@0PAPAV12@AAV?$xalloc@PAVCPEDef@PS@@@@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Al$dead$ = 12						; size = 4
??$_Uninitialized_move@PAPAVCPEDef@PS@@V?$xalloc@PAVCPEDef@PS@@@@@std@@YAPAPAVCPEDef@PS@@QAPAV12@0PAPAV12@AAV?$xalloc@PAVCPEDef@PS@@@@@Z PROC ; std::_Uninitialized_move<PS::CPEDef * *,xalloc<PS::CPEDef *> >, COMDAT
; __First$ = ecx
; __Last$ = edx

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	eax, DWORD PTR __Dest$[esp-4]

; 1699 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

	push	esi
	mov	esi, edx

; 1700 :     // move [_First, _Last) to raw _Dest, using _Al
; 1701 :     // note: only called internally from elsewhere in the STL
; 1702 :     using _Ptrval     = typename _Alloc::value_type*;
; 1703 :     auto _UFirst      = _Get_unwrapped(_First);
; 1704 :     const auto _ULast = _Get_unwrapped(_Last);
; 1705 :     if constexpr (conjunction_v<bool_constant<_Ptr_move_cat<decltype(_UFirst), _Ptrval>::_Really_trivial>,
; 1706 :                       _Uses_default_construct<_Alloc, _Ptrval, decltype(_STD move(*_UFirst))>>) {
; 1707 : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 1708 :         if (!_STD is_constant_evaluated())
; 1709 : #endif // __cpp_lib_constexpr_dynamic_alloc
; 1710 :         {
; 1711 :             _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));
; 1712 :             return _Dest + (_ULast - _UFirst);
; 1713 :         }
; 1714 :     }
; 1715 : 
; 1716 :     _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	ecx, esi
	je	SHORT $LN3@Uninitiali
	npad	5
$LL4@Uninitiali:

; 1620 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

	mov	edx, DWORD PTR [ecx]

; 1621 :         ++_Last;

	add	ecx, 4
	mov	DWORD PTR [eax], edx
	add	eax, 4

; 1700 :     // move [_First, _Last) to raw _Dest, using _Al
; 1701 :     // note: only called internally from elsewhere in the STL
; 1702 :     using _Ptrval     = typename _Alloc::value_type*;
; 1703 :     auto _UFirst      = _Get_unwrapped(_First);
; 1704 :     const auto _ULast = _Get_unwrapped(_Last);
; 1705 :     if constexpr (conjunction_v<bool_constant<_Ptr_move_cat<decltype(_UFirst), _Ptrval>::_Really_trivial>,
; 1706 :                       _Uses_default_construct<_Alloc, _Ptrval, decltype(_STD move(*_UFirst))>>) {
; 1707 : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 1708 :         if (!_STD is_constant_evaluated())
; 1709 : #endif // __cpp_lib_constexpr_dynamic_alloc
; 1710 :         {
; 1711 :             _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));
; 1712 :             return _Dest + (_ULast - _UFirst);
; 1713 :         }
; 1714 :     }
; 1715 : 
; 1716 :     _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	ecx, esi
	jne	SHORT $LL4@Uninitiali
$LN3@Uninitiali:
	pop	esi

; 1718 :         _Backout._Emplace_back(_STD move(*_UFirst));
; 1719 :     }
; 1720 : 
; 1721 :     return _Backout._Release();
; 1722 : }

	ret	0
??$_Uninitialized_move@PAPAVCPEDef@PS@@V?$xalloc@PAVCPEDef@PS@@@@@std@@YAPAPAVCPEDef@PS@@QAPAV12@0PAPAV12@AAV?$xalloc@PAVCPEDef@PS@@@@@Z ENDP ; std::_Uninitialized_move<PS::CPEDef * *,xalloc<PS::CPEDef *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_Get_unwrapped@ABQAPAVCPEDef@PS@@@std@@YA?A_TABQAPAVCPEDef@PS@@@Z
_TEXT	SEGMENT
??$_Get_unwrapped@ABQAPAVCPEDef@PS@@@std@@YA?A_TABQAPAVCPEDef@PS@@@Z PROC ; std::_Get_unwrapped<PS::CPEDef * * const &>, COMDAT
; __It$ = ecx

; 1275 :     // unwrap an iterator previously subjected to _Adl_verify_range or otherwise validated
; 1276 :     if constexpr (is_pointer_v<decay_t<_Iter>>) { // special-case pointers and arrays
; 1277 :         return _It + 0;

	mov	eax, DWORD PTR [ecx]

; 1278 :     } else if constexpr (_Unwrappable_v<_Iter>) {
; 1279 :         return static_cast<_Iter&&>(_It)._Unwrapped();
; 1280 :     } else {
; 1281 :         return static_cast<_Iter&&>(_It);
; 1282 :     }
; 1283 : }

	ret	0
??$_Get_unwrapped@ABQAPAVCPEDef@PS@@@std@@YA?A_TABQAPAVCPEDef@PS@@@Z ENDP ; std::_Get_unwrapped<PS::CPEDef * * const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
;	COMDAT ??$xr_alloc@PAVCPEDef@PS@@@@YAPAPAVCPEDef@PS@@I@Z
_TEXT	SEGMENT
??$xr_alloc@PAVCPEDef@PS@@@@YAPAPAVCPEDef@PS@@I@Z PROC	; xr_alloc<PS::CPEDef *>, COMDAT
; _count$ = ecx

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	lea	eax, DWORD PTR [ecx*4]
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
	ret	0
??$xr_alloc@PAVCPEDef@PS@@@@YAPAPAVCPEDef@PS@@I@Z ENDP	; xr_alloc<PS::CPEDef *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Release@?$_Uninitialized_backout_al@V?$xalloc@PAVCPEDef@PS@@@@@std@@QAEPAPAVCPEDef@PS@@XZ
_TEXT	SEGMENT
?_Release@?$_Uninitialized_backout_al@V?$xalloc@PAVCPEDef@PS@@@@@std@@QAEPAPAVCPEDef@PS@@XZ PROC ; std::_Uninitialized_backout_al<xalloc<PS::CPEDef *> >::_Release, COMDAT
; _this$ = ecx

; 1625 :         _First = _Last;

	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [ecx], eax

; 1626 :         return _Last;
; 1627 :     }

	ret	0
?_Release@?$_Uninitialized_backout_al@V?$xalloc@PAVCPEDef@PS@@@@@std@@QAEPAPAVCPEDef@PS@@XZ ENDP ; std::_Uninitialized_backout_al<xalloc<PS::CPEDef *> >::_Release
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??1?$_Uninitialized_backout_al@V?$xalloc@PAVCPEDef@PS@@@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Uninitialized_backout_al@V?$xalloc@PAVCPEDef@PS@@@@@std@@QAE@XZ PROC ; std::_Uninitialized_backout_al<xalloc<PS::CPEDef *> >::~_Uninitialized_backout_al<xalloc<PS::CPEDef *> >, COMDAT
; _this$ = ecx

; 1615 :         _Destroy_range(_First, _Last, _Al);
; 1616 :     }

	ret	0
??1?$_Uninitialized_backout_al@V?$xalloc@PAVCPEDef@PS@@@@@std@@QAE@XZ ENDP ; std::_Uninitialized_backout_al<xalloc<PS::CPEDef *> >::~_Uninitialized_backout_al<xalloc<PS::CPEDef *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??0?$_Uninitialized_backout_al@V?$xalloc@PAVCPEDef@PS@@@@@std@@QAE@PAPAVCPEDef@PS@@AAV?$xalloc@PAVCPEDef@PS@@@@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Al_$ = 12						; size = 4
??0?$_Uninitialized_backout_al@V?$xalloc@PAVCPEDef@PS@@@@@std@@QAE@PAPAVCPEDef@PS@@AAV?$xalloc@PAVCPEDef@PS@@@@@Z PROC ; std::_Uninitialized_backout_al<xalloc<PS::CPEDef *> >::_Uninitialized_backout_al<xalloc<PS::CPEDef *> >, COMDAT
; _this$ = ecx

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	eax, DWORD PTR __Dest$[esp-4]
	mov	DWORD PTR [ecx], eax
	mov	DWORD PTR [ecx+4], eax
	mov	eax, DWORD PTR __Al_$[esp-4]
	mov	DWORD PTR [ecx+8], eax
	mov	eax, ecx
	ret	8
??0?$_Uninitialized_backout_al@V?$xalloc@PAVCPEDef@PS@@@@@std@@QAE@PAPAVCPEDef@PS@@AAV?$xalloc@PAVCPEDef@PS@@@@@Z ENDP ; std::_Uninitialized_backout_al<xalloc<PS::CPEDef *> >::_Uninitialized_backout_al<xalloc<PS::CPEDef *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Release@?$_Uninitialized_backout_al@V?$xalloc@PAVCPGDef@PS@@@@@std@@QAEPAPAVCPGDef@PS@@XZ
_TEXT	SEGMENT
?_Release@?$_Uninitialized_backout_al@V?$xalloc@PAVCPGDef@PS@@@@@std@@QAEPAPAVCPGDef@PS@@XZ PROC ; std::_Uninitialized_backout_al<xalloc<PS::CPGDef *> >::_Release, COMDAT
; _this$ = ecx

; 1625 :         _First = _Last;

	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [ecx], eax

; 1626 :         return _Last;
; 1627 :     }

	ret	0
?_Release@?$_Uninitialized_backout_al@V?$xalloc@PAVCPGDef@PS@@@@@std@@QAEPAPAVCPGDef@PS@@XZ ENDP ; std::_Uninitialized_backout_al<xalloc<PS::CPGDef *> >::_Release
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??1?$_Uninitialized_backout_al@V?$xalloc@PAVCPGDef@PS@@@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Uninitialized_backout_al@V?$xalloc@PAVCPGDef@PS@@@@@std@@QAE@XZ PROC ; std::_Uninitialized_backout_al<xalloc<PS::CPGDef *> >::~_Uninitialized_backout_al<xalloc<PS::CPGDef *> >, COMDAT
; _this$ = ecx

; 1615 :         _Destroy_range(_First, _Last, _Al);
; 1616 :     }

	ret	0
??1?$_Uninitialized_backout_al@V?$xalloc@PAVCPGDef@PS@@@@@std@@QAE@XZ ENDP ; std::_Uninitialized_backout_al<xalloc<PS::CPGDef *> >::~_Uninitialized_backout_al<xalloc<PS::CPGDef *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??0?$_Uninitialized_backout_al@V?$xalloc@PAVCPGDef@PS@@@@@std@@QAE@PAPAVCPGDef@PS@@AAV?$xalloc@PAVCPGDef@PS@@@@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Al_$ = 12						; size = 4
??0?$_Uninitialized_backout_al@V?$xalloc@PAVCPGDef@PS@@@@@std@@QAE@PAPAVCPGDef@PS@@AAV?$xalloc@PAVCPGDef@PS@@@@@Z PROC ; std::_Uninitialized_backout_al<xalloc<PS::CPGDef *> >::_Uninitialized_backout_al<xalloc<PS::CPGDef *> >, COMDAT
; _this$ = ecx

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	eax, DWORD PTR __Dest$[esp-4]
	mov	DWORD PTR [ecx], eax
	mov	DWORD PTR [ecx+4], eax
	mov	eax, DWORD PTR __Al_$[esp-4]
	mov	DWORD PTR [ecx+8], eax
	mov	eax, ecx
	ret	8
??0?$_Uninitialized_backout_al@V?$xalloc@PAVCPGDef@PS@@@@@std@@QAE@PAPAVCPGDef@PS@@AAV?$xalloc@PAVCPGDef@PS@@@@@Z ENDP ; std::_Uninitialized_backout_al<xalloc<PS::CPGDef *> >::_Uninitialized_backout_al<xalloc<PS::CPGDef *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Seek_to@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPGDef@PS@@@std@@@std@@@std@@QAEXPBQAVCPGDef@PS@@@Z
_TEXT	SEGMENT
__It$ = 8						; size = 4
?_Seek_to@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPGDef@PS@@@std@@@std@@@std@@QAEXPBQAVCPGDef@PS@@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<PS::CPGDef *> > >::_Seek_to, COMDAT
; _this$ = ecx

; 205  :         _Ptr = _Refancy<_Tptr>(const_cast<value_type*>(_It));

	mov	eax, DWORD PTR __It$[esp-4]
	mov	DWORD PTR [ecx], eax

; 206  :     }

	ret	4
?_Seek_to@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPGDef@PS@@@std@@@std@@@std@@QAEXPBQAVCPGDef@PS@@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<PS::CPGDef *> > >::_Seek_to
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Seek_to@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPEDef@PS@@@std@@@std@@@std@@QAEXPBQAVCPEDef@PS@@@Z
_TEXT	SEGMENT
__It$ = 8						; size = 4
?_Seek_to@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPEDef@PS@@@std@@@std@@@std@@QAEXPBQAVCPEDef@PS@@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<PS::CPEDef *> > >::_Seek_to, COMDAT
; _this$ = ecx

; 205  :         _Ptr = _Refancy<_Tptr>(const_cast<value_type*>(_It));

	mov	eax, DWORD PTR __It$[esp-4]
	mov	DWORD PTR [ecx], eax

; 206  :     }

	ret	4
?_Seek_to@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPEDef@PS@@@std@@@std@@@std@@QAEXPBQAVCPEDef@PS@@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<PS::CPEDef *> > >::_Seek_to
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$advance@PAPAVCPEDef@PS@@H@std@@YAXAAPAPAVCPEDef@PS@@H@Z
_TEXT	SEGMENT
??$advance@PAPAVCPEDef@PS@@H@std@@YAXAAPAPAVCPEDef@PS@@H@Z PROC ; std::advance<PS::CPEDef * *,int>, COMDAT
; __Where$ = ecx
; __Off$ = edx

; 1496 :     if constexpr (_Is_random_iter_v<_InIt>) {
; 1497 :         _Where += _Off;

	lea	eax, DWORD PTR [edx*4]
	add	DWORD PTR [ecx], eax

; 1498 :     } else {
; 1499 :         if constexpr (is_signed_v<_Diff> && !_Is_bidi_iter_v<_InIt>) {
; 1500 :             _STL_ASSERT(_Off >= 0, "negative advance of non-bidirectional iterator");
; 1501 :         }
; 1502 : 
; 1503 :         decltype(auto) _UWhere      = _Get_unwrapped_n(_STD move(_Where), _Off);
; 1504 :         constexpr bool _Need_rewrap = !is_reference_v<decltype(_Get_unwrapped_n(_STD move(_Where), _Off))>;
; 1505 : 
; 1506 :         if constexpr (is_signed_v<_Diff> && _Is_bidi_iter_v<_InIt>) {
; 1507 :             for (; _Off < 0; ++_Off) {
; 1508 :                 --_UWhere;
; 1509 :             }
; 1510 :         }
; 1511 : 
; 1512 :         for (; 0 < _Off; --_Off) {
; 1513 :             ++_UWhere;
; 1514 :         }
; 1515 : 
; 1516 :         if constexpr (_Need_rewrap) {
; 1517 :             _Seek_wrapped(_Where, _STD move(_UWhere));
; 1518 :         }
; 1519 :     }
; 1520 : }

	ret	0
??$advance@PAPAVCPEDef@PS@@H@std@@YAXAAPAPAVCPEDef@PS@@H@Z ENDP ; std::advance<PS::CPEDef * *,int>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\type_traits
;	COMDAT ??$forward@AAPAPAVCPEDef@PS@@@std@@YAAAPAPAVCPEDef@PS@@AAPAPAV12@@Z
_TEXT	SEGMENT
??$forward@AAPAPAVCPEDef@PS@@@std@@YAAAPAPAVCPEDef@PS@@AAPAPAV12@@Z PROC ; std::forward<PS::CPEDef * * &>, COMDAT
; __Arg$ = ecx

; 1386 :     return static_cast<_Ty&&>(_Arg);

	mov	eax, ecx

; 1387 : }

	ret	0
??$forward@AAPAPAVCPEDef@PS@@@std@@YAAAPAPAVCPEDef@PS@@AAPAPAV12@@Z ENDP ; std::forward<PS::CPEDef * * &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$advance@PAPAVCPGDef@PS@@H@std@@YAXAAPAPAVCPGDef@PS@@H@Z
_TEXT	SEGMENT
??$advance@PAPAVCPGDef@PS@@H@std@@YAXAAPAPAVCPGDef@PS@@H@Z PROC ; std::advance<PS::CPGDef * *,int>, COMDAT
; __Where$ = ecx
; __Off$ = edx

; 1496 :     if constexpr (_Is_random_iter_v<_InIt>) {
; 1497 :         _Where += _Off;

	lea	eax, DWORD PTR [edx*4]
	add	DWORD PTR [ecx], eax

; 1498 :     } else {
; 1499 :         if constexpr (is_signed_v<_Diff> && !_Is_bidi_iter_v<_InIt>) {
; 1500 :             _STL_ASSERT(_Off >= 0, "negative advance of non-bidirectional iterator");
; 1501 :         }
; 1502 : 
; 1503 :         decltype(auto) _UWhere      = _Get_unwrapped_n(_STD move(_Where), _Off);
; 1504 :         constexpr bool _Need_rewrap = !is_reference_v<decltype(_Get_unwrapped_n(_STD move(_Where), _Off))>;
; 1505 : 
; 1506 :         if constexpr (is_signed_v<_Diff> && _Is_bidi_iter_v<_InIt>) {
; 1507 :             for (; _Off < 0; ++_Off) {
; 1508 :                 --_UWhere;
; 1509 :             }
; 1510 :         }
; 1511 : 
; 1512 :         for (; 0 < _Off; --_Off) {
; 1513 :             ++_UWhere;
; 1514 :         }
; 1515 : 
; 1516 :         if constexpr (_Need_rewrap) {
; 1517 :             _Seek_wrapped(_Where, _STD move(_UWhere));
; 1518 :         }
; 1519 :     }
; 1520 : }

	ret	0
??$advance@PAPAVCPGDef@PS@@H@std@@YAXAAPAPAVCPGDef@PS@@H@Z ENDP ; std::advance<PS::CPGDef * *,int>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\type_traits
;	COMDAT ??$forward@AAPAPAVCPGDef@PS@@@std@@YAAAPAPAVCPGDef@PS@@AAPAPAV12@@Z
_TEXT	SEGMENT
??$forward@AAPAPAVCPGDef@PS@@@std@@YAAAPAPAVCPGDef@PS@@AAPAPAV12@@Z PROC ; std::forward<PS::CPGDef * * &>, COMDAT
; __Arg$ = ecx

; 1386 :     return static_cast<_Ty&&>(_Arg);

	mov	eax, ecx

; 1387 : }

	ret	0
??$forward@AAPAPAVCPGDef@PS@@@std@@YAAAPAPAVCPGDef@PS@@AAPAPAV12@@Z ENDP ; std::forward<PS::CPGDef * * &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
;	COMDAT ??$_Insertion_sort_unchecked@PAPAVCPEDef@PS@@P6A_NPBV12@0@Z@std@@YAPAPAVCPEDef@PS@@QAPAV12@0P6A_NPBV12@1@Z@Z
_TEXT	SEGMENT
__First$1$ = -8						; size = 4
__Last$1$ = -4						; size = 4
__Pred$ = 8						; size = 4
??$_Insertion_sort_unchecked@PAPAVCPEDef@PS@@P6A_NPBV12@0@Z@std@@YAPAPAVCPEDef@PS@@QAPAV12@0P6A_NPBV12@1@Z@Z PROC ; std::_Insertion_sort_unchecked<PS::CPEDef * *,bool (__cdecl*)(PS::CPEDef const *,PS::CPEDef const *)>, COMDAT
; __First$ = ecx
; __Last$ = edx

; 6919 : _CONSTEXPR20 _BidIt _Insertion_sort_unchecked(const _BidIt _First, const _BidIt _Last, _Pr _Pred) {

	sub	esp, 8
	push	esi
	mov	eax, edx
	mov	esi, ecx
	mov	DWORD PTR __Last$1$[esp+12], eax
	mov	DWORD PTR __First$1$[esp+12], esi

; 6920 :     // insertion sort [_First, _Last)
; 6921 :     if (_First != _Last) {

	cmp	esi, eax
	je	SHORT $LN3@Insertion_

; 6922 :         for (_BidIt _Mid = _First; ++_Mid != _Last;) { // order next element

	push	edi
	lea	edi, DWORD PTR [esi+4]
	cmp	edi, eax
	je	SHORT $LN27@Insertion_
	push	ebx
	push	ebp
	npad	2
$LL2@Insertion_:

; 6923 :             _BidIt _Hole               = _Mid;
; 6924 :             _Iter_value_t<_BidIt> _Val = _STD move(*_Mid);
; 6925 : 
; 6926 :             if (_DEBUG_LT_PRED(_Pred, _Val, *_First)) { // found new earliest element, move to front

	push	DWORD PTR [esi]
	mov	ebx, DWORD PTR [edi]
	mov	ebp, edi
	push	ebx
	call	DWORD PTR __Pred$[esp+28]
	add	esp, 8
	test	al, al
	je	SHORT $LN9@Insertion_
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility

; 4254 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	mov	ecx, edi

; 4255 :     auto _Result                = _CSTD memmove(_Dest_ch - _Count, _First_ch, _Count);

	mov	eax, edi
	sub	ecx, esi
	push	ecx
	sub	eax, ecx
	add	eax, 4
	push	esi
	push	eax
	call	_memmove
	add	esp, 12					; 0000000cH
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 6928 :                 *_First = _STD move(_Val);

	mov	DWORD PTR [esi], ebx

; 6929 :             } else { // look for insertion point after first

	jmp	SHORT $LN10@Insertion_
$LN9@Insertion_:

; 6930 :                 for (_BidIt _Prev = _Hole; _DEBUG_LT_PRED(_Pred, _Val, *--_Prev); _Hole = _Prev) {

	push	DWORD PTR [edi-4]
	lea	esi, DWORD PTR [edi-4]
	push	ebx
	call	DWORD PTR __Pred$[esp+28]
	add	esp, 8
	test	al, al
	je	SHORT $LN6@Insertion_
	npad	2
$LL7@Insertion_:

; 6931 :                     *_Hole = _STD move(*_Prev); // move hole down

	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [ebp], eax
	mov	ebp, esi
	push	DWORD PTR [esi-4]
	sub	esi, 4
	push	ebx
	call	DWORD PTR __Pred$[esp+28]
	add	esp, 8
	test	al, al
	jne	SHORT $LL7@Insertion_
$LN6@Insertion_:
	mov	esi, DWORD PTR __First$1$[esp+24]

; 6932 :                 }
; 6933 : 
; 6934 :                 *_Hole = _STD move(_Val); // insert element in hole

	mov	DWORD PTR [ebp], ebx
$LN10@Insertion_:

; 6922 :         for (_BidIt _Mid = _First; ++_Mid != _Last;) { // order next element

	mov	eax, DWORD PTR __Last$1$[esp+24]
	add	edi, 4
	cmp	edi, eax
	jne	SHORT $LL2@Insertion_

; 6935 :             }
; 6936 :         }
; 6937 :     }
; 6938 : 
; 6939 :     return _Last;

	pop	ebp
	pop	ebx
$LN27@Insertion_:
	pop	edi
$LN3@Insertion_:
	pop	esi

; 6940 : }

	add	esp, 8
	ret	0
??$_Insertion_sort_unchecked@PAPAVCPEDef@PS@@P6A_NPBV12@0@Z@std@@YAPAPAVCPEDef@PS@@QAPAV12@0P6A_NPBV12@1@Z@Z ENDP ; std::_Insertion_sort_unchecked<PS::CPEDef * *,bool (__cdecl*)(PS::CPEDef const *,PS::CPEDef const *)>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
;	COMDAT ??$_Make_heap_unchecked@PAPAVCPEDef@PS@@P6A_NPBV12@0@Z@std@@YAXPAPAVCPEDef@PS@@0P6A_NPBV12@1@Z@Z
_TEXT	SEGMENT
__Val$1$ = -20						; size = 4
__Max_sequence_non_leaf$1$ = -16			; size = 4
__Hole$1$ = -12						; size = 4
__Bottom$1$ = -8					; size = 4
tv268 = -4						; size = 4
__Pred$ = 8						; size = 4
??$_Make_heap_unchecked@PAPAVCPEDef@PS@@P6A_NPBV12@0@Z@std@@YAXPAPAVCPEDef@PS@@0P6A_NPBV12@1@Z@Z PROC ; std::_Make_heap_unchecked<PS::CPEDef * *,bool (__cdecl*)(PS::CPEDef const *,PS::CPEDef const *)>, COMDAT
; __First$ = ecx
; __Last$ = edx

; 5544 : _CONSTEXPR20 void _Make_heap_unchecked(_RanIt _First, _RanIt _Last, _Pr _Pred) {

	sub	esp, 20					; 00000014H
	push	ebx
	mov	eax, edx
	mov	ebx, ecx

; 5545 :     // make [_First, _Last) into a heap
; 5546 :     using _Diff   = _Iter_diff_t<_RanIt>;
; 5547 :     _Diff _Bottom = _Last - _First;

	sub	eax, ebx
	sar	eax, 2
	push	ebp

; 5548 :     for (_Diff _Hole = _Bottom >> 1; _Hole > 0;) { // shift for codegen

	mov	ebp, eax
	mov	DWORD PTR __Bottom$1$[esp+28], eax
	sar	ebp, 1
	test	ebp, ebp
	jle	$LN3@Make_heap_

; 5385 :     const _Diff _Max_sequence_non_leaf = (_Bottom - 1) >> 1; // shift for codegen

	mov	ecx, DWORD PTR __Pred$[esp+24]
	dec	eax
	mov	DWORD PTR tv268[esp+28], eax
	sar	eax, 1
	push	esi
	mov	DWORD PTR __Max_sequence_non_leaf$1$[esp+32], eax
	push	edi
	npad	1
$LL2@Make_heap_:

; 5549 :         // reheap top half, bottom to top
; 5550 :         --_Hole;
; 5551 :         _Iter_value_t<_RanIt> _Val = _STD move(*(_First + _Hole));

	mov	edx, DWORD PTR [ebx+ebp*4-4]
	dec	ebp
	mov	DWORD PTR __Hole$1$[esp+36], ebp

; 5552 :         _Pop_heap_hole_by_index(_First, _Hole, _Bottom, _STD move(_Val), _Pred);

	mov	edi, ebp
	mov	DWORD PTR __Val$1$[esp+36], edx

; 5381 :     _Diff _Idx       = _Hole;

	mov	esi, ebp

; 5386 :     while (_Idx < _Max_sequence_non_leaf) { // move _Hole down to larger child

	cmp	ebp, eax
	jge	SHORT $LN8@Make_heap_
	mov	ebp, DWORD PTR __Max_sequence_non_leaf$1$[esp+36]
	npad	7
$LL7@Make_heap_:

; 5387 :         _Idx = 2 * _Idx + 2;
; 5388 :         if (_DEBUG_LT_PRED(_Pred, *(_First + _Idx), *(_First + (_Idx - 1)))) {

	push	DWORD PTR [ebx+esi*8+4]
	lea	esi, DWORD PTR [esi*2+2]
	push	DWORD PTR [ebx+esi*4]
	call	ecx
	add	esp, 8
	test	al, al
	je	SHORT $LN9@Make_heap_

; 5389 :             --_Idx;

	dec	esi
$LN9@Make_heap_:

; 5390 :         }
; 5391 :         *(_First + _Hole) = _STD move(*(_First + _Idx));

	mov	eax, DWORD PTR [ebx+esi*4]
	mov	ecx, DWORD PTR __Pred$[esp+32]
	mov	DWORD PTR [ebx+edi*4], eax

; 5392 :         _Hole             = _Idx;

	mov	edi, esi
	cmp	esi, ebp
	jl	SHORT $LL7@Make_heap_
	mov	ebp, DWORD PTR __Hole$1$[esp+36]
	mov	eax, DWORD PTR __Max_sequence_non_leaf$1$[esp+36]
	mov	edx, DWORD PTR __Val$1$[esp+36]
$LN8@Make_heap_:

; 5393 :     }
; 5394 : 
; 5395 :     if (_Idx == _Max_sequence_non_leaf && _Bottom % 2 == 0) { // only child at bottom, move _Hole down to it

	cmp	esi, eax
	jne	SHORT $LN10@Make_heap_
	mov	eax, DWORD PTR __Bottom$1$[esp+36]
	test	al, 1
	jne	SHORT $LN10@Make_heap_

; 5396 :         *(_First + _Hole) = _STD move(*(_First + (_Bottom - 1)));

	mov	eax, DWORD PTR [ebx+eax*4-4]
	mov	DWORD PTR [ebx+edi*4], eax

; 5397 :         _Hole             = _Bottom - 1;

	mov	edi, DWORD PTR tv268[esp+36]
$LN10@Make_heap_:

; 5268 :          _Top < _Hole && _DEBUG_LT_PRED(_Pred, *(_First + _Idx), _Val); //

	cmp	ebp, edi
	jge	SHORT $LN29@Make_heap_
	npad	1
$LL15@Make_heap_:

; 5267 :     for (_Diff _Idx = (_Hole - 1) >> 1; // shift for codegen

	lea	esi, DWORD PTR [edi-1]
	sar	esi, 1

; 5268 :          _Top < _Hole && _DEBUG_LT_PRED(_Pred, *(_First + _Idx), _Val); //

	push	edx
	push	DWORD PTR [ebx+esi*4]
	call	ecx
	add	esp, 8
	test	al, al
	je	SHORT $LN29@Make_heap_

; 5269 :          _Idx = (_Hole - 1) >> 1) { // shift for codegen
; 5270 :         // move _Hole up to parent
; 5271 :         *(_First + _Hole) = _STD move(*(_First + _Idx));

	mov	eax, DWORD PTR [ebx+esi*4]
	mov	ecx, DWORD PTR __Pred$[esp+32]
	mov	edx, DWORD PTR __Val$1$[esp+36]
	mov	DWORD PTR [ebx+edi*4], eax

; 5272 :         _Hole             = _Idx;

	mov	edi, esi
	cmp	ebp, esi
	jl	SHORT $LL15@Make_heap_
$LN29@Make_heap_:

; 5273 :     }
; 5274 : 
; 5275 :     *(_First + _Hole) = _STD forward<_Ty>(_Val); // drop _Val into final hole

	mov	eax, DWORD PTR __Val$1$[esp+36]

; 5548 :     for (_Diff _Hole = _Bottom >> 1; _Hole > 0;) { // shift for codegen

	mov	ecx, DWORD PTR __Pred$[esp+32]

; 5275 :     *(_First + _Hole) = _STD forward<_Ty>(_Val); // drop _Val into final hole

	mov	DWORD PTR [ebx+edi*4], eax

; 5548 :     for (_Diff _Hole = _Bottom >> 1; _Hole > 0;) { // shift for codegen

	mov	eax, DWORD PTR __Max_sequence_non_leaf$1$[esp+36]
	test	ebp, ebp
	jg	$LL2@Make_heap_
	pop	edi
	pop	esi
$LN3@Make_heap_:
	pop	ebp

; 5553 :     }
; 5554 : }

	pop	ebx
	add	esp, 20					; 00000014H
	ret	0
??$_Make_heap_unchecked@PAPAVCPEDef@PS@@P6A_NPBV12@0@Z@std@@YAXPAPAVCPEDef@PS@@0P6A_NPBV12@1@Z@Z ENDP ; std::_Make_heap_unchecked<PS::CPEDef * *,bool (__cdecl*)(PS::CPEDef const *,PS::CPEDef const *)>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
;	COMDAT ??$_Sort_heap_unchecked@PAPAVCPEDef@PS@@P6A_NPBV12@0@Z@std@@YAXPAPAVCPEDef@PS@@0P6A_NPBV12@1@Z@Z
_TEXT	SEGMENT
__Val$1 = -4						; size = 4
__Pred$ = 8						; size = 4
??$_Sort_heap_unchecked@PAPAVCPEDef@PS@@P6A_NPBV12@0@Z@std@@YAXPAPAVCPEDef@PS@@0P6A_NPBV12@1@Z@Z PROC ; std::_Sort_heap_unchecked<PS::CPEDef * *,bool (__cdecl*)(PS::CPEDef const *,PS::CPEDef const *)>, COMDAT
; __First$ = ecx
; __Last$ = edx

; 5772 : _CONSTEXPR20 void _Sort_heap_unchecked(_RanIt _First, _RanIt _Last, _Pr _Pred) {

	push	ecx
	push	esi
	push	edi
	mov	esi, edx
	mov	edi, ecx

; 5773 :     // order heap by repeatedly popping
; 5774 :     for (; _Last - _First >= 2; --_Last) {

	sub	esi, edi
	mov	eax, esi
	and	eax, -4					; fffffffcH
	cmp	eax, 8
	jl	SHORT $LN3@Sort_heap_
	push	ebx
	mov	ebx, DWORD PTR __Pred$[esp+12]
	npad	8
$LL4@Sort_heap_:

; 5419 :         _Iter_value_t<_RanIt> _Val = _STD move(*_Last);

	mov	eax, DWORD PTR [edi+esi-4]

; 5410 :     _Pop_heap_hole_by_index(

	xor	edx, edx

; 5419 :         _Iter_value_t<_RanIt> _Val = _STD move(*_Last);

	mov	DWORD PTR __Val$1[esp+16], eax

; 5410 :     _Pop_heap_hole_by_index(

	mov	ecx, edi
	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR [edi+esi-4], eax
	lea	eax, DWORD PTR __Val$1[esp+16]
	push	ebx
	push	eax
	lea	eax, DWORD PTR [esi-4]
	sar	eax, 2
	push	eax
	call	??$_Pop_heap_hole_by_index@PAPAVCPEDef@PS@@PAV12@P6A_NPBV12@0@Z@std@@YAXPAPAVCPEDef@PS@@HH$$QAPAV12@P6A_NPBV12@2@Z@Z ; std::_Pop_heap_hole_by_index<PS::CPEDef * *,PS::CPEDef *,bool (__cdecl*)(PS::CPEDef const *,PS::CPEDef const *)>

; 5773 :     // order heap by repeatedly popping
; 5774 :     for (; _Last - _First >= 2; --_Last) {

	sub	esi, 4

; 5410 :     _Pop_heap_hole_by_index(

	add	esp, 12					; 0000000cH

; 5773 :     // order heap by repeatedly popping
; 5774 :     for (; _Last - _First >= 2; --_Last) {

	mov	eax, esi
	and	eax, -4					; fffffffcH
	cmp	eax, 8
	jge	SHORT $LL4@Sort_heap_
	pop	ebx
$LN3@Sort_heap_:
	pop	edi

; 5775 :         _Pop_heap_unchecked(_First, _Last, _Pred);
; 5776 :     }
; 5777 : }

	pop	esi
	pop	ecx
	ret	0
??$_Sort_heap_unchecked@PAPAVCPEDef@PS@@P6A_NPBV12@0@Z@std@@YAXPAPAVCPEDef@PS@@0P6A_NPBV12@1@Z@Z ENDP ; std::_Sort_heap_unchecked<PS::CPEDef * *,bool (__cdecl*)(PS::CPEDef const *,PS::CPEDef const *)>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
;	COMDAT ??$_Partition_by_median_guess_unchecked@PAPAVCPEDef@PS@@P6A_NPBV12@0@Z@std@@YA?AU?$pair@PAPAVCPEDef@PS@@PAPAV12@@0@PAPAVCPEDef@PS@@0P6A_NPBV23@1@Z@Z
_TEXT	SEGMENT
__Plast$1$ = -20					; size = 4
__Glast$1$ = -16					; size = 4
__First$1$ = -12					; size = 4
__Gfirst$1$ = -8					; size = 4
___$ReturnUdt$1$ = -4					; size = 4
__Last$ = 8						; size = 4
__Pred$ = 12						; size = 4
??$_Partition_by_median_guess_unchecked@PAPAVCPEDef@PS@@P6A_NPBV12@0@Z@std@@YA?AU?$pair@PAPAVCPEDef@PS@@PAPAV12@@0@PAPAVCPEDef@PS@@0P6A_NPBV23@1@Z@Z PROC ; std::_Partition_by_median_guess_unchecked<PS::CPEDef * *,bool (__cdecl*)(PS::CPEDef const *,PS::CPEDef const *)>, COMDAT
; ___$ReturnUdt$ = ecx
; __First$ = edx

; 6976 : _CONSTEXPR20 pair<_RanIt, _RanIt> _Partition_by_median_guess_unchecked(_RanIt _First, _RanIt _Last, _Pr _Pred) {

	sub	esp, 20					; 00000014H
	push	ebx
	push	ebp

; 6977 :     // partition [_First, _Last)
; 6978 :     _RanIt _Mid = _First + ((_Last - _First) >> 1); // shift for codegen
; 6979 :     _Guess_median_unchecked(_First, _Mid, _Prev_iter(_Last), _Pred);

	mov	ebp, DWORD PTR __Pred$[esp+24]
	mov	ebx, edx
	push	esi
	push	edi
	mov	edi, DWORD PTR __Last$[esp+32]
	mov	eax, edi
	sub	eax, ebx
	mov	DWORD PTR ___$ReturnUdt$1$[esp+36], ecx
	sar	eax, 3
	mov	ecx, ebx
	push	ebp
	mov	DWORD PTR __First$1$[esp+40], ebx
	lea	esi, DWORD PTR [ebx+eax*4]
	lea	eax, DWORD PTR [edi-4]
	mov	edx, esi
	push	eax
	call	??$_Guess_median_unchecked@PAPAVCPEDef@PS@@P6A_NPBV12@0@Z@std@@YAXPAPAVCPEDef@PS@@00P6A_NPBV12@1@Z@Z ; std::_Guess_median_unchecked<PS::CPEDef * *,bool (__cdecl*)(PS::CPEDef const *,PS::CPEDef const *)>
	add	esp, 8

; 6980 :     _RanIt _Pfirst = _Mid;
; 6981 :     _RanIt _Plast  = _Next_iter(_Pfirst);

	lea	ebx, DWORD PTR [esi+4]
	mov	DWORD PTR __Plast$1$[esp+36], ebx

; 6982 : 
; 6983 :     while (_First < _Pfirst && !_DEBUG_LT_PRED(_Pred, *_Prev_iter(_Pfirst), *_Pfirst)
; 6984 :            && !_Pred(*_Pfirst, *_Prev_iter(_Pfirst))) {

	cmp	DWORD PTR __First$1$[esp+36], esi
	jae	SHORT $LN66@Partition_
	mov	ebx, DWORD PTR __First$1$[esp+36]
$LL2@Partition_:
	push	DWORD PTR [esi]
	push	DWORD PTR [esi-4]
	call	ebp
	add	esp, 8
	test	al, al
	jne	SHORT $LN91@Partition_
	push	DWORD PTR [esi-4]
	push	DWORD PTR [esi]
	call	ebp
	add	esp, 8
	test	al, al
	jne	SHORT $LN91@Partition_

; 6985 :         --_Pfirst;

	add	esi, -4					; fffffffcH
	cmp	ebx, esi
	jb	SHORT $LL2@Partition_
$LN91@Partition_:
	mov	ebx, DWORD PTR __Plast$1$[esp+36]
$LN66@Partition_:

; 6986 :     }
; 6987 : 
; 6988 :     while (_Plast < _Last && !_DEBUG_LT_PRED(_Pred, *_Plast, *_Pfirst) && !_Pred(*_Pfirst, *_Plast)) {

	cmp	ebx, edi
	jae	SHORT $LN5@Partition_
$LL4@Partition_:
	push	DWORD PTR [esi]
	push	DWORD PTR [ebx]
	call	ebp
	add	esp, 8
	test	al, al
	jne	SHORT $LN92@Partition_
	push	DWORD PTR [ebx]
	push	DWORD PTR [esi]
	call	ebp
	add	esp, 8
	test	al, al
	jne	SHORT $LN92@Partition_

; 6989 :         ++_Plast;

	add	ebx, 4
	cmp	ebx, edi
	jb	SHORT $LL4@Partition_
$LN92@Partition_:
	mov	DWORD PTR __Plast$1$[esp+36], ebx
$LN5@Partition_:

; 6990 :     }
; 6991 : 
; 6992 :     _RanIt _Gfirst = _Plast;

	mov	edi, ebx

; 6993 :     _RanIt _Glast  = _Pfirst;

	mov	ebp, esi
$LN97@Partition_:

; 6996 :         for (; _Gfirst < _Last; ++_Gfirst) {

	mov	DWORD PTR __Glast$1$[esp+36], ebp
$LN96@Partition_:
	mov	DWORD PTR __Gfirst$1$[esp+36], edi
$LL6@Partition_:
	cmp	edi, DWORD PTR __Last$[esp+32]
	jae	SHORT $LN70@Partition_
	mov	ebp, DWORD PTR __Last$[esp+32]
	npad	5
$LL11@Partition_:

; 6997 :             if (_DEBUG_LT_PRED(_Pred, *_Pfirst, *_Gfirst)) {

	push	DWORD PTR [edi]
	push	DWORD PTR [esi]
	call	DWORD PTR __Pred$[esp+40]
	add	esp, 8
	test	al, al
	jne	SHORT $LN9@Partition_

; 6998 :                 continue;
; 6999 :             } else if (_Pred(*_Gfirst, *_Pfirst)) {

	push	DWORD PTR [esi]
	push	DWORD PTR [edi]
	call	DWORD PTR __Pred$[esp+40]
	add	esp, 8
	test	al, al
	jne	SHORT $LN93@Partition_

; 7000 :                 break;
; 7001 :             } else if (_Plast != _Gfirst) {

	cmp	ebx, edi
	je	SHORT $LN19@Partition_
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 100  :     _Ty _Tmp = _STD move(_Left);

	mov	ecx, DWORD PTR [ebx]

; 101  :     _Left    = _STD move(_Right);

	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR [ebx], eax

; 102  :     _Right   = _STD move(_Tmp);

	mov	DWORD PTR [edi], ecx
$LN19@Partition_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 6996 :         for (; _Gfirst < _Last; ++_Gfirst) {

	add	ebx, 4
$LN9@Partition_:
	add	edi, 4
	cmp	edi, ebp
	jb	SHORT $LL11@Partition_
$LN93@Partition_:
	mov	ebp, DWORD PTR __Glast$1$[esp+36]
	mov	DWORD PTR __Plast$1$[esp+36], ebx
	mov	DWORD PTR __Gfirst$1$[esp+36], edi
$LN70@Partition_:

; 7009 :         for (; _First < _Glast; --_Glast) {

	mov	eax, DWORD PTR __First$1$[esp+36]
	cmp	ebp, eax
	jbe	SHORT $LN95@Partition_
	mov	edi, DWORD PTR __Glast$1$[esp+36]
	mov	ebx, eax
	lea	ebp, DWORD PTR [edi-4]
$LL14@Partition_:

; 7010 :             if (_DEBUG_LT_PRED(_Pred, *_Prev_iter(_Glast), *_Pfirst)) {

	push	DWORD PTR [esi]
	push	DWORD PTR [ebp]
	call	DWORD PTR __Pred$[esp+40]
	add	esp, 8
	test	al, al
	jne	SHORT $LN12@Partition_

; 7011 :                 continue;
; 7012 :             } else if (_Pred(*_Pfirst, *_Prev_iter(_Glast))) {

	push	DWORD PTR [ebp]
	push	DWORD PTR [esi]
	call	DWORD PTR __Pred$[esp+40]
	add	esp, 8
	test	al, al
	jne	SHORT $LN94@Partition_

; 7013 :                 break;
; 7014 :             } else if (--_Pfirst != _Prev_iter(_Glast)) {

	sub	esi, 4
	cmp	esi, ebp
	je	SHORT $LN12@Partition_
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 100  :     _Ty _Tmp = _STD move(_Left);

	mov	ecx, DWORD PTR [esi]

; 101  :     _Left    = _STD move(_Right);

	mov	eax, DWORD PTR [ebp]
	mov	DWORD PTR [esi], eax

; 102  :     _Right   = _STD move(_Tmp);

	mov	DWORD PTR [ebp], ecx
$LN12@Partition_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 7009 :         for (; _First < _Glast; --_Glast) {

	sub	edi, 4
	sub	ebp, 4
	cmp	ebx, edi
	jb	SHORT $LL14@Partition_
$LN94@Partition_:
	mov	eax, DWORD PTR __First$1$[esp+36]
	mov	ebx, DWORD PTR __Plast$1$[esp+36]
	mov	DWORD PTR __Glast$1$[esp+36], edi
	mov	ebp, DWORD PTR __Glast$1$[esp+36]

; 7015 :                 _STD iter_swap(_Pfirst, _Prev_iter(_Glast));
; 7016 :             }
; 7017 :         }
; 7018 : 
; 7019 :         if (_Glast == _First && _Gfirst == _Last) {

	cmp	ebp, eax
	mov	edi, DWORD PTR __Gfirst$1$[esp+36]
$LN95@Partition_:
	jne	SHORT $LN27@Partition_
	cmp	edi, DWORD PTR __Last$[esp+32]
	je	SHORT $LN72@Partition_

; 7021 :         }
; 7022 : 
; 7023 :         if (_Glast == _First) { // no room at bottom, rotate pivot upward
; 7024 :             if (_Plast != _Gfirst) {

	cmp	ebx, edi
	je	SHORT $LN29@Partition_
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 100  :     _Ty _Tmp = _STD move(_Left);

	mov	ecx, DWORD PTR [esi]

; 101  :     _Left    = _STD move(_Right);

	mov	eax, DWORD PTR [ebx]
	mov	DWORD PTR [esi], eax

; 102  :     _Right   = _STD move(_Tmp);

	mov	DWORD PTR [ebx], ecx
$LN29@Partition_:

; 100  :     _Ty _Tmp = _STD move(_Left);

	mov	ecx, DWORD PTR [esi]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 7028 :             ++_Plast;

	add	ebx, 4
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 101  :     _Left    = _STD move(_Right);

	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR [esi], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 7030 :             ++_Pfirst;

	add	esi, 4
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 102  :     _Right   = _STD move(_Tmp);

	mov	DWORD PTR [edi], ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 7031 :             ++_Gfirst;

	add	edi, 4
	mov	DWORD PTR __Plast$1$[esp+36], ebx
	jmp	$LN96@Partition_
$LN27@Partition_:

; 7032 :         } else if (_Gfirst == _Last) { // no room at top, rotate pivot downward

	add	ebp, -4					; fffffffcH
	mov	DWORD PTR __Glast$1$[esp+36], ebp
	cmp	edi, DWORD PTR __Last$[esp+32]
	jne	SHORT $LN30@Partition_

; 7033 :             if (--_Glast != --_Pfirst) {

	sub	esi, 4
	cmp	ebp, esi
	je	SHORT $LN82@Partition_
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 101  :     _Left    = _STD move(_Right);

	mov	eax, DWORD PTR [esi]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 7037 :             _STD iter_swap(_Pfirst, --_Plast);

	sub	ebx, 4
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 100  :     _Ty _Tmp = _STD move(_Left);

	mov	ecx, DWORD PTR [ebp]

; 101  :     _Left    = _STD move(_Right);

	mov	DWORD PTR [ebp], eax

; 102  :     _Right   = _STD move(_Tmp);

	mov	DWORD PTR [esi], ecx

; 101  :     _Left    = _STD move(_Right);

	mov	eax, DWORD PTR [ebx]
	mov	DWORD PTR [esi], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 7037 :             _STD iter_swap(_Pfirst, --_Plast);

	mov	DWORD PTR __Plast$1$[esp+36], ebx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 102  :     _Right   = _STD move(_Tmp);

	mov	DWORD PTR [ebx], ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 7038 :         } else {

	jmp	$LL6@Partition_
$LN82@Partition_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 102  :     _Right   = _STD move(_Tmp);

	mov	ecx, DWORD PTR [esi]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 7037 :             _STD iter_swap(_Pfirst, --_Plast);

	sub	ebx, 4
	mov	DWORD PTR __Plast$1$[esp+36], ebx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 101  :     _Left    = _STD move(_Right);

	mov	eax, DWORD PTR [ebx]
	mov	DWORD PTR [esi], eax

; 102  :     _Right   = _STD move(_Tmp);

	mov	DWORD PTR [ebx], ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 7038 :         } else {

	jmp	$LL6@Partition_
$LN30@Partition_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 100  :     _Ty _Tmp = _STD move(_Left);

	mov	ecx, DWORD PTR [edi]

; 101  :     _Left    = _STD move(_Right);

	mov	eax, DWORD PTR [ebp]
	mov	DWORD PTR [edi], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 7040 :             ++_Gfirst;

	add	edi, 4
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 102  :     _Right   = _STD move(_Tmp);

	mov	DWORD PTR [ebp], ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 7042 :     }

	jmp	$LN97@Partition_
$LN72@Partition_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 186  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

	mov	eax, DWORD PTR ___$ReturnUdt$1$[esp+36]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 7020 :             return pair<_RanIt, _RanIt>(_Pfirst, _Plast);

	pop	edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 186  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

	mov	DWORD PTR [eax], esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 7020 :             return pair<_RanIt, _RanIt>(_Pfirst, _Plast);

	pop	esi
	pop	ebp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 186  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

	mov	DWORD PTR [eax+4], ebx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 7020 :             return pair<_RanIt, _RanIt>(_Pfirst, _Plast);

	pop	ebx

; 7043 : }

	add	esp, 20					; 00000014H
	ret	0
??$_Partition_by_median_guess_unchecked@PAPAVCPEDef@PS@@P6A_NPBV12@0@Z@std@@YA?AU?$pair@PAPAVCPEDef@PS@@PAPAV12@@0@PAPAVCPEDef@PS@@0P6A_NPBV23@1@Z@Z ENDP ; std::_Partition_by_median_guess_unchecked<PS::CPEDef * *,bool (__cdecl*)(PS::CPEDef const *,PS::CPEDef const *)>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
;	COMDAT ??$_Insertion_sort_unchecked@PAPAVCPGDef@PS@@P6A_NPBV12@0@Z@std@@YAPAPAVCPGDef@PS@@QAPAV12@0P6A_NPBV12@1@Z@Z
_TEXT	SEGMENT
__First$1$ = -8						; size = 4
__Last$1$ = -4						; size = 4
__Pred$ = 8						; size = 4
??$_Insertion_sort_unchecked@PAPAVCPGDef@PS@@P6A_NPBV12@0@Z@std@@YAPAPAVCPGDef@PS@@QAPAV12@0P6A_NPBV12@1@Z@Z PROC ; std::_Insertion_sort_unchecked<PS::CPGDef * *,bool (__cdecl*)(PS::CPGDef const *,PS::CPGDef const *)>, COMDAT
; __First$ = ecx
; __Last$ = edx

; 6919 : _CONSTEXPR20 _BidIt _Insertion_sort_unchecked(const _BidIt _First, const _BidIt _Last, _Pr _Pred) {

	sub	esp, 8
	push	esi
	mov	eax, edx
	mov	esi, ecx
	mov	DWORD PTR __Last$1$[esp+12], eax
	mov	DWORD PTR __First$1$[esp+12], esi

; 6920 :     // insertion sort [_First, _Last)
; 6921 :     if (_First != _Last) {

	cmp	esi, eax
	je	SHORT $LN3@Insertion_

; 6922 :         for (_BidIt _Mid = _First; ++_Mid != _Last;) { // order next element

	push	edi
	lea	edi, DWORD PTR [esi+4]
	cmp	edi, eax
	je	SHORT $LN27@Insertion_
	push	ebx
	push	ebp
	npad	2
$LL2@Insertion_:

; 6923 :             _BidIt _Hole               = _Mid;
; 6924 :             _Iter_value_t<_BidIt> _Val = _STD move(*_Mid);
; 6925 : 
; 6926 :             if (_DEBUG_LT_PRED(_Pred, _Val, *_First)) { // found new earliest element, move to front

	push	DWORD PTR [esi]
	mov	ebx, DWORD PTR [edi]
	mov	ebp, edi
	push	ebx
	call	DWORD PTR __Pred$[esp+28]
	add	esp, 8
	test	al, al
	je	SHORT $LN9@Insertion_
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility

; 4254 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	mov	ecx, edi

; 4255 :     auto _Result                = _CSTD memmove(_Dest_ch - _Count, _First_ch, _Count);

	mov	eax, edi
	sub	ecx, esi
	push	ecx
	sub	eax, ecx
	add	eax, 4
	push	esi
	push	eax
	call	_memmove
	add	esp, 12					; 0000000cH
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 6928 :                 *_First = _STD move(_Val);

	mov	DWORD PTR [esi], ebx

; 6929 :             } else { // look for insertion point after first

	jmp	SHORT $LN10@Insertion_
$LN9@Insertion_:

; 6930 :                 for (_BidIt _Prev = _Hole; _DEBUG_LT_PRED(_Pred, _Val, *--_Prev); _Hole = _Prev) {

	push	DWORD PTR [edi-4]
	lea	esi, DWORD PTR [edi-4]
	push	ebx
	call	DWORD PTR __Pred$[esp+28]
	add	esp, 8
	test	al, al
	je	SHORT $LN6@Insertion_
	npad	2
$LL7@Insertion_:

; 6931 :                     *_Hole = _STD move(*_Prev); // move hole down

	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [ebp], eax
	mov	ebp, esi
	push	DWORD PTR [esi-4]
	sub	esi, 4
	push	ebx
	call	DWORD PTR __Pred$[esp+28]
	add	esp, 8
	test	al, al
	jne	SHORT $LL7@Insertion_
$LN6@Insertion_:
	mov	esi, DWORD PTR __First$1$[esp+24]

; 6932 :                 }
; 6933 : 
; 6934 :                 *_Hole = _STD move(_Val); // insert element in hole

	mov	DWORD PTR [ebp], ebx
$LN10@Insertion_:

; 6922 :         for (_BidIt _Mid = _First; ++_Mid != _Last;) { // order next element

	mov	eax, DWORD PTR __Last$1$[esp+24]
	add	edi, 4
	cmp	edi, eax
	jne	SHORT $LL2@Insertion_

; 6935 :             }
; 6936 :         }
; 6937 :     }
; 6938 : 
; 6939 :     return _Last;

	pop	ebp
	pop	ebx
$LN27@Insertion_:
	pop	edi
$LN3@Insertion_:
	pop	esi

; 6940 : }

	add	esp, 8
	ret	0
??$_Insertion_sort_unchecked@PAPAVCPGDef@PS@@P6A_NPBV12@0@Z@std@@YAPAPAVCPGDef@PS@@QAPAV12@0P6A_NPBV12@1@Z@Z ENDP ; std::_Insertion_sort_unchecked<PS::CPGDef * *,bool (__cdecl*)(PS::CPGDef const *,PS::CPGDef const *)>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
;	COMDAT ??$_Make_heap_unchecked@PAPAVCPGDef@PS@@P6A_NPBV12@0@Z@std@@YAXPAPAVCPGDef@PS@@0P6A_NPBV12@1@Z@Z
_TEXT	SEGMENT
__Val$1$ = -20						; size = 4
__Max_sequence_non_leaf$1$ = -16			; size = 4
__Hole$1$ = -12						; size = 4
__Bottom$1$ = -8					; size = 4
tv268 = -4						; size = 4
__Pred$ = 8						; size = 4
??$_Make_heap_unchecked@PAPAVCPGDef@PS@@P6A_NPBV12@0@Z@std@@YAXPAPAVCPGDef@PS@@0P6A_NPBV12@1@Z@Z PROC ; std::_Make_heap_unchecked<PS::CPGDef * *,bool (__cdecl*)(PS::CPGDef const *,PS::CPGDef const *)>, COMDAT
; __First$ = ecx
; __Last$ = edx

; 5544 : _CONSTEXPR20 void _Make_heap_unchecked(_RanIt _First, _RanIt _Last, _Pr _Pred) {

	sub	esp, 20					; 00000014H
	push	ebx
	mov	eax, edx
	mov	ebx, ecx

; 5545 :     // make [_First, _Last) into a heap
; 5546 :     using _Diff   = _Iter_diff_t<_RanIt>;
; 5547 :     _Diff _Bottom = _Last - _First;

	sub	eax, ebx
	sar	eax, 2
	push	ebp

; 5548 :     for (_Diff _Hole = _Bottom >> 1; _Hole > 0;) { // shift for codegen

	mov	ebp, eax
	mov	DWORD PTR __Bottom$1$[esp+28], eax
	sar	ebp, 1
	test	ebp, ebp
	jle	$LN3@Make_heap_

; 5385 :     const _Diff _Max_sequence_non_leaf = (_Bottom - 1) >> 1; // shift for codegen

	mov	ecx, DWORD PTR __Pred$[esp+24]
	dec	eax
	mov	DWORD PTR tv268[esp+28], eax
	sar	eax, 1
	push	esi
	mov	DWORD PTR __Max_sequence_non_leaf$1$[esp+32], eax
	push	edi
	npad	1
$LL2@Make_heap_:

; 5549 :         // reheap top half, bottom to top
; 5550 :         --_Hole;
; 5551 :         _Iter_value_t<_RanIt> _Val = _STD move(*(_First + _Hole));

	mov	edx, DWORD PTR [ebx+ebp*4-4]
	dec	ebp
	mov	DWORD PTR __Hole$1$[esp+36], ebp

; 5552 :         _Pop_heap_hole_by_index(_First, _Hole, _Bottom, _STD move(_Val), _Pred);

	mov	edi, ebp
	mov	DWORD PTR __Val$1$[esp+36], edx

; 5381 :     _Diff _Idx       = _Hole;

	mov	esi, ebp

; 5386 :     while (_Idx < _Max_sequence_non_leaf) { // move _Hole down to larger child

	cmp	ebp, eax
	jge	SHORT $LN8@Make_heap_
	mov	ebp, DWORD PTR __Max_sequence_non_leaf$1$[esp+36]
	npad	7
$LL7@Make_heap_:

; 5387 :         _Idx = 2 * _Idx + 2;
; 5388 :         if (_DEBUG_LT_PRED(_Pred, *(_First + _Idx), *(_First + (_Idx - 1)))) {

	push	DWORD PTR [ebx+esi*8+4]
	lea	esi, DWORD PTR [esi*2+2]
	push	DWORD PTR [ebx+esi*4]
	call	ecx
	add	esp, 8
	test	al, al
	je	SHORT $LN9@Make_heap_

; 5389 :             --_Idx;

	dec	esi
$LN9@Make_heap_:

; 5390 :         }
; 5391 :         *(_First + _Hole) = _STD move(*(_First + _Idx));

	mov	eax, DWORD PTR [ebx+esi*4]
	mov	ecx, DWORD PTR __Pred$[esp+32]
	mov	DWORD PTR [ebx+edi*4], eax

; 5392 :         _Hole             = _Idx;

	mov	edi, esi
	cmp	esi, ebp
	jl	SHORT $LL7@Make_heap_
	mov	ebp, DWORD PTR __Hole$1$[esp+36]
	mov	eax, DWORD PTR __Max_sequence_non_leaf$1$[esp+36]
	mov	edx, DWORD PTR __Val$1$[esp+36]
$LN8@Make_heap_:

; 5393 :     }
; 5394 : 
; 5395 :     if (_Idx == _Max_sequence_non_leaf && _Bottom % 2 == 0) { // only child at bottom, move _Hole down to it

	cmp	esi, eax
	jne	SHORT $LN10@Make_heap_
	mov	eax, DWORD PTR __Bottom$1$[esp+36]
	test	al, 1
	jne	SHORT $LN10@Make_heap_

; 5396 :         *(_First + _Hole) = _STD move(*(_First + (_Bottom - 1)));

	mov	eax, DWORD PTR [ebx+eax*4-4]
	mov	DWORD PTR [ebx+edi*4], eax

; 5397 :         _Hole             = _Bottom - 1;

	mov	edi, DWORD PTR tv268[esp+36]
$LN10@Make_heap_:

; 5268 :          _Top < _Hole && _DEBUG_LT_PRED(_Pred, *(_First + _Idx), _Val); //

	cmp	ebp, edi
	jge	SHORT $LN29@Make_heap_
	npad	1
$LL15@Make_heap_:

; 5267 :     for (_Diff _Idx = (_Hole - 1) >> 1; // shift for codegen

	lea	esi, DWORD PTR [edi-1]
	sar	esi, 1

; 5268 :          _Top < _Hole && _DEBUG_LT_PRED(_Pred, *(_First + _Idx), _Val); //

	push	edx
	push	DWORD PTR [ebx+esi*4]
	call	ecx
	add	esp, 8
	test	al, al
	je	SHORT $LN29@Make_heap_

; 5269 :          _Idx = (_Hole - 1) >> 1) { // shift for codegen
; 5270 :         // move _Hole up to parent
; 5271 :         *(_First + _Hole) = _STD move(*(_First + _Idx));

	mov	eax, DWORD PTR [ebx+esi*4]
	mov	ecx, DWORD PTR __Pred$[esp+32]
	mov	edx, DWORD PTR __Val$1$[esp+36]
	mov	DWORD PTR [ebx+edi*4], eax

; 5272 :         _Hole             = _Idx;

	mov	edi, esi
	cmp	ebp, esi
	jl	SHORT $LL15@Make_heap_
$LN29@Make_heap_:

; 5273 :     }
; 5274 : 
; 5275 :     *(_First + _Hole) = _STD forward<_Ty>(_Val); // drop _Val into final hole

	mov	eax, DWORD PTR __Val$1$[esp+36]

; 5548 :     for (_Diff _Hole = _Bottom >> 1; _Hole > 0;) { // shift for codegen

	mov	ecx, DWORD PTR __Pred$[esp+32]

; 5275 :     *(_First + _Hole) = _STD forward<_Ty>(_Val); // drop _Val into final hole

	mov	DWORD PTR [ebx+edi*4], eax

; 5548 :     for (_Diff _Hole = _Bottom >> 1; _Hole > 0;) { // shift for codegen

	mov	eax, DWORD PTR __Max_sequence_non_leaf$1$[esp+36]
	test	ebp, ebp
	jg	$LL2@Make_heap_
	pop	edi
	pop	esi
$LN3@Make_heap_:
	pop	ebp

; 5553 :     }
; 5554 : }

	pop	ebx
	add	esp, 20					; 00000014H
	ret	0
??$_Make_heap_unchecked@PAPAVCPGDef@PS@@P6A_NPBV12@0@Z@std@@YAXPAPAVCPGDef@PS@@0P6A_NPBV12@1@Z@Z ENDP ; std::_Make_heap_unchecked<PS::CPGDef * *,bool (__cdecl*)(PS::CPGDef const *,PS::CPGDef const *)>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
;	COMDAT ??$_Sort_heap_unchecked@PAPAVCPGDef@PS@@P6A_NPBV12@0@Z@std@@YAXPAPAVCPGDef@PS@@0P6A_NPBV12@1@Z@Z
_TEXT	SEGMENT
__Val$1 = -4						; size = 4
__Pred$ = 8						; size = 4
??$_Sort_heap_unchecked@PAPAVCPGDef@PS@@P6A_NPBV12@0@Z@std@@YAXPAPAVCPGDef@PS@@0P6A_NPBV12@1@Z@Z PROC ; std::_Sort_heap_unchecked<PS::CPGDef * *,bool (__cdecl*)(PS::CPGDef const *,PS::CPGDef const *)>, COMDAT
; __First$ = ecx
; __Last$ = edx

; 5772 : _CONSTEXPR20 void _Sort_heap_unchecked(_RanIt _First, _RanIt _Last, _Pr _Pred) {

	push	ecx
	push	esi
	push	edi
	mov	esi, edx
	mov	edi, ecx

; 5773 :     // order heap by repeatedly popping
; 5774 :     for (; _Last - _First >= 2; --_Last) {

	sub	esi, edi
	mov	eax, esi
	and	eax, -4					; fffffffcH
	cmp	eax, 8
	jl	SHORT $LN3@Sort_heap_
	push	ebx
	mov	ebx, DWORD PTR __Pred$[esp+12]
	npad	8
$LL4@Sort_heap_:

; 5419 :         _Iter_value_t<_RanIt> _Val = _STD move(*_Last);

	mov	eax, DWORD PTR [edi+esi-4]

; 5410 :     _Pop_heap_hole_by_index(

	xor	edx, edx

; 5419 :         _Iter_value_t<_RanIt> _Val = _STD move(*_Last);

	mov	DWORD PTR __Val$1[esp+16], eax

; 5410 :     _Pop_heap_hole_by_index(

	mov	ecx, edi
	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR [edi+esi-4], eax
	lea	eax, DWORD PTR __Val$1[esp+16]
	push	ebx
	push	eax
	lea	eax, DWORD PTR [esi-4]
	sar	eax, 2
	push	eax
	call	??$_Pop_heap_hole_by_index@PAPAVCPGDef@PS@@PAV12@P6A_NPBV12@0@Z@std@@YAXPAPAVCPGDef@PS@@HH$$QAPAV12@P6A_NPBV12@2@Z@Z ; std::_Pop_heap_hole_by_index<PS::CPGDef * *,PS::CPGDef *,bool (__cdecl*)(PS::CPGDef const *,PS::CPGDef const *)>

; 5773 :     // order heap by repeatedly popping
; 5774 :     for (; _Last - _First >= 2; --_Last) {

	sub	esi, 4

; 5410 :     _Pop_heap_hole_by_index(

	add	esp, 12					; 0000000cH

; 5773 :     // order heap by repeatedly popping
; 5774 :     for (; _Last - _First >= 2; --_Last) {

	mov	eax, esi
	and	eax, -4					; fffffffcH
	cmp	eax, 8
	jge	SHORT $LL4@Sort_heap_
	pop	ebx
$LN3@Sort_heap_:
	pop	edi

; 5775 :         _Pop_heap_unchecked(_First, _Last, _Pred);
; 5776 :     }
; 5777 : }

	pop	esi
	pop	ecx
	ret	0
??$_Sort_heap_unchecked@PAPAVCPGDef@PS@@P6A_NPBV12@0@Z@std@@YAXPAPAVCPGDef@PS@@0P6A_NPBV12@1@Z@Z ENDP ; std::_Sort_heap_unchecked<PS::CPGDef * *,bool (__cdecl*)(PS::CPGDef const *,PS::CPGDef const *)>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
;	COMDAT ??$_Partition_by_median_guess_unchecked@PAPAVCPGDef@PS@@P6A_NPBV12@0@Z@std@@YA?AU?$pair@PAPAVCPGDef@PS@@PAPAV12@@0@PAPAVCPGDef@PS@@0P6A_NPBV23@1@Z@Z
_TEXT	SEGMENT
__Plast$1$ = -20					; size = 4
__Glast$1$ = -16					; size = 4
__First$1$ = -12					; size = 4
__Gfirst$1$ = -8					; size = 4
___$ReturnUdt$1$ = -4					; size = 4
__Last$ = 8						; size = 4
__Pred$ = 12						; size = 4
??$_Partition_by_median_guess_unchecked@PAPAVCPGDef@PS@@P6A_NPBV12@0@Z@std@@YA?AU?$pair@PAPAVCPGDef@PS@@PAPAV12@@0@PAPAVCPGDef@PS@@0P6A_NPBV23@1@Z@Z PROC ; std::_Partition_by_median_guess_unchecked<PS::CPGDef * *,bool (__cdecl*)(PS::CPGDef const *,PS::CPGDef const *)>, COMDAT
; ___$ReturnUdt$ = ecx
; __First$ = edx

; 6976 : _CONSTEXPR20 pair<_RanIt, _RanIt> _Partition_by_median_guess_unchecked(_RanIt _First, _RanIt _Last, _Pr _Pred) {

	sub	esp, 20					; 00000014H
	push	ebx
	push	ebp

; 6977 :     // partition [_First, _Last)
; 6978 :     _RanIt _Mid = _First + ((_Last - _First) >> 1); // shift for codegen
; 6979 :     _Guess_median_unchecked(_First, _Mid, _Prev_iter(_Last), _Pred);

	mov	ebp, DWORD PTR __Pred$[esp+24]
	mov	ebx, edx
	push	esi
	push	edi
	mov	edi, DWORD PTR __Last$[esp+32]
	mov	eax, edi
	sub	eax, ebx
	mov	DWORD PTR ___$ReturnUdt$1$[esp+36], ecx
	sar	eax, 3
	mov	ecx, ebx
	push	ebp
	mov	DWORD PTR __First$1$[esp+40], ebx
	lea	esi, DWORD PTR [ebx+eax*4]
	lea	eax, DWORD PTR [edi-4]
	mov	edx, esi
	push	eax
	call	??$_Guess_median_unchecked@PAPAVCPGDef@PS@@P6A_NPBV12@0@Z@std@@YAXPAPAVCPGDef@PS@@00P6A_NPBV12@1@Z@Z ; std::_Guess_median_unchecked<PS::CPGDef * *,bool (__cdecl*)(PS::CPGDef const *,PS::CPGDef const *)>
	add	esp, 8

; 6980 :     _RanIt _Pfirst = _Mid;
; 6981 :     _RanIt _Plast  = _Next_iter(_Pfirst);

	lea	ebx, DWORD PTR [esi+4]
	mov	DWORD PTR __Plast$1$[esp+36], ebx

; 6982 : 
; 6983 :     while (_First < _Pfirst && !_DEBUG_LT_PRED(_Pred, *_Prev_iter(_Pfirst), *_Pfirst)
; 6984 :            && !_Pred(*_Pfirst, *_Prev_iter(_Pfirst))) {

	cmp	DWORD PTR __First$1$[esp+36], esi
	jae	SHORT $LN66@Partition_
	mov	ebx, DWORD PTR __First$1$[esp+36]
$LL2@Partition_:
	push	DWORD PTR [esi]
	push	DWORD PTR [esi-4]
	call	ebp
	add	esp, 8
	test	al, al
	jne	SHORT $LN91@Partition_
	push	DWORD PTR [esi-4]
	push	DWORD PTR [esi]
	call	ebp
	add	esp, 8
	test	al, al
	jne	SHORT $LN91@Partition_

; 6985 :         --_Pfirst;

	add	esi, -4					; fffffffcH
	cmp	ebx, esi
	jb	SHORT $LL2@Partition_
$LN91@Partition_:
	mov	ebx, DWORD PTR __Plast$1$[esp+36]
$LN66@Partition_:

; 6986 :     }
; 6987 : 
; 6988 :     while (_Plast < _Last && !_DEBUG_LT_PRED(_Pred, *_Plast, *_Pfirst) && !_Pred(*_Pfirst, *_Plast)) {

	cmp	ebx, edi
	jae	SHORT $LN5@Partition_
$LL4@Partition_:
	push	DWORD PTR [esi]
	push	DWORD PTR [ebx]
	call	ebp
	add	esp, 8
	test	al, al
	jne	SHORT $LN92@Partition_
	push	DWORD PTR [ebx]
	push	DWORD PTR [esi]
	call	ebp
	add	esp, 8
	test	al, al
	jne	SHORT $LN92@Partition_

; 6989 :         ++_Plast;

	add	ebx, 4
	cmp	ebx, edi
	jb	SHORT $LL4@Partition_
$LN92@Partition_:
	mov	DWORD PTR __Plast$1$[esp+36], ebx
$LN5@Partition_:

; 6990 :     }
; 6991 : 
; 6992 :     _RanIt _Gfirst = _Plast;

	mov	edi, ebx

; 6993 :     _RanIt _Glast  = _Pfirst;

	mov	ebp, esi
$LN97@Partition_:

; 6996 :         for (; _Gfirst < _Last; ++_Gfirst) {

	mov	DWORD PTR __Glast$1$[esp+36], ebp
$LN96@Partition_:
	mov	DWORD PTR __Gfirst$1$[esp+36], edi
$LL6@Partition_:
	cmp	edi, DWORD PTR __Last$[esp+32]
	jae	SHORT $LN70@Partition_
	mov	ebp, DWORD PTR __Last$[esp+32]
	npad	5
$LL11@Partition_:

; 6997 :             if (_DEBUG_LT_PRED(_Pred, *_Pfirst, *_Gfirst)) {

	push	DWORD PTR [edi]
	push	DWORD PTR [esi]
	call	DWORD PTR __Pred$[esp+40]
	add	esp, 8
	test	al, al
	jne	SHORT $LN9@Partition_

; 6998 :                 continue;
; 6999 :             } else if (_Pred(*_Gfirst, *_Pfirst)) {

	push	DWORD PTR [esi]
	push	DWORD PTR [edi]
	call	DWORD PTR __Pred$[esp+40]
	add	esp, 8
	test	al, al
	jne	SHORT $LN93@Partition_

; 7000 :                 break;
; 7001 :             } else if (_Plast != _Gfirst) {

	cmp	ebx, edi
	je	SHORT $LN19@Partition_
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 100  :     _Ty _Tmp = _STD move(_Left);

	mov	ecx, DWORD PTR [ebx]

; 101  :     _Left    = _STD move(_Right);

	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR [ebx], eax

; 102  :     _Right   = _STD move(_Tmp);

	mov	DWORD PTR [edi], ecx
$LN19@Partition_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 6996 :         for (; _Gfirst < _Last; ++_Gfirst) {

	add	ebx, 4
$LN9@Partition_:
	add	edi, 4
	cmp	edi, ebp
	jb	SHORT $LL11@Partition_
$LN93@Partition_:
	mov	ebp, DWORD PTR __Glast$1$[esp+36]
	mov	DWORD PTR __Plast$1$[esp+36], ebx
	mov	DWORD PTR __Gfirst$1$[esp+36], edi
$LN70@Partition_:

; 7009 :         for (; _First < _Glast; --_Glast) {

	mov	eax, DWORD PTR __First$1$[esp+36]
	cmp	ebp, eax
	jbe	SHORT $LN95@Partition_
	mov	edi, DWORD PTR __Glast$1$[esp+36]
	mov	ebx, eax
	lea	ebp, DWORD PTR [edi-4]
$LL14@Partition_:

; 7010 :             if (_DEBUG_LT_PRED(_Pred, *_Prev_iter(_Glast), *_Pfirst)) {

	push	DWORD PTR [esi]
	push	DWORD PTR [ebp]
	call	DWORD PTR __Pred$[esp+40]
	add	esp, 8
	test	al, al
	jne	SHORT $LN12@Partition_

; 7011 :                 continue;
; 7012 :             } else if (_Pred(*_Pfirst, *_Prev_iter(_Glast))) {

	push	DWORD PTR [ebp]
	push	DWORD PTR [esi]
	call	DWORD PTR __Pred$[esp+40]
	add	esp, 8
	test	al, al
	jne	SHORT $LN94@Partition_

; 7013 :                 break;
; 7014 :             } else if (--_Pfirst != _Prev_iter(_Glast)) {

	sub	esi, 4
	cmp	esi, ebp
	je	SHORT $LN12@Partition_
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 100  :     _Ty _Tmp = _STD move(_Left);

	mov	ecx, DWORD PTR [esi]

; 101  :     _Left    = _STD move(_Right);

	mov	eax, DWORD PTR [ebp]
	mov	DWORD PTR [esi], eax

; 102  :     _Right   = _STD move(_Tmp);

	mov	DWORD PTR [ebp], ecx
$LN12@Partition_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 7009 :         for (; _First < _Glast; --_Glast) {

	sub	edi, 4
	sub	ebp, 4
	cmp	ebx, edi
	jb	SHORT $LL14@Partition_
$LN94@Partition_:
	mov	eax, DWORD PTR __First$1$[esp+36]
	mov	ebx, DWORD PTR __Plast$1$[esp+36]
	mov	DWORD PTR __Glast$1$[esp+36], edi
	mov	ebp, DWORD PTR __Glast$1$[esp+36]

; 7015 :                 _STD iter_swap(_Pfirst, _Prev_iter(_Glast));
; 7016 :             }
; 7017 :         }
; 7018 : 
; 7019 :         if (_Glast == _First && _Gfirst == _Last) {

	cmp	ebp, eax
	mov	edi, DWORD PTR __Gfirst$1$[esp+36]
$LN95@Partition_:
	jne	SHORT $LN27@Partition_
	cmp	edi, DWORD PTR __Last$[esp+32]
	je	SHORT $LN72@Partition_

; 7021 :         }
; 7022 : 
; 7023 :         if (_Glast == _First) { // no room at bottom, rotate pivot upward
; 7024 :             if (_Plast != _Gfirst) {

	cmp	ebx, edi
	je	SHORT $LN29@Partition_
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 100  :     _Ty _Tmp = _STD move(_Left);

	mov	ecx, DWORD PTR [esi]

; 101  :     _Left    = _STD move(_Right);

	mov	eax, DWORD PTR [ebx]
	mov	DWORD PTR [esi], eax

; 102  :     _Right   = _STD move(_Tmp);

	mov	DWORD PTR [ebx], ecx
$LN29@Partition_:

; 100  :     _Ty _Tmp = _STD move(_Left);

	mov	ecx, DWORD PTR [esi]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 7028 :             ++_Plast;

	add	ebx, 4
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 101  :     _Left    = _STD move(_Right);

	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR [esi], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 7030 :             ++_Pfirst;

	add	esi, 4
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 102  :     _Right   = _STD move(_Tmp);

	mov	DWORD PTR [edi], ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 7031 :             ++_Gfirst;

	add	edi, 4
	mov	DWORD PTR __Plast$1$[esp+36], ebx
	jmp	$LN96@Partition_
$LN27@Partition_:

; 7032 :         } else if (_Gfirst == _Last) { // no room at top, rotate pivot downward

	add	ebp, -4					; fffffffcH
	mov	DWORD PTR __Glast$1$[esp+36], ebp
	cmp	edi, DWORD PTR __Last$[esp+32]
	jne	SHORT $LN30@Partition_

; 7033 :             if (--_Glast != --_Pfirst) {

	sub	esi, 4
	cmp	ebp, esi
	je	SHORT $LN82@Partition_
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 101  :     _Left    = _STD move(_Right);

	mov	eax, DWORD PTR [esi]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 7037 :             _STD iter_swap(_Pfirst, --_Plast);

	sub	ebx, 4
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 100  :     _Ty _Tmp = _STD move(_Left);

	mov	ecx, DWORD PTR [ebp]

; 101  :     _Left    = _STD move(_Right);

	mov	DWORD PTR [ebp], eax

; 102  :     _Right   = _STD move(_Tmp);

	mov	DWORD PTR [esi], ecx

; 101  :     _Left    = _STD move(_Right);

	mov	eax, DWORD PTR [ebx]
	mov	DWORD PTR [esi], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 7037 :             _STD iter_swap(_Pfirst, --_Plast);

	mov	DWORD PTR __Plast$1$[esp+36], ebx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 102  :     _Right   = _STD move(_Tmp);

	mov	DWORD PTR [ebx], ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 7038 :         } else {

	jmp	$LL6@Partition_
$LN82@Partition_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 102  :     _Right   = _STD move(_Tmp);

	mov	ecx, DWORD PTR [esi]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 7037 :             _STD iter_swap(_Pfirst, --_Plast);

	sub	ebx, 4
	mov	DWORD PTR __Plast$1$[esp+36], ebx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 101  :     _Left    = _STD move(_Right);

	mov	eax, DWORD PTR [ebx]
	mov	DWORD PTR [esi], eax

; 102  :     _Right   = _STD move(_Tmp);

	mov	DWORD PTR [ebx], ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 7038 :         } else {

	jmp	$LL6@Partition_
$LN30@Partition_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 100  :     _Ty _Tmp = _STD move(_Left);

	mov	ecx, DWORD PTR [edi]

; 101  :     _Left    = _STD move(_Right);

	mov	eax, DWORD PTR [ebp]
	mov	DWORD PTR [edi], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 7040 :             ++_Gfirst;

	add	edi, 4
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 102  :     _Right   = _STD move(_Tmp);

	mov	DWORD PTR [ebp], ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 7042 :     }

	jmp	$LN97@Partition_
$LN72@Partition_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 186  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

	mov	eax, DWORD PTR ___$ReturnUdt$1$[esp+36]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 7020 :             return pair<_RanIt, _RanIt>(_Pfirst, _Plast);

	pop	edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 186  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

	mov	DWORD PTR [eax], esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 7020 :             return pair<_RanIt, _RanIt>(_Pfirst, _Plast);

	pop	esi
	pop	ebp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 186  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

	mov	DWORD PTR [eax+4], ebx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 7020 :             return pair<_RanIt, _RanIt>(_Pfirst, _Plast);

	pop	ebx

; 7043 : }

	add	esp, 20					; 00000014H
	ret	0
??$_Partition_by_median_guess_unchecked@PAPAVCPGDef@PS@@P6A_NPBV12@0@Z@std@@YA?AU?$pair@PAPAVCPGDef@PS@@PAPAV12@@0@PAPAVCPGDef@PS@@0P6A_NPBV23@1@Z@Z ENDP ; std::_Partition_by_median_guess_unchecked<PS::CPGDef * *,bool (__cdecl*)(PS::CPGDef const *,PS::CPGDef const *)>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Emplace_back@PAVCPGDef@PS@@@?$_Uninitialized_backout_al@V?$xalloc@PAVCPGDef@PS@@@@@std@@QAEX$$QAPAVCPGDef@PS@@@Z
_TEXT	SEGMENT
_<_Vals_0>$ = 8						; size = 4
??$_Emplace_back@PAVCPGDef@PS@@@?$_Uninitialized_backout_al@V?$xalloc@PAVCPGDef@PS@@@@@std@@QAEX$$QAPAVCPGDef@PS@@@Z PROC ; std::_Uninitialized_backout_al<xalloc<PS::CPGDef *> >::_Emplace_back<PS::CPGDef *>, COMDAT
; _this$ = ecx

; 1620 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _<_Vals_0>$[esp-4]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edx], eax

; 1621 :         ++_Last;

	add	DWORD PTR [ecx+4], 4

; 1622 :     }

	ret	4
??$_Emplace_back@PAVCPGDef@PS@@@?$_Uninitialized_backout_al@V?$xalloc@PAVCPGDef@PS@@@@@std@@QAEX$$QAPAVCPGDef@PS@@@Z ENDP ; std::_Uninitialized_backout_al<xalloc<PS::CPGDef *> >::_Emplace_back<PS::CPGDef *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Emplace_back@PAVCPEDef@PS@@@?$_Uninitialized_backout_al@V?$xalloc@PAVCPEDef@PS@@@@@std@@QAEX$$QAPAVCPEDef@PS@@@Z
_TEXT	SEGMENT
_<_Vals_0>$ = 8						; size = 4
??$_Emplace_back@PAVCPEDef@PS@@@?$_Uninitialized_backout_al@V?$xalloc@PAVCPEDef@PS@@@@@std@@QAEX$$QAPAVCPEDef@PS@@@Z PROC ; std::_Uninitialized_backout_al<xalloc<PS::CPEDef *> >::_Emplace_back<PS::CPEDef *>, COMDAT
; _this$ = ecx

; 1620 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _<_Vals_0>$[esp-4]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edx], eax

; 1621 :         ++_Last;

	add	DWORD PTR [ecx+4], 4

; 1622 :     }

	ret	4
??$_Emplace_back@PAVCPEDef@PS@@@?$_Uninitialized_backout_al@V?$xalloc@PAVCPEDef@PS@@@@@std@@QAEX$$QAPAVCPEDef@PS@@@Z ENDP ; std::_Uninitialized_backout_al<xalloc<PS::CPEDef *> >::_Emplace_back<PS::CPEDef *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Refancy@PAPAVCPGDef@PS@@$0A@@std@@YAPAPAVCPGDef@PS@@PAPAV12@@Z
_TEXT	SEGMENT
??$_Refancy@PAPAVCPGDef@PS@@$0A@@std@@YAPAPAVCPGDef@PS@@PAPAV12@@Z PROC ; std::_Refancy<PS::CPGDef * *,0>, COMDAT
; __Ptr$ = ecx

; 287  :     return _Ptr;

	mov	eax, ecx

; 288  : }

	ret	0
??$_Refancy@PAPAVCPGDef@PS@@$0A@@std@@YAPAPAVCPGDef@PS@@PAPAV12@@Z ENDP ; std::_Refancy<PS::CPGDef * *,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Refancy@PAPAVCPEDef@PS@@$0A@@std@@YAPAPAVCPEDef@PS@@PAPAV12@@Z
_TEXT	SEGMENT
??$_Refancy@PAPAVCPEDef@PS@@$0A@@std@@YAPAPAVCPEDef@PS@@PAPAV12@@Z PROC ; std::_Refancy<PS::CPEDef * *,0>, COMDAT
; __Ptr$ = ecx

; 287  :     return _Ptr;

	mov	eax, ecx

; 288  : }

	ret	0
??$_Refancy@PAPAVCPEDef@PS@@$0A@@std@@YAPAPAVCPEDef@PS@@PAPAV12@@Z ENDP ; std::_Refancy<PS::CPEDef * *,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_Move_backward_unchecked@PAPAVCPEDef@PS@@PAPAV12@@std@@YAPAPAVCPEDef@PS@@PAPAV12@00@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
??$_Move_backward_unchecked@PAPAVCPEDef@PS@@PAPAV12@@std@@YAPAPAVCPEDef@PS@@PAPAV12@00@Z PROC ; std::_Move_backward_unchecked<PS::CPEDef * *,PS::CPEDef * *>, COMDAT
; __First$ = ecx
; __Last$ = edx

; 4255 :     auto _Result                = _CSTD memmove(_Dest_ch - _Count, _First_ch, _Count);

	mov	eax, DWORD PTR __Dest$[esp-4]
	sub	edx, ecx
	push	edx
	push	ecx
	sub	eax, edx
	push	eax
	call	_memmove
	add	esp, 12					; 0000000cH

; 4351 :     // move [_First, _Last) backwards to [..., _Dest)
; 4352 :     // note: _Move_backward_unchecked has callers other than the move_backward family
; 4353 :     if constexpr (_Ptr_move_cat<_BidIt1, _BidIt2>::_Trivially_copyable) {
; 4354 : #ifdef __cpp_lib_is_constant_evaluated
; 4355 :         if (!_STD is_constant_evaluated())
; 4356 : #endif // __cpp_lib_is_constant_evaluated
; 4357 :         {
; 4358 :             return _Copy_backward_memmove(_First, _Last, _Dest);
; 4359 :         }
; 4360 :     }
; 4361 : 
; 4362 :     while (_First != _Last) {
; 4363 :         *--_Dest = _STD move(*--_Last);
; 4364 :     }
; 4365 : 
; 4366 :     return _Dest;
; 4367 : }

	ret	0
??$_Move_backward_unchecked@PAPAVCPEDef@PS@@PAPAV12@@std@@YAPAPAVCPEDef@PS@@PAPAV12@00@Z ENDP ; std::_Move_backward_unchecked<PS::CPEDef * *,PS::CPEDef * *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
;	COMDAT ??$_Pop_heap_hole_by_index@PAPAVCPEDef@PS@@PAV12@P6A_NPBV12@0@Z@std@@YAXPAPAVCPEDef@PS@@HH$$QAPAV12@P6A_NPBV12@2@Z@Z
_TEXT	SEGMENT
__Top$1$ = -8						; size = 4
tv234 = -4						; size = 4
__Bottom$ = 8						; size = 4
__Val$ = 12						; size = 4
__Pred$ = 16						; size = 4
??$_Pop_heap_hole_by_index@PAPAVCPEDef@PS@@PAV12@P6A_NPBV12@0@Z@std@@YAXPAPAVCPEDef@PS@@HH$$QAPAV12@P6A_NPBV12@2@Z@Z PROC ; std::_Pop_heap_hole_by_index<PS::CPEDef * *,PS::CPEDef *,bool (__cdecl*)(PS::CPEDef const *,PS::CPEDef const *)>, COMDAT
; __First$ = ecx
; __Hole$ = edx

; 5375 :     _RanIt _First, _Iter_diff_t<_RanIt> _Hole, _Iter_diff_t<_RanIt> _Bottom, _Ty&& _Val, _Pr _Pred) {

	sub	esp, 8

; 5376 :     // percolate _Hole to _Bottom, then push _Val
; 5377 :     _STL_INTERNAL_CHECK(_Bottom > 0);
; 5378 : 
; 5379 :     using _Diff      = _Iter_diff_t<_RanIt>;
; 5380 :     const _Diff _Top = _Hole;
; 5381 :     _Diff _Idx       = _Hole;
; 5382 : 
; 5383 :     // Check whether _Idx can have a child before calculating that child's index, since
; 5384 :     // calculating the child's index can trigger integer overflows
; 5385 :     const _Diff _Max_sequence_non_leaf = (_Bottom - 1) >> 1; // shift for codegen

	mov	eax, DWORD PTR __Bottom$[esp+4]
	push	ebx
	push	ebp
	mov	ebx, ecx
	mov	DWORD PTR __Top$1$[esp+16], edx
	lea	ecx, DWORD PTR [eax-1]
	mov	ebp, ecx
	mov	DWORD PTR tv234[esp+16], ecx

; 5386 :     while (_Idx < _Max_sequence_non_leaf) { // move _Hole down to larger child

	mov	ecx, DWORD PTR __Pred$[esp+12]
	push	esi
	mov	esi, edx
	sar	ebp, 1
	push	edi
	mov	edi, esi
	cmp	esi, ebp
	jge	SHORT $LN3@Pop_heap_h
	npad	8
$LL2@Pop_heap_h:

; 5387 :         _Idx = 2 * _Idx + 2;
; 5388 :         if (_DEBUG_LT_PRED(_Pred, *(_First + _Idx), *(_First + (_Idx - 1)))) {

	push	DWORD PTR [ebx+edi*8+4]
	lea	edi, DWORD PTR [edi*2+2]
	push	DWORD PTR [ebx+edi*4]
	call	ecx
	add	esp, 8
	test	al, al
	je	SHORT $LN4@Pop_heap_h

; 5389 :             --_Idx;

	dec	edi
$LN4@Pop_heap_h:

; 5390 :         }
; 5391 :         *(_First + _Hole) = _STD move(*(_First + _Idx));

	mov	eax, DWORD PTR [ebx+edi*4]
	mov	ecx, DWORD PTR __Pred$[esp+20]
	mov	DWORD PTR [ebx+esi*4], eax

; 5392 :         _Hole             = _Idx;

	mov	esi, edi
	cmp	edi, ebp
	jl	SHORT $LL2@Pop_heap_h
	mov	edx, DWORD PTR __Top$1$[esp+24]
	mov	eax, DWORD PTR __Bottom$[esp+20]
$LN3@Pop_heap_h:

; 5393 :     }
; 5394 : 
; 5395 :     if (_Idx == _Max_sequence_non_leaf && _Bottom % 2 == 0) { // only child at bottom, move _Hole down to it

	cmp	edi, ebp
	jne	SHORT $LN5@Pop_heap_h
	test	al, 1
	jne	SHORT $LN5@Pop_heap_h

; 5396 :         *(_First + _Hole) = _STD move(*(_First + (_Bottom - 1)));

	mov	eax, DWORD PTR [ebx+eax*4-4]
	mov	DWORD PTR [ebx+esi*4], eax

; 5397 :         _Hole             = _Bottom - 1;

	mov	esi, DWORD PTR tv234[esp+24]
$LN5@Pop_heap_h:

; 5268 :          _Top < _Hole && _DEBUG_LT_PRED(_Pred, *(_First + _Idx), _Val); //

	cmp	edx, esi
	jge	SHORT $LN20@Pop_heap_h
	mov	ebp, DWORD PTR __Val$[esp+20]
	npad	5
$LL10@Pop_heap_h:
	push	DWORD PTR [ebp]
	lea	edi, DWORD PTR [esi-1]
	sar	edi, 1
	push	DWORD PTR [ebx+edi*4]
	call	ecx
	add	esp, 8
	test	al, al
	je	SHORT $LN21@Pop_heap_h

; 5269 :          _Idx = (_Hole - 1) >> 1) { // shift for codegen
; 5270 :         // move _Hole up to parent
; 5271 :         *(_First + _Hole) = _STD move(*(_First + _Idx));

	mov	eax, DWORD PTR [ebx+edi*4]
	mov	ecx, DWORD PTR __Pred$[esp+20]
	mov	DWORD PTR [ebx+esi*4], eax

; 5272 :         _Hole             = _Idx;

	mov	esi, edi
	cmp	DWORD PTR __Top$1$[esp+24], edi
	jl	SHORT $LL10@Pop_heap_h
$LN21@Pop_heap_h:

; 5398 :     }
; 5399 : 
; 5400 :     _Push_heap_by_index(_First, _Hole, _Top, _STD forward<_Ty>(_Val), _Pred);
; 5401 : }

	mov	eax, DWORD PTR [ebp]
	pop	edi
	mov	DWORD PTR [ebx+esi*4], eax
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 8
	ret	0
$LN20@Pop_heap_h:

; 5275 :     *(_First + _Hole) = _STD forward<_Ty>(_Val); // drop _Val into final hole

	mov	eax, DWORD PTR __Val$[esp+20]
	pop	edi
	mov	eax, DWORD PTR [eax]

; 5398 :     }
; 5399 : 
; 5400 :     _Push_heap_by_index(_First, _Hole, _Top, _STD forward<_Ty>(_Val), _Pred);
; 5401 : }

	mov	DWORD PTR [ebx+esi*4], eax
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 8
	ret	0
??$_Pop_heap_hole_by_index@PAPAVCPEDef@PS@@PAV12@P6A_NPBV12@0@Z@std@@YAXPAPAVCPEDef@PS@@HH$$QAPAV12@P6A_NPBV12@2@Z@Z ENDP ; std::_Pop_heap_hole_by_index<PS::CPEDef * *,PS::CPEDef *,bool (__cdecl*)(PS::CPEDef const *,PS::CPEDef const *)>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
;	COMDAT ??$_Pop_heap_unchecked@PAPAVCPEDef@PS@@P6A_NPBV12@0@Z@std@@YAXPAPAVCPEDef@PS@@0P6A_NPBV12@1@Z@Z
_TEXT	SEGMENT
__Val$1 = -4						; size = 4
__Pred$ = 8						; size = 4
??$_Pop_heap_unchecked@PAPAVCPEDef@PS@@P6A_NPBV12@0@Z@std@@YAXPAPAVCPEDef@PS@@0P6A_NPBV12@1@Z@Z PROC ; std::_Pop_heap_unchecked<PS::CPEDef * *,bool (__cdecl*)(PS::CPEDef const *,PS::CPEDef const *)>, COMDAT
; __First$ = ecx
; __Last$ = edx

; 5415 : _CONSTEXPR20 void _Pop_heap_unchecked(_RanIt _First, _RanIt _Last, _Pr _Pred) {

	push	ecx

; 5416 :     // pop *_First to *(_Last - 1) and reheap
; 5417 :     if (2 <= _Last - _First) {

	mov	eax, edx
	sub	eax, ecx
	and	eax, -4					; fffffffcH
	cmp	eax, 8
	jl	SHORT $LN2@Pop_heap_u

; 5418 :         --_Last;
; 5419 :         _Iter_value_t<_RanIt> _Val = _STD move(*_Last);

	mov	eax, DWORD PTR [edx-4]
	sub	edx, 4

; 5410 :     _Pop_heap_hole_by_index(

	push	DWORD PTR __Pred$[esp]

; 5418 :         --_Last;
; 5419 :         _Iter_value_t<_RanIt> _Val = _STD move(*_Last);

	mov	DWORD PTR __Val$1[esp+8], eax

; 5408 :     *_Dest      = _STD move(*_First);

	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax

; 5409 :     using _Diff = _Iter_diff_t<_RanIt>;
; 5410 :     _Pop_heap_hole_by_index(

	sub	edx, ecx
	lea	eax, DWORD PTR __Val$1[esp+8]
	sar	edx, 2
	push	eax
	push	edx
	xor	edx, edx
	call	??$_Pop_heap_hole_by_index@PAPAVCPEDef@PS@@PAV12@P6A_NPBV12@0@Z@std@@YAXPAPAVCPEDef@PS@@HH$$QAPAV12@P6A_NPBV12@2@Z@Z ; std::_Pop_heap_hole_by_index<PS::CPEDef * *,PS::CPEDef *,bool (__cdecl*)(PS::CPEDef const *,PS::CPEDef const *)>
	add	esp, 12					; 0000000cH
$LN2@Pop_heap_u:

; 5420 :         _Pop_heap_hole_unchecked(_First, _Last, _Last, _STD move(_Val), _Pred);
; 5421 :     }
; 5422 : }

	pop	ecx
	ret	0
??$_Pop_heap_unchecked@PAPAVCPEDef@PS@@P6A_NPBV12@0@Z@std@@YAXPAPAVCPEDef@PS@@0P6A_NPBV12@1@Z@Z ENDP ; std::_Pop_heap_unchecked<PS::CPEDef * *,bool (__cdecl*)(PS::CPEDef const *,PS::CPEDef const *)>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_Prev_iter@PAPAVCPEDef@PS@@@std@@YAPAPAVCPEDef@PS@@PAPAV12@@Z
_TEXT	SEGMENT
??$_Prev_iter@PAPAVCPEDef@PS@@@std@@YAPAPAVCPEDef@PS@@PAPAV12@@Z PROC ; std::_Prev_iter<PS::CPEDef * *>, COMDAT
; __First$ = ecx

; 1554 :     return --_First;

	lea	eax, DWORD PTR [ecx-4]

; 1555 : }

	ret	0
??$_Prev_iter@PAPAVCPEDef@PS@@@std@@YAPAPAVCPEDef@PS@@PAPAV12@@Z ENDP ; std::_Prev_iter<PS::CPEDef * *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
;	COMDAT ??$_Guess_median_unchecked@PAPAVCPEDef@PS@@P6A_NPBV12@0@Z@std@@YAXPAPAVCPEDef@PS@@00P6A_NPBV12@1@Z@Z
_TEXT	SEGMENT
tv426 = -8						; size = 4
tv422 = -4						; size = 4
__First$1$ = -4						; size = 4
__Last$ = 8						; size = 4
__Pred$ = 12						; size = 4
??$_Guess_median_unchecked@PAPAVCPEDef@PS@@P6A_NPBV12@0@Z@std@@YAXPAPAVCPEDef@PS@@00P6A_NPBV12@1@Z@Z PROC ; std::_Guess_median_unchecked<PS::CPEDef * *,bool (__cdecl*)(PS::CPEDef const *,PS::CPEDef const *)>, COMDAT
; __First$ = ecx
; __Mid$ = edx

; 6959 : _CONSTEXPR20 void _Guess_median_unchecked(_RanIt _First, _RanIt _Mid, _RanIt _Last, _Pr _Pred) {

	sub	esp, 8
	push	ebx

; 6960 :     // sort median element to middle
; 6961 :     using _Diff        = _Iter_diff_t<_RanIt>;
; 6962 :     const _Diff _Count = _Last - _First;

	mov	ebx, DWORD PTR __Last$[esp+8]
	mov	eax, ebx
	push	ebp

; 6963 :     if (40 < _Count) { // Tukey's ninther

	mov	ebp, DWORD PTR __Pred$[esp+12]
	push	esi
	push	edi
	mov	edi, ecx
	mov	esi, edx
	sub	eax, edi
	sar	eax, 2
	mov	ecx, DWORD PTR [edi]
	push	ecx
	cmp	eax, 40					; 00000028H
	jle	$LN2@Guess_medi

; 6964 :         const _Diff _Step     = (_Count + 1) >> 3; // +1 can't overflow because range was made inclusive in caller

	inc	eax
	sar	eax, 3

; 6965 :         const _Diff _Two_step = _Step << 1; // note: intentionally discards low-order bit
; 6966 :         _Med3_unchecked(_First, _First + _Step, _First + _Two_step, _Pred);

	lea	edx, DWORD PTR [eax*8]
	shl	eax, 2

; 6945 :     if (_DEBUG_LT_PRED(_Pred, *_Mid, *_First)) {

	push	DWORD PTR [eax+edi]

; 6965 :         const _Diff _Two_step = _Step << 1; // note: intentionally discards low-order bit
; 6966 :         _Med3_unchecked(_First, _First + _Step, _First + _Two_step, _Pred);

	lea	ebx, DWORD PTR [eax+edi]
	mov	DWORD PTR tv422[esp+32], edx
	mov	DWORD PTR tv426[esp+32], eax

; 6945 :     if (_DEBUG_LT_PRED(_Pred, *_Mid, *_First)) {

	call	ebp
	add	esp, 8
	test	al, al
	je	SHORT $LN95@Guess_medi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 100  :     _Ty _Tmp = _STD move(_Left);

	mov	ecx, DWORD PTR [ebx]

; 101  :     _Left    = _STD move(_Right);

	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR [ebx], eax

; 102  :     _Right   = _STD move(_Tmp);

	mov	DWORD PTR [edi], ecx
$LN95@Guess_medi:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 6949 :     if (_DEBUG_LT_PRED(_Pred, *_Last, *_Mid)) { // swap middle and last, then test first again

	mov	eax, DWORD PTR tv422[esp+24]
	push	DWORD PTR [ebx]
	push	DWORD PTR [eax+edi]
	call	ebp
	add	esp, 8
	test	al, al
	je	SHORT $LN8@Guess_medi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 100  :     _Ty _Tmp = _STD move(_Left);

	mov	edx, DWORD PTR tv422[esp+24]

; 101  :     _Left    = _STD move(_Right);

	mov	eax, DWORD PTR [ebx]
	mov	ecx, DWORD PTR [edx+edi]
	mov	DWORD PTR [edx+edi], eax

; 102  :     _Right   = _STD move(_Tmp);

	mov	DWORD PTR [ebx], ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 6952 :         if (_DEBUG_LT_PRED(_Pred, *_Mid, *_First)) {

	push	DWORD PTR [edi]
	push	ecx
	call	ebp
	add	esp, 8
	test	al, al
	je	SHORT $LN8@Guess_medi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 100  :     _Ty _Tmp = _STD move(_Left);

	mov	ecx, DWORD PTR [ebx]

; 101  :     _Left    = _STD move(_Right);

	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR [ebx], eax

; 102  :     _Right   = _STD move(_Tmp);

	mov	DWORD PTR [edi], ecx
$LN8@Guess_medi:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 6967 :         _Med3_unchecked(_Mid - _Step, _Mid, _Mid + _Step, _Pred);

	mov	edi, esi
	sub	edi, DWORD PTR tv426[esp+24]

; 6945 :     if (_DEBUG_LT_PRED(_Pred, *_Mid, *_First)) {

	push	DWORD PTR [edi]
	push	DWORD PTR [esi]
	call	ebp
	add	esp, 8
	test	al, al
	je	SHORT $LN96@Guess_medi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 100  :     _Ty _Tmp = _STD move(_Left);

	mov	ecx, DWORD PTR [esi]

; 101  :     _Left    = _STD move(_Right);

	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR [esi], eax

; 102  :     _Right   = _STD move(_Tmp);

	mov	DWORD PTR [edi], ecx
$LN96@Guess_medi:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 6949 :     if (_DEBUG_LT_PRED(_Pred, *_Last, *_Mid)) { // swap middle and last, then test first again

	mov	eax, DWORD PTR tv426[esp+24]
	push	DWORD PTR [esi]
	push	DWORD PTR [eax+esi]
	call	ebp
	add	esp, 8
	test	al, al
	je	SHORT $LN25@Guess_medi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 100  :     _Ty _Tmp = _STD move(_Left);

	mov	edx, DWORD PTR tv426[esp+24]

; 101  :     _Left    = _STD move(_Right);

	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR [edx+esi]
	mov	DWORD PTR [edx+esi], eax

; 102  :     _Right   = _STD move(_Tmp);

	mov	DWORD PTR [esi], ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 6952 :         if (_DEBUG_LT_PRED(_Pred, *_Mid, *_First)) {

	push	DWORD PTR [edi]
	push	ecx
	call	ebp
	add	esp, 8
	test	al, al
	je	SHORT $LN25@Guess_medi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 100  :     _Ty _Tmp = _STD move(_Left);

	mov	ecx, DWORD PTR [esi]

; 101  :     _Left    = _STD move(_Right);

	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR [esi], eax

; 102  :     _Right   = _STD move(_Tmp);

	mov	DWORD PTR [edi], ecx
$LN25@Guess_medi:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 6968 :         _Med3_unchecked(_Last - _Two_step, _Last - _Step, _Last, _Pred);

	mov	eax, DWORD PTR __Last$[esp+20]
	mov	edi, eax
	sub	eax, DWORD PTR tv422[esp+24]
	sub	edi, DWORD PTR tv426[esp+24]
	mov	DWORD PTR __First$1$[esp+24], eax

; 6945 :     if (_DEBUG_LT_PRED(_Pred, *_Mid, *_First)) {

	push	DWORD PTR [eax]
	push	DWORD PTR [edi]
	call	ebp
	add	esp, 8
	test	al, al
	je	SHORT $LN97@Guess_medi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 101  :     _Left    = _STD move(_Right);

	mov	edx, DWORD PTR __First$1$[esp+24]
	mov	ecx, DWORD PTR [edi]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [edi], eax

; 102  :     _Right   = _STD move(_Tmp);

	mov	DWORD PTR [edx], ecx
$LN97@Guess_medi:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 6949 :     if (_DEBUG_LT_PRED(_Pred, *_Last, *_Mid)) { // swap middle and last, then test first again

	mov	eax, DWORD PTR __Last$[esp+20]
	push	DWORD PTR [edi]
	push	DWORD PTR [eax]
	call	ebp
	add	esp, 8
	test	al, al
	je	SHORT $LN42@Guess_medi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 100  :     _Ty _Tmp = _STD move(_Left);

	mov	edx, DWORD PTR __Last$[esp+20]

; 101  :     _Left    = _STD move(_Right);

	mov	eax, DWORD PTR [edi]
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [edx], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 6952 :         if (_DEBUG_LT_PRED(_Pred, *_Mid, *_First)) {

	mov	eax, DWORD PTR __First$1$[esp+24]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 102  :     _Right   = _STD move(_Tmp);

	mov	DWORD PTR [edi], ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 6952 :         if (_DEBUG_LT_PRED(_Pred, *_Mid, *_First)) {

	push	DWORD PTR [eax]
	push	ecx
	call	ebp
	add	esp, 8
	test	al, al
	je	SHORT $LN42@Guess_medi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 101  :     _Left    = _STD move(_Right);

	mov	edx, DWORD PTR __First$1$[esp+24]
	mov	ecx, DWORD PTR [edi]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [edi], eax

; 102  :     _Right   = _STD move(_Tmp);

	mov	DWORD PTR [edx], ecx
$LN42@Guess_medi:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 6945 :     if (_DEBUG_LT_PRED(_Pred, *_Mid, *_First)) {

	push	DWORD PTR [ebx]
	push	DWORD PTR [esi]
	call	ebp
	add	esp, 8
	test	al, al
	je	SHORT $LN98@Guess_medi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 100  :     _Ty _Tmp = _STD move(_Left);

	mov	ecx, DWORD PTR [esi]

; 101  :     _Left    = _STD move(_Right);

	mov	eax, DWORD PTR [ebx]
	mov	DWORD PTR [esi], eax

; 102  :     _Right   = _STD move(_Tmp);

	mov	DWORD PTR [ebx], ecx
$LN98@Guess_medi:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 6949 :     if (_DEBUG_LT_PRED(_Pred, *_Last, *_Mid)) { // swap middle and last, then test first again

	push	DWORD PTR [esi]
	push	DWORD PTR [edi]
	call	ebp
	add	esp, 8
	test	al, al
	je	SHORT $LN76@Guess_medi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 100  :     _Ty _Tmp = _STD move(_Left);

	mov	ecx, DWORD PTR [edi]

; 101  :     _Left    = _STD move(_Right);

	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [edi], eax

; 102  :     _Right   = _STD move(_Tmp);

	mov	DWORD PTR [esi], ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 6952 :         if (_DEBUG_LT_PRED(_Pred, *_Mid, *_First)) {

	push	DWORD PTR [ebx]
	push	ecx
	call	ebp
	add	esp, 8
	test	al, al
	je	SHORT $LN76@Guess_medi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 100  :     _Ty _Tmp = _STD move(_Left);

	mov	ecx, DWORD PTR [esi]

; 101  :     _Left    = _STD move(_Right);

	mov	eax, DWORD PTR [ebx]
	pop	edi
	mov	DWORD PTR [esi], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 6973 : }

	pop	esi
	pop	ebp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 102  :     _Right   = _STD move(_Tmp);

	mov	DWORD PTR [ebx], ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 6973 : }

	pop	ebx
	add	esp, 8
	ret	0
$LN2@Guess_medi:

; 6945 :     if (_DEBUG_LT_PRED(_Pred, *_Mid, *_First)) {

	push	DWORD PTR [esi]
	call	ebp
	add	esp, 8
	test	al, al
	je	SHORT $LN99@Guess_medi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 100  :     _Ty _Tmp = _STD move(_Left);

	mov	ecx, DWORD PTR [esi]

; 101  :     _Left    = _STD move(_Right);

	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR [esi], eax

; 102  :     _Right   = _STD move(_Tmp);

	mov	DWORD PTR [edi], ecx
$LN99@Guess_medi:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 6949 :     if (_DEBUG_LT_PRED(_Pred, *_Last, *_Mid)) { // swap middle and last, then test first again

	push	DWORD PTR [esi]
	push	DWORD PTR [ebx]
	call	ebp
	add	esp, 8
	test	al, al
	je	SHORT $LN76@Guess_medi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 100  :     _Ty _Tmp = _STD move(_Left);

	mov	ecx, DWORD PTR [ebx]

; 101  :     _Left    = _STD move(_Right);

	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [ebx], eax

; 102  :     _Right   = _STD move(_Tmp);

	mov	DWORD PTR [esi], ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 6952 :         if (_DEBUG_LT_PRED(_Pred, *_Mid, *_First)) {

	push	DWORD PTR [edi]
	push	ecx
	call	ebp
	add	esp, 8
	test	al, al
	je	SHORT $LN76@Guess_medi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 100  :     _Ty _Tmp = _STD move(_Left);

	mov	ecx, DWORD PTR [esi]

; 101  :     _Left    = _STD move(_Right);

	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR [esi], eax

; 102  :     _Right   = _STD move(_Tmp);

	mov	DWORD PTR [edi], ecx
$LN76@Guess_medi:
	pop	edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 6973 : }

	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 8
	ret	0
??$_Guess_median_unchecked@PAPAVCPEDef@PS@@P6A_NPBV12@0@Z@std@@YAXPAPAVCPEDef@PS@@00P6A_NPBV12@1@Z@Z ENDP ; std::_Guess_median_unchecked<PS::CPEDef * *,bool (__cdecl*)(PS::CPEDef const *,PS::CPEDef const *)>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
;	COMDAT ??$iter_swap@PAPAVCPEDef@PS@@PAPAV12@@std@@YAXPAPAVCPEDef@PS@@0@Z
_TEXT	SEGMENT
??$iter_swap@PAPAVCPEDef@PS@@PAPAV12@@std@@YAXPAPAVCPEDef@PS@@0@Z PROC ; std::iter_swap<PS::CPEDef * *,PS::CPEDef * *>, COMDAT
; __Left$ = ecx
; __Right$ = edx

; 101  :     _Left    = _STD move(_Right);

	mov	eax, DWORD PTR [edx]

; 77   : _CONSTEXPR20 void iter_swap(_FwdIt1 _Left, _FwdIt2 _Right) { // swap *_Left and *_Right

	push	esi

; 100  :     _Ty _Tmp = _STD move(_Left);

	mov	esi, DWORD PTR [ecx]

; 101  :     _Left    = _STD move(_Right);

	mov	DWORD PTR [ecx], eax

; 102  :     _Right   = _STD move(_Tmp);

	mov	DWORD PTR [edx], esi
	pop	esi

; 78   :     swap(*_Left, *_Right);
; 79   : }

	ret	0
??$iter_swap@PAPAVCPEDef@PS@@PAPAV12@@std@@YAXPAPAVCPEDef@PS@@0@Z ENDP ; std::iter_swap<PS::CPEDef * *,PS::CPEDef * *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
;	COMDAT ??$?0AAPAPAVCPEDef@PS@@AAPAPAV01@$0A@@?$pair@PAPAVCPEDef@PS@@PAPAV12@@std@@QAE@AAPAPAVCPEDef@PS@@0@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??$?0AAPAPAVCPEDef@PS@@AAPAPAV01@$0A@@?$pair@PAPAVCPEDef@PS@@PAPAV12@@std@@QAE@AAPAPAVCPEDef@PS@@0@Z PROC ; std::pair<PS::CPEDef * *,PS::CPEDef * *>::pair<PS::CPEDef * *,PS::CPEDef * *><PS::CPEDef * * &,PS::CPEDef * * &,0>, COMDAT
; _this$ = ecx

; 186  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

	mov	eax, DWORD PTR __Val1$[esp-4]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR __Val2$[esp-4]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx+4], eax
	mov	eax, ecx
	ret	8
??$?0AAPAPAVCPEDef@PS@@AAPAPAV01@$0A@@?$pair@PAPAVCPEDef@PS@@PAPAV12@@std@@QAE@AAPAPAVCPEDef@PS@@0@Z ENDP ; std::pair<PS::CPEDef * *,PS::CPEDef * *>::pair<PS::CPEDef * *,PS::CPEDef * *><PS::CPEDef * * &,PS::CPEDef * * &,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_Move_backward_unchecked@PAPAVCPGDef@PS@@PAPAV12@@std@@YAPAPAVCPGDef@PS@@PAPAV12@00@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
??$_Move_backward_unchecked@PAPAVCPGDef@PS@@PAPAV12@@std@@YAPAPAVCPGDef@PS@@PAPAV12@00@Z PROC ; std::_Move_backward_unchecked<PS::CPGDef * *,PS::CPGDef * *>, COMDAT
; __First$ = ecx
; __Last$ = edx

; 4255 :     auto _Result                = _CSTD memmove(_Dest_ch - _Count, _First_ch, _Count);

	mov	eax, DWORD PTR __Dest$[esp-4]
	sub	edx, ecx
	push	edx
	push	ecx
	sub	eax, edx
	push	eax
	call	_memmove
	add	esp, 12					; 0000000cH

; 4351 :     // move [_First, _Last) backwards to [..., _Dest)
; 4352 :     // note: _Move_backward_unchecked has callers other than the move_backward family
; 4353 :     if constexpr (_Ptr_move_cat<_BidIt1, _BidIt2>::_Trivially_copyable) {
; 4354 : #ifdef __cpp_lib_is_constant_evaluated
; 4355 :         if (!_STD is_constant_evaluated())
; 4356 : #endif // __cpp_lib_is_constant_evaluated
; 4357 :         {
; 4358 :             return _Copy_backward_memmove(_First, _Last, _Dest);
; 4359 :         }
; 4360 :     }
; 4361 : 
; 4362 :     while (_First != _Last) {
; 4363 :         *--_Dest = _STD move(*--_Last);
; 4364 :     }
; 4365 : 
; 4366 :     return _Dest;
; 4367 : }

	ret	0
??$_Move_backward_unchecked@PAPAVCPGDef@PS@@PAPAV12@@std@@YAPAPAVCPGDef@PS@@PAPAV12@00@Z ENDP ; std::_Move_backward_unchecked<PS::CPGDef * *,PS::CPGDef * *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
;	COMDAT ??$_Pop_heap_hole_by_index@PAPAVCPGDef@PS@@PAV12@P6A_NPBV12@0@Z@std@@YAXPAPAVCPGDef@PS@@HH$$QAPAV12@P6A_NPBV12@2@Z@Z
_TEXT	SEGMENT
__Top$1$ = -8						; size = 4
tv234 = -4						; size = 4
__Bottom$ = 8						; size = 4
__Val$ = 12						; size = 4
__Pred$ = 16						; size = 4
??$_Pop_heap_hole_by_index@PAPAVCPGDef@PS@@PAV12@P6A_NPBV12@0@Z@std@@YAXPAPAVCPGDef@PS@@HH$$QAPAV12@P6A_NPBV12@2@Z@Z PROC ; std::_Pop_heap_hole_by_index<PS::CPGDef * *,PS::CPGDef *,bool (__cdecl*)(PS::CPGDef const *,PS::CPGDef const *)>, COMDAT
; __First$ = ecx
; __Hole$ = edx

; 5375 :     _RanIt _First, _Iter_diff_t<_RanIt> _Hole, _Iter_diff_t<_RanIt> _Bottom, _Ty&& _Val, _Pr _Pred) {

	sub	esp, 8

; 5376 :     // percolate _Hole to _Bottom, then push _Val
; 5377 :     _STL_INTERNAL_CHECK(_Bottom > 0);
; 5378 : 
; 5379 :     using _Diff      = _Iter_diff_t<_RanIt>;
; 5380 :     const _Diff _Top = _Hole;
; 5381 :     _Diff _Idx       = _Hole;
; 5382 : 
; 5383 :     // Check whether _Idx can have a child before calculating that child's index, since
; 5384 :     // calculating the child's index can trigger integer overflows
; 5385 :     const _Diff _Max_sequence_non_leaf = (_Bottom - 1) >> 1; // shift for codegen

	mov	eax, DWORD PTR __Bottom$[esp+4]
	push	ebx
	push	ebp
	mov	ebx, ecx
	mov	DWORD PTR __Top$1$[esp+16], edx
	lea	ecx, DWORD PTR [eax-1]
	mov	ebp, ecx
	mov	DWORD PTR tv234[esp+16], ecx

; 5386 :     while (_Idx < _Max_sequence_non_leaf) { // move _Hole down to larger child

	mov	ecx, DWORD PTR __Pred$[esp+12]
	push	esi
	mov	esi, edx
	sar	ebp, 1
	push	edi
	mov	edi, esi
	cmp	esi, ebp
	jge	SHORT $LN3@Pop_heap_h
	npad	8
$LL2@Pop_heap_h:

; 5387 :         _Idx = 2 * _Idx + 2;
; 5388 :         if (_DEBUG_LT_PRED(_Pred, *(_First + _Idx), *(_First + (_Idx - 1)))) {

	push	DWORD PTR [ebx+edi*8+4]
	lea	edi, DWORD PTR [edi*2+2]
	push	DWORD PTR [ebx+edi*4]
	call	ecx
	add	esp, 8
	test	al, al
	je	SHORT $LN4@Pop_heap_h

; 5389 :             --_Idx;

	dec	edi
$LN4@Pop_heap_h:

; 5390 :         }
; 5391 :         *(_First + _Hole) = _STD move(*(_First + _Idx));

	mov	eax, DWORD PTR [ebx+edi*4]
	mov	ecx, DWORD PTR __Pred$[esp+20]
	mov	DWORD PTR [ebx+esi*4], eax

; 5392 :         _Hole             = _Idx;

	mov	esi, edi
	cmp	edi, ebp
	jl	SHORT $LL2@Pop_heap_h
	mov	edx, DWORD PTR __Top$1$[esp+24]
	mov	eax, DWORD PTR __Bottom$[esp+20]
$LN3@Pop_heap_h:

; 5393 :     }
; 5394 : 
; 5395 :     if (_Idx == _Max_sequence_non_leaf && _Bottom % 2 == 0) { // only child at bottom, move _Hole down to it

	cmp	edi, ebp
	jne	SHORT $LN5@Pop_heap_h
	test	al, 1
	jne	SHORT $LN5@Pop_heap_h

; 5396 :         *(_First + _Hole) = _STD move(*(_First + (_Bottom - 1)));

	mov	eax, DWORD PTR [ebx+eax*4-4]
	mov	DWORD PTR [ebx+esi*4], eax

; 5397 :         _Hole             = _Bottom - 1;

	mov	esi, DWORD PTR tv234[esp+24]
$LN5@Pop_heap_h:

; 5268 :          _Top < _Hole && _DEBUG_LT_PRED(_Pred, *(_First + _Idx), _Val); //

	cmp	edx, esi
	jge	SHORT $LN20@Pop_heap_h
	mov	ebp, DWORD PTR __Val$[esp+20]
	npad	5
$LL10@Pop_heap_h:
	push	DWORD PTR [ebp]
	lea	edi, DWORD PTR [esi-1]
	sar	edi, 1
	push	DWORD PTR [ebx+edi*4]
	call	ecx
	add	esp, 8
	test	al, al
	je	SHORT $LN21@Pop_heap_h

; 5269 :          _Idx = (_Hole - 1) >> 1) { // shift for codegen
; 5270 :         // move _Hole up to parent
; 5271 :         *(_First + _Hole) = _STD move(*(_First + _Idx));

	mov	eax, DWORD PTR [ebx+edi*4]
	mov	ecx, DWORD PTR __Pred$[esp+20]
	mov	DWORD PTR [ebx+esi*4], eax

; 5272 :         _Hole             = _Idx;

	mov	esi, edi
	cmp	DWORD PTR __Top$1$[esp+24], edi
	jl	SHORT $LL10@Pop_heap_h
$LN21@Pop_heap_h:

; 5398 :     }
; 5399 : 
; 5400 :     _Push_heap_by_index(_First, _Hole, _Top, _STD forward<_Ty>(_Val), _Pred);
; 5401 : }

	mov	eax, DWORD PTR [ebp]
	pop	edi
	mov	DWORD PTR [ebx+esi*4], eax
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 8
	ret	0
$LN20@Pop_heap_h:

; 5275 :     *(_First + _Hole) = _STD forward<_Ty>(_Val); // drop _Val into final hole

	mov	eax, DWORD PTR __Val$[esp+20]
	pop	edi
	mov	eax, DWORD PTR [eax]

; 5398 :     }
; 5399 : 
; 5400 :     _Push_heap_by_index(_First, _Hole, _Top, _STD forward<_Ty>(_Val), _Pred);
; 5401 : }

	mov	DWORD PTR [ebx+esi*4], eax
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 8
	ret	0
??$_Pop_heap_hole_by_index@PAPAVCPGDef@PS@@PAV12@P6A_NPBV12@0@Z@std@@YAXPAPAVCPGDef@PS@@HH$$QAPAV12@P6A_NPBV12@2@Z@Z ENDP ; std::_Pop_heap_hole_by_index<PS::CPGDef * *,PS::CPGDef *,bool (__cdecl*)(PS::CPGDef const *,PS::CPGDef const *)>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
;	COMDAT ??$_Pop_heap_unchecked@PAPAVCPGDef@PS@@P6A_NPBV12@0@Z@std@@YAXPAPAVCPGDef@PS@@0P6A_NPBV12@1@Z@Z
_TEXT	SEGMENT
__Val$1 = -4						; size = 4
__Pred$ = 8						; size = 4
??$_Pop_heap_unchecked@PAPAVCPGDef@PS@@P6A_NPBV12@0@Z@std@@YAXPAPAVCPGDef@PS@@0P6A_NPBV12@1@Z@Z PROC ; std::_Pop_heap_unchecked<PS::CPGDef * *,bool (__cdecl*)(PS::CPGDef const *,PS::CPGDef const *)>, COMDAT
; __First$ = ecx
; __Last$ = edx

; 5415 : _CONSTEXPR20 void _Pop_heap_unchecked(_RanIt _First, _RanIt _Last, _Pr _Pred) {

	push	ecx

; 5416 :     // pop *_First to *(_Last - 1) and reheap
; 5417 :     if (2 <= _Last - _First) {

	mov	eax, edx
	sub	eax, ecx
	and	eax, -4					; fffffffcH
	cmp	eax, 8
	jl	SHORT $LN2@Pop_heap_u

; 5418 :         --_Last;
; 5419 :         _Iter_value_t<_RanIt> _Val = _STD move(*_Last);

	mov	eax, DWORD PTR [edx-4]
	sub	edx, 4

; 5410 :     _Pop_heap_hole_by_index(

	push	DWORD PTR __Pred$[esp]

; 5418 :         --_Last;
; 5419 :         _Iter_value_t<_RanIt> _Val = _STD move(*_Last);

	mov	DWORD PTR __Val$1[esp+8], eax

; 5408 :     *_Dest      = _STD move(*_First);

	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax

; 5409 :     using _Diff = _Iter_diff_t<_RanIt>;
; 5410 :     _Pop_heap_hole_by_index(

	sub	edx, ecx
	lea	eax, DWORD PTR __Val$1[esp+8]
	sar	edx, 2
	push	eax
	push	edx
	xor	edx, edx
	call	??$_Pop_heap_hole_by_index@PAPAVCPGDef@PS@@PAV12@P6A_NPBV12@0@Z@std@@YAXPAPAVCPGDef@PS@@HH$$QAPAV12@P6A_NPBV12@2@Z@Z ; std::_Pop_heap_hole_by_index<PS::CPGDef * *,PS::CPGDef *,bool (__cdecl*)(PS::CPGDef const *,PS::CPGDef const *)>
	add	esp, 12					; 0000000cH
$LN2@Pop_heap_u:

; 5420 :         _Pop_heap_hole_unchecked(_First, _Last, _Last, _STD move(_Val), _Pred);
; 5421 :     }
; 5422 : }

	pop	ecx
	ret	0
??$_Pop_heap_unchecked@PAPAVCPGDef@PS@@P6A_NPBV12@0@Z@std@@YAXPAPAVCPGDef@PS@@0P6A_NPBV12@1@Z@Z ENDP ; std::_Pop_heap_unchecked<PS::CPGDef * *,bool (__cdecl*)(PS::CPGDef const *,PS::CPGDef const *)>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_Prev_iter@PAPAVCPGDef@PS@@@std@@YAPAPAVCPGDef@PS@@PAPAV12@@Z
_TEXT	SEGMENT
??$_Prev_iter@PAPAVCPGDef@PS@@@std@@YAPAPAVCPGDef@PS@@PAPAV12@@Z PROC ; std::_Prev_iter<PS::CPGDef * *>, COMDAT
; __First$ = ecx

; 1554 :     return --_First;

	lea	eax, DWORD PTR [ecx-4]

; 1555 : }

	ret	0
??$_Prev_iter@PAPAVCPGDef@PS@@@std@@YAPAPAVCPGDef@PS@@PAPAV12@@Z ENDP ; std::_Prev_iter<PS::CPGDef * *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
;	COMDAT ??$_Guess_median_unchecked@PAPAVCPGDef@PS@@P6A_NPBV12@0@Z@std@@YAXPAPAVCPGDef@PS@@00P6A_NPBV12@1@Z@Z
_TEXT	SEGMENT
tv426 = -8						; size = 4
tv422 = -4						; size = 4
__First$1$ = -4						; size = 4
__Last$ = 8						; size = 4
__Pred$ = 12						; size = 4
??$_Guess_median_unchecked@PAPAVCPGDef@PS@@P6A_NPBV12@0@Z@std@@YAXPAPAVCPGDef@PS@@00P6A_NPBV12@1@Z@Z PROC ; std::_Guess_median_unchecked<PS::CPGDef * *,bool (__cdecl*)(PS::CPGDef const *,PS::CPGDef const *)>, COMDAT
; __First$ = ecx
; __Mid$ = edx

; 6959 : _CONSTEXPR20 void _Guess_median_unchecked(_RanIt _First, _RanIt _Mid, _RanIt _Last, _Pr _Pred) {

	sub	esp, 8
	push	ebx

; 6960 :     // sort median element to middle
; 6961 :     using _Diff        = _Iter_diff_t<_RanIt>;
; 6962 :     const _Diff _Count = _Last - _First;

	mov	ebx, DWORD PTR __Last$[esp+8]
	mov	eax, ebx
	push	ebp

; 6963 :     if (40 < _Count) { // Tukey's ninther

	mov	ebp, DWORD PTR __Pred$[esp+12]
	push	esi
	push	edi
	mov	edi, ecx
	mov	esi, edx
	sub	eax, edi
	sar	eax, 2
	mov	ecx, DWORD PTR [edi]
	push	ecx
	cmp	eax, 40					; 00000028H
	jle	$LN2@Guess_medi

; 6964 :         const _Diff _Step     = (_Count + 1) >> 3; // +1 can't overflow because range was made inclusive in caller

	inc	eax
	sar	eax, 3

; 6965 :         const _Diff _Two_step = _Step << 1; // note: intentionally discards low-order bit
; 6966 :         _Med3_unchecked(_First, _First + _Step, _First + _Two_step, _Pred);

	lea	edx, DWORD PTR [eax*8]
	shl	eax, 2

; 6945 :     if (_DEBUG_LT_PRED(_Pred, *_Mid, *_First)) {

	push	DWORD PTR [eax+edi]

; 6965 :         const _Diff _Two_step = _Step << 1; // note: intentionally discards low-order bit
; 6966 :         _Med3_unchecked(_First, _First + _Step, _First + _Two_step, _Pred);

	lea	ebx, DWORD PTR [eax+edi]
	mov	DWORD PTR tv422[esp+32], edx
	mov	DWORD PTR tv426[esp+32], eax

; 6945 :     if (_DEBUG_LT_PRED(_Pred, *_Mid, *_First)) {

	call	ebp
	add	esp, 8
	test	al, al
	je	SHORT $LN95@Guess_medi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 100  :     _Ty _Tmp = _STD move(_Left);

	mov	ecx, DWORD PTR [ebx]

; 101  :     _Left    = _STD move(_Right);

	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR [ebx], eax

; 102  :     _Right   = _STD move(_Tmp);

	mov	DWORD PTR [edi], ecx
$LN95@Guess_medi:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 6949 :     if (_DEBUG_LT_PRED(_Pred, *_Last, *_Mid)) { // swap middle and last, then test first again

	mov	eax, DWORD PTR tv422[esp+24]
	push	DWORD PTR [ebx]
	push	DWORD PTR [eax+edi]
	call	ebp
	add	esp, 8
	test	al, al
	je	SHORT $LN8@Guess_medi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 100  :     _Ty _Tmp = _STD move(_Left);

	mov	edx, DWORD PTR tv422[esp+24]

; 101  :     _Left    = _STD move(_Right);

	mov	eax, DWORD PTR [ebx]
	mov	ecx, DWORD PTR [edx+edi]
	mov	DWORD PTR [edx+edi], eax

; 102  :     _Right   = _STD move(_Tmp);

	mov	DWORD PTR [ebx], ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 6952 :         if (_DEBUG_LT_PRED(_Pred, *_Mid, *_First)) {

	push	DWORD PTR [edi]
	push	ecx
	call	ebp
	add	esp, 8
	test	al, al
	je	SHORT $LN8@Guess_medi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 100  :     _Ty _Tmp = _STD move(_Left);

	mov	ecx, DWORD PTR [ebx]

; 101  :     _Left    = _STD move(_Right);

	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR [ebx], eax

; 102  :     _Right   = _STD move(_Tmp);

	mov	DWORD PTR [edi], ecx
$LN8@Guess_medi:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 6967 :         _Med3_unchecked(_Mid - _Step, _Mid, _Mid + _Step, _Pred);

	mov	edi, esi
	sub	edi, DWORD PTR tv426[esp+24]

; 6945 :     if (_DEBUG_LT_PRED(_Pred, *_Mid, *_First)) {

	push	DWORD PTR [edi]
	push	DWORD PTR [esi]
	call	ebp
	add	esp, 8
	test	al, al
	je	SHORT $LN96@Guess_medi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 100  :     _Ty _Tmp = _STD move(_Left);

	mov	ecx, DWORD PTR [esi]

; 101  :     _Left    = _STD move(_Right);

	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR [esi], eax

; 102  :     _Right   = _STD move(_Tmp);

	mov	DWORD PTR [edi], ecx
$LN96@Guess_medi:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 6949 :     if (_DEBUG_LT_PRED(_Pred, *_Last, *_Mid)) { // swap middle and last, then test first again

	mov	eax, DWORD PTR tv426[esp+24]
	push	DWORD PTR [esi]
	push	DWORD PTR [eax+esi]
	call	ebp
	add	esp, 8
	test	al, al
	je	SHORT $LN25@Guess_medi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 100  :     _Ty _Tmp = _STD move(_Left);

	mov	edx, DWORD PTR tv426[esp+24]

; 101  :     _Left    = _STD move(_Right);

	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR [edx+esi]
	mov	DWORD PTR [edx+esi], eax

; 102  :     _Right   = _STD move(_Tmp);

	mov	DWORD PTR [esi], ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 6952 :         if (_DEBUG_LT_PRED(_Pred, *_Mid, *_First)) {

	push	DWORD PTR [edi]
	push	ecx
	call	ebp
	add	esp, 8
	test	al, al
	je	SHORT $LN25@Guess_medi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 100  :     _Ty _Tmp = _STD move(_Left);

	mov	ecx, DWORD PTR [esi]

; 101  :     _Left    = _STD move(_Right);

	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR [esi], eax

; 102  :     _Right   = _STD move(_Tmp);

	mov	DWORD PTR [edi], ecx
$LN25@Guess_medi:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 6968 :         _Med3_unchecked(_Last - _Two_step, _Last - _Step, _Last, _Pred);

	mov	eax, DWORD PTR __Last$[esp+20]
	mov	edi, eax
	sub	eax, DWORD PTR tv422[esp+24]
	sub	edi, DWORD PTR tv426[esp+24]
	mov	DWORD PTR __First$1$[esp+24], eax

; 6945 :     if (_DEBUG_LT_PRED(_Pred, *_Mid, *_First)) {

	push	DWORD PTR [eax]
	push	DWORD PTR [edi]
	call	ebp
	add	esp, 8
	test	al, al
	je	SHORT $LN97@Guess_medi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 101  :     _Left    = _STD move(_Right);

	mov	edx, DWORD PTR __First$1$[esp+24]
	mov	ecx, DWORD PTR [edi]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [edi], eax

; 102  :     _Right   = _STD move(_Tmp);

	mov	DWORD PTR [edx], ecx
$LN97@Guess_medi:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 6949 :     if (_DEBUG_LT_PRED(_Pred, *_Last, *_Mid)) { // swap middle and last, then test first again

	mov	eax, DWORD PTR __Last$[esp+20]
	push	DWORD PTR [edi]
	push	DWORD PTR [eax]
	call	ebp
	add	esp, 8
	test	al, al
	je	SHORT $LN42@Guess_medi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 100  :     _Ty _Tmp = _STD move(_Left);

	mov	edx, DWORD PTR __Last$[esp+20]

; 101  :     _Left    = _STD move(_Right);

	mov	eax, DWORD PTR [edi]
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [edx], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 6952 :         if (_DEBUG_LT_PRED(_Pred, *_Mid, *_First)) {

	mov	eax, DWORD PTR __First$1$[esp+24]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 102  :     _Right   = _STD move(_Tmp);

	mov	DWORD PTR [edi], ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 6952 :         if (_DEBUG_LT_PRED(_Pred, *_Mid, *_First)) {

	push	DWORD PTR [eax]
	push	ecx
	call	ebp
	add	esp, 8
	test	al, al
	je	SHORT $LN42@Guess_medi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 101  :     _Left    = _STD move(_Right);

	mov	edx, DWORD PTR __First$1$[esp+24]
	mov	ecx, DWORD PTR [edi]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [edi], eax

; 102  :     _Right   = _STD move(_Tmp);

	mov	DWORD PTR [edx], ecx
$LN42@Guess_medi:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 6945 :     if (_DEBUG_LT_PRED(_Pred, *_Mid, *_First)) {

	push	DWORD PTR [ebx]
	push	DWORD PTR [esi]
	call	ebp
	add	esp, 8
	test	al, al
	je	SHORT $LN98@Guess_medi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 100  :     _Ty _Tmp = _STD move(_Left);

	mov	ecx, DWORD PTR [esi]

; 101  :     _Left    = _STD move(_Right);

	mov	eax, DWORD PTR [ebx]
	mov	DWORD PTR [esi], eax

; 102  :     _Right   = _STD move(_Tmp);

	mov	DWORD PTR [ebx], ecx
$LN98@Guess_medi:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 6949 :     if (_DEBUG_LT_PRED(_Pred, *_Last, *_Mid)) { // swap middle and last, then test first again

	push	DWORD PTR [esi]
	push	DWORD PTR [edi]
	call	ebp
	add	esp, 8
	test	al, al
	je	SHORT $LN76@Guess_medi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 100  :     _Ty _Tmp = _STD move(_Left);

	mov	ecx, DWORD PTR [edi]

; 101  :     _Left    = _STD move(_Right);

	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [edi], eax

; 102  :     _Right   = _STD move(_Tmp);

	mov	DWORD PTR [esi], ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 6952 :         if (_DEBUG_LT_PRED(_Pred, *_Mid, *_First)) {

	push	DWORD PTR [ebx]
	push	ecx
	call	ebp
	add	esp, 8
	test	al, al
	je	SHORT $LN76@Guess_medi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 100  :     _Ty _Tmp = _STD move(_Left);

	mov	ecx, DWORD PTR [esi]

; 101  :     _Left    = _STD move(_Right);

	mov	eax, DWORD PTR [ebx]
	pop	edi
	mov	DWORD PTR [esi], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 6973 : }

	pop	esi
	pop	ebp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 102  :     _Right   = _STD move(_Tmp);

	mov	DWORD PTR [ebx], ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 6973 : }

	pop	ebx
	add	esp, 8
	ret	0
$LN2@Guess_medi:

; 6945 :     if (_DEBUG_LT_PRED(_Pred, *_Mid, *_First)) {

	push	DWORD PTR [esi]
	call	ebp
	add	esp, 8
	test	al, al
	je	SHORT $LN99@Guess_medi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 100  :     _Ty _Tmp = _STD move(_Left);

	mov	ecx, DWORD PTR [esi]

; 101  :     _Left    = _STD move(_Right);

	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR [esi], eax

; 102  :     _Right   = _STD move(_Tmp);

	mov	DWORD PTR [edi], ecx
$LN99@Guess_medi:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 6949 :     if (_DEBUG_LT_PRED(_Pred, *_Last, *_Mid)) { // swap middle and last, then test first again

	push	DWORD PTR [esi]
	push	DWORD PTR [ebx]
	call	ebp
	add	esp, 8
	test	al, al
	je	SHORT $LN76@Guess_medi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 100  :     _Ty _Tmp = _STD move(_Left);

	mov	ecx, DWORD PTR [ebx]

; 101  :     _Left    = _STD move(_Right);

	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [ebx], eax

; 102  :     _Right   = _STD move(_Tmp);

	mov	DWORD PTR [esi], ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 6952 :         if (_DEBUG_LT_PRED(_Pred, *_Mid, *_First)) {

	push	DWORD PTR [edi]
	push	ecx
	call	ebp
	add	esp, 8
	test	al, al
	je	SHORT $LN76@Guess_medi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 100  :     _Ty _Tmp = _STD move(_Left);

	mov	ecx, DWORD PTR [esi]

; 101  :     _Left    = _STD move(_Right);

	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR [esi], eax

; 102  :     _Right   = _STD move(_Tmp);

	mov	DWORD PTR [edi], ecx
$LN76@Guess_medi:
	pop	edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 6973 : }

	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 8
	ret	0
??$_Guess_median_unchecked@PAPAVCPGDef@PS@@P6A_NPBV12@0@Z@std@@YAXPAPAVCPGDef@PS@@00P6A_NPBV12@1@Z@Z ENDP ; std::_Guess_median_unchecked<PS::CPGDef * *,bool (__cdecl*)(PS::CPGDef const *,PS::CPGDef const *)>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
;	COMDAT ??$iter_swap@PAPAVCPGDef@PS@@PAPAV12@@std@@YAXPAPAVCPGDef@PS@@0@Z
_TEXT	SEGMENT
??$iter_swap@PAPAVCPGDef@PS@@PAPAV12@@std@@YAXPAPAVCPGDef@PS@@0@Z PROC ; std::iter_swap<PS::CPGDef * *,PS::CPGDef * *>, COMDAT
; __Left$ = ecx
; __Right$ = edx

; 101  :     _Left    = _STD move(_Right);

	mov	eax, DWORD PTR [edx]

; 77   : _CONSTEXPR20 void iter_swap(_FwdIt1 _Left, _FwdIt2 _Right) { // swap *_Left and *_Right

	push	esi

; 100  :     _Ty _Tmp = _STD move(_Left);

	mov	esi, DWORD PTR [ecx]

; 101  :     _Left    = _STD move(_Right);

	mov	DWORD PTR [ecx], eax

; 102  :     _Right   = _STD move(_Tmp);

	mov	DWORD PTR [edx], esi
	pop	esi

; 78   :     swap(*_Left, *_Right);
; 79   : }

	ret	0
??$iter_swap@PAPAVCPGDef@PS@@PAPAV12@@std@@YAXPAPAVCPGDef@PS@@0@Z ENDP ; std::iter_swap<PS::CPGDef * *,PS::CPGDef * *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
;	COMDAT ??$?0AAPAPAVCPGDef@PS@@AAPAPAV01@$0A@@?$pair@PAPAVCPGDef@PS@@PAPAV12@@std@@QAE@AAPAPAVCPGDef@PS@@0@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??$?0AAPAPAVCPGDef@PS@@AAPAPAV01@$0A@@?$pair@PAPAVCPGDef@PS@@PAPAV12@@std@@QAE@AAPAPAVCPGDef@PS@@0@Z PROC ; std::pair<PS::CPGDef * *,PS::CPGDef * *>::pair<PS::CPGDef * *,PS::CPGDef * *><PS::CPGDef * * &,PS::CPGDef * * &,0>, COMDAT
; _this$ = ecx

; 186  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

	mov	eax, DWORD PTR __Val1$[esp-4]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR __Val2$[esp-4]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx+4], eax
	mov	eax, ecx
	ret	8
??$?0AAPAPAVCPGDef@PS@@AAPAPAV01@$0A@@?$pair@PAPAVCPGDef@PS@@PAPAV12@@std@@QAE@AAPAPAVCPGDef@PS@@0@Z ENDP ; std::pair<PS::CPGDef * *,PS::CPGDef * *>::pair<PS::CPGDef * *,PS::CPGDef * *><PS::CPGDef * * &,PS::CPGDef * * &,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\type_traits
;	COMDAT ??$forward@PAVCPGDef@PS@@@std@@YA$$QAPAVCPGDef@PS@@AAPAV12@@Z
_TEXT	SEGMENT
??$forward@PAVCPGDef@PS@@@std@@YA$$QAPAVCPGDef@PS@@AAPAV12@@Z PROC ; std::forward<PS::CPGDef *>, COMDAT
; __Arg$ = ecx

; 1386 :     return static_cast<_Ty&&>(_Arg);

	mov	eax, ecx

; 1387 : }

	ret	0
??$forward@PAVCPGDef@PS@@@std@@YA$$QAPAVCPGDef@PS@@AAPAV12@@Z ENDP ; std::forward<PS::CPGDef *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$construct@PAVCPGDef@PS@@PAV12@@?$_Normal_allocator_traits@V?$xalloc@PAVCPGDef@PS@@@@@std@@SAXAAV?$xalloc@PAVCPGDef@PS@@@@PAPAVCPGDef@PS@@$$QAPAV34@@Z
_TEXT	SEGMENT
_<_Args_0>$ = 8						; size = 4
??$construct@PAVCPGDef@PS@@PAV12@@?$_Normal_allocator_traits@V?$xalloc@PAVCPGDef@PS@@@@@std@@SAXAAV?$xalloc@PAVCPGDef@PS@@@@PAPAVCPGDef@PS@@$$QAPAV34@@Z PROC ; std::_Normal_allocator_traits<xalloc<PS::CPGDef *> >::construct<PS::CPGDef *,PS::CPGDef *>, COMDAT
; __Al$dead$ = ecx
; __Ptr$ = edx

; 565  :         if constexpr (_Uses_default_construct<_Alloc, _Ty*, _Types...>::value) {
; 566  :             (void) _Al; // TRANSITION, DevCom-1004719
; 567  : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 568  :             _STD construct_at(_Ptr, _STD forward<_Types>(_Args)...);
; 569  : #else // __cpp_lib_constexpr_dynamic_alloc
; 570  :             ::new (static_cast<void*>(_Ptr)) _Ty(_STD forward<_Types>(_Args)...);
; 571  : #endif // __cpp_lib_constexpr_dynamic_alloc
; 572  :         } else {
; 573  :             _Al.construct(_Ptr, _STD forward<_Types>(_Args)...);

	mov	eax, DWORD PTR _<_Args_0>$[esp-4]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edx], eax

; 574  :         }
; 575  :     }

	ret	0
??$construct@PAVCPGDef@PS@@PAV12@@?$_Normal_allocator_traits@V?$xalloc@PAVCPGDef@PS@@@@@std@@SAXAAV?$xalloc@PAVCPGDef@PS@@@@PAPAVCPGDef@PS@@$$QAPAV34@@Z ENDP ; std::_Normal_allocator_traits<xalloc<PS::CPGDef *> >::construct<PS::CPGDef *,PS::CPGDef *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\type_traits
;	COMDAT ??$forward@PAVCPEDef@PS@@@std@@YA$$QAPAVCPEDef@PS@@AAPAV12@@Z
_TEXT	SEGMENT
??$forward@PAVCPEDef@PS@@@std@@YA$$QAPAVCPEDef@PS@@AAPAV12@@Z PROC ; std::forward<PS::CPEDef *>, COMDAT
; __Arg$ = ecx

; 1386 :     return static_cast<_Ty&&>(_Arg);

	mov	eax, ecx

; 1387 : }

	ret	0
??$forward@PAVCPEDef@PS@@@std@@YA$$QAPAVCPEDef@PS@@AAPAV12@@Z ENDP ; std::forward<PS::CPEDef *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$construct@PAVCPEDef@PS@@PAV12@@?$_Normal_allocator_traits@V?$xalloc@PAVCPEDef@PS@@@@@std@@SAXAAV?$xalloc@PAVCPEDef@PS@@@@PAPAVCPEDef@PS@@$$QAPAV34@@Z
_TEXT	SEGMENT
_<_Args_0>$ = 8						; size = 4
??$construct@PAVCPEDef@PS@@PAV12@@?$_Normal_allocator_traits@V?$xalloc@PAVCPEDef@PS@@@@@std@@SAXAAV?$xalloc@PAVCPEDef@PS@@@@PAPAVCPEDef@PS@@$$QAPAV34@@Z PROC ; std::_Normal_allocator_traits<xalloc<PS::CPEDef *> >::construct<PS::CPEDef *,PS::CPEDef *>, COMDAT
; __Al$dead$ = ecx
; __Ptr$ = edx

; 565  :         if constexpr (_Uses_default_construct<_Alloc, _Ty*, _Types...>::value) {
; 566  :             (void) _Al; // TRANSITION, DevCom-1004719
; 567  : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 568  :             _STD construct_at(_Ptr, _STD forward<_Types>(_Args)...);
; 569  : #else // __cpp_lib_constexpr_dynamic_alloc
; 570  :             ::new (static_cast<void*>(_Ptr)) _Ty(_STD forward<_Types>(_Args)...);
; 571  : #endif // __cpp_lib_constexpr_dynamic_alloc
; 572  :         } else {
; 573  :             _Al.construct(_Ptr, _STD forward<_Types>(_Args)...);

	mov	eax, DWORD PTR _<_Args_0>$[esp-4]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edx], eax

; 574  :         }
; 575  :     }

	ret	0
??$construct@PAVCPEDef@PS@@PAV12@@?$_Normal_allocator_traits@V?$xalloc@PAVCPEDef@PS@@@@@std@@SAXAAV?$xalloc@PAVCPEDef@PS@@@@PAPAVCPEDef@PS@@$$QAPAV34@@Z ENDP ; std::_Normal_allocator_traits<xalloc<PS::CPEDef *> >::construct<PS::CPEDef *,PS::CPEDef *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_Copy_backward_memmove@PAPAVCPEDef@PS@@PAPAV12@@std@@YAPAPAVCPEDef@PS@@PAPAV12@00@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
??$_Copy_backward_memmove@PAPAVCPEDef@PS@@PAPAV12@@std@@YAPAPAVCPEDef@PS@@PAPAV12@00@Z PROC ; std::_Copy_backward_memmove<PS::CPEDef * *,PS::CPEDef * *>, COMDAT
; __First$ = ecx
; __Last$ = edx

; 4247 :     // implement copy_backward-like function as memmove
; 4248 :     auto _FirstPtr              = _To_address(_First);
; 4249 :     auto _LastPtr               = _To_address(_Last);
; 4250 :     auto _DestPtr               = _To_address(_Dest);
; 4251 :     const char* const _First_ch = const_cast<const char*>(reinterpret_cast<const volatile char*>(_FirstPtr));
; 4252 :     const char* const _Last_ch  = const_cast<const char*>(reinterpret_cast<const volatile char*>(_LastPtr));
; 4253 :     char* const _Dest_ch        = const_cast<char*>(reinterpret_cast<const volatile char*>(_DestPtr));
; 4254 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);
; 4255 :     auto _Result                = _CSTD memmove(_Dest_ch - _Count, _First_ch, _Count);

	mov	eax, DWORD PTR __Dest$[esp-4]
	sub	edx, ecx
	push	edx
	push	ecx
	sub	eax, edx
	push	eax
	call	_memmove
	add	esp, 12					; 0000000cH

; 4256 :     if constexpr (is_pointer_v<_CtgIt2>) {
; 4257 :         return static_cast<_CtgIt2>(_Result);
; 4258 :     } else {
; 4259 :         return _Dest - (_LastPtr - _FirstPtr);
; 4260 :     }
; 4261 : }

	ret	0
??$_Copy_backward_memmove@PAPAVCPEDef@PS@@PAPAV12@@std@@YAPAPAVCPEDef@PS@@PAPAV12@00@Z ENDP ; std::_Copy_backward_memmove<PS::CPEDef * *,PS::CPEDef * *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
;	COMDAT ??$_Push_heap_by_index@PAPAVCPEDef@PS@@PAV12@P6A_NPBV12@0@Z@std@@YAXPAPAVCPEDef@PS@@HH$$QAPAV12@P6A_NPBV12@2@Z@Z
_TEXT	SEGMENT
__Top$ = 8						; size = 4
__Val$ = 12						; size = 4
__Pred$ = 16						; size = 4
??$_Push_heap_by_index@PAPAVCPEDef@PS@@PAV12@P6A_NPBV12@0@Z@std@@YAXPAPAVCPEDef@PS@@HH$$QAPAV12@P6A_NPBV12@2@Z@Z PROC ; std::_Push_heap_by_index<PS::CPEDef * *,PS::CPEDef *,bool (__cdecl*)(PS::CPEDef const *,PS::CPEDef const *)>, COMDAT
; __First$ = ecx
; __Hole$ = edx

; 5264 :     _RanIt _First, _Iter_diff_t<_RanIt> _Hole, _Iter_diff_t<_RanIt> _Top, _Ty&& _Val, _Pr _Pred) {

	push	ebx
	push	edi
	mov	edi, edx
	mov	ebx, ecx

; 5265 :     // percolate _Hole to _Top or where _Val belongs
; 5266 :     using _Diff = _Iter_diff_t<_RanIt>;
; 5267 :     for (_Diff _Idx = (_Hole - 1) >> 1; // shift for codegen
; 5268 :          _Top < _Hole && _DEBUG_LT_PRED(_Pred, *(_First + _Idx), _Val); //

	cmp	DWORD PTR __Top$[esp+4], edi
	jge	SHORT $LN10@Push_heap_
	push	ebp
	mov	ebp, DWORD PTR __Val$[esp+8]
	push	esi
$LL4@Push_heap_:
	push	DWORD PTR [ebp]
	lea	esi, DWORD PTR [edi-1]
	sar	esi, 1
	push	DWORD PTR [ebx+esi*4]
	call	DWORD PTR __Pred$[esp+20]
	add	esp, 8
	test	al, al
	je	SHORT $LN11@Push_heap_

; 5269 :          _Idx = (_Hole - 1) >> 1) { // shift for codegen
; 5270 :         // move _Hole up to parent
; 5271 :         *(_First + _Hole) = _STD move(*(_First + _Idx));

	mov	eax, DWORD PTR [ebx+esi*4]
	mov	DWORD PTR [ebx+edi*4], eax

; 5272 :         _Hole             = _Idx;

	mov	edi, esi
	cmp	DWORD PTR __Top$[esp+12], esi
	jl	SHORT $LL4@Push_heap_
$LN11@Push_heap_:

; 5273 :     }
; 5274 : 
; 5275 :     *(_First + _Hole) = _STD forward<_Ty>(_Val); // drop _Val into final hole

	mov	eax, DWORD PTR [ebp]
	pop	esi
	pop	ebp
	mov	DWORD PTR [ebx+edi*4], eax
	pop	edi

; 5276 : }

	pop	ebx
	ret	0
$LN10@Push_heap_:

; 5273 :     }
; 5274 : 
; 5275 :     *(_First + _Hole) = _STD forward<_Ty>(_Val); // drop _Val into final hole

	mov	eax, DWORD PTR __Val$[esp+4]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ebx+edi*4], eax
	pop	edi

; 5276 : }

	pop	ebx
	ret	0
??$_Push_heap_by_index@PAPAVCPEDef@PS@@PAV12@P6A_NPBV12@0@Z@std@@YAXPAPAVCPEDef@PS@@HH$$QAPAV12@P6A_NPBV12@2@Z@Z ENDP ; std::_Push_heap_by_index<PS::CPEDef * *,PS::CPEDef *,bool (__cdecl*)(PS::CPEDef const *,PS::CPEDef const *)>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
;	COMDAT ??$_Pop_heap_hole_unchecked@PAPAVCPEDef@PS@@PAV12@P6A_NPBV12@0@Z@std@@YAXPAPAVCPEDef@PS@@00$$QAPAV12@P6A_NPBV12@2@Z@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Val$ = 12						; size = 4
__Pred$ = 16						; size = 4
??$_Pop_heap_hole_unchecked@PAPAVCPEDef@PS@@PAV12@P6A_NPBV12@0@Z@std@@YAXPAPAVCPEDef@PS@@00$$QAPAV12@P6A_NPBV12@2@Z@Z PROC ; std::_Pop_heap_hole_unchecked<PS::CPEDef * *,PS::CPEDef *,bool (__cdecl*)(PS::CPEDef const *,PS::CPEDef const *)>, COMDAT
; __First$ = ecx
; __Last$ = edx

; 5405 :     // pop *_First to *_Dest and reheap
; 5406 :     // precondition: _First != _Last
; 5407 :     // precondition: _First != _Dest
; 5408 :     *_Dest      = _STD move(*_First);

	mov	eax, DWORD PTR __Dest$[esp-4]
	push	esi
	mov	esi, DWORD PTR [ecx]
	mov	DWORD PTR [eax], esi

; 5409 :     using _Diff = _Iter_diff_t<_RanIt>;
; 5410 :     _Pop_heap_hole_by_index(

	pop	esi
	sub	edx, ecx
	sar	edx, 2
	mov	DWORD PTR __Dest$[esp-4], edx
	xor	edx, edx
	jmp	??$_Pop_heap_hole_by_index@PAPAVCPEDef@PS@@PAV12@P6A_NPBV12@0@Z@std@@YAXPAPAVCPEDef@PS@@HH$$QAPAV12@P6A_NPBV12@2@Z@Z ; std::_Pop_heap_hole_by_index<PS::CPEDef * *,PS::CPEDef *,bool (__cdecl*)(PS::CPEDef const *,PS::CPEDef const *)>
??$_Pop_heap_hole_unchecked@PAPAVCPEDef@PS@@PAV12@P6A_NPBV12@0@Z@std@@YAXPAPAVCPEDef@PS@@00$$QAPAV12@P6A_NPBV12@2@Z@Z ENDP ; std::_Pop_heap_hole_unchecked<PS::CPEDef * *,PS::CPEDef *,bool (__cdecl*)(PS::CPEDef const *,PS::CPEDef const *)>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
;	COMDAT ??$_Med3_unchecked@PAPAVCPEDef@PS@@P6A_NPBV12@0@Z@std@@YAXPAPAVCPEDef@PS@@00P6A_NPBV12@1@Z@Z
_TEXT	SEGMENT
__Last$ = 8						; size = 4
__Pred$ = 12						; size = 4
??$_Med3_unchecked@PAPAVCPEDef@PS@@P6A_NPBV12@0@Z@std@@YAXPAPAVCPEDef@PS@@00P6A_NPBV12@1@Z@Z PROC ; std::_Med3_unchecked<PS::CPEDef * *,bool (__cdecl*)(PS::CPEDef const *,PS::CPEDef const *)>, COMDAT
; __First$ = ecx
; __Mid$ = edx

; 6943 : _CONSTEXPR20 void _Med3_unchecked(_RanIt _First, _RanIt _Mid, _RanIt _Last, _Pr _Pred) {

	push	ebx
	push	ebp

; 6944 :     // sort median of three elements to middle
; 6945 :     if (_DEBUG_LT_PRED(_Pred, *_Mid, *_First)) {

	mov	ebp, DWORD PTR __Pred$[esp+4]
	push	esi
	push	edi
	mov	edi, ecx
	mov	esi, edx
	push	DWORD PTR [edi]
	push	DWORD PTR [esi]
	call	ebp
	add	esp, 8
	test	al, al
	je	SHORT $LN19@Med3_unche
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 100  :     _Ty _Tmp = _STD move(_Left);

	mov	ecx, DWORD PTR [esi]

; 101  :     _Left    = _STD move(_Right);

	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR [esi], eax

; 102  :     _Right   = _STD move(_Tmp);

	mov	DWORD PTR [edi], ecx
$LN19@Med3_unche:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 6949 :     if (_DEBUG_LT_PRED(_Pred, *_Last, *_Mid)) { // swap middle and last, then test first again

	mov	ebx, DWORD PTR __Last$[esp+12]
	push	DWORD PTR [esi]
	push	DWORD PTR [ebx]
	call	ebp
	add	esp, 8
	test	al, al
	je	SHORT $LN4@Med3_unche
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 100  :     _Ty _Tmp = _STD move(_Left);

	mov	ecx, DWORD PTR [ebx]

; 101  :     _Left    = _STD move(_Right);

	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [ebx], eax

; 102  :     _Right   = _STD move(_Tmp);

	mov	DWORD PTR [esi], ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 6952 :         if (_DEBUG_LT_PRED(_Pred, *_Mid, *_First)) {

	push	DWORD PTR [edi]
	push	ecx
	call	ebp
	add	esp, 8
	test	al, al
	je	SHORT $LN4@Med3_unche
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 100  :     _Ty _Tmp = _STD move(_Left);

	mov	ecx, DWORD PTR [esi]

; 101  :     _Left    = _STD move(_Right);

	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR [esi], eax

; 102  :     _Right   = _STD move(_Tmp);

	mov	DWORD PTR [edi], ecx
$LN4@Med3_unche:
	pop	edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 6956 : }

	pop	esi
	pop	ebp
	pop	ebx
	ret	0
??$_Med3_unchecked@PAPAVCPEDef@PS@@P6A_NPBV12@0@Z@std@@YAXPAPAVCPEDef@PS@@00P6A_NPBV12@1@Z@Z ENDP ; std::_Med3_unchecked<PS::CPEDef * *,bool (__cdecl*)(PS::CPEDef const *,PS::CPEDef const *)>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
;	COMDAT ??$swap@PAVCPEDef@PS@@$0A@@std@@YAXAAPAVCPEDef@PS@@0@Z
_TEXT	SEGMENT
??$swap@PAVCPEDef@PS@@$0A@@std@@YAXAAPAVCPEDef@PS@@0@Z PROC ; std::swap<PS::CPEDef *,0>, COMDAT
; __Left$ = ecx
; __Right$ = edx

; 100  :     _Ty _Tmp = _STD move(_Left);
; 101  :     _Left    = _STD move(_Right);

	mov	eax, DWORD PTR [edx]
	push	esi
	mov	esi, DWORD PTR [ecx]
	mov	DWORD PTR [ecx], eax

; 102  :     _Right   = _STD move(_Tmp);

	mov	DWORD PTR [edx], esi
	pop	esi

; 103  : }

	ret	0
??$swap@PAVCPEDef@PS@@$0A@@std@@YAXAAPAVCPEDef@PS@@0@Z ENDP ; std::swap<PS::CPEDef *,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_Copy_backward_memmove@PAPAVCPGDef@PS@@PAPAV12@@std@@YAPAPAVCPGDef@PS@@PAPAV12@00@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
??$_Copy_backward_memmove@PAPAVCPGDef@PS@@PAPAV12@@std@@YAPAPAVCPGDef@PS@@PAPAV12@00@Z PROC ; std::_Copy_backward_memmove<PS::CPGDef * *,PS::CPGDef * *>, COMDAT
; __First$ = ecx
; __Last$ = edx

; 4247 :     // implement copy_backward-like function as memmove
; 4248 :     auto _FirstPtr              = _To_address(_First);
; 4249 :     auto _LastPtr               = _To_address(_Last);
; 4250 :     auto _DestPtr               = _To_address(_Dest);
; 4251 :     const char* const _First_ch = const_cast<const char*>(reinterpret_cast<const volatile char*>(_FirstPtr));
; 4252 :     const char* const _Last_ch  = const_cast<const char*>(reinterpret_cast<const volatile char*>(_LastPtr));
; 4253 :     char* const _Dest_ch        = const_cast<char*>(reinterpret_cast<const volatile char*>(_DestPtr));
; 4254 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);
; 4255 :     auto _Result                = _CSTD memmove(_Dest_ch - _Count, _First_ch, _Count);

	mov	eax, DWORD PTR __Dest$[esp-4]
	sub	edx, ecx
	push	edx
	push	ecx
	sub	eax, edx
	push	eax
	call	_memmove
	add	esp, 12					; 0000000cH

; 4256 :     if constexpr (is_pointer_v<_CtgIt2>) {
; 4257 :         return static_cast<_CtgIt2>(_Result);
; 4258 :     } else {
; 4259 :         return _Dest - (_LastPtr - _FirstPtr);
; 4260 :     }
; 4261 : }

	ret	0
??$_Copy_backward_memmove@PAPAVCPGDef@PS@@PAPAV12@@std@@YAPAPAVCPGDef@PS@@PAPAV12@00@Z ENDP ; std::_Copy_backward_memmove<PS::CPGDef * *,PS::CPGDef * *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
;	COMDAT ??$_Push_heap_by_index@PAPAVCPGDef@PS@@PAV12@P6A_NPBV12@0@Z@std@@YAXPAPAVCPGDef@PS@@HH$$QAPAV12@P6A_NPBV12@2@Z@Z
_TEXT	SEGMENT
__Top$ = 8						; size = 4
__Val$ = 12						; size = 4
__Pred$ = 16						; size = 4
??$_Push_heap_by_index@PAPAVCPGDef@PS@@PAV12@P6A_NPBV12@0@Z@std@@YAXPAPAVCPGDef@PS@@HH$$QAPAV12@P6A_NPBV12@2@Z@Z PROC ; std::_Push_heap_by_index<PS::CPGDef * *,PS::CPGDef *,bool (__cdecl*)(PS::CPGDef const *,PS::CPGDef const *)>, COMDAT
; __First$ = ecx
; __Hole$ = edx

; 5264 :     _RanIt _First, _Iter_diff_t<_RanIt> _Hole, _Iter_diff_t<_RanIt> _Top, _Ty&& _Val, _Pr _Pred) {

	push	ebx
	push	edi
	mov	edi, edx
	mov	ebx, ecx

; 5265 :     // percolate _Hole to _Top or where _Val belongs
; 5266 :     using _Diff = _Iter_diff_t<_RanIt>;
; 5267 :     for (_Diff _Idx = (_Hole - 1) >> 1; // shift for codegen
; 5268 :          _Top < _Hole && _DEBUG_LT_PRED(_Pred, *(_First + _Idx), _Val); //

	cmp	DWORD PTR __Top$[esp+4], edi
	jge	SHORT $LN10@Push_heap_
	push	ebp
	mov	ebp, DWORD PTR __Val$[esp+8]
	push	esi
$LL4@Push_heap_:
	push	DWORD PTR [ebp]
	lea	esi, DWORD PTR [edi-1]
	sar	esi, 1
	push	DWORD PTR [ebx+esi*4]
	call	DWORD PTR __Pred$[esp+20]
	add	esp, 8
	test	al, al
	je	SHORT $LN11@Push_heap_

; 5269 :          _Idx = (_Hole - 1) >> 1) { // shift for codegen
; 5270 :         // move _Hole up to parent
; 5271 :         *(_First + _Hole) = _STD move(*(_First + _Idx));

	mov	eax, DWORD PTR [ebx+esi*4]
	mov	DWORD PTR [ebx+edi*4], eax

; 5272 :         _Hole             = _Idx;

	mov	edi, esi
	cmp	DWORD PTR __Top$[esp+12], esi
	jl	SHORT $LL4@Push_heap_
$LN11@Push_heap_:

; 5273 :     }
; 5274 : 
; 5275 :     *(_First + _Hole) = _STD forward<_Ty>(_Val); // drop _Val into final hole

	mov	eax, DWORD PTR [ebp]
	pop	esi
	pop	ebp
	mov	DWORD PTR [ebx+edi*4], eax
	pop	edi

; 5276 : }

	pop	ebx
	ret	0
$LN10@Push_heap_:

; 5273 :     }
; 5274 : 
; 5275 :     *(_First + _Hole) = _STD forward<_Ty>(_Val); // drop _Val into final hole

	mov	eax, DWORD PTR __Val$[esp+4]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ebx+edi*4], eax
	pop	edi

; 5276 : }

	pop	ebx
	ret	0
??$_Push_heap_by_index@PAPAVCPGDef@PS@@PAV12@P6A_NPBV12@0@Z@std@@YAXPAPAVCPGDef@PS@@HH$$QAPAV12@P6A_NPBV12@2@Z@Z ENDP ; std::_Push_heap_by_index<PS::CPGDef * *,PS::CPGDef *,bool (__cdecl*)(PS::CPGDef const *,PS::CPGDef const *)>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
;	COMDAT ??$_Pop_heap_hole_unchecked@PAPAVCPGDef@PS@@PAV12@P6A_NPBV12@0@Z@std@@YAXPAPAVCPGDef@PS@@00$$QAPAV12@P6A_NPBV12@2@Z@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Val$ = 12						; size = 4
__Pred$ = 16						; size = 4
??$_Pop_heap_hole_unchecked@PAPAVCPGDef@PS@@PAV12@P6A_NPBV12@0@Z@std@@YAXPAPAVCPGDef@PS@@00$$QAPAV12@P6A_NPBV12@2@Z@Z PROC ; std::_Pop_heap_hole_unchecked<PS::CPGDef * *,PS::CPGDef *,bool (__cdecl*)(PS::CPGDef const *,PS::CPGDef const *)>, COMDAT
; __First$ = ecx
; __Last$ = edx

; 5405 :     // pop *_First to *_Dest and reheap
; 5406 :     // precondition: _First != _Last
; 5407 :     // precondition: _First != _Dest
; 5408 :     *_Dest      = _STD move(*_First);

	mov	eax, DWORD PTR __Dest$[esp-4]
	push	esi
	mov	esi, DWORD PTR [ecx]
	mov	DWORD PTR [eax], esi

; 5409 :     using _Diff = _Iter_diff_t<_RanIt>;
; 5410 :     _Pop_heap_hole_by_index(

	pop	esi
	sub	edx, ecx
	sar	edx, 2
	mov	DWORD PTR __Dest$[esp-4], edx
	xor	edx, edx
	jmp	??$_Pop_heap_hole_by_index@PAPAVCPGDef@PS@@PAV12@P6A_NPBV12@0@Z@std@@YAXPAPAVCPGDef@PS@@HH$$QAPAV12@P6A_NPBV12@2@Z@Z ; std::_Pop_heap_hole_by_index<PS::CPGDef * *,PS::CPGDef *,bool (__cdecl*)(PS::CPGDef const *,PS::CPGDef const *)>
??$_Pop_heap_hole_unchecked@PAPAVCPGDef@PS@@PAV12@P6A_NPBV12@0@Z@std@@YAXPAPAVCPGDef@PS@@00$$QAPAV12@P6A_NPBV12@2@Z@Z ENDP ; std::_Pop_heap_hole_unchecked<PS::CPGDef * *,PS::CPGDef *,bool (__cdecl*)(PS::CPGDef const *,PS::CPGDef const *)>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
;	COMDAT ??$_Med3_unchecked@PAPAVCPGDef@PS@@P6A_NPBV12@0@Z@std@@YAXPAPAVCPGDef@PS@@00P6A_NPBV12@1@Z@Z
_TEXT	SEGMENT
__Last$ = 8						; size = 4
__Pred$ = 12						; size = 4
??$_Med3_unchecked@PAPAVCPGDef@PS@@P6A_NPBV12@0@Z@std@@YAXPAPAVCPGDef@PS@@00P6A_NPBV12@1@Z@Z PROC ; std::_Med3_unchecked<PS::CPGDef * *,bool (__cdecl*)(PS::CPGDef const *,PS::CPGDef const *)>, COMDAT
; __First$ = ecx
; __Mid$ = edx

; 6943 : _CONSTEXPR20 void _Med3_unchecked(_RanIt _First, _RanIt _Mid, _RanIt _Last, _Pr _Pred) {

	push	ebx
	push	ebp

; 6944 :     // sort median of three elements to middle
; 6945 :     if (_DEBUG_LT_PRED(_Pred, *_Mid, *_First)) {

	mov	ebp, DWORD PTR __Pred$[esp+4]
	push	esi
	push	edi
	mov	edi, ecx
	mov	esi, edx
	push	DWORD PTR [edi]
	push	DWORD PTR [esi]
	call	ebp
	add	esp, 8
	test	al, al
	je	SHORT $LN19@Med3_unche
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 100  :     _Ty _Tmp = _STD move(_Left);

	mov	ecx, DWORD PTR [esi]

; 101  :     _Left    = _STD move(_Right);

	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR [esi], eax

; 102  :     _Right   = _STD move(_Tmp);

	mov	DWORD PTR [edi], ecx
$LN19@Med3_unche:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 6949 :     if (_DEBUG_LT_PRED(_Pred, *_Last, *_Mid)) { // swap middle and last, then test first again

	mov	ebx, DWORD PTR __Last$[esp+12]
	push	DWORD PTR [esi]
	push	DWORD PTR [ebx]
	call	ebp
	add	esp, 8
	test	al, al
	je	SHORT $LN4@Med3_unche
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 100  :     _Ty _Tmp = _STD move(_Left);

	mov	ecx, DWORD PTR [ebx]

; 101  :     _Left    = _STD move(_Right);

	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [ebx], eax

; 102  :     _Right   = _STD move(_Tmp);

	mov	DWORD PTR [esi], ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 6952 :         if (_DEBUG_LT_PRED(_Pred, *_Mid, *_First)) {

	push	DWORD PTR [edi]
	push	ecx
	call	ebp
	add	esp, 8
	test	al, al
	je	SHORT $LN4@Med3_unche
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 100  :     _Ty _Tmp = _STD move(_Left);

	mov	ecx, DWORD PTR [esi]

; 101  :     _Left    = _STD move(_Right);

	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR [esi], eax

; 102  :     _Right   = _STD move(_Tmp);

	mov	DWORD PTR [edi], ecx
$LN4@Med3_unche:
	pop	edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 6956 : }

	pop	esi
	pop	ebp
	pop	ebx
	ret	0
??$_Med3_unchecked@PAPAVCPGDef@PS@@P6A_NPBV12@0@Z@std@@YAXPAPAVCPGDef@PS@@00P6A_NPBV12@1@Z@Z ENDP ; std::_Med3_unchecked<PS::CPGDef * *,bool (__cdecl*)(PS::CPGDef const *,PS::CPGDef const *)>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
;	COMDAT ??$swap@PAVCPGDef@PS@@$0A@@std@@YAXAAPAVCPGDef@PS@@0@Z
_TEXT	SEGMENT
??$swap@PAVCPGDef@PS@@$0A@@std@@YAXAAPAVCPGDef@PS@@0@Z PROC ; std::swap<PS::CPGDef *,0>, COMDAT
; __Left$ = ecx
; __Right$ = edx

; 100  :     _Ty _Tmp = _STD move(_Left);
; 101  :     _Left    = _STD move(_Right);

	mov	eax, DWORD PTR [edx]
	push	esi
	mov	esi, DWORD PTR [ecx]
	mov	DWORD PTR [ecx], eax

; 102  :     _Right   = _STD move(_Tmp);

	mov	DWORD PTR [edx], esi
	pop	esi

; 103  : }

	ret	0
??$swap@PAVCPGDef@PS@@$0A@@std@@YAXAAPAVCPGDef@PS@@0@Z ENDP ; std::swap<PS::CPGDef *,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
;	COMDAT ??$xr_free@PAVCPEDef@PS@@@@YAXAAPAPAVCPEDef@PS@@@Z
_TEXT	SEGMENT
??$xr_free@PAVCPEDef@PS@@@@YAXAAPAPAVCPEDef@PS@@@Z PROC	; xr_free<PS::CPEDef *>, COMDAT
; _P$ = ecx

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	push	esi
	mov	esi, ecx
	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN2@xr_free
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
	mov	DWORD PTR [esi], 0
$LN2@xr_free:
	pop	esi
	ret	0
??$xr_free@PAVCPEDef@PS@@@@YAXAAPAPAVCPEDef@PS@@@Z ENDP	; xr_free<PS::CPEDef *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?deallocate@?$xalloc@PAVCPEDef@PS@@@@QBEXPAPAVCPEDef@PS@@I@Z
_TEXT	SEGMENT
_p$ = 8							; size = 4
_n$dead$ = 12						; size = 4
?deallocate@?$xalloc@PAVCPEDef@PS@@@@QBEXPAPAVCPEDef@PS@@I@Z PROC ; xalloc<PS::CPEDef *>::deallocate, COMDAT
; _this$dead$ = ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	eax, DWORD PTR _p$[esp-4]
	test	eax, eax
	je	SHORT $LN4@deallocate
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN4@deallocate:
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 82   : 							void					deallocate		(pointer p, size_type n) const			{	xr_free	(p);				}

	ret	8
?deallocate@?$xalloc@PAVCPEDef@PS@@@@QBEXPAPAVCPEDef@PS@@I@Z ENDP ; xalloc<PS::CPEDef *>::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
;	COMDAT ??$xr_free@PAVCPGDef@PS@@@@YAXAAPAPAVCPGDef@PS@@@Z
_TEXT	SEGMENT
??$xr_free@PAVCPGDef@PS@@@@YAXAAPAPAVCPGDef@PS@@@Z PROC	; xr_free<PS::CPGDef *>, COMDAT
; _P$ = ecx

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	push	esi
	mov	esi, ecx
	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN2@xr_free
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
	mov	DWORD PTR [esi], 0
$LN2@xr_free:
	pop	esi
	ret	0
??$xr_free@PAVCPGDef@PS@@@@YAXAAPAPAVCPGDef@PS@@@Z ENDP	; xr_free<PS::CPGDef *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?deallocate@?$xalloc@PAVCPGDef@PS@@@@QBEXPAPAVCPGDef@PS@@I@Z
_TEXT	SEGMENT
_p$ = 8							; size = 4
_n$dead$ = 12						; size = 4
?deallocate@?$xalloc@PAVCPGDef@PS@@@@QBEXPAPAVCPGDef@PS@@I@Z PROC ; xalloc<PS::CPGDef *>::deallocate, COMDAT
; _this$dead$ = ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	eax, DWORD PTR _p$[esp-4]
	test	eax, eax
	je	SHORT $LN4@deallocate
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN4@deallocate:
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 82   : 							void					deallocate		(pointer p, size_type n) const			{	xr_free	(p);				}

	ret	8
?deallocate@?$xalloc@PAVCPGDef@PS@@@@QBEXPAPAVCPGDef@PS@@I@Z ENDP ; xalloc<PS::CPGDef *>::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Destroy_range@V?$xalloc@PAVCPEDef@PS@@@@@std@@YAXPAPAVCPEDef@PS@@QAPAV12@AAV?$xalloc@PAVCPEDef@PS@@@@@Z
_TEXT	SEGMENT
__Al$dead$ = 8						; size = 4
??$_Destroy_range@V?$xalloc@PAVCPEDef@PS@@@@@std@@YAXPAPAVCPEDef@PS@@QAPAV12@AAV?$xalloc@PAVCPEDef@PS@@@@@Z PROC ; std::_Destroy_range<xalloc<PS::CPEDef *> >, COMDAT
; __First$dead$ = ecx
; __Last$dead$ = edx

; 901  :     // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
; 902  :     using _Ty = typename _Alloc::value_type;
; 903  :     if constexpr (!conjunction_v<is_trivially_destructible<_Ty>, _Uses_default_destroy<_Alloc, _Ty*>>) {
; 904  :         for (; _First != _Last; ++_First) {
; 905  :             allocator_traits<_Alloc>::destroy(_Al, _Unfancy(_First));
; 906  :         }
; 907  :     }
; 908  : }

	ret	0
??$_Destroy_range@V?$xalloc@PAVCPEDef@PS@@@@@std@@YAXPAPAVCPEDef@PS@@QAPAV12@AAV?$xalloc@PAVCPEDef@PS@@@@@Z ENDP ; std::_Destroy_range<xalloc<PS::CPEDef *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Destroy@?$vector@PAVCPEDef@PS@@V?$xalloc@PAVCPEDef@PS@@@@@std@@AAEXPAPAVCPEDef@PS@@0@Z
_TEXT	SEGMENT
__First$dead$ = 8					; size = 4
__Last$dead$ = 12					; size = 4
?_Destroy@?$vector@PAVCPEDef@PS@@V?$xalloc@PAVCPEDef@PS@@@@@std@@AAEXPAPAVCPEDef@PS@@0@Z PROC ; std::vector<PS::CPEDef *,xalloc<PS::CPEDef *> >::_Destroy, COMDAT
; _this$dead$ = ecx

; 1666 :         // destroy [_First, _Last) using allocator
; 1667 :         _Destroy_range(_First, _Last, _Getal());
; 1668 :     }

	ret	8
?_Destroy@?$vector@PAVCPEDef@PS@@V?$xalloc@PAVCPEDef@PS@@@@@std@@AAEXPAPAVCPEDef@PS@@0@Z ENDP ; std::vector<PS::CPEDef *,xalloc<PS::CPEDef *> >::_Destroy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Destroy_range@V?$xalloc@PAVCPGDef@PS@@@@@std@@YAXPAPAVCPGDef@PS@@QAPAV12@AAV?$xalloc@PAVCPGDef@PS@@@@@Z
_TEXT	SEGMENT
__Al$dead$ = 8						; size = 4
??$_Destroy_range@V?$xalloc@PAVCPGDef@PS@@@@@std@@YAXPAPAVCPGDef@PS@@QAPAV12@AAV?$xalloc@PAVCPGDef@PS@@@@@Z PROC ; std::_Destroy_range<xalloc<PS::CPGDef *> >, COMDAT
; __First$dead$ = ecx
; __Last$dead$ = edx

; 901  :     // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
; 902  :     using _Ty = typename _Alloc::value_type;
; 903  :     if constexpr (!conjunction_v<is_trivially_destructible<_Ty>, _Uses_default_destroy<_Alloc, _Ty*>>) {
; 904  :         for (; _First != _Last; ++_First) {
; 905  :             allocator_traits<_Alloc>::destroy(_Al, _Unfancy(_First));
; 906  :         }
; 907  :     }
; 908  : }

	ret	0
??$_Destroy_range@V?$xalloc@PAVCPGDef@PS@@@@@std@@YAXPAPAVCPGDef@PS@@QAPAV12@AAV?$xalloc@PAVCPGDef@PS@@@@@Z ENDP ; std::_Destroy_range<xalloc<PS::CPGDef *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Destroy@?$vector@PAVCPGDef@PS@@V?$xalloc@PAVCPGDef@PS@@@@@std@@AAEXPAPAVCPGDef@PS@@0@Z
_TEXT	SEGMENT
__First$dead$ = 8					; size = 4
__Last$dead$ = 12					; size = 4
?_Destroy@?$vector@PAVCPGDef@PS@@V?$xalloc@PAVCPGDef@PS@@@@@std@@AAEXPAPAVCPGDef@PS@@0@Z PROC ; std::vector<PS::CPGDef *,xalloc<PS::CPGDef *> >::_Destroy, COMDAT
; _this$dead$ = ecx

; 1666 :         // destroy [_First, _Last) using allocator
; 1667 :         _Destroy_range(_First, _Last, _Getal());
; 1668 :     }

	ret	8
?_Destroy@?$vector@PAVCPGDef@PS@@V?$xalloc@PAVCPGDef@PS@@@@@std@@AAEXPAPAVCPGDef@PS@@0@Z ENDP ; std::vector<PS::CPGDef *,xalloc<PS::CPGDef *> >::_Destroy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$xalloc@PAVCPEDef@PS@@@@V?$_Vector_val@U?$_Simple_types@PAVCPEDef@PS@@@std@@@std@@$00@std@@QAEAAV?$xalloc@PAVCPEDef@PS@@@@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@V?$xalloc@PAVCPEDef@PS@@@@V?$_Vector_val@U?$_Simple_types@PAVCPEDef@PS@@@std@@@std@@$00@std@@QAEAAV?$xalloc@PAVCPEDef@PS@@@@XZ PROC ; std::_Compressed_pair<xalloc<PS::CPEDef *>,std::_Vector_val<std::_Simple_types<PS::CPEDef *> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 1339 :         return *this;

	mov	eax, ecx

; 1340 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$xalloc@PAVCPEDef@PS@@@@V?$_Vector_val@U?$_Simple_types@PAVCPEDef@PS@@@std@@@std@@$00@std@@QAEAAV?$xalloc@PAVCPEDef@PS@@@@XZ ENDP ; std::_Compressed_pair<xalloc<PS::CPEDef *>,std::_Vector_val<std::_Simple_types<PS::CPEDef *> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Getal@?$vector@PAVCPEDef@PS@@V?$xalloc@PAVCPEDef@PS@@@@@std@@AAEAAV?$xalloc@PAVCPEDef@PS@@@@XZ
_TEXT	SEGMENT
?_Getal@?$vector@PAVCPEDef@PS@@V?$xalloc@PAVCPEDef@PS@@@@@std@@AAEAAV?$xalloc@PAVCPEDef@PS@@@@XZ PROC ; std::vector<PS::CPEDef *,xalloc<PS::CPEDef *> >::_Getal, COMDAT
; _this$ = ecx

; 1805 :         return _Mypair._Get_first();

	mov	eax, ecx

; 1806 :     }

	ret	0
?_Getal@?$vector@PAVCPEDef@PS@@V?$xalloc@PAVCPEDef@PS@@@@@std@@AAEAAV?$xalloc@PAVCPEDef@PS@@@@XZ ENDP ; std::vector<PS::CPEDef *,xalloc<PS::CPEDef *> >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef
;	COMDAT ??$_Unfancy@PAVCPEDef@PS@@@std@@YAPAPAVCPEDef@PS@@PAPAV12@@Z
_TEXT	SEGMENT
??$_Unfancy@PAVCPEDef@PS@@@std@@YAPAPAVCPEDef@PS@@PAPAV12@@Z PROC ; std::_Unfancy<PS::CPEDef *>, COMDAT
; __Ptr$ = ecx

; 266  :     return _Ptr;

	mov	eax, ecx

; 267  : }

	ret	0
??$_Unfancy@PAVCPEDef@PS@@@std@@YAPAPAVCPEDef@PS@@PAPAV12@@Z ENDP ; std::_Unfancy<PS::CPEDef *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Destroy_in_place@PAPAVCPEDef@PS@@@std@@YAXAAPAPAVCPEDef@PS@@@Z
_TEXT	SEGMENT
??$_Destroy_in_place@PAPAVCPEDef@PS@@@std@@YAXAAPAPAVCPEDef@PS@@@Z PROC ; std::_Destroy_in_place<PS::CPEDef * *>, COMDAT
; __Obj$dead$ = ecx

; 295  :     if constexpr (is_array_v<_Ty>) {
; 296  :         _Destroy_range(_Obj, _Obj + extent_v<_Ty>);
; 297  :     } else {
; 298  :         _Obj.~_Ty();
; 299  :     }
; 300  : }

	ret	0
??$_Destroy_in_place@PAPAVCPEDef@PS@@@std@@YAXAAPAPAVCPEDef@PS@@@Z ENDP ; std::_Destroy_in_place<PS::CPEDef * *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?destroy@?$xalloc@PAVCPEDef@PS@@@@QAEXPAPAVCPEDef@PS@@@Z
_TEXT	SEGMENT
_p$dead$ = 8						; size = 4
?destroy@?$xalloc@PAVCPEDef@PS@@@@QAEXPAPAVCPEDef@PS@@@Z PROC ; xalloc<PS::CPEDef *>::destroy, COMDAT
; _this$dead$ = ecx

; 85   : 							void					destroy			(pointer p)								{	std::_Destroy_in_place(p);			}

	ret	4
?destroy@?$xalloc@PAVCPEDef@PS@@@@QAEXPAPAVCPEDef@PS@@@Z ENDP ; xalloc<PS::CPEDef *>::destroy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$destroy@PAVCPEDef@PS@@@?$_Normal_allocator_traits@V?$xalloc@PAVCPEDef@PS@@@@@std@@SAXAAV?$xalloc@PAVCPEDef@PS@@@@PAPAVCPEDef@PS@@@Z
_TEXT	SEGMENT
??$destroy@PAVCPEDef@PS@@@?$_Normal_allocator_traits@V?$xalloc@PAVCPEDef@PS@@@@@std@@SAXAAV?$xalloc@PAVCPEDef@PS@@@@PAPAVCPEDef@PS@@@Z PROC ; std::_Normal_allocator_traits<xalloc<PS::CPEDef *> >::destroy<PS::CPEDef *>, COMDAT
; __Al$dead$ = ecx
; __Ptr$dead$ = edx

; 579  :         if constexpr (_Uses_default_destroy<_Alloc, _Ty*>::value) {
; 580  : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 581  :             _STD destroy_at(_Ptr);
; 582  : #else // __cpp_lib_constexpr_dynamic_alloc
; 583  :             _Ptr->~_Ty();
; 584  : #endif // __cpp_lib_constexpr_dynamic_alloc
; 585  :         } else {
; 586  :             _Al.destroy(_Ptr);
; 587  :         }
; 588  :     }

	ret	0
??$destroy@PAVCPEDef@PS@@@?$_Normal_allocator_traits@V?$xalloc@PAVCPEDef@PS@@@@@std@@SAXAAV?$xalloc@PAVCPEDef@PS@@@@PAPAVCPEDef@PS@@@Z ENDP ; std::_Normal_allocator_traits<xalloc<PS::CPEDef *> >::destroy<PS::CPEDef *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$xalloc@PAVCPGDef@PS@@@@V?$_Vector_val@U?$_Simple_types@PAVCPGDef@PS@@@std@@@std@@$00@std@@QAEAAV?$xalloc@PAVCPGDef@PS@@@@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@V?$xalloc@PAVCPGDef@PS@@@@V?$_Vector_val@U?$_Simple_types@PAVCPGDef@PS@@@std@@@std@@$00@std@@QAEAAV?$xalloc@PAVCPGDef@PS@@@@XZ PROC ; std::_Compressed_pair<xalloc<PS::CPGDef *>,std::_Vector_val<std::_Simple_types<PS::CPGDef *> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 1339 :         return *this;

	mov	eax, ecx

; 1340 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$xalloc@PAVCPGDef@PS@@@@V?$_Vector_val@U?$_Simple_types@PAVCPGDef@PS@@@std@@@std@@$00@std@@QAEAAV?$xalloc@PAVCPGDef@PS@@@@XZ ENDP ; std::_Compressed_pair<xalloc<PS::CPGDef *>,std::_Vector_val<std::_Simple_types<PS::CPGDef *> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Getal@?$vector@PAVCPGDef@PS@@V?$xalloc@PAVCPGDef@PS@@@@@std@@AAEAAV?$xalloc@PAVCPGDef@PS@@@@XZ
_TEXT	SEGMENT
?_Getal@?$vector@PAVCPGDef@PS@@V?$xalloc@PAVCPGDef@PS@@@@@std@@AAEAAV?$xalloc@PAVCPGDef@PS@@@@XZ PROC ; std::vector<PS::CPGDef *,xalloc<PS::CPGDef *> >::_Getal, COMDAT
; _this$ = ecx

; 1805 :         return _Mypair._Get_first();

	mov	eax, ecx

; 1806 :     }

	ret	0
?_Getal@?$vector@PAVCPGDef@PS@@V?$xalloc@PAVCPGDef@PS@@@@@std@@AAEAAV?$xalloc@PAVCPGDef@PS@@@@XZ ENDP ; std::vector<PS::CPGDef *,xalloc<PS::CPGDef *> >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef
;	COMDAT ??$_Unfancy@PAVCPGDef@PS@@@std@@YAPAPAVCPGDef@PS@@PAPAV12@@Z
_TEXT	SEGMENT
??$_Unfancy@PAVCPGDef@PS@@@std@@YAPAPAVCPGDef@PS@@PAPAV12@@Z PROC ; std::_Unfancy<PS::CPGDef *>, COMDAT
; __Ptr$ = ecx

; 266  :     return _Ptr;

	mov	eax, ecx

; 267  : }

	ret	0
??$_Unfancy@PAVCPGDef@PS@@@std@@YAPAPAVCPGDef@PS@@PAPAV12@@Z ENDP ; std::_Unfancy<PS::CPGDef *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Destroy_in_place@PAPAVCPGDef@PS@@@std@@YAXAAPAPAVCPGDef@PS@@@Z
_TEXT	SEGMENT
??$_Destroy_in_place@PAPAVCPGDef@PS@@@std@@YAXAAPAPAVCPGDef@PS@@@Z PROC ; std::_Destroy_in_place<PS::CPGDef * *>, COMDAT
; __Obj$dead$ = ecx

; 295  :     if constexpr (is_array_v<_Ty>) {
; 296  :         _Destroy_range(_Obj, _Obj + extent_v<_Ty>);
; 297  :     } else {
; 298  :         _Obj.~_Ty();
; 299  :     }
; 300  : }

	ret	0
??$_Destroy_in_place@PAPAVCPGDef@PS@@@std@@YAXAAPAPAVCPGDef@PS@@@Z ENDP ; std::_Destroy_in_place<PS::CPGDef * *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?destroy@?$xalloc@PAVCPGDef@PS@@@@QAEXPAPAVCPGDef@PS@@@Z
_TEXT	SEGMENT
_p$dead$ = 8						; size = 4
?destroy@?$xalloc@PAVCPGDef@PS@@@@QAEXPAPAVCPGDef@PS@@@Z PROC ; xalloc<PS::CPGDef *>::destroy, COMDAT
; _this$dead$ = ecx

; 85   : 							void					destroy			(pointer p)								{	std::_Destroy_in_place(p);			}

	ret	4
?destroy@?$xalloc@PAVCPGDef@PS@@@@QAEXPAPAVCPGDef@PS@@@Z ENDP ; xalloc<PS::CPGDef *>::destroy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$destroy@PAVCPGDef@PS@@@?$_Normal_allocator_traits@V?$xalloc@PAVCPGDef@PS@@@@@std@@SAXAAV?$xalloc@PAVCPGDef@PS@@@@PAPAVCPGDef@PS@@@Z
_TEXT	SEGMENT
??$destroy@PAVCPGDef@PS@@@?$_Normal_allocator_traits@V?$xalloc@PAVCPGDef@PS@@@@@std@@SAXAAV?$xalloc@PAVCPGDef@PS@@@@PAPAVCPGDef@PS@@@Z PROC ; std::_Normal_allocator_traits<xalloc<PS::CPGDef *> >::destroy<PS::CPGDef *>, COMDAT
; __Al$dead$ = ecx
; __Ptr$dead$ = edx

; 579  :         if constexpr (_Uses_default_destroy<_Alloc, _Ty*>::value) {
; 580  : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 581  :             _STD destroy_at(_Ptr);
; 582  : #else // __cpp_lib_constexpr_dynamic_alloc
; 583  :             _Ptr->~_Ty();
; 584  : #endif // __cpp_lib_constexpr_dynamic_alloc
; 585  :         } else {
; 586  :             _Al.destroy(_Ptr);
; 587  :         }
; 588  :     }

	ret	0
??$destroy@PAVCPGDef@PS@@@?$_Normal_allocator_traits@V?$xalloc@PAVCPGDef@PS@@@@@std@@SAXAAV?$xalloc@PAVCPGDef@PS@@@@PAPAVCPGDef@PS@@@Z ENDP ; std::_Normal_allocator_traits<xalloc<PS::CPGDef *> >::destroy<PS::CPGDef *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?end@?$vector@PAVCPGDef@PS@@V?$xalloc@PAVCPGDef@PS@@@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPGDef@PS@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@PAVCPGDef@PS@@V?$xalloc@PAVCPGDef@PS@@@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPGDef@PS@@@std@@@std@@@2@XZ PROC ; std::vector<PS::CPGDef *,xalloc<PS::CPGDef *> >::end, COMDAT
; _this$ = ecx

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	ecx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax], ecx

; 1472 :         auto& _My_data = _Mypair._Myval2;
; 1473 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));
; 1474 :     }

	ret	4
?end@?$vector@PAVCPGDef@PS@@V?$xalloc@PAVCPGDef@PS@@@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPGDef@PS@@@std@@@std@@@2@XZ ENDP ; std::vector<PS::CPGDef *,xalloc<PS::CPGDef *> >::end
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPGDef@PS@@@std@@@std@@@std@@QAE@PAPAVCPGDef@PS@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Pvector$dead$ = 12					; size = 4
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPGDef@PS@@@std@@@std@@@std@@QAE@PAPAVCPGDef@PS@@PBU_Container_base0@1@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<PS::CPGDef *> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<PS::CPGDef *> > >, COMDAT
; _this$ = ecx

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	eax, DWORD PTR __Parg$[esp-4]
	mov	DWORD PTR [ecx], eax

; 42   :         this->_Adopt(_Pvector);
; 43   :     }

	mov	eax, ecx
	ret	8
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPGDef@PS@@@std@@@std@@@std@@QAE@PAPAVCPGDef@PS@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<PS::CPGDef *> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<PS::CPGDef *> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPGDef@PS@@@std@@@std@@@std@@QAE@PAPAVCPGDef@PS@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
___param0$ = 8						; size = 4
___param1$dead$ = 12					; size = 4
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPGDef@PS@@@std@@@std@@@std@@QAE@PAPAVCPGDef@PS@@PBU_Container_base0@1@@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<PS::CPGDef *> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<PS::CPGDef *> > >, COMDAT
; _this$ = ecx

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	eax, DWORD PTR ___param0$[esp-4]
	mov	DWORD PTR [ecx], eax
	mov	eax, ecx
	ret	8
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPGDef@PS@@@std@@@std@@@std@@QAE@PAPAVCPGDef@PS@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<PS::CPGDef *> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<PS::CPGDef *> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef
;	COMDAT ??$addressof@V?$_Vector_val@U?$_Simple_types@PAVCPGDef@PS@@@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@PAVCPGDef@PS@@@std@@@0@AAV10@@Z
_TEXT	SEGMENT
??$addressof@V?$_Vector_val@U?$_Simple_types@PAVCPGDef@PS@@@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@PAVCPGDef@PS@@@std@@@0@AAV10@@Z PROC ; std::addressof<std::_Vector_val<std::_Simple_types<PS::CPGDef *> > >, COMDAT
; __Val$ = ecx

; 253  :     return __builtin_addressof(_Val);

	mov	eax, ecx

; 254  : }

	ret	0
??$addressof@V?$_Vector_val@U?$_Simple_types@PAVCPGDef@PS@@@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@PAVCPGDef@PS@@@std@@@0@AAV10@@Z ENDP ; std::addressof<std::_Vector_val<std::_Simple_types<PS::CPGDef *> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?begin@?$vector@PAVCPGDef@PS@@V?$xalloc@PAVCPGDef@PS@@@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPGDef@PS@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@PAVCPGDef@PS@@V?$xalloc@PAVCPGDef@PS@@@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPGDef@PS@@@std@@@std@@@2@XZ PROC ; std::vector<PS::CPGDef *,xalloc<PS::CPGDef *> >::begin, COMDAT
; _this$ = ecx

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	ecx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], ecx

; 1462 :         auto& _My_data = _Mypair._Myval2;
; 1463 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));
; 1464 :     }

	ret	4
?begin@?$vector@PAVCPGDef@PS@@V?$xalloc@PAVCPGDef@PS@@@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPGDef@PS@@@std@@@std@@@2@XZ ENDP ; std::vector<PS::CPGDef *,xalloc<PS::CPGDef *> >::begin
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?end@?$vector@PAVCPEDef@PS@@V?$xalloc@PAVCPEDef@PS@@@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPEDef@PS@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@PAVCPEDef@PS@@V?$xalloc@PAVCPEDef@PS@@@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPEDef@PS@@@std@@@std@@@2@XZ PROC ; std::vector<PS::CPEDef *,xalloc<PS::CPEDef *> >::end, COMDAT
; _this$ = ecx

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	ecx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax], ecx

; 1472 :         auto& _My_data = _Mypair._Myval2;
; 1473 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));
; 1474 :     }

	ret	4
?end@?$vector@PAVCPEDef@PS@@V?$xalloc@PAVCPEDef@PS@@@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPEDef@PS@@@std@@@std@@@2@XZ ENDP ; std::vector<PS::CPEDef *,xalloc<PS::CPEDef *> >::end
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPEDef@PS@@@std@@@std@@@std@@QAE@PAPAVCPEDef@PS@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Pvector$dead$ = 12					; size = 4
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPEDef@PS@@@std@@@std@@@std@@QAE@PAPAVCPEDef@PS@@PBU_Container_base0@1@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<PS::CPEDef *> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<PS::CPEDef *> > >, COMDAT
; _this$ = ecx

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	eax, DWORD PTR __Parg$[esp-4]
	mov	DWORD PTR [ecx], eax

; 42   :         this->_Adopt(_Pvector);
; 43   :     }

	mov	eax, ecx
	ret	8
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPEDef@PS@@@std@@@std@@@std@@QAE@PAPAVCPEDef@PS@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<PS::CPEDef *> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<PS::CPEDef *> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPEDef@PS@@@std@@@std@@@std@@QAE@PAPAVCPEDef@PS@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
___param0$ = 8						; size = 4
___param1$dead$ = 12					; size = 4
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPEDef@PS@@@std@@@std@@@std@@QAE@PAPAVCPEDef@PS@@PBU_Container_base0@1@@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<PS::CPEDef *> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<PS::CPEDef *> > >, COMDAT
; _this$ = ecx

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	eax, DWORD PTR ___param0$[esp-4]
	mov	DWORD PTR [ecx], eax
	mov	eax, ecx
	ret	8
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPEDef@PS@@@std@@@std@@@std@@QAE@PAPAVCPEDef@PS@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<PS::CPEDef *> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<PS::CPEDef *> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef
;	COMDAT ??$addressof@V?$_Vector_val@U?$_Simple_types@PAVCPEDef@PS@@@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@PAVCPEDef@PS@@@std@@@0@AAV10@@Z
_TEXT	SEGMENT
??$addressof@V?$_Vector_val@U?$_Simple_types@PAVCPEDef@PS@@@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@PAVCPEDef@PS@@@std@@@0@AAV10@@Z PROC ; std::addressof<std::_Vector_val<std::_Simple_types<PS::CPEDef *> > >, COMDAT
; __Val$ = ecx

; 253  :     return __builtin_addressof(_Val);

	mov	eax, ecx

; 254  : }

	ret	0
??$addressof@V?$_Vector_val@U?$_Simple_types@PAVCPEDef@PS@@@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@PAVCPEDef@PS@@@std@@@0@AAV10@@Z ENDP ; std::addressof<std::_Vector_val<std::_Simple_types<PS::CPEDef *> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?begin@?$vector@PAVCPEDef@PS@@V?$xalloc@PAVCPEDef@PS@@@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPEDef@PS@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@PAVCPEDef@PS@@V?$xalloc@PAVCPEDef@PS@@@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPEDef@PS@@@std@@@std@@@2@XZ PROC ; std::vector<PS::CPEDef *,xalloc<PS::CPEDef *> >::begin, COMDAT
; _this$ = ecx

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	ecx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], ecx

; 1462 :         auto& _My_data = _Mypair._Myval2;
; 1463 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));
; 1464 :     }

	ret	4
?begin@?$vector@PAVCPEDef@PS@@V?$xalloc@PAVCPEDef@PS@@@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPEDef@PS@@@std@@@std@@@2@XZ ENDP ; std::vector<PS::CPEDef *,xalloc<PS::CPEDef *> >::begin
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\xrstring.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_std_extensions.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xrstring.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_std_extensions.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xrstring.h
;	COMDAT ?xr_strcmp@@YAHABVshared_str@@PBD@Z
_TEXT	SEGMENT
?xr_strcmp@@YAHABVshared_str@@PBD@Z PROC		; xr_strcmp, COMDAT
; _a$ = ecx
; _b$ = edx

; 65   : 	str_c				operator*	() const						{	return p_?p_->value:0;							}

	mov	eax, DWORD PTR [ecx]
; File I:\Vitalya\mine\NSProjectX\xrCore\_std_extensions.h

; 183  : {	return (int)strcmp(S1,S2);  }

	lea	ecx, DWORD PTR [eax+12]
	neg	eax
	sbb	eax, eax
	and	eax, ecx
	npad	5
$LL9@xr_strcmp:
	mov	cl, BYTE PTR [eax]
	cmp	cl, BYTE PTR [edx]
	jne	SHORT $LN10@xr_strcmp
	test	cl, cl
	je	SHORT $LN11@xr_strcmp
	mov	cl, BYTE PTR [eax+1]
	cmp	cl, BYTE PTR [edx+1]
	jne	SHORT $LN10@xr_strcmp
	add	eax, 2
	add	edx, 2
	test	cl, cl
	jne	SHORT $LL9@xr_strcmp
$LN11@xr_strcmp:
; File I:\Vitalya\mine\NSProjectX\xrCore\xrstring.h

; 101  : IC int	xr_strcmp		(const shared_str & a, const char* b)				{ return xr_strcmp(*a,b);	}

	xor	eax, eax
	ret	0
$LN10@xr_strcmp:
; File I:\Vitalya\mine\NSProjectX\xrCore\_std_extensions.h

; 183  : {	return (int)strcmp(S1,S2);  }

	sbb	eax, eax
	or	eax, 1
; File I:\Vitalya\mine\NSProjectX\xrCore\xrstring.h

; 101  : IC int	xr_strcmp		(const shared_str & a, const char* b)				{ return xr_strcmp(*a,b);	}

	ret	0
?xr_strcmp@@YAHABVshared_str@@PBD@Z ENDP		; xr_strcmp
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleEffectDef.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xrstring.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleEffectDef.h
;	COMDAT ?Name@CPEDef@PS@@QBEPBDXZ
_TEXT	SEGMENT
?Name@CPEDef@PS@@QBEPBDXZ PROC				; PS::CPEDef::Name, COMDAT
; _this$ = ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\xrstring.h

; 65   : 	str_c				operator*	() const						{	return p_?p_->value:0;							}

	mov	eax, DWORD PTR [ecx]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleEffectDef.h

; 108  :         IC LPCSTR			Name				()const{return *m_Name;}

	lea	ecx, DWORD PTR [eax+12]
	neg	eax
	sbb	eax, eax
	and	eax, ecx
	ret	0
?Name@CPEDef@PS@@QBEPBDXZ ENDP				; PS::CPEDef::Name
_TEXT	ENDS
END
