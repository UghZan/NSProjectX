; Listing generated by Microsoft (R) Optimizing Compiler Version 19.29.30146.0 

	TITLE	i:\vitalya\mine\nsprojectx\nspx_build\intermediate\release-win32\xrrender_r1\lightppa.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	??_R2CLightR_Manager@@8				; CLightR_Manager::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CLightR_Manager@@8		; CLightR_Manager::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R3CLightR_Manager@@8				; CLightR_Manager::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R0?AVCLightR_Manager@@@8			; CLightR_Manager `RTTI Type Descriptor'
PUBLIC	??_R4CLightR_Manager@@6B@			; CLightR_Manager::`RTTI Complete Object Locator'
PUBLIC	??_7CLightR_Manager@@6B@			; CLightR_Manager::`vftable'
;	COMDAT ??_7CLightR_Manager@@6B@
CONST	SEGMENT
??_7CLightR_Manager@@6B@ DD FLAT:??_R4CLightR_Manager@@6B@ ; CLightR_Manager::`vftable'
	DD	FLAT:??_ECLightR_Manager@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_R4CLightR_Manager@@6B@
rdata$r	SEGMENT
??_R4CLightR_Manager@@6B@ DD 00H			; CLightR_Manager::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCLightR_Manager@@@8
	DD	FLAT:??_R3CLightR_Manager@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCLightR_Manager@@@8
data$rs	SEGMENT
??_R0?AVCLightR_Manager@@@8 DD FLAT:??_7type_info@@6B@	; CLightR_Manager `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCLightR_Manager@@', 00H
data$rs	ENDS
;	COMDAT ??_R3CLightR_Manager@@8
rdata$r	SEGMENT
??_R3CLightR_Manager@@8 DD 00H				; CLightR_Manager::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2CLightR_Manager@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@CLightR_Manager@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CLightR_Manager@@8 DD FLAT:??_R0?AVCLightR_Manager@@@8 ; CLightR_Manager::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CLightR_Manager@@8
rdata$r	ENDS
;	COMDAT ??_R2CLightR_Manager@@8
rdata$r	SEGMENT
??_R2CLightR_Manager@@8 DD FLAT:??_R1A@?0A@EA@CLightR_Manager@@8 ; CLightR_Manager::`RTTI Base Class Array'
?_Fake_alloc@std@@3U_Fake_allocator@1@B	ORG $+1		; std::_Fake_alloc
PUBLIC	??$construct@PAVlight@@PAV1@@?$_Normal_allocator_traits@V?$xalloc@PAVlight@@@@@std@@SAXAAV?$xalloc@PAVlight@@@@PAPAVlight@@$$QAPAV3@@Z ; std::_Normal_allocator_traits<xalloc<light *> >::construct<light *,light *>
PUBLIC	??$forward@PAVlight@@@std@@YA$$QAPAVlight@@AAPAV1@@Z ; std::forward<light *>
PUBLIC	??$_Emplace_back@PAVlight@@@?$_Uninitialized_backout_al@V?$xalloc@PAVlight@@@@@std@@QAEX$$QAPAVlight@@@Z ; std::_Uninitialized_backout_al<xalloc<light *> >::_Emplace_back<light *>
PUBLIC	??$move@AAPAVlight@@@std@@YA$$QAPAVlight@@AAPAV1@@Z ; std::move<light * &>
PUBLIC	??0?$_Uninitialized_backout_al@V?$xalloc@PAVlight@@@@@std@@QAE@PAPAVlight@@AAV?$xalloc@PAVlight@@@@@Z ; std::_Uninitialized_backout_al<xalloc<light *> >::_Uninitialized_backout_al<xalloc<light *> >
PUBLIC	??1?$_Uninitialized_backout_al@V?$xalloc@PAVlight@@@@@std@@QAE@XZ ; std::_Uninitialized_backout_al<xalloc<light *> >::~_Uninitialized_backout_al<xalloc<light *> >
PUBLIC	?_Release@?$_Uninitialized_backout_al@V?$xalloc@PAVlight@@@@@std@@QAEPAPAVlight@@XZ ; std::_Uninitialized_backout_al<xalloc<light *> >::_Release
PUBLIC	??$xr_alloc@PAVlight@@@@YAPAPAVlight@@I@Z	; xr_alloc<light *>
PUBLIC	??$_Get_unwrapped@ABQAPAVlight@@@std@@YA?A_TABQAPAVlight@@@Z ; std::_Get_unwrapped<light * * const &>
PUBLIC	??$_Uninitialized_move@PAPAVlight@@V?$xalloc@PAVlight@@@@@std@@YAPAPAVlight@@QAPAV1@0PAPAV1@AAV?$xalloc@PAVlight@@@@@Z ; std::_Uninitialized_move<light * *,xalloc<light *> >
PUBLIC	?max_size@?$xalloc@PAVlight@@@@QBEIXZ		; xalloc<light *>::max_size
PUBLIC	?_Get_first@?$_Compressed_pair@V?$xalloc@PAVlight@@@@V?$_Vector_val@U?$_Simple_types@PAVlight@@@std@@@std@@$00@std@@QBEABV?$xalloc@PAVlight@@@@XZ ; std::_Compressed_pair<xalloc<light *>,std::_Vector_val<std::_Simple_types<light *> >,1>::_Get_first
PUBLIC	?max_size@?$_Normal_allocator_traits@V?$xalloc@PAVlight@@@@@std@@SAIABV?$xalloc@PAVlight@@@@@Z ; std::_Normal_allocator_traits<xalloc<light *> >::max_size
PUBLIC	?capacity@?$vector@PAVlight@@V?$xalloc@PAVlight@@@@@std@@QBEIXZ ; std::vector<light *,xalloc<light *> >::capacity
PUBLIC	?_Umove_if_noexcept1@?$vector@PAVlight@@V?$xalloc@PAVlight@@@@@std@@AAEXPAPAVlight@@00U?$integral_constant@_N$00@2@@Z ; std::vector<light *,xalloc<light *> >::_Umove_if_noexcept1
PUBLIC	?_Getal@?$vector@PAVlight@@V?$xalloc@PAVlight@@@@@std@@ABEABV?$xalloc@PAVlight@@@@XZ ; std::vector<light *,xalloc<light *> >::_Getal
PUBLIC	?allocate@?$xalloc@PAVlight@@@@QBEPAPAVlight@@IPBX@Z ; xalloc<light *>::allocate
PUBLIC	?construct@?$xalloc@PAVlight@@@@QAEXPAPAVlight@@ABQAV2@@Z ; xalloc<light *>::construct
PUBLIC	?max_size@?$vector@PAVlight@@V?$xalloc@PAVlight@@@@@std@@QBEIXZ ; std::vector<light *,xalloc<light *> >::max_size
PUBLIC	?_Umove@?$vector@PAVlight@@V?$xalloc@PAVlight@@@@@std@@AAEPAPAVlight@@PAPAV3@00@Z ; std::vector<light *,xalloc<light *> >::_Umove
PUBLIC	?_Umove_if_noexcept@?$vector@PAVlight@@V?$xalloc@PAVlight@@@@@std@@AAEXPAPAVlight@@00@Z ; std::vector<light *,xalloc<light *> >::_Umove_if_noexcept
PUBLIC	?_Calculate_growth@?$vector@PAVlight@@V?$xalloc@PAVlight@@@@@std@@ABEII@Z ; std::vector<light *,xalloc<light *> >::_Calculate_growth
PUBLIC	?_Change_array@?$vector@PAVlight@@V?$xalloc@PAVlight@@@@@std@@AAEXQAPAVlight@@II@Z ; std::vector<light *,xalloc<light *> >::_Change_array
PUBLIC	?_Xlength@?$vector@PAVlight@@V?$xalloc@PAVlight@@@@@std@@CAXXZ ; std::vector<light *,xalloc<light *> >::_Xlength
PUBLIC	??$_Emplace_reallocate@ABQAVlight@@@?$vector@PAVlight@@V?$xalloc@PAVlight@@@@@std@@QAEPAPAVlight@@QAPAV2@ABQAV2@@Z ; std::vector<light *,xalloc<light *> >::_Emplace_reallocate<light * const &>
PUBLIC	??$construct@PAVlight@@ABQAV1@@?$_Normal_allocator_traits@V?$xalloc@PAVlight@@@@@std@@SAXAAV?$xalloc@PAVlight@@@@PAPAVlight@@ABQAV3@@Z ; std::_Normal_allocator_traits<xalloc<light *> >::construct<light *,light * const &>
PUBLIC	??$forward@ABQAVlight@@@std@@YAABQAVlight@@ABQAV1@@Z ; std::forward<light * const &>
PUBLIC	??$addressof@V?$_Vector_val@U?$_Simple_types@PAVlight@@@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@PAVlight@@@std@@@0@AAV10@@Z ; std::addressof<std::_Vector_val<std::_Simple_types<light *> > >
PUBLIC	?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVlight@@@std@@@std@@@std@@QBEXABV12@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<light *> > >::_Compat
PUBLIC	?size@?$vector@PAVlight@@V?$xalloc@PAVlight@@@@@std@@QBEIXZ ; std::vector<light *,xalloc<light *> >::size
PUBLIC	?_Orphan_range@?$vector@PAVlight@@V?$xalloc@PAVlight@@@@@std@@ABEXPAPAVlight@@0@Z ; std::vector<light *,xalloc<light *> >::_Orphan_range
PUBLIC	??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVlight@@@std@@@std@@@std@@QAE@PAPAVlight@@PBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<light *> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<light *> > >
PUBLIC	??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVlight@@@std@@@std@@@std@@QBEABQAVlight@@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<light *> > >::operator*
PUBLIC	??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVlight@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<light *> > >::operator++
PUBLIC	??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVlight@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<light *> > >::operator==
PUBLIC	??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVlight@@@std@@@std@@@std@@QAE@PAPAVlight@@PBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<light *> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<light *> > >
PUBLIC	??$_Emplace_back_with_unused_capacity@ABQAVlight@@@?$vector@PAVlight@@V?$xalloc@PAVlight@@@@@std@@AAE?A_TABQAVlight@@@Z ; std::vector<light *,xalloc<light *> >::_Emplace_back_with_unused_capacity<light * const &>
PUBLIC	??$emplace_back@ABQAVlight@@@?$vector@PAVlight@@V?$xalloc@PAVlight@@@@@std@@QAE?A_TABQAVlight@@@Z ; std::vector<light *,xalloc<light *> >::emplace_back<light * const &>
PUBLIC	?push_back@?$vector@PAVlight@@V?$xalloc@PAVlight@@@@@std@@QAEXABQAVlight@@@Z ; std::vector<light *,xalloc<light *> >::push_back
PUBLIC	?begin@?$vector@PAVlight@@V?$xalloc@PAVlight@@@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVlight@@@std@@@std@@@2@XZ ; std::vector<light *,xalloc<light *> >::begin
PUBLIC	?end@?$vector@PAVlight@@V?$xalloc@PAVlight@@@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVlight@@@std@@@std@@@2@XZ ; std::vector<light *,xalloc<light *> >::end
PUBLIC	?size@?$xr_vector@PAVlight@@V?$xalloc@PAVlight@@@@@@QBEIXZ ; xr_vector<light *,xalloc<light *> >::size
PUBLIC	??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVlight@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<light *> > >::operator!=
PUBLIC	??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVlight@@@std@@@std@@@std@@QBEAAPAVlight@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<light *> > >::operator*
PUBLIC	??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVlight@@@std@@@std@@@std@@QAE?AV01@H@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<light *> > >::operator++
PUBLIC	??1CLightR_Manager@@UAE@XZ			; CLightR_Manager::~CLightR_Manager
PUBLIC	??_GCLightR_Manager@@UAEPAXI@Z			; CLightR_Manager::`scalar deleting destructor'
PUBLIC	?render_spot@CLightR_Manager@@QAEXXZ		; CLightR_Manager::render_spot
PUBLIC	?render_point@CLightR_Manager@@QAEXXZ		; CLightR_Manager::render_point
PUBLIC	?render@CLightR_Manager@@QAEXXZ			; CLightR_Manager::render
PUBLIC	??0CLightR_Manager@@QAE@XZ			; CLightR_Manager::CLightR_Manager
PUBLIC	?setup@cl_light_PR@@EAEXPAUR_constant@@@Z	; cl_light_PR::setup
PUBLIC	?setup@cl_light_C@@EAEXPAUR_constant@@@Z	; cl_light_C::setup
PUBLIC	?setup@cl_light_XFORM@@EAEXPAUR_constant@@@Z	; cl_light_XFORM::setup
PUBLIC	?add@CLightR_Manager@@QAEXPAVlight@@@Z		; CLightR_Manager::add
EXTRN	??_ECLightR_Manager@@UAEPAXI@Z:PROC		; CLightR_Manager::`vector deleting destructor'
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$_Emplace_reallocate@ABQAVlight@@@?$vector@PAVlight@@V?$xalloc@PAVlight@@@@@std@@QAEPAPAVlight@@QAPAV2@ABQAV2@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Emplace_reallocate@ABQAVlight@@@?$vector@PAVlight@@V?$xalloc@PAVlight@@@@@std@@QAEPAPAVlight@@QAPAV2@ABQAV2@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Emplace_reallocate@ABQAVlight@@@?$vector@PAVlight@@V?$xalloc@PAVlight@@@@@std@@QAEPAPAVlight@@QAPAV2@ABQAV2@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
__unwindtable$??$_Emplace_reallocate@ABQAVlight@@@?$vector@PAVlight@@V?$xalloc@PAVlight@@@@@std@@QAEPAPAVlight@@QAPAV2@ABQAV2@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Emplace_reallocate@ABQAVlight@@@?$vector@PAVlight@@V?$xalloc@PAVlight@@@@@std@@QAEPAPAVlight@@QAPAV2@ABQAV2@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Emplace_reallocate@ABQAVlight@@@?$vector@PAVlight@@V?$xalloc@PAVlight@@@@@std@@QAEPAPAVlight@@QAPAV2@ABQAV2@@Z$2
__catchsym$??$_Emplace_reallocate@ABQAVlight@@@?$vector@PAVlight@@V?$xalloc@PAVlight@@@@@std@@QAEPAPAVlight@@QAPAV2@ABQAV2@@Z$2 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Emplace_reallocate@ABQAVlight@@@?$vector@PAVlight@@V?$xalloc@PAVlight@@@@@std@@QAEPAPAVlight@@QAPAV2@ABQAV2@@Z$0
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightPPA.cpp
_TEXT	SEGMENT
_L$ = 8							; size = 4
?add@CLightR_Manager@@QAEXPAVlight@@@Z PROC		; CLightR_Manager::add
; _this$ = ecx

; 308  : 	if (L->range<0.1f)				return;

	mov	edx, DWORD PTR _L$[esp-4]
	movss	xmm0, DWORD PTR __real@3dcccccd
	comiss	xmm0, DWORD PTR [edx+100]
	ja	SHORT $LN3@add

; 309  : 	if (0==L->spatial.sector)		return;

	cmp	DWORD PTR [edx+52], 0
	je	SHORT $LN3@add

; 310  : 	if (IRender_Light::POINT==L->flags.type)

	mov	eax, DWORD PTR [edx+60]
	and	eax, 15					; 0000000fH
	cmp	al, 1
	jne	SHORT $LN7@add

; 311  : 	{
; 312  : 		// PPA
; 313  : 		selected_point.push_back	(L);

	add	ecx, 28					; 0000001cH

; 314  : 	} else {

	jmp	SHORT $LN26@add
$LN7@add:

; 315  : 		// spot/flash
; 316  : 		selected_spot.push_back		(L);

	add	ecx, 40					; 00000028H
$LN26@add:

; 317  : 	}
; 318  : 	VERIFY							(L->spatial.sector);
; 319  : }

	mov	eax, DWORD PTR [ecx+4]
	cmp	eax, DWORD PTR [ecx+8]
	je	SHORT $LN20@add
	mov	DWORD PTR [eax], edx
	add	DWORD PTR [ecx+4], 4
	ret	4
$LN20@add:
	lea	edx, DWORD PTR _L$[esp-4]
	push	edx
	push	eax
	call	??$_Emplace_reallocate@ABQAVlight@@@?$vector@PAVlight@@V?$xalloc@PAVlight@@@@@std@@QAEPAPAVlight@@QAPAV2@ABQAV2@@Z ; std::vector<light *,xalloc<light *> >::_Emplace_reallocate<light * const &>
$LN3@add:
	ret	4
?add@CLightR_Manager@@QAEXPAVlight@@@Z ENDP		; CLightR_Manager::add
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightPPA.cpp
; File I:\Vitalya\mine\NSProjectX\xrEngine\R_Backend.h
; File I:\Vitalya\mine\NSProjectX\xrEngine\r_constants_cache.h
; File I:\Vitalya\mine\NSProjectX\xrEngine\R_Backend.h
; File I:\Vitalya\mine\NSProjectX\xrEngine\r_constants_cache.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightPPA.cpp
_TEXT	SEGMENT
_C$ = 8							; size = 4
?setup@cl_light_XFORM@@EAEXPAUR_constant@@@Z PROC	; cl_light_XFORM::setup
; _this$ = ecx

; 31   : void cl_light_XFORM::setup	(R_constant* C)					{

	push	esi
; File I:\Vitalya\mine\NSProjectX\xrEngine\R_Backend.h

; 189  : 	ICF	void						set_c(R_constant* C, const Fmatrix& A) { if (C)		constants.set(C, A); }

	mov	esi, DWORD PTR _C$[esp]
	test	esi, esi
	je	SHORT $LN8@setup
; File I:\Vitalya\mine\NSProjectX\xrEngine\r_constants_cache.h

; 143  : 		if (C->destination & 1) { a_pixel.set(C, C->ps, A); a_pixel.b_dirty = TRUE; }

	movzx	eax, WORD PTR [esi+10]
	mov	ecx, eax
; File I:\Vitalya\mine\NSProjectX\xrEngine\R_Backend.h

; 189  : 	ICF	void						set_c(R_constant* C, const Fmatrix& A) { if (C)		constants.set(C, A); }

	push	edi
	mov	edi, DWORD PTR __imp_?RCache@@3VCBackend@@A
; File I:\Vitalya\mine\NSProjectX\xrEngine\r_constants_cache.h

; 143  : 		if (C->destination & 1) { a_pixel.set(C, C->ps, A); a_pixel.b_dirty = TRUE; }

	test	al, 1
	je	SHORT $LN7@setup
	push	OFFSET ?RImplementation@@3VCRender@@A+1016
	lea	eax, DWORD PTR [esi+12]
	push	eax
	push	esi
	lea	ecx, DWORD PTR [edi+608]
	call	?set@R_constant_array@@QAEXPAUR_constant@@AAUR_constant_load@@ABU?$_matrix@M@@@Z ; R_constant_array::set
	mov	DWORD PTR [edi+4720], 1
	movzx	ecx, WORD PTR [esi+10]
$LN7@setup:

; 144  : 		if (C->destination & 2) { a_vertex.set(C, C->vs, A); a_vertex.b_dirty = TRUE; }

	test	cl, 2
	je	SHORT $LN106@setup
	push	OFFSET ?RImplementation@@3VCRender@@A+1016
	lea	eax, DWORD PTR [esi+16]
	push	eax
	push	esi
	lea	ecx, DWORD PTR [edi+4736]
	call	?set@R_constant_array@@QAEXPAUR_constant@@AAUR_constant_load@@ABU?$_matrix@M@@@Z ; R_constant_array::set
	mov	DWORD PTR [edi+8848], 1
$LN106@setup:
	pop	edi
$LN8@setup:
	pop	esi
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightPPA.cpp

; 33   : }

	ret	4
?setup@cl_light_XFORM@@EAEXPAUR_constant@@@Z ENDP	; cl_light_XFORM::setup
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightPPA.cpp
; File I:\Vitalya\mine\NSProjectX\xrEngine\R_Backend.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_color.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightPPA.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_color.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightPPA.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_color.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightPPA.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_color.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightPPA.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_color.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightPPA.cpp
; File I:\Vitalya\mine\NSProjectX\xrEngine\R_Backend.h
; File I:\Vitalya\mine\NSProjectX\xrEngine\r_constants_cache.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector4.h
; File I:\Vitalya\mine\NSProjectX\xrEngine\r_constants_cache.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector4.h
; File I:\Vitalya\mine\NSProjectX\xrEngine\R_Backend.h
; File I:\Vitalya\mine\NSProjectX\xrEngine\r_constants_cache.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightPPA.cpp
_TEXT	SEGMENT
_data$1 = -16						; size = 16
__C$ = -16						; size = 16
_C$ = 8							; size = 4
?setup@cl_light_C@@EAEXPAUR_constant@@@Z PROC		; cl_light_C::setup
; _this$ = ecx

; 26   : void cl_light_C::setup		(R_constant* C)					{

	sub	esp, 16					; 00000010H

; 27   : 	Fcolor		_C	= RImplementation.r1_dlight_light->color;

	mov	ecx, DWORD PTR ?RImplementation@@3VCRender@@A+1080

; 28   : 				_C.mul_rgb	(RImplementation.r1_dlight_scale);

	movss	xmm0, DWORD PTR ?RImplementation@@3VCRender@@A+1084
	push	esi
; File I:\Vitalya\mine\NSProjectX\xrEngine\R_Backend.h

; 191  : 	ICF	void						set_c(R_constant* C, float x, float y, float z, float w) { if (C)		constants.set(C, x, y, z, w); }

	mov	esi, DWORD PTR _C$[esp+16]
; File I:\Vitalya\mine\NSProjectX\xrCore\_color.h

; 173  : 		r*=s;

	movaps	xmm1, xmm0
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightPPA.cpp

; 27   : 	Fcolor		_C	= RImplementation.r1_dlight_light->color;

	mov	eax, DWORD PTR [ecx+108]
; File I:\Vitalya\mine\NSProjectX\xrCore\_color.h

; 174  : 		g*=s;

	movaps	xmm2, xmm0
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightPPA.cpp

; 27   : 	Fcolor		_C	= RImplementation.r1_dlight_light->color;

	mov	DWORD PTR __C$[esp+20], eax
	mov	eax, DWORD PTR [ecx+112]
; File I:\Vitalya\mine\NSProjectX\xrCore\_color.h

; 173  : 		r*=s;

	mulss	xmm1, DWORD PTR __C$[esp+20]
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightPPA.cpp

; 27   : 	Fcolor		_C	= RImplementation.r1_dlight_light->color;

	mov	DWORD PTR __C$[esp+24], eax
	mov	eax, DWORD PTR [ecx+116]
; File I:\Vitalya\mine\NSProjectX\xrCore\_color.h

; 174  : 		g*=s;

	mulss	xmm2, DWORD PTR __C$[esp+24]
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightPPA.cpp

; 27   : 	Fcolor		_C	= RImplementation.r1_dlight_light->color;

	mov	DWORD PTR __C$[esp+28], eax
	mov	eax, DWORD PTR [ecx+120]
; File I:\Vitalya\mine\NSProjectX\xrCore\_color.h

; 175  : 		b*=s;

	mulss	xmm0, DWORD PTR __C$[esp+28]
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightPPA.cpp

; 27   : 	Fcolor		_C	= RImplementation.r1_dlight_light->color;

	mov	DWORD PTR __C$[esp+32], eax
; File I:\Vitalya\mine\NSProjectX\xrEngine\R_Backend.h

; 191  : 	ICF	void						set_c(R_constant* C, float x, float y, float z, float w) { if (C)		constants.set(C, x, y, z, w); }

	test	esi, esi
	je	SHORT $LN14@setup
; File I:\Vitalya\mine\NSProjectX\xrEngine\r_constants_cache.h

; 147  : 		if (C->destination & 1) { a_pixel.set(C, C->ps, A); a_pixel.b_dirty = TRUE; }

	movzx	eax, WORD PTR [esi+10]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector4.h

; 17   : 	IC	SelfRef 	set(T _x, T _y, T _z, T _w=1)		{ x=_x;		y=_y;		z=_z;		w=_w;		return *this; }

	movss	DWORD PTR _data$1[esp+20], xmm1
; File I:\Vitalya\mine\NSProjectX\xrEngine\r_constants_cache.h

; 147  : 		if (C->destination & 1) { a_pixel.set(C, C->ps, A); a_pixel.b_dirty = TRUE; }

	mov	ecx, eax
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector4.h

; 17   : 	IC	SelfRef 	set(T _x, T _y, T _z, T _w=1)		{ x=_x;		y=_y;		z=_z;		w=_w;		return *this; }

	movss	DWORD PTR _data$1[esp+24], xmm2
	movss	DWORD PTR _data$1[esp+28], xmm0
	mov	DWORD PTR _data$1[esp+32], 1065353216	; 3f800000H
; File I:\Vitalya\mine\NSProjectX\xrEngine\R_Backend.h

; 191  : 	ICF	void						set_c(R_constant* C, float x, float y, float z, float w) { if (C)		constants.set(C, x, y, z, w); }

	push	edi
	mov	edi, DWORD PTR __imp_?RCache@@3VCBackend@@A
; File I:\Vitalya\mine\NSProjectX\xrEngine\r_constants_cache.h

; 147  : 		if (C->destination & 1) { a_pixel.set(C, C->ps, A); a_pixel.b_dirty = TRUE; }

	test	al, 1
	je	SHORT $LN13@setup
	lea	eax, DWORD PTR _data$1[esp+24]
	push	eax
	lea	eax, DWORD PTR [esi+12]
	push	eax
	push	esi
	lea	ecx, DWORD PTR [edi+608]
	call	?set@R_constant_array@@QAEXPAUR_constant@@AAUR_constant_load@@ABU?$_vector4@M@@@Z ; R_constant_array::set
	mov	DWORD PTR [edi+4720], 1
	movzx	ecx, WORD PTR [esi+10]
$LN13@setup:

; 148  : 		if (C->destination & 2) { a_vertex.set(C, C->vs, A); a_vertex.b_dirty = TRUE; }

	test	cl, 2
	je	SHORT $LN58@setup
	lea	eax, DWORD PTR _data$1[esp+24]
	push	eax
	lea	eax, DWORD PTR [esi+16]
	push	eax
	push	esi
	lea	ecx, DWORD PTR [edi+4736]
	call	?set@R_constant_array@@QAEXPAUR_constant@@AAUR_constant_load@@ABU?$_vector4@M@@@Z ; R_constant_array::set
	mov	DWORD PTR [edi+8848], 1
$LN58@setup:
	pop	edi
$LN14@setup:
	pop	esi
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightPPA.cpp

; 30   : }

	add	esp, 16					; 00000010H
	ret	4
?setup@cl_light_C@@EAEXPAUR_constant@@@Z ENDP		; cl_light_C::setup
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightPPA.cpp
; File I:\Vitalya\mine\NSProjectX\xrEngine\R_Backend.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightPPA.cpp
; File I:\Vitalya\mine\NSProjectX\xrEngine\r_constants_cache.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightPPA.cpp
_TEXT	SEGMENT
_data$1 = -16						; size = 16
_data$2 = -16						; size = 16
_C$ = 8							; size = 4
?setup@cl_light_PR@@EAEXPAUR_constant@@@Z PROC		; cl_light_PR::setup
; _this$ = ecx

; 21   : 	Fvector&	P	= RImplementation.r1_dlight_light->position;

	mov	ecx, DWORD PTR ?RImplementation@@3VCRender@@A+1080
	sub	esp, 16					; 00000010H

; 22   : 	float		R	= RImplementation.r1_dlight_light->range;

	movss	xmm1, DWORD PTR [ecx+100]
	push	esi
; File I:\Vitalya\mine\NSProjectX\xrEngine\R_Backend.h

; 191  : 	ICF	void						set_c(R_constant* C, float x, float y, float z, float w) { if (C)		constants.set(C, x, y, z, w); }

	mov	esi, DWORD PTR _C$[esp+16]
	test	esi, esi
	je	$LN67@setup
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightPPA.cpp

; 23   : 	if (RImplementation.phase==CRender::PHASE_POINT)		RCache.set_c	(C,P.x,P.y,P.z,.5f/R);

	cmp	DWORD PTR ?RImplementation@@3VCRender@@A+292, 1
	movss	xmm0, DWORD PTR [ecx+64]
	movzx	eax, WORD PTR [esi+10]
	movss	DWORD PTR _data$2[esp+20], xmm0
	movss	xmm0, DWORD PTR [ecx+68]
	movss	DWORD PTR _data$2[esp+24], xmm0
	movss	xmm0, DWORD PTR [ecx+72]
	mov	ecx, eax
	push	edi
	mov	edi, DWORD PTR __imp_?RCache@@3VCBackend@@A
	movss	DWORD PTR _data$2[esp+32], xmm0
	jne	SHORT $LN2@setup
	movss	xmm0, DWORD PTR __real@3f000000
	jmp	SHORT $LN115@setup
$LN2@setup:

; 24   : 	else													RCache.set_c	(C,P.x,P.y,P.z,1.f/R);

	movss	xmm0, DWORD PTR __real@3f800000
$LN115@setup:
; File I:\Vitalya\mine\NSProjectX\xrEngine\r_constants_cache.h

; 148  : 		if (C->destination & 2) { a_vertex.set(C, C->vs, A); a_vertex.b_dirty = TRUE; }

	divss	xmm0, xmm1
	movss	DWORD PTR _data$1[esp+36], xmm0
	test	al, 1
	je	SHORT $LN66@setup
	lea	eax, DWORD PTR _data$1[esp+24]
	push	eax
	lea	eax, DWORD PTR [esi+12]
	push	eax
	push	esi
	lea	ecx, DWORD PTR [edi+608]
	call	?set@R_constant_array@@QAEXPAUR_constant@@AAUR_constant_load@@ABU?$_vector4@M@@@Z ; R_constant_array::set
	mov	DWORD PTR [edi+4720], 1
	movzx	ecx, WORD PTR [esi+10]
$LN66@setup:
	test	cl, 2
	je	SHORT $LN111@setup
	lea	eax, DWORD PTR _data$1[esp+24]
	push	eax
	lea	eax, DWORD PTR [esi+16]
	push	eax
	push	esi
	lea	ecx, DWORD PTR [edi+4736]
	call	?set@R_constant_array@@QAEXPAUR_constant@@AAUR_constant_load@@ABU?$_vector4@M@@@Z ; R_constant_array::set
	mov	DWORD PTR [edi+8848], 1
$LN111@setup:
	pop	edi
$LN67@setup:
	pop	esi
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightPPA.cpp

; 25   : }

	add	esp, 16					; 00000010H
	ret	4
?setup@cl_light_PR@@EAEXPAUR_constant@@@Z ENDP		; cl_light_PR::setup
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightPPA.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightPPA.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightPPA.cpp
_TEXT	SEGMENT
??0CLightR_Manager@@QAE@XZ PROC				; CLightR_Manager::CLightR_Manager
; _this$ = ecx

; 322  : {

	push	esi
	mov	esi, ecx
	lea	ecx, DWORD PTR [esi+4]
	mov	DWORD PTR [esi], OFFSET ??_7CLightR_Manager@@6B@
	call	DWORD PTR __imp_??0xrXRC@@QAE@XZ
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [esi+28], 0
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightPPA.cpp

; 323  : }

	mov	eax, esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [esi+32], 0
	mov	DWORD PTR [esi+36], 0
	mov	DWORD PTR [esi+40], 0
	mov	DWORD PTR [esi+44], 0
	mov	DWORD PTR [esi+48], 0
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightPPA.cpp

; 323  : }

	pop	esi
	ret	0
??0CLightR_Manager@@QAE@XZ ENDP				; CLightR_Manager::CLightR_Manager
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightPPA.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightPPA.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightPPA.cpp
_TEXT	SEGMENT
?render@CLightR_Manager@@QAEXXZ PROC			; CLightR_Manager::render
; _this$ = ecx

; 293  : {

	push	esi
	mov	esi, ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	eax, DWORD PTR [esi+44]
	sub	eax, DWORD PTR [esi+40]
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightPPA.cpp

; 294  : 	if (selected_spot.size())		{ 

	test	eax, -4					; fffffffcH
	je	SHORT $LN2@render

; 295  : 		RImplementation.phase		= CRender::PHASE_SPOT;

	mov	DWORD PTR ?RImplementation@@3VCRender@@A+292, 2

; 296  : 		render_spot			();	

	call	?render_spot@CLightR_Manager@@QAEXXZ	; CLightR_Manager::render_spot

; 297  : 		selected_spot.clear	();	

	mov	eax, DWORD PTR [esi+40]
	mov	DWORD PTR [esi+44], eax
$LN2@render:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	eax, DWORD PTR [esi+32]
	sub	eax, DWORD PTR [esi+28]
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightPPA.cpp

; 299  : 	if (selected_point.size())		{ 

	test	eax, -4					; fffffffcH
	je	SHORT $LN3@render

; 300  : 		RImplementation.phase		= CRender::PHASE_POINT;
; 301  : 		render_point		();	

	mov	ecx, esi
	mov	DWORD PTR ?RImplementation@@3VCRender@@A+292, 1
	call	?render_point@CLightR_Manager@@QAEXXZ	; CLightR_Manager::render_point

; 302  : 		selected_point.clear(); 

	mov	eax, DWORD PTR [esi+28]
	mov	DWORD PTR [esi+32], eax
$LN3@render:

; 303  : 	}
; 304  : }

	pop	esi
	ret	0
?render@CLightR_Manager@@QAEXXZ ENDP			; CLightR_Manager::render
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightPPA.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightPPA.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightPPA.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightPPA.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightPPA.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightPPA.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightPPA.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightPPA.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightPPA.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightPPA.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightPPA.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightPPA.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\vector.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\vector.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightPPA.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_render.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightPPA.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_render.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightPPA.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_render.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightPPA.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_structure.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightPPA.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_render.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightPPA.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightPPA.cpp
_TEXT	SEGMENT
tv3949 = -720						; size = 4
tv3947 = -720						; size = 4
tv3942 = -716						; size = 4
tv3902 = -716						; size = 4
tv3944 = -712						; size = 4
tv3948 = -708						; size = 4
tv3901 = -708						; size = 4
tv3934 = -704						; size = 4
tv3938 = -700						; size = 4
tv3941 = -696						; size = 4
tv3932 = -692						; size = 4
tv3908 = -692						; size = 4
tv3937 = -688						; size = 4
tv3914 = -688						; size = 4
tv3935 = -684						; size = 4
tv3940 = -680						; size = 4
tv4018 = -676						; size = 4
tv3931 = -672						; size = 4
tv3936 = -668						; size = 4
tv3920 = -664						; size = 4
tv3943 = -660						; size = 4
tv3946 = -656						; size = 4
_lc_scale$1$ = -652					; size = 4
_lc_COP$ = -648						; size = 12
_L_pos$1 = -636						; size = 12
_L_project$2 = -624					; size = 64
_L_combine$3 = -560					; size = 64
_temp$4 = -496						; size = 244
_F$5 = -248						; size = 244
?render_point@CLightR_Manager@@QAEXXZ PROC		; CLightR_Manager::render_point
; _this$ = ecx

; 145  : {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	sub	esp, 724				; 000002d4H

; 147  : 	Fvector		lc_COP		= Device.vCameraPosition	;

	mov	edx, DWORD PTR __imp_?Device@@3VCRenderDevice@@A
	push	ebx
	mov	ebx, ecx
	push	esi
	mov	eax, DWORD PTR [edx+488]
	mov	DWORD PTR _lc_COP$[esp+732], eax
	mov	eax, DWORD PTR [edx+492]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	esi, DWORD PTR [ebx+28]
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightPPA.cpp

; 147  : 	Fvector		lc_COP		= Device.vCameraPosition	;

	mov	DWORD PTR _lc_COP$[esp+736], eax
	mov	eax, DWORD PTR [edx+496]
	push	edi
	mov	DWORD PTR _lc_COP$[esp+744], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 150  :         return _Ptr == _Right._Ptr;

	cmp	esi, DWORD PTR [ebx+32]
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightPPA.cpp

; 149  : 	for (xr_vector<light*>::iterator it=selected_point.begin(); it!=selected_point.end(); it++)

	je	$LN3@render_poi
	movss	xmm4, DWORD PTR __real@3f800000
	movaps	xmm3, xmm4
	fld1
	divss	xmm3, DWORD PTR ?ps_r1_dlights_clip@@3MA
	movss	xmm6, DWORD PTR __xmm@80000000800000008000000080000000
	movss	xmm5, DWORD PTR __real@43960000
	fld	DWORD PTR __real@3c8efa36
	movss	xmm7, DWORD PTR __real@bf800000
	movss	DWORD PTR tv4018[esp+736], xmm3
$LN4@render_poi:

; 150  : 	{
; 151  : 		light*	L					= *it;

	mov	edi, DWORD PTR [esi]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 287  : 	{	return (x-v.x)*(x-v.x) + (y-v.y)*(y-v.y) + (z-v.z)*(z-v.z);	}

	movss	xmm1, DWORD PTR _lc_COP$[esp+740]
	movss	xmm2, DWORD PTR _lc_COP$[esp+736]
	movss	xmm0, DWORD PTR _lc_COP$[esp+744]
	subss	xmm1, DWORD PTR [edi+20]
	subss	xmm2, DWORD PTR [edi+16]
	subss	xmm0, DWORD PTR [edi+24]
	mulss	xmm1, xmm1
	mulss	xmm2, xmm2
	mulss	xmm0, xmm0
	addss	xmm2, xmm1
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightPPA.cpp

; 156  : 		float	lc_scale			= 1 - lc_dist/lc_limit;

	movaps	xmm1, xmm4
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 287  : 	{	return (x-v.x)*(x-v.x) + (y-v.y)*(y-v.y) + (z-v.z)*(z-v.z);	}

	addss	xmm2, xmm0
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h

; 764  :             return (float)sqrt(_X);

	sqrtss	xmm0, xmm2
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightPPA.cpp

; 155  : 		float	lc_dist				= lc_COP.distance_to	(L->spatial.sphere.P) - L->spatial.sphere.R;

	subss	xmm0, DWORD PTR [edi+28]

; 156  : 		float	lc_scale			= 1 - lc_dist/lc_limit;

	mulss	xmm0, xmm3
	subss	xmm1, xmm0

; 157  : 		if		(lc_scale<EPS)		continue;

	movss	xmm0, DWORD PTR __real@3727c5ac
	comiss	xmm0, xmm1
	movss	DWORD PTR _lc_scale$1$[esp+736], xmm1
	ja	$LN2@render_poi

; 158  : 		if		(L->range<0.01f)	continue;

	movss	xmm0, DWORD PTR __real@3c23d70a
	comiss	xmm0, DWORD PTR [edi+100]
	ja	$LN2@render_poi
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h

; 764  :             return (float)sqrt(_X);

	sqrtss	xmm4, xmm4
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 398  : 		return build_projection_HAT		(tanf(fFOV/2.f),fAspect,fNearPlane,fFarPlane);

	lea	ecx, DWORD PTR _L_project$2[esp+736]
	sub	esp, 16					; 00000010H
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 24   : 	ICF SelfRef	set(const _vector3<float> &v)			{ x = T(v.x);	y = T(v.y);	z = T(v.z);	return *this;	};

	movss	xmm1, DWORD PTR [edi+64]
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 398  : 		return build_projection_HAT		(tanf(fFOV/2.f),fAspect,fNearPlane,fFarPlane);

	fxch	ST(1)
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 24   : 	ICF SelfRef	set(const _vector3<float> &v)			{ x = T(v.x);	y = T(v.y);	z = T(v.z);	return *this;	};

	movss	DWORD PTR _L_pos$1[esp+752], xmm1
	movss	xmm2, DWORD PTR [edi+68]
	movss	DWORD PTR _L_pos$1[esp+756], xmm2
	addss	xmm2, xmm5
	movss	xmm0, DWORD PTR [edi+72]
	movss	DWORD PTR _L_pos$1[esp+760], xmm0
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h

; 764  :             return (float)sqrt(_X);

	movss	DWORD PTR tv3944[esp+752], xmm4
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightPPA.cpp

; 168  : 		L_pos.set					(L->position);			L_pos.y	+=	_camrange;

	movss	DWORD PTR _L_pos$1[esp+756], xmm2
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 24   : 	ICF SelfRef	set(const _vector3<float> &v)			{ x = T(v.x);	y = T(v.y);	z = T(v.z);	return *this;	};

	movss	DWORD PTR tv3902[esp+752], xmm2
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 475  : 		_31 = vRight.z;  _32 = vUp.z;  _33 = vView.z;  _34 = 0.0f;

	movaps	xmm2, xmm4
	mulss	xmm2, xmm1
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	movaps	xmm1, xmm4
	mulss	xmm1, xmm0
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightPPA.cpp

; 170  : 		L_project.build_projection	(deg2rad(2.f),1.f,_camrange-L->range,_camrange+L->range);

	movss	xmm0, DWORD PTR [edi+100]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	xorps	xmm2, xmm6
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightPPA.cpp

; 170  : 		L_project.build_projection	(deg2rad(2.f),1.f,_camrange-L->range,_camrange+L->range);

	addss	xmm0, xmm5
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	movss	DWORD PTR tv3901[esp+752], xmm2
	xorps	xmm1, xmm6
	movss	DWORD PTR tv3949[esp+752], xmm1
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 398  : 		return build_projection_HAT		(tanf(fFOV/2.f),fAspect,fNearPlane,fFarPlane);

	movss	DWORD PTR [esp+12], xmm0
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightPPA.cpp

; 170  : 		L_project.build_projection	(deg2rad(2.f),1.f,_camrange-L->range,_camrange+L->range);

	movaps	xmm0, xmm5
	subss	xmm0, DWORD PTR [edi+100]
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 398  : 		return build_projection_HAT		(tanf(fFOV/2.f),fAspect,fNearPlane,fFarPlane);

	movss	DWORD PTR [esp+8], xmm0
	fstp	DWORD PTR [esp+4]
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h

; 769  :             return (float)tan(_X);

	fptan
	fstp	ST(0)
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 398  : 		return build_projection_HAT		(tanf(fFOV/2.f),fAspect,fNearPlane,fFarPlane);

	fstp	DWORD PTR [esp]
	call	?build_projection_HAT@?$_matrix@M@@QAEAAU1@MMMM@Z ; _matrix<float>::build_projection_HAT

; 85   : 		m[0][0] = A.m[0][0] * B.m[0][0] + A.m[1][0] * B.m[0][1] + A.m[2][0] * B.m[0][2] + A.m[3][0] * B.m[0][3];

	movaps	xmm0, xmm4

; 93   : 		m[1][3] = A.m[0][3] * B.m[1][0] + A.m[1][3] * B.m[1][1] + A.m[2][3] * B.m[1][2] + A.m[3][3] * B.m[1][3];
; 94   : 
; 95   : 		m[2][0] = A.m[0][0] * B.m[2][0] + A.m[1][0] * B.m[2][1] + A.m[2][0] * B.m[2][2] + A.m[3][0] * B.m[2][3];

	movaps	xmm3, xmm4
	mulss	xmm0, DWORD PTR _L_project$2[esp+736]
	movaps	xmm1, xmm3
	mulss	xmm1, DWORD PTR _L_project$2[esp+752]

; 96   : 		m[2][1] = A.m[0][1] * B.m[2][0] + A.m[1][1] * B.m[2][1] + A.m[2][1] * B.m[2][2] + A.m[3][1] * B.m[2][3];

	movaps	xmm2, xmm3
	movss	DWORD PTR tv3931[esp+736], xmm0
	movss	DWORD PTR _L_combine$3[esp+736], xmm0
	movaps	xmm0, xmm4
	mulss	xmm0, DWORD PTR _L_project$2[esp+740]
	mulss	xmm2, DWORD PTR _L_project$2[esp+756]
	movss	DWORD PTR tv3908[esp+736], xmm0
	movss	DWORD PTR _L_combine$3[esp+740], xmm0
	movaps	xmm0, xmm4
	mulss	xmm0, DWORD PTR _L_project$2[esp+744]

; 97   : 		m[2][2] = A.m[0][2] * B.m[2][0] + A.m[1][2] * B.m[2][1] + A.m[2][2] * B.m[2][2] + A.m[3][2] * B.m[2][3];

	mulss	xmm3, DWORD PTR _L_project$2[esp+760]
	movss	DWORD PTR tv3934[esp+736], xmm0
	movss	DWORD PTR _L_combine$3[esp+744], xmm0
	movaps	xmm0, xmm4
	mulss	xmm0, DWORD PTR _L_project$2[esp+748]
	movss	DWORD PTR tv3941[esp+736], xmm1
	movss	DWORD PTR _L_combine$3[esp+768], xmm1
	movss	DWORD PTR tv3935[esp+736], xmm0
	movss	DWORD PTR _L_combine$3[esp+748], xmm0
	movss	xmm0, DWORD PTR _L_project$2[esp+768]
	mulss	xmm0, xmm7
	movss	DWORD PTR tv3920[esp+736], xmm2
	movss	DWORD PTR _L_combine$3[esp+772], xmm2
	movss	DWORD PTR tv3936[esp+736], xmm0
	movss	DWORD PTR _L_combine$3[esp+752], xmm0
	movss	xmm0, DWORD PTR _L_project$2[esp+772]
	mulss	xmm0, xmm7
	movss	DWORD PTR tv3943[esp+736], xmm3
	movss	DWORD PTR _L_combine$3[esp+776], xmm3
	movss	DWORD PTR tv3914[esp+736], xmm0
	movss	DWORD PTR _L_combine$3[esp+756], xmm0
	movss	xmm0, DWORD PTR _L_project$2[esp+776]
	mulss	xmm0, xmm7

; 98   : 		m[2][3] = A.m[0][3] * B.m[2][0] + A.m[1][3] * B.m[2][1] + A.m[2][3] * B.m[2][2] + A.m[3][3] * B.m[2][3];

	movaps	xmm7, xmm4
	mulss	xmm7, DWORD PTR _L_project$2[esp+764]
	movss	DWORD PTR tv3938[esp+736], xmm0
	movss	DWORD PTR _L_combine$3[esp+760], xmm0
	movss	xmm0, DWORD PTR _L_project$2[esp+780]
	mulss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR tv3944[esp+736], xmm7
	movss	DWORD PTR _L_combine$3[esp+780], xmm7
	movss	DWORD PTR tv3940[esp+736], xmm0
	movss	DWORD PTR _L_combine$3[esp+764], xmm0

; 100  : 		m[3][0] = A.m[0][0] * B.m[3][0] + A.m[1][0] * B.m[3][1] + A.m[2][0] * B.m[3][2] + A.m[3][0] * B.m[3][3];

	movss	xmm0, DWORD PTR tv3901[esp+736]
	mulss	xmm0, DWORD PTR _L_project$2[esp+736]
	movss	xmm7, DWORD PTR tv3949[esp+736]
	mulss	xmm7, DWORD PTR _L_project$2[esp+752]

; 101  : 		m[3][1] = A.m[0][1] * B.m[3][0] + A.m[1][1] * B.m[3][1] + A.m[2][1] * B.m[3][2] + A.m[3][1] * B.m[3][3];

	movss	xmm1, DWORD PTR tv3901[esp+736]
	movss	xmm4, DWORD PTR tv3949[esp+736]
	addss	xmm7, xmm0
	mulss	xmm4, DWORD PTR _L_project$2[esp+756]
	movss	xmm0, DWORD PTR tv3902[esp+736]
	mulss	xmm0, DWORD PTR _L_project$2[esp+768]
	movss	xmm5, DWORD PTR tv3949[esp+736]

; 102  : 		m[3][2] = A.m[0][2] * B.m[3][0] + A.m[1][2] * B.m[3][1] + A.m[2][2] * B.m[3][2] + A.m[3][2] * B.m[3][3];

	movss	xmm2, DWORD PTR tv3902[esp+736]
	addss	xmm0, DWORD PTR _L_project$2[esp+784]

; 85   : 		m[0][0] = A.m[0][0] * B.m[0][0] + A.m[1][0] * B.m[0][1] + A.m[2][0] * B.m[0][2] + A.m[3][0] * B.m[0][3];

	movss	xmm3, DWORD PTR tv3935[esp+736]
	mulss	xmm3, DWORD PTR __real@3f040000
	movss	xmm6, DWORD PTR tv3931[esp+736]

; 100  : 		m[3][0] = A.m[0][0] * B.m[3][0] + A.m[1][0] * B.m[3][1] + A.m[2][0] * B.m[3][2] + A.m[3][0] * B.m[3][3];

	addss	xmm7, xmm0

; 101  : 		m[3][1] = A.m[0][1] * B.m[3][0] + A.m[1][1] * B.m[3][1] + A.m[2][1] * B.m[3][2] + A.m[3][1] * B.m[3][3];

	movaps	xmm0, xmm1
	mulss	xmm0, DWORD PTR _L_project$2[esp+740]
	addss	xmm4, xmm0
	movss	DWORD PTR _L_combine$3[esp+784], xmm7
	movss	xmm0, DWORD PTR tv3902[esp+736]
	mulss	xmm0, DWORD PTR _L_project$2[esp+772]
	movss	DWORD PTR tv3946[esp+736], xmm7
	movaps	xmm7, xmm5
	mulss	xmm7, DWORD PTR _L_project$2[esp+760]
	addss	xmm0, DWORD PTR _L_project$2[esp+788]

; 102  : 		m[3][2] = A.m[0][2] * B.m[3][0] + A.m[1][2] * B.m[3][1] + A.m[2][2] * B.m[3][2] + A.m[3][2] * B.m[3][3];

	mulss	xmm5, DWORD PTR _L_project$2[esp+764]
	addss	xmm4, xmm0
	movaps	xmm0, xmm1
	mulss	xmm0, DWORD PTR _L_project$2[esp+744]

; 103  : 		m[3][3] = A.m[0][3] * B.m[3][0] + A.m[1][3] * B.m[3][1] + A.m[2][3] * B.m[3][2] + A.m[3][3] * B.m[3][3];

	mulss	xmm1, DWORD PTR _L_project$2[esp+748]
	addss	xmm7, xmm0
	movss	DWORD PTR _L_combine$3[esp+788], xmm4
	movaps	xmm0, xmm2
	mulss	xmm2, DWORD PTR _L_project$2[esp+780]
	mulss	xmm0, DWORD PTR _L_project$2[esp+776]
	addss	xmm5, xmm1
	addss	xmm2, DWORD PTR _L_project$2[esp+796]

; 85   : 		m[0][0] = A.m[0][0] * B.m[0][0] + A.m[1][0] * B.m[0][1] + A.m[2][0] * B.m[0][2] + A.m[3][0] * B.m[0][3];

	movss	xmm1, DWORD PTR tv3908[esp+736]

; 102  : 		m[3][2] = A.m[0][2] * B.m[3][0] + A.m[1][2] * B.m[3][1] + A.m[2][2] * B.m[3][2] + A.m[3][2] * B.m[3][3];

	addss	xmm0, DWORD PTR _L_project$2[esp+792]

; 103  : 		m[3][3] = A.m[0][3] * B.m[3][0] + A.m[1][3] * B.m[3][1] + A.m[2][3] * B.m[3][2] + A.m[3][3] * B.m[3][3];

	addss	xmm5, xmm2

; 85   : 		m[0][0] = A.m[0][0] * B.m[0][0] + A.m[1][0] * B.m[0][1] + A.m[2][0] * B.m[0][2] + A.m[3][0] * B.m[0][3];

	movss	xmm2, DWORD PTR __real@3f000000
	mulss	xmm1, xmm2

; 102  : 		m[3][2] = A.m[0][2] * B.m[3][0] + A.m[1][2] * B.m[3][1] + A.m[2][2] * B.m[3][2] + A.m[3][2] * B.m[3][3];

	addss	xmm7, xmm0

; 85   : 		m[0][0] = A.m[0][0] * B.m[0][0] + A.m[1][0] * B.m[0][1] + A.m[2][0] * B.m[0][2] + A.m[3][0] * B.m[0][3];

	mulss	xmm6, xmm2
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightPPA.cpp

; 175  : 		float			fRange				= 1.f  / L->range;

	movss	xmm0, DWORD PTR __real@3f800000
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 103  : 		m[3][3] = A.m[0][3] * B.m[3][0] + A.m[1][3] * B.m[3][1] + A.m[2][3] * B.m[3][2] + A.m[3][3] * B.m[3][3];

	movss	DWORD PTR _L_combine$3[esp+796], xmm5

; 85   : 		m[0][0] = A.m[0][0] * B.m[0][0] + A.m[1][0] * B.m[0][1] + A.m[2][0] * B.m[0][2] + A.m[3][0] * B.m[0][3];

	addss	xmm6, xmm3

; 102  : 		m[3][2] = A.m[0][2] * B.m[3][0] + A.m[1][2] * B.m[3][1] + A.m[2][2] * B.m[3][2] + A.m[3][2] * B.m[3][3];

	movss	DWORD PTR _L_combine$3[esp+792], xmm7

; 86   : 		m[0][1] = A.m[0][1] * B.m[0][0] + A.m[1][1] * B.m[0][1] + A.m[2][1] * B.m[0][2] + A.m[3][1] * B.m[0][3];

	subss	xmm3, xmm1
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightPPA.cpp

; 175  : 		float			fRange				= 1.f  / L->range;

	divss	xmm0, DWORD PTR [edi+100]
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 87   : 		m[0][2] = A.m[0][2] * B.m[0][0] + A.m[1][2] * B.m[0][1] + A.m[2][2] * B.m[0][2] + A.m[3][2] * B.m[0][3];

	movss	xmm1, DWORD PTR tv3934[esp+736]
	mulss	xmm1, xmm0
	movss	DWORD PTR tv3932[esp+736], xmm3

; 88   : 		m[0][3] = A.m[0][3] * B.m[0][0] + A.m[1][3] * B.m[0][1] + A.m[2][3] * B.m[0][2] + A.m[3][3] * B.m[0][3];
; 89   : 
; 90   : 		m[1][0] = A.m[0][0] * B.m[1][0] + A.m[1][0] * B.m[1][1] + A.m[2][0] * B.m[1][2] + A.m[3][0] * B.m[1][3];

	movss	xmm3, DWORD PTR tv3940[esp+736]
	mulss	xmm3, DWORD PTR __real@3f040000
	movss	DWORD PTR tv3934[esp+736], xmm1
	movss	xmm1, DWORD PTR tv3914[esp+736]
	mulss	xmm1, xmm2

; 102  : 		m[3][2] = A.m[0][2] * B.m[3][0] + A.m[1][2] * B.m[3][1] + A.m[2][2] * B.m[3][2] + A.m[3][2] * B.m[3][3];

	movss	DWORD PTR tv3948[esp+736], xmm7

; 90   : 		m[1][0] = A.m[0][0] * B.m[1][0] + A.m[1][0] * B.m[1][1] + A.m[2][0] * B.m[1][2] + A.m[3][0] * B.m[1][3];

	movss	xmm7, DWORD PTR tv3936[esp+736]
	mulss	xmm7, xmm2
	addss	xmm7, xmm3

; 91   : 		m[1][1] = A.m[0][1] * B.m[1][0] + A.m[1][1] * B.m[1][1] + A.m[2][1] * B.m[1][2] + A.m[3][1] * B.m[1][3];

	subss	xmm3, xmm1

; 92   : 		m[1][2] = A.m[0][2] * B.m[1][0] + A.m[1][2] * B.m[1][1] + A.m[2][2] * B.m[1][2] + A.m[3][2] * B.m[1][3];

	movss	xmm1, DWORD PTR tv3938[esp+736]
	mulss	xmm1, xmm0
	movss	DWORD PTR tv3938[esp+736], xmm1

; 93   : 		m[1][3] = A.m[0][3] * B.m[1][0] + A.m[1][3] * B.m[1][1] + A.m[2][3] * B.m[1][2] + A.m[3][3] * B.m[1][3];
; 94   : 
; 95   : 		m[2][0] = A.m[0][0] * B.m[2][0] + A.m[1][0] * B.m[2][1] + A.m[2][0] * B.m[2][2] + A.m[3][0] * B.m[2][3];

	movss	xmm1, DWORD PTR tv3941[esp+736]
	movss	DWORD PTR tv3937[esp+736], xmm3
	movss	xmm3, DWORD PTR tv3944[esp+736]
	mulss	xmm3, DWORD PTR __real@3f040000
	mulss	xmm1, xmm2
	movss	DWORD PTR tv3942[esp+736], xmm3
	addss	xmm1, xmm3
	movss	DWORD PTR tv3941[esp+736], xmm1
	movss	xmm1, DWORD PTR tv3920[esp+736]
	mulss	xmm1, xmm2

; 96   : 		m[2][1] = A.m[0][1] * B.m[2][0] + A.m[1][1] * B.m[2][1] + A.m[2][1] * B.m[2][2] + A.m[3][1] * B.m[2][3];

	subss	xmm3, xmm1
	movss	DWORD PTR tv3942[esp+736], xmm3

; 97   : 		m[2][2] = A.m[0][2] * B.m[2][0] + A.m[1][2] * B.m[2][1] + A.m[2][2] * B.m[2][2] + A.m[3][2] * B.m[2][3];

	movss	xmm3, DWORD PTR tv3943[esp+736]

; 100  : 		m[3][0] = A.m[0][0] * B.m[3][0] + A.m[1][0] * B.m[3][1] + A.m[2][0] * B.m[3][2] + A.m[3][0] * B.m[3][3];

	mulss	xmm4, DWORD PTR __real@3f000000
	movaps	xmm1, xmm5
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightPPA.cpp

; 187  : 		RImplementation.r1_dlight_light		= L;

	mov	DWORD PTR ?RImplementation@@3VCRender@@A+1080, edi
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 100  : 		m[3][0] = A.m[0][0] * B.m[3][0] + A.m[1][0] * B.m[3][1] + A.m[2][0] * B.m[3][2] + A.m[3][0] * B.m[3][3];

	mulss	xmm1, DWORD PTR __real@3f040000
	mulss	xmm3, xmm0
	movss	DWORD PTR tv3947[esp+736], xmm1
	movss	xmm1, DWORD PTR tv3946[esp+736]
	mulss	xmm1, xmm2
	movss	xmm2, DWORD PTR tv3947[esp+736]
	addss	xmm1, xmm2

; 101  : 		m[3][1] = A.m[0][1] * B.m[3][0] + A.m[1][1] * B.m[3][1] + A.m[2][1] * B.m[3][2] + A.m[3][1] * B.m[3][3];

	subss	xmm2, xmm4

; 102  : 		m[3][2] = A.m[0][2] * B.m[3][0] + A.m[1][2] * B.m[3][1] + A.m[2][2] * B.m[3][2] + A.m[3][2] * B.m[3][3];

	movss	xmm4, DWORD PTR tv3948[esp+736]
	mulss	xmm4, xmm0
; File I:\Vitalya\mine\NSProjectX\xrCore\vector.h

; 97   : 	else if	( val>_high )	return _high;

	movss	xmm0, DWORD PTR _lc_scale$1$[esp+736]
	comiss	xmm0, DWORD PTR __real@3f800000
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 101  : 		m[3][1] = A.m[0][1] * B.m[3][0] + A.m[1][1] * B.m[3][1] + A.m[2][1] * B.m[3][2] + A.m[3][1] * B.m[3][3];

	movss	DWORD PTR tv3947[esp+736], xmm2
; File I:\Vitalya\mine\NSProjectX\xrCore\vector.h

; 97   : 	else if	( val>_high )	return _high;

	jbe	SHORT $LN118@render_poi
	mov	DWORD PTR ?RImplementation@@3VCRender@@A+1084, 1065353216 ; 3f800000H
	jmp	SHORT $LN119@render_poi
$LN118@render_poi:

; 98   : 	else					return val;

	movss	DWORD PTR ?RImplementation@@3VCRender@@A+1084, xmm0
$LN119@render_poi:
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightPPA.cpp

; 189  : 		RImplementation.r1_dlight_tcgen		= L_texgen;

	movss	xmm0, DWORD PTR tv3932[esp+736]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_render.cpp

; 434  : 	temp.CreateFromMatrix			(mCombined,	FRUSTUM_P_ALL);

	lea	eax, DWORD PTR _L_combine$3[esp+736]
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightPPA.cpp

; 189  : 		RImplementation.r1_dlight_tcgen		= L_texgen;

	movss	DWORD PTR ?RImplementation@@3VCRender@@A+1020, xmm0
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_render.cpp

; 434  : 	temp.CreateFromMatrix			(mCombined,	FRUSTUM_P_ALL);

	lea	ecx, DWORD PTR _temp$4[esp+736]
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightPPA.cpp

; 189  : 		RImplementation.r1_dlight_tcgen		= L_texgen;

	movss	xmm0, DWORD PTR tv3934[esp+736]
	movss	DWORD PTR ?RImplementation@@3VCRender@@A+1024, xmm0
	movss	xmm0, DWORD PTR tv3935[esp+736]
	movss	DWORD PTR ?RImplementation@@3VCRender@@A+1028, xmm0
	movss	xmm0, DWORD PTR tv3937[esp+736]
	movss	DWORD PTR ?RImplementation@@3VCRender@@A+1036, xmm0
	movss	xmm0, DWORD PTR tv3938[esp+736]
	movss	DWORD PTR ?RImplementation@@3VCRender@@A+1040, xmm0
	movss	xmm0, DWORD PTR tv3940[esp+736]
	movss	DWORD PTR ?RImplementation@@3VCRender@@A+1044, xmm0
	movss	xmm0, DWORD PTR tv3941[esp+736]
	movss	DWORD PTR ?RImplementation@@3VCRender@@A+1048, xmm0
	movss	xmm0, DWORD PTR tv3942[esp+736]
	movss	DWORD PTR ?RImplementation@@3VCRender@@A+1052, xmm0
	movss	xmm0, DWORD PTR tv3947[esp+736]
	movss	DWORD PTR ?RImplementation@@3VCRender@@A+1056, xmm3
	movss	xmm3, DWORD PTR tv3944[esp+736]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_render.cpp

; 434  : 	temp.CreateFromMatrix			(mCombined,	FRUSTUM_P_ALL);

	push	63					; 0000003fH
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightPPA.cpp

; 189  : 		RImplementation.r1_dlight_tcgen		= L_texgen;

	movss	DWORD PTR ?RImplementation@@3VCRender@@A+1016, xmm6
	movss	DWORD PTR ?RImplementation@@3VCRender@@A+1032, xmm7
	movss	DWORD PTR ?RImplementation@@3VCRender@@A+1060, xmm3
	movss	DWORD PTR ?RImplementation@@3VCRender@@A+1064, xmm1
	movss	DWORD PTR ?RImplementation@@3VCRender@@A+1068, xmm0
	movss	DWORD PTR ?RImplementation@@3VCRender@@A+1072, xmm4
	movss	DWORD PTR ?RImplementation@@3VCRender@@A+1076, xmm5
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_structure.h

; 139  : 	void		r_pmask											(bool _1, bool _2, bool _wm=false)				{ pmask[0]=_1; pmask[1]=_2;	pmask_wmark = _wm; }

	mov	WORD PTR ?RImplementation@@3VCRender@@A+300, 1
	mov	BYTE PTR ?RImplementation@@3VCRender@@A+302, 0
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightPPA.cpp

; 194  : 		RImplementation.r_dsgraph_render_subspace	(

	mov	edi, DWORD PTR [edi+52]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_render.cpp

; 434  : 	temp.CreateFromMatrix			(mCombined,	FRUSTUM_P_ALL);

	push	eax
	call	DWORD PTR __imp_?CreateFromMatrix@CFrustum@@QAEXAAU?$_matrix@M@@I@Z

; 435  : 	r_dsgraph_render_subspace		(_sector,&temp,mCombined,_cop,_dynamic,_precise_portals);

	push	0
	push	ecx
	lea	eax, DWORD PTR _L_pos$1[esp+744]
	mov	ecx, OFFSET ?RImplementation@@3VCRender@@A ; RImplementation
	push	eax
	lea	eax, DWORD PTR _L_combine$3[esp+748]
	push	eax
	lea	eax, DWORD PTR _temp$4[esp+752]
	push	eax
	push	edi
	call	?r_dsgraph_render_subspace@R_dsgraph_structure@@QAEXPAVIRender_Sector@@PAVCFrustum@@AAU?$_matrix@M@@AAU?$_vector3@M@@HH@Z ; R_dsgraph_structure::r_dsgraph_render_subspace
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightPPA.cpp

; 204  : 		F.CreateFromMatrix	(L_combine,FRUSTUM_P_ALL);

	push	63					; 0000003fH
	lea	eax, DWORD PTR _L_combine$3[esp+740]
	push	eax
	lea	ecx, DWORD PTR _F$5[esp+744]
	call	DWORD PTR __imp_?CreateFromMatrix@CFrustum@@QAEXAAU?$_matrix@M@@I@Z

; 205  : 		bHUD				= F.testSphere_dirty	(Device.vCameraPosition,2.f);

	mov	eax, DWORD PTR __imp_?Device@@3VCRenderDevice@@A
	fld	DWORD PTR __real@40000000
	add	eax, 488				; 000001e8H
	push	ecx
	fstp	DWORD PTR [esp]
	push	eax
	lea	ecx, DWORD PTR _F$5[esp+744]
	call	DWORD PTR __imp_?testSphere_dirty@CFrustum@@QBEHAAU?$_vector3@M@@M@Z

; 206  : 
; 207  : 		//		5. Dump sorting tree
; 208  : 		RCache.set_Constants((R_constant_table*)0);

	mov	ecx, DWORD PTR __imp_?RCache@@3VCBackend@@A
	mov	edi, eax
	push	0
	call	DWORD PTR __imp_?set_Constants@CBackend@@QAEXPAVR_constant_table@@@Z

; 209  : 		if (bHUD)			g_pGameLevel->pHUD->Render_Last		();	

	test	edi, edi
	je	SHORT $LN13@render_poi
	mov	eax, DWORD PTR __imp_?g_pGameLevel@@3PAVIGame_Level@@A
	mov	eax, DWORD PTR [eax]
	mov	ecx, DWORD PTR [eax+280]
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+16]
	push	1
	push	0
	mov	ecx, OFFSET ?RImplementation@@3VCRender@@A ; RImplementation
	call	?r_dsgraph_render_graph@R_dsgraph_structure@@QAEXI_N@Z ; R_dsgraph_structure::r_dsgraph_render_graph

; 211  : 		if (bHUD)			RImplementation.r_dsgraph_render_hud();	

	mov	ecx, OFFSET ?RImplementation@@3VCRender@@A ; RImplementation
	call	?r_dsgraph_render_hud@R_dsgraph_structure@@QAEXXZ ; R_dsgraph_structure::r_dsgraph_render_hud
	jmp	SHORT $LN189@render_poi
$LN13@render_poi:

; 210  : 		RImplementation.r_dsgraph_render_graph					(0);

	push	1
	push	0
	mov	ecx, OFFSET ?RImplementation@@3VCRender@@A ; RImplementation
	call	?r_dsgraph_render_graph@R_dsgraph_structure@@QAEXI_N@Z ; R_dsgraph_structure::r_dsgraph_render_graph
$LN189@render_poi:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 74   :         ++_Ptr;

	fld1
	fld	DWORD PTR __real@3c8efa36
	movss	xmm6, DWORD PTR __xmm@80000000800000008000000080000000
	movss	xmm5, DWORD PTR __real@43960000
	movss	xmm7, DWORD PTR __real@bf800000
	movss	xmm4, DWORD PTR __real@3f800000
	movss	xmm3, DWORD PTR tv4018[esp+736]
$LN2@render_poi:
	add	esi, 4

; 150  :         return _Ptr == _Right._Ptr;

	cmp	esi, DWORD PTR [ebx+32]
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightPPA.cpp

; 149  : 	for (xr_vector<light*>::iterator it=selected_point.begin(); it!=selected_point.end(); it++)

	jne	$LN4@render_poi
	fstp	ST(1)
	fstp	ST(0)
$LN3@render_poi:

; 212  : 	}
; 213  : 	//		??? grass ???
; 214  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?render_point@CLightR_Manager@@QAEXXZ ENDP		; CLightR_Manager::render_point
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightPPA.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightPPA.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightPPA.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightPPA.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightPPA.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightPPA.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightPPA.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightPPA.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightPPA.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightPPA.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightPPA.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\vector.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\vector.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightPPA.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_render.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightPPA.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_render.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightPPA.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_render.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightPPA.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_structure.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightPPA.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_render.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightPPA.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightPPA.cpp
_TEXT	SEGMENT
tv4476 = -732						; size = 4
tv4444 = -732						; size = 4
_L_project$2$ = -728					; size = 4
tv4508 = -728						; size = 4
tv4478 = -724						; size = 4
_L_project$5$ = -720					; size = 4
tv4512 = -720						; size = 4
tv4446 = -720						; size = 4
tv4474 = -716						; size = 4
tv4436 = -716						; size = 4
tv4513 = -712						; size = 4
tv4507 = -708						; size = 4
tv4440 = -708						; size = 4
tv4510 = -704						; size = 4
tv4441 = -704						; size = 4
tv4514 = -700						; size = 4
tv4437 = -700						; size = 4
_L_up$1$sroa$1277$1$ = -696				; size = 4
tv4432 = -696						; size = 4
tv4292 = -696						; size = 4
_L_up$1$sroa$1280$1$ = -692				; size = 4
tv4515 = -692						; size = 4
tv4447 = -692						; size = 4
tv4295 = -692						; size = 4
tv4435 = -688						; size = 4
_this$1$ = -684						; size = 4
tv4433 = -680						; size = 4
tv4409 = -680						; size = 4
tv4434 = -676						; size = 4
tv4350 = -676						; size = 4
tv4442 = -672						; size = 4
tv4414 = -672						; size = 4
tv4438 = -668						; size = 4
tv4368 = -668						; size = 4
tv4443 = -664						; size = 4
tv4384 = -664						; size = 4
tv4462 = -660						; size = 4
_L_project$2 = -656					; size = 64
_lc_scale$1$ = -588					; size = 4
_lc_COP$ = -584						; size = 12
_L_pos$3 = -572						; size = 12
_L_combine$4 = -560					; size = 64
_temp$5 = -496						; size = 244
_F$6 = -248						; size = 244
?render_spot@CLightR_Manager@@QAEXXZ PROC		; CLightR_Manager::render_spot
; _this$ = ecx

; 217  : {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	sub	esp, 732				; 000002dcH

; 220  : 	Fvector		lc_COP		= Device.vCameraPosition	;

	mov	edx, DWORD PTR __imp_?Device@@3VCRenderDevice@@A
	push	ebx
	mov	ebx, ecx
	push	esi
	mov	eax, DWORD PTR [edx+488]
	mov	DWORD PTR _lc_COP$[esp+740], eax
	mov	eax, DWORD PTR [edx+492]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	esi, DWORD PTR [ebx+40]
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightPPA.cpp

; 220  : 	Fvector		lc_COP		= Device.vCameraPosition	;

	mov	DWORD PTR _lc_COP$[esp+744], eax
	mov	eax, DWORD PTR [edx+496]
	push	edi
	mov	DWORD PTR _this$1$[esp+744], ebx
	mov	DWORD PTR _lc_COP$[esp+752], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 150  :         return _Ptr == _Right._Ptr;

	cmp	esi, DWORD PTR [ebx+44]
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightPPA.cpp

; 223  : 	for (xr_vector<light*>::iterator it=selected_spot.begin(); it!=selected_spot.end(); it++)

	je	$LN3@render_spo
	movss	xmm4, DWORD PTR __real@3f800000
	mov	eax, ecx
	movaps	xmm3, xmm4
	fld1
	divss	xmm3, DWORD PTR ?ps_r1_dlights_clip@@3MA
	mov	ebx, DWORD PTR __imp_?CreateFromMatrix@CFrustum@@QAEXAAU?$_matrix@M@@I@Z
	fld	DWORD PTR __real@3dcccccd
	fld	DWORD PTR __real@3f000000
	movss	DWORD PTR tv4462[esp+744], xmm3
$LN4@render_spo:

; 224  : 	{
; 225  : 		light*	L					= *it;

	mov	edi, DWORD PTR [esi]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 287  : 	{	return (x-v.x)*(x-v.x) + (y-v.y)*(y-v.y) + (z-v.z)*(z-v.z);	}

	movss	xmm1, DWORD PTR _lc_COP$[esp+748]
	movss	xmm2, DWORD PTR _lc_COP$[esp+744]
	movss	xmm0, DWORD PTR _lc_COP$[esp+752]
	subss	xmm1, DWORD PTR [edi+20]
	subss	xmm2, DWORD PTR [edi+16]
	subss	xmm0, DWORD PTR [edi+24]
	mulss	xmm1, xmm1
	mulss	xmm2, xmm2
	mulss	xmm0, xmm0
	addss	xmm2, xmm1
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightPPA.cpp

; 229  : 		float	lc_scale			= 1 - lc_dist/lc_limit;

	movaps	xmm1, xmm4
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 287  : 	{	return (x-v.x)*(x-v.x) + (y-v.y)*(y-v.y) + (z-v.z)*(z-v.z);	}

	addss	xmm2, xmm0
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h

; 764  :             return (float)sqrt(_X);

	sqrtss	xmm0, xmm2
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightPPA.cpp

; 228  : 		float	lc_dist				= lc_COP.distance_to	(L->spatial.sphere.P) - L->spatial.sphere.R;

	subss	xmm0, DWORD PTR [edi+28]

; 229  : 		float	lc_scale			= 1 - lc_dist/lc_limit;

	mulss	xmm0, xmm3
	subss	xmm1, xmm0

; 230  : 		if		(lc_scale<EPS)		continue;

	movss	xmm0, DWORD PTR __real@3727c5ac
	comiss	xmm0, xmm1
	movss	DWORD PTR _lc_scale$1$[esp+744], xmm1
	ja	$LN2@render_spo
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 24   : 	ICF SelfRef	set(const _vector3<float> &v)			{ x = T(v.x);	y = T(v.y);	z = T(v.z);	return *this;	};

	movss	xmm5, DWORD PTR [edi+80]

; 23   : 	ICF	SelfRef	set(T _x, T _y, T _z)					{ x = _x;		y = _y;		z = _z;		return *this;	};

	movaps	xmm6, xmm4

; 24   : 	ICF SelfRef	set(const _vector3<float> &v)			{ x = T(v.x);	y = T(v.y);	z = T(v.z);	return *this;	};

	movss	xmm7, DWORD PTR [edi+76]
	movaps	xmm1, xmm5
	movss	xmm2, DWORD PTR [edi+84]

; 190  : 		T mag=_sqrt(T(1)/(x*x + y*y + z*z));

	movaps	xmm0, xmm7
	mulss	xmm0, xmm7

; 24   : 	ICF SelfRef	set(const _vector3<float> &v)			{ x = T(v.x);	y = T(v.y);	z = T(v.z);	return *this;	};

	mulss	xmm1, xmm5

; 190  : 		T mag=_sqrt(T(1)/(x*x + y*y + z*z));

	addss	xmm1, xmm0
	movaps	xmm0, xmm2
	mulss	xmm0, xmm2
	addss	xmm1, xmm0
	movaps	xmm0, xmm4
	divss	xmm0, xmm1

; 23   : 	ICF	SelfRef	set(T _x, T _y, T _z)					{ x = _x;		y = _y;		z = _z;		return *this;	};

	xorps	xmm1, xmm1
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h

; 764  :             return (float)sqrt(_X);

	sqrtss	xmm0, xmm0
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 191  : 		x *= mag;

	mulss	xmm5, xmm0
	mulss	xmm7, xmm0

; 192  : 		y *= mag;

	mulss	xmm2, xmm0
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h

; 676  :             return (float)fabs(_X);

	movaps	xmm0, xmm5
	andps	xmm0, DWORD PTR __xmm@7fffffff7fffffff7fffffff7fffffff
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightPPA.cpp

; 236  : 		L_up.set					(0,1,0);				if (_abs(L_up.dotproduct(L_dir))>.99f)	L_up.set(0,0,1);

	comiss	xmm0, DWORD PTR __real@3f7d70a4
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 190  : 		T mag=_sqrt(T(1)/(x*x + y*y + z*z));

	movss	DWORD PTR tv4474[esp+744], xmm7

; 191  : 		x *= mag;

	movss	DWORD PTR tv4476[esp+744], xmm5

; 192  : 		y *= mag;

	movss	DWORD PTR tv4478[esp+744], xmm2
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightPPA.cpp

; 236  : 		L_up.set					(0,1,0);				if (_abs(L_up.dotproduct(L_dir))>.99f)	L_up.set(0,0,1);

	jbe	SHORT $LN9@render_spo
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 23   : 	ICF	SelfRef	set(T _x, T _y, T _z)					{ x = _x;		y = _y;		z = _z;		return *this;	};

	movaps	xmm6, xmm1
	movaps	xmm1, xmm4
$LN9@render_spo:

; 273  : 		x = v1.y  * v2.z  - v1.z  * v2.y ;

	movaps	xmm0, xmm1
	movaps	xmm3, xmm6
	mulss	xmm0, xmm5
	mulss	xmm3, xmm2
	mulss	xmm1, xmm7
	subss	xmm3, xmm0

; 275  : 		z = v1.x  * v2.y  - v1.y  * v2.x ;

	mulss	xmm6, xmm7
	movss	DWORD PTR _L_up$1$sroa$1277$1$[esp+744], xmm1
	mulss	xmm1, xmm1
	xorps	xmm6, DWORD PTR __xmm@80000000800000008000000080000000

; 190  : 		T mag=_sqrt(T(1)/(x*x + y*y + z*z));

	movaps	xmm0, xmm3
	mulss	xmm0, xmm3

; 275  : 		z = v1.x  * v2.y  - v1.y  * v2.x ;

	movss	DWORD PTR _L_up$1$sroa$1280$1$[esp+744], xmm6

; 190  : 		T mag=_sqrt(T(1)/(x*x + y*y + z*z));

	addss	xmm1, xmm0
	movaps	xmm0, xmm6
	mulss	xmm0, xmm6
	addss	xmm1, xmm0
	movaps	xmm0, xmm4
	divss	xmm0, xmm1
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h

; 764  :             return (float)sqrt(_X);

	sqrtss	xmm1, xmm0
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 191  : 		x *= mag;

	movaps	xmm6, xmm1
	movaps	xmm2, xmm1

; 192  : 		y *= mag;

	mulss	xmm1, DWORD PTR _L_up$1$sroa$1280$1$[esp+744]
	mulss	xmm6, DWORD PTR _L_up$1$sroa$1277$1$[esp+744]
	mulss	xmm2, xmm3

; 193  : 		z *= mag;

	movaps	xmm4, xmm1

; 274  : 		y = v1.z  * v2.x  - v1.x  * v2.z ;

	mulss	xmm1, xmm7
	movaps	xmm0, xmm6
	mulss	xmm0, DWORD PTR tv4478[esp+744]
	movaps	xmm3, xmm2
	mulss	xmm3, DWORD PTR tv4478[esp+744]

; 193  : 		z *= mag;

	mulss	xmm4, xmm5

; 274  : 		y = v1.z  * v2.x  - v1.x  * v2.z ;

	subss	xmm3, xmm1

; 275  : 		z = v1.x  * v2.y  - v1.y  * v2.x ;

	mulss	xmm2, xmm5
	subss	xmm4, xmm0
	mulss	xmm6, xmm7
	movaps	xmm1, xmm3
	mulss	xmm1, xmm3
	subss	xmm6, xmm2

; 190  : 		T mag=_sqrt(T(1)/(x*x + y*y + z*z));

	movaps	xmm0, xmm4
	mulss	xmm0, xmm4
	addss	xmm1, xmm0
	movaps	xmm0, xmm6
	mulss	xmm0, xmm6
	addss	xmm1, xmm0
	movss	xmm0, DWORD PTR __real@3f800000
	divss	xmm0, xmm1
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h

; 764  :             return (float)sqrt(_X);

	sqrtss	xmm7, xmm0
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 24   : 	ICF SelfRef	set(const _vector3<float> &v)			{ x = T(v.x);	y = T(v.y);	z = T(v.z);	return *this;	};

	movss	xmm0, DWORD PTR [edi+64]

; 190  : 		T mag=_sqrt(T(1)/(x*x + y*y + z*z));

	movaps	xmm2, xmm7

; 24   : 	ICF SelfRef	set(const _vector3<float> &v)			{ x = T(v.x);	y = T(v.y);	z = T(v.z);	return *this;	};

	movss	DWORD PTR _L_pos$3[esp+744], xmm0

; 190  : 		T mag=_sqrt(T(1)/(x*x + y*y + z*z));

	mulss	xmm2, xmm4

; 191  : 		x *= mag;

	movaps	xmm5, xmm7

; 24   : 	ICF SelfRef	set(const _vector3<float> &v)			{ x = T(v.x);	y = T(v.y);	z = T(v.z);	return *this;	};

	movss	DWORD PTR tv4292[esp+744], xmm0
	movss	xmm0, DWORD PTR [edi+68]

; 191  : 		x *= mag;

	mulss	xmm5, xmm3

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	movaps	xmm1, xmm2
	mulss	xmm1, DWORD PTR tv4474[esp+744]

; 24   : 	ICF SelfRef	set(const _vector3<float> &v)			{ x = T(v.x);	y = T(v.y);	z = T(v.z);	return *this;	};

	movss	DWORD PTR _L_pos$3[esp+748], xmm0
	movss	DWORD PTR tv4295[esp+744], xmm0
	movss	xmm0, DWORD PTR tv4476[esp+744]
	mulss	xmm0, xmm5

; 192  : 		y *= mag;

	mulss	xmm7, xmm6

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	addss	xmm1, xmm0

; 24   : 	ICF SelfRef	set(const _vector3<float> &v)			{ x = T(v.x);	y = T(v.y);	z = T(v.z);	return *this;	};

	movss	xmm6, DWORD PTR [edi+72]

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	movss	xmm0, DWORD PTR tv4478[esp+744]
	mulss	xmm0, xmm7

; 24   : 	ICF SelfRef	set(const _vector3<float> &v)			{ x = T(v.x);	y = T(v.y);	z = T(v.z);	return *this;	};

	movss	DWORD PTR _L_pos$3[esp+752], xmm6

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	addss	xmm1, xmm0
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 464  : 		vUp.mul	(vView, -fDotProduct).add(vWorldUp).normalize();

	xorps	xmm1, DWORD PTR __xmm@80000000800000008000000080000000
	movaps	xmm4, xmm1
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 42   : 	ICF SelfRef	mul(const Self &a, T s)					{ x=a.x*s;  y=a.y*s;	z=a.z*s;		return *this;	};

	movaps	xmm3, xmm1
	mulss	xmm3, DWORD PTR tv4476[esp+744]
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 464  : 		vUp.mul	(vView, -fDotProduct).add(vWorldUp).normalize();

	mulss	xmm4, DWORD PTR tv4474[esp+744]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 29   : 	ICF	SelfRef	add(const Self &v)						{ x+=v.x;	y+=v.y;		z+=v.z;			return *this;	};

	addss	xmm3, xmm5

; 42   : 	ICF SelfRef	mul(const Self &a, T s)					{ x=a.x*s;  y=a.y*s;	z=a.z*s;		return *this;	};

	addss	xmm4, xmm2
	movss	xmm2, DWORD PTR tv4478[esp+744]
	mulss	xmm2, xmm1

; 29   : 	ICF	SelfRef	add(const Self &v)						{ x+=v.x;	y+=v.y;		z+=v.z;			return *this;	};

	movaps	xmm1, xmm3
	mulss	xmm1, xmm3
	addss	xmm2, xmm7

; 190  : 		T mag=_sqrt(T(1)/(x*x + y*y + z*z));

	movaps	xmm0, xmm4
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 398  : 		return build_projection_HAT		(tanf(fFOV/2.f),fAspect,fNearPlane,fFarPlane);

	sub	esp, 16					; 00000010H
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 190  : 		T mag=_sqrt(T(1)/(x*x + y*y + z*z));

	mulss	xmm0, xmm4
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 398  : 		return build_projection_HAT		(tanf(fFOV/2.f),fAspect,fNearPlane,fFarPlane);

	fxch	ST(1)
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 190  : 		T mag=_sqrt(T(1)/(x*x + y*y + z*z));

	addss	xmm1, xmm0
	movaps	xmm0, xmm2
	mulss	xmm0, xmm2
	addss	xmm1, xmm0
	movss	xmm0, DWORD PTR __real@3f800000
	divss	xmm0, xmm1
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h

; 764  :             return (float)sqrt(_X);

	sqrtss	xmm1, xmm0
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 190  : 		T mag=_sqrt(T(1)/(x*x + y*y + z*z));

	movaps	xmm5, xmm1

; 191  : 		x *= mag;

	movaps	xmm7, xmm1
	mulss	xmm7, xmm3

; 192  : 		y *= mag;

	mulss	xmm1, xmm2
	mulss	xmm5, xmm4

; 193  : 		z *= mag;

	movss	xmm4, DWORD PTR tv4478[esp+760]

; 273  : 		x = v1.y  * v2.z  - v1.z  * v2.y ;

	movaps	xmm0, xmm1
	mulss	xmm0, DWORD PTR tv4476[esp+760]
	movaps	xmm2, xmm1
	mulss	xmm2, DWORD PTR tv4474[esp+760]

; 274  : 		y = v1.z  * v2.x  - v1.x  * v2.z ;

	movaps	xmm3, xmm5
	mulss	xmm3, DWORD PTR tv4476[esp+760]

; 193  : 		z *= mag;

	mulss	xmm4, xmm7
	movss	DWORD PTR tv4508[esp+760], xmm1
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 475  : 		_31 = vRight.z;  _32 = vUp.z;  _33 = vView.z;  _34 = 0.0f;

	movss	xmm1, DWORD PTR tv4295[esp+760]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 273  : 		x = v1.y  * v2.z  - v1.z  * v2.y ;

	subss	xmm4, xmm0

; 191  : 		x *= mag;

	movss	DWORD PTR tv4507[esp+760], xmm7

; 274  : 		y = v1.z  * v2.x  - v1.x  * v2.z ;

	movss	xmm0, DWORD PTR tv4478[esp+760]
	mulss	xmm0, xmm5
	subss	xmm2, xmm0

; 275  : 		z = v1.x  * v2.y  - v1.y  * v2.x ;

	movaps	xmm0, xmm7
	mulss	xmm0, DWORD PTR tv4474[esp+760]
	subss	xmm3, xmm0
	movss	DWORD PTR tv4510[esp+760], xmm2
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 475  : 		_31 = vRight.z;  _32 = vUp.z;  _33 = vView.z;  _34 = 0.0f;

	movaps	xmm0, xmm1
	mulss	xmm0, xmm2
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	movss	xmm2, DWORD PTR tv4292[esp+760]

; 275  : 		z = v1.x  * v2.y  - v1.y  * v2.x ;

	movss	DWORD PTR tv4512[esp+760], xmm3
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 475  : 		_31 = vRight.z;  _32 = vUp.z;  _33 = vView.z;  _34 = 0.0f;

	movss	DWORD PTR tv4513[esp+760], xmm0
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	movaps	xmm0, xmm2
	movss	xmm7, DWORD PTR tv4513[esp+760]
	mulss	xmm0, xmm4
	addss	xmm7, xmm0
	movaps	xmm0, xmm6
	mulss	xmm0, xmm3
	movaps	xmm3, xmm7
	movss	DWORD PTR tv4513[esp+760], xmm7
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 478  : 		_41 = - vFrom.dotproduct(vRight);

	movss	xmm7, DWORD PTR tv4507[esp+760]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	addss	xmm3, xmm0
	movss	xmm0, DWORD PTR tv4508[esp+760]
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 478  : 		_41 = - vFrom.dotproduct(vRight);

	mulss	xmm7, xmm1
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	mulss	xmm0, xmm6
	xorps	xmm3, DWORD PTR __xmm@80000000800000008000000080000000
	movss	DWORD PTR tv4513[esp+760], xmm3
	movaps	xmm3, xmm5
	mulss	xmm3, xmm2
	addss	xmm3, xmm7
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 479  : 		_42 = - vFrom.dotproduct( vUp  );

	movss	xmm7, DWORD PTR tv4474[esp+760]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	addss	xmm3, xmm0
	movss	xmm0, DWORD PTR tv4476[esp+760]
	mulss	xmm0, xmm1
	xorps	xmm3, DWORD PTR __xmm@80000000800000008000000080000000
	movss	DWORD PTR tv4514[esp+760], xmm3
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 479  : 		_42 = - vFrom.dotproduct( vUp  );

	movaps	xmm3, xmm7
	mulss	xmm3, xmm2
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	addss	xmm3, xmm0
	movss	xmm0, DWORD PTR tv4478[esp+760]
	mulss	xmm0, xmm6
	addss	xmm3, xmm0
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightPPA.cpp

; 241  : 		L_project.build_projection	(L->cone,1.f,SSM_near_plane,L->range+EPS_S);

	movss	xmm0, DWORD PTR [edi+100]
	addss	xmm0, DWORD PTR __real@33d6bf95
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	xorps	xmm3, DWORD PTR __xmm@80000000800000008000000080000000
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 398  : 		return build_projection_HAT		(tanf(fFOV/2.f),fAspect,fNearPlane,fFarPlane);

	movss	DWORD PTR [esp+12], xmm0
	fstp	DWORD PTR [esp+8]
	fxch	ST(1)
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	movss	DWORD PTR tv4515[esp+760], xmm3
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 398  : 		return build_projection_HAT		(tanf(fFOV/2.f),fAspect,fNearPlane,fFarPlane);

	fstp	DWORD PTR [esp+4]
	fmul	DWORD PTR [edi+104]
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h

; 769  :             return (float)tan(_X);

	fptan
	fstp	ST(0)
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 398  : 		return build_projection_HAT		(tanf(fFOV/2.f),fAspect,fNearPlane,fFarPlane);

	lea	ecx, DWORD PTR _L_project$2[esp+760]
	fstp	DWORD PTR [esp]
	call	?build_projection_HAT@?$_matrix@M@@QAEAAU1@MMMM@Z ; _matrix<float>::build_projection_HAT

; 85   : 		m[0][0] = A.m[0][0] * B.m[0][0] + A.m[1][0] * B.m[0][1] + A.m[2][0] * B.m[0][2] + A.m[3][0] * B.m[0][3];

	movss	xmm1, DWORD PTR _L_project$2[esp+744]
	movss	xmm0, DWORD PTR _L_project$2[esp+760]
	mulss	xmm0, xmm5

; 86   : 		m[0][1] = A.m[0][1] * B.m[0][0] + A.m[1][1] * B.m[0][1] + A.m[2][1] * B.m[0][2] + A.m[3][1] * B.m[0][3];

	movss	xmm2, DWORD PTR _L_project$2[esp+748]
	mulss	xmm1, xmm4

; 87   : 		m[0][2] = A.m[0][2] * B.m[0][0] + A.m[1][2] * B.m[0][1] + A.m[2][2] * B.m[0][2] + A.m[3][2] * B.m[0][3];

	movss	xmm6, DWORD PTR _L_project$2[esp+784]
	addss	xmm1, xmm0
	movss	xmm0, DWORD PTR _L_project$2[esp+776]
	mulss	xmm0, xmm7
	addss	xmm1, xmm0
	movss	xmm0, DWORD PTR _L_project$2[esp+764]
	mulss	xmm0, xmm5
	movss	DWORD PTR tv4432[esp+744], xmm1
	movss	DWORD PTR _L_combine$4[esp+744], xmm1
	movaps	xmm1, xmm2
	mulss	xmm1, xmm4

; 91   : 		m[1][1] = A.m[0][1] * B.m[1][0] + A.m[1][1] * B.m[1][1] + A.m[2][1] * B.m[1][2] + A.m[3][1] * B.m[1][3];

	mulss	xmm2, DWORD PTR tv4510[esp+744]
	addss	xmm1, xmm0
	movss	xmm0, DWORD PTR _L_project$2[esp+780]
	mulss	xmm0, xmm7
	addss	xmm1, xmm0
	movss	xmm0, DWORD PTR _L_project$2[esp+768]
	mulss	xmm0, xmm5
	movss	DWORD PTR tv4409[esp+744], xmm1
	movss	DWORD PTR _L_combine$4[esp+748], xmm1
	movss	xmm1, DWORD PTR _L_project$2[esp+752]
	movaps	xmm3, xmm1
	mulss	xmm3, xmm4
	addss	xmm3, xmm0
	movaps	xmm0, xmm6
	mulss	xmm0, xmm7
	movss	xmm7, DWORD PTR _L_project$2[esp+756]
	addss	xmm3, xmm0
	movss	xmm0, DWORD PTR _L_project$2[esp+772]
	mulss	xmm0, xmm5
	movss	xmm5, DWORD PTR _L_project$2[esp+744]
	mulss	xmm5, DWORD PTR tv4510[esp+744]
	movss	DWORD PTR tv4350[esp+744], xmm3
	movss	DWORD PTR _L_combine$4[esp+752], xmm3
	movaps	xmm3, xmm7
	mulss	xmm3, xmm4
	addss	xmm3, xmm0
	movss	DWORD PTR tv4435[esp+744], xmm3
	movss	xmm3, DWORD PTR _L_project$2[esp+788]
	movss	xmm4, DWORD PTR tv4435[esp+744]
	movaps	xmm0, xmm3
	mulss	xmm0, DWORD PTR tv4474[esp+744]
	addss	xmm4, xmm0
	movss	xmm0, DWORD PTR _L_project$2[esp+760]
	mulss	xmm0, DWORD PTR tv4507[esp+744]
	addss	xmm5, xmm0
	movss	DWORD PTR tv4435[esp+744], xmm4
	movss	DWORD PTR _L_combine$4[esp+756], xmm4
	movss	DWORD PTR tv4436[esp+744], xmm5
	movss	xmm5, DWORD PTR _L_project$2[esp+776]
	movss	xmm4, DWORD PTR tv4436[esp+744]
	movaps	xmm0, xmm5
	mulss	xmm0, DWORD PTR tv4476[esp+744]
	addss	xmm4, xmm0
	movaps	xmm0, xmm4
	movss	DWORD PTR tv4436[esp+744], xmm4
	movss	xmm4, DWORD PTR _L_project$2[esp+780]
	movss	DWORD PTR _L_combine$4[esp+760], xmm0
	movss	xmm0, DWORD PTR _L_project$2[esp+764]
	mulss	xmm0, DWORD PTR tv4507[esp+744]
	addss	xmm2, xmm0
	movaps	xmm0, xmm4
	mulss	xmm0, DWORD PTR tv4476[esp+744]
	addss	xmm2, xmm0

; 92   : 		m[1][2] = A.m[0][2] * B.m[1][0] + A.m[1][2] * B.m[1][1] + A.m[2][2] * B.m[1][2] + A.m[3][2] * B.m[1][3];

	movss	xmm0, DWORD PTR _L_project$2[esp+768]
	mulss	xmm0, DWORD PTR tv4507[esp+744]
	movss	DWORD PTR tv4414[esp+744], xmm2
	movss	DWORD PTR _L_combine$4[esp+764], xmm2
	movaps	xmm2, xmm1
	mulss	xmm2, DWORD PTR tv4510[esp+744]
	addss	xmm2, xmm0
	movaps	xmm0, xmm6
	mulss	xmm0, DWORD PTR tv4476[esp+744]
	addss	xmm2, xmm0

; 97   : 		m[2][2] = A.m[0][2] * B.m[2][0] + A.m[1][2] * B.m[2][1] + A.m[2][2] * B.m[2][2] + A.m[3][2] * B.m[2][3];

	mulss	xmm1, DWORD PTR tv4512[esp+744]
	movss	xmm0, DWORD PTR _L_project$2[esp+772]
	mulss	xmm0, DWORD PTR tv4507[esp+744]
	movss	DWORD PTR tv4368[esp+744], xmm2
	movss	DWORD PTR _L_combine$4[esp+768], xmm2
	movaps	xmm2, xmm7
	mulss	xmm2, DWORD PTR tv4510[esp+744]
	addss	xmm2, xmm0
	movaps	xmm0, xmm3
	mulss	xmm0, DWORD PTR tv4476[esp+744]
	addss	xmm2, xmm0
	movss	xmm0, DWORD PTR _L_project$2[esp+760]
	mulss	xmm0, DWORD PTR tv4508[esp+744]
	movss	DWORD PTR tv4440[esp+744], xmm2
	movss	DWORD PTR _L_combine$4[esp+772], xmm2
	movss	xmm2, DWORD PTR _L_project$2[esp+744]
	mulss	xmm2, DWORD PTR tv4512[esp+744]
	addss	xmm2, xmm0
	movaps	xmm0, xmm5
	mulss	xmm0, DWORD PTR tv4478[esp+744]

; 98   : 		m[2][3] = A.m[0][3] * B.m[2][0] + A.m[1][3] * B.m[2][1] + A.m[2][3] * B.m[2][2] + A.m[3][3] * B.m[2][3];
; 99   : 
; 100  : 		m[3][0] = A.m[0][0] * B.m[3][0] + A.m[1][0] * B.m[3][1] + A.m[2][0] * B.m[3][2] + A.m[3][0] * B.m[3][3];

	mulss	xmm5, DWORD PTR tv4515[esp+744]
	addss	xmm2, xmm0
	movss	xmm0, DWORD PTR _L_project$2[esp+764]
	mulss	xmm0, DWORD PTR tv4508[esp+744]
	addss	xmm5, DWORD PTR _L_project$2[esp+792]
	movss	DWORD PTR tv4441[esp+744], xmm2
	movss	DWORD PTR _L_combine$4[esp+776], xmm2
	movss	xmm2, DWORD PTR _L_project$2[esp+748]
	mulss	xmm2, DWORD PTR tv4512[esp+744]
	addss	xmm2, xmm0
	movaps	xmm0, xmm4
	mulss	xmm0, DWORD PTR tv4478[esp+744]
	addss	xmm2, xmm0
	movss	xmm0, DWORD PTR _L_project$2[esp+768]
	mulss	xmm0, DWORD PTR tv4508[esp+744]
	addss	xmm1, xmm0
	movss	DWORD PTR _L_combine$4[esp+780], xmm2
	movaps	xmm0, xmm6
	mulss	xmm0, DWORD PTR tv4478[esp+744]
	addss	xmm1, xmm0
	movss	xmm0, DWORD PTR _L_project$2[esp+772]
	mulss	xmm0, DWORD PTR tv4508[esp+744]
	movss	DWORD PTR tv4384[esp+744], xmm1
	movss	DWORD PTR _L_combine$4[esp+784], xmm1
	movaps	xmm1, xmm7
	mulss	xmm1, DWORD PTR tv4512[esp+744]
	addss	xmm1, xmm0
	movaps	xmm0, xmm3
	mulss	xmm0, DWORD PTR tv4478[esp+744]
	addss	xmm1, xmm0
	movss	xmm0, DWORD PTR _L_project$2[esp+760]
	mulss	xmm0, DWORD PTR tv4514[esp+744]
	movss	DWORD PTR _L_project$2$[esp+744], xmm0
	movss	xmm0, DWORD PTR _L_project$2[esp+744]
	mulss	xmm0, DWORD PTR tv4513[esp+744]
	movss	DWORD PTR tv4444[esp+744], xmm1
	movss	DWORD PTR _L_combine$4[esp+788], xmm1
	movss	xmm1, DWORD PTR _L_project$2$[esp+744]
	addss	xmm1, xmm0
	movaps	xmm0, xmm1
	movss	DWORD PTR _L_project$2$[esp+744], xmm1
	addss	xmm0, xmm5
	movss	xmm5, DWORD PTR _L_project$2[esp+764]
	mulss	xmm5, DWORD PTR tv4514[esp+744]
	movss	DWORD PTR _L_project$2$[esp+744], xmm0
	movss	DWORD PTR _L_combine$4[esp+792], xmm0

; 101  : 		m[3][1] = A.m[0][1] * B.m[3][0] + A.m[1][1] * B.m[3][1] + A.m[2][1] * B.m[3][2] + A.m[3][1] * B.m[3][3];

	movss	xmm0, DWORD PTR _L_project$2[esp+748]
	mulss	xmm0, DWORD PTR tv4513[esp+744]
	addss	xmm5, xmm0
	movss	DWORD PTR _L_project$5$[esp+744], xmm5
	movss	xmm5, DWORD PTR tv4515[esp+744]
	movss	xmm0, DWORD PTR _L_project$5$[esp+744]
	mulss	xmm4, xmm5
	addss	xmm4, DWORD PTR _L_project$2[esp+796]
	addss	xmm0, xmm4
	movss	xmm4, DWORD PTR _L_project$2[esp+768]
	mulss	xmm4, DWORD PTR tv4514[esp+744]
	movss	DWORD PTR _L_project$5$[esp+744], xmm0
	movss	DWORD PTR _L_combine$4[esp+796], xmm0

; 102  : 		m[3][2] = A.m[0][2] * B.m[3][0] + A.m[1][2] * B.m[3][1] + A.m[2][2] * B.m[3][2] + A.m[3][2] * B.m[3][3];

	movss	xmm0, DWORD PTR _L_project$2[esp+752]
	mulss	xmm0, DWORD PTR tv4513[esp+744]

; 103  : 		m[3][3] = A.m[0][3] * B.m[3][0] + A.m[1][3] * B.m[3][1] + A.m[2][3] * B.m[3][2] + A.m[3][3] * B.m[3][3];

	mulss	xmm7, DWORD PTR tv4513[esp+744]
	addss	xmm4, xmm0
	mulss	xmm6, xmm5
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightPPA.cpp

; 246  : 		float			fRange				= 1.f  / L->range;

	movss	xmm1, DWORD PTR __real@3f800000
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 103  : 		m[3][3] = A.m[0][3] * B.m[3][0] + A.m[1][3] * B.m[3][1] + A.m[2][3] * B.m[3][2] + A.m[3][3] * B.m[3][3];

	mulss	xmm3, xmm5
	addss	xmm6, DWORD PTR _L_project$2[esp+800]

; 85   : 		m[0][0] = A.m[0][0] * B.m[0][0] + A.m[1][0] * B.m[0][1] + A.m[2][0] * B.m[0][2] + A.m[3][0] * B.m[0][3];

	movss	xmm5, DWORD PTR tv4432[esp+744]

; 103  : 		m[3][3] = A.m[0][3] * B.m[3][0] + A.m[1][3] * B.m[3][1] + A.m[2][3] * B.m[3][2] + A.m[3][3] * B.m[3][3];

	addss	xmm3, DWORD PTR _L_project$2[esp+804]

; 85   : 		m[0][0] = A.m[0][0] * B.m[0][0] + A.m[1][0] * B.m[0][1] + A.m[2][0] * B.m[0][2] + A.m[3][0] * B.m[0][3];

	mulss	xmm5, DWORD PTR __real@3f000000

; 102  : 		m[3][2] = A.m[0][2] * B.m[3][0] + A.m[1][2] * B.m[3][1] + A.m[2][2] * B.m[3][2] + A.m[3][2] * B.m[3][3];

	addss	xmm4, xmm6

; 85   : 		m[0][0] = A.m[0][0] * B.m[0][0] + A.m[1][0] * B.m[0][1] + A.m[2][0] * B.m[0][2] + A.m[3][0] * B.m[0][3];

	movss	xmm0, DWORD PTR tv4409[esp+744]

; 102  : 		m[3][2] = A.m[0][2] * B.m[3][0] + A.m[1][2] * B.m[3][1] + A.m[2][2] * B.m[3][2] + A.m[3][2] * B.m[3][3];

	movss	xmm6, DWORD PTR _L_project$2[esp+772]
	mulss	xmm6, DWORD PTR tv4514[esp+744]

; 95   : 		m[2][0] = A.m[0][0] * B.m[2][0] + A.m[1][0] * B.m[2][1] + A.m[2][0] * B.m[2][2] + A.m[3][0] * B.m[2][3];

	mulss	xmm2, DWORD PTR __real@3f000000

; 103  : 		m[3][3] = A.m[0][3] * B.m[3][0] + A.m[1][3] * B.m[3][1] + A.m[2][3] * B.m[3][2] + A.m[3][3] * B.m[3][3];

	addss	xmm6, xmm7
	movss	DWORD PTR _L_combine$4[esp+800], xmm4

; 85   : 		m[0][0] = A.m[0][0] * B.m[0][0] + A.m[1][0] * B.m[0][1] + A.m[2][0] * B.m[0][2] + A.m[3][0] * B.m[0][3];

	movss	xmm7, DWORD PTR tv4435[esp+744]
	mulss	xmm7, DWORD PTR __real@3f040000

; 103  : 		m[3][3] = A.m[0][3] * B.m[3][0] + A.m[1][3] * B.m[3][1] + A.m[2][3] * B.m[3][2] + A.m[3][3] * B.m[3][3];

	addss	xmm6, xmm3

; 85   : 		m[0][0] = A.m[0][0] * B.m[0][0] + A.m[1][0] * B.m[0][1] + A.m[2][0] * B.m[0][2] + A.m[3][0] * B.m[0][3];

	addss	xmm5, xmm7

; 103  : 		m[3][3] = A.m[0][3] * B.m[3][0] + A.m[1][3] * B.m[3][1] + A.m[2][3] * B.m[3][2] + A.m[3][3] * B.m[3][3];

	movss	DWORD PTR _L_combine$4[esp+804], xmm6
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightPPA.cpp

; 246  : 		float			fRange				= 1.f  / L->range;

	divss	xmm1, DWORD PTR [edi+100]

; 247  : 		float			fBias				= 0.f;
; 248  : 		Fmatrix			m_TexelAdjust		= 
; 249  : 		{
; 250  : 			0.5f,				0.0f,				0.0f,			0.0f,
; 251  : 			0.0f,				-0.5f,				0.0f,			0.0f,
; 252  : 			0.0f,				0.0f,				fRange,			0.0f,
; 253  : 			0.5f + fTexelOffs,	0.5f + fTexelOffs,	fBias,			1.0f
; 254  : 		};
; 255  : 		Fmatrix		L_texgen;		L_texgen.mul	(m_TexelAdjust,L_combine);
; 256  : 
; 257  : 		//		2. Set global light-params to be used by shading
; 258  : 		RImplementation.r1_dlight_light		= L;

	mov	DWORD PTR ?RImplementation@@3VCRender@@A+1080, edi
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 85   : 		m[0][0] = A.m[0][0] * B.m[0][0] + A.m[1][0] * B.m[0][1] + A.m[2][0] * B.m[0][2] + A.m[3][0] * B.m[0][3];

	movss	DWORD PTR tv4432[esp+744], xmm5
	movss	xmm5, DWORD PTR __real@3f000000
	mulss	xmm0, xmm5
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightPPA.cpp

; 246  : 		float			fRange				= 1.f  / L->range;

	movss	DWORD PTR tv4447[esp+744], xmm1
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 86   : 		m[0][1] = A.m[0][1] * B.m[0][0] + A.m[1][1] * B.m[0][1] + A.m[2][1] * B.m[0][2] + A.m[3][1] * B.m[0][3];

	subss	xmm7, xmm0

; 87   : 		m[0][2] = A.m[0][2] * B.m[0][0] + A.m[1][2] * B.m[0][1] + A.m[2][2] * B.m[0][2] + A.m[3][2] * B.m[0][3];

	movaps	xmm0, xmm1
	mulss	xmm0, DWORD PTR tv4350[esp+744]
	movss	DWORD PTR tv4434[esp+744], xmm0

; 88   : 		m[0][3] = A.m[0][3] * B.m[0][0] + A.m[1][3] * B.m[0][1] + A.m[2][3] * B.m[0][2] + A.m[3][3] * B.m[0][3];
; 89   : 
; 90   : 		m[1][0] = A.m[0][0] * B.m[1][0] + A.m[1][0] * B.m[1][1] + A.m[2][0] * B.m[1][2] + A.m[3][0] * B.m[1][3];

	movss	xmm0, DWORD PTR tv4440[esp+744]
	mulss	xmm0, DWORD PTR __real@3f040000
	movss	DWORD PTR tv4433[esp+744], xmm7
	movss	xmm7, DWORD PTR tv4436[esp+744]
	movss	DWORD PTR tv4437[esp+744], xmm0
	mulss	xmm7, xmm5
	addss	xmm7, xmm0
	movss	xmm0, DWORD PTR tv4414[esp+744]
	mulss	xmm0, xmm5

; 91   : 		m[1][1] = A.m[0][1] * B.m[1][0] + A.m[1][1] * B.m[1][1] + A.m[2][1] * B.m[1][2] + A.m[3][1] * B.m[1][3];

	movss	xmm5, DWORD PTR tv4437[esp+744]
	subss	xmm5, xmm0

; 92   : 		m[1][2] = A.m[0][2] * B.m[1][0] + A.m[1][2] * B.m[1][1] + A.m[2][2] * B.m[1][2] + A.m[3][2] * B.m[1][3];

	movaps	xmm0, xmm1
	mulss	xmm0, DWORD PTR tv4368[esp+744]
	movss	DWORD PTR tv4438[esp+744], xmm0

; 93   : 		m[1][3] = A.m[0][3] * B.m[1][0] + A.m[1][3] * B.m[1][1] + A.m[2][3] * B.m[1][2] + A.m[3][3] * B.m[1][3];
; 94   : 
; 95   : 		m[2][0] = A.m[0][0] * B.m[2][0] + A.m[1][0] * B.m[2][1] + A.m[2][0] * B.m[2][2] + A.m[3][0] * B.m[2][3];

	movss	xmm0, DWORD PTR tv4441[esp+744]
	mulss	xmm0, DWORD PTR __real@3f000000
	movss	DWORD PTR tv4437[esp+744], xmm5
	movss	xmm5, DWORD PTR tv4444[esp+744]
	mulss	xmm5, DWORD PTR __real@3f040000
	addss	xmm0, xmm5

; 96   : 		m[2][1] = A.m[0][1] * B.m[2][0] + A.m[1][1] * B.m[2][1] + A.m[2][1] * B.m[2][2] + A.m[3][1] * B.m[2][3];

	subss	xmm5, xmm2

; 98   : 		m[2][3] = A.m[0][3] * B.m[2][0] + A.m[1][3] * B.m[2][1] + A.m[2][3] * B.m[2][2] + A.m[3][3] * B.m[2][3];
; 99   : 
; 100  : 		m[3][0] = A.m[0][0] * B.m[3][0] + A.m[1][0] * B.m[3][1] + A.m[2][0] * B.m[3][2] + A.m[3][0] * B.m[3][3];

	movaps	xmm2, xmm6
	mulss	xmm2, DWORD PTR __real@3f040000
	movss	DWORD PTR tv4441[esp+744], xmm0
	movaps	xmm0, xmm1
	mulss	xmm0, DWORD PTR tv4384[esp+744]
	movss	xmm1, DWORD PTR _L_project$2$[esp+744]
	mulss	xmm1, DWORD PTR __real@3f000000
	movss	DWORD PTR tv4443[esp+744], xmm0
	movss	xmm0, DWORD PTR _L_project$5$[esp+744]
	mulss	xmm0, DWORD PTR __real@3f000000
	addss	xmm1, xmm2
	movss	DWORD PTR tv4442[esp+744], xmm5

; 101  : 		m[3][1] = A.m[0][1] * B.m[3][0] + A.m[1][1] * B.m[3][1] + A.m[2][1] * B.m[3][2] + A.m[3][1] * B.m[3][3];

	subss	xmm2, xmm0
; File I:\Vitalya\mine\NSProjectX\xrCore\vector.h

; 97   : 	else if	( val>_high )	return _high;

	movss	xmm0, DWORD PTR _lc_scale$1$[esp+744]
	comiss	xmm0, DWORD PTR __real@3f800000
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 101  : 		m[3][1] = A.m[0][1] * B.m[3][0] + A.m[1][1] * B.m[3][1] + A.m[2][1] * B.m[3][2] + A.m[3][1] * B.m[3][3];

	movss	DWORD PTR tv4446[esp+744], xmm2

; 102  : 		m[3][2] = A.m[0][2] * B.m[3][0] + A.m[1][2] * B.m[3][1] + A.m[2][2] * B.m[3][2] + A.m[3][2] * B.m[3][3];

	movss	xmm2, DWORD PTR tv4447[esp+744]
	mulss	xmm2, xmm4
; File I:\Vitalya\mine\NSProjectX\xrCore\vector.h

; 97   : 	else if	( val>_high )	return _high;

	jbe	SHORT $LN128@render_spo
	mov	DWORD PTR ?RImplementation@@3VCRender@@A+1084, 1065353216 ; 3f800000H
	jmp	SHORT $LN129@render_spo
$LN128@render_spo:

; 98   : 	else					return val;

	movss	DWORD PTR ?RImplementation@@3VCRender@@A+1084, xmm0
$LN129@render_spo:
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightPPA.cpp

; 260  : 		RImplementation.r1_dlight_tcgen		= L_texgen;

	movss	xmm0, DWORD PTR tv4433[esp+744]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_render.cpp

; 434  : 	temp.CreateFromMatrix			(mCombined,	FRUSTUM_P_ALL);

	lea	eax, DWORD PTR _L_combine$4[esp+744]
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightPPA.cpp

; 260  : 		RImplementation.r1_dlight_tcgen		= L_texgen;

	movss	DWORD PTR ?RImplementation@@3VCRender@@A+1020, xmm0
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_render.cpp

; 434  : 	temp.CreateFromMatrix			(mCombined,	FRUSTUM_P_ALL);

	lea	ecx, DWORD PTR _temp$5[esp+744]
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightPPA.cpp

; 260  : 		RImplementation.r1_dlight_tcgen		= L_texgen;

	movss	xmm0, DWORD PTR tv4434[esp+744]
	movss	DWORD PTR ?RImplementation@@3VCRender@@A+1024, xmm0
	movss	xmm0, DWORD PTR tv4435[esp+744]
	movss	xmm5, DWORD PTR tv4432[esp+744]
	movss	DWORD PTR ?RImplementation@@3VCRender@@A+1028, xmm0
	movss	xmm0, DWORD PTR tv4437[esp+744]
	movss	DWORD PTR ?RImplementation@@3VCRender@@A+1036, xmm0
	movss	xmm0, DWORD PTR tv4438[esp+744]
	movss	DWORD PTR ?RImplementation@@3VCRender@@A+1040, xmm0
	movss	xmm0, DWORD PTR tv4440[esp+744]
	movss	DWORD PTR ?RImplementation@@3VCRender@@A+1044, xmm0
	movss	xmm0, DWORD PTR tv4441[esp+744]
	movss	DWORD PTR ?RImplementation@@3VCRender@@A+1048, xmm0
	movss	xmm0, DWORD PTR tv4442[esp+744]
	movss	DWORD PTR ?RImplementation@@3VCRender@@A+1052, xmm0
	movss	xmm0, DWORD PTR tv4443[esp+744]
	movss	DWORD PTR ?RImplementation@@3VCRender@@A+1056, xmm0
	movss	xmm0, DWORD PTR tv4444[esp+744]
	movss	DWORD PTR ?RImplementation@@3VCRender@@A+1060, xmm0
	movss	xmm0, DWORD PTR tv4446[esp+744]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_render.cpp

; 434  : 	temp.CreateFromMatrix			(mCombined,	FRUSTUM_P_ALL);

	push	63					; 0000003fH
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightPPA.cpp

; 260  : 		RImplementation.r1_dlight_tcgen		= L_texgen;

	movss	DWORD PTR ?RImplementation@@3VCRender@@A+1016, xmm5
	movss	DWORD PTR ?RImplementation@@3VCRender@@A+1032, xmm7
	movss	DWORD PTR ?RImplementation@@3VCRender@@A+1064, xmm1
	movss	DWORD PTR ?RImplementation@@3VCRender@@A+1068, xmm0
	movss	DWORD PTR ?RImplementation@@3VCRender@@A+1072, xmm2
	movss	DWORD PTR ?RImplementation@@3VCRender@@A+1076, xmm6
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_structure.h

; 139  : 	void		r_pmask											(bool _1, bool _2, bool _wm=false)				{ pmask[0]=_1; pmask[1]=_2;	pmask_wmark = _wm; }

	mov	WORD PTR ?RImplementation@@3VCRender@@A+300, 1
	mov	BYTE PTR ?RImplementation@@3VCRender@@A+302, 0
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightPPA.cpp

; 266  : 		RImplementation.r_dsgraph_render_subspace	(

	mov	edi, DWORD PTR [edi+52]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_render.cpp

; 434  : 	temp.CreateFromMatrix			(mCombined,	FRUSTUM_P_ALL);

	push	eax
	call	ebx

; 435  : 	r_dsgraph_render_subspace		(_sector,&temp,mCombined,_cop,_dynamic,_precise_portals);

	push	1
	push	ecx
	lea	eax, DWORD PTR _L_pos$3[esp+752]
	mov	ecx, OFFSET ?RImplementation@@3VCRender@@A ; RImplementation
	push	eax
	lea	eax, DWORD PTR _L_combine$4[esp+756]
	push	eax
	lea	eax, DWORD PTR _temp$5[esp+760]
	push	eax
	push	edi
	call	?r_dsgraph_render_subspace@R_dsgraph_structure@@QAEXPAVIRender_Sector@@PAVCFrustum@@AAU?$_matrix@M@@AAU?$_vector3@M@@HH@Z ; R_dsgraph_structure::r_dsgraph_render_subspace
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightPPA.cpp

; 277  : 		F.CreateFromMatrix	(L_combine,FRUSTUM_P_ALL);

	push	63					; 0000003fH
	lea	eax, DWORD PTR _L_combine$4[esp+748]
	push	eax
	lea	ecx, DWORD PTR _F$6[esp+752]
	call	ebx

; 278  : 		bHUD				= F.testSphere_dirty	(Device.vCameraPosition,2.f);

	mov	eax, DWORD PTR __imp_?Device@@3VCRenderDevice@@A
	fld	DWORD PTR __real@40000000
	add	eax, 488				; 000001e8H
	push	ecx
	fstp	DWORD PTR [esp]
	push	eax
	lea	ecx, DWORD PTR _F$6[esp+752]
	call	DWORD PTR __imp_?testSphere_dirty@CFrustum@@QBEHAAU?$_vector3@M@@M@Z

; 279  : 		// if (bHUD)		Msg	("HUD");
; 280  : 
; 281  : 		//		4. Dump sorting tree
; 282  : 		//	RCache.set_ClipPlanes					(true,	&L_combine);
; 283  : 		RCache.set_Constants	((R_constant_table*)0);

	mov	ecx, DWORD PTR __imp_?RCache@@3VCBackend@@A
	mov	edi, eax
	push	0
	call	DWORD PTR __imp_?set_Constants@CBackend@@QAEXPAVR_constant_table@@@Z

; 284  : 		if (bHUD)	g_pGameLevel->pHUD->Render_Last		();	

	test	edi, edi
	je	SHORT $LN10@render_spo
	mov	eax, DWORD PTR __imp_?g_pGameLevel@@3PAVIGame_Level@@A
	mov	eax, DWORD PTR [eax]
	mov	ecx, DWORD PTR [eax+280]
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+16]
	push	1
	push	0
	mov	ecx, OFFSET ?RImplementation@@3VCRender@@A ; RImplementation
	call	?r_dsgraph_render_graph@R_dsgraph_structure@@QAEXI_N@Z ; R_dsgraph_structure::r_dsgraph_render_graph

; 286  : 		if (bHUD)	RImplementation.r_dsgraph_render_hud();	

	mov	ecx, OFFSET ?RImplementation@@3VCRender@@A ; RImplementation
	call	?r_dsgraph_render_hud@R_dsgraph_structure@@QAEXXZ ; R_dsgraph_structure::r_dsgraph_render_hud
	jmp	SHORT $LN204@render_spo
$LN10@render_spo:

; 285  : 		RImplementation.r_dsgraph_render_graph			(0);

	push	1
	push	0
	mov	ecx, OFFSET ?RImplementation@@3VCRender@@A ; RImplementation
	call	?r_dsgraph_render_graph@R_dsgraph_structure@@QAEXI_N@Z ; R_dsgraph_structure::r_dsgraph_render_graph
$LN204@render_spo:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 74   :         ++_Ptr;

	fld1
	fld	DWORD PTR __real@3dcccccd
	mov	eax, DWORD PTR _this$1$[esp+744]
	fld	DWORD PTR __real@3f000000
	movss	xmm3, DWORD PTR tv4462[esp+744]
	movss	xmm4, DWORD PTR __real@3f800000
$LN2@render_spo:
	add	esi, 4

; 150  :         return _Ptr == _Right._Ptr;

	cmp	esi, DWORD PTR [eax+44]
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightPPA.cpp

; 223  : 	for (xr_vector<light*>::iterator it=selected_spot.begin(); it!=selected_spot.end(); it++)

	jne	$LN4@render_spo
	fstp	ST(2)
	fstp	ST(0)
	fstp	ST(0)
$LN3@render_spo:

; 287  : 		//	RCache.set_ClipPlanes					(false,	&L_combine);
; 288  : 	}
; 289  : 	//		??? grass ???
; 290  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?render_spot@CLightR_Manager@@QAEXXZ ENDP		; CLightR_Manager::render_spot
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightPPA.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightPPA.cpp
;	COMDAT ??_GCLightR_Manager@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCLightR_Manager@@UAEPAXI@Z PROC			; CLightR_Manager::`scalar deleting destructor', COMDAT
; _this$ = ecx

; 326  : {

	push	esi
	mov	esi, ecx
	mov	DWORD PTR [esi], OFFSET ??_7CLightR_Manager@@6B@
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [esi+40]
	test	eax, eax
	je	SHORT $LN11@scalar
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi+40], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+44], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+48], 0
$LN11@scalar:

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [esi+28]
	test	eax, eax
	je	SHORT $LN23@scalar
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi+28], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+32], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+36], 0
$LN23@scalar:
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightPPA.cpp

; 327  : }

	lea	ecx, DWORD PTR [esi+4]
	call	DWORD PTR __imp_??1xrXRC@@QAE@XZ
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN30@scalar
	push	52					; 00000034H
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN30@scalar:
	mov	eax, esi
	pop	esi
	ret	4
??_GCLightR_Manager@@UAEPAXI@Z ENDP			; CLightR_Manager::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightPPA.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightPPA.cpp
_TEXT	SEGMENT
??1CLightR_Manager@@UAE@XZ PROC				; CLightR_Manager::~CLightR_Manager
; _this$ = ecx

; 326  : {

	push	esi
	mov	esi, ecx
	mov	DWORD PTR [esi], OFFSET ??_7CLightR_Manager@@6B@
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [esi+40]
	test	eax, eax
	je	SHORT $LN8@CLightR_Ma
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi+40], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+44], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+48], 0
$LN8@CLightR_Ma:

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [esi+28]
	test	eax, eax
	je	SHORT $LN20@CLightR_Ma
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi+28], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+32], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+36], 0
$LN20@CLightR_Ma:
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightPPA.cpp

; 327  : }

	lea	ecx, DWORD PTR [esi+4]
	pop	esi
	jmp	DWORD PTR __imp_??1xrXRC@@QAE@XZ
??1CLightR_Manager@@UAE@XZ ENDP				; CLightR_Manager::~CLightR_Manager
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVlight@@@std@@@std@@@std@@QAE?AV01@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$dead$ = 12					; size = 4
??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVlight@@@std@@@std@@@std@@QAE?AV01@H@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<light *> > >::operator++, COMDAT
; _this$ = ecx

; 281  :         _Vector_iterator _Tmp = *this;

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx

; 74   :         ++_Ptr;

	add	edx, 4
	mov	DWORD PTR [ecx], edx

; 282  :         _Mybase::operator++();
; 283  :         return _Tmp;
; 284  :     }

	ret	8
??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVlight@@@std@@@std@@@std@@QAE?AV01@H@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<light *> > >::operator++
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVlight@@@std@@@std@@@std@@QBEAAPAVlight@@XZ
_TEXT	SEGMENT
??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVlight@@@std@@@std@@@std@@QBEAAPAVlight@@XZ PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<light *> > >::operator*, COMDAT
; _this$ = ecx

; 261  :         return const_cast<reference>(_Mybase::operator*());

	mov	eax, DWORD PTR [ecx]

; 262  :     }

	ret	0
??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVlight@@@std@@@std@@@std@@QBEAAPAVlight@@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<light *> > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVlight@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVlight@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<light *> > >::operator!=, COMDAT
; _this$ = ecx

; 160  :         return !(*this == _Right);

	mov	eax, DWORD PTR __Right$[esp-4]
	mov	ecx, DWORD PTR [ecx]
	cmp	ecx, DWORD PTR [eax]
	setne	al

; 161  :     }

	ret	4
??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVlight@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<light *> > >::operator!=
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?size@?$xr_vector@PAVlight@@V?$xalloc@PAVlight@@@@@@QBEIXZ
_TEXT	SEGMENT
?size@?$xr_vector@PAVlight@@V?$xalloc@PAVlight@@@@@@QBEIXZ PROC ; xr_vector<light *,xalloc<light *> >::size, COMDAT
; _this$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	eax, DWORD PTR [ecx+4]
	sub	eax, DWORD PTR [ecx]
	sar	eax, 2
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 125  : 	u32		size				() const							{ return (u32)inherited::size();} 

	ret	0
?size@?$xr_vector@PAVlight@@V?$xalloc@PAVlight@@@@@@QBEIXZ ENDP ; xr_vector<light *,xalloc<light *> >::size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?end@?$vector@PAVlight@@V?$xalloc@PAVlight@@@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVlight@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@PAVlight@@V?$xalloc@PAVlight@@@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVlight@@@std@@@std@@@2@XZ PROC ; std::vector<light *,xalloc<light *> >::end, COMDAT
; _this$ = ecx

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	ecx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax], ecx

; 1472 :         auto& _My_data = _Mypair._Myval2;
; 1473 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));
; 1474 :     }

	ret	4
?end@?$vector@PAVlight@@V?$xalloc@PAVlight@@@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVlight@@@std@@@std@@@2@XZ ENDP ; std::vector<light *,xalloc<light *> >::end
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?begin@?$vector@PAVlight@@V?$xalloc@PAVlight@@@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVlight@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@PAVlight@@V?$xalloc@PAVlight@@@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVlight@@@std@@@std@@@2@XZ PROC ; std::vector<light *,xalloc<light *> >::begin, COMDAT
; _this$ = ecx

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	ecx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], ecx

; 1462 :         auto& _My_data = _Mypair._Myval2;
; 1463 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));
; 1464 :     }

	ret	4
?begin@?$vector@PAVlight@@V?$xalloc@PAVlight@@@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVlight@@@std@@@std@@@2@XZ ENDP ; std::vector<light *,xalloc<light *> >::begin
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?push_back@?$vector@PAVlight@@V?$xalloc@PAVlight@@@@@std@@QAEXABQAVlight@@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?push_back@?$vector@PAVlight@@V?$xalloc@PAVlight@@@@@std@@QAEXABQAVlight@@@Z PROC ; std::vector<light *,xalloc<light *> >::push_back, COMDAT
; _this$ = ecx

; 730  :         if (_Mylast != _My_data._Myend) {

	mov	edx, DWORD PTR [ecx+4]
	cmp	edx, DWORD PTR [ecx+8]
	je	SHORT $LN4@push_back

; 713  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

	mov	eax, DWORD PTR __Val$[esp-4]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edx], eax

; 714  :         _Orphan_range(_Mylast, _Mylast);
; 715  :         _Ty& _Result = *_Mylast;
; 716  :         ++_Mylast;

	add	DWORD PTR [ecx+4], 4

; 743  :         emplace_back(_Val);
; 744  :     }

	ret	4
$LN4@push_back:

; 734  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	push	DWORD PTR __Val$[esp-4]
	push	edx
	call	??$_Emplace_reallocate@ABQAVlight@@@?$vector@PAVlight@@V?$xalloc@PAVlight@@@@@std@@QAEPAPAVlight@@QAPAV2@ABQAV2@@Z ; std::vector<light *,xalloc<light *> >::_Emplace_reallocate<light * const &>

; 743  :         emplace_back(_Val);
; 744  :     }

	ret	4
?push_back@?$vector@PAVlight@@V?$xalloc@PAVlight@@@@@std@@QAEXABQAVlight@@@Z ENDP ; std::vector<light *,xalloc<light *> >::push_back
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??$emplace_back@ABQAVlight@@@?$vector@PAVlight@@V?$xalloc@PAVlight@@@@@std@@QAE?A_TABQAVlight@@@Z
_TEXT	SEGMENT
_<_Val_0>$ = 8						; size = 4
??$emplace_back@ABQAVlight@@@?$vector@PAVlight@@V?$xalloc@PAVlight@@@@@std@@QAE?A_TABQAVlight@@@Z PROC ; std::vector<light *,xalloc<light *> >::emplace_back<light * const &>, COMDAT
; _this$ = ecx

; 727  :         // insert by perfectly forwarding into element at end, provide strong guarantee
; 728  :         auto& _My_data   = _Mypair._Myval2;
; 729  :         pointer& _Mylast = _My_data._Mylast;
; 730  :         if (_Mylast != _My_data._Myend) {

	mov	edx, DWORD PTR [ecx+4]
	cmp	edx, DWORD PTR [ecx+8]
	je	SHORT $LN2@emplace_ba

; 713  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

	mov	eax, DWORD PTR _<_Val_0>$[esp-4]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edx], eax

; 714  :         _Orphan_range(_Mylast, _Mylast);
; 715  :         _Ty& _Result = *_Mylast;
; 716  :         ++_Mylast;

	add	DWORD PTR [ecx+4], 4

; 735  : #if _HAS_CXX17
; 736  :         return _Result;
; 737  : #else // ^^^ _HAS_CXX17 ^^^ // vvv !_HAS_CXX17 vvv
; 738  :         (void) _Result;
; 739  : #endif // _HAS_CXX17
; 740  :     }

	ret	4
$LN2@emplace_ba:

; 731  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);
; 732  :         }
; 733  : 
; 734  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	push	DWORD PTR _<_Val_0>$[esp-4]
	push	edx
	call	??$_Emplace_reallocate@ABQAVlight@@@?$vector@PAVlight@@V?$xalloc@PAVlight@@@@@std@@QAEPAPAVlight@@QAPAV2@ABQAV2@@Z ; std::vector<light *,xalloc<light *> >::_Emplace_reallocate<light * const &>

; 735  : #if _HAS_CXX17
; 736  :         return _Result;
; 737  : #else // ^^^ _HAS_CXX17 ^^^ // vvv !_HAS_CXX17 vvv
; 738  :         (void) _Result;
; 739  : #endif // _HAS_CXX17
; 740  :     }

	ret	4
??$emplace_back@ABQAVlight@@@?$vector@PAVlight@@V?$xalloc@PAVlight@@@@@std@@QAE?A_TABQAVlight@@@Z ENDP ; std::vector<light *,xalloc<light *> >::emplace_back<light * const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??$_Emplace_back_with_unused_capacity@ABQAVlight@@@?$vector@PAVlight@@V?$xalloc@PAVlight@@@@@std@@AAE?A_TABQAVlight@@@Z
_TEXT	SEGMENT
_<_Val_0>$ = 8						; size = 4
??$_Emplace_back_with_unused_capacity@ABQAVlight@@@?$vector@PAVlight@@V?$xalloc@PAVlight@@@@@std@@AAE?A_TABQAVlight@@@Z PROC ; std::vector<light *,xalloc<light *> >::_Emplace_back_with_unused_capacity<light * const &>, COMDAT
; _this$ = ecx

; 709  :         // insert by perfectly forwarding into element at end, provide strong guarantee
; 710  :         auto& _My_data   = _Mypair._Myval2;
; 711  :         pointer& _Mylast = _My_data._Mylast;
; 712  :         _STL_INTERNAL_CHECK(_Mylast != _My_data._Myend); // check that we have unused capacity
; 713  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _<_Val_0>$[esp-4]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edx], eax

; 714  :         _Orphan_range(_Mylast, _Mylast);
; 715  :         _Ty& _Result = *_Mylast;
; 716  :         ++_Mylast;

	add	DWORD PTR [ecx+4], 4

; 717  : #if _HAS_CXX17
; 718  :         return _Result;
; 719  : #else // ^^^ _HAS_CXX17 ^^^ // vvv !_HAS_CXX17 vvv
; 720  :         (void) _Result;
; 721  : #endif // _HAS_CXX17
; 722  :     }

	ret	4
??$_Emplace_back_with_unused_capacity@ABQAVlight@@@?$vector@PAVlight@@V?$xalloc@PAVlight@@@@@std@@AAE?A_TABQAVlight@@@Z ENDP ; std::vector<light *,xalloc<light *> >::_Emplace_back_with_unused_capacity<light * const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVlight@@@std@@@std@@@std@@QAE@PAPAVlight@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
___param0$ = 8						; size = 4
___param1$dead$ = 12					; size = 4
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVlight@@@std@@@std@@@std@@QAE@PAPAVlight@@PBU_Container_base0@1@@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<light *> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<light *> > >, COMDAT
; _this$ = ecx

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	eax, DWORD PTR ___param0$[esp-4]
	mov	DWORD PTR [ecx], eax
	mov	eax, ecx
	ret	8
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVlight@@@std@@@std@@@std@@QAE@PAPAVlight@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<light *> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<light *> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVlight@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVlight@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<light *> > >::operator==, COMDAT
; _this$ = ecx

; 149  :         _Compat(_Right);
; 150  :         return _Ptr == _Right._Ptr;

	mov	eax, DWORD PTR __Right$[esp-4]
	mov	ecx, DWORD PTR [ecx]
	cmp	ecx, DWORD PTR [eax]
	sete	al

; 151  :     }

	ret	4
??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVlight@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<light *> > >::operator==
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVlight@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVlight@@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<light *> > >::operator++, COMDAT
; _this$ = ecx

; 68   : #if _ITERATOR_DEBUG_LEVEL != 0
; 69   :         const auto _Mycont = static_cast<const _Myvec*>(this->_Getcont());
; 70   :         _STL_VERIFY(_Ptr, "can't increment value-initialized vector iterator");
; 71   :         _STL_VERIFY(_Ptr < _Mycont->_Mylast, "can't increment vector iterator past end");
; 72   : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 73   : 
; 74   :         ++_Ptr;

	add	DWORD PTR [ecx], 4

; 75   :         return *this;

	mov	eax, ecx

; 76   :     }

	ret	0
??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVlight@@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<light *> > >::operator++
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVlight@@@std@@@std@@@std@@QBEABQAVlight@@XZ
_TEXT	SEGMENT
??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVlight@@@std@@@std@@@std@@QBEABQAVlight@@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<light *> > >::operator*, COMDAT
; _this$ = ecx

; 46   : #if _ITERATOR_DEBUG_LEVEL != 0
; 47   :         const auto _Mycont = static_cast<const _Myvec*>(this->_Getcont());
; 48   :         _STL_VERIFY(_Ptr, "can't dereference value-initialized vector iterator");
; 49   :         _STL_VERIFY(
; 50   :             _Mycont->_Myfirst <= _Ptr && _Ptr < _Mycont->_Mylast, "can't dereference out of range vector iterator");
; 51   : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 52   : 
; 53   :         return *_Ptr;

	mov	eax, DWORD PTR [ecx]

; 54   :     }

	ret	0
??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVlight@@@std@@@std@@@std@@QBEABQAVlight@@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<light *> > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVlight@@@std@@@std@@@std@@QAE@PAPAVlight@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Pvector$dead$ = 12					; size = 4
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVlight@@@std@@@std@@@std@@QAE@PAPAVlight@@PBU_Container_base0@1@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<light *> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<light *> > >, COMDAT
; _this$ = ecx

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	eax, DWORD PTR __Parg$[esp-4]
	mov	DWORD PTR [ecx], eax

; 42   :         this->_Adopt(_Pvector);
; 43   :     }

	mov	eax, ecx
	ret	8
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVlight@@@std@@@std@@@std@@QAE@PAPAVlight@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<light *> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<light *> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Orphan_range@?$vector@PAVlight@@V?$xalloc@PAVlight@@@@@std@@ABEXPAPAVlight@@0@Z
_TEXT	SEGMENT
___formal$dead$ = 8					; size = 4
___formal$dead$ = 12					; size = 4
?_Orphan_range@?$vector@PAVlight@@V?$xalloc@PAVlight@@@@@std@@ABEXPAPAVlight@@0@Z PROC ; std::vector<light *,xalloc<light *> >::_Orphan_range, COMDAT
; _this$dead$ = ecx

; 1801 :     _CONSTEXPR20_CONTAINER void _Orphan_range(pointer, pointer) const {}

	ret	8
?_Orphan_range@?$vector@PAVlight@@V?$xalloc@PAVlight@@@@@std@@ABEXPAPAVlight@@0@Z ENDP ; std::vector<light *,xalloc<light *> >::_Orphan_range
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?size@?$vector@PAVlight@@V?$xalloc@PAVlight@@@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@PAVlight@@V?$xalloc@PAVlight@@@@@std@@QBEIXZ PROC ; std::vector<light *,xalloc<light *> >::size, COMDAT
; _this$ = ecx

; 1535 :         auto& _My_data = _Mypair._Myval2;
; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	eax, DWORD PTR [ecx+4]
	sub	eax, DWORD PTR [ecx]
	sar	eax, 2

; 1537 :     }

	ret	0
?size@?$vector@PAVlight@@V?$xalloc@PAVlight@@@@@std@@QBEIXZ ENDP ; std::vector<light *,xalloc<light *> >::size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVlight@@@std@@@std@@@std@@QBEXABV12@@Z
_TEXT	SEGMENT
__Right$dead$ = 8					; size = 4
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVlight@@@std@@@std@@@std@@QBEXABV12@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<light *> > >::_Compat, COMDAT
; _this$dead$ = ecx

; 182  :         // test for compatible iterator pair
; 183  : #if _ITERATOR_DEBUG_LEVEL == 0
; 184  :         (void) _Right;
; 185  : #else // ^^^ _ITERATOR_DEBUG_LEVEL == 0 ^^^ // vvv _ITERATOR_DEBUG_LEVEL != 0 vvv
; 186  :         _STL_VERIFY(this->_Getcont() == _Right._Getcont(), "vector iterators incompatible");
; 187  : #endif // _ITERATOR_DEBUG_LEVEL == 0
; 188  :     }

	ret	4
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVlight@@@std@@@std@@@std@@QBEXABV12@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<light *> > >::_Compat
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef
;	COMDAT ??$addressof@V?$_Vector_val@U?$_Simple_types@PAVlight@@@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@PAVlight@@@std@@@0@AAV10@@Z
_TEXT	SEGMENT
??$addressof@V?$_Vector_val@U?$_Simple_types@PAVlight@@@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@PAVlight@@@std@@@0@AAV10@@Z PROC ; std::addressof<std::_Vector_val<std::_Simple_types<light *> > >, COMDAT
; __Val$ = ecx

; 253  :     return __builtin_addressof(_Val);

	mov	eax, ecx

; 254  : }

	ret	0
??$addressof@V?$_Vector_val@U?$_Simple_types@PAVlight@@@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@PAVlight@@@std@@@0@AAV10@@Z ENDP ; std::addressof<std::_Vector_val<std::_Simple_types<light *> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\type_traits
;	COMDAT ??$forward@ABQAVlight@@@std@@YAABQAVlight@@ABQAV1@@Z
_TEXT	SEGMENT
??$forward@ABQAVlight@@@std@@YAABQAVlight@@ABQAV1@@Z PROC ; std::forward<light * const &>, COMDAT
; __Arg$ = ecx

; 1386 :     return static_cast<_Ty&&>(_Arg);

	mov	eax, ecx

; 1387 : }

	ret	0
??$forward@ABQAVlight@@@std@@YAABQAVlight@@ABQAV1@@Z ENDP ; std::forward<light * const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$construct@PAVlight@@ABQAV1@@?$_Normal_allocator_traits@V?$xalloc@PAVlight@@@@@std@@SAXAAV?$xalloc@PAVlight@@@@PAPAVlight@@ABQAV3@@Z
_TEXT	SEGMENT
_<_Args_0>$ = 8						; size = 4
??$construct@PAVlight@@ABQAV1@@?$_Normal_allocator_traits@V?$xalloc@PAVlight@@@@@std@@SAXAAV?$xalloc@PAVlight@@@@PAPAVlight@@ABQAV3@@Z PROC ; std::_Normal_allocator_traits<xalloc<light *> >::construct<light *,light * const &>, COMDAT
; __Al$dead$ = ecx
; __Ptr$ = edx

; 565  :         if constexpr (_Uses_default_construct<_Alloc, _Ty*, _Types...>::value) {
; 566  :             (void) _Al; // TRANSITION, DevCom-1004719
; 567  : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 568  :             _STD construct_at(_Ptr, _STD forward<_Types>(_Args)...);
; 569  : #else // __cpp_lib_constexpr_dynamic_alloc
; 570  :             ::new (static_cast<void*>(_Ptr)) _Ty(_STD forward<_Types>(_Args)...);
; 571  : #endif // __cpp_lib_constexpr_dynamic_alloc
; 572  :         } else {
; 573  :             _Al.construct(_Ptr, _STD forward<_Types>(_Args)...);

	mov	eax, DWORD PTR _<_Args_0>$[esp-4]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edx], eax

; 574  :         }
; 575  :     }

	ret	0
??$construct@PAVlight@@ABQAV1@@?$_Normal_allocator_traits@V?$xalloc@PAVlight@@@@@std@@SAXAAV?$xalloc@PAVlight@@@@PAPAVlight@@ABQAV3@@Z ENDP ; std::_Normal_allocator_traits<xalloc<light *> >::construct<light *,light * const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??$_Emplace_reallocate@ABQAVlight@@@?$vector@PAVlight@@V?$xalloc@PAVlight@@@@@std@@QAEPAPAVlight@@QAPAV2@ABQAV2@@Z
_TEXT	SEGMENT
__Backout$2 = -76					; size = 12
__Backout$3 = -64					; size = 12
__Backout$4 = -52					; size = 12
__UFirst$5 = -40					; size = 4
__UFirst$6 = -36					; size = 4
__UFirst$7 = -32					; size = 4
__Newvec$ = -28						; size = 4
__Newcapacity$1$ = -24					; size = 4
__Newsize$1$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
tv555 = 8						; size = 4
__Whereptr$ = 8						; size = 4
_<_Val_0>$ = 12						; size = 4
??$_Emplace_reallocate@ABQAVlight@@@?$vector@PAVlight@@V?$xalloc@PAVlight@@@@@std@@QAEPAPAVlight@@QAPAV2@ABQAV2@@Z PROC ; std::vector<light *,xalloc<light *> >::_Emplace_reallocate<light * const &>, COMDAT
; _this$ = ecx

; 752  :     _CONSTEXPR20_CONTAINER pointer _Emplace_reallocate(const pointer _Whereptr, _Valty&&... _Val) {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Emplace_reallocate@ABQAVlight@@@?$vector@PAVlight@@V?$xalloc@PAVlight@@@@@std@@QAEPAPAVlight@@QAPAV2@ABQAV2@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	edi, ecx

; 753  :         // reallocate and insert by perfectly forwarding _Val at _Whereptr
; 754  :         _Alty& _Al        = _Getal();
; 755  :         auto& _My_data    = _Mypair._Myval2;
; 756  :         pointer& _Myfirst = _My_data._Myfirst;
; 757  :         pointer& _Mylast  = _My_data._Mylast;
; 758  : 
; 759  :         _STL_INTERNAL_CHECK(_Mylast == _My_data._Myend); // check that we have no unused capacity
; 760  : 
; 761  :         const auto _Whereoff = static_cast<size_type>(_Whereptr - _Myfirst);

	mov	edx, DWORD PTR [edi]
	mov	esi, DWORD PTR __Whereptr$[ebp]
	mov	ebx, esi
	sub	ebx, edx
	sar	ebx, 2

; 762  :         const auto _Oldsize  = static_cast<size_type>(_Mylast - _Myfirst);

	mov	eax, DWORD PTR [edi+4]
	sub	eax, edx
	sar	eax, 2

; 763  : 
; 764  :         if (_Oldsize == max_size()) {

	cmp	eax, 1073741823				; 3fffffffH
	je	$LN83@Emplace_re

; 766  :         }
; 767  : 
; 768  :         const size_type _Newsize     = _Oldsize + 1;

	inc	eax
	mov	DWORD PTR __Newsize$1$[ebp], eax

; 1546 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	ecx, DWORD PTR [edi+8]
	sub	ecx, edx
	sar	ecx, 2

; 1675 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	edx, ecx
	shr	edx, 1
	mov	eax, 1073741823				; 3fffffffH
	sub	eax, edx
	cmp	ecx, eax
	jbe	SHORT $LN12@Emplace_re

; 1676 :             return _Max; // geometric growth would overflow

	mov	eax, 1073741823				; 3fffffffH
	jmp	SHORT $LN81@Emplace_re
$LN12@Emplace_re:

; 1677 :         }
; 1678 : 
; 1679 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	lea	eax, DWORD PTR [edx+ecx]

; 1680 : 
; 1681 :         if (_Geometric < _Newsize) {

	cmp	eax, DWORD PTR __Newsize$1$[ebp]
	cmovb	eax, DWORD PTR __Newsize$1$[ebp]
$LN81@Emplace_re:
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	mov	DWORD PTR __Newcapacity$1$[ebp], eax
	shl	eax, 2
	push	eax
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 771  :         const pointer _Newvec           = _Al.allocate(_Newcapacity);

	mov	edx, eax
	mov	DWORD PTR __Newvec$[ebp], edx

; 772  :         const pointer _Constructed_last = _Newvec + _Whereoff + 1;
; 773  :         pointer _Constructed_first      = _Constructed_last;
; 774  : 
; 775  :         _TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 776  :         _Alty_traits::construct(_Al, _Unfancy(_Newvec + _Whereoff), _STD forward<_Valty>(_Val)...);

	lea	ecx, DWORD PTR [edx+ebx*4]
	mov	DWORD PTR tv555[ebp], ecx
	mov	eax, DWORD PTR _<_Val_0>$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax

; 777  :         _Constructed_first = _Newvec + _Whereoff;
; 778  : 
; 779  :         if (_Whereptr == _Mylast) { // at back, provide strong guarantee

	mov	ebx, DWORD PTR [edi+4]
	mov	ecx, DWORD PTR [edi]
	cmp	esi, ebx
	jne	SHORT $LN4@Emplace_re
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1703 :     auto _UFirst      = _Get_unwrapped(_First);

	mov	DWORD PTR __UFirst$7[ebp], ecx

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	DWORD PTR __Backout$4[ebp], edx
	mov	DWORD PTR __Backout$4[ebp+4], edx
	mov	DWORD PTR __Backout$4[ebp+8], edi
	npad	1
$LL28@Emplace_re:

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	ecx, ebx
	je	SHORT $LN27@Emplace_re

; 1620 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax

; 1621 :         ++_Last;

	add	edx, 4
	mov	DWORD PTR __Backout$4[ebp+4], edx

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	add	ecx, 4
	mov	DWORD PTR __UFirst$7[ebp], ecx
	jmp	SHORT $LL28@Emplace_re
$LN27@Emplace_re:

; 1625 :         _First = _Last;

	mov	DWORD PTR __Backout$4[ebp], edx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 781  :         } else { // provide basic guarantee

	mov	ebx, DWORD PTR tv555[ebp]
	jmp	SHORT $LN5@Emplace_re
$LN4@Emplace_re:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1703 :     auto _UFirst      = _Get_unwrapped(_First);

	mov	DWORD PTR __UFirst$6[ebp], ecx

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	DWORD PTR __Backout$3[ebp], edx
	mov	DWORD PTR __Backout$3[ebp+4], edx
	mov	DWORD PTR __Backout$3[ebp+8], edi
	npad	6
$LL41@Emplace_re:

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	ecx, esi
	je	SHORT $LN40@Emplace_re

; 1620 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax

; 1621 :         ++_Last;

	add	edx, 4
	mov	DWORD PTR __Backout$3[ebp+4], edx

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	add	ecx, 4
	mov	DWORD PTR __UFirst$6[ebp], ecx
	jmp	SHORT $LL41@Emplace_re
$LN40@Emplace_re:

; 1625 :         _First = _Last;

	mov	DWORD PTR __Backout$3[ebp], edx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 784  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

	mov	ebx, DWORD PTR tv555[ebp]
	lea	ecx, DWORD PTR [ebx+4]

; 1646 :         return _Uninitialized_move(_First, _Last, _Dest, _Getal());

	mov	edx, DWORD PTR [edi+4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1703 :     auto _UFirst      = _Get_unwrapped(_First);

	mov	DWORD PTR __UFirst$5[ebp], esi

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	DWORD PTR __Backout$2[ebp], ecx
	mov	DWORD PTR __Backout$2[ebp+4], ecx
	mov	DWORD PTR __Backout$2[ebp+8], edi
	npad	2
$LL54@Emplace_re:

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	esi, edx
	je	SHORT $LN53@Emplace_re

; 1620 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [ecx], eax

; 1621 :         ++_Last;

	add	ecx, 4
	mov	DWORD PTR __Backout$2[ebp+4], ecx

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	add	esi, 4
	mov	DWORD PTR __UFirst$5[ebp], esi
	jmp	SHORT $LL54@Emplace_re
$LN53@Emplace_re:

; 1625 :         _First = _Last;

	mov	DWORD PTR __Backout$2[ebp], ecx
$LN5@Emplace_re:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
	mov	DWORD PTR __$EHRec$[ebp+12], -1

; 1732 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [edi]
	test	eax, eax
	je	SHORT $LN68@Emplace_re
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	push	eax
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN68@Emplace_re:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1737 :         _Myfirst = _Newvec;

	mov	eax, DWORD PTR __Newvec$[ebp]
	mov	DWORD PTR [edi], eax

; 1738 :         _Mylast  = _Newvec + _Newsize;

	mov	ecx, DWORD PTR __Newsize$1$[ebp]
	lea	ecx, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR [edi+4], ecx

; 1739 :         _Myend   = _Newvec + _Newcapacity;

	mov	ecx, DWORD PTR __Newcapacity$1$[ebp]
	lea	ecx, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR [edi+8], ecx

; 790  :         _CATCH_END
; 791  : 
; 792  :         _Change_array(_Newvec, _Newsize, _Newcapacity);
; 793  :         return _Newvec + _Whereoff;

	mov	eax, ebx

; 794  :     }

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
__catch$??$_Emplace_reallocate@ABQAVlight@@@?$vector@PAVlight@@V?$xalloc@PAVlight@@@@@std@@QAEPAPAVlight@@QAPAV2@ABQAV2@@Z$0:

; 785  :         }
; 786  :         _CATCH_ALL
; 787  :         _Destroy(_Constructed_first, _Constructed_last);
; 788  :         _Al.deallocate(_Newvec, _Newcapacity);

	push	ecx
	push	DWORD PTR __Newvec$[ebp]
	call	?deallocate@?$xalloc@PAVlight@@@@QBEXPAPAVlight@@I@Z ; xalloc<light *>::deallocate

; 789  :         _RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$LN83@Emplace_re:

; 765  :             _Xlength();

	call	?_Xlength@?$vector@PAVlight@@V?$xalloc@PAVlight@@@@@std@@CAXXZ ; std::vector<light *,xalloc<light *> >::_Xlength
$LN80@Emplace_re:
	int	3
	int	3
	int	3
	int	3
	int	3
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Emplace_reallocate@ABQAVlight@@@?$vector@PAVlight@@V?$xalloc@PAVlight@@@@@std@@QAEPAPAVlight@@QAPAV2@ABQAV2@@Z:
	npad	1
	npad	1
	mov	eax, OFFSET __ehfuncinfo$??$_Emplace_reallocate@ABQAVlight@@@?$vector@PAVlight@@V?$xalloc@PAVlight@@@@@std@@QAEPAPAVlight@@QAPAV2@ABQAV2@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Emplace_reallocate@ABQAVlight@@@?$vector@PAVlight@@V?$xalloc@PAVlight@@@@@std@@QAEPAPAVlight@@QAPAV2@ABQAV2@@Z ENDP ; std::vector<light *,xalloc<light *> >::_Emplace_reallocate<light * const &>
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Xlength@?$vector@PAVlight@@V?$xalloc@PAVlight@@@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@PAVlight@@V?$xalloc@PAVlight@@@@@std@@CAXXZ PROC ; std::vector<light *,xalloc<light *> >::_Xlength, COMDAT

; 1761 :         _Xlength_error("vector too long");

	push	OFFSET ??_C@_0BA@FOIKENOD@vector?5too?5long@
	call	DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN3@Xlength:
	int	3
?_Xlength@?$vector@PAVlight@@V?$xalloc@PAVlight@@@@@std@@CAXXZ ENDP ; std::vector<light *,xalloc<light *> >::_Xlength
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Change_array@?$vector@PAVlight@@V?$xalloc@PAVlight@@@@@std@@AAEXQAPAVlight@@II@Z
_TEXT	SEGMENT
__Newvec$ = 8						; size = 4
__Newsize$ = 12						; size = 4
__Newcapacity$ = 16					; size = 4
?_Change_array@?$vector@PAVlight@@V?$xalloc@PAVlight@@@@@std@@AAEXQAPAVlight@@II@Z PROC ; std::vector<light *,xalloc<light *> >::_Change_array, COMDAT
; _this$ = ecx

; 1723 :         const pointer _Newvec, const size_type _Newsize, const size_type _Newcapacity) {

	push	esi
	mov	esi, ecx

; 1724 :         // orphan all iterators, discard old array, acquire new array
; 1725 :         auto& _My_data    = _Mypair._Myval2;
; 1726 :         pointer& _Myfirst = _My_data._Myfirst;
; 1727 :         pointer& _Mylast  = _My_data._Mylast;
; 1728 :         pointer& _Myend   = _My_data._Myend;
; 1729 : 
; 1730 :         _My_data._Orphan_all();
; 1731 : 
; 1732 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN7@Change_arr
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN7@Change_arr:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1737 :         _Myfirst = _Newvec;

	mov	ecx, DWORD PTR __Newvec$[esp]

; 1738 :         _Mylast  = _Newvec + _Newsize;

	mov	eax, DWORD PTR __Newsize$[esp]
	mov	DWORD PTR [esi], ecx
	lea	eax, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR [esi+4], eax

; 1739 :         _Myend   = _Newvec + _Newcapacity;

	mov	eax, DWORD PTR __Newcapacity$[esp]
	lea	eax, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR [esi+8], eax
	pop	esi

; 1740 :     }

	ret	12					; 0000000cH
?_Change_array@?$vector@PAVlight@@V?$xalloc@PAVlight@@@@@std@@AAEXQAPAVlight@@II@Z ENDP ; std::vector<light *,xalloc<light *> >::_Change_array
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Calculate_growth@?$vector@PAVlight@@V?$xalloc@PAVlight@@@@@std@@ABEII@Z
_TEXT	SEGMENT
__Newsize$ = 8						; size = 4
?_Calculate_growth@?$vector@PAVlight@@V?$xalloc@PAVlight@@@@@std@@ABEII@Z PROC ; std::vector<light *,xalloc<light *> >::_Calculate_growth, COMDAT
; _this$ = ecx

; 1546 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	edx, DWORD PTR [ecx+8]
	sub	edx, DWORD PTR [ecx]

; 1671 :         // given _Oldcapacity and _Newsize, calculate geometric growth
; 1672 :         const size_type _Oldcapacity = capacity();
; 1673 :         const auto _Max              = max_size();
; 1674 : 
; 1675 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	ecx, 1073741823				; 3fffffffH

; 1546 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	sar	edx, 2

; 1670 :     _CONSTEXPR20_CONTAINER size_type _Calculate_growth(const size_type _Newsize) const {

	push	esi

; 1671 :         // given _Oldcapacity and _Newsize, calculate geometric growth
; 1672 :         const size_type _Oldcapacity = capacity();
; 1673 :         const auto _Max              = max_size();
; 1674 : 
; 1675 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	esi, edx
	shr	esi, 1
	sub	ecx, esi
	cmp	edx, ecx
	jbe	SHORT $LN2@Calculate_

; 1676 :             return _Max; // geometric growth would overflow

	mov	eax, 1073741823				; 3fffffffH
	pop	esi

; 1682 :             return _Newsize; // geometric growth would be insufficient
; 1683 :         }
; 1684 : 
; 1685 :         return _Geometric; // geometric growth is sufficient
; 1686 :     }

	ret	4
$LN2@Calculate_:

; 1677 :         }
; 1678 : 
; 1679 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	lea	eax, DWORD PTR [esi+edx]

; 1680 : 
; 1681 :         if (_Geometric < _Newsize) {

	cmp	eax, DWORD PTR __Newsize$[esp]
	pop	esi
	cmovb	eax, DWORD PTR __Newsize$[esp-4]

; 1682 :             return _Newsize; // geometric growth would be insufficient
; 1683 :         }
; 1684 : 
; 1685 :         return _Geometric; // geometric growth is sufficient
; 1686 :     }

	ret	4
?_Calculate_growth@?$vector@PAVlight@@V?$xalloc@PAVlight@@@@@std@@ABEII@Z ENDP ; std::vector<light *,xalloc<light *> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Umove_if_noexcept@?$vector@PAVlight@@V?$xalloc@PAVlight@@@@@std@@AAEXPAPAVlight@@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
?_Umove_if_noexcept@?$vector@PAVlight@@V?$xalloc@PAVlight@@@@@std@@AAEXPAPAVlight@@00@Z PROC ; std::vector<light *,xalloc<light *> >::_Umove_if_noexcept, COMDAT
; _this$dead$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1703 :     auto _UFirst      = _Get_unwrapped(_First);

	mov	eax, DWORD PTR __First$[esp-4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1659 :     _CONSTEXPR20_CONTAINER void _Umove_if_noexcept(pointer _First, pointer _Last, pointer _Dest) {

	push	esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	mov	esi, DWORD PTR __Last$[esp]
	cmp	eax, esi
	je	SHORT $LN7@Umove_if_n

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	edx, DWORD PTR __Dest$[esp]
	sub	edx, eax
$LL8@Umove_if_n:

; 1620 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx+eax], ecx

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	add	eax, 4
	cmp	eax, esi
	jne	SHORT $LL8@Umove_if_n
$LN7@Umove_if_n:
	pop	esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1663 :     }

	ret	12					; 0000000cH
?_Umove_if_noexcept@?$vector@PAVlight@@V?$xalloc@PAVlight@@@@@std@@AAEXPAPAVlight@@00@Z ENDP ; std::vector<light *,xalloc<light *> >::_Umove_if_noexcept
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Umove@?$vector@PAVlight@@V?$xalloc@PAVlight@@@@@std@@AAEPAPAVlight@@PAPAV3@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
?_Umove@?$vector@PAVlight@@V?$xalloc@PAVlight@@@@@std@@AAEPAPAVlight@@PAPAV3@00@Z PROC ; std::vector<light *,xalloc<light *> >::_Umove, COMDAT
; _this$dead$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	mov	ecx, DWORD PTR __First$[esp-4]

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	eax, DWORD PTR __Dest$[esp-4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1644 :     _CONSTEXPR20_CONTAINER pointer _Umove(pointer _First, pointer _Last, pointer _Dest) {

	push	esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	mov	esi, DWORD PTR __Last$[esp]
	cmp	ecx, esi
	je	SHORT $LN5@Umove
$LL6@Umove:

; 1620 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

	mov	edx, DWORD PTR [ecx]

; 1621 :         ++_Last;

	add	ecx, 4
	mov	DWORD PTR [eax], edx
	add	eax, 4

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	ecx, esi
	jne	SHORT $LL6@Umove
$LN5@Umove:
	pop	esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1647 :     }

	ret	12					; 0000000cH
?_Umove@?$vector@PAVlight@@V?$xalloc@PAVlight@@@@@std@@AAEPAPAVlight@@PAPAV3@00@Z ENDP ; std::vector<light *,xalloc<light *> >::_Umove
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?max_size@?$vector@PAVlight@@V?$xalloc@PAVlight@@@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@PAVlight@@V?$xalloc@PAVlight@@@@@std@@QBEIXZ PROC ; std::vector<light *,xalloc<light *> >::max_size, COMDAT
; _this$dead$ = ecx

; 1540 :         return (_STD min)(

	mov	eax, 1073741823				; 3fffffffH

; 1541 :             static_cast<size_type>((numeric_limits<difference_type>::max)()), _Alty_traits::max_size(_Getal()));
; 1542 :     }

	ret	0
?max_size@?$vector@PAVlight@@V?$xalloc@PAVlight@@@@@std@@QBEIXZ ENDP ; std::vector<light *,xalloc<light *> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?construct@?$xalloc@PAVlight@@@@QAEXPAPAVlight@@ABQAV2@@Z
_TEXT	SEGMENT
_p$ = 8							; size = 4
__Val$ = 12						; size = 4
?construct@?$xalloc@PAVlight@@@@QAEXPAPAVlight@@ABQAV2@@Z PROC ; xalloc<light *>::construct, COMDAT
; _this$dead$ = ecx

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	eax, DWORD PTR __Val$[esp-4]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR _p$[esp-4]
	mov	DWORD PTR [eax], ecx
	ret	8
?construct@?$xalloc@PAVlight@@@@QAEXPAPAVlight@@ABQAV2@@Z ENDP ; xalloc<light *>::construct
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?allocate@?$xalloc@PAVlight@@@@QBEPAPAVlight@@IPBX@Z
_TEXT	SEGMENT
_n$ = 8							; size = 4
_p$dead$ = 12						; size = 4
?allocate@?$xalloc@PAVlight@@@@QBEPAPAVlight@@IPBX@Z PROC ; xalloc<light *>::allocate, COMDAT
; _this$dead$ = ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	mov	eax, DWORD PTR _n$[esp-4]
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	shl	eax, 2
	push	eax
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 80   : 							pointer					allocate		(size_type n, const void* p=0) const	{	return xr_alloc<T>((u32)n);	}

	ret	8
?allocate@?$xalloc@PAVlight@@@@QBEPAPAVlight@@IPBX@Z ENDP ; xalloc<light *>::allocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Getal@?$vector@PAVlight@@V?$xalloc@PAVlight@@@@@std@@ABEABV?$xalloc@PAVlight@@@@XZ
_TEXT	SEGMENT
?_Getal@?$vector@PAVlight@@V?$xalloc@PAVlight@@@@@std@@ABEABV?$xalloc@PAVlight@@@@XZ PROC ; std::vector<light *,xalloc<light *> >::_Getal, COMDAT
; _this$ = ecx

; 1809 :         return _Mypair._Get_first();

	mov	eax, ecx

; 1810 :     }

	ret	0
?_Getal@?$vector@PAVlight@@V?$xalloc@PAVlight@@@@@std@@ABEABV?$xalloc@PAVlight@@@@XZ ENDP ; std::vector<light *,xalloc<light *> >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Umove_if_noexcept1@?$vector@PAVlight@@V?$xalloc@PAVlight@@@@@std@@AAEXPAPAVlight@@00U?$integral_constant@_N$00@2@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
?_Umove_if_noexcept1@?$vector@PAVlight@@V?$xalloc@PAVlight@@@@@std@@AAEXPAPAVlight@@00U?$integral_constant@_N$00@2@@Z PROC ; std::vector<light *,xalloc<light *> >::_Umove_if_noexcept1, COMDAT
; _this$dead$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1703 :     auto _UFirst      = _Get_unwrapped(_First);

	mov	eax, DWORD PTR __First$[esp-4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1649 :     _CONSTEXPR20_CONTAINER void _Umove_if_noexcept1(pointer _First, pointer _Last, pointer _Dest, true_type) {

	push	esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	mov	esi, DWORD PTR __Last$[esp]
	cmp	eax, esi
	je	SHORT $LN5@Umove_if_n

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	edx, DWORD PTR __Dest$[esp]
	sub	edx, eax
$LL6@Umove_if_n:

; 1620 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx+eax], ecx

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	add	eax, 4
	cmp	eax, esi
	jne	SHORT $LL6@Umove_if_n
$LN5@Umove_if_n:
	pop	esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1652 :     }

	ret	16					; 00000010H
?_Umove_if_noexcept1@?$vector@PAVlight@@V?$xalloc@PAVlight@@@@@std@@AAEXPAPAVlight@@00U?$integral_constant@_N$00@2@@Z ENDP ; std::vector<light *,xalloc<light *> >::_Umove_if_noexcept1
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?capacity@?$vector@PAVlight@@V?$xalloc@PAVlight@@@@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@PAVlight@@V?$xalloc@PAVlight@@@@@std@@QBEIXZ PROC ; std::vector<light *,xalloc<light *> >::capacity, COMDAT
; _this$ = ecx

; 1545 :         auto& _My_data = _Mypair._Myval2;
; 1546 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx]
	sar	eax, 2

; 1547 :     }

	ret	0
?capacity@?$vector@PAVlight@@V?$xalloc@PAVlight@@@@@std@@QBEIXZ ENDP ; std::vector<light *,xalloc<light *> >::capacity
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?max_size@?$_Normal_allocator_traits@V?$xalloc@PAVlight@@@@@std@@SAIABV?$xalloc@PAVlight@@@@@Z
_TEXT	SEGMENT
?max_size@?$_Normal_allocator_traits@V?$xalloc@PAVlight@@@@@std@@SAIABV?$xalloc@PAVlight@@@@@Z PROC ; std::_Normal_allocator_traits<xalloc<light *> >::max_size, COMDAT
; __Al$dead$ = ecx

; 591  :         if constexpr (_Has_max_size<_Alloc>::value) {
; 592  :             return _Al.max_size();

	mov	eax, 1073741823				; 3fffffffH

; 593  :         } else {
; 594  :             return (numeric_limits<size_type>::max)() / sizeof(value_type);
; 595  :         }
; 596  :     }

	ret	0
?max_size@?$_Normal_allocator_traits@V?$xalloc@PAVlight@@@@@std@@SAIABV?$xalloc@PAVlight@@@@@Z ENDP ; std::_Normal_allocator_traits<xalloc<light *> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$xalloc@PAVlight@@@@V?$_Vector_val@U?$_Simple_types@PAVlight@@@std@@@std@@$00@std@@QBEABV?$xalloc@PAVlight@@@@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@V?$xalloc@PAVlight@@@@V?$_Vector_val@U?$_Simple_types@PAVlight@@@std@@@std@@$00@std@@QBEABV?$xalloc@PAVlight@@@@XZ PROC ; std::_Compressed_pair<xalloc<light *>,std::_Vector_val<std::_Simple_types<light *> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 1343 :         return *this;

	mov	eax, ecx

; 1344 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$xalloc@PAVlight@@@@V?$_Vector_val@U?$_Simple_types@PAVlight@@@std@@@std@@$00@std@@QBEABV?$xalloc@PAVlight@@@@XZ ENDP ; std::_Compressed_pair<xalloc<light *>,std::_Vector_val<std::_Simple_types<light *> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?max_size@?$xalloc@PAVlight@@@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$xalloc@PAVlight@@@@QBEIXZ PROC		; xalloc<light *>::max_size, COMDAT
; _this$dead$ = ecx

; 86   : 							size_type				max_size		() const								{	size_type _Count = (size_type)(-1) / sizeof (T);	return (0 < _Count ? _Count : 1);	}

	mov	eax, 1073741823				; 3fffffffH
	ret	0
?max_size@?$xalloc@PAVlight@@@@QBEIXZ ENDP		; xalloc<light *>::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Uninitialized_move@PAPAVlight@@V?$xalloc@PAVlight@@@@@std@@YAPAPAVlight@@QAPAV1@0PAPAV1@AAV?$xalloc@PAVlight@@@@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Al$dead$ = 12						; size = 4
??$_Uninitialized_move@PAPAVlight@@V?$xalloc@PAVlight@@@@@std@@YAPAPAVlight@@QAPAV1@0PAPAV1@AAV?$xalloc@PAVlight@@@@@Z PROC ; std::_Uninitialized_move<light * *,xalloc<light *> >, COMDAT
; __First$ = ecx
; __Last$ = edx

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	eax, DWORD PTR __Dest$[esp-4]

; 1699 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

	push	esi
	mov	esi, edx

; 1700 :     // move [_First, _Last) to raw _Dest, using _Al
; 1701 :     // note: only called internally from elsewhere in the STL
; 1702 :     using _Ptrval     = typename _Alloc::value_type*;
; 1703 :     auto _UFirst      = _Get_unwrapped(_First);
; 1704 :     const auto _ULast = _Get_unwrapped(_Last);
; 1705 :     if constexpr (conjunction_v<bool_constant<_Ptr_move_cat<decltype(_UFirst), _Ptrval>::_Really_trivial>,
; 1706 :                       _Uses_default_construct<_Alloc, _Ptrval, decltype(_STD move(*_UFirst))>>) {
; 1707 : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 1708 :         if (!_STD is_constant_evaluated())
; 1709 : #endif // __cpp_lib_constexpr_dynamic_alloc
; 1710 :         {
; 1711 :             _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));
; 1712 :             return _Dest + (_ULast - _UFirst);
; 1713 :         }
; 1714 :     }
; 1715 : 
; 1716 :     _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	ecx, esi
	je	SHORT $LN3@Uninitiali
	npad	5
$LL4@Uninitiali:

; 1620 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

	mov	edx, DWORD PTR [ecx]

; 1621 :         ++_Last;

	add	ecx, 4
	mov	DWORD PTR [eax], edx
	add	eax, 4

; 1700 :     // move [_First, _Last) to raw _Dest, using _Al
; 1701 :     // note: only called internally from elsewhere in the STL
; 1702 :     using _Ptrval     = typename _Alloc::value_type*;
; 1703 :     auto _UFirst      = _Get_unwrapped(_First);
; 1704 :     const auto _ULast = _Get_unwrapped(_Last);
; 1705 :     if constexpr (conjunction_v<bool_constant<_Ptr_move_cat<decltype(_UFirst), _Ptrval>::_Really_trivial>,
; 1706 :                       _Uses_default_construct<_Alloc, _Ptrval, decltype(_STD move(*_UFirst))>>) {
; 1707 : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 1708 :         if (!_STD is_constant_evaluated())
; 1709 : #endif // __cpp_lib_constexpr_dynamic_alloc
; 1710 :         {
; 1711 :             _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));
; 1712 :             return _Dest + (_ULast - _UFirst);
; 1713 :         }
; 1714 :     }
; 1715 : 
; 1716 :     _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	ecx, esi
	jne	SHORT $LL4@Uninitiali
$LN3@Uninitiali:
	pop	esi

; 1718 :         _Backout._Emplace_back(_STD move(*_UFirst));
; 1719 :     }
; 1720 : 
; 1721 :     return _Backout._Release();
; 1722 : }

	ret	0
??$_Uninitialized_move@PAPAVlight@@V?$xalloc@PAVlight@@@@@std@@YAPAPAVlight@@QAPAV1@0PAPAV1@AAV?$xalloc@PAVlight@@@@@Z ENDP ; std::_Uninitialized_move<light * *,xalloc<light *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_Get_unwrapped@ABQAPAVlight@@@std@@YA?A_TABQAPAVlight@@@Z
_TEXT	SEGMENT
??$_Get_unwrapped@ABQAPAVlight@@@std@@YA?A_TABQAPAVlight@@@Z PROC ; std::_Get_unwrapped<light * * const &>, COMDAT
; __It$ = ecx

; 1275 :     // unwrap an iterator previously subjected to _Adl_verify_range or otherwise validated
; 1276 :     if constexpr (is_pointer_v<decay_t<_Iter>>) { // special-case pointers and arrays
; 1277 :         return _It + 0;

	mov	eax, DWORD PTR [ecx]

; 1278 :     } else if constexpr (_Unwrappable_v<_Iter>) {
; 1279 :         return static_cast<_Iter&&>(_It)._Unwrapped();
; 1280 :     } else {
; 1281 :         return static_cast<_Iter&&>(_It);
; 1282 :     }
; 1283 : }

	ret	0
??$_Get_unwrapped@ABQAPAVlight@@@std@@YA?A_TABQAPAVlight@@@Z ENDP ; std::_Get_unwrapped<light * * const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
;	COMDAT ??$xr_alloc@PAVlight@@@@YAPAPAVlight@@I@Z
_TEXT	SEGMENT
??$xr_alloc@PAVlight@@@@YAPAPAVlight@@I@Z PROC		; xr_alloc<light *>, COMDAT
; _count$ = ecx

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	lea	eax, DWORD PTR [ecx*4]
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
	ret	0
??$xr_alloc@PAVlight@@@@YAPAPAVlight@@I@Z ENDP		; xr_alloc<light *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Release@?$_Uninitialized_backout_al@V?$xalloc@PAVlight@@@@@std@@QAEPAPAVlight@@XZ
_TEXT	SEGMENT
?_Release@?$_Uninitialized_backout_al@V?$xalloc@PAVlight@@@@@std@@QAEPAPAVlight@@XZ PROC ; std::_Uninitialized_backout_al<xalloc<light *> >::_Release, COMDAT
; _this$ = ecx

; 1625 :         _First = _Last;

	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [ecx], eax

; 1626 :         return _Last;
; 1627 :     }

	ret	0
?_Release@?$_Uninitialized_backout_al@V?$xalloc@PAVlight@@@@@std@@QAEPAPAVlight@@XZ ENDP ; std::_Uninitialized_backout_al<xalloc<light *> >::_Release
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??1?$_Uninitialized_backout_al@V?$xalloc@PAVlight@@@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Uninitialized_backout_al@V?$xalloc@PAVlight@@@@@std@@QAE@XZ PROC ; std::_Uninitialized_backout_al<xalloc<light *> >::~_Uninitialized_backout_al<xalloc<light *> >, COMDAT
; _this$ = ecx

; 1615 :         _Destroy_range(_First, _Last, _Al);
; 1616 :     }

	ret	0
??1?$_Uninitialized_backout_al@V?$xalloc@PAVlight@@@@@std@@QAE@XZ ENDP ; std::_Uninitialized_backout_al<xalloc<light *> >::~_Uninitialized_backout_al<xalloc<light *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??0?$_Uninitialized_backout_al@V?$xalloc@PAVlight@@@@@std@@QAE@PAPAVlight@@AAV?$xalloc@PAVlight@@@@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Al_$ = 12						; size = 4
??0?$_Uninitialized_backout_al@V?$xalloc@PAVlight@@@@@std@@QAE@PAPAVlight@@AAV?$xalloc@PAVlight@@@@@Z PROC ; std::_Uninitialized_backout_al<xalloc<light *> >::_Uninitialized_backout_al<xalloc<light *> >, COMDAT
; _this$ = ecx

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	eax, DWORD PTR __Dest$[esp-4]
	mov	DWORD PTR [ecx], eax
	mov	DWORD PTR [ecx+4], eax
	mov	eax, DWORD PTR __Al_$[esp-4]
	mov	DWORD PTR [ecx+8], eax
	mov	eax, ecx
	ret	8
??0?$_Uninitialized_backout_al@V?$xalloc@PAVlight@@@@@std@@QAE@PAPAVlight@@AAV?$xalloc@PAVlight@@@@@Z ENDP ; std::_Uninitialized_backout_al<xalloc<light *> >::_Uninitialized_backout_al<xalloc<light *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\type_traits
;	COMDAT ??$move@AAPAVlight@@@std@@YA$$QAPAVlight@@AAPAV1@@Z
_TEXT	SEGMENT
??$move@AAPAVlight@@@std@@YA$$QAPAVlight@@AAPAV1@@Z PROC ; std::move<light * &>, COMDAT
; __Arg$ = ecx

; 1397 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

	mov	eax, ecx

; 1398 : }

	ret	0
??$move@AAPAVlight@@@std@@YA$$QAPAVlight@@AAPAV1@@Z ENDP ; std::move<light * &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Emplace_back@PAVlight@@@?$_Uninitialized_backout_al@V?$xalloc@PAVlight@@@@@std@@QAEX$$QAPAVlight@@@Z
_TEXT	SEGMENT
_<_Vals_0>$ = 8						; size = 4
??$_Emplace_back@PAVlight@@@?$_Uninitialized_backout_al@V?$xalloc@PAVlight@@@@@std@@QAEX$$QAPAVlight@@@Z PROC ; std::_Uninitialized_backout_al<xalloc<light *> >::_Emplace_back<light *>, COMDAT
; _this$ = ecx

; 1620 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _<_Vals_0>$[esp-4]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edx], eax

; 1621 :         ++_Last;

	add	DWORD PTR [ecx+4], 4

; 1622 :     }

	ret	4
??$_Emplace_back@PAVlight@@@?$_Uninitialized_backout_al@V?$xalloc@PAVlight@@@@@std@@QAEX$$QAPAVlight@@@Z ENDP ; std::_Uninitialized_backout_al<xalloc<light *> >::_Emplace_back<light *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\type_traits
;	COMDAT ??$forward@PAVlight@@@std@@YA$$QAPAVlight@@AAPAV1@@Z
_TEXT	SEGMENT
??$forward@PAVlight@@@std@@YA$$QAPAVlight@@AAPAV1@@Z PROC ; std::forward<light *>, COMDAT
; __Arg$ = ecx

; 1386 :     return static_cast<_Ty&&>(_Arg);

	mov	eax, ecx

; 1387 : }

	ret	0
??$forward@PAVlight@@@std@@YA$$QAPAVlight@@AAPAV1@@Z ENDP ; std::forward<light *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$construct@PAVlight@@PAV1@@?$_Normal_allocator_traits@V?$xalloc@PAVlight@@@@@std@@SAXAAV?$xalloc@PAVlight@@@@PAPAVlight@@$$QAPAV3@@Z
_TEXT	SEGMENT
_<_Args_0>$ = 8						; size = 4
??$construct@PAVlight@@PAV1@@?$_Normal_allocator_traits@V?$xalloc@PAVlight@@@@@std@@SAXAAV?$xalloc@PAVlight@@@@PAPAVlight@@$$QAPAV3@@Z PROC ; std::_Normal_allocator_traits<xalloc<light *> >::construct<light *,light *>, COMDAT
; __Al$dead$ = ecx
; __Ptr$ = edx

; 565  :         if constexpr (_Uses_default_construct<_Alloc, _Ty*, _Types...>::value) {
; 566  :             (void) _Al; // TRANSITION, DevCom-1004719
; 567  : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 568  :             _STD construct_at(_Ptr, _STD forward<_Types>(_Args)...);
; 569  : #else // __cpp_lib_constexpr_dynamic_alloc
; 570  :             ::new (static_cast<void*>(_Ptr)) _Ty(_STD forward<_Types>(_Args)...);
; 571  : #endif // __cpp_lib_constexpr_dynamic_alloc
; 572  :         } else {
; 573  :             _Al.construct(_Ptr, _STD forward<_Types>(_Args)...);

	mov	eax, DWORD PTR _<_Args_0>$[esp-4]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edx], eax

; 574  :         }
; 575  :     }

	ret	0
??$construct@PAVlight@@PAV1@@?$_Normal_allocator_traits@V?$xalloc@PAVlight@@@@@std@@SAXAAV?$xalloc@PAVlight@@@@PAPAVlight@@$$QAPAV3@@Z ENDP ; std::_Normal_allocator_traits<xalloc<light *> >::construct<light *,light *>
_TEXT	ENDS
END
