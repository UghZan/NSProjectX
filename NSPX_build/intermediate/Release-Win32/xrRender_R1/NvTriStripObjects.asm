; Listing generated by Microsoft (R) Optimizing Compiler Version 19.29.30146.0 

	TITLE	i:\vitalya\mine\nsprojectx\nspx_build\intermediate\release-win32\xrrender_r1\nvtristripobjects.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	??_C@_0ED@PGPLFOBO@?$CB?5WARNING?3?5GetNextIndex?3?5Triang@ ; `string'
PUBLIC	??_C@_0EF@NPIJGPAE@?$CB?5WARNING?3?5GetNextIndex?3?5Duplic@ ; `string'
PUBLIC	??_C@_0DB@JOONJBKI@?$CB?5WARNING?3?5GetNextIndex?3?5Duplic@ ; `string'
;	COMDAT ??_C@_0DB@JOONJBKI@?$CB?5WARNING?3?5GetNextIndex?3?5Duplic@
CONST	SEGMENT
??_C@_0DB@JOONJBKI@?$CB?5WARNING?3?5GetNextIndex?3?5Duplic@ DB '! WARNING'
	DB	': GetNextIndex: Duplicate triangle sent', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EF@NPIJGPAE@?$CB?5WARNING?3?5GetNextIndex?3?5Duplic@
CONST	SEGMENT
??_C@_0EF@NPIJGPAE@?$CB?5WARNING?3?5GetNextIndex?3?5Duplic@ DB '! WARNING'
	DB	': GetNextIndex: Duplicate triangle probably got us derailed', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0ED@PGPLFOBO@?$CB?5WARNING?3?5GetNextIndex?3?5Triang@
CONST	SEGMENT
??_C@_0ED@PGPLFOBO@?$CB?5WARNING?3?5GetNextIndex?3?5Triang@ DB '! WARNING'
	DB	': GetNextIndex: Triangle doesn''t have all of its vertices', 00H ; `string'
?_Fake_alloc@std@@3U_Fake_allocator@1@B	ORG $+1		; std::_Fake_alloc
PUBLIC	?_max@@YAHHH@Z					; _max
PUBLIC	??$construct@PAVNvStripInfo@@AAPAV1@@?$_Normal_allocator_traits@V?$xalloc@PAVNvStripInfo@@@@@std@@SAXAAV?$xalloc@PAVNvStripInfo@@@@PAPAVNvStripInfo@@AAPAV3@@Z ; std::_Normal_allocator_traits<xalloc<NvStripInfo *> >::construct<NvStripInfo *,NvStripInfo * &>
PUBLIC	??$forward@AAPAVNvStripInfo@@@std@@YAAAPAVNvStripInfo@@AAPAV1@@Z ; std::forward<NvStripInfo * &>
PUBLIC	??$_Emplace_back@AAPAVNvStripInfo@@@?$_Uninitialized_backout_al@V?$xalloc@PAVNvStripInfo@@@@@std@@QAEXAAPAVNvStripInfo@@@Z ; std::_Uninitialized_backout_al<xalloc<NvStripInfo *> >::_Emplace_back<NvStripInfo * &>
PUBLIC	??$_Uninitialized_copy@PAPAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@std@@YAPAPAVNvStripInfo@@QAPAV1@0PAPAV1@AAV?$xalloc@PAVNvStripInfo@@@@@Z ; std::_Uninitialized_copy<NvStripInfo * *,xalloc<NvStripInfo *> >
PUBLIC	??$forward@V?$xalloc@PAVNvStripInfo@@@@@std@@YA$$QAV?$xalloc@PAVNvStripInfo@@@@AAV1@@Z ; std::forward<xalloc<NvStripInfo *> >
PUBLIC	??$_Ucopy@PAPAVNvStripInfo@@@?$vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@std@@AAEPAPAVNvStripInfo@@PAPAV2@00@Z ; std::vector<NvStripInfo *,xalloc<NvStripInfo *> >::_Ucopy<NvStripInfo * *>
PUBLIC	??$?0V?$xalloc@PAVNvStripInfo@@@@$$V@?$_Compressed_pair@V?$xalloc@PAVNvStripInfo@@@@V?$_Vector_val@U?$_Simple_types@PAVNvStripInfo@@@std@@@std@@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAV?$xalloc@PAVNvStripInfo@@@@@Z ; std::_Compressed_pair<xalloc<NvStripInfo *>,std::_Vector_val<std::_Simple_types<NvStripInfo *> >,1>::_Compressed_pair<xalloc<NvStripInfo *>,std::_Vector_val<std::_Simple_types<NvStripInfo *> >,1><xalloc<NvStripInfo *> >
PUBLIC	??0?$xalloc@PAVNvStripInfo@@@@QAE@ABV0@@Z	; xalloc<NvStripInfo *>::xalloc<NvStripInfo *>
PUBLIC	?select_on_container_copy_construction@?$_Normal_allocator_traits@V?$xalloc@PAVNvStripInfo@@@@@std@@SA?AV?$xalloc@PAVNvStripInfo@@@@ABV3@@Z ; std::_Normal_allocator_traits<xalloc<NvStripInfo *> >::select_on_container_copy_construction
PUBLIC	?_Buy_raw@?$vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@std@@AAEXI@Z ; std::vector<NvStripInfo *,xalloc<NvStripInfo *> >::_Buy_raw
PUBLIC	??1?$_Tidy_guard@V?$vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@std@@@std@@QAE@XZ ; std::_Tidy_guard<std::vector<NvStripInfo *,xalloc<NvStripInfo *> > >::~_Tidy_guard<std::vector<NvStripInfo *,xalloc<NvStripInfo *> > >
PUBLIC	??0?$vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@std@@QAE@ABV01@@Z ; std::vector<NvStripInfo *,xalloc<NvStripInfo *> >::vector<NvStripInfo *,xalloc<NvStripInfo *> >
PUBLIC	??0?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@QAE@ABV0@@Z ; xr_vector<NvStripInfo *,xalloc<NvStripInfo *> >::xr_vector<NvStripInfo *,xalloc<NvStripInfo *> >
PUBLIC	?construct@?$xalloc@PAVNvEdgeInfo@@@@QAEXPAPAVNvEdgeInfo@@ABQAV2@@Z ; xalloc<NvEdgeInfo *>::construct
PUBLIC	?construct@?$xalloc@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@@QAEXPAV?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@ABV2@@Z ; xalloc<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> > >::construct
PUBLIC	??$construct@PAVNvEdgeInfo@@PAV1@@?$_Normal_allocator_traits@V?$xalloc@PAVNvEdgeInfo@@@@@std@@SAXAAV?$xalloc@PAVNvEdgeInfo@@@@PAPAVNvEdgeInfo@@$$QAPAV3@@Z ; std::_Normal_allocator_traits<xalloc<NvEdgeInfo *> >::construct<NvEdgeInfo *,NvEdgeInfo *>
PUBLIC	??$forward@PAVNvEdgeInfo@@@std@@YA$$QAPAVNvEdgeInfo@@AAPAV1@@Z ; std::forward<NvEdgeInfo *>
PUBLIC	??$construct@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@V1@@?$_Normal_allocator_traits@V?$xalloc@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@@@std@@SAXAAV?$xalloc@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@@PAV?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@$$QAV3@@Z ; std::_Normal_allocator_traits<xalloc<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> > > >::construct<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> >,xr_vector<NvStripInfo *,xalloc<NvStripInfo *> > >
PUBLIC	??$forward@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@std@@YA$$QAV?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@AAV1@@Z ; std::forward<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> > >
PUBLIC	??$_Emplace_back@PAVNvEdgeInfo@@@?$_Uninitialized_backout_al@V?$xalloc@PAVNvEdgeInfo@@@@@std@@QAEX$$QAPAVNvEdgeInfo@@@Z ; std::_Uninitialized_backout_al<xalloc<NvEdgeInfo *> >::_Emplace_back<NvEdgeInfo *>
PUBLIC	??$move@AAPAVNvEdgeInfo@@@std@@YA$$QAPAVNvEdgeInfo@@AAPAV1@@Z ; std::move<NvEdgeInfo * &>
PUBLIC	??$_Emplace_back@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@?$_Uninitialized_backout_al@V?$xalloc@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@@@std@@QAEX$$QAV?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@Z ; std::_Uninitialized_backout_al<xalloc<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> > > >::_Emplace_back<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> > >
PUBLIC	??$move@AAV?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@std@@YA$$QAV?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@AAV1@@Z ; std::move<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> > &>
PUBLIC	??$construct@PAVNvEdgeInfo@@$$V@?$_Normal_allocator_traits@V?$xalloc@PAVNvEdgeInfo@@@@@std@@SAXAAV?$xalloc@PAVNvEdgeInfo@@@@PAPAVNvEdgeInfo@@@Z ; std::_Normal_allocator_traits<xalloc<NvEdgeInfo *> >::construct<NvEdgeInfo *>
PUBLIC	??$construct@PAVNvStripInfo@@PAV1@@?$_Normal_allocator_traits@V?$xalloc@PAVNvStripInfo@@@@@std@@SAXAAV?$xalloc@PAVNvStripInfo@@@@PAPAVNvStripInfo@@$$QAPAV3@@Z ; std::_Normal_allocator_traits<xalloc<NvStripInfo *> >::construct<NvStripInfo *,NvStripInfo *>
PUBLIC	??$forward@PAVNvStripInfo@@@std@@YA$$QAPAVNvStripInfo@@AAPAV1@@Z ; std::forward<NvStripInfo *>
PUBLIC	??$construct@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@$$V@?$_Normal_allocator_traits@V?$xalloc@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@@@std@@SAXAAV?$xalloc@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@@PAV?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@Z ; std::_Normal_allocator_traits<xalloc<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> > > >::construct<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> > >
PUBLIC	??$forward@PAU?$_Tree_node@PAVNvFaceInfo@@PAX@std@@@std@@YA$$QAPAU?$_Tree_node@PAVNvFaceInfo@@PAX@0@AAPAU10@@Z ; std::forward<std::_Tree_node<NvFaceInfo *,void *> *>
PUBLIC	??$_Construct_in_place@PAU?$_Tree_node@PAVNvFaceInfo@@PAX@std@@AAPAU12@@std@@YAXAAPAU?$_Tree_node@PAVNvFaceInfo@@PAX@0@0@Z ; std::_Construct_in_place<std::_Tree_node<NvFaceInfo *,void *> *,std::_Tree_node<NvFaceInfo *,void *> * &>
PUBLIC	??$construct@PAVNvFaceInfo@@ABQAV1@@?$_Normal_allocator_traits@V?$xalloc@U?$_Tree_node@PAVNvFaceInfo@@PAX@std@@@@@std@@SAXAAV?$xalloc@U?$_Tree_node@PAVNvFaceInfo@@PAX@std@@@@PAPAVNvFaceInfo@@ABQAV3@@Z ; std::_Normal_allocator_traits<xalloc<std::_Tree_node<NvFaceInfo *,void *> > >::construct<NvFaceInfo *,NvFaceInfo * const &>
PUBLIC	??$forward@AAPAU?$_Tree_node@PAVNvFaceInfo@@PAX@std@@@std@@YAAAPAU?$_Tree_node@PAVNvFaceInfo@@PAX@0@AAPAU10@@Z ; std::forward<std::_Tree_node<NvFaceInfo *,void *> * &>
PUBLIC	??0?$_Alloc_construct_ptr@V?$xalloc@U?$_Tree_node@PAVNvFaceInfo@@PAX@std@@@@@std@@QAE@AAV?$xalloc@U?$_Tree_node@PAVNvFaceInfo@@PAX@std@@@@@Z ; std::_Alloc_construct_ptr<xalloc<std::_Tree_node<NvFaceInfo *,void *> > >::_Alloc_construct_ptr<xalloc<std::_Tree_node<NvFaceInfo *,void *> > >
PUBLIC	?_Allocate@?$_Alloc_construct_ptr@V?$xalloc@U?$_Tree_node@PAVNvFaceInfo@@PAX@std@@@@@std@@QAEXXZ ; std::_Alloc_construct_ptr<xalloc<std::_Tree_node<NvFaceInfo *,void *> > >::_Allocate
PUBLIC	??0?$_Tree_temp_node_alloc@V?$xalloc@U?$_Tree_node@PAVNvFaceInfo@@PAX@std@@@@@std@@QAE@AAV?$xalloc@U?$_Tree_node@PAVNvFaceInfo@@PAX@std@@@@@Z ; std::_Tree_temp_node_alloc<xalloc<std::_Tree_node<NvFaceInfo *,void *> > >::_Tree_temp_node_alloc<xalloc<std::_Tree_node<NvFaceInfo *,void *> > >
PUBLIC	??$_Get_unwrapped@ABQAPAVNvEdgeInfo@@@std@@YA?A_TABQAPAVNvEdgeInfo@@@Z ; std::_Get_unwrapped<NvEdgeInfo * * const &>
PUBLIC	??$_Uninitialized_move@PAPAVNvEdgeInfo@@V?$xalloc@PAVNvEdgeInfo@@@@@std@@YAPAPAVNvEdgeInfo@@QAPAV1@0PAPAV1@AAV?$xalloc@PAVNvEdgeInfo@@@@@Z ; std::_Uninitialized_move<NvEdgeInfo * *,xalloc<NvEdgeInfo *> >
PUBLIC	??$_Get_unwrapped@ABQAV?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@std@@YA?A_TABQAV?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@Z ; std::_Get_unwrapped<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> > * const &>
PUBLIC	??$_Uninitialized_move@PAV?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@V?$xalloc@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@@@std@@YAPAV?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@QAV1@0PAV1@AAV?$xalloc@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@@@Z ; std::_Uninitialized_move<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> > *,xalloc<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> > > >
PUBLIC	??$xr_free@U?$_Tree_node@PAVNvFaceInfo@@PAX@std@@@@YAXAAPAU?$_Tree_node@PAVNvFaceInfo@@PAX@std@@@Z ; xr_free<std::_Tree_node<NvFaceInfo *,void *> >
PUBLIC	??$xr_alloc@PAVNvEdgeInfo@@@@YAPAPAVNvEdgeInfo@@I@Z ; xr_alloc<NvEdgeInfo *>
PUBLIC	??$_Destroy_in_place@PAPAVNvEdgeInfo@@@std@@YAXAAPAPAVNvEdgeInfo@@@Z ; std::_Destroy_in_place<NvEdgeInfo * *>
PUBLIC	??$xr_alloc@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@@YAPAV?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@I@Z ; xr_alloc<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> > >
PUBLIC	??$_Destroy_in_place@PAV?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@std@@YAXAAPAV?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@Z ; std::_Destroy_in_place<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> > *>
PUBLIC	??$exchange@PAU?$_Tree_node@PAVNvFaceInfo@@PAX@std@@$$T@std@@YAPAU?$_Tree_node@PAVNvFaceInfo@@PAX@0@AAPAU10@$$QA$$T@Z ; std::exchange<std::_Tree_node<NvFaceInfo *,void *> *,std::nullptr_t>
PUBLIC	??$destroy@PAVNvFaceInfo@@@?$_Normal_allocator_traits@V?$xalloc@U?$_Tree_node@PAVNvFaceInfo@@PAX@std@@@@@std@@SAXAAV?$xalloc@U?$_Tree_node@PAVNvFaceInfo@@PAX@std@@@@PAPAVNvFaceInfo@@@Z ; std::_Normal_allocator_traits<xalloc<std::_Tree_node<NvFaceInfo *,void *> > >::destroy<NvFaceInfo *>
PUBLIC	??$addressof@PAVNvFaceInfo@@@std@@YAPAPAVNvFaceInfo@@AAPAV1@@Z ; std::addressof<NvFaceInfo *>
PUBLIC	??$_Emplace_back@H@?$_Uninitialized_backout_al@V?$xalloc@H@@@std@@QAEX$$QAH@Z ; std::_Uninitialized_backout_al<xalloc<int> >::_Emplace_back<int>
PUBLIC	??$_Emplace_back@$$V@?$_Uninitialized_backout_al@V?$xalloc@PAVNvEdgeInfo@@@@@std@@QAEXXZ ; std::_Uninitialized_backout_al<xalloc<NvEdgeInfo *> >::_Emplace_back<>
PUBLIC	??$_To_address@PAPAVNvEdgeInfo@@@std@@YA?A_PABQAPAVNvEdgeInfo@@@Z ; std::_To_address<NvEdgeInfo * *>
PUBLIC	??$_Zero_range@PAPAVNvEdgeInfo@@@std@@YAPAPAVNvEdgeInfo@@QAPAV1@0@Z ; std::_Zero_range<NvEdgeInfo * *>
PUBLIC	??$_Emplace_back@PAVNvStripInfo@@@?$_Uninitialized_backout_al@V?$xalloc@PAVNvStripInfo@@@@@std@@QAEX$$QAPAVNvStripInfo@@@Z ; std::_Uninitialized_backout_al<xalloc<NvStripInfo *> >::_Emplace_back<NvStripInfo *>
PUBLIC	??$move@AAPAVNvStripInfo@@@std@@YA$$QAPAVNvStripInfo@@AAPAV1@@Z ; std::move<NvStripInfo * &>
PUBLIC	??$_Emplace_back@$$V@?$_Uninitialized_backout_al@V?$xalloc@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@@@std@@QAEXXZ ; std::_Uninitialized_backout_al<xalloc<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> > > >::_Emplace_back<>
PUBLIC	??$construct@PAVNvFaceInfo@@PAV1@@?$_Normal_allocator_traits@V?$xalloc@PAVNvFaceInfo@@@@@std@@SAXAAV?$xalloc@PAVNvFaceInfo@@@@PAPAVNvFaceInfo@@$$QAPAV3@@Z ; std::_Normal_allocator_traits<xalloc<NvFaceInfo *> >::construct<NvFaceInfo *,NvFaceInfo *>
PUBLIC	??$forward@PAVNvFaceInfo@@@std@@YA$$QAPAVNvFaceInfo@@AAPAV1@@Z ; std::forward<NvFaceInfo *>
PUBLIC	??$forward@ABQAU?$_Tree_node@PAVNvFaceInfo@@PAX@std@@@std@@YAABQAU?$_Tree_node@PAVNvFaceInfo@@PAX@0@ABQAU10@@Z ; std::forward<std::_Tree_node<NvFaceInfo *,void *> * const &>
PUBLIC	??$_Voidify_iter@PAPAU?$_Tree_node@PAVNvFaceInfo@@PAX@std@@@std@@YAPAXPAPAU?$_Tree_node@PAVNvFaceInfo@@PAX@0@@Z ; std::_Voidify_iter<std::_Tree_node<NvFaceInfo *,void *> * *>
PUBLIC	??$addressof@PAU?$_Tree_node@PAVNvFaceInfo@@PAX@std@@@std@@YAPAPAU?$_Tree_node@PAVNvFaceInfo@@PAX@0@AAPAU10@@Z ; std::addressof<std::_Tree_node<NvFaceInfo *,void *> *>
PUBLIC	??$_Destroy_in_place@PAU?$_Tree_node@PAVNvFaceInfo@@PAX@std@@@std@@YAXAAPAU?$_Tree_node@PAVNvFaceInfo@@PAX@0@@Z ; std::_Destroy_in_place<std::_Tree_node<NvFaceInfo *,void *> *>
PUBLIC	??$_Freenode@V?$xalloc@U?$_Tree_node@PAVNvFaceInfo@@PAX@std@@@@@?$_Tree_node@PAVNvFaceInfo@@PAX@std@@SAXAAV?$xalloc@U?$_Tree_node@PAVNvFaceInfo@@PAX@std@@@@PAU01@@Z ; std::_Tree_node<NvFaceInfo *,void *>::_Freenode<xalloc<std::_Tree_node<NvFaceInfo *,void *> > >
PUBLIC	??$exchange@PAU?$_Tree_node@PAVNvFaceInfo@@PAX@std@@AAPAU12@@std@@YAPAU?$_Tree_node@PAVNvFaceInfo@@PAX@0@AAPAU10@0@Z ; std::exchange<std::_Tree_node<NvFaceInfo *,void *> *,std::_Tree_node<NvFaceInfo *,void *> * &>
PUBLIC	??$forward@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@PAVNvFaceInfo@@@std@@@std@@@std@@@std@@YA$$QAV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@PAVNvFaceInfo@@@std@@@std@@@0@AAV10@@Z ; std::forward<std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<NvFaceInfo *> > > >
PUBLIC	??$?0PAU?$_Tree_node@PAVNvFaceInfo@@PAX@std@@_N$0A@@?$pair@PAU?$_Tree_node@PAVNvFaceInfo@@PAX@std@@_N@std@@QAE@$$QAPAU?$_Tree_node@PAVNvFaceInfo@@PAX@1@$$QA_N@Z ; std::pair<std::_Tree_node<NvFaceInfo *,void *> *,bool>::pair<std::_Tree_node<NvFaceInfo *,void *> *,bool><std::_Tree_node<NvFaceInfo *,void *> *,bool,0>
PUBLIC	??$?0ABQAVNvFaceInfo@@@?$_Tree_temp_node@V?$xalloc@U?$_Tree_node@PAVNvFaceInfo@@PAX@std@@@@@std@@QAE@AAV?$xalloc@U?$_Tree_node@PAVNvFaceInfo@@PAX@std@@@@PAU?$_Tree_node@PAVNvFaceInfo@@PAX@1@ABQAVNvFaceInfo@@@Z ; std::_Tree_temp_node<xalloc<std::_Tree_node<NvFaceInfo *,void *> > >::_Tree_temp_node<xalloc<std::_Tree_node<NvFaceInfo *,void *> > ><NvFaceInfo * const &>
PUBLIC	??$?0AAPAU?$_Tree_node@PAVNvFaceInfo@@PAX@std@@_N$0A@@?$pair@PAU?$_Tree_node@PAVNvFaceInfo@@PAX@std@@_N@std@@QAE@AAPAU?$_Tree_node@PAVNvFaceInfo@@PAX@1@$$QA_N@Z ; std::pair<std::_Tree_node<NvFaceInfo *,void *> *,bool>::pair<std::_Tree_node<NvFaceInfo *,void *> *,bool><std::_Tree_node<NvFaceInfo *,void *> * &,bool,0>
PUBLIC	?max_size@?$xalloc@U?$_Tree_node@PAVNvFaceInfo@@PAX@std@@@@QBEIXZ ; xalloc<std::_Tree_node<NvFaceInfo *,void *> >::max_size
PUBLIC	?_Get_first@?$_Compressed_pair@V?$xalloc@U?$_Tree_node@PAVNvFaceInfo@@PAX@std@@@@V?$_Tree_val@U?$_Tree_simple_types@PAVNvFaceInfo@@@std@@@std@@$00@std@@QBEABV?$xalloc@U?$_Tree_node@PAVNvFaceInfo@@PAX@std@@@@XZ ; std::_Compressed_pair<xalloc<std::_Tree_node<NvFaceInfo *,void *> >,std::_Tree_val<std::_Tree_simple_types<NvFaceInfo *> >,1>::_Get_first
PUBLIC	?max_size@?$xalloc@PAVNvEdgeInfo@@@@QBEIXZ	; xalloc<NvEdgeInfo *>::max_size
PUBLIC	?_Get_first@?$_Compressed_pair@V?$xalloc@PAVNvEdgeInfo@@@@V?$_Vector_val@U?$_Simple_types@PAVNvEdgeInfo@@@std@@@std@@$00@std@@QBEABV?$xalloc@PAVNvEdgeInfo@@@@XZ ; std::_Compressed_pair<xalloc<NvEdgeInfo *>,std::_Vector_val<std::_Simple_types<NvEdgeInfo *> >,1>::_Get_first
PUBLIC	?max_size@?$xalloc@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@@QBEIXZ ; xalloc<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> > >::max_size
PUBLIC	?_Get_first@?$_Compressed_pair@V?$xalloc@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@@V?$_Vector_val@U?$_Simple_types@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@std@@@std@@$00@std@@QBEABV?$xalloc@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@@XZ ; std::_Compressed_pair<xalloc<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> > >,std::_Vector_val<std::_Simple_types<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> > > >,1>::_Get_first
PUBLIC	?max_size@?$_Normal_allocator_traits@V?$xalloc@U?$_Tree_node@PAVNvFaceInfo@@PAX@std@@@@@std@@SAIABV?$xalloc@U?$_Tree_node@PAVNvFaceInfo@@PAX@std@@@@@Z ; std::_Normal_allocator_traits<xalloc<std::_Tree_node<NvFaceInfo *,void *> > >::max_size
PUBLIC	?_Getal@?$_Tree@V?$_Tset_traits@PAVNvFaceInfo@@U?$less@PAVNvFaceInfo@@@std@@V?$xalloc@PAVNvFaceInfo@@@@$0A@@std@@@std@@IBEABV?$xalloc@U?$_Tree_node@PAVNvFaceInfo@@PAX@std@@@@XZ ; std::_Tree<std::_Tset_traits<NvFaceInfo *,std::less<NvFaceInfo *>,xalloc<NvFaceInfo *>,0> >::_Getal
PUBLIC	?max_size@?$_Normal_allocator_traits@V?$xalloc@PAVNvEdgeInfo@@@@@std@@SAIABV?$xalloc@PAVNvEdgeInfo@@@@@Z ; std::_Normal_allocator_traits<xalloc<NvEdgeInfo *> >::max_size
PUBLIC	?capacity@?$vector@PAVNvEdgeInfo@@V?$xalloc@PAVNvEdgeInfo@@@@@std@@QBEIXZ ; std::vector<NvEdgeInfo *,xalloc<NvEdgeInfo *> >::capacity
PUBLIC	?_Umove_if_noexcept1@?$vector@PAVNvEdgeInfo@@V?$xalloc@PAVNvEdgeInfo@@@@@std@@AAEXPAPAVNvEdgeInfo@@00U?$integral_constant@_N$00@2@@Z ; std::vector<NvEdgeInfo *,xalloc<NvEdgeInfo *> >::_Umove_if_noexcept1
PUBLIC	?_Getal@?$vector@PAVNvEdgeInfo@@V?$xalloc@PAVNvEdgeInfo@@@@@std@@ABEABV?$xalloc@PAVNvEdgeInfo@@@@XZ ; std::vector<NvEdgeInfo *,xalloc<NvEdgeInfo *> >::_Getal
PUBLIC	?max_size@?$_Normal_allocator_traits@V?$xalloc@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@@@std@@SAIABV?$xalloc@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@@@Z ; std::_Normal_allocator_traits<xalloc<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> > > >::max_size
PUBLIC	?capacity@?$vector@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@V?$xalloc@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@@@std@@QBEIXZ ; std::vector<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> >,xalloc<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> > > >::capacity
PUBLIC	?_Umove_if_noexcept1@?$vector@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@V?$xalloc@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@@@std@@AAEXPAV?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@00U?$integral_constant@_N$00@2@@Z ; std::vector<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> >,xalloc<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> > > >::_Umove_if_noexcept1
PUBLIC	?_Getal@?$vector@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@V?$xalloc@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@@@std@@ABEABV?$xalloc@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@@XZ ; std::vector<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> >,xalloc<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> > > >::_Getal
PUBLIC	?deallocate@?$xalloc@U?$_Tree_node@PAVNvFaceInfo@@PAX@std@@@@QBEXPAU?$_Tree_node@PAVNvFaceInfo@@PAX@std@@I@Z ; xalloc<std::_Tree_node<NvFaceInfo *,void *> >::deallocate
PUBLIC	?max_size@?$_Tree@V?$_Tset_traits@PAVNvFaceInfo@@U?$less@PAVNvFaceInfo@@@std@@V?$xalloc@PAVNvFaceInfo@@@@$0A@@std@@@std@@QBEIXZ ; std::_Tree<std::_Tset_traits<NvFaceInfo *,std::less<NvFaceInfo *>,xalloc<NvFaceInfo *>,0> >::max_size
PUBLIC	?_Lrotate@?$_Tree_val@U?$_Tree_simple_types@PAVNvFaceInfo@@@std@@@std@@QAEXPAU?$_Tree_node@PAVNvFaceInfo@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<NvFaceInfo *> >::_Lrotate
PUBLIC	?_Rrotate@?$_Tree_val@U?$_Tree_simple_types@PAVNvFaceInfo@@@std@@@std@@QAEXPAU?$_Tree_node@PAVNvFaceInfo@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<NvFaceInfo *> >::_Rrotate
PUBLIC	?_Get_first@?$_Compressed_pair@U?$less@PAVNvFaceInfo@@@std@@V?$_Compressed_pair@V?$xalloc@U?$_Tree_node@PAVNvFaceInfo@@PAX@std@@@@V?$_Tree_val@U?$_Tree_simple_types@PAVNvFaceInfo@@@std@@@std@@$00@2@$00@std@@QBEABU?$less@PAVNvFaceInfo@@@2@XZ ; std::_Compressed_pair<std::less<NvFaceInfo *>,std::_Compressed_pair<xalloc<std::_Tree_node<NvFaceInfo *,void *> >,std::_Tree_val<std::_Tree_simple_types<NvFaceInfo *> >,1>,1>::_Get_first
PUBLIC	??1?$_Alloc_construct_ptr@V?$xalloc@U?$_Tree_node@PAVNvFaceInfo@@PAX@std@@@@@std@@QAE@XZ ; std::_Alloc_construct_ptr<xalloc<std::_Tree_node<NvFaceInfo *,void *> > >::~_Alloc_construct_ptr<xalloc<std::_Tree_node<NvFaceInfo *,void *> > >
PUBLIC	??1?$_Tree_temp_node_alloc@V?$xalloc@U?$_Tree_node@PAVNvFaceInfo@@PAX@std@@@@@std@@QAE@XZ ; std::_Tree_temp_node_alloc<xalloc<std::_Tree_node<NvFaceInfo *,void *> > >::~_Tree_temp_node_alloc<xalloc<std::_Tree_node<NvFaceInfo *,void *> > >
PUBLIC	?allocate@?$xalloc@PAVNvEdgeInfo@@@@QBEPAPAVNvEdgeInfo@@IPBX@Z ; xalloc<NvEdgeInfo *>::allocate
PUBLIC	?destroy@?$xalloc@PAVNvEdgeInfo@@@@QAEXPAPAVNvEdgeInfo@@@Z ; xalloc<NvEdgeInfo *>::destroy
PUBLIC	?max_size@?$vector@PAVNvEdgeInfo@@V?$xalloc@PAVNvEdgeInfo@@@@@std@@QBEIXZ ; std::vector<NvEdgeInfo *,xalloc<NvEdgeInfo *> >::max_size
PUBLIC	?_Umove_if_noexcept@?$vector@PAVNvEdgeInfo@@V?$xalloc@PAVNvEdgeInfo@@@@@std@@AAEXPAPAVNvEdgeInfo@@00@Z ; std::vector<NvEdgeInfo *,xalloc<NvEdgeInfo *> >::_Umove_if_noexcept
PUBLIC	?_Calculate_growth@?$vector@PAVNvEdgeInfo@@V?$xalloc@PAVNvEdgeInfo@@@@@std@@ABEII@Z ; std::vector<NvEdgeInfo *,xalloc<NvEdgeInfo *> >::_Calculate_growth
PUBLIC	?_Change_array@?$vector@PAVNvEdgeInfo@@V?$xalloc@PAVNvEdgeInfo@@@@@std@@AAEXQAPAVNvEdgeInfo@@II@Z ; std::vector<NvEdgeInfo *,xalloc<NvEdgeInfo *> >::_Change_array
PUBLIC	?_Xlength@?$vector@PAVNvEdgeInfo@@V?$xalloc@PAVNvEdgeInfo@@@@@std@@CAXXZ ; std::vector<NvEdgeInfo *,xalloc<NvEdgeInfo *> >::_Xlength
PUBLIC	?allocate@?$xalloc@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@@QBEPAV?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@IPBX@Z ; xalloc<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> > >::allocate
PUBLIC	?destroy@?$xalloc@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@@QAEXPAV?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@Z ; xalloc<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> > >::destroy
PUBLIC	?max_size@?$vector@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@V?$xalloc@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@@@std@@QBEIXZ ; std::vector<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> >,xalloc<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> > > >::max_size
PUBLIC	?_Umove_if_noexcept@?$vector@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@V?$xalloc@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@@@std@@AAEXPAV?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@00@Z ; std::vector<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> >,xalloc<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> > > >::_Umove_if_noexcept
PUBLIC	?_Calculate_growth@?$vector@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@V?$xalloc@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@@@std@@ABEII@Z ; std::vector<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> >,xalloc<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> > > >::_Calculate_growth
PUBLIC	?_Change_array@?$vector@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@V?$xalloc@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@@@std@@AAEXQAV?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@II@Z ; std::vector<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> >,xalloc<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> > > >::_Change_array
PUBLIC	?_Xlength@?$vector@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@V?$xalloc@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@@@std@@CAXXZ ; std::vector<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> >,xalloc<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> > > >::_Xlength
PUBLIC	?_Kfn@?$_Tset_traits@PAVNvFaceInfo@@U?$less@PAVNvFaceInfo@@@std@@V?$xalloc@PAVNvFaceInfo@@@@$0A@@std@@SAABQAVNvFaceInfo@@ABQAV3@@Z ; std::_Tset_traits<NvFaceInfo *,std::less<NvFaceInfo *>,xalloc<NvFaceInfo *>,0>::_Kfn
PUBLIC	??0?$xalloc@U?$_Tree_node@PAVNvFaceInfo@@PAX@std@@@@QAE@XZ ; xalloc<std::_Tree_node<NvFaceInfo *,void *> >::xalloc<std::_Tree_node<NvFaceInfo *,void *> >
PUBLIC	?deallocate@?$_Normal_allocator_traits@V?$xalloc@U?$_Tree_node@PAVNvFaceInfo@@PAX@std@@@@@std@@SAXAAV?$xalloc@U?$_Tree_node@PAVNvFaceInfo@@PAX@std@@@@PAU?$_Tree_node@PAVNvFaceInfo@@PAX@2@I@Z ; std::_Normal_allocator_traits<xalloc<std::_Tree_node<NvFaceInfo *,void *> > >::deallocate
PUBLIC	?_Check_grow_by_1@?$_Tree@V?$_Tset_traits@PAVNvFaceInfo@@U?$less@PAVNvFaceInfo@@@std@@V?$xalloc@PAVNvFaceInfo@@@@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tset_traits<NvFaceInfo *,std::less<NvFaceInfo *>,xalloc<NvFaceInfo *>,0> >::_Check_grow_by_1
PUBLIC	?_Getcomp@?$_Tree@V?$_Tset_traits@PAVNvFaceInfo@@U?$less@PAVNvFaceInfo@@@std@@V?$xalloc@PAVNvFaceInfo@@@@$0A@@std@@@std@@IBEABU?$less@PAVNvFaceInfo@@@2@XZ ; std::_Tree<std::_Tset_traits<NvFaceInfo *,std::less<NvFaceInfo *>,xalloc<NvFaceInfo *>,0> >::_Getcomp
PUBLIC	??R?$less@PAVNvFaceInfo@@@std@@QBE_NABQAVNvFaceInfo@@0@Z ; std::less<NvFaceInfo *>::operator()
PUBLIC	??0?$_Tree_val@U?$_Tree_simple_types@PAVNvFaceInfo@@@std@@@std@@QAE@XZ ; std::_Tree_val<std::_Tree_simple_types<NvFaceInfo *> >::_Tree_val<std::_Tree_simple_types<NvFaceInfo *> >
PUBLIC	?_Insert_node@?$_Tree_val@U?$_Tree_simple_types@PAVNvFaceInfo@@@std@@@std@@QAEPAU?$_Tree_node@PAVNvFaceInfo@@PAX@2@U?$_Tree_id@PAU?$_Tree_node@PAVNvFaceInfo@@PAX@std@@@2@QAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<NvFaceInfo *> >::_Insert_node
PUBLIC	?_Extract@?$_In_place_key_extract_set@PAVNvFaceInfo@@PAV1@@std@@SAABQAVNvFaceInfo@@ABQAV3@@Z ; std::_In_place_key_extract_set<NvFaceInfo *,NvFaceInfo *>::_Extract
PUBLIC	?_Release@?$_Alloc_construct_ptr@V?$xalloc@U?$_Tree_node@PAVNvFaceInfo@@PAX@std@@@@@std@@QAEPAU?$_Tree_node@PAVNvFaceInfo@@PAX@2@XZ ; std::_Alloc_construct_ptr<xalloc<std::_Tree_node<NvFaceInfo *,void *> > >::_Release
PUBLIC	??1?$_Tree_temp_node@V?$xalloc@U?$_Tree_node@PAVNvFaceInfo@@PAX@std@@@@@std@@QAE@XZ ; std::_Tree_temp_node<xalloc<std::_Tree_node<NvFaceInfo *,void *> > >::~_Tree_temp_node<xalloc<std::_Tree_node<NvFaceInfo *,void *> > >
PUBLIC	??0?$_Uninitialized_backout_al@V?$xalloc@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@@@std@@QAE@PAV?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@AAV?$xalloc@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@@@Z ; std::_Uninitialized_backout_al<xalloc<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> > > >::_Uninitialized_backout_al<xalloc<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> > > >
PUBLIC	??1?$_Uninitialized_backout_al@V?$xalloc@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@@@std@@QAE@XZ ; std::_Uninitialized_backout_al<xalloc<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> > > >::~_Uninitialized_backout_al<xalloc<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> > > >
PUBLIC	?_Release@?$_Uninitialized_backout_al@V?$xalloc@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@@@std@@QAEPAV?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@XZ ; std::_Uninitialized_backout_al<xalloc<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> > > >::_Release
PUBLIC	??0?$_Uninitialized_backout_al@V?$xalloc@PAVNvStripInfo@@@@@std@@QAE@PAPAVNvStripInfo@@AAV?$xalloc@PAVNvStripInfo@@@@@Z ; std::_Uninitialized_backout_al<xalloc<NvStripInfo *> >::_Uninitialized_backout_al<xalloc<NvStripInfo *> >
PUBLIC	??1?$_Uninitialized_backout_al@V?$xalloc@PAVNvStripInfo@@@@@std@@QAE@XZ ; std::_Uninitialized_backout_al<xalloc<NvStripInfo *> >::~_Uninitialized_backout_al<xalloc<NvStripInfo *> >
PUBLIC	?_Release@?$_Uninitialized_backout_al@V?$xalloc@PAVNvStripInfo@@@@@std@@QAEPAPAVNvStripInfo@@XZ ; std::_Uninitialized_backout_al<xalloc<NvStripInfo *> >::_Release
PUBLIC	??0?$_Uninitialized_backout_al@V?$xalloc@PAVNvEdgeInfo@@@@@std@@QAE@PAPAVNvEdgeInfo@@AAV?$xalloc@PAVNvEdgeInfo@@@@@Z ; std::_Uninitialized_backout_al<xalloc<NvEdgeInfo *> >::_Uninitialized_backout_al<xalloc<NvEdgeInfo *> >
PUBLIC	??1?$_Uninitialized_backout_al@V?$xalloc@PAVNvEdgeInfo@@@@@std@@QAE@XZ ; std::_Uninitialized_backout_al<xalloc<NvEdgeInfo *> >::~_Uninitialized_backout_al<xalloc<NvEdgeInfo *> >
PUBLIC	?_Release@?$_Uninitialized_backout_al@V?$xalloc@PAVNvEdgeInfo@@@@@std@@QAEPAPAVNvEdgeInfo@@XZ ; std::_Uninitialized_backout_al<xalloc<NvEdgeInfo *> >::_Release
PUBLIC	??0?$_Uninitialized_backout_al@V?$xalloc@H@@@std@@QAE@PAHAAV?$xalloc@H@@@Z ; std::_Uninitialized_backout_al<xalloc<int> >::_Uninitialized_backout_al<xalloc<int> >
PUBLIC	??1?$_Uninitialized_backout_al@V?$xalloc@H@@@std@@QAE@XZ ; std::_Uninitialized_backout_al<xalloc<int> >::~_Uninitialized_backout_al<xalloc<int> >
PUBLIC	?_Release@?$_Uninitialized_backout_al@V?$xalloc@H@@@std@@QAEPAHXZ ; std::_Uninitialized_backout_al<xalloc<int> >::_Release
PUBLIC	??$_Get_unwrapped@ABQAH@std@@YA?A_TABQAH@Z	; std::_Get_unwrapped<int * const &>
PUBLIC	??$_Uninitialized_move@PAHV?$xalloc@H@@@std@@YAPAHQAH0PAHAAV?$xalloc@H@@@Z ; std::_Uninitialized_move<int *,xalloc<int> >
PUBLIC	??$xr_alloc@PAVNvStripInfo@@@@YAPAPAVNvStripInfo@@I@Z ; xr_alloc<NvStripInfo *>
PUBLIC	??$_Uninitialized_value_construct_n@V?$xalloc@PAVNvEdgeInfo@@@@@std@@YAPAPAVNvEdgeInfo@@PAPAV1@IAAV?$xalloc@PAVNvEdgeInfo@@@@@Z ; std::_Uninitialized_value_construct_n<xalloc<NvEdgeInfo *> >
PUBLIC	??$_Get_unwrapped@ABQAPAVNvStripInfo@@@std@@YA?A_TABQAPAVNvStripInfo@@@Z ; std::_Get_unwrapped<NvStripInfo * * const &>
PUBLIC	??$_Uninitialized_move@PAPAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@std@@YAPAPAVNvStripInfo@@QAPAV1@0PAPAV1@AAV?$xalloc@PAVNvStripInfo@@@@@Z ; std::_Uninitialized_move<NvStripInfo * *,xalloc<NvStripInfo *> >
PUBLIC	??$_Uninitialized_value_construct_n@V?$xalloc@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@@@std@@YAPAV?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@PAV1@IAAV?$xalloc@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@@@Z ; std::_Uninitialized_value_construct_n<xalloc<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> > > >
PUBLIC	??$xr_alloc@U?$_Tree_node@PAVNvFaceInfo@@PAX@std@@@@YAPAU?$_Tree_node@PAVNvFaceInfo@@PAX@std@@I@Z ; xr_alloc<std::_Tree_node<NvFaceInfo *,void *> >
PUBLIC	??$addressof@$$CBV?$_Tree_val@U?$_Tree_simple_types@PAVNvFaceInfo@@@std@@@std@@@std@@YAPBV?$_Tree_val@U?$_Tree_simple_types@PAVNvFaceInfo@@@std@@@0@ABV10@@Z ; std::addressof<std::_Tree_val<std::_Tree_simple_types<NvFaceInfo *> > const >
PUBLIC	??$_Emplace_back@PAVNvFaceInfo@@@?$_Uninitialized_backout_al@V?$xalloc@PAVNvFaceInfo@@@@@std@@QAEX$$QAPAVNvFaceInfo@@@Z ; std::_Uninitialized_backout_al<xalloc<NvFaceInfo *> >::_Emplace_back<NvFaceInfo *>
PUBLIC	??$move@AAPAVNvFaceInfo@@@std@@YA$$QAPAVNvFaceInfo@@AAPAV1@@Z ; std::move<NvFaceInfo * &>
PUBLIC	??$destroy@PAVNvEdgeInfo@@@?$_Normal_allocator_traits@V?$xalloc@PAVNvEdgeInfo@@@@@std@@SAXAAV?$xalloc@PAVNvEdgeInfo@@@@PAPAVNvEdgeInfo@@@Z ; std::_Normal_allocator_traits<xalloc<NvEdgeInfo *> >::destroy<NvEdgeInfo *>
PUBLIC	??$_Unfancy@PAVNvEdgeInfo@@@std@@YAPAPAVNvEdgeInfo@@PAPAV1@@Z ; std::_Unfancy<NvEdgeInfo *>
PUBLIC	??$destroy@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@?$_Normal_allocator_traits@V?$xalloc@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@@@std@@SAXAAV?$xalloc@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@@PAV?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@Z ; std::_Normal_allocator_traits<xalloc<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> > > >::destroy<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> > >
PUBLIC	??$_Unfancy@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@std@@YAPAV?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@PAV1@@Z ; std::_Unfancy<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> > >
PUBLIC	??$_Construct_in_place@PAU?$_Tree_node@PAVNvFaceInfo@@PAX@std@@ABQAU12@@std@@YAXAAPAU?$_Tree_node@PAVNvFaceInfo@@PAX@0@ABQAU10@@Z ; std::_Construct_in_place<std::_Tree_node<NvFaceInfo *,void *> *,std::_Tree_node<NvFaceInfo *,void *> * const &>
PUBLIC	??$forward@ABU?$less@PAVNvFaceInfo@@@std@@@std@@YAABU?$less@PAVNvFaceInfo@@@0@ABU10@@Z ; std::forward<std::less<NvFaceInfo *> const &>
PUBLIC	??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@PAVNvEdgeInfo@@V?$xalloc@PAVNvEdgeInfo@@@@@std@@AAEXIABU_Value_init_tag@1@@Z ; std::vector<NvEdgeInfo *,xalloc<NvEdgeInfo *> >::_Resize_reallocate<std::_Value_init_tag>
PUBLIC	??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@V?$xalloc@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@@@std@@AAEXIABU_Value_init_tag@1@@Z ; std::vector<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> >,xalloc<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> > > >::_Resize_reallocate<std::_Value_init_tag>
PUBLIC	??$_Freenode0@V?$xalloc@U?$_Tree_node@PAVNvFaceInfo@@PAX@std@@@@@?$_Tree_node@PAVNvFaceInfo@@PAX@std@@SAXAAV?$xalloc@U?$_Tree_node@PAVNvFaceInfo@@PAX@std@@@@PAU01@@Z ; std::_Tree_node<NvFaceInfo *,void *>::_Freenode0<xalloc<std::_Tree_node<NvFaceInfo *,void *> > >
PUBLIC	??$_Erase_tree@V?$xalloc@U?$_Tree_node@PAVNvFaceInfo@@PAX@std@@@@@?$_Tree_val@U?$_Tree_simple_types@PAVNvFaceInfo@@@std@@@std@@QAEXAAV?$xalloc@U?$_Tree_node@PAVNvFaceInfo@@PAX@std@@@@PAU?$_Tree_node@PAVNvFaceInfo@@PAX@1@@Z ; std::_Tree_val<std::_Tree_simple_types<NvFaceInfo *> >::_Erase_tree<xalloc<std::_Tree_node<NvFaceInfo *,void *> > >
PUBLIC	??$_Lower_bound_duplicate@PAVNvFaceInfo@@@?$_Tree@V?$_Tset_traits@PAVNvFaceInfo@@U?$less@PAVNvFaceInfo@@@std@@V?$xalloc@PAVNvFaceInfo@@@@$0A@@std@@@std@@IBE_NQAU?$_Tree_node@PAVNvFaceInfo@@PAX@1@ABQAVNvFaceInfo@@@Z ; std::_Tree<std::_Tset_traits<NvFaceInfo *,std::less<NvFaceInfo *>,xalloc<NvFaceInfo *>,0> >::_Lower_bound_duplicate<NvFaceInfo *>
PUBLIC	??$_Find_lower_bound@PAVNvFaceInfo@@@?$_Tree@V?$_Tset_traits@PAVNvFaceInfo@@U?$less@PAVNvFaceInfo@@@std@@V?$xalloc@PAVNvFaceInfo@@@@$0A@@std@@@std@@IBE?AU?$_Tree_find_result@PAU?$_Tree_node@PAVNvFaceInfo@@PAX@std@@@1@ABQAVNvFaceInfo@@@Z ; std::_Tree<std::_Tset_traits<NvFaceInfo *,std::less<NvFaceInfo *>,xalloc<NvFaceInfo *>,0> >::_Find_lower_bound<NvFaceInfo *>
PUBLIC	??$?0V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@PAVNvFaceInfo@@@std@@@std@@@std@@AB_N$0A@@?$pair@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@PAVNvFaceInfo@@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@PAVNvFaceInfo@@@std@@@std@@@1@AB_N@Z ; std::pair<std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<NvFaceInfo *> > >,bool>::pair<std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<NvFaceInfo *> > >,bool><std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<NvFaceInfo *> > >,bool const &,0>
PUBLIC	??$_Emplace@ABQAVNvFaceInfo@@@?$_Tree@V?$_Tset_traits@PAVNvFaceInfo@@U?$less@PAVNvFaceInfo@@@std@@V?$xalloc@PAVNvFaceInfo@@@@$0A@@std@@@std@@IAE?AU?$pair@PAU?$_Tree_node@PAVNvFaceInfo@@PAX@std@@_N@1@ABQAVNvFaceInfo@@@Z ; std::_Tree<std::_Tset_traits<NvFaceInfo *,std::less<NvFaceInfo *>,xalloc<NvFaceInfo *>,0> >::_Emplace<NvFaceInfo * const &>
PUBLIC	??$?0$$V@?$_Compressed_pair@V?$xalloc@U?$_Tree_node@PAVNvFaceInfo@@PAX@std@@@@V?$_Tree_val@U?$_Tree_simple_types@PAVNvFaceInfo@@@std@@@std@@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<xalloc<std::_Tree_node<NvFaceInfo *,void *> >,std::_Tree_val<std::_Tree_simple_types<NvFaceInfo *> >,1>::_Compressed_pair<xalloc<std::_Tree_node<NvFaceInfo *,void *> >,std::_Tree_val<std::_Tree_simple_types<NvFaceInfo *> >,1><>
PUBLIC	?max_size@?$xalloc@H@@QBEIXZ			; xalloc<int>::max_size
PUBLIC	?_Get_first@?$_Compressed_pair@V?$xalloc@H@@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@$00@std@@QBEABV?$xalloc@H@@XZ ; std::_Compressed_pair<xalloc<int>,std::_Vector_val<std::_Simple_types<int> >,1>::_Get_first
PUBLIC	?max_size@?$xalloc@PAVNvStripInfo@@@@QBEIXZ	; xalloc<NvStripInfo *>::max_size
PUBLIC	?_Get_first@?$_Compressed_pair@V?$xalloc@PAVNvStripInfo@@@@V?$_Vector_val@U?$_Simple_types@PAVNvStripInfo@@@std@@@std@@$00@std@@QBEABV?$xalloc@PAVNvStripInfo@@@@XZ ; std::_Compressed_pair<xalloc<NvStripInfo *>,std::_Vector_val<std::_Simple_types<NvStripInfo *> >,1>::_Get_first
PUBLIC	?max_size@?$_Normal_allocator_traits@V?$xalloc@H@@@std@@SAIABV?$xalloc@H@@@Z ; std::_Normal_allocator_traits<xalloc<int> >::max_size
PUBLIC	?capacity@?$vector@HV?$xalloc@H@@@std@@QBEIXZ	; std::vector<int,xalloc<int> >::capacity
PUBLIC	?_Umove_if_noexcept1@?$vector@HV?$xalloc@H@@@std@@AAEXPAH00U?$integral_constant@_N$00@2@@Z ; std::vector<int,xalloc<int> >::_Umove_if_noexcept1
PUBLIC	?_Getal@?$vector@HV?$xalloc@H@@@std@@ABEABV?$xalloc@H@@XZ ; std::vector<int,xalloc<int> >::_Getal
PUBLIC	?max_size@?$_Normal_allocator_traits@V?$xalloc@PAVNvStripInfo@@@@@std@@SAIABV?$xalloc@PAVNvStripInfo@@@@@Z ; std::_Normal_allocator_traits<xalloc<NvStripInfo *> >::max_size
PUBLIC	?capacity@?$vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@std@@QBEIXZ ; std::vector<NvStripInfo *,xalloc<NvStripInfo *> >::capacity
PUBLIC	?_Umove_if_noexcept1@?$vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@std@@AAEXPAPAVNvStripInfo@@00U?$integral_constant@_N$00@2@@Z ; std::vector<NvStripInfo *,xalloc<NvStripInfo *> >::_Umove_if_noexcept1
PUBLIC	?_Getal@?$vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@std@@ABEABV?$xalloc@PAVNvStripInfo@@@@XZ ; std::vector<NvStripInfo *,xalloc<NvStripInfo *> >::_Getal
PUBLIC	??_GVertexCache@@QAEPAXI@Z			; VertexCache::`scalar deleting destructor'
PUBLIC	?allocate@?$xalloc@H@@QBEPAHIPBX@Z		; xalloc<int>::allocate
PUBLIC	?construct@?$xalloc@H@@QAEXPAHABH@Z		; xalloc<int>::construct
PUBLIC	?max_size@?$vector@HV?$xalloc@H@@@std@@QBEIXZ	; std::vector<int,xalloc<int> >::max_size
PUBLIC	?_Umove@?$vector@HV?$xalloc@H@@@std@@AAEPAHPAH00@Z ; std::vector<int,xalloc<int> >::_Umove
PUBLIC	?_Umove_if_noexcept@?$vector@HV?$xalloc@H@@@std@@AAEXPAH00@Z ; std::vector<int,xalloc<int> >::_Umove_if_noexcept
PUBLIC	?_Calculate_growth@?$vector@HV?$xalloc@H@@@std@@ABEII@Z ; std::vector<int,xalloc<int> >::_Calculate_growth
PUBLIC	?_Change_array@?$vector@HV?$xalloc@H@@@std@@AAEXQAHII@Z ; std::vector<int,xalloc<int> >::_Change_array
PUBLIC	?_Xlength@?$vector@HV?$xalloc@H@@@std@@CAXXZ	; std::vector<int,xalloc<int> >::_Xlength
PUBLIC	?_Umove@?$vector@GV?$xalloc@G@@@std@@AAEPAGPAG00@Z ; std::vector<unsigned short,xalloc<unsigned short> >::_Umove
PUBLIC	?construct@?$xalloc@PAVNvFaceInfo@@@@QAEXPAPAVNvFaceInfo@@ABQAV2@@Z ; xalloc<NvFaceInfo *>::construct
PUBLIC	?_Umove@?$vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@std@@AAEPAPAVNvFaceInfo@@PAPAV3@00@Z ; std::vector<NvFaceInfo *,xalloc<NvFaceInfo *> >::_Umove
PUBLIC	?_Calculate_growth@?$vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@std@@ABEII@Z ; std::vector<NvFaceInfo *,xalloc<NvFaceInfo *> >::_Calculate_growth
PUBLIC	?allocate@?$xalloc@PAVNvStripInfo@@@@QBEPAPAVNvStripInfo@@IPBX@Z ; xalloc<NvStripInfo *>::allocate
PUBLIC	?construct@?$xalloc@PAVNvStripInfo@@@@QAEXPAPAVNvStripInfo@@ABQAV2@@Z ; xalloc<NvStripInfo *>::construct
PUBLIC	??0?$xalloc@PAVNvEdgeInfo@@@@QAE@XZ		; xalloc<NvEdgeInfo *>::xalloc<NvEdgeInfo *>
PUBLIC	?_Ufill@?$vector@PAVNvEdgeInfo@@V?$xalloc@PAVNvEdgeInfo@@@@@std@@AAEPAPAVNvEdgeInfo@@PAPAV3@IU_Value_init_tag@2@@Z ; std::vector<NvEdgeInfo *,xalloc<NvEdgeInfo *> >::_Ufill
PUBLIC	?_Orphan_range@?$vector@PAVNvEdgeInfo@@V?$xalloc@PAVNvEdgeInfo@@@@@std@@ABEXPAPAVNvEdgeInfo@@0@Z ; std::vector<NvEdgeInfo *,xalloc<NvEdgeInfo *> >::_Orphan_range
PUBLIC	??0?$_Vector_val@U?$_Simple_types@PAVNvEdgeInfo@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<NvEdgeInfo *> >::_Vector_val<std::_Simple_types<NvEdgeInfo *> >
PUBLIC	?max_size@?$vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@std@@QBEIXZ ; std::vector<NvStripInfo *,xalloc<NvStripInfo *> >::max_size
PUBLIC	?_Umove@?$vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@std@@AAEPAPAVNvStripInfo@@PAPAV3@00@Z ; std::vector<NvStripInfo *,xalloc<NvStripInfo *> >::_Umove
PUBLIC	?_Umove_if_noexcept@?$vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@std@@AAEXPAPAVNvStripInfo@@00@Z ; std::vector<NvStripInfo *,xalloc<NvStripInfo *> >::_Umove_if_noexcept
PUBLIC	?_Calculate_growth@?$vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@std@@ABEII@Z ; std::vector<NvStripInfo *,xalloc<NvStripInfo *> >::_Calculate_growth
PUBLIC	?_Change_array@?$vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@std@@AAEXQAPAVNvStripInfo@@II@Z ; std::vector<NvStripInfo *,xalloc<NvStripInfo *> >::_Change_array
PUBLIC	?_Xlength@?$vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@std@@CAXXZ ; std::vector<NvStripInfo *,xalloc<NvStripInfo *> >::_Xlength
PUBLIC	??0?$xalloc@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@@QAE@XZ ; xalloc<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> > >::xalloc<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> > >
PUBLIC	?_Ufill@?$vector@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@V?$xalloc@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@@@std@@AAEPAV?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@PAV3@IU_Value_init_tag@2@@Z ; std::vector<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> >,xalloc<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> > > >::_Ufill
PUBLIC	?_Orphan_range@?$vector@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@V?$xalloc@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@@@std@@ABEXPAV?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@0@Z ; std::vector<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> >,xalloc<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> > > >::_Orphan_range
PUBLIC	??0?$_Vector_val@U?$_Simple_types@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> > > >::_Vector_val<std::_Simple_types<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> > > >
PUBLIC	?allocate@?$xalloc@U?$_Tree_node@PAVNvFaceInfo@@PAX@std@@@@QBEPAU?$_Tree_node@PAVNvFaceInfo@@PAX@std@@IPBX@Z ; xalloc<std::_Tree_node<NvFaceInfo *,void *> >::allocate
PUBLIC	?_Get_scary@?$_Tree@V?$_Tset_traits@PAVNvFaceInfo@@U?$less@PAVNvFaceInfo@@@std@@V?$xalloc@PAVNvFaceInfo@@@@$0A@@std@@@std@@IBEPBV?$_Tree_val@U?$_Tree_simple_types@PAVNvFaceInfo@@@std@@@2@XZ ; std::_Tree<std::_Tset_traits<NvFaceInfo *,std::less<NvFaceInfo *>,xalloc<NvFaceInfo *>,0> >::_Get_scary
PUBLIC	??R?$xr_special_free@$0A@VVertexCache@@@@QAEXAAPAVVertexCache@@@Z ; xr_special_free<0,VertexCache>::operator()
PUBLIC	??0?$_Uninitialized_backout_al@V?$xalloc@PAVNvFaceInfo@@@@@std@@QAE@PAPAVNvFaceInfo@@AAV?$xalloc@PAVNvFaceInfo@@@@@Z ; std::_Uninitialized_backout_al<xalloc<NvFaceInfo *> >::_Uninitialized_backout_al<xalloc<NvFaceInfo *> >
PUBLIC	??1?$_Uninitialized_backout_al@V?$xalloc@PAVNvFaceInfo@@@@@std@@QAE@XZ ; std::_Uninitialized_backout_al<xalloc<NvFaceInfo *> >::~_Uninitialized_backout_al<xalloc<NvFaceInfo *> >
PUBLIC	?_Release@?$_Uninitialized_backout_al@V?$xalloc@PAVNvFaceInfo@@@@@std@@QAEPAPAVNvFaceInfo@@XZ ; std::_Uninitialized_backout_al<xalloc<NvFaceInfo *> >::_Release
PUBLIC	??$_Get_unwrapped@ABQAPAVNvFaceInfo@@@std@@YA?A_TABQAPAVNvFaceInfo@@@Z ; std::_Get_unwrapped<NvFaceInfo * * const &>
PUBLIC	??$_Uninitialized_move@PAPAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@std@@YAPAPAVNvFaceInfo@@QAPAV1@0PAPAV1@AAV?$xalloc@PAVNvFaceInfo@@@@@Z ; std::_Uninitialized_move<NvFaceInfo * *,xalloc<NvFaceInfo *> >
PUBLIC	??$xr_alloc@PAVNvFaceInfo@@@@YAPAPAVNvFaceInfo@@I@Z ; xr_alloc<NvFaceInfo *>
PUBLIC	??$xr_free@PAVNvEdgeInfo@@@@YAXAAPAPAVNvEdgeInfo@@@Z ; xr_free<NvEdgeInfo *>
PUBLIC	??$_Destroy_range@V?$xalloc@PAVNvEdgeInfo@@@@@std@@YAXPAPAVNvEdgeInfo@@QAPAV1@AAV?$xalloc@PAVNvEdgeInfo@@@@@Z ; std::_Destroy_range<xalloc<NvEdgeInfo *> >
PUBLIC	??$xr_free@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@@YAXAAPAV?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@Z ; xr_free<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> > >
PUBLIC	??$_Destroy_range@V?$xalloc@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@@@std@@YAXPAV?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@QAV1@AAV?$xalloc@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@@@Z ; std::_Destroy_range<xalloc<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> > > >
PUBLIC	??$_Buyheadnode@V?$xalloc@U?$_Tree_node@PAVNvFaceInfo@@PAX@std@@@@@?$_Tree_node@PAVNvFaceInfo@@PAX@std@@SAPAU01@AAV?$xalloc@U?$_Tree_node@PAVNvFaceInfo@@PAX@std@@@@@Z ; std::_Tree_node<NvFaceInfo *,void *>::_Buyheadnode<xalloc<std::_Tree_node<NvFaceInfo *,void *> > >
PUBLIC	??$_Pocca@V?$xalloc@G@@@std@@YAXAAV?$xalloc@G@@ABV1@@Z ; std::_Pocca<xalloc<unsigned short> >
PUBLIC	??$addressof@$$CBV?$_Vector_val@U?$_Simple_types@G@std@@@std@@@std@@YAPBV?$_Vector_val@U?$_Simple_types@G@std@@@0@ABV10@@Z ; std::addressof<std::_Vector_val<std::_Simple_types<unsigned short> > const >
PUBLIC	??$addressof@$$CBV?$_Vector_val@U?$_Simple_types@PAVNvFaceInfo@@@std@@@std@@@std@@YAPBV?$_Vector_val@U?$_Simple_types@PAVNvFaceInfo@@@std@@@0@ABV10@@Z ; std::addressof<std::_Vector_val<std::_Simple_types<NvFaceInfo *> > const >
PUBLIC	??$?0$$V@?$_Compressed_pair@V?$xalloc@PAVNvEdgeInfo@@@@V?$_Vector_val@U?$_Simple_types@PAVNvEdgeInfo@@@std@@@std@@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<xalloc<NvEdgeInfo *>,std::_Vector_val<std::_Simple_types<NvEdgeInfo *> >,1>::_Compressed_pair<xalloc<NvEdgeInfo *>,std::_Vector_val<std::_Simple_types<NvEdgeInfo *> >,1><>
PUBLIC	??$addressof@V?$_Vector_val@U?$_Simple_types@PAVNvEdgeInfo@@@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@PAVNvEdgeInfo@@@std@@@0@AAV10@@Z ; std::addressof<std::_Vector_val<std::_Simple_types<NvEdgeInfo *> > >
PUBLIC	??$addressof@$$CBV?$_Vector_val@U?$_Simple_types@PAVNvStripInfo@@@std@@@std@@@std@@YAPBV?$_Vector_val@U?$_Simple_types@PAVNvStripInfo@@@std@@@0@ABV10@@Z ; std::addressof<std::_Vector_val<std::_Simple_types<NvStripInfo *> > const >
PUBLIC	??$?0$$V@?$_Compressed_pair@V?$xalloc@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@@V?$_Vector_val@U?$_Simple_types@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@std@@@std@@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<xalloc<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> > >,std::_Vector_val<std::_Simple_types<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> > > >,1>::_Compressed_pair<xalloc<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> > >,std::_Vector_val<std::_Simple_types<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> > > >,1><>
PUBLIC	??$addressof@V?$_Vector_val@U?$_Simple_types@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@std@@@0@AAV10@@Z ; std::addressof<std::_Vector_val<std::_Simple_types<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> > > > >
PUBLIC	??$?0ABU?$less@PAVNvFaceInfo@@@std@@U_Zero_then_variadic_args_t@1@@?$_Compressed_pair@U?$less@PAVNvFaceInfo@@@std@@V?$_Compressed_pair@V?$xalloc@U?$_Tree_node@PAVNvFaceInfo@@PAX@std@@@@V?$_Tree_val@U?$_Tree_simple_types@PAVNvFaceInfo@@@std@@@std@@$00@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABU?$less@PAVNvFaceInfo@@@1@$$QAU_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::less<NvFaceInfo *>,std::_Compressed_pair<xalloc<std::_Tree_node<NvFaceInfo *,void *> >,std::_Tree_val<std::_Tree_simple_types<NvFaceInfo *> >,1>,1>::_Compressed_pair<std::less<NvFaceInfo *>,std::_Compressed_pair<xalloc<std::_Tree_node<NvFaceInfo *,void *> >,std::_Tree_val<std::_Tree_simple_types<NvFaceInfo *> >,1>,1><std::less<NvFaceInfo *> const &,std::_Zero_then_variadic_args_t>
PUBLIC	??$addressof@V?$_Tree_val@U?$_Tree_simple_types@PAVNvFaceInfo@@@std@@@std@@@std@@YAPAV?$_Tree_val@U?$_Tree_simple_types@PAVNvFaceInfo@@@std@@@0@AAV10@@Z ; std::addressof<std::_Tree_val<std::_Tree_simple_types<NvFaceInfo *> > >
PUBLIC	??$_Emplace_reallocate@ABH@?$vector@HV?$xalloc@H@@@std@@QAEPAHQAHABH@Z ; std::vector<int,xalloc<int> >::_Emplace_reallocate<int const &>
PUBLIC	??$construct@HABH@?$_Normal_allocator_traits@V?$xalloc@H@@@std@@SAXAAV?$xalloc@H@@PAHABH@Z ; std::_Normal_allocator_traits<xalloc<int> >::construct<int,int const &>
PUBLIC	??$forward@ABH@std@@YAABHABH@Z			; std::forward<int const &>
PUBLIC	??$_Emplace_reallocate@H@?$vector@HV?$xalloc@H@@@std@@QAEPAHQAH$$QAH@Z ; std::vector<int,xalloc<int> >::_Emplace_reallocate<int>
PUBLIC	??$construct@HH@?$_Normal_allocator_traits@V?$xalloc@H@@@std@@SAXAAV?$xalloc@H@@PAH$$QAH@Z ; std::_Normal_allocator_traits<xalloc<int> >::construct<int,int>
PUBLIC	??$forward@H@std@@YA$$QAHAAH@Z			; std::forward<int>
PUBLIC	??$move@AAH@std@@YA$$QAHAAH@Z			; std::move<int &>
PUBLIC	??$_Emplace_reallocate@G@?$vector@GV?$xalloc@G@@@std@@QAEPAGQAG$$QAG@Z ; std::vector<unsigned short,xalloc<unsigned short> >::_Emplace_reallocate<unsigned short>
PUBLIC	??$addressof@$$CBV?$vector@GV?$xalloc@G@@@std@@@std@@YAPBV?$vector@GV?$xalloc@G@@@0@ABV10@@Z ; std::addressof<std::vector<unsigned short,xalloc<unsigned short> > const >
PUBLIC	??$_Emplace_reallocate@ABQAVNvFaceInfo@@@?$vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@std@@QAEPAPAVNvFaceInfo@@QAPAV2@ABQAV2@@Z ; std::vector<NvFaceInfo *,xalloc<NvFaceInfo *> >::_Emplace_reallocate<NvFaceInfo * const &>
PUBLIC	??$construct@PAVNvFaceInfo@@ABQAV1@@?$_Normal_allocator_traits@V?$xalloc@PAVNvFaceInfo@@@@@std@@SAXAAV?$xalloc@PAVNvFaceInfo@@@@PAPAVNvFaceInfo@@ABQAV3@@Z ; std::_Normal_allocator_traits<xalloc<NvFaceInfo *> >::construct<NvFaceInfo *,NvFaceInfo * const &>
PUBLIC	??$forward@ABQAVNvFaceInfo@@@std@@YAABQAVNvFaceInfo@@ABQAV1@@Z ; std::forward<NvFaceInfo * const &>
PUBLIC	??$_Resize@U_Value_init_tag@std@@@?$vector@PAVNvEdgeInfo@@V?$xalloc@PAVNvEdgeInfo@@@@@std@@AAEXIABU_Value_init_tag@1@@Z ; std::vector<NvEdgeInfo *,xalloc<NvEdgeInfo *> >::_Resize<std::_Value_init_tag>
PUBLIC	??$_Emplace_reallocate@ABQAVNvStripInfo@@@?$vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@std@@QAEPAPAVNvStripInfo@@QAPAV2@ABQAV2@@Z ; std::vector<NvStripInfo *,xalloc<NvStripInfo *> >::_Emplace_reallocate<NvStripInfo * const &>
PUBLIC	??$construct@PAVNvStripInfo@@ABQAV1@@?$_Normal_allocator_traits@V?$xalloc@PAVNvStripInfo@@@@@std@@SAXAAV?$xalloc@PAVNvStripInfo@@@@PAPAVNvStripInfo@@ABQAV3@@Z ; std::_Normal_allocator_traits<xalloc<NvStripInfo *> >::construct<NvStripInfo *,NvStripInfo * const &>
PUBLIC	??$forward@ABQAVNvStripInfo@@@std@@YAABQAVNvStripInfo@@ABQAV1@@Z ; std::forward<NvStripInfo * const &>
PUBLIC	??$_Resize@U_Value_init_tag@std@@@?$vector@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@V?$xalloc@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@@@std@@AAEXIABU_Value_init_tag@1@@Z ; std::vector<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> >,xalloc<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> > > >::_Resize<std::_Value_init_tag>
PUBLIC	??$_Erase_head@V?$xalloc@U?$_Tree_node@PAVNvFaceInfo@@PAX@std@@@@@?$_Tree_val@U?$_Tree_simple_types@PAVNvFaceInfo@@@std@@@std@@QAEXAAV?$xalloc@U?$_Tree_node@PAVNvFaceInfo@@PAX@std@@@@@Z ; std::_Tree_val<std::_Tree_simple_types<NvFaceInfo *> >::_Erase_head<xalloc<std::_Tree_node<NvFaceInfo *,void *> > >
PUBLIC	??$_Find@PAVNvFaceInfo@@@?$_Tree@V?$_Tset_traits@PAVNvFaceInfo@@U?$less@PAVNvFaceInfo@@@std@@V?$xalloc@PAVNvFaceInfo@@@@$0A@@std@@@std@@ABEPAU?$_Tree_node@PAVNvFaceInfo@@PAX@1@ABQAVNvFaceInfo@@@Z ; std::_Tree<std::_Tset_traits<NvFaceInfo *,std::less<NvFaceInfo *>,xalloc<NvFaceInfo *>,0> >::_Find<NvFaceInfo *>
PUBLIC	??$insert@$0A@$0A@@?$_Tree@V?$_Tset_traits@PAVNvFaceInfo@@U?$less@PAVNvFaceInfo@@@std@@V?$xalloc@PAVNvFaceInfo@@@@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@PAVNvFaceInfo@@@std@@@std@@@std@@_N@1@ABQAVNvFaceInfo@@@Z ; std::_Tree<std::_Tset_traits<NvFaceInfo *,std::less<NvFaceInfo *>,xalloc<NvFaceInfo *>,0> >::insert<0,0>
PUBLIC	??$xr_new@VNvStripInfo@@VNvStripStartInfo@@HH@@YAPAVNvStripInfo@@ABVNvStripStartInfo@@ABH1@Z ; xr_new<NvStripInfo,NvStripStartInfo,int,int>
PUBLIC	??$SWAP@H@@YAXAAH0@Z				; SWAP<int>
PUBLIC	??$xr_free@_N@@YAXAAPA_N@Z			; xr_free<bool>
PUBLIC	??$xr_delete@VVertexCache@@@@YAXAAPAVVertexCache@@@Z ; xr_delete<VertexCache>
PUBLIC	??$xr_new@VVertexCache@@H@@YAPAVVertexCache@@ABH@Z ; xr_new<VertexCache,int>
PUBLIC	??$xr_alloc@_N@@YAPA_NI@Z			; xr_alloc<bool>
PUBLIC	??$xr_new@VNvEdgeInfo@@HH@@YAPAVNvEdgeInfo@@ABH0@Z ; xr_new<NvEdgeInfo,int,int>
PUBLIC	??$xr_new@VNvFaceInfo@@HHH@@YAPAVNvFaceInfo@@ABH00@Z ; xr_new<NvFaceInfo,int,int,int>
PUBLIC	?_Verify_offset@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@std@@@std@@@std@@QBEXH@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> > > > >::_Verify_offset
PUBLIC	?_Verify_offset@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVNvEdgeInfo@@@std@@@std@@@std@@QBEXH@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<NvEdgeInfo *> > >::_Verify_offset
PUBLIC	?max_size@?$xalloc@PAVNvFaceInfo@@@@QBEIXZ	; xalloc<NvFaceInfo *>::max_size
PUBLIC	?_Umove_if_noexcept1@?$vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@std@@AAEXPAPAVNvFaceInfo@@00U?$integral_constant@_N$00@2@@Z ; std::vector<NvFaceInfo *,xalloc<NvFaceInfo *> >::_Umove_if_noexcept1
PUBLIC	?_Get_first@?$_Compressed_pair@V?$xalloc@PAVNvFaceInfo@@@@V?$_Vector_val@U?$_Simple_types@PAVNvFaceInfo@@@std@@@std@@$00@std@@QBEABV?$xalloc@PAVNvFaceInfo@@@@XZ ; std::_Compressed_pair<xalloc<NvFaceInfo *>,std::_Vector_val<std::_Simple_types<NvFaceInfo *> >,1>::_Get_first
PUBLIC	?_Get_first@?$_Compressed_pair@V?$xalloc@PAVNvEdgeInfo@@@@V?$_Vector_val@U?$_Simple_types@PAVNvEdgeInfo@@@std@@@std@@$00@std@@QAEAAV?$xalloc@PAVNvEdgeInfo@@@@XZ ; std::_Compressed_pair<xalloc<NvEdgeInfo *>,std::_Vector_val<std::_Simple_types<NvEdgeInfo *> >,1>::_Get_first
PUBLIC	?_Get_first@?$_Compressed_pair@V?$xalloc@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@@V?$_Vector_val@U?$_Simple_types@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@std@@@std@@$00@std@@QAEAAV?$xalloc@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@@XZ ; std::_Compressed_pair<xalloc<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> > >,std::_Vector_val<std::_Simple_types<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> > > >,1>::_Get_first
PUBLIC	??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> > > > >::operator+=
PUBLIC	??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVNvEdgeInfo@@@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<NvEdgeInfo *> > >::operator+=
PUBLIC	?allocate@?$xalloc@PAVNvFaceInfo@@@@QBEPAPAVNvFaceInfo@@IPBX@Z ; xalloc<NvFaceInfo *>::allocate
PUBLIC	?max_size@?$_Normal_allocator_traits@V?$xalloc@PAVNvFaceInfo@@@@@std@@SAIABV?$xalloc@PAVNvFaceInfo@@@@@Z ; std::_Normal_allocator_traits<xalloc<NvFaceInfo *> >::max_size
PUBLIC	?clear@?$vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@std@@QAEXXZ ; std::vector<NvFaceInfo *,xalloc<NvFaceInfo *> >::clear
PUBLIC	?_Umove_if_noexcept@?$vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@std@@AAEXPAPAVNvFaceInfo@@00@Z ; std::vector<NvFaceInfo *,xalloc<NvFaceInfo *> >::_Umove_if_noexcept
PUBLIC	?_Change_array@?$vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@std@@AAEXQAPAVNvFaceInfo@@II@Z ; std::vector<NvFaceInfo *,xalloc<NvFaceInfo *> >::_Change_array
PUBLIC	?_Getal@?$vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@std@@ABEABV?$xalloc@PAVNvFaceInfo@@@@XZ ; std::vector<NvFaceInfo *,xalloc<NvFaceInfo *> >::_Getal
PUBLIC	?deallocate@?$xalloc@PAVNvEdgeInfo@@@@QBEXPAPAVNvEdgeInfo@@I@Z ; xalloc<NvEdgeInfo *>::deallocate
PUBLIC	?_Destroy@?$vector@PAVNvEdgeInfo@@V?$xalloc@PAVNvEdgeInfo@@@@@std@@AAEXPAPAVNvEdgeInfo@@0@Z ; std::vector<NvEdgeInfo *,xalloc<NvEdgeInfo *> >::_Destroy
PUBLIC	?_Getal@?$vector@PAVNvEdgeInfo@@V?$xalloc@PAVNvEdgeInfo@@@@@std@@AAEAAV?$xalloc@PAVNvEdgeInfo@@@@XZ ; std::vector<NvEdgeInfo *,xalloc<NvEdgeInfo *> >::_Getal
PUBLIC	?clear@?$vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@std@@QAEXXZ ; std::vector<NvStripInfo *,xalloc<NvStripInfo *> >::clear
PUBLIC	?deallocate@?$xalloc@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@@QBEXPAV?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@I@Z ; xalloc<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> > >::deallocate
PUBLIC	?clear@?$vector@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@V?$xalloc@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@@@std@@QAEXXZ ; std::vector<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> >,xalloc<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> > > >::clear
PUBLIC	?_Destroy@?$vector@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@V?$xalloc@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@@@std@@AAEXPAV?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@0@Z ; std::vector<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> >,xalloc<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> > > >::_Destroy
PUBLIC	?_Getal@?$vector@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@V?$xalloc@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@@@std@@AAEAAV?$xalloc@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@@XZ ; std::vector<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> >,xalloc<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> > > >::_Getal
PUBLIC	?_Alloc_sentinel_and_proxy@?$_Tree@V?$_Tset_traits@PAVNvFaceInfo@@U?$less@PAVNvFaceInfo@@@std@@V?$xalloc@PAVNvFaceInfo@@@@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tset_traits<NvFaceInfo *,std::less<NvFaceInfo *>,xalloc<NvFaceInfo *>,0> >::_Alloc_sentinel_and_proxy
PUBLIC	?_Get_first@?$_Compressed_pair@V?$xalloc@U?$_Tree_node@PAVNvFaceInfo@@PAX@std@@@@V?$_Tree_val@U?$_Tree_simple_types@PAVNvFaceInfo@@@std@@@std@@$00@std@@QAEAAV?$xalloc@U?$_Tree_node@PAVNvFaceInfo@@PAX@std@@@@XZ ; std::_Compressed_pair<xalloc<std::_Tree_node<NvFaceInfo *,void *> >,std::_Tree_val<std::_Tree_simple_types<NvFaceInfo *> >,1>::_Get_first
PUBLIC	??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@std@@@std@@@std@@QAE@PAV?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@PBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> > > > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> > > > >
PUBLIC	??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@std@@@std@@@std@@QBEABV?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> > > > >::operator*
PUBLIC	??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> > > > >::operator+=
PUBLIC	??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVNvEdgeInfo@@@std@@@std@@@std@@QAE@PAPAVNvEdgeInfo@@PBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<NvEdgeInfo *> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<NvEdgeInfo *> > >
PUBLIC	??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVNvEdgeInfo@@@std@@@std@@@std@@QBEABQAVNvEdgeInfo@@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<NvEdgeInfo *> > >::operator*
PUBLIC	??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVNvEdgeInfo@@@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NvEdgeInfo *> > >::operator+=
PUBLIC	??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVNvEdgeInfo@@@std@@@std@@@std@@QAE@PAPAVNvEdgeInfo@@PBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NvEdgeInfo *> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<NvEdgeInfo *> > >
PUBLIC	??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@std@@@std@@@std@@QAE@PAV?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@PBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> > > > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> > > > >
PUBLIC	?_Orphan_range@?$vector@HV?$xalloc@H@@@std@@ABEXPAH0@Z ; std::vector<int,xalloc<int> >::_Orphan_range
PUBLIC	?_Copy_assign@?$vector@GV?$xalloc@G@@@std@@AAEXABV12@U?$integral_constant@_N$0A@@2@@Z ; std::vector<unsigned short,xalloc<unsigned short> >::_Copy_assign
PUBLIC	?begin@?$vector@GV?$xalloc@G@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@G@std@@@std@@@2@XZ ; std::vector<unsigned short,xalloc<unsigned short> >::begin
PUBLIC	?_Reallocate_exactly@?$vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@std@@AAEXI@Z ; std::vector<NvFaceInfo *,xalloc<NvFaceInfo *> >::_Reallocate_exactly
PUBLIC	?begin@?$vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVNvFaceInfo@@@std@@@std@@@2@XZ ; std::vector<NvFaceInfo *,xalloc<NvFaceInfo *> >::begin
PUBLIC	?max_size@?$vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@std@@QBEIXZ ; std::vector<NvFaceInfo *,xalloc<NvFaceInfo *> >::max_size
PUBLIC	?capacity@?$vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@std@@QBEIXZ ; std::vector<NvFaceInfo *,xalloc<NvFaceInfo *> >::capacity
PUBLIC	?_Xlength@?$vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@std@@CAXXZ ; std::vector<NvFaceInfo *,xalloc<NvFaceInfo *> >::_Xlength
PUBLIC	?_Orphan_range@?$vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@std@@ABEXPAPAVNvFaceInfo@@0@Z ; std::vector<NvFaceInfo *,xalloc<NvFaceInfo *> >::_Orphan_range
PUBLIC	?clear_and_free@?$xr_vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@@QAEXXZ ; xr_vector<NvFaceInfo *,xalloc<NvFaceInfo *> >::clear_and_free
PUBLIC	??0?$vector@PAVNvEdgeInfo@@V?$xalloc@PAVNvEdgeInfo@@@@@std@@QAE@XZ ; std::vector<NvEdgeInfo *,xalloc<NvEdgeInfo *> >::vector<NvEdgeInfo *,xalloc<NvEdgeInfo *> >
PUBLIC	?begin@?$vector@PAVNvEdgeInfo@@V?$xalloc@PAVNvEdgeInfo@@@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVNvEdgeInfo@@@std@@@std@@@2@XZ ; std::vector<NvEdgeInfo *,xalloc<NvEdgeInfo *> >::begin
PUBLIC	?size@?$vector@PAVNvEdgeInfo@@V?$xalloc@PAVNvEdgeInfo@@@@@std@@QBEIXZ ; std::vector<NvEdgeInfo *,xalloc<NvEdgeInfo *> >::size
PUBLIC	?_Tidy@?$vector@PAVNvEdgeInfo@@V?$xalloc@PAVNvEdgeInfo@@@@@std@@AAEXXZ ; std::vector<NvEdgeInfo *,xalloc<NvEdgeInfo *> >::_Tidy
PUBLIC	?begin@?$vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVNvStripInfo@@@std@@@std@@@2@XZ ; std::vector<NvStripInfo *,xalloc<NvStripInfo *> >::begin
PUBLIC	?_Orphan_range@?$vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@std@@ABEXPAPAVNvStripInfo@@0@Z ; std::vector<NvStripInfo *,xalloc<NvStripInfo *> >::_Orphan_range
PUBLIC	?clear_and_free@?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@QAEXXZ ; xr_vector<NvStripInfo *,xalloc<NvStripInfo *> >::clear_and_free
PUBLIC	??0?$vector@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@V?$xalloc@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@@@std@@QAE@XZ ; std::vector<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> >,xalloc<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> > > >::vector<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> >,xalloc<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> > > >
PUBLIC	?begin@?$vector@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@V?$xalloc@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@std@@@std@@@2@XZ ; std::vector<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> >,xalloc<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> > > >::begin
PUBLIC	?_Tidy@?$vector@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@V?$xalloc@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@@@std@@AAEXXZ ; std::vector<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> >,xalloc<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> > > >::_Tidy
PUBLIC	?clear_and_free@?$xr_vector@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@V?$xalloc@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@@@@QAEXXZ ; xr_vector<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> >,xalloc<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> > > >::clear_and_free
PUBLIC	??0?$_Tree@V?$_Tset_traits@PAVNvFaceInfo@@U?$less@PAVNvFaceInfo@@@std@@V?$xalloc@PAVNvFaceInfo@@@@$0A@@std@@@std@@QAE@ABU?$less@PAVNvFaceInfo@@@1@@Z ; std::_Tree<std::_Tset_traits<NvFaceInfo *,std::less<NvFaceInfo *>,xalloc<NvFaceInfo *>,0> >::_Tree<std::_Tset_traits<NvFaceInfo *,std::less<NvFaceInfo *>,xalloc<NvFaceInfo *>,0> >
PUBLIC	?_Getal@?$_Tree@V?$_Tset_traits@PAVNvFaceInfo@@U?$less@PAVNvFaceInfo@@@std@@V?$xalloc@PAVNvFaceInfo@@@@$0A@@std@@@std@@IAEAAV?$xalloc@U?$_Tree_node@PAVNvFaceInfo@@PAX@std@@@@XZ ; std::_Tree<std::_Tset_traits<NvFaceInfo *,std::less<NvFaceInfo *>,xalloc<NvFaceInfo *>,0> >::_Getal
PUBLIC	?_Get_scary@?$_Tree@V?$_Tset_traits@PAVNvFaceInfo@@U?$less@PAVNvFaceInfo@@@std@@V?$xalloc@PAVNvFaceInfo@@@@$0A@@std@@@std@@IAEPAV?$_Tree_val@U?$_Tree_simple_types@PAVNvFaceInfo@@@std@@@2@XZ ; std::_Tree<std::_Tset_traits<NvFaceInfo *,std::less<NvFaceInfo *>,xalloc<NvFaceInfo *>,0> >::_Get_scary
PUBLIC	??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@PAVNvFaceInfo@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU?$_Tree_node@PAVNvFaceInfo@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@PAVNvFaceInfo@@@std@@@1@@Z ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<NvFaceInfo *> >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<NvFaceInfo *> >,std::_Iterator_base0>
PUBLIC	??8?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@PAVNvFaceInfo@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<NvFaceInfo *> > >::operator==
PUBLIC	??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@std@@@std@@@std@@QBEAAV?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> > > > >::operator*
PUBLIC	??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@std@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> > > > >::operator+
PUBLIC	??H?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVNvStripInfo@@@std@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<NvStripInfo *> > >::operator+
PUBLIC	??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVNvEdgeInfo@@@std@@@std@@@std@@QBEAAPAVNvEdgeInfo@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NvEdgeInfo *> > >::operator*
PUBLIC	??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVNvEdgeInfo@@@std@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NvEdgeInfo *> > >::operator+
PUBLIC	??H?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVNvFaceInfo@@@std@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<NvFaceInfo *> > >::operator+
PUBLIC	??H?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@G@std@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned short> > >::operator+
PUBLIC	??0?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@PAVNvFaceInfo@@@std@@@std@@@std@@QAE@PAU?$_Tree_node@PAVNvFaceInfo@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@PAVNvFaceInfo@@@std@@@1@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<NvFaceInfo *> > >::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<NvFaceInfo *> > >
PUBLIC	??$_Emplace_back_with_unused_capacity@ABH@?$vector@HV?$xalloc@H@@@std@@AAE?A_TABH@Z ; std::vector<int,xalloc<int> >::_Emplace_back_with_unused_capacity<int const &>
PUBLIC	??$emplace_back@ABH@?$vector@HV?$xalloc@H@@@std@@QAE?A_TABH@Z ; std::vector<int,xalloc<int> >::emplace_back<int const &>
PUBLIC	?push_back@?$vector@HV?$xalloc@H@@@std@@QAEXABH@Z ; std::vector<int,xalloc<int> >::push_back
PUBLIC	??$_Emplace_back_with_unused_capacity@H@?$vector@HV?$xalloc@H@@@std@@AAE?A_T$$QAH@Z ; std::vector<int,xalloc<int> >::_Emplace_back_with_unused_capacity<int>
PUBLIC	??$emplace_back@H@?$vector@HV?$xalloc@H@@@std@@QAE?A_T$$QAH@Z ; std::vector<int,xalloc<int> >::emplace_back<int>
PUBLIC	?push_back@?$vector@HV?$xalloc@H@@@std@@QAEX$$QAH@Z ; std::vector<int,xalloc<int> >::push_back
PUBLIC	??$_Emplace_back_with_unused_capacity@G@?$vector@GV?$xalloc@G@@@std@@AAE?A_T$$QAG@Z ; std::vector<unsigned short,xalloc<unsigned short> >::_Emplace_back_with_unused_capacity<unsigned short>
PUBLIC	??$emplace_back@G@?$vector@GV?$xalloc@G@@@std@@QAE?A_T$$QAG@Z ; std::vector<unsigned short,xalloc<unsigned short> >::emplace_back<unsigned short>
PUBLIC	?push_back@?$vector@GV?$xalloc@G@@@std@@QAEX$$QAG@Z ; std::vector<unsigned short,xalloc<unsigned short> >::push_back
PUBLIC	??4?$vector@GV?$xalloc@G@@@std@@QAEAAV01@ABV01@@Z ; std::vector<unsigned short,xalloc<unsigned short> >::operator=
PUBLIC	??A?$xr_vector@GV?$xalloc@G@@@@QBEABGI@Z	; xr_vector<unsigned short,xalloc<unsigned short> >::operator[]
PUBLIC	??$_Emplace_back_with_unused_capacity@ABQAVNvFaceInfo@@@?$vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@std@@AAE?A_TABQAVNvFaceInfo@@@Z ; std::vector<NvFaceInfo *,xalloc<NvFaceInfo *> >::_Emplace_back_with_unused_capacity<NvFaceInfo * const &>
PUBLIC	??$emplace_back@ABQAVNvFaceInfo@@@?$vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@std@@QAE?A_TABQAVNvFaceInfo@@@Z ; std::vector<NvFaceInfo *,xalloc<NvFaceInfo *> >::emplace_back<NvFaceInfo * const &>
PUBLIC	?push_back@?$vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@std@@QAEXABQAVNvFaceInfo@@@Z ; std::vector<NvFaceInfo *,xalloc<NvFaceInfo *> >::push_back
PUBLIC	?reserve@?$vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@std@@QAEXI@Z ; std::vector<NvFaceInfo *,xalloc<NvFaceInfo *> >::reserve
PUBLIC	?clear@?$xr_vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@@QAEXXZ ; xr_vector<NvFaceInfo *,xalloc<NvFaceInfo *> >::clear
PUBLIC	??A?$xr_vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@@QBEABQAVNvFaceInfo@@I@Z ; xr_vector<NvFaceInfo *,xalloc<NvFaceInfo *> >::operator[]
PUBLIC	??1?$vector@PAVNvEdgeInfo@@V?$xalloc@PAVNvEdgeInfo@@@@@std@@QAE@XZ ; std::vector<NvEdgeInfo *,xalloc<NvEdgeInfo *> >::~vector<NvEdgeInfo *,xalloc<NvEdgeInfo *> >
PUBLIC	?resize@?$vector@PAVNvEdgeInfo@@V?$xalloc@PAVNvEdgeInfo@@@@@std@@QAEXI@Z ; std::vector<NvEdgeInfo *,xalloc<NvEdgeInfo *> >::resize
PUBLIC	??0?$xr_vector@PAVNvEdgeInfo@@V?$xalloc@PAVNvEdgeInfo@@@@@@QAE@XZ ; xr_vector<NvEdgeInfo *,xalloc<NvEdgeInfo *> >::xr_vector<NvEdgeInfo *,xalloc<NvEdgeInfo *> >
PUBLIC	?size@?$xr_vector@PAVNvEdgeInfo@@V?$xalloc@PAVNvEdgeInfo@@@@@@QBEIXZ ; xr_vector<NvEdgeInfo *,xalloc<NvEdgeInfo *> >::size
PUBLIC	??A?$xr_vector@PAVNvEdgeInfo@@V?$xalloc@PAVNvEdgeInfo@@@@@@QAEAAPAVNvEdgeInfo@@I@Z ; xr_vector<NvEdgeInfo *,xalloc<NvEdgeInfo *> >::operator[]
PUBLIC	??$_Emplace_back_with_unused_capacity@ABQAVNvStripInfo@@@?$vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@std@@AAE?A_TABQAVNvStripInfo@@@Z ; std::vector<NvStripInfo *,xalloc<NvStripInfo *> >::_Emplace_back_with_unused_capacity<NvStripInfo * const &>
PUBLIC	??$emplace_back@ABQAVNvStripInfo@@@?$vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@std@@QAE?A_TABQAVNvStripInfo@@@Z ; std::vector<NvStripInfo *,xalloc<NvStripInfo *> >::emplace_back<NvStripInfo * const &>
PUBLIC	?push_back@?$vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@std@@QAEXABQAVNvStripInfo@@@Z ; std::vector<NvStripInfo *,xalloc<NvStripInfo *> >::push_back
PUBLIC	?clear@?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@QAEXXZ ; xr_vector<NvStripInfo *,xalloc<NvStripInfo *> >::clear
PUBLIC	??A?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@QBEABQAVNvStripInfo@@I@Z ; xr_vector<NvStripInfo *,xalloc<NvStripInfo *> >::operator[]
PUBLIC	??1?$vector@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@V?$xalloc@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@@@std@@QAE@XZ ; std::vector<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> >,xalloc<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> > > >::~vector<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> >,xalloc<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> > > >
PUBLIC	?resize@?$vector@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@V?$xalloc@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@@@std@@QAEXI@Z ; std::vector<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> >,xalloc<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> > > >::resize
PUBLIC	??0?$xr_vector@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@V?$xalloc@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@@@@QAE@XZ ; xr_vector<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> >,xalloc<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> > > >::xr_vector<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> >,xalloc<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> > > >
PUBLIC	?clear@?$xr_vector@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@V?$xalloc@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@@@@QAEXXZ ; xr_vector<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> >,xalloc<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> > > >::clear
PUBLIC	??A?$xr_vector@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@V?$xalloc@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@@@@QAEAAV?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@I@Z ; xr_vector<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> >,xalloc<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> > > >::operator[]
PUBLIC	??1?$_Tree@V?$_Tset_traits@PAVNvFaceInfo@@U?$less@PAVNvFaceInfo@@@std@@V?$xalloc@PAVNvFaceInfo@@@@$0A@@std@@@std@@QAE@XZ ; std::_Tree<std::_Tset_traits<NvFaceInfo *,std::less<NvFaceInfo *>,xalloc<NvFaceInfo *>,0> >::~_Tree<std::_Tset_traits<NvFaceInfo *,std::less<NvFaceInfo *>,xalloc<NvFaceInfo *>,0> >
PUBLIC	?end@?$_Tree@V?$_Tset_traits@PAVNvFaceInfo@@U?$less@PAVNvFaceInfo@@@std@@V?$xalloc@PAVNvFaceInfo@@@@$0A@@std@@@std@@QAE?AV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@PAVNvFaceInfo@@@std@@@std@@@2@XZ ; std::_Tree<std::_Tset_traits<NvFaceInfo *,std::less<NvFaceInfo *>,xalloc<NvFaceInfo *>,0> >::end
PUBLIC	?find@?$_Tree@V?$_Tset_traits@PAVNvFaceInfo@@U?$less@PAVNvFaceInfo@@@std@@V?$xalloc@PAVNvFaceInfo@@@@$0A@@std@@@std@@QAE?AV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@PAVNvFaceInfo@@@std@@@std@@@2@ABQAVNvFaceInfo@@@Z ; std::_Tree<std::_Tset_traits<NvFaceInfo *,std::less<NvFaceInfo *>,xalloc<NvFaceInfo *>,0> >::find
PUBLIC	??0?$set@PAVNvFaceInfo@@U?$less@PAVNvFaceInfo@@@std@@V?$xalloc@PAVNvFaceInfo@@@@@std@@QAE@XZ ; std::set<NvFaceInfo *,std::less<NvFaceInfo *>,xalloc<NvFaceInfo *> >::set<NvFaceInfo *,std::less<NvFaceInfo *>,xalloc<NvFaceInfo *> >
PUBLIC	??9?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@PAVNvFaceInfo@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<NvFaceInfo *> > >::operator!=
PUBLIC	??1?$set@PAVNvFaceInfo@@U?$less@PAVNvFaceInfo@@@std@@V?$xalloc@PAVNvFaceInfo@@@@@std@@QAE@XZ ; std::set<NvFaceInfo *,std::less<NvFaceInfo *>,xalloc<NvFaceInfo *> >::~set<NvFaceInfo *,std::less<NvFaceInfo *>,xalloc<NvFaceInfo *> >
PUBLIC	??1?$xr_set@PAVNvFaceInfo@@U?$less@PAVNvFaceInfo@@@std@@V?$xalloc@PAVNvFaceInfo@@@@@@QAE@XZ ; xr_set<NvFaceInfo *,std::less<NvFaceInfo *>,xalloc<NvFaceInfo *> >::~xr_set<NvFaceInfo *,std::less<NvFaceInfo *>,xalloc<NvFaceInfo *> >
PUBLIC	??0?$xr_set@PAVNvFaceInfo@@U?$less@PAVNvFaceInfo@@@std@@V?$xalloc@PAVNvFaceInfo@@@@@@QAE@XZ ; xr_set<NvFaceInfo *,std::less<NvFaceInfo *>,xalloc<NvFaceInfo *> >::xr_set<NvFaceInfo *,std::less<NvFaceInfo *>,xalloc<NvFaceInfo *> >
PUBLIC	??1?$xr_vector@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@V?$xalloc@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@@@@QAE@XZ ; xr_vector<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> >,xalloc<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> > > >::~xr_vector<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> >,xalloc<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> > > >
PUBLIC	?FindAllStrips@NvStripifier@@IAEXAAV?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@AAV?$xr_vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@@AAV?$xr_vector@PAVNvEdgeInfo@@V?$xalloc@PAVNvEdgeInfo@@@@@@H@Z ; NvStripifier::FindAllStrips
PUBLIC	?AvgStripSize@NvStripifier@@IAEMABV?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@Z ; NvStripifier::AvgStripSize
PUBLIC	?NumNeighbors@NvStripifier@@IAEHPAVNvFaceInfo@@AAV?$xr_vector@PAVNvEdgeInfo@@V?$xalloc@PAVNvEdgeInfo@@@@@@@Z ; NvStripifier::NumNeighbors
PUBLIC	?CalcNumHitsFace@NvStripifier@@IAEHPAVVertexCache@@PAVNvFaceInfo@@@Z ; NvStripifier::CalcNumHitsFace
PUBLIC	?CalcNumHitsStrip@NvStripifier@@IAEMPAVVertexCache@@PAVNvStripInfo@@@Z ; NvStripifier::CalcNumHitsStrip
PUBLIC	?UpdateCacheFace@NvStripifier@@IAEXPAVVertexCache@@PAVNvFaceInfo@@@Z ; NvStripifier::UpdateCacheFace
PUBLIC	?UpdateCacheStrip@NvStripifier@@IAEXPAVVertexCache@@PAVNvStripInfo@@@Z ; NvStripifier::UpdateCacheStrip
PUBLIC	?SplitUpStripsAndOptimize@NvStripifier@@IAEXAAV?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@0AAV?$xr_vector@PAVNvEdgeInfo@@V?$xalloc@PAVNvEdgeInfo@@@@@@AAV?$xr_vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@@@Z ; NvStripifier::SplitUpStripsAndOptimize
PUBLIC	??1?$xr_vector@PAVNvEdgeInfo@@V?$xalloc@PAVNvEdgeInfo@@@@@@QAE@XZ ; xr_vector<NvEdgeInfo *,xalloc<NvEdgeInfo *> >::~xr_vector<NvEdgeInfo *,xalloc<NvEdgeInfo *> >
PUBLIC	??4?$xr_vector@GV?$xalloc@G@@@@QAEAAV0@ABV0@@Z	; xr_vector<unsigned short,xalloc<unsigned short> >::operator=
PUBLIC	?IsCW@NvStripifier@@IAE_NPAVNvFaceInfo@@HH@Z	; NvStripifier::IsCW
PUBLIC	?NextIsCW@NvStripifier@@IAE_NH@Z		; NvStripifier::NextIsCW
PUBLIC	?RemoveSmallStrips@NvStripifier@@IAEXAAV?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@0AAV?$xr_vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@@@Z ; NvStripifier::RemoveSmallStrips
PUBLIC	?FindTraversal@NvStripifier@@IAE_NAAV?$xr_vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@@AAV?$xr_vector@PAVNvEdgeInfo@@V?$xalloc@PAVNvEdgeInfo@@@@@@PAVNvStripInfo@@AAVNvStripStartInfo@@@Z ; NvStripifier::FindTraversal
PUBLIC	?CommitStrips@NvStripifier@@IAEXAAV?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@ABV2@@Z ; NvStripifier::CommitStrips
PUBLIC	?SharesEdge@NvStripInfo@@QAE_NPBVNvFaceInfo@@AAV?$xr_vector@PAVNvEdgeInfo@@V?$xalloc@PAVNvEdgeInfo@@@@@@@Z ; NvStripInfo::SharesEdge
PUBLIC	?Combine@NvStripInfo@@QAEXABV?$xr_vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@@0@Z ; NvStripInfo::Combine
PUBLIC	?Build@NvStripInfo@@QAEXAAV?$xr_vector@PAVNvEdgeInfo@@V?$xalloc@PAVNvEdgeInfo@@@@@@AAV?$xr_vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@@@Z ; NvStripInfo::Build
PUBLIC	?Unique@NvStripInfo@@QAE_NAAV?$xr_vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@@PAVNvFaceInfo@@@Z ; NvStripInfo::Unique
PUBLIC	?MarkTriangle@NvStripInfo@@QAEXPAVNvFaceInfo@@@Z ; NvStripInfo::MarkTriangle
PUBLIC	?IsMarked@NvStripInfo@@QAE_NPAVNvFaceInfo@@@Z	; NvStripInfo::IsMarked
PUBLIC	?GetNextIndex@NvStripifier@@KAHABV?$xr_vector@GV?$xalloc@G@@@@PAVNvFaceInfo@@@Z ; NvStripifier::GetNextIndex
PUBLIC	?GetSharedVertex@NvStripifier@@SAHPAVNvFaceInfo@@0@Z ; NvStripifier::GetSharedVertex
PUBLIC	?GetUniqueVertexInB@NvStripifier@@SAHPAVNvFaceInfo@@0@Z ; NvStripifier::GetUniqueVertexInB
PUBLIC	?FindGoodResetPoint@NvStripifier@@IAEPAVNvFaceInfo@@AAV?$xr_vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@@AAV?$xr_vector@PAVNvEdgeInfo@@V?$xalloc@PAVNvEdgeInfo@@@@@@@Z ; NvStripifier::FindGoodResetPoint
PUBLIC	?FindStartPoint@NvStripifier@@IAEHAAV?$xr_vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@@AAV?$xr_vector@PAVNvEdgeInfo@@V?$xalloc@PAVNvEdgeInfo@@@@@@@Z ; NvStripifier::FindStartPoint
PUBLIC	?BuildStripifyInfo@NvStripifier@@IAEXAAV?$xr_vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@@AAV?$xr_vector@PAVNvEdgeInfo@@V?$xalloc@PAVNvEdgeInfo@@@@@@@Z ; NvStripifier::BuildStripifyInfo
PUBLIC	?AlreadyExists@NvStripifier@@IAE_NPAVNvFaceInfo@@AAV?$xr_vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@@@Z ; NvStripifier::AlreadyExists
PUBLIC	?FindOtherFace@NvStripifier@@KAPAVNvFaceInfo@@AAV?$xr_vector@PAVNvEdgeInfo@@V?$xalloc@PAVNvEdgeInfo@@@@@@HHPAV2@@Z ; NvStripifier::FindOtherFace
PUBLIC	?FindEdgeInfo@NvStripifier@@KAPAVNvEdgeInfo@@AAV?$xr_vector@PAVNvEdgeInfo@@V?$xalloc@PAVNvEdgeInfo@@@@@@HH@Z ; NvStripifier::FindEdgeInfo
PUBLIC	?IsInStrip@NvStripInfo@@QBE_NPBVNvFaceInfo@@@Z	; NvStripInfo::IsInStrip
PUBLIC	?IsExperiment@NvStripInfo@@QBE_NXZ		; NvStripInfo::IsExperiment
PUBLIC	??0NvStripInfo@@QAE@ABVNvStripStartInfo@@HH@Z	; NvStripInfo::NvStripInfo
PUBLIC	??0NvStripStartInfo@@QAE@PAVNvFaceInfo@@PAVNvEdgeInfo@@_N@Z ; NvStripStartInfo::NvStripStartInfo
PUBLIC	?Unref@NvEdgeInfo@@QAEXXZ			; NvEdgeInfo::Unref
PUBLIC	??0NvEdgeInfo@@QAE@HH@Z				; NvEdgeInfo::NvEdgeInfo
PUBLIC	??0NvFaceInfo@@QAE@HHH@Z			; NvFaceInfo::NvFaceInfo
PUBLIC	?AddEntry@VertexCache@@QAEHH@Z			; VertexCache::AddEntry
PUBLIC	?InCache@VertexCache@@QAE_NH@Z			; VertexCache::InCache
PUBLIC	??0NvStripifier@@QAE@XZ				; NvStripifier::NvStripifier
PUBLIC	??1NvStripifier@@QAE@XZ				; NvStripifier::~NvStripifier
PUBLIC	?Stripify@NvStripifier@@QAEXABV?$xr_vector@GV?$xalloc@G@@@@HHAAV?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@AAV?$xr_vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@@@Z ; NvStripifier::Stripify
PUBLIC	?CreateStrips@NvStripifier@@QAEXABV?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@AAV?$xr_vector@HV?$xalloc@H@@@@_NAAI@Z ; NvStripifier::CreateStrips
;	COMDAT ?$TSS0@?1??Build@NvStripInfo@@QAEXAAV?$xr_vector@PAVNvEdgeInfo@@V?$xalloc@PAVNvEdgeInfo@@@@@@AAV?$xr_vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@@@Z@4HA
_BSS	SEGMENT
?$TSS0@?1??Build@NvStripInfo@@QAEXAAV?$xr_vector@PAVNvEdgeInfo@@V?$xalloc@PAVNvEdgeInfo@@@@@@AAV?$xr_vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@@@Z@4HA DD 01H DUP (?) ; `NvStripInfo::Build'::`2'::$TSS0
_BSS	ENDS
;	COMDAT ?scratchIndices@?1??Build@NvStripInfo@@QAEXAAV?$xr_vector@PAVNvEdgeInfo@@V?$xalloc@PAVNvEdgeInfo@@@@@@AAV?$xr_vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@@@Z@4V?$xr_vector@GV?$xalloc@G@@@@A
_BSS	SEGMENT
?scratchIndices@?1??Build@NvStripInfo@@QAEXAAV?$xr_vector@PAVNvEdgeInfo@@V?$xalloc@PAVNvEdgeInfo@@@@@@AAV?$xr_vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@@@Z@4V?$xr_vector@GV?$xalloc@G@@@@A DB 0cH DUP (?) ; `NvStripInfo::Build'::`2'::scratchIndices
_BSS	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?_Reallocate_exactly@?$vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@std@@AAEXI@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Reallocate_exactly@?$vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@std@@AAEXI@Z
	DD	01H
	DD	FLAT:__tryblocktable$?_Reallocate_exactly@?$vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@std@@AAEXI@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
__unwindtable$?_Reallocate_exactly@?$vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@std@@AAEXI@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?_Reallocate_exactly@?$vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@std@@AAEXI@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Reallocate_exactly@?$vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@std@@AAEXI@Z$2
__catchsym$?_Reallocate_exactly@?$vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@std@@AAEXI@Z$2 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Reallocate_exactly@?$vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@std@@AAEXI@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$_Emplace_reallocate@ABQAVNvStripInfo@@@?$vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@std@@QAEPAPAVNvStripInfo@@QAPAV2@ABQAV2@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Emplace_reallocate@ABQAVNvStripInfo@@@?$vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@std@@QAEPAPAVNvStripInfo@@QAPAV2@ABQAV2@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Emplace_reallocate@ABQAVNvStripInfo@@@?$vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@std@@QAEPAPAVNvStripInfo@@QAPAV2@ABQAV2@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
__unwindtable$??$_Emplace_reallocate@ABQAVNvStripInfo@@@?$vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@std@@QAEPAPAVNvStripInfo@@QAPAV2@ABQAV2@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Emplace_reallocate@ABQAVNvStripInfo@@@?$vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@std@@QAEPAPAVNvStripInfo@@QAPAV2@ABQAV2@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Emplace_reallocate@ABQAVNvStripInfo@@@?$vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@std@@QAEPAPAVNvStripInfo@@QAPAV2@ABQAV2@@Z$2
__catchsym$??$_Emplace_reallocate@ABQAVNvStripInfo@@@?$vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@std@@QAEPAPAVNvStripInfo@@QAPAV2@ABQAV2@@Z$2 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Emplace_reallocate@ABQAVNvStripInfo@@@?$vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@std@@QAEPAPAVNvStripInfo@@QAPAV2@ABQAV2@@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$_Emplace_reallocate@ABQAVNvFaceInfo@@@?$vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@std@@QAEPAPAVNvFaceInfo@@QAPAV2@ABQAV2@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Emplace_reallocate@ABQAVNvFaceInfo@@@?$vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@std@@QAEPAPAVNvFaceInfo@@QAPAV2@ABQAV2@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Emplace_reallocate@ABQAVNvFaceInfo@@@?$vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@std@@QAEPAPAVNvFaceInfo@@QAPAV2@ABQAV2@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
__unwindtable$??$_Emplace_reallocate@ABQAVNvFaceInfo@@@?$vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@std@@QAEPAPAVNvFaceInfo@@QAPAV2@ABQAV2@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Emplace_reallocate@ABQAVNvFaceInfo@@@?$vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@std@@QAEPAPAVNvFaceInfo@@QAPAV2@ABQAV2@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Emplace_reallocate@ABQAVNvFaceInfo@@@?$vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@std@@QAEPAPAVNvFaceInfo@@QAPAV2@ABQAV2@@Z$2
__catchsym$??$_Emplace_reallocate@ABQAVNvFaceInfo@@@?$vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@std@@QAEPAPAVNvFaceInfo@@QAPAV2@ABQAV2@@Z$2 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Emplace_reallocate@ABQAVNvFaceInfo@@@?$vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@std@@QAEPAPAVNvFaceInfo@@QAPAV2@ABQAV2@@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$_Emplace_reallocate@G@?$vector@GV?$xalloc@G@@@std@@QAEPAGQAG$$QAG@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Emplace_reallocate@G@?$vector@GV?$xalloc@G@@@std@@QAEPAGQAG$$QAG@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Emplace_reallocate@G@?$vector@GV?$xalloc@G@@@std@@QAEPAGQAG$$QAG@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
__unwindtable$??$_Emplace_reallocate@G@?$vector@GV?$xalloc@G@@@std@@QAEPAGQAG$$QAG@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Emplace_reallocate@G@?$vector@GV?$xalloc@G@@@std@@QAEPAGQAG$$QAG@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Emplace_reallocate@G@?$vector@GV?$xalloc@G@@@std@@QAEPAGQAG$$QAG@Z$2
__catchsym$??$_Emplace_reallocate@G@?$vector@GV?$xalloc@G@@@std@@QAEPAGQAG$$QAG@Z$2 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Emplace_reallocate@G@?$vector@GV?$xalloc@G@@@std@@QAEPAGQAG$$QAG@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$_Emplace_reallocate@H@?$vector@HV?$xalloc@H@@@std@@QAEPAHQAH$$QAH@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Emplace_reallocate@H@?$vector@HV?$xalloc@H@@@std@@QAEPAHQAH$$QAH@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Emplace_reallocate@H@?$vector@HV?$xalloc@H@@@std@@QAEPAHQAH$$QAH@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
__unwindtable$??$_Emplace_reallocate@H@?$vector@HV?$xalloc@H@@@std@@QAEPAHQAH$$QAH@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Emplace_reallocate@H@?$vector@HV?$xalloc@H@@@std@@QAEPAHQAH$$QAH@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Emplace_reallocate@H@?$vector@HV?$xalloc@H@@@std@@QAEPAHQAH$$QAH@Z$2
__catchsym$??$_Emplace_reallocate@H@?$vector@HV?$xalloc@H@@@std@@QAEPAHQAH$$QAH@Z$2 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Emplace_reallocate@H@?$vector@HV?$xalloc@H@@@std@@QAEPAHQAH$$QAH@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$_Emplace_reallocate@ABH@?$vector@HV?$xalloc@H@@@std@@QAEPAHQAHABH@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Emplace_reallocate@ABH@?$vector@HV?$xalloc@H@@@std@@QAEPAHQAHABH@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Emplace_reallocate@ABH@?$vector@HV?$xalloc@H@@@std@@QAEPAHQAHABH@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
__unwindtable$??$_Emplace_reallocate@ABH@?$vector@HV?$xalloc@H@@@std@@QAEPAHQAHABH@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Emplace_reallocate@ABH@?$vector@HV?$xalloc@H@@@std@@QAEPAHQAHABH@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Emplace_reallocate@ABH@?$vector@HV?$xalloc@H@@@std@@QAEPAHQAHABH@Z$2
__catchsym$??$_Emplace_reallocate@ABH@?$vector@HV?$xalloc@H@@@std@@QAEPAHQAHABH@Z$2 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Emplace_reallocate@ABH@?$vector@HV?$xalloc@H@@@std@@QAEPAHQAHABH@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@V?$xalloc@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@@@std@@AAEXIABU_Value_init_tag@1@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@V?$xalloc@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@@@std@@AAEXIABU_Value_init_tag@1@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@V?$xalloc@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@@@std@@AAEXIABU_Value_init_tag@1@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
__unwindtable$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@V?$xalloc@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@@@std@@AAEXIABU_Value_init_tag@1@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@V?$xalloc@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@@@std@@AAEXIABU_Value_init_tag@1@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@V?$xalloc@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@@@std@@AAEXIABU_Value_init_tag@1@@Z$2
__catchsym$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@V?$xalloc@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@@@std@@AAEXIABU_Value_init_tag@1@@Z$2 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@V?$xalloc@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@@@std@@AAEXIABU_Value_init_tag@1@@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@PAVNvEdgeInfo@@V?$xalloc@PAVNvEdgeInfo@@@@@std@@AAEXIABU_Value_init_tag@1@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@PAVNvEdgeInfo@@V?$xalloc@PAVNvEdgeInfo@@@@@std@@AAEXIABU_Value_init_tag@1@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@PAVNvEdgeInfo@@V?$xalloc@PAVNvEdgeInfo@@@@@std@@AAEXIABU_Value_init_tag@1@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
__unwindtable$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@PAVNvEdgeInfo@@V?$xalloc@PAVNvEdgeInfo@@@@@std@@AAEXIABU_Value_init_tag@1@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@PAVNvEdgeInfo@@V?$xalloc@PAVNvEdgeInfo@@@@@std@@AAEXIABU_Value_init_tag@1@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@PAVNvEdgeInfo@@V?$xalloc@PAVNvEdgeInfo@@@@@std@@AAEXIABU_Value_init_tag@1@@Z$2
__catchsym$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@PAVNvEdgeInfo@@V?$xalloc@PAVNvEdgeInfo@@@@@std@@AAEXIABU_Value_init_tag@1@@Z$2 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@PAVNvEdgeInfo@@V?$xalloc@PAVNvEdgeInfo@@@@@std@@AAEXIABU_Value_init_tag@1@@Z$0
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
_TEXT	SEGMENT
$T1 = -81						; size = 1
_tLastFace$3$ = -80					; size = 4
_tLastFace$2$ = -76					; size = 4
_nUnique$2 = -76					; size = 4
_strip$1$ = -72						; size = 4
_nStripFaceCount$1$ = -68				; size = 4
_i$1$ = -64						; size = 4
tv1991 = -60						; size = 4
tv1985 = -60						; size = 4
tv1971 = -60						; size = 4
_j$1$ = -60						; size = 4
tv1982 = -56						; size = 4
_nStripCount$1$ = -52					; size = 4
_tFirstFace$3 = -48					; size = 24
_tLastFace$ = -24					; size = 24
_allStrips$ = 8						; size = 4
_stripIndices$ = 12					; size = 4
_bStitchStrips$dead$ = 16				; size = 1
_numSeparateStrips$ = 20				; size = 4
?CreateStrips@NvStripifier@@QAEXABV?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@AAV?$xr_vector@HV?$xalloc@H@@@@_NAAI@Z PROC ; NvStripifier::CreateStrips
; _this$dead$ = ecx

; 771  : {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	sub	esp, 84					; 00000054H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	ecx, DWORD PTR _allStrips$[ebp]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 771  : {

	push	ebx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1535 :         auto& _My_data = _Mypair._Myval2;

	xor	ebx, ebx
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 771  : {

	push	esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	eax, DWORD PTR [ecx+4]
	sub	eax, DWORD PTR [ecx]
	sar	eax, 2
	mov	DWORD PTR _nStripCount$1$[esp+92], eax
	mov	DWORD PTR _i$1$[esp+92], ebx
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 771  : {

	push	edi

; 783  : 	for (int i = 0; i < nStripCount; i++)

	test	eax, eax
	jle	$LN303@CreateStri
	mov	edi, DWORD PTR _stripIndices$[ebp]
	dec	eax
	mov	DWORD PTR tv1982[esp+96], eax
$LL4@CreateStri:

; 785  : 		NvStripInfo *strip = allStrips[i];

	mov	eax, DWORD PTR [ecx]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.h

; 33   : 		m_stripId      = -1;

	mov	DWORD PTR _tFirstFace$3[esp+108], -1

; 34   : 		m_testStripId  = -1;

	mov	DWORD PTR _tFirstFace$3[esp+112], -1

; 35   : 		m_experimentId = -1;

	mov	DWORD PTR _tFirstFace$3[esp+116], -1
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 785  : 		NvStripInfo *strip = allStrips[i];

	mov	ecx, DWORD PTR [eax+ebx*4]
	mov	DWORD PTR _strip$1$[esp+96], ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	eax, DWORD PTR [ecx+12]
	mov	ecx, DWORD PTR [ecx+16]
	sub	ecx, eax
	sar	ecx, 2
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 791  : 			NvFaceInfo tFirstFace(strip->m_faces[0]->m_v0, strip->m_faces[0]->m_v1, strip->m_faces[0]->m_v2);

	mov	eax, DWORD PTR [eax]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	DWORD PTR _nStripFaceCount$1$[esp+96], ecx
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 795  : 			if (nStripFaceCount > 1)

	cmp	DWORD PTR _nStripFaceCount$1$[esp+96], 1
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.h

; 32   : 		m_v0 = v0; m_v1 = v1; m_v2 = v2;

	mov	edx, DWORD PTR [eax]
	mov	ecx, edx
	mov	esi, DWORD PTR [eax+8]
	mov	ebx, DWORD PTR [eax+4]
	mov	DWORD PTR _tLastFace$2$[esp+96], ecx
	mov	DWORD PTR _tFirstFace$3[esp+96], ecx
	mov	DWORD PTR _tFirstFace$3[esp+100], ebx
	mov	DWORD PTR _tLastFace$3$[esp+96], esi
	mov	DWORD PTR _tFirstFace$3[esp+104], esi
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 795  : 			if (nStripFaceCount > 1)

	jle	$LN13@CreateStri

; 796  : 			{
; 797  : 				int nUnique = NvStripifier::GetUniqueVertexInB(strip->m_faces[1], &tFirstFace);

	mov	edi, DWORD PTR _strip$1$[esp+96]
	mov	eax, DWORD PTR [edi+12]

; 273  : 		facev0 != faceA->m_v1 &&

	mov	edi, DWORD PTR _stripIndices$[ebp]

; 796  : 			{
; 797  : 				int nUnique = NvStripifier::GetUniqueVertexInB(strip->m_faces[1], &tFirstFace);

	mov	eax, DWORD PTR [eax+4]

; 273  : 		facev0 != faceA->m_v1 &&

	cmp	edx, DWORD PTR [eax]
	je	SHORT $LN119@CreateStri
	cmp	edx, DWORD PTR [eax+4]
	je	SHORT $LN119@CreateStri
	cmp	edx, DWORD PTR [eax+8]
	je	SHORT $LN119@CreateStri

; 274  : 		facev0 != faceA->m_v2)
; 275  : 		return facev0;

	mov	eax, edx
	jmp	SHORT $LN118@CreateStri
$LN119@CreateStri:

; 278  : 	if (facev1 != faceA->m_v0 &&
; 279  : 		facev1 != faceA->m_v1 &&

	cmp	ebx, DWORD PTR [eax]
	je	SHORT $LN120@CreateStri
	cmp	ebx, DWORD PTR [eax+4]
	je	SHORT $LN120@CreateStri
	cmp	ebx, DWORD PTR [eax+8]
	je	SHORT $LN120@CreateStri

; 280  : 		facev1 != faceA->m_v2)
; 281  : 		return facev1;

	mov	eax, ebx
	jmp	SHORT $LN118@CreateStri
$LN120@CreateStri:

; 284  : 	if (facev2 != faceA->m_v0 &&
; 285  : 		facev2 != faceA->m_v1 &&

	cmp	esi, DWORD PTR [eax]
	je	SHORT $LN121@CreateStri
	cmp	esi, DWORD PTR [eax+4]
	je	SHORT $LN121@CreateStri
	cmp	esi, DWORD PTR [eax+8]
	je	SHORT $LN121@CreateStri

; 286  : 		facev2 != faceA->m_v2)
; 287  : 		return facev2;

	mov	eax, esi
	jmp	SHORT $LN118@CreateStri
$LN121@CreateStri:

; 288  : 	
; 289  : 	// nothing is different
; 290  : 	return -1;

	or	eax, -1
$LN118@CreateStri:

; 798  : 				if (nUnique == tFirstFace.m_v1)

	cmp	eax, ebx
	jne	SHORT $LN9@CreateStri
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.h

; 113  : 	first = second;

	mov	ecx, ebx

; 114  : 	second = temp;

	mov	ebx, edx
	mov	DWORD PTR _tFirstFace$3[esp+100], ebx
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 801  : 				}

	jmp	SHORT $LN310@CreateStri
$LN9@CreateStri:

; 802  : 				else if (nUnique == tFirstFace.m_v2)

	cmp	eax, esi
	jne	SHORT $LN11@CreateStri
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.h

; 113  : 	first = second;

	mov	ecx, esi

; 114  : 	second = temp;

	mov	esi, edx
	mov	DWORD PTR _tLastFace$3$[esp+96], esi
	mov	DWORD PTR _tFirstFace$3[esp+104], esi
$LN310@CreateStri:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 809  : 				if (nStripFaceCount > 2)

	mov	DWORD PTR _tFirstFace$3[esp+96], ecx
	mov	DWORD PTR _tLastFace$2$[esp+96], ecx
$LN11@CreateStri:
	cmp	DWORD PTR _nStripFaceCount$1$[esp+96], 2
	jle	SHORT $LN13@CreateStri

; 810  : 				{
; 811  : 					int nShared = GetSharedVertex(strip->m_faces[2], &tFirstFace);

	mov	eax, DWORD PTR _strip$1$[esp+96]
	mov	eax, DWORD PTR [eax+12]
	mov	eax, DWORD PTR [eax+8]

; 303  : 		facev0 == faceA->m_v1 ||

	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR tv1991[esp+96], edx
	cmp	ecx, edx
	je	SHORT $LN146@CreateStri
	mov	edx, DWORD PTR [eax+4]
	cmp	ecx, edx
	je	SHORT $LN146@CreateStri
	mov	eax, DWORD PTR [eax+8]
	cmp	ecx, eax
	je	SHORT $LN146@CreateStri

; 306  : 	
; 307  : 	int facev1 = faceB->m_v1;
; 308  : 	if (facev1 == faceA->m_v0 ||
; 309  : 		facev1 == faceA->m_v1 ||

	cmp	ebx, DWORD PTR tv1991[esp+96]
	je	SHORT $LN300@CreateStri
	cmp	ebx, edx
	je	SHORT $LN300@CreateStri
	cmp	ebx, eax
	je	SHORT $LN300@CreateStri

; 310  : 		facev1 == faceA->m_v2)
; 311  : 		return facev1;
; 312  : 	
; 313  : 	int facev2 = faceB->m_v2;
; 314  : 	if (facev2 == faceA->m_v0 ||
; 315  : 		facev2 == faceA->m_v1 ||

	cmp	esi, DWORD PTR tv1991[esp+96]
	je	SHORT $LN150@CreateStri
	cmp	esi, edx
	je	SHORT $LN150@CreateStri
	cmp	esi, eax
	je	SHORT $LN150@CreateStri

; 318  : 	
; 319  : 	// nothing is shared
; 320  : 	return -1;

	or	eax, -1
	jmp	SHORT $LN144@CreateStri
$LN150@CreateStri:

; 316  : 		facev2 == faceA->m_v2)
; 317  : 		return facev2;

	mov	eax, esi
	jmp	SHORT $LN144@CreateStri
$LN146@CreateStri:

; 304  : 		facev0 == faceA->m_v2)
; 305  : 		return facev0;

	mov	eax, ecx
$LN144@CreateStri:

; 812  : 					if (nShared == tFirstFace.m_v1)

	cmp	eax, ebx
	jne	SHORT $LN13@CreateStri
$LN300@CreateStri:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.h

; 112  : 	T temp = first;

	mov	eax, ebx

; 113  : 	first = second;

	mov	ebx, esi

; 114  : 	second = temp;

	mov	esi, eax
	mov	DWORD PTR _tFirstFace$3[esp+100], ebx
	mov	DWORD PTR _tLastFace$3$[esp+96], esi
	mov	DWORD PTR _tFirstFace$3[esp+104], esi
$LN13@CreateStri:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 819  : 			if( (i == 0) || !bStitchStrips)

	cmp	DWORD PTR _i$1$[esp+96], 0
	je	SHORT $LN157@CreateStri
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 730  :         if (_Mylast != _My_data._Myend) {

	mov	eax, DWORD PTR [edi+4]
	cmp	eax, DWORD PTR [edi+8]
	je	SHORT $LN187@CreateStri

; 713  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

	mov	DWORD PTR [eax], ecx

; 714  :         _Orphan_range(_Mylast, _Mylast);
; 715  :         _Ty& _Result = *_Mylast;
; 716  :         ++_Mylast;

	add	DWORD PTR [edi+4], 4

; 731  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

	jmp	SHORT $LN311@CreateStri
$LN187@CreateStri:

; 732  :         }
; 733  : 
; 734  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	lea	ecx, DWORD PTR _tFirstFace$3[esp+96]
	push	ecx
	push	eax
	mov	ecx, edi
	call	??$_Emplace_reallocate@ABH@?$vector@HV?$xalloc@H@@@std@@QAEPAHQAHABH@Z ; std::vector<int,xalloc<int> >::_Emplace_reallocate<int const &>
	mov	ecx, DWORD PTR _tLastFace$2$[esp+96]
$LN311@CreateStri:

; 1463 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));

	mov	eax, DWORD PTR _strip$1$[esp+96]
	mov	edx, DWORD PTR [edi+4]
	mov	eax, DWORD PTR [eax+12]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 830  : 				if (NextIsCW(stripIndices.size() - accountForNegatives) != IsCW(strip->m_faces[0], tFirstFace.m_v0, tFirstFace.m_v1))

	mov	eax, DWORD PTR [eax]

; 754  : 	if (faceInfo->m_v0 == v0)

	mov	esi, DWORD PTR [eax+4]
	mov	DWORD PTR tv1971[esp+96], esi
	mov	esi, DWORD PTR [eax]
	cmp	esi, ecx
	jne	SHORT $LN215@CreateStri

; 755  : 		return (faceInfo->m_v1 == v1);

	cmp	DWORD PTR tv1971[esp+96], ebx
	jmp	SHORT $LN312@CreateStri
$LN215@CreateStri:

; 756  : 	
; 757  : 	else if (faceInfo->m_v1 == v0)

	cmp	DWORD PTR [eax+4], ecx
	jne	SHORT $LN217@CreateStri

; 758  : 		return (faceInfo->m_v2 == v1);

	cmp	DWORD PTR [eax+8], ebx
	jmp	SHORT $LN312@CreateStri
$LN217@CreateStri:

; 759  : 	
; 760  : 	else 
; 761  : 		return (faceInfo->m_v0 == v1);

	cmp	esi, ebx
$LN312@CreateStri:

; 830  : 				if (NextIsCW(stripIndices.size() - accountForNegatives) != IsCW(strip->m_faces[0], tFirstFace.m_v0, tFirstFace.m_v1))

	mov	esi, DWORD PTR _tLastFace$3$[esp+96]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	sete	BYTE PTR $T1[esp+96]
	mov	eax, edx
	sub	eax, DWORD PTR [edi]
	sar	eax, 2
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 830  : 				if (NextIsCW(stripIndices.size() - accountForNegatives) != IsCW(strip->m_faces[0], tFirstFace.m_v0, tFirstFace.m_v1))

	not	al

; 743  : 	return ((numIndices % 2) == 0);

	and	al, 1

; 830  : 				if (NextIsCW(stripIndices.size() - accountForNegatives) != IsCW(strip->m_faces[0], tFirstFace.m_v0, tFirstFace.m_v1))

	cmp	al, BYTE PTR $T1[esp+96]
	je	SHORT $LN179@CreateStri
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 730  :         if (_Mylast != _My_data._Myend) {

	cmp	edx, DWORD PTR [edi+8]
	je	SHORT $LN223@CreateStri

; 713  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

	mov	DWORD PTR [edx], ecx

; 714  :         _Orphan_range(_Mylast, _Mylast);
; 715  :         _Ty& _Result = *_Mylast;
; 716  :         ++_Mylast;

	add	DWORD PTR [edi+4], 4

; 731  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

	jmp	SHORT $LN179@CreateStri
$LN223@CreateStri:

; 732  :         }
; 733  : 
; 734  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	lea	eax, DWORD PTR _tFirstFace$3[esp+96]
	push	eax
	push	edx
	jmp	SHORT $LN313@CreateStri
$LN157@CreateStri:

; 1463 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));

	mov	eax, DWORD PTR _strip$1$[esp+96]
	mov	eax, DWORD PTR [eax+12]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 821  : 				if(!IsCW(strip->m_faces[0], tFirstFace.m_v0, tFirstFace.m_v1))

	mov	eax, DWORD PTR [eax]

; 754  : 	if (faceInfo->m_v0 == v0)

	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR tv1985[esp+96], edx
	mov	edx, DWORD PTR [eax+4]
	cmp	DWORD PTR [eax], ecx
	jne	SHORT $LN172@CreateStri

; 755  : 		return (faceInfo->m_v1 == v1);

	cmp	edx, ebx
	jmp	SHORT $LN314@CreateStri
$LN172@CreateStri:

; 756  : 	
; 757  : 	else if (faceInfo->m_v1 == v0)

	cmp	edx, ecx
	jne	SHORT $LN174@CreateStri

; 758  : 		return (faceInfo->m_v2 == v1);

	cmp	DWORD PTR [eax+8], ebx
	jmp	SHORT $LN314@CreateStri
$LN174@CreateStri:

; 759  : 	
; 760  : 	else 
; 761  : 		return (faceInfo->m_v0 == v1);

	cmp	DWORD PTR tv1985[esp+96], ebx
$LN314@CreateStri:

; 821  : 				if(!IsCW(strip->m_faces[0], tFirstFace.m_v0, tFirstFace.m_v1))

	sete	al
	test	al, al
	jne	SHORT $LN179@CreateStri
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 730  :         if (_Mylast != _My_data._Myend) {

	mov	eax, DWORD PTR [edi+4]
	cmp	eax, DWORD PTR [edi+8]
	je	SHORT $LN180@CreateStri

; 713  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

	mov	DWORD PTR [eax], ecx

; 714  :         _Orphan_range(_Mylast, _Mylast);
; 715  :         _Ty& _Result = *_Mylast;
; 716  :         ++_Mylast;

	add	DWORD PTR [edi+4], 4

; 731  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

	jmp	SHORT $LN179@CreateStri
$LN180@CreateStri:

; 732  :         }
; 733  : 
; 734  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	lea	ecx, DWORD PTR _tFirstFace$3[esp+96]
	push	ecx
	push	eax
$LN313@CreateStri:

; 730  :         if (_Mylast != _My_data._Myend) {

	mov	ecx, edi
	call	??$_Emplace_reallocate@ABH@?$vector@HV?$xalloc@H@@@std@@QAEPAHQAHABH@Z ; std::vector<int,xalloc<int> >::_Emplace_reallocate<int const &>
	mov	ecx, DWORD PTR _tLastFace$2$[esp+96]
$LN179@CreateStri:
	mov	eax, DWORD PTR [edi+4]
	cmp	eax, DWORD PTR [edi+8]
	je	SHORT $LN230@CreateStri

; 713  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

	mov	DWORD PTR [eax], ecx

; 714  :         _Orphan_range(_Mylast, _Mylast);
; 715  :         _Ty& _Result = *_Mylast;
; 716  :         ++_Mylast;

	add	DWORD PTR [edi+4], 4

; 731  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

	jmp	SHORT $LN315@CreateStri
$LN230@CreateStri:

; 732  :         }
; 733  : 
; 734  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	lea	ecx, DWORD PTR _tFirstFace$3[esp+96]
	push	ecx
	push	eax
	mov	ecx, edi
	call	??$_Emplace_reallocate@ABH@?$vector@HV?$xalloc@H@@@std@@QAEPAHQAHABH@Z ; std::vector<int,xalloc<int> >::_Emplace_reallocate<int const &>
$LN315@CreateStri:

; 730  :         if (_Mylast != _My_data._Myend) {

	mov	eax, DWORD PTR [edi+4]
	cmp	eax, DWORD PTR [edi+8]
	je	SHORT $LN237@CreateStri

; 713  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

	mov	DWORD PTR [eax], ebx

; 714  :         _Orphan_range(_Mylast, _Mylast);
; 715  :         _Ty& _Result = *_Mylast;
; 716  :         ++_Mylast;

	add	DWORD PTR [edi+4], 4

; 731  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

	jmp	SHORT $LN316@CreateStri
$LN237@CreateStri:

; 732  :         }
; 733  : 
; 734  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	lea	ecx, DWORD PTR _tFirstFace$3[esp+100]
	push	ecx
	push	eax
	mov	ecx, edi
	call	??$_Emplace_reallocate@ABH@?$vector@HV?$xalloc@H@@@std@@QAEPAHQAHABH@Z ; std::vector<int,xalloc<int> >::_Emplace_reallocate<int const &>
$LN316@CreateStri:

; 730  :         if (_Mylast != _My_data._Myend) {

	mov	eax, DWORD PTR [edi+4]
	cmp	eax, DWORD PTR [edi+8]
	je	SHORT $LN244@CreateStri

; 713  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

	mov	DWORD PTR [eax], esi

; 714  :         _Orphan_range(_Mylast, _Mylast);
; 715  :         _Ty& _Result = *_Mylast;
; 716  :         ++_Mylast;

	add	DWORD PTR [edi+4], 4

; 731  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

	jmp	SHORT $LN243@CreateStri
$LN244@CreateStri:

; 732  :         }
; 733  : 
; 734  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	lea	ecx, DWORD PTR _tFirstFace$3[esp+104]
	push	ecx
	push	eax
	mov	ecx, edi
	call	??$_Emplace_reallocate@ABH@?$vector@HV?$xalloc@H@@@std@@QAEPAHQAHABH@Z ; std::vector<int,xalloc<int> >::_Emplace_reallocate<int const &>
$LN243@CreateStri:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 841  : 			tLastFace = tFirstFace;

	mov	ecx, DWORD PTR _tLastFace$2$[esp+96]
	mov	edx, 1
	mov	DWORD PTR _tLastFace$[esp+96], ecx
	mov	DWORD PTR _tLastFace$[esp+100], ebx
	mov	DWORD PTR _tLastFace$[esp+104], esi
	mov	DWORD PTR _tLastFace$[esp+108], -1
	mov	DWORD PTR _tLastFace$[esp+112], -1
	mov	DWORD PTR _tLastFace$[esp+116], -1
	mov	DWORD PTR _j$1$[esp+96], edx

; 842  : 		}
; 843  : 
; 844  : 		for (int j = 1; j < nStripFaceCount; j++)

	cmp	DWORD PTR _nStripFaceCount$1$[esp+96], edx
	jle	$LN302@CreateStri
$LL7@CreateStri:

; 845  : 		{
; 846  : 			int nUnique = GetUniqueVertexInB(&tLastFace, strip->m_faces[j]);

	mov	eax, DWORD PTR _strip$1$[esp+96]
	mov	eax, DWORD PTR [eax+12]
	mov	edx, DWORD PTR [eax+edx*4]

; 273  : 		facev0 != faceA->m_v1 &&

	mov	eax, DWORD PTR _tLastFace$3$[esp+96]
	mov	esi, DWORD PTR [edx]
	cmp	esi, ecx
	je	SHORT $LN266@CreateStri
	cmp	esi, ebx
	je	SHORT $LN266@CreateStri
	cmp	esi, eax
	jne	SHORT $LN265@CreateStri
$LN266@CreateStri:

; 276  : 	
; 277  : 	int facev1 = faceB->m_v1;

	mov	esi, DWORD PTR [edx+4]

; 278  : 	if (facev1 != faceA->m_v0 &&
; 279  : 		facev1 != faceA->m_v1 &&

	cmp	esi, ecx
	je	SHORT $LN267@CreateStri
	cmp	esi, ebx
	je	SHORT $LN267@CreateStri
	cmp	esi, eax
	jne	SHORT $LN265@CreateStri
$LN267@CreateStri:

; 282  : 	
; 283  : 	int facev2 = faceB->m_v2;

	mov	esi, DWORD PTR [edx+8]

; 284  : 	if (facev2 != faceA->m_v0 &&
; 285  : 		facev2 != faceA->m_v1 &&

	cmp	esi, ecx
	je	SHORT $LN309@CreateStri
	cmp	esi, ebx
	je	SHORT $LN309@CreateStri
	cmp	esi, eax
	je	SHORT $LN309@CreateStri
$LN265@CreateStri:

; 845  : 		{
; 846  : 			int nUnique = GetUniqueVertexInB(&tLastFace, strip->m_faces[j]);

	mov	DWORD PTR _nUnique$2[esp+96], esi
	cmp	esi, -1

; 847  : 			if (nUnique != -1)

	je	SHORT $LN309@CreateStri
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 730  :         if (_Mylast != _My_data._Myend) {

	mov	ecx, DWORD PTR [edi+4]
	cmp	ecx, DWORD PTR [edi+8]
	je	SHORT $LN273@CreateStri

; 713  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

	mov	DWORD PTR [ecx], esi

; 714  :         _Orphan_range(_Mylast, _Mylast);
; 715  :         _Ty& _Result = *_Mylast;
; 716  :         ++_Mylast;

	add	DWORD PTR [edi+4], 4

; 731  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

	jmp	SHORT $LN272@CreateStri
$LN273@CreateStri:

; 732  :         }
; 733  : 
; 734  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	lea	eax, DWORD PTR _nUnique$2[esp+96]
	push	eax
	push	ecx
	mov	ecx, edi
	call	??$_Emplace_reallocate@ABH@?$vector@HV?$xalloc@H@@@std@@QAEPAHQAHABH@Z ; std::vector<int,xalloc<int> >::_Emplace_reallocate<int const &>
	mov	eax, DWORD PTR _tLastFace$3$[esp+96]
$LN272@CreateStri:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 852  : 				tLastFace.m_v0 = tLastFace.m_v1;

	mov	ecx, ebx

; 853  : 				tLastFace.m_v1 = tLastFace.m_v2;
; 854  : 				tLastFace.m_v2 = nUnique;

	mov	DWORD PTR _tLastFace$3$[esp+96], esi
	mov	ebx, eax
	mov	DWORD PTR _tLastFace$[esp+96], ecx
	mov	DWORD PTR _tLastFace$[esp+100], ebx
	mov	DWORD PTR _tLastFace$[esp+104], esi

; 285  : 		facev2 != faceA->m_v1 &&

	jmp	SHORT $LN5@CreateStri
$LN309@CreateStri:

; 842  : 		}
; 843  : 
; 844  : 		for (int j = 1; j < nStripFaceCount; j++)

	mov	esi, DWORD PTR _tLastFace$3$[esp+96]
$LN5@CreateStri:
	mov	edx, DWORD PTR _j$1$[esp+96]
	inc	edx
	mov	DWORD PTR _j$1$[esp+96], edx
	cmp	edx, DWORD PTR _nStripFaceCount$1$[esp+96]
	jl	$LL7@CreateStri
$LN302@CreateStri:

; 855  : 			}
; 856  : 		}
; 857  : 
; 858  : 		// Double tap between strips.
; 859  : 		if(bStitchStrips)
; 860  : 		{
; 861  : 			if(i != nStripCount - 1)

	mov	ebx, DWORD PTR _i$1$[esp+96]
	cmp	ebx, DWORD PTR tv1982[esp+96]
	je	SHORT $LN279@CreateStri
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 730  :         if (_Mylast != _My_data._Myend) {

	mov	eax, DWORD PTR [edi+4]
	cmp	eax, DWORD PTR [edi+8]
	je	SHORT $LN280@CreateStri

; 713  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

	mov	DWORD PTR [eax], esi

; 714  :         _Orphan_range(_Mylast, _Mylast);
; 715  :         _Ty& _Result = *_Mylast;
; 716  :         ++_Mylast;

	add	DWORD PTR [edi+4], 4

; 731  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

	jmp	SHORT $LN279@CreateStri
$LN280@CreateStri:

; 732  :         }
; 733  : 
; 734  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	lea	ecx, DWORD PTR _tLastFace$[esp+104]
	push	ecx
	push	eax
	mov	ecx, edi
	call	??$_Emplace_reallocate@ABH@?$vector@HV?$xalloc@H@@@std@@QAEPAHQAHABH@Z ; std::vector<int,xalloc<int> >::_Emplace_reallocate<int const &>
$LN279@CreateStri:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 783  : 	for (int i = 0; i < nStripCount; i++)

	mov	ecx, DWORD PTR _allStrips$[ebp]
	inc	ebx
	mov	DWORD PTR _i$1$[esp+96], ebx
	cmp	ebx, DWORD PTR _nStripCount$1$[esp+96]
	jl	$LL4@CreateStri
$LN303@CreateStri:

; 862  : 				stripIndices.push_back(tLastFace.m_v2);
; 863  : 		}
; 864  : 		else
; 865  : 		{
; 866  : 			//-1 index indicates next strip
; 867  : 			stripIndices.push_back(-1);
; 868  : 			accountForNegatives++;
; 869  : 			numSeparateStrips++;
; 870  : 		}
; 871  : 
; 872  : 		// Update last face info
; 873  : 		tLastFace.m_v0 = tLastFace.m_v1;
; 874  : 		tLastFace.m_v1 = tLastFace.m_v2;
; 875  : 		tLastFace.m_v2 = tLastFace.m_v2;
; 876  : 	}
; 877  : 	
; 878  : 	if(bStitchStrips)
; 879  : 		numSeparateStrips = 1;
; 880  : }

	mov	eax, DWORD PTR _numSeparateStrips$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	DWORD PTR [eax], 1
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?CreateStrips@NvStripifier@@QAEXABV?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@AAV?$xr_vector@HV?$xalloc@H@@@@_NAAI@Z ENDP ; NvStripifier::CreateStrips
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_std_extensions.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_std_extensions.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_std_extensions.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
_TEXT	SEGMENT
_allEdgeInfos$ = -36					; size = 12
_allStrips$ = -24					; size = 12
_allFaceInfos$ = -12					; size = 12
tv814 = 8						; size = 4
_in_indices$ = 8					; size = 4
_in_cacheSize$dead$ = 12				; size = 4
_in_minStripLength$dead$ = 16				; size = 4
_outStrips$ = 20					; size = 4
_outFaceList$ = 24					; size = 4
?Stripify@NvStripifier@@QAEXABV?$xr_vector@GV?$xalloc@G@@@@HHAAV?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@AAV?$xr_vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@@@Z PROC ; NvStripifier::Stripify
; _this$ = ecx

; 892  : {

	sub	esp, 36					; 00000024H
; File I:\Vitalya\mine\NSProjectX\xrCore\_std_extensions.h

; 159  : IC s32		_max	(s32 x, s32 y)	{ return x - ((x - y) & ((x - y) >> (sizeof(s32) * 8 - 1))); };

	mov	eax, 7
	sub	eax, DWORD PTR ?cacheSize@@3IA
	mov	edx, eax
	sar	edx, 31					; 0000001fH
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 892  : {

	push	ebx
	push	ebp
; File I:\Vitalya\mine\NSProjectX\xrCore\_std_extensions.h

; 159  : IC s32		_max	(s32 x, s32 y)	{ return x - ((x - y) & ((x - y) >> (sizeof(s32) * 8 - 1))); };

	and	edx, eax
	mov	eax, 1
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 892  : {

	push	esi
	mov	esi, ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\_std_extensions.h

; 159  : IC s32		_max	(s32 x, s32 y)	{ return x - ((x - y) & ((x - y) >> (sizeof(s32) * 8 - 1))); };

	sub	eax, edx
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 892  : {

	push	edi

; 895  : 
; 896  : 	//the number of times to run the experiments
; 897  : 	int numSamples = 10;
; 898  : 	
; 899  : 	//the cache size, clamped to one
; 900  : 	cacheSize = _max	(1, in_cacheSize - CACHE_INEFFICIENCY);

	mov	DWORD PTR [esi+12], eax

; 901  : 	
; 902  : 	minStripLength = in_minStripLength;  //this is the strip size threshold below which we dump the strip into a list

	mov	eax, DWORD PTR ?minStripSize@@3IA
	mov	DWORD PTR [esi+16], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1202 :         if (this != _STD addressof(_Right)) {

	mov	eax, DWORD PTR _in_indices$[esp+48]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 893  : 	meshJump = 0.0f;

	mov	DWORD PTR [esi+20], 0

; 894  : 	bFirstTimeResetPoint = true; //used in FindGoodResetPoint()

	mov	BYTE PTR [esi+24], 1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1202 :         if (this != _STD addressof(_Right)) {

	cmp	esi, eax
	je	SHORT $LN18@Stripify

; 1187 :         assign(_Right_data._Myfirst, _Right_data._Mylast);

	push	DWORD PTR [eax+4]
	push	DWORD PTR [eax]
	call	??$assign@PAG$0A@@?$vector@GV?$xalloc@G@@@std@@QAEXPAG0@Z ; std::vector<unsigned short,xalloc<unsigned short> >::assign<unsigned short *,0>
$LN18@Stripify:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 910  : 	BuildStripifyInfo(allFaceInfos, allEdgeInfos);

	lea	eax, DWORD PTR _allEdgeInfos$[esp+52]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR _allFaceInfos$[esp+52], 0
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 910  : 	BuildStripifyInfo(allFaceInfos, allEdgeInfos);

	push	eax
	lea	eax, DWORD PTR _allFaceInfos$[esp+56]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR _allFaceInfos$[esp+60], 0
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 910  : 	BuildStripifyInfo(allFaceInfos, allEdgeInfos);

	push	eax
	mov	ecx, esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR _allFaceInfos$[esp+68], 0
	mov	DWORD PTR _allEdgeInfos$[esp+60], 0
	mov	DWORD PTR _allEdgeInfos$[esp+64], 0
	mov	DWORD PTR _allEdgeInfos$[esp+68], 0
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 910  : 	BuildStripifyInfo(allFaceInfos, allEdgeInfos);

	call	?BuildStripifyInfo@NvStripifier@@IAEXAAV?$xr_vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@@AAV?$xr_vector@PAVNvEdgeInfo@@V?$xalloc@PAVNvEdgeInfo@@@@@@@Z ; NvStripifier::BuildStripifyInfo

; 915  : 	FindAllStrips(allStrips, allFaceInfos, allEdgeInfos, numSamples);

	push	ecx
	lea	eax, DWORD PTR _allEdgeInfos$[esp+56]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR _allStrips$[esp+56], 0
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 915  : 	FindAllStrips(allStrips, allFaceInfos, allEdgeInfos, numSamples);

	push	eax
	lea	eax, DWORD PTR _allFaceInfos$[esp+60]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR _allStrips$[esp+64], 0
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 915  : 	FindAllStrips(allStrips, allFaceInfos, allEdgeInfos, numSamples);

	push	eax
	lea	eax, DWORD PTR _allStrips$[esp+64]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR _allStrips$[esp+72], 0
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 915  : 	FindAllStrips(allStrips, allFaceInfos, allEdgeInfos, numSamples);

	push	eax
	mov	ecx, esi
	call	?FindAllStrips@NvStripifier@@IAEXAAV?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@AAV?$xr_vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@@AAV?$xr_vector@PAVNvEdgeInfo@@V?$xalloc@PAVNvEdgeInfo@@@@@@H@Z ; NvStripifier::FindAllStrips

; 916  : 	
; 917  : 	//split up the strips into cache friendly pieces, optimize them, then dump these into outStrips
; 918  : 	SplitUpStripsAndOptimize(allStrips, outStrips, allEdgeInfos, outFaceList);

	push	DWORD PTR _outFaceList$[esp+48]
	lea	eax, DWORD PTR _allEdgeInfos$[esp+56]
	mov	ecx, esi
	push	eax
	push	DWORD PTR _outStrips$[esp+56]
	lea	eax, DWORD PTR _allStrips$[esp+64]
	push	eax
	call	?SplitUpStripsAndOptimize@NvStripifier@@IAEXAAV?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@0AAV?$xr_vector@PAVNvEdgeInfo@@V?$xalloc@PAVNvEdgeInfo@@@@@@AAV?$xr_vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@@@Z ; NvStripifier::SplitUpStripsAndOptimize
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	eax, DWORD PTR _allStrips$[esp+56]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 921  : 	for(int i = 0; i < allStrips.size(); i++)

	xor	esi, esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	ebp, DWORD PTR _allStrips$[esp+52]
	sub	eax, ebp
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 921  : 	for(int i = 0; i < allStrips.size(); i++)

	mov	ebx, DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	sar	eax, 2
	mov	DWORD PTR tv814[esp+48], eax
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 921  : 	for(int i = 0; i < allStrips.size(); i++)

	test	eax, eax
	je	SHORT $LN3@Stripify
$LL4@Stripify:
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h

; 151  : 	if (ptr) 

	mov	edi, DWORD PTR [ebp+esi*4]
	test	edi, edi
	je	SHORT $LN2@Stripify
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [edi+12]
	test	eax, eax
	je	SHORT $LN82@Stripify
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	ebx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [edi+12], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [edi+16], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [edi+20], 0
	mov	edi, DWORD PTR [ebp+esi*4]
$LN82@Stripify:
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h

; 144  : 		Memory.mem_free	(ptr);

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	edi
	call	ebx
	mov	eax, DWORD PTR tv814[esp+48]

; 154  : 		ptr = nullptr;

	mov	DWORD PTR [ebp+esi*4], 0
$LN2@Stripify:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 921  : 	for(int i = 0; i < allStrips.size(); i++)

	inc	esi
	cmp	esi, eax
	jb	SHORT $LL4@Stripify
$LN3@Stripify:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	edx, DWORD PTR _allEdgeInfos$[esp+56]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 926  : 	for (u32 i = 0; i < allEdgeInfos.size(); i++)

	xor	edi, edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	ecx, DWORD PTR _allEdgeInfos$[esp+52]
	mov	eax, edx
	sub	eax, ecx
	sar	eax, 2
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 926  : 	for (u32 i = 0; i < allEdgeInfos.size(); i++)

	test	eax, eax
	je	SHORT $LN6@Stripify
$LL7@Stripify:

; 927  : 	{
; 928  : 		NvEdgeInfo *info = allEdgeInfos[i];

	mov	eax, DWORD PTR [ecx+edi*4]

; 929  : 		while (info != NULL)

	test	eax, eax
	je	SHORT $LN5@Stripify
$LL8@Stripify:

; 930  : 		{
; 931  : 			NvEdgeInfo *next = (info->m_v0 == int(i) ? info->m_nextV0 : info->m_nextV1);

	cmp	DWORD PTR [eax+12], edi
	jne	SHORT $LN11@Stripify
	mov	esi, DWORD PTR [eax+20]
	jmp	SHORT $LN12@Stripify
$LN11@Stripify:
	mov	esi, DWORD PTR [eax+24]
$LN12@Stripify:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.h

; 68   : 		if (--m_refCount == 0) 

	add	DWORD PTR [eax], -1
	jne	SHORT $LN111@Stripify

; 69   : 		{
; 70   : 			Memory.mem_free	(this);

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	ebx
$LN111@Stripify:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 933  : 			info = next;

	mov	eax, esi
	test	esi, esi
	jne	SHORT $LL8@Stripify
	mov	edx, DWORD PTR _allEdgeInfos$[esp+56]
	mov	ecx, DWORD PTR _allEdgeInfos$[esp+52]
$LN5@Stripify:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	eax, edx
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 926  : 	for (u32 i = 0; i < allEdgeInfos.size(); i++)

	inc	edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	sub	eax, ecx
	sar	eax, 2
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 926  : 	for (u32 i = 0; i < allEdgeInfos.size(); i++)

	cmp	edi, eax
	jb	SHORT $LL7@Stripify
$LN6@Stripify:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	test	ebp, ebp
	je	SHORT $LN123@Stripify
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	ebp
	call	ebx
	mov	ecx, DWORD PTR _allEdgeInfos$[esp+52]
$LN123@Stripify:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	test	ecx, ecx
	je	SHORT $LN130@Stripify
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	push	ecx
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	ebx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR _allEdgeInfos$[esp+52], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR _allEdgeInfos$[esp+56], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR _allEdgeInfos$[esp+60], 0
$LN130@Stripify:

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR _allFaceInfos$[esp+52]
	test	eax, eax
	je	SHORT $LN147@Stripify
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	ebx
$LN147@Stripify:
	pop	edi
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 937  : }

	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 36					; 00000024H
	ret	20					; 00000014H
?Stripify@NvStripifier@@QAEXABV?$xr_vector@GV?$xalloc@G@@@@HHAAV?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@AAV?$xr_vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@@@Z ENDP ; NvStripifier::Stripify
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
_TEXT	SEGMENT
??1NvStripifier@@QAE@XZ PROC				; NvStripifier::~NvStripifier
; _this$ = ecx

; 18   : {

	push	esi
	mov	esi, ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN8@NvStripifi
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+4], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+8], 0
$LN8@NvStripifi:
	pop	esi
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 20   : }

	ret	0
??1NvStripifier@@QAE@XZ ENDP				; NvStripifier::~NvStripifier
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
_TEXT	SEGMENT
??0NvStripifier@@QAE@XZ PROC				; NvStripifier::NvStripifier
; _this$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx], 0
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 15   : }

	mov	eax, ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 15   : }

	ret	0
??0NvStripifier@@QAE@XZ ENDP				; NvStripifier::NvStripifier
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\VertexCache.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\VertexCache.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\VertexCache.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\VertexCache.h
;	COMDAT ?InCache@VertexCache@@QAE_NH@Z
_TEXT	SEGMENT
_entry$ = 8						; size = 4
?InCache@VertexCache@@QAE_NH@Z PROC			; VertexCache::InCache, COMDAT
; _this$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	edx, DWORD PTR [ecx]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\VertexCache.h

; 26   : 	bool returnVal = false;

	xor	al, al
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	ecx, DWORD PTR [ecx+4]
	sub	ecx, edx
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\VertexCache.h

; 25   : {

	push	esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	sar	ecx, 2
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\VertexCache.h

; 28   : 	for(u32 i = 0; i < entries.size(); i++)

	xor	esi, esi
	test	ecx, ecx
	je	SHORT $LN3@InCache
	push	edi
	mov	edi, DWORD PTR _entry$[esp+4]
$LL4@InCache:

; 29   : 	{
; 30   : 		if(entries[i] == entry)

	cmp	DWORD PTR [edx], edi
	je	SHORT $LN29@InCache

; 28   : 	for(u32 i = 0; i < entries.size(); i++)

	inc	esi
	add	edx, 4
	cmp	esi, ecx
	jb	SHORT $LL4@InCache
	pop	edi
	pop	esi

; 33   : 			break;
; 34   : 		}
; 35   : 	}
; 36   : 
; 37   : 	return returnVal;
; 38   : }

	ret	4
$LN29@InCache:

; 31   : 		{
; 32   : 			returnVal = true;

	mov	al, 1
	pop	edi
$LN3@InCache:

; 33   : 			break;
; 34   : 		}
; 35   : 	}
; 36   : 
; 37   : 	return returnVal;
; 38   : }

	pop	esi
	ret	4
?InCache@VertexCache@@QAE_NH@Z ENDP			; VertexCache::InCache
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\VertexCache.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\VertexCache.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\VertexCache.h
;	COMDAT ?AddEntry@VertexCache@@QAEHH@Z
_TEXT	SEGMENT
_entry$ = 8						; size = 4
?AddEntry@VertexCache@@QAEHH@Z PROC			; VertexCache::AddEntry, COMDAT
; _this$ = ecx

; 42   : {

	push	esi
	mov	esi, ecx
	push	edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	ecx, DWORD PTR [esi]
	mov	edx, DWORD PTR [esi+4]
	sub	edx, ecx
	sar	edx, 2
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\VertexCache.h

; 45   : 	removed = entries[entries.size() - 1];

	mov	edi, DWORD PTR [ecx+edx*4-4]

; 46   : 
; 47   : 	//push everything right one
; 48   : 	for(int i = (u32)entries.size() - 2; i >= 0; i--)

	add	edx, -2					; fffffffeH
	js	SHORT $LN86@AddEntry
$LL4@AddEntry:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 119  :         _Ptr += _Off;

	mov	eax, DWORD PTR [esi]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\VertexCache.h

; 50   : 		entries[i + 1] = entries[i];

	mov	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR [eax+edx*4+4], ecx
	sub	edx, 1
	jns	SHORT $LL4@AddEntry

; 54   : 
; 55   : 	return removed;
; 56   : }

	mov	edx, DWORD PTR [esi]
	mov	eax, edi
	mov	ecx, DWORD PTR _entry$[esp+4]
	pop	edi
	pop	esi
	mov	DWORD PTR [edx], ecx
	ret	4
$LN86@AddEntry:

; 51   : 	}
; 52   : 
; 53   : 	entries[0] = entry;

	mov	eax, DWORD PTR _entry$[esp+4]
	mov	DWORD PTR [ecx], eax

; 54   : 
; 55   : 	return removed;
; 56   : }

	mov	eax, edi
	pop	edi
	pop	esi
	ret	4
?AddEntry@VertexCache@@QAEHH@Z ENDP			; VertexCache::AddEntry
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.h
;	COMDAT ??0NvFaceInfo@@QAE@HHH@Z
_TEXT	SEGMENT
_v0$ = 8						; size = 4
_v1$ = 12						; size = 4
_v2$ = 16						; size = 4
??0NvFaceInfo@@QAE@HHH@Z PROC				; NvFaceInfo::NvFaceInfo, COMDAT
; _this$ = ecx

; 32   : 		m_v0 = v0; m_v1 = v1; m_v2 = v2;

	mov	eax, DWORD PTR _v0$[esp-4]
	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR _v1$[esp-4]
	mov	DWORD PTR [ecx+4], eax
	mov	eax, DWORD PTR _v2$[esp-4]
	mov	DWORD PTR [ecx+8], eax

; 33   : 		m_stripId      = -1;
; 34   : 		m_testStripId  = -1;
; 35   : 		m_experimentId = -1;
; 36   : 	}

	mov	eax, ecx
	mov	DWORD PTR [ecx+12], -1
	mov	DWORD PTR [ecx+16], -1
	mov	DWORD PTR [ecx+20], -1
	ret	12					; 0000000cH
??0NvFaceInfo@@QAE@HHH@Z ENDP				; NvFaceInfo::NvFaceInfo
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.h
;	COMDAT ??0NvEdgeInfo@@QAE@HH@Z
_TEXT	SEGMENT
_v0$ = 8						; size = 4
_v1$ = 12						; size = 4
??0NvEdgeInfo@@QAE@HH@Z PROC				; NvEdgeInfo::NvEdgeInfo, COMDAT
; _this$ = ecx

; 53   : 		m_v0       = v0;

	mov	eax, DWORD PTR _v0$[esp-4]
	mov	DWORD PTR [ecx+12], eax

; 54   : 		m_v1       = v1;

	mov	eax, DWORD PTR _v1$[esp-4]
	mov	DWORD PTR [ecx+16], eax

; 55   : 		m_face0    = NULL;
; 56   : 		m_face1    = NULL;
; 57   : 		m_nextV0   = NULL;
; 58   : 		m_nextV1   = NULL;
; 59   : 		
; 60   : 		// we will appear in 2 lists.  this is a good
; 61   : 		// way to make sure we _delete it the second time
; 62   : 		// we hit it in the edge infos
; 63   : 		m_refCount = 2;    
; 64   : 	}

	mov	eax, ecx
	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0
	mov	DWORD PTR [ecx+20], 0
	mov	DWORD PTR [ecx+24], 0
	mov	DWORD PTR [ecx], 2
	ret	8
??0NvEdgeInfo@@QAE@HH@Z ENDP				; NvEdgeInfo::NvEdgeInfo
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.h
;	COMDAT ?Unref@NvEdgeInfo@@QAEXXZ
_TEXT	SEGMENT
?Unref@NvEdgeInfo@@QAEXXZ PROC				; NvEdgeInfo::Unref, COMDAT
; _this$ = ecx

; 68   : 		if (--m_refCount == 0) 

	add	DWORD PTR [ecx], -1
	jne	SHORT $LN2@Unref

; 69   : 		{
; 70   : 			Memory.mem_free	(this);

	push	ecx
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN2@Unref:

; 71   : 		}
; 72   : 	}

	ret	0
?Unref@NvEdgeInfo@@QAEXXZ ENDP				; NvEdgeInfo::Unref
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.h
;	COMDAT ??0NvStripStartInfo@@QAE@PAVNvFaceInfo@@PAVNvEdgeInfo@@_N@Z
_TEXT	SEGMENT
_startFace$ = 8						; size = 4
_startEdge$ = 12					; size = 4
_toV1$ = 16						; size = 1
??0NvStripStartInfo@@QAE@PAVNvFaceInfo@@PAVNvEdgeInfo@@_N@Z PROC ; NvStripStartInfo::NvStripStartInfo, COMDAT
; _this$ = ecx

; 89   : 		m_startFace    = startFace;

	mov	eax, DWORD PTR _startFace$[esp-4]
	mov	DWORD PTR [ecx], eax

; 90   : 		m_startEdge    = startEdge;

	mov	eax, DWORD PTR _startEdge$[esp-4]
	mov	DWORD PTR [ecx+4], eax

; 91   : 		m_toV1         = toV1;

	mov	al, BYTE PTR _toV1$[esp-4]
	mov	BYTE PTR [ecx+8], al

; 92   : 	}

	mov	eax, ecx
	ret	12					; 0000000cH
??0NvStripStartInfo@@QAE@PAVNvFaceInfo@@PAVNvEdgeInfo@@_N@Z ENDP ; NvStripStartInfo::NvStripStartInfo
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.h
;	COMDAT ??0NvStripInfo@@QAE@ABVNvStripStartInfo@@HH@Z
_TEXT	SEGMENT
_startInfo$ = 8						; size = 4
_stripId$ = 12						; size = 4
_experimentId$ = 16					; size = 4
??0NvStripInfo@@QAE@ABVNvStripStartInfo@@HH@Z PROC	; NvStripInfo::NvStripInfo, COMDAT
; _this$ = ecx

; 123  : 	  m_startInfo(startInfo)

	mov	edx, DWORD PTR _startInfo$[esp-4]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+4], eax
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR [ecx+8], eax

; 125  : 		m_stripId      = stripId;

	mov	eax, DWORD PTR _stripId$[esp-4]
	mov	DWORD PTR [ecx+24], eax

; 126  : 		m_experimentId = experimentId;

	mov	eax, DWORD PTR _experimentId$[esp-4]
	mov	DWORD PTR [ecx+28], eax

; 128  : 	}

	mov	eax, ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx+12], 0
	mov	DWORD PTR [ecx+16], 0
	mov	DWORD PTR [ecx+20], 0
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.h

; 127  : 		visited = false;

	mov	BYTE PTR [ecx+32], 0

; 128  : 	}

	ret	12					; 0000000cH
??0NvStripInfo@@QAE@ABVNvStripStartInfo@@HH@Z ENDP	; NvStripInfo::NvStripInfo
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.h
;	COMDAT ?IsExperiment@NvStripInfo@@QBE_NXZ
_TEXT	SEGMENT
?IsExperiment@NvStripInfo@@QBE_NXZ PROC			; NvStripInfo::IsExperiment, COMDAT
; _this$ = ecx

; 131  : 	inline bool IsExperiment () const { return m_experimentId >= 0; }

	mov	eax, DWORD PTR [ecx+28]
	shr	eax, 31					; 0000001fH
	xor	al, 1
	ret	0
?IsExperiment@NvStripInfo@@QBE_NXZ ENDP			; NvStripInfo::IsExperiment
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.h
;	COMDAT ?IsInStrip@NvStripInfo@@QBE_NPBVNvFaceInfo@@@Z
_TEXT	SEGMENT
_faceInfo$ = 8						; size = 4
?IsInStrip@NvStripInfo@@QBE_NPBVNvFaceInfo@@@Z PROC	; NvStripInfo::IsInStrip, COMDAT
; _this$ = ecx

; 134  : 	{

	push	esi
	mov	esi, ecx

; 135  : 		if(faceInfo == NULL)

	mov	ecx, DWORD PTR _faceInfo$[esp]
	test	ecx, ecx
	jne	SHORT $LN2@IsInStrip

; 136  : 			return false;

	xor	al, al
	pop	esi

; 139  : 	}

	ret	4
$LN2@IsInStrip:

; 137  : 		  
; 138  : 		return (m_experimentId >= 0 ? faceInfo->m_testStripId == m_stripId : faceInfo->m_stripId == m_stripId);

	xor	edx, edx
	cmp	DWORD PTR [esi+28], edx
	jl	SHORT $LN4@IsInStrip
	mov	eax, DWORD PTR [ecx+16]
	cmp	eax, DWORD PTR [esi+24]
	pop	esi
	sete	dl
	mov	al, dl

; 139  : 	}

	ret	4
$LN4@IsInStrip:

; 137  : 		  
; 138  : 		return (m_experimentId >= 0 ? faceInfo->m_testStripId == m_stripId : faceInfo->m_stripId == m_stripId);

	mov	ecx, DWORD PTR [ecx+12]
	cmp	ecx, DWORD PTR [esi+24]
	pop	esi
	sete	dl
	mov	al, dl

; 139  : 	}

	ret	4
?IsInStrip@NvStripInfo@@QBE_NPBVNvFaceInfo@@@Z ENDP	; NvStripInfo::IsInStrip
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
_TEXT	SEGMENT
_v1$ = 8						; size = 4
?FindEdgeInfo@NvStripifier@@KAPAVNvEdgeInfo@@AAV?$xr_vector@PAVNvEdgeInfo@@V?$xalloc@PAVNvEdgeInfo@@@@@@HH@Z PROC ; NvStripifier::FindEdgeInfo
; _edgeInfos$ = ecx
; _v0$ = edx

; 28   : 	
; 29   : 	// we can get to it through either array
; 30   : 	// because the edge infos have a v0 and v1
; 31   : 	// and there is no order except how it was
; 32   : 	// first created.
; 33   : 	NvEdgeInfo *infoIter = edgeInfos[v0];

	mov	eax, DWORD PTR [ecx]
	push	esi
	mov	eax, DWORD PTR [eax+edx*4]

; 34   : 	while (infoIter != NULL){

	test	eax, eax
	je	SHORT $LN3@FindEdgeIn
	mov	esi, DWORD PTR _v1$[esp]
	npad	2
$LL2@FindEdgeIn:

; 35   : 		if (infoIter->m_v0 == v0){

	mov	ecx, DWORD PTR [eax+12]
	cmp	ecx, edx
	jne	SHORT $LN4@FindEdgeIn

; 36   : 			if (infoIter->m_v1 == v1)

	cmp	DWORD PTR [eax+16], esi
	je	SHORT $LN1@FindEdgeIn

; 37   : 				return infoIter;
; 38   : 			else
; 39   : 				infoIter = infoIter->m_nextV0;

	mov	eax, DWORD PTR [eax+20]

; 40   : 		}

	jmp	SHORT $LN9@FindEdgeIn
$LN4@FindEdgeIn:

; 41   : 		else {
; 42   : 			assert(infoIter->m_v1 == v0);
; 43   : 			if (infoIter->m_v0 == v1)

	cmp	ecx, esi
	je	SHORT $LN1@FindEdgeIn

; 44   : 				return infoIter;
; 45   : 			else
; 46   : 				infoIter = infoIter->m_nextV1;

	mov	eax, DWORD PTR [eax+24]
$LN9@FindEdgeIn:

; 34   : 	while (infoIter != NULL){

	test	eax, eax
	jne	SHORT $LL2@FindEdgeIn
$LN3@FindEdgeIn:

; 47   : 		}
; 48   : 	}
; 49   : 	return NULL;

	xor	eax, eax
$LN1@FindEdgeIn:
	pop	esi

; 50   : }

	ret	0
?FindEdgeInfo@NvStripifier@@KAPAVNvEdgeInfo@@AAV?$xr_vector@PAVNvEdgeInfo@@V?$xalloc@PAVNvEdgeInfo@@@@@@HH@Z ENDP ; NvStripifier::FindEdgeInfo
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
_TEXT	SEGMENT
_v1$ = 8						; size = 4
_faceInfo$ = 12						; size = 4
?FindOtherFace@NvStripifier@@KAPAVNvFaceInfo@@AAV?$xr_vector@PAVNvEdgeInfo@@V?$xalloc@PAVNvEdgeInfo@@@@@@HHPAV2@@Z PROC ; NvStripifier::FindOtherFace
; _edgeInfos$ = ecx
; _v0$ = edx

; 33   : 	NvEdgeInfo *infoIter = edgeInfos[v0];

	mov	eax, DWORD PTR [ecx]

; 59   : NvFaceInfo * NvStripifier::FindOtherFace(NvEdgeInfoVec &edgeInfos, int v0, int v1, NvFaceInfo *faceInfo){

	push	esi

; 33   : 	NvEdgeInfo *infoIter = edgeInfos[v0];

	mov	eax, DWORD PTR [eax+edx*4]

; 34   : 	while (infoIter != NULL){

	test	eax, eax
	je	SHORT $LN7@FindOtherF
	mov	esi, DWORD PTR _v1$[esp]
	npad	2
$LL6@FindOtherF:

; 35   : 		if (infoIter->m_v0 == v0){

	mov	ecx, DWORD PTR [eax+12]
	cmp	ecx, edx
	jne	SHORT $LN8@FindOtherF

; 36   : 			if (infoIter->m_v1 == v1)

	cmp	DWORD PTR [eax+16], esi
	je	SHORT $LN5@FindOtherF

; 37   : 				return infoIter;
; 38   : 			else
; 39   : 				infoIter = infoIter->m_nextV0;

	mov	eax, DWORD PTR [eax+20]

; 40   : 		}

	jmp	SHORT $LN13@FindOtherF
$LN8@FindOtherF:

; 41   : 		else {
; 42   : 			assert(infoIter->m_v1 == v0);
; 43   : 			if (infoIter->m_v0 == v1)

	cmp	ecx, esi
	je	SHORT $LN5@FindOtherF

; 44   : 				return infoIter;
; 45   : 			else
; 46   : 				infoIter = infoIter->m_nextV1;

	mov	eax, DWORD PTR [eax+24]
$LN13@FindOtherF:

; 34   : 	while (infoIter != NULL){

	test	eax, eax
	jne	SHORT $LL6@FindOtherF
$LN7@FindOtherF:

; 47   : 		}
; 48   : 	}
; 49   : 	return NULL;

	xor	eax, eax
$LN5@FindOtherF:

; 60   : 	NvEdgeInfo *edgeInfo = FindEdgeInfo(edgeInfos, v0, v1);
; 61   : 	assert(edgeInfo != NULL);
; 62   : 	return (edgeInfo->m_face0 == faceInfo ? edgeInfo->m_face1 : edgeInfo->m_face0);

	mov	ecx, DWORD PTR [eax+4]
	pop	esi
	cmp	ecx, DWORD PTR _faceInfo$[esp-4]
	jne	SHORT $LN3@FindOtherF
	mov	eax, DWORD PTR [eax+8]

; 63   : }

	ret	0
$LN3@FindOtherF:

; 60   : 	NvEdgeInfo *edgeInfo = FindEdgeInfo(edgeInfos, v0, v1);
; 61   : 	assert(edgeInfo != NULL);
; 62   : 	return (edgeInfo->m_face0 == faceInfo ? edgeInfo->m_face1 : edgeInfo->m_face0);

	mov	eax, ecx

; 63   : }

	ret	0
?FindOtherFace@NvStripifier@@KAPAVNvFaceInfo@@AAV?$xr_vector@PAVNvEdgeInfo@@V?$xalloc@PAVNvEdgeInfo@@@@@@HHPAV2@@Z ENDP ; NvStripifier::FindOtherFace
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
_TEXT	SEGMENT
_faceInfo$ = 8						; size = 4
_faceInfos$ = 12					; size = 4
?AlreadyExists@NvStripifier@@IAE_NPAVNvFaceInfo@@AAV?$xr_vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@@@Z PROC ; NvStripifier::AlreadyExists
; _this$dead$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	eax, DWORD PTR _faceInfos$[esp-4]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 68   : 	for(int i = 0; i < faceInfos.size(); i++)

	xor	ecx, ecx
	push	ebx
	push	ebp
	push	esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	esi, DWORD PTR [eax+4]
	mov	ebx, DWORD PTR [eax]
	sub	esi, ebx
	sar	esi, 2
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 67   : {

	push	edi

; 68   : 	for(int i = 0; i < faceInfos.size(); i++)

	test	esi, esi
	je	SHORT $LN67@AlreadyExi

; 69   : 	{
; 70   : 		if( (faceInfos[i]->m_v0 == faceInfo->m_v0) &&
; 71   : 			(faceInfos[i]->m_v1 == faceInfo->m_v1) &&

	mov	edi, DWORD PTR _faceInfo$[esp+12]
	mov	ebp, DWORD PTR [edi]
	npad	2
$LL4@AlreadyExi:
	mov	edx, DWORD PTR [ebx+ecx*4]
	cmp	DWORD PTR [edx], ebp
	jne	SHORT $LN2@AlreadyExi
	mov	eax, DWORD PTR [edx+4]
	cmp	eax, DWORD PTR [edi+4]
	jne	SHORT $LN2@AlreadyExi
	mov	eax, DWORD PTR [edx+8]
	cmp	eax, DWORD PTR [edi+8]
	je	SHORT $LN63@AlreadyExi
$LN2@AlreadyExi:

; 68   : 	for(int i = 0; i < faceInfos.size(); i++)

	inc	ecx
	cmp	ecx, esi
	jb	SHORT $LL4@AlreadyExi
$LN67@AlreadyExi:
	pop	edi

; 72   : 			(faceInfos[i]->m_v2 == faceInfo->m_v2) )
; 73   : 			return true;
; 74   : 	}
; 75   : 
; 76   : 	return false;
; 77   : }

	pop	esi
	pop	ebp
	xor	al, al
	pop	ebx
	ret	8
$LN63@AlreadyExi:
	pop	edi
	pop	esi
	pop	ebp
	mov	al, 1
	pop	ebx
	ret	8
?AlreadyExists@NvStripifier@@IAE_NPAVNvFaceInfo@@AAV?$xr_vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@@@Z ENDP ; NvStripifier::AlreadyExists
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
_TEXT	SEGMENT
$T1 = -24						; size = 4
_numTriangles$1$ = -20					; size = 4
_this$1$ = -16						; size = 4
tv2466 = -12						; size = 4
_faceInfo$2 = -8					; size = 4
_index$1$ = -4						; size = 4
_faceInfos$ = 8						; size = 4
_edgeInfos$ = 12					; size = 4
?BuildStripifyInfo@NvStripifier@@IAEXAAV?$xr_vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@@AAV?$xr_vector@PAVNvEdgeInfo@@V?$xalloc@PAVNvEdgeInfo@@@@@@@Z PROC ; NvStripifier::BuildStripifyInfo
; _this$ = ecx

; 84   : void NvStripifier::BuildStripifyInfo(NvFaceInfoVec &faceInfos, NvEdgeInfoVec &edgeInfos){

	sub	esp, 24					; 00000018H
	push	esi
	mov	esi, ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1546 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	ecx, DWORD PTR _faceInfos$[esp+24]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 84   : void NvStripifier::BuildStripifyInfo(NvFaceInfoVec &faceInfos, NvEdgeInfoVec &edgeInfos){

	push	edi
	mov	DWORD PTR _this$1$[esp+32], esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	edi, DWORD PTR [esi+4]

; 1546 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	eax, DWORD PTR [ecx+8]

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	sub	edi, DWORD PTR [esi]

; 1546 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	sub	eax, DWORD PTR [ecx]

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	sar	edi, 1

; 1546 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	sar	eax, 2

; 1358 :         if (_Newcapacity > capacity()) { // something to do (reserve() never shrinks)

	cmp	edi, eax
	jbe	SHORT $LN27@BuildStrip

; 1359 :             if (_Newcapacity > max_size()) {

	cmp	edi, 1073741823				; 3fffffffH
	ja	$LN531@BuildStrip

; 1361 :             }
; 1362 : 
; 1363 :             _Reallocate_exactly(_Newcapacity);

	push	edi
	call	?_Reallocate_exactly@?$vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@std@@AAEXI@Z ; std::vector<NvFaceInfo *,xalloc<NvFaceInfo *> >::_Reallocate_exactly
$LN27@BuildStrip:
	push	ebx
	push	ebp

; 1250 :         const auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);

	mov	ebp, DWORD PTR _edgeInfos$[esp+36]
	mov	ebx, DWORD PTR [ebp+4]
	mov	ecx, ebx
	mov	edx, DWORD PTR [ebp]
	sub	ecx, edx
	sar	ecx, 2

; 1251 :         if (_Newsize < _Oldsize) { // trim

	cmp	edi, ecx
	jae	SHORT $LN36@BuildStrip

; 1252 :             const pointer _Newlast = _Myfirst + _Newsize;

	lea	eax, DWORD PTR [edx+edi*4]

; 1253 :             _Orphan_range(_Newlast, _Mylast);
; 1254 :             _Destroy(_Newlast, _Mylast);
; 1255 :             _Mylast = _Newlast;
; 1256 :             return;

	jmp	SHORT $LN529@BuildStrip
$LN36@BuildStrip:

; 1257 :         }
; 1258 : 
; 1259 :         if (_Newsize > _Oldsize) { // append

	jbe	SHORT $LN37@BuildStrip

; 1260 :             const auto _Oldcapacity = static_cast<size_type>(_My_data._Myend - _Myfirst);

	mov	eax, DWORD PTR [ebp+8]
	sub	eax, edx
	sar	eax, 2

; 1261 :             if (_Newsize > _Oldcapacity) { // reallocate

	cmp	edi, eax
	jbe	SHORT $LN38@BuildStrip

; 1262 :                 _Resize_reallocate(_Newsize, _Val);

	push	ecx
	push	edi
	mov	ecx, ebp
	call	??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@PAVNvEdgeInfo@@V?$xalloc@PAVNvEdgeInfo@@@@@std@@AAEXIABU_Value_init_tag@1@@Z ; std::vector<NvEdgeInfo *,xalloc<NvEdgeInfo *> >::_Resize_reallocate<std::_Value_init_tag>

; 1263 :                 return;

	jmp	SHORT $LN37@BuildStrip
$LN38@BuildStrip:

; 1264 :             }
; 1265 : 
; 1266 :             const pointer _Oldlast = _Mylast;
; 1267 :             _Mylast                = _Ufill(_Oldlast, _Newsize - _Oldsize, _Val);

	mov	eax, edi
	sub	eax, ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1807 :             _Zero_range(_PFirst, _PFirst + _Count);

	lea	esi, DWORD PTR [eax*4]

; 1792 :     _CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

	push	esi
	push	0
	push	ebx
	call	_memset

; 1808 :             return _First + _Count;

	lea	eax, DWORD PTR [esi+ebx]

; 1792 :     _CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

	add	esp, 12					; 0000000cH
	mov	esi, DWORD PTR _this$1$[esp+40]
$LN529@BuildStrip:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 92   : 	for (int i = 0; i < numIndices; i++)

	mov	DWORD PTR [ebp+4], eax
$LN37@BuildStrip:
	xor	ecx, ecx
	test	edi, edi
	jle	SHORT $LN3@BuildStrip
$LL4@BuildStrip:

; 93   : 		edgeInfos[i] = NULL;

	mov	eax, DWORD PTR [ebp]
	mov	DWORD PTR [eax+ecx*4], 0
	inc	ecx
	cmp	ecx, edi
	jl	SHORT $LL4@BuildStrip
$LN3@BuildStrip:

; 94   : 	
; 95   : 	// iterate through the triangles of the triangle list
; 96   : 	int numTriangles = numIndices / 3;

	mov	eax, 1431655766				; 55555556H

; 97   : 	int index        = 0;

	mov	ecx, 0
	imul	edi
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	mov	DWORD PTR _numTriangles$1$[esp+40], eax

; 98   : 	for (u32 i = 0; i < numTriangles; i++)

	je	$LN526@BuildStrip
	npad	4
$LL7@BuildStrip:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 119  :         _Ptr += _Off;

	mov	eax, DWORD PTR [esi]
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h

; 86   : 	T* ptr	= (T*)Memory.mem_alloc(sizeof(T));

	push	24					; 00000018H
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 101  : 		int v0 = indices[index++];

	movzx	edi, WORD PTR [eax+ecx*2]

; 102  : 		int v1 = indices[index++];

	movzx	esi, WORD PTR [eax+ecx*2+2]

; 103  : 		int v2 = indices[index++];

	movzx	ebx, WORD PTR [eax+ecx*2+4]
	add	ecx, 3
	mov	DWORD PTR _index$1$[esp+44], ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h

; 86   : 	T* ptr	= (T*)Memory.mem_alloc(sizeof(T));

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	edx, DWORD PTR _faceInfos$[esp+36]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 68   : 	for(int i = 0; i < faceInfos.size(); i++)

	xor	ecx, ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h

; 87   : 	return new (ptr) T(p1,p2,p3);

	mov	DWORD PTR $T1[esp+40], eax
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 107  : 		NvFaceInfo *faceInfo = xr_new<NvFaceInfo>(v0, v1, v2);

	mov	DWORD PTR _faceInfo$2[esp+40], eax
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.h

; 32   : 		m_v0 = v0; m_v1 = v1; m_v2 = v2;

	mov	DWORD PTR [eax], edi
	mov	DWORD PTR [eax+4], esi
	mov	DWORD PTR [eax+8], ebx

; 33   : 		m_stripId      = -1;

	mov	DWORD PTR [eax+12], -1

; 34   : 		m_testStripId  = -1;

	mov	DWORD PTR [eax+16], -1

; 35   : 		m_experimentId = -1;

	mov	DWORD PTR [eax+20], -1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	eax, DWORD PTR [edx+4]
	mov	ebp, DWORD PTR [edx]
	mov	edx, eax
	sub	edx, ebp
	mov	DWORD PTR tv2466[esp+40], eax
	sar	edx, 2
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 68   : 	for(int i = 0; i < faceInfos.size(); i++)

	test	edx, edx
	je	SHORT $LN131@BuildStrip
$LL132@BuildStrip:

; 69   : 	{
; 70   : 		if( (faceInfos[i]->m_v0 == faceInfo->m_v0) &&
; 71   : 			(faceInfos[i]->m_v1 == faceInfo->m_v1) &&

	mov	eax, DWORD PTR [ebp+ecx*4]
	cmp	DWORD PTR [eax], edi
	jne	SHORT $LN130@BuildStrip
	cmp	DWORD PTR [eax+4], esi
	jne	SHORT $LN130@BuildStrip
	cmp	DWORD PTR [eax+8], ebx
	je	$LN5@BuildStrip
$LN130@BuildStrip:

; 68   : 	for(int i = 0; i < faceInfos.size(); i++)

	inc	ecx
	cmp	ecx, edx
	jb	SHORT $LL132@BuildStrip
	mov	eax, DWORD PTR tv2466[esp+40]
$LN131@BuildStrip:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 730  :         if (_Mylast != _My_data._Myend) {

	mov	ecx, DWORD PTR _faceInfos$[esp+36]
	cmp	eax, DWORD PTR [ecx+8]
	je	SHORT $LN193@BuildStrip

; 713  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

	mov	edx, DWORD PTR $T1[esp+40]
	mov	DWORD PTR [eax], edx

; 714  :         _Orphan_range(_Mylast, _Mylast);
; 715  :         _Ty& _Result = *_Mylast;
; 716  :         ++_Mylast;

	add	DWORD PTR [ecx+4], 4

; 731  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

	jmp	SHORT $LN192@BuildStrip
$LN193@BuildStrip:

; 732  :         }
; 733  : 
; 734  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	lea	edx, DWORD PTR _faceInfo$2[esp+40]
	push	edx
	push	eax
	call	??$_Emplace_reallocate@ABQAVNvFaceInfo@@@?$vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@std@@QAEPAPAVNvFaceInfo@@QAPAV2@ABQAV2@@Z ; std::vector<NvFaceInfo *,xalloc<NvFaceInfo *> >::_Emplace_reallocate<NvFaceInfo * const &>
	mov	edx, DWORD PTR $T1[esp+40]
$LN192@BuildStrip:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 33   : 	NvEdgeInfo *infoIter = edgeInfos[v0];

	mov	ebp, DWORD PTR _edgeInfos$[esp+36]
	mov	eax, DWORD PTR [ebp]
	mov	eax, DWORD PTR [eax+edi*4]

; 34   : 	while (infoIter != NULL){

	test	eax, eax
	je	SHORT $LN523@BuildStrip
$LL198@BuildStrip:

; 35   : 		if (infoIter->m_v0 == v0){

	mov	ecx, DWORD PTR [eax+12]
	cmp	ecx, edi
	jne	SHORT $LN200@BuildStrip

; 36   : 			if (infoIter->m_v1 == v1)

	cmp	DWORD PTR [eax+16], esi
	je	$LN9@BuildStrip

; 37   : 				return infoIter;
; 38   : 			else
; 39   : 				infoIter = infoIter->m_nextV0;

	mov	eax, DWORD PTR [eax+20]

; 40   : 		}

	jmp	SHORT $LN205@BuildStrip
$LN200@BuildStrip:

; 41   : 		else {
; 42   : 			assert(infoIter->m_v1 == v0);
; 43   : 			if (infoIter->m_v0 == v1)

	cmp	ecx, esi
	je	$LN9@BuildStrip

; 44   : 				return infoIter;
; 45   : 			else
; 46   : 				infoIter = infoIter->m_nextV1;

	mov	eax, DWORD PTR [eax+24]
$LN205@BuildStrip:

; 34   : 	while (infoIter != NULL){

	test	eax, eax
	jne	SHORT $LL198@BuildStrip
$LN523@BuildStrip:
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h

; 80   : 	T* ptr	= (T*)Memory.mem_alloc(sizeof(T));

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	28					; 0000001cH
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z

; 81   : 	return new (ptr) T(p1,p2);

	mov	ecx, eax
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 126  : 				edgeInfo01->m_face0 = faceInfo;

	mov	edx, DWORD PTR $T1[esp+40]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.h

; 55   : 		m_face0    = NULL;

	mov	DWORD PTR [ecx+4], 0

; 56   : 		m_face1    = NULL;
; 57   : 		m_nextV0   = NULL;

	mov	DWORD PTR [ecx+20], 0

; 58   : 		m_nextV1   = NULL;

	mov	DWORD PTR [ecx+24], 0
	mov	DWORD PTR [ecx+12], edi
	mov	DWORD PTR [ecx+16], esi
	mov	DWORD PTR [ecx+8], 0

; 59   : 		
; 60   : 		// we will appear in 2 lists.  this is a good
; 61   : 		// way to make sure we _delete it the second time
; 62   : 		// we hit it in the edge infos
; 63   : 		m_refCount = 2;    

	mov	DWORD PTR [ecx], 2
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 120  : 				edgeInfo01->m_nextV0 = edgeInfos[v0];

	mov	eax, DWORD PTR [ebp]
	mov	eax, DWORD PTR [eax+edi*4]
	mov	DWORD PTR [ecx+20], eax

; 121  : 				edgeInfo01->m_nextV1 = edgeInfos[v1];

	mov	eax, DWORD PTR [ebp]
	mov	eax, DWORD PTR [eax+esi*4]
	mov	DWORD PTR [ecx+24], eax

; 122  : 				edgeInfos[v0] = edgeInfo01;

	mov	eax, DWORD PTR [ebp]
	mov	DWORD PTR [eax+edi*4], ecx

; 123  : 				edgeInfos[v1] = edgeInfo01;

	mov	eax, DWORD PTR [ebp]
	mov	DWORD PTR [eax+esi*4], ecx

; 126  : 				edgeInfo01->m_face0 = faceInfo;

	mov	DWORD PTR [ecx+4], edx
$LN12@BuildStrip:

; 33   : 	NvEdgeInfo *infoIter = edgeInfos[v0];

	mov	eax, DWORD PTR [ebp]
	mov	eax, DWORD PTR [eax+esi*4]

; 34   : 	while (infoIter != NULL){

	test	eax, eax
	je	SHORT $LN524@BuildStrip
$LL297@BuildStrip:

; 35   : 		if (infoIter->m_v0 == v0){

	mov	ecx, DWORD PTR [eax+12]
	cmp	ecx, esi
	jne	SHORT $LN299@BuildStrip

; 36   : 			if (infoIter->m_v1 == v1)

	cmp	DWORD PTR [eax+16], ebx
	je	$LN13@BuildStrip

; 37   : 				return infoIter;
; 38   : 			else
; 39   : 				infoIter = infoIter->m_nextV0;

	mov	eax, DWORD PTR [eax+20]

; 40   : 		}

	jmp	SHORT $LN304@BuildStrip
$LN9@BuildStrip:

; 127  : 			}
; 128  : 			else {
; 129  : 				if (edgeInfo01->m_face1 != NULL)	;

	cmp	DWORD PTR [eax+8], 0
	jne	SHORT $LN12@BuildStrip

; 130  : 					//Msg("! WARNING: BuildStripifyInfo: > 2 triangles on an edge... uncertain consequences");
; 131  : 				else
; 132  : 					edgeInfo01->m_face1 = faceInfo;

	mov	DWORD PTR [eax+8], edx
	jmp	SHORT $LN12@BuildStrip
$LN299@BuildStrip:

; 43   : 			if (infoIter->m_v0 == v1)

	cmp	ecx, ebx
	je	$LN13@BuildStrip

; 44   : 				return infoIter;
; 45   : 			else
; 46   : 				infoIter = infoIter->m_nextV1;

	mov	eax, DWORD PTR [eax+24]
$LN304@BuildStrip:

; 34   : 	while (infoIter != NULL){

	test	eax, eax
	jne	SHORT $LL297@BuildStrip
$LN524@BuildStrip:
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h

; 80   : 	T* ptr	= (T*)Memory.mem_alloc(sizeof(T));

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	28					; 0000001cH
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z

; 81   : 	return new (ptr) T(p1,p2);

	mov	ecx, eax
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 149  : 				edgeInfo12->m_face0 = faceInfo;

	mov	edx, DWORD PTR $T1[esp+40]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.h

; 55   : 		m_face0    = NULL;

	mov	DWORD PTR [ecx+4], 0

; 56   : 		m_face1    = NULL;
; 57   : 		m_nextV0   = NULL;

	mov	DWORD PTR [ecx+20], 0

; 58   : 		m_nextV1   = NULL;

	mov	DWORD PTR [ecx+24], 0
	mov	DWORD PTR [ecx+12], esi
	mov	DWORD PTR [ecx+16], ebx
	mov	DWORD PTR [ecx+8], 0

; 59   : 		
; 60   : 		// we will appear in 2 lists.  this is a good
; 61   : 		// way to make sure we _delete it the second time
; 62   : 		// we hit it in the edge infos
; 63   : 		m_refCount = 2;    

	mov	DWORD PTR [ecx], 2
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 143  : 				edgeInfo12->m_nextV0 = edgeInfos[v1];

	mov	eax, DWORD PTR [ebp]
	mov	eax, DWORD PTR [eax+esi*4]
	mov	DWORD PTR [ecx+20], eax

; 144  : 				edgeInfo12->m_nextV1 = edgeInfos[v2];

	mov	eax, DWORD PTR [ebp]
	mov	eax, DWORD PTR [eax+ebx*4]
	mov	DWORD PTR [ecx+24], eax

; 145  : 				edgeInfos[v1] = edgeInfo12;

	mov	eax, DWORD PTR [ebp]
	mov	DWORD PTR [eax+esi*4], ecx

; 146  : 				edgeInfos[v2] = edgeInfo12;

	mov	eax, DWORD PTR [ebp]
	mov	DWORD PTR [eax+ebx*4], ecx

; 149  : 				edgeInfo12->m_face0 = faceInfo;

	mov	DWORD PTR [ecx+4], edx
$LN16@BuildStrip:

; 33   : 	NvEdgeInfo *infoIter = edgeInfos[v0];

	mov	eax, DWORD PTR [ebp]
	mov	eax, DWORD PTR [eax+ebx*4]

; 34   : 	while (infoIter != NULL){

	test	eax, eax
	je	SHORT $LN525@BuildStrip
$LL396@BuildStrip:

; 35   : 		if (infoIter->m_v0 == v0){

	mov	ecx, DWORD PTR [eax+12]
	cmp	ecx, ebx
	jne	SHORT $LN398@BuildStrip

; 36   : 			if (infoIter->m_v1 == v1)

	cmp	DWORD PTR [eax+16], edi
	je	$LN17@BuildStrip

; 37   : 				return infoIter;
; 38   : 			else
; 39   : 				infoIter = infoIter->m_nextV0;

	mov	eax, DWORD PTR [eax+20]

; 40   : 		}

	jmp	SHORT $LN403@BuildStrip
$LN13@BuildStrip:

; 150  : 			}
; 151  : 			else {
; 152  : 				if (edgeInfo12->m_face1 != NULL)	;

	cmp	DWORD PTR [eax+8], 0
	jne	SHORT $LN16@BuildStrip

; 153  : 					//Msg("! WARNING: BuildStripifyInfo: > 2 triangles on an edge... uncertain consequences");
; 154  : 				else
; 155  : 					edgeInfo12->m_face1 = faceInfo;

	mov	DWORD PTR [eax+8], edx
	jmp	SHORT $LN16@BuildStrip
$LN398@BuildStrip:

; 43   : 			if (infoIter->m_v0 == v1)

	cmp	ecx, edi
	je	$LN17@BuildStrip

; 44   : 				return infoIter;
; 45   : 			else
; 46   : 				infoIter = infoIter->m_nextV1;

	mov	eax, DWORD PTR [eax+24]
$LN403@BuildStrip:

; 34   : 	while (infoIter != NULL){

	test	eax, eax
	jne	SHORT $LL396@BuildStrip
$LN525@BuildStrip:
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h

; 80   : 	T* ptr	= (T*)Memory.mem_alloc(sizeof(T));

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	28					; 0000001cH
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z

; 81   : 	return new (ptr) T(p1,p2);

	mov	ecx, eax
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.h

; 55   : 		m_face0    = NULL;

	mov	DWORD PTR [ecx+4], 0

; 56   : 		m_face1    = NULL;
; 57   : 		m_nextV0   = NULL;

	mov	DWORD PTR [ecx+20], 0

; 58   : 		m_nextV1   = NULL;

	mov	DWORD PTR [ecx+24], 0
	mov	DWORD PTR [ecx+12], ebx
	mov	DWORD PTR [ecx+16], edi
	mov	DWORD PTR [ecx+8], 0

; 59   : 		
; 60   : 		// we will appear in 2 lists.  this is a good
; 61   : 		// way to make sure we _delete it the second time
; 62   : 		// we hit it in the edge infos
; 63   : 		m_refCount = 2;    

	mov	DWORD PTR [ecx], 2
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 166  : 				edgeInfo20->m_nextV0 = edgeInfos[v2];

	mov	eax, DWORD PTR [ebp]
	mov	eax, DWORD PTR [eax+ebx*4]
	mov	DWORD PTR [ecx+20], eax

; 167  : 				edgeInfo20->m_nextV1 = edgeInfos[v0];

	mov	eax, DWORD PTR [ebp]
	mov	eax, DWORD PTR [eax+edi*4]
	mov	DWORD PTR [ecx+24], eax

; 168  : 				edgeInfos[v2] = edgeInfo20;

	mov	eax, DWORD PTR [ebp]
	mov	DWORD PTR [eax+ebx*4], ecx

; 169  : 				edgeInfos[v0] = edgeInfo20;

	mov	eax, DWORD PTR [ebp]
	mov	DWORD PTR [eax+edi*4], ecx

; 170  : 				
; 171  : 				// set face 0
; 172  : 				edgeInfo20->m_face0 = faceInfo;

	mov	eax, DWORD PTR $T1[esp+40]
	mov	DWORD PTR [ecx+4], eax
$LN5@BuildStrip:

; 98   : 	for (u32 i = 0; i < numTriangles; i++)

	sub	DWORD PTR _numTriangles$1$[esp+40], 1
	mov	ecx, DWORD PTR _index$1$[esp+40]
	mov	esi, DWORD PTR _this$1$[esp+40]
	jne	$LL7@BuildStrip
$LN526@BuildStrip:
	pop	ebp
	pop	ebx
	pop	edi

; 183  : }

	pop	esi
	add	esp, 24					; 00000018H
	ret	8
$LN17@BuildStrip:

; 173  : 			}
; 174  : 			else {
; 175  : 				if (edgeInfo20->m_face1 != NULL)	;

	cmp	DWORD PTR [eax+8], 0
	jne	SHORT $LN5@BuildStrip

; 176  : 					//Msg("! WARNING: BuildStripifyInfo: > 2 triangles on an edge... uncertain consequences");
; 177  : 				else
; 178  : 					edgeInfo20->m_face1 = faceInfo;

	mov	DWORD PTR [eax+8], edx
	jmp	SHORT $LN5@BuildStrip
$LN531@BuildStrip:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1360 :                 _Xlength();

	call	?_Xlength@?$vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@std@@CAXXZ ; std::vector<NvFaceInfo *,xalloc<NvFaceInfo *> >::_Xlength
$LN528@BuildStrip:
	int	3
?BuildStripifyInfo@NvStripifier@@IAEXAAV?$xr_vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@@AAV?$xr_vector@PAVNvEdgeInfo@@V?$xalloc@PAVNvEdgeInfo@@@@@@@Z ENDP ; NvStripifier::BuildStripifyInfo
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
_TEXT	SEGMENT
_i$1$ = -12						; size = 4
tv1210 = -8						; size = 4
$T1 = -4						; size = 4
$T2 = 8							; size = 4
_faceInfos$ = 8						; size = 4
_edgeInfos$ = 12					; size = 4
?FindStartPoint@NvStripifier@@IAEHAAV?$xr_vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@@AAV?$xr_vector@PAVNvEdgeInfo@@V?$xalloc@PAVNvEdgeInfo@@@@@@@Z PROC ; NvStripifier::FindStartPoint
; _this$dead$ = ecx

; 191  : {

	sub	esp, 12					; 0000000cH
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	eax, DWORD PTR _faceInfos$[esp+8]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 192  : 	for(int i = 0; i < faceInfos.size(); i++)

	xor	ecx, ecx
	push	ebx
	push	ebp
	push	esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR [eax+4]
	sub	eax, edx
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 192  : 	for(int i = 0; i < faceInfos.size(); i++)

	mov	DWORD PTR _i$1$[esp+24], ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	sar	eax, 2
	mov	DWORD PTR $T1[esp+24], edx
	mov	DWORD PTR tv1210[esp+24], eax
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 191  : {

	push	edi

; 192  : 	for(int i = 0; i < faceInfos.size(); i++)

	test	eax, eax
	je	$LN3@FindStartP
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1463 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));

	mov	eax, DWORD PTR _edgeInfos$[esp+24]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR $T2[esp+24], eax
$LL4@FindStartP:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 196  : 		if(FindOtherFace(edgeInfos, faceInfos[i]->m_v0, faceInfos[i]->m_v1, faceInfos[i]) == NULL)

	mov	ebp, DWORD PTR [edx+ecx*4]
	mov	edi, DWORD PTR [ebp]
	mov	edx, DWORD PTR [ebp+4]

; 33   : 	NvEdgeInfo *infoIter = edgeInfos[v0];

	mov	eax, DWORD PTR [eax+edi*4]

; 34   : 	while (infoIter != NULL){

	test	eax, eax
	je	SHORT $LN71@FindStartP
$LL70@FindStartP:

; 35   : 		if (infoIter->m_v0 == v0){

	mov	ecx, DWORD PTR [eax+12]
	cmp	ecx, edi
	jne	SHORT $LN72@FindStartP

; 36   : 			if (infoIter->m_v1 == v1)

	cmp	DWORD PTR [eax+16], edx
	je	SHORT $LN69@FindStartP

; 37   : 				return infoIter;
; 38   : 			else
; 39   : 				infoIter = infoIter->m_nextV0;

	mov	eax, DWORD PTR [eax+20]

; 40   : 		}

	jmp	SHORT $LN77@FindStartP
$LN72@FindStartP:

; 41   : 		else {
; 42   : 			assert(infoIter->m_v1 == v0);
; 43   : 			if (infoIter->m_v0 == v1)

	cmp	ecx, edx
	je	SHORT $LN69@FindStartP

; 44   : 				return infoIter;
; 45   : 			else
; 46   : 				infoIter = infoIter->m_nextV1;

	mov	eax, DWORD PTR [eax+24]
$LN77@FindStartP:

; 34   : 	while (infoIter != NULL){

	test	eax, eax
	jne	SHORT $LL70@FindStartP
$LN71@FindStartP:

; 47   : 		}
; 48   : 	}
; 49   : 	return NULL;

	xor	eax, eax
$LN69@FindStartP:

; 62   : 	return (edgeInfo->m_face0 == faceInfo ? edgeInfo->m_face1 : edgeInfo->m_face0);

	mov	ecx, DWORD PTR [eax+4]
	cmp	ecx, ebp
	jne	SHORT $LN67@FindStartP
	mov	ecx, DWORD PTR [eax+8]
$LN67@FindStartP:

; 33   : 	NvEdgeInfo *infoIter = edgeInfos[v0];

	mov	eax, DWORD PTR $T2[esp+24]

; 197  : 			ctr++;
; 198  : 		if(FindOtherFace(edgeInfos, faceInfos[i]->m_v1, faceInfos[i]->m_v2, faceInfos[i]) == NULL)

	xor	ebx, ebx
	mov	esi, DWORD PTR [ebp+8]
	test	ecx, ecx
	sete	bl

; 33   : 	NvEdgeInfo *infoIter = edgeInfos[v0];

	mov	eax, DWORD PTR [eax+edx*4]

; 34   : 	while (infoIter != NULL){

	test	eax, eax
	je	SHORT $LN153@FindStartP
$LL152@FindStartP:

; 35   : 		if (infoIter->m_v0 == v0){

	mov	ecx, DWORD PTR [eax+12]
	cmp	ecx, edx
	jne	SHORT $LN154@FindStartP

; 36   : 			if (infoIter->m_v1 == v1)

	cmp	DWORD PTR [eax+16], esi
	je	SHORT $LN151@FindStartP

; 37   : 				return infoIter;
; 38   : 			else
; 39   : 				infoIter = infoIter->m_nextV0;

	mov	eax, DWORD PTR [eax+20]

; 40   : 		}

	jmp	SHORT $LN159@FindStartP
$LN154@FindStartP:

; 41   : 		else {
; 42   : 			assert(infoIter->m_v1 == v0);
; 43   : 			if (infoIter->m_v0 == v1)

	cmp	ecx, esi
	je	SHORT $LN151@FindStartP

; 44   : 				return infoIter;
; 45   : 			else
; 46   : 				infoIter = infoIter->m_nextV1;

	mov	eax, DWORD PTR [eax+24]
$LN159@FindStartP:

; 34   : 	while (infoIter != NULL){

	test	eax, eax
	jne	SHORT $LL152@FindStartP
$LN153@FindStartP:

; 47   : 		}
; 48   : 	}
; 49   : 	return NULL;

	xor	eax, eax
$LN151@FindStartP:

; 62   : 	return (edgeInfo->m_face0 == faceInfo ? edgeInfo->m_face1 : edgeInfo->m_face0);

	mov	ecx, DWORD PTR [eax+4]
	cmp	ecx, ebp
	jne	SHORT $LN149@FindStartP
	mov	ecx, DWORD PTR [eax+8]
$LN149@FindStartP:

; 33   : 	NvEdgeInfo *infoIter = edgeInfos[v0];

	mov	eax, DWORD PTR $T2[esp+24]

; 199  : 			ctr++;
; 200  : 		if(FindOtherFace(edgeInfos, faceInfos[i]->m_v2, faceInfos[i]->m_v0, faceInfos[i]) == NULL)

	lea	edx, DWORD PTR [ebx+1]
	test	ecx, ecx
	cmovne	edx, ebx

; 33   : 	NvEdgeInfo *infoIter = edgeInfos[v0];

	mov	eax, DWORD PTR [eax+esi*4]

; 34   : 	while (infoIter != NULL){

	test	eax, eax
	je	SHORT $LN235@FindStartP
	npad	3
$LL234@FindStartP:

; 35   : 		if (infoIter->m_v0 == v0){

	mov	ecx, DWORD PTR [eax+12]
	cmp	ecx, esi
	jne	SHORT $LN236@FindStartP

; 36   : 			if (infoIter->m_v1 == v1)

	cmp	DWORD PTR [eax+16], edi
	je	SHORT $LN233@FindStartP

; 37   : 				return infoIter;
; 38   : 			else
; 39   : 				infoIter = infoIter->m_nextV0;

	mov	eax, DWORD PTR [eax+20]

; 40   : 		}

	jmp	SHORT $LN241@FindStartP
$LN236@FindStartP:

; 41   : 		else {
; 42   : 			assert(infoIter->m_v1 == v0);
; 43   : 			if (infoIter->m_v0 == v1)

	cmp	ecx, edi
	je	SHORT $LN233@FindStartP

; 44   : 				return infoIter;
; 45   : 			else
; 46   : 				infoIter = infoIter->m_nextV1;

	mov	eax, DWORD PTR [eax+24]
$LN241@FindStartP:

; 34   : 	while (infoIter != NULL){

	test	eax, eax
	jne	SHORT $LL234@FindStartP
$LN235@FindStartP:

; 47   : 		}
; 48   : 	}
; 49   : 	return NULL;

	xor	eax, eax
$LN233@FindStartP:

; 62   : 	return (edgeInfo->m_face0 == faceInfo ? edgeInfo->m_face1 : edgeInfo->m_face0);

	mov	ecx, DWORD PTR [eax+4]
	cmp	ecx, ebp
	jne	SHORT $LN231@FindStartP
	mov	ecx, DWORD PTR [eax+8]
$LN231@FindStartP:

; 201  : 			ctr++;
; 202  : 		if(ctr > 1)

	test	ecx, ecx
	lea	eax, DWORD PTR [edx+1]
	cmovne	eax, edx
	cmp	eax, 1
	ja	SHORT $LN270@FindStartP

; 192  : 	for(int i = 0; i < faceInfos.size(); i++)

	mov	ecx, DWORD PTR _i$1$[esp+28]
	mov	eax, DWORD PTR $T2[esp+24]
	inc	ecx
	mov	edx, DWORD PTR $T1[esp+28]
	mov	DWORD PTR _i$1$[esp+28], ecx
	cmp	ecx, DWORD PTR tv1210[esp+28]
	jb	$LL4@FindStartP
$LN3@FindStartP:
	pop	edi

; 204  : 	}
; 205  : 	return -1;
; 206  : }

	pop	esi
	pop	ebp
	or	eax, -1
	pop	ebx
	add	esp, 12					; 0000000cH
	ret	8
$LN270@FindStartP:

; 203  : 			return i;

	mov	eax, DWORD PTR _i$1$[esp+28]
	pop	edi

; 204  : 	}
; 205  : 	return -1;
; 206  : }

	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 12					; 0000000cH
	ret	8
?FindStartPoint@NvStripifier@@IAEHAAV?$xr_vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@@AAV?$xr_vector@PAVNvEdgeInfo@@V?$xalloc@PAVNvEdgeInfo@@@@@@@Z ENDP ; NvStripifier::FindStartPoint
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
_TEXT	SEGMENT
_faceInfos$ = 8						; size = 4
_edgeInfos$ = 12					; size = 4
?FindGoodResetPoint@NvStripifier@@IAEPAVNvFaceInfo@@AAV?$xr_vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@@AAV?$xr_vector@PAVNvEdgeInfo@@V?$xalloc@PAVNvEdgeInfo@@@@@@@Z PROC ; NvStripifier::FindGoodResetPoint
; _this$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	eax, DWORD PTR _faceInfos$[esp-4]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 226  : 		if(bFirstTimeResetPoint)

	movss	xmm3, DWORD PTR __real@3f800000
	push	ebx
	push	ebp
	push	esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	esi, DWORD PTR [eax]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 216  : NvFaceInfo* NvStripifier::FindGoodResetPoint(NvFaceInfoVec &faceInfos, NvEdgeInfoVec &edgeInfos){

	mov	ebx, ecx
	push	edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	edi, DWORD PTR [eax+4]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 220  : 	NvFaceInfo *result = NULL;

	xor	ebp, ebp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	sub	edi, esi
	sar	edi, 2
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 226  : 		if(bFirstTimeResetPoint)

	cmp	BYTE PTR [ebx+24], 0
	cvtsi2ss xmm2, edi
	je	SHORT $LN6@FindGoodRe

; 227  : 		{
; 228  : 			//first time, find a face with few neighbors (look for an edge of the mesh)
; 229  : 			startPoint = FindStartPoint(faceInfos, edgeInfos);

	push	DWORD PTR _edgeInfos$[esp+12]
	push	eax
	call	?FindStartPoint@NvStripifier@@IAEHAAV?$xr_vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@@AAV?$xr_vector@PAVNvEdgeInfo@@V?$xalloc@PAVNvEdgeInfo@@@@@@@Z ; NvStripifier::FindStartPoint

; 230  : 			bFirstTimeResetPoint = false;

	mov	esi, DWORD PTR _faceInfos$[esp+12]
	mov	edx, eax
	movss	xmm1, DWORD PTR [ebx+20]
	mov	BYTE PTR [ebx+24], 0
	mov	esi, DWORD PTR [esi]

; 231  : 		}

	jmp	SHORT $LN57@FindGoodRe
$LN6@FindGoodRe:

; 232  : 		else
; 233  : 			startPoint = (int)(((float) numFaces - 1) * meshJump);

	movss	xmm1, DWORD PTR [ebx+20]
	movaps	xmm0, xmm2
	subss	xmm0, xmm3
	mulss	xmm0, xmm1
	cvttss2si edx, xmm0
$LN57@FindGoodRe:

; 234  : 		
; 235  : 		if(startPoint == -1)

	movaps	xmm0, xmm1
	cmp	edx, -1
	jne	SHORT $LN8@FindGoodRe

; 236  : 			startPoint = (int)(((float) numFaces - 1) * meshJump);

	subss	xmm2, xmm3
	mulss	xmm2, xmm0
	cvttss2si edx, xmm2
$LN8@FindGoodRe:

; 237  : 		
; 238  : 		int i = startPoint;
; 239  : 		do {
; 240  : 			
; 241  : 			// if this guy isn't visited, try him
; 242  : 			if (faceInfos[i]->m_stripId < 0){

	mov	eax, DWORD PTR [esi+edx*4]
	mov	ecx, edx
	cmp	DWORD PTR [eax+12], ebp
	jl	SHORT $LN52@FindGoodRe
$LL4@FindGoodRe:

; 244  : 				break;
; 245  : 			}
; 246  : 			
; 247  : 			// update the index and clamp to 0-(numFaces-1)
; 248  : 			if (++i >= numFaces)

	lea	eax, DWORD PTR [ecx+1]

; 249  : 				i = 0;
; 250  : 			
; 251  : 		} while (i != startPoint);

	xor	ecx, ecx
	cmp	eax, edi
	cmovl	ecx, eax
	cmp	ecx, edx
	je	SHORT $LN3@FindGoodRe

; 237  : 		
; 238  : 		int i = startPoint;
; 239  : 		do {
; 240  : 			
; 241  : 			// if this guy isn't visited, try him
; 242  : 			if (faceInfos[i]->m_stripId < 0){

	mov	eax, DWORD PTR [esi+ecx*4]
	cmp	DWORD PTR [eax+12], ebp
	jge	SHORT $LL4@FindGoodRe
$LN52@FindGoodRe:

; 243  : 				result = faceInfos[i];

	mov	ebp, DWORD PTR [esi+ecx*4]
$LN3@FindGoodRe:

; 252  : 		
; 253  : 		// update the meshJump
; 254  : 		meshJump += 0.1f;

	addss	xmm1, DWORD PTR __real@3dcccccd

; 255  : 		if (meshJump > 1.0f)

	mov	eax, ebp
	comiss	xmm1, xmm3
	movss	DWORD PTR [ebx+20], xmm1
	jbe	SHORT $LN11@FindGoodRe

; 256  : 			meshJump = .05f;

	mov	DWORD PTR [ebx+20], 1028443341		; 3d4ccccdH
$LN11@FindGoodRe:
	pop	edi

; 257  : 	}
; 258  : 	
; 259  : 	// return the best face we found
; 260  : 	return result;
; 261  : }

	pop	esi
	pop	ebp
	pop	ebx
	ret	8
?FindGoodResetPoint@NvStripifier@@IAEPAVNvFaceInfo@@AAV?$xr_vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@@AAV?$xr_vector@PAVNvEdgeInfo@@V?$xalloc@PAVNvEdgeInfo@@@@@@@Z ENDP ; NvStripifier::FindGoodResetPoint
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
_TEXT	SEGMENT
?GetUniqueVertexInB@NvStripifier@@SAHPAVNvFaceInfo@@0@Z PROC ; NvStripifier::GetUniqueVertexInB
; _faceA$ = ecx
; _faceB$ = edx

; 270  : 	
; 271  : 	int facev0 = faceB->m_v0;

	mov	eax, DWORD PTR [edx]
	push	esi

; 272  : 	if (facev0 != faceA->m_v0 &&
; 273  : 		facev0 != faceA->m_v1 &&

	mov	esi, DWORD PTR [ecx]
	cmp	eax, esi
	je	SHORT $LN2@GetUniqueV
	cmp	eax, DWORD PTR [ecx+4]
	je	SHORT $LN2@GetUniqueV
	cmp	eax, DWORD PTR [ecx+8]
	jne	SHORT $LN1@GetUniqueV
$LN2@GetUniqueV:

; 274  : 		facev0 != faceA->m_v2)
; 275  : 		return facev0;
; 276  : 	
; 277  : 	int facev1 = faceB->m_v1;

	mov	eax, DWORD PTR [edx+4]

; 278  : 	if (facev1 != faceA->m_v0 &&
; 279  : 		facev1 != faceA->m_v1 &&

	cmp	eax, esi
	je	SHORT $LN3@GetUniqueV
	cmp	eax, DWORD PTR [ecx+4]
	je	SHORT $LN3@GetUniqueV
	cmp	eax, DWORD PTR [ecx+8]
	jne	SHORT $LN1@GetUniqueV
$LN3@GetUniqueV:

; 280  : 		facev1 != faceA->m_v2)
; 281  : 		return facev1;
; 282  : 	
; 283  : 	int facev2 = faceB->m_v2;

	mov	eax, DWORD PTR [edx+8]

; 284  : 	if (facev2 != faceA->m_v0 &&
; 285  : 		facev2 != faceA->m_v1 &&

	cmp	eax, esi
	je	SHORT $LN4@GetUniqueV
	cmp	eax, DWORD PTR [ecx+4]
	je	SHORT $LN4@GetUniqueV
	cmp	eax, DWORD PTR [ecx+8]
	jne	SHORT $LN1@GetUniqueV
$LN4@GetUniqueV:

; 286  : 		facev2 != faceA->m_v2)
; 287  : 		return facev2;
; 288  : 	
; 289  : 	// nothing is different
; 290  : 	return -1;

	or	eax, -1
$LN1@GetUniqueV:
	pop	esi

; 291  : }

	ret	0
?GetUniqueVertexInB@NvStripifier@@SAHPAVNvFaceInfo@@0@Z ENDP ; NvStripifier::GetUniqueVertexInB
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
_TEXT	SEGMENT
?GetSharedVertex@NvStripifier@@SAHPAVNvFaceInfo@@0@Z PROC ; NvStripifier::GetSharedVertex
; _faceA$ = ecx
; _faceB$ = edx

; 300  : 	
; 301  : 	int facev0 = faceB->m_v0;

	mov	eax, DWORD PTR [edx]
	push	esi
	push	edi

; 302  : 	if (facev0 == faceA->m_v0 ||
; 303  : 		facev0 == faceA->m_v1 ||

	mov	edi, DWORD PTR [ecx]
	cmp	eax, edi
	je	SHORT $LN1@GetSharedV
	mov	esi, DWORD PTR [ecx+4]
	cmp	eax, esi
	je	SHORT $LN1@GetSharedV
	mov	ecx, DWORD PTR [ecx+8]
	cmp	eax, ecx
	je	SHORT $LN1@GetSharedV

; 304  : 		facev0 == faceA->m_v2)
; 305  : 		return facev0;
; 306  : 	
; 307  : 	int facev1 = faceB->m_v1;

	mov	eax, DWORD PTR [edx+4]

; 308  : 	if (facev1 == faceA->m_v0 ||
; 309  : 		facev1 == faceA->m_v1 ||

	cmp	eax, edi
	je	SHORT $LN1@GetSharedV
	cmp	eax, esi
	je	SHORT $LN1@GetSharedV
	cmp	eax, ecx
	je	SHORT $LN1@GetSharedV

; 310  : 		facev1 == faceA->m_v2)
; 311  : 		return facev1;
; 312  : 	
; 313  : 	int facev2 = faceB->m_v2;

	mov	eax, DWORD PTR [edx+8]

; 314  : 	if (facev2 == faceA->m_v0 ||
; 315  : 		facev2 == faceA->m_v1 ||

	cmp	eax, edi
	je	SHORT $LN1@GetSharedV
	cmp	eax, esi
	je	SHORT $LN1@GetSharedV
	cmp	eax, ecx
	je	SHORT $LN1@GetSharedV

; 316  : 		facev2 == faceA->m_v2)
; 317  : 		return facev2;
; 318  : 	
; 319  : 	// nothing is shared
; 320  : 	return -1;

	or	eax, -1
$LN1@GetSharedV:
	pop	edi

; 321  : }

	pop	esi
	ret	0
?GetSharedVertex@NvStripifier@@SAHPAVNvFaceInfo@@0@Z ENDP ; NvStripifier::GetSharedVertex
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
;	COMDAT ?GetNextIndex@NvStripifier@@KAHABV?$xr_vector@GV?$xalloc@G@@@@PAVNvFaceInfo@@@Z
_TEXT	SEGMENT
?GetNextIndex@NvStripifier@@KAHABV?$xr_vector@GV?$xalloc@G@@@@PAVNvFaceInfo@@@Z PROC ; NvStripifier::GetNextIndex, COMDAT
; _indices$dead$ = ecx
; _face$ = edx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	eax, DWORD PTR ?scratchIndices@?1??Build@NvStripInfo@@QAEXAAV?$xr_vector@PAVNvEdgeInfo@@V?$xalloc@PAVNvEdgeInfo@@@@@@AAV?$xr_vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@@@Z@4V?$xr_vector@GV?$xalloc@G@@@@A
	mov	ecx, DWORD PTR ?scratchIndices@?1??Build@NvStripInfo@@QAEXAAV?$xr_vector@PAVNvEdgeInfo@@V?$xalloc@PAVNvEdgeInfo@@@@@@AAV?$xr_vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@@@Z@4V?$xr_vector@GV?$xalloc@G@@@@A+4
	sub	ecx, eax
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 329  : IC int NvStripifier::GetNextIndex(const WordVec &indices, NvFaceInfo *face){

	push	ebx

; 338  : 	int fv1 = face->m_v1;

	mov	ebx, DWORD PTR [edx+4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	sar	ecx, 1
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 329  : IC int NvStripifier::GetNextIndex(const WordVec &indices, NvFaceInfo *face){

	push	ebp

; 330  : 	
; 331  : 	int numIndices = indices.size();
; 332  : 	assert(numIndices >= 2);
; 333  : 	
; 334  : 	int v0  = indices[numIndices-2];
; 335  : 	int v1  = indices[numIndices-1];
; 336  : 	
; 337  : 	int fv0 = face->m_v0;

	mov	ebp, DWORD PTR [edx]
	push	esi
	movzx	esi, WORD PTR [eax+ecx*2-4]
	movzx	eax, WORD PTR [eax+ecx*2-2]
	push	edi

; 339  : 	int fv2 = face->m_v2;

	mov	edi, DWORD PTR [edx+8]

; 340  : 	
; 341  : 	if (fv0 != v0 && fv0 != v1){

	cmp	ebp, esi
	je	SHORT $LN2@GetNextInd
	cmp	ebp, eax
	je	SHORT $LN2@GetNextInd

; 342  : 		if ((fv1 != v0 && fv1 != v1) || (fv2 != v0 && fv2 != v1)){

	cmp	ebx, esi
	je	SHORT $LN5@GetNextInd
	cmp	ebx, eax
	jne	SHORT $LN4@GetNextInd
$LN5@GetNextInd:
	cmp	edi, esi
	je	SHORT $LN3@GetNextInd
	cmp	edi, eax
	je	SHORT $LN3@GetNextInd
$LN4@GetNextInd:

; 343  : 			Msg("! WARNING: GetNextIndex: Triangle doesn't have all of its vertices");

	mov	esi, DWORD PTR __imp_?Msg@@YAXPBDZZ
	push	OFFSET ??_C@_0ED@PGPLFOBO@?$CB?5WARNING?3?5GetNextIndex?3?5Triang@
	call	esi

; 344  : 			Msg("! WARNING: GetNextIndex: Duplicate triangle probably got us derailed");

	push	OFFSET ??_C@_0EF@NPIJGPAE@?$CB?5WARNING?3?5GetNextIndex?3?5Duplic@
	call	esi
	add	esp, 8
$LN3@GetNextInd:

; 366  : }

	pop	edi
	pop	esi
	mov	eax, ebp
	pop	ebp
	pop	ebx
	ret	0
$LN2@GetNextInd:

; 345  : 		}
; 346  : 		return fv0;
; 347  : 	}
; 348  : 	if (fv1 != v0 && fv1 != v1){

	cmp	ebx, esi
	je	SHORT $LN6@GetNextInd
	cmp	ebx, eax
	je	SHORT $LN6@GetNextInd

; 349  : 		if ((fv0 != v0 && fv0 != v1) || (fv2 != v0 && fv2 != v1)){

	cmp	ebp, esi
	je	SHORT $LN9@GetNextInd
	cmp	ebp, eax
	jne	SHORT $LN8@GetNextInd
$LN9@GetNextInd:
	cmp	edi, esi
	je	SHORT $LN7@GetNextInd
	cmp	edi, eax
	je	SHORT $LN7@GetNextInd
$LN8@GetNextInd:

; 350  : 			Msg("! WARNING: GetNextIndex: Triangle doesn't have all of its vertices");

	mov	esi, DWORD PTR __imp_?Msg@@YAXPBDZZ
	push	OFFSET ??_C@_0ED@PGPLFOBO@?$CB?5WARNING?3?5GetNextIndex?3?5Triang@
	call	esi

; 351  : 			Msg("! WARNING: GetNextIndex: Duplicate triangle probably got us derailed");

	push	OFFSET ??_C@_0EF@NPIJGPAE@?$CB?5WARNING?3?5GetNextIndex?3?5Duplic@
	call	esi
	add	esp, 8
$LN7@GetNextInd:

; 366  : }

	pop	edi
	pop	esi
	pop	ebp
	mov	eax, ebx
	pop	ebx
	ret	0
$LN6@GetNextInd:

; 352  : 		}
; 353  : 		return fv1;
; 354  : 	}
; 355  : 	if (fv2 != v0 && fv2 != v1){

	cmp	edi, esi
	je	SHORT $LN10@GetNextInd
	cmp	edi, eax
	je	SHORT $LN10@GetNextInd

; 356  : 		if ((fv0 != v0 && fv0 != v1) || (fv1 != v0 && fv1 != v1)){

	cmp	ebp, esi
	je	SHORT $LN13@GetNextInd
	cmp	ebp, eax
	jne	SHORT $LN12@GetNextInd
$LN13@GetNextInd:
	cmp	ebx, esi
	je	SHORT $LN11@GetNextInd
	cmp	ebx, eax
	je	SHORT $LN11@GetNextInd
$LN12@GetNextInd:

; 357  : 			Msg("! WARNING: GetNextIndex: Triangle doesn't have all of its vertices");

	mov	esi, DWORD PTR __imp_?Msg@@YAXPBDZZ
	push	OFFSET ??_C@_0ED@PGPLFOBO@?$CB?5WARNING?3?5GetNextIndex?3?5Triang@
	call	esi

; 358  : 			Msg("! WARNING: GetNextIndex: Duplicate triangle probably got us derailed");

	push	OFFSET ??_C@_0EF@NPIJGPAE@?$CB?5WARNING?3?5GetNextIndex?3?5Duplic@
	call	esi
	add	esp, 8
$LN11@GetNextInd:

; 359  : 		}
; 360  : 		return fv2;

	mov	eax, edi
	pop	edi

; 366  : }

	pop	esi
	pop	ebp
	pop	ebx
	ret	0
$LN10@GetNextInd:

; 361  : 	}
; 362  : 	
; 363  : 	// shouldn't get here
; 364  : 	Msg("! WARNING: GetNextIndex: Duplicate triangle sent");

	push	OFFSET ??_C@_0DB@JOONJBKI@?$CB?5WARNING?3?5GetNextIndex?3?5Duplic@
	call	DWORD PTR __imp_?Msg@@YAXPBDZZ
	add	esp, 4

; 365  : 	return -1;

	or	eax, -1
	pop	edi

; 366  : }

	pop	esi
	pop	ebp
	pop	ebx
	ret	0
?GetNextIndex@NvStripifier@@KAHABV?$xr_vector@GV?$xalloc@G@@@@PAVNvFaceInfo@@@Z ENDP ; NvStripifier::GetNextIndex
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
;	COMDAT ?IsMarked@NvStripInfo@@QAE_NPAVNvFaceInfo@@@Z
_TEXT	SEGMENT
_faceInfo$ = 8						; size = 4
?IsMarked@NvStripInfo@@QAE_NPAVNvFaceInfo@@@Z PROC	; NvStripInfo::IsMarked, COMDAT
; _this$ = ecx

; 377  : 	return (faceInfo->m_stripId >= 0) || (IsExperiment() && faceInfo->m_experimentId == m_experimentId);

	mov	edx, DWORD PTR _faceInfo$[esp-4]
	cmp	DWORD PTR [edx+12], 0
	jge	SHORT $LN4@IsMarked
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.h

; 131  : 	inline bool IsExperiment () const { return m_experimentId >= 0; }

	mov	eax, DWORD PTR [ecx+28]
	test	eax, eax
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 377  : 	return (faceInfo->m_stripId >= 0) || (IsExperiment() && faceInfo->m_experimentId == m_experimentId);

	js	SHORT $LN3@IsMarked
	cmp	DWORD PTR [edx+20], eax
	je	SHORT $LN4@IsMarked
$LN3@IsMarked:
	xor	al, al

; 378  : }

	ret	4
$LN4@IsMarked:

; 377  : 	return (faceInfo->m_stripId >= 0) || (IsExperiment() && faceInfo->m_experimentId == m_experimentId);

	mov	al, 1

; 378  : }

	ret	4
?IsMarked@NvStripInfo@@QAE_NPAVNvFaceInfo@@@Z ENDP	; NvStripInfo::IsMarked
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
;	COMDAT ?MarkTriangle@NvStripInfo@@QAEXPAVNvFaceInfo@@@Z
_TEXT	SEGMENT
_faceInfo$ = 8						; size = 4
?MarkTriangle@NvStripInfo@@QAEXPAVNvFaceInfo@@@Z PROC	; NvStripInfo::MarkTriangle, COMDAT
; _this$ = ecx
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.h

; 131  : 	inline bool IsExperiment () const { return m_experimentId >= 0; }

	mov	eax, DWORD PTR [ecx+28]
	mov	edx, DWORD PTR _faceInfo$[esp-4]
	test	eax, eax
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 388  : 	if (IsExperiment()){

	js	SHORT $LN2@MarkTriang

; 389  : 		faceInfo->m_experimentId = m_experimentId;

	mov	DWORD PTR [edx+20], eax

; 390  : 		faceInfo->m_testStripId  = m_stripId;

	mov	eax, DWORD PTR [ecx+24]
	mov	DWORD PTR [edx+16], eax

; 396  : 	}
; 397  : }

	ret	4
$LN2@MarkTriang:

; 391  :     }
; 392  : 	else{
; 393  : 		assert(faceInfo->m_stripId == -1);
; 394  : 		faceInfo->m_experimentId = -1;

	mov	DWORD PTR [edx+20], -1

; 395  : 		faceInfo->m_stripId      = m_stripId;

	mov	eax, DWORD PTR [ecx+24]
	mov	DWORD PTR [edx+12], eax

; 396  : 	}
; 397  : }

	ret	4
?MarkTriangle@NvStripInfo@@QAEXPAVNvFaceInfo@@@Z ENDP	; NvStripInfo::MarkTriangle
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
_TEXT	SEGMENT
_bv0$1$ = -1						; size = 1
_faceVec$ = 8						; size = 4
_face$ = 12						; size = 4
?Unique@NvStripInfo@@QAE_NAAV?$xr_vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@@PAVNvFaceInfo@@@Z PROC ; NvStripInfo::Unique
; _this$dead$ = ecx

; 401  : {

	push	ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	eax, DWORD PTR _faceVec$[esp]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 403  : 	bv0 = bv1 = bv2 = false;

	xor	cl, cl
	push	ebx
	push	ebp
	push	esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	ebp, DWORD PTR [eax+4]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 403  : 	bv0 = bv1 = bv2 = false;

	xor	bl, bl
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	edx, DWORD PTR [eax]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 403  : 	bv0 = bv1 = bv2 = false;

	xor	bh, bh
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	sub	ebp, edx
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 403  : 	bv0 = bv1 = bv2 = false;

	mov	BYTE PTR _bv0$1$[esp+16], cl
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	sar	ebp, 2
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 405  : 	for(int i = 0; i < faceVec.size(); i++)

	xor	esi, esi
	push	edi
	test	ebp, ebp
	je	SHORT $LN178@Unique

; 416  : 		{
; 417  : 			if( (faceVec[i]->m_v0 == face->m_v1) || 
; 418  : 				(faceVec[i]->m_v1 == face->m_v1) ||

	mov	edi, DWORD PTR _face$[esp+16]
$LL4@Unique:

; 406  : 	{
; 407  : 		if(!bv0)

	test	cl, cl
	jne	SHORT $LN6@Unique

; 408  : 		{
; 409  : 			if( (faceVec[i]->m_v0 == face->m_v0) || 
; 410  : 				(faceVec[i]->m_v1 == face->m_v0) ||

	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [edi]
	cmp	DWORD PTR [eax], ecx
	je	SHORT $LN7@Unique
	cmp	DWORD PTR [eax+4], ecx
	je	SHORT $LN7@Unique
	cmp	DWORD PTR [eax+8], ecx
	jne	SHORT $LN6@Unique
$LN7@Unique:

; 411  : 				(faceVec[i]->m_v2 == face->m_v0) )
; 412  : 				bv0 = true;

	mov	BYTE PTR _bv0$1$[esp+20], 1
$LN6@Unique:

; 413  : 		}
; 414  : 
; 415  : 		if(!bv1)

	test	bh, bh
	jne	SHORT $LN9@Unique

; 416  : 		{
; 417  : 			if( (faceVec[i]->m_v0 == face->m_v1) || 
; 418  : 				(faceVec[i]->m_v1 == face->m_v1) ||

	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [edi+4]
	cmp	DWORD PTR [eax], ecx
	je	SHORT $LN10@Unique
	cmp	DWORD PTR [eax+4], ecx
	je	SHORT $LN10@Unique
	cmp	DWORD PTR [eax+8], ecx
	jne	SHORT $LN9@Unique
$LN10@Unique:

; 419  : 				(faceVec[i]->m_v2 == face->m_v1) )
; 420  : 				bv1 = true;

	mov	bh, 1
$LN9@Unique:

; 421  : 		}
; 422  : 
; 423  : 		if(!bv2)

	test	bl, bl
	jne	SHORT $LN12@Unique

; 424  : 		{
; 425  : 			if( (faceVec[i]->m_v0 == face->m_v2) || 
; 426  : 				(faceVec[i]->m_v1 == face->m_v2) ||

	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [edi+8]
	cmp	DWORD PTR [eax], ecx
	je	SHORT $LN13@Unique
	cmp	DWORD PTR [eax+4], ecx
	je	SHORT $LN13@Unique
	cmp	DWORD PTR [eax+8], ecx
	jne	SHORT $LN12@Unique
$LN13@Unique:

; 427  : 				(faceVec[i]->m_v2 == face->m_v2) )
; 428  : 				bv2 = true;

	mov	bl, 1
$LN12@Unique:

; 429  : 		}
; 430  : 
; 431  : 		//the face is not unique, all it's vertices exist in the face vector3
; 432  : 		if(bv0 && bv1 && bv2)

	mov	cl, BYTE PTR _bv0$1$[esp+20]
	test	cl, cl
	je	SHORT $LN2@Unique
	test	bh, bh
	je	SHORT $LN2@Unique
	test	bl, bl
	jne	SHORT $LN174@Unique
$LN2@Unique:

; 405  : 	for(int i = 0; i < faceVec.size(); i++)

	inc	esi
	add	edx, 4
	cmp	esi, ebp
	jb	SHORT $LL4@Unique
$LN178@Unique:
	pop	edi

; 433  : 			return false;
; 434  : 	}
; 435  : 	
; 436  : 	//if we get out here, it's unique
; 437  : 	return true;
; 438  : }

	pop	esi
	pop	ebp
	mov	al, 1
	pop	ebx
	pop	ecx
	ret	8
$LN174@Unique:
	pop	edi
	pop	esi
	pop	ebp
	xor	al, al
	pop	ebx
	pop	ecx
	ret	8
?Unique@NvStripInfo@@QAE_NAAV?$xr_vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@@PAVNvFaceInfo@@@Z ENDP ; NvStripInfo::Unique
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
_TEXT	SEGMENT
_numFaces$1$ = -80					; size = 4
_nv1$2$ = -76						; size = 4
$T1 = -72						; size = 2
$T2 = -72						; size = 2
$T3 = -72						; size = 2
$T4 = -72						; size = 2
_nextFace$ = -72					; size = 4
_this$1$ = -68						; size = 4
_i$1$ = -64						; size = 4
_v1$1$ = -60						; size = 4
_nv0$1$ = -56						; size = 4
tv3192 = -52						; size = 4
$T5 = -52						; size = 2
$T6 = -48						; size = 2
tv3191 = -48						; size = 4
_nv0$2$ = -44						; size = 4
$T7 = -44						; size = 2
tv3190 = -44						; size = 4
$T8 = -40						; size = 2
tv3204 = -40						; size = 4
_tempAllFaces$ = -36					; size = 12
_forwardFaces$ = -24					; size = 12
_backwardFaces$ = -12					; size = 12
_edgeInfos$ = 8						; size = 4
_faceInfos$dead$ = 12					; size = 4
?Build@NvStripInfo@@QAEXAAV?$xr_vector@PAVNvEdgeInfo@@V?$xalloc@PAVNvEdgeInfo@@@@@@AAV?$xr_vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@@@Z PROC ; NvStripInfo::Build
; _this$ = ecx

; 446  : void NvStripInfo::Build(NvEdgeInfoVec &edgeInfos, NvFaceInfoVec &faceInfos){

	sub	esp, 80					; 00000050H

; 447  : 	
; 448  : 	// used in building the strips forward and backward
; 449  : 	static WordVec scratchIndices;

	mov	eax, DWORD PTR fs:__tls_array
	mov	edx, DWORD PTR __tls_index
	push	ebx
	push	ebp
	push	esi
	mov	edx, DWORD PTR [eax+edx*4]
	mov	esi, ecx
	mov	eax, DWORD PTR ?$TSS0@?1??Build@NvStripInfo@@QAEXAAV?$xr_vector@PAVNvEdgeInfo@@V?$xalloc@PAVNvEdgeInfo@@@@@@AAV?$xr_vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@@@Z@4HA
	mov	DWORD PTR _this$1$[esp+92], esi
	cmp	eax, DWORD PTR __Init_thread_epoch[edx]
	jg	$LN604@Build
$LN2@Build:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1250 :         const auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);

	mov	edx, DWORD PTR ?scratchIndices@?1??Build@NvStripInfo@@QAEXAAV?$xr_vector@PAVNvEdgeInfo@@V?$xalloc@PAVNvEdgeInfo@@@@@@AAV?$xr_vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@@@Z@4V?$xr_vector@GV?$xalloc@G@@@@A+4
	mov	ecx, edx
	sub	ecx, DWORD PTR ?scratchIndices@?1??Build@NvStripInfo@@QAEXAAV?$xr_vector@PAVNvEdgeInfo@@V?$xalloc@PAVNvEdgeInfo@@@@@@AAV?$xr_vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@@@Z@4V?$xr_vector@GV?$xalloc@G@@@@A
	sar	ecx, 1

; 734  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	push	esi

; 1251 :         if (_Newsize < _Oldsize) { // trim

	cmovne	edx, DWORD PTR ?scratchIndices@?1??Build@NvStripInfo@@QAEXAAV?$xr_vector@PAVNvEdgeInfo@@V?$xalloc@PAVNvEdgeInfo@@@@@@AAV?$xr_vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@@@Z@4V?$xr_vector@GV?$xalloc@G@@@@A

; 734  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	lea	ecx, DWORD PTR _forwardFaces$[esp+96]

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	xor	eax, eax

; 1251 :         if (_Newsize < _Oldsize) { // trim

	mov	DWORD PTR ?scratchIndices@?1??Build@NvStripInfo@@QAEXAAV?$xr_vector@PAVNvEdgeInfo@@V?$xalloc@PAVNvEdgeInfo@@@@@@AAV?$xr_vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@@@Z@4V?$xr_vector@GV?$xalloc@G@@@@A+4, edx

; 734  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	push	eax

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR _forwardFaces$[esp+100], 0
	mov	DWORD PTR _forwardFaces$[esp+104], 0
	mov	DWORD PTR _forwardFaces$[esp+108], 0
	mov	DWORD PTR _backwardFaces$[esp+100], 0
	mov	DWORD PTR _i$1$[esp+100], eax
	mov	DWORD PTR _backwardFaces$[esp+104], eax
	mov	DWORD PTR _backwardFaces$[esp+108], eax

; 734  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	call	??$_Emplace_reallocate@ABQAVNvFaceInfo@@@?$vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@std@@QAEPAPAVNvFaceInfo@@QAPAV2@ABQAV2@@Z ; std::vector<NvFaceInfo *,xalloc<NvFaceInfo *> >::_Emplace_reallocate<NvFaceInfo * const &>
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.h

; 131  : 	inline bool IsExperiment () const { return m_experimentId >= 0; }

	mov	eax, DWORD PTR [esi+28]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 456  : 	MarkTriangle(m_startInfo.m_startFace);

	mov	ecx, DWORD PTR [esi]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.h

; 131  : 	inline bool IsExperiment () const { return m_experimentId >= 0; }

	test	eax, eax
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 388  : 	if (IsExperiment()){

	js	SHORT $LN73@Build

; 389  : 		faceInfo->m_experimentId = m_experimentId;

	mov	DWORD PTR [ecx+20], eax

; 390  : 		faceInfo->m_testStripId  = m_stripId;

	mov	eax, DWORD PTR [esi+24]
	mov	DWORD PTR [ecx+16], eax

; 391  :     }

	jmp	SHORT $LN74@Build
$LN73@Build:

; 392  : 	else{
; 393  : 		assert(faceInfo->m_stripId == -1);
; 394  : 		faceInfo->m_experimentId = -1;

	mov	DWORD PTR [ecx+20], -1

; 395  : 		faceInfo->m_stripId      = m_stripId;

	mov	eax, DWORD PTR [esi+24]
	mov	DWORD PTR [ecx+12], eax
$LN74@Build:

; 457  : 	
; 458  : 	int v0 = (m_startInfo.m_toV1 ? m_startInfo.m_startEdge->m_v0 : m_startInfo.m_startEdge->m_v1);

	cmp	BYTE PTR [esi+8], 0
	mov	eax, DWORD PTR [esi+4]
	je	SHORT $LN13@Build
	mov	ecx, DWORD PTR [eax+12]

; 459  : 	int v1 = (m_startInfo.m_toV1 ? m_startInfo.m_startEdge->m_v1 : m_startInfo.m_startEdge->m_v0);

	mov	ebx, DWORD PTR [eax+16]
	jmp	SHORT $LN601@Build
$LN13@Build:

; 457  : 	
; 458  : 	int v0 = (m_startInfo.m_toV1 ? m_startInfo.m_startEdge->m_v0 : m_startInfo.m_startEdge->m_v1);

	mov	ecx, DWORD PTR [eax+16]

; 459  : 	int v1 = (m_startInfo.m_toV1 ? m_startInfo.m_startEdge->m_v1 : m_startInfo.m_startEdge->m_v0);

	mov	ebx, DWORD PTR [eax+12]
$LN601@Build:

; 463  : 	scratchIndices.push_back(u16(v0));

	mov	DWORD PTR _nv1$2$[esp+92], ecx
	movzx	ecx, cx
	movzx	eax, cx
	mov	DWORD PTR $T4[esp+92], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 730  :         if (_Mylast != _My_data._Myend) {

	mov	eax, DWORD PTR ?scratchIndices@?1??Build@NvStripInfo@@QAEXAAV?$xr_vector@PAVNvEdgeInfo@@V?$xalloc@PAVNvEdgeInfo@@@@@@AAV?$xr_vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@@@Z@4V?$xr_vector@GV?$xalloc@G@@@@A+4
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 463  : 	scratchIndices.push_back(u16(v0));

	mov	DWORD PTR _v1$1$[esp+92], ebx
	mov	DWORD PTR tv3190[esp+92], ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 730  :         if (_Mylast != _My_data._Myend) {

	cmp	eax, DWORD PTR ?scratchIndices@?1??Build@NvStripInfo@@QAEXAAV?$xr_vector@PAVNvEdgeInfo@@V?$xalloc@PAVNvEdgeInfo@@@@@@AAV?$xr_vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@@@Z@4V?$xr_vector@GV?$xalloc@G@@@@A+8
	je	SHORT $LN81@Build

; 713  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

	mov	WORD PTR [eax], cx

; 714  :         _Orphan_range(_Mylast, _Mylast);
; 715  :         _Ty& _Result = *_Mylast;
; 716  :         ++_Mylast;

	mov	ecx, DWORD PTR ?scratchIndices@?1??Build@NvStripInfo@@QAEXAAV?$xr_vector@PAVNvEdgeInfo@@V?$xalloc@PAVNvEdgeInfo@@@@@@AAV?$xr_vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@@@Z@4V?$xr_vector@GV?$xalloc@G@@@@A+4
	add	ecx, 2
	mov	DWORD PTR ?scratchIndices@?1??Build@NvStripInfo@@QAEXAAV?$xr_vector@PAVNvEdgeInfo@@V?$xalloc@PAVNvEdgeInfo@@@@@@AAV?$xr_vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@@@Z@4V?$xr_vector@GV?$xalloc@G@@@@A+4, ecx

; 731  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

	jmp	SHORT $LN80@Build
$LN81@Build:

; 732  :         }
; 733  : 
; 734  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	lea	ecx, DWORD PTR $T4[esp+92]
	push	ecx
	push	eax
	call	??$_Emplace_reallocate@G@?$vector@GV?$xalloc@G@@@std@@QAEPAGQAG$$QAG@Z ; std::vector<unsigned short,xalloc<unsigned short> >::_Emplace_reallocate<unsigned short>
	mov	ecx, DWORD PTR ?scratchIndices@?1??Build@NvStripInfo@@QAEXAAV?$xr_vector@PAVNvEdgeInfo@@V?$xalloc@PAVNvEdgeInfo@@@@@@AAV?$xr_vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@@@Z@4V?$xr_vector@GV?$xalloc@G@@@@A+4
$LN80@Build:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 464  : 	scratchIndices.push_back(u16(v1));

	movzx	edx, bx
	movzx	eax, dx
	mov	DWORD PTR tv3191[esp+92], edx
	mov	DWORD PTR $T3[esp+92], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 730  :         if (_Mylast != _My_data._Myend) {

	cmp	ecx, DWORD PTR ?scratchIndices@?1??Build@NvStripInfo@@QAEXAAV?$xr_vector@PAVNvEdgeInfo@@V?$xalloc@PAVNvEdgeInfo@@@@@@AAV?$xr_vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@@@Z@4V?$xr_vector@GV?$xalloc@G@@@@A+8
	je	SHORT $LN88@Build

; 713  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

	mov	WORD PTR [ecx], dx

; 714  :         _Orphan_range(_Mylast, _Mylast);
; 715  :         _Ty& _Result = *_Mylast;
; 716  :         ++_Mylast;

	add	DWORD PTR ?scratchIndices@?1??Build@NvStripInfo@@QAEXAAV?$xr_vector@PAVNvEdgeInfo@@V?$xalloc@PAVNvEdgeInfo@@@@@@AAV?$xr_vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@@@Z@4V?$xr_vector@GV?$xalloc@G@@@@A+4, 2

; 731  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

	jmp	SHORT $LN87@Build
$LN88@Build:

; 732  :         }
; 733  : 
; 734  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	lea	eax, DWORD PTR $T3[esp+92]
	push	eax
	push	ecx
	call	??$_Emplace_reallocate@G@?$vector@GV?$xalloc@G@@@std@@QAEPAGQAG$$QAG@Z ; std::vector<unsigned short,xalloc<unsigned short> >::_Emplace_reallocate<unsigned short>
$LN87@Build:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 465  : 	int v2 = NvStripifier::GetNextIndex(scratchIndices, m_startInfo.m_startFace);

	mov	edx, DWORD PTR [esi]
	call	?GetNextIndex@NvStripifier@@KAHABV?$xr_vector@GV?$xalloc@G@@@@PAVNvFaceInfo@@@Z ; NvStripifier::GetNextIndex
	mov	esi, eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 730  :         if (_Mylast != _My_data._Myend) {

	mov	eax, DWORD PTR ?scratchIndices@?1??Build@NvStripInfo@@QAEXAAV?$xr_vector@PAVNvEdgeInfo@@V?$xalloc@PAVNvEdgeInfo@@@@@@AAV?$xr_vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@@@Z@4V?$xr_vector@GV?$xalloc@G@@@@A+4
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 466  : 	scratchIndices.push_back(u16(v2));

	movzx	edx, si
	movzx	ecx, dx
	mov	DWORD PTR tv3192[esp+92], edx
	mov	DWORD PTR $T2[esp+92], ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 730  :         if (_Mylast != _My_data._Myend) {

	cmp	eax, DWORD PTR ?scratchIndices@?1??Build@NvStripInfo@@QAEXAAV?$xr_vector@PAVNvEdgeInfo@@V?$xalloc@PAVNvEdgeInfo@@@@@@AAV?$xr_vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@@@Z@4V?$xr_vector@GV?$xalloc@G@@@@A+8
	je	SHORT $LN95@Build

; 713  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

	mov	WORD PTR [eax], dx

; 714  :         _Orphan_range(_Mylast, _Mylast);
; 715  :         _Ty& _Result = *_Mylast;
; 716  :         ++_Mylast;

	add	DWORD PTR ?scratchIndices@?1??Build@NvStripInfo@@QAEXAAV?$xr_vector@PAVNvEdgeInfo@@V?$xalloc@PAVNvEdgeInfo@@@@@@AAV?$xr_vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@@@Z@4V?$xr_vector@GV?$xalloc@G@@@@A+4, 2

; 731  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

	jmp	SHORT $LN94@Build
$LN95@Build:

; 732  :         }
; 733  : 
; 734  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	lea	ecx, DWORD PTR $T2[esp+92]
	push	ecx
	push	eax
	call	??$_Emplace_reallocate@G@?$vector@GV?$xalloc@G@@@std@@QAEPAGQAG$$QAG@Z ; std::vector<unsigned short,xalloc<unsigned short> >::_Emplace_reallocate<unsigned short>
$LN94@Build:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 33   : 	NvEdgeInfo *infoIter = edgeInfos[v0];

	mov	eax, DWORD PTR _edgeInfos$[esp+88]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 119  :         _Ptr += _Off;

	lea	ecx, DWORD PTR [ebx*4]
	mov	DWORD PTR tv3204[esp+92], ecx
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 33   : 	NvEdgeInfo *infoIter = edgeInfos[v0];

	mov	eax, DWORD PTR [eax]
	mov	eax, DWORD PTR [ecx+eax]

; 34   : 	while (infoIter != NULL){

	test	eax, eax
	je	SHORT $LN105@Build
$LL104@Build:

; 35   : 		if (infoIter->m_v0 == v0){

	mov	ecx, DWORD PTR [eax+12]
	cmp	ecx, ebx
	jne	SHORT $LN106@Build

; 36   : 			if (infoIter->m_v1 == v1)

	cmp	DWORD PTR [eax+16], esi
	je	SHORT $LN103@Build

; 37   : 				return infoIter;
; 38   : 			else
; 39   : 				infoIter = infoIter->m_nextV0;

	mov	eax, DWORD PTR [eax+20]

; 40   : 		}

	jmp	SHORT $LN111@Build
$LN106@Build:

; 41   : 		else {
; 42   : 			assert(infoIter->m_v1 == v0);
; 43   : 			if (infoIter->m_v0 == v1)

	cmp	ecx, esi
	je	SHORT $LN103@Build

; 44   : 				return infoIter;
; 45   : 			else
; 46   : 				infoIter = infoIter->m_nextV1;

	mov	eax, DWORD PTR [eax+24]
$LN111@Build:

; 34   : 	while (infoIter != NULL){

	test	eax, eax
	jne	SHORT $LL104@Build
$LN105@Build:

; 47   : 		}
; 48   : 	}
; 49   : 	return NULL;

	xor	eax, eax
$LN103@Build:

; 62   : 	return (edgeInfo->m_face0 == faceInfo ? edgeInfo->m_face1 : edgeInfo->m_face0);

	mov	ebx, DWORD PTR _this$1$[esp+92]
	mov	ebp, DWORD PTR [eax+4]
	cmp	ebp, DWORD PTR [ebx]
	jne	SHORT $LN101@Build
	mov	ebp, DWORD PTR [eax+8]
$LN101@Build:

; 467  : 	
; 468  : 	//
; 469  : 	// build the forward list
; 470  : 	//
; 471  : 	int nv0 = v1;
; 472  : 	int nv1 = v2;
; 473  : 	
; 474  : 	NvFaceInfo *nextFace = NvStripifier::FindOtherFace(edgeInfos, nv0, nv1, m_startInfo.m_startFace);
; 475  : 	while (nextFace != NULL && !IsMarked(nextFace))

	mov	DWORD PTR _nextFace$[esp+92], ebp
	push	edi
	mov	edi, DWORD PTR _forwardFaces$[esp+100]
	test	ebp, ebp
	je	$LN578@Build
	mov	ecx, ebp
$LL3@Build:

; 377  : 	return (faceInfo->m_stripId >= 0) || (IsExperiment() && faceInfo->m_experimentId == m_experimentId);

	cmp	DWORD PTR [ebp+12], 0
	jge	$LN578@Build
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.h

; 131  : 	inline bool IsExperiment () const { return m_experimentId >= 0; }

	mov	eax, DWORD PTR [ebx+28]
	test	eax, eax
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 377  : 	return (faceInfo->m_stripId >= 0) || (IsExperiment() && faceInfo->m_experimentId == m_experimentId);

	js	SHORT $LN132@Build
	cmp	DWORD PTR [ebp+20], eax
	je	$LN578@Build
$LN132@Build:

; 476  : 	{
; 477  : 		//this tests to see if a face is "unique", meaning that its vertices aren't already in the list
; 478  : 		// so, strips which "wrap-around" are not allowed
; 479  : 		if(!Unique(forwardFaces, nextFace))

	push	ecx
	lea	eax, DWORD PTR _forwardFaces$[esp+100]
	push	eax
	call	?Unique@NvStripInfo@@QAE_NAAV?$xr_vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@@PAVNvFaceInfo@@@Z ; NvStripInfo::Unique
	test	al, al
	je	$LN578@Build
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 730  :         if (_Mylast != _My_data._Myend) {

	cmp	edi, DWORD PTR _forwardFaces$[esp+104]
	je	SHORT $LN140@Build

; 713  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

	mov	DWORD PTR [edi], ebp

; 714  :         _Orphan_range(_Mylast, _Mylast);
; 715  :         _Ty& _Result = *_Mylast;
; 716  :         ++_Mylast;

	add	edi, 4
	mov	DWORD PTR _numFaces$1$[esp+96], edi
	mov	DWORD PTR _forwardFaces$[esp+100], edi

; 731  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

	jmp	SHORT $LN139@Build
$LN140@Build:

; 732  :         }
; 733  : 
; 734  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	lea	eax, DWORD PTR _nextFace$[esp+96]
	push	eax
	push	edi
	lea	ecx, DWORD PTR _forwardFaces$[esp+104]
	call	??$_Emplace_reallocate@ABQAVNvFaceInfo@@@?$vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@std@@QAEPAPAVNvFaceInfo@@QAPAV2@ABQAV2@@Z ; std::vector<NvFaceInfo *,xalloc<NvFaceInfo *> >::_Emplace_reallocate<NvFaceInfo * const &>
	mov	eax, DWORD PTR _forwardFaces$[esp+100]
	mov	DWORD PTR _numFaces$1$[esp+96], eax
$LN139@Build:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.h

; 131  : 	inline bool IsExperiment () const { return m_experimentId >= 0; }

	mov	eax, DWORD PTR [ebx+28]
	test	eax, eax
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 388  : 	if (IsExperiment()){

	js	SHORT $LN145@Build

; 389  : 		faceInfo->m_experimentId = m_experimentId;

	mov	DWORD PTR [ebp+20], eax

; 390  : 		faceInfo->m_testStripId  = m_stripId;

	mov	eax, DWORD PTR [ebx+24]
	mov	DWORD PTR [ebp+16], eax

; 391  :     }

	jmp	SHORT $LN146@Build
$LN145@Build:

; 392  : 	else{
; 393  : 		assert(faceInfo->m_stripId == -1);
; 394  : 		faceInfo->m_experimentId = -1;

	mov	DWORD PTR [ebp+20], -1

; 395  : 		faceInfo->m_stripId      = m_stripId;

	mov	eax, DWORD PTR [ebx+24]
	mov	DWORD PTR [ebp+12], eax
$LN146@Build:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	eax, DWORD PTR ?scratchIndices@?1??Build@NvStripInfo@@QAEXAAV?$xr_vector@PAVNvEdgeInfo@@V?$xalloc@PAVNvEdgeInfo@@@@@@AAV?$xr_vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@@@Z@4V?$xr_vector@GV?$xalloc@G@@@@A
	mov	ecx, DWORD PTR ?scratchIndices@?1??Build@NvStripInfo@@QAEXAAV?$xr_vector@PAVNvEdgeInfo@@V?$xalloc@PAVNvEdgeInfo@@@@@@AAV?$xr_vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@@@Z@4V?$xr_vector@GV?$xalloc@G@@@@A+4
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 338  : 	int fv1 = face->m_v1;

	mov	edi, DWORD PTR [ebp+4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	sub	ecx, eax
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 339  : 	int fv2 = face->m_v2;

	mov	ebx, DWORD PTR [ebp+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	sar	ecx, 1
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 488  : 		nv0 = nv1;

	mov	DWORD PTR _nv0$1$[esp+96], esi

; 337  : 	int fv0 = face->m_v0;

	mov	esi, DWORD PTR [ebp]
	movzx	edx, WORD PTR [eax+ecx*2-4]
	movzx	eax, WORD PTR [eax+ecx*2-2]

; 340  : 	
; 341  : 	if (fv0 != v0 && fv0 != v1){

	cmp	esi, edx
	je	SHORT $LN151@Build
	cmp	esi, eax
	je	SHORT $LN151@Build

; 342  : 		if ((fv1 != v0 && fv1 != v1) || (fv2 != v0 && fv2 != v1)){

	cmp	edi, edx
	je	SHORT $LN154@Build
	cmp	edi, eax
	jne	SHORT $LN153@Build
$LN154@Build:
	cmp	ebx, edx
	je	$LN150@Build
	cmp	ebx, eax
	je	$LN150@Build
$LN153@Build:

; 343  : 			Msg("! WARNING: GetNextIndex: Triangle doesn't have all of its vertices");

	mov	ebx, DWORD PTR __imp_?Msg@@YAXPBDZZ
	push	OFFSET ??_C@_0ED@PGPLFOBO@?$CB?5WARNING?3?5GetNextIndex?3?5Triang@
	call	ebx

; 344  : 			Msg("! WARNING: GetNextIndex: Duplicate triangle probably got us derailed");

	push	OFFSET ??_C@_0EF@NPIJGPAE@?$CB?5WARNING?3?5GetNextIndex?3?5Duplic@
	call	ebx
	add	esp, 8

; 345  : 		}
; 346  : 		return fv0;

	jmp	SHORT $LN150@Build
$LN151@Build:

; 347  : 	}
; 348  : 	if (fv1 != v0 && fv1 != v1){

	cmp	edi, edx
	je	SHORT $LN155@Build
	cmp	edi, eax
	je	SHORT $LN155@Build

; 349  : 		if ((fv0 != v0 && fv0 != v1) || (fv2 != v0 && fv2 != v1)){

	cmp	esi, edx
	je	SHORT $LN158@Build
	cmp	esi, eax
	jne	SHORT $LN157@Build
$LN158@Build:
	cmp	ebx, edx
	je	SHORT $LN156@Build
	cmp	ebx, eax
	je	SHORT $LN156@Build
$LN157@Build:

; 350  : 			Msg("! WARNING: GetNextIndex: Triangle doesn't have all of its vertices");

	mov	ebx, DWORD PTR __imp_?Msg@@YAXPBDZZ
	push	OFFSET ??_C@_0ED@PGPLFOBO@?$CB?5WARNING?3?5GetNextIndex?3?5Triang@
	call	ebx

; 351  : 			Msg("! WARNING: GetNextIndex: Duplicate triangle probably got us derailed");

	push	OFFSET ??_C@_0EF@NPIJGPAE@?$CB?5WARNING?3?5GetNextIndex?3?5Duplic@
	call	ebx
	add	esp, 8
$LN156@Build:

; 352  : 		}
; 353  : 		return fv1;

	mov	esi, edi
	jmp	SHORT $LN150@Build
$LN155@Build:

; 354  : 	}
; 355  : 	if (fv2 != v0 && fv2 != v1){

	cmp	ebx, edx
	je	SHORT $LN159@Build
	cmp	ebx, eax
	je	SHORT $LN159@Build

; 356  : 		if ((fv0 != v0 && fv0 != v1) || (fv1 != v0 && fv1 != v1)){

	cmp	esi, edx
	je	SHORT $LN162@Build
	cmp	esi, eax
	jne	SHORT $LN161@Build
$LN162@Build:
	cmp	edi, edx
	je	SHORT $LN160@Build
	cmp	edi, eax
	je	SHORT $LN160@Build
$LN161@Build:

; 357  : 			Msg("! WARNING: GetNextIndex: Triangle doesn't have all of its vertices");

	mov	esi, DWORD PTR __imp_?Msg@@YAXPBDZZ
	push	OFFSET ??_C@_0ED@PGPLFOBO@?$CB?5WARNING?3?5GetNextIndex?3?5Triang@
	call	esi

; 358  : 			Msg("! WARNING: GetNextIndex: Duplicate triangle probably got us derailed");

	push	OFFSET ??_C@_0EF@NPIJGPAE@?$CB?5WARNING?3?5GetNextIndex?3?5Duplic@
	call	esi
	add	esp, 8
$LN160@Build:

; 359  : 		}
; 360  : 		return fv2;

	mov	esi, ebx
	jmp	SHORT $LN150@Build
$LN159@Build:

; 361  : 	}
; 362  : 	
; 363  : 	// shouldn't get here
; 364  : 	Msg("! WARNING: GetNextIndex: Duplicate triangle sent");

	push	OFFSET ??_C@_0DB@JOONJBKI@?$CB?5WARNING?3?5GetNextIndex?3?5Duplic@
	call	DWORD PTR __imp_?Msg@@YAXPBDZZ
	add	esp, 4

; 365  : 	return -1;

	or	esi, -1
$LN150@Build:

; 489  : 		nv1 = NvStripifier::GetNextIndex(scratchIndices, nextFace);
; 490  : 		scratchIndices.push_back(u16(nv1));

	movzx	ecx, si
	mov	eax, ecx
	mov	DWORD PTR $T1[esp+96], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 730  :         if (_Mylast != _My_data._Myend) {

	mov	eax, DWORD PTR ?scratchIndices@?1??Build@NvStripInfo@@QAEXAAV?$xr_vector@PAVNvEdgeInfo@@V?$xalloc@PAVNvEdgeInfo@@@@@@AAV?$xr_vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@@@Z@4V?$xr_vector@GV?$xalloc@G@@@@A+4
	cmp	eax, DWORD PTR ?scratchIndices@?1??Build@NvStripInfo@@QAEXAAV?$xr_vector@PAVNvEdgeInfo@@V?$xalloc@PAVNvEdgeInfo@@@@@@AAV?$xr_vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@@@Z@4V?$xr_vector@GV?$xalloc@G@@@@A+8
	je	SHORT $LN197@Build

; 713  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

	mov	WORD PTR [eax], cx

; 714  :         _Orphan_range(_Mylast, _Mylast);
; 715  :         _Ty& _Result = *_Mylast;
; 716  :         ++_Mylast;

	add	DWORD PTR ?scratchIndices@?1??Build@NvStripInfo@@QAEXAAV?$xr_vector@PAVNvEdgeInfo@@V?$xalloc@PAVNvEdgeInfo@@@@@@AAV?$xr_vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@@@Z@4V?$xr_vector@GV?$xalloc@G@@@@A+4, 2

; 731  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

	jmp	SHORT $LN196@Build
$LN197@Build:

; 732  :         }
; 733  : 
; 734  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	lea	eax, DWORD PTR $T1[esp+96]
	push	eax
	push	DWORD PTR ?scratchIndices@?1??Build@NvStripInfo@@QAEXAAV?$xr_vector@PAVNvEdgeInfo@@V?$xalloc@PAVNvEdgeInfo@@@@@@AAV?$xr_vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@@@Z@4V?$xr_vector@GV?$xalloc@G@@@@A+4
	call	??$_Emplace_reallocate@G@?$vector@GV?$xalloc@G@@@std@@QAEPAGQAG$$QAG@Z ; std::vector<unsigned short,xalloc<unsigned short> >::_Emplace_reallocate<unsigned short>
$LN196@Build:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 33   : 	NvEdgeInfo *infoIter = edgeInfos[v0];

	mov	eax, DWORD PTR _edgeInfos$[esp+92]
	mov	edx, DWORD PTR _nv0$1$[esp+96]
	mov	eax, DWORD PTR [eax]
	mov	eax, DWORD PTR [eax+edx*4]

; 34   : 	while (infoIter != NULL){

	test	eax, eax
	je	SHORT $LN207@Build
$LL206@Build:

; 35   : 		if (infoIter->m_v0 == v0){

	mov	ecx, DWORD PTR [eax+12]
	cmp	ecx, edx
	jne	SHORT $LN208@Build

; 36   : 			if (infoIter->m_v1 == v1)

	cmp	DWORD PTR [eax+16], esi
	je	SHORT $LN205@Build

; 37   : 				return infoIter;
; 38   : 			else
; 39   : 				infoIter = infoIter->m_nextV0;

	mov	eax, DWORD PTR [eax+20]

; 40   : 		}

	jmp	SHORT $LN213@Build
$LN208@Build:

; 41   : 		else {
; 42   : 			assert(infoIter->m_v1 == v0);
; 43   : 			if (infoIter->m_v0 == v1)

	cmp	ecx, esi
	je	SHORT $LN205@Build

; 44   : 				return infoIter;
; 45   : 			else
; 46   : 				infoIter = infoIter->m_nextV1;

	mov	eax, DWORD PTR [eax+24]
$LN213@Build:

; 34   : 	while (infoIter != NULL){

	test	eax, eax
	jne	SHORT $LL206@Build
$LN207@Build:

; 47   : 		}
; 48   : 	}
; 49   : 	return NULL;

	xor	eax, eax
$LN205@Build:

; 62   : 	return (edgeInfo->m_face0 == faceInfo ? edgeInfo->m_face1 : edgeInfo->m_face0);

	mov	ecx, DWORD PTR [eax+4]
	cmp	ecx, ebp
	jne	SHORT $LN203@Build
	mov	ebp, DWORD PTR [eax+8]
	jmp	SHORT $LN204@Build
$LN203@Build:
	mov	ebp, ecx
$LN204@Build:

; 467  : 	
; 468  : 	//
; 469  : 	// build the forward list
; 470  : 	//
; 471  : 	int nv0 = v1;
; 472  : 	int nv1 = v2;
; 473  : 	
; 474  : 	NvFaceInfo *nextFace = NvStripifier::FindOtherFace(edgeInfos, nv0, nv1, m_startInfo.m_startFace);
; 475  : 	while (nextFace != NULL && !IsMarked(nextFace))

	mov	edi, DWORD PTR _numFaces$1$[esp+96]
	mov	ecx, ebp
	mov	DWORD PTR _nextFace$[esp+96], ebp
	test	ebp, ebp
	je	SHORT $LN578@Build
	mov	ebx, DWORD PTR _this$1$[esp+96]
	jmp	$LL3@Build
$LN578@Build:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	ecx, DWORD PTR _forwardFaces$[esp+96]

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	xor	ebx, ebx

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	sub	edi, ecx

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR _tempAllFaces$[esp+96], ebx

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	sar	edi, 2

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	xor	ebp, ebp
	xor	eax, eax
	mov	DWORD PTR _tempAllFaces$[esp+100], ebp
	mov	DWORD PTR _tempAllFaces$[esp+104], eax

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	DWORD PTR _numFaces$1$[esp+96], edi
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 500  : 	for(int i = 0; i < forwardFaces.size(); i++)

	test	edi, edi
	je	SHORT $LN6@Build
	mov	esi, ecx
	npad	6
$LL7@Build:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 730  :         if (_Mylast != _My_data._Myend) {

	cmp	ebp, eax
	je	SHORT $LN264@Build

; 713  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [ebp], eax

; 714  :         _Orphan_range(_Mylast, _Mylast);
; 715  :         _Ty& _Result = *_Mylast;
; 716  :         ++_Mylast;

	add	ebp, 4
	mov	DWORD PTR _tempAllFaces$[esp+100], ebp

; 731  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

	jmp	SHORT $LN5@Build
$LN264@Build:

; 732  :         }
; 733  : 
; 734  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	push	esi
	push	ebp
	lea	ecx, DWORD PTR _tempAllFaces$[esp+104]
	call	??$_Emplace_reallocate@ABQAVNvFaceInfo@@@?$vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@std@@QAEPAPAVNvFaceInfo@@QAPAV2@ABQAV2@@Z ; std::vector<NvFaceInfo *,xalloc<NvFaceInfo *> >::_Emplace_reallocate<NvFaceInfo * const &>
	mov	ebp, DWORD PTR _tempAllFaces$[esp+100]
$LN5@Build:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 500  : 	for(int i = 0; i < forwardFaces.size(); i++)

	mov	eax, DWORD PTR _tempAllFaces$[esp+104]
	add	esi, 4
	sub	edi, 1
	jne	SHORT $LL7@Build
	mov	ebx, DWORD PTR _tempAllFaces$[esp+96]
$LN6@Build:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1250 :         const auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);

	mov	edx, DWORD PTR ?scratchIndices@?1??Build@NvStripInfo@@QAEXAAV?$xr_vector@PAVNvEdgeInfo@@V?$xalloc@PAVNvEdgeInfo@@@@@@AAV?$xr_vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@@@Z@4V?$xr_vector@GV?$xalloc@G@@@@A+4
	mov	ecx, edx
	sub	ecx, DWORD PTR ?scratchIndices@?1??Build@NvStripInfo@@QAEXAAV?$xr_vector@PAVNvEdgeInfo@@V?$xalloc@PAVNvEdgeInfo@@@@@@AAV?$xr_vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@@@Z@4V?$xr_vector@GV?$xalloc@G@@@@A
	sar	ecx, 1
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 507  : 	scratchIndices.push_back(u16(v2));

	mov	ecx, DWORD PTR tv3192[esp+96]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1251 :         if (_Newsize < _Oldsize) { // trim

	cmovne	edx, DWORD PTR ?scratchIndices@?1??Build@NvStripInfo@@QAEXAAV?$xr_vector@PAVNvEdgeInfo@@V?$xalloc@PAVNvEdgeInfo@@@@@@AAV?$xr_vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@@@Z@4V?$xr_vector@GV?$xalloc@G@@@@A
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 507  : 	scratchIndices.push_back(u16(v2));

	movzx	eax, cx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1251 :         if (_Newsize < _Oldsize) { // trim

	mov	DWORD PTR ?scratchIndices@?1??Build@NvStripInfo@@QAEXAAV?$xr_vector@PAVNvEdgeInfo@@V?$xalloc@PAVNvEdgeInfo@@@@@@AAV?$xr_vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@@@Z@4V?$xr_vector@GV?$xalloc@G@@@@A+4, edx
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 507  : 	scratchIndices.push_back(u16(v2));

	mov	DWORD PTR $T5[esp+96], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 730  :         if (_Mylast != _My_data._Myend) {

	cmp	edx, DWORD PTR ?scratchIndices@?1??Build@NvStripInfo@@QAEXAAV?$xr_vector@PAVNvEdgeInfo@@V?$xalloc@PAVNvEdgeInfo@@@@@@AAV?$xr_vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@@@Z@4V?$xr_vector@GV?$xalloc@G@@@@A+8
	je	SHORT $LN295@Build

; 713  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

	mov	WORD PTR [edx], cx

; 714  :         _Orphan_range(_Mylast, _Mylast);
; 715  :         _Ty& _Result = *_Mylast;
; 716  :         ++_Mylast;

	mov	ecx, DWORD PTR ?scratchIndices@?1??Build@NvStripInfo@@QAEXAAV?$xr_vector@PAVNvEdgeInfo@@V?$xalloc@PAVNvEdgeInfo@@@@@@AAV?$xr_vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@@@Z@4V?$xr_vector@GV?$xalloc@G@@@@A+4
	add	ecx, 2
	mov	DWORD PTR ?scratchIndices@?1??Build@NvStripInfo@@QAEXAAV?$xr_vector@PAVNvEdgeInfo@@V?$xalloc@PAVNvEdgeInfo@@@@@@AAV?$xr_vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@@@Z@4V?$xr_vector@GV?$xalloc@G@@@@A+4, ecx

; 731  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

	jmp	SHORT $LN294@Build
$LN295@Build:

; 732  :         }
; 733  : 
; 734  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	lea	eax, DWORD PTR $T5[esp+96]
	push	eax
	push	edx
	call	??$_Emplace_reallocate@G@?$vector@GV?$xalloc@G@@@std@@QAEPAGQAG$$QAG@Z ; std::vector<unsigned short,xalloc<unsigned short> >::_Emplace_reallocate<unsigned short>
	mov	ecx, DWORD PTR ?scratchIndices@?1??Build@NvStripInfo@@QAEXAAV?$xr_vector@PAVNvEdgeInfo@@V?$xalloc@PAVNvEdgeInfo@@@@@@AAV?$xr_vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@@@Z@4V?$xr_vector@GV?$xalloc@G@@@@A+4
$LN294@Build:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 508  : 	scratchIndices.push_back(u16(v1));

	mov	edx, DWORD PTR tv3191[esp+96]
	movzx	eax, dx
	mov	DWORD PTR $T6[esp+96], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 730  :         if (_Mylast != _My_data._Myend) {

	cmp	ecx, DWORD PTR ?scratchIndices@?1??Build@NvStripInfo@@QAEXAAV?$xr_vector@PAVNvEdgeInfo@@V?$xalloc@PAVNvEdgeInfo@@@@@@AAV?$xr_vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@@@Z@4V?$xr_vector@GV?$xalloc@G@@@@A+8
	je	SHORT $LN302@Build

; 713  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

	mov	WORD PTR [ecx], dx

; 714  :         _Orphan_range(_Mylast, _Mylast);
; 715  :         _Ty& _Result = *_Mylast;
; 716  :         ++_Mylast;

	mov	ecx, DWORD PTR ?scratchIndices@?1??Build@NvStripInfo@@QAEXAAV?$xr_vector@PAVNvEdgeInfo@@V?$xalloc@PAVNvEdgeInfo@@@@@@AAV?$xr_vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@@@Z@4V?$xr_vector@GV?$xalloc@G@@@@A+4
	add	ecx, 2
	mov	DWORD PTR ?scratchIndices@?1??Build@NvStripInfo@@QAEXAAV?$xr_vector@PAVNvEdgeInfo@@V?$xalloc@PAVNvEdgeInfo@@@@@@AAV?$xr_vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@@@Z@4V?$xr_vector@GV?$xalloc@G@@@@A+4, ecx

; 731  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

	jmp	SHORT $LN301@Build
$LN302@Build:

; 732  :         }
; 733  : 
; 734  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	lea	eax, DWORD PTR $T6[esp+96]
	push	eax
	push	ecx
	call	??$_Emplace_reallocate@G@?$vector@GV?$xalloc@G@@@std@@QAEPAGQAG$$QAG@Z ; std::vector<unsigned short,xalloc<unsigned short> >::_Emplace_reallocate<unsigned short>
	mov	ecx, DWORD PTR ?scratchIndices@?1??Build@NvStripInfo@@QAEXAAV?$xr_vector@PAVNvEdgeInfo@@V?$xalloc@PAVNvEdgeInfo@@@@@@AAV?$xr_vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@@@Z@4V?$xr_vector@GV?$xalloc@G@@@@A+4
$LN301@Build:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 509  : 	scratchIndices.push_back(u16(v0));

	mov	edx, DWORD PTR tv3190[esp+96]
	movzx	eax, dx
	mov	DWORD PTR $T7[esp+96], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 730  :         if (_Mylast != _My_data._Myend) {

	cmp	ecx, DWORD PTR ?scratchIndices@?1??Build@NvStripInfo@@QAEXAAV?$xr_vector@PAVNvEdgeInfo@@V?$xalloc@PAVNvEdgeInfo@@@@@@AAV?$xr_vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@@@Z@4V?$xr_vector@GV?$xalloc@G@@@@A+8
	je	SHORT $LN309@Build

; 713  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

	mov	WORD PTR [ecx], dx

; 714  :         _Orphan_range(_Mylast, _Mylast);
; 715  :         _Ty& _Result = *_Mylast;
; 716  :         ++_Mylast;

	add	DWORD PTR ?scratchIndices@?1??Build@NvStripInfo@@QAEXAAV?$xr_vector@PAVNvEdgeInfo@@V?$xalloc@PAVNvEdgeInfo@@@@@@AAV?$xr_vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@@@Z@4V?$xr_vector@GV?$xalloc@G@@@@A+4, 2

; 731  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

	jmp	SHORT $LN308@Build
$LN309@Build:

; 732  :         }
; 733  : 
; 734  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	lea	eax, DWORD PTR $T7[esp+96]
	push	eax
	push	ecx
	call	??$_Emplace_reallocate@G@?$vector@GV?$xalloc@G@@@std@@QAEPAGQAG$$QAG@Z ; std::vector<unsigned short,xalloc<unsigned short> >::_Emplace_reallocate<unsigned short>
$LN308@Build:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 33   : 	NvEdgeInfo *infoIter = edgeInfos[v0];

	mov	eax, DWORD PTR _edgeInfos$[esp+92]
	mov	ecx, DWORD PTR tv3204[esp+96]
	mov	eax, DWORD PTR [eax]
	mov	eax, DWORD PTR [ecx+eax]

; 34   : 	while (infoIter != NULL){

	test	eax, eax
	je	SHORT $LN319@Build
	mov	edx, DWORD PTR _v1$1$[esp+96]
	npad	3
$LL318@Build:

; 35   : 		if (infoIter->m_v0 == v0){

	mov	ecx, DWORD PTR [eax+12]
	mov	edi, DWORD PTR _nv1$2$[esp+96]
	cmp	ecx, edx
	jne	SHORT $LN320@Build

; 36   : 			if (infoIter->m_v1 == v1)

	cmp	DWORD PTR [eax+16], edi
	je	SHORT $LN317@Build

; 37   : 				return infoIter;
; 38   : 			else
; 39   : 				infoIter = infoIter->m_nextV0;

	mov	eax, DWORD PTR [eax+20]

; 40   : 		}

	jmp	SHORT $LN325@Build
$LN320@Build:

; 41   : 		else {
; 42   : 			assert(infoIter->m_v1 == v0);
; 43   : 			if (infoIter->m_v0 == v1)

	cmp	ecx, edi
	je	SHORT $LN317@Build

; 44   : 				return infoIter;
; 45   : 			else
; 46   : 				infoIter = infoIter->m_nextV1;

	mov	eax, DWORD PTR [eax+24]
$LN325@Build:

; 34   : 	while (infoIter != NULL){

	test	eax, eax
	jne	SHORT $LL318@Build
$LN319@Build:
	mov	edi, DWORD PTR _nv1$2$[esp+96]

; 47   : 		}
; 48   : 	}
; 49   : 	return NULL;

	xor	eax, eax
$LN317@Build:

; 62   : 	return (edgeInfo->m_face0 == faceInfo ? edgeInfo->m_face1 : edgeInfo->m_face0);

	mov	ecx, DWORD PTR _this$1$[esp+96]
	mov	esi, DWORD PTR [eax+4]
	cmp	esi, DWORD PTR [ecx]
	jne	SHORT $LN315@Build
	mov	esi, DWORD PTR [eax+8]
$LN315@Build:

; 510  : 	nv0 = v1;
; 511  : 	nv1 = v0;
; 512  : 	nextFace = NvStripifier::FindOtherFace(edgeInfos, nv0, nv1, m_startInfo.m_startFace);
; 513  : 	while (nextFace != NULL && !IsMarked(nextFace))

	mov	DWORD PTR _nextFace$[esp+96], esi
	test	esi, esi
	je	$LN579@Build
	mov	ecx, esi
$LL8@Build:

; 377  : 	return (faceInfo->m_stripId >= 0) || (IsExperiment() && faceInfo->m_experimentId == m_experimentId);

	cmp	DWORD PTR [esi+12], 0
	jge	$LN598@Build
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.h

; 131  : 	inline bool IsExperiment () const { return m_experimentId >= 0; }

	mov	ebx, DWORD PTR _this$1$[esp+96]
	mov	eax, DWORD PTR [ebx+28]
	test	eax, eax
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 377  : 	return (faceInfo->m_stripId >= 0) || (IsExperiment() && faceInfo->m_experimentId == m_experimentId);

	js	SHORT $LN346@Build
	cmp	DWORD PTR [esi+20], eax
	je	$LN598@Build
$LN346@Build:

; 514  : 	{
; 515  : 		//this tests to see if a face is "unique", meaning that its vertices aren't already in the list
; 516  : 		// so, strips which "wrap-around" are not allowed
; 517  : 		if(!Unique(tempAllFaces, nextFace))

	push	ecx
	lea	eax, DWORD PTR _tempAllFaces$[esp+100]
	push	eax
	call	?Unique@NvStripInfo@@QAE_NAAV?$xr_vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@@PAVNvFaceInfo@@@Z ; NvStripInfo::Unique
	test	al, al
	je	$LN598@Build
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 730  :         if (_Mylast != _My_data._Myend) {

	mov	eax, DWORD PTR _i$1$[esp+96]
	cmp	eax, DWORD PTR _backwardFaces$[esp+104]
	je	SHORT $LN354@Build

; 713  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

	mov	DWORD PTR [eax], esi

; 714  :         _Orphan_range(_Mylast, _Mylast);
; 715  :         _Ty& _Result = *_Mylast;
; 716  :         ++_Mylast;

	add	eax, 4
	mov	DWORD PTR _backwardFaces$[esp+100], eax

; 731  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

	jmp	SHORT $LN602@Build
$LN354@Build:

; 732  :         }
; 733  : 
; 734  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	lea	ecx, DWORD PTR _nextFace$[esp+96]
	push	ecx
	push	eax
	lea	ecx, DWORD PTR _backwardFaces$[esp+104]
	call	??$_Emplace_reallocate@ABQAVNvFaceInfo@@@?$vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@std@@QAEPAPAVNvFaceInfo@@QAPAV2@ABQAV2@@Z ; std::vector<NvFaceInfo *,xalloc<NvFaceInfo *> >::_Emplace_reallocate<NvFaceInfo * const &>
	mov	eax, DWORD PTR _backwardFaces$[esp+100]
$LN602@Build:

; 730  :         if (_Mylast != _My_data._Myend) {

	mov	DWORD PTR _i$1$[esp+96], eax
	cmp	ebp, DWORD PTR _tempAllFaces$[esp+104]
	je	SHORT $LN361@Build

; 713  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

	mov	DWORD PTR [ebp], esi

; 714  :         _Orphan_range(_Mylast, _Mylast);
; 715  :         _Ty& _Result = *_Mylast;
; 716  :         ++_Mylast;

	add	ebp, 4
	mov	DWORD PTR _tempAllFaces$[esp+100], ebp

; 731  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

	jmp	SHORT $LN360@Build
$LN361@Build:

; 732  :         }
; 733  : 
; 734  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	lea	eax, DWORD PTR _nextFace$[esp+96]
	push	eax
	push	ebp
	lea	ecx, DWORD PTR _tempAllFaces$[esp+104]
	call	??$_Emplace_reallocate@ABQAVNvFaceInfo@@@?$vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@std@@QAEPAPAVNvFaceInfo@@QAPAV2@ABQAV2@@Z ; std::vector<NvFaceInfo *,xalloc<NvFaceInfo *> >::_Emplace_reallocate<NvFaceInfo * const &>
	mov	ebp, DWORD PTR _tempAllFaces$[esp+100]
$LN360@Build:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.h

; 131  : 	inline bool IsExperiment () const { return m_experimentId >= 0; }

	mov	eax, DWORD PTR [ebx+28]
	test	eax, eax
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 388  : 	if (IsExperiment()){

	js	SHORT $LN366@Build

; 389  : 		faceInfo->m_experimentId = m_experimentId;

	mov	DWORD PTR [esi+20], eax

; 390  : 		faceInfo->m_testStripId  = m_stripId;

	mov	eax, DWORD PTR [ebx+24]
	mov	DWORD PTR [esi+16], eax

; 391  :     }

	jmp	SHORT $LN367@Build
$LN366@Build:

; 392  : 	else{
; 393  : 		assert(faceInfo->m_stripId == -1);
; 394  : 		faceInfo->m_experimentId = -1;

	mov	DWORD PTR [esi+20], -1

; 395  : 		faceInfo->m_stripId      = m_stripId;

	mov	eax, DWORD PTR [ebx+24]
	mov	DWORD PTR [esi+12], eax
$LN367@Build:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	eax, DWORD PTR ?scratchIndices@?1??Build@NvStripInfo@@QAEXAAV?$xr_vector@PAVNvEdgeInfo@@V?$xalloc@PAVNvEdgeInfo@@@@@@AAV?$xr_vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@@@Z@4V?$xr_vector@GV?$xalloc@G@@@@A
	mov	ecx, DWORD PTR ?scratchIndices@?1??Build@NvStripInfo@@QAEXAAV?$xr_vector@PAVNvEdgeInfo@@V?$xalloc@PAVNvEdgeInfo@@@@@@AAV?$xr_vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@@@Z@4V?$xr_vector@GV?$xalloc@G@@@@A+4
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 339  : 	int fv2 = face->m_v2;

	mov	ebx, DWORD PTR [esi+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	sub	ecx, eax
	sar	ecx, 1
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 529  : 		nv0 = nv1;

	mov	DWORD PTR _nv0$2$[esp+96], edi

; 338  : 	int fv1 = face->m_v1;

	mov	edi, DWORD PTR [esi+4]
	movzx	edx, WORD PTR [eax+ecx*2-4]
	movzx	eax, WORD PTR [eax+ecx*2-2]
	mov	ecx, DWORD PTR [esi]
	mov	DWORD PTR _nv1$2$[esp+96], ecx

; 340  : 	
; 341  : 	if (fv0 != v0 && fv0 != v1){

	cmp	ecx, edx
	je	SHORT $LN372@Build
	cmp	ecx, eax
	je	SHORT $LN372@Build

; 342  : 		if ((fv1 != v0 && fv1 != v1) || (fv2 != v0 && fv2 != v1)){

	cmp	edi, edx
	je	SHORT $LN375@Build
	cmp	edi, eax
	jne	SHORT $LN374@Build
$LN375@Build:
	cmp	ebx, edx
	je	SHORT $LN373@Build
	cmp	ebx, eax
	je	SHORT $LN373@Build
$LN374@Build:

; 343  : 			Msg("! WARNING: GetNextIndex: Triangle doesn't have all of its vertices");

	mov	ebx, DWORD PTR __imp_?Msg@@YAXPBDZZ
	push	OFFSET ??_C@_0ED@PGPLFOBO@?$CB?5WARNING?3?5GetNextIndex?3?5Triang@
	call	ebx

; 344  : 			Msg("! WARNING: GetNextIndex: Duplicate triangle probably got us derailed");

	push	OFFSET ??_C@_0EF@NPIJGPAE@?$CB?5WARNING?3?5GetNextIndex?3?5Duplic@
	call	ebx
	add	esp, 8
$LN373@Build:

; 345  : 		}
; 346  : 		return fv0;

	mov	edi, DWORD PTR _nv1$2$[esp+96]
	jmp	SHORT $LN371@Build
$LN372@Build:

; 347  : 	}
; 348  : 	if (fv1 != v0 && fv1 != v1){

	cmp	edi, edx
	je	SHORT $LN376@Build
	cmp	edi, eax
	je	SHORT $LN376@Build

; 349  : 		if ((fv0 != v0 && fv0 != v1) || (fv2 != v0 && fv2 != v1)){

	cmp	ecx, edx
	je	SHORT $LN379@Build
	cmp	ecx, eax
	jne	SHORT $LN378@Build
$LN379@Build:
	cmp	ebx, edx
	je	SHORT $LN371@Build
	cmp	ebx, eax
	je	SHORT $LN371@Build
$LN378@Build:

; 350  : 			Msg("! WARNING: GetNextIndex: Triangle doesn't have all of its vertices");

	mov	ebx, DWORD PTR __imp_?Msg@@YAXPBDZZ
	push	OFFSET ??_C@_0ED@PGPLFOBO@?$CB?5WARNING?3?5GetNextIndex?3?5Triang@
	call	ebx

; 351  : 			Msg("! WARNING: GetNextIndex: Duplicate triangle probably got us derailed");

	push	OFFSET ??_C@_0EF@NPIJGPAE@?$CB?5WARNING?3?5GetNextIndex?3?5Duplic@
	call	ebx
	add	esp, 8

; 352  : 		}
; 353  : 		return fv1;

	jmp	SHORT $LN371@Build
$LN376@Build:

; 354  : 	}
; 355  : 	if (fv2 != v0 && fv2 != v1){

	cmp	ebx, edx
	je	SHORT $LN380@Build
	cmp	ebx, eax
	je	SHORT $LN380@Build

; 356  : 		if ((fv0 != v0 && fv0 != v1) || (fv1 != v0 && fv1 != v1)){

	cmp	ecx, edx
	je	SHORT $LN383@Build
	cmp	ecx, eax
	jne	SHORT $LN382@Build
$LN383@Build:
	cmp	edi, edx
	je	SHORT $LN381@Build
	cmp	edi, eax
	je	SHORT $LN381@Build
$LN382@Build:

; 357  : 			Msg("! WARNING: GetNextIndex: Triangle doesn't have all of its vertices");

	mov	edi, DWORD PTR __imp_?Msg@@YAXPBDZZ
	push	OFFSET ??_C@_0ED@PGPLFOBO@?$CB?5WARNING?3?5GetNextIndex?3?5Triang@
	call	edi

; 358  : 			Msg("! WARNING: GetNextIndex: Duplicate triangle probably got us derailed");

	push	OFFSET ??_C@_0EF@NPIJGPAE@?$CB?5WARNING?3?5GetNextIndex?3?5Duplic@
	call	edi
	add	esp, 8
$LN381@Build:

; 359  : 		}
; 360  : 		return fv2;

	mov	edi, ebx
	jmp	SHORT $LN371@Build
$LN380@Build:

; 361  : 	}
; 362  : 	
; 363  : 	// shouldn't get here
; 364  : 	Msg("! WARNING: GetNextIndex: Duplicate triangle sent");

	push	OFFSET ??_C@_0DB@JOONJBKI@?$CB?5WARNING?3?5GetNextIndex?3?5Duplic@
	call	DWORD PTR __imp_?Msg@@YAXPBDZZ
	add	esp, 4

; 365  : 	return -1;

	or	edi, -1
$LN371@Build:

; 530  : 		nv1 = NvStripifier::GetNextIndex(scratchIndices, nextFace);
; 531  : 		scratchIndices.push_back(u16(nv1));

	movzx	ecx, di
	mov	eax, ecx
	mov	DWORD PTR $T8[esp+96], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 730  :         if (_Mylast != _My_data._Myend) {

	mov	eax, DWORD PTR ?scratchIndices@?1??Build@NvStripInfo@@QAEXAAV?$xr_vector@PAVNvEdgeInfo@@V?$xalloc@PAVNvEdgeInfo@@@@@@AAV?$xr_vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@@@Z@4V?$xr_vector@GV?$xalloc@G@@@@A+4
	cmp	eax, DWORD PTR ?scratchIndices@?1??Build@NvStripInfo@@QAEXAAV?$xr_vector@PAVNvEdgeInfo@@V?$xalloc@PAVNvEdgeInfo@@@@@@AAV?$xr_vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@@@Z@4V?$xr_vector@GV?$xalloc@G@@@@A+8
	je	SHORT $LN418@Build

; 713  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

	mov	WORD PTR [eax], cx

; 714  :         _Orphan_range(_Mylast, _Mylast);
; 715  :         _Ty& _Result = *_Mylast;
; 716  :         ++_Mylast;

	add	DWORD PTR ?scratchIndices@?1??Build@NvStripInfo@@QAEXAAV?$xr_vector@PAVNvEdgeInfo@@V?$xalloc@PAVNvEdgeInfo@@@@@@AAV?$xr_vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@@@Z@4V?$xr_vector@GV?$xalloc@G@@@@A+4, 2

; 731  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

	jmp	SHORT $LN417@Build
$LN418@Build:

; 732  :         }
; 733  : 
; 734  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	lea	eax, DWORD PTR $T8[esp+96]
	push	eax
	push	DWORD PTR ?scratchIndices@?1??Build@NvStripInfo@@QAEXAAV?$xr_vector@PAVNvEdgeInfo@@V?$xalloc@PAVNvEdgeInfo@@@@@@AAV?$xr_vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@@@Z@4V?$xr_vector@GV?$xalloc@G@@@@A+4
	call	??$_Emplace_reallocate@G@?$vector@GV?$xalloc@G@@@std@@QAEPAGQAG$$QAG@Z ; std::vector<unsigned short,xalloc<unsigned short> >::_Emplace_reallocate<unsigned short>
$LN417@Build:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 33   : 	NvEdgeInfo *infoIter = edgeInfos[v0];

	mov	eax, DWORD PTR _edgeInfos$[esp+92]
	mov	edx, DWORD PTR _nv0$2$[esp+96]
	mov	eax, DWORD PTR [eax]
	mov	eax, DWORD PTR [eax+edx*4]

; 34   : 	while (infoIter != NULL){

	test	eax, eax
	je	SHORT $LN428@Build
	npad	7
$LL427@Build:

; 35   : 		if (infoIter->m_v0 == v0){

	mov	ecx, DWORD PTR [eax+12]
	cmp	ecx, edx
	jne	SHORT $LN429@Build

; 36   : 			if (infoIter->m_v1 == v1)

	cmp	DWORD PTR [eax+16], edi
	je	SHORT $LN426@Build

; 37   : 				return infoIter;
; 38   : 			else
; 39   : 				infoIter = infoIter->m_nextV0;

	mov	eax, DWORD PTR [eax+20]

; 40   : 		}

	jmp	SHORT $LN434@Build
$LN429@Build:

; 41   : 		else {
; 42   : 			assert(infoIter->m_v1 == v0);
; 43   : 			if (infoIter->m_v0 == v1)

	cmp	ecx, edi
	je	SHORT $LN426@Build

; 44   : 				return infoIter;
; 45   : 			else
; 46   : 				infoIter = infoIter->m_nextV1;

	mov	eax, DWORD PTR [eax+24]
$LN434@Build:

; 34   : 	while (infoIter != NULL){

	test	eax, eax
	jne	SHORT $LL427@Build
$LN428@Build:

; 47   : 		}
; 48   : 	}
; 49   : 	return NULL;

	xor	eax, eax
$LN426@Build:

; 62   : 	return (edgeInfo->m_face0 == faceInfo ? edgeInfo->m_face1 : edgeInfo->m_face0);

	mov	ecx, DWORD PTR [eax+4]
	cmp	ecx, esi
	jne	SHORT $LN424@Build
	mov	esi, DWORD PTR [eax+8]
	jmp	SHORT $LN425@Build
$LN424@Build:
	mov	esi, ecx
$LN425@Build:

; 510  : 	nv0 = v1;
; 511  : 	nv1 = v0;
; 512  : 	nextFace = NvStripifier::FindOtherFace(edgeInfos, nv0, nv1, m_startInfo.m_startFace);
; 513  : 	while (nextFace != NULL && !IsMarked(nextFace))

	mov	DWORD PTR _nextFace$[esp+96], esi
	mov	ecx, esi
	test	esi, esi
	jne	$LL8@Build
$LN598@Build:

; 377  : 	return (faceInfo->m_stripId >= 0) || (IsExperiment() && faceInfo->m_experimentId == m_experimentId);

	mov	ebx, DWORD PTR _tempAllFaces$[esp+96]
	mov	ecx, DWORD PTR _this$1$[esp+96]
$LN579@Build:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	ebp, DWORD PTR _i$1$[esp+96]
	mov	eax, DWORD PTR _backwardFaces$[esp+96]
	sub	ebp, eax
	sar	ebp, 2
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 551  : 	for (int i = numFaces - 1; i >= 0; i--)

	sub	ebp, 1
	js	SHORT $LN455@Build
	lea	esi, DWORD PTR [ecx+12]

; 552  : 		m_faces.push_back(backward[i]);

	lea	edi, DWORD PTR [eax+ebp*4]
	npad	6
$LL456@Build:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 730  :         if (_Mylast != _My_data._Myend) {

	mov	ecx, DWORD PTR [esi+4]
	cmp	ecx, DWORD PTR [esi+8]
	je	SHORT $LN481@Build

; 713  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR [ecx], eax

; 714  :         _Orphan_range(_Mylast, _Mylast);
; 715  :         _Ty& _Result = *_Mylast;
; 716  :         ++_Mylast;

	add	DWORD PTR [esi+4], 4

; 731  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

	jmp	SHORT $LN454@Build
$LN481@Build:

; 732  :         }
; 733  : 
; 734  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	push	edi
	push	ecx
	mov	ecx, esi
	call	??$_Emplace_reallocate@ABQAVNvFaceInfo@@@?$vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@std@@QAEPAPAVNvFaceInfo@@QAPAV2@ABQAV2@@Z ; std::vector<NvFaceInfo *,xalloc<NvFaceInfo *> >::_Emplace_reallocate<NvFaceInfo * const &>
$LN454@Build:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 551  : 	for (int i = numFaces - 1; i >= 0; i--)

	sub	edi, 4
	sub	ebp, 1
	jns	SHORT $LL456@Build
$LN455@Build:

; 556  : 	for (u32 i = 0; i < numFaces; i++)

	cmp	DWORD PTR _numFaces$1$[esp+96], 0
	mov	ebp, DWORD PTR _forwardFaces$[esp+96]
	je	SHORT $LN458@Build
	mov	esi, DWORD PTR _this$1$[esp+96]

; 557  : 		m_faces.push_back(forward[i]);

	mov	edi, ebp
$LL459@Build:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 730  :         if (_Mylast != _My_data._Myend) {

	mov	ecx, DWORD PTR [esi+16]
	cmp	ecx, DWORD PTR [esi+20]
	je	SHORT $LN505@Build

; 713  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR [ecx], eax

; 714  :         _Orphan_range(_Mylast, _Mylast);
; 715  :         _Ty& _Result = *_Mylast;
; 716  :         ++_Mylast;

	add	DWORD PTR [esi+16], 4

; 731  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

	jmp	SHORT $LN457@Build
$LN505@Build:

; 732  :         }
; 733  : 
; 734  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	push	edi
	push	ecx
	lea	ecx, DWORD PTR [esi+12]
	call	??$_Emplace_reallocate@ABQAVNvFaceInfo@@@?$vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@std@@QAEPAPAVNvFaceInfo@@QAPAV2@ABQAV2@@Z ; std::vector<NvFaceInfo *,xalloc<NvFaceInfo *> >::_Emplace_reallocate<NvFaceInfo * const &>
$LN457@Build:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 556  : 	for (u32 i = 0; i < numFaces; i++)

	add	edi, 4
	sub	DWORD PTR _numFaces$1$[esp+96], 1
	jne	SHORT $LL459@Build
$LN458@Build:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	esi, DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
	pop	edi
	test	ebx, ebx
	je	SHORT $LN519@Build
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	ebx
	call	esi
$LN519@Build:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR _backwardFaces$[esp+92]
	test	eax, eax
	je	SHORT $LN531@Build
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	esi
$LN531@Build:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	test	ebp, ebp
	je	SHORT $LN543@Build
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	ebp
	call	esi
$LN543@Build:
	pop	esi
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 539  : }

	pop	ebp
	pop	ebx
	add	esp, 80					; 00000050H
	ret	8
$LN604@Build:

; 447  : 	
; 448  : 	// used in building the strips forward and backward
; 449  : 	static WordVec scratchIndices;

	push	OFFSET ?$TSS0@?1??Build@NvStripInfo@@QAEXAAV?$xr_vector@PAVNvEdgeInfo@@V?$xalloc@PAVNvEdgeInfo@@@@@@AAV?$xr_vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@@@Z@4HA
	call	__Init_thread_header
	add	esp, 4
	cmp	DWORD PTR ?$TSS0@?1??Build@NvStripInfo@@QAEXAAV?$xr_vector@PAVNvEdgeInfo@@V?$xalloc@PAVNvEdgeInfo@@@@@@AAV?$xr_vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@@@Z@4HA, -1
	jne	$LN2@Build
	push	OFFSET ??__FscratchIndices@?1??Build@NvStripInfo@@QAEXAAV?$xr_vector@PAVNvEdgeInfo@@V?$xalloc@PAVNvEdgeInfo@@@@@@AAV?$xr_vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@@@Z@YAXXZ ; `NvStripInfo::Build'::`2'::`dynamic atexit destructor for 'scratchIndices''
	call	_atexit
	push	OFFSET ?$TSS0@?1??Build@NvStripInfo@@QAEXAAV?$xr_vector@PAVNvEdgeInfo@@V?$xalloc@PAVNvEdgeInfo@@@@@@AAV?$xr_vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@@@Z@4HA
	call	__Init_thread_footer
	add	esp, 8
	jmp	$LN2@Build
?Build@NvStripInfo@@QAEXAAV?$xr_vector@PAVNvEdgeInfo@@V?$xalloc@PAVNvEdgeInfo@@@@@@AAV?$xr_vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@@@Z ENDP ; NvStripInfo::Build
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??__FscratchIndices@?1??Build@NvStripInfo@@QAEXAAV?$xr_vector@PAVNvEdgeInfo@@V?$xalloc@PAVNvEdgeInfo@@@@@@AAV?$xr_vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@@@Z@YAXXZ
text$yd	SEGMENT
??__FscratchIndices@?1??Build@NvStripInfo@@QAEXAAV?$xr_vector@PAVNvEdgeInfo@@V?$xalloc@PAVNvEdgeInfo@@@@@@AAV?$xr_vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@@@Z@YAXXZ PROC ; `NvStripInfo::Build'::`2'::`dynamic atexit destructor for 'scratchIndices'', COMDAT

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR ?scratchIndices@?1??Build@NvStripInfo@@QAEXAAV?$xr_vector@PAVNvEdgeInfo@@V?$xalloc@PAVNvEdgeInfo@@@@@@AAV?$xr_vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@@@Z@4V?$xr_vector@GV?$xalloc@G@@@@A
	test	eax, eax
	je	SHORT $LN8@dynamic
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR ?scratchIndices@?1??Build@NvStripInfo@@QAEXAAV?$xr_vector@PAVNvEdgeInfo@@V?$xalloc@PAVNvEdgeInfo@@@@@@AAV?$xr_vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@@@Z@4V?$xr_vector@GV?$xalloc@G@@@@A, 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR ?scratchIndices@?1??Build@NvStripInfo@@QAEXAAV?$xr_vector@PAVNvEdgeInfo@@V?$xalloc@PAVNvEdgeInfo@@@@@@AAV?$xr_vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@@@Z@4V?$xr_vector@GV?$xalloc@G@@@@A+4, 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR ?scratchIndices@?1??Build@NvStripInfo@@QAEXAAV?$xr_vector@PAVNvEdgeInfo@@V?$xalloc@PAVNvEdgeInfo@@@@@@AAV?$xr_vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@@@Z@4V?$xr_vector@GV?$xalloc@G@@@@A+8, 0
$LN8@dynamic:
	ret	0
??__FscratchIndices@?1??Build@NvStripInfo@@QAEXAAV?$xr_vector@PAVNvEdgeInfo@@V?$xalloc@PAVNvEdgeInfo@@@@@@AAV?$xr_vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@@@Z@YAXXZ ENDP ; `NvStripInfo::Build'::`2'::`dynamic atexit destructor for 'scratchIndices''
text$yd	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
_TEXT	SEGMENT
_this$1$ = -4						; size = 4
_forward$ = 8						; size = 4
_backward$ = 12						; size = 4
?Combine@NvStripInfo@@QAEXABV?$xr_vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@@0@Z PROC ; NvStripInfo::Combine
; _this$ = ecx

; 547  : void NvStripInfo::Combine(const NvFaceInfoVec &forward, const NvFaceInfoVec &backward){

	push	ecx
	push	ebx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	ebx, DWORD PTR _backward$[esp+4]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 547  : void NvStripInfo::Combine(const NvFaceInfoVec &forward, const NvFaceInfoVec &backward){

	mov	eax, ecx
	push	ebp
	push	esi
	push	edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	esi, DWORD PTR [ebx+4]
	sub	esi, DWORD PTR [ebx]
	sar	esi, 2
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 551  : 	for (int i = numFaces - 1; i >= 0; i--)

	sub	esi, 1
	mov	DWORD PTR _this$1$[esp+20], eax
	js	SHORT $LN3@Combine
	lea	edi, DWORD PTR [eax+12]
	npad	1
$LL4@Combine:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 119  :         _Ptr += _Off;

	mov	eax, DWORD PTR [ebx]

; 730  :         if (_Mylast != _My_data._Myend) {

	mov	ecx, DWORD PTR [edi+4]

; 119  :         _Ptr += _Off;

	lea	eax, DWORD PTR [eax+esi*4]

; 730  :         if (_Mylast != _My_data._Myend) {

	cmp	ecx, DWORD PTR [edi+8]
	je	SHORT $LN29@Combine

; 713  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax

; 714  :         _Orphan_range(_Mylast, _Mylast);
; 715  :         _Ty& _Result = *_Mylast;
; 716  :         ++_Mylast;

	add	DWORD PTR [edi+4], 4

; 731  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

	jmp	SHORT $LN2@Combine
$LN29@Combine:

; 732  :         }
; 733  : 
; 734  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	push	eax
	push	ecx
	mov	ecx, edi
	call	??$_Emplace_reallocate@ABQAVNvFaceInfo@@@?$vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@std@@QAEPAPAVNvFaceInfo@@QAPAV2@ABQAV2@@Z ; std::vector<NvFaceInfo *,xalloc<NvFaceInfo *> >::_Emplace_reallocate<NvFaceInfo * const &>
$LN2@Combine:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 551  : 	for (int i = numFaces - 1; i >= 0; i--)

	sub	esi, 1
	jns	SHORT $LL4@Combine
	mov	eax, DWORD PTR _this$1$[esp+20]
$LN3@Combine:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	ebp, DWORD PTR _forward$[esp+16]
	xor	esi, esi
	mov	ebx, DWORD PTR [ebp+4]
	sub	ebx, DWORD PTR [ebp]
	sar	ebx, 2
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 556  : 	for (u32 i = 0; i < numFaces; i++)

	test	ebx, ebx
	je	SHORT $LN6@Combine
	lea	edi, DWORD PTR [eax+12]
	npad	1
$LL7@Combine:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 119  :         _Ptr += _Off;

	mov	eax, DWORD PTR [ebp]

; 730  :         if (_Mylast != _My_data._Myend) {

	mov	ecx, DWORD PTR [edi+4]

; 119  :         _Ptr += _Off;

	lea	eax, DWORD PTR [eax+esi*4]

; 730  :         if (_Mylast != _My_data._Myend) {

	cmp	ecx, DWORD PTR [edi+8]
	je	SHORT $LN53@Combine

; 713  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax

; 714  :         _Orphan_range(_Mylast, _Mylast);
; 715  :         _Ty& _Result = *_Mylast;
; 716  :         ++_Mylast;

	add	DWORD PTR [edi+4], 4

; 731  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

	jmp	SHORT $LN5@Combine
$LN53@Combine:

; 732  :         }
; 733  : 
; 734  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	push	eax
	push	ecx
	mov	ecx, edi
	call	??$_Emplace_reallocate@ABQAVNvFaceInfo@@@?$vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@std@@QAEPAPAVNvFaceInfo@@QAPAV2@ABQAV2@@Z ; std::vector<NvFaceInfo *,xalloc<NvFaceInfo *> >::_Emplace_reallocate<NvFaceInfo * const &>
$LN5@Combine:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 556  : 	for (u32 i = 0; i < numFaces; i++)

	inc	esi
	cmp	esi, ebx
	jb	SHORT $LL7@Combine
$LN6@Combine:
	pop	edi

; 557  : 		m_faces.push_back(forward[i]);
; 558  : }

	pop	esi
	pop	ebp
	pop	ebx
	pop	ecx
	ret	8
?Combine@NvStripInfo@@QAEXABV?$xr_vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@@0@Z ENDP ; NvStripInfo::Combine
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
_TEXT	SEGMENT
_faceInfo$ = 8						; size = 4
_edgeInfos$ = 12					; size = 4
?SharesEdge@NvStripInfo@@QAE_NPBVNvFaceInfo@@AAV?$xr_vector@PAVNvEdgeInfo@@V?$xalloc@PAVNvEdgeInfo@@@@@@@Z PROC ; NvStripInfo::SharesEdge
; _this$ = ecx

; 567  : {

	push	ebx
	push	ebp

; 33   : 	NvEdgeInfo *infoIter = edgeInfos[v0];

	mov	ebp, DWORD PTR _edgeInfos$[esp+4]

; 567  : {

	push	esi
	push	edi

; 568  : 	//check v0->v1 edge
; 569  : 	NvEdgeInfo* currEdge = NvStripifier::FindEdgeInfo(edgeInfos, faceInfo->m_v0, faceInfo->m_v1);

	mov	edi, DWORD PTR _faceInfo$[esp+12]
	mov	esi, ecx

; 33   : 	NvEdgeInfo *infoIter = edgeInfos[v0];

	mov	eax, DWORD PTR [ebp]

; 568  : 	//check v0->v1 edge
; 569  : 	NvEdgeInfo* currEdge = NvStripifier::FindEdgeInfo(edgeInfos, faceInfo->m_v0, faceInfo->m_v1);

	mov	ebx, DWORD PTR [edi]
	mov	ecx, DWORD PTR [edi+4]

; 33   : 	NvEdgeInfo *infoIter = edgeInfos[v0];

	mov	edx, DWORD PTR [eax+ebx*4]

; 34   : 	while (infoIter != NULL){

	test	edx, edx
	je	SHORT $LN11@SharesEdge
	npad	3
$LL10@SharesEdge:

; 35   : 		if (infoIter->m_v0 == v0){

	mov	eax, DWORD PTR [edx+12]
	cmp	eax, ebx
	jne	SHORT $LN12@SharesEdge

; 36   : 			if (infoIter->m_v1 == v1)

	cmp	DWORD PTR [edx+16], ecx
	je	SHORT $LN9@SharesEdge

; 37   : 				return infoIter;
; 38   : 			else
; 39   : 				infoIter = infoIter->m_nextV0;

	mov	edx, DWORD PTR [edx+20]

; 40   : 		}

	jmp	SHORT $LN17@SharesEdge
$LN12@SharesEdge:

; 41   : 		else {
; 42   : 			assert(infoIter->m_v1 == v0);
; 43   : 			if (infoIter->m_v0 == v1)

	cmp	eax, ecx
	je	SHORT $LN9@SharesEdge

; 44   : 				return infoIter;
; 45   : 			else
; 46   : 				infoIter = infoIter->m_nextV1;

	mov	edx, DWORD PTR [edx+24]
$LN17@SharesEdge:

; 34   : 	while (infoIter != NULL){

	test	edx, edx
	jne	SHORT $LL10@SharesEdge
$LN11@SharesEdge:

; 47   : 		}
; 48   : 	}
; 49   : 	return NULL;

	xor	edx, edx
$LN9@SharesEdge:

; 571  : 	if(IsInStrip(currEdge->m_face0) || IsInStrip(currEdge->m_face1))

	mov	eax, DWORD PTR [edx+4]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.h

; 135  : 		if(faceInfo == NULL)

	test	eax, eax
	je	SHORT $LN71@SharesEdge

; 136  : 			return false;
; 137  : 		  
; 138  : 		return (m_experimentId >= 0 ? faceInfo->m_testStripId == m_stripId : faceInfo->m_stripId == m_stripId);

	cmp	DWORD PTR [esi+28], 0
	jl	SHORT $LN39@SharesEdge
	mov	eax, DWORD PTR [eax+16]
	jmp	SHORT $LN78@SharesEdge
$LN39@SharesEdge:
	mov	eax, DWORD PTR [eax+12]
$LN78@SharesEdge:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 571  : 	if(IsInStrip(currEdge->m_face0) || IsInStrip(currEdge->m_face1))

	cmp	eax, DWORD PTR [esi+24]
	sete	al
	test	al, al
	jne	$LN3@SharesEdge
$LN71@SharesEdge:
	mov	eax, DWORD PTR [edx+8]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.h

; 135  : 		if(faceInfo == NULL)

	test	eax, eax
	je	SHORT $LN72@SharesEdge

; 136  : 			return false;
; 137  : 		  
; 138  : 		return (m_experimentId >= 0 ? faceInfo->m_testStripId == m_stripId : faceInfo->m_stripId == m_stripId);

	cmp	DWORD PTR [esi+28], 0
	jl	SHORT $LN44@SharesEdge
	mov	eax, DWORD PTR [eax+16]
	jmp	SHORT $LN79@SharesEdge
$LN44@SharesEdge:
	mov	eax, DWORD PTR [eax+12]
$LN79@SharesEdge:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 571  : 	if(IsInStrip(currEdge->m_face0) || IsInStrip(currEdge->m_face1))

	cmp	eax, DWORD PTR [esi+24]
	sete	al
	test	al, al
	jne	$LN3@SharesEdge
$LN72@SharesEdge:

; 572  : 		return true;
; 573  : 	
; 574  : 	//check v1->v2 edge
; 575  : 	currEdge = NvStripifier::FindEdgeInfo(edgeInfos, faceInfo->m_v1, faceInfo->m_v2);

	mov	edi, DWORD PTR [edi+8]
	mov	edx, ecx
	push	edi
	mov	ecx, ebp
	call	?FindEdgeInfo@NvStripifier@@KAPAVNvEdgeInfo@@AAV?$xr_vector@PAVNvEdgeInfo@@V?$xalloc@PAVNvEdgeInfo@@@@@@HH@Z ; NvStripifier::FindEdgeInfo
	mov	edx, eax
	add	esp, 4

; 577  : 	if(IsInStrip(currEdge->m_face0) || IsInStrip(currEdge->m_face1))

	mov	eax, DWORD PTR [edx+4]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.h

; 135  : 		if(faceInfo == NULL)

	test	eax, eax
	je	SHORT $LN73@SharesEdge

; 136  : 			return false;
; 137  : 		  
; 138  : 		return (m_experimentId >= 0 ? faceInfo->m_testStripId == m_stripId : faceInfo->m_stripId == m_stripId);

	cmp	DWORD PTR [esi+28], 0
	jl	SHORT $LN49@SharesEdge
	mov	ecx, DWORD PTR [eax+16]
	cmp	ecx, DWORD PTR [esi+24]
	jmp	SHORT $LN80@SharesEdge
$LN49@SharesEdge:
	mov	eax, DWORD PTR [eax+12]
	cmp	eax, DWORD PTR [esi+24]
$LN80@SharesEdge:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 577  : 	if(IsInStrip(currEdge->m_face0) || IsInStrip(currEdge->m_face1))

	sete	al
	test	al, al
	jne	SHORT $LN3@SharesEdge
$LN73@SharesEdge:
	mov	eax, DWORD PTR [edx+8]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.h

; 135  : 		if(faceInfo == NULL)

	test	eax, eax
	je	SHORT $LN74@SharesEdge

; 136  : 			return false;
; 137  : 		  
; 138  : 		return (m_experimentId >= 0 ? faceInfo->m_testStripId == m_stripId : faceInfo->m_stripId == m_stripId);

	cmp	DWORD PTR [esi+28], 0
	jl	SHORT $LN54@SharesEdge
	mov	eax, DWORD PTR [eax+16]
	jmp	SHORT $LN81@SharesEdge
$LN54@SharesEdge:
	mov	eax, DWORD PTR [eax+12]
$LN81@SharesEdge:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 577  : 	if(IsInStrip(currEdge->m_face0) || IsInStrip(currEdge->m_face1))

	cmp	eax, DWORD PTR [esi+24]
	sete	al
	test	al, al
	jne	SHORT $LN3@SharesEdge
$LN74@SharesEdge:

; 578  : 		return true;
; 579  : 	
; 580  : 	//check v2->v0 edge
; 581  : 	currEdge = NvStripifier::FindEdgeInfo(edgeInfos, faceInfo->m_v2, faceInfo->m_v0);

	push	ebx
	mov	edx, edi
	mov	ecx, ebp
	call	?FindEdgeInfo@NvStripifier@@KAPAVNvEdgeInfo@@AAV?$xr_vector@PAVNvEdgeInfo@@V?$xalloc@PAVNvEdgeInfo@@@@@@HH@Z ; NvStripifier::FindEdgeInfo
	mov	edx, eax
	add	esp, 4

; 583  : 	if(IsInStrip(currEdge->m_face0) || IsInStrip(currEdge->m_face1))

	mov	eax, DWORD PTR [edx+4]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.h

; 135  : 		if(faceInfo == NULL)

	test	eax, eax
	je	SHORT $LN75@SharesEdge

; 136  : 			return false;
; 137  : 		  
; 138  : 		return (m_experimentId >= 0 ? faceInfo->m_testStripId == m_stripId : faceInfo->m_stripId == m_stripId);

	cmp	DWORD PTR [esi+28], 0
	jl	SHORT $LN59@SharesEdge
	mov	ecx, DWORD PTR [eax+16]
	cmp	ecx, DWORD PTR [esi+24]
	jmp	SHORT $LN82@SharesEdge
$LN59@SharesEdge:
	mov	eax, DWORD PTR [eax+12]
	cmp	eax, DWORD PTR [esi+24]
$LN82@SharesEdge:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 583  : 	if(IsInStrip(currEdge->m_face0) || IsInStrip(currEdge->m_face1))

	sete	al
	test	al, al
	jne	SHORT $LN3@SharesEdge
$LN75@SharesEdge:
	mov	eax, DWORD PTR [edx+8]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.h

; 135  : 		if(faceInfo == NULL)

	test	eax, eax
	je	SHORT $LN76@SharesEdge

; 136  : 			return false;
; 137  : 		  
; 138  : 		return (m_experimentId >= 0 ? faceInfo->m_testStripId == m_stripId : faceInfo->m_stripId == m_stripId);

	cmp	DWORD PTR [esi+28], 0
	jl	SHORT $LN64@SharesEdge
	mov	eax, DWORD PTR [eax+16]
	jmp	SHORT $LN83@SharesEdge
$LN64@SharesEdge:
	mov	eax, DWORD PTR [eax+12]
$LN83@SharesEdge:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 583  : 	if(IsInStrip(currEdge->m_face0) || IsInStrip(currEdge->m_face1))

	cmp	eax, DWORD PTR [esi+24]
	sete	al
	test	al, al
	je	SHORT $LN76@SharesEdge
$LN3@SharesEdge:
	pop	edi

; 584  : 		return true;
; 585  : 	
; 586  : 	return false;
; 587  : 	
; 588  : }

	pop	esi
	pop	ebp
	mov	al, 1
	pop	ebx
	ret	8
$LN76@SharesEdge:
	pop	edi
	pop	esi
	pop	ebp
	xor	al, al
	pop	ebx
	ret	8
?SharesEdge@NvStripInfo@@QAE_NPBVNvFaceInfo@@AAV?$xr_vector@PAVNvEdgeInfo@@V?$xalloc@PAVNvEdgeInfo@@@@@@@Z ENDP ; NvStripInfo::SharesEdge
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
_TEXT	SEGMENT
_strip$1 = -8						; size = 4
_numStrips$1$ = -4					; size = 4
_allStrips$ = 8						; size = 4
_strips$ = 12						; size = 4
?CommitStrips@NvStripifier@@IAEXAAV?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@ABV2@@Z PROC ; NvStripifier::CommitStrips
; _this$dead$ = ecx

; 598  : {	

	sub	esp, 8
	push	ebx
	push	edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	edi, DWORD PTR _strips$[esp+12]
	xor	ebx, ebx
	mov	eax, DWORD PTR [edi+4]
	sub	eax, DWORD PTR [edi]
	sar	eax, 2
	mov	DWORD PTR _numStrips$1$[esp+16], eax
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 601  : 	for (int i = 0; i < numStrips; i++){

	test	eax, eax
	jle	SHORT $LN3@CommitStri
	push	ebp
	push	esi
	npad	3
$LL4@CommitStri:

; 604  : 		NvStripInfo *strip = strips[i];

	mov	eax, DWORD PTR [edi]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 730  :         if (_Mylast != _My_data._Myend) {

	mov	ecx, DWORD PTR _allStrips$[esp+20]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 604  : 		NvStripInfo *strip = strips[i];

	mov	esi, DWORD PTR [eax+ebx*4]
	mov	DWORD PTR _strip$1[esp+24], esi

; 605  : 		strip->m_experimentId = -1;

	mov	DWORD PTR [esi+28], -1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 730  :         if (_Mylast != _My_data._Myend) {

	mov	eax, DWORD PTR [ecx+4]
	cmp	eax, DWORD PTR [ecx+8]
	je	SHORT $LN29@CommitStri

; 713  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

	mov	DWORD PTR [eax], esi

; 714  :         _Orphan_range(_Mylast, _Mylast);
; 715  :         _Ty& _Result = *_Mylast;
; 716  :         ++_Mylast;

	add	DWORD PTR [ecx+4], 4

; 731  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

	jmp	SHORT $LN36@CommitStri
$LN29@CommitStri:

; 732  :         }
; 733  : 
; 734  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	lea	edx, DWORD PTR _strip$1[esp+24]
	push	edx
	push	eax
	call	??$_Emplace_reallocate@ABQAVNvStripInfo@@@?$vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@std@@QAEPAPAVNvStripInfo@@QAPAV2@ABQAV2@@Z ; std::vector<NvStripInfo *,xalloc<NvStripInfo *> >::_Emplace_reallocate<NvStripInfo * const &>
$LN36@CommitStri:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 612  : 		const NvFaceInfoVec &faces = strips[i]->m_faces;

	mov	eax, DWORD PTR [edi]
	mov	ebp, DWORD PTR [eax+ebx*4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 119  :         _Ptr += _Off;

	xor	eax, eax

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	edi, DWORD PTR [ebp+16]
	sub	edi, DWORD PTR [ebp+12]
	sar	edi, 2
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 615  : 		for (int j = 0; j < numFaces; j++)

	test	edi, edi
	jle	SHORT $LN2@CommitStri
$LL7@CommitStri:

; 616  : 		{
; 617  : 			strip->MarkTriangle(faces[j]);

	mov	ecx, DWORD PTR [ebp+12]
	mov	edx, DWORD PTR [ecx+eax*4]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.h

; 131  : 	inline bool IsExperiment () const { return m_experimentId >= 0; }

	mov	ecx, DWORD PTR [esi+28]
	test	ecx, ecx
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 388  : 	if (IsExperiment()){

	js	SHORT $LN64@CommitStri

; 389  : 		faceInfo->m_experimentId = m_experimentId;

	mov	DWORD PTR [edx+20], ecx

; 390  : 		faceInfo->m_testStripId  = m_stripId;

	mov	ecx, DWORD PTR [esi+24]
	mov	DWORD PTR [edx+16], ecx

; 391  :     }

	jmp	SHORT $LN5@CommitStri
$LN64@CommitStri:

; 392  : 	else{
; 393  : 		assert(faceInfo->m_stripId == -1);
; 394  : 		faceInfo->m_experimentId = -1;

	mov	DWORD PTR [edx+20], -1

; 395  : 		faceInfo->m_stripId      = m_stripId;

	mov	ecx, DWORD PTR [esi+24]
	mov	DWORD PTR [edx+12], ecx
$LN5@CommitStri:

; 615  : 		for (int j = 0; j < numFaces; j++)

	inc	eax
	cmp	eax, edi
	jl	SHORT $LL7@CommitStri
$LN2@CommitStri:

; 601  : 	for (int i = 0; i < numStrips; i++){

	mov	edi, DWORD PTR _strips$[esp+20]
	inc	ebx
	cmp	ebx, DWORD PTR _numStrips$1$[esp+24]
	jl	SHORT $LL4@CommitStri
	pop	esi
	pop	ebp
$LN3@CommitStri:
	pop	edi

; 618  : 		}
; 619  : 	}
; 620  : }

	pop	ebx
	add	esp, 8
	ret	8
?CommitStrips@NvStripifier@@IAEXAAV?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@ABV2@@Z ENDP ; NvStripifier::CommitStrips
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
_TEXT	SEGMENT
_faceInfos$dead$ = 8					; size = 4
_edgeInfos$ = 12					; size = 4
_untouchedFace$1$ = 16					; size = 4
_strip$ = 16						; size = 4
_startInfo$ = 20					; size = 4
?FindTraversal@NvStripifier@@IAE_NAAV?$xr_vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@@AAV?$xr_vector@PAVNvEdgeInfo@@V?$xalloc@PAVNvEdgeInfo@@@@@@PAVNvStripInfo@@AAVNvStripStartInfo@@@Z PROC ; NvStripifier::FindTraversal
; _this$dead$ = ecx

; 631  : 								 NvStripStartInfo &startInfo){

	push	ebx

; 632  : 	
; 633  : 	// if the strip was v0->v1 on the edge, then v1 will be a vertex in the next edge.
; 634  : 	int v = (strip->m_startInfo.m_toV1 ? strip->m_startInfo.m_startEdge->m_v1 : strip->m_startInfo.m_startEdge->m_v0);

	mov	ebx, DWORD PTR _strip$[esp]
	push	ebp
	push	esi
	push	edi
	cmp	BYTE PTR [ebx+8], 0
	mov	eax, DWORD PTR [ebx+4]
	je	SHORT $LN10@FindTraver
	mov	ebp, DWORD PTR [eax+16]
	jmp	SHORT $LN11@FindTraver
$LN10@FindTraver:
	mov	ebp, DWORD PTR [eax+12]
$LN11@FindTraver:

; 635  : 	
; 636  : 	NvFaceInfo *untouchedFace = NULL;
; 637  : 	NvEdgeInfo *edgeIter      = edgeInfos[v];

	mov	ecx, DWORD PTR _edgeInfos$[esp+12]
	mov	DWORD PTR _untouchedFace$1$[esp+12], 0
	mov	eax, DWORD PTR [ecx]
	mov	esi, DWORD PTR [eax+ebp*4]

; 638  : 	while (edgeIter != NULL){

	test	esi, esi
	je	SHORT $LN3@FindTraver
	npad	2
$LL2@FindTraver:

; 639  : 		NvFaceInfo *face0 = edgeIter->m_face0;

	mov	edx, DWORD PTR [esi+4]

; 640  : 		NvFaceInfo *face1 = edgeIter->m_face1;

	mov	ecx, DWORD PTR [esi+8]

; 641  : 		if ((face0 != NULL && !strip->IsInStrip(face0)) && face1 != NULL && !strip->IsMarked(face1))

	test	edx, edx
	je	SHORT $LN4@FindTraver
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.h

; 138  : 		return (m_experimentId >= 0 ? faceInfo->m_testStripId == m_stripId : faceInfo->m_stripId == m_stripId);

	mov	edi, DWORD PTR [ebx+28]
	test	edi, edi
	js	SHORT $LN34@FindTraver
	mov	eax, DWORD PTR [edx+16]
	jmp	SHORT $LN63@FindTraver
$LN34@FindTraver:
	mov	eax, DWORD PTR [edx+12]
$LN63@FindTraver:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 641  : 		if ((face0 != NULL && !strip->IsInStrip(face0)) && face1 != NULL && !strip->IsMarked(face1))

	cmp	eax, DWORD PTR [ebx+24]
	sete	al
	test	al, al
	jne	SHORT $LN4@FindTraver
	test	ecx, ecx
	je	$LN51@FindTraver

; 377  : 	return (faceInfo->m_stripId >= 0) || (IsExperiment() && faceInfo->m_experimentId == m_experimentId);

	cmp	DWORD PTR [ecx+12], 0
	jge	SHORT $LN62@FindTraver
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.h

; 131  : 	inline bool IsExperiment () const { return m_experimentId >= 0; }

	test	edi, edi
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 377  : 	return (faceInfo->m_stripId >= 0) || (IsExperiment() && faceInfo->m_experimentId == m_experimentId);

	js	SHORT $LN56@FindTraver
	cmp	DWORD PTR [ecx+20], edi
	je	SHORT $LN62@FindTraver
$LN56@FindTraver:

; 642  : 		{
; 643  : 			untouchedFace = face1;

	mov	DWORD PTR _untouchedFace$1$[esp+12], ecx
$LN65@FindTraver:

; 653  : 	}
; 654  : 	
; 655  : 	startInfo.m_startFace = untouchedFace;

	mov	ecx, DWORD PTR _edgeInfos$[esp+12]
$LN3@FindTraver:
	mov	edi, DWORD PTR _startInfo$[esp+12]
	mov	eax, DWORD PTR _untouchedFace$1$[esp+12]
	mov	DWORD PTR [edi], eax

; 656  : 	startInfo.m_startEdge = edgeIter;

	mov	DWORD PTR [edi+4], esi

; 657  : 	if (edgeIter != NULL)

	test	esi, esi
	je	$LN8@FindTraver

; 658  : 	{
; 659  : 		if(strip->SharesEdge(startInfo.m_startFace, edgeInfos))

	push	ecx
	push	eax
	mov	ecx, ebx
	call	?SharesEdge@NvStripInfo@@QAE_NPBVNvFaceInfo@@AAV?$xr_vector@PAVNvEdgeInfo@@V?$xalloc@PAVNvEdgeInfo@@@@@@@Z ; NvStripInfo::SharesEdge
	test	al, al
	je	SHORT $LN7@FindTraver

; 660  : 			startInfo.m_toV1 = (edgeIter->m_v0 == v);  //note! used to be m_v1

	cmp	DWORD PTR [esi+12], ebp

; 663  : 	}
; 664  : 	return (startInfo.m_startFace != NULL);

	sete	al
	cmp	DWORD PTR _untouchedFace$1$[esp+12], 0
	mov	BYTE PTR [edi+8], al
	pop	edi
	pop	esi
	pop	ebp
	setne	al
	pop	ebx

; 665  : }

	ret	16					; 00000010H
$LN4@FindTraver:

; 646  : 		if ((face1 != NULL && !strip->IsInStrip(face1)) && face0 != NULL && !strip->IsMarked(face0)){

	test	ecx, ecx
	je	SHORT $LN51@FindTraver
$LN62@FindTraver:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.h

; 138  : 		return (m_experimentId >= 0 ? faceInfo->m_testStripId == m_stripId : faceInfo->m_stripId == m_stripId);

	mov	edi, DWORD PTR [ebx+28]
	test	edi, edi
	js	SHORT $LN46@FindTraver
	mov	eax, DWORD PTR [ecx+16]
	jmp	SHORT $LN64@FindTraver
$LN46@FindTraver:
	mov	eax, DWORD PTR [ecx+12]
$LN64@FindTraver:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 646  : 		if ((face1 != NULL && !strip->IsInStrip(face1)) && face0 != NULL && !strip->IsMarked(face0)){

	cmp	eax, DWORD PTR [ebx+24]
	sete	al
	test	al, al
	jne	SHORT $LN51@FindTraver
	test	edx, edx
	je	SHORT $LN51@FindTraver

; 377  : 	return (faceInfo->m_stripId >= 0) || (IsExperiment() && faceInfo->m_experimentId == m_experimentId);

	cmp	DWORD PTR [edx+12], 0
	jge	SHORT $LN51@FindTraver
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.h

; 131  : 	inline bool IsExperiment () const { return m_experimentId >= 0; }

	test	edi, edi
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 377  : 	return (faceInfo->m_stripId >= 0) || (IsExperiment() && faceInfo->m_experimentId == m_experimentId);

	js	SHORT $LN57@FindTraver
	cmp	DWORD PTR [edx+20], edi
	jne	SHORT $LN57@FindTraver
$LN51@FindTraver:

; 648  : 			break;
; 649  : 		}
; 650  : 		
; 651  : 		// find the next edgeIter
; 652  : 		edgeIter = (edgeIter->m_v0 == v ? edgeIter->m_nextV0 : edgeIter->m_nextV1);

	cmp	DWORD PTR [esi+12], ebp
	jne	SHORT $LN12@FindTraver
	mov	esi, DWORD PTR [esi+20]
	jmp	SHORT $LN13@FindTraver
$LN12@FindTraver:
	mov	esi, DWORD PTR [esi+24]
$LN13@FindTraver:

; 638  : 	while (edgeIter != NULL){

	test	esi, esi
	jne	$LL2@FindTraver

; 646  : 		if ((face1 != NULL && !strip->IsInStrip(face1)) && face0 != NULL && !strip->IsMarked(face0)){

	mov	eax, DWORD PTR _startInfo$[esp+12]

; 663  : 	}
; 664  : 	return (startInfo.m_startFace != NULL);

	cmp	DWORD PTR _untouchedFace$1$[esp+12], esi
	pop	edi
	mov	DWORD PTR [eax], esi
	mov	DWORD PTR [eax+4], esi
	setne	al
	pop	esi
	pop	ebp
	pop	ebx

; 665  : }

	ret	16					; 00000010H
$LN57@FindTraver:

; 647  : 			untouchedFace = face0;

	mov	DWORD PTR _untouchedFace$1$[esp+12], edx
	jmp	$LN65@FindTraver
$LN7@FindTraver:

; 661  : 		else
; 662  : 			startInfo.m_toV1 = (edgeIter->m_v1 == v);

	cmp	DWORD PTR [esi+16], ebp

; 663  : 	}
; 664  : 	return (startInfo.m_startFace != NULL);

	sete	al
	mov	BYTE PTR [edi+8], al
$LN8@FindTraver:
	cmp	DWORD PTR _untouchedFace$1$[esp+12], 0
	pop	edi
	pop	esi
	pop	ebp
	setne	al
	pop	ebx

; 665  : }

	ret	16					; 00000010H
?FindTraversal@NvStripifier@@IAE_NAAV?$xr_vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@@AAV?$xr_vector@PAVNvEdgeInfo@@V?$xalloc@PAVNvEdgeInfo@@@@@@PAVNvStripInfo@@AAVNvStripStartInfo@@@Z ENDP ; NvStripifier::FindTraversal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\VertexCache.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\VertexCache.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\VertexCache.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\VertexCache.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\VertexCache.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\VertexCache.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\VertexCache.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\VertexCache.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\VertexCache.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\VertexCache.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\VertexCache.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\VertexCache.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\VertexCache.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\VertexCache.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\VertexCache.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\VertexCache.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\VertexCache.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\VertexCache.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\VertexCache.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\VertexCache.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\VertexCache.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\VertexCache.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\VertexCache.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
_TEXT	SEGMENT
$T1 = -28						; size = 4
_bestIndex$1$ = -24					; size = 4
_this$1$ = -24						; size = 4
tv3604 = -20						; size = 4
_bestNumHits$1$ = -16					; size = 4
$T2 = -16						; size = 4
_tempFaceList$ = -12					; size = 12
_bVisitedList$1$ = 8					; size = 4
_allStrips$ = 8						; size = 4
$T3 = 12						; size = 4
_allBigStrips$ = 12					; size = 4
_faceList$ = 16						; size = 4
?RemoveSmallStrips@NvStripifier@@IAEXAAV?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@0AAV?$xr_vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@@@Z PROC ; NvStripifier::RemoveSmallStrips
; _this$ = ecx

; 676  : {

	sub	esp, 28					; 0000001cH
	push	ebx
	push	ebp
	push	esi
	mov	DWORD PTR _this$1$[esp+40], ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	xor	ebp, ebp
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 677  : 	faceList.clear();

	mov	ecx, DWORD PTR _faceList$[esp+36]

; 681  : 	for(int i = 0; i < allStrips.size(); i++)

	xor	ebx, ebx
	push	edi
	mov	edi, DWORD PTR _allBigStrips$[esp+40]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR _tempFaceList$[esp+44], 0
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 677  : 	faceList.clear();

	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [ecx+4], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	xor	ecx, ecx
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 678  : 	allBigStrips.clear();  //make sure these are empty

	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR [edi+4], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	eax, DWORD PTR _allStrips$[esp+40]

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR $T1[esp+44], ecx
	mov	DWORD PTR _tempFaceList$[esp+48], ecx
	mov	DWORD PTR _tempFaceList$[esp+52], ebp

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	esi, DWORD PTR [eax]
	mov	eax, DWORD PTR [eax+4]
	sub	eax, esi
	sar	eax, 2
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 681  : 	for(int i = 0; i < allStrips.size(); i++)

	test	eax, eax
	je	$LN3@RemoveSmal
	npad	3
$LL4@RemoveSmal:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1535 :         auto& _My_data = _Mypair._Myval2;

	mov	ecx, DWORD PTR [esi+ebx*4]

; 119  :         _Ptr += _Off;

	lea	edx, DWORD PTR [esi+ebx*4]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 683  : 		if(allStrips[i]->m_faces.size() < minStripLength)

	mov	edi, DWORD PTR _this$1$[esp+44]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	eax, DWORD PTR [ecx+16]
	sub	eax, DWORD PTR [ecx+12]
	sar	eax, 2
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 683  : 		if(allStrips[i]->m_faces.size() < minStripLength)

	cmp	eax, DWORD PTR [edi+16]
	mov	edi, DWORD PTR _allBigStrips$[esp+40]
	jae	$LN156@RemoveSmal

; 686  : 			for(int j = 0; j < allStrips[i]->m_faces.size(); j++)

	xor	edi, edi
	test	eax, eax
	je	SHORT $LN117@RemoveSmal
	mov	edx, DWORD PTR $T1[esp+44]
	npad	6
$LL55@RemoveSmal:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 119  :         _Ptr += _Off;

	mov	eax, DWORD PTR [esi+ebx*4]
	mov	eax, DWORD PTR [eax+12]
	lea	eax, DWORD PTR [eax+edi*4]

; 730  :         if (_Mylast != _My_data._Myend) {

	cmp	edx, ebp
	je	SHORT $LN110@RemoveSmal

; 713  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edx], eax

; 714  :         _Orphan_range(_Mylast, _Mylast);
; 715  :         _Ty& _Result = *_Mylast;
; 716  :         ++_Mylast;

	add	edx, 4
	mov	DWORD PTR _tempFaceList$[esp+48], edx

; 731  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

	jmp	SHORT $LN5@RemoveSmal
$LN110@RemoveSmal:

; 732  :         }
; 733  : 
; 734  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	push	eax
	push	edx
	lea	ecx, DWORD PTR _tempFaceList$[esp+52]
	call	??$_Emplace_reallocate@ABQAVNvFaceInfo@@@?$vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@std@@QAEPAPAVNvFaceInfo@@QAPAV2@ABQAV2@@Z ; std::vector<NvFaceInfo *,xalloc<NvFaceInfo *> >::_Emplace_reallocate<NvFaceInfo * const &>
	mov	ebp, DWORD PTR _tempFaceList$[esp+52]
	mov	edx, DWORD PTR _tempFaceList$[esp+48]
$LN5@RemoveSmal:

; 119  :         _Ptr += _Off;

	mov	eax, DWORD PTR _allStrips$[esp+40]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 686  : 			for(int j = 0; j < allStrips[i]->m_faces.size(); j++)

	inc	edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 119  :         _Ptr += _Off;

	mov	esi, DWORD PTR [eax]

; 1535 :         auto& _My_data = _Mypair._Myval2;

	mov	ecx, DWORD PTR [esi+ebx*4]

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	eax, DWORD PTR [ecx+16]
	sub	eax, DWORD PTR [ecx+12]
	sar	eax, 2
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 686  : 			for(int j = 0; j < allStrips[i]->m_faces.size(); j++)

	cmp	edi, eax
	jb	SHORT $LL55@RemoveSmal
	mov	DWORD PTR $T1[esp+44], edx
$LN117@RemoveSmal:
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h

; 151  : 	if (ptr) 

	mov	edi, DWORD PTR [esi+ebx*4]
	test	edi, edi
	je	SHORT $LN2@RemoveSmal
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [edi+12]
	test	eax, eax
	je	SHORT $LN146@RemoveSmal
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [edi+12], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [edi+16], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [edi+20], 0
	mov	edi, DWORD PTR [esi+ebx*4]
$LN146@RemoveSmal:
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h

; 144  : 		Memory.mem_free	(ptr);

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	edi
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z

; 154  : 		ptr = nullptr;

	mov	DWORD PTR [esi+ebx*4], 0
	jmp	SHORT $LN2@RemoveSmal
$LN156@RemoveSmal:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 730  :         if (_Mylast != _My_data._Myend) {

	mov	eax, DWORD PTR [edi+4]
	cmp	eax, DWORD PTR [edi+8]
	je	SHORT $LN173@RemoveSmal

; 713  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

	mov	DWORD PTR [eax], ecx

; 714  :         _Orphan_range(_Mylast, _Mylast);
; 715  :         _Ty& _Result = *_Mylast;
; 716  :         ++_Mylast;

	add	DWORD PTR [edi+4], 4

; 731  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

	jmp	SHORT $LN2@RemoveSmal
$LN173@RemoveSmal:

; 732  :         }
; 733  : 
; 734  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	push	edx
	push	eax
	mov	ecx, edi
	call	??$_Emplace_reallocate@ABQAVNvStripInfo@@@?$vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@std@@QAEPAPAVNvStripInfo@@QAPAV2@ABQAV2@@Z ; std::vector<NvStripInfo *,xalloc<NvStripInfo *> >::_Emplace_reallocate<NvStripInfo * const &>
$LN2@RemoveSmal:

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	eax, DWORD PTR _allStrips$[esp+40]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 681  : 	for(int i = 0; i < allStrips.size(); i++)

	inc	ebx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	esi, DWORD PTR [eax]
	mov	eax, DWORD PTR [eax+4]
	sub	eax, esi
	sar	eax, 2
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 681  : 	for(int i = 0; i < allStrips.size(); i++)

	cmp	ebx, eax
	jb	$LL4@RemoveSmal
	mov	ecx, DWORD PTR $T1[esp+44]
$LN3@RemoveSmal:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	sub	ecx, DWORD PTR _tempFaceList$[esp+44]
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	mov	esi, DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	sar	ecx, 2
	mov	DWORD PTR $T1[esp+44], ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	push	ecx
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	esi
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 699  : 	ZeroMemory			(bVisitedList, tempFaceList.size()*sizeof(bool));

	push	DWORD PTR $T1[esp+44]
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	mov	ebx, eax
	push	0
	push	ebx
	mov	DWORD PTR _bVisitedList$1$[esp+52], ebx
	mov	ecx, DWORD PTR [ecx+12]
	call	ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h

; 74   : 	T* ptr	= (T*)Memory.mem_alloc(sizeof(T));

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	12					; 0000000cH
	call	esi

; 75   : 	return new (ptr) T(p1);

	mov	edi, eax
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\VertexCache.cpp

; 12   : 	entries.assign	(size,-1);

	mov	DWORD PTR $T2[esp+44], -1
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h

; 75   : 	return new (ptr) T(p1);

	mov	eax, DWORD PTR _this$1$[esp+44]
	mov	DWORD PTR $T3[esp+40], edi
	mov	ecx, DWORD PTR [eax+12]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\VertexCache.cpp

; 12   : 	entries.assign	(size,-1);

	lea	eax, DWORD PTR $T2[esp+44]
	push	eax
	push	ecx
	mov	ecx, edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [edi], 0
	mov	DWORD PTR [edi+4], 0
	mov	DWORD PTR [edi+8], 0
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\VertexCache.cpp

; 12   : 	entries.assign	(size,-1);

	call	?assign@?$vector@HV?$xalloc@H@@@std@@QAEXIABH@Z ; std::vector<int,xalloc<int> >::assign
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 705  : 	int bestIndex	= 0;

	xor	edx, edx
	mov	DWORD PTR _bestIndex$1$[esp+44], edx
	npad	3
$LL8@RemoveSmal:

; 706  : 	
; 707  : 	while(1)
; 708  : 	{
; 709  : 		bestNumHits = -1;
; 710  : 		
; 711  : 		//find best face to add next, given the current cache
; 712  : 		for(int i = 0; i < tempFaceList.size(); i++)

	mov	eax, DWORD PTR $T1[esp+44]
	or	ecx, -1
	xor	ebp, ebp
	mov	DWORD PTR _bestNumHits$1$[esp+44], ecx
	test	eax, eax
	je	$LN11@RemoveSmal
$LL12@RemoveSmal:

; 713  : 		{
; 714  : 			if(bVisitedList[i])

	cmp	BYTE PTR [ebx+ebp], 0
	jne	$LN10@RemoveSmal

; 717  : 			numHits = CalcNumHitsFace(vcache, tempFaceList[i]);

	mov	eax, DWORD PTR _tempFaceList$[esp+44]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\VertexCache.h

; 28   : 	for(u32 i = 0; i < entries.size(); i++)

	xor	ecx, ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	edx, DWORD PTR [edi+4]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 717  : 			numHits = CalcNumHitsFace(vcache, tempFaceList[i]);

	mov	ebx, DWORD PTR [eax+ebp*4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	eax, DWORD PTR [edi]
	sub	edx, eax
	sar	edx, 2
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 1153 : 	if(vcache->InCache(face->m_v0))

	mov	esi, DWORD PTR [ebx]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\VertexCache.h

; 28   : 	for(u32 i = 0; i < entries.size(); i++)

	test	edx, edx
	je	SHORT $LN254@RemoveSmal
$LL228@RemoveSmal:

; 30   : 		if(entries[i] == entry)

	cmp	DWORD PTR [eax+ecx*4], esi
	je	SHORT $LN727@RemoveSmal

; 28   : 	for(u32 i = 0; i < entries.size(); i++)

	inc	ecx
	cmp	ecx, edx
	jb	SHORT $LL228@RemoveSmal
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 725  : 		if(bestNumHits == -1.0f)

	mov	DWORD PTR tv3604[esp+44], 0
	xor	edi, edi
	jmp	SHORT $LN785@RemoveSmal
$LN727@RemoveSmal:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\VertexCache.h

; 32   : 			returnVal = true;

	mov	DWORD PTR tv3604[esp+44], 1
	mov	edi, 1
$LN785@RemoveSmal:
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h

; 154  : 		ptr = nullptr;

	mov	esi, DWORD PTR [ebx+4]
	xor	ecx, ecx
$LL255@RemoveSmal:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\VertexCache.h

; 30   : 		if(entries[i] == entry)

	cmp	DWORD PTR [eax+ecx*4], esi
	je	SHORT $LN779@RemoveSmal

; 28   : 	for(u32 i = 0; i < entries.size(); i++)

	inc	ecx
	cmp	ecx, edx
	jb	SHORT $LL255@RemoveSmal
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 725  : 		if(bestNumHits == -1.0f)

	mov	esi, DWORD PTR [ebx+8]
	jmp	SHORT $LN781@RemoveSmal
$LN779@RemoveSmal:

; 1157 : 		numHits++;

	mov	edi, DWORD PTR tv3604[esp+44]

; 1158 : 		
; 1159 : 	if(vcache->InCache(face->m_v2))

	mov	esi, DWORD PTR [ebx+8]
	inc	edi
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\VertexCache.h

; 28   : 	for(u32 i = 0; i < entries.size(); i++)

	test	edx, edx
	je	SHORT $LN223@RemoveSmal
$LN781@RemoveSmal:
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h

; 154  : 		ptr = nullptr;

	xor	ecx, ecx
	npad	3
$LL282@RemoveSmal:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\VertexCache.h

; 30   : 		if(entries[i] == entry)

	cmp	DWORD PTR [eax], esi
	je	SHORT $LN729@RemoveSmal

; 28   : 	for(u32 i = 0; i < entries.size(); i++)

	inc	ecx
	add	eax, 4
	cmp	ecx, edx
	jb	SHORT $LL282@RemoveSmal
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 725  : 		if(bestNumHits == -1.0f)

	jmp	SHORT $LN223@RemoveSmal
$LN729@RemoveSmal:

; 1160 : 		numHits++;

	inc	edi
	jmp	SHORT $LN223@RemoveSmal
$LN254@RemoveSmal:

; 1154 : 		numHits++;
; 1155 : 		
; 1156 : 	if(vcache->InCache(face->m_v1))

	xor	edi, edi
$LN223@RemoveSmal:

; 718  : 			if(numHits > bestNumHits)

	mov	ecx, DWORD PTR _bestNumHits$1$[esp+44]
	mov	eax, DWORD PTR $T1[esp+44]
	mov	ebx, DWORD PTR _bVisitedList$1$[esp+40]
	cmp	edi, ecx
	jle	SHORT $LN783@RemoveSmal

; 719  : 			{
; 720  : 				bestNumHits = numHits;

	mov	ecx, edi

; 721  : 				bestIndex = i;

	mov	edx, ebp
	mov	DWORD PTR _bestNumHits$1$[esp+44], ecx
	mov	DWORD PTR _bestIndex$1$[esp+44], edx
	jmp	SHORT $LN786@RemoveSmal
$LN783@RemoveSmal:

; 718  : 			if(numHits > bestNumHits)

	mov	edx, DWORD PTR _bestIndex$1$[esp+44]
$LN786@RemoveSmal:

; 706  : 	
; 707  : 	while(1)
; 708  : 	{
; 709  : 		bestNumHits = -1;
; 710  : 		
; 711  : 		//find best face to add next, given the current cache
; 712  : 		for(int i = 0; i < tempFaceList.size(); i++)

	mov	edi, DWORD PTR $T3[esp+40]
$LN10@RemoveSmal:
	inc	ebp
	cmp	ebp, eax
	jb	$LL12@RemoveSmal
$LN11@RemoveSmal:

; 725  : 		if(bestNumHits == -1.0f)

	cvtsi2ss xmm0, ecx
	ucomiss	xmm0, DWORD PTR __real@bf800000
	lahf
	test	ah, 68					; 00000044H
	jnp	$LN733@RemoveSmal
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 119  :         _Ptr += _Off;

	mov	eax, DWORD PTR _tempFaceList$[esp+44]

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	ebp, DWORD PTR $T3[esp+40]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 727  : 		bVisitedList[bestIndex] = true;

	mov	BYTE PTR [edx+ebx], 1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 119  :         _Ptr += _Off;

	lea	ebx, DWORD PTR [eax+edx*4]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 728  : 		UpdateCacheFace(vcache, tempFaceList[bestIndex]);

	mov	edi, DWORD PTR [ebx]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\VertexCache.h

; 28   : 	for(u32 i = 0; i < entries.size(); i++)

	xor	eax, eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	edx, DWORD PTR [ebp+4]
	mov	ecx, DWORD PTR [ebp]
	sub	edx, ecx
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 1104 : 	if(!vcache->InCache(face->m_v0))

	mov	esi, DWORD PTR [edi]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	sar	edx, 2
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\VertexCache.h

; 28   : 	for(u32 i = 0; i < entries.size(); i++)

	test	edx, edx
	je	SHORT $LN774@RemoveSmal
	npad	5
$LL331@RemoveSmal:

; 30   : 		if(entries[i] == entry)

	cmp	DWORD PTR [ecx+eax*4], esi
	je	SHORT $LN324@RemoveSmal

; 28   : 	for(u32 i = 0; i < entries.size(); i++)

	inc	eax
	cmp	eax, edx
	jb	SHORT $LL331@RemoveSmal
$LN774@RemoveSmal:

; 48   : 	for(int i = (u32)entries.size() - 2; i >= 0; i--)

	add	edx, -2					; fffffffeH
	js	SHORT $LN422@RemoveSmal
	npad	1
$LL358@RemoveSmal:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 119  :         _Ptr += _Off;

	mov	ecx, DWORD PTR [ebp]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\VertexCache.h

; 50   : 		entries[i + 1] = entries[i];

	mov	eax, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR [ecx+edx*4+4], eax
	sub	edx, 1
	jns	SHORT $LL358@RemoveSmal
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h

; 154  : 		ptr = nullptr;

	mov	ecx, DWORD PTR [ebp]
$LN422@RemoveSmal:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\VertexCache.h

; 53   : 	entries[0] = entry;

	mov	DWORD PTR [ecx], esi
$LN324@RemoveSmal:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	edx, DWORD PTR [ebp+4]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\VertexCache.h

; 28   : 	for(u32 i = 0; i < entries.size(); i++)

	xor	eax, eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	ecx, DWORD PTR [ebp]
	sub	edx, ecx
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 1107 : 	if(!vcache->InCache(face->m_v1))

	mov	esi, DWORD PTR [edi+4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	sar	edx, 2
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\VertexCache.h

; 28   : 	for(u32 i = 0; i < entries.size(); i++)

	test	edx, edx
	je	SHORT $LN775@RemoveSmal
$LL439@RemoveSmal:

; 30   : 		if(entries[i] == entry)

	cmp	DWORD PTR [ecx+eax*4], esi
	je	SHORT $LN325@RemoveSmal

; 28   : 	for(u32 i = 0; i < entries.size(); i++)

	inc	eax
	cmp	eax, edx
	jb	SHORT $LL439@RemoveSmal
$LN775@RemoveSmal:

; 48   : 	for(int i = (u32)entries.size() - 2; i >= 0; i--)

	add	edx, -2					; fffffffeH
	js	SHORT $LN530@RemoveSmal
	npad	9
$LL466@RemoveSmal:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 119  :         _Ptr += _Off;

	mov	ecx, DWORD PTR [ebp]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\VertexCache.h

; 50   : 		entries[i + 1] = entries[i];

	mov	eax, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR [ecx+edx*4+4], eax
	sub	edx, 1
	jns	SHORT $LL466@RemoveSmal
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h

; 154  : 		ptr = nullptr;

	mov	ecx, DWORD PTR [ebp]
$LN530@RemoveSmal:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\VertexCache.h

; 53   : 	entries[0] = entry;

	mov	DWORD PTR [ecx], esi
$LN325@RemoveSmal:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	edx, DWORD PTR [ebp+4]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\VertexCache.h

; 28   : 	for(u32 i = 0; i < entries.size(); i++)

	xor	eax, eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	ecx, DWORD PTR [ebp]
	sub	edx, ecx
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 1110 : 	if(!vcache->InCache(face->m_v2))

	mov	esi, DWORD PTR [edi+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	sar	edx, 2
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\VertexCache.h

; 28   : 	for(u32 i = 0; i < entries.size(); i++)

	test	edx, edx
	je	SHORT $LN776@RemoveSmal
$LL547@RemoveSmal:

; 30   : 		if(entries[i] == entry)

	cmp	DWORD PTR [ecx+eax*4], esi
	je	SHORT $LN655@RemoveSmal

; 28   : 	for(u32 i = 0; i < entries.size(); i++)

	inc	eax
	cmp	eax, edx
	jb	SHORT $LL547@RemoveSmal
$LN776@RemoveSmal:

; 48   : 	for(int i = (u32)entries.size() - 2; i >= 0; i--)

	add	edx, -2					; fffffffeH
	js	SHORT $LN638@RemoveSmal
	npad	9
$LL574@RemoveSmal:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 119  :         _Ptr += _Off;

	mov	ecx, DWORD PTR [ebp]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\VertexCache.h

; 50   : 		entries[i + 1] = entries[i];

	mov	eax, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR [ecx+edx*4+4], eax
	sub	edx, 1
	jns	SHORT $LL574@RemoveSmal
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h

; 154  : 		ptr = nullptr;

	mov	ecx, DWORD PTR [ebp]
$LN638@RemoveSmal:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\VertexCache.h

; 53   : 	entries[0] = entry;

	mov	DWORD PTR [ecx], esi
$LN655@RemoveSmal:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 730  :         if (_Mylast != _My_data._Myend) {

	mov	edx, DWORD PTR _faceList$[esp+40]
	mov	ecx, DWORD PTR [edx+4]
	cmp	ecx, DWORD PTR [edx+8]
	je	SHORT $LN672@RemoveSmal

; 713  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

	mov	eax, DWORD PTR [ebx]

; 731  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

	mov	edi, DWORD PTR $T3[esp+40]
	mov	ebx, DWORD PTR _bVisitedList$1$[esp+40]

; 713  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

	mov	DWORD PTR [ecx], eax

; 714  :         _Orphan_range(_Mylast, _Mylast);
; 715  :         _Ty& _Result = *_Mylast;
; 716  :         ++_Mylast;

	add	DWORD PTR [edx+4], 4

; 731  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

	mov	edx, DWORD PTR _bestIndex$1$[esp+44]
	jmp	$LL8@RemoveSmal
$LN672@RemoveSmal:

; 732  :         }
; 733  : 
; 734  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	push	ebx
	push	ecx
	mov	ecx, edx
	call	??$_Emplace_reallocate@ABQAVNvFaceInfo@@@?$vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@std@@QAEPAPAVNvFaceInfo@@QAPAV2@ABQAV2@@Z ; std::vector<NvFaceInfo *,xalloc<NvFaceInfo *> >::_Emplace_reallocate<NvFaceInfo * const &>
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 730  : 	}

	mov	edi, DWORD PTR $T3[esp+40]
	mov	ebx, DWORD PTR _bVisitedList$1$[esp+40]
	mov	edx, DWORD PTR _bestIndex$1$[esp+44]
	jmp	$LL8@RemoveSmal
$LN733@RemoveSmal:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\VertexCache.cpp

; 18   : 	entries.clear	();

	mov	eax, DWORD PTR [edi]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	ebp, DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\VertexCache.cpp

; 18   : 	entries.clear	();

	mov	DWORD PTR [edi+4], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	test	eax, eax
	je	SHORT $LN691@RemoveSmal
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	ebp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [edi], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [edi+4], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [edi+8], 0
$LN691@RemoveSmal:
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h

; 144  : 		Memory.mem_free	(ptr);

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	edi
	call	ebp
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	test	ebx, ebx
	je	SHORT $LN699@RemoveSmal
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	ebx
	call	ebp
$LN699@RemoveSmal:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR _tempFaceList$[esp+44]
	test	eax, eax
	je	SHORT $LN711@RemoveSmal
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	ebp
$LN711@RemoveSmal:
	pop	edi
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 734  : }

	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 28					; 0000001cH
	ret	12					; 0000000cH
?RemoveSmallStrips@NvStripifier@@IAEXAAV?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@0AAV?$xr_vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@@@Z ENDP ; NvStripifier::RemoveSmallStrips
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
_TEXT	SEGMENT
_numIndices$ = 8					; size = 4
?NextIsCW@NvStripifier@@IAE_NH@Z PROC			; NvStripifier::NextIsCW
; _this$dead$ = ecx

; 743  : 	return ((numIndices % 2) == 0);

	mov	al, BYTE PTR _numIndices$[esp-4]
	not	al
	and	al, 1

; 744  : }

	ret	4
?NextIsCW@NvStripifier@@IAE_NH@Z ENDP			; NvStripifier::NextIsCW
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
_TEXT	SEGMENT
_faceInfo$ = 8						; size = 4
_v0$ = 12						; size = 4
_v1$ = 16						; size = 4
?IsCW@NvStripifier@@IAE_NPAVNvFaceInfo@@HH@Z PROC	; NvStripifier::IsCW
; _this$dead$ = ecx

; 754  : 	if (faceInfo->m_v0 == v0)

	mov	eax, DWORD PTR _faceInfo$[esp-4]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [eax+4]
	cmp	edx, DWORD PTR _v0$[esp-4]
	jne	SHORT $LN2@IsCW

; 755  : 		return (faceInfo->m_v1 == v1);

	cmp	ecx, DWORD PTR _v1$[esp-4]

; 762  : }

	sete	al
	ret	12					; 0000000cH
$LN2@IsCW:

; 756  : 	
; 757  : 	else if (faceInfo->m_v1 == v0)

	cmp	ecx, DWORD PTR _v0$[esp-4]
	jne	SHORT $LN4@IsCW

; 758  : 		return (faceInfo->m_v2 == v1);

	mov	eax, DWORD PTR [eax+8]
	cmp	eax, DWORD PTR _v1$[esp-4]

; 762  : }

	sete	al
	ret	12					; 0000000cH
$LN4@IsCW:

; 759  : 	
; 760  : 	else 
; 761  : 		return (faceInfo->m_v0 == v1);

	cmp	edx, DWORD PTR _v1$[esp-4]

; 762  : }

	sete	al
	ret	12					; 0000000cH
?IsCW@NvStripifier@@IAE_NPAVNvFaceInfo@@HH@Z ENDP	; NvStripifier::IsCW
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??4?$xr_vector@GV?$xalloc@G@@@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??4?$xr_vector@GV?$xalloc@G@@@@QAEAAV0@ABV0@@Z PROC	; xr_vector<unsigned short,xalloc<unsigned short> >::operator=, COMDAT
; _this$ = ecx

; 1202 :         if (this != _STD addressof(_Right)) {

	mov	eax, DWORD PTR ___that$[esp-4]
	push	esi
	mov	esi, ecx
	cmp	esi, eax
	je	SHORT $LN8@operator

; 1187 :         assign(_Right_data._Myfirst, _Right_data._Mylast);

	push	DWORD PTR [eax+4]
	push	DWORD PTR [eax]
	call	??$assign@PAG$0A@@?$vector@GV?$xalloc@G@@@std@@QAEXPAG0@Z ; std::vector<unsigned short,xalloc<unsigned short> >::assign<unsigned short *,0>
$LN8@operator:
	mov	eax, esi
	pop	esi
	ret	4
??4?$xr_vector@GV?$xalloc@G@@@@QAEAAV0@ABV0@@Z ENDP	; xr_vector<unsigned short,xalloc<unsigned short> >::operator=
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??1?$xr_vector@PAVNvEdgeInfo@@V?$xalloc@PAVNvEdgeInfo@@@@@@QAE@XZ
_TEXT	SEGMENT
??1?$xr_vector@PAVNvEdgeInfo@@V?$xalloc@PAVNvEdgeInfo@@@@@@QAE@XZ PROC ; xr_vector<NvEdgeInfo *,xalloc<NvEdgeInfo *> >::~xr_vector<NvEdgeInfo *,xalloc<NvEdgeInfo *> >, COMDAT
; _this$ = ecx

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	push	esi
	mov	esi, ecx
	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN6@xr_vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+4], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+8], 0
$LN6@xr_vector:
	pop	esi
	ret	0
??1?$xr_vector@PAVNvEdgeInfo@@V?$xalloc@PAVNvEdgeInfo@@@@@@QAE@XZ ENDP ; xr_vector<NvEdgeInfo *,xalloc<NvEdgeInfo *> >::~xr_vector<NvEdgeInfo *,xalloc<NvEdgeInfo *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\VertexCache.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\VertexCache.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\VertexCache.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\VertexCache.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\VertexCache.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\VertexCache.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\VertexCache.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\VertexCache.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\VertexCache.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\VertexCache.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\VertexCache.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\VertexCache.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\VertexCache.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\VertexCache.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
_TEXT	SEGMENT
_threshold$1$ = -56					; size = 4
_vcache$1$ = -52					; size = 4
_i$1$ = -52						; size = 4
_i$2$ = -48						; size = 4
_currentStrip$1 = -48					; size = 4
_bestIndex$1$ = -44					; size = 4
_leftOff$1$ = -44					; size = 4
$T2 = -40						; size = 4
_numLeftover$1$ = -40					; size = 4
_i$1$ = -36						; size = 4
_firstIndex$1$ = -36					; size = 4
_numTimes$1$ = -36					; size = 4
$T3 = -32						; size = 4
$T4 = -32						; size = 4
$T5 = -32						; size = 4
tv4175 = -28						; size = 4
tv4113 = -28						; size = 4
_this$1$ = -28						; size = 4
_tempStrips$ = -24					; size = 12
_tempStrips2$ = -12					; size = 12
_startInfo$6 = -12					; size = 12
$T7 = 8							; size = 4
tv4208 = 8						; size = 4
$T8 = 8							; size = 4
_currCost$9 = 8						; size = 4
_numNeighbors$10 = 8					; size = 4
_allStrips$ = 8						; size = 4
_outStrips$ = 12					; size = 4
_numFaces$1$ = 16					; size = 4
_edgeInfos$ = 16					; size = 4
_i$1$ = 20						; size = 4
_minCost$11 = 20					; size = 4
_outFaceList$ = 20					; size = 4
?SplitUpStripsAndOptimize@NvStripifier@@IAEXAAV?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@0AAV?$xr_vector@PAVNvEdgeInfo@@V?$xalloc@PAVNvEdgeInfo@@@@@@AAV?$xr_vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@@@Z PROC ; NvStripifier::SplitUpStripsAndOptimize
; _this$ = ecx

; 949  : {

	sub	esp, 56					; 00000038H
	push	ebx
	push	ebp
	mov	eax, ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR _tempStrips$[esp+64], 0
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 949  : {

	push	esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	esi, DWORD PTR _allStrips$[esp+64]

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	xor	ebx, ebx
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 949  : {

	mov	DWORD PTR _this$1$[esp+68], eax

; 955  : 	for(i = 0; i < allStrips.size(); i++)

	xor	edx, edx
	mov	ebp, DWORD PTR [eax+12]
	push	edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi]
	sub	eax, ecx
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 955  : 	for(i = 0; i < allStrips.size(); i++)

	mov	edi, DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	sar	eax, 2
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 950  : 	int threshold = cacheSize;

	mov	DWORD PTR _threshold$1$[esp+72], ebp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR _tempStrips$[esp+76], ebx
	mov	DWORD PTR _tempStrips$[esp+80], ebx
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 955  : 	for(i = 0; i < allStrips.size(); i++)

	mov	DWORD PTR _i$1$[esp+72], edx
	test	eax, eax
	je	$LN3@SplitUpStr
	npad	8
$LL4@SplitUpStr:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1535 :         auto& _My_data = _Mypair._Myval2;

	mov	ecx, DWORD PTR [ecx+edx*4]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.h

; 91   : 		m_toV1         = toV1;

	mov	BYTE PTR _startInfo$6[esp+80], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	eax, DWORD PTR [ecx+16]
	sub	eax, DWORD PTR [ecx+12]
	sar	eax, 2
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 960  : 		if(allStrips[i]->m_faces.size() > threshold)

	cmp	eax, ebp
	jbe	$LN28@SplitUpStr

; 961  : 		{
; 962  : 			
; 963  : 			int numTimes    = allStrips[i]->m_faces.size() / threshold;

	xor	edx, edx

; 967  : 			for(j = 0; j < numTimes; j++)

	xor	ecx, ecx
	div	ebp
	mov	DWORD PTR _numTimes$1$[esp+72], eax
	mov	edi, edx
	mov	DWORD PTR _numLeftover$1$[esp+72], edi
	test	eax, eax
	jle	$LN6@SplitUpStr

; 961  : 		{
; 962  : 			
; 963  : 			int numTimes    = allStrips[i]->m_faces.size() / threshold;

	xor	esi, esi
	mov	DWORD PTR _leftOff$1$[esp+72], eax
	npad	9
$LL7@SplitUpStr:
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h

; 86   : 	T* ptr	= (T*)Memory.mem_alloc(sizeof(T));

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	36					; 00000024H
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.h

; 123  : 	  m_startInfo(startInfo)

	mov	ecx, DWORD PTR _startInfo$6[esp+80]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 971  : 				for(int faceCtr = j*threshold; faceCtr < threshold+(j*threshold); faceCtr++) {

	add	ebp, esi
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h

; 87   : 	return new (ptr) T(p1,p2,p3);

	mov	DWORD PTR $T5[esp+72], eax
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 969  : 				currentStrip = xr_new<NvStripInfo> (startInfo, 0, -1);

	mov	DWORD PTR _currentStrip$1[esp+72], eax
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.h

; 123  : 	  m_startInfo(startInfo)

	mov	DWORD PTR [eax], 0

; 124  : 	{

	lea	edi, DWORD PTR [eax+12]
	mov	DWORD PTR [eax+4], 0
	mov	DWORD PTR [eax+8], ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [edi], 0
	mov	DWORD PTR [edi+4], 0
	mov	DWORD PTR [edi+8], 0
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.h

; 125  : 		m_stripId      = stripId;

	mov	DWORD PTR [eax+24], 0

; 126  : 		m_experimentId = experimentId;

	mov	DWORD PTR [eax+28], -1

; 127  : 		visited = false;

	mov	BYTE PTR [eax+32], 0
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 971  : 				for(int faceCtr = j*threshold; faceCtr < threshold+(j*threshold); faceCtr++) {

	cmp	esi, ebp
	jge	SHORT $LN9@SplitUpStr
	mov	ebx, DWORD PTR _i$1$[esp+72]
	npad	3
$LL10@SplitUpStr:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 119  :         _Ptr += _Off;

	mov	eax, DWORD PTR _allStrips$[esp+68]

; 730  :         if (_Mylast != _My_data._Myend) {

	mov	ecx, DWORD PTR [edi+4]

; 119  :         _Ptr += _Off;

	mov	eax, DWORD PTR [eax]
	mov	eax, DWORD PTR [eax+ebx*4]
	mov	eax, DWORD PTR [eax+12]
	lea	eax, DWORD PTR [eax+esi*4]

; 730  :         if (_Mylast != _My_data._Myend) {

	cmp	ecx, DWORD PTR [edi+8]
	je	SHORT $LN163@SplitUpStr

; 713  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax

; 714  :         _Orphan_range(_Mylast, _Mylast);
; 715  :         _Ty& _Result = *_Mylast;
; 716  :         ++_Mylast;

	add	DWORD PTR [edi+4], 4

; 731  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

	jmp	SHORT $LN8@SplitUpStr
$LN163@SplitUpStr:

; 732  :         }
; 733  : 
; 734  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	push	eax
	push	ecx
	mov	ecx, edi
	call	??$_Emplace_reallocate@ABQAVNvFaceInfo@@@?$vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@std@@QAEPAPAVNvFaceInfo@@QAPAV2@ABQAV2@@Z ; std::vector<NvFaceInfo *,xalloc<NvFaceInfo *> >::_Emplace_reallocate<NvFaceInfo * const &>
$LN8@SplitUpStr:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 971  : 				for(int faceCtr = j*threshold; faceCtr < threshold+(j*threshold); faceCtr++) {

	inc	esi
	cmp	esi, ebp
	jl	SHORT $LL10@SplitUpStr
	mov	ebx, DWORD PTR _tempStrips$[esp+76]
	mov	eax, DWORD PTR $T5[esp+72]
$LN9@SplitUpStr:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 730  :         if (_Mylast != _My_data._Myend) {

	cmp	ebx, DWORD PTR _tempStrips$[esp+80]
	je	SHORT $LN170@SplitUpStr

; 713  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

	mov	DWORD PTR [ebx], eax

; 714  :         _Orphan_range(_Mylast, _Mylast);
; 715  :         _Ty& _Result = *_Mylast;
; 716  :         ++_Mylast;

	add	ebx, 4
	mov	DWORD PTR _tempStrips$[esp+76], ebx

; 731  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

	jmp	SHORT $LN5@SplitUpStr
$LN170@SplitUpStr:

; 732  :         }
; 733  : 
; 734  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	lea	eax, DWORD PTR _currentStrip$1[esp+72]
	push	eax
	push	ebx
	lea	ecx, DWORD PTR _tempStrips$[esp+80]
	call	??$_Emplace_reallocate@ABQAVNvStripInfo@@@?$vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@std@@QAEPAPAVNvStripInfo@@QAPAV2@ABQAV2@@Z ; std::vector<NvStripInfo *,xalloc<NvStripInfo *> >::_Emplace_reallocate<NvStripInfo * const &>
	mov	ebx, DWORD PTR _tempStrips$[esp+76]
$LN5@SplitUpStr:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 967  : 			for(j = 0; j < numTimes; j++)

	sub	DWORD PTR _numTimes$1$[esp+72], 1
	mov	esi, ebp
	mov	ebp, DWORD PTR _threshold$1$[esp+72]
	jne	$LL7@SplitUpStr
	mov	esi, DWORD PTR _allStrips$[esp+68]
	mov	edi, DWORD PTR _numLeftover$1$[esp+72]
	mov	ecx, DWORD PTR _leftOff$1$[esp+72]
$LN6@SplitUpStr:

; 972  : 					currentStrip->m_faces.push_back(allStrips[i]->m_faces[faceCtr]);
; 973  : 				}
; 974  : 				
; 975  : 				tempStrips.push_back(currentStrip);
; 976  : 			}
; 977  : 			
; 978  : 			int leftOff = j * threshold;

	imul	ecx, ebp
	mov	DWORD PTR _leftOff$1$[esp+72], ecx

; 979  : 			
; 980  : 			if(numLeftover != 0)

	test	edi, edi
	je	$LN2@SplitUpStr
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h

; 86   : 	T* ptr	= (T*)Memory.mem_alloc(sizeof(T));

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	36					; 00000024H
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z

; 87   : 	return new (ptr) T(p1,p2,p3);

	mov	ebp, eax
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.h

; 123  : 	  m_startInfo(startInfo)

	mov	eax, DWORD PTR _startInfo$6[esp+80]
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h

; 87   : 	return new (ptr) T(p1,p2,p3);

	mov	DWORD PTR $T4[esp+72], ebp
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.h

; 124  : 	{

	lea	esi, DWORD PTR [ebp+12]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 982  : 				currentStrip = xr_new<NvStripInfo> (startInfo, 0, -1);   

	mov	DWORD PTR _currentStrip$1[esp+72], ebp
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.h

; 123  : 	  m_startInfo(startInfo)

	mov	DWORD PTR [ebp], 0
	mov	DWORD PTR [ebp+4], 0
	mov	DWORD PTR [ebp+8], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [esi], 0
	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.h

; 125  : 		m_stripId      = stripId;

	mov	DWORD PTR [ebp+24], 0

; 126  : 		m_experimentId = experimentId;

	mov	DWORD PTR [ebp+28], -1

; 127  : 		visited = false;

	mov	BYTE PTR [ebp+32], 0
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 984  : 				for(int k = 0; k < numLeftover; k++)

	test	edi, edi
	jle	SHORT $LN12@SplitUpStr
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h

; 86   : 	T* ptr	= (T*)Memory.mem_alloc(sizeof(T));

	mov	eax, DWORD PTR _leftOff$1$[esp+72]
	mov	ebp, DWORD PTR _i$1$[esp+72]
	mov	ebx, DWORD PTR _allStrips$[esp+68]
	lea	edi, DWORD PTR [eax*4]
$LL13@SplitUpStr:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 119  :         _Ptr += _Off;

	mov	eax, DWORD PTR [ebx]

; 730  :         if (_Mylast != _My_data._Myend) {

	mov	ecx, DWORD PTR [esi+4]

; 119  :         _Ptr += _Off;

	mov	eax, DWORD PTR [eax+ebp*4]
	mov	eax, DWORD PTR [eax+12]
	add	eax, edi

; 730  :         if (_Mylast != _My_data._Myend) {

	cmp	ecx, DWORD PTR [esi+8]
	je	SHORT $LN223@SplitUpStr

; 713  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax

; 714  :         _Orphan_range(_Mylast, _Mylast);
; 715  :         _Ty& _Result = *_Mylast;
; 716  :         ++_Mylast;

	add	DWORD PTR [esi+4], 4

; 731  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

	jmp	SHORT $LN222@SplitUpStr
$LN223@SplitUpStr:

; 732  :         }
; 733  : 
; 734  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	push	eax
	push	ecx
	mov	ecx, esi
	call	??$_Emplace_reallocate@ABQAVNvFaceInfo@@@?$vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@std@@QAEPAPAVNvFaceInfo@@QAPAV2@ABQAV2@@Z ; std::vector<NvFaceInfo *,xalloc<NvFaceInfo *> >::_Emplace_reallocate<NvFaceInfo * const &>
$LN222@SplitUpStr:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 986  : 					currentStrip->m_faces.push_back(allStrips[i]->m_faces[leftOff++]);

	add	edi, 4
	sub	DWORD PTR _numLeftover$1$[esp+72], 1
	jne	SHORT $LL13@SplitUpStr
$LN828@SplitUpStr:

; 955  : 	for(i = 0; i < allStrips.size(); i++)

	mov	ebx, DWORD PTR _tempStrips$[esp+76]
	mov	ebp, DWORD PTR $T4[esp+72]
$LN12@SplitUpStr:
	cmp	ebx, DWORD PTR _tempStrips$[esp+80]
	je	$LN311@SplitUpStr
	mov	DWORD PTR [ebx], ebp
	add	ebx, 4
	mov	DWORD PTR _tempStrips$[esp+76], ebx
	jmp	$LN827@SplitUpStr
$LN28@SplitUpStr:
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h

; 86   : 	T* ptr	= (T*)Memory.mem_alloc(sizeof(T));

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	36					; 00000024H
	call	edi
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.h

; 123  : 	  m_startInfo(startInfo)

	mov	ecx, DWORD PTR _startInfo$6[esp+80]
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h

; 87   : 	return new (ptr) T(p1,p2,p3);

	mov	ebp, eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 119  :         _Ptr += _Off;

	mov	eax, DWORD PTR _allStrips$[esp+68]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.h

; 124  : 	{

	lea	esi, DWORD PTR [ebp+12]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 998  : 			for(int j = 0; j < allStrips[i]->m_faces.size(); j++)

	xor	edi, edi
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h

; 87   : 	return new (ptr) T(p1,p2,p3);

	mov	DWORD PTR $T3[esp+72], ebp
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 996  : 			currentStrip = xr_new<NvStripInfo> (startInfo, 0, -1);

	mov	DWORD PTR _currentStrip$1[esp+72], ebp
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.h

; 123  : 	  m_startInfo(startInfo)

	mov	DWORD PTR [ebp], 0
	mov	DWORD PTR [ebp+4], 0
	mov	DWORD PTR [ebp+8], ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [esi], 0
	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.h

; 125  : 		m_stripId      = stripId;

	mov	DWORD PTR [ebp+24], 0

; 126  : 		m_experimentId = experimentId;

	mov	DWORD PTR [ebp+28], -1

; 127  : 		visited = false;

	mov	BYTE PTR [ebp+32], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 119  :         _Ptr += _Off;

	mov	edx, DWORD PTR [eax]

; 1535 :         auto& _My_data = _Mypair._Myval2;

	mov	eax, DWORD PTR _i$1$[esp+72]
	mov	ecx, DWORD PTR [edx+eax*4]

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	eax, DWORD PTR [ecx+16]
	sub	eax, DWORD PTR [ecx+12]
	sar	eax, 2
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 998  : 			for(int j = 0; j < allStrips[i]->m_faces.size(); j++)

	test	eax, eax
	je	$LN12@SplitUpStr
	mov	ebp, DWORD PTR _i$1$[esp+72]
	mov	ebx, DWORD PTR _allStrips$[esp+68]
	npad	3
$LL249@SplitUpStr:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 119  :         _Ptr += _Off;

	mov	eax, DWORD PTR [edx+ebp*4]

; 730  :         if (_Mylast != _My_data._Myend) {

	mov	ecx, DWORD PTR [esi+4]

; 119  :         _Ptr += _Off;

	mov	eax, DWORD PTR [eax+12]
	lea	eax, DWORD PTR [eax+edi*4]

; 730  :         if (_Mylast != _My_data._Myend) {

	cmp	ecx, DWORD PTR [esi+8]
	je	SHORT $LN304@SplitUpStr

; 713  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax

; 714  :         _Orphan_range(_Mylast, _Mylast);
; 715  :         _Ty& _Result = *_Mylast;
; 716  :         ++_Mylast;

	add	DWORD PTR [esi+4], 4

; 731  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

	jmp	SHORT $LN14@SplitUpStr
$LN304@SplitUpStr:

; 732  :         }
; 733  : 
; 734  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	push	eax
	push	ecx
	mov	ecx, esi
	call	??$_Emplace_reallocate@ABQAVNvFaceInfo@@@?$vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@std@@QAEPAPAVNvFaceInfo@@QAPAV2@ABQAV2@@Z ; std::vector<NvFaceInfo *,xalloc<NvFaceInfo *> >::_Emplace_reallocate<NvFaceInfo * const &>
$LN14@SplitUpStr:

; 119  :         _Ptr += _Off;

	mov	edx, DWORD PTR [ebx]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 998  : 			for(int j = 0; j < allStrips[i]->m_faces.size(); j++)

	inc	edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1535 :         auto& _My_data = _Mypair._Myval2;

	mov	ecx, DWORD PTR [edx+ebp*4]

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	eax, DWORD PTR [ecx+16]
	sub	eax, DWORD PTR [ecx+12]
	sar	eax, 2
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 998  : 			for(int j = 0; j < allStrips[i]->m_faces.size(); j++)

	cmp	edi, eax
	jb	SHORT $LL249@SplitUpStr
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 731  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

	jmp	$LN828@SplitUpStr
$LN311@SplitUpStr:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 955  : 	for(i = 0; i < allStrips.size(); i++)

	lea	eax, DWORD PTR _currentStrip$1[esp+72]
	push	eax
	push	ebx
	lea	ecx, DWORD PTR _tempStrips$[esp+80]
	call	??$_Emplace_reallocate@ABQAVNvStripInfo@@@?$vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@std@@QAEPAPAVNvStripInfo@@QAPAV2@ABQAV2@@Z ; std::vector<NvStripInfo *,xalloc<NvStripInfo *> >::_Emplace_reallocate<NvStripInfo * const &>
	mov	ebx, DWORD PTR _tempStrips$[esp+76]
$LN827@SplitUpStr:
	mov	ebp, DWORD PTR _threshold$1$[esp+72]
	mov	esi, DWORD PTR _allStrips$[esp+68]
$LN2@SplitUpStr:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	eax, DWORD PTR [esi+4]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 955  : 	for(i = 0; i < allStrips.size(); i++)

	mov	edx, DWORD PTR _i$1$[esp+72]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	ecx, DWORD PTR [esi]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 955  : 	for(i = 0; i < allStrips.size(); i++)

	inc	edx
	mov	edi, DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	sub	eax, ecx
	sar	eax, 2
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 955  : 	for(i = 0; i < allStrips.size(); i++)

	mov	DWORD PTR _i$1$[esp+72], edx
	cmp	edx, eax
	jb	$LL4@SplitUpStr
$LN3@SplitUpStr:

; 1007 : 	RemoveSmallStrips(tempStrips, tempStrips2, outFaceList);

	push	DWORD PTR _outFaceList$[esp+68]
	mov	esi, DWORD PTR _this$1$[esp+76]
	lea	eax, DWORD PTR _tempStrips2$[esp+76]
	push	eax
	lea	eax, DWORD PTR _tempStrips$[esp+80]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR _tempStrips2$[esp+80], 0
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 1007 : 	RemoveSmallStrips(tempStrips, tempStrips2, outFaceList);

	push	eax
	mov	ecx, esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR _tempStrips2$[esp+88], 0
	mov	DWORD PTR _tempStrips2$[esp+92], 0
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 1007 : 	RemoveSmallStrips(tempStrips, tempStrips2, outFaceList);

	call	?RemoveSmallStrips@NvStripifier@@IAEXAAV?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@0AAV?$xr_vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@@@Z ; NvStripifier::RemoveSmallStrips

; 1008 : 	
; 1009 : 	outStrips.clear();

	mov	ecx, DWORD PTR _outStrips$[esp+68]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	ebp, DWORD PTR _tempStrips2$[esp+72]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 1010 : 	if(tempStrips2.size() != 0)

	mov	ebx, DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [ecx+4], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	eax, DWORD PTR _tempStrips2$[esp+76]
	sub	eax, ebp
	sar	eax, 2
	mov	DWORD PTR $T2[esp+72], eax
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 1010 : 	if(tempStrips2.size() != 0)

	test	eax, eax
	je	$LN718@SplitUpStr
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h

; 74   : 	T* ptr	= (T*)Memory.mem_alloc(sizeof(T));

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	12					; 0000000cH
	call	edi

; 75   : 	return new (ptr) T(p1);

	mov	ecx, DWORD PTR [esi+12]
	mov	ebx, eax
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\VertexCache.cpp

; 12   : 	entries.assign	(size,-1);

	lea	eax, DWORD PTR $T8[esp+68]
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h

; 74   : 	T* ptr	= (T*)Memory.mem_alloc(sizeof(T));

	mov	DWORD PTR _vcache$1$[esp+72], ebx
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\VertexCache.cpp

; 12   : 	entries.assign	(size,-1);

	push	eax
	push	ecx
	mov	ecx, ebx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ebx], 0
	mov	DWORD PTR [ebx+4], 0
	mov	DWORD PTR [ebx+8], 0
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\VertexCache.cpp

; 12   : 	entries.assign	(size,-1);

	mov	DWORD PTR $T8[esp+76], -1
	call	?assign@?$vector@HV?$xalloc@H@@@std@@QAEXIABH@Z ; std::vector<int,xalloc<int> >::assign
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 1022 : 		for(i = 0; i < tempStrips2.size(); i++)

	mov	edi, DWORD PTR $T2[esp+72]
	xor	eax, eax
	xor	ecx, ecx
	mov	DWORD PTR _bestIndex$1$[esp+72], 0
	mov	DWORD PTR _firstIndex$1$[esp+72], eax
	mov	DWORD PTR _minCost$11[esp+68], 1176256512 ; 461c4000H
	mov	DWORD PTR _i$2$[esp+72], ecx
	test	edi, edi
	je	$LN422@SplitUpStr
$LL19@SplitUpStr:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1535 :         auto& _My_data = _Mypair._Myval2;

	mov	edx, DWORD PTR [ebp+ecx*4]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 1024 : 			int numNeighbors = 0;

	xor	esi, esi

; 1027 : 			for(int j = 0; j < tempStrips2[i]->m_faces.size(); j++)

	xor	ebx, ebx
	mov	DWORD PTR _numNeighbors$10[esp+68], esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1535 :         auto& _My_data = _Mypair._Myval2;

	mov	DWORD PTR tv4113[esp+72], edx

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	eax, DWORD PTR [edx+16]
	mov	ebp, eax
	mov	edi, DWORD PTR [edx+12]
	sub	ebp, edi
	sar	ebp, 2
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 1027 : 			for(int j = 0; j < tempStrips2[i]->m_faces.size(); j++)

	test	ebp, ebp
	je	SHORT $LN401@SplitUpStr
	npad	10
$LL346@SplitUpStr:

; 1028 : 			{
; 1029 : 				numNeighbors += NumNeighbors(tempStrips2[i]->m_faces[j], edgeInfos);

	push	DWORD PTR _edgeInfos$[esp+68]
	push	DWORD PTR [edi]
	call	?NumNeighbors@NvStripifier@@IAEHPAVNvFaceInfo@@AAV?$xr_vector@PAVNvEdgeInfo@@V?$xalloc@PAVNvEdgeInfo@@@@@@@Z ; NvStripifier::NumNeighbors
	inc	ebx
	lea	edi, DWORD PTR [edi+4]
	add	esi, eax
	cmp	ebx, ebp
	jb	SHORT $LL346@SplitUpStr
	mov	edx, DWORD PTR tv4113[esp+72]
	mov	ecx, DWORD PTR _i$2$[esp+72]
	mov	DWORD PTR _numNeighbors$10[esp+68], esi
	mov	eax, DWORD PTR [edx+16]
$LN401@SplitUpStr:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	sub	eax, DWORD PTR [edx+12]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 1032 : 			float currCost = (float)numNeighbors / (float)tempStrips2[i]->m_faces.size();

	fild	DWORD PTR _numNeighbors$10[esp+68]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	sar	eax, 2
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 1032 : 			float currCost = (float)numNeighbors / (float)tempStrips2[i]->m_faces.size();

	mov	DWORD PTR tv4208[esp+68], eax
	fild	DWORD PTR tv4208[esp+68]
	test	eax, eax
	jns	SHORT $LN826@SplitUpStr
	fadd	DWORD PTR __real@4f800000
$LN826@SplitUpStr:
	fdivp	ST(1), ST(0)
	fst	DWORD PTR _currCost$9[esp+68]

; 1033 : 			if(currCost < minCost)

	fld	DWORD PTR _minCost$11[esp+68]
	fcomip	ST(1)
	fstp	ST(0)
	jbe	SHORT $LN821@SplitUpStr

; 1034 : 			{
; 1035 : 				minCost = currCost;

	movss	xmm0, DWORD PTR _currCost$9[esp+68]

; 1036 : 				firstIndex = i;

	mov	eax, ecx
	movss	DWORD PTR _minCost$11[esp+68], xmm0
	mov	DWORD PTR _firstIndex$1$[esp+72], eax
	jmp	SHORT $LN17@SplitUpStr
$LN821@SplitUpStr:

; 1033 : 			if(currCost < minCost)

	mov	eax, DWORD PTR _firstIndex$1$[esp+72]
$LN17@SplitUpStr:

; 1022 : 		for(i = 0; i < tempStrips2.size(); i++)

	mov	edi, DWORD PTR $T2[esp+72]
	inc	ecx
	mov	ebp, DWORD PTR _tempStrips2$[esp+72]
	mov	DWORD PTR _i$2$[esp+72], ecx
	cmp	ecx, edi
	jb	$LL19@SplitUpStr
	mov	ebx, DWORD PTR _vcache$1$[esp+72]
$LN422@SplitUpStr:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 119  :         _Ptr += _Off;

	lea	esi, DWORD PTR [eax*4]
	add	esi, ebp
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 1040 : 		UpdateCacheStrip(vcache, tempStrips2[firstIndex]);

	push	DWORD PTR [esi]
	push	ebx
	call	?UpdateCacheStrip@NvStripifier@@IAEXPAVVertexCache@@PAVNvStripInfo@@@Z ; NvStripifier::UpdateCacheStrip
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 730  :         if (_Mylast != _My_data._Myend) {

	mov	edx, DWORD PTR _outStrips$[esp+68]
	mov	ecx, DWORD PTR [edx+4]
	cmp	ecx, DWORD PTR [edx+8]
	je	SHORT $LN456@SplitUpStr

; 713  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [ecx], eax

; 714  :         _Orphan_range(_Mylast, _Mylast);
; 715  :         _Ty& _Result = *_Mylast;
; 716  :         ++_Mylast;

	add	DWORD PTR [edx+4], 4

; 731  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

	jmp	SHORT $LN463@SplitUpStr
$LN456@SplitUpStr:

; 732  :         }
; 733  : 
; 734  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	push	esi
	push	ecx
	mov	ecx, edx
	call	??$_Emplace_reallocate@ABQAVNvStripInfo@@@?$vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@std@@QAEPAPAVNvStripInfo@@QAPAV2@ABQAV2@@Z ; std::vector<NvStripInfo *,xalloc<NvStripInfo *> >::_Emplace_reallocate<NvStripInfo * const &>
$LN463@SplitUpStr:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 1043 : 		tempStrips2[firstIndex]->visited = true;

	mov	eax, DWORD PTR [esi]
	mov	BYTE PTR [eax+32], 1
$LN832@SplitUpStr:

; 1044 : 		
; 1045 : 		//this n^2 algo is what slows down stripification so much....
; 1046 : 		// needs to be improved
; 1047 : 		while(1)
; 1048 : 		{
; 1049 : 			bestNumHits = -1.0f;

	movss	xmm3, DWORD PTR __real@bf800000
	npad	1
$LL23@SplitUpStr:
	xor	ecx, ecx
	movaps	xmm2, xmm3
	mov	DWORD PTR _i$1$[esp+72], ecx

; 1050 : 			
; 1051 : 			//find best strip to add next, given the current cache
; 1052 : 			for(int i = 0; i < tempStrips2.size(); i++)

	test	edi, edi
	je	$LN779@SplitUpStr
$LL27@SplitUpStr:

; 1053 : 			{
; 1054 : 				if(tempStrips2[i]->visited)

	mov	eax, DWORD PTR [ebp+ecx*4]
	cmp	BYTE PTR [eax+32], 0
	jne	$LN824@SplitUpStr
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	esi, DWORD PTR [eax+12]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 1122 : 	int numHits = 0;

	xor	ebp, ebp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	eax, DWORD PTR [eax+16]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 1125 : 	for(int i = 0; i < strip->m_faces.size(); i++)

	xor	edx, edx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	sub	eax, esi
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 1123 : 	int numFaces = 0;

	mov	DWORD PTR _numFaces$1$[esp+68], ebp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	sar	eax, 2
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 1125 : 	for(int i = 0; i < strip->m_faces.size(); i++)

	mov	DWORD PTR _i$1$[esp+68], edx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	DWORD PTR $T7[esp+68], esi
	mov	DWORD PTR tv4175[esp+72], eax
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 1125 : 	for(int i = 0; i < strip->m_faces.size(); i++)

	test	eax, eax
	je	$LN822@SplitUpStr
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1535 :         auto& _My_data = _Mypair._Myval2;

	mov	edi, DWORD PTR [ebx+4]
	mov	ecx, DWORD PTR [ebx]
	npad	5
$LL518@SplitUpStr:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 1127 : 		if(vcache->InCache(strip->m_faces[i]->m_v0))

	mov	eax, DWORD PTR [esi+edx*4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	edx, edi
	sub	edx, ecx
	sar	edx, 2
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 1127 : 		if(vcache->InCache(strip->m_faces[i]->m_v0))

	mov	ebx, DWORD PTR [eax]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\VertexCache.h

; 28   : 	for(u32 i = 0; i < entries.size(); i++)

	xor	eax, eax
	test	edx, edx
	je	SHORT $LN546@SplitUpStr
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1463 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));

	mov	esi, ecx
$LL547@SplitUpStr:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\VertexCache.h

; 30   : 		if(entries[i] == entry)

	cmp	DWORD PTR [ecx+eax*4], ebx
	je	SHORT $LN776@SplitUpStr
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	esi, DWORD PTR _vcache$1$[esp+72]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\VertexCache.h

; 28   : 	for(u32 i = 0; i < entries.size(); i++)

	inc	eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	edi, DWORD PTR [esi+4]
	mov	esi, DWORD PTR [esi]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\VertexCache.h

; 28   : 	for(u32 i = 0; i < entries.size(); i++)

	cmp	eax, edx
	jb	SHORT $LL547@SplitUpStr
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 1065 : 			if(bestNumHits == -1.0f)

	mov	ecx, DWORD PTR _vcache$1$[esp+72]
	mov	esi, DWORD PTR [ecx]
	jmp	SHORT $LN829@SplitUpStr
$LN776@SplitUpStr:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\VertexCache.h

; 32   : 			returnVal = true;

	inc	ebp
$LN829@SplitUpStr:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1463 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));

	mov	eax, DWORD PTR _i$1$[esp+68]
	mov	ecx, DWORD PTR $T7[esp+68]
	mov	ebx, DWORD PTR [ecx+eax*4]
	mov	ecx, esi
	xor	eax, eax
	mov	ebx, DWORD PTR [ebx+4]
$LL591@SplitUpStr:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\VertexCache.h

; 30   : 		if(entries[i] == entry)

	cmp	DWORD PTR [esi+eax*4], ebx
	je	SHORT $LN777@SplitUpStr
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	ecx, DWORD PTR _vcache$1$[esp+72]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\VertexCache.h

; 28   : 	for(u32 i = 0; i < entries.size(); i++)

	inc	eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	edi, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR [ecx]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\VertexCache.h

; 28   : 	for(u32 i = 0; i < entries.size(); i++)

	cmp	eax, edx
	jb	SHORT $LL591@SplitUpStr
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 1065 : 			if(bestNumHits == -1.0f)

	mov	ecx, DWORD PTR _vcache$1$[esp+72]
	mov	ebx, ebp
	mov	ecx, DWORD PTR [ecx]
	jmp	SHORT $LN830@SplitUpStr
$LN777@SplitUpStr:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\VertexCache.h

; 32   : 			returnVal = true;

	lea	ebx, DWORD PTR [ebp+1]
$LN830@SplitUpStr:
	mov	esi, DWORD PTR _i$1$[esp+68]
	mov	ebp, DWORD PTR $T7[esp+68]
	mov	eax, DWORD PTR [ebp+esi*4]
	mov	esi, DWORD PTR [eax+8]
	xor	eax, eax
$LL635@SplitUpStr:

; 30   : 		if(entries[i] == entry)

	cmp	DWORD PTR [ecx+eax*4], esi
	je	SHORT $LN778@SplitUpStr

; 28   : 	for(u32 i = 0; i < entries.size(); i++)

	inc	eax
	cmp	eax, edx
	jb	SHORT $LL635@SplitUpStr
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 1065 : 			if(bestNumHits == -1.0f)

	mov	esi, DWORD PTR $T7[esp+68]
	jmp	SHORT $LN831@SplitUpStr
$LN778@SplitUpStr:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\VertexCache.h

; 32   : 			returnVal = true;

	mov	esi, DWORD PTR $T7[esp+68]
	mov	al, 1
	jmp	SHORT $LN634@SplitUpStr
$LN546@SplitUpStr:

; 28   : 	for(u32 i = 0; i < entries.size(); i++)

	mov	ebx, ebp
$LN831@SplitUpStr:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 1136 : 		numFaces++;

	xor	al, al
$LN634@SplitUpStr:

; 1125 : 	for(int i = 0; i < strip->m_faces.size(); i++)

	mov	edx, DWORD PTR _i$1$[esp+68]

; 1136 : 		numFaces++;

	lea	ebp, DWORD PTR [ebx+1]
	test	al, al
	mov	eax, DWORD PTR _numFaces$1$[esp+68]
	cmove	ebp, ebx
	inc	edx
	inc	eax
	mov	DWORD PTR _i$1$[esp+68], edx
	mov	DWORD PTR _numFaces$1$[esp+68], eax
	cmp	edx, DWORD PTR tv4175[esp+72]
	jb	$LL518@SplitUpStr
	mov	ebx, DWORD PTR _vcache$1$[esp+72]
	mov	ecx, DWORD PTR _i$1$[esp+72]

; 1125 : 	for(int i = 0; i < strip->m_faces.size(); i++)

	mov	edi, DWORD PTR $T2[esp+72]
	jmp	SHORT $LN805@SplitUpStr
$LN822@SplitUpStr:
	xor	eax, eax
$LN805@SplitUpStr:

; 1137 : 		
; 1138 : 	}
; 1139 : 	
; 1140 : 	return ((float)numHits / (float)numFaces);

	cvtsi2ss xmm1, ebp

; 1055 : 					continue;
; 1056 : 				
; 1057 : 				numHits = CalcNumHitsStrip(vcache, tempStrips2[i]);
; 1058 : 				if(numHits > bestNumHits)

	mov	ebp, DWORD PTR _tempStrips2$[esp+72]

; 1140 : 	return ((float)numHits / (float)numFaces);

	cvtsi2ss xmm0, eax
	divss	xmm1, xmm0

; 1055 : 					continue;
; 1056 : 				
; 1057 : 				numHits = CalcNumHitsStrip(vcache, tempStrips2[i]);
; 1058 : 				if(numHits > bestNumHits)

	comiss	xmm1, xmm2
	jbe	SHORT $LN824@SplitUpStr

; 1059 : 				{
; 1060 : 					bestNumHits = numHits;
; 1061 : 					bestIndex = i;

	mov	edx, ecx
	movaps	xmm2, xmm1
	mov	DWORD PTR _bestIndex$1$[esp+72], edx
	jmp	SHORT $LN25@SplitUpStr
$LN824@SplitUpStr:

; 1050 : 			
; 1051 : 			//find best strip to add next, given the current cache
; 1052 : 			for(int i = 0; i < tempStrips2.size(); i++)

	mov	edx, DWORD PTR _bestIndex$1$[esp+72]
$LN25@SplitUpStr:
	inc	ecx
	mov	DWORD PTR _i$1$[esp+72], ecx
	cmp	ecx, edi
	jb	$LL27@SplitUpStr

; 1065 : 			if(bestNumHits == -1.0f)

	ucomiss	xmm2, xmm3
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN779@SplitUpStr
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 119  :         _Ptr += _Off;

	lea	esi, DWORD PTR [edx*4]
	add	esi, ebp
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 1067 : 			tempStrips2[bestIndex]->visited = true;

	mov	eax, DWORD PTR [esi]
	mov	BYTE PTR [eax+32], 1

; 1068 : 			UpdateCacheStrip(vcache, tempStrips2[bestIndex]);

	push	DWORD PTR [esi]
	push	ebx
	call	?UpdateCacheStrip@NvStripifier@@IAEXPAVVertexCache@@PAVNvStripInfo@@@Z ; NvStripifier::UpdateCacheStrip
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 730  :         if (_Mylast != _My_data._Myend) {

	mov	edx, DWORD PTR _outStrips$[esp+68]
	mov	ecx, DWORD PTR [edx+4]
	cmp	ecx, DWORD PTR [edx+8]
	je	SHORT $LN713@SplitUpStr

; 713  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [ecx], eax

; 714  :         _Orphan_range(_Mylast, _Mylast);
; 715  :         _Ty& _Result = *_Mylast;
; 716  :         ++_Mylast;

	add	DWORD PTR [edx+4], 4

; 731  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

	jmp	$LL23@SplitUpStr
$LN713@SplitUpStr:

; 732  :         }
; 733  : 
; 734  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	push	esi
	push	ecx
	mov	ecx, edx
	call	??$_Emplace_reallocate@ABQAVNvStripInfo@@@?$vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@std@@QAEPAPAVNvStripInfo@@QAPAV2@ABQAV2@@Z ; std::vector<NvStripInfo *,xalloc<NvStripInfo *> >::_Emplace_reallocate<NvStripInfo * const &>
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 1070 : 		}

	jmp	$LN832@SplitUpStr
$LN779@SplitUpStr:
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h

; 151  : 	if (ptr) 

	test	ebx, ebx
	je	SHORT $LN825@SplitUpStr
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\VertexCache.cpp

; 18   : 	entries.clear	();

	mov	eax, DWORD PTR [ebx]
	mov	DWORD PTR [ebx+4], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	test	eax, eax
	je	SHORT $LN732@SplitUpStr
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [ebx], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [ebx+4], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [ebx+8], 0
$LN732@SplitUpStr:
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h

; 144  : 		Memory.mem_free	(ptr);

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	ebx
	mov	ebx, DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
	call	ebx

; 151  : 	if (ptr) 

	jmp	SHORT $LN718@SplitUpStr
$LN825@SplitUpStr:
	mov	ebx, DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN718@SplitUpStr:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	test	ebp, ebp
	je	SHORT $LN749@SplitUpStr
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	ebp
	call	ebx
$LN749@SplitUpStr:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR _tempStrips$[esp+72]
	test	eax, eax
	je	SHORT $LN761@SplitUpStr
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	ebx
$LN761@SplitUpStr:
	pop	edi
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 1074 : }

	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 56					; 00000038H
	ret	16					; 00000010H
?SplitUpStripsAndOptimize@NvStripifier@@IAEXAAV?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@0AAV?$xr_vector@PAVNvEdgeInfo@@V?$xalloc@PAVNvEdgeInfo@@@@@@AAV?$xr_vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@@@Z ENDP ; NvStripifier::SplitUpStripsAndOptimize
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\VertexCache.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\VertexCache.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\VertexCache.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\VertexCache.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\VertexCache.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\VertexCache.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
_TEXT	SEGMENT
_vcache$ = 8						; size = 4
_strip$ = 12						; size = 4
?UpdateCacheStrip@NvStripifier@@IAEXPAVVertexCache@@PAVNvStripInfo@@@Z PROC ; NvStripifier::UpdateCacheStrip
; _this$dead$ = ecx

; 1083 : {

	push	ebx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1535 :         auto& _My_data = _Mypair._Myval2;

	mov	ebx, DWORD PTR _strip$[esp]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 1083 : {

	push	ebp

; 1084 : 	for(int i = 0; i < strip->m_faces.size(); i++)

	xor	ebp, ebp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	eax, DWORD PTR [ebx+16]
	mov	ecx, DWORD PTR [ebx+12]
	sub	eax, ecx
	sar	eax, 2
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 1084 : 	for(int i = 0; i < strip->m_faces.size(); i++)

	test	eax, eax
	je	$LN3@UpdateCach
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1535 :         auto& _My_data = _Mypair._Myval2;

	push	esi
	mov	esi, DWORD PTR _vcache$[esp+8]
	push	edi
$LL4@UpdateCach:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 1086 : 		if(!vcache->InCache(strip->m_faces[i]->m_v0))

	mov	eax, DWORD PTR [ecx+ebp*4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	edx, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi]
	sub	edx, ecx
	sar	edx, 2
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 1086 : 		if(!vcache->InCache(strip->m_faces[i]->m_v0))

	mov	edi, DWORD PTR [eax]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\VertexCache.h

; 28   : 	for(u32 i = 0; i < entries.size(); i++)

	xor	eax, eax
	test	edx, edx
	je	SHORT $LN470@UpdateCach
$LL33@UpdateCach:

; 29   : 	{
; 30   : 		if(entries[i] == entry)

	cmp	DWORD PTR [ecx+eax*4], edi
	je	SHORT $LN158@UpdateCach

; 28   : 	for(u32 i = 0; i < entries.size(); i++)

	inc	eax
	cmp	eax, edx
	jb	SHORT $LL33@UpdateCach
$LN470@UpdateCach:

; 48   : 	for(int i = (u32)entries.size() - 2; i >= 0; i--)

	add	edx, -2					; fffffffeH
	js	SHORT $LN141@UpdateCach
$LL77@UpdateCach:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 119  :         _Ptr += _Off;

	mov	eax, DWORD PTR [esi]
	lea	ecx, DWORD PTR [eax+edx*4]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\VertexCache.h

; 48   : 	for(int i = (u32)entries.size() - 2; i >= 0; i--)

	sub	edx, 1

; 49   : 	{
; 50   : 		entries[i + 1] = entries[i];

	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [ecx+4], eax
	jns	SHORT $LL77@UpdateCach
	mov	ecx, DWORD PTR [esi]
$LN141@UpdateCach:

; 51   : 	}
; 52   : 
; 53   : 	entries[0] = entry;

	mov	DWORD PTR [ecx], edi
$LN158@UpdateCach:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 1089 : 		if(!vcache->InCache(strip->m_faces[i]->m_v1))

	mov	eax, DWORD PTR [ebx+12]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	edx, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi]
	sub	edx, ecx
	sar	edx, 2
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 1089 : 		if(!vcache->InCache(strip->m_faces[i]->m_v1))

	mov	eax, DWORD PTR [eax+ebp*4]
	mov	edi, DWORD PTR [eax+4]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\VertexCache.h

; 28   : 	for(u32 i = 0; i < entries.size(); i++)

	xor	eax, eax
	test	edx, edx
	je	SHORT $LN471@UpdateCach
$LL175@UpdateCach:

; 29   : 	{
; 30   : 		if(entries[i] == entry)

	cmp	DWORD PTR [ecx+eax*4], edi
	je	SHORT $LN300@UpdateCach

; 28   : 	for(u32 i = 0; i < entries.size(); i++)

	inc	eax
	cmp	eax, edx
	jb	SHORT $LL175@UpdateCach
$LN471@UpdateCach:

; 48   : 	for(int i = (u32)entries.size() - 2; i >= 0; i--)

	add	edx, -2					; fffffffeH
	js	SHORT $LN283@UpdateCach
$LL219@UpdateCach:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 119  :         _Ptr += _Off;

	mov	eax, DWORD PTR [esi]
	lea	ecx, DWORD PTR [eax+edx*4]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\VertexCache.h

; 48   : 	for(int i = (u32)entries.size() - 2; i >= 0; i--)

	sub	edx, 1

; 49   : 	{
; 50   : 		entries[i + 1] = entries[i];

	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [ecx+4], eax
	jns	SHORT $LL219@UpdateCach
	mov	ecx, DWORD PTR [esi]
$LN283@UpdateCach:

; 51   : 	}
; 52   : 
; 53   : 	entries[0] = entry;

	mov	DWORD PTR [ecx], edi
$LN300@UpdateCach:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 1092 : 		if(!vcache->InCache(strip->m_faces[i]->m_v2))

	mov	eax, DWORD PTR [ebx+12]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	edx, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi]
	sub	edx, ecx
	sar	edx, 2
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 1092 : 		if(!vcache->InCache(strip->m_faces[i]->m_v2))

	mov	eax, DWORD PTR [eax+ebp*4]
	mov	edi, DWORD PTR [eax+8]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\VertexCache.h

; 28   : 	for(u32 i = 0; i < entries.size(); i++)

	xor	eax, eax
	test	edx, edx
	je	SHORT $LN472@UpdateCach
	npad	4
$LL317@UpdateCach:

; 29   : 	{
; 30   : 		if(entries[i] == entry)

	cmp	DWORD PTR [ecx+eax*4], edi
	je	SHORT $LN2@UpdateCach

; 28   : 	for(u32 i = 0; i < entries.size(); i++)

	inc	eax
	cmp	eax, edx
	jb	SHORT $LL317@UpdateCach
$LN472@UpdateCach:

; 48   : 	for(int i = (u32)entries.size() - 2; i >= 0; i--)

	add	edx, -2					; fffffffeH
	js	SHORT $LN425@UpdateCach
	npad	1
$LL361@UpdateCach:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 119  :         _Ptr += _Off;

	mov	eax, DWORD PTR [esi]
	lea	ecx, DWORD PTR [eax+edx*4]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\VertexCache.h

; 48   : 	for(int i = (u32)entries.size() - 2; i >= 0; i--)

	sub	edx, 1

; 49   : 	{
; 50   : 		entries[i + 1] = entries[i];

	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [ecx+4], eax
	jns	SHORT $LL361@UpdateCach
	mov	ecx, DWORD PTR [esi]
$LN425@UpdateCach:

; 51   : 	}
; 52   : 
; 53   : 	entries[0] = entry;

	mov	DWORD PTR [ecx], edi
$LN2@UpdateCach:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	eax, DWORD PTR [ebx+16]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 1084 : 	for(int i = 0; i < strip->m_faces.size(); i++)

	inc	ebp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	ecx, DWORD PTR [ebx+12]
	sub	eax, ecx
	sar	eax, 2
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 1084 : 	for(int i = 0; i < strip->m_faces.size(); i++)

	cmp	ebp, eax
	jb	$LL4@UpdateCach
	pop	edi
	pop	esi
$LN3@UpdateCach:
	pop	ebp

; 1093 : 			vcache->AddEntry(strip->m_faces[i]->m_v2);
; 1094 : 	}
; 1095 : }

	pop	ebx
	ret	8
?UpdateCacheStrip@NvStripifier@@IAEXPAVVertexCache@@PAVNvStripInfo@@@Z ENDP ; NvStripifier::UpdateCacheStrip
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\VertexCache.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\VertexCache.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\VertexCache.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\VertexCache.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\VertexCache.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\VertexCache.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\VertexCache.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
_TEXT	SEGMENT
_vcache$ = 8						; size = 4
_face$ = 12						; size = 4
?UpdateCacheFace@NvStripifier@@IAEXPAVVertexCache@@PAVNvFaceInfo@@@Z PROC ; NvStripifier::UpdateCacheFace
; _this$dead$ = ecx

; 1103 : {

	push	ebx
	push	ebp

; 1104 : 	if(!vcache->InCache(face->m_v0))

	mov	ebp, DWORD PTR _face$[esp+4]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\VertexCache.h

; 28   : 	for(u32 i = 0; i < entries.size(); i++)

	xor	ecx, ecx
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 1103 : {

	push	esi
	push	edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	edi, DWORD PTR _vcache$[esp+12]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 1104 : 	if(!vcache->InCache(face->m_v0))

	mov	esi, DWORD PTR [ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	ebx, DWORD PTR [edi+4]
	mov	edx, ebx
	mov	eax, DWORD PTR [edi]
	sub	edx, eax
	sar	edx, 2
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\VertexCache.h

; 28   : 	for(u32 i = 0; i < entries.size(); i++)

	test	edx, edx
	je	SHORT $LN8@UpdateCach
$LL9@UpdateCach:

; 29   : 	{
; 30   : 		if(entries[i] == entry)

	cmp	DWORD PTR [eax], esi
	je	SHORT $LN90@UpdateCach

; 28   : 	for(u32 i = 0; i < entries.size(); i++)

	inc	ecx
	add	eax, 4
	cmp	ecx, edx
	jb	SHORT $LL9@UpdateCach
$LN8@UpdateCach:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 1105 : 		vcache->AddEntry(face->m_v0);

	push	esi
	mov	ecx, edi
	call	?AddEntry@VertexCache@@QAEHH@Z		; VertexCache::AddEntry
	mov	ebx, DWORD PTR [edi+4]
$LN90@UpdateCach:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	eax, DWORD PTR [edi]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 1107 : 	if(!vcache->InCache(face->m_v1))

	mov	ecx, ebx
	mov	ebp, DWORD PTR [ebp+4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	esi, ecx
	sub	esi, eax
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\VertexCache.h

; 28   : 	for(u32 i = 0; i < entries.size(); i++)

	xor	edx, edx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	sar	esi, 2
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\VertexCache.h

; 28   : 	for(u32 i = 0; i < entries.size(); i++)

	test	esi, esi
	je	SHORT $LN35@UpdateCach
	npad	4
$LL36@UpdateCach:

; 29   : 	{
; 30   : 		if(entries[i] == entry)

	cmp	DWORD PTR [eax], ebp
	je	SHORT $LN3@UpdateCach

; 28   : 	for(u32 i = 0; i < entries.size(); i++)

	inc	edx
	add	eax, 4
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	ecx, ebx
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\VertexCache.h

; 28   : 	for(u32 i = 0; i < entries.size(); i++)

	cmp	edx, esi
	jb	SHORT $LL36@UpdateCach
$LN35@UpdateCach:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 1108 : 		vcache->AddEntry(face->m_v1);

	push	ebp
	mov	ecx, edi
	call	?AddEntry@VertexCache@@QAEHH@Z		; VertexCache::AddEntry
	mov	ecx, DWORD PTR [edi+4]
$LN3@UpdateCach:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	eax, DWORD PTR [edi]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\VertexCache.h

; 28   : 	for(u32 i = 0; i < entries.size(); i++)

	xor	edx, edx
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 1110 : 	if(!vcache->InCache(face->m_v2))

	mov	esi, DWORD PTR _face$[esp+12]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	sub	ecx, eax
	sar	ecx, 2
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 1110 : 	if(!vcache->InCache(face->m_v2))

	mov	esi, DWORD PTR [esi+8]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\VertexCache.h

; 28   : 	for(u32 i = 0; i < entries.size(); i++)

	test	ecx, ecx
	je	SHORT $LN102@UpdateCach
	npad	3
$LL63@UpdateCach:

; 29   : 	{
; 30   : 		if(entries[i] == entry)

	cmp	DWORD PTR [eax], esi
	je	SHORT $LN4@UpdateCach

; 28   : 	for(u32 i = 0; i < entries.size(); i++)

	inc	edx
	add	eax, 4
	cmp	edx, ecx
	jb	SHORT $LL63@UpdateCach
$LN102@UpdateCach:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 1111 : 		vcache->AddEntry(face->m_v2);

	push	esi
	mov	ecx, edi
	call	?AddEntry@VertexCache@@QAEHH@Z		; VertexCache::AddEntry
$LN4@UpdateCach:

; 1112 : }

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	ret	8
?UpdateCacheFace@NvStripifier@@IAEXPAVVertexCache@@PAVNvFaceInfo@@@Z ENDP ; NvStripifier::UpdateCacheFace
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\VertexCache.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\VertexCache.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\VertexCache.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\VertexCache.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\VertexCache.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
_TEXT	SEGMENT
_numHits$1$ = -28					; size = 4
_numFaces$ = -24					; size = 4
tv951 = -20						; size = 4
tv955 = -16						; size = 4
_numHits$ = -16						; size = 4
_i$1$ = -12						; size = 4
$T1 = -8						; size = 4
tv960 = -4						; size = 4
tv950 = 8						; size = 4
_vcache$ = 8						; size = 4
tv958 = 12						; size = 4
_strip$ = 12						; size = 4
?CalcNumHitsStrip@NvStripifier@@IAEMPAVVertexCache@@PAVNvStripInfo@@@Z PROC ; NvStripifier::CalcNumHitsStrip
; _this$dead$ = ecx

; 1121 : {

	sub	esp, 28					; 0000001cH
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1535 :         auto& _My_data = _Mypair._Myval2;

	mov	eax, DWORD PTR _strip$[esp+24]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 1125 : 	for(int i = 0; i < strip->m_faces.size(); i++)

	xor	edx, edx
	push	edi
	xor	edi, edi
	mov	DWORD PTR _i$1$[esp+32], edx
	mov	DWORD PTR _numHits$1$[esp+32], edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	ecx, DWORD PTR [eax+12]
	mov	eax, DWORD PTR [eax+16]
	sub	eax, ecx
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 1122 : 	int numHits = 0;

	mov	DWORD PTR _numHits$[esp+32], edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	sar	eax, 2
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 1123 : 	int numFaces = 0;

	mov	DWORD PTR _numFaces$[esp+32], edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	DWORD PTR $T1[esp+32], ecx
	mov	DWORD PTR tv960[esp+32], eax
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 1125 : 	for(int i = 0; i < strip->m_faces.size(); i++)

	test	eax, eax
	je	$LN3@CalcNumHit
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1535 :         auto& _My_data = _Mypair._Myval2;

	mov	eax, DWORD PTR _vcache$[esp+28]
	push	ebx
	push	ebp
	push	esi
	mov	ebx, DWORD PTR [eax+4]
	mov	esi, ebx
	mov	ebp, DWORD PTR [eax]
	mov	ecx, ebp
	mov	DWORD PTR tv951[esp+44], ebx
	mov	DWORD PTR tv955[esp+44], ebp
	npad	1
$LL4@CalcNumHit:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 1127 : 		if(vcache->InCache(strip->m_faces[i]->m_v0))

	mov	eax, DWORD PTR $T1[esp+44]
	mov	eax, DWORD PTR [eax+edx*4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	edx, esi
	sub	edx, ecx
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 1127 : 		if(vcache->InCache(strip->m_faces[i]->m_v0))

	mov	DWORD PTR tv958[esp+40], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	sar	edx, 2
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\VertexCache.h

; 28   : 	for(u32 i = 0; i < entries.size(); i++)

	xor	eax, eax
	test	edx, edx
	je	$LN32@CalcNumHit
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1463 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));

	mov	edi, ecx
	npad	2
$LL33@CalcNumHit:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\VertexCache.h

; 30   : 		if(entries[i] == entry)

	mov	ebp, DWORD PTR tv958[esp+40]
	mov	ebx, DWORD PTR [ebp]
	cmp	DWORD PTR [ecx+eax*4], ebx
	mov	ebx, DWORD PTR tv951[esp+44]
	mov	ebp, DWORD PTR tv955[esp+44]
	je	SHORT $LN149@CalcNumHit

; 28   : 	for(u32 i = 0; i < entries.size(); i++)

	inc	eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	esi, ebx
	mov	edi, ebp
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\VertexCache.h

; 28   : 	for(u32 i = 0; i < entries.size(); i++)

	cmp	eax, edx
	jb	SHORT $LL33@CalcNumHit

; 30   : 		if(entries[i] == entry)

	jmp	SHORT $LN165@CalcNumHit
$LN149@CalcNumHit:

; 32   : 			returnVal = true;

	inc	DWORD PTR _numHits$1$[esp+44]
$LN165@CalcNumHit:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1463 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));

	mov	ecx, edi
	xor	eax, eax
	npad	9
$LL77@CalcNumHit:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\VertexCache.h

; 30   : 		if(entries[i] == entry)

	mov	ebp, DWORD PTR tv958[esp+40]
	mov	ebx, DWORD PTR [ebp+4]
	cmp	DWORD PTR [edi+eax*4], ebx
	mov	ebx, DWORD PTR tv951[esp+44]
	mov	ebp, DWORD PTR tv955[esp+44]
	je	SHORT $LN150@CalcNumHit

; 28   : 	for(u32 i = 0; i < entries.size(); i++)

	inc	eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	esi, ebx
	mov	ecx, ebp
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\VertexCache.h

; 28   : 	for(u32 i = 0; i < entries.size(); i++)

	cmp	eax, edx
	jb	SHORT $LL77@CalcNumHit

; 30   : 		if(entries[i] == entry)

	mov	eax, DWORD PTR _numHits$1$[esp+44]
	jmp	SHORT $LN166@CalcNumHit
$LN150@CalcNumHit:

; 32   : 			returnVal = true;

	mov	eax, DWORD PTR _numHits$1$[esp+44]
	inc	eax
$LN166@CalcNumHit:
	mov	DWORD PTR tv950[esp+40], eax
	mov	eax, DWORD PTR tv958[esp+40]
	mov	edi, DWORD PTR [eax+8]
	xor	eax, eax
$LL121@CalcNumHit:

; 30   : 		if(entries[i] == entry)

	cmp	DWORD PTR [ecx+eax*4], edi
	je	SHORT $LN151@CalcNumHit

; 28   : 	for(u32 i = 0; i < entries.size(); i++)

	inc	eax
	cmp	eax, edx
	jb	SHORT $LL121@CalcNumHit

; 30   : 		if(entries[i] == entry)

	mov	edx, DWORD PTR tv950[esp+40]
	jmp	SHORT $LN167@CalcNumHit
$LN151@CalcNumHit:

; 31   : 		{
; 32   : 			returnVal = true;

	mov	edx, DWORD PTR tv950[esp+40]
	mov	al, 1
	jmp	SHORT $LN120@CalcNumHit
$LN32@CalcNumHit:

; 28   : 	for(u32 i = 0; i < entries.size(); i++)

	mov	edx, edi
$LN167@CalcNumHit:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 1136 : 		numFaces++;

	xor	al, al
$LN120@CalcNumHit:
	lea	edi, DWORD PTR [edx+1]
	test	al, al
	cmove	edi, edx
	mov	edx, DWORD PTR _i$1$[esp+44]
	inc	DWORD PTR _numFaces$[esp+44]
	inc	edx
	mov	DWORD PTR _numHits$1$[esp+44], edi
	mov	DWORD PTR _i$1$[esp+44], edx
	cmp	edx, DWORD PTR tv960[esp+44]
	jb	$LL4@CalcNumHit
	pop	esi
	pop	ebp
	mov	DWORD PTR _numHits$[esp+36], edi
	pop	ebx
$LN3@CalcNumHit:

; 1137 : 		
; 1138 : 	}
; 1139 : 	
; 1140 : 	return ((float)numHits / (float)numFaces);

	fild	DWORD PTR _numHits$[esp+32]
	pop	edi
	fidiv	DWORD PTR _numFaces$[esp+28]

; 1141 : }

	add	esp, 28					; 0000001cH
	ret	8
?CalcNumHitsStrip@NvStripifier@@IAEMPAVVertexCache@@PAVNvStripInfo@@@Z ENDP ; NvStripifier::CalcNumHitsStrip
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\VertexCache.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\VertexCache.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\VertexCache.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
_TEXT	SEGMENT
_vcache$ = 8						; size = 4
_face$ = 12						; size = 4
?CalcNumHitsFace@NvStripifier@@IAEHPAVVertexCache@@PAVNvFaceInfo@@@Z PROC ; NvStripifier::CalcNumHitsFace
; _this$dead$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	eax, DWORD PTR _vcache$[esp-4]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\VertexCache.h

; 28   : 	for(u32 i = 0; i < entries.size(); i++)

	xor	edx, edx
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 1150 : {

	push	ebx
	mov	ebx, DWORD PTR _face$[esp]
	push	esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR [eax+4]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 1153 : 	if(vcache->InCache(face->m_v0))

	mov	esi, DWORD PTR [ebx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	sub	eax, ecx
	sar	eax, 2
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\VertexCache.h

; 28   : 	for(u32 i = 0; i < entries.size(); i++)

	test	eax, eax
	je	SHORT $LN35@CalcNumHit
	push	ebp
	push	edi
	npad	2
$LL9@CalcNumHit:

; 29   : 	{
; 30   : 		if(entries[i] == entry)

	cmp	DWORD PTR [ecx+edx*4], esi
	je	SHORT $LN90@CalcNumHit

; 28   : 	for(u32 i = 0; i < entries.size(); i++)

	inc	edx
	cmp	edx, eax
	jb	SHORT $LL9@CalcNumHit

; 30   : 		if(entries[i] == entry)

	xor	ebp, ebp
	xor	esi, esi
	jmp	SHORT $LN109@CalcNumHit
$LN90@CalcNumHit:

; 32   : 			returnVal = true;

	mov	ebp, 1
	mov	esi, ebp
$LN109@CalcNumHit:
	mov	edi, DWORD PTR [ebx+4]
	xor	edx, edx
	npad	4
$LL36@CalcNumHit:

; 30   : 		if(entries[i] == entry)

	cmp	DWORD PTR [ecx+edx*4], edi
	je	SHORT $LN103@CalcNumHit

; 28   : 	for(u32 i = 0; i < entries.size(); i++)

	inc	edx
	cmp	edx, eax
	jb	SHORT $LL36@CalcNumHit

; 30   : 		if(entries[i] == entry)

	mov	edi, DWORD PTR [ebx+8]
	jmp	SHORT $LN105@CalcNumHit
$LN103@CalcNumHit:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 1159 : 	if(vcache->InCache(face->m_v2))

	mov	edi, DWORD PTR [ebx+8]
	lea	esi, DWORD PTR [ebp+1]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\VertexCache.h

; 28   : 	for(u32 i = 0; i < entries.size(); i++)

	test	eax, eax
	je	SHORT $LN106@CalcNumHit
$LN105@CalcNumHit:
	xor	edx, edx
	npad	5
$LL63@CalcNumHit:

; 29   : 	{
; 30   : 		if(entries[i] == entry)

	cmp	DWORD PTR [ecx], edi
	je	SHORT $LN92@CalcNumHit

; 28   : 	for(u32 i = 0; i < entries.size(); i++)

	inc	edx
	add	ecx, 4
	cmp	edx, eax
	jb	SHORT $LL63@CalcNumHit
$LN106@CalcNumHit:
	pop	edi
	pop	ebp
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 1162 : 	return numHits;

	mov	eax, esi
	pop	esi

; 1163 : }

	pop	ebx
	ret	8
$LN92@CalcNumHit:
	pop	edi
	pop	ebp

; 1160 : 		numHits++;

	lea	eax, DWORD PTR [esi+1]
	pop	esi

; 1163 : }

	pop	ebx
	ret	8
$LN35@CalcNumHit:
	pop	esi

; 1162 : 	return numHits;

	xor	eax, eax

; 1163 : }

	pop	ebx
	ret	8
?CalcNumHitsFace@NvStripifier@@IAEHPAVVertexCache@@PAVNvFaceInfo@@@Z ENDP ; NvStripifier::CalcNumHitsFace
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
_TEXT	SEGMENT
tv556 = 8						; size = 4
_face$ = 8						; size = 4
_edgeInfoVec$ = 12					; size = 4
?NumNeighbors@NvStripifier@@IAEHPAVNvFaceInfo@@AAV?$xr_vector@PAVNvEdgeInfo@@V?$xalloc@PAVNvEdgeInfo@@@@@@@Z PROC ; NvStripifier::NumNeighbors
; _this$dead$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 119  :         _Ptr += _Off;

	mov	eax, DWORD PTR _edgeInfoVec$[esp-4]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 1172 : {

	push	ebp

; 1173 : 	int numNeighbors = 0;
; 1174 : 	
; 1175 : 	if(FindOtherFace(edgeInfoVec, face->m_v0, face->m_v1, face) != NULL)

	mov	ebp, DWORD PTR _face$[esp]
	push	esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 119  :         _Ptr += _Off;

	mov	eax, DWORD PTR [eax]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 1172 : {

	push	edi

; 1173 : 	int numNeighbors = 0;
; 1174 : 	
; 1175 : 	if(FindOtherFace(edgeInfoVec, face->m_v0, face->m_v1, face) != NULL)

	mov	edi, DWORD PTR [ebp]
	mov	esi, DWORD PTR [ebp+4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 119  :         _Ptr += _Off;

	mov	DWORD PTR tv556[esp+8], eax
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 33   : 	NvEdgeInfo *infoIter = edgeInfos[v0];

	mov	eax, DWORD PTR [eax+edi*4]

; 34   : 	while (infoIter != NULL){

	test	eax, eax
	je	SHORT $LN12@NumNeighbo
	npad	2
$LL11@NumNeighbo:

; 35   : 		if (infoIter->m_v0 == v0){

	mov	ecx, DWORD PTR [eax+12]
	cmp	ecx, edi
	jne	SHORT $LN13@NumNeighbo

; 36   : 			if (infoIter->m_v1 == v1)

	cmp	DWORD PTR [eax+16], esi
	je	SHORT $LN10@NumNeighbo

; 37   : 				return infoIter;
; 38   : 			else
; 39   : 				infoIter = infoIter->m_nextV0;

	mov	eax, DWORD PTR [eax+20]

; 40   : 		}

	jmp	SHORT $LN18@NumNeighbo
$LN13@NumNeighbo:

; 41   : 		else {
; 42   : 			assert(infoIter->m_v1 == v0);
; 43   : 			if (infoIter->m_v0 == v1)

	cmp	ecx, esi
	je	SHORT $LN10@NumNeighbo

; 44   : 				return infoIter;
; 45   : 			else
; 46   : 				infoIter = infoIter->m_nextV1;

	mov	eax, DWORD PTR [eax+24]
$LN18@NumNeighbo:

; 34   : 	while (infoIter != NULL){

	test	eax, eax
	jne	SHORT $LL11@NumNeighbo
$LN12@NumNeighbo:

; 47   : 		}
; 48   : 	}
; 49   : 	return NULL;

	xor	eax, eax
$LN10@NumNeighbo:

; 62   : 	return (edgeInfo->m_face0 == faceInfo ? edgeInfo->m_face1 : edgeInfo->m_face0);

	mov	ecx, DWORD PTR [eax+4]
	cmp	ecx, ebp
	jne	SHORT $LN8@NumNeighbo
	mov	ecx, DWORD PTR [eax+8]
$LN8@NumNeighbo:

; 33   : 	NvEdgeInfo *infoIter = edgeInfos[v0];

	mov	eax, DWORD PTR tv556[esp+8]

; 1176 : 	{
; 1177 : 		numNeighbors++;
; 1178 : 	}
; 1179 : 	
; 1180 : 	if(FindOtherFace(edgeInfoVec, face->m_v1, face->m_v2, face) != NULL)

	mov	edx, DWORD PTR [ebp+8]
	push	ebx
	xor	ebx, ebx
	test	ecx, ecx

; 33   : 	NvEdgeInfo *infoIter = edgeInfos[v0];

	mov	eax, DWORD PTR [eax+esi*4]

; 1176 : 	{
; 1177 : 		numNeighbors++;
; 1178 : 	}
; 1179 : 	
; 1180 : 	if(FindOtherFace(edgeInfoVec, face->m_v1, face->m_v2, face) != NULL)

	setne	bl

; 34   : 	while (infoIter != NULL){

	test	eax, eax
	je	SHORT $LN43@NumNeighbo
	npad	2
$LL42@NumNeighbo:

; 35   : 		if (infoIter->m_v0 == v0){

	mov	ecx, DWORD PTR [eax+12]
	cmp	ecx, esi
	jne	SHORT $LN44@NumNeighbo

; 36   : 			if (infoIter->m_v1 == v1)

	cmp	DWORD PTR [eax+16], edx
	je	SHORT $LN41@NumNeighbo

; 37   : 				return infoIter;
; 38   : 			else
; 39   : 				infoIter = infoIter->m_nextV0;

	mov	eax, DWORD PTR [eax+20]

; 40   : 		}

	jmp	SHORT $LN49@NumNeighbo
$LN44@NumNeighbo:

; 41   : 		else {
; 42   : 			assert(infoIter->m_v1 == v0);
; 43   : 			if (infoIter->m_v0 == v1)

	cmp	ecx, edx
	je	SHORT $LN41@NumNeighbo

; 44   : 				return infoIter;
; 45   : 			else
; 46   : 				infoIter = infoIter->m_nextV1;

	mov	eax, DWORD PTR [eax+24]
$LN49@NumNeighbo:

; 34   : 	while (infoIter != NULL){

	test	eax, eax
	jne	SHORT $LL42@NumNeighbo
$LN43@NumNeighbo:

; 47   : 		}
; 48   : 	}
; 49   : 	return NULL;

	xor	eax, eax
$LN41@NumNeighbo:

; 62   : 	return (edgeInfo->m_face0 == faceInfo ? edgeInfo->m_face1 : edgeInfo->m_face0);

	mov	ecx, DWORD PTR [eax+4]
	cmp	ecx, ebp
	jne	SHORT $LN39@NumNeighbo
	mov	ecx, DWORD PTR [eax+8]
$LN39@NumNeighbo:

; 33   : 	NvEdgeInfo *infoIter = edgeInfos[v0];

	mov	eax, DWORD PTR tv556[esp+12]

; 1181 : 	{
; 1182 : 		numNeighbors++;
; 1183 : 	}
; 1184 : 	
; 1185 : 	if(FindOtherFace(edgeInfoVec, face->m_v2, face->m_v0, face) != NULL)

	lea	esi, DWORD PTR [ebx+1]
	test	ecx, ecx
	cmove	esi, ebx

; 33   : 	NvEdgeInfo *infoIter = edgeInfos[v0];

	mov	eax, DWORD PTR [eax+edx*4]
	pop	ebx

; 34   : 	while (infoIter != NULL){

	test	eax, eax
	je	SHORT $LN74@NumNeighbo
	npad	4
$LL73@NumNeighbo:

; 35   : 		if (infoIter->m_v0 == v0){

	mov	ecx, DWORD PTR [eax+12]
	cmp	ecx, edx
	jne	SHORT $LN75@NumNeighbo

; 36   : 			if (infoIter->m_v1 == v1)

	cmp	DWORD PTR [eax+16], edi
	je	SHORT $LN72@NumNeighbo

; 37   : 				return infoIter;
; 38   : 			else
; 39   : 				infoIter = infoIter->m_nextV0;

	mov	eax, DWORD PTR [eax+20]

; 40   : 		}

	jmp	SHORT $LN80@NumNeighbo
$LN75@NumNeighbo:

; 41   : 		else {
; 42   : 			assert(infoIter->m_v1 == v0);
; 43   : 			if (infoIter->m_v0 == v1)

	cmp	ecx, edi
	je	SHORT $LN72@NumNeighbo

; 44   : 				return infoIter;
; 45   : 			else
; 46   : 				infoIter = infoIter->m_nextV1;

	mov	eax, DWORD PTR [eax+24]
$LN80@NumNeighbo:

; 34   : 	while (infoIter != NULL){

	test	eax, eax
	jne	SHORT $LL73@NumNeighbo
$LN74@NumNeighbo:

; 47   : 		}
; 48   : 	}
; 49   : 	return NULL;

	xor	eax, eax
$LN72@NumNeighbo:

; 62   : 	return (edgeInfo->m_face0 == faceInfo ? edgeInfo->m_face1 : edgeInfo->m_face0);

	mov	ecx, DWORD PTR [eax+4]
	cmp	ecx, ebp
	jne	SHORT $LN70@NumNeighbo
	mov	ecx, DWORD PTR [eax+8]
$LN70@NumNeighbo:

; 1186 : 	{
; 1187 : 		numNeighbors++;
; 1188 : 	}
; 1189 : 	
; 1190 : 	return numNeighbors;

	lea	eax, DWORD PTR [esi+1]
	test	ecx, ecx
	pop	edi
	cmove	eax, esi
	pop	esi
	pop	ebp

; 1191 : }

	ret	8
?NumNeighbors@NvStripifier@@IAEHPAVNvFaceInfo@@AAV?$xr_vector@PAVNvEdgeInfo@@V?$xalloc@PAVNvEdgeInfo@@@@@@@Z ENDP ; NvStripifier::NumNeighbors
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
_TEXT	SEGMENT
_numStrips$ = -4					; size = 4
tv373 = 8						; size = 4
tv370 = 8						; size = 4
$T1 = 8							; size = 4
_strips$ = 8						; size = 4
?AvgStripSize@NvStripifier@@IAEMABV?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@Z PROC ; NvStripifier::AvgStripSize
; _this$dead$ = ecx

; 1199 : float NvStripifier::AvgStripSize(const NvStripInfoVec &strips){

	push	ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	eax, DWORD PTR _strips$[esp]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 1199 : float NvStripifier::AvgStripSize(const NvStripInfoVec &strips){

	xor	ecx, ecx
	push	ebx
	push	ebp
	push	esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	esi, DWORD PTR [eax+4]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 1199 : float NvStripifier::AvgStripSize(const NvStripInfoVec &strips){

	xor	ebp, ebp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	ebx, DWORD PTR [eax]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 1200 : 	int sizeAccum = 0;

	xor	edx, edx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	sub	esi, ebx
	sar	esi, 2
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 1199 : float NvStripifier::AvgStripSize(const NvStripInfoVec &strips){

	push	edi

; 1200 : 	int sizeAccum = 0;

	xor	edi, edi

; 1201 : 	int numStrips = strips.size();

	mov	DWORD PTR _numStrips$[esp+20], esi

; 1202 : 	for (int i = 0; i < numStrips; i++){

	cmp	esi, 2
	jl	SHORT $LC31@AvgStripSi
	lea	eax, DWORD PTR [esi-1]
	mov	esi, eax
	npad	7
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1468 :         return const_iterator(_My_data._Myfirst, _STD addressof(_My_data));

$LL32@AvgStripSi:

; 1535 :         auto& _My_data = _Mypair._Myval2;

	mov	ecx, DWORD PTR [ebx+edx*4]

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	eax, DWORD PTR [ecx+16]
	sub	eax, DWORD PTR [ecx+12]
	mov	ecx, DWORD PTR [ebx+edx*4+4]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 1204 : 		sizeAccum += strip->m_faces.size();

	add	edx, 2
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	sar	eax, 2
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 1204 : 		sizeAccum += strip->m_faces.size();

	add	ebp, eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	eax, DWORD PTR [ecx+16]
	sub	eax, DWORD PTR [ecx+12]
	sar	eax, 2
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 1204 : 		sizeAccum += strip->m_faces.size();

	add	edi, eax
	cmp	edx, esi
	jl	SHORT $LL32@AvgStripSi

; 1202 : 	for (int i = 0; i < numStrips; i++){

	mov	DWORD PTR $T1[esp+16], edi
	mov	edi, 0
	mov	ecx, DWORD PTR $T1[esp+16]
	cmp	edx, DWORD PTR _numStrips$[esp+20]
	jl	SHORT $LL4@AvgStripSi
	jmp	SHORT $LN30@AvgStripSi
$LC31@AvgStripSi:
	test	esi, esi
	jle	SHORT $LN30@AvgStripSi
	npad	3
$LL4@AvgStripSi:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1535 :         auto& _My_data = _Mypair._Myval2;

	mov	eax, DWORD PTR [ebx+edx*4]

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	edi, DWORD PTR [eax+16]
	sub	edi, DWORD PTR [eax+12]
	sar	edi, 2
$LN30@AvgStripSi:
	lea	eax, DWORD PTR [ecx+ebp]
	add	eax, edi
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 1206 : 	return ((float)sizeAccum) / ((float)numStrips);

	mov	DWORD PTR tv373[esp+16], eax
	fild	DWORD PTR tv373[esp+16]
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	fidiv	DWORD PTR _numStrips$[esp+4]

; 1207 : }

	pop	ecx
	ret	4
?AvgStripSize@NvStripifier@@IAEMABV?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@Z ENDP ; NvStripifier::AvgStripSize
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xtree
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xtree
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xtree
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xtree
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xtree
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xtree
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xtree
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xtree
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xtree
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp
_TEXT	SEGMENT
$T3 = -188						; size = 4
_experiments$1$ = -188					; size = 4
$T4 = -184						; size = 4
_i$1$ = -184						; size = 4
_i$3$ = -184						; size = 4
tv5783 = -184						; size = 4
_stripIter$5 = -184					; size = 4
_strip02$6 = -184					; size = 4
_strip20$7 = -184					; size = 4
_strip21$8 = -184					; size = 4
_strip12$9 = -184					; size = 4
_strip10$10 = -184					; size = 4
_strip01$11 = -184					; size = 4
_stripId$1$ = -180					; size = 4
_numStrips$1$ = -176					; size = 4
_experimentId$1$ = -176					; size = 4
tv5832 = -176						; size = 4
tv5805 = -176						; size = 4
tv5801 = -176						; size = 4
tv5781 = -176						; size = 4
_bestValue$12 = -176					; size = 4
_experimentId$1$ = -172					; size = 4
_i$2$ = -168						; size = 4
tv5845 = -168						; size = 4
tv5803 = -168						; size = 4
_nextFace$13 = -168					; size = 4
_done$1$ = -161						; size = 1
_experimentIndex$1$ = -160				; size = 4
$T14 = -156						; size = 4
_i$1$ = -156						; size = 4
tv5785 = -156						; size = 4
_v$1$ = -152						; size = 4
_bestIndex$1$ = -152					; size = 4
_numStrips$1$ = -148					; size = 4
tv5875 = -148						; size = 4
tv5872 = -148						; size = 4
tv5818 = -148						; size = 4
_strip$15 = -148					; size = 4
_value$16 = -148					; size = 4
_experiments$17 = -144					; size = 12
_resetPoints$18 = -132					; size = 8
tv5755 = -124						; size = 4
_numStrips$19 = -124					; size = 4
$T20 = -117						; size = 1
_this$1$ = -116						; size = 4
_sizeAccum$1$ = -112					; size = 4
_startInfo$21 = -108					; size = 12
__Loc$22 = -96						; size = 12
$T23 = -84						; size = 12
$T24 = -72						; size = 12
$T25 = -60						; size = 12
$T26 = -48						; size = 12
$T27 = -36						; size = 12
$T28 = -24						; size = 12
$T29 = -12						; size = 12
_allStrips$ = 8						; size = 4
_allFaceInfos$ = 12					; size = 4
_allEdgeInfos$ = 16					; size = 4
_numSamples$dead$ = 20					; size = 4
?FindAllStrips@NvStripifier@@IAEXAAV?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@AAV?$xr_vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@@AAV?$xr_vector@PAVNvEdgeInfo@@V?$xalloc@PAVNvEdgeInfo@@@@@@H@Z PROC ; NvStripifier::FindAllStrips
; _this$ = ecx

; 1223 : 								 int numSamples){

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	sub	esp, 188				; 000000bcH
	push	ebx

; 1224 : 	// the experiments
; 1225 : 	int experimentId = 0;
; 1226 : 	int stripId      = 0;

	xor	eax, eax
	mov	DWORD PTR _this$1$[esp+192], ecx
	push	esi
	push	edi
	mov	DWORD PTR _experimentId$1$[esp+200], 0
	mov	DWORD PTR _stripId$1$[esp+200], eax

; 1227 : 	bool done        = false;

	mov	BYTE PTR _done$1$[esp+200], al
	npad	11
$LL2@FindAllStr:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1262 :                 _Resize_reallocate(_Newsize, _Val);

	lea	eax, DWORD PTR $T20[esp+200]

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR _experiments$17[esp+200], 0

; 1262 :                 _Resize_reallocate(_Newsize, _Val);

	push	eax
	push	ecx
	lea	ecx, DWORD PTR _experiments$17[esp+208]

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR _experiments$17[esp+212], 0
	mov	DWORD PTR _experiments$17[esp+216], 0

; 1262 :                 _Resize_reallocate(_Newsize, _Val);

	call	??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@V?$xalloc@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@@@std@@AAEXIABU_Value_init_tag@1@@Z ; std::vector<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> >,xalloc<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> > > >::_Resize_reallocate<std::_Value_init_tag>
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 1240 : 		int							experimentIndex = 0;

	xor	ebx, ebx
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	push	20					; 00000014H
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 1240 : 		int							experimentIndex = 0;

	mov	DWORD PTR _experimentIndex$1$[esp+204], ebx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xtree

; 435  :     _Tree_val() noexcept : _Myhead(), _Mysize(0) {}

	mov	DWORD PTR _resetPoints$18[esp+204], ebx
	mov	DWORD PTR _resetPoints$18[esp+208], ebx
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 1243 : 		for (i = 0; i < numSamples; i++)

	mov	DWORD PTR _i$1$[esp+200], ebx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xtree

; 345  :         _Construct_in_place(_Pnode->_Left, _Pnode);

	mov	DWORD PTR [eax], eax

; 346  :         _Construct_in_place(_Pnode->_Parent, _Pnode);

	mov	DWORD PTR [eax+4], eax

; 347  :         _Construct_in_place(_Pnode->_Right, _Pnode);

	mov	DWORD PTR [eax+8], eax

; 348  :         _Pnode->_Color = _Black;

	mov	WORD PTR [eax+12], 257			; 00000101H

; 1917 :         _Scary->_Myhead = _Node::_Buyheadnode(_Getal());

	mov	DWORD PTR _resetPoints$18[esp+200], eax
	npad	7
$LL6@FindAllStr:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 226  : 		if(bFirstTimeResetPoint)

	mov	eax, DWORD PTR _this$1$[esp+200]
	xor	ecx, ecx
	mov	DWORD PTR $T3[esp+200], ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	ecx, DWORD PTR _allFaceInfos$[ebp]
	mov	esi, DWORD PTR [ecx+4]
	mov	edi, DWORD PTR [ecx]
	sub	esi, edi
	sar	esi, 2
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 226  : 		if(bFirstTimeResetPoint)

	cmp	BYTE PTR [eax+24], 0
	cvtsi2ss xmm1, esi
	je	SHORT $LN90@FindAllStr

; 227  : 		{
; 228  : 			//first time, find a face with few neighbors (look for an edge of the mesh)
; 229  : 			startPoint = FindStartPoint(faceInfos, edgeInfos);

	push	DWORD PTR _allEdgeInfos$[ebp]
	push	ecx
	call	?FindStartPoint@NvStripifier@@IAEHAAV?$xr_vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@@AAV?$xr_vector@PAVNvEdgeInfo@@V?$xalloc@PAVNvEdgeInfo@@@@@@@Z ; NvStripifier::FindStartPoint

; 230  : 			bFirstTimeResetPoint = false;

	mov	edi, DWORD PTR _allFaceInfos$[ebp]
	mov	edx, eax
	mov	eax, DWORD PTR _this$1$[esp+200]

; 231  : 		}

	movss	xmm3, DWORD PTR __real@3f800000
	movss	xmm2, DWORD PTR [eax+20]
	mov	BYTE PTR [eax+24], 0
	mov	edi, DWORD PTR [edi]
	jmp	SHORT $LN91@FindAllStr
$LN90@FindAllStr:

; 232  : 		else
; 233  : 			startPoint = (int)(((float) numFaces - 1) * meshJump);

	movss	xmm3, DWORD PTR __real@3f800000
	movaps	xmm0, xmm1
	movss	xmm2, DWORD PTR [eax+20]
	subss	xmm0, xmm3
	mulss	xmm0, xmm2
	cvttss2si edx, xmm0
$LN91@FindAllStr:

; 234  : 		
; 235  : 		if(startPoint == -1)

	cmp	edx, -1
	jne	SHORT $LN92@FindAllStr

; 236  : 			startPoint = (int)(((float) numFaces - 1) * meshJump);

	subss	xmm1, xmm3
	mulss	xmm1, xmm2
	cvttss2si edx, xmm1
$LN92@FindAllStr:

; 237  : 		
; 238  : 		int i = startPoint;
; 239  : 		do {
; 240  : 			
; 241  : 			// if this guy isn't visited, try him
; 242  : 			if (faceInfos[i]->m_stripId < 0){

	mov	eax, DWORD PTR [edi+edx*4]
	mov	ecx, edx
	cmp	DWORD PTR [eax+12], 0
	jl	SHORT $LN1074@FindAllStr
$LL88@FindAllStr:

; 244  : 				break;
; 245  : 			}
; 246  : 			
; 247  : 			// update the index and clamp to 0-(numFaces-1)
; 248  : 			if (++i >= numFaces)

	lea	eax, DWORD PTR [ecx+1]

; 249  : 				i = 0;
; 250  : 			
; 251  : 		} while (i != startPoint);

	xor	ecx, ecx
	cmp	eax, esi
	cmovl	ecx, eax
	cmp	ecx, edx
	je	SHORT $LN1164@FindAllStr

; 237  : 		
; 238  : 		int i = startPoint;
; 239  : 		do {
; 240  : 			
; 241  : 			// if this guy isn't visited, try him
; 242  : 			if (faceInfos[i]->m_stripId < 0){

	mov	eax, DWORD PTR [edi+ecx*4]
	cmp	DWORD PTR [eax+12], 0
	jge	SHORT $LL88@FindAllStr
$LN1074@FindAllStr:

; 243  : 				result = faceInfos[i];

	mov	eax, DWORD PTR _allFaceInfos$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	esi, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR $T3[esp+200], esi

; 249  : 				i = 0;
; 250  : 			
; 251  : 		} while (i != startPoint);

	jmp	SHORT $LN87@FindAllStr
$LN1164@FindAllStr:
	mov	esi, DWORD PTR $T3[esp+200]
$LN87@FindAllStr:

; 252  : 		
; 253  : 		// update the meshJump
; 254  : 		meshJump += 0.1f;

	mov	eax, DWORD PTR _this$1$[esp+200]
	movss	xmm0, DWORD PTR [eax+20]
	addss	xmm0, DWORD PTR __real@3dcccccd

; 255  : 		if (meshJump > 1.0f)

	comiss	xmm0, xmm3
	movss	DWORD PTR [eax+20], xmm0
	jbe	SHORT $LN95@FindAllStr

; 256  : 			meshJump = .05f;

	mov	DWORD PTR [eax+20], 1028443341		; 3d4ccccdH
$LN95@FindAllStr:

; 1244 : 		{
; 1245 : 			// Try to find another good reset point.
; 1246 : 			// If there are none to be found, we are done
; 1247 : 			NvFaceInfo *nextFace = FindGoodResetPoint(allFaceInfos, allEdgeInfos);

	mov	DWORD PTR _nextFace$13[esp+200], esi
	test	esi, esi

; 1248 : 			if (nextFace == NULL){

	je	$LN1087@FindAllStr
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xtree

; 1353 :         const _Tree_find_result<_Nodeptr> _Loc = _Find_lower_bound(_Keyval);

	lea	eax, DWORD PTR _nextFace$13[esp+200]
	push	eax
	lea	eax, DWORD PTR __Loc$22[esp+204]
	push	eax
	lea	ecx, DWORD PTR _resetPoints$18[esp+208]
	call	??$_Find_lower_bound@PAVNvFaceInfo@@@?$_Tree@V?$_Tset_traits@PAVNvFaceInfo@@U?$less@PAVNvFaceInfo@@@std@@V?$xalloc@PAVNvFaceInfo@@@@$0A@@std@@@std@@IBE?AU?$_Tree_find_result@PAU?$_Tree_node@PAVNvFaceInfo@@PAX@std@@@1@ABQAVNvFaceInfo@@@Z ; std::_Tree<std::_Tset_traits<NvFaceInfo *,std::less<NvFaceInfo *>,xalloc<NvFaceInfo *>,0> >::_Find_lower_bound<NvFaceInfo *>

; 1591 :         return !_Bound->_Isnil && !_DEBUG_LT_PRED(_Getcomp(), _Keyval, _Traits::_Kfn(_Bound->_Myval));

	mov	eax, DWORD PTR __Loc$22[esp+208]
	cmp	BYTE PTR [eax+13], 0
	jne	SHORT $LN1146@FindAllStr
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef

; 117  :         return _Left < _Right;

	cmp	esi, DWORD PTR [eax+16]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xtree

; 1591 :         return !_Bound->_Isnil && !_DEBUG_LT_PRED(_Getcomp(), _Keyval, _Traits::_Kfn(_Bound->_Myval));

	jb	SHORT $LN1146@FindAllStr

; 233  :         return this->_Ptr == _Right._Ptr;

	cmp	eax, DWORD PTR _resetPoints$18[esp+200]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 1255 : 			else if (resetPoints.find(nextFace) != resetPoints.end()){

	jne	$LN4@FindAllStr
$LN1146@FindAllStr:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xtree

; 1006 :             _Loc                = _Find_lower_bound(_Keyval);

	lea	eax, DWORD PTR _nextFace$13[esp+200]
	push	eax
	lea	eax, DWORD PTR $T29[esp+204]
	push	eax
	lea	ecx, DWORD PTR _resetPoints$18[esp+208]
	call	??$_Find_lower_bound@PAVNvFaceInfo@@@?$_Tree@V?$_Tset_traits@PAVNvFaceInfo@@U?$less@PAVNvFaceInfo@@@std@@V?$xalloc@PAVNvFaceInfo@@@@$0A@@std@@@std@@IBE?AU?$_Tree_find_result@PAU?$_Tree_node@PAVNvFaceInfo@@PAX@std@@@1@ABQAVNvFaceInfo@@@Z ; std::_Tree<std::_Tset_traits<NvFaceInfo *,std::less<NvFaceInfo *>,xalloc<NvFaceInfo *>,0> >::_Find_lower_bound<NvFaceInfo *>
	mov	edi, DWORD PTR [eax]
	mov	ebx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR [eax+8]

; 1591 :         return !_Bound->_Isnil && !_DEBUG_LT_PRED(_Getcomp(), _Keyval, _Traits::_Kfn(_Bound->_Myval));

	cmp	BYTE PTR [eax+13], 0
	jne	SHORT $LN167@FindAllStr
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef

; 117  :         return _Left < _Right;

	cmp	esi, DWORD PTR [eax+16]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xtree

; 1591 :         return !_Bound->_Isnil && !_DEBUG_LT_PRED(_Getcomp(), _Keyval, _Traits::_Kfn(_Bound->_Myval));

	jae	SHORT $LN162@FindAllStr
$LN167@FindAllStr:

; 1615 :         if (max_size() == _Get_scary()->_Mysize) {

	cmp	DWORD PTR _resetPoints$18[esp+204], 214748364 ; 0cccccccH
	je	$LN1088@FindAllStr
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xtree

; 1012 :             _Inserted = _Tree_temp_node<_Alnode>(_Getal(), _Scary->_Myhead, _STD forward<_Valtys>(_Vals)...)._Release();

	mov	esi, DWORD PTR _resetPoints$18[esp+200]
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	push	20					; 00000014H
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xtree

; 805  :         _Alnode_traits::construct(this->_Al, _STD addressof(this->_Ptr->_Myval), _STD forward<_Valtys>(_Vals)...);

	mov	ecx, DWORD PTR $T3[esp+200]

; 1031 :         return {_Scary->_Insert_node(_Loc._Location, _Inserted), true};

	push	eax
	push	ebx

; 805  :         _Alnode_traits::construct(this->_Al, _STD addressof(this->_Ptr->_Myval), _STD forward<_Valtys>(_Vals)...);

	mov	DWORD PTR [eax+16], ecx

; 1031 :         return {_Scary->_Insert_node(_Loc._Location, _Inserted), true};

	lea	ecx, DWORD PTR _resetPoints$18[esp+208]

; 806  :         _Construct_in_place(this->_Ptr->_Left, _Myhead);

	mov	DWORD PTR [eax], esi

; 807  :         _Construct_in_place(this->_Ptr->_Parent, _Myhead);

	mov	DWORD PTR [eax+4], esi

; 808  :         _Construct_in_place(this->_Ptr->_Right, _Myhead);

	mov	DWORD PTR [eax+8], esi

; 1031 :         return {_Scary->_Insert_node(_Loc._Location, _Inserted), true};

	push	edi

; 809  :         this->_Ptr->_Color = _Red;

	mov	WORD PTR [eax+12], 0

; 1031 :         return {_Scary->_Insert_node(_Loc._Location, _Inserted), true};

	call	?_Insert_node@?$_Tree_val@U?$_Tree_simple_types@PAVNvFaceInfo@@@std@@@std@@QAEPAU?$_Tree_node@PAVNvFaceInfo@@PAX@2@U?$_Tree_id@PAU?$_Tree_node@PAVNvFaceInfo@@PAX@std@@@2@QAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<NvFaceInfo *> >::_Insert_node
	mov	esi, DWORD PTR $T3[esp+200]
$LN162@FindAllStr:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 33   : 	NvEdgeInfo *infoIter = edgeInfos[v0];

	mov	eax, DWORD PTR _allEdgeInfos$[ebp]

; 1256 : 				continue;
; 1257 : 			}
; 1258 : 			
; 1259 : 			// trying it now...
; 1260 : 			resetPoints.insert(nextFace);
; 1261 : 			
; 1262 : 			// otherwise, we shall now try experiments for starting on the 01,12, and 20 edges
; 1263 : 			assert(nextFace->m_stripId < 0);
; 1264 : 			
; 1265 : 			// build the strip off of this face's 0-1 edge
; 1266 : 			NvEdgeInfo *edge01	= FindEdgeInfo(allEdgeInfos, nextFace->m_v0, nextFace->m_v1);

	mov	edx, DWORD PTR [esi]
	mov	ecx, DWORD PTR [esi+4]

; 33   : 	NvEdgeInfo *infoIter = edgeInfos[v0];

	mov	eax, DWORD PTR [eax]
	mov	ebx, DWORD PTR [eax+edx*4]

; 34   : 	while (infoIter != NULL){

	test	ebx, ebx
	je	SHORT $LN218@FindAllStr
$LL217@FindAllStr:

; 35   : 		if (infoIter->m_v0 == v0){

	mov	eax, DWORD PTR [ebx+12]
	cmp	eax, edx
	jne	SHORT $LN219@FindAllStr

; 36   : 			if (infoIter->m_v1 == v1)

	cmp	DWORD PTR [ebx+16], ecx
	je	SHORT $LN216@FindAllStr

; 37   : 				return infoIter;
; 38   : 			else
; 39   : 				infoIter = infoIter->m_nextV0;

	mov	ebx, DWORD PTR [ebx+20]

; 40   : 		}

	jmp	SHORT $LN224@FindAllStr
$LN219@FindAllStr:

; 41   : 		else {
; 42   : 			assert(infoIter->m_v1 == v0);
; 43   : 			if (infoIter->m_v0 == v1)

	cmp	eax, ecx
	je	SHORT $LN216@FindAllStr

; 44   : 				return infoIter;
; 45   : 			else
; 46   : 				infoIter = infoIter->m_nextV1;

	mov	ebx, DWORD PTR [ebx+24]
$LN224@FindAllStr:

; 34   : 	while (infoIter != NULL){

	test	ebx, ebx
	jne	SHORT $LL217@FindAllStr
$LN218@FindAllStr:

; 47   : 		}
; 48   : 	}
; 49   : 	return NULL;

	xor	ebx, ebx
$LN216@FindAllStr:

; 1267 : 			NvStripInfo *strip01 = xr_new<NvStripInfo> (NvStripStartInfo(nextFace, edge01, true), stripId++, experimentId++);

	mov	eax, DWORD PTR _experimentId$1$[esp+200]
	mov	edi, eax
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h

; 86   : 	T* ptr	= (T*)Memory.mem_alloc(sizeof(T));

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 1267 : 			NvStripInfo *strip01 = xr_new<NvStripInfo> (NvStripStartInfo(nextFace, edge01, true), stripId++, experimentId++);

	inc	eax
	mov	DWORD PTR _experimentId$1$[esp+200], eax
	mov	eax, DWORD PTR _stripId$1$[esp+200]
	mov	esi, eax
	inc	eax
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.h

; 91   : 		m_toV1         = toV1;

	mov	BYTE PTR $T23[esp+208], 1
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h

; 86   : 	T* ptr	= (T*)Memory.mem_alloc(sizeof(T));

	push	36					; 00000024H
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 1267 : 			NvStripInfo *strip01 = xr_new<NvStripInfo> (NvStripStartInfo(nextFace, edge01, true), stripId++, experimentId++);

	mov	DWORD PTR _stripId$1$[esp+204], eax
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h

; 86   : 	T* ptr	= (T*)Memory.mem_alloc(sizeof(T));

	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.h

; 123  : 	  m_startInfo(startInfo)

	mov	ecx, DWORD PTR $T3[esp+200]
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h

; 87   : 	return new (ptr) T(p1,p2,p3);

	mov	edx, eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 119  :         _Ptr += _Off;

	mov	eax, DWORD PTR _experimentIndex$1$[esp+200]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 1267 : 			NvStripInfo *strip01 = xr_new<NvStripInfo> (NvStripStartInfo(nextFace, edge01, true), stripId++, experimentId++);

	mov	DWORD PTR _strip01$11[esp+200], edx
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.h

; 123  : 	  m_startInfo(startInfo)

	mov	DWORD PTR [edx], ecx
	mov	ecx, DWORD PTR $T23[esp+208]
	mov	DWORD PTR [edx+4], ebx
	mov	DWORD PTR [edx+8], ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 119  :         _Ptr += _Off;

	lea	ecx, DWORD PTR [eax+eax*2]
	shl	ecx, 2

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [edx+12], 0
	mov	DWORD PTR [edx+16], 0
	mov	DWORD PTR [edx+20], 0
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.h

; 125  : 		m_stripId      = stripId;

	mov	DWORD PTR [edx+24], esi

; 126  : 		m_experimentId = experimentId;

	mov	DWORD PTR [edx+28], edi

; 127  : 		visited = false;

	mov	BYTE PTR [edx+32], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 119  :         _Ptr += _Off;

	mov	DWORD PTR tv5832[esp+200], ecx
	add	ecx, DWORD PTR _experiments$17[esp+200]

; 730  :         if (_Mylast != _My_data._Myend) {

	mov	eax, DWORD PTR [ecx+4]
	cmp	eax, DWORD PTR [ecx+8]
	je	SHORT $LN277@FindAllStr

; 713  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

	mov	DWORD PTR [eax], edx

; 714  :         _Orphan_range(_Mylast, _Mylast);
; 715  :         _Ty& _Result = *_Mylast;
; 716  :         ++_Mylast;

	add	DWORD PTR [ecx+4], 4

; 731  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

	jmp	SHORT $LN276@FindAllStr
$LN277@FindAllStr:

; 734  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	lea	edx, DWORD PTR _strip01$11[esp+200]
	push	edx
	push	eax
	call	??$_Emplace_reallocate@ABQAVNvStripInfo@@@?$vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@std@@QAEPAPAVNvStripInfo@@QAPAV2@ABQAV2@@Z ; std::vector<NvStripInfo *,xalloc<NvStripInfo *> >::_Emplace_reallocate<NvStripInfo * const &>
$LN276@FindAllStr:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 1271 : 			NvEdgeInfo *edge10 = FindEdgeInfo(allEdgeInfos, nextFace->m_v0, nextFace->m_v1);

	mov	eax, DWORD PTR $T3[esp+200]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [eax+4]

; 33   : 	NvEdgeInfo *infoIter = edgeInfos[v0];

	mov	eax, DWORD PTR _allEdgeInfos$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	ebx, DWORD PTR [eax+edx*4]

; 34   : 	while (infoIter != NULL){

	test	ebx, ebx
	je	SHORT $LN283@FindAllStr
$LL282@FindAllStr:

; 35   : 		if (infoIter->m_v0 == v0){

	mov	eax, DWORD PTR [ebx+12]
	cmp	eax, edx
	jne	SHORT $LN284@FindAllStr

; 36   : 			if (infoIter->m_v1 == v1)

	cmp	DWORD PTR [ebx+16], ecx
	je	SHORT $LN281@FindAllStr

; 37   : 				return infoIter;
; 38   : 			else
; 39   : 				infoIter = infoIter->m_nextV0;

	mov	ebx, DWORD PTR [ebx+20]

; 40   : 		}

	jmp	SHORT $LN289@FindAllStr
$LN284@FindAllStr:

; 41   : 		else {
; 42   : 			assert(infoIter->m_v1 == v0);
; 43   : 			if (infoIter->m_v0 == v1)

	cmp	eax, ecx
	je	SHORT $LN281@FindAllStr

; 44   : 				return infoIter;
; 45   : 			else
; 46   : 				infoIter = infoIter->m_nextV1;

	mov	ebx, DWORD PTR [ebx+24]
$LN289@FindAllStr:

; 34   : 	while (infoIter != NULL){

	test	ebx, ebx
	jne	SHORT $LL282@FindAllStr
$LN283@FindAllStr:

; 47   : 		}
; 48   : 	}
; 49   : 	return NULL;

	xor	ebx, ebx
$LN281@FindAllStr:

; 1272 : 			NvStripInfo *strip10 = xr_new<NvStripInfo> (NvStripStartInfo(nextFace, edge10, false), stripId++, experimentId++);

	mov	eax, DWORD PTR _experimentId$1$[esp+200]
	mov	edi, eax
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h

; 86   : 	T* ptr	= (T*)Memory.mem_alloc(sizeof(T));

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 1272 : 			NvStripInfo *strip10 = xr_new<NvStripInfo> (NvStripStartInfo(nextFace, edge10, false), stripId++, experimentId++);

	inc	eax
	mov	DWORD PTR _experimentId$1$[esp+200], eax
	mov	eax, DWORD PTR _stripId$1$[esp+200]
	mov	esi, eax
	inc	eax
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.h

; 91   : 		m_toV1         = toV1;

	mov	BYTE PTR $T24[esp+208], 0
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h

; 86   : 	T* ptr	= (T*)Memory.mem_alloc(sizeof(T));

	push	36					; 00000024H
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 1272 : 			NvStripInfo *strip10 = xr_new<NvStripInfo> (NvStripStartInfo(nextFace, edge10, false), stripId++, experimentId++);

	mov	DWORD PTR _stripId$1$[esp+204], eax
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h

; 86   : 	T* ptr	= (T*)Memory.mem_alloc(sizeof(T));

	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.h

; 123  : 	  m_startInfo(startInfo)

	mov	ecx, DWORD PTR $T3[esp+200]
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h

; 87   : 	return new (ptr) T(p1,p2,p3);

	mov	edx, eax
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 1272 : 			NvStripInfo *strip10 = xr_new<NvStripInfo> (NvStripStartInfo(nextFace, edge10, false), stripId++, experimentId++);

	mov	DWORD PTR _strip10$10[esp+200], edx
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.h

; 123  : 	  m_startInfo(startInfo)

	mov	DWORD PTR [edx], ecx
	mov	ecx, DWORD PTR $T24[esp+208]
	mov	DWORD PTR [edx+4], ebx
	mov	DWORD PTR [edx+8], ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 119  :         _Ptr += _Off;

	mov	ecx, DWORD PTR tv5832[esp+200]

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [edx+12], 0
	mov	DWORD PTR [edx+16], 0
	mov	DWORD PTR [edx+20], 0
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.h

; 125  : 		m_stripId      = stripId;

	mov	DWORD PTR [edx+24], esi

; 126  : 		m_experimentId = experimentId;

	mov	DWORD PTR [edx+28], edi

; 127  : 		visited = false;

	mov	BYTE PTR [edx+32], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 119  :         _Ptr += _Off;

	mov	eax, DWORD PTR _experiments$17[esp+200]
	add	eax, 12					; 0000000cH
	add	ecx, eax

; 730  :         if (_Mylast != _My_data._Myend) {

	mov	eax, DWORD PTR [ecx+4]
	cmp	eax, DWORD PTR [ecx+8]
	je	SHORT $LN342@FindAllStr

; 713  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

	mov	DWORD PTR [eax], edx

; 714  :         _Orphan_range(_Mylast, _Mylast);
; 715  :         _Ty& _Result = *_Mylast;
; 716  :         ++_Mylast;

	add	DWORD PTR [ecx+4], 4

; 731  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

	jmp	SHORT $LN341@FindAllStr
$LN342@FindAllStr:

; 734  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	lea	edx, DWORD PTR _strip10$10[esp+200]
	push	edx
	push	eax
	call	??$_Emplace_reallocate@ABQAVNvStripInfo@@@?$vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@std@@QAEPAPAVNvStripInfo@@QAPAV2@ABQAV2@@Z ; std::vector<NvStripInfo *,xalloc<NvStripInfo *> >::_Emplace_reallocate<NvStripInfo * const &>
$LN341@FindAllStr:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 1276 : 			NvEdgeInfo *edge12 = FindEdgeInfo(allEdgeInfos, nextFace->m_v1, nextFace->m_v2);

	mov	eax, DWORD PTR $T3[esp+200]
	mov	edx, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR [eax+8]

; 33   : 	NvEdgeInfo *infoIter = edgeInfos[v0];

	mov	eax, DWORD PTR _allEdgeInfos$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	ebx, DWORD PTR [eax+edx*4]

; 34   : 	while (infoIter != NULL){

	test	ebx, ebx
	je	SHORT $LN348@FindAllStr
$LL347@FindAllStr:

; 35   : 		if (infoIter->m_v0 == v0){

	mov	eax, DWORD PTR [ebx+12]
	cmp	eax, edx
	jne	SHORT $LN349@FindAllStr

; 36   : 			if (infoIter->m_v1 == v1)

	cmp	DWORD PTR [ebx+16], ecx
	je	SHORT $LN346@FindAllStr

; 37   : 				return infoIter;
; 38   : 			else
; 39   : 				infoIter = infoIter->m_nextV0;

	mov	ebx, DWORD PTR [ebx+20]

; 40   : 		}

	jmp	SHORT $LN354@FindAllStr
$LN349@FindAllStr:

; 41   : 		else {
; 42   : 			assert(infoIter->m_v1 == v0);
; 43   : 			if (infoIter->m_v0 == v1)

	cmp	eax, ecx
	je	SHORT $LN346@FindAllStr

; 44   : 				return infoIter;
; 45   : 			else
; 46   : 				infoIter = infoIter->m_nextV1;

	mov	ebx, DWORD PTR [ebx+24]
$LN354@FindAllStr:

; 34   : 	while (infoIter != NULL){

	test	ebx, ebx
	jne	SHORT $LL347@FindAllStr
$LN348@FindAllStr:

; 47   : 		}
; 48   : 	}
; 49   : 	return NULL;

	xor	ebx, ebx
$LN346@FindAllStr:

; 1277 : 			NvStripInfo *strip12 = xr_new<NvStripInfo> (NvStripStartInfo(nextFace, edge12, true), stripId++, experimentId++);

	mov	eax, DWORD PTR _experimentId$1$[esp+200]
	mov	edi, eax
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h

; 86   : 	T* ptr	= (T*)Memory.mem_alloc(sizeof(T));

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 1277 : 			NvStripInfo *strip12 = xr_new<NvStripInfo> (NvStripStartInfo(nextFace, edge12, true), stripId++, experimentId++);

	inc	eax
	mov	DWORD PTR _experimentId$1$[esp+200], eax
	mov	eax, DWORD PTR _stripId$1$[esp+200]
	mov	esi, eax
	inc	eax
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.h

; 91   : 		m_toV1         = toV1;

	mov	BYTE PTR $T25[esp+208], 1
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h

; 86   : 	T* ptr	= (T*)Memory.mem_alloc(sizeof(T));

	push	36					; 00000024H
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 1277 : 			NvStripInfo *strip12 = xr_new<NvStripInfo> (NvStripStartInfo(nextFace, edge12, true), stripId++, experimentId++);

	mov	DWORD PTR _stripId$1$[esp+204], eax
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h

; 86   : 	T* ptr	= (T*)Memory.mem_alloc(sizeof(T));

	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.h

; 123  : 	  m_startInfo(startInfo)

	mov	ecx, DWORD PTR $T3[esp+200]
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h

; 87   : 	return new (ptr) T(p1,p2,p3);

	mov	edx, eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 119  :         _Ptr += _Off;

	mov	eax, DWORD PTR _experimentIndex$1$[esp+200]
	add	eax, 2
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 1277 : 			NvStripInfo *strip12 = xr_new<NvStripInfo> (NvStripStartInfo(nextFace, edge12, true), stripId++, experimentId++);

	mov	DWORD PTR _strip12$9[esp+200], edx
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.h

; 123  : 	  m_startInfo(startInfo)

	mov	DWORD PTR [edx], ecx
	mov	ecx, DWORD PTR $T25[esp+208]
	mov	DWORD PTR [edx+4], ebx
	mov	DWORD PTR [edx+8], ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 119  :         _Ptr += _Off;

	lea	ecx, DWORD PTR [eax+eax*2]
	shl	ecx, 2

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [edx+12], 0
	mov	DWORD PTR [edx+16], 0
	mov	DWORD PTR [edx+20], 0
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.h

; 125  : 		m_stripId      = stripId;

	mov	DWORD PTR [edx+24], esi

; 126  : 		m_experimentId = experimentId;

	mov	DWORD PTR [edx+28], edi

; 127  : 		visited = false;

	mov	BYTE PTR [edx+32], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 119  :         _Ptr += _Off;

	mov	DWORD PTR tv5805[esp+200], ecx
	add	ecx, DWORD PTR _experiments$17[esp+200]

; 730  :         if (_Mylast != _My_data._Myend) {

	mov	eax, DWORD PTR [ecx+4]
	cmp	eax, DWORD PTR [ecx+8]
	je	SHORT $LN407@FindAllStr

; 713  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

	mov	DWORD PTR [eax], edx

; 714  :         _Orphan_range(_Mylast, _Mylast);
; 715  :         _Ty& _Result = *_Mylast;
; 716  :         ++_Mylast;

	add	DWORD PTR [ecx+4], 4

; 731  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

	jmp	SHORT $LN406@FindAllStr
$LN407@FindAllStr:

; 734  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	lea	edx, DWORD PTR _strip12$9[esp+200]
	push	edx
	push	eax
	call	??$_Emplace_reallocate@ABQAVNvStripInfo@@@?$vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@std@@QAEPAPAVNvStripInfo@@QAPAV2@ABQAV2@@Z ; std::vector<NvStripInfo *,xalloc<NvStripInfo *> >::_Emplace_reallocate<NvStripInfo * const &>
$LN406@FindAllStr:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 1281 : 			NvEdgeInfo *edge21 = FindEdgeInfo(allEdgeInfos, nextFace->m_v1, nextFace->m_v2);

	mov	eax, DWORD PTR $T3[esp+200]
	mov	edx, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR [eax+8]

; 33   : 	NvEdgeInfo *infoIter = edgeInfos[v0];

	mov	eax, DWORD PTR _allEdgeInfos$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	ebx, DWORD PTR [eax+edx*4]

; 34   : 	while (infoIter != NULL){

	test	ebx, ebx
	je	SHORT $LN413@FindAllStr
$LL412@FindAllStr:

; 35   : 		if (infoIter->m_v0 == v0){

	mov	eax, DWORD PTR [ebx+12]
	cmp	eax, edx
	jne	SHORT $LN414@FindAllStr

; 36   : 			if (infoIter->m_v1 == v1)

	cmp	DWORD PTR [ebx+16], ecx
	je	SHORT $LN411@FindAllStr

; 37   : 				return infoIter;
; 38   : 			else
; 39   : 				infoIter = infoIter->m_nextV0;

	mov	ebx, DWORD PTR [ebx+20]

; 40   : 		}

	jmp	SHORT $LN419@FindAllStr
$LN414@FindAllStr:

; 41   : 		else {
; 42   : 			assert(infoIter->m_v1 == v0);
; 43   : 			if (infoIter->m_v0 == v1)

	cmp	eax, ecx
	je	SHORT $LN411@FindAllStr

; 44   : 				return infoIter;
; 45   : 			else
; 46   : 				infoIter = infoIter->m_nextV1;

	mov	ebx, DWORD PTR [ebx+24]
$LN419@FindAllStr:

; 34   : 	while (infoIter != NULL){

	test	ebx, ebx
	jne	SHORT $LL412@FindAllStr
$LN413@FindAllStr:

; 47   : 		}
; 48   : 	}
; 49   : 	return NULL;

	xor	ebx, ebx
$LN411@FindAllStr:

; 1282 : 			NvStripInfo *strip21 = xr_new<NvStripInfo> (NvStripStartInfo(nextFace, edge21, false), stripId++, experimentId++);

	mov	eax, DWORD PTR _experimentId$1$[esp+200]
	mov	edi, eax
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h

; 86   : 	T* ptr	= (T*)Memory.mem_alloc(sizeof(T));

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 1282 : 			NvStripInfo *strip21 = xr_new<NvStripInfo> (NvStripStartInfo(nextFace, edge21, false), stripId++, experimentId++);

	inc	eax
	mov	DWORD PTR _experimentId$1$[esp+200], eax
	mov	eax, DWORD PTR _stripId$1$[esp+200]
	mov	esi, eax
	inc	eax
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.h

; 91   : 		m_toV1         = toV1;

	mov	BYTE PTR $T26[esp+208], 0
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h

; 86   : 	T* ptr	= (T*)Memory.mem_alloc(sizeof(T));

	push	36					; 00000024H
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 1282 : 			NvStripInfo *strip21 = xr_new<NvStripInfo> (NvStripStartInfo(nextFace, edge21, false), stripId++, experimentId++);

	mov	DWORD PTR _stripId$1$[esp+204], eax
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h

; 86   : 	T* ptr	= (T*)Memory.mem_alloc(sizeof(T));

	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.h

; 123  : 	  m_startInfo(startInfo)

	mov	ecx, DWORD PTR $T3[esp+200]
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h

; 87   : 	return new (ptr) T(p1,p2,p3);

	mov	edx, eax
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 1282 : 			NvStripInfo *strip21 = xr_new<NvStripInfo> (NvStripStartInfo(nextFace, edge21, false), stripId++, experimentId++);

	mov	DWORD PTR _strip21$8[esp+200], edx
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.h

; 123  : 	  m_startInfo(startInfo)

	mov	DWORD PTR [edx], ecx
	mov	ecx, DWORD PTR $T26[esp+208]
	mov	DWORD PTR [edx+4], ebx
	mov	DWORD PTR [edx+8], ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 119  :         _Ptr += _Off;

	mov	ecx, DWORD PTR tv5805[esp+200]

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [edx+12], 0
	mov	DWORD PTR [edx+16], 0
	mov	DWORD PTR [edx+20], 0
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.h

; 125  : 		m_stripId      = stripId;

	mov	DWORD PTR [edx+24], esi

; 126  : 		m_experimentId = experimentId;

	mov	DWORD PTR [edx+28], edi

; 127  : 		visited = false;

	mov	BYTE PTR [edx+32], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 119  :         _Ptr += _Off;

	mov	eax, DWORD PTR _experiments$17[esp+200]
	add	eax, 12					; 0000000cH
	add	ecx, eax
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 1283 : 			experiments[experimentIndex++].push_back(strip21);

	mov	eax, DWORD PTR _experimentIndex$1$[esp+200]
	add	eax, 4
	mov	DWORD PTR tv5803[esp+200], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 730  :         if (_Mylast != _My_data._Myend) {

	mov	eax, DWORD PTR [ecx+4]
	cmp	eax, DWORD PTR [ecx+8]
	je	SHORT $LN472@FindAllStr

; 713  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

	mov	DWORD PTR [eax], edx

; 714  :         _Orphan_range(_Mylast, _Mylast);
; 715  :         _Ty& _Result = *_Mylast;
; 716  :         ++_Mylast;

	add	DWORD PTR [ecx+4], 4

; 731  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

	jmp	SHORT $LN471@FindAllStr
$LN472@FindAllStr:

; 734  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	lea	edx, DWORD PTR _strip21$8[esp+200]
	push	edx
	push	eax
	call	??$_Emplace_reallocate@ABQAVNvStripInfo@@@?$vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@std@@QAEPAPAVNvStripInfo@@QAPAV2@ABQAV2@@Z ; std::vector<NvStripInfo *,xalloc<NvStripInfo *> >::_Emplace_reallocate<NvStripInfo * const &>
$LN471@FindAllStr:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 1286 : 			NvEdgeInfo *edge20 = FindEdgeInfo(allEdgeInfos, nextFace->m_v2, nextFace->m_v0);

	mov	eax, DWORD PTR $T3[esp+200]
	mov	edx, DWORD PTR [eax+8]
	mov	ecx, DWORD PTR [eax]

; 33   : 	NvEdgeInfo *infoIter = edgeInfos[v0];

	mov	eax, DWORD PTR _allEdgeInfos$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	ebx, DWORD PTR [eax+edx*4]

; 34   : 	while (infoIter != NULL){

	test	ebx, ebx
	je	SHORT $LN478@FindAllStr
$LL477@FindAllStr:

; 35   : 		if (infoIter->m_v0 == v0){

	mov	eax, DWORD PTR [ebx+12]
	cmp	eax, edx
	jne	SHORT $LN479@FindAllStr

; 36   : 			if (infoIter->m_v1 == v1)

	cmp	DWORD PTR [ebx+16], ecx
	je	SHORT $LN476@FindAllStr

; 37   : 				return infoIter;
; 38   : 			else
; 39   : 				infoIter = infoIter->m_nextV0;

	mov	ebx, DWORD PTR [ebx+20]

; 40   : 		}

	jmp	SHORT $LN484@FindAllStr
$LN479@FindAllStr:

; 41   : 		else {
; 42   : 			assert(infoIter->m_v1 == v0);
; 43   : 			if (infoIter->m_v0 == v1)

	cmp	eax, ecx
	je	SHORT $LN476@FindAllStr

; 44   : 				return infoIter;
; 45   : 			else
; 46   : 				infoIter = infoIter->m_nextV1;

	mov	ebx, DWORD PTR [ebx+24]
$LN484@FindAllStr:

; 34   : 	while (infoIter != NULL){

	test	ebx, ebx
	jne	SHORT $LL477@FindAllStr
$LN478@FindAllStr:

; 47   : 		}
; 48   : 	}
; 49   : 	return NULL;

	xor	ebx, ebx
$LN476@FindAllStr:

; 1287 : 			NvStripInfo *strip20 = xr_new<NvStripInfo> (NvStripStartInfo(nextFace, edge20, true), stripId++, experimentId++);

	mov	eax, DWORD PTR _experimentId$1$[esp+200]
	mov	edi, eax
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h

; 86   : 	T* ptr	= (T*)Memory.mem_alloc(sizeof(T));

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 1287 : 			NvStripInfo *strip20 = xr_new<NvStripInfo> (NvStripStartInfo(nextFace, edge20, true), stripId++, experimentId++);

	inc	eax
	mov	DWORD PTR _experimentId$1$[esp+200], eax
	mov	eax, DWORD PTR _stripId$1$[esp+200]
	mov	esi, eax
	inc	eax
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.h

; 91   : 		m_toV1         = toV1;

	mov	BYTE PTR $T27[esp+208], 1
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h

; 86   : 	T* ptr	= (T*)Memory.mem_alloc(sizeof(T));

	push	36					; 00000024H
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 1287 : 			NvStripInfo *strip20 = xr_new<NvStripInfo> (NvStripStartInfo(nextFace, edge20, true), stripId++, experimentId++);

	mov	DWORD PTR _stripId$1$[esp+204], eax
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h

; 86   : 	T* ptr	= (T*)Memory.mem_alloc(sizeof(T));

	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.h

; 123  : 	  m_startInfo(startInfo)

	mov	ecx, DWORD PTR $T3[esp+200]
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h

; 87   : 	return new (ptr) T(p1,p2,p3);

	mov	edx, eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 119  :         _Ptr += _Off;

	mov	eax, DWORD PTR tv5803[esp+200]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 1287 : 			NvStripInfo *strip20 = xr_new<NvStripInfo> (NvStripStartInfo(nextFace, edge20, true), stripId++, experimentId++);

	mov	DWORD PTR _strip20$7[esp+200], edx
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.h

; 123  : 	  m_startInfo(startInfo)

	mov	DWORD PTR [edx], ecx
	mov	ecx, DWORD PTR $T27[esp+208]
	mov	DWORD PTR [edx+4], ebx
	mov	DWORD PTR [edx+8], ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 119  :         _Ptr += _Off;

	lea	ecx, DWORD PTR [eax+eax*2]
	shl	ecx, 2

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [edx+12], 0
	mov	DWORD PTR [edx+16], 0
	mov	DWORD PTR [edx+20], 0
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.h

; 125  : 		m_stripId      = stripId;

	mov	DWORD PTR [edx+24], esi

; 126  : 		m_experimentId = experimentId;

	mov	DWORD PTR [edx+28], edi

; 127  : 		visited = false;

	mov	BYTE PTR [edx+32], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 119  :         _Ptr += _Off;

	mov	DWORD PTR tv5801[esp+200], ecx
	add	ecx, DWORD PTR _experiments$17[esp+200]

; 730  :         if (_Mylast != _My_data._Myend) {

	mov	eax, DWORD PTR [ecx+4]
	cmp	eax, DWORD PTR [ecx+8]
	je	SHORT $LN537@FindAllStr

; 713  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

	mov	DWORD PTR [eax], edx

; 714  :         _Orphan_range(_Mylast, _Mylast);
; 715  :         _Ty& _Result = *_Mylast;
; 716  :         ++_Mylast;

	add	DWORD PTR [ecx+4], 4

; 731  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

	jmp	SHORT $LN536@FindAllStr
$LN537@FindAllStr:

; 734  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	lea	edx, DWORD PTR _strip20$7[esp+200]
	push	edx
	push	eax
	call	??$_Emplace_reallocate@ABQAVNvStripInfo@@@?$vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@std@@QAEPAPAVNvStripInfo@@QAPAV2@ABQAV2@@Z ; std::vector<NvStripInfo *,xalloc<NvStripInfo *> >::_Emplace_reallocate<NvStripInfo * const &>
$LN536@FindAllStr:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 1291 : 			NvEdgeInfo *edge02 = FindEdgeInfo(allEdgeInfos, nextFace->m_v2, nextFace->m_v0);

	mov	eax, DWORD PTR $T3[esp+200]
	mov	edx, DWORD PTR [eax+8]
	mov	ecx, DWORD PTR [eax]

; 33   : 	NvEdgeInfo *infoIter = edgeInfos[v0];

	mov	eax, DWORD PTR _allEdgeInfos$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	ebx, DWORD PTR [eax+edx*4]

; 34   : 	while (infoIter != NULL){

	test	ebx, ebx
	je	SHORT $LN543@FindAllStr
$LL542@FindAllStr:

; 35   : 		if (infoIter->m_v0 == v0){

	mov	eax, DWORD PTR [ebx+12]
	cmp	eax, edx
	jne	SHORT $LN544@FindAllStr

; 36   : 			if (infoIter->m_v1 == v1)

	cmp	DWORD PTR [ebx+16], ecx
	je	SHORT $LN541@FindAllStr

; 37   : 				return infoIter;
; 38   : 			else
; 39   : 				infoIter = infoIter->m_nextV0;

	mov	ebx, DWORD PTR [ebx+20]

; 40   : 		}

	jmp	SHORT $LN549@FindAllStr
$LN544@FindAllStr:

; 41   : 		else {
; 42   : 			assert(infoIter->m_v1 == v0);
; 43   : 			if (infoIter->m_v0 == v1)

	cmp	eax, ecx
	je	SHORT $LN541@FindAllStr

; 44   : 				return infoIter;
; 45   : 			else
; 46   : 				infoIter = infoIter->m_nextV1;

	mov	ebx, DWORD PTR [ebx+24]
$LN549@FindAllStr:

; 34   : 	while (infoIter != NULL){

	test	ebx, ebx
	jne	SHORT $LL542@FindAllStr
$LN543@FindAllStr:

; 47   : 		}
; 48   : 	}
; 49   : 	return NULL;

	xor	ebx, ebx
$LN541@FindAllStr:

; 1292 : 			NvStripInfo *strip02 = xr_new<NvStripInfo> (NvStripStartInfo(nextFace, edge02, false), stripId++, experimentId++);

	mov	eax, DWORD PTR _experimentId$1$[esp+200]
	mov	edi, eax
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h

; 86   : 	T* ptr	= (T*)Memory.mem_alloc(sizeof(T));

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 1292 : 			NvStripInfo *strip02 = xr_new<NvStripInfo> (NvStripStartInfo(nextFace, edge02, false), stripId++, experimentId++);

	inc	eax
	mov	DWORD PTR _experimentId$1$[esp+200], eax
	mov	eax, DWORD PTR _stripId$1$[esp+200]
	mov	esi, eax
	inc	eax
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.h

; 91   : 		m_toV1         = toV1;

	mov	BYTE PTR $T28[esp+208], 0
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h

; 86   : 	T* ptr	= (T*)Memory.mem_alloc(sizeof(T));

	push	36					; 00000024H
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 1292 : 			NvStripInfo *strip02 = xr_new<NvStripInfo> (NvStripStartInfo(nextFace, edge02, false), stripId++, experimentId++);

	mov	DWORD PTR _stripId$1$[esp+204], eax
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h

; 86   : 	T* ptr	= (T*)Memory.mem_alloc(sizeof(T));

	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.h

; 123  : 	  m_startInfo(startInfo)

	mov	ecx, DWORD PTR $T3[esp+200]
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h

; 87   : 	return new (ptr) T(p1,p2,p3);

	mov	edx, eax
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 1292 : 			NvStripInfo *strip02 = xr_new<NvStripInfo> (NvStripStartInfo(nextFace, edge02, false), stripId++, experimentId++);

	mov	DWORD PTR _strip02$6[esp+200], edx
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.h

; 123  : 	  m_startInfo(startInfo)

	mov	DWORD PTR [edx], ecx
	mov	ecx, DWORD PTR $T28[esp+208]
	mov	DWORD PTR [edx+4], ebx
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 1293 : 			experiments[experimentIndex++].push_back(strip02);

	mov	ebx, DWORD PTR tv5803[esp+200]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.h

; 123  : 	  m_startInfo(startInfo)

	mov	DWORD PTR [edx+8], ecx
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 1293 : 			experiments[experimentIndex++].push_back(strip02);

	add	ebx, 2
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 119  :         _Ptr += _Off;

	mov	ecx, DWORD PTR tv5801[esp+200]

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [edx+12], 0
	mov	DWORD PTR [edx+16], 0
	mov	DWORD PTR [edx+20], 0
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.h

; 125  : 		m_stripId      = stripId;

	mov	DWORD PTR [edx+24], esi

; 126  : 		m_experimentId = experimentId;

	mov	DWORD PTR [edx+28], edi

; 127  : 		visited = false;

	mov	BYTE PTR [edx+32], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 119  :         _Ptr += _Off;

	mov	eax, DWORD PTR _experiments$17[esp+200]
	add	eax, 12					; 0000000cH
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 1293 : 			experiments[experimentIndex++].push_back(strip02);

	mov	DWORD PTR _experimentIndex$1$[esp+200], ebx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 119  :         _Ptr += _Off;

	add	ecx, eax

; 730  :         if (_Mylast != _My_data._Myend) {

	mov	eax, DWORD PTR [ecx+4]
	cmp	eax, DWORD PTR [ecx+8]
	je	SHORT $LN602@FindAllStr

; 713  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

	mov	DWORD PTR [eax], edx

; 714  :         _Orphan_range(_Mylast, _Mylast);
; 715  :         _Ty& _Result = *_Mylast;
; 716  :         ++_Mylast;

	add	DWORD PTR [ecx+4], 4

; 731  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

	jmp	SHORT $LN4@FindAllStr
$LN602@FindAllStr:

; 734  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	lea	edx, DWORD PTR _strip02$6[esp+200]
	push	edx
	push	eax
	call	??$_Emplace_reallocate@ABQAVNvStripInfo@@@?$vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@std@@QAEPAPAVNvStripInfo@@QAPAV2@ABQAV2@@Z ; std::vector<NvStripInfo *,xalloc<NvStripInfo *> >::_Emplace_reallocate<NvStripInfo * const &>
	mov	DWORD PTR _experimentIndex$1$[esp+200], ebx
$LN4@FindAllStr:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 1243 : 		for (i = 0; i < numSamples; i++)

	mov	eax, DWORD PTR _i$1$[esp+200]
	inc	eax
	mov	DWORD PTR _i$1$[esp+200], eax
	cmp	eax, 10					; 0000000aH
	jl	$LL6@FindAllStr

; 646  : 		if ((face1 != NULL && !strip->IsInStrip(face1)) && face0 != NULL && !strip->IsMarked(face0)){

	jmp	SHORT $LN5@FindAllStr
$LN1087@FindAllStr:

; 1249 : 				done = true;

	mov	BYTE PTR _done$1$[esp+200], 1
$LN5@FindAllStr:

; 1302 : 		for (i = 0; i < numExperiments; i++){

	test	ebx, ebx
	jle	$LN8@FindAllStr

; 1294 : 		}
; 1295 : 		
; 1296 : 		//
; 1297 : 		// PHASE 2: Iterate through that we setup in the last phase
; 1298 : 		// and really build each of the strips and strips that follow to see how
; 1299 : 		// far we get
; 1300 : 		//
; 1301 : 		int numExperiments = experimentIndex;

	mov	eax, DWORD PTR _experimentIndex$1$[esp+200]
	xor	ebx, ebx
	mov	edx, DWORD PTR _experiments$17[esp+200]
	mov	DWORD PTR tv5785[esp+200], ebx
	mov	DWORD PTR tv5845[esp+200], eax
$LL9@FindAllStr:

; 1307 : 			experiments[i][0]->Build(allEdgeInfos, allFaceInfos);

	push	ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1463 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));

	mov	ecx, DWORD PTR [edx+ebx]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 1307 : 			experiments[i][0]->Build(allEdgeInfos, allFaceInfos);

	push	DWORD PTR _allEdgeInfos$[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?Build@NvStripInfo@@QAEXAAV?$xr_vector@PAVNvEdgeInfo@@V?$xalloc@PAVNvEdgeInfo@@@@@@AAV?$xr_vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@@@Z ; NvStripInfo::Build
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1463 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));

	mov	ecx, DWORD PTR _experiments$17[esp+200]
	mov	DWORD PTR _experiments$1$[esp+200], ecx
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.h

; 91   : 		m_toV1         = toV1;

	mov	BYTE PTR _startInfo$21[esp+208], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1463 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));

	mov	eax, DWORD PTR [ecx+ebx]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 1308 : 			int experimentId = experiments[i][0]->m_experimentId;

	mov	esi, DWORD PTR [eax]
	mov	eax, DWORD PTR [esi+28]
	mov	DWORD PTR _experimentId$1$[esp+200], eax
	npad	7
$LL10@FindAllStr:

; 634  : 	int v = (strip->m_startInfo.m_toV1 ? strip->m_startInfo.m_startEdge->m_v1 : strip->m_startInfo.m_startEdge->m_v0);

	cmp	BYTE PTR [esi+8], 0
	mov	eax, DWORD PTR [esi+4]
	je	SHORT $LN719@FindAllStr
	mov	ecx, DWORD PTR [eax+16]
	jmp	SHORT $LN1192@FindAllStr
$LN719@FindAllStr:
	mov	ecx, DWORD PTR [eax+12]
$LN1192@FindAllStr:

; 635  : 	
; 636  : 	NvFaceInfo *untouchedFace = NULL;
; 637  : 	NvEdgeInfo *edgeIter      = edgeInfos[v];

	mov	edx, DWORD PTR _allEdgeInfos$[ebp]
	xor	edi, edi
	mov	DWORD PTR _v$1$[esp+200], ecx
	mov	eax, DWORD PTR [edx]
	mov	ebx, DWORD PTR [eax+ecx*4]

; 638  : 	while (edgeIter != NULL){

	test	ebx, ebx
	je	$LN717@FindAllStr
$LL711@FindAllStr:

; 639  : 		NvFaceInfo *face0 = edgeIter->m_face0;

	mov	ecx, DWORD PTR [ebx+4]

; 640  : 		NvFaceInfo *face1 = edgeIter->m_face1;

	mov	edi, DWORD PTR [ebx+8]

; 641  : 		if ((face0 != NULL && !strip->IsInStrip(face0)) && face1 != NULL && !strip->IsMarked(face1))

	test	ecx, ecx
	je	SHORT $LN713@FindAllStr
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.h

; 138  : 		return (m_experimentId >= 0 ? faceInfo->m_testStripId == m_stripId : faceInfo->m_stripId == m_stripId);

	mov	edx, DWORD PTR [esi+28]
	test	edx, edx
	js	SHORT $LN743@FindAllStr
	mov	eax, DWORD PTR [ecx+16]
	jmp	SHORT $LN1194@FindAllStr
$LN743@FindAllStr:
	mov	eax, DWORD PTR [ecx+12]
$LN1194@FindAllStr:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 641  : 		if ((face0 != NULL && !strip->IsInStrip(face0)) && face1 != NULL && !strip->IsMarked(face1))

	cmp	eax, DWORD PTR [esi+24]
	sete	al
	test	al, al
	jne	SHORT $LN713@FindAllStr
	test	edi, edi
	je	SHORT $LN760@FindAllStr

; 377  : 	return (faceInfo->m_stripId >= 0) || (IsExperiment() && faceInfo->m_experimentId == m_experimentId);

	cmp	DWORD PTR [edi+12], 0
	jge	SHORT $LN1152@FindAllStr
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.h

; 131  : 	inline bool IsExperiment () const { return m_experimentId >= 0; }

	test	edx, edx
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 377  : 	return (faceInfo->m_stripId >= 0) || (IsExperiment() && faceInfo->m_experimentId == m_experimentId);

	js	$LN1089@FindAllStr
	cmp	DWORD PTR [edi+20], edx
	jne	$LN1089@FindAllStr
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.h

; 138  : 		return (m_experimentId >= 0 ? faceInfo->m_testStripId == m_stripId : faceInfo->m_stripId == m_stripId);

	mov	eax, DWORD PTR [edi+16]
	jmp	SHORT $LN1195@FindAllStr
$LN713@FindAllStr:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 646  : 		if ((face1 != NULL && !strip->IsInStrip(face1)) && face0 != NULL && !strip->IsMarked(face0)){

	test	edi, edi
	je	SHORT $LN760@FindAllStr
$LN1152@FindAllStr:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.h

; 138  : 		return (m_experimentId >= 0 ? faceInfo->m_testStripId == m_stripId : faceInfo->m_stripId == m_stripId);

	mov	edx, DWORD PTR [esi+28]
	test	edx, edx
	js	SHORT $LN755@FindAllStr
	mov	eax, DWORD PTR [edi+16]
	jmp	SHORT $LN1195@FindAllStr
$LN755@FindAllStr:
	mov	eax, DWORD PTR [edi+12]
$LN1195@FindAllStr:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 646  : 		if ((face1 != NULL && !strip->IsInStrip(face1)) && face0 != NULL && !strip->IsMarked(face0)){

	cmp	eax, DWORD PTR [esi+24]
	sete	al
	test	al, al
	jne	SHORT $LN760@FindAllStr
	test	ecx, ecx
	je	SHORT $LN760@FindAllStr

; 377  : 	return (faceInfo->m_stripId >= 0) || (IsExperiment() && faceInfo->m_experimentId == m_experimentId);

	cmp	DWORD PTR [ecx+12], 0
	jge	SHORT $LN760@FindAllStr
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.h

; 131  : 	inline bool IsExperiment () const { return m_experimentId >= 0; }

	test	edx, edx
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 377  : 	return (faceInfo->m_stripId >= 0) || (IsExperiment() && faceInfo->m_experimentId == m_experimentId);

	js	$LN1090@FindAllStr
	cmp	DWORD PTR [ecx+20], edx
	jne	$LN1090@FindAllStr
$LN760@FindAllStr:

; 652  : 		edgeIter = (edgeIter->m_v0 == v ? edgeIter->m_nextV0 : edgeIter->m_nextV1);

	mov	eax, DWORD PTR _v$1$[esp+200]
	cmp	DWORD PTR [ebx+12], eax
	jne	SHORT $LN721@FindAllStr
	mov	ebx, DWORD PTR [ebx+20]
	jmp	SHORT $LN722@FindAllStr
$LN721@FindAllStr:
	mov	ebx, DWORD PTR [ebx+24]
$LN722@FindAllStr:

; 638  : 	while (edgeIter != NULL){

	test	ebx, ebx
	jne	$LL711@FindAllStr

; 646  : 		if ((face1 != NULL && !strip->IsInStrip(face1)) && face0 != NULL && !strip->IsMarked(face0)){

	mov	DWORD PTR _startInfo$21[esp+200], ebx
$LN7@FindAllStr:

; 1302 : 		for (i = 0; i < numExperiments; i++){

	mov	ebx, DWORD PTR tv5785[esp+200]
	mov	edx, DWORD PTR _experiments$1$[esp+200]
	add	ebx, 12					; 0000000cH
	sub	DWORD PTR tv5845[esp+200], 1
	mov	DWORD PTR tv5785[esp+200], ebx
	jne	$LL9@FindAllStr

; 377  : 	return (faceInfo->m_stripId >= 0) || (IsExperiment() && faceInfo->m_experimentId == m_experimentId);

	mov	eax, DWORD PTR _stripId$1$[esp+200]
	fld1
	mov	DWORD PTR tv5783[esp+200], edx
	mov	DWORD PTR _bestIndex$1$[esp+200], 0
	mov	DWORD PTR _bestValue$12[esp+200], 0
	mov	DWORD PTR _i$2$[esp+200], 0
	mov	DWORD PTR _stripId$1$[esp+200], eax
$LN14@FindAllStr:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	esi, DWORD PTR [edx+4]
	xor	ecx, ecx
	mov	edi, DWORD PTR [edx]
	xor	ebx, ebx
	sub	esi, edi
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 1200 : 	int sizeAccum = 0;

	mov	DWORD PTR _sizeAccum$1$[esp+200], ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	sar	esi, 2

; 119  :         _Ptr += _Off;

	xor	edx, edx
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 1201 : 	int numStrips = strips.size();

	mov	DWORD PTR _numStrips$19[esp+200], esi

; 1202 : 	for (int i = 0; i < numStrips; i++){

	cmp	esi, 2
	jl	$LC1121@FindAllStr
	lea	eax, DWORD PTR [esi-1]
	mov	esi, ecx
	mov	DWORD PTR tv5818[esp+200], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1468 :         return const_iterator(_My_data._Myfirst, _STD addressof(_My_data));

$LN1122@FindAllStr:

; 1535 :         auto& _My_data = _Mypair._Myval2;

	mov	ecx, DWORD PTR [edi+edx*4]

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	eax, DWORD PTR [ecx+16]
	sub	eax, DWORD PTR [ecx+12]
	mov	ecx, DWORD PTR [edi+edx*4+4]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 1204 : 		sizeAccum += strip->m_faces.size();

	add	edx, 2
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	sar	eax, 2
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 1204 : 		sizeAccum += strip->m_faces.size();

	add	ebx, eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	eax, DWORD PTR [ecx+16]
	sub	eax, DWORD PTR [ecx+12]
	sar	eax, 2
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 1204 : 		sizeAccum += strip->m_faces.size();

	add	esi, eax
	cmp	edx, DWORD PTR tv5818[esp+200]
	jl	SHORT $LN1122@FindAllStr
	mov	DWORD PTR $T14[esp+200], esi

; 1202 : 	for (int i = 0; i < numStrips; i++){

	mov	esi, DWORD PTR _numStrips$19[esp+200]
	mov	ecx, DWORD PTR $T14[esp+200]
	cmp	edx, esi
	jl	$LN820@FindAllStr
	mov	edx, DWORD PTR _sizeAccum$1$[esp+200]
	jmp	$LN1120@FindAllStr
$LN1090@FindAllStr:

; 647  : 			untouchedFace = face0;

	mov	edi, ecx
$LN1089@FindAllStr:

; 653  : 	}
; 654  : 	
; 655  : 	startInfo.m_startFace = untouchedFace;
; 656  : 	startInfo.m_startEdge = edgeIter;
; 657  : 	if (edgeIter != NULL)

	mov	edx, DWORD PTR _allEdgeInfos$[ebp]
	test	ebx, ebx
	je	SHORT $LN717@FindAllStr

; 658  : 	{
; 659  : 		if(strip->SharesEdge(startInfo.m_startFace, edgeInfos))

	push	edx
	push	edi
	mov	ecx, esi
	call	?SharesEdge@NvStripInfo@@QAE_NPBVNvFaceInfo@@AAV?$xr_vector@PAVNvEdgeInfo@@V?$xalloc@PAVNvEdgeInfo@@@@@@@Z ; NvStripInfo::SharesEdge
	test	al, al
	mov	eax, DWORD PTR _v$1$[esp+200]
	je	SHORT $LN716@FindAllStr

; 660  : 			startInfo.m_toV1 = (edgeIter->m_v0 == v);  //note! used to be m_v1

	cmp	DWORD PTR [ebx+12], eax
	jmp	SHORT $LN1196@FindAllStr
$LN716@FindAllStr:

; 661  : 		else
; 662  : 			startInfo.m_toV1 = (edgeIter->m_v1 == v);

	cmp	DWORD PTR [ebx+16], eax
$LN1196@FindAllStr:

; 663  : 	}
; 664  : 	return (startInfo.m_startFace != NULL);

	sete	BYTE PTR _startInfo$21[esp+208]
$LN717@FindAllStr:
	test	edi, edi

; 1309 : 			
; 1310 : 			NvStripInfo *stripIter = experiments[i][0];
; 1311 : 			NvStripStartInfo startInfo(NULL, NULL, false);
; 1312 : 			while (FindTraversal(allFaceInfos, allEdgeInfos, stripIter, startInfo)){

	je	$LN7@FindAllStr

; 1315 : 				stripIter = xr_new<NvStripInfo> (startInfo, stripId++, experimentId);

	mov	eax, DWORD PTR _stripId$1$[esp+200]
	mov	esi, eax
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h

; 86   : 	T* ptr	= (T*)Memory.mem_alloc(sizeof(T));

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 1315 : 				stripIter = xr_new<NvStripInfo> (startInfo, stripId++, experimentId);

	inc	eax
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h

; 86   : 	T* ptr	= (T*)Memory.mem_alloc(sizeof(T));

	push	36					; 00000024H
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 1315 : 				stripIter = xr_new<NvStripInfo> (startInfo, stripId++, experimentId);

	mov	DWORD PTR _stripId$1$[esp+204], eax
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h

; 86   : 	T* ptr	= (T*)Memory.mem_alloc(sizeof(T));

	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z

; 87   : 	return new (ptr) T(p1,p2,p3);

	mov	ecx, eax
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.h

; 123  : 	  m_startInfo(startInfo)

	mov	eax, DWORD PTR _startInfo$21[esp+208]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 1318 : 				stripIter->Build(allEdgeInfos, allFaceInfos);

	push	ecx
	push	DWORD PTR _allEdgeInfos$[ebp]
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h

; 87   : 	return new (ptr) T(p1,p2,p3);

	mov	DWORD PTR $T4[esp+208], ecx
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.h

; 123  : 	  m_startInfo(startInfo)

	mov	DWORD PTR [ecx], edi
	mov	DWORD PTR [ecx+4], ebx

; 125  : 		m_stripId      = stripId;

	mov	DWORD PTR [ecx+24], esi

; 126  : 		m_experimentId = experimentId;

	mov	esi, ecx
	mov	DWORD PTR [ecx+8], eax
	mov	eax, DWORD PTR _experimentId$1$[esp+208]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx+12], 0
	mov	DWORD PTR [ecx+16], 0
	mov	DWORD PTR [ecx+20], 0
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.h

; 126  : 		m_experimentId = experimentId;

	mov	DWORD PTR [esi+28], eax

; 127  : 		visited = false;

	mov	BYTE PTR [esi+32], 0
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 1315 : 				stripIter = xr_new<NvStripInfo> (startInfo, stripId++, experimentId);

	mov	DWORD PTR _stripIter$5[esp+208], esi

; 1318 : 				stripIter->Build(allEdgeInfos, allFaceInfos);

	call	?Build@NvStripInfo@@QAEXAAV?$xr_vector@PAVNvEdgeInfo@@V?$xalloc@PAVNvEdgeInfo@@@@@@AAV?$xr_vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@@@Z ; NvStripInfo::Build
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 119  :         _Ptr += _Off;

	mov	ecx, DWORD PTR tv5785[esp+200]
	add	ecx, DWORD PTR _experiments$17[esp+200]

; 730  :         if (_Mylast != _My_data._Myend) {

	mov	eax, DWORD PTR [ecx+4]
	cmp	eax, DWORD PTR [ecx+8]
	je	SHORT $LN796@FindAllStr

; 713  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

	mov	DWORD PTR [eax], esi

; 714  :         _Orphan_range(_Mylast, _Mylast);
; 715  :         _Ty& _Result = *_Mylast;
; 716  :         ++_Mylast;

	add	DWORD PTR [ecx+4], 4
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 1322 : 			}

	mov	eax, DWORD PTR _experiments$17[esp+200]
	mov	DWORD PTR _experiments$1$[esp+200], eax
	jmp	$LL10@FindAllStr
$LN796@FindAllStr:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 734  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	lea	edx, DWORD PTR _stripIter$5[esp+200]
	push	edx
	push	eax
	call	??$_Emplace_reallocate@ABQAVNvStripInfo@@@?$vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@std@@QAEPAPAVNvStripInfo@@QAPAV2@ABQAV2@@Z ; std::vector<NvStripInfo *,xalloc<NvStripInfo *> >::_Emplace_reallocate<NvStripInfo * const &>
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 1322 : 			}

	mov	eax, DWORD PTR _experiments$17[esp+200]
	mov	DWORD PTR _experiments$1$[esp+200], eax
	jmp	$LL10@FindAllStr
$LC1121@FindAllStr:

; 1202 : 	for (int i = 0; i < numStrips; i++){

	test	esi, esi
	jle	SHORT $LN1162@FindAllStr
$LN820@FindAllStr:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1535 :         auto& _My_data = _Mypair._Myval2;

	mov	eax, DWORD PTR [edi+edx*4]

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	edx, DWORD PTR [eax+16]
	sub	edx, DWORD PTR [eax+12]
	sar	edx, 2
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 1202 : 	for (int i = 0; i < numStrips; i++){

	jmp	SHORT $LN1120@FindAllStr
$LN1162@FindAllStr:
	mov	edx, ecx
$LN1120@FindAllStr:
	lea	eax, DWORD PTR [ebx+ecx]
	add	eax, edx

; 1205 : 	}
; 1206 : 	return ((float)sizeAccum) / ((float)numStrips);

	mov	DWORD PTR tv5875[esp+200], eax
	fild	DWORD PTR tv5875[esp+200]

; 1331 : 		{
; 1332 : 			const float avgStripSizeWeight = 1.0f;
; 1333 : 			const float numTrisWeight      = 1.0f;
; 1334 : 			float avgStripSize = AvgStripSize(experiments[i]);
; 1335 : 			float numStrips    = (float) experiments[i].size();

	mov	DWORD PTR tv5872[esp+200], esi

; 1206 : 	return ((float)sizeAccum) / ((float)numStrips);

	fidiv	DWORD PTR _numStrips$19[esp+200]

; 1331 : 		{
; 1332 : 			const float avgStripSizeWeight = 1.0f;
; 1333 : 			const float numTrisWeight      = 1.0f;
; 1334 : 			float avgStripSize = AvgStripSize(experiments[i]);
; 1335 : 			float numStrips    = (float) experiments[i].size();

	fild	DWORD PTR tv5872[esp+200]
	test	esi, esi
	jns	SHORT $LN1190@FindAllStr
	fadd	DWORD PTR __real@4f800000
$LN1190@FindAllStr:

; 1336 : 			float value        = avgStripSize * avgStripSizeWeight + (avgStripSize * numStrips * numTrisWeight);
; 1337 : 				
; 1338 : 			if (value > bestValue)

	mov	eax, DWORD PTR _i$2$[esp+200]
	fadd	ST(0), ST(2)
	fmulp	ST(1), ST(0)
	fst	DWORD PTR _value$16[esp+200]
	fld	DWORD PTR _bestValue$12[esp+200]
	fxch	ST(1)
	fcomip	ST(1)
	fstp	ST(0)
	jbe	SHORT $LN1163@FindAllStr

; 1339 : 			{
; 1340 : 				bestValue = value;

	movss	xmm0, DWORD PTR _value$16[esp+200]

; 1341 : 				bestIndex = i;

	mov	esi, eax
	movss	DWORD PTR _bestValue$12[esp+200], xmm0
	mov	DWORD PTR _bestIndex$1$[esp+200], esi
	jmp	SHORT $LN12@FindAllStr
$LN1163@FindAllStr:

; 1336 : 			float value        = avgStripSize * avgStripSizeWeight + (avgStripSize * numStrips * numTrisWeight);
; 1337 : 				
; 1338 : 			if (value > bestValue)

	mov	esi, DWORD PTR _bestIndex$1$[esp+200]
$LN12@FindAllStr:

; 1329 : 		float bestValue = 0;
; 1330 : 		for (i = 0; i < numExperiments; i++)

	mov	edx, DWORD PTR tv5783[esp+200]
	inc	eax
	add	edx, 12					; 0000000cH
	mov	DWORD PTR _i$2$[esp+200], eax
	mov	DWORD PTR tv5783[esp+200], edx
	cmp	eax, DWORD PTR _experimentIndex$1$[esp+200]
	jl	$LN14@FindAllStr
	mov	ecx, DWORD PTR _experiments$1$[esp+200]
	fstp	ST(0)
	jmp	SHORT $LN867@FindAllStr
$LN8@FindAllStr:

; 1323 : 		}
; 1324 : 		
; 1325 : 		//
; 1326 : 		// Phase 3: Find the experiment that has the most promise
; 1327 : 		//
; 1328 : 		int bestIndex = 0;

	mov	eax, DWORD PTR _stripId$1$[esp+200]
	xor	esi, esi
	mov	ecx, DWORD PTR _experiments$17[esp+200]
	mov	DWORD PTR _bestIndex$1$[esp+200], esi
	mov	DWORD PTR _stripId$1$[esp+200], eax
	mov	DWORD PTR _experiments$1$[esp+200], ecx
$LN867@FindAllStr:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 119  :         _Ptr += _Off;

	lea	edi, DWORD PTR [esi+esi*2]
	xor	ebx, ebx

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	eax, DWORD PTR [ecx+edi*4+4]
	sub	eax, DWORD PTR [ecx+edi*4]
	sar	eax, 2

; 119  :         _Ptr += _Off;

	mov	DWORD PTR tv5755[esp+200], edi

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	DWORD PTR _numStrips$1$[esp+200], eax

; 119  :         _Ptr += _Off;

	mov	DWORD PTR _i$1$[esp+200], ebx
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 601  : 	for (int i = 0; i < numStrips; i++){

	test	eax, eax
	jle	$LN1166@FindAllStr
$LL884@FindAllStr:

; 604  : 		NvStripInfo *strip = strips[i];

	mov	eax, DWORD PTR [ecx+edi*4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 730  :         if (_Mylast != _My_data._Myend) {

	mov	edx, DWORD PTR _allStrips$[ebp]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 604  : 		NvStripInfo *strip = strips[i];

	mov	esi, DWORD PTR [eax+ebx*4]
	mov	DWORD PTR _strip$15[esp+200], esi

; 605  : 		strip->m_experimentId = -1;

	mov	DWORD PTR [esi+28], -1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 730  :         if (_Mylast != _My_data._Myend) {

	mov	eax, DWORD PTR [edx+4]
	cmp	eax, DWORD PTR [edx+8]
	je	SHORT $LN909@FindAllStr

; 713  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

	mov	DWORD PTR [eax], esi

; 714  :         _Orphan_range(_Mylast, _Mylast);
; 715  :         _Ty& _Result = *_Mylast;
; 716  :         ++_Mylast;

	add	DWORD PTR [edx+4], 4

; 731  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

	jmp	SHORT $LN916@FindAllStr
$LN909@FindAllStr:

; 734  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	lea	ecx, DWORD PTR _strip$15[esp+200]
	push	ecx
	push	eax
	mov	ecx, edx
	call	??$_Emplace_reallocate@ABQAVNvStripInfo@@@?$vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@std@@QAEPAPAVNvStripInfo@@QAPAV2@ABQAV2@@Z ; std::vector<NvStripInfo *,xalloc<NvStripInfo *> >::_Emplace_reallocate<NvStripInfo * const &>
	mov	ecx, DWORD PTR _experiments$1$[esp+200]
$LN916@FindAllStr:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 612  : 		const NvFaceInfoVec &faces = strips[i]->m_faces;

	mov	eax, DWORD PTR [ecx+edi*4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 119  :         _Ptr += _Off;

	xor	edx, edx
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 612  : 		const NvFaceInfoVec &faces = strips[i]->m_faces;

	mov	ebx, DWORD PTR [eax+ebx*4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	edi, DWORD PTR [ebx+16]
	sub	edi, DWORD PTR [ebx+12]
	sar	edi, 2
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 615  : 		for (int j = 0; j < numFaces; j++)

	test	edi, edi
	jle	SHORT $LN882@FindAllStr
	npad	1
$LL887@FindAllStr:

; 616  : 		{
; 617  : 			strip->MarkTriangle(faces[j]);

	mov	eax, DWORD PTR [ebx+12]
	mov	ecx, DWORD PTR [eax+edx*4]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.h

; 131  : 	inline bool IsExperiment () const { return m_experimentId >= 0; }

	mov	eax, DWORD PTR [esi+28]
	test	eax, eax
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 388  : 	if (IsExperiment()){

	js	SHORT $LN944@FindAllStr

; 389  : 		faceInfo->m_experimentId = m_experimentId;

	mov	DWORD PTR [ecx+20], eax

; 390  : 		faceInfo->m_testStripId  = m_stripId;

	mov	eax, DWORD PTR [esi+24]
	mov	DWORD PTR [ecx+16], eax

; 391  :     }

	jmp	SHORT $LN885@FindAllStr
$LN944@FindAllStr:

; 392  : 	else{
; 393  : 		assert(faceInfo->m_stripId == -1);
; 394  : 		faceInfo->m_experimentId = -1;

	mov	DWORD PTR [ecx+20], -1

; 395  : 		faceInfo->m_stripId      = m_stripId;

	mov	eax, DWORD PTR [esi+24]
	mov	DWORD PTR [ecx+12], eax
$LN885@FindAllStr:

; 615  : 		for (int j = 0; j < numFaces; j++)

	inc	edx
	cmp	edx, edi
	jl	SHORT $LL887@FindAllStr
	mov	ecx, DWORD PTR _experiments$1$[esp+200]
$LN882@FindAllStr:

; 601  : 	for (int i = 0; i < numStrips; i++){

	mov	ebx, DWORD PTR _i$1$[esp+200]
	mov	edi, DWORD PTR tv5755[esp+200]
	inc	ebx
	mov	DWORD PTR _i$1$[esp+200], ebx
	cmp	ebx, DWORD PTR _numStrips$1$[esp+200]
	jl	$LL884@FindAllStr
	mov	ebx, DWORD PTR _experiments$17[esp+200]
	mov	esi, DWORD PTR _bestIndex$1$[esp+200]
	mov	DWORD PTR _experiments$1$[esp+200], ebx
	jmp	SHORT $LN883@FindAllStr
$LN1166@FindAllStr:
	mov	ebx, DWORD PTR _experiments$1$[esp+200]
$LN883@FindAllStr:

; 1342 : 			}
; 1343 : 		}
; 1344 : 		
; 1345 : 		//
; 1346 : 		// Phase 4: commit the best experiment of the bunch
; 1347 : 		//
; 1348 : 		CommitStrips(allStrips, experiments[bestIndex]);
; 1349 : 		
; 1350 : 		// and destroy all of the others
; 1351 : 		for (i = 0; i < numExperiments; i++)

	xor	edx, edx
	mov	DWORD PTR _i$3$[esp+200], edx
	cmp	DWORD PTR _experimentIndex$1$[esp+200], edx
	jle	$LN16@FindAllStr
	mov	eax, DWORD PTR _experimentIndex$1$[esp+200]
	xor	ecx, ecx
	mov	DWORD PTR tv5781[esp+200], ecx
$LL17@FindAllStr:

; 1352 : 		{
; 1353 : 			if (i != bestIndex)

	cmp	edx, esi
	je	$LN15@FindAllStr
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	eax, DWORD PTR [ebx+ecx+4]

; 119  :         _Ptr += _Off;

	xor	edi, edi

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	sub	eax, DWORD PTR [ebx+ecx]
	sar	eax, 2
	mov	DWORD PTR _numStrips$1$[esp+200], eax
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 1356 : 				for (int j = 0; j < numStrips; j++)

	test	eax, eax
	jle	$LN1167@FindAllStr
$LL20@FindAllStr:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 119  :         _Ptr += _Off;

	mov	ebx, DWORD PTR [ebx+ecx]
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h

; 151  : 	if (ptr) 

	mov	esi, DWORD PTR [ebx+edi*4]
	test	esi, esi
	je	SHORT $LN1165@FindAllStr
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [esi+12]
	test	eax, eax
	je	SHORT $LN1019@FindAllStr
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi+12], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+16], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+20], 0
	mov	esi, DWORD PTR [ebx+edi*4]
$LN1019@FindAllStr:
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h

; 144  : 		Memory.mem_free	(ptr);

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	esi
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
	mov	eax, DWORD PTR _numStrips$1$[esp+200]
	mov	ecx, DWORD PTR tv5781[esp+200]

; 154  : 		ptr = nullptr;

	mov	DWORD PTR [ebx+edi*4], 0
	mov	ebx, DWORD PTR _experiments$17[esp+200]
	mov	DWORD PTR _experiments$1$[esp+200], ebx
	jmp	SHORT $LN18@FindAllStr
$LN1165@FindAllStr:

; 151  : 	if (ptr) 

	mov	ebx, DWORD PTR _experiments$1$[esp+200]
$LN18@FindAllStr:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 1356 : 				for (int j = 0; j < numStrips; j++)

	inc	edi
	cmp	edi, eax
	jl	SHORT $LL20@FindAllStr
	mov	edx, DWORD PTR _i$3$[esp+200]
	mov	esi, DWORD PTR _bestIndex$1$[esp+200]
$LN1167@FindAllStr:

; 1342 : 			}
; 1343 : 		}
; 1344 : 		
; 1345 : 		//
; 1346 : 		// Phase 4: commit the best experiment of the bunch
; 1347 : 		//
; 1348 : 		CommitStrips(allStrips, experiments[bestIndex]);
; 1349 : 		
; 1350 : 		// and destroy all of the others
; 1351 : 		for (i = 0; i < numExperiments; i++)

	mov	eax, DWORD PTR _experimentIndex$1$[esp+200]
$LN15@FindAllStr:
	inc	edx
	add	ecx, 12					; 0000000cH
	mov	DWORD PTR _i$3$[esp+200], edx
	mov	DWORD PTR tv5781[esp+200], ecx
	cmp	edx, eax
	jl	$LL17@FindAllStr
$LN16@FindAllStr:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xtree

; 752  :         _Erase_tree(_Al, _Myhead->_Parent);

	mov	eax, DWORD PTR _resetPoints$18[esp+200]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 1364 : 		experiments.clear	();

	mov	DWORD PTR _experiments$17[esp+204], ebx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xtree

; 752  :         _Erase_tree(_Al, _Myhead->_Parent);

	push	DWORD PTR [eax+4]
	lea	eax, DWORD PTR _resetPoints$18[esp+204]
	push	eax
	mov	ecx, eax
	call	??$_Erase_tree@V?$xalloc@U?$_Tree_node@PAVNvFaceInfo@@PAX@std@@@@@?$_Tree_val@U?$_Tree_simple_types@PAVNvFaceInfo@@@std@@@std@@QAEXAAV?$xalloc@U?$_Tree_node@PAVNvFaceInfo@@PAX@std@@@@PAU?$_Tree_node@PAVNvFaceInfo@@PAX@1@@Z ; std::_Tree_val<std::_Tree_simple_types<NvFaceInfo *> >::_Erase_tree<xalloc<std::_Tree_node<NvFaceInfo *,void *> > >
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	eax, DWORD PTR _resetPoints$18[esp+200]
	mov	esi, DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
	test	eax, eax
	je	SHORT $LN1041@FindAllStr
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	esi
$LN1041@FindAllStr:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR _experiments$17[esp+200]
	test	eax, eax
	je	SHORT $LN1048@FindAllStr
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR _experiments$17[esp+200], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR _experiments$17[esp+204], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR _experiments$17[esp+208], 0
$LN1048@FindAllStr:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.cpp

; 1231 : 	while (!done)

	cmp	BYTE PTR _done$1$[esp+200], 0
	je	$LL2@FindAllStr

; 1366 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
$LN1088@FindAllStr:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xtree

; 1616 :             _Throw_tree_length_error();

	call	?_Throw_tree_length_error@std@@YAXXZ	; std::_Throw_tree_length_error
$LN1191@FindAllStr:
	int	3
?FindAllStrips@NvStripifier@@IAEXAAV?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@AAV?$xr_vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@@AAV?$xr_vector@PAVNvEdgeInfo@@V?$xalloc@PAVNvEdgeInfo@@@@@@H@Z ENDP ; NvStripifier::FindAllStrips
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??1?$xr_vector@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@V?$xalloc@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@@@@QAE@XZ
_TEXT	SEGMENT
??1?$xr_vector@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@V?$xalloc@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@@@@QAE@XZ PROC ; xr_vector<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> >,xalloc<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> > > >::~xr_vector<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> >,xalloc<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> > > >, COMDAT
; _this$ = ecx

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	push	esi
	mov	esi, ecx
	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN6@xr_vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+4], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+8], 0
$LN6@xr_vector:
	pop	esi
	ret	0
??1?$xr_vector@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@V?$xalloc@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@@@@QAE@XZ ENDP ; xr_vector<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> >,xalloc<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> > > >::~xr_vector<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> >,xalloc<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xtree
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xtree
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xtree
;	COMDAT ??0?$xr_set@PAVNvFaceInfo@@U?$less@PAVNvFaceInfo@@@std@@V?$xalloc@PAVNvFaceInfo@@@@@@QAE@XZ
_TEXT	SEGMENT
??0?$xr_set@PAVNvFaceInfo@@U?$less@PAVNvFaceInfo@@@std@@V?$xalloc@PAVNvFaceInfo@@@@@@QAE@XZ PROC ; xr_set<NvFaceInfo *,std::less<NvFaceInfo *>,xalloc<NvFaceInfo *> >::xr_set<NvFaceInfo *,std::less<NvFaceInfo *>,xalloc<NvFaceInfo *> >, COMDAT
; _this$ = ecx

; 435  :     _Tree_val() noexcept : _Myhead(), _Mysize(0) {}

	push	esi
	mov	esi, ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	push	20					; 00000014H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xtree

; 435  :     _Tree_val() noexcept : _Myhead(), _Mysize(0) {}

	mov	DWORD PTR [esi], 0
	mov	DWORD PTR [esi+4], 0
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xtree

; 345  :         _Construct_in_place(_Pnode->_Left, _Pnode);

	mov	DWORD PTR [eax], eax

; 346  :         _Construct_in_place(_Pnode->_Parent, _Pnode);

	mov	DWORD PTR [eax+4], eax

; 347  :         _Construct_in_place(_Pnode->_Right, _Pnode);

	mov	DWORD PTR [eax+8], eax

; 348  :         _Pnode->_Color = _Black;

	mov	WORD PTR [eax+12], 257			; 00000101H

; 1917 :         _Scary->_Myhead = _Node::_Buyheadnode(_Getal());

	mov	DWORD PTR [esi], eax
	mov	eax, esi
	pop	esi
	ret	0
??0?$xr_set@PAVNvFaceInfo@@U?$less@PAVNvFaceInfo@@@std@@V?$xalloc@PAVNvFaceInfo@@@@@@QAE@XZ ENDP ; xr_set<NvFaceInfo *,std::less<NvFaceInfo *>,xalloc<NvFaceInfo *> >::xr_set<NvFaceInfo *,std::less<NvFaceInfo *>,xalloc<NvFaceInfo *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
;	COMDAT ??1?$xr_set@PAVNvFaceInfo@@U?$less@PAVNvFaceInfo@@@std@@V?$xalloc@PAVNvFaceInfo@@@@@@QAE@XZ
_TEXT	SEGMENT
??1?$xr_set@PAVNvFaceInfo@@U?$less@PAVNvFaceInfo@@@std@@V?$xalloc@PAVNvFaceInfo@@@@@@QAE@XZ PROC ; xr_set<NvFaceInfo *,std::less<NvFaceInfo *>,xalloc<NvFaceInfo *> >::~xr_set<NvFaceInfo *,std::less<NvFaceInfo *>,xalloc<NvFaceInfo *> >, COMDAT
; _this$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xtree

; 752  :         _Erase_tree(_Al, _Myhead->_Parent);

	push	esi
	mov	esi, ecx
	mov	eax, DWORD PTR [esi]
	push	DWORD PTR [eax+4]
	push	esi
	call	??$_Erase_tree@V?$xalloc@U?$_Tree_node@PAVNvFaceInfo@@PAX@std@@@@@?$_Tree_val@U?$_Tree_simple_types@PAVNvFaceInfo@@@std@@@std@@QAEXAAV?$xalloc@U?$_Tree_node@PAVNvFaceInfo@@PAX@std@@@@PAU?$_Tree_node@PAVNvFaceInfo@@PAX@1@@Z ; std::_Tree_val<std::_Tree_simple_types<NvFaceInfo *> >::_Erase_tree<xalloc<std::_Tree_node<NvFaceInfo *,void *> > >
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 560  :         _Al.deallocate(_Ptr, _Count);

	mov	eax, DWORD PTR [esi]
	pop	esi
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	test	eax, eax
	je	SHORT $LN16@xr_set
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN16@xr_set:
	ret	0
??1?$xr_set@PAVNvFaceInfo@@U?$less@PAVNvFaceInfo@@@std@@V?$xalloc@PAVNvFaceInfo@@@@@@QAE@XZ ENDP ; xr_set<NvFaceInfo *,std::less<NvFaceInfo *>,xalloc<NvFaceInfo *> >::~xr_set<NvFaceInfo *,std::less<NvFaceInfo *>,xalloc<NvFaceInfo *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
;	COMDAT ??1?$set@PAVNvFaceInfo@@U?$less@PAVNvFaceInfo@@@std@@V?$xalloc@PAVNvFaceInfo@@@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$set@PAVNvFaceInfo@@U?$less@PAVNvFaceInfo@@@std@@V?$xalloc@PAVNvFaceInfo@@@@@std@@QAE@XZ PROC ; std::set<NvFaceInfo *,std::less<NvFaceInfo *>,xalloc<NvFaceInfo *> >::~set<NvFaceInfo *,std::less<NvFaceInfo *>,xalloc<NvFaceInfo *> >, COMDAT
; _this$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xtree

; 752  :         _Erase_tree(_Al, _Myhead->_Parent);

	push	esi
	mov	esi, ecx
	mov	eax, DWORD PTR [esi]
	push	DWORD PTR [eax+4]
	push	esi
	call	??$_Erase_tree@V?$xalloc@U?$_Tree_node@PAVNvFaceInfo@@PAX@std@@@@@?$_Tree_val@U?$_Tree_simple_types@PAVNvFaceInfo@@@std@@@std@@QAEXAAV?$xalloc@U?$_Tree_node@PAVNvFaceInfo@@PAX@std@@@@PAU?$_Tree_node@PAVNvFaceInfo@@PAX@1@@Z ; std::_Tree_val<std::_Tree_simple_types<NvFaceInfo *> >::_Erase_tree<xalloc<std::_Tree_node<NvFaceInfo *,void *> > >
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 560  :         _Al.deallocate(_Ptr, _Count);

	mov	eax, DWORD PTR [esi]
	pop	esi
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	test	eax, eax
	je	SHORT $LN14@set
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN14@set:
	ret	0
??1?$set@PAVNvFaceInfo@@U?$less@PAVNvFaceInfo@@@std@@V?$xalloc@PAVNvFaceInfo@@@@@std@@QAE@XZ ENDP ; std::set<NvFaceInfo *,std::less<NvFaceInfo *>,xalloc<NvFaceInfo *> >::~set<NvFaceInfo *,std::less<NvFaceInfo *>,xalloc<NvFaceInfo *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xtree
;	COMDAT ??9?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@PAVNvFaceInfo@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@PAVNvFaceInfo@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<NvFaceInfo *> > >::operator!=, COMDAT
; _this$ = ecx

; 238  :         return !(*this == _Right);

	mov	eax, DWORD PTR __Right$[esp-4]
	mov	ecx, DWORD PTR [ecx]
	cmp	ecx, DWORD PTR [eax]
	setne	al

; 239  :     }

	ret	4
??9?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@PAVNvFaceInfo@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<NvFaceInfo *> > >::operator!=
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\set
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xtree
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\set
;	COMDAT ??0?$set@PAVNvFaceInfo@@U?$less@PAVNvFaceInfo@@@std@@V?$xalloc@PAVNvFaceInfo@@@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$set@PAVNvFaceInfo@@U?$less@PAVNvFaceInfo@@@std@@V?$xalloc@PAVNvFaceInfo@@@@@std@@QAE@XZ PROC ; std::set<NvFaceInfo *,std::less<NvFaceInfo *>,xalloc<NvFaceInfo *> >::set<NvFaceInfo *,std::less<NvFaceInfo *>,xalloc<NvFaceInfo *> >, COMDAT
; _this$ = ecx

; 82   :     set() : _Mybase(key_compare()) {}

	push	esi
	mov	esi, ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	push	20					; 00000014H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xtree

; 435  :     _Tree_val() noexcept : _Myhead(), _Mysize(0) {}

	mov	DWORD PTR [esi], 0
	mov	DWORD PTR [esi+4], 0
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xtree

; 345  :         _Construct_in_place(_Pnode->_Left, _Pnode);

	mov	DWORD PTR [eax], eax

; 346  :         _Construct_in_place(_Pnode->_Parent, _Pnode);

	mov	DWORD PTR [eax+4], eax

; 347  :         _Construct_in_place(_Pnode->_Right, _Pnode);

	mov	DWORD PTR [eax+8], eax

; 348  :         _Pnode->_Color = _Black;

	mov	WORD PTR [eax+12], 257			; 00000101H

; 1917 :         _Scary->_Myhead = _Node::_Buyheadnode(_Getal());

	mov	DWORD PTR [esi], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\set

; 82   :     set() : _Mybase(key_compare()) {}

	mov	eax, esi
	pop	esi
	ret	0
??0?$set@PAVNvFaceInfo@@U?$less@PAVNvFaceInfo@@@std@@V?$xalloc@PAVNvFaceInfo@@@@@std@@QAE@XZ ENDP ; std::set<NvFaceInfo *,std::less<NvFaceInfo *>,xalloc<NvFaceInfo *> >::set<NvFaceInfo *,std::less<NvFaceInfo *>,xalloc<NvFaceInfo *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xtree
;	COMDAT ?find@?$_Tree@V?$_Tset_traits@PAVNvFaceInfo@@U?$less@PAVNvFaceInfo@@@std@@V?$xalloc@PAVNvFaceInfo@@@@$0A@@std@@@std@@QAE?AV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@PAVNvFaceInfo@@@std@@@std@@@2@ABQAVNvFaceInfo@@@Z
_TEXT	SEGMENT
__Loc$1 = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Keyval$ = 12						; size = 4
?find@?$_Tree@V?$_Tset_traits@PAVNvFaceInfo@@U?$less@PAVNvFaceInfo@@@std@@V?$xalloc@PAVNvFaceInfo@@@@$0A@@std@@@std@@QAE?AV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@PAVNvFaceInfo@@@std@@@std@@@2@ABQAVNvFaceInfo@@@Z PROC ; std::_Tree<std::_Tset_traits<NvFaceInfo *,std::less<NvFaceInfo *>,xalloc<NvFaceInfo *>,0> >::find, COMDAT
; _this$ = ecx

; 1362 :     _NODISCARD iterator find(const key_type& _Keyval) {

	sub	esp, 12					; 0000000cH
	push	esi

; 1353 :         const _Tree_find_result<_Nodeptr> _Loc = _Find_lower_bound(_Keyval);

	mov	esi, DWORD PTR __Keyval$[esp+12]
	lea	eax, DWORD PTR __Loc$1[esp+16]

; 1362 :     _NODISCARD iterator find(const key_type& _Keyval) {

	push	edi

; 1353 :         const _Tree_find_result<_Nodeptr> _Loc = _Find_lower_bound(_Keyval);

	push	esi
	push	eax

; 1362 :     _NODISCARD iterator find(const key_type& _Keyval) {

	mov	edi, ecx

; 1353 :         const _Tree_find_result<_Nodeptr> _Loc = _Find_lower_bound(_Keyval);

	call	??$_Find_lower_bound@PAVNvFaceInfo@@@?$_Tree@V?$_Tset_traits@PAVNvFaceInfo@@U?$less@PAVNvFaceInfo@@@std@@V?$xalloc@PAVNvFaceInfo@@@@$0A@@std@@@std@@IBE?AU?$_Tree_find_result@PAU?$_Tree_node@PAVNvFaceInfo@@PAX@std@@@1@ABQAVNvFaceInfo@@@Z ; std::_Tree<std::_Tset_traits<NvFaceInfo *,std::less<NvFaceInfo *>,xalloc<NvFaceInfo *>,0> >::_Find_lower_bound<NvFaceInfo *>

; 1591 :         return !_Bound->_Isnil && !_DEBUG_LT_PRED(_Getcomp(), _Keyval, _Traits::_Kfn(_Bound->_Myval));

	mov	edx, DWORD PTR __Loc$1[esp+28]
	cmp	BYTE PTR [edx+13], 0
	jne	SHORT $LN4@find
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef

; 117  :         return _Left < _Right;

	mov	eax, DWORD PTR [esi]
	cmp	eax, DWORD PTR [edx+16]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xtree

; 1591 :         return !_Bound->_Isnil && !_DEBUG_LT_PRED(_Getcomp(), _Keyval, _Traits::_Kfn(_Bound->_Myval));

	jb	SHORT $LN4@find

; 38   :     _Tree_unchecked_const_iterator(_Nodeptr _Pnode, const _Mytree* _Plist) noexcept : _Ptr(_Pnode) {

	mov	eax, DWORD PTR ___$ReturnUdt$[esp+16]
	pop	edi

; 1363 :         return iterator(_Find(_Keyval), _Get_scary());
; 1364 :     }

	pop	esi

; 38   :     _Tree_unchecked_const_iterator(_Nodeptr _Pnode, const _Mytree* _Plist) noexcept : _Ptr(_Pnode) {

	mov	DWORD PTR [eax], edx

; 1363 :         return iterator(_Find(_Keyval), _Get_scary());
; 1364 :     }

	add	esp, 12					; 0000000cH
	ret	8
$LN4@find:

; 38   :     _Tree_unchecked_const_iterator(_Nodeptr _Pnode, const _Mytree* _Plist) noexcept : _Ptr(_Pnode) {

	mov	eax, DWORD PTR ___$ReturnUdt$[esp+16]

; 1358 :         return _Get_scary()->_Myhead;

	mov	ecx, DWORD PTR [edi]
	pop	edi

; 1363 :         return iterator(_Find(_Keyval), _Get_scary());
; 1364 :     }

	pop	esi

; 38   :     _Tree_unchecked_const_iterator(_Nodeptr _Pnode, const _Mytree* _Plist) noexcept : _Ptr(_Pnode) {

	mov	DWORD PTR [eax], ecx

; 1363 :         return iterator(_Find(_Keyval), _Get_scary());
; 1364 :     }

	add	esp, 12					; 0000000cH
	ret	8
?find@?$_Tree@V?$_Tset_traits@PAVNvFaceInfo@@U?$less@PAVNvFaceInfo@@@std@@V?$xalloc@PAVNvFaceInfo@@@@$0A@@std@@@std@@QAE?AV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@PAVNvFaceInfo@@@std@@@std@@@2@ABQAVNvFaceInfo@@@Z ENDP ; std::_Tree<std::_Tset_traits<NvFaceInfo *,std::less<NvFaceInfo *>,xalloc<NvFaceInfo *>,0> >::find
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xtree
;	COMDAT ?end@?$_Tree@V?$_Tset_traits@PAVNvFaceInfo@@U?$less@PAVNvFaceInfo@@@std@@V?$xalloc@PAVNvFaceInfo@@@@$0A@@std@@@std@@QAE?AV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@PAVNvFaceInfo@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$_Tree@V?$_Tset_traits@PAVNvFaceInfo@@U?$less@PAVNvFaceInfo@@@std@@V?$xalloc@PAVNvFaceInfo@@@@$0A@@std@@@std@@QAE?AV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@PAVNvFaceInfo@@@std@@@std@@@2@XZ PROC ; std::_Tree<std::_Tset_traits<NvFaceInfo *,std::less<NvFaceInfo *>,xalloc<NvFaceInfo *>,0> >::end, COMDAT
; _this$ = ecx

; 38   :     _Tree_unchecked_const_iterator(_Nodeptr _Pnode, const _Mytree* _Plist) noexcept : _Ptr(_Pnode) {

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	ecx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], ecx

; 1144 :         const auto _Scary = _Get_scary();
; 1145 :         return iterator(_Scary->_Myhead, _Scary);
; 1146 :     }

	ret	4
?end@?$_Tree@V?$_Tset_traits@PAVNvFaceInfo@@U?$less@PAVNvFaceInfo@@@std@@V?$xalloc@PAVNvFaceInfo@@@@$0A@@std@@@std@@QAE?AV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@PAVNvFaceInfo@@@std@@@std@@@2@XZ ENDP ; std::_Tree<std::_Tset_traits<NvFaceInfo *,std::less<NvFaceInfo *>,xalloc<NvFaceInfo *>,0> >::end
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xtree
;	COMDAT ??1?$_Tree@V?$_Tset_traits@PAVNvFaceInfo@@U?$less@PAVNvFaceInfo@@@std@@V?$xalloc@PAVNvFaceInfo@@@@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Tree@V?$_Tset_traits@PAVNvFaceInfo@@U?$less@PAVNvFaceInfo@@@std@@V?$xalloc@PAVNvFaceInfo@@@@$0A@@std@@@std@@QAE@XZ PROC ; std::_Tree<std::_Tset_traits<NvFaceInfo *,std::less<NvFaceInfo *>,xalloc<NvFaceInfo *>,0> >::~_Tree<std::_Tset_traits<NvFaceInfo *,std::less<NvFaceInfo *>,xalloc<NvFaceInfo *>,0> >, COMDAT
; _this$ = ecx

; 1084 :     ~_Tree() noexcept {

	push	esi
	mov	esi, ecx

; 752  :         _Erase_tree(_Al, _Myhead->_Parent);

	mov	eax, DWORD PTR [esi]
	push	DWORD PTR [eax+4]
	push	esi
	call	??$_Erase_tree@V?$xalloc@U?$_Tree_node@PAVNvFaceInfo@@PAX@std@@@@@?$_Tree_val@U?$_Tree_simple_types@PAVNvFaceInfo@@@std@@@std@@QAEXAAV?$xalloc@U?$_Tree_node@PAVNvFaceInfo@@PAX@std@@@@PAU?$_Tree_node@PAVNvFaceInfo@@PAX@1@@Z ; std::_Tree_val<std::_Tree_simple_types<NvFaceInfo *> >::_Erase_tree<xalloc<std::_Tree_node<NvFaceInfo *,void *> > >
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 560  :         _Al.deallocate(_Ptr, _Count);

	mov	eax, DWORD PTR [esi]
	pop	esi
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	test	eax, eax
	je	SHORT $LN12@Tree
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN12@Tree:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xtree

; 1091 :     }

	ret	0
??1?$_Tree@V?$_Tset_traits@PAVNvFaceInfo@@U?$less@PAVNvFaceInfo@@@std@@V?$xalloc@PAVNvFaceInfo@@@@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree<std::_Tset_traits<NvFaceInfo *,std::less<NvFaceInfo *>,xalloc<NvFaceInfo *>,0> >::~_Tree<std::_Tset_traits<NvFaceInfo *,std::less<NvFaceInfo *>,xalloc<NvFaceInfo *>,0> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ??A?$xr_vector@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@V?$xalloc@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@@@@QAEAAV?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$xr_vector@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@V?$xalloc@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@@@@QAEAAV?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@I@Z PROC ; xr_vector<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> >,xalloc<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> > > >::operator[], COMDAT
; _this$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 119  :         _Ptr += _Off;

	mov	eax, DWORD PTR __Pos$[esp-4]
	lea	edx, DWORD PTR [eax+eax*2]
	mov	eax, DWORD PTR [ecx]
	lea	eax, DWORD PTR [eax+edx*4]
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 138  : 	reference operator[]		(size_type _Pos)					{ {VERIFY(_Pos<size());} return (*(begin() + _Pos)); }

	ret	4
??A?$xr_vector@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@V?$xalloc@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@@@@QAEAAV?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@I@Z ENDP ; xr_vector<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> >,xalloc<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> > > >::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?clear@?$xr_vector@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@V?$xalloc@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@@@@QAEXXZ
_TEXT	SEGMENT
?clear@?$xr_vector@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@V?$xalloc@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@@@@QAEXXZ PROC ; xr_vector<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> >,xalloc<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> > > >::clear, COMDAT
; _this$ = ecx

; 132  : 	void	clear				()									{ clear_and_free	();			}

	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [ecx+4], eax
	ret	0
?clear@?$xr_vector@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@V?$xalloc@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@@@@QAEXXZ ENDP ; xr_vector<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> >,xalloc<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> > > >::clear
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ??0?$xr_vector@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@V?$xalloc@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@@@@QAE@XZ
_TEXT	SEGMENT
??0?$xr_vector@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@V?$xalloc@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@@@@QAE@XZ PROC ; xr_vector<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> >,xalloc<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> > > >::xr_vector<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> >,xalloc<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> > > >, COMDAT
; _this$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx], 0
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 122  : 			xr_vector			()									: inherited	()					{}

	mov	eax, ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 122  : 			xr_vector			()									: inherited	()					{}

	ret	0
??0?$xr_vector@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@V?$xalloc@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@@@@QAE@XZ ENDP ; xr_vector<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> >,xalloc<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> > > >::xr_vector<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> >,xalloc<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?resize@?$vector@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@V?$xalloc@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@@@std@@QAEXI@Z
_TEXT	SEGMENT
$T1 = -4						; size = 1
__Newsize$dead$ = 8					; size = 4
?resize@?$vector@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@V?$xalloc@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@@@std@@QAEXI@Z PROC ; std::vector<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> >,xalloc<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> > > >::resize, COMDAT
; _this$ = ecx

; 1275 :     _CONSTEXPR20_CONTAINER void resize(_CRT_GUARDOVERFLOW const size_type _Newsize) {

	push	ecx
	mov	edx, ecx
	push	esi

; 1250 :         const auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);

	mov	eax, DWORD PTR [edx+4]
	mov	esi, DWORD PTR [edx]
	sub	eax, esi
	sar	eax, 2
	imul	ecx, eax, -1431655765

; 1251 :         if (_Newsize < _Oldsize) { // trim

	cmp	ecx, 60					; 0000003cH
	jbe	SHORT $LN4@resize

; 1252 :             const pointer _Newlast = _Myfirst + _Newsize;

	lea	eax, DWORD PTR [esi+720]

; 1276 :         // trim or append value-initialized elements, provide strong guarantee
; 1277 :         _Resize(_Newsize, _Value_init_tag{});
; 1278 :     }

	mov	DWORD PTR [edx+4], eax
	pop	esi
	pop	ecx
	ret	4
$LN4@resize:

; 1259 :         if (_Newsize > _Oldsize) { // append

	jae	SHORT $LN5@resize

; 1260 :             const auto _Oldcapacity = static_cast<size_type>(_My_data._Myend - _Myfirst);

	mov	eax, DWORD PTR [edx+8]
	sub	eax, esi
	sar	eax, 2
	imul	eax, eax, -1431655765

; 1261 :             if (_Newsize > _Oldcapacity) { // reallocate

	cmp	eax, 60					; 0000003cH
	jae	SHORT $LN6@resize

; 1262 :                 _Resize_reallocate(_Newsize, _Val);

	lea	eax, DWORD PTR $T1[esp+8]
	push	eax
	push	ecx
	mov	ecx, edx
	call	??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@V?$xalloc@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@@@std@@AAEXIABU_Value_init_tag@1@@Z ; std::vector<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> >,xalloc<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> > > >::_Resize_reallocate<std::_Value_init_tag>
	pop	esi

; 1276 :         // trim or append value-initialized elements, provide strong guarantee
; 1277 :         _Resize(_Newsize, _Value_init_tag{});
; 1278 :     }

	pop	ecx
	ret	4
$LN6@resize:

; 1267 :             _Mylast                = _Ufill(_Oldlast, _Newsize - _Oldsize, _Val);

	push	DWORD PTR $T1[esp+8]
	mov	eax, 60					; 0000003cH
	sub	eax, ecx
	push	eax
	push	DWORD PTR [edx+4]
	call	?_Ufill@?$vector@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@V?$xalloc@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@@@std@@AAEPAV?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@PAV3@IU_Value_init_tag@2@@Z ; std::vector<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> >,xalloc<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> > > >::_Ufill

; 1276 :         // trim or append value-initialized elements, provide strong guarantee
; 1277 :         _Resize(_Newsize, _Value_init_tag{});
; 1278 :     }

	mov	DWORD PTR [edx+4], eax
$LN5@resize:
	pop	esi
	pop	ecx
	ret	4
?resize@?$vector@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@V?$xalloc@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@@@std@@QAEXI@Z ENDP ; std::vector<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> >,xalloc<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> > > >::resize
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??1?$vector@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@V?$xalloc@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@V?$xalloc@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@@@std@@QAE@XZ PROC ; std::vector<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> >,xalloc<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> > > >::~vector<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> >,xalloc<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> > > >, COMDAT
; _this$ = ecx

; 698  :     _CONSTEXPR20_CONTAINER ~vector() noexcept {

	push	esi
	mov	esi, ecx

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN4@vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+4], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+8], 0
$LN4@vector:
	pop	esi

; 699  :         _Tidy();
; 700  : #if _ITERATOR_DEBUG_LEVEL != 0
; 701  :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 702  :         _Delete_plain_internal(_Alproxy, _STD exchange(_Mypair._Myval2._Myproxy, nullptr));
; 703  : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 704  :     }

	ret	0
??1?$vector@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@V?$xalloc@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@@@std@@QAE@XZ ENDP ; std::vector<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> >,xalloc<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> > > >::~vector<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> >,xalloc<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ??A?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@QBEABQAVNvStripInfo@@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@QBEABQAVNvStripInfo@@I@Z PROC ; xr_vector<NvStripInfo *,xalloc<NvStripInfo *> >::operator[], COMDAT
; _this$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 119  :         _Ptr += _Off;

	mov	ecx, DWORD PTR [ecx]
	mov	eax, DWORD PTR __Pos$[esp-4]
	lea	eax, DWORD PTR [ecx+eax*4]
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 137  : 	const_reference operator[]	(size_type _Pos) const				{ {VERIFY(_Pos<size());} return (*(begin() + _Pos)); }

	ret	4
??A?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@QBEABQAVNvStripInfo@@I@Z ENDP ; xr_vector<NvStripInfo *,xalloc<NvStripInfo *> >::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?clear@?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@QAEXXZ
_TEXT	SEGMENT
?clear@?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@QAEXXZ PROC ; xr_vector<NvStripInfo *,xalloc<NvStripInfo *> >::clear, COMDAT
; _this$ = ecx

; 132  : 	void	clear				()									{ clear_and_free	();			}

	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [ecx+4], eax
	ret	0
?clear@?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@QAEXXZ ENDP ; xr_vector<NvStripInfo *,xalloc<NvStripInfo *> >::clear
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?push_back@?$vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@std@@QAEXABQAVNvStripInfo@@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?push_back@?$vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@std@@QAEXABQAVNvStripInfo@@@Z PROC ; std::vector<NvStripInfo *,xalloc<NvStripInfo *> >::push_back, COMDAT
; _this$ = ecx

; 730  :         if (_Mylast != _My_data._Myend) {

	mov	edx, DWORD PTR [ecx+4]
	cmp	edx, DWORD PTR [ecx+8]
	je	SHORT $LN4@push_back

; 713  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

	mov	eax, DWORD PTR __Val$[esp-4]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edx], eax

; 714  :         _Orphan_range(_Mylast, _Mylast);
; 715  :         _Ty& _Result = *_Mylast;
; 716  :         ++_Mylast;

	add	DWORD PTR [ecx+4], 4

; 743  :         emplace_back(_Val);
; 744  :     }

	ret	4
$LN4@push_back:

; 734  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	push	DWORD PTR __Val$[esp-4]
	push	edx
	call	??$_Emplace_reallocate@ABQAVNvStripInfo@@@?$vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@std@@QAEPAPAVNvStripInfo@@QAPAV2@ABQAV2@@Z ; std::vector<NvStripInfo *,xalloc<NvStripInfo *> >::_Emplace_reallocate<NvStripInfo * const &>

; 743  :         emplace_back(_Val);
; 744  :     }

	ret	4
?push_back@?$vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@std@@QAEXABQAVNvStripInfo@@@Z ENDP ; std::vector<NvStripInfo *,xalloc<NvStripInfo *> >::push_back
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??$emplace_back@ABQAVNvStripInfo@@@?$vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@std@@QAE?A_TABQAVNvStripInfo@@@Z
_TEXT	SEGMENT
_<_Val_0>$ = 8						; size = 4
??$emplace_back@ABQAVNvStripInfo@@@?$vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@std@@QAE?A_TABQAVNvStripInfo@@@Z PROC ; std::vector<NvStripInfo *,xalloc<NvStripInfo *> >::emplace_back<NvStripInfo * const &>, COMDAT
; _this$ = ecx

; 727  :         // insert by perfectly forwarding into element at end, provide strong guarantee
; 728  :         auto& _My_data   = _Mypair._Myval2;
; 729  :         pointer& _Mylast = _My_data._Mylast;
; 730  :         if (_Mylast != _My_data._Myend) {

	mov	edx, DWORD PTR [ecx+4]
	cmp	edx, DWORD PTR [ecx+8]
	je	SHORT $LN2@emplace_ba

; 713  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

	mov	eax, DWORD PTR _<_Val_0>$[esp-4]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edx], eax

; 714  :         _Orphan_range(_Mylast, _Mylast);
; 715  :         _Ty& _Result = *_Mylast;
; 716  :         ++_Mylast;

	add	DWORD PTR [ecx+4], 4

; 735  : #if _HAS_CXX17
; 736  :         return _Result;
; 737  : #else // ^^^ _HAS_CXX17 ^^^ // vvv !_HAS_CXX17 vvv
; 738  :         (void) _Result;
; 739  : #endif // _HAS_CXX17
; 740  :     }

	ret	4
$LN2@emplace_ba:

; 731  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);
; 732  :         }
; 733  : 
; 734  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	push	DWORD PTR _<_Val_0>$[esp-4]
	push	edx
	call	??$_Emplace_reallocate@ABQAVNvStripInfo@@@?$vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@std@@QAEPAPAVNvStripInfo@@QAPAV2@ABQAV2@@Z ; std::vector<NvStripInfo *,xalloc<NvStripInfo *> >::_Emplace_reallocate<NvStripInfo * const &>

; 735  : #if _HAS_CXX17
; 736  :         return _Result;
; 737  : #else // ^^^ _HAS_CXX17 ^^^ // vvv !_HAS_CXX17 vvv
; 738  :         (void) _Result;
; 739  : #endif // _HAS_CXX17
; 740  :     }

	ret	4
??$emplace_back@ABQAVNvStripInfo@@@?$vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@std@@QAE?A_TABQAVNvStripInfo@@@Z ENDP ; std::vector<NvStripInfo *,xalloc<NvStripInfo *> >::emplace_back<NvStripInfo * const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??$_Emplace_back_with_unused_capacity@ABQAVNvStripInfo@@@?$vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@std@@AAE?A_TABQAVNvStripInfo@@@Z
_TEXT	SEGMENT
_<_Val_0>$ = 8						; size = 4
??$_Emplace_back_with_unused_capacity@ABQAVNvStripInfo@@@?$vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@std@@AAE?A_TABQAVNvStripInfo@@@Z PROC ; std::vector<NvStripInfo *,xalloc<NvStripInfo *> >::_Emplace_back_with_unused_capacity<NvStripInfo * const &>, COMDAT
; _this$ = ecx

; 709  :         // insert by perfectly forwarding into element at end, provide strong guarantee
; 710  :         auto& _My_data   = _Mypair._Myval2;
; 711  :         pointer& _Mylast = _My_data._Mylast;
; 712  :         _STL_INTERNAL_CHECK(_Mylast != _My_data._Myend); // check that we have unused capacity
; 713  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _<_Val_0>$[esp-4]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edx], eax

; 714  :         _Orphan_range(_Mylast, _Mylast);
; 715  :         _Ty& _Result = *_Mylast;
; 716  :         ++_Mylast;

	add	DWORD PTR [ecx+4], 4

; 717  : #if _HAS_CXX17
; 718  :         return _Result;
; 719  : #else // ^^^ _HAS_CXX17 ^^^ // vvv !_HAS_CXX17 vvv
; 720  :         (void) _Result;
; 721  : #endif // _HAS_CXX17
; 722  :     }

	ret	4
??$_Emplace_back_with_unused_capacity@ABQAVNvStripInfo@@@?$vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@std@@AAE?A_TABQAVNvStripInfo@@@Z ENDP ; std::vector<NvStripInfo *,xalloc<NvStripInfo *> >::_Emplace_back_with_unused_capacity<NvStripInfo * const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ??A?$xr_vector@PAVNvEdgeInfo@@V?$xalloc@PAVNvEdgeInfo@@@@@@QAEAAPAVNvEdgeInfo@@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$xr_vector@PAVNvEdgeInfo@@V?$xalloc@PAVNvEdgeInfo@@@@@@QAEAAPAVNvEdgeInfo@@I@Z PROC ; xr_vector<NvEdgeInfo *,xalloc<NvEdgeInfo *> >::operator[], COMDAT
; _this$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 119  :         _Ptr += _Off;

	mov	ecx, DWORD PTR [ecx]
	mov	eax, DWORD PTR __Pos$[esp-4]
	lea	eax, DWORD PTR [ecx+eax*4]
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 138  : 	reference operator[]		(size_type _Pos)					{ {VERIFY(_Pos<size());} return (*(begin() + _Pos)); }

	ret	4
??A?$xr_vector@PAVNvEdgeInfo@@V?$xalloc@PAVNvEdgeInfo@@@@@@QAEAAPAVNvEdgeInfo@@I@Z ENDP ; xr_vector<NvEdgeInfo *,xalloc<NvEdgeInfo *> >::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?size@?$xr_vector@PAVNvEdgeInfo@@V?$xalloc@PAVNvEdgeInfo@@@@@@QBEIXZ
_TEXT	SEGMENT
?size@?$xr_vector@PAVNvEdgeInfo@@V?$xalloc@PAVNvEdgeInfo@@@@@@QBEIXZ PROC ; xr_vector<NvEdgeInfo *,xalloc<NvEdgeInfo *> >::size, COMDAT
; _this$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	eax, DWORD PTR [ecx+4]
	sub	eax, DWORD PTR [ecx]
	sar	eax, 2
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 125  : 	u32		size				() const							{ return (u32)inherited::size();} 

	ret	0
?size@?$xr_vector@PAVNvEdgeInfo@@V?$xalloc@PAVNvEdgeInfo@@@@@@QBEIXZ ENDP ; xr_vector<NvEdgeInfo *,xalloc<NvEdgeInfo *> >::size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ??0?$xr_vector@PAVNvEdgeInfo@@V?$xalloc@PAVNvEdgeInfo@@@@@@QAE@XZ
_TEXT	SEGMENT
??0?$xr_vector@PAVNvEdgeInfo@@V?$xalloc@PAVNvEdgeInfo@@@@@@QAE@XZ PROC ; xr_vector<NvEdgeInfo *,xalloc<NvEdgeInfo *> >::xr_vector<NvEdgeInfo *,xalloc<NvEdgeInfo *> >, COMDAT
; _this$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx], 0
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 122  : 			xr_vector			()									: inherited	()					{}

	mov	eax, ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 122  : 			xr_vector			()									: inherited	()					{}

	ret	0
??0?$xr_vector@PAVNvEdgeInfo@@V?$xalloc@PAVNvEdgeInfo@@@@@@QAE@XZ ENDP ; xr_vector<NvEdgeInfo *,xalloc<NvEdgeInfo *> >::xr_vector<NvEdgeInfo *,xalloc<NvEdgeInfo *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?resize@?$vector@PAVNvEdgeInfo@@V?$xalloc@PAVNvEdgeInfo@@@@@std@@QAEXI@Z
_TEXT	SEGMENT
__Newsize$ = 8						; size = 4
?resize@?$vector@PAVNvEdgeInfo@@V?$xalloc@PAVNvEdgeInfo@@@@@std@@QAEXI@Z PROC ; std::vector<NvEdgeInfo *,xalloc<NvEdgeInfo *> >::resize, COMDAT
; _this$ = ecx

; 1275 :     _CONSTEXPR20_CONTAINER void resize(_CRT_GUARDOVERFLOW const size_type _Newsize) {

	push	ebx
	push	esi

; 1251 :         if (_Newsize < _Oldsize) { // trim

	mov	esi, DWORD PTR __Newsize$[esp+4]

; 1275 :     _CONSTEXPR20_CONTAINER void resize(_CRT_GUARDOVERFLOW const size_type _Newsize) {

	push	edi
	mov	edi, ecx

; 1250 :         const auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);

	mov	ebx, DWORD PTR [edi+4]
	mov	ecx, ebx
	mov	edx, DWORD PTR [edi]
	sub	ecx, edx
	sar	ecx, 2

; 1251 :         if (_Newsize < _Oldsize) { // trim

	cmp	esi, ecx
	jae	SHORT $LN4@resize

; 1252 :             const pointer _Newlast = _Myfirst + _Newsize;

	lea	eax, DWORD PTR [edx+esi*4]

; 1278 :     }

	mov	DWORD PTR [edi+4], eax
	pop	edi
	pop	esi
	pop	ebx
	ret	4
$LN4@resize:

; 1259 :         if (_Newsize > _Oldsize) { // append

	jbe	SHORT $LN5@resize

; 1260 :             const auto _Oldcapacity = static_cast<size_type>(_My_data._Myend - _Myfirst);

	mov	eax, DWORD PTR [edi+8]
	sub	eax, edx
	sar	eax, 2

; 1261 :             if (_Newsize > _Oldcapacity) { // reallocate

	cmp	esi, eax
	jbe	SHORT $LN6@resize

; 1262 :                 _Resize_reallocate(_Newsize, _Val);

	push	ecx
	push	esi
	mov	ecx, edi
	call	??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@PAVNvEdgeInfo@@V?$xalloc@PAVNvEdgeInfo@@@@@std@@AAEXIABU_Value_init_tag@1@@Z ; std::vector<NvEdgeInfo *,xalloc<NvEdgeInfo *> >::_Resize_reallocate<std::_Value_init_tag>
	pop	edi

; 1278 :     }

	pop	esi
	pop	ebx
	ret	4
$LN6@resize:

; 1267 :             _Mylast                = _Ufill(_Oldlast, _Newsize - _Oldsize, _Val);

	sub	esi, ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1807 :             _Zero_range(_PFirst, _PFirst + _Count);

	shl	esi, 2

; 1792 :     _CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

	push	esi
	push	0
	push	ebx
	call	_memset

; 1808 :             return _First + _Count;

	lea	eax, DWORD PTR [esi+ebx]

; 1792 :     _CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

	add	esp, 12					; 0000000cH
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1278 :     }

	mov	DWORD PTR [edi+4], eax
$LN5@resize:
	pop	edi
	pop	esi
	pop	ebx
	ret	4
?resize@?$vector@PAVNvEdgeInfo@@V?$xalloc@PAVNvEdgeInfo@@@@@std@@QAEXI@Z ENDP ; std::vector<NvEdgeInfo *,xalloc<NvEdgeInfo *> >::resize
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??1?$vector@PAVNvEdgeInfo@@V?$xalloc@PAVNvEdgeInfo@@@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@PAVNvEdgeInfo@@V?$xalloc@PAVNvEdgeInfo@@@@@std@@QAE@XZ PROC ; std::vector<NvEdgeInfo *,xalloc<NvEdgeInfo *> >::~vector<NvEdgeInfo *,xalloc<NvEdgeInfo *> >, COMDAT
; _this$ = ecx

; 698  :     _CONSTEXPR20_CONTAINER ~vector() noexcept {

	push	esi
	mov	esi, ecx

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN4@vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+4], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+8], 0
$LN4@vector:
	pop	esi

; 699  :         _Tidy();
; 700  : #if _ITERATOR_DEBUG_LEVEL != 0
; 701  :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 702  :         _Delete_plain_internal(_Alproxy, _STD exchange(_Mypair._Myval2._Myproxy, nullptr));
; 703  : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 704  :     }

	ret	0
??1?$vector@PAVNvEdgeInfo@@V?$xalloc@PAVNvEdgeInfo@@@@@std@@QAE@XZ ENDP ; std::vector<NvEdgeInfo *,xalloc<NvEdgeInfo *> >::~vector<NvEdgeInfo *,xalloc<NvEdgeInfo *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ??A?$xr_vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@@QBEABQAVNvFaceInfo@@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$xr_vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@@QBEABQAVNvFaceInfo@@I@Z PROC ; xr_vector<NvFaceInfo *,xalloc<NvFaceInfo *> >::operator[], COMDAT
; _this$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 119  :         _Ptr += _Off;

	mov	ecx, DWORD PTR [ecx]
	mov	eax, DWORD PTR __Pos$[esp-4]
	lea	eax, DWORD PTR [ecx+eax*4]
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 137  : 	const_reference operator[]	(size_type _Pos) const				{ {VERIFY(_Pos<size());} return (*(begin() + _Pos)); }

	ret	4
??A?$xr_vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@@QBEABQAVNvFaceInfo@@I@Z ENDP ; xr_vector<NvFaceInfo *,xalloc<NvFaceInfo *> >::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?clear@?$xr_vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@@QAEXXZ
_TEXT	SEGMENT
?clear@?$xr_vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@@QAEXXZ PROC ; xr_vector<NvFaceInfo *,xalloc<NvFaceInfo *> >::clear, COMDAT
; _this$ = ecx

; 132  : 	void	clear				()									{ clear_and_free	();			}

	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [ecx+4], eax
	ret	0
?clear@?$xr_vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@@QAEXXZ ENDP ; xr_vector<NvFaceInfo *,xalloc<NvFaceInfo *> >::clear
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?reserve@?$vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@std@@QAEXI@Z
_TEXT	SEGMENT
__Newcapacity$ = 8					; size = 4
?reserve@?$vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@std@@QAEXI@Z PROC ; std::vector<NvFaceInfo *,xalloc<NvFaceInfo *> >::reserve, COMDAT
; _this$ = ecx

; 1546 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx]

; 1357 :         // increase capacity to _Newcapacity (without geometric growth), provide strong guarantee
; 1358 :         if (_Newcapacity > capacity()) { // something to do (reserve() never shrinks)

	mov	edx, DWORD PTR __Newcapacity$[esp-4]

; 1546 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	sar	eax, 2

; 1357 :         // increase capacity to _Newcapacity (without geometric growth), provide strong guarantee
; 1358 :         if (_Newcapacity > capacity()) { // something to do (reserve() never shrinks)

	cmp	edx, eax
	jbe	SHORT $LN2@reserve

; 1359 :             if (_Newcapacity > max_size()) {

	cmp	edx, 1073741823				; 3fffffffH
	ja	SHORT $LN9@reserve

; 1361 :             }
; 1362 : 
; 1363 :             _Reallocate_exactly(_Newcapacity);

	mov	DWORD PTR __Newcapacity$[esp-4], edx
	jmp	?_Reallocate_exactly@?$vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@std@@AAEXI@Z ; std::vector<NvFaceInfo *,xalloc<NvFaceInfo *> >::_Reallocate_exactly
$LN2@reserve:

; 1364 :         }
; 1365 :     }

	ret	4
$LN9@reserve:

; 1360 :                 _Xlength();

	call	?_Xlength@?$vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@std@@CAXXZ ; std::vector<NvFaceInfo *,xalloc<NvFaceInfo *> >::_Xlength
$LN7@reserve:
	int	3
?reserve@?$vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@std@@QAEXI@Z ENDP ; std::vector<NvFaceInfo *,xalloc<NvFaceInfo *> >::reserve
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?push_back@?$vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@std@@QAEXABQAVNvFaceInfo@@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?push_back@?$vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@std@@QAEXABQAVNvFaceInfo@@@Z PROC ; std::vector<NvFaceInfo *,xalloc<NvFaceInfo *> >::push_back, COMDAT
; _this$ = ecx

; 730  :         if (_Mylast != _My_data._Myend) {

	mov	edx, DWORD PTR [ecx+4]
	cmp	edx, DWORD PTR [ecx+8]
	je	SHORT $LN4@push_back

; 713  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

	mov	eax, DWORD PTR __Val$[esp-4]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edx], eax

; 714  :         _Orphan_range(_Mylast, _Mylast);
; 715  :         _Ty& _Result = *_Mylast;
; 716  :         ++_Mylast;

	add	DWORD PTR [ecx+4], 4

; 743  :         emplace_back(_Val);
; 744  :     }

	ret	4
$LN4@push_back:

; 734  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	push	DWORD PTR __Val$[esp-4]
	push	edx
	call	??$_Emplace_reallocate@ABQAVNvFaceInfo@@@?$vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@std@@QAEPAPAVNvFaceInfo@@QAPAV2@ABQAV2@@Z ; std::vector<NvFaceInfo *,xalloc<NvFaceInfo *> >::_Emplace_reallocate<NvFaceInfo * const &>

; 743  :         emplace_back(_Val);
; 744  :     }

	ret	4
?push_back@?$vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@std@@QAEXABQAVNvFaceInfo@@@Z ENDP ; std::vector<NvFaceInfo *,xalloc<NvFaceInfo *> >::push_back
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??$emplace_back@ABQAVNvFaceInfo@@@?$vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@std@@QAE?A_TABQAVNvFaceInfo@@@Z
_TEXT	SEGMENT
_<_Val_0>$ = 8						; size = 4
??$emplace_back@ABQAVNvFaceInfo@@@?$vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@std@@QAE?A_TABQAVNvFaceInfo@@@Z PROC ; std::vector<NvFaceInfo *,xalloc<NvFaceInfo *> >::emplace_back<NvFaceInfo * const &>, COMDAT
; _this$ = ecx

; 727  :         // insert by perfectly forwarding into element at end, provide strong guarantee
; 728  :         auto& _My_data   = _Mypair._Myval2;
; 729  :         pointer& _Mylast = _My_data._Mylast;
; 730  :         if (_Mylast != _My_data._Myend) {

	mov	edx, DWORD PTR [ecx+4]
	cmp	edx, DWORD PTR [ecx+8]
	je	SHORT $LN2@emplace_ba

; 713  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

	mov	eax, DWORD PTR _<_Val_0>$[esp-4]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edx], eax

; 714  :         _Orphan_range(_Mylast, _Mylast);
; 715  :         _Ty& _Result = *_Mylast;
; 716  :         ++_Mylast;

	add	DWORD PTR [ecx+4], 4

; 735  : #if _HAS_CXX17
; 736  :         return _Result;
; 737  : #else // ^^^ _HAS_CXX17 ^^^ // vvv !_HAS_CXX17 vvv
; 738  :         (void) _Result;
; 739  : #endif // _HAS_CXX17
; 740  :     }

	ret	4
$LN2@emplace_ba:

; 731  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);
; 732  :         }
; 733  : 
; 734  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	push	DWORD PTR _<_Val_0>$[esp-4]
	push	edx
	call	??$_Emplace_reallocate@ABQAVNvFaceInfo@@@?$vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@std@@QAEPAPAVNvFaceInfo@@QAPAV2@ABQAV2@@Z ; std::vector<NvFaceInfo *,xalloc<NvFaceInfo *> >::_Emplace_reallocate<NvFaceInfo * const &>

; 735  : #if _HAS_CXX17
; 736  :         return _Result;
; 737  : #else // ^^^ _HAS_CXX17 ^^^ // vvv !_HAS_CXX17 vvv
; 738  :         (void) _Result;
; 739  : #endif // _HAS_CXX17
; 740  :     }

	ret	4
??$emplace_back@ABQAVNvFaceInfo@@@?$vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@std@@QAE?A_TABQAVNvFaceInfo@@@Z ENDP ; std::vector<NvFaceInfo *,xalloc<NvFaceInfo *> >::emplace_back<NvFaceInfo * const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??$_Emplace_back_with_unused_capacity@ABQAVNvFaceInfo@@@?$vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@std@@AAE?A_TABQAVNvFaceInfo@@@Z
_TEXT	SEGMENT
_<_Val_0>$ = 8						; size = 4
??$_Emplace_back_with_unused_capacity@ABQAVNvFaceInfo@@@?$vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@std@@AAE?A_TABQAVNvFaceInfo@@@Z PROC ; std::vector<NvFaceInfo *,xalloc<NvFaceInfo *> >::_Emplace_back_with_unused_capacity<NvFaceInfo * const &>, COMDAT
; _this$ = ecx

; 709  :         // insert by perfectly forwarding into element at end, provide strong guarantee
; 710  :         auto& _My_data   = _Mypair._Myval2;
; 711  :         pointer& _Mylast = _My_data._Mylast;
; 712  :         _STL_INTERNAL_CHECK(_Mylast != _My_data._Myend); // check that we have unused capacity
; 713  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _<_Val_0>$[esp-4]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edx], eax

; 714  :         _Orphan_range(_Mylast, _Mylast);
; 715  :         _Ty& _Result = *_Mylast;
; 716  :         ++_Mylast;

	add	DWORD PTR [ecx+4], 4

; 717  : #if _HAS_CXX17
; 718  :         return _Result;
; 719  : #else // ^^^ _HAS_CXX17 ^^^ // vvv !_HAS_CXX17 vvv
; 720  :         (void) _Result;
; 721  : #endif // _HAS_CXX17
; 722  :     }

	ret	4
??$_Emplace_back_with_unused_capacity@ABQAVNvFaceInfo@@@?$vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@std@@AAE?A_TABQAVNvFaceInfo@@@Z ENDP ; std::vector<NvFaceInfo *,xalloc<NvFaceInfo *> >::_Emplace_back_with_unused_capacity<NvFaceInfo * const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ??A?$xr_vector@GV?$xalloc@G@@@@QBEABGI@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$xr_vector@GV?$xalloc@G@@@@QBEABGI@Z PROC		; xr_vector<unsigned short,xalloc<unsigned short> >::operator[], COMDAT
; _this$dead$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 119  :         _Ptr += _Off;

	mov	ecx, DWORD PTR __Pos$[esp-4]
	mov	eax, DWORD PTR ?scratchIndices@?1??Build@NvStripInfo@@QAEXAAV?$xr_vector@PAVNvEdgeInfo@@V?$xalloc@PAVNvEdgeInfo@@@@@@AAV?$xr_vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@@@Z@4V?$xr_vector@GV?$xalloc@G@@@@A
	lea	eax, DWORD PTR [eax+ecx*2]
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 137  : 	const_reference operator[]	(size_type _Pos) const				{ {VERIFY(_Pos<size());} return (*(begin() + _Pos)); }

	ret	4
??A?$xr_vector@GV?$xalloc@G@@@@QBEABGI@Z ENDP		; xr_vector<unsigned short,xalloc<unsigned short> >::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??4?$vector@GV?$xalloc@G@@@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??4?$vector@GV?$xalloc@G@@@std@@QAEAAV01@ABV01@@Z PROC	; std::vector<unsigned short,xalloc<unsigned short> >::operator=, COMDAT
; _this$ = ecx

; 1202 :         if (this != _STD addressof(_Right)) {

	mov	eax, DWORD PTR __Right$[esp-4]
	push	esi
	mov	esi, ecx
	cmp	esi, eax
	je	SHORT $LN6@operator

; 1187 :         assign(_Right_data._Myfirst, _Right_data._Mylast);

	push	DWORD PTR [eax+4]
	push	DWORD PTR [eax]
	call	??$assign@PAG$0A@@?$vector@GV?$xalloc@G@@@std@@QAEXPAG0@Z ; std::vector<unsigned short,xalloc<unsigned short> >::assign<unsigned short *,0>
$LN6@operator:

; 1203 :             _Copy_assign(_Right, _Choose_pocca<_Alty>{});
; 1204 :         }
; 1205 : 
; 1206 :         return *this;
; 1207 :     }

	mov	eax, esi
	pop	esi
	ret	4
??4?$vector@GV?$xalloc@G@@@std@@QAEAAV01@ABV01@@Z ENDP	; std::vector<unsigned short,xalloc<unsigned short> >::operator=
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?push_back@?$vector@GV?$xalloc@G@@@std@@QAEX$$QAG@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?push_back@?$vector@GV?$xalloc@G@@@std@@QAEX$$QAG@Z PROC ; std::vector<unsigned short,xalloc<unsigned short> >::push_back, COMDAT
; _this$dead$ = ecx

; 730  :         if (_Mylast != _My_data._Myend) {

	mov	ecx, DWORD PTR ?scratchIndices@?1??Build@NvStripInfo@@QAEXAAV?$xr_vector@PAVNvEdgeInfo@@V?$xalloc@PAVNvEdgeInfo@@@@@@AAV?$xr_vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@@@Z@4V?$xr_vector@GV?$xalloc@G@@@@A+4
	cmp	ecx, DWORD PTR ?scratchIndices@?1??Build@NvStripInfo@@QAEXAAV?$xr_vector@PAVNvEdgeInfo@@V?$xalloc@PAVNvEdgeInfo@@@@@@AAV?$xr_vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@@@Z@4V?$xr_vector@GV?$xalloc@G@@@@A+8
	je	SHORT $LN4@push_back

; 713  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

	mov	eax, DWORD PTR __Val$[esp-4]
	mov	ax, WORD PTR [eax]
	mov	WORD PTR [ecx], ax

; 714  :         _Orphan_range(_Mylast, _Mylast);
; 715  :         _Ty& _Result = *_Mylast;
; 716  :         ++_Mylast;

	add	DWORD PTR ?scratchIndices@?1??Build@NvStripInfo@@QAEXAAV?$xr_vector@PAVNvEdgeInfo@@V?$xalloc@PAVNvEdgeInfo@@@@@@AAV?$xr_vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@@@Z@4V?$xr_vector@GV?$xalloc@G@@@@A+4, 2

; 747  :         // insert by moving into element at end, provide strong guarantee
; 748  :         emplace_back(_STD move(_Val));
; 749  :     }

	ret	4
$LN4@push_back:

; 734  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	push	DWORD PTR __Val$[esp-4]
	push	ecx
	call	??$_Emplace_reallocate@G@?$vector@GV?$xalloc@G@@@std@@QAEPAGQAG$$QAG@Z ; std::vector<unsigned short,xalloc<unsigned short> >::_Emplace_reallocate<unsigned short>

; 747  :         // insert by moving into element at end, provide strong guarantee
; 748  :         emplace_back(_STD move(_Val));
; 749  :     }

	ret	4
?push_back@?$vector@GV?$xalloc@G@@@std@@QAEX$$QAG@Z ENDP ; std::vector<unsigned short,xalloc<unsigned short> >::push_back
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??$emplace_back@G@?$vector@GV?$xalloc@G@@@std@@QAE?A_T$$QAG@Z
_TEXT	SEGMENT
_<_Val_0>$ = 8						; size = 4
??$emplace_back@G@?$vector@GV?$xalloc@G@@@std@@QAE?A_T$$QAG@Z PROC ; std::vector<unsigned short,xalloc<unsigned short> >::emplace_back<unsigned short>, COMDAT
; _this$dead$ = ecx

; 727  :         // insert by perfectly forwarding into element at end, provide strong guarantee
; 728  :         auto& _My_data   = _Mypair._Myval2;
; 729  :         pointer& _Mylast = _My_data._Mylast;
; 730  :         if (_Mylast != _My_data._Myend) {

	mov	ecx, DWORD PTR ?scratchIndices@?1??Build@NvStripInfo@@QAEXAAV?$xr_vector@PAVNvEdgeInfo@@V?$xalloc@PAVNvEdgeInfo@@@@@@AAV?$xr_vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@@@Z@4V?$xr_vector@GV?$xalloc@G@@@@A+4
	cmp	ecx, DWORD PTR ?scratchIndices@?1??Build@NvStripInfo@@QAEXAAV?$xr_vector@PAVNvEdgeInfo@@V?$xalloc@PAVNvEdgeInfo@@@@@@AAV?$xr_vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@@@Z@4V?$xr_vector@GV?$xalloc@G@@@@A+8
	je	SHORT $LN2@emplace_ba

; 713  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

	mov	eax, DWORD PTR _<_Val_0>$[esp-4]
	mov	ax, WORD PTR [eax]
	mov	WORD PTR [ecx], ax

; 714  :         _Orphan_range(_Mylast, _Mylast);
; 715  :         _Ty& _Result = *_Mylast;
; 716  :         ++_Mylast;

	add	DWORD PTR ?scratchIndices@?1??Build@NvStripInfo@@QAEXAAV?$xr_vector@PAVNvEdgeInfo@@V?$xalloc@PAVNvEdgeInfo@@@@@@AAV?$xr_vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@@@Z@4V?$xr_vector@GV?$xalloc@G@@@@A+4, 2

; 735  : #if _HAS_CXX17
; 736  :         return _Result;
; 737  : #else // ^^^ _HAS_CXX17 ^^^ // vvv !_HAS_CXX17 vvv
; 738  :         (void) _Result;
; 739  : #endif // _HAS_CXX17
; 740  :     }

	ret	4
$LN2@emplace_ba:

; 731  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);
; 732  :         }
; 733  : 
; 734  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	push	DWORD PTR _<_Val_0>$[esp-4]
	push	ecx
	call	??$_Emplace_reallocate@G@?$vector@GV?$xalloc@G@@@std@@QAEPAGQAG$$QAG@Z ; std::vector<unsigned short,xalloc<unsigned short> >::_Emplace_reallocate<unsigned short>

; 735  : #if _HAS_CXX17
; 736  :         return _Result;
; 737  : #else // ^^^ _HAS_CXX17 ^^^ // vvv !_HAS_CXX17 vvv
; 738  :         (void) _Result;
; 739  : #endif // _HAS_CXX17
; 740  :     }

	ret	4
??$emplace_back@G@?$vector@GV?$xalloc@G@@@std@@QAE?A_T$$QAG@Z ENDP ; std::vector<unsigned short,xalloc<unsigned short> >::emplace_back<unsigned short>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??$_Emplace_back_with_unused_capacity@G@?$vector@GV?$xalloc@G@@@std@@AAE?A_T$$QAG@Z
_TEXT	SEGMENT
_<_Val_0>$ = 8						; size = 4
??$_Emplace_back_with_unused_capacity@G@?$vector@GV?$xalloc@G@@@std@@AAE?A_T$$QAG@Z PROC ; std::vector<unsigned short,xalloc<unsigned short> >::_Emplace_back_with_unused_capacity<unsigned short>, COMDAT
; _this$dead$ = ecx

; 709  :         // insert by perfectly forwarding into element at end, provide strong guarantee
; 710  :         auto& _My_data   = _Mypair._Myval2;
; 711  :         pointer& _Mylast = _My_data._Mylast;
; 712  :         _STL_INTERNAL_CHECK(_Mylast != _My_data._Myend); // check that we have unused capacity
; 713  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

	mov	eax, DWORD PTR _<_Val_0>$[esp-4]
	mov	cx, WORD PTR [eax]
	mov	eax, DWORD PTR ?scratchIndices@?1??Build@NvStripInfo@@QAEXAAV?$xr_vector@PAVNvEdgeInfo@@V?$xalloc@PAVNvEdgeInfo@@@@@@AAV?$xr_vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@@@Z@4V?$xr_vector@GV?$xalloc@G@@@@A+4
	mov	WORD PTR [eax], cx

; 714  :         _Orphan_range(_Mylast, _Mylast);
; 715  :         _Ty& _Result = *_Mylast;
; 716  :         ++_Mylast;

	add	DWORD PTR ?scratchIndices@?1??Build@NvStripInfo@@QAEXAAV?$xr_vector@PAVNvEdgeInfo@@V?$xalloc@PAVNvEdgeInfo@@@@@@AAV?$xr_vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@@@Z@4V?$xr_vector@GV?$xalloc@G@@@@A+4, 2

; 717  : #if _HAS_CXX17
; 718  :         return _Result;
; 719  : #else // ^^^ _HAS_CXX17 ^^^ // vvv !_HAS_CXX17 vvv
; 720  :         (void) _Result;
; 721  : #endif // _HAS_CXX17
; 722  :     }

	ret	4
??$_Emplace_back_with_unused_capacity@G@?$vector@GV?$xalloc@G@@@std@@AAE?A_T$$QAG@Z ENDP ; std::vector<unsigned short,xalloc<unsigned short> >::_Emplace_back_with_unused_capacity<unsigned short>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?push_back@?$vector@HV?$xalloc@H@@@std@@QAEX$$QAH@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?push_back@?$vector@HV?$xalloc@H@@@std@@QAEX$$QAH@Z PROC ; std::vector<int,xalloc<int> >::push_back, COMDAT
; _this$ = ecx

; 730  :         if (_Mylast != _My_data._Myend) {

	mov	edx, DWORD PTR [ecx+4]
	cmp	edx, DWORD PTR [ecx+8]
	je	SHORT $LN4@push_back

; 713  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

	mov	eax, DWORD PTR __Val$[esp-4]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edx], eax

; 714  :         _Orphan_range(_Mylast, _Mylast);
; 715  :         _Ty& _Result = *_Mylast;
; 716  :         ++_Mylast;

	add	DWORD PTR [ecx+4], 4

; 747  :         // insert by moving into element at end, provide strong guarantee
; 748  :         emplace_back(_STD move(_Val));
; 749  :     }

	ret	4
$LN4@push_back:

; 734  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	push	DWORD PTR __Val$[esp-4]
	push	edx
	call	??$_Emplace_reallocate@H@?$vector@HV?$xalloc@H@@@std@@QAEPAHQAH$$QAH@Z ; std::vector<int,xalloc<int> >::_Emplace_reallocate<int>

; 747  :         // insert by moving into element at end, provide strong guarantee
; 748  :         emplace_back(_STD move(_Val));
; 749  :     }

	ret	4
?push_back@?$vector@HV?$xalloc@H@@@std@@QAEX$$QAH@Z ENDP ; std::vector<int,xalloc<int> >::push_back
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??$emplace_back@H@?$vector@HV?$xalloc@H@@@std@@QAE?A_T$$QAH@Z
_TEXT	SEGMENT
_<_Val_0>$ = 8						; size = 4
??$emplace_back@H@?$vector@HV?$xalloc@H@@@std@@QAE?A_T$$QAH@Z PROC ; std::vector<int,xalloc<int> >::emplace_back<int>, COMDAT
; _this$ = ecx

; 727  :         // insert by perfectly forwarding into element at end, provide strong guarantee
; 728  :         auto& _My_data   = _Mypair._Myval2;
; 729  :         pointer& _Mylast = _My_data._Mylast;
; 730  :         if (_Mylast != _My_data._Myend) {

	mov	edx, DWORD PTR [ecx+4]
	cmp	edx, DWORD PTR [ecx+8]
	je	SHORT $LN2@emplace_ba

; 713  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

	mov	eax, DWORD PTR _<_Val_0>$[esp-4]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edx], eax

; 714  :         _Orphan_range(_Mylast, _Mylast);
; 715  :         _Ty& _Result = *_Mylast;
; 716  :         ++_Mylast;

	add	DWORD PTR [ecx+4], 4

; 735  : #if _HAS_CXX17
; 736  :         return _Result;
; 737  : #else // ^^^ _HAS_CXX17 ^^^ // vvv !_HAS_CXX17 vvv
; 738  :         (void) _Result;
; 739  : #endif // _HAS_CXX17
; 740  :     }

	ret	4
$LN2@emplace_ba:

; 731  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);
; 732  :         }
; 733  : 
; 734  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	push	DWORD PTR _<_Val_0>$[esp-4]
	push	edx
	call	??$_Emplace_reallocate@H@?$vector@HV?$xalloc@H@@@std@@QAEPAHQAH$$QAH@Z ; std::vector<int,xalloc<int> >::_Emplace_reallocate<int>

; 735  : #if _HAS_CXX17
; 736  :         return _Result;
; 737  : #else // ^^^ _HAS_CXX17 ^^^ // vvv !_HAS_CXX17 vvv
; 738  :         (void) _Result;
; 739  : #endif // _HAS_CXX17
; 740  :     }

	ret	4
??$emplace_back@H@?$vector@HV?$xalloc@H@@@std@@QAE?A_T$$QAH@Z ENDP ; std::vector<int,xalloc<int> >::emplace_back<int>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??$_Emplace_back_with_unused_capacity@H@?$vector@HV?$xalloc@H@@@std@@AAE?A_T$$QAH@Z
_TEXT	SEGMENT
_<_Val_0>$ = 8						; size = 4
??$_Emplace_back_with_unused_capacity@H@?$vector@HV?$xalloc@H@@@std@@AAE?A_T$$QAH@Z PROC ; std::vector<int,xalloc<int> >::_Emplace_back_with_unused_capacity<int>, COMDAT
; _this$ = ecx

; 709  :         // insert by perfectly forwarding into element at end, provide strong guarantee
; 710  :         auto& _My_data   = _Mypair._Myval2;
; 711  :         pointer& _Mylast = _My_data._Mylast;
; 712  :         _STL_INTERNAL_CHECK(_Mylast != _My_data._Myend); // check that we have unused capacity
; 713  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _<_Val_0>$[esp-4]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edx], eax

; 714  :         _Orphan_range(_Mylast, _Mylast);
; 715  :         _Ty& _Result = *_Mylast;
; 716  :         ++_Mylast;

	add	DWORD PTR [ecx+4], 4

; 717  : #if _HAS_CXX17
; 718  :         return _Result;
; 719  : #else // ^^^ _HAS_CXX17 ^^^ // vvv !_HAS_CXX17 vvv
; 720  :         (void) _Result;
; 721  : #endif // _HAS_CXX17
; 722  :     }

	ret	4
??$_Emplace_back_with_unused_capacity@H@?$vector@HV?$xalloc@H@@@std@@AAE?A_T$$QAH@Z ENDP ; std::vector<int,xalloc<int> >::_Emplace_back_with_unused_capacity<int>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?push_back@?$vector@HV?$xalloc@H@@@std@@QAEXABH@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?push_back@?$vector@HV?$xalloc@H@@@std@@QAEXABH@Z PROC	; std::vector<int,xalloc<int> >::push_back, COMDAT
; _this$ = ecx

; 730  :         if (_Mylast != _My_data._Myend) {

	mov	edx, DWORD PTR [ecx+4]
	cmp	edx, DWORD PTR [ecx+8]
	je	SHORT $LN4@push_back

; 713  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

	mov	eax, DWORD PTR __Val$[esp-4]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edx], eax

; 714  :         _Orphan_range(_Mylast, _Mylast);
; 715  :         _Ty& _Result = *_Mylast;
; 716  :         ++_Mylast;

	add	DWORD PTR [ecx+4], 4

; 743  :         emplace_back(_Val);
; 744  :     }

	ret	4
$LN4@push_back:

; 734  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	push	DWORD PTR __Val$[esp-4]
	push	edx
	call	??$_Emplace_reallocate@ABH@?$vector@HV?$xalloc@H@@@std@@QAEPAHQAHABH@Z ; std::vector<int,xalloc<int> >::_Emplace_reallocate<int const &>

; 743  :         emplace_back(_Val);
; 744  :     }

	ret	4
?push_back@?$vector@HV?$xalloc@H@@@std@@QAEXABH@Z ENDP	; std::vector<int,xalloc<int> >::push_back
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??$emplace_back@ABH@?$vector@HV?$xalloc@H@@@std@@QAE?A_TABH@Z
_TEXT	SEGMENT
_<_Val_0>$ = 8						; size = 4
??$emplace_back@ABH@?$vector@HV?$xalloc@H@@@std@@QAE?A_TABH@Z PROC ; std::vector<int,xalloc<int> >::emplace_back<int const &>, COMDAT
; _this$ = ecx

; 727  :         // insert by perfectly forwarding into element at end, provide strong guarantee
; 728  :         auto& _My_data   = _Mypair._Myval2;
; 729  :         pointer& _Mylast = _My_data._Mylast;
; 730  :         if (_Mylast != _My_data._Myend) {

	mov	edx, DWORD PTR [ecx+4]
	cmp	edx, DWORD PTR [ecx+8]
	je	SHORT $LN2@emplace_ba

; 713  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

	mov	eax, DWORD PTR _<_Val_0>$[esp-4]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edx], eax

; 714  :         _Orphan_range(_Mylast, _Mylast);
; 715  :         _Ty& _Result = *_Mylast;
; 716  :         ++_Mylast;

	add	DWORD PTR [ecx+4], 4

; 735  : #if _HAS_CXX17
; 736  :         return _Result;
; 737  : #else // ^^^ _HAS_CXX17 ^^^ // vvv !_HAS_CXX17 vvv
; 738  :         (void) _Result;
; 739  : #endif // _HAS_CXX17
; 740  :     }

	ret	4
$LN2@emplace_ba:

; 731  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);
; 732  :         }
; 733  : 
; 734  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	push	DWORD PTR _<_Val_0>$[esp-4]
	push	edx
	call	??$_Emplace_reallocate@ABH@?$vector@HV?$xalloc@H@@@std@@QAEPAHQAHABH@Z ; std::vector<int,xalloc<int> >::_Emplace_reallocate<int const &>

; 735  : #if _HAS_CXX17
; 736  :         return _Result;
; 737  : #else // ^^^ _HAS_CXX17 ^^^ // vvv !_HAS_CXX17 vvv
; 738  :         (void) _Result;
; 739  : #endif // _HAS_CXX17
; 740  :     }

	ret	4
??$emplace_back@ABH@?$vector@HV?$xalloc@H@@@std@@QAE?A_TABH@Z ENDP ; std::vector<int,xalloc<int> >::emplace_back<int const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??$_Emplace_back_with_unused_capacity@ABH@?$vector@HV?$xalloc@H@@@std@@AAE?A_TABH@Z
_TEXT	SEGMENT
_<_Val_0>$ = 8						; size = 4
??$_Emplace_back_with_unused_capacity@ABH@?$vector@HV?$xalloc@H@@@std@@AAE?A_TABH@Z PROC ; std::vector<int,xalloc<int> >::_Emplace_back_with_unused_capacity<int const &>, COMDAT
; _this$ = ecx

; 709  :         // insert by perfectly forwarding into element at end, provide strong guarantee
; 710  :         auto& _My_data   = _Mypair._Myval2;
; 711  :         pointer& _Mylast = _My_data._Mylast;
; 712  :         _STL_INTERNAL_CHECK(_Mylast != _My_data._Myend); // check that we have unused capacity
; 713  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _<_Val_0>$[esp-4]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edx], eax

; 714  :         _Orphan_range(_Mylast, _Mylast);
; 715  :         _Ty& _Result = *_Mylast;
; 716  :         ++_Mylast;

	add	DWORD PTR [ecx+4], 4

; 717  : #if _HAS_CXX17
; 718  :         return _Result;
; 719  : #else // ^^^ _HAS_CXX17 ^^^ // vvv !_HAS_CXX17 vvv
; 720  :         (void) _Result;
; 721  : #endif // _HAS_CXX17
; 722  :     }

	ret	4
??$_Emplace_back_with_unused_capacity@ABH@?$vector@HV?$xalloc@H@@@std@@AAE?A_TABH@Z ENDP ; std::vector<int,xalloc<int> >::_Emplace_back_with_unused_capacity<int const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xtree
;	COMDAT ??0?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@PAVNvFaceInfo@@@std@@@std@@@std@@QAE@PAU?$_Tree_node@PAVNvFaceInfo@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@PAVNvFaceInfo@@@std@@@1@@Z
_TEXT	SEGMENT
___param0$ = 8						; size = 4
___param1$dead$ = 12					; size = 4
??0?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@PAVNvFaceInfo@@@std@@@std@@@std@@QAE@PAU?$_Tree_node@PAVNvFaceInfo@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@PAVNvFaceInfo@@@std@@@1@@Z PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<NvFaceInfo *> > >::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<NvFaceInfo *> > >, COMDAT
; _this$ = ecx

; 38   :     _Tree_unchecked_const_iterator(_Nodeptr _Pnode, const _Mytree* _Plist) noexcept : _Ptr(_Pnode) {

	mov	eax, DWORD PTR ___param0$[esp-4]
	mov	DWORD PTR [ecx], eax
	mov	eax, ecx
	ret	8
??0?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@PAVNvFaceInfo@@@std@@@std@@@std@@QAE@PAU?$_Tree_node@PAVNvFaceInfo@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@PAVNvFaceInfo@@@std@@@1@@Z ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<NvFaceInfo *> > >::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<NvFaceInfo *> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??H?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@G@std@@@std@@@std@@QBE?AV01@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??H?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@G@std@@@std@@@std@@QBE?AV01@H@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned short> > >::operator+, COMDAT
; _this$ = ecx

; 119  :         _Ptr += _Off;

	mov	eax, DWORD PTR __Off$[esp-4]
	mov	ecx, DWORD PTR [ecx]
	lea	ecx, DWORD PTR [ecx+eax*2]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 124  :         _Vector_const_iterator _Tmp = *this;
; 125  :         _Tmp += _Off; // TRANSITION, LLVM-49342
; 126  :         return _Tmp;
; 127  :     }

	ret	8
??H?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@G@std@@@std@@@std@@QBE?AV01@H@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned short> > >::operator+
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??H?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVNvFaceInfo@@@std@@@std@@@std@@QBE?AV01@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??H?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVNvFaceInfo@@@std@@@std@@@std@@QBE?AV01@H@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<NvFaceInfo *> > >::operator+, COMDAT
; _this$ = ecx

; 119  :         _Ptr += _Off;

	mov	eax, DWORD PTR __Off$[esp-4]
	mov	ecx, DWORD PTR [ecx]
	lea	ecx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 124  :         _Vector_const_iterator _Tmp = *this;
; 125  :         _Tmp += _Off; // TRANSITION, LLVM-49342
; 126  :         return _Tmp;
; 127  :     }

	ret	8
??H?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVNvFaceInfo@@@std@@@std@@@std@@QBE?AV01@H@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<NvFaceInfo *> > >::operator+
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVNvEdgeInfo@@@std@@@std@@@std@@QBE?AV01@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVNvEdgeInfo@@@std@@@std@@@std@@QBE?AV01@H@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NvEdgeInfo *> > >::operator+, COMDAT
; _this$ = ecx

; 119  :         _Ptr += _Off;

	mov	eax, DWORD PTR __Off$[esp-4]
	mov	ecx, DWORD PTR [ecx]
	lea	ecx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 303  :         _Vector_iterator _Tmp = *this;
; 304  :         _Tmp += _Off; // TRANSITION, LLVM-49342
; 305  :         return _Tmp;
; 306  :     }

	ret	8
??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVNvEdgeInfo@@@std@@@std@@@std@@QBE?AV01@H@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NvEdgeInfo *> > >::operator+
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVNvEdgeInfo@@@std@@@std@@@std@@QBEAAPAVNvEdgeInfo@@XZ
_TEXT	SEGMENT
??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVNvEdgeInfo@@@std@@@std@@@std@@QBEAAPAVNvEdgeInfo@@XZ PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NvEdgeInfo *> > >::operator*, COMDAT
; _this$ = ecx

; 261  :         return const_cast<reference>(_Mybase::operator*());

	mov	eax, DWORD PTR [ecx]

; 262  :     }

	ret	0
??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVNvEdgeInfo@@@std@@@std@@@std@@QBEAAPAVNvEdgeInfo@@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NvEdgeInfo *> > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??H?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVNvStripInfo@@@std@@@std@@@std@@QBE?AV01@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??H?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVNvStripInfo@@@std@@@std@@@std@@QBE?AV01@H@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<NvStripInfo *> > >::operator+, COMDAT
; _this$ = ecx

; 119  :         _Ptr += _Off;

	mov	eax, DWORD PTR __Off$[esp-4]
	mov	ecx, DWORD PTR [ecx]
	lea	ecx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 124  :         _Vector_const_iterator _Tmp = *this;
; 125  :         _Tmp += _Off; // TRANSITION, LLVM-49342
; 126  :         return _Tmp;
; 127  :     }

	ret	8
??H?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVNvStripInfo@@@std@@@std@@@std@@QBE?AV01@H@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<NvStripInfo *> > >::operator+
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@std@@@std@@@std@@QBE?AV01@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@std@@@std@@@std@@QBE?AV01@H@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> > > > >::operator+, COMDAT
; _this$ = ecx

; 119  :         _Ptr += _Off;

	mov	eax, DWORD PTR __Off$[esp-4]
	lea	edx, DWORD PTR [eax+eax*2]
	mov	eax, DWORD PTR [ecx]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 303  :         _Vector_iterator _Tmp = *this;
; 304  :         _Tmp += _Off; // TRANSITION, LLVM-49342
; 305  :         return _Tmp;
; 306  :     }

	ret	8
??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@std@@@std@@@std@@QBE?AV01@H@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> > > > >::operator+
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@std@@@std@@@std@@QBEAAV?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@XZ
_TEXT	SEGMENT
??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@std@@@std@@@std@@QBEAAV?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@XZ PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> > > > >::operator*, COMDAT
; _this$ = ecx

; 261  :         return const_cast<reference>(_Mybase::operator*());

	mov	eax, DWORD PTR [ecx]

; 262  :     }

	ret	0
??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@std@@@std@@@std@@QBEAAV?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> > > > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xtree
;	COMDAT ??8?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@PAVNvFaceInfo@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@PAVNvFaceInfo@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<NvFaceInfo *> > >::operator==, COMDAT
; _this$ = ecx

; 229  : #if _ITERATOR_DEBUG_LEVEL == 2
; 230  :         _STL_VERIFY(this->_Getcont() == _Right._Getcont(), "map/set iterators incompatible");
; 231  : #endif // _ITERATOR_DEBUG_LEVEL == 2
; 232  : 
; 233  :         return this->_Ptr == _Right._Ptr;

	mov	eax, DWORD PTR __Right$[esp-4]
	mov	ecx, DWORD PTR [ecx]
	cmp	ecx, DWORD PTR [eax]
	sete	al

; 234  :     }

	ret	4
??8?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@PAVNvFaceInfo@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<NvFaceInfo *> > >::operator==
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xtree
;	COMDAT ??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@PAVNvFaceInfo@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU?$_Tree_node@PAVNvFaceInfo@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@PAVNvFaceInfo@@@std@@@1@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
__Plist$dead$ = 12					; size = 4
??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@PAVNvFaceInfo@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU?$_Tree_node@PAVNvFaceInfo@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@PAVNvFaceInfo@@@std@@@1@@Z PROC ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<NvFaceInfo *> >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<NvFaceInfo *> >,std::_Iterator_base0>, COMDAT
; _this$ = ecx

; 38   :     _Tree_unchecked_const_iterator(_Nodeptr _Pnode, const _Mytree* _Plist) noexcept : _Ptr(_Pnode) {

	mov	eax, DWORD PTR __Pnode$[esp-4]
	mov	DWORD PTR [ecx], eax

; 39   :         this->_Adopt(_Plist);
; 40   :     }

	mov	eax, ecx
	ret	8
??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@PAVNvFaceInfo@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU?$_Tree_node@PAVNvFaceInfo@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@PAVNvFaceInfo@@@std@@@1@@Z ENDP ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<NvFaceInfo *> >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<NvFaceInfo *> >,std::_Iterator_base0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xtree
;	COMDAT ?_Get_scary@?$_Tree@V?$_Tset_traits@PAVNvFaceInfo@@U?$less@PAVNvFaceInfo@@@std@@V?$xalloc@PAVNvFaceInfo@@@@$0A@@std@@@std@@IAEPAV?$_Tree_val@U?$_Tree_simple_types@PAVNvFaceInfo@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_scary@?$_Tree@V?$_Tset_traits@PAVNvFaceInfo@@U?$less@PAVNvFaceInfo@@@std@@V?$xalloc@PAVNvFaceInfo@@@@$0A@@std@@@std@@IAEPAV?$_Tree_val@U?$_Tree_simple_types@PAVNvFaceInfo@@@std@@@2@XZ PROC ; std::_Tree<std::_Tset_traits<NvFaceInfo *,std::less<NvFaceInfo *>,xalloc<NvFaceInfo *>,0> >::_Get_scary, COMDAT
; _this$ = ecx

; 1943 :         return _STD addressof(_Mypair._Myval2._Myval2);

	mov	eax, ecx

; 1944 :     }

	ret	0
?_Get_scary@?$_Tree@V?$_Tset_traits@PAVNvFaceInfo@@U?$less@PAVNvFaceInfo@@@std@@V?$xalloc@PAVNvFaceInfo@@@@$0A@@std@@@std@@IAEPAV?$_Tree_val@U?$_Tree_simple_types@PAVNvFaceInfo@@@std@@@2@XZ ENDP ; std::_Tree<std::_Tset_traits<NvFaceInfo *,std::less<NvFaceInfo *>,xalloc<NvFaceInfo *>,0> >::_Get_scary
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xtree
;	COMDAT ?_Getal@?$_Tree@V?$_Tset_traits@PAVNvFaceInfo@@U?$less@PAVNvFaceInfo@@@std@@V?$xalloc@PAVNvFaceInfo@@@@$0A@@std@@@std@@IAEAAV?$xalloc@U?$_Tree_node@PAVNvFaceInfo@@PAX@std@@@@XZ
_TEXT	SEGMENT
?_Getal@?$_Tree@V?$_Tset_traits@PAVNvFaceInfo@@U?$less@PAVNvFaceInfo@@@std@@V?$xalloc@PAVNvFaceInfo@@@@$0A@@std@@@std@@IAEAAV?$xalloc@U?$_Tree_node@PAVNvFaceInfo@@PAX@std@@@@XZ PROC ; std::_Tree<std::_Tset_traits<NvFaceInfo *,std::less<NvFaceInfo *>,xalloc<NvFaceInfo *>,0> >::_Getal, COMDAT
; _this$ = ecx

; 1935 :         return _Mypair._Myval2._Get_first();

	mov	eax, ecx

; 1936 :     }

	ret	0
?_Getal@?$_Tree@V?$_Tset_traits@PAVNvFaceInfo@@U?$less@PAVNvFaceInfo@@@std@@V?$xalloc@PAVNvFaceInfo@@@@$0A@@std@@@std@@IAEAAV?$xalloc@U?$_Tree_node@PAVNvFaceInfo@@PAX@std@@@@XZ ENDP ; std::_Tree<std::_Tset_traits<NvFaceInfo *,std::less<NvFaceInfo *>,xalloc<NvFaceInfo *>,0> >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xtree
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xtree
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xtree
;	COMDAT ??0?$_Tree@V?$_Tset_traits@PAVNvFaceInfo@@U?$less@PAVNvFaceInfo@@@std@@V?$xalloc@PAVNvFaceInfo@@@@$0A@@std@@@std@@QAE@ABU?$less@PAVNvFaceInfo@@@1@@Z
_TEXT	SEGMENT
__Parg$dead$ = 8					; size = 4
??0?$_Tree@V?$_Tset_traits@PAVNvFaceInfo@@U?$less@PAVNvFaceInfo@@@std@@V?$xalloc@PAVNvFaceInfo@@@@$0A@@std@@@std@@QAE@ABU?$less@PAVNvFaceInfo@@@1@@Z PROC ; std::_Tree<std::_Tset_traits<NvFaceInfo *,std::less<NvFaceInfo *>,xalloc<NvFaceInfo *>,0> >::_Tree<std::_Tset_traits<NvFaceInfo *,std::less<NvFaceInfo *>,xalloc<NvFaceInfo *>,0> >, COMDAT
; _this$ = ecx

; 883  :     _Tree(const key_compare& _Parg) : _Mypair(_One_then_variadic_args_t{}, _Parg, _Zero_then_variadic_args_t{}) {

	push	esi
	mov	esi, ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	push	20					; 00000014H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xtree

; 435  :     _Tree_val() noexcept : _Myhead(), _Mysize(0) {}

	mov	DWORD PTR [esi], 0
	mov	DWORD PTR [esi+4], 0
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xtree

; 345  :         _Construct_in_place(_Pnode->_Left, _Pnode);

	mov	DWORD PTR [eax], eax

; 346  :         _Construct_in_place(_Pnode->_Parent, _Pnode);

	mov	DWORD PTR [eax+4], eax

; 347  :         _Construct_in_place(_Pnode->_Right, _Pnode);

	mov	DWORD PTR [eax+8], eax

; 348  :         _Pnode->_Color = _Black;

	mov	WORD PTR [eax+12], 257			; 00000101H

; 1917 :         _Scary->_Myhead = _Node::_Buyheadnode(_Getal());

	mov	DWORD PTR [esi], eax

; 884  :         _Alloc_sentinel_and_proxy();
; 885  :     }

	mov	eax, esi
	pop	esi
	ret	4
??0?$_Tree@V?$_Tset_traits@PAVNvFaceInfo@@U?$less@PAVNvFaceInfo@@@std@@V?$xalloc@PAVNvFaceInfo@@@@$0A@@std@@@std@@QAE@ABU?$less@PAVNvFaceInfo@@@1@@Z ENDP ; std::_Tree<std::_Tset_traits<NvFaceInfo *,std::less<NvFaceInfo *>,xalloc<NvFaceInfo *>,0> >::_Tree<std::_Tset_traits<NvFaceInfo *,std::less<NvFaceInfo *>,xalloc<NvFaceInfo *>,0> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?clear_and_free@?$xr_vector@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@V?$xalloc@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@@@@QAEXXZ
_TEXT	SEGMENT
?clear_and_free@?$xr_vector@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@V?$xalloc@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@@@@QAEXXZ PROC ; xr_vector<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> >,xalloc<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> > > >::clear_and_free, COMDAT
; _this$ = ecx

; 127  : 	void	clear_and_free		()									{ inherited::clear();			}

	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [ecx+4], eax
	ret	0
?clear_and_free@?$xr_vector@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@V?$xalloc@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@@@@QAEXXZ ENDP ; xr_vector<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> >,xalloc<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> > > >::clear_and_free
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Tidy@?$vector@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@V?$xalloc@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@@@std@@AAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@V?$xalloc@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@@@std@@AAEXXZ PROC ; std::vector<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> >,xalloc<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> > > >::_Tidy, COMDAT
; _this$ = ecx

; 1742 :     _CONSTEXPR20_CONTAINER void _Tidy() noexcept { // free all storage

	push	esi
	mov	esi, ecx

; 1743 :         auto& _My_data    = _Mypair._Myval2;
; 1744 :         pointer& _Myfirst = _My_data._Myfirst;
; 1745 :         pointer& _Mylast  = _My_data._Mylast;
; 1746 :         pointer& _Myend   = _My_data._Myend;
; 1747 : 
; 1748 :         _My_data._Orphan_all();
; 1749 : 
; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN2@Tidy
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+4], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+8], 0
$LN2@Tidy:

; 1757 :         }
; 1758 :     }

	pop	esi
	ret	0
?_Tidy@?$vector@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@V?$xalloc@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@@@std@@AAEXXZ ENDP ; std::vector<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> >,xalloc<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> > > >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?begin@?$vector@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@V?$xalloc@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@V?$xalloc@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@std@@@std@@@2@XZ PROC ; std::vector<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> >,xalloc<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> > > >::begin, COMDAT
; _this$ = ecx

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	ecx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], ecx

; 1462 :         auto& _My_data = _Mypair._Myval2;
; 1463 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));
; 1464 :     }

	ret	4
?begin@?$vector@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@V?$xalloc@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@std@@@std@@@2@XZ ENDP ; std::vector<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> >,xalloc<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> > > >::begin
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0?$vector@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@V?$xalloc@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@V?$xalloc@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@@@std@@QAE@XZ PROC ; std::vector<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> >,xalloc<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> > > >::vector<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> >,xalloc<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> > > >, COMDAT
; _this$ = ecx

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx], 0

; 464  :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 465  :     }

	mov	eax, ecx

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0

; 464  :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 465  :     }

	ret	0
??0?$vector@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@V?$xalloc@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@@@std@@QAE@XZ ENDP ; std::vector<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> >,xalloc<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> > > >::vector<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> >,xalloc<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?clear_and_free@?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@QAEXXZ
_TEXT	SEGMENT
?clear_and_free@?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@QAEXXZ PROC ; xr_vector<NvStripInfo *,xalloc<NvStripInfo *> >::clear_and_free, COMDAT
; _this$ = ecx

; 127  : 	void	clear_and_free		()									{ inherited::clear();			}

	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [ecx+4], eax
	ret	0
?clear_and_free@?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@QAEXXZ ENDP ; xr_vector<NvStripInfo *,xalloc<NvStripInfo *> >::clear_and_free
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Orphan_range@?$vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@std@@ABEXPAPAVNvStripInfo@@0@Z
_TEXT	SEGMENT
___formal$dead$ = 8					; size = 4
___formal$dead$ = 12					; size = 4
?_Orphan_range@?$vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@std@@ABEXPAPAVNvStripInfo@@0@Z PROC ; std::vector<NvStripInfo *,xalloc<NvStripInfo *> >::_Orphan_range, COMDAT
; _this$dead$ = ecx

; 1801 :     _CONSTEXPR20_CONTAINER void _Orphan_range(pointer, pointer) const {}

	ret	8
?_Orphan_range@?$vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@std@@ABEXPAPAVNvStripInfo@@0@Z ENDP ; std::vector<NvStripInfo *,xalloc<NvStripInfo *> >::_Orphan_range
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?begin@?$vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVNvStripInfo@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVNvStripInfo@@@std@@@std@@@2@XZ PROC ; std::vector<NvStripInfo *,xalloc<NvStripInfo *> >::begin, COMDAT
; _this$ = ecx

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	ecx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], ecx

; 1467 :         auto& _My_data = _Mypair._Myval2;
; 1468 :         return const_iterator(_My_data._Myfirst, _STD addressof(_My_data));
; 1469 :     }

	ret	4
?begin@?$vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVNvStripInfo@@@std@@@std@@@2@XZ ENDP ; std::vector<NvStripInfo *,xalloc<NvStripInfo *> >::begin
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Tidy@?$vector@PAVNvEdgeInfo@@V?$xalloc@PAVNvEdgeInfo@@@@@std@@AAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@PAVNvEdgeInfo@@V?$xalloc@PAVNvEdgeInfo@@@@@std@@AAEXXZ PROC ; std::vector<NvEdgeInfo *,xalloc<NvEdgeInfo *> >::_Tidy, COMDAT
; _this$ = ecx

; 1742 :     _CONSTEXPR20_CONTAINER void _Tidy() noexcept { // free all storage

	push	esi
	mov	esi, ecx

; 1743 :         auto& _My_data    = _Mypair._Myval2;
; 1744 :         pointer& _Myfirst = _My_data._Myfirst;
; 1745 :         pointer& _Mylast  = _My_data._Mylast;
; 1746 :         pointer& _Myend   = _My_data._Myend;
; 1747 : 
; 1748 :         _My_data._Orphan_all();
; 1749 : 
; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN2@Tidy
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+4], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+8], 0
$LN2@Tidy:

; 1757 :         }
; 1758 :     }

	pop	esi
	ret	0
?_Tidy@?$vector@PAVNvEdgeInfo@@V?$xalloc@PAVNvEdgeInfo@@@@@std@@AAEXXZ ENDP ; std::vector<NvEdgeInfo *,xalloc<NvEdgeInfo *> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?size@?$vector@PAVNvEdgeInfo@@V?$xalloc@PAVNvEdgeInfo@@@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@PAVNvEdgeInfo@@V?$xalloc@PAVNvEdgeInfo@@@@@std@@QBEIXZ PROC ; std::vector<NvEdgeInfo *,xalloc<NvEdgeInfo *> >::size, COMDAT
; _this$ = ecx

; 1535 :         auto& _My_data = _Mypair._Myval2;
; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	eax, DWORD PTR [ecx+4]
	sub	eax, DWORD PTR [ecx]
	sar	eax, 2

; 1537 :     }

	ret	0
?size@?$vector@PAVNvEdgeInfo@@V?$xalloc@PAVNvEdgeInfo@@@@@std@@QBEIXZ ENDP ; std::vector<NvEdgeInfo *,xalloc<NvEdgeInfo *> >::size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?begin@?$vector@PAVNvEdgeInfo@@V?$xalloc@PAVNvEdgeInfo@@@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVNvEdgeInfo@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@PAVNvEdgeInfo@@V?$xalloc@PAVNvEdgeInfo@@@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVNvEdgeInfo@@@std@@@std@@@2@XZ PROC ; std::vector<NvEdgeInfo *,xalloc<NvEdgeInfo *> >::begin, COMDAT
; _this$ = ecx

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	ecx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], ecx

; 1462 :         auto& _My_data = _Mypair._Myval2;
; 1463 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));
; 1464 :     }

	ret	4
?begin@?$vector@PAVNvEdgeInfo@@V?$xalloc@PAVNvEdgeInfo@@@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVNvEdgeInfo@@@std@@@std@@@2@XZ ENDP ; std::vector<NvEdgeInfo *,xalloc<NvEdgeInfo *> >::begin
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0?$vector@PAVNvEdgeInfo@@V?$xalloc@PAVNvEdgeInfo@@@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@PAVNvEdgeInfo@@V?$xalloc@PAVNvEdgeInfo@@@@@std@@QAE@XZ PROC ; std::vector<NvEdgeInfo *,xalloc<NvEdgeInfo *> >::vector<NvEdgeInfo *,xalloc<NvEdgeInfo *> >, COMDAT
; _this$ = ecx

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx], 0

; 464  :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 465  :     }

	mov	eax, ecx

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0

; 464  :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 465  :     }

	ret	0
??0?$vector@PAVNvEdgeInfo@@V?$xalloc@PAVNvEdgeInfo@@@@@std@@QAE@XZ ENDP ; std::vector<NvEdgeInfo *,xalloc<NvEdgeInfo *> >::vector<NvEdgeInfo *,xalloc<NvEdgeInfo *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?clear_and_free@?$xr_vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@@QAEXXZ
_TEXT	SEGMENT
?clear_and_free@?$xr_vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@@QAEXXZ PROC ; xr_vector<NvFaceInfo *,xalloc<NvFaceInfo *> >::clear_and_free, COMDAT
; _this$ = ecx

; 127  : 	void	clear_and_free		()									{ inherited::clear();			}

	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [ecx+4], eax
	ret	0
?clear_and_free@?$xr_vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@@QAEXXZ ENDP ; xr_vector<NvFaceInfo *,xalloc<NvFaceInfo *> >::clear_and_free
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Orphan_range@?$vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@std@@ABEXPAPAVNvFaceInfo@@0@Z
_TEXT	SEGMENT
___formal$dead$ = 8					; size = 4
___formal$dead$ = 12					; size = 4
?_Orphan_range@?$vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@std@@ABEXPAPAVNvFaceInfo@@0@Z PROC ; std::vector<NvFaceInfo *,xalloc<NvFaceInfo *> >::_Orphan_range, COMDAT
; _this$dead$ = ecx

; 1801 :     _CONSTEXPR20_CONTAINER void _Orphan_range(pointer, pointer) const {}

	ret	8
?_Orphan_range@?$vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@std@@ABEXPAPAVNvFaceInfo@@0@Z ENDP ; std::vector<NvFaceInfo *,xalloc<NvFaceInfo *> >::_Orphan_range
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Xlength@?$vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@std@@CAXXZ PROC ; std::vector<NvFaceInfo *,xalloc<NvFaceInfo *> >::_Xlength, COMDAT

; 1761 :         _Xlength_error("vector too long");

	push	OFFSET ??_C@_0BA@FOIKENOD@vector?5too?5long@
	call	DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN3@Xlength:
	int	3
?_Xlength@?$vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@std@@CAXXZ ENDP ; std::vector<NvFaceInfo *,xalloc<NvFaceInfo *> >::_Xlength
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?capacity@?$vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@std@@QBEIXZ PROC ; std::vector<NvFaceInfo *,xalloc<NvFaceInfo *> >::capacity, COMDAT
; _this$ = ecx

; 1545 :         auto& _My_data = _Mypair._Myval2;
; 1546 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx]
	sar	eax, 2

; 1547 :     }

	ret	0
?capacity@?$vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@std@@QBEIXZ ENDP ; std::vector<NvFaceInfo *,xalloc<NvFaceInfo *> >::capacity
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?max_size@?$vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@std@@QBEIXZ PROC ; std::vector<NvFaceInfo *,xalloc<NvFaceInfo *> >::max_size, COMDAT
; _this$dead$ = ecx

; 1540 :         return (_STD min)(

	mov	eax, 1073741823				; 3fffffffH

; 1541 :             static_cast<size_type>((numeric_limits<difference_type>::max)()), _Alty_traits::max_size(_Getal()));
; 1542 :     }

	ret	0
?max_size@?$vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@std@@QBEIXZ ENDP ; std::vector<NvFaceInfo *,xalloc<NvFaceInfo *> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?begin@?$vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVNvFaceInfo@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVNvFaceInfo@@@std@@@std@@@2@XZ PROC ; std::vector<NvFaceInfo *,xalloc<NvFaceInfo *> >::begin, COMDAT
; _this$ = ecx

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	ecx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], ecx

; 1467 :         auto& _My_data = _Mypair._Myval2;
; 1468 :         return const_iterator(_My_data._Myfirst, _STD addressof(_My_data));
; 1469 :     }

	ret	4
?begin@?$vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVNvFaceInfo@@@std@@@std@@@2@XZ ENDP ; std::vector<NvFaceInfo *,xalloc<NvFaceInfo *> >::begin
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Reallocate_exactly@?$vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@std@@AAEXI@Z
_TEXT	SEGMENT
__Backout$2 = -40					; size = 12
__Newvec$ = -28						; size = 4
__Size$1$ = -24						; size = 4
__UFirst$3 = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Newcapacity$ = 8					; size = 4
?_Reallocate_exactly@?$vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@std@@AAEXI@Z PROC ; std::vector<NvFaceInfo *,xalloc<NvFaceInfo *> >::_Reallocate_exactly, COMDAT
; _this$ = ecx

; 1286 :     _CONSTEXPR20_CONTAINER void _Reallocate_exactly(const size_type _Newcapacity) {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Reallocate_exactly@?$vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@std@@AAEXI@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 28					; 0000001cH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	esi, ecx

; 1287 :         // set capacity to _Newcapacity (without geometric growth), provide strong guarantee
; 1288 :         auto& _My_data    = _Mypair._Myval2;
; 1289 :         pointer& _Myfirst = _My_data._Myfirst;
; 1290 :         pointer& _Mylast  = _My_data._Mylast;
; 1291 : 
; 1292 :         const auto _Size = static_cast<size_type>(_Mylast - _Myfirst);

	mov	eax, DWORD PTR [esi+4]
	sub	eax, DWORD PTR [esi]
	sar	eax, 2
	mov	DWORD PTR __Size$1$[ebp], eax
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	mov	eax, DWORD PTR __Newcapacity$[ebp]
	shl	eax, 2
	push	eax
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1294 :         const pointer _Newvec = _Getal().allocate(_Newcapacity);

	mov	ebx, eax
	mov	DWORD PTR __Newvec$[ebp], ebx

; 1295 : 
; 1296 :         _TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 1297 :         _Umove_if_noexcept(_Myfirst, _Mylast, _Newvec);

	mov	edi, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1703 :     auto _UFirst      = _Get_unwrapped(_First);

	mov	DWORD PTR __UFirst$3[ebp], ecx

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	DWORD PTR __Backout$2[ebp], ebx
	mov	edx, ebx
	mov	DWORD PTR __Backout$2[ebp+4], edx
	mov	DWORD PTR __Backout$2[ebp+8], esi
$LL19@Reallocate:

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	ecx, edi
	je	SHORT $LN18@Reallocate

; 1620 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax

; 1621 :         ++_Last;

	add	edx, 4
	mov	DWORD PTR __Backout$2[ebp+4], edx

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	add	ecx, 4
	mov	DWORD PTR __UFirst$3[ebp], ecx
	jmp	SHORT $LL19@Reallocate
$LN18@Reallocate:

; 1625 :         _First = _Last;

	mov	DWORD PTR __Backout$2[ebp], edx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
	mov	DWORD PTR __$EHRec$[ebp+12], -1

; 1732 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN33@Reallocate
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	push	eax
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN33@Reallocate:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1737 :         _Myfirst = _Newvec;

	mov	DWORD PTR [esi], ebx

; 1738 :         _Mylast  = _Newvec + _Newsize;

	mov	eax, DWORD PTR __Size$1$[ebp]
	lea	eax, DWORD PTR [ebx+eax*4]
	mov	DWORD PTR [esi+4], eax

; 1739 :         _Myend   = _Newvec + _Newcapacity;

	mov	eax, DWORD PTR __Newcapacity$[ebp]
	lea	eax, DWORD PTR [ebx+eax*4]
	mov	DWORD PTR [esi+8], eax

; 1301 :         _CATCH_END
; 1302 : 
; 1303 :         _Change_array(_Newvec, _Size, _Newcapacity);
; 1304 :     }

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
__catch$?_Reallocate_exactly@?$vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@std@@AAEXI@Z$0:

; 1298 :         _CATCH_ALL
; 1299 :         _Getal().deallocate(_Newvec, _Newcapacity);

	push	ecx
	push	DWORD PTR __Newvec$[ebp]
	call	?deallocate@?$xalloc@PAVNvFaceInfo@@@@QBEXPAPAVNvFaceInfo@@I@Z ; xalloc<NvFaceInfo *>::deallocate

; 1300 :         _RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$LN39@Reallocate:
	int	3
	int	3
	int	3
	int	3
	int	3
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Reallocate_exactly@?$vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@std@@AAEXI@Z:
	npad	1
	npad	1
	mov	eax, OFFSET __ehfuncinfo$?_Reallocate_exactly@?$vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@std@@AAEXI@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Reallocate_exactly@?$vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@std@@AAEXI@Z ENDP ; std::vector<NvFaceInfo *,xalloc<NvFaceInfo *> >::_Reallocate_exactly
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?begin@?$vector@GV?$xalloc@G@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@G@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@GV?$xalloc@G@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@G@std@@@std@@@2@XZ PROC ; std::vector<unsigned short,xalloc<unsigned short> >::begin, COMDAT
; _this$dead$ = ecx

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	ecx, DWORD PTR ?scratchIndices@?1??Build@NvStripInfo@@QAEXAAV?$xr_vector@PAVNvEdgeInfo@@V?$xalloc@PAVNvEdgeInfo@@@@@@AAV?$xr_vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@@@Z@4V?$xr_vector@GV?$xalloc@G@@@@A
	mov	DWORD PTR [eax], ecx

; 1467 :         auto& _My_data = _Mypair._Myval2;
; 1468 :         return const_iterator(_My_data._Myfirst, _STD addressof(_My_data));
; 1469 :     }

	ret	4
?begin@?$vector@GV?$xalloc@G@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@G@std@@@std@@@2@XZ ENDP ; std::vector<unsigned short,xalloc<unsigned short> >::begin
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Copy_assign@?$vector@GV?$xalloc@G@@@std@@AAEXABV12@U?$integral_constant@_N$0A@@2@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
___formal$ = 12						; size = 1
?_Copy_assign@?$vector@GV?$xalloc@G@@@std@@AAEXABV12@U?$integral_constant@_N$0A@@2@@Z PROC ; std::vector<unsigned short,xalloc<unsigned short> >::_Copy_assign, COMDAT
; _this$ = ecx

; 1185 :         _Pocca(_Getal(), _Right._Getal());
; 1186 :         auto& _Right_data = _Right._Mypair._Myval2;
; 1187 :         assign(_Right_data._Myfirst, _Right_data._Mylast);

	mov	eax, DWORD PTR __Right$[esp-4]
	push	DWORD PTR [eax+4]
	push	DWORD PTR [eax]
	call	??$assign@PAG$0A@@?$vector@GV?$xalloc@G@@@std@@QAEXPAG0@Z ; std::vector<unsigned short,xalloc<unsigned short> >::assign<unsigned short *,0>

; 1188 :     }

	ret	8
?_Copy_assign@?$vector@GV?$xalloc@G@@@std@@AAEXABV12@U?$integral_constant@_N$0A@@2@@Z ENDP ; std::vector<unsigned short,xalloc<unsigned short> >::_Copy_assign
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Orphan_range@?$vector@HV?$xalloc@H@@@std@@ABEXPAH0@Z
_TEXT	SEGMENT
___formal$dead$ = 8					; size = 4
___formal$dead$ = 12					; size = 4
?_Orphan_range@?$vector@HV?$xalloc@H@@@std@@ABEXPAH0@Z PROC ; std::vector<int,xalloc<int> >::_Orphan_range, COMDAT
; _this$dead$ = ecx

; 1801 :     _CONSTEXPR20_CONTAINER void _Orphan_range(pointer, pointer) const {}

	ret	8
?_Orphan_range@?$vector@HV?$xalloc@H@@@std@@ABEXPAH0@Z ENDP ; std::vector<int,xalloc<int> >::_Orphan_range
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@std@@@std@@@std@@QAE@PAV?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
___param0$ = 8						; size = 4
___param1$dead$ = 12					; size = 4
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@std@@@std@@@std@@QAE@PAV?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@PBU_Container_base0@1@@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> > > > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> > > > >, COMDAT
; _this$ = ecx

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	eax, DWORD PTR ___param0$[esp-4]
	mov	DWORD PTR [ecx], eax
	mov	eax, ecx
	ret	8
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@std@@@std@@@std@@QAE@PAV?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> > > > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> > > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVNvEdgeInfo@@@std@@@std@@@std@@QAE@PAPAVNvEdgeInfo@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
___param0$ = 8						; size = 4
___param1$dead$ = 12					; size = 4
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVNvEdgeInfo@@@std@@@std@@@std@@QAE@PAPAVNvEdgeInfo@@PBU_Container_base0@1@@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NvEdgeInfo *> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<NvEdgeInfo *> > >, COMDAT
; _this$ = ecx

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	eax, DWORD PTR ___param0$[esp-4]
	mov	DWORD PTR [ecx], eax
	mov	eax, ecx
	ret	8
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVNvEdgeInfo@@@std@@@std@@@std@@QAE@PAPAVNvEdgeInfo@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NvEdgeInfo *> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<NvEdgeInfo *> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVNvEdgeInfo@@@std@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVNvEdgeInfo@@@std@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NvEdgeInfo *> > >::operator+=, COMDAT
; _this$ = ecx

; 119  :         _Ptr += _Off;

	mov	eax, DWORD PTR __Off$[esp-4]
	shl	eax, 2
	add	DWORD PTR [ecx], eax

; 298  :         _Mybase::operator+=(_Off);
; 299  :         return *this;

	mov	eax, ecx

; 300  :     }

	ret	4
??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVNvEdgeInfo@@@std@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NvEdgeInfo *> > >::operator+=
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVNvEdgeInfo@@@std@@@std@@@std@@QBEABQAVNvEdgeInfo@@XZ
_TEXT	SEGMENT
??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVNvEdgeInfo@@@std@@@std@@@std@@QBEABQAVNvEdgeInfo@@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<NvEdgeInfo *> > >::operator*, COMDAT
; _this$ = ecx

; 46   : #if _ITERATOR_DEBUG_LEVEL != 0
; 47   :         const auto _Mycont = static_cast<const _Myvec*>(this->_Getcont());
; 48   :         _STL_VERIFY(_Ptr, "can't dereference value-initialized vector iterator");
; 49   :         _STL_VERIFY(
; 50   :             _Mycont->_Myfirst <= _Ptr && _Ptr < _Mycont->_Mylast, "can't dereference out of range vector iterator");
; 51   : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 52   : 
; 53   :         return *_Ptr;

	mov	eax, DWORD PTR [ecx]

; 54   :     }

	ret	0
??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVNvEdgeInfo@@@std@@@std@@@std@@QBEABQAVNvEdgeInfo@@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<NvEdgeInfo *> > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVNvEdgeInfo@@@std@@@std@@@std@@QAE@PAPAVNvEdgeInfo@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Pvector$dead$ = 12					; size = 4
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVNvEdgeInfo@@@std@@@std@@@std@@QAE@PAPAVNvEdgeInfo@@PBU_Container_base0@1@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<NvEdgeInfo *> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<NvEdgeInfo *> > >, COMDAT
; _this$ = ecx

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	eax, DWORD PTR __Parg$[esp-4]
	mov	DWORD PTR [ecx], eax

; 42   :         this->_Adopt(_Pvector);
; 43   :     }

	mov	eax, ecx
	ret	8
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVNvEdgeInfo@@@std@@@std@@@std@@QAE@PAPAVNvEdgeInfo@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<NvEdgeInfo *> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<NvEdgeInfo *> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@std@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@std@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> > > > >::operator+=, COMDAT
; _this$ = ecx

; 119  :         _Ptr += _Off;

	mov	eax, DWORD PTR __Off$[esp-4]
	lea	eax, DWORD PTR [eax+eax*2]
	shl	eax, 2
	add	DWORD PTR [ecx], eax

; 298  :         _Mybase::operator+=(_Off);
; 299  :         return *this;

	mov	eax, ecx

; 300  :     }

	ret	4
??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@std@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> > > > >::operator+=
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@std@@@std@@@std@@QBEABV?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@XZ
_TEXT	SEGMENT
??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@std@@@std@@@std@@QBEABV?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> > > > >::operator*, COMDAT
; _this$ = ecx

; 46   : #if _ITERATOR_DEBUG_LEVEL != 0
; 47   :         const auto _Mycont = static_cast<const _Myvec*>(this->_Getcont());
; 48   :         _STL_VERIFY(_Ptr, "can't dereference value-initialized vector iterator");
; 49   :         _STL_VERIFY(
; 50   :             _Mycont->_Myfirst <= _Ptr && _Ptr < _Mycont->_Mylast, "can't dereference out of range vector iterator");
; 51   : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 52   : 
; 53   :         return *_Ptr;

	mov	eax, DWORD PTR [ecx]

; 54   :     }

	ret	0
??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@std@@@std@@@std@@QBEABV?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> > > > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@std@@@std@@@std@@QAE@PAV?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Pvector$dead$ = 12					; size = 4
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@std@@@std@@@std@@QAE@PAV?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@PBU_Container_base0@1@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> > > > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> > > > >, COMDAT
; _this$ = ecx

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	eax, DWORD PTR __Parg$[esp-4]
	mov	DWORD PTR [ecx], eax

; 42   :         this->_Adopt(_Pvector);
; 43   :     }

	mov	eax, ecx
	ret	8
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@std@@@std@@@std@@QAE@PAV?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> > > > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> > > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$xalloc@U?$_Tree_node@PAVNvFaceInfo@@PAX@std@@@@V?$_Tree_val@U?$_Tree_simple_types@PAVNvFaceInfo@@@std@@@std@@$00@std@@QAEAAV?$xalloc@U?$_Tree_node@PAVNvFaceInfo@@PAX@std@@@@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@V?$xalloc@U?$_Tree_node@PAVNvFaceInfo@@PAX@std@@@@V?$_Tree_val@U?$_Tree_simple_types@PAVNvFaceInfo@@@std@@@std@@$00@std@@QAEAAV?$xalloc@U?$_Tree_node@PAVNvFaceInfo@@PAX@std@@@@XZ PROC ; std::_Compressed_pair<xalloc<std::_Tree_node<NvFaceInfo *,void *> >,std::_Tree_val<std::_Tree_simple_types<NvFaceInfo *> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 1339 :         return *this;

	mov	eax, ecx

; 1340 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$xalloc@U?$_Tree_node@PAVNvFaceInfo@@PAX@std@@@@V?$_Tree_val@U?$_Tree_simple_types@PAVNvFaceInfo@@@std@@@std@@$00@std@@QAEAAV?$xalloc@U?$_Tree_node@PAVNvFaceInfo@@PAX@std@@@@XZ ENDP ; std::_Compressed_pair<xalloc<std::_Tree_node<NvFaceInfo *,void *> >,std::_Tree_val<std::_Tree_simple_types<NvFaceInfo *> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xtree
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xtree
;	COMDAT ?_Alloc_sentinel_and_proxy@?$_Tree@V?$_Tset_traits@PAVNvFaceInfo@@U?$less@PAVNvFaceInfo@@@std@@V?$xalloc@PAVNvFaceInfo@@@@$0A@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Alloc_sentinel_and_proxy@?$_Tree@V?$_Tset_traits@PAVNvFaceInfo@@U?$less@PAVNvFaceInfo@@@std@@V?$xalloc@PAVNvFaceInfo@@@@$0A@@std@@@std@@IAEXXZ PROC ; std::_Tree<std::_Tset_traits<NvFaceInfo *,std::less<NvFaceInfo *>,xalloc<NvFaceInfo *>,0> >::_Alloc_sentinel_and_proxy, COMDAT
; _this$ = ecx

; 1913 :     void _Alloc_sentinel_and_proxy() {

	push	esi
	mov	esi, ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	20					; 00000014H
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xtree

; 345  :         _Construct_in_place(_Pnode->_Left, _Pnode);

	mov	DWORD PTR [eax], eax

; 346  :         _Construct_in_place(_Pnode->_Parent, _Pnode);

	mov	DWORD PTR [eax+4], eax

; 347  :         _Construct_in_place(_Pnode->_Right, _Pnode);

	mov	DWORD PTR [eax+8], eax

; 348  :         _Pnode->_Color = _Black;

	mov	WORD PTR [eax+12], 257			; 00000101H

; 1914 :         const auto _Scary = _Get_scary();
; 1915 :         auto&& _Alproxy   = _GET_PROXY_ALLOCATOR(_Alnode, _Getal());
; 1916 :         _Container_proxy_ptr<_Alnode> _Proxy(_Alproxy, *_Scary);
; 1917 :         _Scary->_Myhead = _Node::_Buyheadnode(_Getal());

	mov	DWORD PTR [esi], eax
	pop	esi

; 1918 :         _Proxy._Release();
; 1919 :     }

	ret	0
?_Alloc_sentinel_and_proxy@?$_Tree@V?$_Tset_traits@PAVNvFaceInfo@@U?$less@PAVNvFaceInfo@@@std@@V?$xalloc@PAVNvFaceInfo@@@@$0A@@std@@@std@@IAEXXZ ENDP ; std::_Tree<std::_Tset_traits<NvFaceInfo *,std::less<NvFaceInfo *>,xalloc<NvFaceInfo *>,0> >::_Alloc_sentinel_and_proxy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Getal@?$vector@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@V?$xalloc@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@@@std@@AAEAAV?$xalloc@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@@XZ
_TEXT	SEGMENT
?_Getal@?$vector@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@V?$xalloc@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@@@std@@AAEAAV?$xalloc@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@@XZ PROC ; std::vector<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> >,xalloc<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> > > >::_Getal, COMDAT
; _this$ = ecx

; 1805 :         return _Mypair._Get_first();

	mov	eax, ecx

; 1806 :     }

	ret	0
?_Getal@?$vector@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@V?$xalloc@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@@@std@@AAEAAV?$xalloc@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@@XZ ENDP ; std::vector<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> >,xalloc<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> > > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Destroy@?$vector@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@V?$xalloc@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@@@std@@AAEXPAV?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@0@Z
_TEXT	SEGMENT
__First$dead$ = 8					; size = 4
__Last$dead$ = 12					; size = 4
?_Destroy@?$vector@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@V?$xalloc@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@@@std@@AAEXPAV?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@0@Z PROC ; std::vector<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> >,xalloc<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> > > >::_Destroy, COMDAT
; _this$dead$ = ecx

; 1666 :         // destroy [_First, _Last) using allocator
; 1667 :         _Destroy_range(_First, _Last, _Getal());
; 1668 :     }

	ret	8
?_Destroy@?$vector@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@V?$xalloc@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@@@std@@AAEXPAV?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@0@Z ENDP ; std::vector<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> >,xalloc<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> > > >::_Destroy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?clear@?$vector@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@V?$xalloc@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$vector@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@V?$xalloc@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@@@std@@QAEXXZ PROC ; std::vector<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> >,xalloc<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> > > >::clear, COMDAT
; _this$ = ecx

; 1437 :         auto& _My_data    = _Mypair._Myval2;
; 1438 :         pointer& _Myfirst = _My_data._Myfirst;
; 1439 :         pointer& _Mylast  = _My_data._Mylast;
; 1440 : 
; 1441 :         _My_data._Orphan_all();
; 1442 :         _Destroy(_Myfirst, _Mylast);
; 1443 :         _Mylast = _Myfirst;

	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [ecx+4], eax

; 1444 :     }

	ret	0
?clear@?$vector@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@V?$xalloc@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@@@std@@QAEXXZ ENDP ; std::vector<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> >,xalloc<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> > > >::clear
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?deallocate@?$xalloc@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@@QBEXPAV?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@I@Z
_TEXT	SEGMENT
_p$ = 8							; size = 4
_n$dead$ = 12						; size = 4
?deallocate@?$xalloc@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@@QBEXPAV?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@I@Z PROC ; xalloc<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> > >::deallocate, COMDAT
; _this$dead$ = ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	eax, DWORD PTR _p$[esp-4]
	test	eax, eax
	je	SHORT $LN4@deallocate
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN4@deallocate:
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 82   : 							void					deallocate		(pointer p, size_type n) const			{	xr_free	(p);				}

	ret	8
?deallocate@?$xalloc@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@@QBEXPAV?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@I@Z ENDP ; xalloc<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> > >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?clear@?$vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@std@@QAEXXZ PROC ; std::vector<NvStripInfo *,xalloc<NvStripInfo *> >::clear, COMDAT
; _this$ = ecx

; 1437 :         auto& _My_data    = _Mypair._Myval2;
; 1438 :         pointer& _Myfirst = _My_data._Myfirst;
; 1439 :         pointer& _Mylast  = _My_data._Mylast;
; 1440 : 
; 1441 :         _My_data._Orphan_all();
; 1442 :         _Destroy(_Myfirst, _Mylast);
; 1443 :         _Mylast = _Myfirst;

	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [ecx+4], eax

; 1444 :     }

	ret	0
?clear@?$vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@std@@QAEXXZ ENDP ; std::vector<NvStripInfo *,xalloc<NvStripInfo *> >::clear
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Getal@?$vector@PAVNvEdgeInfo@@V?$xalloc@PAVNvEdgeInfo@@@@@std@@AAEAAV?$xalloc@PAVNvEdgeInfo@@@@XZ
_TEXT	SEGMENT
?_Getal@?$vector@PAVNvEdgeInfo@@V?$xalloc@PAVNvEdgeInfo@@@@@std@@AAEAAV?$xalloc@PAVNvEdgeInfo@@@@XZ PROC ; std::vector<NvEdgeInfo *,xalloc<NvEdgeInfo *> >::_Getal, COMDAT
; _this$ = ecx

; 1805 :         return _Mypair._Get_first();

	mov	eax, ecx

; 1806 :     }

	ret	0
?_Getal@?$vector@PAVNvEdgeInfo@@V?$xalloc@PAVNvEdgeInfo@@@@@std@@AAEAAV?$xalloc@PAVNvEdgeInfo@@@@XZ ENDP ; std::vector<NvEdgeInfo *,xalloc<NvEdgeInfo *> >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Destroy@?$vector@PAVNvEdgeInfo@@V?$xalloc@PAVNvEdgeInfo@@@@@std@@AAEXPAPAVNvEdgeInfo@@0@Z
_TEXT	SEGMENT
__First$dead$ = 8					; size = 4
__Last$dead$ = 12					; size = 4
?_Destroy@?$vector@PAVNvEdgeInfo@@V?$xalloc@PAVNvEdgeInfo@@@@@std@@AAEXPAPAVNvEdgeInfo@@0@Z PROC ; std::vector<NvEdgeInfo *,xalloc<NvEdgeInfo *> >::_Destroy, COMDAT
; _this$dead$ = ecx

; 1666 :         // destroy [_First, _Last) using allocator
; 1667 :         _Destroy_range(_First, _Last, _Getal());
; 1668 :     }

	ret	8
?_Destroy@?$vector@PAVNvEdgeInfo@@V?$xalloc@PAVNvEdgeInfo@@@@@std@@AAEXPAPAVNvEdgeInfo@@0@Z ENDP ; std::vector<NvEdgeInfo *,xalloc<NvEdgeInfo *> >::_Destroy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?deallocate@?$xalloc@PAVNvEdgeInfo@@@@QBEXPAPAVNvEdgeInfo@@I@Z
_TEXT	SEGMENT
_p$ = 8							; size = 4
_n$dead$ = 12						; size = 4
?deallocate@?$xalloc@PAVNvEdgeInfo@@@@QBEXPAPAVNvEdgeInfo@@I@Z PROC ; xalloc<NvEdgeInfo *>::deallocate, COMDAT
; _this$dead$ = ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	eax, DWORD PTR _p$[esp-4]
	test	eax, eax
	je	SHORT $LN4@deallocate
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN4@deallocate:
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 82   : 							void					deallocate		(pointer p, size_type n) const			{	xr_free	(p);				}

	ret	8
?deallocate@?$xalloc@PAVNvEdgeInfo@@@@QBEXPAPAVNvEdgeInfo@@I@Z ENDP ; xalloc<NvEdgeInfo *>::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Getal@?$vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@std@@ABEABV?$xalloc@PAVNvFaceInfo@@@@XZ
_TEXT	SEGMENT
?_Getal@?$vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@std@@ABEABV?$xalloc@PAVNvFaceInfo@@@@XZ PROC ; std::vector<NvFaceInfo *,xalloc<NvFaceInfo *> >::_Getal, COMDAT
; _this$ = ecx

; 1809 :         return _Mypair._Get_first();

	mov	eax, ecx

; 1810 :     }

	ret	0
?_Getal@?$vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@std@@ABEABV?$xalloc@PAVNvFaceInfo@@@@XZ ENDP ; std::vector<NvFaceInfo *,xalloc<NvFaceInfo *> >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Change_array@?$vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@std@@AAEXQAPAVNvFaceInfo@@II@Z
_TEXT	SEGMENT
__Newvec$ = 8						; size = 4
__Newsize$ = 12						; size = 4
__Newcapacity$ = 16					; size = 4
?_Change_array@?$vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@std@@AAEXQAPAVNvFaceInfo@@II@Z PROC ; std::vector<NvFaceInfo *,xalloc<NvFaceInfo *> >::_Change_array, COMDAT
; _this$ = ecx

; 1723 :         const pointer _Newvec, const size_type _Newsize, const size_type _Newcapacity) {

	push	esi
	mov	esi, ecx

; 1724 :         // orphan all iterators, discard old array, acquire new array
; 1725 :         auto& _My_data    = _Mypair._Myval2;
; 1726 :         pointer& _Myfirst = _My_data._Myfirst;
; 1727 :         pointer& _Mylast  = _My_data._Mylast;
; 1728 :         pointer& _Myend   = _My_data._Myend;
; 1729 : 
; 1730 :         _My_data._Orphan_all();
; 1731 : 
; 1732 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN7@Change_arr
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN7@Change_arr:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1737 :         _Myfirst = _Newvec;

	mov	ecx, DWORD PTR __Newvec$[esp]

; 1738 :         _Mylast  = _Newvec + _Newsize;

	mov	eax, DWORD PTR __Newsize$[esp]
	mov	DWORD PTR [esi], ecx
	lea	eax, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR [esi+4], eax

; 1739 :         _Myend   = _Newvec + _Newcapacity;

	mov	eax, DWORD PTR __Newcapacity$[esp]
	lea	eax, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR [esi+8], eax
	pop	esi

; 1740 :     }

	ret	12					; 0000000cH
?_Change_array@?$vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@std@@AAEXQAPAVNvFaceInfo@@II@Z ENDP ; std::vector<NvFaceInfo *,xalloc<NvFaceInfo *> >::_Change_array
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Umove_if_noexcept@?$vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@std@@AAEXPAPAVNvFaceInfo@@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
?_Umove_if_noexcept@?$vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@std@@AAEXPAPAVNvFaceInfo@@00@Z PROC ; std::vector<NvFaceInfo *,xalloc<NvFaceInfo *> >::_Umove_if_noexcept, COMDAT
; _this$dead$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1703 :     auto _UFirst      = _Get_unwrapped(_First);

	mov	eax, DWORD PTR __First$[esp-4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1659 :     _CONSTEXPR20_CONTAINER void _Umove_if_noexcept(pointer _First, pointer _Last, pointer _Dest) {

	push	esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	mov	esi, DWORD PTR __Last$[esp]
	cmp	eax, esi
	je	SHORT $LN7@Umove_if_n

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	edx, DWORD PTR __Dest$[esp]
	sub	edx, eax
$LL8@Umove_if_n:

; 1620 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx+eax], ecx

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	add	eax, 4
	cmp	eax, esi
	jne	SHORT $LL8@Umove_if_n
$LN7@Umove_if_n:
	pop	esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1663 :     }

	ret	12					; 0000000cH
?_Umove_if_noexcept@?$vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@std@@AAEXPAPAVNvFaceInfo@@00@Z ENDP ; std::vector<NvFaceInfo *,xalloc<NvFaceInfo *> >::_Umove_if_noexcept
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?clear@?$vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@std@@QAEXXZ PROC ; std::vector<NvFaceInfo *,xalloc<NvFaceInfo *> >::clear, COMDAT
; _this$ = ecx

; 1437 :         auto& _My_data    = _Mypair._Myval2;
; 1438 :         pointer& _Myfirst = _My_data._Myfirst;
; 1439 :         pointer& _Mylast  = _My_data._Mylast;
; 1440 : 
; 1441 :         _My_data._Orphan_all();
; 1442 :         _Destroy(_Myfirst, _Mylast);
; 1443 :         _Mylast = _Myfirst;

	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [ecx+4], eax

; 1444 :     }

	ret	0
?clear@?$vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@std@@QAEXXZ ENDP ; std::vector<NvFaceInfo *,xalloc<NvFaceInfo *> >::clear
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?max_size@?$_Normal_allocator_traits@V?$xalloc@PAVNvFaceInfo@@@@@std@@SAIABV?$xalloc@PAVNvFaceInfo@@@@@Z
_TEXT	SEGMENT
?max_size@?$_Normal_allocator_traits@V?$xalloc@PAVNvFaceInfo@@@@@std@@SAIABV?$xalloc@PAVNvFaceInfo@@@@@Z PROC ; std::_Normal_allocator_traits<xalloc<NvFaceInfo *> >::max_size, COMDAT
; __Al$dead$ = ecx

; 591  :         if constexpr (_Has_max_size<_Alloc>::value) {
; 592  :             return _Al.max_size();

	mov	eax, 1073741823				; 3fffffffH

; 593  :         } else {
; 594  :             return (numeric_limits<size_type>::max)() / sizeof(value_type);
; 595  :         }
; 596  :     }

	ret	0
?max_size@?$_Normal_allocator_traits@V?$xalloc@PAVNvFaceInfo@@@@@std@@SAIABV?$xalloc@PAVNvFaceInfo@@@@@Z ENDP ; std::_Normal_allocator_traits<xalloc<NvFaceInfo *> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?allocate@?$xalloc@PAVNvFaceInfo@@@@QBEPAPAVNvFaceInfo@@IPBX@Z
_TEXT	SEGMENT
_n$ = 8							; size = 4
_p$dead$ = 12						; size = 4
?allocate@?$xalloc@PAVNvFaceInfo@@@@QBEPAPAVNvFaceInfo@@IPBX@Z PROC ; xalloc<NvFaceInfo *>::allocate, COMDAT
; _this$dead$ = ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	mov	eax, DWORD PTR _n$[esp-4]
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	shl	eax, 2
	push	eax
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 80   : 							pointer					allocate		(size_type n, const void* p=0) const	{	return xr_alloc<T>((u32)n);	}

	ret	8
?allocate@?$xalloc@PAVNvFaceInfo@@@@QBEPAPAVNvFaceInfo@@IPBX@Z ENDP ; xalloc<NvFaceInfo *>::allocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVNvEdgeInfo@@@std@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVNvEdgeInfo@@@std@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<NvEdgeInfo *> > >::operator+=, COMDAT
; _this$ = ecx

; 118  :         _Verify_offset(_Off);
; 119  :         _Ptr += _Off;

	mov	eax, DWORD PTR __Off$[esp-4]
	shl	eax, 2
	add	DWORD PTR [ecx], eax

; 120  :         return *this;

	mov	eax, ecx

; 121  :     }

	ret	4
??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVNvEdgeInfo@@@std@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<NvEdgeInfo *> > >::operator+=
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@std@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@std@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> > > > >::operator+=, COMDAT
; _this$ = ecx

; 118  :         _Verify_offset(_Off);
; 119  :         _Ptr += _Off;

	mov	eax, DWORD PTR __Off$[esp-4]
	lea	eax, DWORD PTR [eax+eax*2]
	shl	eax, 2
	add	DWORD PTR [ecx], eax

; 120  :         return *this;

	mov	eax, ecx

; 121  :     }

	ret	4
??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@std@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> > > > >::operator+=
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$xalloc@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@@V?$_Vector_val@U?$_Simple_types@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@std@@@std@@$00@std@@QAEAAV?$xalloc@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@V?$xalloc@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@@V?$_Vector_val@U?$_Simple_types@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@std@@@std@@$00@std@@QAEAAV?$xalloc@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@@XZ PROC ; std::_Compressed_pair<xalloc<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> > >,std::_Vector_val<std::_Simple_types<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> > > >,1>::_Get_first, COMDAT
; _this$ = ecx

; 1339 :         return *this;

	mov	eax, ecx

; 1340 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$xalloc@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@@V?$_Vector_val@U?$_Simple_types@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@std@@@std@@$00@std@@QAEAAV?$xalloc@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@@XZ ENDP ; std::_Compressed_pair<xalloc<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> > >,std::_Vector_val<std::_Simple_types<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> > > >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$xalloc@PAVNvEdgeInfo@@@@V?$_Vector_val@U?$_Simple_types@PAVNvEdgeInfo@@@std@@@std@@$00@std@@QAEAAV?$xalloc@PAVNvEdgeInfo@@@@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@V?$xalloc@PAVNvEdgeInfo@@@@V?$_Vector_val@U?$_Simple_types@PAVNvEdgeInfo@@@std@@@std@@$00@std@@QAEAAV?$xalloc@PAVNvEdgeInfo@@@@XZ PROC ; std::_Compressed_pair<xalloc<NvEdgeInfo *>,std::_Vector_val<std::_Simple_types<NvEdgeInfo *> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 1339 :         return *this;

	mov	eax, ecx

; 1340 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$xalloc@PAVNvEdgeInfo@@@@V?$_Vector_val@U?$_Simple_types@PAVNvEdgeInfo@@@std@@@std@@$00@std@@QAEAAV?$xalloc@PAVNvEdgeInfo@@@@XZ ENDP ; std::_Compressed_pair<xalloc<NvEdgeInfo *>,std::_Vector_val<std::_Simple_types<NvEdgeInfo *> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$xalloc@PAVNvFaceInfo@@@@V?$_Vector_val@U?$_Simple_types@PAVNvFaceInfo@@@std@@@std@@$00@std@@QBEABV?$xalloc@PAVNvFaceInfo@@@@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@V?$xalloc@PAVNvFaceInfo@@@@V?$_Vector_val@U?$_Simple_types@PAVNvFaceInfo@@@std@@@std@@$00@std@@QBEABV?$xalloc@PAVNvFaceInfo@@@@XZ PROC ; std::_Compressed_pair<xalloc<NvFaceInfo *>,std::_Vector_val<std::_Simple_types<NvFaceInfo *> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 1343 :         return *this;

	mov	eax, ecx

; 1344 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$xalloc@PAVNvFaceInfo@@@@V?$_Vector_val@U?$_Simple_types@PAVNvFaceInfo@@@std@@@std@@$00@std@@QBEABV?$xalloc@PAVNvFaceInfo@@@@XZ ENDP ; std::_Compressed_pair<xalloc<NvFaceInfo *>,std::_Vector_val<std::_Simple_types<NvFaceInfo *> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Umove_if_noexcept1@?$vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@std@@AAEXPAPAVNvFaceInfo@@00U?$integral_constant@_N$00@2@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
?_Umove_if_noexcept1@?$vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@std@@AAEXPAPAVNvFaceInfo@@00U?$integral_constant@_N$00@2@@Z PROC ; std::vector<NvFaceInfo *,xalloc<NvFaceInfo *> >::_Umove_if_noexcept1, COMDAT
; _this$dead$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1703 :     auto _UFirst      = _Get_unwrapped(_First);

	mov	eax, DWORD PTR __First$[esp-4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1649 :     _CONSTEXPR20_CONTAINER void _Umove_if_noexcept1(pointer _First, pointer _Last, pointer _Dest, true_type) {

	push	esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	mov	esi, DWORD PTR __Last$[esp]
	cmp	eax, esi
	je	SHORT $LN5@Umove_if_n

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	edx, DWORD PTR __Dest$[esp]
	sub	edx, eax
$LL6@Umove_if_n:

; 1620 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx+eax], ecx

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	add	eax, 4
	cmp	eax, esi
	jne	SHORT $LL6@Umove_if_n
$LN5@Umove_if_n:
	pop	esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1652 :     }

	ret	16					; 00000010H
?_Umove_if_noexcept1@?$vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@std@@AAEXPAPAVNvFaceInfo@@00U?$integral_constant@_N$00@2@@Z ENDP ; std::vector<NvFaceInfo *,xalloc<NvFaceInfo *> >::_Umove_if_noexcept1
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?max_size@?$xalloc@PAVNvFaceInfo@@@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$xalloc@PAVNvFaceInfo@@@@QBEIXZ PROC		; xalloc<NvFaceInfo *>::max_size, COMDAT
; _this$dead$ = ecx

; 86   : 							size_type				max_size		() const								{	size_type _Count = (size_type)(-1) / sizeof (T);	return (0 < _Count ? _Count : 1);	}

	mov	eax, 1073741823				; 3fffffffH
	ret	0
?max_size@?$xalloc@PAVNvFaceInfo@@@@QBEIXZ ENDP		; xalloc<NvFaceInfo *>::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Verify_offset@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVNvEdgeInfo@@@std@@@std@@@std@@QBEXH@Z
_TEXT	SEGMENT
__Off$dead$ = 8						; size = 4
?_Verify_offset@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVNvEdgeInfo@@@std@@@std@@@std@@QBEXH@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<NvEdgeInfo *> > >::_Verify_offset, COMDAT
; _this$dead$ = ecx

; 102  : #if _ITERATOR_DEBUG_LEVEL == 0
; 103  :         (void) _Off;
; 104  : #else // ^^^ _ITERATOR_DEBUG_LEVEL == 0 ^^^ // vvv _ITERATOR_DEBUG_LEVEL != 0 vvv
; 105  :         const auto _Mycont = static_cast<const _Myvec*>(this->_Getcont());
; 106  :         _STL_VERIFY(_Off == 0 || _Ptr, "cannot seek value-initialized vector iterator");
; 107  :         if (_Off < 0) {
; 108  :             _STL_VERIFY(_Off >= _Mycont->_Myfirst - _Ptr, "cannot seek vector iterator before begin");
; 109  :         }
; 110  : 
; 111  :         if (_Off > 0) {
; 112  :             _STL_VERIFY(_Off <= _Mycont->_Mylast - _Ptr, "cannot seek vector iterator after end");
; 113  :         }
; 114  : #endif // _ITERATOR_DEBUG_LEVEL == 0
; 115  :     }

	ret	4
?_Verify_offset@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVNvEdgeInfo@@@std@@@std@@@std@@QBEXH@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<NvEdgeInfo *> > >::_Verify_offset
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Verify_offset@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@std@@@std@@@std@@QBEXH@Z
_TEXT	SEGMENT
__Off$dead$ = 8						; size = 4
?_Verify_offset@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@std@@@std@@@std@@QBEXH@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> > > > >::_Verify_offset, COMDAT
; _this$dead$ = ecx

; 102  : #if _ITERATOR_DEBUG_LEVEL == 0
; 103  :         (void) _Off;
; 104  : #else // ^^^ _ITERATOR_DEBUG_LEVEL == 0 ^^^ // vvv _ITERATOR_DEBUG_LEVEL != 0 vvv
; 105  :         const auto _Mycont = static_cast<const _Myvec*>(this->_Getcont());
; 106  :         _STL_VERIFY(_Off == 0 || _Ptr, "cannot seek value-initialized vector iterator");
; 107  :         if (_Off < 0) {
; 108  :             _STL_VERIFY(_Off >= _Mycont->_Myfirst - _Ptr, "cannot seek vector iterator before begin");
; 109  :         }
; 110  : 
; 111  :         if (_Off > 0) {
; 112  :             _STL_VERIFY(_Off <= _Mycont->_Mylast - _Ptr, "cannot seek vector iterator after end");
; 113  :         }
; 114  : #endif // _ITERATOR_DEBUG_LEVEL == 0
; 115  :     }

	ret	4
?_Verify_offset@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@std@@@std@@@std@@QBEXH@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> > > > >::_Verify_offset
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
;	COMDAT ??$xr_new@VNvFaceInfo@@HHH@@YAPAVNvFaceInfo@@ABH00@Z
_TEXT	SEGMENT
_p3$ = 8						; size = 4
??$xr_new@VNvFaceInfo@@HHH@@YAPAVNvFaceInfo@@ABH00@Z PROC ; xr_new<NvFaceInfo,int,int,int>, COMDAT
; _p1$ = ecx
; _p2$ = edx

; 85   : IC	T*		xr_new		(const P1& p1, const P2& p2, const P3& p3) {

	push	esi
	push	edi
	mov	esi, ecx
	mov	edi, edx

; 86   : 	T* ptr	= (T*)Memory.mem_alloc(sizeof(T));

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	24					; 00000018H
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.h

; 32   : 		m_v0 = v0; m_v1 = v1; m_v2 = v2;

	mov	ecx, DWORD PTR [esi]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR [edi]
	mov	DWORD PTR [eax+4], ecx
	mov	ecx, DWORD PTR _p3$[esp+4]
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h

; 87   : 	return new (ptr) T(p1,p2,p3);

	pop	edi
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.h

; 33   : 		m_stripId      = -1;

	mov	DWORD PTR [eax+12], -1

; 34   : 		m_testStripId  = -1;

	mov	DWORD PTR [eax+16], -1
	mov	ecx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+8], ecx

; 35   : 		m_experimentId = -1;

	mov	DWORD PTR [eax+20], -1
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h

; 87   : 	return new (ptr) T(p1,p2,p3);

	pop	esi

; 88   : }

	ret	0
??$xr_new@VNvFaceInfo@@HHH@@YAPAVNvFaceInfo@@ABH00@Z ENDP ; xr_new<NvFaceInfo,int,int,int>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
;	COMDAT ??$xr_new@VNvEdgeInfo@@HH@@YAPAVNvEdgeInfo@@ABH0@Z
_TEXT	SEGMENT
??$xr_new@VNvEdgeInfo@@HH@@YAPAVNvEdgeInfo@@ABH0@Z PROC	; xr_new<NvEdgeInfo,int,int>, COMDAT
; _p1$ = ecx
; _p2$ = edx

; 79   : IC	T*		xr_new		(const P1& p1, const P2& p2) {

	push	esi
	push	edi
	mov	esi, ecx
	mov	edi, edx

; 80   : 	T* ptr	= (T*)Memory.mem_alloc(sizeof(T));

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	28					; 0000001cH
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.h

; 53   : 		m_v0       = v0;

	mov	ecx, DWORD PTR [esi]
	mov	DWORD PTR [eax+12], ecx

; 54   : 		m_v1       = v1;

	mov	ecx, DWORD PTR [edi]
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h

; 81   : 	return new (ptr) T(p1,p2);

	pop	edi
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.h

; 54   : 		m_v1       = v1;

	mov	DWORD PTR [eax+16], ecx

; 55   : 		m_face0    = NULL;

	mov	DWORD PTR [eax+4], 0

; 56   : 		m_face1    = NULL;

	mov	DWORD PTR [eax+8], 0

; 57   : 		m_nextV0   = NULL;

	mov	DWORD PTR [eax+20], 0

; 58   : 		m_nextV1   = NULL;

	mov	DWORD PTR [eax+24], 0

; 59   : 		
; 60   : 		// we will appear in 2 lists.  this is a good
; 61   : 		// way to make sure we _delete it the second time
; 62   : 		// we hit it in the edge infos
; 63   : 		m_refCount = 2;    

	mov	DWORD PTR [eax], 2
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h

; 81   : 	return new (ptr) T(p1,p2);

	pop	esi

; 82   : }

	ret	0
??$xr_new@VNvEdgeInfo@@HH@@YAPAVNvEdgeInfo@@ABH0@Z ENDP	; xr_new<NvEdgeInfo,int,int>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
;	COMDAT ??$xr_alloc@_N@@YAPA_NI@Z
_TEXT	SEGMENT
??$xr_alloc@_N@@YAPA_NI@Z PROC				; xr_alloc<bool>, COMDAT
; _count$ = ecx

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	push	ecx
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
	ret	0
??$xr_alloc@_N@@YAPA_NI@Z ENDP				; xr_alloc<bool>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\VertexCache.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\VertexCache.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
;	COMDAT ??$xr_new@VVertexCache@@H@@YAPAVVertexCache@@ABH@Z
_TEXT	SEGMENT
$T1 = -4						; size = 4
??$xr_new@VVertexCache@@H@@YAPAVVertexCache@@ABH@Z PROC	; xr_new<VertexCache,int>, COMDAT
; _p1$ = ecx

; 73   : IC	T*		xr_new		(const P1& p1) {

	push	ecx
	push	esi
	push	edi
	mov	esi, ecx

; 74   : 	T* ptr	= (T*)Memory.mem_alloc(sizeof(T));

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	12					; 0000000cH
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z

; 75   : 	return new (ptr) T(p1);

	mov	ecx, DWORD PTR [esi]
	mov	edi, eax
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\VertexCache.cpp

; 12   : 	entries.assign	(size,-1);

	lea	eax, DWORD PTR $T1[esp+12]
	mov	DWORD PTR $T1[esp+12], -1
	push	eax
	push	ecx
	mov	ecx, edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [edi], 0
	mov	DWORD PTR [edi+4], 0
	mov	DWORD PTR [edi+8], 0
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\VertexCache.cpp

; 12   : 	entries.assign	(size,-1);

	call	?assign@?$vector@HV?$xalloc@H@@@std@@QAEXIABH@Z ; std::vector<int,xalloc<int> >::assign
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h

; 75   : 	return new (ptr) T(p1);

	mov	eax, edi
	pop	edi
	pop	esi

; 76   : }

	pop	ecx
	ret	0
??$xr_new@VVertexCache@@H@@YAPAVVertexCache@@ABH@Z ENDP	; xr_new<VertexCache,int>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\VertexCache.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
;	COMDAT ??$xr_delete@VVertexCache@@@@YAXAAPAVVertexCache@@@Z
_TEXT	SEGMENT
??$xr_delete@VVertexCache@@@@YAXAAPAVVertexCache@@@Z PROC ; xr_delete<VertexCache>, COMDAT
; _ptr$ = ecx

; 150  : {

	push	esi
	push	edi
	mov	edi, ecx

; 151  : 	if (ptr) 

	mov	esi, DWORD PTR [edi]
	test	esi, esi
	je	SHORT $LN2@xr_delete
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\VertexCache.cpp

; 18   : 	entries.clear	();

	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [esi+4], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	test	eax, eax
	je	SHORT $LN16@xr_delete
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+4], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+8], 0
	mov	esi, DWORD PTR [edi]
$LN16@xr_delete:
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h

; 144  : 		Memory.mem_free	(ptr);

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	esi
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z

; 152  : 	{
; 153  : 		xr_special_free<is_polymorphic<T>::result,T>()(ptr);
; 154  : 		ptr = nullptr;

	mov	DWORD PTR [edi], 0
$LN2@xr_delete:

; 155  : 	}
; 156  : }

	pop	edi
	pop	esi
	ret	0
??$xr_delete@VVertexCache@@@@YAXAAPAVVertexCache@@@Z ENDP ; xr_delete<VertexCache>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
;	COMDAT ??$xr_free@_N@@YAXAAPA_N@Z
_TEXT	SEGMENT
??$xr_free@_N@@YAXAAPA_N@Z PROC				; xr_free<bool>, COMDAT
; _P$ = ecx

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	push	esi
	mov	esi, ecx
	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN2@xr_free
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
	mov	DWORD PTR [esi], 0
$LN2@xr_free:
	pop	esi
	ret	0
??$xr_free@_N@@YAXAAPA_N@Z ENDP				; xr_free<bool>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.h
;	COMDAT ??$SWAP@H@@YAXAAH0@Z
_TEXT	SEGMENT
??$SWAP@H@@YAXAAH0@Z PROC				; SWAP<int>, COMDAT
; _first$ = ecx
; _second$ = edx

; 112  : 	T temp = first;
; 113  : 	first = second;

	mov	eax, DWORD PTR [edx]
	push	esi
	mov	esi, DWORD PTR [ecx]
	mov	DWORD PTR [ecx], eax

; 114  : 	second = temp;

	mov	DWORD PTR [edx], esi
	pop	esi

; 115  : }

	ret	0
??$SWAP@H@@YAXAAH0@Z ENDP				; SWAP<int>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
;	COMDAT ??$xr_new@VNvStripInfo@@VNvStripStartInfo@@HH@@YAPAVNvStripInfo@@ABVNvStripStartInfo@@ABH1@Z
_TEXT	SEGMENT
_p3$ = 8						; size = 4
??$xr_new@VNvStripInfo@@VNvStripStartInfo@@HH@@YAPAVNvStripInfo@@ABVNvStripStartInfo@@ABH1@Z PROC ; xr_new<NvStripInfo,NvStripStartInfo,int,int>, COMDAT
; _p1$ = ecx
; _p2$ = edx

; 85   : IC	T*		xr_new		(const P1& p1, const P2& p2, const P3& p3) {

	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	ebx, ecx
	mov	edi, edx

; 86   : 	T* ptr	= (T*)Memory.mem_alloc(sizeof(T));

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	36					; 00000024H
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.h

; 123  : 	  m_startInfo(startInfo)

	mov	edx, DWORD PTR [ebx]
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h

; 87   : 	return new (ptr) T(p1,p2,p3);

	mov	ebp, eax
	mov	esi, DWORD PTR _p3$[esp+12]
	mov	eax, DWORD PTR [esi]
	mov	esi, DWORD PTR [edi]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.h

; 123  : 	  m_startInfo(startInfo)

	mov	DWORD PTR [ebp], edx
	mov	ecx, DWORD PTR [ebx+4]
	mov	DWORD PTR [ebp+4], ecx
	mov	ecx, DWORD PTR [ebx+8]
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h

; 87   : 	return new (ptr) T(p1,p2,p3);

	pop	edi
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.h

; 123  : 	  m_startInfo(startInfo)

	mov	DWORD PTR [ebp+8], ecx

; 124  : 	{
; 125  : 		m_stripId      = stripId;

	mov	DWORD PTR [ebp+24], esi

; 126  : 		m_experimentId = experimentId;

	mov	DWORD PTR [ebp+28], eax
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h

; 87   : 	return new (ptr) T(p1,p2,p3);

	mov	eax, ebp
	pop	esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ebp+12], 0
	mov	DWORD PTR [ebp+16], 0
	mov	DWORD PTR [ebp+20], 0
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStripObjects.h

; 127  : 		visited = false;

	mov	BYTE PTR [ebp+32], 0
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h

; 87   : 	return new (ptr) T(p1,p2,p3);

	pop	ebp
	pop	ebx

; 88   : }

	ret	0
??$xr_new@VNvStripInfo@@VNvStripStartInfo@@HH@@YAPAVNvStripInfo@@ABVNvStripStartInfo@@ABH1@Z ENDP ; xr_new<NvStripInfo,NvStripStartInfo,int,int>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xtree
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xtree
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xtree
;	COMDAT ??$insert@$0A@$0A@@?$_Tree@V?$_Tset_traits@PAVNvFaceInfo@@U?$less@PAVNvFaceInfo@@@std@@V?$xalloc@PAVNvFaceInfo@@@@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@PAVNvFaceInfo@@@std@@@std@@@std@@_N@1@ABQAVNvFaceInfo@@@Z
_TEXT	SEGMENT
$T2 = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Loc$3$ = 12						; size = 4
__Val$ = 12						; size = 4
??$insert@$0A@$0A@@?$_Tree@V?$_Tset_traits@PAVNvFaceInfo@@U?$less@PAVNvFaceInfo@@@std@@V?$xalloc@PAVNvFaceInfo@@@@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@PAVNvFaceInfo@@@std@@@std@@@std@@_N@1@ABQAVNvFaceInfo@@@Z PROC ; std::_Tree<std::_Tset_traits<NvFaceInfo *,std::less<NvFaceInfo *>,xalloc<NvFaceInfo *>,0> >::insert<0,0>, COMDAT
; _this$ = ecx

; 1227 :     pair<iterator, bool> insert(const value_type& _Val) {

	sub	esp, 12					; 0000000cH
	push	ebx

; 1006 :             _Loc                = _Find_lower_bound(_Keyval);

	mov	ebx, DWORD PTR __Val$[esp+12]
	lea	eax, DWORD PTR $T2[esp+16]

; 1227 :     pair<iterator, bool> insert(const value_type& _Val) {

	push	ebp
	push	esi
	push	edi

; 1006 :             _Loc                = _Find_lower_bound(_Keyval);

	push	ebx
	push	eax

; 1227 :     pair<iterator, bool> insert(const value_type& _Val) {

	mov	edi, ecx

; 1006 :             _Loc                = _Find_lower_bound(_Keyval);

	call	??$_Find_lower_bound@PAVNvFaceInfo@@@?$_Tree@V?$_Tset_traits@PAVNvFaceInfo@@U?$less@PAVNvFaceInfo@@@std@@V?$xalloc@PAVNvFaceInfo@@@@$0A@@std@@@std@@IBE?AU?$_Tree_find_result@PAU?$_Tree_node@PAVNvFaceInfo@@PAX@std@@@1@ABQAVNvFaceInfo@@@Z ; std::_Tree<std::_Tset_traits<NvFaceInfo *,std::less<NvFaceInfo *>,xalloc<NvFaceInfo *>,0> >::_Find_lower_bound<NvFaceInfo *>
	mov	ecx, DWORD PTR [eax+4]
	mov	ebp, DWORD PTR [eax]
	mov	DWORD PTR __Loc$3$[esp+24], ecx
	mov	ecx, DWORD PTR [eax+8]

; 1591 :         return !_Bound->_Isnil && !_DEBUG_LT_PRED(_Getcomp(), _Keyval, _Traits::_Kfn(_Bound->_Myval));

	cmp	BYTE PTR [ecx+13], 0
	jne	SHORT $LN4@insert
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef

; 117  :         return _Left < _Right;

	mov	eax, DWORD PTR [ebx]
	cmp	eax, DWORD PTR [ecx+16]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xtree

; 1591 :         return !_Bound->_Isnil && !_DEBUG_LT_PRED(_Getcomp(), _Keyval, _Traits::_Kfn(_Bound->_Myval));

	jb	SHORT $LN4@insert
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 186  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

	mov	eax, DWORD PTR ___$ReturnUdt$[esp+24]
	xor	dl, dl
	mov	DWORD PTR [eax], ecx
	mov	BYTE PTR [eax+4], dl
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xtree

; 1230 :     }

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 12					; 0000000cH
	ret	8
$LN4@insert:

; 1615 :         if (max_size() == _Get_scary()->_Mysize) {

	cmp	DWORD PTR [edi+4], 214748364		; 0cccccccH
	je	SHORT $LN61@insert
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xtree

; 1012 :             _Inserted = _Tree_temp_node<_Alnode>(_Getal(), _Scary->_Myhead, _STD forward<_Valtys>(_Vals)...)._Release();

	mov	esi, DWORD PTR [edi]
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	push	20					; 00000014H
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xtree

; 805  :         _Alnode_traits::construct(this->_Al, _STD addressof(this->_Ptr->_Myval), _STD forward<_Valtys>(_Vals)...);

	mov	ecx, DWORD PTR [ebx]

; 1031 :         return {_Scary->_Insert_node(_Loc._Location, _Inserted), true};

	push	eax
	push	DWORD PTR __Loc$3$[esp+28]

; 805  :         _Alnode_traits::construct(this->_Al, _STD addressof(this->_Ptr->_Myval), _STD forward<_Valtys>(_Vals)...);

	mov	DWORD PTR [eax+16], ecx

; 1031 :         return {_Scary->_Insert_node(_Loc._Location, _Inserted), true};

	mov	ecx, edi

; 806  :         _Construct_in_place(this->_Ptr->_Left, _Myhead);

	mov	DWORD PTR [eax], esi

; 807  :         _Construct_in_place(this->_Ptr->_Parent, _Myhead);

	mov	DWORD PTR [eax+4], esi

; 808  :         _Construct_in_place(this->_Ptr->_Right, _Myhead);

	mov	DWORD PTR [eax+8], esi

; 1031 :         return {_Scary->_Insert_node(_Loc._Location, _Inserted), true};

	push	ebp

; 809  :         this->_Ptr->_Color = _Red;

	mov	WORD PTR [eax+12], 0

; 1031 :         return {_Scary->_Insert_node(_Loc._Location, _Inserted), true};

	call	?_Insert_node@?$_Tree_val@U?$_Tree_simple_types@PAVNvFaceInfo@@@std@@@std@@QAEPAU?$_Tree_node@PAVNvFaceInfo@@PAX@2@U?$_Tree_id@PAU?$_Tree_node@PAVNvFaceInfo@@PAX@std@@@2@QAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<NvFaceInfo *> >::_Insert_node

; 1230 :     }

	pop	edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 186  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

	mov	ecx, eax
	mov	dl, 1
	mov	eax, DWORD PTR ___$ReturnUdt$[esp+20]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xtree

; 1230 :     }

	pop	esi
	pop	ebp
	pop	ebx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 186  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

	mov	DWORD PTR [eax], ecx
	mov	BYTE PTR [eax+4], dl
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xtree

; 1230 :     }

	add	esp, 12					; 0000000cH
	ret	8
$LN61@insert:

; 1616 :             _Throw_tree_length_error();

	call	?_Throw_tree_length_error@std@@YAXXZ	; std::_Throw_tree_length_error
$LN59@insert:
	int	3
??$insert@$0A@$0A@@?$_Tree@V?$_Tset_traits@PAVNvFaceInfo@@U?$less@PAVNvFaceInfo@@@std@@V?$xalloc@PAVNvFaceInfo@@@@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@PAVNvFaceInfo@@@std@@@std@@@std@@_N@1@ABQAVNvFaceInfo@@@Z ENDP ; std::_Tree<std::_Tset_traits<NvFaceInfo *,std::less<NvFaceInfo *>,xalloc<NvFaceInfo *>,0> >::insert<0,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xtree
;	COMDAT ??$_Find@PAVNvFaceInfo@@@?$_Tree@V?$_Tset_traits@PAVNvFaceInfo@@U?$less@PAVNvFaceInfo@@@std@@V?$xalloc@PAVNvFaceInfo@@@@$0A@@std@@@std@@ABEPAU?$_Tree_node@PAVNvFaceInfo@@PAX@1@ABQAVNvFaceInfo@@@Z
_TEXT	SEGMENT
__Loc$ = -12						; size = 12
__Keyval$ = 8						; size = 4
??$_Find@PAVNvFaceInfo@@@?$_Tree@V?$_Tset_traits@PAVNvFaceInfo@@U?$less@PAVNvFaceInfo@@@std@@V?$xalloc@PAVNvFaceInfo@@@@$0A@@std@@@std@@ABEPAU?$_Tree_node@PAVNvFaceInfo@@PAX@1@ABQAVNvFaceInfo@@@Z PROC ; std::_Tree<std::_Tset_traits<NvFaceInfo *,std::less<NvFaceInfo *>,xalloc<NvFaceInfo *>,0> >::_Find<NvFaceInfo *>, COMDAT
; _this$ = ecx

; 1352 :     _NODISCARD _Nodeptr _Find(const _Other& _Keyval) const {

	sub	esp, 12					; 0000000cH
	push	esi
	push	edi

; 1353 :         const _Tree_find_result<_Nodeptr> _Loc = _Find_lower_bound(_Keyval);

	mov	edi, DWORD PTR __Keyval$[esp+16]
	lea	eax, DWORD PTR __Loc$[esp+20]
	push	edi
	push	eax
	mov	esi, ecx
	call	??$_Find_lower_bound@PAVNvFaceInfo@@@?$_Tree@V?$_Tset_traits@PAVNvFaceInfo@@U?$less@PAVNvFaceInfo@@@std@@V?$xalloc@PAVNvFaceInfo@@@@$0A@@std@@@std@@IBE?AU?$_Tree_find_result@PAU?$_Tree_node@PAVNvFaceInfo@@PAX@std@@@1@ABQAVNvFaceInfo@@@Z ; std::_Tree<std::_Tset_traits<NvFaceInfo *,std::less<NvFaceInfo *>,xalloc<NvFaceInfo *>,0> >::_Find_lower_bound<NvFaceInfo *>

; 1591 :         return !_Bound->_Isnil && !_DEBUG_LT_PRED(_Getcomp(), _Keyval, _Traits::_Kfn(_Bound->_Myval));

	mov	eax, DWORD PTR __Loc$[esp+28]
	cmp	BYTE PTR [eax+13], 0
	jne	SHORT $LN2@Find
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef

; 117  :         return _Left < _Right;

	mov	ecx, DWORD PTR [edi]
	cmp	ecx, DWORD PTR [eax+16]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xtree

; 1591 :         return !_Bound->_Isnil && !_DEBUG_LT_PRED(_Getcomp(), _Keyval, _Traits::_Kfn(_Bound->_Myval));

	jae	SHORT $LN1@Find
$LN2@Find:

; 1354 :         if (_Lower_bound_duplicate(_Loc._Bound, _Keyval)) {
; 1355 :             return _Loc._Bound;
; 1356 :         }
; 1357 : 
; 1358 :         return _Get_scary()->_Myhead;

	mov	eax, DWORD PTR [esi]
$LN1@Find:
	pop	edi

; 1359 :     }

	pop	esi
	add	esp, 12					; 0000000cH
	ret	4
??$_Find@PAVNvFaceInfo@@@?$_Tree@V?$_Tset_traits@PAVNvFaceInfo@@U?$less@PAVNvFaceInfo@@@std@@V?$xalloc@PAVNvFaceInfo@@@@$0A@@std@@@std@@ABEPAU?$_Tree_node@PAVNvFaceInfo@@PAX@1@ABQAVNvFaceInfo@@@Z ENDP ; std::_Tree<std::_Tset_traits<NvFaceInfo *,std::less<NvFaceInfo *>,xalloc<NvFaceInfo *>,0> >::_Find<NvFaceInfo *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xtree
;	COMDAT ??$_Erase_head@V?$xalloc@U?$_Tree_node@PAVNvFaceInfo@@PAX@std@@@@@?$_Tree_val@U?$_Tree_simple_types@PAVNvFaceInfo@@@std@@@std@@QAEXAAV?$xalloc@U?$_Tree_node@PAVNvFaceInfo@@PAX@std@@@@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
??$_Erase_head@V?$xalloc@U?$_Tree_node@PAVNvFaceInfo@@PAX@std@@@@@?$_Tree_val@U?$_Tree_simple_types@PAVNvFaceInfo@@@std@@@std@@QAEXAAV?$xalloc@U?$_Tree_node@PAVNvFaceInfo@@PAX@std@@@@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<NvFaceInfo *> >::_Erase_head<xalloc<std::_Tree_node<NvFaceInfo *,void *> > >, COMDAT
; _this$ = ecx

; 750  :     void _Erase_head(_Alnode& _Al) noexcept {

	push	esi
	mov	esi, ecx

; 751  :         this->_Orphan_all();
; 752  :         _Erase_tree(_Al, _Myhead->_Parent);

	mov	eax, DWORD PTR [esi]
	push	DWORD PTR [eax+4]
	push	DWORD PTR __Al$[esp+4]
	call	??$_Erase_tree@V?$xalloc@U?$_Tree_node@PAVNvFaceInfo@@PAX@std@@@@@?$_Tree_val@U?$_Tree_simple_types@PAVNvFaceInfo@@@std@@@std@@QAEXAAV?$xalloc@U?$_Tree_node@PAVNvFaceInfo@@PAX@std@@@@PAU?$_Tree_node@PAVNvFaceInfo@@PAX@1@@Z ; std::_Tree_val<std::_Tree_simple_types<NvFaceInfo *> >::_Erase_tree<xalloc<std::_Tree_node<NvFaceInfo *,void *> > >
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 560  :         _Al.deallocate(_Ptr, _Count);

	mov	eax, DWORD PTR [esi]
	pop	esi
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	test	eax, eax
	je	SHORT $LN10@Erase_head
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	mov	DWORD PTR __Al$[esp-4], eax
	jmp	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN10@Erase_head:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xtree

; 754  :     }

	ret	4
??$_Erase_head@V?$xalloc@U?$_Tree_node@PAVNvFaceInfo@@PAX@std@@@@@?$_Tree_val@U?$_Tree_simple_types@PAVNvFaceInfo@@@std@@@std@@QAEXAAV?$xalloc@U?$_Tree_node@PAVNvFaceInfo@@PAX@std@@@@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<NvFaceInfo *> >::_Erase_head<xalloc<std::_Tree_node<NvFaceInfo *,void *> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??$_Resize@U_Value_init_tag@std@@@?$vector@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@V?$xalloc@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@@@std@@AAEXIABU_Value_init_tag@1@@Z
_TEXT	SEGMENT
__Newsize$dead$ = 8					; size = 4
__Val$ = 12						; size = 4
??$_Resize@U_Value_init_tag@std@@@?$vector@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@V?$xalloc@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@@@std@@AAEXIABU_Value_init_tag@1@@Z PROC ; std::vector<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> >,xalloc<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> > > >::_Resize<std::_Value_init_tag>, COMDAT
; _this$ = ecx

; 1245 :     _CONSTEXPR20_CONTAINER void _Resize(const size_type _Newsize, const _Ty2& _Val) {

	mov	edx, ecx
	push	esi

; 1246 :         // trim or append elements, provide strong guarantee
; 1247 :         auto& _My_data      = _Mypair._Myval2;
; 1248 :         pointer& _Myfirst   = _My_data._Myfirst;
; 1249 :         pointer& _Mylast    = _My_data._Mylast;
; 1250 :         const auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);

	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [edx]
	sub	eax, ecx
	sar	eax, 2
	imul	esi, eax, -1431655765

; 1251 :         if (_Newsize < _Oldsize) { // trim

	cmp	esi, 60					; 0000003cH
	jbe	SHORT $LN2@Resize

; 1252 :             const pointer _Newlast = _Myfirst + _Newsize;

	lea	eax, DWORD PTR [ecx+720]

; 1268 :             _Orphan_range(_Oldlast, _Oldlast);
; 1269 :         }
; 1270 : 
; 1271 :         // if _Newsize == _Oldsize, do nothing; avoid invalidating iterators
; 1272 :     }

	mov	DWORD PTR [edx+4], eax
	pop	esi
	ret	8
$LN2@Resize:

; 1253 :             _Orphan_range(_Newlast, _Mylast);
; 1254 :             _Destroy(_Newlast, _Mylast);
; 1255 :             _Mylast = _Newlast;
; 1256 :             return;
; 1257 :         }
; 1258 : 
; 1259 :         if (_Newsize > _Oldsize) { // append

	jae	SHORT $LN3@Resize

; 1260 :             const auto _Oldcapacity = static_cast<size_type>(_My_data._Myend - _Myfirst);

	mov	eax, DWORD PTR [edx+8]
	sub	eax, ecx
	sar	eax, 2
	imul	eax, eax, -1431655765

; 1261 :             if (_Newsize > _Oldcapacity) { // reallocate

	cmp	eax, 60					; 0000003cH
	jae	SHORT $LN4@Resize
	pop	esi

; 1262 :                 _Resize_reallocate(_Newsize, _Val);

	mov	ecx, edx
	jmp	??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@V?$xalloc@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@@@std@@AAEXIABU_Value_init_tag@1@@Z ; std::vector<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> >,xalloc<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> > > >::_Resize_reallocate<std::_Value_init_tag>
$LN4@Resize:

; 1263 :                 return;
; 1264 :             }
; 1265 : 
; 1266 :             const pointer _Oldlast = _Mylast;
; 1267 :             _Mylast                = _Ufill(_Oldlast, _Newsize - _Oldsize, _Val);

	mov	eax, DWORD PTR __Val$[esp]
	movzx	eax, BYTE PTR [eax]
	push	eax
	mov	eax, 60					; 0000003cH
	sub	eax, esi
	push	eax
	push	DWORD PTR [edx+4]
	call	?_Ufill@?$vector@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@V?$xalloc@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@@@std@@AAEPAV?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@PAV3@IU_Value_init_tag@2@@Z ; std::vector<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> >,xalloc<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> > > >::_Ufill

; 1268 :             _Orphan_range(_Oldlast, _Oldlast);
; 1269 :         }
; 1270 : 
; 1271 :         // if _Newsize == _Oldsize, do nothing; avoid invalidating iterators
; 1272 :     }

	mov	DWORD PTR [edx+4], eax
$LN3@Resize:
	pop	esi
	ret	8
??$_Resize@U_Value_init_tag@std@@@?$vector@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@V?$xalloc@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@@@std@@AAEXIABU_Value_init_tag@1@@Z ENDP ; std::vector<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> >,xalloc<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> > > >::_Resize<std::_Value_init_tag>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\type_traits
;	COMDAT ??$forward@ABQAVNvStripInfo@@@std@@YAABQAVNvStripInfo@@ABQAV1@@Z
_TEXT	SEGMENT
??$forward@ABQAVNvStripInfo@@@std@@YAABQAVNvStripInfo@@ABQAV1@@Z PROC ; std::forward<NvStripInfo * const &>, COMDAT
; __Arg$ = ecx

; 1386 :     return static_cast<_Ty&&>(_Arg);

	mov	eax, ecx

; 1387 : }

	ret	0
??$forward@ABQAVNvStripInfo@@@std@@YAABQAVNvStripInfo@@ABQAV1@@Z ENDP ; std::forward<NvStripInfo * const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$construct@PAVNvStripInfo@@ABQAV1@@?$_Normal_allocator_traits@V?$xalloc@PAVNvStripInfo@@@@@std@@SAXAAV?$xalloc@PAVNvStripInfo@@@@PAPAVNvStripInfo@@ABQAV3@@Z
_TEXT	SEGMENT
_<_Args_0>$ = 8						; size = 4
??$construct@PAVNvStripInfo@@ABQAV1@@?$_Normal_allocator_traits@V?$xalloc@PAVNvStripInfo@@@@@std@@SAXAAV?$xalloc@PAVNvStripInfo@@@@PAPAVNvStripInfo@@ABQAV3@@Z PROC ; std::_Normal_allocator_traits<xalloc<NvStripInfo *> >::construct<NvStripInfo *,NvStripInfo * const &>, COMDAT
; __Al$dead$ = ecx
; __Ptr$ = edx

; 565  :         if constexpr (_Uses_default_construct<_Alloc, _Ty*, _Types...>::value) {
; 566  :             (void) _Al; // TRANSITION, DevCom-1004719
; 567  : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 568  :             _STD construct_at(_Ptr, _STD forward<_Types>(_Args)...);
; 569  : #else // __cpp_lib_constexpr_dynamic_alloc
; 570  :             ::new (static_cast<void*>(_Ptr)) _Ty(_STD forward<_Types>(_Args)...);
; 571  : #endif // __cpp_lib_constexpr_dynamic_alloc
; 572  :         } else {
; 573  :             _Al.construct(_Ptr, _STD forward<_Types>(_Args)...);

	mov	eax, DWORD PTR _<_Args_0>$[esp-4]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edx], eax

; 574  :         }
; 575  :     }

	ret	0
??$construct@PAVNvStripInfo@@ABQAV1@@?$_Normal_allocator_traits@V?$xalloc@PAVNvStripInfo@@@@@std@@SAXAAV?$xalloc@PAVNvStripInfo@@@@PAPAVNvStripInfo@@ABQAV3@@Z ENDP ; std::_Normal_allocator_traits<xalloc<NvStripInfo *> >::construct<NvStripInfo *,NvStripInfo * const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??$_Emplace_reallocate@ABQAVNvStripInfo@@@?$vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@std@@QAEPAPAVNvStripInfo@@QAPAV2@ABQAV2@@Z
_TEXT	SEGMENT
__Backout$2 = -76					; size = 12
__Backout$3 = -64					; size = 12
__Backout$4 = -52					; size = 12
__UFirst$5 = -40					; size = 4
__UFirst$6 = -36					; size = 4
__UFirst$7 = -32					; size = 4
__Newvec$ = -28						; size = 4
__Newcapacity$1$ = -24					; size = 4
__Newsize$1$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
tv555 = 8						; size = 4
__Whereptr$ = 8						; size = 4
_<_Val_0>$ = 12						; size = 4
??$_Emplace_reallocate@ABQAVNvStripInfo@@@?$vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@std@@QAEPAPAVNvStripInfo@@QAPAV2@ABQAV2@@Z PROC ; std::vector<NvStripInfo *,xalloc<NvStripInfo *> >::_Emplace_reallocate<NvStripInfo * const &>, COMDAT
; _this$ = ecx

; 752  :     _CONSTEXPR20_CONTAINER pointer _Emplace_reallocate(const pointer _Whereptr, _Valty&&... _Val) {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Emplace_reallocate@ABQAVNvStripInfo@@@?$vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@std@@QAEPAPAVNvStripInfo@@QAPAV2@ABQAV2@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	edi, ecx

; 753  :         // reallocate and insert by perfectly forwarding _Val at _Whereptr
; 754  :         _Alty& _Al        = _Getal();
; 755  :         auto& _My_data    = _Mypair._Myval2;
; 756  :         pointer& _Myfirst = _My_data._Myfirst;
; 757  :         pointer& _Mylast  = _My_data._Mylast;
; 758  : 
; 759  :         _STL_INTERNAL_CHECK(_Mylast == _My_data._Myend); // check that we have no unused capacity
; 760  : 
; 761  :         const auto _Whereoff = static_cast<size_type>(_Whereptr - _Myfirst);

	mov	edx, DWORD PTR [edi]
	mov	esi, DWORD PTR __Whereptr$[ebp]
	mov	ebx, esi
	sub	ebx, edx
	sar	ebx, 2

; 762  :         const auto _Oldsize  = static_cast<size_type>(_Mylast - _Myfirst);

	mov	eax, DWORD PTR [edi+4]
	sub	eax, edx
	sar	eax, 2

; 763  : 
; 764  :         if (_Oldsize == max_size()) {

	cmp	eax, 1073741823				; 3fffffffH
	je	$LN83@Emplace_re

; 766  :         }
; 767  : 
; 768  :         const size_type _Newsize     = _Oldsize + 1;

	inc	eax
	mov	DWORD PTR __Newsize$1$[ebp], eax

; 1546 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	ecx, DWORD PTR [edi+8]
	sub	ecx, edx
	sar	ecx, 2

; 1675 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	edx, ecx
	shr	edx, 1
	mov	eax, 1073741823				; 3fffffffH
	sub	eax, edx
	cmp	ecx, eax
	jbe	SHORT $LN12@Emplace_re

; 1676 :             return _Max; // geometric growth would overflow

	mov	eax, 1073741823				; 3fffffffH
	jmp	SHORT $LN81@Emplace_re
$LN12@Emplace_re:

; 1677 :         }
; 1678 : 
; 1679 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	lea	eax, DWORD PTR [edx+ecx]

; 1680 : 
; 1681 :         if (_Geometric < _Newsize) {

	cmp	eax, DWORD PTR __Newsize$1$[ebp]
	cmovb	eax, DWORD PTR __Newsize$1$[ebp]
$LN81@Emplace_re:
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	mov	DWORD PTR __Newcapacity$1$[ebp], eax
	shl	eax, 2
	push	eax
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 771  :         const pointer _Newvec           = _Al.allocate(_Newcapacity);

	mov	edx, eax
	mov	DWORD PTR __Newvec$[ebp], edx

; 772  :         const pointer _Constructed_last = _Newvec + _Whereoff + 1;
; 773  :         pointer _Constructed_first      = _Constructed_last;
; 774  : 
; 775  :         _TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 776  :         _Alty_traits::construct(_Al, _Unfancy(_Newvec + _Whereoff), _STD forward<_Valty>(_Val)...);

	lea	ecx, DWORD PTR [edx+ebx*4]
	mov	DWORD PTR tv555[ebp], ecx
	mov	eax, DWORD PTR _<_Val_0>$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax

; 777  :         _Constructed_first = _Newvec + _Whereoff;
; 778  : 
; 779  :         if (_Whereptr == _Mylast) { // at back, provide strong guarantee

	mov	ebx, DWORD PTR [edi+4]
	mov	ecx, DWORD PTR [edi]
	cmp	esi, ebx
	jne	SHORT $LN4@Emplace_re
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1703 :     auto _UFirst      = _Get_unwrapped(_First);

	mov	DWORD PTR __UFirst$7[ebp], ecx

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	DWORD PTR __Backout$4[ebp], edx
	mov	DWORD PTR __Backout$4[ebp+4], edx
	mov	DWORD PTR __Backout$4[ebp+8], edi
	npad	1
$LL28@Emplace_re:

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	ecx, ebx
	je	SHORT $LN27@Emplace_re

; 1620 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax

; 1621 :         ++_Last;

	add	edx, 4
	mov	DWORD PTR __Backout$4[ebp+4], edx

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	add	ecx, 4
	mov	DWORD PTR __UFirst$7[ebp], ecx
	jmp	SHORT $LL28@Emplace_re
$LN27@Emplace_re:

; 1625 :         _First = _Last;

	mov	DWORD PTR __Backout$4[ebp], edx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 781  :         } else { // provide basic guarantee

	mov	ebx, DWORD PTR tv555[ebp]
	jmp	SHORT $LN5@Emplace_re
$LN4@Emplace_re:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1703 :     auto _UFirst      = _Get_unwrapped(_First);

	mov	DWORD PTR __UFirst$6[ebp], ecx

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	DWORD PTR __Backout$3[ebp], edx
	mov	DWORD PTR __Backout$3[ebp+4], edx
	mov	DWORD PTR __Backout$3[ebp+8], edi
	npad	6
$LL41@Emplace_re:

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	ecx, esi
	je	SHORT $LN40@Emplace_re

; 1620 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax

; 1621 :         ++_Last;

	add	edx, 4
	mov	DWORD PTR __Backout$3[ebp+4], edx

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	add	ecx, 4
	mov	DWORD PTR __UFirst$6[ebp], ecx
	jmp	SHORT $LL41@Emplace_re
$LN40@Emplace_re:

; 1625 :         _First = _Last;

	mov	DWORD PTR __Backout$3[ebp], edx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 784  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

	mov	ebx, DWORD PTR tv555[ebp]
	lea	ecx, DWORD PTR [ebx+4]

; 1646 :         return _Uninitialized_move(_First, _Last, _Dest, _Getal());

	mov	edx, DWORD PTR [edi+4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1703 :     auto _UFirst      = _Get_unwrapped(_First);

	mov	DWORD PTR __UFirst$5[ebp], esi

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	DWORD PTR __Backout$2[ebp], ecx
	mov	DWORD PTR __Backout$2[ebp+4], ecx
	mov	DWORD PTR __Backout$2[ebp+8], edi
	npad	2
$LL54@Emplace_re:

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	esi, edx
	je	SHORT $LN53@Emplace_re

; 1620 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [ecx], eax

; 1621 :         ++_Last;

	add	ecx, 4
	mov	DWORD PTR __Backout$2[ebp+4], ecx

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	add	esi, 4
	mov	DWORD PTR __UFirst$5[ebp], esi
	jmp	SHORT $LL54@Emplace_re
$LN53@Emplace_re:

; 1625 :         _First = _Last;

	mov	DWORD PTR __Backout$2[ebp], ecx
$LN5@Emplace_re:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
	mov	DWORD PTR __$EHRec$[ebp+12], -1

; 1732 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [edi]
	test	eax, eax
	je	SHORT $LN68@Emplace_re
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	push	eax
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN68@Emplace_re:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1737 :         _Myfirst = _Newvec;

	mov	eax, DWORD PTR __Newvec$[ebp]
	mov	DWORD PTR [edi], eax

; 1738 :         _Mylast  = _Newvec + _Newsize;

	mov	ecx, DWORD PTR __Newsize$1$[ebp]
	lea	ecx, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR [edi+4], ecx

; 1739 :         _Myend   = _Newvec + _Newcapacity;

	mov	ecx, DWORD PTR __Newcapacity$1$[ebp]
	lea	ecx, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR [edi+8], ecx

; 790  :         _CATCH_END
; 791  : 
; 792  :         _Change_array(_Newvec, _Newsize, _Newcapacity);
; 793  :         return _Newvec + _Whereoff;

	mov	eax, ebx

; 794  :     }

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
__catch$??$_Emplace_reallocate@ABQAVNvStripInfo@@@?$vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@std@@QAEPAPAVNvStripInfo@@QAPAV2@ABQAV2@@Z$0:

; 785  :         }
; 786  :         _CATCH_ALL
; 787  :         _Destroy(_Constructed_first, _Constructed_last);
; 788  :         _Al.deallocate(_Newvec, _Newcapacity);

	push	ecx
	push	DWORD PTR __Newvec$[ebp]
	call	?deallocate@?$xalloc@PAVNvStripInfo@@@@QBEXPAPAVNvStripInfo@@I@Z ; xalloc<NvStripInfo *>::deallocate

; 789  :         _RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$LN83@Emplace_re:

; 765  :             _Xlength();

	call	?_Xlength@?$vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@std@@CAXXZ ; std::vector<NvStripInfo *,xalloc<NvStripInfo *> >::_Xlength
$LN80@Emplace_re:
	int	3
	int	3
	int	3
	int	3
	int	3
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Emplace_reallocate@ABQAVNvStripInfo@@@?$vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@std@@QAEPAPAVNvStripInfo@@QAPAV2@ABQAV2@@Z:
	npad	1
	npad	1
	mov	eax, OFFSET __ehfuncinfo$??$_Emplace_reallocate@ABQAVNvStripInfo@@@?$vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@std@@QAEPAPAVNvStripInfo@@QAPAV2@ABQAV2@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Emplace_reallocate@ABQAVNvStripInfo@@@?$vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@std@@QAEPAPAVNvStripInfo@@QAPAV2@ABQAV2@@Z ENDP ; std::vector<NvStripInfo *,xalloc<NvStripInfo *> >::_Emplace_reallocate<NvStripInfo * const &>
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??$_Resize@U_Value_init_tag@std@@@?$vector@PAVNvEdgeInfo@@V?$xalloc@PAVNvEdgeInfo@@@@@std@@AAEXIABU_Value_init_tag@1@@Z
_TEXT	SEGMENT
__Newsize$ = 8						; size = 4
__Val$dead$ = 12					; size = 4
??$_Resize@U_Value_init_tag@std@@@?$vector@PAVNvEdgeInfo@@V?$xalloc@PAVNvEdgeInfo@@@@@std@@AAEXIABU_Value_init_tag@1@@Z PROC ; std::vector<NvEdgeInfo *,xalloc<NvEdgeInfo *> >::_Resize<std::_Value_init_tag>, COMDAT
; _this$ = ecx

; 1245 :     _CONSTEXPR20_CONTAINER void _Resize(const size_type _Newsize, const _Ty2& _Val) {

	push	ebx
	push	esi

; 1246 :         // trim or append elements, provide strong guarantee
; 1247 :         auto& _My_data      = _Mypair._Myval2;
; 1248 :         pointer& _Myfirst   = _My_data._Myfirst;
; 1249 :         pointer& _Mylast    = _My_data._Mylast;
; 1250 :         const auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);
; 1251 :         if (_Newsize < _Oldsize) { // trim

	mov	esi, DWORD PTR __Newsize$[esp+4]
	push	edi
	mov	edi, ecx
	mov	ebx, DWORD PTR [edi+4]
	mov	ecx, ebx
	mov	edx, DWORD PTR [edi]
	sub	ecx, edx
	sar	ecx, 2
	cmp	esi, ecx
	jae	SHORT $LN2@Resize

; 1252 :             const pointer _Newlast = _Myfirst + _Newsize;

	lea	eax, DWORD PTR [edx+esi*4]

; 1272 :     }

	mov	DWORD PTR [edi+4], eax
	pop	edi
	pop	esi
	pop	ebx
	ret	8
$LN2@Resize:

; 1253 :             _Orphan_range(_Newlast, _Mylast);
; 1254 :             _Destroy(_Newlast, _Mylast);
; 1255 :             _Mylast = _Newlast;
; 1256 :             return;
; 1257 :         }
; 1258 : 
; 1259 :         if (_Newsize > _Oldsize) { // append

	jbe	SHORT $LN3@Resize

; 1260 :             const auto _Oldcapacity = static_cast<size_type>(_My_data._Myend - _Myfirst);

	mov	eax, DWORD PTR [edi+8]
	sub	eax, edx
	sar	eax, 2

; 1261 :             if (_Newsize > _Oldcapacity) { // reallocate

	cmp	esi, eax
	jbe	SHORT $LN4@Resize

; 1262 :                 _Resize_reallocate(_Newsize, _Val);

	push	ecx
	push	esi
	mov	ecx, edi
	call	??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@PAVNvEdgeInfo@@V?$xalloc@PAVNvEdgeInfo@@@@@std@@AAEXIABU_Value_init_tag@1@@Z ; std::vector<NvEdgeInfo *,xalloc<NvEdgeInfo *> >::_Resize_reallocate<std::_Value_init_tag>
	pop	edi

; 1272 :     }

	pop	esi
	pop	ebx
	ret	8
$LN4@Resize:

; 1263 :                 return;
; 1264 :             }
; 1265 : 
; 1266 :             const pointer _Oldlast = _Mylast;
; 1267 :             _Mylast                = _Ufill(_Oldlast, _Newsize - _Oldsize, _Val);

	sub	esi, ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1807 :             _Zero_range(_PFirst, _PFirst + _Count);

	shl	esi, 2

; 1792 :     _CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

	push	esi
	push	0
	push	ebx
	call	_memset

; 1808 :             return _First + _Count;

	lea	eax, DWORD PTR [esi+ebx]

; 1792 :     _CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

	add	esp, 12					; 0000000cH
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1272 :     }

	mov	DWORD PTR [edi+4], eax
$LN3@Resize:
	pop	edi
	pop	esi
	pop	ebx
	ret	8
??$_Resize@U_Value_init_tag@std@@@?$vector@PAVNvEdgeInfo@@V?$xalloc@PAVNvEdgeInfo@@@@@std@@AAEXIABU_Value_init_tag@1@@Z ENDP ; std::vector<NvEdgeInfo *,xalloc<NvEdgeInfo *> >::_Resize<std::_Value_init_tag>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\type_traits
;	COMDAT ??$forward@ABQAVNvFaceInfo@@@std@@YAABQAVNvFaceInfo@@ABQAV1@@Z
_TEXT	SEGMENT
??$forward@ABQAVNvFaceInfo@@@std@@YAABQAVNvFaceInfo@@ABQAV1@@Z PROC ; std::forward<NvFaceInfo * const &>, COMDAT
; __Arg$ = ecx

; 1386 :     return static_cast<_Ty&&>(_Arg);

	mov	eax, ecx

; 1387 : }

	ret	0
??$forward@ABQAVNvFaceInfo@@@std@@YAABQAVNvFaceInfo@@ABQAV1@@Z ENDP ; std::forward<NvFaceInfo * const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$construct@PAVNvFaceInfo@@ABQAV1@@?$_Normal_allocator_traits@V?$xalloc@PAVNvFaceInfo@@@@@std@@SAXAAV?$xalloc@PAVNvFaceInfo@@@@PAPAVNvFaceInfo@@ABQAV3@@Z
_TEXT	SEGMENT
_<_Args_0>$ = 8						; size = 4
??$construct@PAVNvFaceInfo@@ABQAV1@@?$_Normal_allocator_traits@V?$xalloc@PAVNvFaceInfo@@@@@std@@SAXAAV?$xalloc@PAVNvFaceInfo@@@@PAPAVNvFaceInfo@@ABQAV3@@Z PROC ; std::_Normal_allocator_traits<xalloc<NvFaceInfo *> >::construct<NvFaceInfo *,NvFaceInfo * const &>, COMDAT
; __Al$dead$ = ecx
; __Ptr$ = edx

; 565  :         if constexpr (_Uses_default_construct<_Alloc, _Ty*, _Types...>::value) {
; 566  :             (void) _Al; // TRANSITION, DevCom-1004719
; 567  : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 568  :             _STD construct_at(_Ptr, _STD forward<_Types>(_Args)...);
; 569  : #else // __cpp_lib_constexpr_dynamic_alloc
; 570  :             ::new (static_cast<void*>(_Ptr)) _Ty(_STD forward<_Types>(_Args)...);
; 571  : #endif // __cpp_lib_constexpr_dynamic_alloc
; 572  :         } else {
; 573  :             _Al.construct(_Ptr, _STD forward<_Types>(_Args)...);

	mov	eax, DWORD PTR _<_Args_0>$[esp-4]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edx], eax

; 574  :         }
; 575  :     }

	ret	0
??$construct@PAVNvFaceInfo@@ABQAV1@@?$_Normal_allocator_traits@V?$xalloc@PAVNvFaceInfo@@@@@std@@SAXAAV?$xalloc@PAVNvFaceInfo@@@@PAPAVNvFaceInfo@@ABQAV3@@Z ENDP ; std::_Normal_allocator_traits<xalloc<NvFaceInfo *> >::construct<NvFaceInfo *,NvFaceInfo * const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??$_Emplace_reallocate@ABQAVNvFaceInfo@@@?$vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@std@@QAEPAPAVNvFaceInfo@@QAPAV2@ABQAV2@@Z
_TEXT	SEGMENT
__Backout$2 = -76					; size = 12
__Backout$3 = -64					; size = 12
__Backout$4 = -52					; size = 12
__UFirst$5 = -40					; size = 4
__UFirst$6 = -36					; size = 4
__UFirst$7 = -32					; size = 4
__Newvec$ = -28						; size = 4
__Newcapacity$1$ = -24					; size = 4
__Newsize$1$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
tv555 = 8						; size = 4
__Whereptr$ = 8						; size = 4
_<_Val_0>$ = 12						; size = 4
??$_Emplace_reallocate@ABQAVNvFaceInfo@@@?$vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@std@@QAEPAPAVNvFaceInfo@@QAPAV2@ABQAV2@@Z PROC ; std::vector<NvFaceInfo *,xalloc<NvFaceInfo *> >::_Emplace_reallocate<NvFaceInfo * const &>, COMDAT
; _this$ = ecx

; 752  :     _CONSTEXPR20_CONTAINER pointer _Emplace_reallocate(const pointer _Whereptr, _Valty&&... _Val) {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Emplace_reallocate@ABQAVNvFaceInfo@@@?$vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@std@@QAEPAPAVNvFaceInfo@@QAPAV2@ABQAV2@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	edi, ecx

; 753  :         // reallocate and insert by perfectly forwarding _Val at _Whereptr
; 754  :         _Alty& _Al        = _Getal();
; 755  :         auto& _My_data    = _Mypair._Myval2;
; 756  :         pointer& _Myfirst = _My_data._Myfirst;
; 757  :         pointer& _Mylast  = _My_data._Mylast;
; 758  : 
; 759  :         _STL_INTERNAL_CHECK(_Mylast == _My_data._Myend); // check that we have no unused capacity
; 760  : 
; 761  :         const auto _Whereoff = static_cast<size_type>(_Whereptr - _Myfirst);

	mov	edx, DWORD PTR [edi]
	mov	esi, DWORD PTR __Whereptr$[ebp]
	mov	ebx, esi
	sub	ebx, edx
	sar	ebx, 2

; 762  :         const auto _Oldsize  = static_cast<size_type>(_Mylast - _Myfirst);

	mov	eax, DWORD PTR [edi+4]
	sub	eax, edx
	sar	eax, 2

; 763  : 
; 764  :         if (_Oldsize == max_size()) {

	cmp	eax, 1073741823				; 3fffffffH
	je	$LN83@Emplace_re

; 766  :         }
; 767  : 
; 768  :         const size_type _Newsize     = _Oldsize + 1;

	inc	eax
	mov	DWORD PTR __Newsize$1$[ebp], eax

; 1546 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	ecx, DWORD PTR [edi+8]
	sub	ecx, edx
	sar	ecx, 2

; 1675 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	edx, ecx
	shr	edx, 1
	mov	eax, 1073741823				; 3fffffffH
	sub	eax, edx
	cmp	ecx, eax
	jbe	SHORT $LN12@Emplace_re

; 1676 :             return _Max; // geometric growth would overflow

	mov	eax, 1073741823				; 3fffffffH
	jmp	SHORT $LN81@Emplace_re
$LN12@Emplace_re:

; 1677 :         }
; 1678 : 
; 1679 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	lea	eax, DWORD PTR [edx+ecx]

; 1680 : 
; 1681 :         if (_Geometric < _Newsize) {

	cmp	eax, DWORD PTR __Newsize$1$[ebp]
	cmovb	eax, DWORD PTR __Newsize$1$[ebp]
$LN81@Emplace_re:
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	mov	DWORD PTR __Newcapacity$1$[ebp], eax
	shl	eax, 2
	push	eax
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 771  :         const pointer _Newvec           = _Al.allocate(_Newcapacity);

	mov	edx, eax
	mov	DWORD PTR __Newvec$[ebp], edx

; 772  :         const pointer _Constructed_last = _Newvec + _Whereoff + 1;
; 773  :         pointer _Constructed_first      = _Constructed_last;
; 774  : 
; 775  :         _TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 776  :         _Alty_traits::construct(_Al, _Unfancy(_Newvec + _Whereoff), _STD forward<_Valty>(_Val)...);

	lea	ecx, DWORD PTR [edx+ebx*4]
	mov	DWORD PTR tv555[ebp], ecx
	mov	eax, DWORD PTR _<_Val_0>$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax

; 777  :         _Constructed_first = _Newvec + _Whereoff;
; 778  : 
; 779  :         if (_Whereptr == _Mylast) { // at back, provide strong guarantee

	mov	ebx, DWORD PTR [edi+4]
	mov	ecx, DWORD PTR [edi]
	cmp	esi, ebx
	jne	SHORT $LN4@Emplace_re
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1703 :     auto _UFirst      = _Get_unwrapped(_First);

	mov	DWORD PTR __UFirst$7[ebp], ecx

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	DWORD PTR __Backout$4[ebp], edx
	mov	DWORD PTR __Backout$4[ebp+4], edx
	mov	DWORD PTR __Backout$4[ebp+8], edi
	npad	1
$LL28@Emplace_re:

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	ecx, ebx
	je	SHORT $LN27@Emplace_re

; 1620 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax

; 1621 :         ++_Last;

	add	edx, 4
	mov	DWORD PTR __Backout$4[ebp+4], edx

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	add	ecx, 4
	mov	DWORD PTR __UFirst$7[ebp], ecx
	jmp	SHORT $LL28@Emplace_re
$LN27@Emplace_re:

; 1625 :         _First = _Last;

	mov	DWORD PTR __Backout$4[ebp], edx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 781  :         } else { // provide basic guarantee

	mov	ebx, DWORD PTR tv555[ebp]
	jmp	SHORT $LN5@Emplace_re
$LN4@Emplace_re:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1703 :     auto _UFirst      = _Get_unwrapped(_First);

	mov	DWORD PTR __UFirst$6[ebp], ecx

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	DWORD PTR __Backout$3[ebp], edx
	mov	DWORD PTR __Backout$3[ebp+4], edx
	mov	DWORD PTR __Backout$3[ebp+8], edi
	npad	6
$LL41@Emplace_re:

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	ecx, esi
	je	SHORT $LN40@Emplace_re

; 1620 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax

; 1621 :         ++_Last;

	add	edx, 4
	mov	DWORD PTR __Backout$3[ebp+4], edx

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	add	ecx, 4
	mov	DWORD PTR __UFirst$6[ebp], ecx
	jmp	SHORT $LL41@Emplace_re
$LN40@Emplace_re:

; 1625 :         _First = _Last;

	mov	DWORD PTR __Backout$3[ebp], edx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 784  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

	mov	ebx, DWORD PTR tv555[ebp]
	lea	ecx, DWORD PTR [ebx+4]

; 1646 :         return _Uninitialized_move(_First, _Last, _Dest, _Getal());

	mov	edx, DWORD PTR [edi+4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1703 :     auto _UFirst      = _Get_unwrapped(_First);

	mov	DWORD PTR __UFirst$5[ebp], esi

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	DWORD PTR __Backout$2[ebp], ecx
	mov	DWORD PTR __Backout$2[ebp+4], ecx
	mov	DWORD PTR __Backout$2[ebp+8], edi
	npad	2
$LL54@Emplace_re:

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	esi, edx
	je	SHORT $LN53@Emplace_re

; 1620 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [ecx], eax

; 1621 :         ++_Last;

	add	ecx, 4
	mov	DWORD PTR __Backout$2[ebp+4], ecx

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	add	esi, 4
	mov	DWORD PTR __UFirst$5[ebp], esi
	jmp	SHORT $LL54@Emplace_re
$LN53@Emplace_re:

; 1625 :         _First = _Last;

	mov	DWORD PTR __Backout$2[ebp], ecx
$LN5@Emplace_re:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
	mov	DWORD PTR __$EHRec$[ebp+12], -1

; 1732 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [edi]
	test	eax, eax
	je	SHORT $LN68@Emplace_re
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	push	eax
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN68@Emplace_re:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1737 :         _Myfirst = _Newvec;

	mov	eax, DWORD PTR __Newvec$[ebp]
	mov	DWORD PTR [edi], eax

; 1738 :         _Mylast  = _Newvec + _Newsize;

	mov	ecx, DWORD PTR __Newsize$1$[ebp]
	lea	ecx, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR [edi+4], ecx

; 1739 :         _Myend   = _Newvec + _Newcapacity;

	mov	ecx, DWORD PTR __Newcapacity$1$[ebp]
	lea	ecx, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR [edi+8], ecx

; 790  :         _CATCH_END
; 791  : 
; 792  :         _Change_array(_Newvec, _Newsize, _Newcapacity);
; 793  :         return _Newvec + _Whereoff;

	mov	eax, ebx

; 794  :     }

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
__catch$??$_Emplace_reallocate@ABQAVNvFaceInfo@@@?$vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@std@@QAEPAPAVNvFaceInfo@@QAPAV2@ABQAV2@@Z$0:

; 785  :         }
; 786  :         _CATCH_ALL
; 787  :         _Destroy(_Constructed_first, _Constructed_last);
; 788  :         _Al.deallocate(_Newvec, _Newcapacity);

	push	ecx
	push	DWORD PTR __Newvec$[ebp]
	call	?deallocate@?$xalloc@PAVNvFaceInfo@@@@QBEXPAPAVNvFaceInfo@@I@Z ; xalloc<NvFaceInfo *>::deallocate

; 789  :         _RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$LN83@Emplace_re:

; 765  :             _Xlength();

	call	?_Xlength@?$vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@std@@CAXXZ ; std::vector<NvFaceInfo *,xalloc<NvFaceInfo *> >::_Xlength
$LN80@Emplace_re:
	int	3
	int	3
	int	3
	int	3
	int	3
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Emplace_reallocate@ABQAVNvFaceInfo@@@?$vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@std@@QAEPAPAVNvFaceInfo@@QAPAV2@ABQAV2@@Z:
	npad	1
	npad	1
	mov	eax, OFFSET __ehfuncinfo$??$_Emplace_reallocate@ABQAVNvFaceInfo@@@?$vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@std@@QAEPAPAVNvFaceInfo@@QAPAV2@ABQAV2@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Emplace_reallocate@ABQAVNvFaceInfo@@@?$vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@std@@QAEPAPAVNvFaceInfo@@QAPAV2@ABQAV2@@Z ENDP ; std::vector<NvFaceInfo *,xalloc<NvFaceInfo *> >::_Emplace_reallocate<NvFaceInfo * const &>
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef
;	COMDAT ??$addressof@$$CBV?$vector@GV?$xalloc@G@@@std@@@std@@YAPBV?$vector@GV?$xalloc@G@@@0@ABV10@@Z
_TEXT	SEGMENT
??$addressof@$$CBV?$vector@GV?$xalloc@G@@@std@@@std@@YAPBV?$vector@GV?$xalloc@G@@@0@ABV10@@Z PROC ; std::addressof<std::vector<unsigned short,xalloc<unsigned short> > const >, COMDAT
; __Val$ = ecx

; 253  :     return __builtin_addressof(_Val);

	mov	eax, ecx

; 254  : }

	ret	0
??$addressof@$$CBV?$vector@GV?$xalloc@G@@@std@@@std@@YAPBV?$vector@GV?$xalloc@G@@@0@ABV10@@Z ENDP ; std::addressof<std::vector<unsigned short,xalloc<unsigned short> > const >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??$_Emplace_reallocate@G@?$vector@GV?$xalloc@G@@@std@@QAEPAGQAG$$QAG@Z
_TEXT	SEGMENT
__Backout$2 = -76					; size = 12
__Backout$3 = -64					; size = 12
__Backout$4 = -52					; size = 12
__Newvec$ = -40						; size = 4
__Newsize$1$ = -36					; size = 4
__UFirst$5 = -32					; size = 4
__UFirst$6 = -28					; size = 4
__UFirst$7 = -24					; size = 4
tv521 = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Newcapacity$1$ = 8					; size = 4
__Whereptr$ = 8						; size = 4
_<_Val_0>$ = 12						; size = 4
??$_Emplace_reallocate@G@?$vector@GV?$xalloc@G@@@std@@QAEPAGQAG$$QAG@Z PROC ; std::vector<unsigned short,xalloc<unsigned short> >::_Emplace_reallocate<unsigned short>, COMDAT
; _this$dead$ = ecx

; 752  :     _CONSTEXPR20_CONTAINER pointer _Emplace_reallocate(const pointer _Whereptr, _Valty&&... _Val) {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Emplace_reallocate@G@?$vector@GV?$xalloc@G@@@std@@QAEPAGQAG$$QAG@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR __$EHRec$[ebp], esp

; 753  :         // reallocate and insert by perfectly forwarding _Val at _Whereptr
; 754  :         _Alty& _Al        = _Getal();
; 755  :         auto& _My_data    = _Mypair._Myval2;
; 756  :         pointer& _Myfirst = _My_data._Myfirst;
; 757  :         pointer& _Mylast  = _My_data._Mylast;
; 758  : 
; 759  :         _STL_INTERNAL_CHECK(_Mylast == _My_data._Myend); // check that we have no unused capacity
; 760  : 
; 761  :         const auto _Whereoff = static_cast<size_type>(_Whereptr - _Myfirst);

	mov	esi, DWORD PTR __Whereptr$[ebp]
	mov	edi, esi
	mov	edx, DWORD PTR ?scratchIndices@?1??Build@NvStripInfo@@QAEXAAV?$xr_vector@PAVNvEdgeInfo@@V?$xalloc@PAVNvEdgeInfo@@@@@@AAV?$xr_vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@@@Z@4V?$xr_vector@GV?$xalloc@G@@@@A
	sub	edi, edx
	sar	edi, 1

; 762  :         const auto _Oldsize  = static_cast<size_type>(_Mylast - _Myfirst);

	mov	eax, DWORD PTR ?scratchIndices@?1??Build@NvStripInfo@@QAEXAAV?$xr_vector@PAVNvEdgeInfo@@V?$xalloc@PAVNvEdgeInfo@@@@@@AAV?$xr_vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@@@Z@4V?$xr_vector@GV?$xalloc@G@@@@A+4
	sub	eax, edx
	sar	eax, 1

; 763  : 
; 764  :         if (_Oldsize == max_size()) {

	cmp	eax, 2147483647				; 7fffffffH
	je	$LN83@Emplace_re

; 766  :         }
; 767  : 
; 768  :         const size_type _Newsize     = _Oldsize + 1;

	lea	ebx, DWORD PTR [eax+1]
	mov	DWORD PTR __Newsize$1$[ebp], ebx

; 1546 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	ecx, DWORD PTR ?scratchIndices@?1??Build@NvStripInfo@@QAEXAAV?$xr_vector@PAVNvEdgeInfo@@V?$xalloc@PAVNvEdgeInfo@@@@@@AAV?$xr_vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@@@Z@4V?$xr_vector@GV?$xalloc@G@@@@A+8
	sub	ecx, edx
	sar	ecx, 1

; 1675 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	edx, ecx
	shr	edx, 1
	mov	eax, 2147483647				; 7fffffffH
	sub	eax, edx
	cmp	ecx, eax
	jbe	SHORT $LN12@Emplace_re

; 1676 :             return _Max; // geometric growth would overflow

	mov	eax, 2147483647				; 7fffffffH
	jmp	SHORT $LN81@Emplace_re
$LN12@Emplace_re:

; 1677 :         }
; 1678 : 
; 1679 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	lea	eax, DWORD PTR [edx+ecx]

; 1680 : 
; 1681 :         if (_Geometric < _Newsize) {

	cmp	eax, ebx
	cmovb	eax, ebx
$LN81@Emplace_re:
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	mov	DWORD PTR __Newcapacity$1$[ebp], eax
	add	eax, eax
	push	eax
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 771  :         const pointer _Newvec           = _Al.allocate(_Newcapacity);

	mov	ebx, eax
	mov	DWORD PTR __Newvec$[ebp], ebx

; 772  :         const pointer _Constructed_last = _Newvec + _Whereoff + 1;
; 773  :         pointer _Constructed_first      = _Constructed_last;
; 774  : 
; 775  :         _TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 776  :         _Alty_traits::construct(_Al, _Unfancy(_Newvec + _Whereoff), _STD forward<_Valty>(_Val)...);

	lea	ecx, DWORD PTR [ebx+edi*2]
	mov	DWORD PTR tv521[ebp], ecx
	mov	eax, DWORD PTR _<_Val_0>$[ebp]
	mov	ax, WORD PTR [eax]
	mov	WORD PTR [ecx], ax

; 777  :         _Constructed_first = _Newvec + _Whereoff;
; 778  : 
; 779  :         if (_Whereptr == _Mylast) { // at back, provide strong guarantee

	mov	edi, DWORD PTR ?scratchIndices@?1??Build@NvStripInfo@@QAEXAAV?$xr_vector@PAVNvEdgeInfo@@V?$xalloc@PAVNvEdgeInfo@@@@@@AAV?$xr_vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@@@Z@4V?$xr_vector@GV?$xalloc@G@@@@A+4
	mov	ecx, DWORD PTR ?scratchIndices@?1??Build@NvStripInfo@@QAEXAAV?$xr_vector@PAVNvEdgeInfo@@V?$xalloc@PAVNvEdgeInfo@@@@@@AAV?$xr_vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@@@Z@4V?$xr_vector@GV?$xalloc@G@@@@A
	mov	edx, ebx
	cmp	esi, edi
	jne	SHORT $LN4@Emplace_re
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1703 :     auto _UFirst      = _Get_unwrapped(_First);

	mov	DWORD PTR __UFirst$7[ebp], ecx

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	DWORD PTR __Backout$4[ebp], ebx
	mov	DWORD PTR __Backout$4[ebp+4], edx
	mov	DWORD PTR __Backout$4[ebp+8], OFFSET ?scratchIndices@?1??Build@NvStripInfo@@QAEXAAV?$xr_vector@PAVNvEdgeInfo@@V?$xalloc@PAVNvEdgeInfo@@@@@@AAV?$xr_vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@@@Z@4V?$xr_vector@GV?$xalloc@G@@@@A
$LL28@Emplace_re:

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	ecx, edi
	je	SHORT $LN27@Emplace_re

; 1620 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

	mov	ax, WORD PTR [ecx]
	mov	WORD PTR [edx], ax

; 1621 :         ++_Last;

	add	edx, 2
	mov	DWORD PTR __Backout$4[ebp+4], edx

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	add	ecx, 2
	mov	DWORD PTR __UFirst$7[ebp], ecx
	jmp	SHORT $LL28@Emplace_re
$LN27@Emplace_re:

; 1625 :         _First = _Last;

	mov	DWORD PTR __Backout$4[ebp], edx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 781  :         } else { // provide basic guarantee

	jmp	SHORT $LN5@Emplace_re
$LN4@Emplace_re:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1703 :     auto _UFirst      = _Get_unwrapped(_First);

	mov	DWORD PTR __UFirst$6[ebp], ecx

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	DWORD PTR __Backout$3[ebp], ebx
	mov	DWORD PTR __Backout$3[ebp+4], edx
	mov	DWORD PTR __Backout$3[ebp+8], OFFSET ?scratchIndices@?1??Build@NvStripInfo@@QAEXAAV?$xr_vector@PAVNvEdgeInfo@@V?$xalloc@PAVNvEdgeInfo@@@@@@AAV?$xr_vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@@@Z@4V?$xr_vector@GV?$xalloc@G@@@@A
	npad	2
$LL41@Emplace_re:

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	ecx, esi
	je	SHORT $LN40@Emplace_re

; 1620 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

	mov	ax, WORD PTR [ecx]
	mov	WORD PTR [edx], ax

; 1621 :         ++_Last;

	add	edx, 2
	mov	DWORD PTR __Backout$3[ebp+4], edx

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	add	ecx, 2
	mov	DWORD PTR __UFirst$6[ebp], ecx
	mov	edi, DWORD PTR ?scratchIndices@?1??Build@NvStripInfo@@QAEXAAV?$xr_vector@PAVNvEdgeInfo@@V?$xalloc@PAVNvEdgeInfo@@@@@@AAV?$xr_vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@@@Z@4V?$xr_vector@GV?$xalloc@G@@@@A+4
	jmp	SHORT $LL41@Emplace_re
$LN40@Emplace_re:

; 1625 :         _First = _Last;

	mov	DWORD PTR __Backout$3[ebp], edx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 784  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

	mov	ecx, DWORD PTR tv521[ebp]
	add	ecx, 2
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1703 :     auto _UFirst      = _Get_unwrapped(_First);

	mov	DWORD PTR __UFirst$5[ebp], esi

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	DWORD PTR __Backout$2[ebp], ecx
	mov	DWORD PTR __Backout$2[ebp+4], ecx
	mov	DWORD PTR __Backout$2[ebp+8], OFFSET ?scratchIndices@?1??Build@NvStripInfo@@QAEXAAV?$xr_vector@PAVNvEdgeInfo@@V?$xalloc@PAVNvEdgeInfo@@@@@@AAV?$xr_vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@@@Z@4V?$xr_vector@GV?$xalloc@G@@@@A
$LL54@Emplace_re:

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	esi, edi
	je	SHORT $LN53@Emplace_re

; 1620 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

	mov	ax, WORD PTR [esi]
	mov	WORD PTR [ecx], ax

; 1621 :         ++_Last;

	add	ecx, 2
	mov	DWORD PTR __Backout$2[ebp+4], ecx

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	add	esi, 2
	mov	DWORD PTR __UFirst$5[ebp], esi
	jmp	SHORT $LL54@Emplace_re
$LN53@Emplace_re:

; 1625 :         _First = _Last;

	mov	DWORD PTR __Backout$2[ebp], ecx
$LN5@Emplace_re:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
	mov	DWORD PTR __$EHRec$[ebp+12], -1

; 1732 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR ?scratchIndices@?1??Build@NvStripInfo@@QAEXAAV?$xr_vector@PAVNvEdgeInfo@@V?$xalloc@PAVNvEdgeInfo@@@@@@AAV?$xr_vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@@@Z@4V?$xr_vector@GV?$xalloc@G@@@@A
	test	eax, eax
	je	SHORT $LN68@Emplace_re
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	push	eax
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN68@Emplace_re:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1737 :         _Myfirst = _Newvec;

	mov	DWORD PTR ?scratchIndices@?1??Build@NvStripInfo@@QAEXAAV?$xr_vector@PAVNvEdgeInfo@@V?$xalloc@PAVNvEdgeInfo@@@@@@AAV?$xr_vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@@@Z@4V?$xr_vector@GV?$xalloc@G@@@@A, ebx

; 1738 :         _Mylast  = _Newvec + _Newsize;

	mov	ecx, DWORD PTR __Newsize$1$[ebp]
	lea	ecx, DWORD PTR [ebx+ecx*2]
	mov	DWORD PTR ?scratchIndices@?1??Build@NvStripInfo@@QAEXAAV?$xr_vector@PAVNvEdgeInfo@@V?$xalloc@PAVNvEdgeInfo@@@@@@AAV?$xr_vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@@@Z@4V?$xr_vector@GV?$xalloc@G@@@@A+4, ecx

; 1739 :         _Myend   = _Newvec + _Newcapacity;

	mov	ecx, DWORD PTR __Newcapacity$1$[ebp]
	lea	ecx, DWORD PTR [ebx+ecx*2]
	mov	DWORD PTR ?scratchIndices@?1??Build@NvStripInfo@@QAEXAAV?$xr_vector@PAVNvEdgeInfo@@V?$xalloc@PAVNvEdgeInfo@@@@@@AAV?$xr_vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@@@Z@4V?$xr_vector@GV?$xalloc@G@@@@A+8, ecx

; 790  :         _CATCH_END
; 791  : 
; 792  :         _Change_array(_Newvec, _Newsize, _Newcapacity);
; 793  :         return _Newvec + _Whereoff;

	mov	eax, DWORD PTR tv521[ebp]

; 794  :     }

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
__catch$??$_Emplace_reallocate@G@?$vector@GV?$xalloc@G@@@std@@QAEPAGQAG$$QAG@Z$0:

; 785  :         }
; 786  :         _CATCH_ALL
; 787  :         _Destroy(_Constructed_first, _Constructed_last);
; 788  :         _Al.deallocate(_Newvec, _Newcapacity);

	push	ecx
	push	DWORD PTR __Newvec$[ebp]
	call	?deallocate@?$xalloc@G@@QBEXPAGI@Z	; xalloc<unsigned short>::deallocate

; 789  :         _RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$LN83@Emplace_re:

; 765  :             _Xlength();

	call	?_Xlength@?$vector@GV?$xalloc@G@@@std@@CAXXZ ; std::vector<unsigned short,xalloc<unsigned short> >::_Xlength
$LN80@Emplace_re:
	int	3
	int	3
	int	3
	int	3
	int	3
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Emplace_reallocate@G@?$vector@GV?$xalloc@G@@@std@@QAEPAGQAG$$QAG@Z:
	npad	1
	npad	1
	mov	eax, OFFSET __ehfuncinfo$??$_Emplace_reallocate@G@?$vector@GV?$xalloc@G@@@std@@QAEPAGQAG$$QAG@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Emplace_reallocate@G@?$vector@GV?$xalloc@G@@@std@@QAEPAGQAG$$QAG@Z ENDP ; std::vector<unsigned short,xalloc<unsigned short> >::_Emplace_reallocate<unsigned short>
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\type_traits
;	COMDAT ??$move@AAH@std@@YA$$QAHAAH@Z
_TEXT	SEGMENT
??$move@AAH@std@@YA$$QAHAAH@Z PROC			; std::move<int &>, COMDAT
; __Arg$ = ecx

; 1397 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

	mov	eax, ecx

; 1398 : }

	ret	0
??$move@AAH@std@@YA$$QAHAAH@Z ENDP			; std::move<int &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\type_traits
;	COMDAT ??$forward@H@std@@YA$$QAHAAH@Z
_TEXT	SEGMENT
??$forward@H@std@@YA$$QAHAAH@Z PROC			; std::forward<int>, COMDAT
; __Arg$ = ecx

; 1386 :     return static_cast<_Ty&&>(_Arg);

	mov	eax, ecx

; 1387 : }

	ret	0
??$forward@H@std@@YA$$QAHAAH@Z ENDP			; std::forward<int>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$construct@HH@?$_Normal_allocator_traits@V?$xalloc@H@@@std@@SAXAAV?$xalloc@H@@PAH$$QAH@Z
_TEXT	SEGMENT
_<_Args_0>$ = 8						; size = 4
??$construct@HH@?$_Normal_allocator_traits@V?$xalloc@H@@@std@@SAXAAV?$xalloc@H@@PAH$$QAH@Z PROC ; std::_Normal_allocator_traits<xalloc<int> >::construct<int,int>, COMDAT
; __Al$dead$ = ecx
; __Ptr$ = edx

; 565  :         if constexpr (_Uses_default_construct<_Alloc, _Ty*, _Types...>::value) {
; 566  :             (void) _Al; // TRANSITION, DevCom-1004719
; 567  : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 568  :             _STD construct_at(_Ptr, _STD forward<_Types>(_Args)...);
; 569  : #else // __cpp_lib_constexpr_dynamic_alloc
; 570  :             ::new (static_cast<void*>(_Ptr)) _Ty(_STD forward<_Types>(_Args)...);
; 571  : #endif // __cpp_lib_constexpr_dynamic_alloc
; 572  :         } else {
; 573  :             _Al.construct(_Ptr, _STD forward<_Types>(_Args)...);

	mov	eax, DWORD PTR _<_Args_0>$[esp-4]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edx], eax

; 574  :         }
; 575  :     }

	ret	0
??$construct@HH@?$_Normal_allocator_traits@V?$xalloc@H@@@std@@SAXAAV?$xalloc@H@@PAH$$QAH@Z ENDP ; std::_Normal_allocator_traits<xalloc<int> >::construct<int,int>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??$_Emplace_reallocate@H@?$vector@HV?$xalloc@H@@@std@@QAEPAHQAH$$QAH@Z
_TEXT	SEGMENT
__Backout$2 = -76					; size = 12
__Backout$3 = -64					; size = 12
__Backout$4 = -52					; size = 12
__UFirst$5 = -40					; size = 4
__UFirst$6 = -36					; size = 4
__UFirst$7 = -32					; size = 4
__Newvec$ = -28						; size = 4
__Newcapacity$1$ = -24					; size = 4
__Newsize$1$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
tv555 = 8						; size = 4
__Whereptr$ = 8						; size = 4
_<_Val_0>$ = 12						; size = 4
??$_Emplace_reallocate@H@?$vector@HV?$xalloc@H@@@std@@QAEPAHQAH$$QAH@Z PROC ; std::vector<int,xalloc<int> >::_Emplace_reallocate<int>, COMDAT
; _this$ = ecx

; 752  :     _CONSTEXPR20_CONTAINER pointer _Emplace_reallocate(const pointer _Whereptr, _Valty&&... _Val) {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Emplace_reallocate@H@?$vector@HV?$xalloc@H@@@std@@QAEPAHQAH$$QAH@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	edi, ecx

; 753  :         // reallocate and insert by perfectly forwarding _Val at _Whereptr
; 754  :         _Alty& _Al        = _Getal();
; 755  :         auto& _My_data    = _Mypair._Myval2;
; 756  :         pointer& _Myfirst = _My_data._Myfirst;
; 757  :         pointer& _Mylast  = _My_data._Mylast;
; 758  : 
; 759  :         _STL_INTERNAL_CHECK(_Mylast == _My_data._Myend); // check that we have no unused capacity
; 760  : 
; 761  :         const auto _Whereoff = static_cast<size_type>(_Whereptr - _Myfirst);

	mov	edx, DWORD PTR [edi]
	mov	esi, DWORD PTR __Whereptr$[ebp]
	mov	ebx, esi
	sub	ebx, edx
	sar	ebx, 2

; 762  :         const auto _Oldsize  = static_cast<size_type>(_Mylast - _Myfirst);

	mov	eax, DWORD PTR [edi+4]
	sub	eax, edx
	sar	eax, 2

; 763  : 
; 764  :         if (_Oldsize == max_size()) {

	cmp	eax, 1073741823				; 3fffffffH
	je	$LN83@Emplace_re

; 766  :         }
; 767  : 
; 768  :         const size_type _Newsize     = _Oldsize + 1;

	inc	eax
	mov	DWORD PTR __Newsize$1$[ebp], eax

; 1546 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	ecx, DWORD PTR [edi+8]
	sub	ecx, edx
	sar	ecx, 2

; 1675 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	edx, ecx
	shr	edx, 1
	mov	eax, 1073741823				; 3fffffffH
	sub	eax, edx
	cmp	ecx, eax
	jbe	SHORT $LN12@Emplace_re

; 1676 :             return _Max; // geometric growth would overflow

	mov	eax, 1073741823				; 3fffffffH
	jmp	SHORT $LN81@Emplace_re
$LN12@Emplace_re:

; 1677 :         }
; 1678 : 
; 1679 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	lea	eax, DWORD PTR [edx+ecx]

; 1680 : 
; 1681 :         if (_Geometric < _Newsize) {

	cmp	eax, DWORD PTR __Newsize$1$[ebp]
	cmovb	eax, DWORD PTR __Newsize$1$[ebp]
$LN81@Emplace_re:
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	mov	DWORD PTR __Newcapacity$1$[ebp], eax
	shl	eax, 2
	push	eax
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 771  :         const pointer _Newvec           = _Al.allocate(_Newcapacity);

	mov	edx, eax
	mov	DWORD PTR __Newvec$[ebp], edx

; 772  :         const pointer _Constructed_last = _Newvec + _Whereoff + 1;
; 773  :         pointer _Constructed_first      = _Constructed_last;
; 774  : 
; 775  :         _TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 776  :         _Alty_traits::construct(_Al, _Unfancy(_Newvec + _Whereoff), _STD forward<_Valty>(_Val)...);

	lea	ecx, DWORD PTR [edx+ebx*4]
	mov	DWORD PTR tv555[ebp], ecx
	mov	eax, DWORD PTR _<_Val_0>$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax

; 777  :         _Constructed_first = _Newvec + _Whereoff;
; 778  : 
; 779  :         if (_Whereptr == _Mylast) { // at back, provide strong guarantee

	mov	ebx, DWORD PTR [edi+4]
	mov	ecx, DWORD PTR [edi]
	cmp	esi, ebx
	jne	SHORT $LN4@Emplace_re
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1703 :     auto _UFirst      = _Get_unwrapped(_First);

	mov	DWORD PTR __UFirst$7[ebp], ecx

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	DWORD PTR __Backout$4[ebp], edx
	mov	DWORD PTR __Backout$4[ebp+4], edx
	mov	DWORD PTR __Backout$4[ebp+8], edi
	npad	1
$LL28@Emplace_re:

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	ecx, ebx
	je	SHORT $LN27@Emplace_re

; 1620 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax

; 1621 :         ++_Last;

	add	edx, 4
	mov	DWORD PTR __Backout$4[ebp+4], edx

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	add	ecx, 4
	mov	DWORD PTR __UFirst$7[ebp], ecx
	jmp	SHORT $LL28@Emplace_re
$LN27@Emplace_re:

; 1625 :         _First = _Last;

	mov	DWORD PTR __Backout$4[ebp], edx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 781  :         } else { // provide basic guarantee

	mov	ebx, DWORD PTR tv555[ebp]
	jmp	SHORT $LN5@Emplace_re
$LN4@Emplace_re:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1703 :     auto _UFirst      = _Get_unwrapped(_First);

	mov	DWORD PTR __UFirst$6[ebp], ecx

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	DWORD PTR __Backout$3[ebp], edx
	mov	DWORD PTR __Backout$3[ebp+4], edx
	mov	DWORD PTR __Backout$3[ebp+8], edi
	npad	6
$LL41@Emplace_re:

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	ecx, esi
	je	SHORT $LN40@Emplace_re

; 1620 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax

; 1621 :         ++_Last;

	add	edx, 4
	mov	DWORD PTR __Backout$3[ebp+4], edx

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	add	ecx, 4
	mov	DWORD PTR __UFirst$6[ebp], ecx
	jmp	SHORT $LL41@Emplace_re
$LN40@Emplace_re:

; 1625 :         _First = _Last;

	mov	DWORD PTR __Backout$3[ebp], edx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 784  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

	mov	ebx, DWORD PTR tv555[ebp]
	lea	ecx, DWORD PTR [ebx+4]

; 1646 :         return _Uninitialized_move(_First, _Last, _Dest, _Getal());

	mov	edx, DWORD PTR [edi+4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1703 :     auto _UFirst      = _Get_unwrapped(_First);

	mov	DWORD PTR __UFirst$5[ebp], esi

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	DWORD PTR __Backout$2[ebp], ecx
	mov	DWORD PTR __Backout$2[ebp+4], ecx
	mov	DWORD PTR __Backout$2[ebp+8], edi
	npad	2
$LL54@Emplace_re:

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	esi, edx
	je	SHORT $LN53@Emplace_re

; 1620 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [ecx], eax

; 1621 :         ++_Last;

	add	ecx, 4
	mov	DWORD PTR __Backout$2[ebp+4], ecx

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	add	esi, 4
	mov	DWORD PTR __UFirst$5[ebp], esi
	jmp	SHORT $LL54@Emplace_re
$LN53@Emplace_re:

; 1625 :         _First = _Last;

	mov	DWORD PTR __Backout$2[ebp], ecx
$LN5@Emplace_re:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
	mov	DWORD PTR __$EHRec$[ebp+12], -1

; 1732 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [edi]
	test	eax, eax
	je	SHORT $LN68@Emplace_re
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	push	eax
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN68@Emplace_re:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1737 :         _Myfirst = _Newvec;

	mov	eax, DWORD PTR __Newvec$[ebp]
	mov	DWORD PTR [edi], eax

; 1738 :         _Mylast  = _Newvec + _Newsize;

	mov	ecx, DWORD PTR __Newsize$1$[ebp]
	lea	ecx, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR [edi+4], ecx

; 1739 :         _Myend   = _Newvec + _Newcapacity;

	mov	ecx, DWORD PTR __Newcapacity$1$[ebp]
	lea	ecx, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR [edi+8], ecx

; 790  :         _CATCH_END
; 791  : 
; 792  :         _Change_array(_Newvec, _Newsize, _Newcapacity);
; 793  :         return _Newvec + _Whereoff;

	mov	eax, ebx

; 794  :     }

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
__catch$??$_Emplace_reallocate@H@?$vector@HV?$xalloc@H@@@std@@QAEPAHQAH$$QAH@Z$0:

; 785  :         }
; 786  :         _CATCH_ALL
; 787  :         _Destroy(_Constructed_first, _Constructed_last);
; 788  :         _Al.deallocate(_Newvec, _Newcapacity);

	push	ecx
	push	DWORD PTR __Newvec$[ebp]
	call	?deallocate@?$xalloc@H@@QBEXPAHI@Z	; xalloc<int>::deallocate

; 789  :         _RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$LN83@Emplace_re:

; 765  :             _Xlength();

	call	?_Xlength@?$vector@HV?$xalloc@H@@@std@@CAXXZ ; std::vector<int,xalloc<int> >::_Xlength
$LN80@Emplace_re:
	int	3
	int	3
	int	3
	int	3
	int	3
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Emplace_reallocate@H@?$vector@HV?$xalloc@H@@@std@@QAEPAHQAH$$QAH@Z:
	npad	1
	npad	1
	mov	eax, OFFSET __ehfuncinfo$??$_Emplace_reallocate@H@?$vector@HV?$xalloc@H@@@std@@QAEPAHQAH$$QAH@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Emplace_reallocate@H@?$vector@HV?$xalloc@H@@@std@@QAEPAHQAH$$QAH@Z ENDP ; std::vector<int,xalloc<int> >::_Emplace_reallocate<int>
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\type_traits
;	COMDAT ??$forward@ABH@std@@YAABHABH@Z
_TEXT	SEGMENT
??$forward@ABH@std@@YAABHABH@Z PROC			; std::forward<int const &>, COMDAT
; __Arg$ = ecx

; 1386 :     return static_cast<_Ty&&>(_Arg);

	mov	eax, ecx

; 1387 : }

	ret	0
??$forward@ABH@std@@YAABHABH@Z ENDP			; std::forward<int const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$construct@HABH@?$_Normal_allocator_traits@V?$xalloc@H@@@std@@SAXAAV?$xalloc@H@@PAHABH@Z
_TEXT	SEGMENT
_<_Args_0>$ = 8						; size = 4
??$construct@HABH@?$_Normal_allocator_traits@V?$xalloc@H@@@std@@SAXAAV?$xalloc@H@@PAHABH@Z PROC ; std::_Normal_allocator_traits<xalloc<int> >::construct<int,int const &>, COMDAT
; __Al$dead$ = ecx
; __Ptr$ = edx

; 565  :         if constexpr (_Uses_default_construct<_Alloc, _Ty*, _Types...>::value) {
; 566  :             (void) _Al; // TRANSITION, DevCom-1004719
; 567  : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 568  :             _STD construct_at(_Ptr, _STD forward<_Types>(_Args)...);
; 569  : #else // __cpp_lib_constexpr_dynamic_alloc
; 570  :             ::new (static_cast<void*>(_Ptr)) _Ty(_STD forward<_Types>(_Args)...);
; 571  : #endif // __cpp_lib_constexpr_dynamic_alloc
; 572  :         } else {
; 573  :             _Al.construct(_Ptr, _STD forward<_Types>(_Args)...);

	mov	eax, DWORD PTR _<_Args_0>$[esp-4]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edx], eax

; 574  :         }
; 575  :     }

	ret	0
??$construct@HABH@?$_Normal_allocator_traits@V?$xalloc@H@@@std@@SAXAAV?$xalloc@H@@PAHABH@Z ENDP ; std::_Normal_allocator_traits<xalloc<int> >::construct<int,int const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??$_Emplace_reallocate@ABH@?$vector@HV?$xalloc@H@@@std@@QAEPAHQAHABH@Z
_TEXT	SEGMENT
__Backout$2 = -76					; size = 12
__Backout$3 = -64					; size = 12
__Backout$4 = -52					; size = 12
__UFirst$5 = -40					; size = 4
__UFirst$6 = -36					; size = 4
__UFirst$7 = -32					; size = 4
__Newvec$ = -28						; size = 4
__Newcapacity$1$ = -24					; size = 4
__Newsize$1$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
tv555 = 8						; size = 4
__Whereptr$ = 8						; size = 4
_<_Val_0>$ = 12						; size = 4
??$_Emplace_reallocate@ABH@?$vector@HV?$xalloc@H@@@std@@QAEPAHQAHABH@Z PROC ; std::vector<int,xalloc<int> >::_Emplace_reallocate<int const &>, COMDAT
; _this$ = ecx

; 752  :     _CONSTEXPR20_CONTAINER pointer _Emplace_reallocate(const pointer _Whereptr, _Valty&&... _Val) {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Emplace_reallocate@ABH@?$vector@HV?$xalloc@H@@@std@@QAEPAHQAHABH@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	edi, ecx

; 753  :         // reallocate and insert by perfectly forwarding _Val at _Whereptr
; 754  :         _Alty& _Al        = _Getal();
; 755  :         auto& _My_data    = _Mypair._Myval2;
; 756  :         pointer& _Myfirst = _My_data._Myfirst;
; 757  :         pointer& _Mylast  = _My_data._Mylast;
; 758  : 
; 759  :         _STL_INTERNAL_CHECK(_Mylast == _My_data._Myend); // check that we have no unused capacity
; 760  : 
; 761  :         const auto _Whereoff = static_cast<size_type>(_Whereptr - _Myfirst);

	mov	edx, DWORD PTR [edi]
	mov	esi, DWORD PTR __Whereptr$[ebp]
	mov	ebx, esi
	sub	ebx, edx
	sar	ebx, 2

; 762  :         const auto _Oldsize  = static_cast<size_type>(_Mylast - _Myfirst);

	mov	eax, DWORD PTR [edi+4]
	sub	eax, edx
	sar	eax, 2

; 763  : 
; 764  :         if (_Oldsize == max_size()) {

	cmp	eax, 1073741823				; 3fffffffH
	je	$LN83@Emplace_re

; 766  :         }
; 767  : 
; 768  :         const size_type _Newsize     = _Oldsize + 1;

	inc	eax
	mov	DWORD PTR __Newsize$1$[ebp], eax

; 1546 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	ecx, DWORD PTR [edi+8]
	sub	ecx, edx
	sar	ecx, 2

; 1675 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	edx, ecx
	shr	edx, 1
	mov	eax, 1073741823				; 3fffffffH
	sub	eax, edx
	cmp	ecx, eax
	jbe	SHORT $LN12@Emplace_re

; 1676 :             return _Max; // geometric growth would overflow

	mov	eax, 1073741823				; 3fffffffH
	jmp	SHORT $LN81@Emplace_re
$LN12@Emplace_re:

; 1677 :         }
; 1678 : 
; 1679 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	lea	eax, DWORD PTR [edx+ecx]

; 1680 : 
; 1681 :         if (_Geometric < _Newsize) {

	cmp	eax, DWORD PTR __Newsize$1$[ebp]
	cmovb	eax, DWORD PTR __Newsize$1$[ebp]
$LN81@Emplace_re:
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	mov	DWORD PTR __Newcapacity$1$[ebp], eax
	shl	eax, 2
	push	eax
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 771  :         const pointer _Newvec           = _Al.allocate(_Newcapacity);

	mov	edx, eax
	mov	DWORD PTR __Newvec$[ebp], edx

; 772  :         const pointer _Constructed_last = _Newvec + _Whereoff + 1;
; 773  :         pointer _Constructed_first      = _Constructed_last;
; 774  : 
; 775  :         _TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 776  :         _Alty_traits::construct(_Al, _Unfancy(_Newvec + _Whereoff), _STD forward<_Valty>(_Val)...);

	lea	ecx, DWORD PTR [edx+ebx*4]
	mov	DWORD PTR tv555[ebp], ecx
	mov	eax, DWORD PTR _<_Val_0>$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax

; 777  :         _Constructed_first = _Newvec + _Whereoff;
; 778  : 
; 779  :         if (_Whereptr == _Mylast) { // at back, provide strong guarantee

	mov	ebx, DWORD PTR [edi+4]
	mov	ecx, DWORD PTR [edi]
	cmp	esi, ebx
	jne	SHORT $LN4@Emplace_re
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1703 :     auto _UFirst      = _Get_unwrapped(_First);

	mov	DWORD PTR __UFirst$7[ebp], ecx

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	DWORD PTR __Backout$4[ebp], edx
	mov	DWORD PTR __Backout$4[ebp+4], edx
	mov	DWORD PTR __Backout$4[ebp+8], edi
	npad	1
$LL28@Emplace_re:

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	ecx, ebx
	je	SHORT $LN27@Emplace_re

; 1620 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax

; 1621 :         ++_Last;

	add	edx, 4
	mov	DWORD PTR __Backout$4[ebp+4], edx

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	add	ecx, 4
	mov	DWORD PTR __UFirst$7[ebp], ecx
	jmp	SHORT $LL28@Emplace_re
$LN27@Emplace_re:

; 1625 :         _First = _Last;

	mov	DWORD PTR __Backout$4[ebp], edx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 781  :         } else { // provide basic guarantee

	mov	ebx, DWORD PTR tv555[ebp]
	jmp	SHORT $LN5@Emplace_re
$LN4@Emplace_re:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1703 :     auto _UFirst      = _Get_unwrapped(_First);

	mov	DWORD PTR __UFirst$6[ebp], ecx

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	DWORD PTR __Backout$3[ebp], edx
	mov	DWORD PTR __Backout$3[ebp+4], edx
	mov	DWORD PTR __Backout$3[ebp+8], edi
	npad	6
$LL41@Emplace_re:

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	ecx, esi
	je	SHORT $LN40@Emplace_re

; 1620 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax

; 1621 :         ++_Last;

	add	edx, 4
	mov	DWORD PTR __Backout$3[ebp+4], edx

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	add	ecx, 4
	mov	DWORD PTR __UFirst$6[ebp], ecx
	jmp	SHORT $LL41@Emplace_re
$LN40@Emplace_re:

; 1625 :         _First = _Last;

	mov	DWORD PTR __Backout$3[ebp], edx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 784  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

	mov	ebx, DWORD PTR tv555[ebp]
	lea	ecx, DWORD PTR [ebx+4]

; 1646 :         return _Uninitialized_move(_First, _Last, _Dest, _Getal());

	mov	edx, DWORD PTR [edi+4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1703 :     auto _UFirst      = _Get_unwrapped(_First);

	mov	DWORD PTR __UFirst$5[ebp], esi

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	DWORD PTR __Backout$2[ebp], ecx
	mov	DWORD PTR __Backout$2[ebp+4], ecx
	mov	DWORD PTR __Backout$2[ebp+8], edi
	npad	2
$LL54@Emplace_re:

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	esi, edx
	je	SHORT $LN53@Emplace_re

; 1620 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [ecx], eax

; 1621 :         ++_Last;

	add	ecx, 4
	mov	DWORD PTR __Backout$2[ebp+4], ecx

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	add	esi, 4
	mov	DWORD PTR __UFirst$5[ebp], esi
	jmp	SHORT $LL54@Emplace_re
$LN53@Emplace_re:

; 1625 :         _First = _Last;

	mov	DWORD PTR __Backout$2[ebp], ecx
$LN5@Emplace_re:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
	mov	DWORD PTR __$EHRec$[ebp+12], -1

; 1732 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [edi]
	test	eax, eax
	je	SHORT $LN68@Emplace_re
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	push	eax
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN68@Emplace_re:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1737 :         _Myfirst = _Newvec;

	mov	eax, DWORD PTR __Newvec$[ebp]
	mov	DWORD PTR [edi], eax

; 1738 :         _Mylast  = _Newvec + _Newsize;

	mov	ecx, DWORD PTR __Newsize$1$[ebp]
	lea	ecx, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR [edi+4], ecx

; 1739 :         _Myend   = _Newvec + _Newcapacity;

	mov	ecx, DWORD PTR __Newcapacity$1$[ebp]
	lea	ecx, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR [edi+8], ecx

; 790  :         _CATCH_END
; 791  : 
; 792  :         _Change_array(_Newvec, _Newsize, _Newcapacity);
; 793  :         return _Newvec + _Whereoff;

	mov	eax, ebx

; 794  :     }

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
__catch$??$_Emplace_reallocate@ABH@?$vector@HV?$xalloc@H@@@std@@QAEPAHQAHABH@Z$0:

; 785  :         }
; 786  :         _CATCH_ALL
; 787  :         _Destroy(_Constructed_first, _Constructed_last);
; 788  :         _Al.deallocate(_Newvec, _Newcapacity);

	push	ecx
	push	DWORD PTR __Newvec$[ebp]
	call	?deallocate@?$xalloc@H@@QBEXPAHI@Z	; xalloc<int>::deallocate

; 789  :         _RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$LN83@Emplace_re:

; 765  :             _Xlength();

	call	?_Xlength@?$vector@HV?$xalloc@H@@@std@@CAXXZ ; std::vector<int,xalloc<int> >::_Xlength
$LN80@Emplace_re:
	int	3
	int	3
	int	3
	int	3
	int	3
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Emplace_reallocate@ABH@?$vector@HV?$xalloc@H@@@std@@QAEPAHQAHABH@Z:
	npad	1
	npad	1
	mov	eax, OFFSET __ehfuncinfo$??$_Emplace_reallocate@ABH@?$vector@HV?$xalloc@H@@@std@@QAEPAHQAHABH@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Emplace_reallocate@ABH@?$vector@HV?$xalloc@H@@@std@@QAEPAHQAHABH@Z ENDP ; std::vector<int,xalloc<int> >::_Emplace_reallocate<int const &>
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef
;	COMDAT ??$addressof@V?$_Tree_val@U?$_Tree_simple_types@PAVNvFaceInfo@@@std@@@std@@@std@@YAPAV?$_Tree_val@U?$_Tree_simple_types@PAVNvFaceInfo@@@std@@@0@AAV10@@Z
_TEXT	SEGMENT
??$addressof@V?$_Tree_val@U?$_Tree_simple_types@PAVNvFaceInfo@@@std@@@std@@@std@@YAPAV?$_Tree_val@U?$_Tree_simple_types@PAVNvFaceInfo@@@std@@@0@AAV10@@Z PROC ; std::addressof<std::_Tree_val<std::_Tree_simple_types<NvFaceInfo *> > >, COMDAT
; __Val$ = ecx

; 253  :     return __builtin_addressof(_Val);

	mov	eax, ecx

; 254  : }

	ret	0
??$addressof@V?$_Tree_val@U?$_Tree_simple_types@PAVNvFaceInfo@@@std@@@std@@@std@@YAPAV?$_Tree_val@U?$_Tree_simple_types@PAVNvFaceInfo@@@std@@@0@AAV10@@Z ENDP ; std::addressof<std::_Tree_val<std::_Tree_simple_types<NvFaceInfo *> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$?0ABU?$less@PAVNvFaceInfo@@@std@@U_Zero_then_variadic_args_t@1@@?$_Compressed_pair@U?$less@PAVNvFaceInfo@@@std@@V?$_Compressed_pair@V?$xalloc@U?$_Tree_node@PAVNvFaceInfo@@PAX@std@@@@V?$_Tree_val@U?$_Tree_simple_types@PAVNvFaceInfo@@@std@@@std@@$00@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABU?$less@PAVNvFaceInfo@@@1@$$QAU_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
__Val1$dead$ = 12					; size = 4
_<_Val2_0>$dead$ = 16					; size = 4
??$?0ABU?$less@PAVNvFaceInfo@@@std@@U_Zero_then_variadic_args_t@1@@?$_Compressed_pair@U?$less@PAVNvFaceInfo@@@std@@V?$_Compressed_pair@V?$xalloc@U?$_Tree_node@PAVNvFaceInfo@@PAX@std@@@@V?$_Tree_val@U?$_Tree_simple_types@PAVNvFaceInfo@@@std@@@std@@$00@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABU?$less@PAVNvFaceInfo@@@1@$$QAU_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::less<NvFaceInfo *>,std::_Compressed_pair<xalloc<std::_Tree_node<NvFaceInfo *,void *> >,std::_Tree_val<std::_Tree_simple_types<NvFaceInfo *> >,1>,1>::_Compressed_pair<std::less<NvFaceInfo *>,std::_Compressed_pair<xalloc<std::_Tree_node<NvFaceInfo *,void *> >,std::_Tree_val<std::_Tree_simple_types<NvFaceInfo *> >,1>,1><std::less<NvFaceInfo *> const &,std::_Zero_then_variadic_args_t>, COMDAT
; _this$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xtree

; 435  :     _Tree_val() noexcept : _Myhead(), _Mysize(0) {}

	mov	DWORD PTR [ecx], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1336 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	eax, ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xtree

; 435  :     _Tree_val() noexcept : _Myhead(), _Mysize(0) {}

	mov	DWORD PTR [ecx+4], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1336 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	ret	12					; 0000000cH
??$?0ABU?$less@PAVNvFaceInfo@@@std@@U_Zero_then_variadic_args_t@1@@?$_Compressed_pair@U?$less@PAVNvFaceInfo@@@std@@V?$_Compressed_pair@V?$xalloc@U?$_Tree_node@PAVNvFaceInfo@@PAX@std@@@@V?$_Tree_val@U?$_Tree_simple_types@PAVNvFaceInfo@@@std@@@std@@$00@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABU?$less@PAVNvFaceInfo@@@1@$$QAU_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::less<NvFaceInfo *>,std::_Compressed_pair<xalloc<std::_Tree_node<NvFaceInfo *,void *> >,std::_Tree_val<std::_Tree_simple_types<NvFaceInfo *> >,1>,1>::_Compressed_pair<std::less<NvFaceInfo *>,std::_Compressed_pair<xalloc<std::_Tree_node<NvFaceInfo *,void *> >,std::_Tree_val<std::_Tree_simple_types<NvFaceInfo *> >,1>,1><std::less<NvFaceInfo *> const &,std::_Zero_then_variadic_args_t>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef
;	COMDAT ??$addressof@V?$_Vector_val@U?$_Simple_types@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@std@@@0@AAV10@@Z
_TEXT	SEGMENT
??$addressof@V?$_Vector_val@U?$_Simple_types@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@std@@@0@AAV10@@Z PROC ; std::addressof<std::_Vector_val<std::_Simple_types<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> > > > >, COMDAT
; __Val$ = ecx

; 253  :     return __builtin_addressof(_Val);

	mov	eax, ecx

; 254  : }

	ret	0
??$addressof@V?$_Vector_val@U?$_Simple_types@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@std@@@0@AAV10@@Z ENDP ; std::addressof<std::_Vector_val<std::_Simple_types<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> > > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$?0$$V@?$_Compressed_pair@V?$xalloc@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@@V?$_Vector_val@U?$_Simple_types@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@std@@@std@@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$?0$$V@?$_Compressed_pair@V?$xalloc@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@@V?$_Vector_val@U?$_Simple_types@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@std@@@std@@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<xalloc<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> > >,std::_Vector_val<std::_Simple_types<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> > > >,1>::_Compressed_pair<xalloc<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> > >,std::_Vector_val<std::_Simple_types<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> > > >,1><>, COMDAT
; _this$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1331 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	eax, ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1331 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	ret	4
??$?0$$V@?$_Compressed_pair@V?$xalloc@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@@V?$_Vector_val@U?$_Simple_types@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@std@@@std@@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<xalloc<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> > >,std::_Vector_val<std::_Simple_types<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> > > >,1>::_Compressed_pair<xalloc<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> > >,std::_Vector_val<std::_Simple_types<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> > > >,1><>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef
;	COMDAT ??$addressof@$$CBV?$_Vector_val@U?$_Simple_types@PAVNvStripInfo@@@std@@@std@@@std@@YAPBV?$_Vector_val@U?$_Simple_types@PAVNvStripInfo@@@std@@@0@ABV10@@Z
_TEXT	SEGMENT
??$addressof@$$CBV?$_Vector_val@U?$_Simple_types@PAVNvStripInfo@@@std@@@std@@@std@@YAPBV?$_Vector_val@U?$_Simple_types@PAVNvStripInfo@@@std@@@0@ABV10@@Z PROC ; std::addressof<std::_Vector_val<std::_Simple_types<NvStripInfo *> > const >, COMDAT
; __Val$ = ecx

; 253  :     return __builtin_addressof(_Val);

	mov	eax, ecx

; 254  : }

	ret	0
??$addressof@$$CBV?$_Vector_val@U?$_Simple_types@PAVNvStripInfo@@@std@@@std@@@std@@YAPBV?$_Vector_val@U?$_Simple_types@PAVNvStripInfo@@@std@@@0@ABV10@@Z ENDP ; std::addressof<std::_Vector_val<std::_Simple_types<NvStripInfo *> > const >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef
;	COMDAT ??$addressof@V?$_Vector_val@U?$_Simple_types@PAVNvEdgeInfo@@@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@PAVNvEdgeInfo@@@std@@@0@AAV10@@Z
_TEXT	SEGMENT
??$addressof@V?$_Vector_val@U?$_Simple_types@PAVNvEdgeInfo@@@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@PAVNvEdgeInfo@@@std@@@0@AAV10@@Z PROC ; std::addressof<std::_Vector_val<std::_Simple_types<NvEdgeInfo *> > >, COMDAT
; __Val$ = ecx

; 253  :     return __builtin_addressof(_Val);

	mov	eax, ecx

; 254  : }

	ret	0
??$addressof@V?$_Vector_val@U?$_Simple_types@PAVNvEdgeInfo@@@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@PAVNvEdgeInfo@@@std@@@0@AAV10@@Z ENDP ; std::addressof<std::_Vector_val<std::_Simple_types<NvEdgeInfo *> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$?0$$V@?$_Compressed_pair@V?$xalloc@PAVNvEdgeInfo@@@@V?$_Vector_val@U?$_Simple_types@PAVNvEdgeInfo@@@std@@@std@@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$?0$$V@?$_Compressed_pair@V?$xalloc@PAVNvEdgeInfo@@@@V?$_Vector_val@U?$_Simple_types@PAVNvEdgeInfo@@@std@@@std@@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<xalloc<NvEdgeInfo *>,std::_Vector_val<std::_Simple_types<NvEdgeInfo *> >,1>::_Compressed_pair<xalloc<NvEdgeInfo *>,std::_Vector_val<std::_Simple_types<NvEdgeInfo *> >,1><>, COMDAT
; _this$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1331 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	eax, ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1331 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	ret	4
??$?0$$V@?$_Compressed_pair@V?$xalloc@PAVNvEdgeInfo@@@@V?$_Vector_val@U?$_Simple_types@PAVNvEdgeInfo@@@std@@@std@@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<xalloc<NvEdgeInfo *>,std::_Vector_val<std::_Simple_types<NvEdgeInfo *> >,1>::_Compressed_pair<xalloc<NvEdgeInfo *>,std::_Vector_val<std::_Simple_types<NvEdgeInfo *> >,1><>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef
;	COMDAT ??$addressof@$$CBV?$_Vector_val@U?$_Simple_types@PAVNvFaceInfo@@@std@@@std@@@std@@YAPBV?$_Vector_val@U?$_Simple_types@PAVNvFaceInfo@@@std@@@0@ABV10@@Z
_TEXT	SEGMENT
??$addressof@$$CBV?$_Vector_val@U?$_Simple_types@PAVNvFaceInfo@@@std@@@std@@@std@@YAPBV?$_Vector_val@U?$_Simple_types@PAVNvFaceInfo@@@std@@@0@ABV10@@Z PROC ; std::addressof<std::_Vector_val<std::_Simple_types<NvFaceInfo *> > const >, COMDAT
; __Val$ = ecx

; 253  :     return __builtin_addressof(_Val);

	mov	eax, ecx

; 254  : }

	ret	0
??$addressof@$$CBV?$_Vector_val@U?$_Simple_types@PAVNvFaceInfo@@@std@@@std@@@std@@YAPBV?$_Vector_val@U?$_Simple_types@PAVNvFaceInfo@@@std@@@0@ABV10@@Z ENDP ; std::addressof<std::_Vector_val<std::_Simple_types<NvFaceInfo *> > const >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef
;	COMDAT ??$addressof@$$CBV?$_Vector_val@U?$_Simple_types@G@std@@@std@@@std@@YAPBV?$_Vector_val@U?$_Simple_types@G@std@@@0@ABV10@@Z
_TEXT	SEGMENT
??$addressof@$$CBV?$_Vector_val@U?$_Simple_types@G@std@@@std@@@std@@YAPBV?$_Vector_val@U?$_Simple_types@G@std@@@0@ABV10@@Z PROC ; std::addressof<std::_Vector_val<std::_Simple_types<unsigned short> > const >, COMDAT
; __Val$dead$ = ecx

; 253  :     return __builtin_addressof(_Val);

	mov	eax, OFFSET ?scratchIndices@?1??Build@NvStripInfo@@QAEXAAV?$xr_vector@PAVNvEdgeInfo@@V?$xalloc@PAVNvEdgeInfo@@@@@@AAV?$xr_vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@@@Z@4V?$xr_vector@GV?$xalloc@G@@@@A

; 254  : }

	ret	0
??$addressof@$$CBV?$_Vector_val@U?$_Simple_types@G@std@@@std@@@std@@YAPBV?$_Vector_val@U?$_Simple_types@G@std@@@0@ABV10@@Z ENDP ; std::addressof<std::_Vector_val<std::_Simple_types<unsigned short> > const >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Pocca@V?$xalloc@G@@@std@@YAXAAV?$xalloc@G@@ABV1@@Z
_TEXT	SEGMENT
??$_Pocca@V?$xalloc@G@@@std@@YAXAAV?$xalloc@G@@ABV1@@Z PROC ; std::_Pocca<xalloc<unsigned short> >, COMDAT
; __Left$dead$ = ecx
; __Right$dead$ = edx

; 877  :     if constexpr (allocator_traits<_Alloc>::propagate_on_container_copy_assignment::value) {
; 878  :         _Left = _Right;
; 879  :     }
; 880  : }

	ret	0
??$_Pocca@V?$xalloc@G@@@std@@YAXAAV?$xalloc@G@@ABV1@@Z ENDP ; std::_Pocca<xalloc<unsigned short> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xtree
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xtree
;	COMDAT ??$_Buyheadnode@V?$xalloc@U?$_Tree_node@PAVNvFaceInfo@@PAX@std@@@@@?$_Tree_node@PAVNvFaceInfo@@PAX@std@@SAPAU01@AAV?$xalloc@U?$_Tree_node@PAVNvFaceInfo@@PAX@std@@@@@Z
_TEXT	SEGMENT
??$_Buyheadnode@V?$xalloc@U?$_Tree_node@PAVNvFaceInfo@@PAX@std@@@@@?$_Tree_node@PAVNvFaceInfo@@PAX@std@@SAPAU01@AAV?$xalloc@U?$_Tree_node@PAVNvFaceInfo@@PAX@std@@@@@Z PROC ; std::_Tree_node<NvFaceInfo *,void *>::_Buyheadnode<xalloc<std::_Tree_node<NvFaceInfo *,void *> > >, COMDAT
; __Al$dead$ = ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	20					; 00000014H
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xtree

; 345  :         _Construct_in_place(_Pnode->_Left, _Pnode);

	mov	DWORD PTR [eax], eax

; 346  :         _Construct_in_place(_Pnode->_Parent, _Pnode);

	mov	DWORD PTR [eax+4], eax

; 347  :         _Construct_in_place(_Pnode->_Right, _Pnode);

	mov	DWORD PTR [eax+8], eax

; 348  :         _Pnode->_Color = _Black;

	mov	WORD PTR [eax+12], 257			; 00000101H

; 349  :         _Pnode->_Isnil = true;
; 350  :         return _Pnode;
; 351  :     }

	ret	0
??$_Buyheadnode@V?$xalloc@U?$_Tree_node@PAVNvFaceInfo@@PAX@std@@@@@?$_Tree_node@PAVNvFaceInfo@@PAX@std@@SAPAU01@AAV?$xalloc@U?$_Tree_node@PAVNvFaceInfo@@PAX@std@@@@@Z ENDP ; std::_Tree_node<NvFaceInfo *,void *>::_Buyheadnode<xalloc<std::_Tree_node<NvFaceInfo *,void *> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Destroy_range@V?$xalloc@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@@@std@@YAXPAV?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@QAV1@AAV?$xalloc@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@@@Z
_TEXT	SEGMENT
__Al$dead$ = 8						; size = 4
??$_Destroy_range@V?$xalloc@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@@@std@@YAXPAV?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@QAV1@AAV?$xalloc@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@@@Z PROC ; std::_Destroy_range<xalloc<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> > > >, COMDAT
; __First$dead$ = ecx
; __Last$dead$ = edx

; 901  :     // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
; 902  :     using _Ty = typename _Alloc::value_type;
; 903  :     if constexpr (!conjunction_v<is_trivially_destructible<_Ty>, _Uses_default_destroy<_Alloc, _Ty*>>) {
; 904  :         for (; _First != _Last; ++_First) {
; 905  :             allocator_traits<_Alloc>::destroy(_Al, _Unfancy(_First));
; 906  :         }
; 907  :     }
; 908  : }

	ret	0
??$_Destroy_range@V?$xalloc@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@@@std@@YAXPAV?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@QAV1@AAV?$xalloc@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@@@Z ENDP ; std::_Destroy_range<xalloc<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
;	COMDAT ??$xr_free@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@@YAXAAPAV?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@Z
_TEXT	SEGMENT
??$xr_free@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@@YAXAAPAV?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@Z PROC ; xr_free<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> > >, COMDAT
; _P$ = ecx

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	push	esi
	mov	esi, ecx
	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN2@xr_free
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
	mov	DWORD PTR [esi], 0
$LN2@xr_free:
	pop	esi
	ret	0
??$xr_free@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@@YAXAAPAV?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@Z ENDP ; xr_free<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Destroy_range@V?$xalloc@PAVNvEdgeInfo@@@@@std@@YAXPAPAVNvEdgeInfo@@QAPAV1@AAV?$xalloc@PAVNvEdgeInfo@@@@@Z
_TEXT	SEGMENT
__Al$dead$ = 8						; size = 4
??$_Destroy_range@V?$xalloc@PAVNvEdgeInfo@@@@@std@@YAXPAPAVNvEdgeInfo@@QAPAV1@AAV?$xalloc@PAVNvEdgeInfo@@@@@Z PROC ; std::_Destroy_range<xalloc<NvEdgeInfo *> >, COMDAT
; __First$dead$ = ecx
; __Last$dead$ = edx

; 901  :     // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
; 902  :     using _Ty = typename _Alloc::value_type;
; 903  :     if constexpr (!conjunction_v<is_trivially_destructible<_Ty>, _Uses_default_destroy<_Alloc, _Ty*>>) {
; 904  :         for (; _First != _Last; ++_First) {
; 905  :             allocator_traits<_Alloc>::destroy(_Al, _Unfancy(_First));
; 906  :         }
; 907  :     }
; 908  : }

	ret	0
??$_Destroy_range@V?$xalloc@PAVNvEdgeInfo@@@@@std@@YAXPAPAVNvEdgeInfo@@QAPAV1@AAV?$xalloc@PAVNvEdgeInfo@@@@@Z ENDP ; std::_Destroy_range<xalloc<NvEdgeInfo *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
;	COMDAT ??$xr_free@PAVNvEdgeInfo@@@@YAXAAPAPAVNvEdgeInfo@@@Z
_TEXT	SEGMENT
??$xr_free@PAVNvEdgeInfo@@@@YAXAAPAPAVNvEdgeInfo@@@Z PROC ; xr_free<NvEdgeInfo *>, COMDAT
; _P$ = ecx

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	push	esi
	mov	esi, ecx
	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN2@xr_free
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
	mov	DWORD PTR [esi], 0
$LN2@xr_free:
	pop	esi
	ret	0
??$xr_free@PAVNvEdgeInfo@@@@YAXAAPAPAVNvEdgeInfo@@@Z ENDP ; xr_free<NvEdgeInfo *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
;	COMDAT ??$xr_alloc@PAVNvFaceInfo@@@@YAPAPAVNvFaceInfo@@I@Z
_TEXT	SEGMENT
??$xr_alloc@PAVNvFaceInfo@@@@YAPAPAVNvFaceInfo@@I@Z PROC ; xr_alloc<NvFaceInfo *>, COMDAT
; _count$ = ecx

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	lea	eax, DWORD PTR [ecx*4]
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
	ret	0
??$xr_alloc@PAVNvFaceInfo@@@@YAPAPAVNvFaceInfo@@I@Z ENDP ; xr_alloc<NvFaceInfo *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Uninitialized_move@PAPAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@std@@YAPAPAVNvFaceInfo@@QAPAV1@0PAPAV1@AAV?$xalloc@PAVNvFaceInfo@@@@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Al$dead$ = 12						; size = 4
??$_Uninitialized_move@PAPAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@std@@YAPAPAVNvFaceInfo@@QAPAV1@0PAPAV1@AAV?$xalloc@PAVNvFaceInfo@@@@@Z PROC ; std::_Uninitialized_move<NvFaceInfo * *,xalloc<NvFaceInfo *> >, COMDAT
; __First$ = ecx
; __Last$ = edx

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	eax, DWORD PTR __Dest$[esp-4]

; 1699 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

	push	esi
	mov	esi, edx

; 1700 :     // move [_First, _Last) to raw _Dest, using _Al
; 1701 :     // note: only called internally from elsewhere in the STL
; 1702 :     using _Ptrval     = typename _Alloc::value_type*;
; 1703 :     auto _UFirst      = _Get_unwrapped(_First);
; 1704 :     const auto _ULast = _Get_unwrapped(_Last);
; 1705 :     if constexpr (conjunction_v<bool_constant<_Ptr_move_cat<decltype(_UFirst), _Ptrval>::_Really_trivial>,
; 1706 :                       _Uses_default_construct<_Alloc, _Ptrval, decltype(_STD move(*_UFirst))>>) {
; 1707 : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 1708 :         if (!_STD is_constant_evaluated())
; 1709 : #endif // __cpp_lib_constexpr_dynamic_alloc
; 1710 :         {
; 1711 :             _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));
; 1712 :             return _Dest + (_ULast - _UFirst);
; 1713 :         }
; 1714 :     }
; 1715 : 
; 1716 :     _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	ecx, esi
	je	SHORT $LN3@Uninitiali
	npad	5
$LL4@Uninitiali:

; 1620 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

	mov	edx, DWORD PTR [ecx]

; 1621 :         ++_Last;

	add	ecx, 4
	mov	DWORD PTR [eax], edx
	add	eax, 4

; 1700 :     // move [_First, _Last) to raw _Dest, using _Al
; 1701 :     // note: only called internally from elsewhere in the STL
; 1702 :     using _Ptrval     = typename _Alloc::value_type*;
; 1703 :     auto _UFirst      = _Get_unwrapped(_First);
; 1704 :     const auto _ULast = _Get_unwrapped(_Last);
; 1705 :     if constexpr (conjunction_v<bool_constant<_Ptr_move_cat<decltype(_UFirst), _Ptrval>::_Really_trivial>,
; 1706 :                       _Uses_default_construct<_Alloc, _Ptrval, decltype(_STD move(*_UFirst))>>) {
; 1707 : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 1708 :         if (!_STD is_constant_evaluated())
; 1709 : #endif // __cpp_lib_constexpr_dynamic_alloc
; 1710 :         {
; 1711 :             _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));
; 1712 :             return _Dest + (_ULast - _UFirst);
; 1713 :         }
; 1714 :     }
; 1715 : 
; 1716 :     _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	ecx, esi
	jne	SHORT $LL4@Uninitiali
$LN3@Uninitiali:
	pop	esi

; 1718 :         _Backout._Emplace_back(_STD move(*_UFirst));
; 1719 :     }
; 1720 : 
; 1721 :     return _Backout._Release();
; 1722 : }

	ret	0
??$_Uninitialized_move@PAPAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@std@@YAPAPAVNvFaceInfo@@QAPAV1@0PAPAV1@AAV?$xalloc@PAVNvFaceInfo@@@@@Z ENDP ; std::_Uninitialized_move<NvFaceInfo * *,xalloc<NvFaceInfo *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_Get_unwrapped@ABQAPAVNvFaceInfo@@@std@@YA?A_TABQAPAVNvFaceInfo@@@Z
_TEXT	SEGMENT
??$_Get_unwrapped@ABQAPAVNvFaceInfo@@@std@@YA?A_TABQAPAVNvFaceInfo@@@Z PROC ; std::_Get_unwrapped<NvFaceInfo * * const &>, COMDAT
; __It$ = ecx

; 1275 :     // unwrap an iterator previously subjected to _Adl_verify_range or otherwise validated
; 1276 :     if constexpr (is_pointer_v<decay_t<_Iter>>) { // special-case pointers and arrays
; 1277 :         return _It + 0;

	mov	eax, DWORD PTR [ecx]

; 1278 :     } else if constexpr (_Unwrappable_v<_Iter>) {
; 1279 :         return static_cast<_Iter&&>(_It)._Unwrapped();
; 1280 :     } else {
; 1281 :         return static_cast<_Iter&&>(_It);
; 1282 :     }
; 1283 : }

	ret	0
??$_Get_unwrapped@ABQAPAVNvFaceInfo@@@std@@YA?A_TABQAPAVNvFaceInfo@@@Z ENDP ; std::_Get_unwrapped<NvFaceInfo * * const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Release@?$_Uninitialized_backout_al@V?$xalloc@PAVNvFaceInfo@@@@@std@@QAEPAPAVNvFaceInfo@@XZ
_TEXT	SEGMENT
?_Release@?$_Uninitialized_backout_al@V?$xalloc@PAVNvFaceInfo@@@@@std@@QAEPAPAVNvFaceInfo@@XZ PROC ; std::_Uninitialized_backout_al<xalloc<NvFaceInfo *> >::_Release, COMDAT
; _this$ = ecx

; 1625 :         _First = _Last;

	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [ecx], eax

; 1626 :         return _Last;
; 1627 :     }

	ret	0
?_Release@?$_Uninitialized_backout_al@V?$xalloc@PAVNvFaceInfo@@@@@std@@QAEPAPAVNvFaceInfo@@XZ ENDP ; std::_Uninitialized_backout_al<xalloc<NvFaceInfo *> >::_Release
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??1?$_Uninitialized_backout_al@V?$xalloc@PAVNvFaceInfo@@@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Uninitialized_backout_al@V?$xalloc@PAVNvFaceInfo@@@@@std@@QAE@XZ PROC ; std::_Uninitialized_backout_al<xalloc<NvFaceInfo *> >::~_Uninitialized_backout_al<xalloc<NvFaceInfo *> >, COMDAT
; _this$ = ecx

; 1615 :         _Destroy_range(_First, _Last, _Al);
; 1616 :     }

	ret	0
??1?$_Uninitialized_backout_al@V?$xalloc@PAVNvFaceInfo@@@@@std@@QAE@XZ ENDP ; std::_Uninitialized_backout_al<xalloc<NvFaceInfo *> >::~_Uninitialized_backout_al<xalloc<NvFaceInfo *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??0?$_Uninitialized_backout_al@V?$xalloc@PAVNvFaceInfo@@@@@std@@QAE@PAPAVNvFaceInfo@@AAV?$xalloc@PAVNvFaceInfo@@@@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Al_$ = 12						; size = 4
??0?$_Uninitialized_backout_al@V?$xalloc@PAVNvFaceInfo@@@@@std@@QAE@PAPAVNvFaceInfo@@AAV?$xalloc@PAVNvFaceInfo@@@@@Z PROC ; std::_Uninitialized_backout_al<xalloc<NvFaceInfo *> >::_Uninitialized_backout_al<xalloc<NvFaceInfo *> >, COMDAT
; _this$ = ecx

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	eax, DWORD PTR __Dest$[esp-4]
	mov	DWORD PTR [ecx], eax
	mov	DWORD PTR [ecx+4], eax
	mov	eax, DWORD PTR __Al_$[esp-4]
	mov	DWORD PTR [ecx+8], eax
	mov	eax, ecx
	ret	8
??0?$_Uninitialized_backout_al@V?$xalloc@PAVNvFaceInfo@@@@@std@@QAE@PAPAVNvFaceInfo@@AAV?$xalloc@PAVNvFaceInfo@@@@@Z ENDP ; std::_Uninitialized_backout_al<xalloc<NvFaceInfo *> >::_Uninitialized_backout_al<xalloc<NvFaceInfo *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\VertexCache.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
;	COMDAT ??R?$xr_special_free@$0A@VVertexCache@@@@QAEXAAPAVVertexCache@@@Z
_TEXT	SEGMENT
_ptr$ = 8						; size = 4
??R?$xr_special_free@$0A@VVertexCache@@@@QAEXAAPAVVertexCache@@@Z PROC ; xr_special_free<0,VertexCache>::operator(), COMDAT
; _this$dead$ = ecx

; 142  : 	{

	push	ebx
	mov	ebx, DWORD PTR _ptr$[esp]
	push	esi

; 143  : 		ptr->~T			();

	mov	esi, DWORD PTR [ebx]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\VertexCache.cpp

; 18   : 	entries.clear	();

	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [esi+4], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	test	eax, eax
	je	SHORT $LN13@operator
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+4], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+8], 0
	mov	esi, DWORD PTR [ebx]
$LN13@operator:
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h

; 144  : 		Memory.mem_free	(ptr);

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	esi
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
	pop	esi
	pop	ebx

; 145  : 	}

	ret	4
??R?$xr_special_free@$0A@VVertexCache@@@@QAEXAAPAVVertexCache@@@Z ENDP ; xr_special_free<0,VertexCache>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xtree
;	COMDAT ?_Get_scary@?$_Tree@V?$_Tset_traits@PAVNvFaceInfo@@U?$less@PAVNvFaceInfo@@@std@@V?$xalloc@PAVNvFaceInfo@@@@$0A@@std@@@std@@IBEPBV?$_Tree_val@U?$_Tree_simple_types@PAVNvFaceInfo@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_scary@?$_Tree@V?$_Tset_traits@PAVNvFaceInfo@@U?$less@PAVNvFaceInfo@@@std@@V?$xalloc@PAVNvFaceInfo@@@@$0A@@std@@@std@@IBEPBV?$_Tree_val@U?$_Tree_simple_types@PAVNvFaceInfo@@@std@@@2@XZ PROC ; std::_Tree<std::_Tset_traits<NvFaceInfo *,std::less<NvFaceInfo *>,xalloc<NvFaceInfo *>,0> >::_Get_scary, COMDAT
; _this$ = ecx

; 1947 :         return _STD addressof(_Mypair._Myval2._Myval2);

	mov	eax, ecx

; 1948 :     }

	ret	0
?_Get_scary@?$_Tree@V?$_Tset_traits@PAVNvFaceInfo@@U?$less@PAVNvFaceInfo@@@std@@V?$xalloc@PAVNvFaceInfo@@@@$0A@@std@@@std@@IBEPBV?$_Tree_val@U?$_Tree_simple_types@PAVNvFaceInfo@@@std@@@2@XZ ENDP ; std::_Tree<std::_Tset_traits<NvFaceInfo *,std::less<NvFaceInfo *>,xalloc<NvFaceInfo *>,0> >::_Get_scary
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?allocate@?$xalloc@U?$_Tree_node@PAVNvFaceInfo@@PAX@std@@@@QBEPAU?$_Tree_node@PAVNvFaceInfo@@PAX@std@@IPBX@Z
_TEXT	SEGMENT
_n$dead$ = 8						; size = 4
_p$dead$ = 12						; size = 4
?allocate@?$xalloc@U?$_Tree_node@PAVNvFaceInfo@@PAX@std@@@@QBEPAU?$_Tree_node@PAVNvFaceInfo@@PAX@std@@IPBX@Z PROC ; xalloc<std::_Tree_node<NvFaceInfo *,void *> >::allocate, COMDAT
; _this$dead$ = ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	20					; 00000014H
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 80   : 							pointer					allocate		(size_type n, const void* p=0) const	{	return xr_alloc<T>((u32)n);	}

	ret	8
?allocate@?$xalloc@U?$_Tree_node@PAVNvFaceInfo@@PAX@std@@@@QBEPAU?$_Tree_node@PAVNvFaceInfo@@PAX@std@@IPBX@Z ENDP ; xalloc<std::_Tree_node<NvFaceInfo *,void *> >::allocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Vector_val@U?$_Simple_types@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<std::_Simple_types<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> > > >::_Vector_val<std::_Simple_types<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> > > >, COMDAT
; _this$ = ecx

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx], 0
	mov	eax, ecx
	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0
	ret	0
??0?$_Vector_val@U?$_Simple_types@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<std::_Simple_types<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> > > >::_Vector_val<std::_Simple_types<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Orphan_range@?$vector@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@V?$xalloc@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@@@std@@ABEXPAV?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@0@Z
_TEXT	SEGMENT
___formal$dead$ = 8					; size = 4
___formal$dead$ = 12					; size = 4
?_Orphan_range@?$vector@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@V?$xalloc@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@@@std@@ABEXPAV?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@0@Z PROC ; std::vector<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> >,xalloc<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> > > >::_Orphan_range, COMDAT
; _this$dead$ = ecx

; 1801 :     _CONSTEXPR20_CONTAINER void _Orphan_range(pointer, pointer) const {}

	ret	8
?_Orphan_range@?$vector@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@V?$xalloc@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@@@std@@ABEXPAV?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@0@Z ENDP ; std::vector<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> >,xalloc<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> > > >::_Orphan_range
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Ufill@?$vector@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@V?$xalloc@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@@@std@@AAEPAV?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@PAV3@IU_Value_init_tag@2@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Count$ = 12						; size = 4
___formal$ = 16						; size = 1
?_Ufill@?$vector@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@V?$xalloc@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@@@std@@AAEPAV?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@PAV3@IU_Value_init_tag@2@@Z PROC ; std::vector<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> >,xalloc<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> > > >::_Ufill, COMDAT
; _this$dead$ = ecx

; 1634 :         // fill raw _Dest with _Count value-initialized objects, using allocator
; 1635 :         return _Uninitialized_value_construct_n(_Dest, _Count, _Getal());

	mov	ecx, DWORD PTR __Count$[esp-4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	eax, DWORD PTR __Dest$[esp-4]

; 1813 :     for (; 0 < _Count; --_Count) {

	test	ecx, ecx
	je	SHORT $LN5@Ufill
	npad	4
$LL6@Ufill:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [eax], 0
	mov	DWORD PTR [eax+4], 0
	mov	DWORD PTR [eax+8], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1621 :         ++_Last;

	add	eax, 12					; 0000000cH

; 1813 :     for (; 0 < _Count; --_Count) {

	sub	ecx, 1
	jne	SHORT $LL6@Ufill
$LN5@Ufill:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1636 :     }

	ret	12					; 0000000cH
?_Ufill@?$vector@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@V?$xalloc@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@@@std@@AAEPAV?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@PAV3@IU_Value_init_tag@2@@Z ENDP ; std::vector<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> >,xalloc<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> > > >::_Ufill
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ??0?$xalloc@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@@QAE@XZ
_TEXT	SEGMENT
??0?$xalloc@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@@QAE@XZ PROC ; xalloc<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> > >::xalloc<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> > >, COMDAT
; _this$ = ecx

; 76   : 													xalloc			()										{	}

	mov	eax, ecx
	ret	0
??0?$xalloc@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@@QAE@XZ ENDP ; xalloc<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> > >::xalloc<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Xlength@?$vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@std@@CAXXZ PROC ; std::vector<NvStripInfo *,xalloc<NvStripInfo *> >::_Xlength, COMDAT

; 1761 :         _Xlength_error("vector too long");

	push	OFFSET ??_C@_0BA@FOIKENOD@vector?5too?5long@
	call	DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN3@Xlength:
	int	3
?_Xlength@?$vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@std@@CAXXZ ENDP ; std::vector<NvStripInfo *,xalloc<NvStripInfo *> >::_Xlength
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Change_array@?$vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@std@@AAEXQAPAVNvStripInfo@@II@Z
_TEXT	SEGMENT
__Newvec$ = 8						; size = 4
__Newsize$ = 12						; size = 4
__Newcapacity$ = 16					; size = 4
?_Change_array@?$vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@std@@AAEXQAPAVNvStripInfo@@II@Z PROC ; std::vector<NvStripInfo *,xalloc<NvStripInfo *> >::_Change_array, COMDAT
; _this$ = ecx

; 1723 :         const pointer _Newvec, const size_type _Newsize, const size_type _Newcapacity) {

	push	esi
	mov	esi, ecx

; 1724 :         // orphan all iterators, discard old array, acquire new array
; 1725 :         auto& _My_data    = _Mypair._Myval2;
; 1726 :         pointer& _Myfirst = _My_data._Myfirst;
; 1727 :         pointer& _Mylast  = _My_data._Mylast;
; 1728 :         pointer& _Myend   = _My_data._Myend;
; 1729 : 
; 1730 :         _My_data._Orphan_all();
; 1731 : 
; 1732 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN7@Change_arr
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN7@Change_arr:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1737 :         _Myfirst = _Newvec;

	mov	ecx, DWORD PTR __Newvec$[esp]

; 1738 :         _Mylast  = _Newvec + _Newsize;

	mov	eax, DWORD PTR __Newsize$[esp]
	mov	DWORD PTR [esi], ecx
	lea	eax, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR [esi+4], eax

; 1739 :         _Myend   = _Newvec + _Newcapacity;

	mov	eax, DWORD PTR __Newcapacity$[esp]
	lea	eax, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR [esi+8], eax
	pop	esi

; 1740 :     }

	ret	12					; 0000000cH
?_Change_array@?$vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@std@@AAEXQAPAVNvStripInfo@@II@Z ENDP ; std::vector<NvStripInfo *,xalloc<NvStripInfo *> >::_Change_array
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Calculate_growth@?$vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@std@@ABEII@Z
_TEXT	SEGMENT
__Newsize$ = 8						; size = 4
?_Calculate_growth@?$vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@std@@ABEII@Z PROC ; std::vector<NvStripInfo *,xalloc<NvStripInfo *> >::_Calculate_growth, COMDAT
; _this$ = ecx

; 1546 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	edx, DWORD PTR [ecx+8]
	sub	edx, DWORD PTR [ecx]

; 1671 :         // given _Oldcapacity and _Newsize, calculate geometric growth
; 1672 :         const size_type _Oldcapacity = capacity();
; 1673 :         const auto _Max              = max_size();
; 1674 : 
; 1675 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	ecx, 1073741823				; 3fffffffH

; 1546 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	sar	edx, 2

; 1670 :     _CONSTEXPR20_CONTAINER size_type _Calculate_growth(const size_type _Newsize) const {

	push	esi

; 1671 :         // given _Oldcapacity and _Newsize, calculate geometric growth
; 1672 :         const size_type _Oldcapacity = capacity();
; 1673 :         const auto _Max              = max_size();
; 1674 : 
; 1675 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	esi, edx
	shr	esi, 1
	sub	ecx, esi
	cmp	edx, ecx
	jbe	SHORT $LN2@Calculate_

; 1676 :             return _Max; // geometric growth would overflow

	mov	eax, 1073741823				; 3fffffffH
	pop	esi

; 1682 :             return _Newsize; // geometric growth would be insufficient
; 1683 :         }
; 1684 : 
; 1685 :         return _Geometric; // geometric growth is sufficient
; 1686 :     }

	ret	4
$LN2@Calculate_:

; 1677 :         }
; 1678 : 
; 1679 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	lea	eax, DWORD PTR [esi+edx]

; 1680 : 
; 1681 :         if (_Geometric < _Newsize) {

	cmp	eax, DWORD PTR __Newsize$[esp]
	pop	esi
	cmovb	eax, DWORD PTR __Newsize$[esp-4]

; 1682 :             return _Newsize; // geometric growth would be insufficient
; 1683 :         }
; 1684 : 
; 1685 :         return _Geometric; // geometric growth is sufficient
; 1686 :     }

	ret	4
?_Calculate_growth@?$vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@std@@ABEII@Z ENDP ; std::vector<NvStripInfo *,xalloc<NvStripInfo *> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Umove_if_noexcept@?$vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@std@@AAEXPAPAVNvStripInfo@@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
?_Umove_if_noexcept@?$vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@std@@AAEXPAPAVNvStripInfo@@00@Z PROC ; std::vector<NvStripInfo *,xalloc<NvStripInfo *> >::_Umove_if_noexcept, COMDAT
; _this$dead$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1703 :     auto _UFirst      = _Get_unwrapped(_First);

	mov	eax, DWORD PTR __First$[esp-4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1659 :     _CONSTEXPR20_CONTAINER void _Umove_if_noexcept(pointer _First, pointer _Last, pointer _Dest) {

	push	esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	mov	esi, DWORD PTR __Last$[esp]
	cmp	eax, esi
	je	SHORT $LN7@Umove_if_n

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	edx, DWORD PTR __Dest$[esp]
	sub	edx, eax
$LL8@Umove_if_n:

; 1620 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx+eax], ecx

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	add	eax, 4
	cmp	eax, esi
	jne	SHORT $LL8@Umove_if_n
$LN7@Umove_if_n:
	pop	esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1663 :     }

	ret	12					; 0000000cH
?_Umove_if_noexcept@?$vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@std@@AAEXPAPAVNvStripInfo@@00@Z ENDP ; std::vector<NvStripInfo *,xalloc<NvStripInfo *> >::_Umove_if_noexcept
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Umove@?$vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@std@@AAEPAPAVNvStripInfo@@PAPAV3@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
?_Umove@?$vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@std@@AAEPAPAVNvStripInfo@@PAPAV3@00@Z PROC ; std::vector<NvStripInfo *,xalloc<NvStripInfo *> >::_Umove, COMDAT
; _this$dead$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	mov	ecx, DWORD PTR __First$[esp-4]

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	eax, DWORD PTR __Dest$[esp-4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1644 :     _CONSTEXPR20_CONTAINER pointer _Umove(pointer _First, pointer _Last, pointer _Dest) {

	push	esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	mov	esi, DWORD PTR __Last$[esp]
	cmp	ecx, esi
	je	SHORT $LN5@Umove
$LL6@Umove:

; 1620 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

	mov	edx, DWORD PTR [ecx]

; 1621 :         ++_Last;

	add	ecx, 4
	mov	DWORD PTR [eax], edx
	add	eax, 4

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	ecx, esi
	jne	SHORT $LL6@Umove
$LN5@Umove:
	pop	esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1647 :     }

	ret	12					; 0000000cH
?_Umove@?$vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@std@@AAEPAPAVNvStripInfo@@PAPAV3@00@Z ENDP ; std::vector<NvStripInfo *,xalloc<NvStripInfo *> >::_Umove
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?max_size@?$vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@std@@QBEIXZ PROC ; std::vector<NvStripInfo *,xalloc<NvStripInfo *> >::max_size, COMDAT
; _this$dead$ = ecx

; 1540 :         return (_STD min)(

	mov	eax, 1073741823				; 3fffffffH

; 1541 :             static_cast<size_type>((numeric_limits<difference_type>::max)()), _Alty_traits::max_size(_Getal()));
; 1542 :     }

	ret	0
?max_size@?$vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@std@@QBEIXZ ENDP ; std::vector<NvStripInfo *,xalloc<NvStripInfo *> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@PAVNvEdgeInfo@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Vector_val@U?$_Simple_types@PAVNvEdgeInfo@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<std::_Simple_types<NvEdgeInfo *> >::_Vector_val<std::_Simple_types<NvEdgeInfo *> >, COMDAT
; _this$ = ecx

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx], 0
	mov	eax, ecx
	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0
	ret	0
??0?$_Vector_val@U?$_Simple_types@PAVNvEdgeInfo@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<std::_Simple_types<NvEdgeInfo *> >::_Vector_val<std::_Simple_types<NvEdgeInfo *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Orphan_range@?$vector@PAVNvEdgeInfo@@V?$xalloc@PAVNvEdgeInfo@@@@@std@@ABEXPAPAVNvEdgeInfo@@0@Z
_TEXT	SEGMENT
___formal$dead$ = 8					; size = 4
___formal$dead$ = 12					; size = 4
?_Orphan_range@?$vector@PAVNvEdgeInfo@@V?$xalloc@PAVNvEdgeInfo@@@@@std@@ABEXPAPAVNvEdgeInfo@@0@Z PROC ; std::vector<NvEdgeInfo *,xalloc<NvEdgeInfo *> >::_Orphan_range, COMDAT
; _this$dead$ = ecx

; 1801 :     _CONSTEXPR20_CONTAINER void _Orphan_range(pointer, pointer) const {}

	ret	8
?_Orphan_range@?$vector@PAVNvEdgeInfo@@V?$xalloc@PAVNvEdgeInfo@@@@@std@@ABEXPAPAVNvEdgeInfo@@0@Z ENDP ; std::vector<NvEdgeInfo *,xalloc<NvEdgeInfo *> >::_Orphan_range
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Ufill@?$vector@PAVNvEdgeInfo@@V?$xalloc@PAVNvEdgeInfo@@@@@std@@AAEPAPAVNvEdgeInfo@@PAPAV3@IU_Value_init_tag@2@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Count$ = 12						; size = 4
___formal$ = 16						; size = 1
?_Ufill@?$vector@PAVNvEdgeInfo@@V?$xalloc@PAVNvEdgeInfo@@@@@std@@AAEPAPAVNvEdgeInfo@@PAPAV3@IU_Value_init_tag@2@@Z PROC ; std::vector<NvEdgeInfo *,xalloc<NvEdgeInfo *> >::_Ufill, COMDAT
; _this$dead$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1807 :             _Zero_range(_PFirst, _PFirst + _Count);

	mov	eax, DWORD PTR __Count$[esp-4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1633 :     _CONSTEXPR20_CONTAINER pointer _Ufill(pointer _Dest, const size_type _Count, _Value_init_tag) {

	push	esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1792 :     _CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

	mov	esi, DWORD PTR __Dest$[esp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1633 :     _CONSTEXPR20_CONTAINER pointer _Ufill(pointer _Dest, const size_type _Count, _Value_init_tag) {

	push	edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1807 :             _Zero_range(_PFirst, _PFirst + _Count);

	lea	edi, DWORD PTR [eax*4]

; 1792 :     _CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

	push	edi
	push	0
	push	esi
	call	_memset
	add	esp, 12					; 0000000cH

; 1808 :             return _First + _Count;

	lea	eax, DWORD PTR [edi+esi]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1635 :         return _Uninitialized_value_construct_n(_Dest, _Count, _Getal());

	pop	edi
	pop	esi

; 1636 :     }

	ret	12					; 0000000cH
?_Ufill@?$vector@PAVNvEdgeInfo@@V?$xalloc@PAVNvEdgeInfo@@@@@std@@AAEPAPAVNvEdgeInfo@@PAPAV3@IU_Value_init_tag@2@@Z ENDP ; std::vector<NvEdgeInfo *,xalloc<NvEdgeInfo *> >::_Ufill
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ??0?$xalloc@PAVNvEdgeInfo@@@@QAE@XZ
_TEXT	SEGMENT
??0?$xalloc@PAVNvEdgeInfo@@@@QAE@XZ PROC		; xalloc<NvEdgeInfo *>::xalloc<NvEdgeInfo *>, COMDAT
; _this$ = ecx

; 76   : 													xalloc			()										{	}

	mov	eax, ecx
	ret	0
??0?$xalloc@PAVNvEdgeInfo@@@@QAE@XZ ENDP		; xalloc<NvEdgeInfo *>::xalloc<NvEdgeInfo *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?construct@?$xalloc@PAVNvStripInfo@@@@QAEXPAPAVNvStripInfo@@ABQAV2@@Z
_TEXT	SEGMENT
_p$ = 8							; size = 4
__Val$ = 12						; size = 4
?construct@?$xalloc@PAVNvStripInfo@@@@QAEXPAPAVNvStripInfo@@ABQAV2@@Z PROC ; xalloc<NvStripInfo *>::construct, COMDAT
; _this$dead$ = ecx

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	eax, DWORD PTR __Val$[esp-4]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR _p$[esp-4]
	mov	DWORD PTR [eax], ecx
	ret	8
?construct@?$xalloc@PAVNvStripInfo@@@@QAEXPAPAVNvStripInfo@@ABQAV2@@Z ENDP ; xalloc<NvStripInfo *>::construct
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?allocate@?$xalloc@PAVNvStripInfo@@@@QBEPAPAVNvStripInfo@@IPBX@Z
_TEXT	SEGMENT
_n$ = 8							; size = 4
_p$dead$ = 12						; size = 4
?allocate@?$xalloc@PAVNvStripInfo@@@@QBEPAPAVNvStripInfo@@IPBX@Z PROC ; xalloc<NvStripInfo *>::allocate, COMDAT
; _this$dead$ = ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	mov	eax, DWORD PTR _n$[esp-4]
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	shl	eax, 2
	push	eax
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 80   : 							pointer					allocate		(size_type n, const void* p=0) const	{	return xr_alloc<T>((u32)n);	}

	ret	8
?allocate@?$xalloc@PAVNvStripInfo@@@@QBEPAPAVNvStripInfo@@IPBX@Z ENDP ; xalloc<NvStripInfo *>::allocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Calculate_growth@?$vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@std@@ABEII@Z
_TEXT	SEGMENT
__Newsize$ = 8						; size = 4
?_Calculate_growth@?$vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@std@@ABEII@Z PROC ; std::vector<NvFaceInfo *,xalloc<NvFaceInfo *> >::_Calculate_growth, COMDAT
; _this$ = ecx

; 1546 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	edx, DWORD PTR [ecx+8]
	sub	edx, DWORD PTR [ecx]

; 1671 :         // given _Oldcapacity and _Newsize, calculate geometric growth
; 1672 :         const size_type _Oldcapacity = capacity();
; 1673 :         const auto _Max              = max_size();
; 1674 : 
; 1675 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	ecx, 1073741823				; 3fffffffH

; 1546 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	sar	edx, 2

; 1670 :     _CONSTEXPR20_CONTAINER size_type _Calculate_growth(const size_type _Newsize) const {

	push	esi

; 1671 :         // given _Oldcapacity and _Newsize, calculate geometric growth
; 1672 :         const size_type _Oldcapacity = capacity();
; 1673 :         const auto _Max              = max_size();
; 1674 : 
; 1675 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	esi, edx
	shr	esi, 1
	sub	ecx, esi
	cmp	edx, ecx
	jbe	SHORT $LN2@Calculate_

; 1676 :             return _Max; // geometric growth would overflow

	mov	eax, 1073741823				; 3fffffffH
	pop	esi

; 1682 :             return _Newsize; // geometric growth would be insufficient
; 1683 :         }
; 1684 : 
; 1685 :         return _Geometric; // geometric growth is sufficient
; 1686 :     }

	ret	4
$LN2@Calculate_:

; 1677 :         }
; 1678 : 
; 1679 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	lea	eax, DWORD PTR [esi+edx]

; 1680 : 
; 1681 :         if (_Geometric < _Newsize) {

	cmp	eax, DWORD PTR __Newsize$[esp]
	pop	esi
	cmovb	eax, DWORD PTR __Newsize$[esp-4]

; 1682 :             return _Newsize; // geometric growth would be insufficient
; 1683 :         }
; 1684 : 
; 1685 :         return _Geometric; // geometric growth is sufficient
; 1686 :     }

	ret	4
?_Calculate_growth@?$vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@std@@ABEII@Z ENDP ; std::vector<NvFaceInfo *,xalloc<NvFaceInfo *> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Umove@?$vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@std@@AAEPAPAVNvFaceInfo@@PAPAV3@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
?_Umove@?$vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@std@@AAEPAPAVNvFaceInfo@@PAPAV3@00@Z PROC ; std::vector<NvFaceInfo *,xalloc<NvFaceInfo *> >::_Umove, COMDAT
; _this$dead$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	mov	ecx, DWORD PTR __First$[esp-4]

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	eax, DWORD PTR __Dest$[esp-4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1644 :     _CONSTEXPR20_CONTAINER pointer _Umove(pointer _First, pointer _Last, pointer _Dest) {

	push	esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	mov	esi, DWORD PTR __Last$[esp]
	cmp	ecx, esi
	je	SHORT $LN5@Umove
$LL6@Umove:

; 1620 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

	mov	edx, DWORD PTR [ecx]

; 1621 :         ++_Last;

	add	ecx, 4
	mov	DWORD PTR [eax], edx
	add	eax, 4

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	ecx, esi
	jne	SHORT $LL6@Umove
$LN5@Umove:
	pop	esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1647 :     }

	ret	12					; 0000000cH
?_Umove@?$vector@PAVNvFaceInfo@@V?$xalloc@PAVNvFaceInfo@@@@@std@@AAEPAPAVNvFaceInfo@@PAPAV3@00@Z ENDP ; std::vector<NvFaceInfo *,xalloc<NvFaceInfo *> >::_Umove
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?construct@?$xalloc@PAVNvFaceInfo@@@@QAEXPAPAVNvFaceInfo@@ABQAV2@@Z
_TEXT	SEGMENT
_p$ = 8							; size = 4
__Val$ = 12						; size = 4
?construct@?$xalloc@PAVNvFaceInfo@@@@QAEXPAPAVNvFaceInfo@@ABQAV2@@Z PROC ; xalloc<NvFaceInfo *>::construct, COMDAT
; _this$dead$ = ecx

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	eax, DWORD PTR __Val$[esp-4]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR _p$[esp-4]
	mov	DWORD PTR [eax], ecx
	ret	8
?construct@?$xalloc@PAVNvFaceInfo@@@@QAEXPAPAVNvFaceInfo@@ABQAV2@@Z ENDP ; xalloc<NvFaceInfo *>::construct
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Umove@?$vector@GV?$xalloc@G@@@std@@AAEPAGPAG00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
?_Umove@?$vector@GV?$xalloc@G@@@std@@AAEPAGPAG00@Z PROC	; std::vector<unsigned short,xalloc<unsigned short> >::_Umove, COMDAT
; _this$dead$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	mov	ecx, DWORD PTR __First$[esp-4]

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	eax, DWORD PTR __Dest$[esp-4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1644 :     _CONSTEXPR20_CONTAINER pointer _Umove(pointer _First, pointer _Last, pointer _Dest) {

	push	esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	mov	esi, DWORD PTR __Last$[esp]
	cmp	ecx, esi
	je	SHORT $LN5@Umove
$LL6@Umove:

; 1620 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

	mov	dx, WORD PTR [ecx]

; 1621 :         ++_Last;

	add	ecx, 2
	mov	WORD PTR [eax], dx
	add	eax, 2

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	ecx, esi
	jne	SHORT $LL6@Umove
$LN5@Umove:
	pop	esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1647 :     }

	ret	12					; 0000000cH
?_Umove@?$vector@GV?$xalloc@G@@@std@@AAEPAGPAG00@Z ENDP	; std::vector<unsigned short,xalloc<unsigned short> >::_Umove
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Xlength@?$vector@HV?$xalloc@H@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@HV?$xalloc@H@@@std@@CAXXZ PROC	; std::vector<int,xalloc<int> >::_Xlength, COMDAT

; 1761 :         _Xlength_error("vector too long");

	push	OFFSET ??_C@_0BA@FOIKENOD@vector?5too?5long@
	call	DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN3@Xlength:
	int	3
?_Xlength@?$vector@HV?$xalloc@H@@@std@@CAXXZ ENDP	; std::vector<int,xalloc<int> >::_Xlength
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Change_array@?$vector@HV?$xalloc@H@@@std@@AAEXQAHII@Z
_TEXT	SEGMENT
__Newvec$ = 8						; size = 4
__Newsize$ = 12						; size = 4
__Newcapacity$ = 16					; size = 4
?_Change_array@?$vector@HV?$xalloc@H@@@std@@AAEXQAHII@Z PROC ; std::vector<int,xalloc<int> >::_Change_array, COMDAT
; _this$ = ecx

; 1723 :         const pointer _Newvec, const size_type _Newsize, const size_type _Newcapacity) {

	push	esi
	mov	esi, ecx

; 1724 :         // orphan all iterators, discard old array, acquire new array
; 1725 :         auto& _My_data    = _Mypair._Myval2;
; 1726 :         pointer& _Myfirst = _My_data._Myfirst;
; 1727 :         pointer& _Mylast  = _My_data._Mylast;
; 1728 :         pointer& _Myend   = _My_data._Myend;
; 1729 : 
; 1730 :         _My_data._Orphan_all();
; 1731 : 
; 1732 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN7@Change_arr
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN7@Change_arr:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1737 :         _Myfirst = _Newvec;

	mov	ecx, DWORD PTR __Newvec$[esp]

; 1738 :         _Mylast  = _Newvec + _Newsize;

	mov	eax, DWORD PTR __Newsize$[esp]
	mov	DWORD PTR [esi], ecx
	lea	eax, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR [esi+4], eax

; 1739 :         _Myend   = _Newvec + _Newcapacity;

	mov	eax, DWORD PTR __Newcapacity$[esp]
	lea	eax, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR [esi+8], eax
	pop	esi

; 1740 :     }

	ret	12					; 0000000cH
?_Change_array@?$vector@HV?$xalloc@H@@@std@@AAEXQAHII@Z ENDP ; std::vector<int,xalloc<int> >::_Change_array
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Calculate_growth@?$vector@HV?$xalloc@H@@@std@@ABEII@Z
_TEXT	SEGMENT
__Newsize$ = 8						; size = 4
?_Calculate_growth@?$vector@HV?$xalloc@H@@@std@@ABEII@Z PROC ; std::vector<int,xalloc<int> >::_Calculate_growth, COMDAT
; _this$ = ecx

; 1546 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	edx, DWORD PTR [ecx+8]
	sub	edx, DWORD PTR [ecx]

; 1671 :         // given _Oldcapacity and _Newsize, calculate geometric growth
; 1672 :         const size_type _Oldcapacity = capacity();
; 1673 :         const auto _Max              = max_size();
; 1674 : 
; 1675 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	ecx, 1073741823				; 3fffffffH

; 1546 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	sar	edx, 2

; 1670 :     _CONSTEXPR20_CONTAINER size_type _Calculate_growth(const size_type _Newsize) const {

	push	esi

; 1671 :         // given _Oldcapacity and _Newsize, calculate geometric growth
; 1672 :         const size_type _Oldcapacity = capacity();
; 1673 :         const auto _Max              = max_size();
; 1674 : 
; 1675 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	esi, edx
	shr	esi, 1
	sub	ecx, esi
	cmp	edx, ecx
	jbe	SHORT $LN2@Calculate_

; 1676 :             return _Max; // geometric growth would overflow

	mov	eax, 1073741823				; 3fffffffH
	pop	esi

; 1682 :             return _Newsize; // geometric growth would be insufficient
; 1683 :         }
; 1684 : 
; 1685 :         return _Geometric; // geometric growth is sufficient
; 1686 :     }

	ret	4
$LN2@Calculate_:

; 1677 :         }
; 1678 : 
; 1679 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	lea	eax, DWORD PTR [esi+edx]

; 1680 : 
; 1681 :         if (_Geometric < _Newsize) {

	cmp	eax, DWORD PTR __Newsize$[esp]
	pop	esi
	cmovb	eax, DWORD PTR __Newsize$[esp-4]

; 1682 :             return _Newsize; // geometric growth would be insufficient
; 1683 :         }
; 1684 : 
; 1685 :         return _Geometric; // geometric growth is sufficient
; 1686 :     }

	ret	4
?_Calculate_growth@?$vector@HV?$xalloc@H@@@std@@ABEII@Z ENDP ; std::vector<int,xalloc<int> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Umove_if_noexcept@?$vector@HV?$xalloc@H@@@std@@AAEXPAH00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
?_Umove_if_noexcept@?$vector@HV?$xalloc@H@@@std@@AAEXPAH00@Z PROC ; std::vector<int,xalloc<int> >::_Umove_if_noexcept, COMDAT
; _this$dead$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1703 :     auto _UFirst      = _Get_unwrapped(_First);

	mov	eax, DWORD PTR __First$[esp-4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1659 :     _CONSTEXPR20_CONTAINER void _Umove_if_noexcept(pointer _First, pointer _Last, pointer _Dest) {

	push	esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	mov	esi, DWORD PTR __Last$[esp]
	cmp	eax, esi
	je	SHORT $LN7@Umove_if_n

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	edx, DWORD PTR __Dest$[esp]
	sub	edx, eax
$LL8@Umove_if_n:

; 1620 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx+eax], ecx

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	add	eax, 4
	cmp	eax, esi
	jne	SHORT $LL8@Umove_if_n
$LN7@Umove_if_n:
	pop	esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1663 :     }

	ret	12					; 0000000cH
?_Umove_if_noexcept@?$vector@HV?$xalloc@H@@@std@@AAEXPAH00@Z ENDP ; std::vector<int,xalloc<int> >::_Umove_if_noexcept
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Umove@?$vector@HV?$xalloc@H@@@std@@AAEPAHPAH00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
?_Umove@?$vector@HV?$xalloc@H@@@std@@AAEPAHPAH00@Z PROC	; std::vector<int,xalloc<int> >::_Umove, COMDAT
; _this$dead$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	mov	ecx, DWORD PTR __First$[esp-4]

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	eax, DWORD PTR __Dest$[esp-4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1644 :     _CONSTEXPR20_CONTAINER pointer _Umove(pointer _First, pointer _Last, pointer _Dest) {

	push	esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	mov	esi, DWORD PTR __Last$[esp]
	cmp	ecx, esi
	je	SHORT $LN5@Umove
$LL6@Umove:

; 1620 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

	mov	edx, DWORD PTR [ecx]

; 1621 :         ++_Last;

	add	ecx, 4
	mov	DWORD PTR [eax], edx
	add	eax, 4

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	ecx, esi
	jne	SHORT $LL6@Umove
$LN5@Umove:
	pop	esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1647 :     }

	ret	12					; 0000000cH
?_Umove@?$vector@HV?$xalloc@H@@@std@@AAEPAHPAH00@Z ENDP	; std::vector<int,xalloc<int> >::_Umove
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?max_size@?$vector@HV?$xalloc@H@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@HV?$xalloc@H@@@std@@QBEIXZ PROC	; std::vector<int,xalloc<int> >::max_size, COMDAT
; _this$dead$ = ecx

; 1540 :         return (_STD min)(

	mov	eax, 1073741823				; 3fffffffH

; 1541 :             static_cast<size_type>((numeric_limits<difference_type>::max)()), _Alty_traits::max_size(_Getal()));
; 1542 :     }

	ret	0
?max_size@?$vector@HV?$xalloc@H@@@std@@QBEIXZ ENDP	; std::vector<int,xalloc<int> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?construct@?$xalloc@H@@QAEXPAHABH@Z
_TEXT	SEGMENT
_p$ = 8							; size = 4
__Val$ = 12						; size = 4
?construct@?$xalloc@H@@QAEXPAHABH@Z PROC		; xalloc<int>::construct, COMDAT
; _this$dead$ = ecx

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	eax, DWORD PTR __Val$[esp-4]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR _p$[esp-4]
	mov	DWORD PTR [eax], ecx
	ret	8
?construct@?$xalloc@H@@QAEXPAHABH@Z ENDP		; xalloc<int>::construct
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?allocate@?$xalloc@H@@QBEPAHIPBX@Z
_TEXT	SEGMENT
_n$ = 8							; size = 4
_p$dead$ = 12						; size = 4
?allocate@?$xalloc@H@@QBEPAHIPBX@Z PROC			; xalloc<int>::allocate, COMDAT
; _this$dead$ = ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	mov	eax, DWORD PTR _n$[esp-4]
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	shl	eax, 2
	push	eax
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 80   : 							pointer					allocate		(size_type n, const void* p=0) const	{	return xr_alloc<T>((u32)n);	}

	ret	8
?allocate@?$xalloc@H@@QBEPAHIPBX@Z ENDP			; xalloc<int>::allocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\VertexCache.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??_GVertexCache@@QAEPAXI@Z
_TEXT	SEGMENT
___flags$dead$ = 8					; size = 4
??_GVertexCache@@QAEPAXI@Z PROC				; VertexCache::`scalar deleting destructor', COMDAT
; _this$ = ecx
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\VertexCache.cpp

; 18   : 	entries.clear	();

	push	esi
	mov	esi, ecx
	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [esi+4], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	test	eax, eax
	je	SHORT $LN18@scalar
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+4], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+8], 0
$LN18@scalar:
	mov	eax, esi
	pop	esi
	ret	4
??_GVertexCache@@QAEPAXI@Z ENDP				; VertexCache::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Getal@?$vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@std@@ABEABV?$xalloc@PAVNvStripInfo@@@@XZ
_TEXT	SEGMENT
?_Getal@?$vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@std@@ABEABV?$xalloc@PAVNvStripInfo@@@@XZ PROC ; std::vector<NvStripInfo *,xalloc<NvStripInfo *> >::_Getal, COMDAT
; _this$ = ecx

; 1809 :         return _Mypair._Get_first();

	mov	eax, ecx

; 1810 :     }

	ret	0
?_Getal@?$vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@std@@ABEABV?$xalloc@PAVNvStripInfo@@@@XZ ENDP ; std::vector<NvStripInfo *,xalloc<NvStripInfo *> >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Umove_if_noexcept1@?$vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@std@@AAEXPAPAVNvStripInfo@@00U?$integral_constant@_N$00@2@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
?_Umove_if_noexcept1@?$vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@std@@AAEXPAPAVNvStripInfo@@00U?$integral_constant@_N$00@2@@Z PROC ; std::vector<NvStripInfo *,xalloc<NvStripInfo *> >::_Umove_if_noexcept1, COMDAT
; _this$dead$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1703 :     auto _UFirst      = _Get_unwrapped(_First);

	mov	eax, DWORD PTR __First$[esp-4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1649 :     _CONSTEXPR20_CONTAINER void _Umove_if_noexcept1(pointer _First, pointer _Last, pointer _Dest, true_type) {

	push	esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	mov	esi, DWORD PTR __Last$[esp]
	cmp	eax, esi
	je	SHORT $LN5@Umove_if_n

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	edx, DWORD PTR __Dest$[esp]
	sub	edx, eax
$LL6@Umove_if_n:

; 1620 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx+eax], ecx

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	add	eax, 4
	cmp	eax, esi
	jne	SHORT $LL6@Umove_if_n
$LN5@Umove_if_n:
	pop	esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1652 :     }

	ret	16					; 00000010H
?_Umove_if_noexcept1@?$vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@std@@AAEXPAPAVNvStripInfo@@00U?$integral_constant@_N$00@2@@Z ENDP ; std::vector<NvStripInfo *,xalloc<NvStripInfo *> >::_Umove_if_noexcept1
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?capacity@?$vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@std@@QBEIXZ PROC ; std::vector<NvStripInfo *,xalloc<NvStripInfo *> >::capacity, COMDAT
; _this$ = ecx

; 1545 :         auto& _My_data = _Mypair._Myval2;
; 1546 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx]
	sar	eax, 2

; 1547 :     }

	ret	0
?capacity@?$vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@std@@QBEIXZ ENDP ; std::vector<NvStripInfo *,xalloc<NvStripInfo *> >::capacity
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?max_size@?$_Normal_allocator_traits@V?$xalloc@PAVNvStripInfo@@@@@std@@SAIABV?$xalloc@PAVNvStripInfo@@@@@Z
_TEXT	SEGMENT
?max_size@?$_Normal_allocator_traits@V?$xalloc@PAVNvStripInfo@@@@@std@@SAIABV?$xalloc@PAVNvStripInfo@@@@@Z PROC ; std::_Normal_allocator_traits<xalloc<NvStripInfo *> >::max_size, COMDAT
; __Al$dead$ = ecx

; 591  :         if constexpr (_Has_max_size<_Alloc>::value) {
; 592  :             return _Al.max_size();

	mov	eax, 1073741823				; 3fffffffH

; 593  :         } else {
; 594  :             return (numeric_limits<size_type>::max)() / sizeof(value_type);
; 595  :         }
; 596  :     }

	ret	0
?max_size@?$_Normal_allocator_traits@V?$xalloc@PAVNvStripInfo@@@@@std@@SAIABV?$xalloc@PAVNvStripInfo@@@@@Z ENDP ; std::_Normal_allocator_traits<xalloc<NvStripInfo *> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Getal@?$vector@HV?$xalloc@H@@@std@@ABEABV?$xalloc@H@@XZ
_TEXT	SEGMENT
?_Getal@?$vector@HV?$xalloc@H@@@std@@ABEABV?$xalloc@H@@XZ PROC ; std::vector<int,xalloc<int> >::_Getal, COMDAT
; _this$ = ecx

; 1809 :         return _Mypair._Get_first();

	mov	eax, ecx

; 1810 :     }

	ret	0
?_Getal@?$vector@HV?$xalloc@H@@@std@@ABEABV?$xalloc@H@@XZ ENDP ; std::vector<int,xalloc<int> >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Umove_if_noexcept1@?$vector@HV?$xalloc@H@@@std@@AAEXPAH00U?$integral_constant@_N$00@2@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
?_Umove_if_noexcept1@?$vector@HV?$xalloc@H@@@std@@AAEXPAH00U?$integral_constant@_N$00@2@@Z PROC ; std::vector<int,xalloc<int> >::_Umove_if_noexcept1, COMDAT
; _this$dead$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1703 :     auto _UFirst      = _Get_unwrapped(_First);

	mov	eax, DWORD PTR __First$[esp-4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1649 :     _CONSTEXPR20_CONTAINER void _Umove_if_noexcept1(pointer _First, pointer _Last, pointer _Dest, true_type) {

	push	esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	mov	esi, DWORD PTR __Last$[esp]
	cmp	eax, esi
	je	SHORT $LN5@Umove_if_n

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	edx, DWORD PTR __Dest$[esp]
	sub	edx, eax
$LL6@Umove_if_n:

; 1620 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx+eax], ecx

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	add	eax, 4
	cmp	eax, esi
	jne	SHORT $LL6@Umove_if_n
$LN5@Umove_if_n:
	pop	esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1652 :     }

	ret	16					; 00000010H
?_Umove_if_noexcept1@?$vector@HV?$xalloc@H@@@std@@AAEXPAH00U?$integral_constant@_N$00@2@@Z ENDP ; std::vector<int,xalloc<int> >::_Umove_if_noexcept1
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?capacity@?$vector@HV?$xalloc@H@@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@HV?$xalloc@H@@@std@@QBEIXZ PROC	; std::vector<int,xalloc<int> >::capacity, COMDAT
; _this$ = ecx

; 1545 :         auto& _My_data = _Mypair._Myval2;
; 1546 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx]
	sar	eax, 2

; 1547 :     }

	ret	0
?capacity@?$vector@HV?$xalloc@H@@@std@@QBEIXZ ENDP	; std::vector<int,xalloc<int> >::capacity
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?max_size@?$_Normal_allocator_traits@V?$xalloc@H@@@std@@SAIABV?$xalloc@H@@@Z
_TEXT	SEGMENT
?max_size@?$_Normal_allocator_traits@V?$xalloc@H@@@std@@SAIABV?$xalloc@H@@@Z PROC ; std::_Normal_allocator_traits<xalloc<int> >::max_size, COMDAT
; __Al$dead$ = ecx

; 591  :         if constexpr (_Has_max_size<_Alloc>::value) {
; 592  :             return _Al.max_size();

	mov	eax, 1073741823				; 3fffffffH

; 593  :         } else {
; 594  :             return (numeric_limits<size_type>::max)() / sizeof(value_type);
; 595  :         }
; 596  :     }

	ret	0
?max_size@?$_Normal_allocator_traits@V?$xalloc@H@@@std@@SAIABV?$xalloc@H@@@Z ENDP ; std::_Normal_allocator_traits<xalloc<int> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$xalloc@PAVNvStripInfo@@@@V?$_Vector_val@U?$_Simple_types@PAVNvStripInfo@@@std@@@std@@$00@std@@QBEABV?$xalloc@PAVNvStripInfo@@@@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@V?$xalloc@PAVNvStripInfo@@@@V?$_Vector_val@U?$_Simple_types@PAVNvStripInfo@@@std@@@std@@$00@std@@QBEABV?$xalloc@PAVNvStripInfo@@@@XZ PROC ; std::_Compressed_pair<xalloc<NvStripInfo *>,std::_Vector_val<std::_Simple_types<NvStripInfo *> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 1343 :         return *this;

	mov	eax, ecx

; 1344 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$xalloc@PAVNvStripInfo@@@@V?$_Vector_val@U?$_Simple_types@PAVNvStripInfo@@@std@@@std@@$00@std@@QBEABV?$xalloc@PAVNvStripInfo@@@@XZ ENDP ; std::_Compressed_pair<xalloc<NvStripInfo *>,std::_Vector_val<std::_Simple_types<NvStripInfo *> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?max_size@?$xalloc@PAVNvStripInfo@@@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$xalloc@PAVNvStripInfo@@@@QBEIXZ PROC	; xalloc<NvStripInfo *>::max_size, COMDAT
; _this$dead$ = ecx

; 86   : 							size_type				max_size		() const								{	size_type _Count = (size_type)(-1) / sizeof (T);	return (0 < _Count ? _Count : 1);	}

	mov	eax, 1073741823				; 3fffffffH
	ret	0
?max_size@?$xalloc@PAVNvStripInfo@@@@QBEIXZ ENDP	; xalloc<NvStripInfo *>::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$xalloc@H@@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@$00@std@@QBEABV?$xalloc@H@@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@V?$xalloc@H@@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@$00@std@@QBEABV?$xalloc@H@@XZ PROC ; std::_Compressed_pair<xalloc<int>,std::_Vector_val<std::_Simple_types<int> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 1343 :         return *this;

	mov	eax, ecx

; 1344 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$xalloc@H@@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@$00@std@@QBEABV?$xalloc@H@@XZ ENDP ; std::_Compressed_pair<xalloc<int>,std::_Vector_val<std::_Simple_types<int> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?max_size@?$xalloc@H@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$xalloc@H@@QBEIXZ PROC			; xalloc<int>::max_size, COMDAT
; _this$dead$ = ecx

; 86   : 							size_type				max_size		() const								{	size_type _Count = (size_type)(-1) / sizeof (T);	return (0 < _Count ? _Count : 1);	}

	mov	eax, 1073741823				; 3fffffffH
	ret	0
?max_size@?$xalloc@H@@QBEIXZ ENDP			; xalloc<int>::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$?0$$V@?$_Compressed_pair@V?$xalloc@U?$_Tree_node@PAVNvFaceInfo@@PAX@std@@@@V?$_Tree_val@U?$_Tree_simple_types@PAVNvFaceInfo@@@std@@@std@@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$?0$$V@?$_Compressed_pair@V?$xalloc@U?$_Tree_node@PAVNvFaceInfo@@PAX@std@@@@V?$_Tree_val@U?$_Tree_simple_types@PAVNvFaceInfo@@@std@@@std@@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<xalloc<std::_Tree_node<NvFaceInfo *,void *> >,std::_Tree_val<std::_Tree_simple_types<NvFaceInfo *> >,1>::_Compressed_pair<xalloc<std::_Tree_node<NvFaceInfo *,void *> >,std::_Tree_val<std::_Tree_simple_types<NvFaceInfo *> >,1><>, COMDAT
; _this$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xtree

; 435  :     _Tree_val() noexcept : _Myhead(), _Mysize(0) {}

	mov	DWORD PTR [ecx], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1331 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	eax, ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xtree

; 435  :     _Tree_val() noexcept : _Myhead(), _Mysize(0) {}

	mov	DWORD PTR [ecx+4], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1331 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	ret	4
??$?0$$V@?$_Compressed_pair@V?$xalloc@U?$_Tree_node@PAVNvFaceInfo@@PAX@std@@@@V?$_Tree_val@U?$_Tree_simple_types@PAVNvFaceInfo@@@std@@@std@@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<xalloc<std::_Tree_node<NvFaceInfo *,void *> >,std::_Tree_val<std::_Tree_simple_types<NvFaceInfo *> >,1>::_Compressed_pair<xalloc<std::_Tree_node<NvFaceInfo *,void *> >,std::_Tree_val<std::_Tree_simple_types<NvFaceInfo *> >,1><>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xtree
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xtree
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xtree
;	COMDAT ??$_Emplace@ABQAVNvFaceInfo@@@?$_Tree@V?$_Tset_traits@PAVNvFaceInfo@@U?$less@PAVNvFaceInfo@@@std@@V?$xalloc@PAVNvFaceInfo@@@@$0A@@std@@@std@@IAE?AU?$pair@PAU?$_Tree_node@PAVNvFaceInfo@@PAX@std@@_N@1@ABQAVNvFaceInfo@@@Z
_TEXT	SEGMENT
$T2 = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Loc$3$ = 12						; size = 4
_<_Vals_0>$ = 12					; size = 4
??$_Emplace@ABQAVNvFaceInfo@@@?$_Tree@V?$_Tset_traits@PAVNvFaceInfo@@U?$less@PAVNvFaceInfo@@@std@@V?$xalloc@PAVNvFaceInfo@@@@$0A@@std@@@std@@IAE?AU?$pair@PAU?$_Tree_node@PAVNvFaceInfo@@PAX@std@@_N@1@ABQAVNvFaceInfo@@@Z PROC ; std::_Tree<std::_Tset_traits<NvFaceInfo *,std::less<NvFaceInfo *>,xalloc<NvFaceInfo *>,0> >::_Emplace<NvFaceInfo * const &>, COMDAT
; _this$ = ecx

; 999  :     pair<_Nodeptr, bool> _Emplace(_Valtys&&... _Vals) {

	sub	esp, 12					; 0000000cH
	push	ebx

; 1000 :         using _In_place_key_extractor = typename _Traits::template _In_place_key_extractor<_Remove_cvref_t<_Valtys>...>;
; 1001 :         const auto _Scary             = _Get_scary();
; 1002 :         _Tree_find_result<_Nodeptr> _Loc;
; 1003 :         _Nodeptr _Inserted;
; 1004 :         if constexpr (!_Multi && _In_place_key_extractor::_Extractable) {
; 1005 :             const auto& _Keyval = _In_place_key_extractor::_Extract(_Vals...);
; 1006 :             _Loc                = _Find_lower_bound(_Keyval);

	mov	ebx, DWORD PTR _<_Vals_0>$[esp+12]
	lea	eax, DWORD PTR $T2[esp+16]
	push	ebp
	push	esi
	push	edi
	push	ebx
	push	eax
	mov	edi, ecx
	call	??$_Find_lower_bound@PAVNvFaceInfo@@@?$_Tree@V?$_Tset_traits@PAVNvFaceInfo@@U?$less@PAVNvFaceInfo@@@std@@V?$xalloc@PAVNvFaceInfo@@@@$0A@@std@@@std@@IBE?AU?$_Tree_find_result@PAU?$_Tree_node@PAVNvFaceInfo@@PAX@std@@@1@ABQAVNvFaceInfo@@@Z ; std::_Tree<std::_Tset_traits<NvFaceInfo *,std::less<NvFaceInfo *>,xalloc<NvFaceInfo *>,0> >::_Find_lower_bound<NvFaceInfo *>
	mov	ecx, DWORD PTR [eax+4]
	mov	ebp, DWORD PTR [eax]
	mov	DWORD PTR __Loc$3$[esp+24], ecx
	mov	ecx, DWORD PTR [eax+8]

; 1591 :         return !_Bound->_Isnil && !_DEBUG_LT_PRED(_Getcomp(), _Keyval, _Traits::_Kfn(_Bound->_Myval));

	cmp	BYTE PTR [ecx+13], 0
	jne	SHORT $LN2@Emplace
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef

; 117  :         return _Left < _Right;

	mov	eax, DWORD PTR [ebx]
	cmp	eax, DWORD PTR [ecx+16]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xtree

; 1591 :         return !_Bound->_Isnil && !_DEBUG_LT_PRED(_Getcomp(), _Keyval, _Traits::_Kfn(_Bound->_Myval));

	jb	SHORT $LN2@Emplace
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 186  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

	mov	eax, DWORD PTR ___$ReturnUdt$[esp+24]
	mov	DWORD PTR [eax], ecx
	mov	BYTE PTR [eax+4], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xtree

; 1032 :     }

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 12					; 0000000cH
	ret	8
$LN2@Emplace:

; 1615 :         if (max_size() == _Get_scary()->_Mysize) {

	cmp	DWORD PTR [edi+4], 214748364		; 0cccccccH
	je	SHORT $LN52@Emplace
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xtree

; 1012 :             _Inserted = _Tree_temp_node<_Alnode>(_Getal(), _Scary->_Myhead, _STD forward<_Valtys>(_Vals)...)._Release();

	mov	esi, DWORD PTR [edi]
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	push	20					; 00000014H
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xtree

; 805  :         _Alnode_traits::construct(this->_Al, _STD addressof(this->_Ptr->_Myval), _STD forward<_Valtys>(_Vals)...);

	mov	ecx, DWORD PTR [ebx]

; 1031 :         return {_Scary->_Insert_node(_Loc._Location, _Inserted), true};

	push	eax
	push	DWORD PTR __Loc$3$[esp+28]

; 805  :         _Alnode_traits::construct(this->_Al, _STD addressof(this->_Ptr->_Myval), _STD forward<_Valtys>(_Vals)...);

	mov	DWORD PTR [eax+16], ecx

; 1031 :         return {_Scary->_Insert_node(_Loc._Location, _Inserted), true};

	mov	ecx, edi

; 806  :         _Construct_in_place(this->_Ptr->_Left, _Myhead);

	mov	DWORD PTR [eax], esi

; 807  :         _Construct_in_place(this->_Ptr->_Parent, _Myhead);

	mov	DWORD PTR [eax+4], esi

; 808  :         _Construct_in_place(this->_Ptr->_Right, _Myhead);

	mov	DWORD PTR [eax+8], esi

; 1031 :         return {_Scary->_Insert_node(_Loc._Location, _Inserted), true};

	push	ebp

; 809  :         this->_Ptr->_Color = _Red;

	mov	WORD PTR [eax+12], 0

; 1031 :         return {_Scary->_Insert_node(_Loc._Location, _Inserted), true};

	call	?_Insert_node@?$_Tree_val@U?$_Tree_simple_types@PAVNvFaceInfo@@@std@@@std@@QAEPAU?$_Tree_node@PAVNvFaceInfo@@PAX@2@U?$_Tree_id@PAU?$_Tree_node@PAVNvFaceInfo@@PAX@std@@@2@QAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<NvFaceInfo *> >::_Insert_node
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 186  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

	mov	ecx, DWORD PTR ___$ReturnUdt$[esp+24]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xtree

; 1032 :     }

	pop	edi
	pop	esi
	pop	ebp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 186  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

	mov	DWORD PTR [ecx], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xtree

; 1031 :         return {_Scary->_Insert_node(_Loc._Location, _Inserted), true};

	mov	eax, ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 186  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

	mov	BYTE PTR [ecx+4], 1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xtree

; 1032 :     }

	pop	ebx
	add	esp, 12					; 0000000cH
	ret	8
$LN52@Emplace:

; 1616 :             _Throw_tree_length_error();

	call	?_Throw_tree_length_error@std@@YAXXZ	; std::_Throw_tree_length_error
$LN50@Emplace:
	int	3
??$_Emplace@ABQAVNvFaceInfo@@@?$_Tree@V?$_Tset_traits@PAVNvFaceInfo@@U?$less@PAVNvFaceInfo@@@std@@V?$xalloc@PAVNvFaceInfo@@@@$0A@@std@@@std@@IAE?AU?$pair@PAU?$_Tree_node@PAVNvFaceInfo@@PAX@std@@_N@1@ABQAVNvFaceInfo@@@Z ENDP ; std::_Tree<std::_Tset_traits<NvFaceInfo *,std::less<NvFaceInfo *>,xalloc<NvFaceInfo *>,0> >::_Emplace<NvFaceInfo * const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
;	COMDAT ??$?0V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@PAVNvFaceInfo@@@std@@@std@@@std@@AB_N$0A@@?$pair@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@PAVNvFaceInfo@@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@PAVNvFaceInfo@@@std@@@std@@@1@AB_N@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??$?0V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@PAVNvFaceInfo@@@std@@@std@@@std@@AB_N$0A@@?$pair@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@PAVNvFaceInfo@@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@PAVNvFaceInfo@@@std@@@std@@@1@AB_N@Z PROC ; std::pair<std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<NvFaceInfo *> > >,bool>::pair<std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<NvFaceInfo *> > >,bool><std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<NvFaceInfo *> > >,bool const &,0>, COMDAT
; _this$ = ecx

; 186  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

	mov	eax, DWORD PTR __Val1$[esp-4]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR __Val2$[esp-4]
	mov	al, BYTE PTR [eax]
	mov	BYTE PTR [ecx+4], al
	mov	eax, ecx
	ret	8
??$?0V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@PAVNvFaceInfo@@@std@@@std@@@std@@AB_N$0A@@?$pair@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@PAVNvFaceInfo@@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@PAVNvFaceInfo@@@std@@@std@@@1@AB_N@Z ENDP ; std::pair<std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<NvFaceInfo *> > >,bool>::pair<std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<NvFaceInfo *> > >,bool><std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<NvFaceInfo *> > >,bool const &,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xtree
;	COMDAT ??$_Find_lower_bound@PAVNvFaceInfo@@@?$_Tree@V?$_Tset_traits@PAVNvFaceInfo@@U?$less@PAVNvFaceInfo@@@std@@V?$xalloc@PAVNvFaceInfo@@@@$0A@@std@@@std@@IBE?AU?$_Tree_find_result@PAU?$_Tree_node@PAVNvFaceInfo@@PAX@std@@@1@ABQAVNvFaceInfo@@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Keyval$ = 12						; size = 4
??$_Find_lower_bound@PAVNvFaceInfo@@@?$_Tree@V?$_Tset_traits@PAVNvFaceInfo@@U?$less@PAVNvFaceInfo@@@std@@V?$xalloc@PAVNvFaceInfo@@@@$0A@@std@@@std@@IBE?AU?$_Tree_find_result@PAU?$_Tree_node@PAVNvFaceInfo@@PAX@std@@@1@ABQAVNvFaceInfo@@@Z PROC ; std::_Tree<std::_Tset_traits<NvFaceInfo *,std::less<NvFaceInfo *>,xalloc<NvFaceInfo *>,0> >::_Find_lower_bound<NvFaceInfo *>, COMDAT
; _this$ = ecx

; 1596 :         const auto _Scary = _Get_scary();
; 1597 :         _Tree_find_result<_Nodeptr> _Result{{_Scary->_Myhead->_Parent, _Tree_child::_Right}, _Scary->_Myhead};

	mov	ecx, DWORD PTR [ecx]
	mov	edx, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx], eax
	mov	DWORD PTR [edx+4], 0
	mov	DWORD PTR [edx+8], ecx

; 1598 :         _Nodeptr _Trynode = _Result._Location._Parent;
; 1599 :         while (!_Trynode->_Isnil) {

	cmp	BYTE PTR [eax+13], 0
	jne	SHORT $LN12@Find_lower
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef

; 117  :         return _Left < _Right;

	mov	ecx, DWORD PTR __Keyval$[esp-4]
	push	esi
	mov	esi, DWORD PTR [ecx]
$LL2@Find_lower:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xtree

; 1600 :             _Result._Location._Parent = _Trynode;

	mov	DWORD PTR [edx], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef

; 117  :         return _Left < _Right;

	cmp	DWORD PTR [eax+16], esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xtree

; 1601 :             if (_DEBUG_LT_PRED(_Getcomp(), _Traits::_Kfn(_Trynode->_Myval), _Keyval)) {

	jae	SHORT $LN4@Find_lower

; 1602 :                 _Result._Location._Child = _Tree_child::_Right;
; 1603 :                 _Trynode                 = _Trynode->_Right;

	mov	eax, DWORD PTR [eax+8]
	xor	ecx, ecx

; 1604 :             } else {

	jmp	SHORT $LN5@Find_lower
$LN4@Find_lower:

; 1605 :                 _Result._Location._Child = _Tree_child::_Left;
; 1606 :                 _Result._Bound           = _Trynode;

	mov	DWORD PTR [edx+8], eax

; 1607 :                 _Trynode                 = _Trynode->_Left;

	mov	ecx, 1
	mov	eax, DWORD PTR [eax]
$LN5@Find_lower:

; 1598 :         _Nodeptr _Trynode = _Result._Location._Parent;
; 1599 :         while (!_Trynode->_Isnil) {

	mov	DWORD PTR [edx+4], ecx
	cmp	BYTE PTR [eax+13], 0
	je	SHORT $LL2@Find_lower

; 1608 :             }
; 1609 :         }
; 1610 : 
; 1611 :         return _Result;

	pop	esi
$LN12@Find_lower:

; 1612 :     }

	mov	eax, edx
	ret	8
??$_Find_lower_bound@PAVNvFaceInfo@@@?$_Tree@V?$_Tset_traits@PAVNvFaceInfo@@U?$less@PAVNvFaceInfo@@@std@@V?$xalloc@PAVNvFaceInfo@@@@$0A@@std@@@std@@IBE?AU?$_Tree_find_result@PAU?$_Tree_node@PAVNvFaceInfo@@PAX@std@@@1@ABQAVNvFaceInfo@@@Z ENDP ; std::_Tree<std::_Tset_traits<NvFaceInfo *,std::less<NvFaceInfo *>,xalloc<NvFaceInfo *>,0> >::_Find_lower_bound<NvFaceInfo *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xtree
;	COMDAT ??$_Lower_bound_duplicate@PAVNvFaceInfo@@@?$_Tree@V?$_Tset_traits@PAVNvFaceInfo@@U?$less@PAVNvFaceInfo@@@std@@V?$xalloc@PAVNvFaceInfo@@@@$0A@@std@@@std@@IBE_NQAU?$_Tree_node@PAVNvFaceInfo@@PAX@1@ABQAVNvFaceInfo@@@Z
_TEXT	SEGMENT
__Bound$ = 8						; size = 4
__Keyval$ = 12						; size = 4
??$_Lower_bound_duplicate@PAVNvFaceInfo@@@?$_Tree@V?$_Tset_traits@PAVNvFaceInfo@@U?$less@PAVNvFaceInfo@@@std@@V?$xalloc@PAVNvFaceInfo@@@@$0A@@std@@@std@@IBE_NQAU?$_Tree_node@PAVNvFaceInfo@@PAX@1@ABQAVNvFaceInfo@@@Z PROC ; std::_Tree<std::_Tset_traits<NvFaceInfo *,std::less<NvFaceInfo *>,xalloc<NvFaceInfo *>,0> >::_Lower_bound_duplicate<NvFaceInfo *>, COMDAT
; _this$dead$ = ecx

; 1591 :         return !_Bound->_Isnil && !_DEBUG_LT_PRED(_Getcomp(), _Keyval, _Traits::_Kfn(_Bound->_Myval));

	mov	ecx, DWORD PTR __Bound$[esp-4]
	cmp	BYTE PTR [ecx+13], 0
	jne	SHORT $LN3@Lower_boun
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef

; 117  :         return _Left < _Right;

	mov	eax, DWORD PTR __Keyval$[esp-4]
	mov	eax, DWORD PTR [eax]
	cmp	eax, DWORD PTR [ecx+16]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xtree

; 1591 :         return !_Bound->_Isnil && !_DEBUG_LT_PRED(_Getcomp(), _Keyval, _Traits::_Kfn(_Bound->_Myval));

	jb	SHORT $LN3@Lower_boun
	mov	al, 1

; 1592 :     }

	ret	8
$LN3@Lower_boun:

; 1591 :         return !_Bound->_Isnil && !_DEBUG_LT_PRED(_Getcomp(), _Keyval, _Traits::_Kfn(_Bound->_Myval));

	xor	al, al

; 1592 :     }

	ret	8
??$_Lower_bound_duplicate@PAVNvFaceInfo@@@?$_Tree@V?$_Tset_traits@PAVNvFaceInfo@@U?$less@PAVNvFaceInfo@@@std@@V?$xalloc@PAVNvFaceInfo@@@@$0A@@std@@@std@@IBE_NQAU?$_Tree_node@PAVNvFaceInfo@@PAX@1@ABQAVNvFaceInfo@@@Z ENDP ; std::_Tree<std::_Tset_traits<NvFaceInfo *,std::less<NvFaceInfo *>,xalloc<NvFaceInfo *>,0> >::_Lower_bound_duplicate<NvFaceInfo *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xtree
;	COMDAT ??$_Erase_tree@V?$xalloc@U?$_Tree_node@PAVNvFaceInfo@@PAX@std@@@@@?$_Tree_val@U?$_Tree_simple_types@PAVNvFaceInfo@@@std@@@std@@QAEXAAV?$xalloc@U?$_Tree_node@PAVNvFaceInfo@@PAX@std@@@@PAU?$_Tree_node@PAVNvFaceInfo@@PAX@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Rootnode$ = 12					; size = 4
??$_Erase_tree@V?$xalloc@U?$_Tree_node@PAVNvFaceInfo@@PAX@std@@@@@?$_Tree_val@U?$_Tree_simple_types@PAVNvFaceInfo@@@std@@@std@@QAEXAAV?$xalloc@U?$_Tree_node@PAVNvFaceInfo@@PAX@std@@@@PAU?$_Tree_node@PAVNvFaceInfo@@PAX@1@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<NvFaceInfo *> >::_Erase_tree<xalloc<std::_Tree_node<NvFaceInfo *,void *> > >, COMDAT
; _this$ = ecx

; 742  :     void _Erase_tree(_Alnode& _Al, _Nodeptr _Rootnode) noexcept {

	push	ebx
	push	esi

; 743  :         while (!_Rootnode->_Isnil) { // free subtrees, then node

	mov	esi, DWORD PTR __Rootnode$[esp+4]
	mov	ebx, ecx
	cmp	BYTE PTR [esi+13], 0
	jne	SHORT $LN3@Erase_tree
	push	ebp
	mov	ebp, DWORD PTR __Al$[esp+8]
	push	edi
	mov	edi, DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
	npad	6
$LL2@Erase_tree:

; 744  :             _Erase_tree(_Al, _Rootnode->_Right);

	push	DWORD PTR [esi+8]
	mov	ecx, ebx
	push	ebp
	call	??$_Erase_tree@V?$xalloc@U?$_Tree_node@PAVNvFaceInfo@@PAX@std@@@@@?$_Tree_val@U?$_Tree_simple_types@PAVNvFaceInfo@@@std@@@std@@QAEXAAV?$xalloc@U?$_Tree_node@PAVNvFaceInfo@@PAX@std@@@@PAU?$_Tree_node@PAVNvFaceInfo@@PAX@1@@Z ; std::_Tree_val<std::_Tree_simple_types<NvFaceInfo *> >::_Erase_tree<xalloc<std::_Tree_node<NvFaceInfo *,void *> > >
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 602  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	eax, esi

; 603  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	esi, DWORD PTR [esi]
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	test	eax, eax
	je	SHORT $LN285@Erase_tree
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	edi
$LN285@Erase_tree:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xtree

; 743  :         while (!_Rootnode->_Isnil) { // free subtrees, then node

	cmp	BYTE PTR [esi+13], 0
	je	SHORT $LL2@Erase_tree
	pop	edi
	pop	ebp
$LN3@Erase_tree:
	pop	esi

; 745  :             _Alnode::value_type::_Freenode(_Al, _STD exchange(_Rootnode, _Rootnode->_Left));
; 746  :         }
; 747  :     }

	pop	ebx
	ret	8
??$_Erase_tree@V?$xalloc@U?$_Tree_node@PAVNvFaceInfo@@PAX@std@@@@@?$_Tree_val@U?$_Tree_simple_types@PAVNvFaceInfo@@@std@@@std@@QAEXAAV?$xalloc@U?$_Tree_node@PAVNvFaceInfo@@PAX@std@@@@PAU?$_Tree_node@PAVNvFaceInfo@@PAX@1@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<NvFaceInfo *> >::_Erase_tree<xalloc<std::_Tree_node<NvFaceInfo *,void *> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xtree
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xtree
;	COMDAT ??$_Freenode0@V?$xalloc@U?$_Tree_node@PAVNvFaceInfo@@PAX@std@@@@@?$_Tree_node@PAVNvFaceInfo@@PAX@std@@SAXAAV?$xalloc@U?$_Tree_node@PAVNvFaceInfo@@PAX@std@@@@PAU01@@Z
_TEXT	SEGMENT
??$_Freenode0@V?$xalloc@U?$_Tree_node@PAVNvFaceInfo@@PAX@std@@@@@?$_Tree_node@PAVNvFaceInfo@@PAX@std@@SAXAAV?$xalloc@U?$_Tree_node@PAVNvFaceInfo@@PAX@std@@@@PAU01@@Z PROC ; std::_Tree_node<NvFaceInfo *,void *>::_Freenode0<xalloc<std::_Tree_node<NvFaceInfo *,void *> > >, COMDAT
; __Al$dead$ = ecx
; __Ptr$ = edx
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	test	edx, edx
	je	SHORT $LN8@Freenode0
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	edx
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN8@Freenode0:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xtree

; 375  :     }

	ret	0
??$_Freenode0@V?$xalloc@U?$_Tree_node@PAVNvFaceInfo@@PAX@std@@@@@?$_Tree_node@PAVNvFaceInfo@@PAX@std@@SAXAAV?$xalloc@U?$_Tree_node@PAVNvFaceInfo@@PAX@std@@@@PAU01@@Z ENDP ; std::_Tree_node<NvFaceInfo *,void *>::_Freenode0<xalloc<std::_Tree_node<NvFaceInfo *,void *> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@V?$xalloc@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@@@std@@AAEXIABU_Value_init_tag@1@@Z
_TEXT	SEGMENT
__Newvec$ = -28						; size = 4
tv262 = -24						; size = 4
__Oldsize$1$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Newsize$dead$ = 8					; size = 4
__Val$ = 12						; size = 4
??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@V?$xalloc@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@@@std@@AAEXIABU_Value_init_tag@1@@Z PROC ; std::vector<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> >,xalloc<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> > > >::_Resize_reallocate<std::_Value_init_tag>, COMDAT
; _this$ = ecx

; 1216 :     _CONSTEXPR20_CONTAINER void _Resize_reallocate(const size_type _Newsize, const _Ty2& _Val) {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@V?$xalloc@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@@@std@@AAEXIABU_Value_init_tag@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 16					; 00000010H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	esi, ecx

; 1217 :         if (_Newsize > max_size()) {
; 1218 :             _Xlength();
; 1219 :         }
; 1220 : 
; 1221 :         auto& _My_data    = _Mypair._Myval2;
; 1222 :         pointer& _Myfirst = _My_data._Myfirst;
; 1223 :         pointer& _Mylast  = _My_data._Mylast;
; 1224 : 
; 1225 :         const auto _Oldsize          = static_cast<size_type>(_Mylast - _Myfirst);

	mov	eax, DWORD PTR [esi+4]
	sub	eax, DWORD PTR [esi]
	sar	eax, 2
	imul	eax, eax, -1431655765
	mov	DWORD PTR __Oldsize$1$[ebp], eax

; 1546 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	eax, DWORD PTR [esi+8]
	sub	eax, DWORD PTR [esi]
	sar	eax, 2
	imul	edx, eax, -1431655765

; 1675 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	ecx, edx
	shr	ecx, 1
	mov	eax, 357913941				; 15555555H
	sub	eax, ecx
	mov	ebx, 60					; 0000003cH
	cmp	edx, eax
	jbe	SHORT $LN10@Resize_rea

; 1676 :             return _Max; // geometric growth would overflow

	mov	eax, 357913941				; 15555555H
	jmp	SHORT $LN11@Resize_rea
$LN10@Resize_rea:

; 1677 :         }
; 1678 : 
; 1679 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	lea	eax, DWORD PTR [ecx+edx]

; 1680 : 
; 1681 :         if (_Geometric < _Newsize) {

	cmp	eax, 60					; 0000003cH
	cmovb	eax, ebx
$LN11@Resize_rea:
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	lea	eax, DWORD PTR [eax+eax*2]
	shl	eax, 2
	mov	DWORD PTR tv262[ebp], eax
	push	eax
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1228 :         const pointer _Newvec         = _Getal().allocate(_Newcapacity);

	mov	edi, eax
	mov	DWORD PTR __Newvec$[ebp], edi

; 1229 :         const pointer _Appended_first = _Newvec + _Oldsize;

	mov	edx, DWORD PTR __Oldsize$1$[ebp]
	lea	ecx, DWORD PTR [edx+edx*2]
	lea	ecx, DWORD PTR [edi+ecx*4]

; 1230 :         pointer _Appended_last        = _Appended_first;
; 1231 : 
; 1232 :         _TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 1233 :         _Appended_last = _Ufill(_Appended_first, _Newsize - _Oldsize, _Val);

	mov	eax, DWORD PTR __Val$[ebp]
	movzx	eax, BYTE PTR [eax]
	push	eax
	sub	ebx, edx
	push	ebx
	push	ecx
	call	?_Ufill@?$vector@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@V?$xalloc@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@@@std@@AAEPAV?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@PAV3@IU_Value_init_tag@2@@Z ; std::vector<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> >,xalloc<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> > > >::_Ufill

; 1234 :         _Umove_if_noexcept(_Myfirst, _Mylast, _Newvec);

	push	edi
	push	DWORD PTR [esi+4]
	push	DWORD PTR [esi]
	call	?_Umove_if_noexcept@?$vector@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@V?$xalloc@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@@@std@@AAEXPAV?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@00@Z ; std::vector<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> >,xalloc<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> > > >::_Umove_if_noexcept
	mov	DWORD PTR __$EHRec$[ebp+12], -1

; 1732 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN25@Resize_rea
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	push	eax
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN25@Resize_rea:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1737 :         _Myfirst = _Newvec;

	mov	DWORD PTR [esi], edi

; 1738 :         _Mylast  = _Newvec + _Newsize;

	lea	eax, DWORD PTR [edi+720]
	mov	DWORD PTR [esi+4], eax

; 1739 :         _Myend   = _Newvec + _Newcapacity;

	mov	eax, DWORD PTR tv262[ebp]
	add	eax, edi
	mov	DWORD PTR [esi+8], eax

; 1239 :         _CATCH_END
; 1240 : 
; 1241 :         _Change_array(_Newvec, _Newsize, _Newcapacity);
; 1242 :     }

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
__catch$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@V?$xalloc@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@@@std@@AAEXIABU_Value_init_tag@1@@Z$0:

; 1235 :         _CATCH_ALL
; 1236 :         _Destroy(_Appended_first, _Appended_last);
; 1237 :         _Getal().deallocate(_Newvec, _Newcapacity);

	push	ecx
	push	DWORD PTR __Newvec$[ebp]
	call	?deallocate@?$xalloc@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@@QBEXPAV?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@I@Z ; xalloc<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> > >::deallocate

; 1238 :         _RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$LN28@Resize_rea:
	int	3
	int	3
	int	3
	int	3
	int	3
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@V?$xalloc@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@@@std@@AAEXIABU_Value_init_tag@1@@Z:
	npad	1
	npad	1
	mov	eax, OFFSET __ehfuncinfo$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@V?$xalloc@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@@@std@@AAEXIABU_Value_init_tag@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@V?$xalloc@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@@@std@@AAEXIABU_Value_init_tag@1@@Z ENDP ; std::vector<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> >,xalloc<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> > > >::_Resize_reallocate<std::_Value_init_tag>
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@PAVNvEdgeInfo@@V?$xalloc@PAVNvEdgeInfo@@@@@std@@AAEXIABU_Value_init_tag@1@@Z
_TEXT	SEGMENT
__Backout$2 = -40					; size = 12
__Newvec$ = -28						; size = 4
__UFirst$3 = -24					; size = 4
__Newcapacity$1$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Newsize$ = 8						; size = 4
__Val$dead$ = 12					; size = 4
??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@PAVNvEdgeInfo@@V?$xalloc@PAVNvEdgeInfo@@@@@std@@AAEXIABU_Value_init_tag@1@@Z PROC ; std::vector<NvEdgeInfo *,xalloc<NvEdgeInfo *> >::_Resize_reallocate<std::_Value_init_tag>, COMDAT
; _this$ = ecx

; 1216 :     _CONSTEXPR20_CONTAINER void _Resize_reallocate(const size_type _Newsize, const _Ty2& _Val) {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@PAVNvEdgeInfo@@V?$xalloc@PAVNvEdgeInfo@@@@@std@@AAEXIABU_Value_init_tag@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 28					; 0000001cH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	esi, ecx

; 1217 :         if (_Newsize > max_size()) {

	mov	edx, DWORD PTR __Newsize$[ebp]
	cmp	edx, 1073741823				; 3fffffffH
	ja	$LN66@Resize_rea

; 1219 :         }
; 1220 : 
; 1221 :         auto& _My_data    = _Mypair._Myval2;
; 1222 :         pointer& _Myfirst = _My_data._Myfirst;
; 1223 :         pointer& _Mylast  = _My_data._Mylast;
; 1224 : 
; 1225 :         const auto _Oldsize          = static_cast<size_type>(_Mylast - _Myfirst);

	mov	edi, DWORD PTR [esi+4]
	sub	edi, DWORD PTR [esi]
	sar	edi, 2

; 1546 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	ecx, DWORD PTR [esi+8]
	sub	ecx, DWORD PTR [esi]
	sar	ecx, 2

; 1675 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	ebx, ecx
	shr	ebx, 1
	mov	eax, 1073741823				; 3fffffffH
	sub	eax, ebx
	cmp	ecx, eax
	jbe	SHORT $LN10@Resize_rea

; 1676 :             return _Max; // geometric growth would overflow

	mov	eax, 1073741823				; 3fffffffH
	jmp	SHORT $LN64@Resize_rea
$LN10@Resize_rea:

; 1677 :         }
; 1678 : 
; 1679 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	lea	eax, DWORD PTR [ebx+ecx]

; 1680 : 
; 1681 :         if (_Geometric < _Newsize) {

	cmp	eax, edx
	cmovb	eax, edx
$LN64@Resize_rea:
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	mov	DWORD PTR __Newcapacity$1$[ebp], eax
	shl	eax, 2
	push	eax
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1228 :         const pointer _Newvec         = _Getal().allocate(_Newcapacity);

	mov	ebx, eax
	mov	DWORD PTR __Newvec$[ebp], ebx

; 1229 :         const pointer _Appended_first = _Newvec + _Oldsize;

	lea	ecx, DWORD PTR [ebx+edi*4]

; 1230 :         pointer _Appended_last        = _Appended_first;
; 1231 : 
; 1232 :         _TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 1233 :         _Appended_last = _Ufill(_Appended_first, _Newsize - _Oldsize, _Val);

	mov	eax, DWORD PTR __Newsize$[ebp]
	sub	eax, edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1807 :             _Zero_range(_PFirst, _PFirst + _Count);

	shl	eax, 2

; 1792 :     _CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

	push	eax
	push	0
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1234 :         _Umove_if_noexcept(_Myfirst, _Mylast, _Newvec);

	mov	edi, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1703 :     auto _UFirst      = _Get_unwrapped(_First);

	mov	DWORD PTR __UFirst$3[ebp], ecx

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	DWORD PTR __Backout$2[ebp], ebx
	mov	edx, ebx
	mov	DWORD PTR __Backout$2[ebp+4], edx
	mov	DWORD PTR __Backout$2[ebp+8], esi
	npad	7
$LL43@Resize_rea:

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	ecx, edi
	je	SHORT $LN42@Resize_rea

; 1620 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax

; 1621 :         ++_Last;

	add	edx, 4
	mov	DWORD PTR __Backout$2[ebp+4], edx

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	add	ecx, 4
	mov	DWORD PTR __UFirst$3[ebp], ecx
	jmp	SHORT $LL43@Resize_rea
$LN42@Resize_rea:

; 1625 :         _First = _Last;

	mov	DWORD PTR __Backout$2[ebp], edx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
	mov	DWORD PTR __$EHRec$[ebp+12], -1

; 1732 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN57@Resize_rea
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	push	eax
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN57@Resize_rea:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1737 :         _Myfirst = _Newvec;

	mov	DWORD PTR [esi], ebx

; 1738 :         _Mylast  = _Newvec + _Newsize;

	mov	eax, DWORD PTR __Newsize$[ebp]
	lea	eax, DWORD PTR [ebx+eax*4]
	mov	DWORD PTR [esi+4], eax

; 1739 :         _Myend   = _Newvec + _Newcapacity;

	mov	eax, DWORD PTR __Newcapacity$1$[ebp]
	lea	eax, DWORD PTR [ebx+eax*4]
	mov	DWORD PTR [esi+8], eax

; 1239 :         _CATCH_END
; 1240 : 
; 1241 :         _Change_array(_Newvec, _Newsize, _Newcapacity);
; 1242 :     }

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
__catch$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@PAVNvEdgeInfo@@V?$xalloc@PAVNvEdgeInfo@@@@@std@@AAEXIABU_Value_init_tag@1@@Z$0:

; 1235 :         _CATCH_ALL
; 1236 :         _Destroy(_Appended_first, _Appended_last);
; 1237 :         _Getal().deallocate(_Newvec, _Newcapacity);

	push	ecx
	push	DWORD PTR __Newvec$[ebp]
	call	?deallocate@?$xalloc@PAVNvEdgeInfo@@@@QBEXPAPAVNvEdgeInfo@@I@Z ; xalloc<NvEdgeInfo *>::deallocate

; 1238 :         _RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$LN66@Resize_rea:

; 1218 :             _Xlength();

	call	?_Xlength@?$vector@PAVNvEdgeInfo@@V?$xalloc@PAVNvEdgeInfo@@@@@std@@CAXXZ ; std::vector<NvEdgeInfo *,xalloc<NvEdgeInfo *> >::_Xlength
$LN63@Resize_rea:
	int	3
	int	3
	int	3
	int	3
	int	3
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@PAVNvEdgeInfo@@V?$xalloc@PAVNvEdgeInfo@@@@@std@@AAEXIABU_Value_init_tag@1@@Z:
	npad	1
	npad	1
	mov	eax, OFFSET __ehfuncinfo$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@PAVNvEdgeInfo@@V?$xalloc@PAVNvEdgeInfo@@@@@std@@AAEXIABU_Value_init_tag@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@PAVNvEdgeInfo@@V?$xalloc@PAVNvEdgeInfo@@@@@std@@AAEXIABU_Value_init_tag@1@@Z ENDP ; std::vector<NvEdgeInfo *,xalloc<NvEdgeInfo *> >::_Resize_reallocate<std::_Value_init_tag>
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\type_traits
;	COMDAT ??$forward@ABU?$less@PAVNvFaceInfo@@@std@@@std@@YAABU?$less@PAVNvFaceInfo@@@0@ABU10@@Z
_TEXT	SEGMENT
??$forward@ABU?$less@PAVNvFaceInfo@@@std@@@std@@YAABU?$less@PAVNvFaceInfo@@@0@ABU10@@Z PROC ; std::forward<std::less<NvFaceInfo *> const &>, COMDAT
; __Arg$ = ecx

; 1386 :     return static_cast<_Ty&&>(_Arg);

	mov	eax, ecx

; 1387 : }

	ret	0
??$forward@ABU?$less@PAVNvFaceInfo@@@std@@@std@@YAABU?$less@PAVNvFaceInfo@@@0@ABU10@@Z ENDP ; std::forward<std::less<NvFaceInfo *> const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_Construct_in_place@PAU?$_Tree_node@PAVNvFaceInfo@@PAX@std@@ABQAU12@@std@@YAXAAPAU?$_Tree_node@PAVNvFaceInfo@@PAX@0@ABQAU10@@Z
_TEXT	SEGMENT
??$_Construct_in_place@PAU?$_Tree_node@PAVNvFaceInfo@@PAX@std@@ABQAU12@@std@@YAXAAPAU?$_Tree_node@PAVNvFaceInfo@@PAX@0@ABQAU10@@Z PROC ; std::_Construct_in_place<std::_Tree_node<NvFaceInfo *,void *> *,std::_Tree_node<NvFaceInfo *,void *> * const &>, COMDAT
; __Obj$ = ecx
; _<_Args_0>$ = edx

; 143  : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 144  :     if (_STD is_constant_evaluated()) {
; 145  :         _STD construct_at(_STD addressof(_Obj), _STD forward<_Types>(_Args)...);
; 146  :     } else
; 147  : #endif // __cpp_lib_constexpr_dynamic_alloc
; 148  :     {
; 149  :         ::new (_Voidify_iter(_STD addressof(_Obj))) _Ty(_STD forward<_Types>(_Args)...);

	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax

; 150  :     }
; 151  : }

	ret	0
??$_Construct_in_place@PAU?$_Tree_node@PAVNvFaceInfo@@PAX@std@@ABQAU12@@std@@YAXAAPAU?$_Tree_node@PAVNvFaceInfo@@PAX@0@ABQAU10@@Z ENDP ; std::_Construct_in_place<std::_Tree_node<NvFaceInfo *,void *> *,std::_Tree_node<NvFaceInfo *,void *> * const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef
;	COMDAT ??$_Unfancy@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@std@@YAPAV?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@PAV1@@Z
_TEXT	SEGMENT
??$_Unfancy@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@std@@YAPAV?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@PAV1@@Z PROC ; std::_Unfancy<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> > >, COMDAT
; __Ptr$ = ecx

; 266  :     return _Ptr;

	mov	eax, ecx

; 267  : }

	ret	0
??$_Unfancy@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@std@@YAPAV?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@PAV1@@Z ENDP ; std::_Unfancy<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$destroy@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@?$_Normal_allocator_traits@V?$xalloc@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@@@std@@SAXAAV?$xalloc@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@@PAV?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@Z
_TEXT	SEGMENT
??$destroy@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@?$_Normal_allocator_traits@V?$xalloc@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@@@std@@SAXAAV?$xalloc@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@@PAV?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@Z PROC ; std::_Normal_allocator_traits<xalloc<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> > > >::destroy<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> > >, COMDAT
; __Al$dead$ = ecx
; __Ptr$dead$ = edx

; 579  :         if constexpr (_Uses_default_destroy<_Alloc, _Ty*>::value) {
; 580  : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 581  :             _STD destroy_at(_Ptr);
; 582  : #else // __cpp_lib_constexpr_dynamic_alloc
; 583  :             _Ptr->~_Ty();
; 584  : #endif // __cpp_lib_constexpr_dynamic_alloc
; 585  :         } else {
; 586  :             _Al.destroy(_Ptr);
; 587  :         }
; 588  :     }

	ret	0
??$destroy@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@?$_Normal_allocator_traits@V?$xalloc@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@@@std@@SAXAAV?$xalloc@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@@PAV?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@Z ENDP ; std::_Normal_allocator_traits<xalloc<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> > > >::destroy<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef
;	COMDAT ??$_Unfancy@PAVNvEdgeInfo@@@std@@YAPAPAVNvEdgeInfo@@PAPAV1@@Z
_TEXT	SEGMENT
??$_Unfancy@PAVNvEdgeInfo@@@std@@YAPAPAVNvEdgeInfo@@PAPAV1@@Z PROC ; std::_Unfancy<NvEdgeInfo *>, COMDAT
; __Ptr$ = ecx

; 266  :     return _Ptr;

	mov	eax, ecx

; 267  : }

	ret	0
??$_Unfancy@PAVNvEdgeInfo@@@std@@YAPAPAVNvEdgeInfo@@PAPAV1@@Z ENDP ; std::_Unfancy<NvEdgeInfo *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$destroy@PAVNvEdgeInfo@@@?$_Normal_allocator_traits@V?$xalloc@PAVNvEdgeInfo@@@@@std@@SAXAAV?$xalloc@PAVNvEdgeInfo@@@@PAPAVNvEdgeInfo@@@Z
_TEXT	SEGMENT
??$destroy@PAVNvEdgeInfo@@@?$_Normal_allocator_traits@V?$xalloc@PAVNvEdgeInfo@@@@@std@@SAXAAV?$xalloc@PAVNvEdgeInfo@@@@PAPAVNvEdgeInfo@@@Z PROC ; std::_Normal_allocator_traits<xalloc<NvEdgeInfo *> >::destroy<NvEdgeInfo *>, COMDAT
; __Al$dead$ = ecx
; __Ptr$dead$ = edx

; 579  :         if constexpr (_Uses_default_destroy<_Alloc, _Ty*>::value) {
; 580  : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 581  :             _STD destroy_at(_Ptr);
; 582  : #else // __cpp_lib_constexpr_dynamic_alloc
; 583  :             _Ptr->~_Ty();
; 584  : #endif // __cpp_lib_constexpr_dynamic_alloc
; 585  :         } else {
; 586  :             _Al.destroy(_Ptr);
; 587  :         }
; 588  :     }

	ret	0
??$destroy@PAVNvEdgeInfo@@@?$_Normal_allocator_traits@V?$xalloc@PAVNvEdgeInfo@@@@@std@@SAXAAV?$xalloc@PAVNvEdgeInfo@@@@PAPAVNvEdgeInfo@@@Z ENDP ; std::_Normal_allocator_traits<xalloc<NvEdgeInfo *> >::destroy<NvEdgeInfo *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\type_traits
;	COMDAT ??$move@AAPAVNvFaceInfo@@@std@@YA$$QAPAVNvFaceInfo@@AAPAV1@@Z
_TEXT	SEGMENT
??$move@AAPAVNvFaceInfo@@@std@@YA$$QAPAVNvFaceInfo@@AAPAV1@@Z PROC ; std::move<NvFaceInfo * &>, COMDAT
; __Arg$ = ecx

; 1397 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

	mov	eax, ecx

; 1398 : }

	ret	0
??$move@AAPAVNvFaceInfo@@@std@@YA$$QAPAVNvFaceInfo@@AAPAV1@@Z ENDP ; std::move<NvFaceInfo * &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Emplace_back@PAVNvFaceInfo@@@?$_Uninitialized_backout_al@V?$xalloc@PAVNvFaceInfo@@@@@std@@QAEX$$QAPAVNvFaceInfo@@@Z
_TEXT	SEGMENT
_<_Vals_0>$ = 8						; size = 4
??$_Emplace_back@PAVNvFaceInfo@@@?$_Uninitialized_backout_al@V?$xalloc@PAVNvFaceInfo@@@@@std@@QAEX$$QAPAVNvFaceInfo@@@Z PROC ; std::_Uninitialized_backout_al<xalloc<NvFaceInfo *> >::_Emplace_back<NvFaceInfo *>, COMDAT
; _this$ = ecx

; 1620 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _<_Vals_0>$[esp-4]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edx], eax

; 1621 :         ++_Last;

	add	DWORD PTR [ecx+4], 4

; 1622 :     }

	ret	4
??$_Emplace_back@PAVNvFaceInfo@@@?$_Uninitialized_backout_al@V?$xalloc@PAVNvFaceInfo@@@@@std@@QAEX$$QAPAVNvFaceInfo@@@Z ENDP ; std::_Uninitialized_backout_al<xalloc<NvFaceInfo *> >::_Emplace_back<NvFaceInfo *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef
;	COMDAT ??$addressof@$$CBV?$_Tree_val@U?$_Tree_simple_types@PAVNvFaceInfo@@@std@@@std@@@std@@YAPBV?$_Tree_val@U?$_Tree_simple_types@PAVNvFaceInfo@@@std@@@0@ABV10@@Z
_TEXT	SEGMENT
??$addressof@$$CBV?$_Tree_val@U?$_Tree_simple_types@PAVNvFaceInfo@@@std@@@std@@@std@@YAPBV?$_Tree_val@U?$_Tree_simple_types@PAVNvFaceInfo@@@std@@@0@ABV10@@Z PROC ; std::addressof<std::_Tree_val<std::_Tree_simple_types<NvFaceInfo *> > const >, COMDAT
; __Val$ = ecx

; 253  :     return __builtin_addressof(_Val);

	mov	eax, ecx

; 254  : }

	ret	0
??$addressof@$$CBV?$_Tree_val@U?$_Tree_simple_types@PAVNvFaceInfo@@@std@@@std@@@std@@YAPBV?$_Tree_val@U?$_Tree_simple_types@PAVNvFaceInfo@@@std@@@0@ABV10@@Z ENDP ; std::addressof<std::_Tree_val<std::_Tree_simple_types<NvFaceInfo *> > const >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
;	COMDAT ??$xr_alloc@U?$_Tree_node@PAVNvFaceInfo@@PAX@std@@@@YAPAU?$_Tree_node@PAVNvFaceInfo@@PAX@std@@I@Z
_TEXT	SEGMENT
??$xr_alloc@U?$_Tree_node@PAVNvFaceInfo@@PAX@std@@@@YAPAU?$_Tree_node@PAVNvFaceInfo@@PAX@std@@I@Z PROC ; xr_alloc<std::_Tree_node<NvFaceInfo *,void *> >, COMDAT
; _count$dead$ = ecx

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	20					; 00000014H
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
	ret	0
??$xr_alloc@U?$_Tree_node@PAVNvFaceInfo@@PAX@std@@@@YAPAU?$_Tree_node@PAVNvFaceInfo@@PAX@std@@I@Z ENDP ; xr_alloc<std::_Tree_node<NvFaceInfo *,void *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Uninitialized_value_construct_n@V?$xalloc@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@@@std@@YAPAV?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@PAV1@IAAV?$xalloc@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@@@Z
_TEXT	SEGMENT
__Al$dead$ = 8						; size = 4
??$_Uninitialized_value_construct_n@V?$xalloc@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@@@std@@YAPAV?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@PAV1@IAAV?$xalloc@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@@@Z PROC ; std::_Uninitialized_value_construct_n<xalloc<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> > > >, COMDAT
; __First$ = ecx
; __Count$ = edx

; 1799 :     // value-initialize _Count objects to raw _First, using _Al
; 1800 :     using _Ptrty = typename _Alloc::value_type*;
; 1801 :     if constexpr (_Use_memset_value_construct_v<_Ptrty> && _Uses_default_construct<_Alloc, _Ptrty>::value) {
; 1802 : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 1803 :         if (!_STD is_constant_evaluated())
; 1804 : #endif // __cpp_lib_constexpr_dynamic_alloc
; 1805 :         {
; 1806 :             auto _PFirst = _Unfancy(_First);
; 1807 :             _Zero_range(_PFirst, _PFirst + _Count);
; 1808 :             return _First + _Count;
; 1809 :         }
; 1810 :     }
; 1811 : 
; 1812 :     _Uninitialized_backout_al<_Alloc> _Backout{_First, _Al};
; 1813 :     for (; 0 < _Count; --_Count) {

	test	edx, edx
	je	SHORT $LN26@Uninitiali
	npad	12
$LL4@Uninitiali:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx], 0
	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1621 :         ++_Last;

	add	ecx, 12					; 0000000cH

; 1799 :     // value-initialize _Count objects to raw _First, using _Al
; 1800 :     using _Ptrty = typename _Alloc::value_type*;
; 1801 :     if constexpr (_Use_memset_value_construct_v<_Ptrty> && _Uses_default_construct<_Alloc, _Ptrty>::value) {
; 1802 : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 1803 :         if (!_STD is_constant_evaluated())
; 1804 : #endif // __cpp_lib_constexpr_dynamic_alloc
; 1805 :         {
; 1806 :             auto _PFirst = _Unfancy(_First);
; 1807 :             _Zero_range(_PFirst, _PFirst + _Count);
; 1808 :             return _First + _Count;
; 1809 :         }
; 1810 :     }
; 1811 : 
; 1812 :     _Uninitialized_backout_al<_Alloc> _Backout{_First, _Al};
; 1813 :     for (; 0 < _Count; --_Count) {

	sub	edx, 1
	jne	SHORT $LL4@Uninitiali
$LN26@Uninitiali:

; 1814 :         _Backout._Emplace_back();
; 1815 :     }
; 1816 : 
; 1817 :     return _Backout._Release();
; 1818 : }

	mov	eax, ecx
	ret	0
??$_Uninitialized_value_construct_n@V?$xalloc@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@@@std@@YAPAV?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@PAV1@IAAV?$xalloc@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@@@Z ENDP ; std::_Uninitialized_value_construct_n<xalloc<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Uninitialized_move@PAPAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@std@@YAPAPAVNvStripInfo@@QAPAV1@0PAPAV1@AAV?$xalloc@PAVNvStripInfo@@@@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Al$dead$ = 12						; size = 4
??$_Uninitialized_move@PAPAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@std@@YAPAPAVNvStripInfo@@QAPAV1@0PAPAV1@AAV?$xalloc@PAVNvStripInfo@@@@@Z PROC ; std::_Uninitialized_move<NvStripInfo * *,xalloc<NvStripInfo *> >, COMDAT
; __First$ = ecx
; __Last$ = edx

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	eax, DWORD PTR __Dest$[esp-4]

; 1699 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

	push	esi
	mov	esi, edx

; 1700 :     // move [_First, _Last) to raw _Dest, using _Al
; 1701 :     // note: only called internally from elsewhere in the STL
; 1702 :     using _Ptrval     = typename _Alloc::value_type*;
; 1703 :     auto _UFirst      = _Get_unwrapped(_First);
; 1704 :     const auto _ULast = _Get_unwrapped(_Last);
; 1705 :     if constexpr (conjunction_v<bool_constant<_Ptr_move_cat<decltype(_UFirst), _Ptrval>::_Really_trivial>,
; 1706 :                       _Uses_default_construct<_Alloc, _Ptrval, decltype(_STD move(*_UFirst))>>) {
; 1707 : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 1708 :         if (!_STD is_constant_evaluated())
; 1709 : #endif // __cpp_lib_constexpr_dynamic_alloc
; 1710 :         {
; 1711 :             _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));
; 1712 :             return _Dest + (_ULast - _UFirst);
; 1713 :         }
; 1714 :     }
; 1715 : 
; 1716 :     _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	ecx, esi
	je	SHORT $LN3@Uninitiali
	npad	5
$LL4@Uninitiali:

; 1620 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

	mov	edx, DWORD PTR [ecx]

; 1621 :         ++_Last;

	add	ecx, 4
	mov	DWORD PTR [eax], edx
	add	eax, 4

; 1700 :     // move [_First, _Last) to raw _Dest, using _Al
; 1701 :     // note: only called internally from elsewhere in the STL
; 1702 :     using _Ptrval     = typename _Alloc::value_type*;
; 1703 :     auto _UFirst      = _Get_unwrapped(_First);
; 1704 :     const auto _ULast = _Get_unwrapped(_Last);
; 1705 :     if constexpr (conjunction_v<bool_constant<_Ptr_move_cat<decltype(_UFirst), _Ptrval>::_Really_trivial>,
; 1706 :                       _Uses_default_construct<_Alloc, _Ptrval, decltype(_STD move(*_UFirst))>>) {
; 1707 : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 1708 :         if (!_STD is_constant_evaluated())
; 1709 : #endif // __cpp_lib_constexpr_dynamic_alloc
; 1710 :         {
; 1711 :             _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));
; 1712 :             return _Dest + (_ULast - _UFirst);
; 1713 :         }
; 1714 :     }
; 1715 : 
; 1716 :     _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	ecx, esi
	jne	SHORT $LL4@Uninitiali
$LN3@Uninitiali:
	pop	esi

; 1718 :         _Backout._Emplace_back(_STD move(*_UFirst));
; 1719 :     }
; 1720 : 
; 1721 :     return _Backout._Release();
; 1722 : }

	ret	0
??$_Uninitialized_move@PAPAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@std@@YAPAPAVNvStripInfo@@QAPAV1@0PAPAV1@AAV?$xalloc@PAVNvStripInfo@@@@@Z ENDP ; std::_Uninitialized_move<NvStripInfo * *,xalloc<NvStripInfo *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_Get_unwrapped@ABQAPAVNvStripInfo@@@std@@YA?A_TABQAPAVNvStripInfo@@@Z
_TEXT	SEGMENT
??$_Get_unwrapped@ABQAPAVNvStripInfo@@@std@@YA?A_TABQAPAVNvStripInfo@@@Z PROC ; std::_Get_unwrapped<NvStripInfo * * const &>, COMDAT
; __It$ = ecx

; 1275 :     // unwrap an iterator previously subjected to _Adl_verify_range or otherwise validated
; 1276 :     if constexpr (is_pointer_v<decay_t<_Iter>>) { // special-case pointers and arrays
; 1277 :         return _It + 0;

	mov	eax, DWORD PTR [ecx]

; 1278 :     } else if constexpr (_Unwrappable_v<_Iter>) {
; 1279 :         return static_cast<_Iter&&>(_It)._Unwrapped();
; 1280 :     } else {
; 1281 :         return static_cast<_Iter&&>(_It);
; 1282 :     }
; 1283 : }

	ret	0
??$_Get_unwrapped@ABQAPAVNvStripInfo@@@std@@YA?A_TABQAPAVNvStripInfo@@@Z ENDP ; std::_Get_unwrapped<NvStripInfo * * const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Uninitialized_value_construct_n@V?$xalloc@PAVNvEdgeInfo@@@@@std@@YAPAPAVNvEdgeInfo@@PAPAV1@IAAV?$xalloc@PAVNvEdgeInfo@@@@@Z
_TEXT	SEGMENT
__Al$dead$ = 8						; size = 4
??$_Uninitialized_value_construct_n@V?$xalloc@PAVNvEdgeInfo@@@@@std@@YAPAPAVNvEdgeInfo@@PAPAV1@IAAV?$xalloc@PAVNvEdgeInfo@@@@@Z PROC ; std::_Uninitialized_value_construct_n<xalloc<NvEdgeInfo *> >, COMDAT
; __First$ = ecx
; __Count$ = edx

; 1798 :     _Alloc_ptr_t<_Alloc> _First, _Alloc_size_t<_Alloc> _Count, _Alloc& _Al) {

	push	esi
	push	edi

; 1799 :     // value-initialize _Count objects to raw _First, using _Al
; 1800 :     using _Ptrty = typename _Alloc::value_type*;
; 1801 :     if constexpr (_Use_memset_value_construct_v<_Ptrty> && _Uses_default_construct<_Alloc, _Ptrty>::value) {
; 1802 : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 1803 :         if (!_STD is_constant_evaluated())
; 1804 : #endif // __cpp_lib_constexpr_dynamic_alloc
; 1805 :         {
; 1806 :             auto _PFirst = _Unfancy(_First);
; 1807 :             _Zero_range(_PFirst, _PFirst + _Count);

	lea	esi, DWORD PTR [edx*4]
	mov	edi, ecx

; 1792 :     _CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

	push	esi
	push	0
	push	edi
	call	_memset
	add	esp, 12					; 0000000cH

; 1808 :             return _First + _Count;

	lea	eax, DWORD PTR [esi+edi]
	pop	edi
	pop	esi

; 1809 :         }
; 1810 :     }
; 1811 : 
; 1812 :     _Uninitialized_backout_al<_Alloc> _Backout{_First, _Al};
; 1813 :     for (; 0 < _Count; --_Count) {
; 1814 :         _Backout._Emplace_back();
; 1815 :     }
; 1816 : 
; 1817 :     return _Backout._Release();
; 1818 : }

	ret	0
??$_Uninitialized_value_construct_n@V?$xalloc@PAVNvEdgeInfo@@@@@std@@YAPAPAVNvEdgeInfo@@PAPAV1@IAAV?$xalloc@PAVNvEdgeInfo@@@@@Z ENDP ; std::_Uninitialized_value_construct_n<xalloc<NvEdgeInfo *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
;	COMDAT ??$xr_alloc@PAVNvStripInfo@@@@YAPAPAVNvStripInfo@@I@Z
_TEXT	SEGMENT
??$xr_alloc@PAVNvStripInfo@@@@YAPAPAVNvStripInfo@@I@Z PROC ; xr_alloc<NvStripInfo *>, COMDAT
; _count$ = ecx

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	lea	eax, DWORD PTR [ecx*4]
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
	ret	0
??$xr_alloc@PAVNvStripInfo@@@@YAPAPAVNvStripInfo@@I@Z ENDP ; xr_alloc<NvStripInfo *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Uninitialized_move@PAHV?$xalloc@H@@@std@@YAPAHQAH0PAHAAV?$xalloc@H@@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Al$dead$ = 12						; size = 4
??$_Uninitialized_move@PAHV?$xalloc@H@@@std@@YAPAHQAH0PAHAAV?$xalloc@H@@@Z PROC ; std::_Uninitialized_move<int *,xalloc<int> >, COMDAT
; __First$ = ecx
; __Last$ = edx

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	eax, DWORD PTR __Dest$[esp-4]

; 1699 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

	push	esi
	mov	esi, edx

; 1700 :     // move [_First, _Last) to raw _Dest, using _Al
; 1701 :     // note: only called internally from elsewhere in the STL
; 1702 :     using _Ptrval     = typename _Alloc::value_type*;
; 1703 :     auto _UFirst      = _Get_unwrapped(_First);
; 1704 :     const auto _ULast = _Get_unwrapped(_Last);
; 1705 :     if constexpr (conjunction_v<bool_constant<_Ptr_move_cat<decltype(_UFirst), _Ptrval>::_Really_trivial>,
; 1706 :                       _Uses_default_construct<_Alloc, _Ptrval, decltype(_STD move(*_UFirst))>>) {
; 1707 : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 1708 :         if (!_STD is_constant_evaluated())
; 1709 : #endif // __cpp_lib_constexpr_dynamic_alloc
; 1710 :         {
; 1711 :             _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));
; 1712 :             return _Dest + (_ULast - _UFirst);
; 1713 :         }
; 1714 :     }
; 1715 : 
; 1716 :     _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	ecx, esi
	je	SHORT $LN3@Uninitiali
	npad	5
$LL4@Uninitiali:

; 1620 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

	mov	edx, DWORD PTR [ecx]

; 1621 :         ++_Last;

	add	ecx, 4
	mov	DWORD PTR [eax], edx
	add	eax, 4

; 1700 :     // move [_First, _Last) to raw _Dest, using _Al
; 1701 :     // note: only called internally from elsewhere in the STL
; 1702 :     using _Ptrval     = typename _Alloc::value_type*;
; 1703 :     auto _UFirst      = _Get_unwrapped(_First);
; 1704 :     const auto _ULast = _Get_unwrapped(_Last);
; 1705 :     if constexpr (conjunction_v<bool_constant<_Ptr_move_cat<decltype(_UFirst), _Ptrval>::_Really_trivial>,
; 1706 :                       _Uses_default_construct<_Alloc, _Ptrval, decltype(_STD move(*_UFirst))>>) {
; 1707 : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 1708 :         if (!_STD is_constant_evaluated())
; 1709 : #endif // __cpp_lib_constexpr_dynamic_alloc
; 1710 :         {
; 1711 :             _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));
; 1712 :             return _Dest + (_ULast - _UFirst);
; 1713 :         }
; 1714 :     }
; 1715 : 
; 1716 :     _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	ecx, esi
	jne	SHORT $LL4@Uninitiali
$LN3@Uninitiali:
	pop	esi

; 1718 :         _Backout._Emplace_back(_STD move(*_UFirst));
; 1719 :     }
; 1720 : 
; 1721 :     return _Backout._Release();
; 1722 : }

	ret	0
??$_Uninitialized_move@PAHV?$xalloc@H@@@std@@YAPAHQAH0PAHAAV?$xalloc@H@@@Z ENDP ; std::_Uninitialized_move<int *,xalloc<int> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_Get_unwrapped@ABQAH@std@@YA?A_TABQAH@Z
_TEXT	SEGMENT
??$_Get_unwrapped@ABQAH@std@@YA?A_TABQAH@Z PROC		; std::_Get_unwrapped<int * const &>, COMDAT
; __It$ = ecx

; 1275 :     // unwrap an iterator previously subjected to _Adl_verify_range or otherwise validated
; 1276 :     if constexpr (is_pointer_v<decay_t<_Iter>>) { // special-case pointers and arrays
; 1277 :         return _It + 0;

	mov	eax, DWORD PTR [ecx]

; 1278 :     } else if constexpr (_Unwrappable_v<_Iter>) {
; 1279 :         return static_cast<_Iter&&>(_It)._Unwrapped();
; 1280 :     } else {
; 1281 :         return static_cast<_Iter&&>(_It);
; 1282 :     }
; 1283 : }

	ret	0
??$_Get_unwrapped@ABQAH@std@@YA?A_TABQAH@Z ENDP		; std::_Get_unwrapped<int * const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Release@?$_Uninitialized_backout_al@V?$xalloc@H@@@std@@QAEPAHXZ
_TEXT	SEGMENT
?_Release@?$_Uninitialized_backout_al@V?$xalloc@H@@@std@@QAEPAHXZ PROC ; std::_Uninitialized_backout_al<xalloc<int> >::_Release, COMDAT
; _this$ = ecx

; 1625 :         _First = _Last;

	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [ecx], eax

; 1626 :         return _Last;
; 1627 :     }

	ret	0
?_Release@?$_Uninitialized_backout_al@V?$xalloc@H@@@std@@QAEPAHXZ ENDP ; std::_Uninitialized_backout_al<xalloc<int> >::_Release
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??1?$_Uninitialized_backout_al@V?$xalloc@H@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Uninitialized_backout_al@V?$xalloc@H@@@std@@QAE@XZ PROC ; std::_Uninitialized_backout_al<xalloc<int> >::~_Uninitialized_backout_al<xalloc<int> >, COMDAT
; _this$ = ecx

; 1615 :         _Destroy_range(_First, _Last, _Al);
; 1616 :     }

	ret	0
??1?$_Uninitialized_backout_al@V?$xalloc@H@@@std@@QAE@XZ ENDP ; std::_Uninitialized_backout_al<xalloc<int> >::~_Uninitialized_backout_al<xalloc<int> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??0?$_Uninitialized_backout_al@V?$xalloc@H@@@std@@QAE@PAHAAV?$xalloc@H@@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Al_$ = 12						; size = 4
??0?$_Uninitialized_backout_al@V?$xalloc@H@@@std@@QAE@PAHAAV?$xalloc@H@@@Z PROC ; std::_Uninitialized_backout_al<xalloc<int> >::_Uninitialized_backout_al<xalloc<int> >, COMDAT
; _this$ = ecx

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	eax, DWORD PTR __Dest$[esp-4]
	mov	DWORD PTR [ecx], eax
	mov	DWORD PTR [ecx+4], eax
	mov	eax, DWORD PTR __Al_$[esp-4]
	mov	DWORD PTR [ecx+8], eax
	mov	eax, ecx
	ret	8
??0?$_Uninitialized_backout_al@V?$xalloc@H@@@std@@QAE@PAHAAV?$xalloc@H@@@Z ENDP ; std::_Uninitialized_backout_al<xalloc<int> >::_Uninitialized_backout_al<xalloc<int> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Release@?$_Uninitialized_backout_al@V?$xalloc@PAVNvEdgeInfo@@@@@std@@QAEPAPAVNvEdgeInfo@@XZ
_TEXT	SEGMENT
?_Release@?$_Uninitialized_backout_al@V?$xalloc@PAVNvEdgeInfo@@@@@std@@QAEPAPAVNvEdgeInfo@@XZ PROC ; std::_Uninitialized_backout_al<xalloc<NvEdgeInfo *> >::_Release, COMDAT
; _this$ = ecx

; 1625 :         _First = _Last;

	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [ecx], eax

; 1626 :         return _Last;
; 1627 :     }

	ret	0
?_Release@?$_Uninitialized_backout_al@V?$xalloc@PAVNvEdgeInfo@@@@@std@@QAEPAPAVNvEdgeInfo@@XZ ENDP ; std::_Uninitialized_backout_al<xalloc<NvEdgeInfo *> >::_Release
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??1?$_Uninitialized_backout_al@V?$xalloc@PAVNvEdgeInfo@@@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Uninitialized_backout_al@V?$xalloc@PAVNvEdgeInfo@@@@@std@@QAE@XZ PROC ; std::_Uninitialized_backout_al<xalloc<NvEdgeInfo *> >::~_Uninitialized_backout_al<xalloc<NvEdgeInfo *> >, COMDAT
; _this$ = ecx

; 1615 :         _Destroy_range(_First, _Last, _Al);
; 1616 :     }

	ret	0
??1?$_Uninitialized_backout_al@V?$xalloc@PAVNvEdgeInfo@@@@@std@@QAE@XZ ENDP ; std::_Uninitialized_backout_al<xalloc<NvEdgeInfo *> >::~_Uninitialized_backout_al<xalloc<NvEdgeInfo *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??0?$_Uninitialized_backout_al@V?$xalloc@PAVNvEdgeInfo@@@@@std@@QAE@PAPAVNvEdgeInfo@@AAV?$xalloc@PAVNvEdgeInfo@@@@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Al_$ = 12						; size = 4
??0?$_Uninitialized_backout_al@V?$xalloc@PAVNvEdgeInfo@@@@@std@@QAE@PAPAVNvEdgeInfo@@AAV?$xalloc@PAVNvEdgeInfo@@@@@Z PROC ; std::_Uninitialized_backout_al<xalloc<NvEdgeInfo *> >::_Uninitialized_backout_al<xalloc<NvEdgeInfo *> >, COMDAT
; _this$ = ecx

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	eax, DWORD PTR __Dest$[esp-4]
	mov	DWORD PTR [ecx], eax
	mov	DWORD PTR [ecx+4], eax
	mov	eax, DWORD PTR __Al_$[esp-4]
	mov	DWORD PTR [ecx+8], eax
	mov	eax, ecx
	ret	8
??0?$_Uninitialized_backout_al@V?$xalloc@PAVNvEdgeInfo@@@@@std@@QAE@PAPAVNvEdgeInfo@@AAV?$xalloc@PAVNvEdgeInfo@@@@@Z ENDP ; std::_Uninitialized_backout_al<xalloc<NvEdgeInfo *> >::_Uninitialized_backout_al<xalloc<NvEdgeInfo *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Release@?$_Uninitialized_backout_al@V?$xalloc@PAVNvStripInfo@@@@@std@@QAEPAPAVNvStripInfo@@XZ
_TEXT	SEGMENT
?_Release@?$_Uninitialized_backout_al@V?$xalloc@PAVNvStripInfo@@@@@std@@QAEPAPAVNvStripInfo@@XZ PROC ; std::_Uninitialized_backout_al<xalloc<NvStripInfo *> >::_Release, COMDAT
; _this$ = ecx

; 1625 :         _First = _Last;

	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [ecx], eax

; 1626 :         return _Last;
; 1627 :     }

	ret	0
?_Release@?$_Uninitialized_backout_al@V?$xalloc@PAVNvStripInfo@@@@@std@@QAEPAPAVNvStripInfo@@XZ ENDP ; std::_Uninitialized_backout_al<xalloc<NvStripInfo *> >::_Release
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??1?$_Uninitialized_backout_al@V?$xalloc@PAVNvStripInfo@@@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Uninitialized_backout_al@V?$xalloc@PAVNvStripInfo@@@@@std@@QAE@XZ PROC ; std::_Uninitialized_backout_al<xalloc<NvStripInfo *> >::~_Uninitialized_backout_al<xalloc<NvStripInfo *> >, COMDAT
; _this$ = ecx

; 1615 :         _Destroy_range(_First, _Last, _Al);
; 1616 :     }

	ret	0
??1?$_Uninitialized_backout_al@V?$xalloc@PAVNvStripInfo@@@@@std@@QAE@XZ ENDP ; std::_Uninitialized_backout_al<xalloc<NvStripInfo *> >::~_Uninitialized_backout_al<xalloc<NvStripInfo *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??0?$_Uninitialized_backout_al@V?$xalloc@PAVNvStripInfo@@@@@std@@QAE@PAPAVNvStripInfo@@AAV?$xalloc@PAVNvStripInfo@@@@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Al_$ = 12						; size = 4
??0?$_Uninitialized_backout_al@V?$xalloc@PAVNvStripInfo@@@@@std@@QAE@PAPAVNvStripInfo@@AAV?$xalloc@PAVNvStripInfo@@@@@Z PROC ; std::_Uninitialized_backout_al<xalloc<NvStripInfo *> >::_Uninitialized_backout_al<xalloc<NvStripInfo *> >, COMDAT
; _this$ = ecx

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	eax, DWORD PTR __Dest$[esp-4]
	mov	DWORD PTR [ecx], eax
	mov	DWORD PTR [ecx+4], eax
	mov	eax, DWORD PTR __Al_$[esp-4]
	mov	DWORD PTR [ecx+8], eax
	mov	eax, ecx
	ret	8
??0?$_Uninitialized_backout_al@V?$xalloc@PAVNvStripInfo@@@@@std@@QAE@PAPAVNvStripInfo@@AAV?$xalloc@PAVNvStripInfo@@@@@Z ENDP ; std::_Uninitialized_backout_al<xalloc<NvStripInfo *> >::_Uninitialized_backout_al<xalloc<NvStripInfo *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Release@?$_Uninitialized_backout_al@V?$xalloc@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@@@std@@QAEPAV?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@XZ
_TEXT	SEGMENT
?_Release@?$_Uninitialized_backout_al@V?$xalloc@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@@@std@@QAEPAV?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@XZ PROC ; std::_Uninitialized_backout_al<xalloc<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> > > >::_Release, COMDAT
; _this$ = ecx

; 1625 :         _First = _Last;

	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [ecx], eax

; 1626 :         return _Last;
; 1627 :     }

	ret	0
?_Release@?$_Uninitialized_backout_al@V?$xalloc@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@@@std@@QAEPAV?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@XZ ENDP ; std::_Uninitialized_backout_al<xalloc<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> > > >::_Release
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??1?$_Uninitialized_backout_al@V?$xalloc@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Uninitialized_backout_al@V?$xalloc@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@@@std@@QAE@XZ PROC ; std::_Uninitialized_backout_al<xalloc<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> > > >::~_Uninitialized_backout_al<xalloc<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> > > >, COMDAT
; _this$ = ecx

; 1615 :         _Destroy_range(_First, _Last, _Al);
; 1616 :     }

	ret	0
??1?$_Uninitialized_backout_al@V?$xalloc@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@@@std@@QAE@XZ ENDP ; std::_Uninitialized_backout_al<xalloc<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> > > >::~_Uninitialized_backout_al<xalloc<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??0?$_Uninitialized_backout_al@V?$xalloc@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@@@std@@QAE@PAV?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@AAV?$xalloc@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Al_$ = 12						; size = 4
??0?$_Uninitialized_backout_al@V?$xalloc@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@@@std@@QAE@PAV?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@AAV?$xalloc@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@@@Z PROC ; std::_Uninitialized_backout_al<xalloc<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> > > >::_Uninitialized_backout_al<xalloc<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> > > >, COMDAT
; _this$ = ecx

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	eax, DWORD PTR __Dest$[esp-4]
	mov	DWORD PTR [ecx], eax
	mov	DWORD PTR [ecx+4], eax
	mov	eax, DWORD PTR __Al_$[esp-4]
	mov	DWORD PTR [ecx+8], eax
	mov	eax, ecx
	ret	8
??0?$_Uninitialized_backout_al@V?$xalloc@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@@@std@@QAE@PAV?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@AAV?$xalloc@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@@@Z ENDP ; std::_Uninitialized_backout_al<xalloc<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> > > >::_Uninitialized_backout_al<xalloc<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xtree
;	COMDAT ??1?$_Tree_temp_node@V?$xalloc@U?$_Tree_node@PAVNvFaceInfo@@PAX@std@@@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Tree_temp_node@V?$xalloc@U?$_Tree_node@PAVNvFaceInfo@@PAX@std@@@@@std@@QAE@XZ PROC ; std::_Tree_temp_node<xalloc<std::_Tree_node<NvFaceInfo *,void *> > >::~_Tree_temp_node<xalloc<std::_Tree_node<NvFaceInfo *,void *> > >, COMDAT
; _this$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 970  :         if (_Ptr) {

	mov	eax, DWORD PTR [ecx+4]
	test	eax, eax
	je	SHORT $LN12@Tree_temp_
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN12@Tree_temp_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xtree

; 823  :     }

	ret	0
??1?$_Tree_temp_node@V?$xalloc@U?$_Tree_node@PAVNvFaceInfo@@PAX@std@@@@@std@@QAE@XZ ENDP ; std::_Tree_temp_node<xalloc<std::_Tree_node<NvFaceInfo *,void *> > >::~_Tree_temp_node<xalloc<std::_Tree_node<NvFaceInfo *,void *> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Release@?$_Alloc_construct_ptr@V?$xalloc@U?$_Tree_node@PAVNvFaceInfo@@PAX@std@@@@@std@@QAEPAU?$_Tree_node@PAVNvFaceInfo@@PAX@2@XZ
_TEXT	SEGMENT
?_Release@?$_Alloc_construct_ptr@V?$xalloc@U?$_Tree_node@PAVNvFaceInfo@@PAX@std@@@@@std@@QAEPAU?$_Tree_node@PAVNvFaceInfo@@PAX@2@XZ PROC ; std::_Alloc_construct_ptr<xalloc<std::_Tree_node<NvFaceInfo *,void *> > >::_Release, COMDAT
; _this$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 602  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	eax, DWORD PTR [ecx+4]

; 603  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	DWORD PTR [ecx+4], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 962  :     }

	ret	0
?_Release@?$_Alloc_construct_ptr@V?$xalloc@U?$_Tree_node@PAVNvFaceInfo@@PAX@std@@@@@std@@QAEPAU?$_Tree_node@PAVNvFaceInfo@@PAX@2@XZ ENDP ; std::_Alloc_construct_ptr<xalloc<std::_Tree_node<NvFaceInfo *,void *> > >::_Release
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Extract@?$_In_place_key_extract_set@PAVNvFaceInfo@@PAV1@@std@@SAABQAVNvFaceInfo@@ABQAV3@@Z
_TEXT	SEGMENT
?_Extract@?$_In_place_key_extract_set@PAVNvFaceInfo@@PAV1@@std@@SAABQAVNvFaceInfo@@ABQAV3@@Z PROC ; std::_In_place_key_extract_set<NvFaceInfo *,NvFaceInfo *>::_Extract, COMDAT
; __Val$ = ecx

; 1860 :         return _Val;

	mov	eax, ecx

; 1861 :     }

	ret	0
?_Extract@?$_In_place_key_extract_set@PAVNvFaceInfo@@PAV1@@std@@SAABQAVNvFaceInfo@@ABQAV3@@Z ENDP ; std::_In_place_key_extract_set<NvFaceInfo *,NvFaceInfo *>::_Extract
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xtree
;	COMDAT ?_Insert_node@?$_Tree_val@U?$_Tree_simple_types@PAVNvFaceInfo@@@std@@@std@@QAEPAU?$_Tree_node@PAVNvFaceInfo@@PAX@2@U?$_Tree_id@PAU?$_Tree_node@PAVNvFaceInfo@@PAX@std@@@2@QAU32@@Z
_TEXT	SEGMENT
__Head$1$ = -4						; size = 4
__Loc$ = 8						; size = 8
__Newnode$ = 16						; size = 4
?_Insert_node@?$_Tree_val@U?$_Tree_simple_types@PAVNvFaceInfo@@@std@@@std@@QAEPAU?$_Tree_node@PAVNvFaceInfo@@PAX@2@U?$_Tree_id@PAU?$_Tree_node@PAVNvFaceInfo@@PAX@std@@@2@QAU32@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<NvFaceInfo *> >::_Insert_node, COMDAT
; _this$ = ecx

; 644  :     _Nodeptr _Insert_node(const _Tree_id<_Nodeptr> _Loc, const _Nodeptr _Newnode) noexcept {

	sub	esp, 8

; 645  :         ++_Mysize;
; 646  :         const auto _Head  = _Myhead;
; 647  :         _Newnode->_Parent = _Loc._Parent;

	mov	edx, DWORD PTR __Loc$[esp+4]
	mov	eax, ecx
	push	ebp
	mov	ebp, DWORD PTR __Newnode$[esp+8]
	inc	DWORD PTR [eax+4]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR __Head$1$[esp+12], eax
	mov	DWORD PTR [ebp+4], edx

; 648  :         if (_Loc._Parent == _Head) { // first node in tree, just set head values

	cmp	edx, eax
	jne	SHORT $LN5@Insert_nod

; 649  :             _Head->_Left     = _Newnode;

	mov	DWORD PTR [eax], ebp

; 650  :             _Head->_Parent   = _Newnode;

	mov	DWORD PTR [eax+4], ebp

; 651  :             _Head->_Right    = _Newnode;

	mov	DWORD PTR [eax+8], ebp

; 710  :         return _Newnode;
; 711  :     }

	mov	eax, ebp
	mov	BYTE PTR [ebp+12], 1
	pop	ebp
	add	esp, 8
	ret	12					; 0000000cH
$LN5@Insert_nod:

; 652  :             _Newnode->_Color = _Black; // the root is black
; 653  :             return _Newnode;
; 654  :         }
; 655  : 
; 656  :         _STL_INTERNAL_CHECK(_Loc._Child != _Tree_child::_Unused);
; 657  :         if (_Loc._Child == _Tree_child::_Right) { // add to right of _Loc._Parent

	cmp	DWORD PTR __Loc$[esp+12], 0
	jne	SHORT $LN6@Insert_nod

; 658  :             _STL_INTERNAL_CHECK(_Loc._Parent->_Right->_Isnil);
; 659  :             _Loc._Parent->_Right = _Newnode;

	mov	DWORD PTR [edx+8], ebp

; 660  :             if (_Loc._Parent == _Head->_Right) { // remember rightmost node

	cmp	edx, DWORD PTR [eax+8]
	jne	SHORT $LN9@Insert_nod

; 661  :                 _Head->_Right = _Newnode;

	mov	DWORD PTR [eax+8], ebp

; 662  :             }
; 663  :         } else { // add to left of _Loc._Parent

	jmp	SHORT $LN9@Insert_nod
$LN6@Insert_nod:

; 664  :             _STL_INTERNAL_CHECK(_Loc._Parent->_Left->_Isnil);
; 665  :             _Loc._Parent->_Left = _Newnode;

	mov	DWORD PTR [edx], ebp

; 666  :             if (_Loc._Parent == _Head->_Left) { // remember leftmost node

	cmp	edx, DWORD PTR [eax]
	jne	SHORT $LN9@Insert_nod

; 667  :                 _Head->_Left = _Newnode;

	mov	DWORD PTR [eax], ebp
$LN9@Insert_nod:

; 668  :             }
; 669  :         }
; 670  : 
; 671  :         for (_Nodeptr _Pnode = _Newnode; _Pnode->_Parent->_Color == _Red;) {

	mov	eax, DWORD PTR [ebp+4]
	mov	edx, ebp
	cmp	BYTE PTR [eax+12], 0
	jne	$LN3@Insert_nod
	push	ebx
	push	esi
	mov	ebp, ecx
	push	edi
$LL2@Insert_nod:

; 672  :             if (_Pnode->_Parent == _Pnode->_Parent->_Parent->_Left) { // fixup red-red in left subtree

	mov	ecx, DWORD PTR [edx+4]
	lea	edi, DWORD PTR [edx+4]
	mov	esi, DWORD PTR [ecx+4]
	lea	ebx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [esi]
	cmp	ecx, eax
	jne	$LN10@Insert_nod

; 673  :                 const auto _Parent_sibling = _Pnode->_Parent->_Parent->_Right;

	mov	eax, DWORD PTR [esi+8]

; 674  :                 if (_Parent_sibling->_Color == _Red) { // parent's sibling has two red children, blacken both

	cmp	BYTE PTR [eax+12], 0
	je	$LN54@Insert_nod

; 675  :                     _Pnode->_Parent->_Color          = _Black;
; 676  :                     _Parent_sibling->_Color          = _Black;
; 677  :                     _Pnode->_Parent->_Parent->_Color = _Red;
; 678  :                     _Pnode                           = _Pnode->_Parent->_Parent;
; 679  :                 } else { // parent's sibling has red and black children
; 680  :                     if (_Pnode == _Pnode->_Parent->_Right) { // rotate right child to left

	mov	esi, DWORD PTR [ecx+8]
	cmp	edx, esi
	jne	SHORT $LN51@Insert_nod

; 460  :         _Wherenode->_Right = _Pnode->_Left;

	mov	eax, DWORD PTR [esi]

; 681  :                         _Pnode = _Pnode->_Parent;

	mov	edx, ecx

; 460  :         _Wherenode->_Right = _Pnode->_Left;

	mov	DWORD PTR [edx+8], eax

; 461  : 
; 462  :         if (!_Pnode->_Left->_Isnil) {

	mov	eax, DWORD PTR [esi]
	cmp	BYTE PTR [eax+13], 0
	jne	SHORT $LN20@Insert_nod

; 463  :             _Pnode->_Left->_Parent = _Wherenode;

	mov	DWORD PTR [eax+4], edx
$LN20@Insert_nod:

; 464  :         }
; 465  : 
; 466  :         _Pnode->_Parent = _Wherenode->_Parent;

	mov	eax, DWORD PTR [ebx]
	mov	DWORD PTR [esi+4], eax

; 467  : 
; 468  :         if (_Wherenode == _Myhead->_Parent) {

	mov	eax, DWORD PTR [ebp]
	cmp	edx, DWORD PTR [eax+4]
	jne	SHORT $LN21@Insert_nod

; 469  :             _Myhead->_Parent = _Pnode;

	mov	DWORD PTR [eax+4], esi

; 477  :         _Wherenode->_Parent = _Pnode;

	mov	edi, ebx
	mov	DWORD PTR [esi], edx
	mov	DWORD PTR [ebx], esi
	jmp	SHORT $LN49@Insert_nod
$LN21@Insert_nod:

; 470  :         } else if (_Wherenode == _Wherenode->_Parent->_Left) {

	mov	eax, DWORD PTR [ebx]
	cmp	edx, DWORD PTR [eax]
	jne	SHORT $LN23@Insert_nod

; 471  :             _Wherenode->_Parent->_Left = _Pnode;

	mov	DWORD PTR [eax], esi

; 477  :         _Wherenode->_Parent = _Pnode;

	mov	edi, ebx
	mov	DWORD PTR [esi], edx
	mov	DWORD PTR [ebx], esi
	jmp	SHORT $LN49@Insert_nod
$LN23@Insert_nod:

; 473  :             _Wherenode->_Parent->_Right = _Pnode;

	mov	DWORD PTR [eax+8], esi

; 477  :         _Wherenode->_Parent = _Pnode;

	mov	edi, ebx
	mov	DWORD PTR [esi], edx
	mov	DWORD PTR [ebx], esi
	jmp	SHORT $LN49@Insert_nod
$LN51@Insert_nod:
	mov	esi, ecx
$LN49@Insert_nod:

; 682  :                         _Lrotate(_Pnode);
; 683  :                     }
; 684  : 
; 685  :                     _Pnode->_Parent->_Color          = _Black; // propagate red up

	mov	BYTE PTR [esi+12], 1

; 686  :                     _Pnode->_Parent->_Parent->_Color = _Red;

	mov	eax, DWORD PTR [edi]
	mov	eax, DWORD PTR [eax+4]
	mov	BYTE PTR [eax+12], 0

; 687  :                     _Rrotate(_Pnode->_Parent->_Parent);

	mov	eax, DWORD PTR [edi]
	mov	ecx, DWORD PTR [eax+4]

; 481  :         _Nodeptr _Pnode   = _Wherenode->_Left;

	mov	esi, DWORD PTR [ecx]

; 482  :         _Wherenode->_Left = _Pnode->_Right;

	mov	eax, DWORD PTR [esi+8]
	mov	DWORD PTR [ecx], eax

; 483  : 
; 484  :         if (!_Pnode->_Right->_Isnil) {

	mov	eax, DWORD PTR [esi+8]
	cmp	BYTE PTR [eax+13], 0
	jne	SHORT $LN27@Insert_nod

; 485  :             _Pnode->_Right->_Parent = _Wherenode;

	mov	DWORD PTR [eax+4], ecx
$LN27@Insert_nod:

; 486  :         }
; 487  : 
; 488  :         _Pnode->_Parent = _Wherenode->_Parent;

	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [esi+4], eax

; 489  : 
; 490  :         if (_Wherenode == _Myhead->_Parent) {

	mov	eax, DWORD PTR [ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jne	SHORT $LN28@Insert_nod

; 491  :             _Myhead->_Parent = _Pnode;

	mov	DWORD PTR [eax+4], esi

; 496  :         }
; 497  : 
; 498  :         _Pnode->_Right      = _Wherenode;

	mov	DWORD PTR [esi+8], ecx

; 688  :                 }
; 689  :             } else { // fixup red-red in right subtree

	jmp	$LN53@Insert_nod
$LN28@Insert_nod:

; 492  :         } else if (_Wherenode == _Wherenode->_Parent->_Right) {

	mov	eax, DWORD PTR [ecx+4]
	cmp	ecx, DWORD PTR [eax+8]
	jne	SHORT $LN30@Insert_nod

; 493  :             _Wherenode->_Parent->_Right = _Pnode;

	mov	DWORD PTR [eax+8], esi

; 496  :         }
; 497  : 
; 498  :         _Pnode->_Right      = _Wherenode;

	mov	DWORD PTR [esi+8], ecx

; 688  :                 }
; 689  :             } else { // fixup red-red in right subtree

	jmp	$LN53@Insert_nod
$LN30@Insert_nod:

; 495  :             _Wherenode->_Parent->_Left = _Pnode;

	mov	DWORD PTR [eax], esi

; 496  :         }
; 497  : 
; 498  :         _Pnode->_Right      = _Wherenode;

	mov	DWORD PTR [esi+8], ecx

; 688  :                 }
; 689  :             } else { // fixup red-red in right subtree

	jmp	$LN53@Insert_nod
$LN10@Insert_nod:

; 690  :                 const auto _Parent_sibling = _Pnode->_Parent->_Parent->_Left;
; 691  :                 if (_Parent_sibling->_Color == _Red) { // parent's sibling has two red children, blacken both

	cmp	BYTE PTR [eax+12], 0
	jne	SHORT $LN15@Insert_nod
$LN54@Insert_nod:

; 668  :             }
; 669  :         }
; 670  : 
; 671  :         for (_Nodeptr _Pnode = _Newnode; _Pnode->_Parent->_Color == _Red;) {

	mov	BYTE PTR [ecx+12], 1
	mov	BYTE PTR [eax+12], 1
	mov	eax, DWORD PTR [edi]
	mov	eax, DWORD PTR [eax+4]
	mov	BYTE PTR [eax+12], 0
	mov	eax, DWORD PTR [edi]
	mov	edx, DWORD PTR [eax+4]
	jmp	$LN16@Insert_nod
$LN15@Insert_nod:

; 692  :                     _Pnode->_Parent->_Color          = _Black;
; 693  :                     _Parent_sibling->_Color          = _Black;
; 694  :                     _Pnode->_Parent->_Parent->_Color = _Red;
; 695  :                     _Pnode                           = _Pnode->_Parent->_Parent;
; 696  :                 } else { // parent's sibling has red and black children
; 697  :                     if (_Pnode == _Pnode->_Parent->_Left) { // rotate left child to right

	mov	eax, DWORD PTR [ecx]
	cmp	edx, eax
	jne	SHORT $LN17@Insert_nod

; 698  :                         _Pnode = _Pnode->_Parent;

	mov	edx, ecx

; 481  :         _Nodeptr _Pnode   = _Wherenode->_Left;

	mov	ecx, eax

; 482  :         _Wherenode->_Left = _Pnode->_Right;

	mov	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx], eax

; 483  : 
; 484  :         if (!_Pnode->_Right->_Isnil) {

	mov	eax, DWORD PTR [ecx+8]
	cmp	BYTE PTR [eax+13], 0
	jne	SHORT $LN34@Insert_nod

; 485  :             _Pnode->_Right->_Parent = _Wherenode;

	mov	DWORD PTR [eax+4], edx
$LN34@Insert_nod:

; 486  :         }
; 487  : 
; 488  :         _Pnode->_Parent = _Wherenode->_Parent;

	mov	eax, DWORD PTR [ebx]
	mov	DWORD PTR [ecx+4], eax

; 489  : 
; 490  :         if (_Wherenode == _Myhead->_Parent) {

	mov	eax, DWORD PTR [ebp]
	cmp	edx, DWORD PTR [eax+4]
	jne	SHORT $LN35@Insert_nod

; 491  :             _Myhead->_Parent = _Pnode;

	mov	DWORD PTR [eax+4], ecx
	jmp	SHORT $LN38@Insert_nod
$LN35@Insert_nod:

; 492  :         } else if (_Wherenode == _Wherenode->_Parent->_Right) {

	mov	eax, DWORD PTR [ebx]
	cmp	edx, DWORD PTR [eax+8]
	jne	SHORT $LN37@Insert_nod

; 493  :             _Wherenode->_Parent->_Right = _Pnode;

	mov	DWORD PTR [eax+8], ecx

; 494  :         } else {

	jmp	SHORT $LN38@Insert_nod
$LN37@Insert_nod:

; 495  :             _Wherenode->_Parent->_Left = _Pnode;

	mov	DWORD PTR [eax], ecx
$LN38@Insert_nod:

; 496  :         }
; 497  : 
; 498  :         _Pnode->_Right      = _Wherenode;

	mov	DWORD PTR [ecx+8], edx

; 499  :         _Wherenode->_Parent = _Pnode;

	mov	edi, ebx
	mov	DWORD PTR [ebx], ecx
$LN17@Insert_nod:

; 699  :                         _Rrotate(_Pnode);
; 700  :                     }
; 701  : 
; 702  :                     _Pnode->_Parent->_Color          = _Black; // propagate red up

	mov	BYTE PTR [ecx+12], 1

; 703  :                     _Pnode->_Parent->_Parent->_Color = _Red;

	mov	eax, DWORD PTR [edi]
	mov	eax, DWORD PTR [eax+4]
	mov	BYTE PTR [eax+12], 0

; 704  :                     _Lrotate(_Pnode->_Parent->_Parent);

	mov	eax, DWORD PTR [edi]
	mov	ecx, DWORD PTR [eax+4]

; 459  :         _Nodeptr _Pnode    = _Wherenode->_Right;

	mov	esi, DWORD PTR [ecx+8]

; 460  :         _Wherenode->_Right = _Pnode->_Left;

	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [ecx+8], eax

; 461  : 
; 462  :         if (!_Pnode->_Left->_Isnil) {

	mov	eax, DWORD PTR [esi]
	cmp	BYTE PTR [eax+13], 0
	jne	SHORT $LN41@Insert_nod

; 463  :             _Pnode->_Left->_Parent = _Wherenode;

	mov	DWORD PTR [eax+4], ecx
$LN41@Insert_nod:

; 464  :         }
; 465  : 
; 466  :         _Pnode->_Parent = _Wherenode->_Parent;

	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [esi+4], eax

; 467  : 
; 468  :         if (_Wherenode == _Myhead->_Parent) {

	mov	eax, DWORD PTR [ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jne	SHORT $LN42@Insert_nod

; 469  :             _Myhead->_Parent = _Pnode;

	mov	DWORD PTR [eax+4], esi
	jmp	SHORT $LN45@Insert_nod
$LN42@Insert_nod:

; 470  :         } else if (_Wherenode == _Wherenode->_Parent->_Left) {

	mov	eax, DWORD PTR [ecx+4]
	cmp	ecx, DWORD PTR [eax]
	jne	SHORT $LN44@Insert_nod

; 471  :             _Wherenode->_Parent->_Left = _Pnode;

	mov	DWORD PTR [eax], esi

; 472  :         } else {

	jmp	SHORT $LN45@Insert_nod
$LN44@Insert_nod:

; 473  :             _Wherenode->_Parent->_Right = _Pnode;

	mov	DWORD PTR [eax+8], esi
$LN45@Insert_nod:

; 474  :         }
; 475  : 
; 476  :         _Pnode->_Left       = _Wherenode;

	mov	DWORD PTR [esi], ecx
$LN53@Insert_nod:

; 668  :             }
; 669  :         }
; 670  : 
; 671  :         for (_Nodeptr _Pnode = _Newnode; _Pnode->_Parent->_Color == _Red;) {

	mov	DWORD PTR [ecx+4], esi
$LN16@Insert_nod:
	mov	eax, DWORD PTR [edx+4]
	cmp	BYTE PTR [eax+12], 0
	je	$LL2@Insert_nod
	mov	ebp, DWORD PTR __Newnode$[esp+20]
	pop	edi
	pop	esi
	pop	ebx
$LN3@Insert_nod:

; 705  :                 }
; 706  :             }
; 707  :         }
; 708  : 
; 709  :         _Head->_Parent->_Color = _Black; // root is always black

	mov	eax, DWORD PTR __Head$1$[esp+12]
	mov	eax, DWORD PTR [eax+4]
	mov	BYTE PTR [eax+12], 1

; 710  :         return _Newnode;
; 711  :     }

	mov	eax, ebp
	pop	ebp
	add	esp, 8
	ret	12					; 0000000cH
?_Insert_node@?$_Tree_val@U?$_Tree_simple_types@PAVNvFaceInfo@@@std@@@std@@QAEPAU?$_Tree_node@PAVNvFaceInfo@@PAX@2@U?$_Tree_id@PAU?$_Tree_node@PAVNvFaceInfo@@PAX@std@@@2@QAU32@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<NvFaceInfo *> >::_Insert_node
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xtree
;	COMDAT ??0?$_Tree_val@U?$_Tree_simple_types@PAVNvFaceInfo@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Tree_val@U?$_Tree_simple_types@PAVNvFaceInfo@@@std@@@std@@QAE@XZ PROC ; std::_Tree_val<std::_Tree_simple_types<NvFaceInfo *> >::_Tree_val<std::_Tree_simple_types<NvFaceInfo *> >, COMDAT
; _this$ = ecx

; 435  :     _Tree_val() noexcept : _Myhead(), _Mysize(0) {}

	mov	DWORD PTR [ecx], 0
	mov	eax, ecx
	mov	DWORD PTR [ecx+4], 0
	ret	0
??0?$_Tree_val@U?$_Tree_simple_types@PAVNvFaceInfo@@@std@@@std@@QAE@XZ ENDP ; std::_Tree_val<std::_Tree_simple_types<NvFaceInfo *> >::_Tree_val<std::_Tree_simple_types<NvFaceInfo *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef
;	COMDAT ??R?$less@PAVNvFaceInfo@@@std@@QBE_NABQAVNvFaceInfo@@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??R?$less@PAVNvFaceInfo@@@std@@QBE_NABQAVNvFaceInfo@@0@Z PROC ; std::less<NvFaceInfo *>::operator(), COMDAT
; _this$dead$ = ecx

; 117  :         return _Left < _Right;

	mov	eax, DWORD PTR __Left$[esp-4]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR __Right$[esp-4]
	cmp	ecx, DWORD PTR [eax]
	setb	al

; 118  :     }

	ret	8
??R?$less@PAVNvFaceInfo@@@std@@QBE_NABQAVNvFaceInfo@@0@Z ENDP ; std::less<NvFaceInfo *>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xtree
;	COMDAT ?_Getcomp@?$_Tree@V?$_Tset_traits@PAVNvFaceInfo@@U?$less@PAVNvFaceInfo@@@std@@V?$xalloc@PAVNvFaceInfo@@@@$0A@@std@@@std@@IBEABU?$less@PAVNvFaceInfo@@@2@XZ
_TEXT	SEGMENT
?_Getcomp@?$_Tree@V?$_Tset_traits@PAVNvFaceInfo@@U?$less@PAVNvFaceInfo@@@std@@V?$xalloc@PAVNvFaceInfo@@@@$0A@@std@@@std@@IBEABU?$less@PAVNvFaceInfo@@@2@XZ PROC ; std::_Tree<std::_Tset_traits<NvFaceInfo *,std::less<NvFaceInfo *>,xalloc<NvFaceInfo *>,0> >::_Getcomp, COMDAT
; _this$ = ecx

; 1931 :         return _Mypair._Get_first();

	mov	eax, ecx

; 1932 :     }

	ret	0
?_Getcomp@?$_Tree@V?$_Tset_traits@PAVNvFaceInfo@@U?$less@PAVNvFaceInfo@@@std@@V?$xalloc@PAVNvFaceInfo@@@@$0A@@std@@@std@@IBEABU?$less@PAVNvFaceInfo@@@2@XZ ENDP ; std::_Tree<std::_Tset_traits<NvFaceInfo *,std::less<NvFaceInfo *>,xalloc<NvFaceInfo *>,0> >::_Getcomp
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xtree
;	COMDAT ?_Check_grow_by_1@?$_Tree@V?$_Tset_traits@PAVNvFaceInfo@@U?$less@PAVNvFaceInfo@@@std@@V?$xalloc@PAVNvFaceInfo@@@@$0A@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Check_grow_by_1@?$_Tree@V?$_Tset_traits@PAVNvFaceInfo@@U?$less@PAVNvFaceInfo@@@std@@V?$xalloc@PAVNvFaceInfo@@@@$0A@@std@@@std@@IAEXXZ PROC ; std::_Tree<std::_Tset_traits<NvFaceInfo *,std::less<NvFaceInfo *>,xalloc<NvFaceInfo *>,0> >::_Check_grow_by_1, COMDAT
; _this$ = ecx

; 1615 :         if (max_size() == _Get_scary()->_Mysize) {

	cmp	DWORD PTR [ecx+4], 214748364		; 0cccccccH
	je	?_Throw_tree_length_error@std@@YAXXZ	; std::_Throw_tree_length_error

; 1616 :             _Throw_tree_length_error();
; 1617 :         }
; 1618 :     }

	ret	0
?_Check_grow_by_1@?$_Tree@V?$_Tset_traits@PAVNvFaceInfo@@U?$less@PAVNvFaceInfo@@@std@@V?$xalloc@PAVNvFaceInfo@@@@$0A@@std@@@std@@IAEXXZ ENDP ; std::_Tree<std::_Tset_traits<NvFaceInfo *,std::less<NvFaceInfo *>,xalloc<NvFaceInfo *>,0> >::_Check_grow_by_1
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?deallocate@?$_Normal_allocator_traits@V?$xalloc@U?$_Tree_node@PAVNvFaceInfo@@PAX@std@@@@@std@@SAXAAV?$xalloc@U?$_Tree_node@PAVNvFaceInfo@@PAX@std@@@@PAU?$_Tree_node@PAVNvFaceInfo@@PAX@2@I@Z
_TEXT	SEGMENT
__Count$dead$ = 8					; size = 4
?deallocate@?$_Normal_allocator_traits@V?$xalloc@U?$_Tree_node@PAVNvFaceInfo@@PAX@std@@@@@std@@SAXAAV?$xalloc@U?$_Tree_node@PAVNvFaceInfo@@PAX@std@@@@PAU?$_Tree_node@PAVNvFaceInfo@@PAX@2@I@Z PROC ; std::_Normal_allocator_traits<xalloc<std::_Tree_node<NvFaceInfo *,void *> > >::deallocate, COMDAT
; __Al$dead$ = ecx
; __Ptr$ = edx
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	test	edx, edx
	je	SHORT $LN6@deallocate
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	edx
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN6@deallocate:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 561  :     }

	ret	0
?deallocate@?$_Normal_allocator_traits@V?$xalloc@U?$_Tree_node@PAVNvFaceInfo@@PAX@std@@@@@std@@SAXAAV?$xalloc@U?$_Tree_node@PAVNvFaceInfo@@PAX@std@@@@PAU?$_Tree_node@PAVNvFaceInfo@@PAX@2@I@Z ENDP ; std::_Normal_allocator_traits<xalloc<std::_Tree_node<NvFaceInfo *,void *> > >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ??0?$xalloc@U?$_Tree_node@PAVNvFaceInfo@@PAX@std@@@@QAE@XZ
_TEXT	SEGMENT
??0?$xalloc@U?$_Tree_node@PAVNvFaceInfo@@PAX@std@@@@QAE@XZ PROC ; xalloc<std::_Tree_node<NvFaceInfo *,void *> >::xalloc<std::_Tree_node<NvFaceInfo *,void *> >, COMDAT
; _this$ = ecx

; 76   : 													xalloc			()										{	}

	mov	eax, ecx
	ret	0
??0?$xalloc@U?$_Tree_node@PAVNvFaceInfo@@PAX@std@@@@QAE@XZ ENDP ; xalloc<std::_Tree_node<NvFaceInfo *,void *> >::xalloc<std::_Tree_node<NvFaceInfo *,void *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\set
;	COMDAT ?_Kfn@?$_Tset_traits@PAVNvFaceInfo@@U?$less@PAVNvFaceInfo@@@std@@V?$xalloc@PAVNvFaceInfo@@@@$0A@@std@@SAABQAVNvFaceInfo@@ABQAV3@@Z
_TEXT	SEGMENT
?_Kfn@?$_Tset_traits@PAVNvFaceInfo@@U?$less@PAVNvFaceInfo@@@std@@V?$xalloc@PAVNvFaceInfo@@@@$0A@@std@@SAABQAVNvFaceInfo@@ABQAV3@@Z PROC ; std::_Tset_traits<NvFaceInfo *,std::less<NvFaceInfo *>,xalloc<NvFaceInfo *>,0>::_Kfn, COMDAT
; __Val$ = ecx

; 47   :         return _Val;

	mov	eax, ecx

; 48   :     }

	ret	0
?_Kfn@?$_Tset_traits@PAVNvFaceInfo@@U?$less@PAVNvFaceInfo@@@std@@V?$xalloc@PAVNvFaceInfo@@@@$0A@@std@@SAABQAVNvFaceInfo@@ABQAV3@@Z ENDP ; std::_Tset_traits<NvFaceInfo *,std::less<NvFaceInfo *>,xalloc<NvFaceInfo *>,0>::_Kfn
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Xlength@?$vector@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@V?$xalloc@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@V?$xalloc@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@@@std@@CAXXZ PROC ; std::vector<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> >,xalloc<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> > > >::_Xlength, COMDAT

; 1761 :         _Xlength_error("vector too long");

	push	OFFSET ??_C@_0BA@FOIKENOD@vector?5too?5long@
	call	DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN3@Xlength:
	int	3
?_Xlength@?$vector@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@V?$xalloc@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@@@std@@CAXXZ ENDP ; std::vector<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> >,xalloc<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> > > >::_Xlength
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Change_array@?$vector@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@V?$xalloc@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@@@std@@AAEXQAV?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@II@Z
_TEXT	SEGMENT
__Newvec$ = 8						; size = 4
__Newsize$dead$ = 12					; size = 4
__Newcapacity$ = 16					; size = 4
?_Change_array@?$vector@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@V?$xalloc@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@@@std@@AAEXQAV?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@II@Z PROC ; std::vector<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> >,xalloc<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> > > >::_Change_array, COMDAT
; _this$ = ecx

; 1723 :         const pointer _Newvec, const size_type _Newsize, const size_type _Newcapacity) {

	push	esi
	mov	esi, ecx

; 1724 :         // orphan all iterators, discard old array, acquire new array
; 1725 :         auto& _My_data    = _Mypair._Myval2;
; 1726 :         pointer& _Myfirst = _My_data._Myfirst;
; 1727 :         pointer& _Mylast  = _My_data._Mylast;
; 1728 :         pointer& _Myend   = _My_data._Myend;
; 1729 : 
; 1730 :         _My_data._Orphan_all();
; 1731 : 
; 1732 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN7@Change_arr
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN7@Change_arr:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1737 :         _Myfirst = _Newvec;

	mov	ecx, DWORD PTR __Newvec$[esp]
	mov	DWORD PTR [esi], ecx

; 1738 :         _Mylast  = _Newvec + _Newsize;

	lea	eax, DWORD PTR [ecx+720]
	mov	DWORD PTR [esi+4], eax

; 1739 :         _Myend   = _Newvec + _Newcapacity;

	mov	eax, DWORD PTR __Newcapacity$[esp]
	lea	eax, DWORD PTR [eax+eax*2]
	lea	eax, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR [esi+8], eax
	pop	esi

; 1740 :     }

	ret	12					; 0000000cH
?_Change_array@?$vector@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@V?$xalloc@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@@@std@@AAEXQAV?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@II@Z ENDP ; std::vector<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> >,xalloc<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> > > >::_Change_array
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Calculate_growth@?$vector@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@V?$xalloc@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@@@std@@ABEII@Z
_TEXT	SEGMENT
__Newsize$dead$ = 8					; size = 4
?_Calculate_growth@?$vector@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@V?$xalloc@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@@@std@@ABEII@Z PROC ; std::vector<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> >,xalloc<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> > > >::_Calculate_growth, COMDAT
; _this$ = ecx

; 1546 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx]

; 1671 :         // given _Oldcapacity and _Newsize, calculate geometric growth
; 1672 :         const size_type _Oldcapacity = capacity();
; 1673 :         const auto _Max              = max_size();
; 1674 : 
; 1675 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	ecx, 357913941				; 15555555H

; 1546 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	sar	eax, 2

; 1670 :     _CONSTEXPR20_CONTAINER size_type _Calculate_growth(const size_type _Newsize) const {

	push	esi

; 1546 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	imul	esi, eax, -1431655765

; 1671 :         // given _Oldcapacity and _Newsize, calculate geometric growth
; 1672 :         const size_type _Oldcapacity = capacity();
; 1673 :         const auto _Max              = max_size();
; 1674 : 
; 1675 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	edx, esi
	shr	edx, 1
	sub	ecx, edx
	cmp	esi, ecx
	jbe	SHORT $LN2@Calculate_

; 1676 :             return _Max; // geometric growth would overflow

	mov	eax, 357913941				; 15555555H
	pop	esi

; 1682 :             return _Newsize; // geometric growth would be insufficient
; 1683 :         }
; 1684 : 
; 1685 :         return _Geometric; // geometric growth is sufficient
; 1686 :     }

	ret	4
$LN2@Calculate_:

; 1677 :         }
; 1678 : 
; 1679 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	lea	eax, DWORD PTR [edx+esi]

; 1680 : 
; 1681 :         if (_Geometric < _Newsize) {

	mov	ecx, 60					; 0000003cH
	cmp	eax, ecx
	pop	esi
	cmovb	eax, ecx

; 1682 :             return _Newsize; // geometric growth would be insufficient
; 1683 :         }
; 1684 : 
; 1685 :         return _Geometric; // geometric growth is sufficient
; 1686 :     }

	ret	4
?_Calculate_growth@?$vector@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@V?$xalloc@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@@@std@@ABEII@Z ENDP ; std::vector<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> >,xalloc<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> > > >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Umove_if_noexcept@?$vector@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@V?$xalloc@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@@@std@@AAEXPAV?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
tv578 = 16						; size = 4
__Dest$ = 16						; size = 4
?_Umove_if_noexcept@?$vector@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@V?$xalloc@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@@@std@@AAEXPAV?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@00@Z PROC ; std::vector<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> >,xalloc<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> > > >::_Umove_if_noexcept, COMDAT
; _this$dead$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	mov	ecx, DWORD PTR __First$[esp-4]
	cmp	ecx, DWORD PTR __Last$[esp-4]
	je	$LN7@Umove_if_n

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	eax, DWORD PTR __Dest$[esp-4]
	mov	edx, ecx
	push	ebx
	push	ebp
	push	esi
	sub	edx, eax
	lea	ebx, DWORD PTR [eax+4]
	push	edi
	mov	DWORD PTR tv578[esp+12], edx
$LL8@Umove_if_n:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ebx-4], 0
	mov	DWORD PTR [ebx], 0
	mov	DWORD PTR [ebx+4], 0

; 546  :         const pointer _Rightfirst = _Right_data._Myfirst;

	mov	esi, DWORD PTR [ecx]

; 547  :         const pointer _Rightlast  = _Right_data._Mylast;

	mov	ebp, DWORD PTR [ebx+edx]

; 548  :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);
; 549  :         if (_Rightfirst != _Rightlast) {

	cmp	esi, ebp
	je	SHORT $LN50@Umove_if_n
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 550  :             _Buy_raw(static_cast<size_type>(_Rightlast - _Rightfirst));

	mov	eax, ebp
	sub	eax, esi
	sar	eax, 2
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	lea	edi, DWORD PTR [eax*4]
	push	edi
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1698 :         const auto _Newvec = _Getal().allocate(_Newcapacity);

	mov	edx, eax

; 1699 :         _Myfirst           = _Newvec;

	mov	DWORD PTR [ebx-4], edx

; 1700 :         _Mylast            = _Newvec;

	mov	DWORD PTR [ebx], edx

; 1701 :         _Myend             = _Newvec + _Newcapacity;

	lea	ecx, DWORD PTR [edi+edx]
	mov	DWORD PTR [ebx+4], ecx
$LL38@Umove_if_n:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1620 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

	mov	eax, DWORD PTR [esi]

; 1658 :     for (; _UFirst != _ULast; ++_UFirst) {

	add	esi, 4

; 1620 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

	mov	DWORD PTR [edx], eax

; 1621 :         ++_Last;

	add	edx, 4

; 1658 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	esi, ebp
	jne	SHORT $LL38@Umove_if_n
	mov	ecx, DWORD PTR __First$[esp+12]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 552  :             _My_data._Mylast = _Ucopy(_Rightfirst, _Rightlast, _My_data._Myfirst);

	mov	DWORD PTR [ebx], edx
	mov	edx, DWORD PTR tv578[esp+12]
$LN50@Umove_if_n:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1621 :         ++_Last;

	add	ecx, 12					; 0000000cH
	add	ebx, 12					; 0000000cH
	mov	DWORD PTR __First$[esp+12], ecx

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	ecx, DWORD PTR __Last$[esp+12]
	jne	SHORT $LL8@Umove_if_n
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
$LN7@Umove_if_n:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1663 :     }

	ret	12					; 0000000cH
?_Umove_if_noexcept@?$vector@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@V?$xalloc@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@@@std@@AAEXPAV?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@00@Z ENDP ; std::vector<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> >,xalloc<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> > > >::_Umove_if_noexcept
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?max_size@?$vector@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@V?$xalloc@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@V?$xalloc@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@@@std@@QBEIXZ PROC ; std::vector<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> >,xalloc<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> > > >::max_size, COMDAT
; _this$dead$ = ecx

; 1540 :         return (_STD min)(

	mov	eax, 357913941				; 15555555H

; 1541 :             static_cast<size_type>((numeric_limits<difference_type>::max)()), _Alty_traits::max_size(_Getal()));
; 1542 :     }

	ret	0
?max_size@?$vector@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@V?$xalloc@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@@@std@@QBEIXZ ENDP ; std::vector<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> >,xalloc<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> > > >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?destroy@?$xalloc@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@@QAEXPAV?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@Z
_TEXT	SEGMENT
_p$dead$ = 8						; size = 4
?destroy@?$xalloc@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@@QAEXPAV?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@Z PROC ; xalloc<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> > >::destroy, COMDAT
; _this$dead$ = ecx

; 85   : 							void					destroy			(pointer p)								{	std::_Destroy_in_place(p);			}

	ret	4
?destroy@?$xalloc@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@@QAEXPAV?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@Z ENDP ; xalloc<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> > >::destroy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?allocate@?$xalloc@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@@QBEPAV?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@IPBX@Z
_TEXT	SEGMENT
_n$ = 8							; size = 4
_p$dead$ = 12						; size = 4
?allocate@?$xalloc@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@@QBEPAV?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@IPBX@Z PROC ; xalloc<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> > >::allocate, COMDAT
; _this$dead$ = ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	mov	eax, DWORD PTR _n$[esp-4]
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	lea	eax, DWORD PTR [eax+eax*2]
	shl	eax, 2
	push	eax
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 80   : 							pointer					allocate		(size_type n, const void* p=0) const	{	return xr_alloc<T>((u32)n);	}

	ret	8
?allocate@?$xalloc@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@@QBEPAV?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@IPBX@Z ENDP ; xalloc<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> > >::allocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Xlength@?$vector@PAVNvEdgeInfo@@V?$xalloc@PAVNvEdgeInfo@@@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@PAVNvEdgeInfo@@V?$xalloc@PAVNvEdgeInfo@@@@@std@@CAXXZ PROC ; std::vector<NvEdgeInfo *,xalloc<NvEdgeInfo *> >::_Xlength, COMDAT

; 1761 :         _Xlength_error("vector too long");

	push	OFFSET ??_C@_0BA@FOIKENOD@vector?5too?5long@
	call	DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN3@Xlength:
	int	3
?_Xlength@?$vector@PAVNvEdgeInfo@@V?$xalloc@PAVNvEdgeInfo@@@@@std@@CAXXZ ENDP ; std::vector<NvEdgeInfo *,xalloc<NvEdgeInfo *> >::_Xlength
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Change_array@?$vector@PAVNvEdgeInfo@@V?$xalloc@PAVNvEdgeInfo@@@@@std@@AAEXQAPAVNvEdgeInfo@@II@Z
_TEXT	SEGMENT
__Newvec$ = 8						; size = 4
__Newsize$ = 12						; size = 4
__Newcapacity$ = 16					; size = 4
?_Change_array@?$vector@PAVNvEdgeInfo@@V?$xalloc@PAVNvEdgeInfo@@@@@std@@AAEXQAPAVNvEdgeInfo@@II@Z PROC ; std::vector<NvEdgeInfo *,xalloc<NvEdgeInfo *> >::_Change_array, COMDAT
; _this$ = ecx

; 1723 :         const pointer _Newvec, const size_type _Newsize, const size_type _Newcapacity) {

	push	esi
	mov	esi, ecx

; 1724 :         // orphan all iterators, discard old array, acquire new array
; 1725 :         auto& _My_data    = _Mypair._Myval2;
; 1726 :         pointer& _Myfirst = _My_data._Myfirst;
; 1727 :         pointer& _Mylast  = _My_data._Mylast;
; 1728 :         pointer& _Myend   = _My_data._Myend;
; 1729 : 
; 1730 :         _My_data._Orphan_all();
; 1731 : 
; 1732 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN7@Change_arr
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN7@Change_arr:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1737 :         _Myfirst = _Newvec;

	mov	ecx, DWORD PTR __Newvec$[esp]

; 1738 :         _Mylast  = _Newvec + _Newsize;

	mov	eax, DWORD PTR __Newsize$[esp]
	mov	DWORD PTR [esi], ecx
	lea	eax, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR [esi+4], eax

; 1739 :         _Myend   = _Newvec + _Newcapacity;

	mov	eax, DWORD PTR __Newcapacity$[esp]
	lea	eax, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR [esi+8], eax
	pop	esi

; 1740 :     }

	ret	12					; 0000000cH
?_Change_array@?$vector@PAVNvEdgeInfo@@V?$xalloc@PAVNvEdgeInfo@@@@@std@@AAEXQAPAVNvEdgeInfo@@II@Z ENDP ; std::vector<NvEdgeInfo *,xalloc<NvEdgeInfo *> >::_Change_array
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Calculate_growth@?$vector@PAVNvEdgeInfo@@V?$xalloc@PAVNvEdgeInfo@@@@@std@@ABEII@Z
_TEXT	SEGMENT
__Newsize$ = 8						; size = 4
?_Calculate_growth@?$vector@PAVNvEdgeInfo@@V?$xalloc@PAVNvEdgeInfo@@@@@std@@ABEII@Z PROC ; std::vector<NvEdgeInfo *,xalloc<NvEdgeInfo *> >::_Calculate_growth, COMDAT
; _this$ = ecx

; 1546 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	edx, DWORD PTR [ecx+8]
	sub	edx, DWORD PTR [ecx]

; 1671 :         // given _Oldcapacity and _Newsize, calculate geometric growth
; 1672 :         const size_type _Oldcapacity = capacity();
; 1673 :         const auto _Max              = max_size();
; 1674 : 
; 1675 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	ecx, 1073741823				; 3fffffffH

; 1546 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	sar	edx, 2

; 1670 :     _CONSTEXPR20_CONTAINER size_type _Calculate_growth(const size_type _Newsize) const {

	push	esi

; 1671 :         // given _Oldcapacity and _Newsize, calculate geometric growth
; 1672 :         const size_type _Oldcapacity = capacity();
; 1673 :         const auto _Max              = max_size();
; 1674 : 
; 1675 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	esi, edx
	shr	esi, 1
	sub	ecx, esi
	cmp	edx, ecx
	jbe	SHORT $LN2@Calculate_

; 1676 :             return _Max; // geometric growth would overflow

	mov	eax, 1073741823				; 3fffffffH
	pop	esi

; 1682 :             return _Newsize; // geometric growth would be insufficient
; 1683 :         }
; 1684 : 
; 1685 :         return _Geometric; // geometric growth is sufficient
; 1686 :     }

	ret	4
$LN2@Calculate_:

; 1677 :         }
; 1678 : 
; 1679 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	lea	eax, DWORD PTR [esi+edx]

; 1680 : 
; 1681 :         if (_Geometric < _Newsize) {

	cmp	eax, DWORD PTR __Newsize$[esp]
	pop	esi
	cmovb	eax, DWORD PTR __Newsize$[esp-4]

; 1682 :             return _Newsize; // geometric growth would be insufficient
; 1683 :         }
; 1684 : 
; 1685 :         return _Geometric; // geometric growth is sufficient
; 1686 :     }

	ret	4
?_Calculate_growth@?$vector@PAVNvEdgeInfo@@V?$xalloc@PAVNvEdgeInfo@@@@@std@@ABEII@Z ENDP ; std::vector<NvEdgeInfo *,xalloc<NvEdgeInfo *> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Umove_if_noexcept@?$vector@PAVNvEdgeInfo@@V?$xalloc@PAVNvEdgeInfo@@@@@std@@AAEXPAPAVNvEdgeInfo@@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
?_Umove_if_noexcept@?$vector@PAVNvEdgeInfo@@V?$xalloc@PAVNvEdgeInfo@@@@@std@@AAEXPAPAVNvEdgeInfo@@00@Z PROC ; std::vector<NvEdgeInfo *,xalloc<NvEdgeInfo *> >::_Umove_if_noexcept, COMDAT
; _this$dead$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1703 :     auto _UFirst      = _Get_unwrapped(_First);

	mov	eax, DWORD PTR __First$[esp-4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1659 :     _CONSTEXPR20_CONTAINER void _Umove_if_noexcept(pointer _First, pointer _Last, pointer _Dest) {

	push	esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	mov	esi, DWORD PTR __Last$[esp]
	cmp	eax, esi
	je	SHORT $LN7@Umove_if_n

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	edx, DWORD PTR __Dest$[esp]
	sub	edx, eax
$LL8@Umove_if_n:

; 1620 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx+eax], ecx

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	add	eax, 4
	cmp	eax, esi
	jne	SHORT $LL8@Umove_if_n
$LN7@Umove_if_n:
	pop	esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1663 :     }

	ret	12					; 0000000cH
?_Umove_if_noexcept@?$vector@PAVNvEdgeInfo@@V?$xalloc@PAVNvEdgeInfo@@@@@std@@AAEXPAPAVNvEdgeInfo@@00@Z ENDP ; std::vector<NvEdgeInfo *,xalloc<NvEdgeInfo *> >::_Umove_if_noexcept
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?max_size@?$vector@PAVNvEdgeInfo@@V?$xalloc@PAVNvEdgeInfo@@@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@PAVNvEdgeInfo@@V?$xalloc@PAVNvEdgeInfo@@@@@std@@QBEIXZ PROC ; std::vector<NvEdgeInfo *,xalloc<NvEdgeInfo *> >::max_size, COMDAT
; _this$dead$ = ecx

; 1540 :         return (_STD min)(

	mov	eax, 1073741823				; 3fffffffH

; 1541 :             static_cast<size_type>((numeric_limits<difference_type>::max)()), _Alty_traits::max_size(_Getal()));
; 1542 :     }

	ret	0
?max_size@?$vector@PAVNvEdgeInfo@@V?$xalloc@PAVNvEdgeInfo@@@@@std@@QBEIXZ ENDP ; std::vector<NvEdgeInfo *,xalloc<NvEdgeInfo *> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?destroy@?$xalloc@PAVNvEdgeInfo@@@@QAEXPAPAVNvEdgeInfo@@@Z
_TEXT	SEGMENT
_p$dead$ = 8						; size = 4
?destroy@?$xalloc@PAVNvEdgeInfo@@@@QAEXPAPAVNvEdgeInfo@@@Z PROC ; xalloc<NvEdgeInfo *>::destroy, COMDAT
; _this$dead$ = ecx

; 85   : 							void					destroy			(pointer p)								{	std::_Destroy_in_place(p);			}

	ret	4
?destroy@?$xalloc@PAVNvEdgeInfo@@@@QAEXPAPAVNvEdgeInfo@@@Z ENDP ; xalloc<NvEdgeInfo *>::destroy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?allocate@?$xalloc@PAVNvEdgeInfo@@@@QBEPAPAVNvEdgeInfo@@IPBX@Z
_TEXT	SEGMENT
_n$ = 8							; size = 4
_p$dead$ = 12						; size = 4
?allocate@?$xalloc@PAVNvEdgeInfo@@@@QBEPAPAVNvEdgeInfo@@IPBX@Z PROC ; xalloc<NvEdgeInfo *>::allocate, COMDAT
; _this$dead$ = ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	mov	eax, DWORD PTR _n$[esp-4]
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	shl	eax, 2
	push	eax
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 80   : 							pointer					allocate		(size_type n, const void* p=0) const	{	return xr_alloc<T>((u32)n);	}

	ret	8
?allocate@?$xalloc@PAVNvEdgeInfo@@@@QBEPAPAVNvEdgeInfo@@IPBX@Z ENDP ; xalloc<NvEdgeInfo *>::allocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
;	COMDAT ??1?$_Tree_temp_node_alloc@V?$xalloc@U?$_Tree_node@PAVNvFaceInfo@@PAX@std@@@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Tree_temp_node_alloc@V?$xalloc@U?$_Tree_node@PAVNvFaceInfo@@PAX@std@@@@@std@@QAE@XZ PROC ; std::_Tree_temp_node_alloc<xalloc<std::_Tree_node<NvFaceInfo *,void *> > >::~_Tree_temp_node_alloc<xalloc<std::_Tree_node<NvFaceInfo *,void *> > >, COMDAT
; _this$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 970  :         if (_Ptr) {

	mov	eax, DWORD PTR [ecx+4]
	test	eax, eax
	je	SHORT $LN9@Tree_temp_
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN9@Tree_temp_:
	ret	0
??1?$_Tree_temp_node_alloc@V?$xalloc@U?$_Tree_node@PAVNvFaceInfo@@PAX@std@@@@@std@@QAE@XZ ENDP ; std::_Tree_temp_node_alloc<xalloc<std::_Tree_node<NvFaceInfo *,void *> > >::~_Tree_temp_node_alloc<xalloc<std::_Tree_node<NvFaceInfo *,void *> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??1?$_Alloc_construct_ptr@V?$xalloc@U?$_Tree_node@PAVNvFaceInfo@@PAX@std@@@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Alloc_construct_ptr@V?$xalloc@U?$_Tree_node@PAVNvFaceInfo@@PAX@std@@@@@std@@QAE@XZ PROC ; std::_Alloc_construct_ptr<xalloc<std::_Tree_node<NvFaceInfo *,void *> > >::~_Alloc_construct_ptr<xalloc<std::_Tree_node<NvFaceInfo *,void *> > >, COMDAT
; _this$ = ecx

; 970  :         if (_Ptr) {

	mov	eax, DWORD PTR [ecx+4]
	test	eax, eax
	je	SHORT $LN7@Alloc_cons
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN7@Alloc_cons:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 973  :     }

	ret	0
??1?$_Alloc_construct_ptr@V?$xalloc@U?$_Tree_node@PAVNvFaceInfo@@PAX@std@@@@@std@@QAE@XZ ENDP ; std::_Alloc_construct_ptr<xalloc<std::_Tree_node<NvFaceInfo *,void *> > >::~_Alloc_construct_ptr<xalloc<std::_Tree_node<NvFaceInfo *,void *> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$less@PAVNvFaceInfo@@@std@@V?$_Compressed_pair@V?$xalloc@U?$_Tree_node@PAVNvFaceInfo@@PAX@std@@@@V?$_Tree_val@U?$_Tree_simple_types@PAVNvFaceInfo@@@std@@@std@@$00@2@$00@std@@QBEABU?$less@PAVNvFaceInfo@@@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@U?$less@PAVNvFaceInfo@@@std@@V?$_Compressed_pair@V?$xalloc@U?$_Tree_node@PAVNvFaceInfo@@PAX@std@@@@V?$_Tree_val@U?$_Tree_simple_types@PAVNvFaceInfo@@@std@@@std@@$00@2@$00@std@@QBEABU?$less@PAVNvFaceInfo@@@2@XZ PROC ; std::_Compressed_pair<std::less<NvFaceInfo *>,std::_Compressed_pair<xalloc<std::_Tree_node<NvFaceInfo *,void *> >,std::_Tree_val<std::_Tree_simple_types<NvFaceInfo *> >,1>,1>::_Get_first, COMDAT
; _this$ = ecx

; 1343 :         return *this;

	mov	eax, ecx

; 1344 :     }

	ret	0
?_Get_first@?$_Compressed_pair@U?$less@PAVNvFaceInfo@@@std@@V?$_Compressed_pair@V?$xalloc@U?$_Tree_node@PAVNvFaceInfo@@PAX@std@@@@V?$_Tree_val@U?$_Tree_simple_types@PAVNvFaceInfo@@@std@@@std@@$00@2@$00@std@@QBEABU?$less@PAVNvFaceInfo@@@2@XZ ENDP ; std::_Compressed_pair<std::less<NvFaceInfo *>,std::_Compressed_pair<xalloc<std::_Tree_node<NvFaceInfo *,void *> >,std::_Tree_val<std::_Tree_simple_types<NvFaceInfo *> >,1>,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xtree
;	COMDAT ?_Rrotate@?$_Tree_val@U?$_Tree_simple_types@PAVNvFaceInfo@@@std@@@std@@QAEXPAU?$_Tree_node@PAVNvFaceInfo@@PAX@2@@Z
_TEXT	SEGMENT
__Wherenode$ = 8					; size = 4
?_Rrotate@?$_Tree_val@U?$_Tree_simple_types@PAVNvFaceInfo@@@std@@@std@@QAEXPAU?$_Tree_node@PAVNvFaceInfo@@PAX@2@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<NvFaceInfo *> >::_Rrotate, COMDAT
; _this$ = ecx

; 481  :         _Nodeptr _Pnode   = _Wherenode->_Left;

	mov	edx, DWORD PTR __Wherenode$[esp-4]
	push	esi
	mov	esi, DWORD PTR [edx]

; 482  :         _Wherenode->_Left = _Pnode->_Right;

	mov	eax, DWORD PTR [esi+8]
	mov	DWORD PTR [edx], eax

; 483  : 
; 484  :         if (!_Pnode->_Right->_Isnil) {

	mov	eax, DWORD PTR [esi+8]
	cmp	BYTE PTR [eax+13], 0
	jne	SHORT $LN2@Rrotate

; 485  :             _Pnode->_Right->_Parent = _Wherenode;

	mov	DWORD PTR [eax+4], edx
$LN2@Rrotate:

; 486  :         }
; 487  : 
; 488  :         _Pnode->_Parent = _Wherenode->_Parent;

	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [esi+4], eax

; 489  : 
; 490  :         if (_Wherenode == _Myhead->_Parent) {

	mov	eax, DWORD PTR [ecx]
	cmp	edx, DWORD PTR [eax+4]
	jne	SHORT $LN3@Rrotate

; 491  :             _Myhead->_Parent = _Pnode;

	mov	DWORD PTR [eax+4], esi

; 496  :         }
; 497  : 
; 498  :         _Pnode->_Right      = _Wherenode;
; 499  :         _Wherenode->_Parent = _Pnode;
; 500  :     }

	mov	DWORD PTR [esi+8], edx
	mov	DWORD PTR [edx+4], esi
	pop	esi
	ret	4
$LN3@Rrotate:

; 492  :         } else if (_Wherenode == _Wherenode->_Parent->_Right) {

	mov	eax, DWORD PTR [edx+4]
	cmp	edx, DWORD PTR [eax+8]
	jne	SHORT $LN5@Rrotate

; 493  :             _Wherenode->_Parent->_Right = _Pnode;

	mov	DWORD PTR [eax+8], esi

; 496  :         }
; 497  : 
; 498  :         _Pnode->_Right      = _Wherenode;
; 499  :         _Wherenode->_Parent = _Pnode;
; 500  :     }

	mov	DWORD PTR [esi+8], edx
	mov	DWORD PTR [edx+4], esi
	pop	esi
	ret	4
$LN5@Rrotate:

; 494  :         } else {
; 495  :             _Wherenode->_Parent->_Left = _Pnode;

	mov	DWORD PTR [eax], esi

; 496  :         }
; 497  : 
; 498  :         _Pnode->_Right      = _Wherenode;
; 499  :         _Wherenode->_Parent = _Pnode;
; 500  :     }

	mov	DWORD PTR [esi+8], edx
	mov	DWORD PTR [edx+4], esi
	pop	esi
	ret	4
?_Rrotate@?$_Tree_val@U?$_Tree_simple_types@PAVNvFaceInfo@@@std@@@std@@QAEXPAU?$_Tree_node@PAVNvFaceInfo@@PAX@2@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<NvFaceInfo *> >::_Rrotate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xtree
;	COMDAT ?_Lrotate@?$_Tree_val@U?$_Tree_simple_types@PAVNvFaceInfo@@@std@@@std@@QAEXPAU?$_Tree_node@PAVNvFaceInfo@@PAX@2@@Z
_TEXT	SEGMENT
__Wherenode$ = 8					; size = 4
?_Lrotate@?$_Tree_val@U?$_Tree_simple_types@PAVNvFaceInfo@@@std@@@std@@QAEXPAU?$_Tree_node@PAVNvFaceInfo@@PAX@2@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<NvFaceInfo *> >::_Lrotate, COMDAT
; _this$ = ecx

; 459  :         _Nodeptr _Pnode    = _Wherenode->_Right;

	mov	edx, DWORD PTR __Wherenode$[esp-4]
	push	esi
	mov	esi, DWORD PTR [edx+8]

; 460  :         _Wherenode->_Right = _Pnode->_Left;

	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [edx+8], eax

; 461  : 
; 462  :         if (!_Pnode->_Left->_Isnil) {

	mov	eax, DWORD PTR [esi]
	cmp	BYTE PTR [eax+13], 0
	jne	SHORT $LN2@Lrotate

; 463  :             _Pnode->_Left->_Parent = _Wherenode;

	mov	DWORD PTR [eax+4], edx
$LN2@Lrotate:

; 464  :         }
; 465  : 
; 466  :         _Pnode->_Parent = _Wherenode->_Parent;

	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [esi+4], eax

; 467  : 
; 468  :         if (_Wherenode == _Myhead->_Parent) {

	mov	eax, DWORD PTR [ecx]
	cmp	edx, DWORD PTR [eax+4]
	jne	SHORT $LN3@Lrotate

; 469  :             _Myhead->_Parent = _Pnode;

	mov	DWORD PTR [eax+4], esi

; 474  :         }
; 475  : 
; 476  :         _Pnode->_Left       = _Wherenode;
; 477  :         _Wherenode->_Parent = _Pnode;
; 478  :     }

	mov	DWORD PTR [esi], edx
	mov	DWORD PTR [edx+4], esi
	pop	esi
	ret	4
$LN3@Lrotate:

; 470  :         } else if (_Wherenode == _Wherenode->_Parent->_Left) {

	mov	eax, DWORD PTR [edx+4]
	cmp	edx, DWORD PTR [eax]
	jne	SHORT $LN5@Lrotate

; 471  :             _Wherenode->_Parent->_Left = _Pnode;

	mov	DWORD PTR [eax], esi

; 474  :         }
; 475  : 
; 476  :         _Pnode->_Left       = _Wherenode;
; 477  :         _Wherenode->_Parent = _Pnode;
; 478  :     }

	mov	DWORD PTR [esi], edx
	mov	DWORD PTR [edx+4], esi
	pop	esi
	ret	4
$LN5@Lrotate:

; 472  :         } else {
; 473  :             _Wherenode->_Parent->_Right = _Pnode;

	mov	DWORD PTR [eax+8], esi

; 474  :         }
; 475  : 
; 476  :         _Pnode->_Left       = _Wherenode;
; 477  :         _Wherenode->_Parent = _Pnode;
; 478  :     }

	mov	DWORD PTR [esi], edx
	mov	DWORD PTR [edx+4], esi
	pop	esi
	ret	4
?_Lrotate@?$_Tree_val@U?$_Tree_simple_types@PAVNvFaceInfo@@@std@@@std@@QAEXPAU?$_Tree_node@PAVNvFaceInfo@@PAX@2@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<NvFaceInfo *> >::_Lrotate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xtree
;	COMDAT ?max_size@?$_Tree@V?$_Tset_traits@PAVNvFaceInfo@@U?$less@PAVNvFaceInfo@@@std@@V?$xalloc@PAVNvFaceInfo@@@@$0A@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$_Tree@V?$_Tset_traits@PAVNvFaceInfo@@U?$less@PAVNvFaceInfo@@@std@@V?$xalloc@PAVNvFaceInfo@@@@$0A@@std@@@std@@QBEIXZ PROC ; std::_Tree<std::_Tset_traits<NvFaceInfo *,std::less<NvFaceInfo *>,xalloc<NvFaceInfo *>,0> >::max_size, COMDAT
; _this$dead$ = ecx

; 1206 :         return (_STD min)(

	mov	eax, 214748364				; 0cccccccH

; 1207 :             static_cast<size_type>((numeric_limits<difference_type>::max)()), _Alnode_traits::max_size(_Getal()));
; 1208 :     }

	ret	0
?max_size@?$_Tree@V?$_Tset_traits@PAVNvFaceInfo@@U?$less@PAVNvFaceInfo@@@std@@V?$xalloc@PAVNvFaceInfo@@@@$0A@@std@@@std@@QBEIXZ ENDP ; std::_Tree<std::_Tset_traits<NvFaceInfo *,std::less<NvFaceInfo *>,xalloc<NvFaceInfo *>,0> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?deallocate@?$xalloc@U?$_Tree_node@PAVNvFaceInfo@@PAX@std@@@@QBEXPAU?$_Tree_node@PAVNvFaceInfo@@PAX@std@@I@Z
_TEXT	SEGMENT
_p$ = 8							; size = 4
_n$dead$ = 12						; size = 4
?deallocate@?$xalloc@U?$_Tree_node@PAVNvFaceInfo@@PAX@std@@@@QBEXPAU?$_Tree_node@PAVNvFaceInfo@@PAX@std@@I@Z PROC ; xalloc<std::_Tree_node<NvFaceInfo *,void *> >::deallocate, COMDAT
; _this$dead$ = ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	eax, DWORD PTR _p$[esp-4]
	test	eax, eax
	je	SHORT $LN4@deallocate
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN4@deallocate:
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 82   : 							void					deallocate		(pointer p, size_type n) const			{	xr_free	(p);				}

	ret	8
?deallocate@?$xalloc@U?$_Tree_node@PAVNvFaceInfo@@PAX@std@@@@QBEXPAU?$_Tree_node@PAVNvFaceInfo@@PAX@std@@I@Z ENDP ; xalloc<std::_Tree_node<NvFaceInfo *,void *> >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Getal@?$vector@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@V?$xalloc@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@@@std@@ABEABV?$xalloc@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@@XZ
_TEXT	SEGMENT
?_Getal@?$vector@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@V?$xalloc@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@@@std@@ABEABV?$xalloc@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@@XZ PROC ; std::vector<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> >,xalloc<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> > > >::_Getal, COMDAT
; _this$ = ecx

; 1809 :         return _Mypair._Get_first();

	mov	eax, ecx

; 1810 :     }

	ret	0
?_Getal@?$vector@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@V?$xalloc@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@@@std@@ABEABV?$xalloc@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@@XZ ENDP ; std::vector<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> >,xalloc<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> > > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Umove_if_noexcept1@?$vector@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@V?$xalloc@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@@@std@@AAEXPAV?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@00U?$integral_constant@_N$00@2@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
tv546 = 16						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
?_Umove_if_noexcept1@?$vector@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@V?$xalloc@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@@@std@@AAEXPAV?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@00U?$integral_constant@_N$00@2@@Z PROC ; std::vector<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> >,xalloc<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> > > >::_Umove_if_noexcept1, COMDAT
; _this$dead$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	mov	ecx, DWORD PTR __First$[esp-4]
	cmp	ecx, DWORD PTR __Last$[esp-4]
	je	$LN5@Umove_if_n

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	eax, DWORD PTR __Dest$[esp-4]
	mov	edx, ecx
	push	ebx
	push	ebp
	push	esi
	sub	edx, eax
	lea	ebx, DWORD PTR [eax+4]
	push	edi
	mov	DWORD PTR tv546[esp+12], edx
$LL6@Umove_if_n:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ebx-4], 0
	mov	DWORD PTR [ebx], 0
	mov	DWORD PTR [ebx+4], 0

; 546  :         const pointer _Rightfirst = _Right_data._Myfirst;

	mov	esi, DWORD PTR [ecx]

; 547  :         const pointer _Rightlast  = _Right_data._Mylast;

	mov	ebp, DWORD PTR [ebx+edx]

; 548  :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);
; 549  :         if (_Rightfirst != _Rightlast) {

	cmp	esi, ebp
	je	SHORT $LN48@Umove_if_n
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 550  :             _Buy_raw(static_cast<size_type>(_Rightlast - _Rightfirst));

	mov	eax, ebp
	sub	eax, esi
	sar	eax, 2
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	lea	edi, DWORD PTR [eax*4]
	push	edi
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1698 :         const auto _Newvec = _Getal().allocate(_Newcapacity);

	mov	edx, eax

; 1699 :         _Myfirst           = _Newvec;

	mov	DWORD PTR [ebx-4], edx

; 1700 :         _Mylast            = _Newvec;

	mov	DWORD PTR [ebx], edx

; 1701 :         _Myend             = _Newvec + _Newcapacity;

	lea	ecx, DWORD PTR [edi+edx]
	mov	DWORD PTR [ebx+4], ecx
$LL36@Umove_if_n:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1620 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

	mov	eax, DWORD PTR [esi]

; 1658 :     for (; _UFirst != _ULast; ++_UFirst) {

	add	esi, 4

; 1620 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

	mov	DWORD PTR [edx], eax

; 1621 :         ++_Last;

	add	edx, 4

; 1658 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	esi, ebp
	jne	SHORT $LL36@Umove_if_n
	mov	ecx, DWORD PTR __First$[esp+12]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 552  :             _My_data._Mylast = _Ucopy(_Rightfirst, _Rightlast, _My_data._Myfirst);

	mov	DWORD PTR [ebx], edx
	mov	edx, DWORD PTR tv546[esp+12]
$LN48@Umove_if_n:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1621 :         ++_Last;

	add	ecx, 12					; 0000000cH
	add	ebx, 12					; 0000000cH
	mov	DWORD PTR __First$[esp+12], ecx

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	ecx, DWORD PTR __Last$[esp+12]
	jne	SHORT $LL6@Umove_if_n
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
$LN5@Umove_if_n:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1652 :     }

	ret	16					; 00000010H
?_Umove_if_noexcept1@?$vector@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@V?$xalloc@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@@@std@@AAEXPAV?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@00U?$integral_constant@_N$00@2@@Z ENDP ; std::vector<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> >,xalloc<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> > > >::_Umove_if_noexcept1
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?capacity@?$vector@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@V?$xalloc@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@V?$xalloc@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@@@std@@QBEIXZ PROC ; std::vector<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> >,xalloc<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> > > >::capacity, COMDAT
; _this$ = ecx

; 1545 :         auto& _My_data = _Mypair._Myval2;
; 1546 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx]
	sar	eax, 2
	imul	eax, eax, -1431655765

; 1547 :     }

	ret	0
?capacity@?$vector@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@V?$xalloc@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@@@std@@QBEIXZ ENDP ; std::vector<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> >,xalloc<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> > > >::capacity
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?max_size@?$_Normal_allocator_traits@V?$xalloc@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@@@std@@SAIABV?$xalloc@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@@@Z
_TEXT	SEGMENT
?max_size@?$_Normal_allocator_traits@V?$xalloc@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@@@std@@SAIABV?$xalloc@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@@@Z PROC ; std::_Normal_allocator_traits<xalloc<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> > > >::max_size, COMDAT
; __Al$dead$ = ecx

; 591  :         if constexpr (_Has_max_size<_Alloc>::value) {
; 592  :             return _Al.max_size();

	mov	eax, 357913941				; 15555555H

; 593  :         } else {
; 594  :             return (numeric_limits<size_type>::max)() / sizeof(value_type);
; 595  :         }
; 596  :     }

	ret	0
?max_size@?$_Normal_allocator_traits@V?$xalloc@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@@@std@@SAIABV?$xalloc@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@@@Z ENDP ; std::_Normal_allocator_traits<xalloc<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> > > >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Getal@?$vector@PAVNvEdgeInfo@@V?$xalloc@PAVNvEdgeInfo@@@@@std@@ABEABV?$xalloc@PAVNvEdgeInfo@@@@XZ
_TEXT	SEGMENT
?_Getal@?$vector@PAVNvEdgeInfo@@V?$xalloc@PAVNvEdgeInfo@@@@@std@@ABEABV?$xalloc@PAVNvEdgeInfo@@@@XZ PROC ; std::vector<NvEdgeInfo *,xalloc<NvEdgeInfo *> >::_Getal, COMDAT
; _this$ = ecx

; 1809 :         return _Mypair._Get_first();

	mov	eax, ecx

; 1810 :     }

	ret	0
?_Getal@?$vector@PAVNvEdgeInfo@@V?$xalloc@PAVNvEdgeInfo@@@@@std@@ABEABV?$xalloc@PAVNvEdgeInfo@@@@XZ ENDP ; std::vector<NvEdgeInfo *,xalloc<NvEdgeInfo *> >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Umove_if_noexcept1@?$vector@PAVNvEdgeInfo@@V?$xalloc@PAVNvEdgeInfo@@@@@std@@AAEXPAPAVNvEdgeInfo@@00U?$integral_constant@_N$00@2@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
?_Umove_if_noexcept1@?$vector@PAVNvEdgeInfo@@V?$xalloc@PAVNvEdgeInfo@@@@@std@@AAEXPAPAVNvEdgeInfo@@00U?$integral_constant@_N$00@2@@Z PROC ; std::vector<NvEdgeInfo *,xalloc<NvEdgeInfo *> >::_Umove_if_noexcept1, COMDAT
; _this$dead$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1703 :     auto _UFirst      = _Get_unwrapped(_First);

	mov	eax, DWORD PTR __First$[esp-4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1649 :     _CONSTEXPR20_CONTAINER void _Umove_if_noexcept1(pointer _First, pointer _Last, pointer _Dest, true_type) {

	push	esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	mov	esi, DWORD PTR __Last$[esp]
	cmp	eax, esi
	je	SHORT $LN5@Umove_if_n

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	edx, DWORD PTR __Dest$[esp]
	sub	edx, eax
$LL6@Umove_if_n:

; 1620 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx+eax], ecx

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	add	eax, 4
	cmp	eax, esi
	jne	SHORT $LL6@Umove_if_n
$LN5@Umove_if_n:
	pop	esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1652 :     }

	ret	16					; 00000010H
?_Umove_if_noexcept1@?$vector@PAVNvEdgeInfo@@V?$xalloc@PAVNvEdgeInfo@@@@@std@@AAEXPAPAVNvEdgeInfo@@00U?$integral_constant@_N$00@2@@Z ENDP ; std::vector<NvEdgeInfo *,xalloc<NvEdgeInfo *> >::_Umove_if_noexcept1
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?capacity@?$vector@PAVNvEdgeInfo@@V?$xalloc@PAVNvEdgeInfo@@@@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@PAVNvEdgeInfo@@V?$xalloc@PAVNvEdgeInfo@@@@@std@@QBEIXZ PROC ; std::vector<NvEdgeInfo *,xalloc<NvEdgeInfo *> >::capacity, COMDAT
; _this$ = ecx

; 1545 :         auto& _My_data = _Mypair._Myval2;
; 1546 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx]
	sar	eax, 2

; 1547 :     }

	ret	0
?capacity@?$vector@PAVNvEdgeInfo@@V?$xalloc@PAVNvEdgeInfo@@@@@std@@QBEIXZ ENDP ; std::vector<NvEdgeInfo *,xalloc<NvEdgeInfo *> >::capacity
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?max_size@?$_Normal_allocator_traits@V?$xalloc@PAVNvEdgeInfo@@@@@std@@SAIABV?$xalloc@PAVNvEdgeInfo@@@@@Z
_TEXT	SEGMENT
?max_size@?$_Normal_allocator_traits@V?$xalloc@PAVNvEdgeInfo@@@@@std@@SAIABV?$xalloc@PAVNvEdgeInfo@@@@@Z PROC ; std::_Normal_allocator_traits<xalloc<NvEdgeInfo *> >::max_size, COMDAT
; __Al$dead$ = ecx

; 591  :         if constexpr (_Has_max_size<_Alloc>::value) {
; 592  :             return _Al.max_size();

	mov	eax, 1073741823				; 3fffffffH

; 593  :         } else {
; 594  :             return (numeric_limits<size_type>::max)() / sizeof(value_type);
; 595  :         }
; 596  :     }

	ret	0
?max_size@?$_Normal_allocator_traits@V?$xalloc@PAVNvEdgeInfo@@@@@std@@SAIABV?$xalloc@PAVNvEdgeInfo@@@@@Z ENDP ; std::_Normal_allocator_traits<xalloc<NvEdgeInfo *> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xtree
;	COMDAT ?_Getal@?$_Tree@V?$_Tset_traits@PAVNvFaceInfo@@U?$less@PAVNvFaceInfo@@@std@@V?$xalloc@PAVNvFaceInfo@@@@$0A@@std@@@std@@IBEABV?$xalloc@U?$_Tree_node@PAVNvFaceInfo@@PAX@std@@@@XZ
_TEXT	SEGMENT
?_Getal@?$_Tree@V?$_Tset_traits@PAVNvFaceInfo@@U?$less@PAVNvFaceInfo@@@std@@V?$xalloc@PAVNvFaceInfo@@@@$0A@@std@@@std@@IBEABV?$xalloc@U?$_Tree_node@PAVNvFaceInfo@@PAX@std@@@@XZ PROC ; std::_Tree<std::_Tset_traits<NvFaceInfo *,std::less<NvFaceInfo *>,xalloc<NvFaceInfo *>,0> >::_Getal, COMDAT
; _this$ = ecx

; 1939 :         return _Mypair._Myval2._Get_first();

	mov	eax, ecx

; 1940 :     }

	ret	0
?_Getal@?$_Tree@V?$_Tset_traits@PAVNvFaceInfo@@U?$less@PAVNvFaceInfo@@@std@@V?$xalloc@PAVNvFaceInfo@@@@$0A@@std@@@std@@IBEABV?$xalloc@U?$_Tree_node@PAVNvFaceInfo@@PAX@std@@@@XZ ENDP ; std::_Tree<std::_Tset_traits<NvFaceInfo *,std::less<NvFaceInfo *>,xalloc<NvFaceInfo *>,0> >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?max_size@?$_Normal_allocator_traits@V?$xalloc@U?$_Tree_node@PAVNvFaceInfo@@PAX@std@@@@@std@@SAIABV?$xalloc@U?$_Tree_node@PAVNvFaceInfo@@PAX@std@@@@@Z
_TEXT	SEGMENT
?max_size@?$_Normal_allocator_traits@V?$xalloc@U?$_Tree_node@PAVNvFaceInfo@@PAX@std@@@@@std@@SAIABV?$xalloc@U?$_Tree_node@PAVNvFaceInfo@@PAX@std@@@@@Z PROC ; std::_Normal_allocator_traits<xalloc<std::_Tree_node<NvFaceInfo *,void *> > >::max_size, COMDAT
; __Al$dead$ = ecx

; 591  :         if constexpr (_Has_max_size<_Alloc>::value) {
; 592  :             return _Al.max_size();

	mov	eax, 214748364				; 0cccccccH

; 593  :         } else {
; 594  :             return (numeric_limits<size_type>::max)() / sizeof(value_type);
; 595  :         }
; 596  :     }

	ret	0
?max_size@?$_Normal_allocator_traits@V?$xalloc@U?$_Tree_node@PAVNvFaceInfo@@PAX@std@@@@@std@@SAIABV?$xalloc@U?$_Tree_node@PAVNvFaceInfo@@PAX@std@@@@@Z ENDP ; std::_Normal_allocator_traits<xalloc<std::_Tree_node<NvFaceInfo *,void *> > >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$xalloc@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@@V?$_Vector_val@U?$_Simple_types@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@std@@@std@@$00@std@@QBEABV?$xalloc@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@V?$xalloc@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@@V?$_Vector_val@U?$_Simple_types@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@std@@@std@@$00@std@@QBEABV?$xalloc@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@@XZ PROC ; std::_Compressed_pair<xalloc<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> > >,std::_Vector_val<std::_Simple_types<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> > > >,1>::_Get_first, COMDAT
; _this$ = ecx

; 1343 :         return *this;

	mov	eax, ecx

; 1344 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$xalloc@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@@V?$_Vector_val@U?$_Simple_types@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@std@@@std@@$00@std@@QBEABV?$xalloc@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@@XZ ENDP ; std::_Compressed_pair<xalloc<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> > >,std::_Vector_val<std::_Simple_types<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> > > >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?max_size@?$xalloc@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$xalloc@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@@QBEIXZ PROC ; xalloc<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> > >::max_size, COMDAT
; _this$dead$ = ecx

; 86   : 							size_type				max_size		() const								{	size_type _Count = (size_type)(-1) / sizeof (T);	return (0 < _Count ? _Count : 1);	}

	mov	eax, 357913941				; 15555555H
	ret	0
?max_size@?$xalloc@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@@QBEIXZ ENDP ; xalloc<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> > >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$xalloc@PAVNvEdgeInfo@@@@V?$_Vector_val@U?$_Simple_types@PAVNvEdgeInfo@@@std@@@std@@$00@std@@QBEABV?$xalloc@PAVNvEdgeInfo@@@@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@V?$xalloc@PAVNvEdgeInfo@@@@V?$_Vector_val@U?$_Simple_types@PAVNvEdgeInfo@@@std@@@std@@$00@std@@QBEABV?$xalloc@PAVNvEdgeInfo@@@@XZ PROC ; std::_Compressed_pair<xalloc<NvEdgeInfo *>,std::_Vector_val<std::_Simple_types<NvEdgeInfo *> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 1343 :         return *this;

	mov	eax, ecx

; 1344 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$xalloc@PAVNvEdgeInfo@@@@V?$_Vector_val@U?$_Simple_types@PAVNvEdgeInfo@@@std@@@std@@$00@std@@QBEABV?$xalloc@PAVNvEdgeInfo@@@@XZ ENDP ; std::_Compressed_pair<xalloc<NvEdgeInfo *>,std::_Vector_val<std::_Simple_types<NvEdgeInfo *> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?max_size@?$xalloc@PAVNvEdgeInfo@@@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$xalloc@PAVNvEdgeInfo@@@@QBEIXZ PROC		; xalloc<NvEdgeInfo *>::max_size, COMDAT
; _this$dead$ = ecx

; 86   : 							size_type				max_size		() const								{	size_type _Count = (size_type)(-1) / sizeof (T);	return (0 < _Count ? _Count : 1);	}

	mov	eax, 1073741823				; 3fffffffH
	ret	0
?max_size@?$xalloc@PAVNvEdgeInfo@@@@QBEIXZ ENDP		; xalloc<NvEdgeInfo *>::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$xalloc@U?$_Tree_node@PAVNvFaceInfo@@PAX@std@@@@V?$_Tree_val@U?$_Tree_simple_types@PAVNvFaceInfo@@@std@@@std@@$00@std@@QBEABV?$xalloc@U?$_Tree_node@PAVNvFaceInfo@@PAX@std@@@@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@V?$xalloc@U?$_Tree_node@PAVNvFaceInfo@@PAX@std@@@@V?$_Tree_val@U?$_Tree_simple_types@PAVNvFaceInfo@@@std@@@std@@$00@std@@QBEABV?$xalloc@U?$_Tree_node@PAVNvFaceInfo@@PAX@std@@@@XZ PROC ; std::_Compressed_pair<xalloc<std::_Tree_node<NvFaceInfo *,void *> >,std::_Tree_val<std::_Tree_simple_types<NvFaceInfo *> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 1343 :         return *this;

	mov	eax, ecx

; 1344 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$xalloc@U?$_Tree_node@PAVNvFaceInfo@@PAX@std@@@@V?$_Tree_val@U?$_Tree_simple_types@PAVNvFaceInfo@@@std@@@std@@$00@std@@QBEABV?$xalloc@U?$_Tree_node@PAVNvFaceInfo@@PAX@std@@@@XZ ENDP ; std::_Compressed_pair<xalloc<std::_Tree_node<NvFaceInfo *,void *> >,std::_Tree_val<std::_Tree_simple_types<NvFaceInfo *> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?max_size@?$xalloc@U?$_Tree_node@PAVNvFaceInfo@@PAX@std@@@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$xalloc@U?$_Tree_node@PAVNvFaceInfo@@PAX@std@@@@QBEIXZ PROC ; xalloc<std::_Tree_node<NvFaceInfo *,void *> >::max_size, COMDAT
; _this$dead$ = ecx

; 86   : 							size_type				max_size		() const								{	size_type _Count = (size_type)(-1) / sizeof (T);	return (0 < _Count ? _Count : 1);	}

	mov	eax, 214748364				; 0cccccccH
	ret	0
?max_size@?$xalloc@U?$_Tree_node@PAVNvFaceInfo@@PAX@std@@@@QBEIXZ ENDP ; xalloc<std::_Tree_node<NvFaceInfo *,void *> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
;	COMDAT ??$?0AAPAU?$_Tree_node@PAVNvFaceInfo@@PAX@std@@_N$0A@@?$pair@PAU?$_Tree_node@PAVNvFaceInfo@@PAX@std@@_N@std@@QAE@AAPAU?$_Tree_node@PAVNvFaceInfo@@PAX@1@$$QA_N@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??$?0AAPAU?$_Tree_node@PAVNvFaceInfo@@PAX@std@@_N$0A@@?$pair@PAU?$_Tree_node@PAVNvFaceInfo@@PAX@std@@_N@std@@QAE@AAPAU?$_Tree_node@PAVNvFaceInfo@@PAX@1@$$QA_N@Z PROC ; std::pair<std::_Tree_node<NvFaceInfo *,void *> *,bool>::pair<std::_Tree_node<NvFaceInfo *,void *> *,bool><std::_Tree_node<NvFaceInfo *,void *> * &,bool,0>, COMDAT
; _this$ = ecx

; 186  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

	mov	eax, DWORD PTR __Val1$[esp-4]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR __Val2$[esp-4]
	mov	al, BYTE PTR [eax]
	mov	BYTE PTR [ecx+4], al
	mov	eax, ecx
	ret	8
??$?0AAPAU?$_Tree_node@PAVNvFaceInfo@@PAX@std@@_N$0A@@?$pair@PAU?$_Tree_node@PAVNvFaceInfo@@PAX@std@@_N@std@@QAE@AAPAU?$_Tree_node@PAVNvFaceInfo@@PAX@1@$$QA_N@Z ENDP ; std::pair<std::_Tree_node<NvFaceInfo *,void *> *,bool>::pair<std::_Tree_node<NvFaceInfo *,void *> *,bool><std::_Tree_node<NvFaceInfo *,void *> * &,bool,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xtree
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xtree
;	COMDAT ??$?0ABQAVNvFaceInfo@@@?$_Tree_temp_node@V?$xalloc@U?$_Tree_node@PAVNvFaceInfo@@PAX@std@@@@@std@@QAE@AAV?$xalloc@U?$_Tree_node@PAVNvFaceInfo@@PAX@std@@@@PAU?$_Tree_node@PAVNvFaceInfo@@PAX@1@ABQAVNvFaceInfo@@@Z
_TEXT	SEGMENT
__Al_$ = 8						; size = 4
__Myhead$ = 12						; size = 4
_<_Vals_0>$ = 16					; size = 4
??$?0ABQAVNvFaceInfo@@@?$_Tree_temp_node@V?$xalloc@U?$_Tree_node@PAVNvFaceInfo@@PAX@std@@@@@std@@QAE@AAV?$xalloc@U?$_Tree_node@PAVNvFaceInfo@@PAX@std@@@@PAU?$_Tree_node@PAVNvFaceInfo@@PAX@1@ABQAVNvFaceInfo@@@Z PROC ; std::_Tree_temp_node<xalloc<std::_Tree_node<NvFaceInfo *,void *> > >::_Tree_temp_node<xalloc<std::_Tree_node<NvFaceInfo *,void *> > ><NvFaceInfo * const &>, COMDAT
; _this$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 958  :     _CONSTEXPR20_DYNALLOC explicit _Alloc_construct_ptr(_Alloc& _Al_) : _Al(_Al_), _Ptr(nullptr) {}

	mov	eax, DWORD PTR __Al_$[esp-4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xtree

; 804  :         : _Tree_temp_node_alloc<_Alnode>(_Al_) {

	push	esi
	mov	esi, ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	push	20					; 00000014H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 958  :     _CONSTEXPR20_DYNALLOC explicit _Alloc_construct_ptr(_Alloc& _Al_) : _Al(_Al_), _Ptr(nullptr) {}

	mov	DWORD PTR [esi], eax

; 965  :         _Ptr = nullptr; // if allocate throws, prevents double-free

	mov	DWORD PTR [esi+4], 0
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xtree

; 805  :         _Alnode_traits::construct(this->_Al, _STD addressof(this->_Ptr->_Myval), _STD forward<_Valtys>(_Vals)...);

	mov	ecx, DWORD PTR _<_Vals_0>$[esp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 966  :         _Ptr = _Al.allocate(1);

	mov	DWORD PTR [esi+4], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xtree

; 805  :         _Alnode_traits::construct(this->_Al, _STD addressof(this->_Ptr->_Myval), _STD forward<_Valtys>(_Vals)...);

	mov	ecx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+16], ecx

; 806  :         _Construct_in_place(this->_Ptr->_Left, _Myhead);

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR __Myhead$[esp]
	mov	DWORD PTR [eax], ecx

; 807  :         _Construct_in_place(this->_Ptr->_Parent, _Myhead);

	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [eax+4], ecx

; 808  :         _Construct_in_place(this->_Ptr->_Right, _Myhead);

	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [eax+8], ecx

; 809  :         this->_Ptr->_Color = _Red;

	mov	eax, DWORD PTR [esi+4]
	mov	BYTE PTR [eax+12], 0

; 810  :         this->_Ptr->_Isnil = false;

	mov	eax, DWORD PTR [esi+4]
	mov	BYTE PTR [eax+13], 0

; 811  :     }

	mov	eax, esi
	pop	esi
	ret	12					; 0000000cH
??$?0ABQAVNvFaceInfo@@@?$_Tree_temp_node@V?$xalloc@U?$_Tree_node@PAVNvFaceInfo@@PAX@std@@@@@std@@QAE@AAV?$xalloc@U?$_Tree_node@PAVNvFaceInfo@@PAX@std@@@@PAU?$_Tree_node@PAVNvFaceInfo@@PAX@1@ABQAVNvFaceInfo@@@Z ENDP ; std::_Tree_temp_node<xalloc<std::_Tree_node<NvFaceInfo *,void *> > >::_Tree_temp_node<xalloc<std::_Tree_node<NvFaceInfo *,void *> > ><NvFaceInfo * const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
;	COMDAT ??$?0PAU?$_Tree_node@PAVNvFaceInfo@@PAX@std@@_N$0A@@?$pair@PAU?$_Tree_node@PAVNvFaceInfo@@PAX@std@@_N@std@@QAE@$$QAPAU?$_Tree_node@PAVNvFaceInfo@@PAX@1@$$QA_N@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??$?0PAU?$_Tree_node@PAVNvFaceInfo@@PAX@std@@_N$0A@@?$pair@PAU?$_Tree_node@PAVNvFaceInfo@@PAX@std@@_N@std@@QAE@$$QAPAU?$_Tree_node@PAVNvFaceInfo@@PAX@1@$$QA_N@Z PROC ; std::pair<std::_Tree_node<NvFaceInfo *,void *> *,bool>::pair<std::_Tree_node<NvFaceInfo *,void *> *,bool><std::_Tree_node<NvFaceInfo *,void *> *,bool,0>, COMDAT
; _this$ = ecx

; 186  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

	mov	eax, DWORD PTR __Val1$[esp-4]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR __Val2$[esp-4]
	mov	al, BYTE PTR [eax]
	mov	BYTE PTR [ecx+4], al
	mov	eax, ecx
	ret	8
??$?0PAU?$_Tree_node@PAVNvFaceInfo@@PAX@std@@_N$0A@@?$pair@PAU?$_Tree_node@PAVNvFaceInfo@@PAX@std@@_N@std@@QAE@$$QAPAU?$_Tree_node@PAVNvFaceInfo@@PAX@1@$$QA_N@Z ENDP ; std::pair<std::_Tree_node<NvFaceInfo *,void *> *,bool>::pair<std::_Tree_node<NvFaceInfo *,void *> *,bool><std::_Tree_node<NvFaceInfo *,void *> *,bool,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\type_traits
;	COMDAT ??$forward@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@PAVNvFaceInfo@@@std@@@std@@@std@@@std@@YA$$QAV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@PAVNvFaceInfo@@@std@@@std@@@0@AAV10@@Z
_TEXT	SEGMENT
??$forward@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@PAVNvFaceInfo@@@std@@@std@@@std@@@std@@YA$$QAV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@PAVNvFaceInfo@@@std@@@std@@@0@AAV10@@Z PROC ; std::forward<std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<NvFaceInfo *> > > >, COMDAT
; __Arg$ = ecx

; 1386 :     return static_cast<_Ty&&>(_Arg);

	mov	eax, ecx

; 1387 : }

	ret	0
??$forward@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@PAVNvFaceInfo@@@std@@@std@@@std@@@std@@YA$$QAV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@PAVNvFaceInfo@@@std@@@std@@@0@AAV10@@Z ENDP ; std::forward<std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<NvFaceInfo *> > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
;	COMDAT ??$exchange@PAU?$_Tree_node@PAVNvFaceInfo@@PAX@std@@AAPAU12@@std@@YAPAU?$_Tree_node@PAVNvFaceInfo@@PAX@0@AAPAU10@0@Z
_TEXT	SEGMENT
??$exchange@PAU?$_Tree_node@PAVNvFaceInfo@@PAX@std@@AAPAU12@@std@@YAPAU?$_Tree_node@PAVNvFaceInfo@@PAX@0@AAPAU10@0@Z PROC ; std::exchange<std::_Tree_node<NvFaceInfo *,void *> *,std::_Tree_node<NvFaceInfo *,void *> * &>, COMDAT
; __Val$ = ecx
; __New_val$ = edx

; 601  :     // assign _New_val to _Val, return previous _Val
; 602  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	eax, DWORD PTR [ecx]

; 603  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	edx, DWORD PTR [edx]
	mov	DWORD PTR [ecx], edx

; 604  :     return _Old_val;
; 605  : }

	ret	0
??$exchange@PAU?$_Tree_node@PAVNvFaceInfo@@PAX@std@@AAPAU12@@std@@YAPAU?$_Tree_node@PAVNvFaceInfo@@PAX@0@AAPAU10@0@Z ENDP ; std::exchange<std::_Tree_node<NvFaceInfo *,void *> *,std::_Tree_node<NvFaceInfo *,void *> * &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xtree
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xtree
;	COMDAT ??$_Freenode@V?$xalloc@U?$_Tree_node@PAVNvFaceInfo@@PAX@std@@@@@?$_Tree_node@PAVNvFaceInfo@@PAX@std@@SAXAAV?$xalloc@U?$_Tree_node@PAVNvFaceInfo@@PAX@std@@@@PAU01@@Z
_TEXT	SEGMENT
??$_Freenode@V?$xalloc@U?$_Tree_node@PAVNvFaceInfo@@PAX@std@@@@@?$_Tree_node@PAVNvFaceInfo@@PAX@std@@SAXAAV?$xalloc@U?$_Tree_node@PAVNvFaceInfo@@PAX@std@@@@PAU01@@Z PROC ; std::_Tree_node<NvFaceInfo *,void *>::_Freenode<xalloc<std::_Tree_node<NvFaceInfo *,void *> > >, COMDAT
; __Al$dead$ = ecx
; __Ptr$ = edx
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	test	edx, edx
	je	SHORT $LN10@Freenode
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	edx
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN10@Freenode:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xtree

; 382  :     }

	ret	0
??$_Freenode@V?$xalloc@U?$_Tree_node@PAVNvFaceInfo@@PAX@std@@@@@?$_Tree_node@PAVNvFaceInfo@@PAX@std@@SAXAAV?$xalloc@U?$_Tree_node@PAVNvFaceInfo@@PAX@std@@@@PAU01@@Z ENDP ; std::_Tree_node<NvFaceInfo *,void *>::_Freenode<xalloc<std::_Tree_node<NvFaceInfo *,void *> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Destroy_in_place@PAU?$_Tree_node@PAVNvFaceInfo@@PAX@std@@@std@@YAXAAPAU?$_Tree_node@PAVNvFaceInfo@@PAX@0@@Z
_TEXT	SEGMENT
??$_Destroy_in_place@PAU?$_Tree_node@PAVNvFaceInfo@@PAX@std@@@std@@YAXAAPAU?$_Tree_node@PAVNvFaceInfo@@PAX@0@@Z PROC ; std::_Destroy_in_place<std::_Tree_node<NvFaceInfo *,void *> *>, COMDAT
; __Obj$dead$ = ecx

; 295  :     if constexpr (is_array_v<_Ty>) {
; 296  :         _Destroy_range(_Obj, _Obj + extent_v<_Ty>);
; 297  :     } else {
; 298  :         _Obj.~_Ty();
; 299  :     }
; 300  : }

	ret	0
??$_Destroy_in_place@PAU?$_Tree_node@PAVNvFaceInfo@@PAX@std@@@std@@YAXAAPAU?$_Tree_node@PAVNvFaceInfo@@PAX@0@@Z ENDP ; std::_Destroy_in_place<std::_Tree_node<NvFaceInfo *,void *> *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef
;	COMDAT ??$addressof@PAU?$_Tree_node@PAVNvFaceInfo@@PAX@std@@@std@@YAPAPAU?$_Tree_node@PAVNvFaceInfo@@PAX@0@AAPAU10@@Z
_TEXT	SEGMENT
??$addressof@PAU?$_Tree_node@PAVNvFaceInfo@@PAX@std@@@std@@YAPAPAU?$_Tree_node@PAVNvFaceInfo@@PAX@0@AAPAU10@@Z PROC ; std::addressof<std::_Tree_node<NvFaceInfo *,void *> *>, COMDAT
; __Val$ = ecx

; 253  :     return __builtin_addressof(_Val);

	mov	eax, ecx

; 254  : }

	ret	0
??$addressof@PAU?$_Tree_node@PAVNvFaceInfo@@PAX@std@@@std@@YAPAPAU?$_Tree_node@PAVNvFaceInfo@@PAX@0@AAPAU10@@Z ENDP ; std::addressof<std::_Tree_node<NvFaceInfo *,void *> *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_Voidify_iter@PAPAU?$_Tree_node@PAVNvFaceInfo@@PAX@std@@@std@@YAPAXPAPAU?$_Tree_node@PAVNvFaceInfo@@PAX@0@@Z
_TEXT	SEGMENT
??$_Voidify_iter@PAPAU?$_Tree_node@PAVNvFaceInfo@@PAX@std@@@std@@YAPAXPAPAU?$_Tree_node@PAVNvFaceInfo@@PAX@0@@Z PROC ; std::_Voidify_iter<std::_Tree_node<NvFaceInfo *,void *> * *>, COMDAT
; __It$ = ecx

; 124  :     if constexpr (is_pointer_v<_Iter>) {
; 125  :         return const_cast<void*>(static_cast<const volatile void*>(_It));

	mov	eax, ecx

; 126  :     } else {
; 127  :         return const_cast<void*>(static_cast<const volatile void*>(_STD addressof(*_It)));
; 128  :     }
; 129  : }

	ret	0
??$_Voidify_iter@PAPAU?$_Tree_node@PAVNvFaceInfo@@PAX@std@@@std@@YAPAXPAPAU?$_Tree_node@PAVNvFaceInfo@@PAX@0@@Z ENDP ; std::_Voidify_iter<std::_Tree_node<NvFaceInfo *,void *> * *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\type_traits
;	COMDAT ??$forward@ABQAU?$_Tree_node@PAVNvFaceInfo@@PAX@std@@@std@@YAABQAU?$_Tree_node@PAVNvFaceInfo@@PAX@0@ABQAU10@@Z
_TEXT	SEGMENT
??$forward@ABQAU?$_Tree_node@PAVNvFaceInfo@@PAX@std@@@std@@YAABQAU?$_Tree_node@PAVNvFaceInfo@@PAX@0@ABQAU10@@Z PROC ; std::forward<std::_Tree_node<NvFaceInfo *,void *> * const &>, COMDAT
; __Arg$ = ecx

; 1386 :     return static_cast<_Ty&&>(_Arg);

	mov	eax, ecx

; 1387 : }

	ret	0
??$forward@ABQAU?$_Tree_node@PAVNvFaceInfo@@PAX@std@@@std@@YAABQAU?$_Tree_node@PAVNvFaceInfo@@PAX@0@ABQAU10@@Z ENDP ; std::forward<std::_Tree_node<NvFaceInfo *,void *> * const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\type_traits
;	COMDAT ??$forward@PAVNvFaceInfo@@@std@@YA$$QAPAVNvFaceInfo@@AAPAV1@@Z
_TEXT	SEGMENT
??$forward@PAVNvFaceInfo@@@std@@YA$$QAPAVNvFaceInfo@@AAPAV1@@Z PROC ; std::forward<NvFaceInfo *>, COMDAT
; __Arg$ = ecx

; 1386 :     return static_cast<_Ty&&>(_Arg);

	mov	eax, ecx

; 1387 : }

	ret	0
??$forward@PAVNvFaceInfo@@@std@@YA$$QAPAVNvFaceInfo@@AAPAV1@@Z ENDP ; std::forward<NvFaceInfo *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$construct@PAVNvFaceInfo@@PAV1@@?$_Normal_allocator_traits@V?$xalloc@PAVNvFaceInfo@@@@@std@@SAXAAV?$xalloc@PAVNvFaceInfo@@@@PAPAVNvFaceInfo@@$$QAPAV3@@Z
_TEXT	SEGMENT
_<_Args_0>$ = 8						; size = 4
??$construct@PAVNvFaceInfo@@PAV1@@?$_Normal_allocator_traits@V?$xalloc@PAVNvFaceInfo@@@@@std@@SAXAAV?$xalloc@PAVNvFaceInfo@@@@PAPAVNvFaceInfo@@$$QAPAV3@@Z PROC ; std::_Normal_allocator_traits<xalloc<NvFaceInfo *> >::construct<NvFaceInfo *,NvFaceInfo *>, COMDAT
; __Al$dead$ = ecx
; __Ptr$ = edx

; 565  :         if constexpr (_Uses_default_construct<_Alloc, _Ty*, _Types...>::value) {
; 566  :             (void) _Al; // TRANSITION, DevCom-1004719
; 567  : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 568  :             _STD construct_at(_Ptr, _STD forward<_Types>(_Args)...);
; 569  : #else // __cpp_lib_constexpr_dynamic_alloc
; 570  :             ::new (static_cast<void*>(_Ptr)) _Ty(_STD forward<_Types>(_Args)...);
; 571  : #endif // __cpp_lib_constexpr_dynamic_alloc
; 572  :         } else {
; 573  :             _Al.construct(_Ptr, _STD forward<_Types>(_Args)...);

	mov	eax, DWORD PTR _<_Args_0>$[esp-4]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edx], eax

; 574  :         }
; 575  :     }

	ret	0
??$construct@PAVNvFaceInfo@@PAV1@@?$_Normal_allocator_traits@V?$xalloc@PAVNvFaceInfo@@@@@std@@SAXAAV?$xalloc@PAVNvFaceInfo@@@@PAPAVNvFaceInfo@@$$QAPAV3@@Z ENDP ; std::_Normal_allocator_traits<xalloc<NvFaceInfo *> >::construct<NvFaceInfo *,NvFaceInfo *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Emplace_back@$$V@?$_Uninitialized_backout_al@V?$xalloc@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@@@std@@QAEXXZ
_TEXT	SEGMENT
??$_Emplace_back@$$V@?$_Uninitialized_backout_al@V?$xalloc@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@@@std@@QAEXXZ PROC ; std::_Uninitialized_backout_al<xalloc<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> > > >::_Emplace_back<>, COMDAT
; _this$ = ecx

; 1331 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	eax, DWORD PTR [ecx+4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [eax], 0
	mov	DWORD PTR [eax+4], 0
	mov	DWORD PTR [eax+8], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1621 :         ++_Last;

	add	DWORD PTR [ecx+4], 12			; 0000000cH

; 1622 :     }

	ret	0
??$_Emplace_back@$$V@?$_Uninitialized_backout_al@V?$xalloc@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@@@std@@QAEXXZ ENDP ; std::_Uninitialized_backout_al<xalloc<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> > > >::_Emplace_back<>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\type_traits
;	COMDAT ??$move@AAPAVNvStripInfo@@@std@@YA$$QAPAVNvStripInfo@@AAPAV1@@Z
_TEXT	SEGMENT
??$move@AAPAVNvStripInfo@@@std@@YA$$QAPAVNvStripInfo@@AAPAV1@@Z PROC ; std::move<NvStripInfo * &>, COMDAT
; __Arg$ = ecx

; 1397 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

	mov	eax, ecx

; 1398 : }

	ret	0
??$move@AAPAVNvStripInfo@@@std@@YA$$QAPAVNvStripInfo@@AAPAV1@@Z ENDP ; std::move<NvStripInfo * &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Emplace_back@PAVNvStripInfo@@@?$_Uninitialized_backout_al@V?$xalloc@PAVNvStripInfo@@@@@std@@QAEX$$QAPAVNvStripInfo@@@Z
_TEXT	SEGMENT
_<_Vals_0>$ = 8						; size = 4
??$_Emplace_back@PAVNvStripInfo@@@?$_Uninitialized_backout_al@V?$xalloc@PAVNvStripInfo@@@@@std@@QAEX$$QAPAVNvStripInfo@@@Z PROC ; std::_Uninitialized_backout_al<xalloc<NvStripInfo *> >::_Emplace_back<NvStripInfo *>, COMDAT
; _this$ = ecx

; 1620 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _<_Vals_0>$[esp-4]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edx], eax

; 1621 :         ++_Last;

	add	DWORD PTR [ecx+4], 4

; 1622 :     }

	ret	4
??$_Emplace_back@PAVNvStripInfo@@@?$_Uninitialized_backout_al@V?$xalloc@PAVNvStripInfo@@@@@std@@QAEX$$QAPAVNvStripInfo@@@Z ENDP ; std::_Uninitialized_backout_al<xalloc<NvStripInfo *> >::_Emplace_back<NvStripInfo *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Zero_range@PAPAVNvEdgeInfo@@@std@@YAPAPAVNvEdgeInfo@@QAPAV1@0@Z
_TEXT	SEGMENT
??$_Zero_range@PAPAVNvEdgeInfo@@@std@@YAPAPAVNvEdgeInfo@@QAPAV1@0@Z PROC ; std::_Zero_range<NvEdgeInfo * *>, COMDAT
; __First$ = ecx
; __Last$ = edx

; 1789 : _Ptr _Zero_range(const _Ptr _First, const _Ptr _Last) { // fill [_First, _Last) with zeroes

	push	esi
	mov	esi, edx

; 1790 :     char* const _First_ch = reinterpret_cast<char*>(_To_address(_First));
; 1791 :     char* const _Last_ch  = reinterpret_cast<char*>(_To_address(_Last));
; 1792 :     _CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

	mov	eax, esi
	sub	eax, ecx
	push	eax
	push	0
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 1793 :     return _Last;

	mov	eax, esi
	pop	esi

; 1794 : }

	ret	0
??$_Zero_range@PAPAVNvEdgeInfo@@@std@@YAPAPAVNvEdgeInfo@@QAPAV1@0@Z ENDP ; std::_Zero_range<NvEdgeInfo * *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_To_address@PAPAVNvEdgeInfo@@@std@@YA?A_PABQAPAVNvEdgeInfo@@@Z
_TEXT	SEGMENT
??$_To_address@PAPAVNvEdgeInfo@@@std@@YA?A_PABQAPAVNvEdgeInfo@@@Z PROC ; std::_To_address<NvEdgeInfo * *>, COMDAT
; __Val$ = ecx

; 3981 :     _STL_INTERNAL_STATIC_ASSERT(is_pointer_v<_Iter>);
; 3982 :     return _Val;

	mov	eax, DWORD PTR [ecx]

; 3983 : }

	ret	0
??$_To_address@PAPAVNvEdgeInfo@@@std@@YA?A_PABQAPAVNvEdgeInfo@@@Z ENDP ; std::_To_address<NvEdgeInfo * *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Emplace_back@$$V@?$_Uninitialized_backout_al@V?$xalloc@PAVNvEdgeInfo@@@@@std@@QAEXXZ
_TEXT	SEGMENT
??$_Emplace_back@$$V@?$_Uninitialized_backout_al@V?$xalloc@PAVNvEdgeInfo@@@@@std@@QAEXXZ PROC ; std::_Uninitialized_backout_al<xalloc<NvEdgeInfo *> >::_Emplace_back<>, COMDAT
; _this$ = ecx

; 570  :             ::new (static_cast<void*>(_Ptr)) _Ty(_STD forward<_Types>(_Args)...);

	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax], 0

; 1620 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);
; 1621 :         ++_Last;

	add	DWORD PTR [ecx+4], 4

; 1622 :     }

	ret	0
??$_Emplace_back@$$V@?$_Uninitialized_backout_al@V?$xalloc@PAVNvEdgeInfo@@@@@std@@QAEXXZ ENDP ; std::_Uninitialized_backout_al<xalloc<NvEdgeInfo *> >::_Emplace_back<>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Emplace_back@H@?$_Uninitialized_backout_al@V?$xalloc@H@@@std@@QAEX$$QAH@Z
_TEXT	SEGMENT
_<_Vals_0>$ = 8						; size = 4
??$_Emplace_back@H@?$_Uninitialized_backout_al@V?$xalloc@H@@@std@@QAEX$$QAH@Z PROC ; std::_Uninitialized_backout_al<xalloc<int> >::_Emplace_back<int>, COMDAT
; _this$ = ecx

; 1620 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _<_Vals_0>$[esp-4]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edx], eax

; 1621 :         ++_Last;

	add	DWORD PTR [ecx+4], 4

; 1622 :     }

	ret	4
??$_Emplace_back@H@?$_Uninitialized_backout_al@V?$xalloc@H@@@std@@QAEX$$QAH@Z ENDP ; std::_Uninitialized_backout_al<xalloc<int> >::_Emplace_back<int>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef
;	COMDAT ??$addressof@PAVNvFaceInfo@@@std@@YAPAPAVNvFaceInfo@@AAPAV1@@Z
_TEXT	SEGMENT
??$addressof@PAVNvFaceInfo@@@std@@YAPAPAVNvFaceInfo@@AAPAV1@@Z PROC ; std::addressof<NvFaceInfo *>, COMDAT
; __Val$ = ecx

; 253  :     return __builtin_addressof(_Val);

	mov	eax, ecx

; 254  : }

	ret	0
??$addressof@PAVNvFaceInfo@@@std@@YAPAPAVNvFaceInfo@@AAPAV1@@Z ENDP ; std::addressof<NvFaceInfo *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$destroy@PAVNvFaceInfo@@@?$_Normal_allocator_traits@V?$xalloc@U?$_Tree_node@PAVNvFaceInfo@@PAX@std@@@@@std@@SAXAAV?$xalloc@U?$_Tree_node@PAVNvFaceInfo@@PAX@std@@@@PAPAVNvFaceInfo@@@Z
_TEXT	SEGMENT
??$destroy@PAVNvFaceInfo@@@?$_Normal_allocator_traits@V?$xalloc@U?$_Tree_node@PAVNvFaceInfo@@PAX@std@@@@@std@@SAXAAV?$xalloc@U?$_Tree_node@PAVNvFaceInfo@@PAX@std@@@@PAPAVNvFaceInfo@@@Z PROC ; std::_Normal_allocator_traits<xalloc<std::_Tree_node<NvFaceInfo *,void *> > >::destroy<NvFaceInfo *>, COMDAT
; __Al$dead$ = ecx
; __Ptr$dead$ = edx

; 579  :         if constexpr (_Uses_default_destroy<_Alloc, _Ty*>::value) {
; 580  : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 581  :             _STD destroy_at(_Ptr);
; 582  : #else // __cpp_lib_constexpr_dynamic_alloc
; 583  :             _Ptr->~_Ty();
; 584  : #endif // __cpp_lib_constexpr_dynamic_alloc
; 585  :         } else {
; 586  :             _Al.destroy(_Ptr);
; 587  :         }
; 588  :     }

	ret	0
??$destroy@PAVNvFaceInfo@@@?$_Normal_allocator_traits@V?$xalloc@U?$_Tree_node@PAVNvFaceInfo@@PAX@std@@@@@std@@SAXAAV?$xalloc@U?$_Tree_node@PAVNvFaceInfo@@PAX@std@@@@PAPAVNvFaceInfo@@@Z ENDP ; std::_Normal_allocator_traits<xalloc<std::_Tree_node<NvFaceInfo *,void *> > >::destroy<NvFaceInfo *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
;	COMDAT ??$exchange@PAU?$_Tree_node@PAVNvFaceInfo@@PAX@std@@$$T@std@@YAPAU?$_Tree_node@PAVNvFaceInfo@@PAX@0@AAPAU10@$$QA$$T@Z
_TEXT	SEGMENT
??$exchange@PAU?$_Tree_node@PAVNvFaceInfo@@PAX@std@@$$T@std@@YAPAU?$_Tree_node@PAVNvFaceInfo@@PAX@0@AAPAU10@$$QA$$T@Z PROC ; std::exchange<std::_Tree_node<NvFaceInfo *,void *> *,std::nullptr_t>, COMDAT
; __Val$ = ecx
; __New_val$ = edx

; 601  :     // assign _New_val to _Val, return previous _Val
; 602  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	eax, DWORD PTR [ecx]

; 603  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	edx, DWORD PTR [edx]
	mov	DWORD PTR [ecx], edx

; 604  :     return _Old_val;
; 605  : }

	ret	0
??$exchange@PAU?$_Tree_node@PAVNvFaceInfo@@PAX@std@@$$T@std@@YAPAU?$_Tree_node@PAVNvFaceInfo@@PAX@0@AAPAU10@$$QA$$T@Z ENDP ; std::exchange<std::_Tree_node<NvFaceInfo *,void *> *,std::nullptr_t>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Destroy_in_place@PAV?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@std@@YAXAAPAV?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@Z
_TEXT	SEGMENT
??$_Destroy_in_place@PAV?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@std@@YAXAAPAV?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@Z PROC ; std::_Destroy_in_place<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> > *>, COMDAT
; __Obj$dead$ = ecx

; 295  :     if constexpr (is_array_v<_Ty>) {
; 296  :         _Destroy_range(_Obj, _Obj + extent_v<_Ty>);
; 297  :     } else {
; 298  :         _Obj.~_Ty();
; 299  :     }
; 300  : }

	ret	0
??$_Destroy_in_place@PAV?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@std@@YAXAAPAV?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@Z ENDP ; std::_Destroy_in_place<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> > *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
;	COMDAT ??$xr_alloc@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@@YAPAV?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@I@Z
_TEXT	SEGMENT
??$xr_alloc@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@@YAPAV?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@I@Z PROC ; xr_alloc<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> > >, COMDAT
; _count$ = ecx

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	lea	eax, DWORD PTR [ecx+ecx*2]
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	shl	eax, 2
	push	eax
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
	ret	0
??$xr_alloc@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@@YAPAV?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@I@Z ENDP ; xr_alloc<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Destroy_in_place@PAPAVNvEdgeInfo@@@std@@YAXAAPAPAVNvEdgeInfo@@@Z
_TEXT	SEGMENT
??$_Destroy_in_place@PAPAVNvEdgeInfo@@@std@@YAXAAPAPAVNvEdgeInfo@@@Z PROC ; std::_Destroy_in_place<NvEdgeInfo * *>, COMDAT
; __Obj$dead$ = ecx

; 295  :     if constexpr (is_array_v<_Ty>) {
; 296  :         _Destroy_range(_Obj, _Obj + extent_v<_Ty>);
; 297  :     } else {
; 298  :         _Obj.~_Ty();
; 299  :     }
; 300  : }

	ret	0
??$_Destroy_in_place@PAPAVNvEdgeInfo@@@std@@YAXAAPAPAVNvEdgeInfo@@@Z ENDP ; std::_Destroy_in_place<NvEdgeInfo * *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
;	COMDAT ??$xr_alloc@PAVNvEdgeInfo@@@@YAPAPAVNvEdgeInfo@@I@Z
_TEXT	SEGMENT
??$xr_alloc@PAVNvEdgeInfo@@@@YAPAPAVNvEdgeInfo@@I@Z PROC ; xr_alloc<NvEdgeInfo *>, COMDAT
; _count$ = ecx

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	lea	eax, DWORD PTR [ecx*4]
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
	ret	0
??$xr_alloc@PAVNvEdgeInfo@@@@YAPAPAVNvEdgeInfo@@I@Z ENDP ; xr_alloc<NvEdgeInfo *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
;	COMDAT ??$xr_free@U?$_Tree_node@PAVNvFaceInfo@@PAX@std@@@@YAXAAPAU?$_Tree_node@PAVNvFaceInfo@@PAX@std@@@Z
_TEXT	SEGMENT
??$xr_free@U?$_Tree_node@PAVNvFaceInfo@@PAX@std@@@@YAXAAPAU?$_Tree_node@PAVNvFaceInfo@@PAX@std@@@Z PROC ; xr_free<std::_Tree_node<NvFaceInfo *,void *> >, COMDAT
; _P$ = ecx

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	push	esi
	mov	esi, ecx
	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN2@xr_free
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
	mov	DWORD PTR [esi], 0
$LN2@xr_free:
	pop	esi
	ret	0
??$xr_free@U?$_Tree_node@PAVNvFaceInfo@@PAX@std@@@@YAXAAPAU?$_Tree_node@PAVNvFaceInfo@@PAX@std@@@Z ENDP ; xr_free<std::_Tree_node<NvFaceInfo *,void *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Uninitialized_move@PAV?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@V?$xalloc@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@@@std@@YAPAV?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@QAV1@0PAV1@AAV?$xalloc@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@@@Z
_TEXT	SEGMENT
__Last$1$ = -4						; size = 4
__First$1$ = 8						; size = 4
__Dest$ = 8						; size = 4
__Al$dead$ = 12						; size = 4
??$_Uninitialized_move@PAV?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@V?$xalloc@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@@@std@@YAPAV?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@QAV1@0PAV1@AAV?$xalloc@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@@@Z PROC ; std::_Uninitialized_move<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> > *,xalloc<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> > > >, COMDAT
; __First$ = ecx
; __Last$ = edx

; 1699 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

	push	ecx
	mov	eax, ecx
	mov	DWORD PTR __Last$1$[esp+4], edx
	push	ebx

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	ebx, DWORD PTR __Dest$[esp+4]

; 1700 :     // move [_First, _Last) to raw _Dest, using _Al
; 1701 :     // note: only called internally from elsewhere in the STL
; 1702 :     using _Ptrval     = typename _Alloc::value_type*;
; 1703 :     auto _UFirst      = _Get_unwrapped(_First);
; 1704 :     const auto _ULast = _Get_unwrapped(_Last);
; 1705 :     if constexpr (conjunction_v<bool_constant<_Ptr_move_cat<decltype(_UFirst), _Ptrval>::_Really_trivial>,
; 1706 :                       _Uses_default_construct<_Alloc, _Ptrval, decltype(_STD move(*_UFirst))>>) {
; 1707 : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 1708 :         if (!_STD is_constant_evaluated())
; 1709 : #endif // __cpp_lib_constexpr_dynamic_alloc
; 1710 :         {
; 1711 :             _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));
; 1712 :             return _Dest + (_ULast - _UFirst);
; 1713 :         }
; 1714 :     }
; 1715 : 
; 1716 :     _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	eax, edx
	je	SHORT $LN63@Uninitiali

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	push	ebp
	sub	eax, ebx
	push	esi
	mov	DWORD PTR __First$1$[esp+12], eax
	push	edi
	npad	8
$LL4@Uninitiali:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ebx], 0
	mov	DWORD PTR [ebx+4], 0
	mov	DWORD PTR [ebx+8], 0

; 546  :         const pointer _Rightfirst = _Right_data._Myfirst;

	mov	esi, DWORD PTR [eax+ebx]

; 547  :         const pointer _Rightlast  = _Right_data._Mylast;

	mov	ebp, DWORD PTR [eax+ebx+4]

; 548  :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);
; 549  :         if (_Rightfirst != _Rightlast) {

	cmp	esi, ebp
	je	SHORT $LN46@Uninitiali
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 550  :             _Buy_raw(static_cast<size_type>(_Rightlast - _Rightfirst));

	mov	eax, ebp
	sub	eax, esi
	sar	eax, 2
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	lea	edi, DWORD PTR [eax*4]
	push	edi
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1698 :         const auto _Newvec = _Getal().allocate(_Newcapacity);

	mov	ecx, eax

; 1699 :         _Myfirst           = _Newvec;

	mov	DWORD PTR [ebx], ecx

; 1700 :         _Mylast            = _Newvec;

	mov	DWORD PTR [ebx+4], ecx

; 1701 :         _Myend             = _Newvec + _Newcapacity;

	lea	eax, DWORD PTR [edi+ecx]
	mov	DWORD PTR [ebx+8], eax
$LL34@Uninitiali:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1620 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

	mov	eax, DWORD PTR [esi]

; 1658 :     for (; _UFirst != _ULast; ++_UFirst) {

	add	esi, 4

; 1620 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

	mov	DWORD PTR [ecx], eax

; 1621 :         ++_Last;

	add	ecx, 4

; 1658 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	esi, ebp
	jne	SHORT $LL34@Uninitiali
	mov	eax, DWORD PTR __First$1$[esp+16]
	mov	edx, DWORD PTR __Last$1$[esp+20]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 552  :             _My_data._Mylast = _Ucopy(_Rightfirst, _Rightlast, _My_data._Myfirst);

	mov	DWORD PTR [ebx+4], ecx
$LN46@Uninitiali:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1621 :         ++_Last;

	add	ebx, 12					; 0000000cH

; 1700 :     // move [_First, _Last) to raw _Dest, using _Al
; 1701 :     // note: only called internally from elsewhere in the STL
; 1702 :     using _Ptrval     = typename _Alloc::value_type*;
; 1703 :     auto _UFirst      = _Get_unwrapped(_First);
; 1704 :     const auto _ULast = _Get_unwrapped(_Last);
; 1705 :     if constexpr (conjunction_v<bool_constant<_Ptr_move_cat<decltype(_UFirst), _Ptrval>::_Really_trivial>,
; 1706 :                       _Uses_default_construct<_Alloc, _Ptrval, decltype(_STD move(*_UFirst))>>) {
; 1707 : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 1708 :         if (!_STD is_constant_evaluated())
; 1709 : #endif // __cpp_lib_constexpr_dynamic_alloc
; 1710 :         {
; 1711 :             _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));
; 1712 :             return _Dest + (_ULast - _UFirst);
; 1713 :         }
; 1714 :     }
; 1715 : 
; 1716 :     _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	lea	ecx, DWORD PTR [eax+ebx]
	cmp	ecx, edx
	jne	SHORT $LL4@Uninitiali

; 1718 :         _Backout._Emplace_back(_STD move(*_UFirst));
; 1719 :     }
; 1720 : 
; 1721 :     return _Backout._Release();

	pop	edi
	pop	esi
	pop	ebp
$LN63@Uninitiali:

; 1722 : }

	mov	eax, ebx
	pop	ebx
	pop	ecx
	ret	0
??$_Uninitialized_move@PAV?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@V?$xalloc@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@@@std@@YAPAV?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@QAV1@0PAV1@AAV?$xalloc@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@@@Z ENDP ; std::_Uninitialized_move<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> > *,xalloc<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_Get_unwrapped@ABQAV?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@std@@YA?A_TABQAV?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@Z
_TEXT	SEGMENT
??$_Get_unwrapped@ABQAV?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@std@@YA?A_TABQAV?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@Z PROC ; std::_Get_unwrapped<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> > * const &>, COMDAT
; __It$ = ecx

; 1275 :     // unwrap an iterator previously subjected to _Adl_verify_range or otherwise validated
; 1276 :     if constexpr (is_pointer_v<decay_t<_Iter>>) { // special-case pointers and arrays
; 1277 :         return _It + 0;

	mov	eax, DWORD PTR [ecx]

; 1278 :     } else if constexpr (_Unwrappable_v<_Iter>) {
; 1279 :         return static_cast<_Iter&&>(_It)._Unwrapped();
; 1280 :     } else {
; 1281 :         return static_cast<_Iter&&>(_It);
; 1282 :     }
; 1283 : }

	ret	0
??$_Get_unwrapped@ABQAV?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@std@@YA?A_TABQAV?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@Z ENDP ; std::_Get_unwrapped<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> > * const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Uninitialized_move@PAPAVNvEdgeInfo@@V?$xalloc@PAVNvEdgeInfo@@@@@std@@YAPAPAVNvEdgeInfo@@QAPAV1@0PAPAV1@AAV?$xalloc@PAVNvEdgeInfo@@@@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Al$dead$ = 12						; size = 4
??$_Uninitialized_move@PAPAVNvEdgeInfo@@V?$xalloc@PAVNvEdgeInfo@@@@@std@@YAPAPAVNvEdgeInfo@@QAPAV1@0PAPAV1@AAV?$xalloc@PAVNvEdgeInfo@@@@@Z PROC ; std::_Uninitialized_move<NvEdgeInfo * *,xalloc<NvEdgeInfo *> >, COMDAT
; __First$ = ecx
; __Last$ = edx

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	eax, DWORD PTR __Dest$[esp-4]

; 1699 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

	push	esi
	mov	esi, edx

; 1700 :     // move [_First, _Last) to raw _Dest, using _Al
; 1701 :     // note: only called internally from elsewhere in the STL
; 1702 :     using _Ptrval     = typename _Alloc::value_type*;
; 1703 :     auto _UFirst      = _Get_unwrapped(_First);
; 1704 :     const auto _ULast = _Get_unwrapped(_Last);
; 1705 :     if constexpr (conjunction_v<bool_constant<_Ptr_move_cat<decltype(_UFirst), _Ptrval>::_Really_trivial>,
; 1706 :                       _Uses_default_construct<_Alloc, _Ptrval, decltype(_STD move(*_UFirst))>>) {
; 1707 : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 1708 :         if (!_STD is_constant_evaluated())
; 1709 : #endif // __cpp_lib_constexpr_dynamic_alloc
; 1710 :         {
; 1711 :             _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));
; 1712 :             return _Dest + (_ULast - _UFirst);
; 1713 :         }
; 1714 :     }
; 1715 : 
; 1716 :     _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	ecx, esi
	je	SHORT $LN3@Uninitiali
	npad	5
$LL4@Uninitiali:

; 1620 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

	mov	edx, DWORD PTR [ecx]

; 1621 :         ++_Last;

	add	ecx, 4
	mov	DWORD PTR [eax], edx
	add	eax, 4

; 1700 :     // move [_First, _Last) to raw _Dest, using _Al
; 1701 :     // note: only called internally from elsewhere in the STL
; 1702 :     using _Ptrval     = typename _Alloc::value_type*;
; 1703 :     auto _UFirst      = _Get_unwrapped(_First);
; 1704 :     const auto _ULast = _Get_unwrapped(_Last);
; 1705 :     if constexpr (conjunction_v<bool_constant<_Ptr_move_cat<decltype(_UFirst), _Ptrval>::_Really_trivial>,
; 1706 :                       _Uses_default_construct<_Alloc, _Ptrval, decltype(_STD move(*_UFirst))>>) {
; 1707 : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 1708 :         if (!_STD is_constant_evaluated())
; 1709 : #endif // __cpp_lib_constexpr_dynamic_alloc
; 1710 :         {
; 1711 :             _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));
; 1712 :             return _Dest + (_ULast - _UFirst);
; 1713 :         }
; 1714 :     }
; 1715 : 
; 1716 :     _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	ecx, esi
	jne	SHORT $LL4@Uninitiali
$LN3@Uninitiali:
	pop	esi

; 1718 :         _Backout._Emplace_back(_STD move(*_UFirst));
; 1719 :     }
; 1720 : 
; 1721 :     return _Backout._Release();
; 1722 : }

	ret	0
??$_Uninitialized_move@PAPAVNvEdgeInfo@@V?$xalloc@PAVNvEdgeInfo@@@@@std@@YAPAPAVNvEdgeInfo@@QAPAV1@0PAPAV1@AAV?$xalloc@PAVNvEdgeInfo@@@@@Z ENDP ; std::_Uninitialized_move<NvEdgeInfo * *,xalloc<NvEdgeInfo *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_Get_unwrapped@ABQAPAVNvEdgeInfo@@@std@@YA?A_TABQAPAVNvEdgeInfo@@@Z
_TEXT	SEGMENT
??$_Get_unwrapped@ABQAPAVNvEdgeInfo@@@std@@YA?A_TABQAPAVNvEdgeInfo@@@Z PROC ; std::_Get_unwrapped<NvEdgeInfo * * const &>, COMDAT
; __It$ = ecx

; 1275 :     // unwrap an iterator previously subjected to _Adl_verify_range or otherwise validated
; 1276 :     if constexpr (is_pointer_v<decay_t<_Iter>>) { // special-case pointers and arrays
; 1277 :         return _It + 0;

	mov	eax, DWORD PTR [ecx]

; 1278 :     } else if constexpr (_Unwrappable_v<_Iter>) {
; 1279 :         return static_cast<_Iter&&>(_It)._Unwrapped();
; 1280 :     } else {
; 1281 :         return static_cast<_Iter&&>(_It);
; 1282 :     }
; 1283 : }

	ret	0
??$_Get_unwrapped@ABQAPAVNvEdgeInfo@@@std@@YA?A_TABQAPAVNvEdgeInfo@@@Z ENDP ; std::_Get_unwrapped<NvEdgeInfo * * const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xtree
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xtree
;	COMDAT ??0?$_Tree_temp_node_alloc@V?$xalloc@U?$_Tree_node@PAVNvFaceInfo@@PAX@std@@@@@std@@QAE@AAV?$xalloc@U?$_Tree_node@PAVNvFaceInfo@@PAX@std@@@@@Z
_TEXT	SEGMENT
__Al_$ = 8						; size = 4
??0?$_Tree_temp_node_alloc@V?$xalloc@U?$_Tree_node@PAVNvFaceInfo@@PAX@std@@@@@std@@QAE@AAV?$xalloc@U?$_Tree_node@PAVNvFaceInfo@@PAX@std@@@@@Z PROC ; std::_Tree_temp_node_alloc<xalloc<std::_Tree_node<NvFaceInfo *,void *> > >::_Tree_temp_node_alloc<xalloc<std::_Tree_node<NvFaceInfo *,void *> > >, COMDAT
; _this$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 958  :     _CONSTEXPR20_DYNALLOC explicit _Alloc_construct_ptr(_Alloc& _Al_) : _Al(_Al_), _Ptr(nullptr) {}

	mov	eax, DWORD PTR __Al_$[esp-4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xtree

; 783  :     explicit _Tree_temp_node_alloc(_Alnode& _Al_) : _Alloc_construct_ptr<_Alnode>(_Al_) {

	push	esi
	mov	esi, ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	push	20					; 00000014H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 958  :     _CONSTEXPR20_DYNALLOC explicit _Alloc_construct_ptr(_Alloc& _Al_) : _Al(_Al_), _Ptr(nullptr) {}

	mov	DWORD PTR [esi], eax

; 965  :         _Ptr = nullptr; // if allocate throws, prevents double-free

	mov	DWORD PTR [esi+4], 0
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 966  :         _Ptr = _Al.allocate(1);

	mov	DWORD PTR [esi+4], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xtree

; 785  :     }

	mov	eax, esi
	pop	esi
	ret	4
??0?$_Tree_temp_node_alloc@V?$xalloc@U?$_Tree_node@PAVNvFaceInfo@@PAX@std@@@@@std@@QAE@AAV?$xalloc@U?$_Tree_node@PAVNvFaceInfo@@PAX@std@@@@@Z ENDP ; std::_Tree_temp_node_alloc<xalloc<std::_Tree_node<NvFaceInfo *,void *> > >::_Tree_temp_node_alloc<xalloc<std::_Tree_node<NvFaceInfo *,void *> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Allocate@?$_Alloc_construct_ptr@V?$xalloc@U?$_Tree_node@PAVNvFaceInfo@@PAX@std@@@@@std@@QAEXXZ
_TEXT	SEGMENT
?_Allocate@?$_Alloc_construct_ptr@V?$xalloc@U?$_Tree_node@PAVNvFaceInfo@@PAX@std@@@@@std@@QAEXXZ PROC ; std::_Alloc_construct_ptr<xalloc<std::_Tree_node<NvFaceInfo *,void *> > >::_Allocate, COMDAT
; _this$ = ecx

; 964  :     _CONSTEXPR20_DYNALLOC void _Allocate() { // disengage *this, then allocate a new memory block

	push	esi
	mov	esi, ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	push	20					; 00000014H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 965  :         _Ptr = nullptr; // if allocate throws, prevents double-free

	mov	DWORD PTR [esi+4], 0
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 966  :         _Ptr = _Al.allocate(1);

	mov	DWORD PTR [esi+4], eax
	pop	esi

; 967  :     }

	ret	0
?_Allocate@?$_Alloc_construct_ptr@V?$xalloc@U?$_Tree_node@PAVNvFaceInfo@@PAX@std@@@@@std@@QAEXXZ ENDP ; std::_Alloc_construct_ptr<xalloc<std::_Tree_node<NvFaceInfo *,void *> > >::_Allocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??0?$_Alloc_construct_ptr@V?$xalloc@U?$_Tree_node@PAVNvFaceInfo@@PAX@std@@@@@std@@QAE@AAV?$xalloc@U?$_Tree_node@PAVNvFaceInfo@@PAX@std@@@@@Z
_TEXT	SEGMENT
__Al_$ = 8						; size = 4
??0?$_Alloc_construct_ptr@V?$xalloc@U?$_Tree_node@PAVNvFaceInfo@@PAX@std@@@@@std@@QAE@AAV?$xalloc@U?$_Tree_node@PAVNvFaceInfo@@PAX@std@@@@@Z PROC ; std::_Alloc_construct_ptr<xalloc<std::_Tree_node<NvFaceInfo *,void *> > >::_Alloc_construct_ptr<xalloc<std::_Tree_node<NvFaceInfo *,void *> > >, COMDAT
; _this$ = ecx

; 958  :     _CONSTEXPR20_DYNALLOC explicit _Alloc_construct_ptr(_Alloc& _Al_) : _Al(_Al_), _Ptr(nullptr) {}

	mov	eax, DWORD PTR __Al_$[esp-4]
	mov	DWORD PTR [ecx], eax
	mov	eax, ecx
	mov	DWORD PTR [ecx+4], 0
	ret	4
??0?$_Alloc_construct_ptr@V?$xalloc@U?$_Tree_node@PAVNvFaceInfo@@PAX@std@@@@@std@@QAE@AAV?$xalloc@U?$_Tree_node@PAVNvFaceInfo@@PAX@std@@@@@Z ENDP ; std::_Alloc_construct_ptr<xalloc<std::_Tree_node<NvFaceInfo *,void *> > >::_Alloc_construct_ptr<xalloc<std::_Tree_node<NvFaceInfo *,void *> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\type_traits
;	COMDAT ??$forward@AAPAU?$_Tree_node@PAVNvFaceInfo@@PAX@std@@@std@@YAAAPAU?$_Tree_node@PAVNvFaceInfo@@PAX@0@AAPAU10@@Z
_TEXT	SEGMENT
??$forward@AAPAU?$_Tree_node@PAVNvFaceInfo@@PAX@std@@@std@@YAAAPAU?$_Tree_node@PAVNvFaceInfo@@PAX@0@AAPAU10@@Z PROC ; std::forward<std::_Tree_node<NvFaceInfo *,void *> * &>, COMDAT
; __Arg$ = ecx

; 1386 :     return static_cast<_Ty&&>(_Arg);

	mov	eax, ecx

; 1387 : }

	ret	0
??$forward@AAPAU?$_Tree_node@PAVNvFaceInfo@@PAX@std@@@std@@YAAAPAU?$_Tree_node@PAVNvFaceInfo@@PAX@0@AAPAU10@@Z ENDP ; std::forward<std::_Tree_node<NvFaceInfo *,void *> * &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$construct@PAVNvFaceInfo@@ABQAV1@@?$_Normal_allocator_traits@V?$xalloc@U?$_Tree_node@PAVNvFaceInfo@@PAX@std@@@@@std@@SAXAAV?$xalloc@U?$_Tree_node@PAVNvFaceInfo@@PAX@std@@@@PAPAVNvFaceInfo@@ABQAV3@@Z
_TEXT	SEGMENT
_<_Args_0>$ = 8						; size = 4
??$construct@PAVNvFaceInfo@@ABQAV1@@?$_Normal_allocator_traits@V?$xalloc@U?$_Tree_node@PAVNvFaceInfo@@PAX@std@@@@@std@@SAXAAV?$xalloc@U?$_Tree_node@PAVNvFaceInfo@@PAX@std@@@@PAPAVNvFaceInfo@@ABQAV3@@Z PROC ; std::_Normal_allocator_traits<xalloc<std::_Tree_node<NvFaceInfo *,void *> > >::construct<NvFaceInfo *,NvFaceInfo * const &>, COMDAT
; __Al$dead$ = ecx
; __Ptr$ = edx

; 565  :         if constexpr (_Uses_default_construct<_Alloc, _Ty*, _Types...>::value) {
; 566  :             (void) _Al; // TRANSITION, DevCom-1004719
; 567  : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 568  :             _STD construct_at(_Ptr, _STD forward<_Types>(_Args)...);
; 569  : #else // __cpp_lib_constexpr_dynamic_alloc
; 570  :             ::new (static_cast<void*>(_Ptr)) _Ty(_STD forward<_Types>(_Args)...);

	mov	eax, DWORD PTR _<_Args_0>$[esp-4]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edx], eax

; 571  : #endif // __cpp_lib_constexpr_dynamic_alloc
; 572  :         } else {
; 573  :             _Al.construct(_Ptr, _STD forward<_Types>(_Args)...);
; 574  :         }
; 575  :     }

	ret	0
??$construct@PAVNvFaceInfo@@ABQAV1@@?$_Normal_allocator_traits@V?$xalloc@U?$_Tree_node@PAVNvFaceInfo@@PAX@std@@@@@std@@SAXAAV?$xalloc@U?$_Tree_node@PAVNvFaceInfo@@PAX@std@@@@PAPAVNvFaceInfo@@ABQAV3@@Z ENDP ; std::_Normal_allocator_traits<xalloc<std::_Tree_node<NvFaceInfo *,void *> > >::construct<NvFaceInfo *,NvFaceInfo * const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_Construct_in_place@PAU?$_Tree_node@PAVNvFaceInfo@@PAX@std@@AAPAU12@@std@@YAXAAPAU?$_Tree_node@PAVNvFaceInfo@@PAX@0@0@Z
_TEXT	SEGMENT
??$_Construct_in_place@PAU?$_Tree_node@PAVNvFaceInfo@@PAX@std@@AAPAU12@@std@@YAXAAPAU?$_Tree_node@PAVNvFaceInfo@@PAX@0@0@Z PROC ; std::_Construct_in_place<std::_Tree_node<NvFaceInfo *,void *> *,std::_Tree_node<NvFaceInfo *,void *> * &>, COMDAT
; __Obj$ = ecx
; _<_Args_0>$ = edx

; 143  : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 144  :     if (_STD is_constant_evaluated()) {
; 145  :         _STD construct_at(_STD addressof(_Obj), _STD forward<_Types>(_Args)...);
; 146  :     } else
; 147  : #endif // __cpp_lib_constexpr_dynamic_alloc
; 148  :     {
; 149  :         ::new (_Voidify_iter(_STD addressof(_Obj))) _Ty(_STD forward<_Types>(_Args)...);

	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax

; 150  :     }
; 151  : }

	ret	0
??$_Construct_in_place@PAU?$_Tree_node@PAVNvFaceInfo@@PAX@std@@AAPAU12@@std@@YAXAAPAU?$_Tree_node@PAVNvFaceInfo@@PAX@0@0@Z ENDP ; std::_Construct_in_place<std::_Tree_node<NvFaceInfo *,void *> *,std::_Tree_node<NvFaceInfo *,void *> * &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\type_traits
;	COMDAT ??$forward@PAU?$_Tree_node@PAVNvFaceInfo@@PAX@std@@@std@@YA$$QAPAU?$_Tree_node@PAVNvFaceInfo@@PAX@0@AAPAU10@@Z
_TEXT	SEGMENT
??$forward@PAU?$_Tree_node@PAVNvFaceInfo@@PAX@std@@@std@@YA$$QAPAU?$_Tree_node@PAVNvFaceInfo@@PAX@0@AAPAU10@@Z PROC ; std::forward<std::_Tree_node<NvFaceInfo *,void *> *>, COMDAT
; __Arg$ = ecx

; 1386 :     return static_cast<_Ty&&>(_Arg);

	mov	eax, ecx

; 1387 : }

	ret	0
??$forward@PAU?$_Tree_node@PAVNvFaceInfo@@PAX@std@@@std@@YA$$QAPAU?$_Tree_node@PAVNvFaceInfo@@PAX@0@AAPAU10@@Z ENDP ; std::forward<std::_Tree_node<NvFaceInfo *,void *> *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$construct@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@$$V@?$_Normal_allocator_traits@V?$xalloc@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@@@std@@SAXAAV?$xalloc@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@@PAV?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@Z
_TEXT	SEGMENT
??$construct@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@$$V@?$_Normal_allocator_traits@V?$xalloc@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@@@std@@SAXAAV?$xalloc@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@@PAV?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@Z PROC ; std::_Normal_allocator_traits<xalloc<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> > > >::construct<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> > >, COMDAT
; __Al$dead$ = ecx
; __Ptr$ = edx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [edx], 0
	mov	DWORD PTR [edx+4], 0
	mov	DWORD PTR [edx+8], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 575  :     }

	ret	0
??$construct@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@$$V@?$_Normal_allocator_traits@V?$xalloc@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@@@std@@SAXAAV?$xalloc@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@@PAV?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@Z ENDP ; std::_Normal_allocator_traits<xalloc<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> > > >::construct<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\type_traits
;	COMDAT ??$forward@PAVNvStripInfo@@@std@@YA$$QAPAVNvStripInfo@@AAPAV1@@Z
_TEXT	SEGMENT
??$forward@PAVNvStripInfo@@@std@@YA$$QAPAVNvStripInfo@@AAPAV1@@Z PROC ; std::forward<NvStripInfo *>, COMDAT
; __Arg$ = ecx

; 1386 :     return static_cast<_Ty&&>(_Arg);

	mov	eax, ecx

; 1387 : }

	ret	0
??$forward@PAVNvStripInfo@@@std@@YA$$QAPAVNvStripInfo@@AAPAV1@@Z ENDP ; std::forward<NvStripInfo *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$construct@PAVNvStripInfo@@PAV1@@?$_Normal_allocator_traits@V?$xalloc@PAVNvStripInfo@@@@@std@@SAXAAV?$xalloc@PAVNvStripInfo@@@@PAPAVNvStripInfo@@$$QAPAV3@@Z
_TEXT	SEGMENT
_<_Args_0>$ = 8						; size = 4
??$construct@PAVNvStripInfo@@PAV1@@?$_Normal_allocator_traits@V?$xalloc@PAVNvStripInfo@@@@@std@@SAXAAV?$xalloc@PAVNvStripInfo@@@@PAPAVNvStripInfo@@$$QAPAV3@@Z PROC ; std::_Normal_allocator_traits<xalloc<NvStripInfo *> >::construct<NvStripInfo *,NvStripInfo *>, COMDAT
; __Al$dead$ = ecx
; __Ptr$ = edx

; 565  :         if constexpr (_Uses_default_construct<_Alloc, _Ty*, _Types...>::value) {
; 566  :             (void) _Al; // TRANSITION, DevCom-1004719
; 567  : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 568  :             _STD construct_at(_Ptr, _STD forward<_Types>(_Args)...);
; 569  : #else // __cpp_lib_constexpr_dynamic_alloc
; 570  :             ::new (static_cast<void*>(_Ptr)) _Ty(_STD forward<_Types>(_Args)...);
; 571  : #endif // __cpp_lib_constexpr_dynamic_alloc
; 572  :         } else {
; 573  :             _Al.construct(_Ptr, _STD forward<_Types>(_Args)...);

	mov	eax, DWORD PTR _<_Args_0>$[esp-4]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edx], eax

; 574  :         }
; 575  :     }

	ret	0
??$construct@PAVNvStripInfo@@PAV1@@?$_Normal_allocator_traits@V?$xalloc@PAVNvStripInfo@@@@@std@@SAXAAV?$xalloc@PAVNvStripInfo@@@@PAPAVNvStripInfo@@$$QAPAV3@@Z ENDP ; std::_Normal_allocator_traits<xalloc<NvStripInfo *> >::construct<NvStripInfo *,NvStripInfo *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$construct@PAVNvEdgeInfo@@$$V@?$_Normal_allocator_traits@V?$xalloc@PAVNvEdgeInfo@@@@@std@@SAXAAV?$xalloc@PAVNvEdgeInfo@@@@PAPAVNvEdgeInfo@@@Z
_TEXT	SEGMENT
??$construct@PAVNvEdgeInfo@@$$V@?$_Normal_allocator_traits@V?$xalloc@PAVNvEdgeInfo@@@@@std@@SAXAAV?$xalloc@PAVNvEdgeInfo@@@@PAPAVNvEdgeInfo@@@Z PROC ; std::_Normal_allocator_traits<xalloc<NvEdgeInfo *> >::construct<NvEdgeInfo *>, COMDAT
; __Al$dead$ = ecx
; __Ptr$ = edx

; 565  :         if constexpr (_Uses_default_construct<_Alloc, _Ty*, _Types...>::value) {
; 566  :             (void) _Al; // TRANSITION, DevCom-1004719
; 567  : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 568  :             _STD construct_at(_Ptr, _STD forward<_Types>(_Args)...);
; 569  : #else // __cpp_lib_constexpr_dynamic_alloc
; 570  :             ::new (static_cast<void*>(_Ptr)) _Ty(_STD forward<_Types>(_Args)...);

	mov	DWORD PTR [edx], 0

; 571  : #endif // __cpp_lib_constexpr_dynamic_alloc
; 572  :         } else {
; 573  :             _Al.construct(_Ptr, _STD forward<_Types>(_Args)...);
; 574  :         }
; 575  :     }

	ret	0
??$construct@PAVNvEdgeInfo@@$$V@?$_Normal_allocator_traits@V?$xalloc@PAVNvEdgeInfo@@@@@std@@SAXAAV?$xalloc@PAVNvEdgeInfo@@@@PAPAVNvEdgeInfo@@@Z ENDP ; std::_Normal_allocator_traits<xalloc<NvEdgeInfo *> >::construct<NvEdgeInfo *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\type_traits
;	COMDAT ??$move@AAV?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@std@@YA$$QAV?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@AAV1@@Z
_TEXT	SEGMENT
??$move@AAV?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@std@@YA$$QAV?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@AAV1@@Z PROC ; std::move<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> > &>, COMDAT
; __Arg$ = ecx

; 1397 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

	mov	eax, ecx

; 1398 : }

	ret	0
??$move@AAV?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@std@@YA$$QAV?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@AAV1@@Z ENDP ; std::move<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> > &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Emplace_back@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@?$_Uninitialized_backout_al@V?$xalloc@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@@@std@@QAEX$$QAV?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@Z
_TEXT	SEGMENT
$T2 = -4						; size = 4
_<_Vals_0>$ = 8						; size = 4
??$_Emplace_back@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@?$_Uninitialized_backout_al@V?$xalloc@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@@@std@@QAEX$$QAV?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@Z PROC ; std::_Uninitialized_backout_al<xalloc<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> > > >::_Emplace_back<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> > >, COMDAT
; _this$ = ecx

; 1619 :     _CONSTEXPR20_DYNALLOC void _Emplace_back(_Types&&... _Vals) { // construct a new element at *_Last and increment

	push	ecx
	push	ebx
	mov	ebx, ecx
	push	ebp
	push	esi
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	eax, DWORD PTR [ebx+4]
	mov	DWORD PTR $T2[esp+16], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [eax], 0
	mov	DWORD PTR [eax+4], 0
	mov	DWORD PTR [eax+8], 0

; 546  :         const pointer _Rightfirst = _Right_data._Myfirst;

	mov	eax, DWORD PTR _<_Vals_0>$[esp+12]
	mov	esi, DWORD PTR [eax]

; 547  :         const pointer _Rightlast  = _Right_data._Mylast;

	mov	ebp, DWORD PTR [eax+4]

; 548  :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);
; 549  :         if (_Rightfirst != _Rightlast) {

	cmp	esi, ebp
	je	SHORT $LN50@Emplace_ba
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 550  :             _Buy_raw(static_cast<size_type>(_Rightlast - _Rightfirst));

	mov	eax, ebp
	sub	eax, esi
	sar	eax, 2
	push	edi
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	lea	edi, DWORD PTR [eax*4]
	push	edi
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1698 :         const auto _Newvec = _Getal().allocate(_Newcapacity);

	mov	edx, eax

; 1699 :         _Myfirst           = _Newvec;

	mov	eax, DWORD PTR $T2[esp+20]
	mov	DWORD PTR [eax], edx

; 1700 :         _Mylast            = _Newvec;
; 1701 :         _Myend             = _Newvec + _Newcapacity;

	lea	ecx, DWORD PTR [edi+edx]
	mov	DWORD PTR [eax+4], edx
	mov	DWORD PTR [eax+8], ecx
	pop	edi
	npad	4
$LL27@Emplace_ba:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1620 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

	mov	eax, DWORD PTR [esi]

; 1658 :     for (; _UFirst != _ULast; ++_UFirst) {

	add	esi, 4

; 1620 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

	mov	DWORD PTR [edx], eax

; 1621 :         ++_Last;

	add	edx, 4

; 1658 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	esi, ebp
	jne	SHORT $LL27@Emplace_ba
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 552  :             _My_data._Mylast = _Ucopy(_Rightfirst, _Rightlast, _My_data._Myfirst);

	mov	eax, DWORD PTR $T2[esp+16]
	mov	DWORD PTR [eax+4], edx
$LN50@Emplace_ba:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1622 :     }

	add	DWORD PTR [ebx+4], 12			; 0000000cH
	pop	esi
	pop	ebp
	pop	ebx
	pop	ecx
	ret	4
??$_Emplace_back@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@?$_Uninitialized_backout_al@V?$xalloc@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@@@std@@QAEX$$QAV?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@Z ENDP ; std::_Uninitialized_backout_al<xalloc<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> > > >::_Emplace_back<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\type_traits
;	COMDAT ??$move@AAPAVNvEdgeInfo@@@std@@YA$$QAPAVNvEdgeInfo@@AAPAV1@@Z
_TEXT	SEGMENT
??$move@AAPAVNvEdgeInfo@@@std@@YA$$QAPAVNvEdgeInfo@@AAPAV1@@Z PROC ; std::move<NvEdgeInfo * &>, COMDAT
; __Arg$ = ecx

; 1397 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

	mov	eax, ecx

; 1398 : }

	ret	0
??$move@AAPAVNvEdgeInfo@@@std@@YA$$QAPAVNvEdgeInfo@@AAPAV1@@Z ENDP ; std::move<NvEdgeInfo * &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Emplace_back@PAVNvEdgeInfo@@@?$_Uninitialized_backout_al@V?$xalloc@PAVNvEdgeInfo@@@@@std@@QAEX$$QAPAVNvEdgeInfo@@@Z
_TEXT	SEGMENT
_<_Vals_0>$ = 8						; size = 4
??$_Emplace_back@PAVNvEdgeInfo@@@?$_Uninitialized_backout_al@V?$xalloc@PAVNvEdgeInfo@@@@@std@@QAEX$$QAPAVNvEdgeInfo@@@Z PROC ; std::_Uninitialized_backout_al<xalloc<NvEdgeInfo *> >::_Emplace_back<NvEdgeInfo *>, COMDAT
; _this$ = ecx

; 1620 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _<_Vals_0>$[esp-4]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edx], eax

; 1621 :         ++_Last;

	add	DWORD PTR [ecx+4], 4

; 1622 :     }

	ret	4
??$_Emplace_back@PAVNvEdgeInfo@@@?$_Uninitialized_backout_al@V?$xalloc@PAVNvEdgeInfo@@@@@std@@QAEX$$QAPAVNvEdgeInfo@@@Z ENDP ; std::_Uninitialized_backout_al<xalloc<NvEdgeInfo *> >::_Emplace_back<NvEdgeInfo *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\type_traits
;	COMDAT ??$forward@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@std@@YA$$QAV?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@AAV1@@Z
_TEXT	SEGMENT
??$forward@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@std@@YA$$QAV?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@AAV1@@Z PROC ; std::forward<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> > >, COMDAT
; __Arg$ = ecx

; 1386 :     return static_cast<_Ty&&>(_Arg);

	mov	eax, ecx

; 1387 : }

	ret	0
??$forward@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@std@@YA$$QAV?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@AAV1@@Z ENDP ; std::forward<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$construct@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@V1@@?$_Normal_allocator_traits@V?$xalloc@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@@@std@@SAXAAV?$xalloc@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@@PAV?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@$$QAV3@@Z
_TEXT	SEGMENT
_<_Args_0>$ = 8						; size = 4
??$construct@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@V1@@?$_Normal_allocator_traits@V?$xalloc@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@@@std@@SAXAAV?$xalloc@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@@PAV?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@$$QAV3@@Z PROC ; std::_Normal_allocator_traits<xalloc<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> > > >::construct<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> >,xr_vector<NvStripInfo *,xalloc<NvStripInfo *> > >, COMDAT
; __Al$dead$ = ecx
; __Ptr$ = edx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 546  :         const pointer _Rightfirst = _Right_data._Myfirst;

	mov	eax, DWORD PTR _<_Args_0>$[esp-4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 564  :     static _CONSTEXPR20_DYNALLOC void construct(_Alloc& _Al, _Ty* _Ptr, _Types&&... _Args) {

	push	ebx
	push	ebp
	mov	ebp, edx
	push	esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ebp], 0
	mov	DWORD PTR [ebp+4], 0
	mov	DWORD PTR [ebp+8], 0

; 546  :         const pointer _Rightfirst = _Right_data._Myfirst;

	mov	esi, DWORD PTR [eax]

; 547  :         const pointer _Rightlast  = _Right_data._Mylast;

	mov	ebx, DWORD PTR [eax+4]

; 548  :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);
; 549  :         if (_Rightfirst != _Rightlast) {

	cmp	esi, ebx
	je	SHORT $LN37@construct
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 550  :             _Buy_raw(static_cast<size_type>(_Rightlast - _Rightfirst));

	mov	eax, ebx
	sub	eax, esi
	sar	eax, 2
	push	edi
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	lea	edi, DWORD PTR [eax*4]
	push	edi
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1698 :         const auto _Newvec = _Getal().allocate(_Newcapacity);

	mov	edx, eax

; 1699 :         _Myfirst           = _Newvec;

	mov	DWORD PTR [ebp], edx

; 1700 :         _Mylast            = _Newvec;

	mov	DWORD PTR [ebp+4], edx

; 1701 :         _Myend             = _Newvec + _Newcapacity;

	lea	ecx, DWORD PTR [edi+edx]
	mov	DWORD PTR [ebp+8], ecx
	pop	edi
$LL25@construct:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1620 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

	mov	eax, DWORD PTR [esi]

; 1658 :     for (; _UFirst != _ULast; ++_UFirst) {

	add	esi, 4

; 1620 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

	mov	DWORD PTR [edx], eax

; 1621 :         ++_Last;

	add	edx, 4

; 1658 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	esi, ebx
	jne	SHORT $LL25@construct
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 552  :             _My_data._Mylast = _Ucopy(_Rightfirst, _Rightlast, _My_data._Myfirst);

	mov	DWORD PTR [ebp+4], edx
$LN37@construct:
	pop	esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 575  :     }

	pop	ebp
	pop	ebx
	ret	0
??$construct@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@V1@@?$_Normal_allocator_traits@V?$xalloc@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@@@std@@SAXAAV?$xalloc@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@@PAV?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@$$QAV3@@Z ENDP ; std::_Normal_allocator_traits<xalloc<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> > > >::construct<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> >,xr_vector<NvStripInfo *,xalloc<NvStripInfo *> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\type_traits
;	COMDAT ??$forward@PAVNvEdgeInfo@@@std@@YA$$QAPAVNvEdgeInfo@@AAPAV1@@Z
_TEXT	SEGMENT
??$forward@PAVNvEdgeInfo@@@std@@YA$$QAPAVNvEdgeInfo@@AAPAV1@@Z PROC ; std::forward<NvEdgeInfo *>, COMDAT
; __Arg$ = ecx

; 1386 :     return static_cast<_Ty&&>(_Arg);

	mov	eax, ecx

; 1387 : }

	ret	0
??$forward@PAVNvEdgeInfo@@@std@@YA$$QAPAVNvEdgeInfo@@AAPAV1@@Z ENDP ; std::forward<NvEdgeInfo *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$construct@PAVNvEdgeInfo@@PAV1@@?$_Normal_allocator_traits@V?$xalloc@PAVNvEdgeInfo@@@@@std@@SAXAAV?$xalloc@PAVNvEdgeInfo@@@@PAPAVNvEdgeInfo@@$$QAPAV3@@Z
_TEXT	SEGMENT
_<_Args_0>$ = 8						; size = 4
??$construct@PAVNvEdgeInfo@@PAV1@@?$_Normal_allocator_traits@V?$xalloc@PAVNvEdgeInfo@@@@@std@@SAXAAV?$xalloc@PAVNvEdgeInfo@@@@PAPAVNvEdgeInfo@@$$QAPAV3@@Z PROC ; std::_Normal_allocator_traits<xalloc<NvEdgeInfo *> >::construct<NvEdgeInfo *,NvEdgeInfo *>, COMDAT
; __Al$dead$ = ecx
; __Ptr$ = edx

; 565  :         if constexpr (_Uses_default_construct<_Alloc, _Ty*, _Types...>::value) {
; 566  :             (void) _Al; // TRANSITION, DevCom-1004719
; 567  : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 568  :             _STD construct_at(_Ptr, _STD forward<_Types>(_Args)...);
; 569  : #else // __cpp_lib_constexpr_dynamic_alloc
; 570  :             ::new (static_cast<void*>(_Ptr)) _Ty(_STD forward<_Types>(_Args)...);
; 571  : #endif // __cpp_lib_constexpr_dynamic_alloc
; 572  :         } else {
; 573  :             _Al.construct(_Ptr, _STD forward<_Types>(_Args)...);

	mov	eax, DWORD PTR _<_Args_0>$[esp-4]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edx], eax

; 574  :         }
; 575  :     }

	ret	0
??$construct@PAVNvEdgeInfo@@PAV1@@?$_Normal_allocator_traits@V?$xalloc@PAVNvEdgeInfo@@@@@std@@SAXAAV?$xalloc@PAVNvEdgeInfo@@@@PAPAVNvEdgeInfo@@$$QAPAV3@@Z ENDP ; std::_Normal_allocator_traits<xalloc<NvEdgeInfo *> >::construct<NvEdgeInfo *,NvEdgeInfo *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?construct@?$xalloc@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@@QAEXPAV?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@ABV2@@Z
_TEXT	SEGMENT
_p$ = 8							; size = 4
__Val$ = 12						; size = 4
?construct@?$xalloc@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@@QAEXPAV?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@ABV2@@Z PROC ; xalloc<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> > >::construct, COMDAT
; _this$dead$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 546  :         const pointer _Rightfirst = _Right_data._Myfirst;

	mov	eax, DWORD PTR __Val$[esp-4]
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	push	ebx
	push	ebp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	ebp, DWORD PTR _p$[esp+4]
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	push	esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ebp], 0
	mov	DWORD PTR [ebp+4], 0
	mov	DWORD PTR [ebp+8], 0

; 546  :         const pointer _Rightfirst = _Right_data._Myfirst;

	mov	esi, DWORD PTR [eax]

; 547  :         const pointer _Rightlast  = _Right_data._Mylast;

	mov	ebx, DWORD PTR [eax+4]

; 548  :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);
; 549  :         if (_Rightfirst != _Rightlast) {

	cmp	esi, ebx
	je	SHORT $LN35@construct
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 550  :             _Buy_raw(static_cast<size_type>(_Rightlast - _Rightfirst));

	mov	eax, ebx
	sub	eax, esi
	sar	eax, 2
	push	edi
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	lea	edi, DWORD PTR [eax*4]
	push	edi
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1698 :         const auto _Newvec = _Getal().allocate(_Newcapacity);

	mov	edx, eax

; 1699 :         _Myfirst           = _Newvec;

	mov	DWORD PTR [ebp], edx

; 1700 :         _Mylast            = _Newvec;

	mov	DWORD PTR [ebp+4], edx

; 1701 :         _Myend             = _Newvec + _Newcapacity;

	lea	ecx, DWORD PTR [edi+edx]
	mov	DWORD PTR [ebp+8], ecx
	pop	edi
$LL23@construct:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1620 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

	mov	eax, DWORD PTR [esi]

; 1658 :     for (; _UFirst != _ULast; ++_UFirst) {

	add	esi, 4

; 1620 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

	mov	DWORD PTR [edx], eax

; 1621 :         ++_Last;

	add	edx, 4

; 1658 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	esi, ebx
	jne	SHORT $LL23@construct
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 552  :             _My_data._Mylast = _Ucopy(_Rightfirst, _Rightlast, _My_data._Myfirst);

	mov	DWORD PTR [ebp+4], edx
$LN35@construct:
	pop	esi
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	pop	ebp
	pop	ebx
	ret	8
?construct@?$xalloc@V?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@@@QAEXPAV?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@ABV2@@Z ENDP ; xalloc<xr_vector<NvStripInfo *,xalloc<NvStripInfo *> > >::construct
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?construct@?$xalloc@PAVNvEdgeInfo@@@@QAEXPAPAVNvEdgeInfo@@ABQAV2@@Z
_TEXT	SEGMENT
_p$ = 8							; size = 4
__Val$ = 12						; size = 4
?construct@?$xalloc@PAVNvEdgeInfo@@@@QAEXPAPAVNvEdgeInfo@@ABQAV2@@Z PROC ; xalloc<NvEdgeInfo *>::construct, COMDAT
; _this$dead$ = ecx

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	eax, DWORD PTR __Val$[esp-4]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR _p$[esp-4]
	mov	DWORD PTR [eax], ecx
	ret	8
?construct@?$xalloc@PAVNvEdgeInfo@@@@QAEXPAPAVNvEdgeInfo@@ABQAV2@@Z ENDP ; xalloc<NvEdgeInfo *>::construct
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@QAE@ABV0@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@QAE@ABV0@@Z PROC ; xr_vector<NvStripInfo *,xalloc<NvStripInfo *> >::xr_vector<NvStripInfo *,xalloc<NvStripInfo *> >, COMDAT
; _this$ = ecx

; 546  :         const pointer _Rightfirst = _Right_data._Myfirst;

	mov	eax, DWORD PTR ___that$[esp-4]

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	push	ebx
	mov	ebx, ecx
	push	ebp
	push	esi
	mov	DWORD PTR [ebx], 0
	mov	DWORD PTR [ebx+4], 0
	mov	DWORD PTR [ebx+8], 0

; 546  :         const pointer _Rightfirst = _Right_data._Myfirst;

	mov	esi, DWORD PTR [eax]

; 547  :         const pointer _Rightlast  = _Right_data._Mylast;

	mov	ebp, DWORD PTR [eax+4]

; 548  :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);
; 549  :         if (_Rightfirst != _Rightlast) {

	cmp	esi, ebp
	je	SHORT $LN44@xr_vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 550  :             _Buy_raw(static_cast<size_type>(_Rightlast - _Rightfirst));

	mov	eax, ebp
	sub	eax, esi
	sar	eax, 2
	push	edi
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	lea	edi, DWORD PTR [eax*4]
	push	edi
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1698 :         const auto _Newvec = _Getal().allocate(_Newcapacity);

	mov	edx, eax

; 1699 :         _Myfirst           = _Newvec;

	mov	DWORD PTR [ebx], edx

; 1700 :         _Mylast            = _Newvec;

	mov	DWORD PTR [ebx+4], edx

; 1701 :         _Myend             = _Newvec + _Newcapacity;

	lea	ecx, DWORD PTR [edi+edx]
	mov	DWORD PTR [ebx+8], ecx
	pop	edi
$LL21@xr_vector:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1620 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

	mov	eax, DWORD PTR [esi]

; 1658 :     for (; _UFirst != _ULast; ++_UFirst) {

	add	esi, 4

; 1620 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

	mov	DWORD PTR [edx], eax

; 1621 :         ++_Last;

	add	edx, 4

; 1658 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	esi, ebp
	jne	SHORT $LL21@xr_vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 552  :             _My_data._Mylast = _Ucopy(_Rightfirst, _Rightlast, _My_data._Myfirst);

	mov	DWORD PTR [ebx+4], edx
$LN44@xr_vector:
	pop	esi
	pop	ebp
	mov	eax, ebx
	pop	ebx
	ret	4
??0?$xr_vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@@QAE@ABV0@@Z ENDP ; xr_vector<NvStripInfo *,xalloc<NvStripInfo *> >::xr_vector<NvStripInfo *,xalloc<NvStripInfo *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0?$vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??0?$vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@std@@QAE@ABV01@@Z PROC ; std::vector<NvStripInfo *,xalloc<NvStripInfo *> >::vector<NvStripInfo *,xalloc<NvStripInfo *> >, COMDAT
; _this$ = ecx

; 543  :         auto&& _Alproxy           = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 544  :         auto& _My_data            = _Mypair._Myval2;
; 545  :         const auto& _Right_data   = _Right._Mypair._Myval2;
; 546  :         const pointer _Rightfirst = _Right_data._Myfirst;

	mov	eax, DWORD PTR __Right$[esp-4]
	push	ebx
	mov	ebx, ecx
	push	ebp
	push	esi

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ebx], 0
	mov	DWORD PTR [ebx+4], 0
	mov	DWORD PTR [ebx+8], 0

; 543  :         auto&& _Alproxy           = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 544  :         auto& _My_data            = _Mypair._Myval2;
; 545  :         const auto& _Right_data   = _Right._Mypair._Myval2;
; 546  :         const pointer _Rightfirst = _Right_data._Myfirst;

	mov	esi, DWORD PTR [eax]

; 547  :         const pointer _Rightlast  = _Right_data._Mylast;

	mov	ebp, DWORD PTR [eax+4]

; 548  :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);
; 549  :         if (_Rightfirst != _Rightlast) {

	cmp	esi, ebp
	je	SHORT $LN42@vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 550  :             _Buy_raw(static_cast<size_type>(_Rightlast - _Rightfirst));

	mov	eax, ebp
	sub	eax, esi
	sar	eax, 2
	push	edi
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	lea	edi, DWORD PTR [eax*4]
	push	edi
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1698 :         const auto _Newvec = _Getal().allocate(_Newcapacity);

	mov	edx, eax

; 1699 :         _Myfirst           = _Newvec;

	mov	DWORD PTR [ebx], edx

; 1700 :         _Mylast            = _Newvec;

	mov	DWORD PTR [ebx+4], edx

; 1701 :         _Myend             = _Newvec + _Newcapacity;

	lea	ecx, DWORD PTR [edi+edx]
	mov	DWORD PTR [ebx+8], ecx
	pop	edi
$LL19@vector:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1620 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

	mov	eax, DWORD PTR [esi]

; 1658 :     for (; _UFirst != _ULast; ++_UFirst) {

	add	esi, 4

; 1620 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

	mov	DWORD PTR [edx], eax

; 1621 :         ++_Last;

	add	edx, 4

; 1658 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	esi, ebp
	jne	SHORT $LL19@vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 552  :             _My_data._Mylast = _Ucopy(_Rightfirst, _Rightlast, _My_data._Myfirst);

	mov	DWORD PTR [ebx+4], edx
$LN42@vector:
	pop	esi

; 553  :             _Guard._Target   = nullptr;
; 554  :         }
; 555  : 
; 556  :         _Proxy._Release();
; 557  :     }

	pop	ebp
	mov	eax, ebx
	pop	ebx
	ret	4
??0?$vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@std@@QAE@ABV01@@Z ENDP ; std::vector<NvStripInfo *,xalloc<NvStripInfo *> >::vector<NvStripInfo *,xalloc<NvStripInfo *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??1?$_Tidy_guard@V?$vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Tidy_guard@V?$vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@std@@@std@@QAE@XZ PROC ; std::_Tidy_guard<std::vector<NvStripInfo *,xalloc<NvStripInfo *> > >::~_Tidy_guard<std::vector<NvStripInfo *,xalloc<NvStripInfo *> > >, COMDAT
; _this$ = ecx

; 33   :     _CONSTEXPR20_DYNALLOC ~_Tidy_guard() {

	push	esi

; 34   :         if (_Target) {

	mov	esi, DWORD PTR [ecx]
	test	esi, esi
	je	SHORT $LN5@Tidy_guard
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN5@Tidy_guard
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+4], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+8], 0
$LN5@Tidy_guard:
	pop	esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 37   :     }

	ret	0
??1?$_Tidy_guard@V?$vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@std@@@std@@QAE@XZ ENDP ; std::_Tidy_guard<std::vector<NvStripInfo *,xalloc<NvStripInfo *> > >::~_Tidy_guard<std::vector<NvStripInfo *,xalloc<NvStripInfo *> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Buy_raw@?$vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@std@@AAEXI@Z
_TEXT	SEGMENT
__Newcapacity$ = 8					; size = 4
?_Buy_raw@?$vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@std@@AAEXI@Z PROC ; std::vector<NvStripInfo *,xalloc<NvStripInfo *> >::_Buy_raw, COMDAT
; _this$ = ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	mov	eax, DWORD PTR __Newcapacity$[esp-4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1688 :     _CONSTEXPR20_CONTAINER void _Buy_raw(const size_type _Newcapacity) {

	push	esi
	push	edi
	mov	edi, ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	lea	esi, DWORD PTR [eax*4]
	push	esi
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1699 :         _Myfirst           = _Newvec;

	mov	DWORD PTR [edi], eax

; 1700 :         _Mylast            = _Newvec;

	mov	DWORD PTR [edi+4], eax

; 1701 :         _Myend             = _Newvec + _Newcapacity;

	add	eax, esi
	mov	DWORD PTR [edi+8], eax
	pop	edi
	pop	esi

; 1702 :     }

	ret	4
?_Buy_raw@?$vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@std@@AAEXI@Z ENDP ; std::vector<NvStripInfo *,xalloc<NvStripInfo *> >::_Buy_raw
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?select_on_container_copy_construction@?$_Normal_allocator_traits@V?$xalloc@PAVNvStripInfo@@@@@std@@SA?AV?$xalloc@PAVNvStripInfo@@@@ABV3@@Z
_TEXT	SEGMENT
?select_on_container_copy_construction@?$_Normal_allocator_traits@V?$xalloc@PAVNvStripInfo@@@@@std@@SA?AV?$xalloc@PAVNvStripInfo@@@@ABV3@@Z PROC ; std::_Normal_allocator_traits<xalloc<NvStripInfo *> >::select_on_container_copy_construction, COMDAT
; ___$ReturnUdt$ = ecx
; __Al$dead$ = edx

; 599  :         if constexpr (_Has_select_on_container_copy_construction<_Alloc>::value) {
; 600  :             return _Al.select_on_container_copy_construction();
; 601  :         } else {
; 602  :             return _Al;

	mov	eax, ecx

; 603  :         }
; 604  :     }

	ret	0
?select_on_container_copy_construction@?$_Normal_allocator_traits@V?$xalloc@PAVNvStripInfo@@@@@std@@SA?AV?$xalloc@PAVNvStripInfo@@@@ABV3@@Z ENDP ; std::_Normal_allocator_traits<xalloc<NvStripInfo *> >::select_on_container_copy_construction
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ??0?$xalloc@PAVNvStripInfo@@@@QAE@ABV0@@Z
_TEXT	SEGMENT
___formal$dead$ = 8					; size = 4
??0?$xalloc@PAVNvStripInfo@@@@QAE@ABV0@@Z PROC		; xalloc<NvStripInfo *>::xalloc<NvStripInfo *>, COMDAT
; _this$ = ecx

; 77   : 													xalloc			(const xalloc<T>&)						{	}

	mov	eax, ecx
	ret	4
??0?$xalloc@PAVNvStripInfo@@@@QAE@ABV0@@Z ENDP		; xalloc<NvStripInfo *>::xalloc<NvStripInfo *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$?0V?$xalloc@PAVNvStripInfo@@@@$$V@?$_Compressed_pair@V?$xalloc@PAVNvStripInfo@@@@V?$_Vector_val@U?$_Simple_types@PAVNvStripInfo@@@std@@@std@@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAV?$xalloc@PAVNvStripInfo@@@@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
__Val1$dead$ = 12					; size = 4
??$?0V?$xalloc@PAVNvStripInfo@@@@$$V@?$_Compressed_pair@V?$xalloc@PAVNvStripInfo@@@@V?$_Vector_val@U?$_Simple_types@PAVNvStripInfo@@@std@@@std@@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAV?$xalloc@PAVNvStripInfo@@@@@Z PROC ; std::_Compressed_pair<xalloc<NvStripInfo *>,std::_Vector_val<std::_Simple_types<NvStripInfo *> >,1>::_Compressed_pair<xalloc<NvStripInfo *>,std::_Vector_val<std::_Simple_types<NvStripInfo *> >,1><xalloc<NvStripInfo *> >, COMDAT
; _this$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1336 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	eax, ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1336 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	ret	8
??$?0V?$xalloc@PAVNvStripInfo@@@@$$V@?$_Compressed_pair@V?$xalloc@PAVNvStripInfo@@@@V?$_Vector_val@U?$_Simple_types@PAVNvStripInfo@@@std@@@std@@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAV?$xalloc@PAVNvStripInfo@@@@@Z ENDP ; std::_Compressed_pair<xalloc<NvStripInfo *>,std::_Vector_val<std::_Simple_types<NvStripInfo *> >,1>::_Compressed_pair<xalloc<NvStripInfo *>,std::_Vector_val<std::_Simple_types<NvStripInfo *> >,1><xalloc<NvStripInfo *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??$_Ucopy@PAPAVNvStripInfo@@@?$vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@std@@AAEPAPAVNvStripInfo@@PAPAV2@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Ucopy@PAPAVNvStripInfo@@@?$vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@std@@AAEPAPAVNvStripInfo@@PAPAV2@00@Z PROC ; std::vector<NvStripInfo *,xalloc<NvStripInfo *> >::_Ucopy<NvStripInfo * *>, COMDAT
; _this$dead$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1658 :     for (; _UFirst != _ULast; ++_UFirst) {

	mov	ecx, DWORD PTR __First$[esp-4]

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	eax, DWORD PTR __Dest$[esp-4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1639 :     _CONSTEXPR20_CONTAINER pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Dest) {

	push	esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1658 :     for (; _UFirst != _ULast; ++_UFirst) {

	mov	esi, DWORD PTR __Last$[esp]
	cmp	ecx, esi
	je	SHORT $LN5@Ucopy
$LL6@Ucopy:

; 1620 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

	mov	edx, DWORD PTR [ecx]

; 1621 :         ++_Last;

	add	ecx, 4
	mov	DWORD PTR [eax], edx
	add	eax, 4

; 1658 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	ecx, esi
	jne	SHORT $LL6@Ucopy
$LN5@Ucopy:
	pop	esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1642 :     }

	ret	12					; 0000000cH
??$_Ucopy@PAPAVNvStripInfo@@@?$vector@PAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@std@@AAEPAPAVNvStripInfo@@PAPAV2@00@Z ENDP ; std::vector<NvStripInfo *,xalloc<NvStripInfo *> >::_Ucopy<NvStripInfo * *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\type_traits
;	COMDAT ??$forward@V?$xalloc@PAVNvStripInfo@@@@@std@@YA$$QAV?$xalloc@PAVNvStripInfo@@@@AAV1@@Z
_TEXT	SEGMENT
??$forward@V?$xalloc@PAVNvStripInfo@@@@@std@@YA$$QAV?$xalloc@PAVNvStripInfo@@@@AAV1@@Z PROC ; std::forward<xalloc<NvStripInfo *> >, COMDAT
; __Arg$ = ecx

; 1386 :     return static_cast<_Ty&&>(_Arg);

	mov	eax, ecx

; 1387 : }

	ret	0
??$forward@V?$xalloc@PAVNvStripInfo@@@@@std@@YA$$QAV?$xalloc@PAVNvStripInfo@@@@AAV1@@Z ENDP ; std::forward<xalloc<NvStripInfo *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Uninitialized_copy@PAPAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@std@@YAPAPAVNvStripInfo@@QAPAV1@0PAPAV1@AAV?$xalloc@PAVNvStripInfo@@@@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Al$dead$ = 12						; size = 4
??$_Uninitialized_copy@PAPAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@std@@YAPAPAVNvStripInfo@@QAPAV1@0PAPAV1@AAV?$xalloc@PAVNvStripInfo@@@@@Z PROC ; std::_Uninitialized_copy<NvStripInfo * *,xalloc<NvStripInfo *> >, COMDAT
; __First$ = ecx
; __Last$ = edx

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	eax, DWORD PTR __Dest$[esp-4]

; 1637 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

	push	esi
	mov	esi, edx

; 1638 :     // copy [_First, _Last) to raw _Dest, using _Al
; 1639 :     // note: only called internally from elsewhere in the STL
; 1640 :     using _Ptrval = typename _Alloc::value_type*;
; 1641 : 
; 1642 :     auto _UFirst      = _Get_unwrapped(_First);
; 1643 :     const auto _ULast = _Get_unwrapped(_Last);
; 1644 : 
; 1645 :     if constexpr (conjunction_v<bool_constant<_Ptr_copy_cat<decltype(_UFirst), _Ptrval>::_Really_trivial>,
; 1646 :                       _Uses_default_construct<_Alloc, _Ptrval, decltype(*_UFirst)>>) {
; 1647 : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 1648 :         if (!_STD is_constant_evaluated())
; 1649 : #endif // __cpp_lib_constexpr_dynamic_alloc
; 1650 :         {
; 1651 :             _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));
; 1652 :             _Dest += _ULast - _UFirst;
; 1653 :             return _Dest;
; 1654 :         }
; 1655 :     }
; 1656 : 
; 1657 :     _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1658 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	ecx, esi
	je	SHORT $LN3@Uninitiali
	npad	5
$LL4@Uninitiali:

; 1620 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

	mov	edx, DWORD PTR [ecx]

; 1621 :         ++_Last;

	add	ecx, 4
	mov	DWORD PTR [eax], edx
	add	eax, 4

; 1638 :     // copy [_First, _Last) to raw _Dest, using _Al
; 1639 :     // note: only called internally from elsewhere in the STL
; 1640 :     using _Ptrval = typename _Alloc::value_type*;
; 1641 : 
; 1642 :     auto _UFirst      = _Get_unwrapped(_First);
; 1643 :     const auto _ULast = _Get_unwrapped(_Last);
; 1644 : 
; 1645 :     if constexpr (conjunction_v<bool_constant<_Ptr_copy_cat<decltype(_UFirst), _Ptrval>::_Really_trivial>,
; 1646 :                       _Uses_default_construct<_Alloc, _Ptrval, decltype(*_UFirst)>>) {
; 1647 : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 1648 :         if (!_STD is_constant_evaluated())
; 1649 : #endif // __cpp_lib_constexpr_dynamic_alloc
; 1650 :         {
; 1651 :             _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));
; 1652 :             _Dest += _ULast - _UFirst;
; 1653 :             return _Dest;
; 1654 :         }
; 1655 :     }
; 1656 : 
; 1657 :     _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1658 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	ecx, esi
	jne	SHORT $LL4@Uninitiali
$LN3@Uninitiali:
	pop	esi

; 1659 :         _Backout._Emplace_back(*_UFirst);
; 1660 :     }
; 1661 : 
; 1662 :     return _Backout._Release();
; 1663 : }

	ret	0
??$_Uninitialized_copy@PAPAVNvStripInfo@@V?$xalloc@PAVNvStripInfo@@@@@std@@YAPAPAVNvStripInfo@@QAPAV1@0PAPAV1@AAV?$xalloc@PAVNvStripInfo@@@@@Z ENDP ; std::_Uninitialized_copy<NvStripInfo * *,xalloc<NvStripInfo *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Emplace_back@AAPAVNvStripInfo@@@?$_Uninitialized_backout_al@V?$xalloc@PAVNvStripInfo@@@@@std@@QAEXAAPAVNvStripInfo@@@Z
_TEXT	SEGMENT
_<_Vals_0>$ = 8						; size = 4
??$_Emplace_back@AAPAVNvStripInfo@@@?$_Uninitialized_backout_al@V?$xalloc@PAVNvStripInfo@@@@@std@@QAEXAAPAVNvStripInfo@@@Z PROC ; std::_Uninitialized_backout_al<xalloc<NvStripInfo *> >::_Emplace_back<NvStripInfo * &>, COMDAT
; _this$ = ecx

; 1620 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _<_Vals_0>$[esp-4]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edx], eax

; 1621 :         ++_Last;

	add	DWORD PTR [ecx+4], 4

; 1622 :     }

	ret	4
??$_Emplace_back@AAPAVNvStripInfo@@@?$_Uninitialized_backout_al@V?$xalloc@PAVNvStripInfo@@@@@std@@QAEXAAPAVNvStripInfo@@@Z ENDP ; std::_Uninitialized_backout_al<xalloc<NvStripInfo *> >::_Emplace_back<NvStripInfo * &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\type_traits
;	COMDAT ??$forward@AAPAVNvStripInfo@@@std@@YAAAPAVNvStripInfo@@AAPAV1@@Z
_TEXT	SEGMENT
??$forward@AAPAVNvStripInfo@@@std@@YAAAPAVNvStripInfo@@AAPAV1@@Z PROC ; std::forward<NvStripInfo * &>, COMDAT
; __Arg$ = ecx

; 1386 :     return static_cast<_Ty&&>(_Arg);

	mov	eax, ecx

; 1387 : }

	ret	0
??$forward@AAPAVNvStripInfo@@@std@@YAAAPAVNvStripInfo@@AAPAV1@@Z ENDP ; std::forward<NvStripInfo * &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$construct@PAVNvStripInfo@@AAPAV1@@?$_Normal_allocator_traits@V?$xalloc@PAVNvStripInfo@@@@@std@@SAXAAV?$xalloc@PAVNvStripInfo@@@@PAPAVNvStripInfo@@AAPAV3@@Z
_TEXT	SEGMENT
_<_Args_0>$ = 8						; size = 4
??$construct@PAVNvStripInfo@@AAPAV1@@?$_Normal_allocator_traits@V?$xalloc@PAVNvStripInfo@@@@@std@@SAXAAV?$xalloc@PAVNvStripInfo@@@@PAPAVNvStripInfo@@AAPAV3@@Z PROC ; std::_Normal_allocator_traits<xalloc<NvStripInfo *> >::construct<NvStripInfo *,NvStripInfo * &>, COMDAT
; __Al$dead$ = ecx
; __Ptr$ = edx

; 565  :         if constexpr (_Uses_default_construct<_Alloc, _Ty*, _Types...>::value) {
; 566  :             (void) _Al; // TRANSITION, DevCom-1004719
; 567  : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 568  :             _STD construct_at(_Ptr, _STD forward<_Types>(_Args)...);
; 569  : #else // __cpp_lib_constexpr_dynamic_alloc
; 570  :             ::new (static_cast<void*>(_Ptr)) _Ty(_STD forward<_Types>(_Args)...);
; 571  : #endif // __cpp_lib_constexpr_dynamic_alloc
; 572  :         } else {
; 573  :             _Al.construct(_Ptr, _STD forward<_Types>(_Args)...);

	mov	eax, DWORD PTR _<_Args_0>$[esp-4]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edx], eax

; 574  :         }
; 575  :     }

	ret	0
??$construct@PAVNvStripInfo@@AAPAV1@@?$_Normal_allocator_traits@V?$xalloc@PAVNvStripInfo@@@@@std@@SAXAAV?$xalloc@PAVNvStripInfo@@@@PAPAVNvStripInfo@@AAPAV3@@Z ENDP ; std::_Normal_allocator_traits<xalloc<NvStripInfo *> >::construct<NvStripInfo *,NvStripInfo * &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_std_extensions.h
;	COMDAT ?_max@@YAHHH@Z
_TEXT	SEGMENT
?_max@@YAHHH@Z PROC					; _max, COMDAT
; _x$dead$ = ecx
; _y$ = edx

; 159  : IC s32		_max	(s32 x, s32 y)	{ return x - ((x - y) & ((x - y) >> (sizeof(s32) * 8 - 1))); };

	push	esi
	mov	eax, 1
	mov	esi, eax
	sub	esi, edx
	mov	ecx, esi
	sar	ecx, 31					; 0000001fH
	and	ecx, esi
	sub	eax, ecx
	pop	esi
	ret	0
?_max@@YAHHH@Z ENDP					; _max
_TEXT	ENDS
END
