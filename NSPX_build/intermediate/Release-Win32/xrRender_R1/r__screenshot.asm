; Listing generated by Microsoft (R) Optimizing Compiler Version 19.29.30146.0 

	TITLE	i:\vitalya\mine\nsprojectx\nspx_build\intermediate\release-win32\xrrender_r1\r__screenshot.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	??_C@_0DB@JJCPJBNI@?$HO?5Can?8t?5capture?5screen?5while?5in@ ; `string'
PUBLIC	??_C@_08PJBAJFMP@mainmenu@			; `string'
PUBLIC	??_C@_0BC@GOMLAKFD@ss_?$CFs_?$CFs_?$CI?$CFs?$CJ?4png@ ; `string'
PUBLIC	??_C@_0O@IBCMCKFE@$screenshots$@		; `string'
PUBLIC	??_C@_0BE@BLBPHPBA@CRender?3?3Screenshot@	; `string'
PUBLIC	??_C@_0DN@GJLDAKLL@I?3?2Vitalya?2mine?2NSProjectX?2laye@ ; `string'
PUBLIC	??_C@_02EIPGLLEK@fs@				; `string'
PUBLIC	??_C@_07DIANDIIF@?9ss_jpg@			; `string'
PUBLIC	??_C@_0BD@PFGAICKI@ssq_?$CFs_?$CFs_?$CI?$CFs?$CJ?4jpg@ ; `string'
PUBLIC	??_C@_07MHPIAKFK@?9ss_tga@			; `string'
PUBLIC	??_C@_0BD@KJFLAHH@ssq_?$CFs_?$CFs_?$CI?$CFs?$CJ?4tga@ ; `string'
PUBLIC	??_C@_02NJPHDIAB@_?$CD@				; `string'
PUBLIC	??_C@_01IDAFKMJL@_@				; `string'
PUBLIC	??_C@_03MMKFLIAD@ss_@				; `string'
PUBLIC	??_C@_04JCAPCJAP@?4tga@				; `string'
PUBLIC	?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage
EXTRN	__imp_?imf_Process@@YAXPAIII0IIW4EIMF_Type@@@Z:PROC
EXTRN	__imp_?strconcat@@YAPADHPADPBD11111@Z:PROC
EXTRN	__imp__strstr:PROC
EXTRN	__imp__D3DXSaveSurfaceToFileInMemory@20:PROC
EXTRN	__imp_?Core@@3VxrCore@@A:BYTE
EXTRN	__imp_?timestamp@@YAPADAAY0EA@D@Z:PROC
EXTRN	__imp____stdio_common_vsprintf_s:PROC
EXTRN	__imp_?w_close@CLocatorAPI@@QAEXAAPAVIWriter@@@Z:PROC
EXTRN	__imp_?w_open@CLocatorAPI@@QAEPAVIWriter@@PBD0@Z:PROC
EXTRN	__imp_?w_open@CLocatorAPI@@QAEPAVIWriter@@PBD@Z:PROC
EXTRN	__imp__D3DXSaveTextureToFileInMemory@16:PROC
EXTRN	__imp__D3DXLoadSurfaceFromSurface@32:PROC
EXTRN	__imp__D3DXCreateTexture@32:PROC
EXTRN	__imp_?GenLUT@CGammaControl@@QAEXAAU_D3DGAMMARAMP@@@Z:PROC
;	COMDAT ?ignore_always@?FF@??Screenshot@CRender@@UAEXW4ScreenshotMode@IRender_interface@@PBD@Z@4_NA
_BSS	SEGMENT
?ignore_always@?FF@??Screenshot@CRender@@UAEXW4ScreenshotMode@IRender_interface@@PBD@Z@4_NA DB 01H DUP (?) ; `CRender::Screenshot'::`85'::ignore_always
_BSS	ENDS
;	COMDAT ?ignore_always@?EK@??Screenshot@CRender@@UAEXW4ScreenshotMode@IRender_interface@@PBD@Z@4_NA
_BSS	SEGMENT
?ignore_always@?EK@??Screenshot@CRender@@UAEXW4ScreenshotMode@IRender_interface@@PBD@Z@4_NA DB 01H DUP (?) ; `CRender::Screenshot'::`74'::ignore_always
_BSS	ENDS
;	COMDAT ?ignore_always@?DP@??Screenshot@CRender@@UAEXW4ScreenshotMode@IRender_interface@@PBD@Z@4_NA
_BSS	SEGMENT
?ignore_always@?DP@??Screenshot@CRender@@UAEXW4ScreenshotMode@IRender_interface@@PBD@Z@4_NA DB 01H DUP (?) ; `CRender::Screenshot'::`63'::ignore_always
_BSS	ENDS
;	COMDAT ?ignore_always@?DE@??Screenshot@CRender@@UAEXW4ScreenshotMode@IRender_interface@@PBD@Z@4_NA
_BSS	SEGMENT
?ignore_always@?DE@??Screenshot@CRender@@UAEXW4ScreenshotMode@IRender_interface@@PBD@Z@4_NA DB 01H DUP (?) ; `CRender::Screenshot'::`52'::ignore_always
_BSS	ENDS
;	COMDAT ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA
_BSS	SEGMENT
?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA DQ 01H DUP (?) ; `__local_stdio_printf_options'::`2'::_OptionsStorage
_BSS	ENDS
;	COMDAT ??_C@_04JCAPCJAP@?4tga@
CONST	SEGMENT
??_C@_04JCAPCJAP@?4tga@ DB '.tga', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03MMKFLIAD@ss_@
CONST	SEGMENT
??_C@_03MMKFLIAD@ss_@ DB 'ss_', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01IDAFKMJL@_@
CONST	SEGMENT
??_C@_01IDAFKMJL@_@ DB '_', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_02NJPHDIAB@_?$CD@
CONST	SEGMENT
??_C@_02NJPHDIAB@_?$CD@ DB '_#', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@KJFLAHH@ssq_?$CFs_?$CFs_?$CI?$CFs?$CJ?4tga@
CONST	SEGMENT
??_C@_0BD@KJFLAHH@ssq_?$CFs_?$CFs_?$CI?$CFs?$CJ?4tga@ DB 'ssq_%s_%s_(%s).'
	DB	'tga', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_07MHPIAKFK@?9ss_tga@
CONST	SEGMENT
??_C@_07MHPIAKFK@?9ss_tga@ DB '-ss_tga', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@PFGAICKI@ssq_?$CFs_?$CFs_?$CI?$CFs?$CJ?4jpg@
CONST	SEGMENT
??_C@_0BD@PFGAICKI@ssq_?$CFs_?$CFs_?$CI?$CFs?$CJ?4jpg@ DB 'ssq_%s_%s_(%s)'
	DB	'.jpg', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_07DIANDIIF@?9ss_jpg@
CONST	SEGMENT
??_C@_07DIANDIIF@?9ss_jpg@ DB '-ss_jpg', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02EIPGLLEK@fs@
CONST	SEGMENT
??_C@_02EIPGLLEK@fs@ DB 'fs', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DN@GJLDAKLL@I?3?2Vitalya?2mine?2NSProjectX?2laye@
CONST	SEGMENT
??_C@_0DN@GJLDAKLL@I?3?2Vitalya?2mine?2NSProjectX?2laye@ DB 'I:\Vitalya\m'
	DB	'ine\NSProjectX\layers\xrRender\r__screenshot.cpp', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@BLBPHPBA@CRender?3?3Screenshot@
CONST	SEGMENT
??_C@_0BE@BLBPHPBA@CRender?3?3Screenshot@ DB 'CRender::Screenshot', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@IBCMCKFE@$screenshots$@
CONST	SEGMENT
??_C@_0O@IBCMCKFE@$screenshots$@ DB '$screenshots$', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@GOMLAKFD@ss_?$CFs_?$CFs_?$CI?$CFs?$CJ?4png@
CONST	SEGMENT
??_C@_0BC@GOMLAKFD@ss_?$CFs_?$CFs_?$CI?$CFs?$CJ?4png@ DB 'ss_%s_%s_(%s).p'
	DB	'ng', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_08PJBAJFMP@mainmenu@
CONST	SEGMENT
??_C@_08PJBAJFMP@mainmenu@ DB 'mainmenu', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DB@JJCPJBNI@?$HO?5Can?8t?5capture?5screen?5while?5in@
CONST	SEGMENT
??_C@_0DB@JJCPJBNI@?$HO?5Can?8t?5capture?5screen?5while?5in@ DB '~ Can''t'
	DB	' capture screen while in windowed mode...', 00H ; `string'
PUBLIC	?color_xrgb@@YAIIII@Z				; color_xrgb
PUBLIC	?color_get_B@@YAII@Z				; color_get_B
PUBLIC	?color_get_G@@YAII@Z				; color_get_G
PUBLIC	?color_get_R@@YAII@Z				; color_get_R
PUBLIC	_sprintf_s
PUBLIC	__vsprintf_s_l
PUBLIC	?strstr@@YAPADQADQBD@Z				; strstr
PUBLIC	?xr_malloc@@YAPAXI@Z				; xr_malloc
PUBLIC	?Screenshot@CRender@@UAEXW4ScreenshotMode@IRender_interface@@PBD@Z ; CRender::Screenshot
PUBLIC	??1TGAdesc@@QAE@XZ				; TGAdesc::~TGAdesc
PUBLIC	??0TGAdesc@@QAE@XZ				; TGAdesc::TGAdesc
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\tga.h
;	COMDAT ??0TGAdesc@@QAE@XZ
_TEXT	SEGMENT
??0TGAdesc@@QAE@XZ PROC					; TGAdesc::TGAdesc, COMDAT
; _this$ = ecx

; 36   : 	TGAdesc()	{ data = 0; };

	mov	DWORD PTR [ecx+16], 0
	mov	eax, ecx
	ret	0
??0TGAdesc@@QAE@XZ ENDP					; TGAdesc::TGAdesc
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\tga.h
;	COMDAT ??1TGAdesc@@QAE@XZ
_TEXT	SEGMENT
??1TGAdesc@@QAE@XZ PROC					; TGAdesc::~TGAdesc, COMDAT
; _this$ = ecx

; 37   : 	~TGAdesc()	{};

	ret	0
??1TGAdesc@@QAE@XZ ENDP					; TGAdesc::~TGAdesc
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__screenshot.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_flags.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__screenshot.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_color.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__screenshot.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\LocatorAPI.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__screenshot.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xrstring.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__screenshot.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\string.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__screenshot.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xrstring.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__screenshot.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\string.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__screenshot.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xrstring.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__screenshot.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__screenshot.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__screenshot.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__screenshot.cpp
_TEXT	SEGMENT
_fs$1 = -2172						; size = 4
_fs$2 = -2172						; size = 4
_fs$3 = -2172						; size = 4
$T4 = -2172						; size = 4
_fs$5 = -2172						; size = 4
_saved$6 = -2168					; size = 4
_saved$7 = -2168					; size = 4
_texture$8 = -2168					; size = 4
_saved$9 = -2164					; size = 4
_saved$10 = -2164					; size = 4
_pFB$ = -2160						; size = 4
_fs$11 = -2156						; size = 4
_surface$12 = -2156					; size = 4
$T13 = -2152						; size = 4
$T14 = -2152						; size = 4
$T15 = -2152						; size = 4
_D$ = -2148						; size = 8
_p$16 = -2140						; size = 20
_t_stemp$17 = -2120					; size = 64
_t_stemp$18 = -2120					; size = 64
_buf$19 = -2056						; size = 520
_buf$20 = -2056						; size = 520
_G$ = -1536						; size = 1536
_mode$ = 8						; size = 4
_name$ = 12						; size = 4
?Screenshot@CRender@@UAEXW4ScreenshotMode@IRender_interface@@PBD@Z PROC ; CRender::Screenshot
; _this$ = ecx

; 34   : {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	sub	esp, 2172				; 0000087cH
	push	ebx
	xor	ebx, ebx
	mov	DWORD PTR $T13[esp+2176], ebx

; 35   : 	if (!Device.b_is_Ready)			return;

	mov	edx, DWORD PTR __imp_?Device@@3VCRenderDevice@@A
	push	esi
	push	edi
	cmp	DWORD PTR [edx+272], ebx
	je	$LN62@Screenshot
; File I:\Vitalya\mine\NSProjectX\xrCore\_flags.h

; 25   : 	IC 	BOOL	test	(const T mask)						const	{ return BOOL(flags&mask);				}

	mov	eax, DWORD PTR __imp_?psDeviceFlags@@3U?$_flags@I@@A
	test	BYTE PTR [eax], 1
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__screenshot.cpp

; 36   : 	if ((psDeviceFlags.test(rsFullscreen)) == 0) {

	jne	SHORT $LN29@Screenshot

; 37   : 		Log("~ Can't capture screen while in windowed mode...");

	push	OFFSET ??_C@_0DB@JJCPJBNI@?$HO?5Can?8t?5capture?5screen?5while?5in@
	call	DWORD PTR __imp_?Log@@YAXPBD@Z
	add	esp, 4

; 172  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
$LN29@Screenshot:

; 38   : 		return;
; 39   : 	}
; 40   : 
; 41   : 	// Create temp-surface
; 42   : 	IDirect3DSurface9*	pFB;
; 43   : 	D3DLOCKED_RECT		D;
; 44   : 	HRESULT				hr;
; 45   : 	hr					= HW.pDevice->CreateOffscreenPlainSurface(Device.dwWidth,Device.dwHeight,D3DFMT_A8R8G8B8,D3DPOOL_SYSTEMMEM,&pFB,NULL);

	mov	eax, DWORD PTR __imp_?HW@@3VCHW@@A
	lea	esi, DWORD PTR _pFB$[esp+2184]
	push	0
	push	esi
	push	2
	mov	eax, DWORD PTR [eax+8]
	push	21					; 00000015H
	push	DWORD PTR [edx+260]
	push	DWORD PTR [edx+256]
	mov	ecx, DWORD PTR [eax]
	push	eax
	call	DWORD PTR [ecx+144]

; 46   : 	if(hr!=D3D_OK)		return;

	test	eax, eax
	jne	$LN62@Screenshot

; 47   : 
; 48   : 	hr					= HW.pDevice->GetFrontBufferData(0,pFB);

	mov	eax, DWORD PTR __imp_?HW@@3VCHW@@A
	push	DWORD PTR _pFB$[esp+2184]
	push	0
	mov	eax, DWORD PTR [eax+8]
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+132]

; 49   : 	if(hr!=D3D_OK)		return;

	test	eax, eax
	jne	$LN62@Screenshot

; 50   : 
; 51   : 	hr					= pFB->LockRect(&D,0,D3DLOCK_NOSYSLOCK);

	mov	eax, DWORD PTR _pFB$[esp+2184]
	lea	edx, DWORD PTR _D$[esp+2184]
	push	2048					; 00000800H
	push	0
	push	edx
	mov	ecx, DWORD PTR [eax]
	push	eax
	call	DWORD PTR [ecx+52]

; 52   : 	if(hr!=D3D_OK)		return;

	test	eax, eax
	jne	$LN62@Screenshot

; 53   : 
; 54   : 	// Image processing (gamma-correct)
; 55   : 	u32* pPixel		= (u32*)D.pBits;
; 56   : 	u32* pEnd		= pPixel+(Device.dwWidth*Device.dwHeight);

	mov	ecx, DWORD PTR __imp_?Device@@3VCRenderDevice@@A
	mov	esi, DWORD PTR _D$[esp+2188]
	mov	eax, DWORD PTR [ecx+260]
	imul	eax, DWORD PTR [ecx+256]

; 57   : 	D3DGAMMARAMP	G;
; 58   : 	Device.Gamma.GenLUT	(G);

	add	ecx, 440				; 000001b8H
	lea	edi, DWORD PTR [esi+eax*4]
	lea	eax, DWORD PTR _G$[esp+2184]
	push	eax
	call	DWORD PTR __imp_?GenLUT@CGammaControl@@QAEXAAU_D3DGAMMARAMP@@@Z
	xor	ecx, ecx
	npad	11
$LL4@Screenshot:

; 59   : 	for (int i=0; i<256; i++) {
; 60   : 		G.red	[i]	/= 256;

	movzx	eax, BYTE PTR _G$[esp+ecx*2+2185]
	mov	WORD PTR _G$[esp+ecx*2+2184], ax

; 61   : 		G.green	[i]	/= 256;

	movzx	eax, BYTE PTR _G$[esp+ecx*2+2697]
	mov	WORD PTR _G$[esp+ecx*2+2696], ax

; 62   : 		G.blue	[i]	/= 256;

	movzx	eax, BYTE PTR _G$[esp+ecx*2+3209]
	mov	WORD PTR _G$[esp+ecx*2+3208], ax
	inc	ecx
	cmp	ecx, 256				; 00000100H
	jl	SHORT $LL4@Screenshot

; 63   : 	}
; 64   : 	for (;pPixel!=pEnd; pPixel++)	{

	cmp	esi, edi
	je	SHORT $LN6@Screenshot
	npad	3
$LL7@Screenshot:

; 65   : 		u32 p = *pPixel;

	mov	ecx, DWORD PTR [esi]
; File I:\Vitalya\mine\NSProjectX\xrCore\_color.h

; 17   : ICF	u32	color_get_R	(u32 rgba)						{	return (((rgba) >> 16) & 0xff);	}

	mov	eax, ecx
	shr	eax, 16					; 00000010H
	movzx	eax, al

; 5    : ICF u32	color_argb	(u32 a, u32 r, u32 g, u32 b)	{	return ((a&0xff)<<24)|((r&0xff)<<16)|((g&0xff)<<8)|(b&0xff);	}

	movzx	edx, WORD PTR _G$[esp+eax*2+2184]

; 18   : ICF	u32	color_get_G	(u32 rgba)						{	return (((rgba) >> 8) & 0xff);	}

	mov	eax, ecx
	shr	eax, 8

; 5    : ICF u32	color_argb	(u32 a, u32 r, u32 g, u32 b)	{	return ((a&0xff)<<24)|((r&0xff)<<16)|((g&0xff)<<8)|(b&0xff);	}

	or	edx, -256				; ffffff00H

; 18   : ICF	u32	color_get_G	(u32 rgba)						{	return (((rgba) >> 8) & 0xff);	}

	movzx	eax, al

; 5    : ICF u32	color_argb	(u32 a, u32 r, u32 g, u32 b)	{	return ((a&0xff)<<24)|((r&0xff)<<16)|((g&0xff)<<8)|(b&0xff);	}

	shl	edx, 8
	movzx	eax, WORD PTR _G$[esp+eax*2+2696]
	movzx	eax, al
	or	edx, eax

; 19   : ICF	u32	color_get_B	(u32 rgba)						{	return ((rgba) & 0xff);			}

	movzx	eax, cl

; 5    : ICF u32	color_argb	(u32 a, u32 r, u32 g, u32 b)	{	return ((a&0xff)<<24)|((r&0xff)<<16)|((g&0xff)<<8)|(b&0xff);	}

	shl	edx, 8
	movzx	eax, WORD PTR _G$[esp+eax*2+3208]
	movzx	eax, al
	or	edx, eax
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__screenshot.cpp

; 66   : 		*pPixel = color_xrgb	(

	mov	DWORD PTR [esi], edx
	add	esi, 4
	cmp	esi, edi
	jne	SHORT $LL7@Screenshot
$LN6@Screenshot:

; 67   : 			G.red	[color_get_R(p)],
; 68   : 			G.green	[color_get_G(p)],
; 69   : 			G.blue	[color_get_B(p)]
; 70   : 			);
; 71   : 	}
; 72   : 	hr					= pFB->UnlockRect();

	mov	eax, DWORD PTR _pFB$[esp+2184]
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+56]

; 73   : 	if(hr!=D3D_OK)		goto _end_;

	test	eax, eax
	jne	$_end_$121

; 74   : 
; 75   : 	// Save
; 76   : 	switch (mode)	{

	mov	eax, DWORD PTR _mode$[ebp]
	cmp	eax, 3
	ja	$_end_$121
	jmp	DWORD PTR $LN118@Screenshot[eax*4]
$LN35@Screenshot:

; 77   : 		case IRender_interface::SM_FOR_GAMESAVE:
; 78   : 			{
; 79   : 				// texture
; 80   : 				IDirect3DTexture9*	texture	= NULL;
; 81   : 				hr					= D3DXCreateTexture(HW.pDevice,GAMESAVE_SIZE,GAMESAVE_SIZE,1,0,D3DFMT_DXT1,D3DPOOL_SCRATCH,&texture);

	lea	eax, DWORD PTR _texture$8[esp+2184]
	mov	DWORD PTR _texture$8[esp+2184], ebx
	push	eax
	mov	eax, DWORD PTR __imp_?HW@@3VCHW@@A
	push	3
	push	827611204				; 31545844H
	push	0
	push	1
	push	128					; 00000080H
	push	128					; 00000080H
	push	DWORD PTR [eax+8]
	call	DWORD PTR __imp__D3DXCreateTexture@32

; 82   : 				if(hr!=D3D_OK)		goto _end_;

	test	eax, eax
	jne	$_end_$121

; 83   : 				if(NULL==texture)	goto _end_;

	mov	ecx, DWORD PTR _texture$8[esp+2184]
	test	ecx, ecx
	je	$_end_$121

; 84   : 
; 85   : 				// resize&convert to surface
; 86   : 				IDirect3DSurface9*	surface = 0;
; 87   : 				hr					= texture->GetSurfaceLevel(0,&surface);

	lea	edx, DWORD PTR _surface$12[esp+2184]
	mov	DWORD PTR _surface$12[esp+2184], ebx
	mov	eax, DWORD PTR [ecx]
	push	edx
	push	0
	push	ecx
	call	DWORD PTR [eax+72]

; 88   : 				if(hr!=D3D_OK)		goto _end_;

	test	eax, eax
	jne	$_end_$121

; 89   : 				VERIFY				(surface);
; 90   : 				hr					= D3DXLoadSurfaceFromSurface(surface,0,0,pFB,0,0,D3DX_DEFAULT,0);

	push	eax
	push	-1
	push	eax
	push	eax
	push	DWORD PTR _pFB$[esp+2200]
	push	eax
	push	eax
	push	DWORD PTR _surface$12[esp+2212]
	call	DWORD PTR __imp__D3DXLoadSurfaceFromSurface@32

; 91   : 				_RELEASE			(surface);

	mov	edx, DWORD PTR _surface$12[esp+2184]
	mov	esi, eax
	test	edx, edx
	je	SHORT $LN42@Screenshot
	mov	ecx, DWORD PTR [edx]
	push	edx
	call	DWORD PTR [ecx+8]
	mov	DWORD PTR _surface$12[esp+2184], ebx
$LN42@Screenshot:

; 92   : 				if(hr!=D3D_OK)		goto _end_;

	test	esi, esi
	jne	$_end_$121

; 93   : 
; 94   : 				// save (logical & physical)
; 95   : 				ID3DXBuffer*		saved	= 0;
; 96   : 				hr					= D3DXSaveTextureToFileInMemory (&saved,D3DXIFF_DDS,texture,0);

	push	esi
	push	DWORD PTR _texture$8[esp+2188]
	lea	eax, DWORD PTR _saved$10[esp+2192]
	mov	DWORD PTR _saved$10[esp+2192], ebx
	push	4
	push	eax
	call	DWORD PTR __imp__D3DXSaveTextureToFileInMemory@16

; 97   : 				if(hr!=D3D_OK)		goto _end_;

	test	eax, eax
	jne	$_end_$121

; 99   : 				IWriter*			fs		= FS.w_open	(name); 

	mov	eax, DWORD PTR __imp_?xr_FS@@3PAVCLocatorAPI@@A
; File I:\Vitalya\mine\NSProjectX\xrCore\LocatorAPI.h

; 122  : 	IC IWriter*					w_open			(LPCSTR N){return w_open(0,N);}

	push	DWORD PTR _name$[ebp]
	push	esi
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR __imp_?w_open@CLocatorAPI@@QAEPAVIWriter@@PBD0@Z
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__screenshot.cpp

; 99   : 				IWriter*			fs		= FS.w_open	(name); 

	mov	DWORD PTR _fs$5[esp+2184], eax

; 100  : 				if (fs)				{

	test	eax, eax
	je	SHORT $LN47@Screenshot

; 101  : 					fs->w				(saved->GetBufferPointer(),saved->GetBufferSize());

	mov	esi, DWORD PTR [eax]
	mov	eax, DWORD PTR _saved$10[esp+2184]
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+16]
	push	eax
	mov	eax, DWORD PTR _saved$10[esp+2188]
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+12]
	mov	ecx, DWORD PTR _fs$5[esp+2188]
	push	eax
	call	DWORD PTR [esi+12]

; 102  : 					FS.w_close			(fs);

	mov	ecx, DWORD PTR __imp_?xr_FS@@3PAVCLocatorAPI@@A
	lea	eax, DWORD PTR _fs$5[esp+2184]
	push	eax
	mov	ecx, DWORD PTR [ecx]
	call	DWORD PTR __imp_?w_close@CLocatorAPI@@QAEXAAPAVIWriter@@@Z
$LN47@Screenshot:

; 103  : 				}
; 104  : 				_RELEASE			(saved);

	mov	ecx, DWORD PTR _saved$10[esp+2184]
	test	ecx, ecx
	je	SHORT $LN48@Screenshot
	mov	eax, DWORD PTR [ecx]
	push	ecx
	call	DWORD PTR [eax+8]
	mov	DWORD PTR _saved$10[esp+2184], ebx
$LN48@Screenshot:

; 166  : 			}
; 167  : 			break;
; 168  : 	}
; 169  : 
; 170  : _end_:
; 171  : 	_RELEASE		(pFB);

	mov	ecx, DWORD PTR _texture$8[esp+2184]
	test	ecx, ecx
	je	$_end_$121
	mov	eax, DWORD PTR [ecx]
	push	ecx
	call	DWORD PTR [eax+8]
	jmp	$_end_$121
$LN50@Screenshot:

; 114  : 				sprintf_s			(buf,sizeof(buf),"ss_%s_%s_(%s).png",Core.UserName,timestamp(t_stemp),(g_pGameLevel)?g_pGameLevel->name().c_str():"mainmenu");

	mov	eax, DWORD PTR __imp_?g_pGameLevel@@3PAVIGame_Level@@A
	mov	ecx, DWORD PTR [eax]
	test	ecx, ecx
	je	SHORT $LN64@Screenshot
	mov	eax, DWORD PTR [ecx]
	lea	edx, DWORD PTR $T4[esp+2184]
	push	edx
	call	DWORD PTR [eax+8]
	mov	ebx, 1
; File I:\Vitalya\mine\NSProjectX\xrCore\xrstring.h

; 68   : 	str_c				c_str		() const						{	return p_?p_->value:0;							}

	mov	ecx, DWORD PTR [eax]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__screenshot.cpp

; 114  : 				sprintf_s			(buf,sizeof(buf),"ss_%s_%s_(%s).png",Core.UserName,timestamp(t_stemp),(g_pGameLevel)?g_pGameLevel->name().c_str():"mainmenu");

	lea	eax, DWORD PTR [ecx+12]
	neg	ecx
	sbb	ecx, ecx
	and	ecx, eax
	jmp	SHORT $LN65@Screenshot
$LN64@Screenshot:
	mov	ecx, OFFSET ??_C@_08PJBAJFMP@mainmenu@
$LN65@Screenshot:
	push	ecx
	lea	eax, DWORD PTR _t_stemp$18[esp+2188]
	push	eax
	call	DWORD PTR __imp_?timestamp@@YAPADAAY0EA@D@Z
	add	esp, 4
	push	eax
	mov	eax, DWORD PTR __imp_?Core@@3VxrCore@@A
	add	eax, 1104				; 00000450H
	push	eax
	push	OFFSET ??_C@_0BC@GOMLAKFD@ss_?$CFs_?$CFs_?$CI?$CFs?$CJ?4png@
	lea	eax, DWORD PTR _buf$20[esp+2200]
	push	520					; 00000208H
	push	eax
	call	_sprintf_s
	add	esp, 24					; 00000018H
	test	bl, 1
	je	SHORT $LN70@Screenshot
	lea	ecx, DWORD PTR $T4[esp+2184]
	and	ebx, -2					; fffffffeH
	call	??1shared_str@@QAE@XZ			; shared_str::~shared_str
$LN70@Screenshot:

; 115  : 				ID3DXBuffer*		saved	= 0;
; 116  : 				CHK_DX				(D3DXSaveSurfaceToFileInMemory (&saved, D3DXIFF_PNG,pFB,0,0));

	push	0
	push	0
	push	DWORD PTR _pFB$[esp+2192]
	lea	eax, DWORD PTR _saved$9[esp+2196]
	mov	DWORD PTR _saved$9[esp+2196], 0
	push	3
	push	eax
	call	DWORD PTR __imp__D3DXSaveSurfaceToFileInMemory@20

; 117  : 				IWriter*		fs	= FS.w_open	("$screenshots$",buf); R_ASSERT(fs);

	mov	ecx, DWORD PTR __imp_?xr_FS@@3PAVCLocatorAPI@@A
	lea	eax, DWORD PTR _buf$20[esp+2184]
	push	eax
	push	OFFSET ??_C@_0O@IBCMCKFE@$screenshots$@
	mov	ecx, DWORD PTR [ecx]
	call	DWORD PTR __imp_?w_open@CLocatorAPI@@QAEPAVIWriter@@PBD0@Z
	cmp	BYTE PTR ?ignore_always@?DE@??Screenshot@CRender@@UAEXW4ScreenshotMode@IRender_interface@@PBD@Z@4_NA, 0
	mov	edi, DWORD PTR __imp_?fail@xrDebug@@QAEXPBD0H0AA_N@Z
	mov	DWORD PTR _fs$11[esp+2184], eax
	jne	SHORT $LN13@Screenshot
	test	eax, eax
	jne	SHORT $LN13@Screenshot
	mov	ecx, DWORD PTR __imp_?Debug@@3VxrDebug@@A
	push	OFFSET ?ignore_always@?DE@??Screenshot@CRender@@UAEXW4ScreenshotMode@IRender_interface@@PBD@Z@4_NA
	push	OFFSET ??_C@_0BE@BLBPHPBA@CRender?3?3Screenshot@
	push	117					; 00000075H
	push	OFFSET ??_C@_0DN@GJLDAKLL@I?3?2Vitalya?2mine?2NSProjectX?2laye@
	push	OFFSET ??_C@_02EIPGLLEK@fs@
	call	edi
	mov	eax, DWORD PTR _fs$11[esp+2184]
$LN13@Screenshot:

; 118  : 				fs->w				(saved->GetBufferPointer(),saved->GetBufferSize());

	mov	esi, DWORD PTR [eax]
	mov	eax, DWORD PTR _saved$9[esp+2184]
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+16]
	push	eax
	mov	eax, DWORD PTR _saved$9[esp+2188]
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+12]
	mov	ecx, DWORD PTR _fs$11[esp+2188]
	push	eax
	call	DWORD PTR [esi+12]

; 119  : 				FS.w_close			(fs);

	mov	ecx, DWORD PTR __imp_?xr_FS@@3PAVCLocatorAPI@@A
	lea	eax, DWORD PTR _fs$11[esp+2184]
	push	eax
	mov	ecx, DWORD PTR [ecx]
	call	DWORD PTR __imp_?w_close@CLocatorAPI@@QAEXAAPAVIWriter@@@Z

; 120  : 				_RELEASE			(saved);

	mov	ecx, DWORD PTR _saved$9[esp+2184]
	test	ecx, ecx
	je	SHORT $LN52@Screenshot
	mov	eax, DWORD PTR [ecx]
	push	ecx
	call	DWORD PTR [eax+8]
	mov	DWORD PTR _saved$9[esp+2184], 0
$LN52@Screenshot:

; 122  : 				if (strstr(Core.Params, "-ss_jpg")) {

	mov	eax, DWORD PTR __imp_?Core@@3VxrCore@@A
	add	eax, 1232				; 000004d0H
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\string.h

; 520  :         return const_cast<char*>(strstr(static_cast<char const*>(_String), _SubString));

	push	OFFSET ??_C@_07DIANDIIF@?9ss_jpg@
	push	eax
	call	DWORD PTR __imp__strstr
	add	esp, 8
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__screenshot.cpp

; 122  : 				if (strstr(Core.Params, "-ss_jpg")) {

	test	eax, eax
	je	$LN55@Screenshot

; 123  : 					sprintf_s(buf, sizeof(buf), "ssq_%s_%s_(%s).jpg", Core.UserName, timestamp(t_stemp), (g_pGameLevel) ? g_pGameLevel->name().c_str() : "mainmenu");

	mov	eax, DWORD PTR __imp_?g_pGameLevel@@3PAVIGame_Level@@A
	mov	ecx, DWORD PTR [eax]
	test	ecx, ecx
	je	SHORT $LN66@Screenshot
	mov	eax, DWORD PTR [ecx]
	lea	edx, DWORD PTR $T15[esp+2184]
	push	edx
	or	ebx, 2
	call	DWORD PTR [eax+8]
; File I:\Vitalya\mine\NSProjectX\xrCore\xrstring.h

; 68   : 	str_c				c_str		() const						{	return p_?p_->value:0;							}

	mov	ecx, DWORD PTR [eax]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__screenshot.cpp

; 123  : 					sprintf_s(buf, sizeof(buf), "ssq_%s_%s_(%s).jpg", Core.UserName, timestamp(t_stemp), (g_pGameLevel) ? g_pGameLevel->name().c_str() : "mainmenu");

	lea	eax, DWORD PTR [ecx+12]
	neg	ecx
	sbb	ecx, ecx
	and	ecx, eax
	jmp	SHORT $LN67@Screenshot
$LN66@Screenshot:
	mov	ecx, OFFSET ??_C@_08PJBAJFMP@mainmenu@
$LN67@Screenshot:
	push	ecx
	lea	eax, DWORD PTR _t_stemp$18[esp+2188]
	push	eax
	call	DWORD PTR __imp_?timestamp@@YAPADAAY0EA@D@Z
	add	esp, 4
	push	eax
	mov	eax, DWORD PTR __imp_?Core@@3VxrCore@@A
	add	eax, 1104				; 00000450H
	push	eax
	push	OFFSET ??_C@_0BD@PFGAICKI@ssq_?$CFs_?$CFs_?$CI?$CFs?$CJ?4jpg@
	lea	eax, DWORD PTR _buf$20[esp+2200]
	push	520					; 00000208H
	push	eax
	call	_sprintf_s
	add	esp, 24					; 00000018H
	test	bl, 2
	je	SHORT $LN71@Screenshot
	lea	ecx, DWORD PTR $T15[esp+2184]
	and	ebx, -3					; fffffffdH
	call	??1shared_str@@QAE@XZ			; shared_str::~shared_str
$LN71@Screenshot:

; 124  : 					ID3DXBuffer* saved = 0;
; 125  : 					CHK_DX(D3DXSaveSurfaceToFileInMemory(&saved, D3DXIFF_JPG, pFB, 0, 0));

	push	0
	push	0
	push	DWORD PTR _pFB$[esp+2192]
	lea	eax, DWORD PTR _saved$7[esp+2196]
	mov	DWORD PTR _saved$7[esp+2196], 0
	push	1
	push	eax
	call	DWORD PTR __imp__D3DXSaveSurfaceToFileInMemory@20

; 126  : 					IWriter* fs = FS.w_open("$screenshots$", buf); R_ASSERT(fs);

	mov	ecx, DWORD PTR __imp_?xr_FS@@3PAVCLocatorAPI@@A
	lea	eax, DWORD PTR _buf$20[esp+2184]
	push	eax
	push	OFFSET ??_C@_0O@IBCMCKFE@$screenshots$@
	mov	ecx, DWORD PTR [ecx]
	call	DWORD PTR __imp_?w_open@CLocatorAPI@@QAEPAVIWriter@@PBD0@Z
	cmp	BYTE PTR ?ignore_always@?DP@??Screenshot@CRender@@UAEXW4ScreenshotMode@IRender_interface@@PBD@Z@4_NA, 0
	mov	DWORD PTR _fs$3[esp+2184], eax
	jne	SHORT $LN16@Screenshot
	test	eax, eax
	jne	SHORT $LN16@Screenshot
	mov	ecx, DWORD PTR __imp_?Debug@@3VxrDebug@@A
	push	OFFSET ?ignore_always@?DP@??Screenshot@CRender@@UAEXW4ScreenshotMode@IRender_interface@@PBD@Z@4_NA
	push	OFFSET ??_C@_0BE@BLBPHPBA@CRender?3?3Screenshot@
	push	126					; 0000007eH
	push	OFFSET ??_C@_0DN@GJLDAKLL@I?3?2Vitalya?2mine?2NSProjectX?2laye@
	push	OFFSET ??_C@_02EIPGLLEK@fs@
	call	edi
	mov	eax, DWORD PTR _fs$3[esp+2184]
$LN16@Screenshot:

; 127  : 					fs->w(saved->GetBufferPointer(), saved->GetBufferSize());

	mov	esi, DWORD PTR [eax]
	mov	eax, DWORD PTR _saved$7[esp+2184]
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+16]
	push	eax
	mov	eax, DWORD PTR _saved$7[esp+2188]
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+12]
	mov	ecx, DWORD PTR _fs$3[esp+2188]
	push	eax
	call	DWORD PTR [esi+12]

; 128  : 					FS.w_close(fs);

	mov	ecx, DWORD PTR __imp_?xr_FS@@3PAVCLocatorAPI@@A
	lea	eax, DWORD PTR _fs$3[esp+2184]
	push	eax
	mov	ecx, DWORD PTR [ecx]
	call	DWORD PTR __imp_?w_close@CLocatorAPI@@QAEXAAPAVIWriter@@@Z

; 129  : 					_RELEASE(saved);

	mov	ecx, DWORD PTR _saved$7[esp+2184]
	test	ecx, ecx
	je	SHORT $LN55@Screenshot
	mov	eax, DWORD PTR [ecx]
	push	ecx
	call	DWORD PTR [eax+8]
$LN55@Screenshot:

; 132  : 				if (strstr(Core.Params,"-ss_tga"))	{ // hq

	mov	eax, DWORD PTR __imp_?Core@@3VxrCore@@A
	add	eax, 1232				; 000004d0H
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\string.h

; 520  :         return const_cast<char*>(strstr(static_cast<char const*>(_String), _SubString));

	push	OFFSET ??_C@_07MHPIAKFK@?9ss_tga@
	push	eax
	call	DWORD PTR __imp__strstr
	add	esp, 8
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__screenshot.cpp

; 132  : 				if (strstr(Core.Params,"-ss_tga"))	{ // hq

	test	eax, eax
	je	$_end_$121

; 133  : 					sprintf_s			(buf,sizeof(buf),"ssq_%s_%s_(%s).tga",Core.UserName,timestamp(t_stemp),(g_pGameLevel)?g_pGameLevel->name().c_str():"mainmenu");

	mov	eax, DWORD PTR __imp_?g_pGameLevel@@3PAVIGame_Level@@A
	mov	ecx, DWORD PTR [eax]
	test	ecx, ecx
	je	SHORT $LN68@Screenshot
	mov	eax, DWORD PTR [ecx]
	lea	edx, DWORD PTR $T14[esp+2184]
	push	edx
	or	ebx, 4
	call	DWORD PTR [eax+8]
; File I:\Vitalya\mine\NSProjectX\xrCore\xrstring.h

; 68   : 	str_c				c_str		() const						{	return p_?p_->value:0;							}

	mov	ecx, DWORD PTR [eax]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__screenshot.cpp

; 133  : 					sprintf_s			(buf,sizeof(buf),"ssq_%s_%s_(%s).tga",Core.UserName,timestamp(t_stemp),(g_pGameLevel)?g_pGameLevel->name().c_str():"mainmenu");

	lea	eax, DWORD PTR [ecx+12]
	neg	ecx
	sbb	ecx, ecx
	and	ecx, eax
	jmp	SHORT $LN69@Screenshot
$LN68@Screenshot:
	mov	ecx, OFFSET ??_C@_08PJBAJFMP@mainmenu@
$LN69@Screenshot:
	push	ecx
	lea	eax, DWORD PTR _t_stemp$18[esp+2188]
	push	eax
	call	DWORD PTR __imp_?timestamp@@YAPADAAY0EA@D@Z
	add	esp, 4
	push	eax
	mov	eax, DWORD PTR __imp_?Core@@3VxrCore@@A
	add	eax, 1104				; 00000450H
	push	eax
	push	OFFSET ??_C@_0BD@KJFLAHH@ssq_?$CFs_?$CFs_?$CI?$CFs?$CJ?4tga@
	lea	eax, DWORD PTR _buf$20[esp+2200]
	push	520					; 00000208H
	push	eax
	call	_sprintf_s
	add	esp, 24					; 00000018H
	test	bl, 4
	je	SHORT $LN72@Screenshot
	lea	ecx, DWORD PTR $T14[esp+2184]
	call	??1shared_str@@QAE@XZ			; shared_str::~shared_str
$LN72@Screenshot:

; 134  : 					ID3DXBuffer*		saved	= 0;
; 135  : 					CHK_DX				(D3DXSaveSurfaceToFileInMemory (&saved,D3DXIFF_TGA,pFB,0,0));

	push	0
	push	0
	push	DWORD PTR _pFB$[esp+2192]
	lea	eax, DWORD PTR _saved$6[esp+2196]
	mov	DWORD PTR _saved$6[esp+2196], 0
	push	2
	push	eax
	call	DWORD PTR __imp__D3DXSaveSurfaceToFileInMemory@20

; 136  : 					IWriter*		fs	= FS.w_open	("$screenshots$",buf); R_ASSERT(fs);

	mov	ecx, DWORD PTR __imp_?xr_FS@@3PAVCLocatorAPI@@A
	lea	eax, DWORD PTR _buf$20[esp+2184]
	push	eax
	push	OFFSET ??_C@_0O@IBCMCKFE@$screenshots$@
	mov	ecx, DWORD PTR [ecx]
	call	DWORD PTR __imp_?w_open@CLocatorAPI@@QAEPAVIWriter@@PBD0@Z
	cmp	BYTE PTR ?ignore_always@?EK@??Screenshot@CRender@@UAEXW4ScreenshotMode@IRender_interface@@PBD@Z@4_NA, 0
	mov	DWORD PTR _fs$2[esp+2184], eax
	jne	SHORT $LN19@Screenshot
	test	eax, eax
	jne	SHORT $LN19@Screenshot
	mov	ecx, DWORD PTR __imp_?Debug@@3VxrDebug@@A
	push	OFFSET ?ignore_always@?EK@??Screenshot@CRender@@UAEXW4ScreenshotMode@IRender_interface@@PBD@Z@4_NA
	push	OFFSET ??_C@_0BE@BLBPHPBA@CRender?3?3Screenshot@
	push	136					; 00000088H
	push	OFFSET ??_C@_0DN@GJLDAKLL@I?3?2Vitalya?2mine?2NSProjectX?2laye@
	push	OFFSET ??_C@_02EIPGLLEK@fs@
	call	edi
	mov	eax, DWORD PTR _fs$2[esp+2184]
$LN19@Screenshot:

; 137  : 					fs->w				(saved->GetBufferPointer(),saved->GetBufferSize());

	mov	esi, DWORD PTR [eax]
	mov	eax, DWORD PTR _saved$6[esp+2184]
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+16]
	push	eax
	mov	eax, DWORD PTR _saved$6[esp+2188]
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+12]
	mov	ecx, DWORD PTR _fs$2[esp+2188]
	push	eax
	call	DWORD PTR [esi+12]

; 138  : 					FS.w_close			(fs);

	mov	ecx, DWORD PTR __imp_?xr_FS@@3PAVCLocatorAPI@@A
	lea	eax, DWORD PTR _fs$2[esp+2184]
	push	eax
	mov	ecx, DWORD PTR [ecx]
	call	DWORD PTR __imp_?w_close@CLocatorAPI@@QAEXAAPAVIWriter@@@Z

; 139  : 					_RELEASE			(saved);
; 140  : 				}
; 141  : 			}
; 142  : 			break;

	jmp	$LN48@Screenshot
$LN24@Screenshot:

; 143  : 		case IRender_interface::SM_FOR_LEVELMAP:
; 144  : 		case IRender_interface::SM_FOR_CUBEMAP:
; 145  : 			{
; 146  : 				string64			t_stemp;
; 147  : 				string_path			buf;
; 148  : 				VERIFY				(name);
; 149  : 				strconcat			(sizeof(buf),buf,"ss_",Core.UserName,"_",timestamp(t_stemp),"_#",name);

	push	DWORD PTR _name$[ebp]
	lea	eax, DWORD PTR _t_stemp$17[esp+2188]
	push	OFFSET ??_C@_02NJPHDIAB@_?$CD@
	push	eax
	call	DWORD PTR __imp_?timestamp@@YAPADAAY0EA@D@Z
	add	esp, 4
	push	eax
	mov	eax, DWORD PTR __imp_?Core@@3VxrCore@@A
	push	OFFSET ??_C@_01IDAFKMJL@_@
	add	eax, 1104				; 00000450H
	push	eax
	push	OFFSET ??_C@_03MMKFLIAD@ss_@
	lea	eax, DWORD PTR _buf$19[esp+2208]
	push	eax
	push	520					; 00000208H
	call	DWORD PTR __imp_?strconcat@@YAPADHPADPBD11111@Z

; 150  : 				strcat				(buf,".tga");

	lea	ecx, DWORD PTR _buf$19[esp+2216]
	add	esp, 32					; 00000020H
	dec	ecx
$LL119@Screenshot:
	mov	al, BYTE PTR [ecx+1]
	lea	ecx, DWORD PTR [ecx+1]
	test	al, al
	jne	SHORT $LL119@Screenshot
	mov	eax, DWORD PTR ??_C@_04JCAPCJAP@?4tga@
	mov	DWORD PTR [ecx], eax
	mov	al, BYTE PTR ??_C@_04JCAPCJAP@?4tga@+4
	mov	BYTE PTR [ecx+4], al

; 151  : 				IWriter*		fs	= FS.w_open	("$screenshots$",buf); R_ASSERT(fs);

	lea	eax, DWORD PTR _buf$19[esp+2184]
	mov	ecx, DWORD PTR __imp_?xr_FS@@3PAVCLocatorAPI@@A
	push	eax
	push	OFFSET ??_C@_0O@IBCMCKFE@$screenshots$@
	mov	ecx, DWORD PTR [ecx]
	call	DWORD PTR __imp_?w_open@CLocatorAPI@@QAEPAVIWriter@@PBD0@Z
	mov	DWORD PTR _fs$1[esp+2184], eax
	cmp	BYTE PTR ?ignore_always@?FF@??Screenshot@CRender@@UAEXW4ScreenshotMode@IRender_interface@@PBD@Z@4_NA, bl
	jne	SHORT $LN25@Screenshot
	test	eax, eax
	jne	SHORT $LN25@Screenshot
	mov	ecx, DWORD PTR __imp_?Debug@@3VxrDebug@@A
	push	OFFSET ?ignore_always@?FF@??Screenshot@CRender@@UAEXW4ScreenshotMode@IRender_interface@@PBD@Z@4_NA
	push	OFFSET ??_C@_0BE@BLBPHPBA@CRender?3?3Screenshot@
	push	151					; 00000097H
	push	OFFSET ??_C@_0DN@GJLDAKLL@I?3?2Vitalya?2mine?2NSProjectX?2laye@
	push	OFFSET ??_C@_02EIPGLLEK@fs@
	call	DWORD PTR __imp_?fail@xrDebug@@QAEXPBD0H0AA_N@Z
$LN25@Screenshot:

; 154  : 
; 155  : 				// save
; 156  : 				u32* data			= (u32*)xr_malloc(Device.dwHeight*Device.dwHeight*4);

	mov	eax, DWORD PTR __imp_?Device@@3VCRenderDevice@@A
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 110  : 	IC void*	xr_malloc	(size_t size)			{	return	Memory.mem_alloc(size);					}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__screenshot.cpp

; 153  : 				p.format			= IMG_24B;

	mov	DWORD PTR _p$16[esp+2184], ebx

; 154  : 
; 155  : 				// save
; 156  : 				u32* data			= (u32*)xr_malloc(Device.dwHeight*Device.dwHeight*4);

	mov	eax, DWORD PTR [eax+260]
	imul	eax, eax
	shl	eax, 2
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 110  : 	IC void*	xr_malloc	(size_t size)			{	return	Memory.mem_alloc(size);					}

	push	eax
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__screenshot.cpp

; 157  : 				imf_Process			(data,Device.dwHeight,Device.dwHeight,(u32*)D.pBits,Device.dwWidth,Device.dwHeight,imf_lanczos3);

	mov	ecx, DWORD PTR __imp_?Device@@3VCRenderDevice@@A
	mov	esi, eax
	push	5
	mov	edx, DWORD PTR [ecx+260]
	push	edx
	push	DWORD PTR [ecx+256]
	push	DWORD PTR _D$[esp+2200]
	push	edx
	push	edx
	push	esi
	call	DWORD PTR __imp_?imf_Process@@YAXPAIII0IIW4EIMF_Type@@@Z

; 158  : 				p.scanlenght		= Device.dwHeight*4;

	mov	eax, DWORD PTR __imp_?Device@@3VCRenderDevice@@A
	add	esp, 28					; 0000001cH

; 159  : 				p.width				= Device.dwHeight;
; 160  : 				p.height			= Device.dwHeight;
; 161  : 				p.data				= data;

	mov	DWORD PTR _p$16[esp+2200], esi
	mov	ecx, DWORD PTR [eax+260]

; 162  : 				p.maketga			(*fs);

	push	DWORD PTR _fs$1[esp+2184]
	mov	DWORD PTR _p$16[esp+2196], ecx
	mov	DWORD PTR _p$16[esp+2200], ecx
	lea	eax, DWORD PTR [ecx*4]
	lea	ecx, DWORD PTR _p$16[esp+2188]
	mov	DWORD PTR _p$16[esp+2192], eax
	call	?maketga@TGAdesc@@QAEXAAVIWriter@@@Z	; TGAdesc::maketga
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	test	esi, esi
	je	SHORT $LN108@Screenshot
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	esi
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN108@Screenshot:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__screenshot.cpp

; 165  : 				FS.w_close			(fs);

	mov	ecx, DWORD PTR __imp_?xr_FS@@3PAVCLocatorAPI@@A
	lea	eax, DWORD PTR _fs$1[esp+2184]
	push	eax
	mov	ecx, DWORD PTR [ecx]
	call	DWORD PTR __imp_?w_close@CLocatorAPI@@QAEXAAPAVIWriter@@@Z
$_end_$121:

; 166  : 			}
; 167  : 			break;
; 168  : 	}
; 169  : 
; 170  : _end_:
; 171  : 	_RELEASE		(pFB);

	mov	ecx, DWORD PTR _pFB$[esp+2184]
	test	ecx, ecx
	je	SHORT $LN62@Screenshot
	mov	eax, DWORD PTR [ecx]
	push	ecx
	call	DWORD PTR [eax+8]
$LN62@Screenshot:

; 172  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
	npad	3
$LN118@Screenshot:
	DD	$LN50@Screenshot
	DD	$LN24@Screenshot
	DD	$LN35@Screenshot
	DD	$LN24@Screenshot
?Screenshot@CRender@@UAEXW4ScreenshotMode@IRender_interface@@PBD@Z ENDP ; CRender::Screenshot
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
;	COMDAT ?xr_malloc@@YAPAXI@Z
_TEXT	SEGMENT
?xr_malloc@@YAPAXI@Z PROC				; xr_malloc, COMDAT
; _size$ = ecx

; 110  : 	IC void*	xr_malloc	(size_t size)			{	return	Memory.mem_alloc(size);					}

	push	ecx
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
	ret	0
?xr_malloc@@YAPAXI@Z ENDP				; xr_malloc
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\string.h
;	COMDAT ?strstr@@YAPADQADQBD@Z
_TEXT	SEGMENT
?strstr@@YAPADQADQBD@Z PROC				; strstr, COMDAT
; __String$ = ecx
; __SubString$ = edx

; 520  :         return const_cast<char*>(strstr(static_cast<char const*>(_String), _SubString));

	push	edx
	push	ecx
	call	DWORD PTR __imp__strstr
	add	esp, 8

; 521  :     }

	ret	0
?strstr@@YAPADQADQBD@Z ENDP				; strstr
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\stdio.h
;	COMDAT __vsprintf_s_l
_TEXT	SEGMENT
__Format$ = 8						; size = 4
__Locale$dead$ = 12					; size = 4
__ArgList$ = 16						; size = 4
__vsprintf_s_l PROC					; COMDAT
; __Buffer$ = ecx
; __BufferCount$ = edx

; 1490 :     {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H

; 1491 :         int const _Result = __stdio_common_vsprintf_s(

	push	DWORD PTR __ArgList$[ebp]
	push	0
	push	DWORD PTR __Format$[ebp]
	push	edx
	push	ecx
	call	___local_stdio_printf_options
	push	DWORD PTR [eax+4]
	push	DWORD PTR [eax]
	call	DWORD PTR __imp____stdio_common_vsprintf_s

; 1492 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS,
; 1493 :             _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1494 : 
; 1495 :         return _Result < 0 ? -1 : _Result;

	or	ecx, -1
	add	esp, 28					; 0000001cH
	test	eax, eax
	cmovs	eax, ecx

; 1496 :     }

	mov	esp, ebp
	pop	ebp
	ret	0
__vsprintf_s_l ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\stdio.h
;	COMDAT _sprintf_s
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__BufferCount$ = 12					; size = 4
__Format$ = 16						; size = 4
_sprintf_s PROC						; COMDAT

; 1823 :         {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H

; 1491 :         int const _Result = __stdio_common_vsprintf_s(

	lea	eax, DWORD PTR __Format$[ebp+4]
	push	eax
	push	0
	push	DWORD PTR __Format$[ebp]
	push	DWORD PTR __BufferCount$[ebp]
	push	DWORD PTR __Buffer$[ebp]
	call	___local_stdio_printf_options
	push	DWORD PTR [eax+4]
	push	DWORD PTR [eax]
	call	DWORD PTR __imp____stdio_common_vsprintf_s

; 1492 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS,
; 1493 :             _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1494 : 
; 1495 :         return _Result < 0 ? -1 : _Result;

	or	ecx, -1
	add	esp, 28					; 0000001cH
	test	eax, eax
	cmovs	eax, ecx

; 1824 :             int _Result;
; 1825 :             va_list _ArgList;
; 1826 :             __crt_va_start(_ArgList, _Format);
; 1827 :             _Result = _vsprintf_s_l(_Buffer, _BufferCount, _Format, NULL, _ArgList);
; 1828 :             __crt_va_end(_ArgList);
; 1829 :             return _Result;
; 1830 :         }

	mov	esp, ebp
	pop	ebp
	ret	0
_sprintf_s ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_color.h
;	COMDAT ?color_get_R@@YAII@Z
_TEXT	SEGMENT
?color_get_R@@YAII@Z PROC				; color_get_R, COMDAT
; _rgba$ = ecx

; 17   : ICF	u32	color_get_R	(u32 rgba)						{	return (((rgba) >> 16) & 0xff);	}

	shr	ecx, 16					; 00000010H
	movzx	eax, cl
	ret	0
?color_get_R@@YAII@Z ENDP				; color_get_R
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_color.h
;	COMDAT ?color_get_G@@YAII@Z
_TEXT	SEGMENT
?color_get_G@@YAII@Z PROC				; color_get_G, COMDAT
; _rgba$ = ecx

; 18   : ICF	u32	color_get_G	(u32 rgba)						{	return (((rgba) >> 8) & 0xff);	}

	shr	ecx, 8
	movzx	eax, cl
	ret	0
?color_get_G@@YAII@Z ENDP				; color_get_G
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_color.h
;	COMDAT ?color_get_B@@YAII@Z
_TEXT	SEGMENT
?color_get_B@@YAII@Z PROC				; color_get_B, COMDAT
; _rgba$ = ecx

; 19   : ICF	u32	color_get_B	(u32 rgba)						{	return ((rgba) & 0xff);			}

	movzx	eax, cl
	ret	0
?color_get_B@@YAII@Z ENDP				; color_get_B
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_color.h
;	COMDAT ?color_xrgb@@YAIIII@Z
_TEXT	SEGMENT
_b$ = 8							; size = 4
?color_xrgb@@YAIIII@Z PROC				; color_xrgb, COMDAT
; _r$ = ecx
; _g$ = edx

; 5    : ICF u32	color_argb	(u32 a, u32 r, u32 g, u32 b)	{	return ((a&0xff)<<24)|((r&0xff)<<16)|((g&0xff)<<8)|(b&0xff);	}

	or	ecx, -256				; ffffff00H
	movzx	eax, dl
	shl	ecx, 8
	or	ecx, eax
	movzx	eax, BYTE PTR _b$[esp-4]
	shl	ecx, 8
	or	eax, ecx

; 16   : ICF u32	color_xrgb	(u32 r, u32 g, u32 b)			{	return color_argb(0xff,r,g,b);	}

	ret	0
?color_xrgb@@YAIIII@Z ENDP				; color_xrgb
_TEXT	ENDS
END
