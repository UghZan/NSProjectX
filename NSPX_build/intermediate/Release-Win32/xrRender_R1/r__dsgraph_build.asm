; Listing generated by Microsoft (R) Optimizing Compiler Version 19.29.30146.0 

	TITLE	i:\vitalya\mine\nsprojectx\nspx_build\intermediate\release-win32\xrrender_r1\r__dsgraph_build.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	?r_ssaDISCARD@@3MA				; r_ssaDISCARD
PUBLIC	?r_ssaGLOD_start@@3MA				; r_ssaGLOD_start
PUBLIC	?r_ssaGLOD_end@@3MA				; r_ssaGLOD_end
PUBLIC	?r_ssaHZBvsTEX@@3MA				; r_ssaHZBvsTEX
PUBLIC	?r_ssaLOD_B@@3MA				; r_ssaLOD_B
PUBLIC	?r_ssaLOD_A@@3MA				; r_ssaLOD_A
EXTRN	__imp_?testSphere@CFrustum@@QBE?AW4EFC_Visible@@AAU?$_vector3@M@@MAAI@Z:PROC
EXTRN	__imp_?CalculateWallmarks@CKinematics@@QAEXXZ:PROC
?r_ssaDISCARD@@3MA DD 01H DUP (?)			; r_ssaDISCARD
?r_ssaGLOD_start@@3MA DD 01H DUP (?)			; r_ssaGLOD_start
?r_ssaGLOD_end@@3MA DD 01H DUP (?)			; r_ssaGLOD_end
?r_ssaHZBvsTEX@@3MA DD 01H DUP (?)			; r_ssaHZBvsTEX
?r_ssaLOD_B@@3MA DD 01H DUP (?)				; r_ssaLOD_B
?r_ssaLOD_A@@3MA DD 01H DUP (?)				; r_ssaLOD_A
_BSS	ENDS
?_Fake_alloc@std@@3U_Fake_allocator@1@B	ORG $+1		; std::_Fake_alloc
PUBLIC	??D?$resptr_core@UShaderElement@@V?$resptr_base@UShaderElement@@@@@@QBEAAUShaderElement@@XZ ; resptr_core<ShaderElement,resptr_base<ShaderElement> >::operator*
PUBLIC	??D?$resptr_core@USPass@@V?$resptr_base@USPass@@@@@@QBEAAUSPass@@XZ ; resptr_core<SPass,resptr_base<SPass> >::operator*
PUBLIC	??C?$resptr_core@USVS@@V?$resptr_base@USVS@@@@@@QBEPAUSVS@@XZ ; resptr_core<SVS,resptr_base<SVS> >::operator->
PUBLIC	??C?$resptr_core@USPS@@V?$resptr_base@USPS@@@@@@QBEPAUSPS@@XZ ; resptr_core<SPS,resptr_base<SPS> >::operator->
PUBLIC	??C?$resptr_core@USState@@V?$resptr_base@USState@@@@@@QBEPAUSState@@XZ ; resptr_core<SState,resptr_base<SState> >::operator->
PUBLIC	??$_Unfancy@U_MatrixItem@R_dsgraph@@@std@@YAPAU_MatrixItem@R_dsgraph@@PAU12@@Z ; std::_Unfancy<R_dsgraph::_MatrixItem>
PUBLIC	?_Getal@?$vector@U_MatrixItem@R_dsgraph@@V?$doug_lea_alloc@U_MatrixItem@R_dsgraph@@@@@std@@AAEAAV?$doug_lea_alloc@U_MatrixItem@R_dsgraph@@@@XZ ; std::vector<R_dsgraph::_MatrixItem,doug_lea_alloc<R_dsgraph::_MatrixItem> >::_Getal
PUBLIC	?_Get_first@?$_Compressed_pair@V?$doug_lea_alloc@U_MatrixItem@R_dsgraph@@@@V?$_Vector_val@U?$_Simple_types@U_MatrixItem@R_dsgraph@@@std@@@std@@$00@std@@QAEAAV?$doug_lea_alloc@U_MatrixItem@R_dsgraph@@@@XZ ; std::_Compressed_pair<doug_lea_alloc<R_dsgraph::_MatrixItem>,std::_Vector_val<std::_Simple_types<R_dsgraph::_MatrixItem> >,1>::_Get_first
PUBLIC	??$_Unfancy@U_NormalItem@R_dsgraph@@@std@@YAPAU_NormalItem@R_dsgraph@@PAU12@@Z ; std::_Unfancy<R_dsgraph::_NormalItem>
PUBLIC	?_Getal@?$vector@U_NormalItem@R_dsgraph@@V?$doug_lea_alloc@U_NormalItem@R_dsgraph@@@@@std@@AAEAAV?$doug_lea_alloc@U_NormalItem@R_dsgraph@@@@XZ ; std::vector<R_dsgraph::_NormalItem,doug_lea_alloc<R_dsgraph::_NormalItem> >::_Getal
PUBLIC	?_Get_first@?$_Compressed_pair@V?$doug_lea_alloc@U_NormalItem@R_dsgraph@@@@V?$_Vector_val@U?$_Simple_types@U_NormalItem@R_dsgraph@@@std@@@std@@$00@std@@QAEAAV?$doug_lea_alloc@U_NormalItem@R_dsgraph@@@@XZ ; std::_Compressed_pair<doug_lea_alloc<R_dsgraph::_NormalItem>,std::_Vector_val<std::_Simple_types<R_dsgraph::_NormalItem> >,1>::_Get_first
PUBLIC	?alloc@doug_lea_allocator@@SAPAXABI@Z		; doug_lea_allocator::alloc
PUBLIC	??$dealloc@UTNode@?$FixedMAP@MU_LodItem@R_dsgraph@@Udoug_lea_allocator@@@@@doug_lea_allocator@@SAXAAPAUTNode@?$FixedMAP@MU_LodItem@R_dsgraph@@Udoug_lea_allocator@@@@@Z ; doug_lea_allocator::dealloc<FixedMAP<float,R_dsgraph::_LodItem,doug_lea_allocator>::TNode>
PUBLIC	??$dealloc@UTNode@?$FixedMAP@MU_MatrixItemS@R_dsgraph@@Udoug_lea_allocator@@@@@doug_lea_allocator@@SAXAAPAUTNode@?$FixedMAP@MU_MatrixItemS@R_dsgraph@@Udoug_lea_allocator@@@@@Z ; doug_lea_allocator::dealloc<FixedMAP<float,R_dsgraph::_MatrixItemS,doug_lea_allocator>::TNode>
PUBLIC	??$dealloc@UTNode@?$FixedMAP@PAUIDirect3DVertexShader9@@UmapMatrixPS@R_dsgraph@@Udoug_lea_allocator@@@@@doug_lea_allocator@@SAXAAPAUTNode@?$FixedMAP@PAUIDirect3DVertexShader9@@UmapMatrixPS@R_dsgraph@@Udoug_lea_allocator@@@@@Z ; doug_lea_allocator::dealloc<FixedMAP<IDirect3DVertexShader9 *,R_dsgraph::mapMatrixPS,doug_lea_allocator>::TNode>
PUBLIC	??$dealloc@UTNode@?$FixedMAP@PAUIDirect3DPixelShader9@@UmapMatrixCS@R_dsgraph@@Udoug_lea_allocator@@@@@doug_lea_allocator@@SAXAAPAUTNode@?$FixedMAP@PAUIDirect3DPixelShader9@@UmapMatrixCS@R_dsgraph@@Udoug_lea_allocator@@@@@Z ; doug_lea_allocator::dealloc<FixedMAP<IDirect3DPixelShader9 *,R_dsgraph::mapMatrixCS,doug_lea_allocator>::TNode>
PUBLIC	??$dealloc@UTNode@?$FixedMAP@PAVR_constant_table@@UmapMatrixStates@R_dsgraph@@Udoug_lea_allocator@@@@@doug_lea_allocator@@SAXAAPAUTNode@?$FixedMAP@PAVR_constant_table@@UmapMatrixStates@R_dsgraph@@Udoug_lea_allocator@@@@@Z ; doug_lea_allocator::dealloc<FixedMAP<R_constant_table *,R_dsgraph::mapMatrixStates,doug_lea_allocator>::TNode>
PUBLIC	??$dealloc@UTNode@?$FixedMAP@PAUIDirect3DStateBlock9@@UmapMatrixTextures@R_dsgraph@@Udoug_lea_allocator@@@@@doug_lea_allocator@@SAXAAPAUTNode@?$FixedMAP@PAUIDirect3DStateBlock9@@UmapMatrixTextures@R_dsgraph@@Udoug_lea_allocator@@@@@Z ; doug_lea_allocator::dealloc<FixedMAP<IDirect3DStateBlock9 *,R_dsgraph::mapMatrixTextures,doug_lea_allocator>::TNode>
PUBLIC	??$dealloc@UTNode@?$FixedMAP@PAUSTextureList@@UmapMatrixItems@R_dsgraph@@Udoug_lea_allocator@@@@@doug_lea_allocator@@SAXAAPAUTNode@?$FixedMAP@PAUSTextureList@@UmapMatrixItems@R_dsgraph@@Udoug_lea_allocator@@@@@Z ; doug_lea_allocator::dealloc<FixedMAP<STextureList *,R_dsgraph::mapMatrixItems,doug_lea_allocator>::TNode>
PUBLIC	??$dealloc@UTNode@?$FixedMAP@PAUIDirect3DVertexShader9@@UmapNormalPS@R_dsgraph@@Udoug_lea_allocator@@@@@doug_lea_allocator@@SAXAAPAUTNode@?$FixedMAP@PAUIDirect3DVertexShader9@@UmapNormalPS@R_dsgraph@@Udoug_lea_allocator@@@@@Z ; doug_lea_allocator::dealloc<FixedMAP<IDirect3DVertexShader9 *,R_dsgraph::mapNormalPS,doug_lea_allocator>::TNode>
PUBLIC	??$dealloc@UTNode@?$FixedMAP@PAUIDirect3DPixelShader9@@UmapNormalCS@R_dsgraph@@Udoug_lea_allocator@@@@@doug_lea_allocator@@SAXAAPAUTNode@?$FixedMAP@PAUIDirect3DPixelShader9@@UmapNormalCS@R_dsgraph@@Udoug_lea_allocator@@@@@Z ; doug_lea_allocator::dealloc<FixedMAP<IDirect3DPixelShader9 *,R_dsgraph::mapNormalCS,doug_lea_allocator>::TNode>
PUBLIC	??$dealloc@UTNode@?$FixedMAP@PAVR_constant_table@@UmapNormalStates@R_dsgraph@@Udoug_lea_allocator@@@@@doug_lea_allocator@@SAXAAPAUTNode@?$FixedMAP@PAVR_constant_table@@UmapNormalStates@R_dsgraph@@Udoug_lea_allocator@@@@@Z ; doug_lea_allocator::dealloc<FixedMAP<R_constant_table *,R_dsgraph::mapNormalStates,doug_lea_allocator>::TNode>
PUBLIC	??$dealloc@UTNode@?$FixedMAP@PAUIDirect3DStateBlock9@@UmapNormalTextures@R_dsgraph@@Udoug_lea_allocator@@@@@doug_lea_allocator@@SAXAAPAUTNode@?$FixedMAP@PAUIDirect3DStateBlock9@@UmapNormalTextures@R_dsgraph@@Udoug_lea_allocator@@@@@Z ; doug_lea_allocator::dealloc<FixedMAP<IDirect3DStateBlock9 *,R_dsgraph::mapNormalTextures,doug_lea_allocator>::TNode>
PUBLIC	??$dealloc@UTNode@?$FixedMAP@PAUSTextureList@@UmapNormalItems@R_dsgraph@@Udoug_lea_allocator@@@@@doug_lea_allocator@@SAXAAPAUTNode@?$FixedMAP@PAUSTextureList@@UmapNormalItems@R_dsgraph@@Udoug_lea_allocator@@@@@Z ; doug_lea_allocator::dealloc<FixedMAP<STextureList *,R_dsgraph::mapNormalItems,doug_lea_allocator>::TNode>
PUBLIC	?_Destroy@?$vector@U_MatrixItem@R_dsgraph@@V?$doug_lea_alloc@U_MatrixItem@R_dsgraph@@@@@std@@AAEXPAU_MatrixItem@R_dsgraph@@0@Z ; std::vector<R_dsgraph::_MatrixItem,doug_lea_alloc<R_dsgraph::_MatrixItem> >::_Destroy
PUBLIC	??$_Destroy_range@V?$doug_lea_alloc@U_MatrixItem@R_dsgraph@@@@@std@@YAXPAU_MatrixItem@R_dsgraph@@QAU12@AAV?$doug_lea_alloc@U_MatrixItem@R_dsgraph@@@@@Z ; std::_Destroy_range<doug_lea_alloc<R_dsgraph::_MatrixItem> >
PUBLIC	??$destroy@U_MatrixItem@R_dsgraph@@@?$_Normal_allocator_traits@V?$doug_lea_alloc@U_MatrixItem@R_dsgraph@@@@@std@@SAXAAV?$doug_lea_alloc@U_MatrixItem@R_dsgraph@@@@PAU_MatrixItem@R_dsgraph@@@Z ; std::_Normal_allocator_traits<doug_lea_alloc<R_dsgraph::_MatrixItem> >::destroy<R_dsgraph::_MatrixItem>
PUBLIC	?destroy@?$doug_lea_alloc@U_MatrixItem@R_dsgraph@@@@QAEXPAU_MatrixItem@R_dsgraph@@@Z ; doug_lea_alloc<R_dsgraph::_MatrixItem>::destroy
PUBLIC	??$_Destroy_in_place@PAU_MatrixItem@R_dsgraph@@@std@@YAXAAPAU_MatrixItem@R_dsgraph@@@Z ; std::_Destroy_in_place<R_dsgraph::_MatrixItem *>
PUBLIC	?deallocate@?$doug_lea_alloc@U_MatrixItem@R_dsgraph@@@@QBEXPAU_MatrixItem@R_dsgraph@@I@Z ; doug_lea_alloc<R_dsgraph::_MatrixItem>::deallocate
PUBLIC	?_Destroy@?$vector@U_NormalItem@R_dsgraph@@V?$doug_lea_alloc@U_NormalItem@R_dsgraph@@@@@std@@AAEXPAU_NormalItem@R_dsgraph@@0@Z ; std::vector<R_dsgraph::_NormalItem,doug_lea_alloc<R_dsgraph::_NormalItem> >::_Destroy
PUBLIC	??$_Destroy_range@V?$doug_lea_alloc@U_NormalItem@R_dsgraph@@@@@std@@YAXPAU_NormalItem@R_dsgraph@@QAU12@AAV?$doug_lea_alloc@U_NormalItem@R_dsgraph@@@@@Z ; std::_Destroy_range<doug_lea_alloc<R_dsgraph::_NormalItem> >
PUBLIC	??$destroy@U_NormalItem@R_dsgraph@@@?$_Normal_allocator_traits@V?$doug_lea_alloc@U_NormalItem@R_dsgraph@@@@@std@@SAXAAV?$doug_lea_alloc@U_NormalItem@R_dsgraph@@@@PAU_NormalItem@R_dsgraph@@@Z ; std::_Normal_allocator_traits<doug_lea_alloc<R_dsgraph::_NormalItem> >::destroy<R_dsgraph::_NormalItem>
PUBLIC	?destroy@?$doug_lea_alloc@U_NormalItem@R_dsgraph@@@@QAEXPAU_NormalItem@R_dsgraph@@@Z ; doug_lea_alloc<R_dsgraph::_NormalItem>::destroy
PUBLIC	??$_Destroy_in_place@PAU_NormalItem@R_dsgraph@@@std@@YAXAAPAU_NormalItem@R_dsgraph@@@Z ; std::_Destroy_in_place<R_dsgraph::_NormalItem *>
PUBLIC	?deallocate@?$doug_lea_alloc@U_NormalItem@R_dsgraph@@@@QBEXPAU_NormalItem@R_dsgraph@@I@Z ; doug_lea_alloc<R_dsgraph::_NormalItem>::deallocate
PUBLIC	??$construct@U_NormalItem@R_dsgraph@@U12@@?$_Normal_allocator_traits@V?$doug_lea_alloc@U_NormalItem@R_dsgraph@@@@@std@@SAXAAV?$doug_lea_alloc@U_NormalItem@R_dsgraph@@@@PAU_NormalItem@R_dsgraph@@$$QAU34@@Z ; std::_Normal_allocator_traits<doug_lea_alloc<R_dsgraph::_NormalItem> >::construct<R_dsgraph::_NormalItem,R_dsgraph::_NormalItem>
PUBLIC	??$forward@U_NormalItem@R_dsgraph@@@std@@YA$$QAU_NormalItem@R_dsgraph@@AAU12@@Z ; std::forward<R_dsgraph::_NormalItem>
PUBLIC	??$construct@U_MatrixItem@R_dsgraph@@U12@@?$_Normal_allocator_traits@V?$doug_lea_alloc@U_MatrixItem@R_dsgraph@@@@@std@@SAXAAV?$doug_lea_alloc@U_MatrixItem@R_dsgraph@@@@PAU_MatrixItem@R_dsgraph@@$$QAU34@@Z ; std::_Normal_allocator_traits<doug_lea_alloc<R_dsgraph::_MatrixItem> >::construct<R_dsgraph::_MatrixItem,R_dsgraph::_MatrixItem>
PUBLIC	??$forward@U_MatrixItem@R_dsgraph@@@std@@YA$$QAU_MatrixItem@R_dsgraph@@AAU12@@Z ; std::forward<R_dsgraph::_MatrixItem>
PUBLIC	??$_Emplace_back@U_NormalItem@R_dsgraph@@@?$_Uninitialized_backout_al@V?$doug_lea_alloc@U_NormalItem@R_dsgraph@@@@@std@@QAEX$$QAU_NormalItem@R_dsgraph@@@Z ; std::_Uninitialized_backout_al<doug_lea_alloc<R_dsgraph::_NormalItem> >::_Emplace_back<R_dsgraph::_NormalItem>
PUBLIC	??$move@AAU_NormalItem@R_dsgraph@@@std@@YA$$QAU_NormalItem@R_dsgraph@@AAU12@@Z ; std::move<R_dsgraph::_NormalItem &>
PUBLIC	??$_Emplace_back@U_MatrixItem@R_dsgraph@@@?$_Uninitialized_backout_al@V?$doug_lea_alloc@U_MatrixItem@R_dsgraph@@@@@std@@QAEX$$QAU_MatrixItem@R_dsgraph@@@Z ; std::_Uninitialized_backout_al<doug_lea_alloc<R_dsgraph::_MatrixItem> >::_Emplace_back<R_dsgraph::_MatrixItem>
PUBLIC	??$move@AAU_MatrixItem@R_dsgraph@@@std@@YA$$QAU_MatrixItem@R_dsgraph@@AAU12@@Z ; std::move<R_dsgraph::_MatrixItem &>
PUBLIC	??0?$_Uninitialized_backout_al@V?$doug_lea_alloc@U_MatrixItem@R_dsgraph@@@@@std@@QAE@PAU_MatrixItem@R_dsgraph@@AAV?$doug_lea_alloc@U_MatrixItem@R_dsgraph@@@@@Z ; std::_Uninitialized_backout_al<doug_lea_alloc<R_dsgraph::_MatrixItem> >::_Uninitialized_backout_al<doug_lea_alloc<R_dsgraph::_MatrixItem> >
PUBLIC	??1?$_Uninitialized_backout_al@V?$doug_lea_alloc@U_MatrixItem@R_dsgraph@@@@@std@@QAE@XZ ; std::_Uninitialized_backout_al<doug_lea_alloc<R_dsgraph::_MatrixItem> >::~_Uninitialized_backout_al<doug_lea_alloc<R_dsgraph::_MatrixItem> >
PUBLIC	?_Release@?$_Uninitialized_backout_al@V?$doug_lea_alloc@U_MatrixItem@R_dsgraph@@@@@std@@QAEPAU_MatrixItem@R_dsgraph@@XZ ; std::_Uninitialized_backout_al<doug_lea_alloc<R_dsgraph::_MatrixItem> >::_Release
PUBLIC	??0?$_Uninitialized_backout_al@V?$doug_lea_alloc@U_NormalItem@R_dsgraph@@@@@std@@QAE@PAU_NormalItem@R_dsgraph@@AAV?$doug_lea_alloc@U_NormalItem@R_dsgraph@@@@@Z ; std::_Uninitialized_backout_al<doug_lea_alloc<R_dsgraph::_NormalItem> >::_Uninitialized_backout_al<doug_lea_alloc<R_dsgraph::_NormalItem> >
PUBLIC	??1?$_Uninitialized_backout_al@V?$doug_lea_alloc@U_NormalItem@R_dsgraph@@@@@std@@QAE@XZ ; std::_Uninitialized_backout_al<doug_lea_alloc<R_dsgraph::_NormalItem> >::~_Uninitialized_backout_al<doug_lea_alloc<R_dsgraph::_NormalItem> >
PUBLIC	?_Release@?$_Uninitialized_backout_al@V?$doug_lea_alloc@U_NormalItem@R_dsgraph@@@@@std@@QAEPAU_NormalItem@R_dsgraph@@XZ ; std::_Uninitialized_backout_al<doug_lea_alloc<R_dsgraph::_NormalItem> >::_Release
PUBLIC	??$_Get_unwrapped@ABQAU_NormalItem@R_dsgraph@@@std@@YA?A_TABQAU_NormalItem@R_dsgraph@@@Z ; std::_Get_unwrapped<R_dsgraph::_NormalItem * const &>
PUBLIC	??$_Uninitialized_move@PAU_NormalItem@R_dsgraph@@V?$doug_lea_alloc@U_NormalItem@R_dsgraph@@@@@std@@YAPAU_NormalItem@R_dsgraph@@QAU12@0PAU12@AAV?$doug_lea_alloc@U_NormalItem@R_dsgraph@@@@@Z ; std::_Uninitialized_move<R_dsgraph::_NormalItem *,doug_lea_alloc<R_dsgraph::_NormalItem> >
PUBLIC	??$_Get_unwrapped@ABQAU_MatrixItem@R_dsgraph@@@std@@YA?A_TABQAU_MatrixItem@R_dsgraph@@@Z ; std::_Get_unwrapped<R_dsgraph::_MatrixItem * const &>
PUBLIC	??$_Uninitialized_move@PAU_MatrixItem@R_dsgraph@@V?$doug_lea_alloc@U_MatrixItem@R_dsgraph@@@@@std@@YAPAU_MatrixItem@R_dsgraph@@QAU12@0PAU12@AAV?$doug_lea_alloc@U_MatrixItem@R_dsgraph@@@@@Z ; std::_Uninitialized_move<R_dsgraph::_MatrixItem *,doug_lea_alloc<R_dsgraph::_MatrixItem> >
PUBLIC	?max_size@?$doug_lea_alloc@U_NormalItem@R_dsgraph@@@@QBEIXZ ; doug_lea_alloc<R_dsgraph::_NormalItem>::max_size
PUBLIC	?_Get_first@?$_Compressed_pair@V?$doug_lea_alloc@U_NormalItem@R_dsgraph@@@@V?$_Vector_val@U?$_Simple_types@U_NormalItem@R_dsgraph@@@std@@@std@@$00@std@@QBEABV?$doug_lea_alloc@U_NormalItem@R_dsgraph@@@@XZ ; std::_Compressed_pair<doug_lea_alloc<R_dsgraph::_NormalItem>,std::_Vector_val<std::_Simple_types<R_dsgraph::_NormalItem> >,1>::_Get_first
PUBLIC	?max_size@?$doug_lea_alloc@U_MatrixItem@R_dsgraph@@@@QBEIXZ ; doug_lea_alloc<R_dsgraph::_MatrixItem>::max_size
PUBLIC	?_Get_first@?$_Compressed_pair@V?$doug_lea_alloc@U_MatrixItem@R_dsgraph@@@@V?$_Vector_val@U?$_Simple_types@U_MatrixItem@R_dsgraph@@@std@@@std@@$00@std@@QBEABV?$doug_lea_alloc@U_MatrixItem@R_dsgraph@@@@XZ ; std::_Compressed_pair<doug_lea_alloc<R_dsgraph::_MatrixItem>,std::_Vector_val<std::_Simple_types<R_dsgraph::_MatrixItem> >,1>::_Get_first
PUBLIC	?max_size@?$_Normal_allocator_traits@V?$doug_lea_alloc@U_NormalItem@R_dsgraph@@@@@std@@SAIABV?$doug_lea_alloc@U_NormalItem@R_dsgraph@@@@@Z ; std::_Normal_allocator_traits<doug_lea_alloc<R_dsgraph::_NormalItem> >::max_size
PUBLIC	?capacity@?$vector@U_NormalItem@R_dsgraph@@V?$doug_lea_alloc@U_NormalItem@R_dsgraph@@@@@std@@QBEIXZ ; std::vector<R_dsgraph::_NormalItem,doug_lea_alloc<R_dsgraph::_NormalItem> >::capacity
PUBLIC	?_Umove_if_noexcept1@?$vector@U_NormalItem@R_dsgraph@@V?$doug_lea_alloc@U_NormalItem@R_dsgraph@@@@@std@@AAEXPAU_NormalItem@R_dsgraph@@00U?$integral_constant@_N$00@2@@Z ; std::vector<R_dsgraph::_NormalItem,doug_lea_alloc<R_dsgraph::_NormalItem> >::_Umove_if_noexcept1
PUBLIC	?_Getal@?$vector@U_NormalItem@R_dsgraph@@V?$doug_lea_alloc@U_NormalItem@R_dsgraph@@@@@std@@ABEABV?$doug_lea_alloc@U_NormalItem@R_dsgraph@@@@XZ ; std::vector<R_dsgraph::_NormalItem,doug_lea_alloc<R_dsgraph::_NormalItem> >::_Getal
PUBLIC	?max_size@?$_Normal_allocator_traits@V?$doug_lea_alloc@U_MatrixItem@R_dsgraph@@@@@std@@SAIABV?$doug_lea_alloc@U_MatrixItem@R_dsgraph@@@@@Z ; std::_Normal_allocator_traits<doug_lea_alloc<R_dsgraph::_MatrixItem> >::max_size
PUBLIC	?capacity@?$vector@U_MatrixItem@R_dsgraph@@V?$doug_lea_alloc@U_MatrixItem@R_dsgraph@@@@@std@@QBEIXZ ; std::vector<R_dsgraph::_MatrixItem,doug_lea_alloc<R_dsgraph::_MatrixItem> >::capacity
PUBLIC	?_Umove_if_noexcept1@?$vector@U_MatrixItem@R_dsgraph@@V?$doug_lea_alloc@U_MatrixItem@R_dsgraph@@@@@std@@AAEXPAU_MatrixItem@R_dsgraph@@00U?$integral_constant@_N$00@2@@Z ; std::vector<R_dsgraph::_MatrixItem,doug_lea_alloc<R_dsgraph::_MatrixItem> >::_Umove_if_noexcept1
PUBLIC	?_Getal@?$vector@U_MatrixItem@R_dsgraph@@V?$doug_lea_alloc@U_MatrixItem@R_dsgraph@@@@@std@@ABEABV?$doug_lea_alloc@U_MatrixItem@R_dsgraph@@@@XZ ; std::vector<R_dsgraph::_MatrixItem,doug_lea_alloc<R_dsgraph::_MatrixItem> >::_Getal
PUBLIC	?allocate@?$doug_lea_alloc@U_NormalItem@R_dsgraph@@@@QBEPAU_NormalItem@R_dsgraph@@IPBX@Z ; doug_lea_alloc<R_dsgraph::_NormalItem>::allocate
PUBLIC	?construct@?$doug_lea_alloc@U_NormalItem@R_dsgraph@@@@QAEXPAU_NormalItem@R_dsgraph@@ABU23@@Z ; doug_lea_alloc<R_dsgraph::_NormalItem>::construct
PUBLIC	?max_size@?$vector@U_NormalItem@R_dsgraph@@V?$doug_lea_alloc@U_NormalItem@R_dsgraph@@@@@std@@QBEIXZ ; std::vector<R_dsgraph::_NormalItem,doug_lea_alloc<R_dsgraph::_NormalItem> >::max_size
PUBLIC	?_Umove@?$vector@U_NormalItem@R_dsgraph@@V?$doug_lea_alloc@U_NormalItem@R_dsgraph@@@@@std@@AAEPAU_NormalItem@R_dsgraph@@PAU34@00@Z ; std::vector<R_dsgraph::_NormalItem,doug_lea_alloc<R_dsgraph::_NormalItem> >::_Umove
PUBLIC	?_Umove_if_noexcept@?$vector@U_NormalItem@R_dsgraph@@V?$doug_lea_alloc@U_NormalItem@R_dsgraph@@@@@std@@AAEXPAU_NormalItem@R_dsgraph@@00@Z ; std::vector<R_dsgraph::_NormalItem,doug_lea_alloc<R_dsgraph::_NormalItem> >::_Umove_if_noexcept
PUBLIC	?_Calculate_growth@?$vector@U_NormalItem@R_dsgraph@@V?$doug_lea_alloc@U_NormalItem@R_dsgraph@@@@@std@@ABEII@Z ; std::vector<R_dsgraph::_NormalItem,doug_lea_alloc<R_dsgraph::_NormalItem> >::_Calculate_growth
PUBLIC	?_Change_array@?$vector@U_NormalItem@R_dsgraph@@V?$doug_lea_alloc@U_NormalItem@R_dsgraph@@@@@std@@AAEXQAU_NormalItem@R_dsgraph@@II@Z ; std::vector<R_dsgraph::_NormalItem,doug_lea_alloc<R_dsgraph::_NormalItem> >::_Change_array
PUBLIC	?_Xlength@?$vector@U_NormalItem@R_dsgraph@@V?$doug_lea_alloc@U_NormalItem@R_dsgraph@@@@@std@@CAXXZ ; std::vector<R_dsgraph::_NormalItem,doug_lea_alloc<R_dsgraph::_NormalItem> >::_Xlength
PUBLIC	?allocate@?$doug_lea_alloc@U_MatrixItem@R_dsgraph@@@@QBEPAU_MatrixItem@R_dsgraph@@IPBX@Z ; doug_lea_alloc<R_dsgraph::_MatrixItem>::allocate
PUBLIC	?construct@?$doug_lea_alloc@U_MatrixItem@R_dsgraph@@@@QAEXPAU_MatrixItem@R_dsgraph@@ABU23@@Z ; doug_lea_alloc<R_dsgraph::_MatrixItem>::construct
PUBLIC	?max_size@?$vector@U_MatrixItem@R_dsgraph@@V?$doug_lea_alloc@U_MatrixItem@R_dsgraph@@@@@std@@QBEIXZ ; std::vector<R_dsgraph::_MatrixItem,doug_lea_alloc<R_dsgraph::_MatrixItem> >::max_size
PUBLIC	?_Umove@?$vector@U_MatrixItem@R_dsgraph@@V?$doug_lea_alloc@U_MatrixItem@R_dsgraph@@@@@std@@AAEPAU_MatrixItem@R_dsgraph@@PAU34@00@Z ; std::vector<R_dsgraph::_MatrixItem,doug_lea_alloc<R_dsgraph::_MatrixItem> >::_Umove
PUBLIC	?_Umove_if_noexcept@?$vector@U_MatrixItem@R_dsgraph@@V?$doug_lea_alloc@U_MatrixItem@R_dsgraph@@@@@std@@AAEXPAU_MatrixItem@R_dsgraph@@00@Z ; std::vector<R_dsgraph::_MatrixItem,doug_lea_alloc<R_dsgraph::_MatrixItem> >::_Umove_if_noexcept
PUBLIC	?_Calculate_growth@?$vector@U_MatrixItem@R_dsgraph@@V?$doug_lea_alloc@U_MatrixItem@R_dsgraph@@@@@std@@ABEII@Z ; std::vector<R_dsgraph::_MatrixItem,doug_lea_alloc<R_dsgraph::_MatrixItem> >::_Calculate_growth
PUBLIC	?_Change_array@?$vector@U_MatrixItem@R_dsgraph@@V?$doug_lea_alloc@U_MatrixItem@R_dsgraph@@@@@std@@AAEXQAU_MatrixItem@R_dsgraph@@II@Z ; std::vector<R_dsgraph::_MatrixItem,doug_lea_alloc<R_dsgraph::_MatrixItem> >::_Change_array
PUBLIC	?_Xlength@?$vector@U_MatrixItem@R_dsgraph@@V?$doug_lea_alloc@U_MatrixItem@R_dsgraph@@@@@std@@CAXXZ ; std::vector<R_dsgraph::_MatrixItem,doug_lea_alloc<R_dsgraph::_MatrixItem> >::_Xlength
PUBLIC	??$_Emplace_reallocate@ABU_NormalItem@R_dsgraph@@@?$vector@U_NormalItem@R_dsgraph@@V?$doug_lea_alloc@U_NormalItem@R_dsgraph@@@@@std@@QAEPAU_NormalItem@R_dsgraph@@QAU23@ABU23@@Z ; std::vector<R_dsgraph::_NormalItem,doug_lea_alloc<R_dsgraph::_NormalItem> >::_Emplace_reallocate<R_dsgraph::_NormalItem const &>
PUBLIC	??$construct@U_NormalItem@R_dsgraph@@ABU12@@?$_Normal_allocator_traits@V?$doug_lea_alloc@U_NormalItem@R_dsgraph@@@@@std@@SAXAAV?$doug_lea_alloc@U_NormalItem@R_dsgraph@@@@PAU_NormalItem@R_dsgraph@@ABU34@@Z ; std::_Normal_allocator_traits<doug_lea_alloc<R_dsgraph::_NormalItem> >::construct<R_dsgraph::_NormalItem,R_dsgraph::_NormalItem const &>
PUBLIC	??$forward@ABU_NormalItem@R_dsgraph@@@std@@YAABU_NormalItem@R_dsgraph@@ABU12@@Z ; std::forward<R_dsgraph::_NormalItem const &>
PUBLIC	??$_Emplace_reallocate@ABU_MatrixItem@R_dsgraph@@@?$vector@U_MatrixItem@R_dsgraph@@V?$doug_lea_alloc@U_MatrixItem@R_dsgraph@@@@@std@@QAEPAU_MatrixItem@R_dsgraph@@QAU23@ABU23@@Z ; std::vector<R_dsgraph::_MatrixItem,doug_lea_alloc<R_dsgraph::_MatrixItem> >::_Emplace_reallocate<R_dsgraph::_MatrixItem const &>
PUBLIC	??$construct@U_MatrixItem@R_dsgraph@@ABU12@@?$_Normal_allocator_traits@V?$doug_lea_alloc@U_MatrixItem@R_dsgraph@@@@@std@@SAXAAV?$doug_lea_alloc@U_MatrixItem@R_dsgraph@@@@PAU_MatrixItem@R_dsgraph@@ABU34@@Z ; std::_Normal_allocator_traits<doug_lea_alloc<R_dsgraph::_MatrixItem> >::construct<R_dsgraph::_MatrixItem,R_dsgraph::_MatrixItem const &>
PUBLIC	??$forward@ABU_MatrixItem@R_dsgraph@@@std@@YAABU_MatrixItem@R_dsgraph@@ABU12@@Z ; std::forward<R_dsgraph::_MatrixItem const &>
PUBLIC	?Size@?$FixedMAP@PAUSTextureList@@UmapNormalItems@R_dsgraph@@Udoug_lea_allocator@@@@AAEII@Z ; FixedMAP<STextureList *,R_dsgraph::mapNormalItems,doug_lea_allocator>::Size
PUBLIC	?Size@?$FixedMAP@PAUIDirect3DStateBlock9@@UmapNormalTextures@R_dsgraph@@Udoug_lea_allocator@@@@AAEII@Z ; FixedMAP<IDirect3DStateBlock9 *,R_dsgraph::mapNormalTextures,doug_lea_allocator>::Size
PUBLIC	?Size@?$FixedMAP@PAVR_constant_table@@UmapNormalStates@R_dsgraph@@Udoug_lea_allocator@@@@AAEII@Z ; FixedMAP<R_constant_table *,R_dsgraph::mapNormalStates,doug_lea_allocator>::Size
PUBLIC	?Size@?$FixedMAP@PAUIDirect3DPixelShader9@@UmapNormalCS@R_dsgraph@@Udoug_lea_allocator@@@@AAEII@Z ; FixedMAP<IDirect3DPixelShader9 *,R_dsgraph::mapNormalCS,doug_lea_allocator>::Size
PUBLIC	?Size@?$FixedMAP@PAUIDirect3DVertexShader9@@UmapNormalPS@R_dsgraph@@Udoug_lea_allocator@@@@AAEII@Z ; FixedMAP<IDirect3DVertexShader9 *,R_dsgraph::mapNormalPS,doug_lea_allocator>::Size
PUBLIC	?Size@?$FixedMAP@PAUSTextureList@@UmapMatrixItems@R_dsgraph@@Udoug_lea_allocator@@@@AAEII@Z ; FixedMAP<STextureList *,R_dsgraph::mapMatrixItems,doug_lea_allocator>::Size
PUBLIC	?Size@?$FixedMAP@PAUIDirect3DStateBlock9@@UmapMatrixTextures@R_dsgraph@@Udoug_lea_allocator@@@@AAEII@Z ; FixedMAP<IDirect3DStateBlock9 *,R_dsgraph::mapMatrixTextures,doug_lea_allocator>::Size
PUBLIC	?Size@?$FixedMAP@PAVR_constant_table@@UmapMatrixStates@R_dsgraph@@Udoug_lea_allocator@@@@AAEII@Z ; FixedMAP<R_constant_table *,R_dsgraph::mapMatrixStates,doug_lea_allocator>::Size
PUBLIC	?Size@?$FixedMAP@PAUIDirect3DPixelShader9@@UmapMatrixCS@R_dsgraph@@Udoug_lea_allocator@@@@AAEII@Z ; FixedMAP<IDirect3DPixelShader9 *,R_dsgraph::mapMatrixCS,doug_lea_allocator>::Size
PUBLIC	?Size@?$FixedMAP@PAUIDirect3DVertexShader9@@UmapMatrixPS@R_dsgraph@@Udoug_lea_allocator@@@@AAEII@Z ; FixedMAP<IDirect3DVertexShader9 *,R_dsgraph::mapMatrixPS,doug_lea_allocator>::Size
PUBLIC	?Size@?$FixedMAP@MU_MatrixItemS@R_dsgraph@@Udoug_lea_allocator@@@@AAEII@Z ; FixedMAP<float,R_dsgraph::_MatrixItemS,doug_lea_allocator>::Size
PUBLIC	?Size@?$FixedMAP@MU_LodItem@R_dsgraph@@Udoug_lea_allocator@@@@AAEII@Z ; FixedMAP<float,R_dsgraph::_LodItem,doug_lea_allocator>::Size
PUBLIC	?Realloc@?$FixedMAP@PAUSTextureList@@UmapNormalItems@R_dsgraph@@Udoug_lea_allocator@@@@AAEXXZ ; FixedMAP<STextureList *,R_dsgraph::mapNormalItems,doug_lea_allocator>::Realloc
PUBLIC	?Realloc@?$FixedMAP@PAUIDirect3DStateBlock9@@UmapNormalTextures@R_dsgraph@@Udoug_lea_allocator@@@@AAEXXZ ; FixedMAP<IDirect3DStateBlock9 *,R_dsgraph::mapNormalTextures,doug_lea_allocator>::Realloc
PUBLIC	?Realloc@?$FixedMAP@PAVR_constant_table@@UmapNormalStates@R_dsgraph@@Udoug_lea_allocator@@@@AAEXXZ ; FixedMAP<R_constant_table *,R_dsgraph::mapNormalStates,doug_lea_allocator>::Realloc
PUBLIC	?Realloc@?$FixedMAP@PAUIDirect3DPixelShader9@@UmapNormalCS@R_dsgraph@@Udoug_lea_allocator@@@@AAEXXZ ; FixedMAP<IDirect3DPixelShader9 *,R_dsgraph::mapNormalCS,doug_lea_allocator>::Realloc
PUBLIC	?Realloc@?$FixedMAP@PAUIDirect3DVertexShader9@@UmapNormalPS@R_dsgraph@@Udoug_lea_allocator@@@@AAEXXZ ; FixedMAP<IDirect3DVertexShader9 *,R_dsgraph::mapNormalPS,doug_lea_allocator>::Realloc
PUBLIC	?Realloc@?$FixedMAP@PAUSTextureList@@UmapMatrixItems@R_dsgraph@@Udoug_lea_allocator@@@@AAEXXZ ; FixedMAP<STextureList *,R_dsgraph::mapMatrixItems,doug_lea_allocator>::Realloc
PUBLIC	?Realloc@?$FixedMAP@PAUIDirect3DStateBlock9@@UmapMatrixTextures@R_dsgraph@@Udoug_lea_allocator@@@@AAEXXZ ; FixedMAP<IDirect3DStateBlock9 *,R_dsgraph::mapMatrixTextures,doug_lea_allocator>::Realloc
PUBLIC	?Realloc@?$FixedMAP@PAVR_constant_table@@UmapMatrixStates@R_dsgraph@@Udoug_lea_allocator@@@@AAEXXZ ; FixedMAP<R_constant_table *,R_dsgraph::mapMatrixStates,doug_lea_allocator>::Realloc
PUBLIC	?Realloc@?$FixedMAP@PAUIDirect3DPixelShader9@@UmapMatrixCS@R_dsgraph@@Udoug_lea_allocator@@@@AAEXXZ ; FixedMAP<IDirect3DPixelShader9 *,R_dsgraph::mapMatrixCS,doug_lea_allocator>::Realloc
PUBLIC	?Realloc@?$FixedMAP@PAUIDirect3DVertexShader9@@UmapMatrixPS@R_dsgraph@@Udoug_lea_allocator@@@@AAEXXZ ; FixedMAP<IDirect3DVertexShader9 *,R_dsgraph::mapMatrixPS,doug_lea_allocator>::Realloc
PUBLIC	?Realloc@?$FixedMAP@MU_MatrixItemS@R_dsgraph@@Udoug_lea_allocator@@@@AAEXXZ ; FixedMAP<float,R_dsgraph::_MatrixItemS,doug_lea_allocator>::Realloc
PUBLIC	?Realloc@?$FixedMAP@MU_LodItem@R_dsgraph@@Udoug_lea_allocator@@@@AAEXXZ ; FixedMAP<float,R_dsgraph::_LodItem,doug_lea_allocator>::Realloc
PUBLIC	?_Orphan_range@?$vector@U_NormalItem@R_dsgraph@@V?$doug_lea_alloc@U_NormalItem@R_dsgraph@@@@@std@@ABEXPAU_NormalItem@R_dsgraph@@0@Z ; std::vector<R_dsgraph::_NormalItem,doug_lea_alloc<R_dsgraph::_NormalItem> >::_Orphan_range
PUBLIC	?Alloc@?$FixedMAP@PAUSTextureList@@UmapNormalItems@R_dsgraph@@Udoug_lea_allocator@@@@AAEPAUTNode@1@ABQAUSTextureList@@@Z ; FixedMAP<STextureList *,R_dsgraph::mapNormalItems,doug_lea_allocator>::Alloc
PUBLIC	?CreateChild@?$FixedMAP@PAUSTextureList@@UmapNormalItems@R_dsgraph@@Udoug_lea_allocator@@@@AAEPAUTNode@1@AAPAU21@ABQAUSTextureList@@@Z ; FixedMAP<STextureList *,R_dsgraph::mapNormalItems,doug_lea_allocator>::CreateChild
PUBLIC	?Alloc@?$FixedMAP@PAUIDirect3DStateBlock9@@UmapNormalTextures@R_dsgraph@@Udoug_lea_allocator@@@@AAEPAUTNode@1@ABQAUIDirect3DStateBlock9@@@Z ; FixedMAP<IDirect3DStateBlock9 *,R_dsgraph::mapNormalTextures,doug_lea_allocator>::Alloc
PUBLIC	?CreateChild@?$FixedMAP@PAUIDirect3DStateBlock9@@UmapNormalTextures@R_dsgraph@@Udoug_lea_allocator@@@@AAEPAUTNode@1@AAPAU21@ABQAUIDirect3DStateBlock9@@@Z ; FixedMAP<IDirect3DStateBlock9 *,R_dsgraph::mapNormalTextures,doug_lea_allocator>::CreateChild
PUBLIC	?Alloc@?$FixedMAP@PAVR_constant_table@@UmapNormalStates@R_dsgraph@@Udoug_lea_allocator@@@@AAEPAUTNode@1@ABQAVR_constant_table@@@Z ; FixedMAP<R_constant_table *,R_dsgraph::mapNormalStates,doug_lea_allocator>::Alloc
PUBLIC	?CreateChild@?$FixedMAP@PAVR_constant_table@@UmapNormalStates@R_dsgraph@@Udoug_lea_allocator@@@@AAEPAUTNode@1@AAPAU21@ABQAVR_constant_table@@@Z ; FixedMAP<R_constant_table *,R_dsgraph::mapNormalStates,doug_lea_allocator>::CreateChild
PUBLIC	?Alloc@?$FixedMAP@PAUIDirect3DPixelShader9@@UmapNormalCS@R_dsgraph@@Udoug_lea_allocator@@@@AAEPAUTNode@1@ABQAUIDirect3DPixelShader9@@@Z ; FixedMAP<IDirect3DPixelShader9 *,R_dsgraph::mapNormalCS,doug_lea_allocator>::Alloc
PUBLIC	?CreateChild@?$FixedMAP@PAUIDirect3DPixelShader9@@UmapNormalCS@R_dsgraph@@Udoug_lea_allocator@@@@AAEPAUTNode@1@AAPAU21@ABQAUIDirect3DPixelShader9@@@Z ; FixedMAP<IDirect3DPixelShader9 *,R_dsgraph::mapNormalCS,doug_lea_allocator>::CreateChild
PUBLIC	?Alloc@?$FixedMAP@PAUIDirect3DVertexShader9@@UmapNormalPS@R_dsgraph@@Udoug_lea_allocator@@@@AAEPAUTNode@1@ABQAUIDirect3DVertexShader9@@@Z ; FixedMAP<IDirect3DVertexShader9 *,R_dsgraph::mapNormalPS,doug_lea_allocator>::Alloc
PUBLIC	?CreateChild@?$FixedMAP@PAUIDirect3DVertexShader9@@UmapNormalPS@R_dsgraph@@Udoug_lea_allocator@@@@AAEPAUTNode@1@AAPAU21@ABQAUIDirect3DVertexShader9@@@Z ; FixedMAP<IDirect3DVertexShader9 *,R_dsgraph::mapNormalPS,doug_lea_allocator>::CreateChild
PUBLIC	?_Orphan_range@?$vector@U_MatrixItem@R_dsgraph@@V?$doug_lea_alloc@U_MatrixItem@R_dsgraph@@@@@std@@ABEXPAU_MatrixItem@R_dsgraph@@0@Z ; std::vector<R_dsgraph::_MatrixItem,doug_lea_alloc<R_dsgraph::_MatrixItem> >::_Orphan_range
PUBLIC	?Alloc@?$FixedMAP@PAUSTextureList@@UmapMatrixItems@R_dsgraph@@Udoug_lea_allocator@@@@AAEPAUTNode@1@ABQAUSTextureList@@@Z ; FixedMAP<STextureList *,R_dsgraph::mapMatrixItems,doug_lea_allocator>::Alloc
PUBLIC	?CreateChild@?$FixedMAP@PAUSTextureList@@UmapMatrixItems@R_dsgraph@@Udoug_lea_allocator@@@@AAEPAUTNode@1@AAPAU21@ABQAUSTextureList@@@Z ; FixedMAP<STextureList *,R_dsgraph::mapMatrixItems,doug_lea_allocator>::CreateChild
PUBLIC	?Alloc@?$FixedMAP@PAUIDirect3DStateBlock9@@UmapMatrixTextures@R_dsgraph@@Udoug_lea_allocator@@@@AAEPAUTNode@1@ABQAUIDirect3DStateBlock9@@@Z ; FixedMAP<IDirect3DStateBlock9 *,R_dsgraph::mapMatrixTextures,doug_lea_allocator>::Alloc
PUBLIC	?CreateChild@?$FixedMAP@PAUIDirect3DStateBlock9@@UmapMatrixTextures@R_dsgraph@@Udoug_lea_allocator@@@@AAEPAUTNode@1@AAPAU21@ABQAUIDirect3DStateBlock9@@@Z ; FixedMAP<IDirect3DStateBlock9 *,R_dsgraph::mapMatrixTextures,doug_lea_allocator>::CreateChild
PUBLIC	?Alloc@?$FixedMAP@PAVR_constant_table@@UmapMatrixStates@R_dsgraph@@Udoug_lea_allocator@@@@AAEPAUTNode@1@ABQAVR_constant_table@@@Z ; FixedMAP<R_constant_table *,R_dsgraph::mapMatrixStates,doug_lea_allocator>::Alloc
PUBLIC	?CreateChild@?$FixedMAP@PAVR_constant_table@@UmapMatrixStates@R_dsgraph@@Udoug_lea_allocator@@@@AAEPAUTNode@1@AAPAU21@ABQAVR_constant_table@@@Z ; FixedMAP<R_constant_table *,R_dsgraph::mapMatrixStates,doug_lea_allocator>::CreateChild
PUBLIC	?Alloc@?$FixedMAP@PAUIDirect3DPixelShader9@@UmapMatrixCS@R_dsgraph@@Udoug_lea_allocator@@@@AAEPAUTNode@1@ABQAUIDirect3DPixelShader9@@@Z ; FixedMAP<IDirect3DPixelShader9 *,R_dsgraph::mapMatrixCS,doug_lea_allocator>::Alloc
PUBLIC	?CreateChild@?$FixedMAP@PAUIDirect3DPixelShader9@@UmapMatrixCS@R_dsgraph@@Udoug_lea_allocator@@@@AAEPAUTNode@1@AAPAU21@ABQAUIDirect3DPixelShader9@@@Z ; FixedMAP<IDirect3DPixelShader9 *,R_dsgraph::mapMatrixCS,doug_lea_allocator>::CreateChild
PUBLIC	?Alloc@?$FixedMAP@PAUIDirect3DVertexShader9@@UmapMatrixPS@R_dsgraph@@Udoug_lea_allocator@@@@AAEPAUTNode@1@ABQAUIDirect3DVertexShader9@@@Z ; FixedMAP<IDirect3DVertexShader9 *,R_dsgraph::mapMatrixPS,doug_lea_allocator>::Alloc
PUBLIC	?CreateChild@?$FixedMAP@PAUIDirect3DVertexShader9@@UmapMatrixPS@R_dsgraph@@Udoug_lea_allocator@@@@AAEPAUTNode@1@AAPAU21@ABQAUIDirect3DVertexShader9@@@Z ; FixedMAP<IDirect3DVertexShader9 *,R_dsgraph::mapMatrixPS,doug_lea_allocator>::CreateChild
PUBLIC	?Alloc@?$FixedMAP@MU_MatrixItemS@R_dsgraph@@Udoug_lea_allocator@@@@AAEPAUTNode@1@ABM@Z ; FixedMAP<float,R_dsgraph::_MatrixItemS,doug_lea_allocator>::Alloc
PUBLIC	?CreateChild@?$FixedMAP@MU_MatrixItemS@R_dsgraph@@Udoug_lea_allocator@@@@AAEPAUTNode@1@AAPAU21@ABM@Z ; FixedMAP<float,R_dsgraph::_MatrixItemS,doug_lea_allocator>::CreateChild
PUBLIC	?Alloc@?$FixedMAP@MU_LodItem@R_dsgraph@@Udoug_lea_allocator@@@@AAEPAUTNode@1@ABM@Z ; FixedMAP<float,R_dsgraph::_LodItem,doug_lea_allocator>::Alloc
PUBLIC	?CreateChild@?$FixedMAP@MU_LodItem@R_dsgraph@@Udoug_lea_allocator@@@@AAEPAUTNode@1@AAPAU21@ABM@Z ; FixedMAP<float,R_dsgraph::_LodItem,doug_lea_allocator>::CreateChild
PUBLIC	?_get@?$resptr_base@VR_constant_table@@@@QBEPAVR_constant_table@@XZ ; resptr_base<R_constant_table>::_get
PUBLIC	?_get@?$resptr_base@USTextureList@@@@QBEPAUSTextureList@@XZ ; resptr_base<STextureList>::_get
PUBLIC	?front@?$svector@V?$resptr_core@USPass@@V?$resptr_base@USPass@@@@@@$01@@QAEAAV?$resptr_core@USPass@@V?$resptr_base@USPass@@@@@@XZ ; svector<resptr_core<SPass,resptr_base<SPass> >,2>::front
PUBLIC	??$_Emplace_back_with_unused_capacity@ABU_NormalItem@R_dsgraph@@@?$vector@U_NormalItem@R_dsgraph@@V?$doug_lea_alloc@U_NormalItem@R_dsgraph@@@@@std@@AAE?A_TABU_NormalItem@R_dsgraph@@@Z ; std::vector<R_dsgraph::_NormalItem,doug_lea_alloc<R_dsgraph::_NormalItem> >::_Emplace_back_with_unused_capacity<R_dsgraph::_NormalItem const &>
PUBLIC	??$emplace_back@ABU_NormalItem@R_dsgraph@@@?$vector@U_NormalItem@R_dsgraph@@V?$doug_lea_alloc@U_NormalItem@R_dsgraph@@@@@std@@QAE?A_TABU_NormalItem@R_dsgraph@@@Z ; std::vector<R_dsgraph::_NormalItem,doug_lea_alloc<R_dsgraph::_NormalItem> >::emplace_back<R_dsgraph::_NormalItem const &>
PUBLIC	?push_back@?$vector@U_NormalItem@R_dsgraph@@V?$doug_lea_alloc@U_NormalItem@R_dsgraph@@@@@std@@QAEXABU_NormalItem@R_dsgraph@@@Z ; std::vector<R_dsgraph::_NormalItem,doug_lea_alloc<R_dsgraph::_NormalItem> >::push_back
PUBLIC	?insert@?$FixedMAP@PAUSTextureList@@UmapNormalItems@R_dsgraph@@Udoug_lea_allocator@@@@QAEPAUTNode@1@ABQAUSTextureList@@@Z ; FixedMAP<STextureList *,R_dsgraph::mapNormalItems,doug_lea_allocator>::insert
PUBLIC	?insert@?$FixedMAP@PAUIDirect3DStateBlock9@@UmapNormalTextures@R_dsgraph@@Udoug_lea_allocator@@@@QAEPAUTNode@1@ABQAUIDirect3DStateBlock9@@@Z ; FixedMAP<IDirect3DStateBlock9 *,R_dsgraph::mapNormalTextures,doug_lea_allocator>::insert
PUBLIC	?insert@?$FixedMAP@PAVR_constant_table@@UmapNormalStates@R_dsgraph@@Udoug_lea_allocator@@@@QAEPAUTNode@1@ABQAVR_constant_table@@@Z ; FixedMAP<R_constant_table *,R_dsgraph::mapNormalStates,doug_lea_allocator>::insert
PUBLIC	?insert@?$FixedMAP@PAUIDirect3DPixelShader9@@UmapNormalCS@R_dsgraph@@Udoug_lea_allocator@@@@QAEPAUTNode@1@ABQAUIDirect3DPixelShader9@@@Z ; FixedMAP<IDirect3DPixelShader9 *,R_dsgraph::mapNormalCS,doug_lea_allocator>::insert
PUBLIC	?insert@?$FixedMAP@PAUIDirect3DVertexShader9@@UmapNormalPS@R_dsgraph@@Udoug_lea_allocator@@@@QAEPAUTNode@1@ABQAUIDirect3DVertexShader9@@@Z ; FixedMAP<IDirect3DVertexShader9 *,R_dsgraph::mapNormalPS,doug_lea_allocator>::insert
PUBLIC	??$_Emplace_back_with_unused_capacity@ABU_MatrixItem@R_dsgraph@@@?$vector@U_MatrixItem@R_dsgraph@@V?$doug_lea_alloc@U_MatrixItem@R_dsgraph@@@@@std@@AAE?A_TABU_MatrixItem@R_dsgraph@@@Z ; std::vector<R_dsgraph::_MatrixItem,doug_lea_alloc<R_dsgraph::_MatrixItem> >::_Emplace_back_with_unused_capacity<R_dsgraph::_MatrixItem const &>
PUBLIC	??$emplace_back@ABU_MatrixItem@R_dsgraph@@@?$vector@U_MatrixItem@R_dsgraph@@V?$doug_lea_alloc@U_MatrixItem@R_dsgraph@@@@@std@@QAE?A_TABU_MatrixItem@R_dsgraph@@@Z ; std::vector<R_dsgraph::_MatrixItem,doug_lea_alloc<R_dsgraph::_MatrixItem> >::emplace_back<R_dsgraph::_MatrixItem const &>
PUBLIC	?push_back@?$vector@U_MatrixItem@R_dsgraph@@V?$doug_lea_alloc@U_MatrixItem@R_dsgraph@@@@@std@@QAEXABU_MatrixItem@R_dsgraph@@@Z ; std::vector<R_dsgraph::_MatrixItem,doug_lea_alloc<R_dsgraph::_MatrixItem> >::push_back
PUBLIC	?insert@?$FixedMAP@PAUSTextureList@@UmapMatrixItems@R_dsgraph@@Udoug_lea_allocator@@@@QAEPAUTNode@1@ABQAUSTextureList@@@Z ; FixedMAP<STextureList *,R_dsgraph::mapMatrixItems,doug_lea_allocator>::insert
PUBLIC	?insert@?$FixedMAP@PAUIDirect3DStateBlock9@@UmapMatrixTextures@R_dsgraph@@Udoug_lea_allocator@@@@QAEPAUTNode@1@ABQAUIDirect3DStateBlock9@@@Z ; FixedMAP<IDirect3DStateBlock9 *,R_dsgraph::mapMatrixTextures,doug_lea_allocator>::insert
PUBLIC	?insert@?$FixedMAP@PAVR_constant_table@@UmapMatrixStates@R_dsgraph@@Udoug_lea_allocator@@@@QAEPAUTNode@1@ABQAVR_constant_table@@@Z ; FixedMAP<R_constant_table *,R_dsgraph::mapMatrixStates,doug_lea_allocator>::insert
PUBLIC	?insert@?$FixedMAP@PAUIDirect3DPixelShader9@@UmapMatrixCS@R_dsgraph@@Udoug_lea_allocator@@@@QAEPAUTNode@1@ABQAUIDirect3DPixelShader9@@@Z ; FixedMAP<IDirect3DPixelShader9 *,R_dsgraph::mapMatrixCS,doug_lea_allocator>::insert
PUBLIC	?insert@?$FixedMAP@PAUIDirect3DVertexShader9@@UmapMatrixPS@R_dsgraph@@Udoug_lea_allocator@@@@QAEPAUTNode@1@ABQAUIDirect3DVertexShader9@@@Z ; FixedMAP<IDirect3DVertexShader9 *,R_dsgraph::mapMatrixPS,doug_lea_allocator>::insert
PUBLIC	?insertInAnyWay@?$FixedMAP@MU_MatrixItemS@R_dsgraph@@Udoug_lea_allocator@@@@QAEPAUTNode@1@ABM@Z ; FixedMAP<float,R_dsgraph::_MatrixItemS,doug_lea_allocator>::insertInAnyWay
PUBLIC	?insertInAnyWay@?$FixedMAP@MU_LodItem@R_dsgraph@@Udoug_lea_allocator@@@@QAEPAUTNode@1@ABM@Z ; FixedMAP<float,R_dsgraph::_LodItem,doug_lea_allocator>::insertInAnyWay
PUBLIC	?add_Static@CRender@@AAEXPAVIRender_Visual@@I@Z	; CRender::add_Static
PUBLIC	?add_Dynamic@CRender@@AAEHPAVIRender_Visual@@I@Z ; CRender::add_Dynamic
PUBLIC	?add_leafs_Static@CRender@@AAEXPAVIRender_Visual@@@Z ; CRender::add_leafs_Static
PUBLIC	?add_leafs_Dynamic@CRender@@AAEXPAVIRender_Visual@@@Z ; CRender::add_leafs_Dynamic
PUBLIC	?r_dsgraph_insert_static@R_dsgraph_structure@@QAEXPAVIRender_Visual@@@Z ; R_dsgraph_structure::r_dsgraph_insert_static
PUBLIC	?r_dsgraph_insert_dynamic@R_dsgraph_structure@@QAEXPAVIRender_Visual@@AAU?$_vector3@M@@@Z ; R_dsgraph_structure::r_dsgraph_insert_dynamic
PUBLIC	?CalcSSA@@YAMAAMAAU?$_vector3@M@@M@Z		; CalcSSA
PUBLIC	?CalcSSA@@YAMAAMAAU?$_vector3@M@@PAVIRender_Visual@@@Z ; CalcSSA
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$_Emplace_reallocate@ABU_MatrixItem@R_dsgraph@@@?$vector@U_MatrixItem@R_dsgraph@@V?$doug_lea_alloc@U_MatrixItem@R_dsgraph@@@@@std@@QAEPAU_MatrixItem@R_dsgraph@@QAU23@ABU23@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Emplace_reallocate@ABU_MatrixItem@R_dsgraph@@@?$vector@U_MatrixItem@R_dsgraph@@V?$doug_lea_alloc@U_MatrixItem@R_dsgraph@@@@@std@@QAEPAU_MatrixItem@R_dsgraph@@QAU23@ABU23@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Emplace_reallocate@ABU_MatrixItem@R_dsgraph@@@?$vector@U_MatrixItem@R_dsgraph@@V?$doug_lea_alloc@U_MatrixItem@R_dsgraph@@@@@std@@QAEPAU_MatrixItem@R_dsgraph@@QAU23@ABU23@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
__unwindtable$??$_Emplace_reallocate@ABU_MatrixItem@R_dsgraph@@@?$vector@U_MatrixItem@R_dsgraph@@V?$doug_lea_alloc@U_MatrixItem@R_dsgraph@@@@@std@@QAEPAU_MatrixItem@R_dsgraph@@QAU23@ABU23@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Emplace_reallocate@ABU_MatrixItem@R_dsgraph@@@?$vector@U_MatrixItem@R_dsgraph@@V?$doug_lea_alloc@U_MatrixItem@R_dsgraph@@@@@std@@QAEPAU_MatrixItem@R_dsgraph@@QAU23@ABU23@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Emplace_reallocate@ABU_MatrixItem@R_dsgraph@@@?$vector@U_MatrixItem@R_dsgraph@@V?$doug_lea_alloc@U_MatrixItem@R_dsgraph@@@@@std@@QAEPAU_MatrixItem@R_dsgraph@@QAU23@ABU23@@Z$2
__catchsym$??$_Emplace_reallocate@ABU_MatrixItem@R_dsgraph@@@?$vector@U_MatrixItem@R_dsgraph@@V?$doug_lea_alloc@U_MatrixItem@R_dsgraph@@@@@std@@QAEPAU_MatrixItem@R_dsgraph@@QAU23@ABU23@@Z$2 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Emplace_reallocate@ABU_MatrixItem@R_dsgraph@@@?$vector@U_MatrixItem@R_dsgraph@@V?$doug_lea_alloc@U_MatrixItem@R_dsgraph@@@@@std@@QAEPAU_MatrixItem@R_dsgraph@@QAU23@ABU23@@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$_Emplace_reallocate@ABU_NormalItem@R_dsgraph@@@?$vector@U_NormalItem@R_dsgraph@@V?$doug_lea_alloc@U_NormalItem@R_dsgraph@@@@@std@@QAEPAU_NormalItem@R_dsgraph@@QAU23@ABU23@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Emplace_reallocate@ABU_NormalItem@R_dsgraph@@@?$vector@U_NormalItem@R_dsgraph@@V?$doug_lea_alloc@U_NormalItem@R_dsgraph@@@@@std@@QAEPAU_NormalItem@R_dsgraph@@QAU23@ABU23@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Emplace_reallocate@ABU_NormalItem@R_dsgraph@@@?$vector@U_NormalItem@R_dsgraph@@V?$doug_lea_alloc@U_NormalItem@R_dsgraph@@@@@std@@QAEPAU_NormalItem@R_dsgraph@@QAU23@ABU23@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
__unwindtable$??$_Emplace_reallocate@ABU_NormalItem@R_dsgraph@@@?$vector@U_NormalItem@R_dsgraph@@V?$doug_lea_alloc@U_NormalItem@R_dsgraph@@@@@std@@QAEPAU_NormalItem@R_dsgraph@@QAU23@ABU23@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Emplace_reallocate@ABU_NormalItem@R_dsgraph@@@?$vector@U_NormalItem@R_dsgraph@@V?$doug_lea_alloc@U_NormalItem@R_dsgraph@@@@@std@@QAEPAU_NormalItem@R_dsgraph@@QAU23@ABU23@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Emplace_reallocate@ABU_NormalItem@R_dsgraph@@@?$vector@U_NormalItem@R_dsgraph@@V?$doug_lea_alloc@U_NormalItem@R_dsgraph@@@@@std@@QAEPAU_NormalItem@R_dsgraph@@QAU23@ABU23@@Z$2
__catchsym$??$_Emplace_reallocate@ABU_NormalItem@R_dsgraph@@@?$vector@U_NormalItem@R_dsgraph@@V?$doug_lea_alloc@U_NormalItem@R_dsgraph@@@@@std@@QAEPAU_NormalItem@R_dsgraph@@QAU23@ABU23@@Z$2 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Emplace_reallocate@ABU_NormalItem@R_dsgraph@@@?$vector@U_NormalItem@R_dsgraph@@V?$doug_lea_alloc@U_NormalItem@R_dsgraph@@@@@std@@QAEPAU_NormalItem@R_dsgraph@@QAU23@ABU23@@Z$0
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp
;	COMDAT ?CalcSSA@@YAMAAMAAU?$_vector3@M@@PAVIRender_Visual@@@Z
_TEXT	SEGMENT
tv149 = -4						; size = 4
_V$ = 8							; size = 4
?CalcSSA@@YAMAAMAAU?$_vector3@M@@PAVIRender_Visual@@@Z PROC ; CalcSSA, COMDAT
; _distSQ$ = ecx
; _C$ = edx

; 24   : {

	push	ecx

; 26   : 	distSQ	= Device.vCameraPosition.distance_to_sqr(C)+EPS;

	mov	eax, DWORD PTR __imp_?Device@@3VCRenderDevice@@A
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 287  : 	{	return (x-v.x)*(x-v.x) + (y-v.y)*(y-v.y) + (z-v.z)*(z-v.z);	}

	movss	xmm1, DWORD PTR [eax+492]
	movss	xmm2, DWORD PTR [eax+488]
	movss	xmm0, DWORD PTR [eax+496]
	subss	xmm2, DWORD PTR [edx]
	subss	xmm0, DWORD PTR [edx+8]
	subss	xmm1, DWORD PTR [edx+4]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp

; 27   : 	return	R/distSQ;

	mov	eax, DWORD PTR _V$[esp]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 287  : 	{	return (x-v.x)*(x-v.x) + (y-v.y)*(y-v.y) + (z-v.z)*(z-v.z);	}

	mulss	xmm2, xmm2
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp

; 27   : 	return	R/distSQ;

	fld	DWORD PTR [eax+20]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 287  : 	{	return (x-v.x)*(x-v.x) + (y-v.y)*(y-v.y) + (z-v.z)*(z-v.z);	}

	mulss	xmm1, xmm1
	mulss	xmm0, xmm0
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp

; 26   : 	distSQ	= Device.vCameraPosition.distance_to_sqr(C)+EPS;

	addss	xmm2, xmm1
	addss	xmm0, DWORD PTR __real@3727c5ac
	addss	xmm2, xmm0
	movss	DWORD PTR tv149[esp+4], xmm2

; 27   : 	return	R/distSQ;

	fdiv	DWORD PTR tv149[esp+4]
	movss	DWORD PTR [ecx], xmm2

; 28   : }

	pop	ecx
	ret	0
?CalcSSA@@YAMAAMAAU?$_vector3@M@@PAVIRender_Visual@@@Z ENDP ; CalcSSA
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp
;	COMDAT ?CalcSSA@@YAMAAMAAU?$_vector3@M@@M@Z
_TEXT	SEGMENT
tv85 = -4						; size = 4
_R$ = 8							; size = 4
?CalcSSA@@YAMAAMAAU?$_vector3@M@@M@Z PROC		; CalcSSA, COMDAT
; _distSQ$ = ecx
; _C$ = edx

; 30   : {

	push	ecx

; 31   : 	distSQ	= Device.vCameraPosition.distance_to_sqr(C)+EPS;

	mov	eax, DWORD PTR __imp_?Device@@3VCRenderDevice@@A

; 32   : 	return	R/distSQ;

	fld	DWORD PTR _R$[esp]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 287  : 	{	return (x-v.x)*(x-v.x) + (y-v.y)*(y-v.y) + (z-v.z)*(z-v.z);	}

	movss	xmm1, DWORD PTR [eax+492]
	movss	xmm2, DWORD PTR [eax+488]
	subss	xmm2, DWORD PTR [edx]
	movss	xmm0, DWORD PTR [eax+496]
	subss	xmm0, DWORD PTR [edx+8]
	subss	xmm1, DWORD PTR [edx+4]
	mulss	xmm2, xmm2
	mulss	xmm0, xmm0
	mulss	xmm1, xmm1
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp

; 31   : 	distSQ	= Device.vCameraPosition.distance_to_sqr(C)+EPS;

	addss	xmm0, DWORD PTR __real@3727c5ac
	addss	xmm2, xmm1
	addss	xmm2, xmm0
	movss	DWORD PTR tv85[esp+4], xmm2

; 32   : 	return	R/distSQ;

	fdiv	DWORD PTR tv85[esp+4]
	movss	DWORD PTR [ecx], xmm2

; 33   : }

	pop	ecx
	ret	0
?CalcSSA@@YAMAAMAAU?$_vector3@M@@M@Z ENDP		; CalcSSA
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\lightProjector.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp
_TEXT	SEGMENT
_Nps$1$ = -96						; size = 4
_Nvs$1$ = -92						; size = 4
_this$1$ = -92						; size = 4
_SSA$1$ = -88						; size = 4
_pass$1$ = -84						; size = 4
$T1 = -84						; size = 4
_this$1$ = -80						; size = 4
tv1451 = -80						; size = 4
_item$ = -76						; size = 76
_Ncs$1$ = 8						; size = 4
_sh$1$ = 8						; size = 4
_sh_d$1$ = 8						; size = 4
_pVisual$ = 8						; size = 4
_Nstate$1$ = 12						; size = 4
$T2 = 12						; size = 4
_distSQ$ = 12						; size = 4
_Center$ = 12						; size = 4
?r_dsgraph_insert_dynamic@R_dsgraph_structure@@QAEXPAVIRender_Visual@@AAU?$_vector3@M@@@Z PROC ; R_dsgraph_structure::r_dsgraph_insert_dynamic
; _this$ = ecx

; 36   : {

	sub	esp, 96					; 00000060H

; 37   : 	CRender&	RI			=	RImplementation;
; 38   : 
; 39   : 	if (pVisual->vis.marker	==	RI.marker)	return	;

	mov	eax, DWORD PTR ?RImplementation@@3VCRender@@A+296
	push	ebx
	mov	ebx, DWORD PTR _pVisual$[esp+96]
	push	edi
	mov	edi, ecx
	mov	DWORD PTR _this$1$[esp+104], edi
	cmp	DWORD PTR [ebx+48], eax
	je	$LN20@r_dsgraph_

; 40   : 	pVisual->vis.marker		=	RI.marker			;

	mov	DWORD PTR [ebx+48], eax

; 41   : 
; 42   : #if RENDER==R_R1
; 43   : 	if (RI.o.vis_intersect &&	(pVisual->vis.accept_frame!=Device.dwFrame))	return;

	test	BYTE PTR ?RImplementation@@3VCRender@@A+628, 1
	mov	ecx, DWORD PTR __imp_?Device@@3VCRenderDevice@@A
	je	SHORT $LN6@r_dsgraph_
	mov	eax, DWORD PTR [ebx+52]
	cmp	eax, DWORD PTR [ecx+244]
	jne	$LN20@r_dsgraph_
$LN6@r_dsgraph_:

; 44   : 	pVisual->vis.accept_frame	=	Device.dwFrame	;

	mov	eax, DWORD PTR [ecx+244]
	mov	DWORD PTR [ebx+52], eax

; 26   : 	distSQ	= Device.vCameraPosition.distance_to_sqr(C)+EPS;

	mov	ecx, DWORD PTR __imp_?Device@@3VCRenderDevice@@A
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 287  : 	{	return (x-v.x)*(x-v.x) + (y-v.y)*(y-v.y) + (z-v.z)*(z-v.z);	}

	mov	eax, DWORD PTR _Center$[esp+100]
	movss	xmm0, DWORD PTR [ecx+488]
	movss	xmm1, DWORD PTR [ecx+496]
	subss	xmm1, DWORD PTR [eax+8]
	movss	xmm2, DWORD PTR [ecx+492]
	subss	xmm2, DWORD PTR [eax+4]
	subss	xmm0, DWORD PTR [eax]
	mulss	xmm1, xmm1
	mulss	xmm2, xmm2
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp

; 26   : 	distSQ	= Device.vCameraPosition.distance_to_sqr(C)+EPS;

	addss	xmm1, DWORD PTR __real@3727c5ac
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 287  : 	{	return (x-v.x)*(x-v.x) + (y-v.y)*(y-v.y) + (z-v.z)*(z-v.z);	}

	mulss	xmm0, xmm0
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp

; 26   : 	distSQ	= Device.vCameraPosition.distance_to_sqr(C)+EPS;

	addss	xmm2, xmm0

; 45   : #endif
; 46   : 
; 47   : 	float distSQ			;
; 48   : 	float SSA				=	CalcSSA		(distSQ,Center,pVisual);
; 49   : 	if (SSA<=r_ssaDISCARD)		return;

	movss	xmm0, DWORD PTR ?r_ssaDISCARD@@3MA

; 26   : 	distSQ	= Device.vCameraPosition.distance_to_sqr(C)+EPS;

	addss	xmm2, xmm1

; 27   : 	return	R/distSQ;

	movss	xmm1, DWORD PTR [ebx+20]
	divss	xmm1, xmm2
	movss	DWORD PTR _distSQ$[esp+100], xmm2

; 45   : #endif
; 46   : 
; 47   : 	float distSQ			;
; 48   : 	float SSA				=	CalcSSA		(distSQ,Center,pVisual);
; 49   : 	if (SSA<=r_ssaDISCARD)		return;

	comiss	xmm0, xmm1

; 27   : 	return	R/distSQ;

	movss	DWORD PTR _SSA$1$[esp+104], xmm1

; 45   : #endif
; 46   : 
; 47   : 	float distSQ			;
; 48   : 	float SSA				=	CalcSSA		(distSQ,Center,pVisual);
; 49   : 	if (SSA<=r_ssaDISCARD)		return;

	jae	$LN20@r_dsgraph_

; 50   : 
; 51   : 	// Distortive geometry should be marked and R2 special-cases it
; 52   : 	// a) Allow to optimize RT order
; 53   : 	// b) Should be rendered to special distort buffer in another pass
; 54   : 	VERIFY						(pVisual->shader._get());
; 55   : 	ShaderElement*		sh_d	= &*pVisual->shader->E[4];
; 56   : 	if (RImplementation.o.distortion && sh_d && sh_d->flags.bDistort && pmask[sh_d->flags.iPriority/2]) {

	test	BYTE PTR ?RImplementation@@3VCRender@@A+628, 2
	mov	eax, DWORD PTR [ebx+64]
	push	esi
	mov	eax, DWORD PTR [eax+24]
	mov	DWORD PTR _sh_d$1$[esp+104], eax
	je	SHORT $LN8@r_dsgraph_
	test	eax, eax
	je	SHORT $LN8@r_dsgraph_
	mov	eax, DWORD PTR [eax+8]
	test	al, 16					; 00000010H
	je	SHORT $LN8@r_dsgraph_
	shr	eax, 1
	and	eax, 1
	cmp	BYTE PTR [eax+edi+300], 0
	je	SHORT $LN8@r_dsgraph_

; 57   : 		mapSorted_Node* N		= mapDistort.insertInAnyWay	(distSQ);

	lea	eax, DWORD PTR _distSQ$[esp+104]
	push	eax
	lea	ecx, DWORD PTR [edi+388]
	call	?insertInAnyWay@?$FixedMAP@MU_MatrixItemS@R_dsgraph@@Udoug_lea_allocator@@@@QAEPAUTNode@1@ABM@Z ; FixedMAP<float,R_dsgraph::_MatrixItemS,doug_lea_allocator>::insertInAnyWay

; 58   : 		N->val.ssa				= SSA;

	movss	xmm1, DWORD PTR _SSA$1$[esp+108]
	movss	DWORD PTR [eax+4], xmm1

; 59   : 		N->val.pObject			= RI.val_pObject;
; 60   : 		N->val.pVisual			= pVisual;
; 61   : 		N->val.Matrix			= *RI.val_pTransform;

	lea	edi, DWORD PTR [eax+16]
	mov	ecx, DWORD PTR ?RImplementation@@3VCRender@@A+260
	mov	DWORD PTR [eax+8], ecx
	mov	ecx, 16					; 00000010H
	mov	DWORD PTR [eax+12], ebx
	mov	esi, DWORD PTR ?RImplementation@@3VCRender@@A+264
	rep movsd

; 62   : 		N->val.se				= sh_d;		// 4=L_special

	mov	ecx, DWORD PTR _sh_d$1$[esp+104]
	mov	edi, DWORD PTR _this$1$[esp+108]
	mov	DWORD PTR [eax+80], ecx
$LN8@r_dsgraph_:
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp

; 23   : 	switch (phase)		{

	mov	eax, DWORD PTR ?RImplementation@@3VCRender@@A+292
	sub	eax, 0
	je	SHORT $LN29@r_dsgraph_
	sub	eax, 1
	mov	eax, DWORD PTR [ebx+64]
	je	SHORT $LN30@r_dsgraph_

; 26   : 	case PHASE_SPOT:	return pVisual->shader->E[SE_R1_LSPOT]._get();

	mov	edx, DWORD PTR [eax+20]
	jmp	SHORT $LN171@r_dsgraph_
$LN30@r_dsgraph_:

; 25   : 	case PHASE_POINT:	return pVisual->shader->E[SE_R1_LPOINT]._get();

	mov	edx, DWORD PTR [eax+16]
	jmp	SHORT $LN171@r_dsgraph_
$LN29@r_dsgraph_:
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\lightProjector.h

; 43   : 	BOOL					shadowing		()			{ return current!=0;	}

	mov	esi, DWORD PTR [ebx+64]
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp

; 24   : 	case PHASE_NORMAL:	return (RImplementation.L_Projector->shadowing()?pVisual->shader->E[SE_R1_NORMAL_HQ]:pVisual->shader->E[SE_R1_NORMAL_LQ])._get();

	mov	eax, DWORD PTR ?RImplementation@@3VCRender@@A+992
	lea	ecx, DWORD PTR [esi+12]
	cmp	DWORD PTR [eax+4], 0
	lea	edx, DWORD PTR [esi+8]
	cmove	edx, ecx
	mov	edx, DWORD PTR [edx]
$LN171@r_dsgraph_:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp

; 67   : 	if (0==sh)								return;

	mov	DWORD PTR _sh$1$[esp+104], edx
	test	edx, edx
	je	$LN170@r_dsgraph_

; 68   : 	if (!pmask[sh->flags.iPriority/2])		return;

	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR tv1451[esp+108], eax
	shr	eax, 1
	and	eax, 1
	cmp	BYTE PTR [eax+edi+300], 0
	je	$LN170@r_dsgraph_

; 69   : 
; 70   : 	// Create common node
; 71   : 	// NOTE: Invisible elements exist only in R1
; 72   : 	_MatrixItem		item	= {SSA,RI.val_pObject,pVisual,*RI.val_pTransform};
; 73   : 
; 74   : 	// HUD rendering
; 75   : 	if (RI.val_bHUD)			{

	cmp	DWORD PTR ?RImplementation@@3VCRender@@A+268, 0
	lea	edi, DWORD PTR _item$[esp+120]
	mov	eax, DWORD PTR ?RImplementation@@3VCRender@@A+260
	mov	ecx, 16					; 00000010H
	mov	esi, DWORD PTR ?RImplementation@@3VCRender@@A+264
	movss	DWORD PTR _item$[esp+108], xmm1
	mov	DWORD PTR _item$[esp+112], eax
	mov	DWORD PTR _item$[esp+116], ebx
	rep movsd
	je	SHORT $LN13@r_dsgraph_

; 76   : 		if (sh->flags.bStrictB2F)	{

	test	BYTE PTR tv1451[esp+108], 4
	lea	eax, DWORD PTR _distSQ$[esp+104]
	mov	ecx, DWORD PTR _this$1$[esp+108]
	push	eax
	je	SHORT $LN12@r_dsgraph_

; 77   : 			mapSorted_Node* N		= mapSorted.insertInAnyWay	(distSQ);

	add	ecx, 352				; 00000160H
	call	?insertInAnyWay@?$FixedMAP@MU_MatrixItemS@R_dsgraph@@Udoug_lea_allocator@@@@QAEPAUTNode@1@ABM@Z ; FixedMAP<float,R_dsgraph::_MatrixItemS,doug_lea_allocator>::insertInAnyWay

; 78   : 			N->val.ssa				= SSA;

	movss	xmm0, DWORD PTR _SSA$1$[esp+108]
	movss	DWORD PTR [eax+4], xmm0

; 79   : 			N->val.pObject			= RI.val_pObject;

	mov	edx, DWORD PTR ?RImplementation@@3VCRender@@A+260
	mov	DWORD PTR [eax+8], edx

; 80   : 			N->val.pVisual			= pVisual;
; 81   : 			N->val.Matrix			= *RI.val_pTransform;
; 82   : 			N->val.se				= sh;
; 83   : 			return;

	jmp	$LN181@r_dsgraph_
$LN12@r_dsgraph_:

; 84   : 		} else {
; 85   : 			mapHUD_Node* N			= mapHUD.insertInAnyWay		(distSQ);

	add	ecx, 364				; 0000016cH

; 86   : 			N->val.ssa				= SSA;
; 87   : 			N->val.pObject			= RI.val_pObject;
; 88   : 			N->val.pVisual			= pVisual;
; 89   : 			N->val.Matrix			= *RI.val_pTransform;
; 90   : 			N->val.se				= sh;
; 91   : 			return;

	jmp	SHORT $LN180@r_dsgraph_
$LN13@r_dsgraph_:

; 92   : 		}
; 93   : 	}
; 94   : 
; 95   : 	// Shadows registering
; 96   : #if RENDER==R_R1
; 97   : 	RI.L_Shadows->add_element	(item);

	mov	ecx, DWORD PTR ?RImplementation@@3VCRender@@A+988
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp

; 128  : 	if (0==current)										return;

	cmp	DWORD PTR [ecx], 0
	je	SHORT $LN50@r_dsgraph_

; 129  : 	VERIFY2	(casters.back()->nodes.size()<24,"Object exceeds limit of 24 renderable parts/materials");
; 130  : 	if (0==N.pVisual->shader->E[SE_R1_LMODELS]._get())	return;

	mov	eax, DWORD PTR [ebx+64]
	cmp	DWORD PTR [eax+24], 0
	je	SHORT $LN50@r_dsgraph_

; 131  : 	casters.back()->nodes.push_back		(N);

	mov	eax, DWORD PTR [ecx+20]
	mov	eax, DWORD PTR [eax-4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 730  :         if (_Mylast != _My_data._Myend) {

	mov	edi, DWORD PTR [eax+24]
	cmp	edi, DWORD PTR [eax+28]
	je	SHORT $LN51@r_dsgraph_
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	ecx, 19					; 00000013H
	lea	esi, DWORD PTR _item$[esp+108]
	rep movsd
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 716  :         ++_Mylast;

	add	DWORD PTR [eax+24], 76			; 0000004cH

; 731  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

	jmp	SHORT $LN50@r_dsgraph_
$LN51@r_dsgraph_:

; 732  :         }
; 733  : 
; 734  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	lea	ecx, DWORD PTR _item$[esp+108]
	push	ecx
	push	edi
	lea	ecx, DWORD PTR [eax+20]
	call	??$_Emplace_reallocate@ABU_MatrixItem@R_dsgraph@@@?$vector@U_MatrixItem@R_dsgraph@@V?$xalloc@U_MatrixItem@R_dsgraph@@@@@std@@QAEPAU_MatrixItem@R_dsgraph@@QAU23@ABU23@@Z ; std::vector<R_dsgraph::_MatrixItem,xalloc<R_dsgraph::_MatrixItem> >::_Emplace_reallocate<R_dsgraph::_MatrixItem const &>
	mov	edx, DWORD PTR _sh$1$[esp+104]
$LN50@r_dsgraph_:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp

; 99   : 	if (RI.val_bInvisible)		return;

	cmp	DWORD PTR ?RImplementation@@3VCRender@@A+272, 0
	jne	$LN170@r_dsgraph_

; 100  : 
; 101  : 	// strict-sorting selection
; 102  : 	if (sh->flags.bStrictB2F)	{

	mov	eax, DWORD PTR [edx+8]
	mov	ecx, DWORD PTR _this$1$[esp+108]
	test	al, 4
	je	SHORT $LN15@r_dsgraph_

; 103  : 		mapSorted_Node* N		= mapSorted.insertInAnyWay	(distSQ);

	lea	eax, DWORD PTR _distSQ$[esp+104]
	add	ecx, 352				; 00000160H
	push	eax
$LN180@r_dsgraph_:
	call	?insertInAnyWay@?$FixedMAP@MU_MatrixItemS@R_dsgraph@@Udoug_lea_allocator@@@@QAEPAUTNode@1@ABM@Z ; FixedMAP<float,R_dsgraph::_MatrixItemS,doug_lea_allocator>::insertInAnyWay

; 104  : 		N->val.ssa				= SSA;

	movss	xmm0, DWORD PTR _SSA$1$[esp+108]
	movss	DWORD PTR [eax+4], xmm0

; 105  : 		N->val.pObject			= RI.val_pObject;

	mov	ecx, DWORD PTR ?RImplementation@@3VCRender@@A+260
	mov	DWORD PTR [eax+8], ecx
$LN181@r_dsgraph_:

; 106  : 		N->val.pVisual			= pVisual;

	mov	DWORD PTR [eax+12], ebx

; 107  : 		N->val.Matrix			= *RI.val_pTransform;

	lea	edi, DWORD PTR [eax+16]
	mov	esi, DWORD PTR ?RImplementation@@3VCRender@@A+264
	mov	ecx, 16					; 00000010H
	rep movsd

; 108  : 		N->val.se				= sh;

	mov	ecx, DWORD PTR _sh$1$[esp+104]
	pop	esi
	pop	edi
	mov	DWORD PTR [eax+80], ecx

; 159  : 	} } } } }
; 160  : 
; 161  : #if RENDER==R_R2
; 162  : 	if (val_recorder)			{
; 163  : 		Fbox3		temp		;
; 164  : 		Fmatrix&	xf			= *RI.val_pTransform;
; 165  : 		temp.xform	(pVisual->vis.box,xf);
; 166  : 		val_recorder->push_back	(temp);
; 167  : 	}
; 168  : #endif
; 169  : }

	pop	ebx
	add	esp, 96					; 00000060H
	ret	8
$LN15@r_dsgraph_:

; 109  : 		return;
; 110  : 	}
; 111  : 
; 112  : #if RENDER==R_R2
; 113  : 	// Emissive geometry should be marked and R2 special-cases it
; 114  : 	// a) Allow to skeep already lit pixels
; 115  : 	// b) Allow to make them 100% lit and really bright
; 116  : 	// c) Should not cast shadows
; 117  : 	// d) Should be rendered to accumulation buffer in the second pass
; 118  : 	if (sh->flags.bEmissive) {
; 119  : 		mapSorted_Node* N		= mapEmissive.insertInAnyWay	(distSQ);
; 120  : 		N->val.ssa				= SSA;
; 121  : 		N->val.pObject			= RI.val_pObject;
; 122  : 		N->val.pVisual			= pVisual;
; 123  : 		N->val.Matrix			= *RI.val_pTransform;
; 124  : 		N->val.se				= &*pVisual->shader->E[4];		// 4=L_special
; 125  : 	}
; 126  : 	if (sh->flags.bWmark	&& pmask_wmark)	{
; 127  : 		mapSorted_Node* N		= mapWmark.insertInAnyWay		(distSQ);
; 128  : 		N->val.ssa				= SSA;
; 129  : 		N->val.pObject			= RI.val_pObject;
; 130  : 		N->val.pVisual			= pVisual;
; 131  : 		N->val.Matrix			= *RI.val_pTransform;
; 132  : 		N->val.se				= sh;							
; 133  : 		return					;
; 134  : 	}
; 135  : #endif
; 136  : 
; 137  : 	// the most common node
; 138  : 	SPass&						pass	= *sh->passes.front	();

	mov	edx, DWORD PTR [edx+12]

; 139  : 	mapMatrix_T&				map		= mapMatrix			[sh->flags.iPriority/2];

	shr	eax, 1
	and	eax, 1
	mov	DWORD PTR _pass$1$[esp+108], edx

; 140  : #ifdef USE_RESOURCE_DEBUGGER
; 141  : 	mapMatrixVS::TNode*			Nvs		= map.insert		(pass.vs);
; 142  : 	mapMatrixPS::TNode*			Nps		= Nvs->val.insert	(pass.ps);
; 143  : #else
; 144  : 	mapMatrixVS::TNode*			Nvs		= map.insert		(pass.vs->vs);

	mov	ebx, DWORD PTR [edx+16]
	add	ebx, 12					; 0000000cH
	lea	edi, DWORD PTR [eax+41]
	lea	edi, DWORD PTR [eax+edi*2]
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h

; 129  : 		if (pool) {

	cmp	DWORD PTR [ecx+edi*4+4], 0
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp

; 139  : 	mapMatrix_T&				map		= mapMatrix			[sh->flags.iPriority/2];

	lea	edi, DWORD PTR [ecx+edi*4]
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h

; 129  : 		if (pool) {

	je	SHORT $LN60@r_dsgraph_

; 130  : 			TNode*	node = nodes;

	mov	esi, DWORD PTR [edi]
	mov	edx, esi

; 131  : 
; 132  : 			once_more:
; 133  : 			if (k < node->key) {

	mov	ecx, DWORD PTR [ebx]
$LN172@r_dsgraph_:
	mov	DWORD PTR _Nvs$1$[esp+108], edx
	npad	5
$once_more$183:
	cmp	ecx, DWORD PTR [edx]
	jae	SHORT $LN62@r_dsgraph_

; 134  : 				if (node->left) {

	mov	eax, DWORD PTR [edx+20]
	test	eax, eax
	je	SHORT $LN64@r_dsgraph_

; 135  : 					node = node->left;

	mov	edx, eax

; 136  : 					goto once_more;

	jmp	SHORT $LN172@r_dsgraph_
$LN62@r_dsgraph_:

; 141  : 				}
; 142  : 			} else if (k > node->key) {

	jbe	SHORT $LN61@r_dsgraph_

; 143  : 				if (node->right) {

	mov	eax, DWORD PTR [edx+24]
	test	eax, eax
	je	SHORT $LN68@r_dsgraph_

; 144  : 					node = node->right;

	mov	edx, eax

; 145  : 					goto once_more;

	jmp	SHORT $LN172@r_dsgraph_
$LN64@r_dsgraph_:

; 69   : 		size_t	PID	= size_t(parent-nodes);

	sub	edx, esi

; 70   : 		TNode*	N	= Alloc	(key);

	mov	ecx, edi
	sar	edx, 2
	push	ebx
	imul	esi, edx, -1227133513
	call	?Alloc@?$FixedMAP@PAUIDirect3DVertexShader9@@UmapMatrixPS@R_dsgraph@@Udoug_lea_allocator@@@@AAEPAUTNode@1@ABQAUIDirect3DVertexShader9@@@Z ; FixedMAP<IDirect3DVertexShader9 *,R_dsgraph::mapMatrixPS,doug_lea_allocator>::Alloc

; 138  : 					TNode* N = CreateChild(node,k);

	mov	edx, eax

; 71   : 		parent		= nodes+PID;

	lea	ecx, DWORD PTR [esi*8]

; 139  : 					node->left = N;

	mov	eax, DWORD PTR [edi]

; 71   : 		parent		= nodes+PID;

	sub	ecx, esi

; 139  : 					node->left = N;

	mov	DWORD PTR [eax+ecx*4+20], edx

; 140  : 					return N;

	jmp	SHORT $LN173@r_dsgraph_
$LN68@r_dsgraph_:

; 69   : 		size_t	PID	= size_t(parent-nodes);

	sub	edx, esi

; 70   : 		TNode*	N	= Alloc	(key);

	mov	ecx, edi
	sar	edx, 2
	push	ebx
	imul	esi, edx, -1227133513
	call	?Alloc@?$FixedMAP@PAUIDirect3DVertexShader9@@UmapMatrixPS@R_dsgraph@@Udoug_lea_allocator@@@@AAEPAUTNode@1@ABQAUIDirect3DVertexShader9@@@Z ; FixedMAP<IDirect3DVertexShader9 *,R_dsgraph::mapMatrixPS,doug_lea_allocator>::Alloc

; 147  : 					TNode* N = CreateChild(node,k);

	mov	edx, eax

; 71   : 		parent		= nodes+PID;

	lea	ecx, DWORD PTR [esi*8]

; 148  : 					node->right = N;

	mov	eax, DWORD PTR [edi]

; 71   : 		parent		= nodes+PID;

	sub	ecx, esi

; 148  : 					node->right = N;

	mov	DWORD PTR [eax+ecx*4+24], edx

; 149  : 					return N;

	jmp	SHORT $LN173@r_dsgraph_
$LN60@r_dsgraph_:

; 150  : 				}
; 151  : 			} else return node;
; 152  : 			
; 153  : 		} else {
; 154  : 			return Alloc(k);

	push	ebx
	mov	ecx, edi
	call	?Alloc@?$FixedMAP@PAUIDirect3DVertexShader9@@UmapMatrixPS@R_dsgraph@@Udoug_lea_allocator@@@@AAEPAUTNode@1@ABQAUIDirect3DVertexShader9@@@Z ; FixedMAP<IDirect3DVertexShader9 *,R_dsgraph::mapMatrixPS,doug_lea_allocator>::Alloc
	mov	edx, eax
$LN173@r_dsgraph_:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp

; 145  : 	mapMatrixPS::TNode*			Nps		= Nvs->val.insert	(pass.ps->ps);

	mov	DWORD PTR _Nvs$1$[esp+108], edx
$LN61@r_dsgraph_:
	mov	edi, DWORD PTR _pass$1$[esp+108]
	lea	ebx, DWORD PTR [edx+4]
	mov	edi, DWORD PTR [edi+12]
	add	edi, 12					; 0000000cH
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h

; 129  : 		if (pool) {

	cmp	DWORD PTR [ebx+4], 0
	je	SHORT $LN76@r_dsgraph_

; 130  : 			TNode*	node = nodes;

	mov	esi, DWORD PTR [ebx]
	mov	edx, esi

; 131  : 
; 132  : 			once_more:
; 133  : 			if (k < node->key) {

	mov	ecx, DWORD PTR [edi]
$LN174@r_dsgraph_:
	mov	DWORD PTR _Nps$1$[esp+108], edx
$once_more$184:
	cmp	ecx, DWORD PTR [edx]
	jae	SHORT $LN78@r_dsgraph_

; 134  : 				if (node->left) {

	mov	eax, DWORD PTR [edx+20]
	test	eax, eax
	je	SHORT $LN80@r_dsgraph_

; 135  : 					node = node->left;

	mov	edx, eax

; 136  : 					goto once_more;

	jmp	SHORT $LN174@r_dsgraph_
$LN78@r_dsgraph_:

; 141  : 				}
; 142  : 			} else if (k > node->key) {

	jbe	SHORT $LN77@r_dsgraph_

; 143  : 				if (node->right) {

	mov	eax, DWORD PTR [edx+24]
	test	eax, eax
	je	SHORT $LN84@r_dsgraph_

; 144  : 					node = node->right;

	mov	edx, eax

; 145  : 					goto once_more;

	jmp	SHORT $LN174@r_dsgraph_
$LN80@r_dsgraph_:

; 69   : 		size_t	PID	= size_t(parent-nodes);

	sub	edx, esi

; 70   : 		TNode*	N	= Alloc	(key);

	mov	ecx, ebx
	sar	edx, 2
	push	edi
	imul	esi, edx, -1227133513
	call	?Alloc@?$FixedMAP@PAUIDirect3DPixelShader9@@UmapMatrixCS@R_dsgraph@@Udoug_lea_allocator@@@@AAEPAUTNode@1@ABQAUIDirect3DPixelShader9@@@Z ; FixedMAP<IDirect3DPixelShader9 *,R_dsgraph::mapMatrixCS,doug_lea_allocator>::Alloc

; 138  : 					TNode* N = CreateChild(node,k);

	mov	edx, eax

; 71   : 		parent		= nodes+PID;

	lea	ecx, DWORD PTR [esi*8]

; 139  : 					node->left = N;

	mov	eax, DWORD PTR [ebx]

; 71   : 		parent		= nodes+PID;

	sub	ecx, esi

; 139  : 					node->left = N;

	mov	DWORD PTR [eax+ecx*4+20], edx

; 140  : 					return N;

	jmp	SHORT $LN175@r_dsgraph_
$LN84@r_dsgraph_:

; 69   : 		size_t	PID	= size_t(parent-nodes);

	sub	edx, esi

; 70   : 		TNode*	N	= Alloc	(key);

	mov	ecx, ebx
	sar	edx, 2
	push	edi
	imul	esi, edx, -1227133513
	call	?Alloc@?$FixedMAP@PAUIDirect3DPixelShader9@@UmapMatrixCS@R_dsgraph@@Udoug_lea_allocator@@@@AAEPAUTNode@1@ABQAUIDirect3DPixelShader9@@@Z ; FixedMAP<IDirect3DPixelShader9 *,R_dsgraph::mapMatrixCS,doug_lea_allocator>::Alloc

; 147  : 					TNode* N = CreateChild(node,k);

	mov	edx, eax

; 71   : 		parent		= nodes+PID;

	lea	ecx, DWORD PTR [esi*8]

; 148  : 					node->right = N;

	mov	eax, DWORD PTR [ebx]

; 71   : 		parent		= nodes+PID;

	sub	ecx, esi

; 148  : 					node->right = N;

	mov	DWORD PTR [eax+ecx*4+24], edx

; 149  : 					return N;

	jmp	SHORT $LN175@r_dsgraph_
$LN76@r_dsgraph_:

; 150  : 				}
; 151  : 			} else return node;
; 152  : 			
; 153  : 		} else {
; 154  : 			return Alloc(k);

	push	edi
	mov	ecx, ebx
	call	?Alloc@?$FixedMAP@PAUIDirect3DPixelShader9@@UmapMatrixCS@R_dsgraph@@Udoug_lea_allocator@@@@AAEPAUTNode@1@ABQAUIDirect3DPixelShader9@@@Z ; FixedMAP<IDirect3DPixelShader9 *,R_dsgraph::mapMatrixCS,doug_lea_allocator>::Alloc
	mov	edx, eax
$LN175@r_dsgraph_:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp

; 147  : 	mapMatrixCS::TNode*			Ncs		= Nps->val.insert	(pass.constants._get());

	mov	DWORD PTR _Nps$1$[esp+108], edx
$LN77@r_dsgraph_:
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h

; 129  : 		if (pool) {

	cmp	DWORD PTR [edx+8], 0
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp

; 147  : 	mapMatrixCS::TNode*			Ncs		= Nps->val.insert	(pass.constants._get());

	lea	ebx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR _pass$1$[esp+108]
	mov	ecx, DWORD PTR [eax+20]
	mov	DWORD PTR $T2[esp+104], ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h

; 129  : 		if (pool) {

	je	SHORT $LN92@r_dsgraph_

; 130  : 			TNode*	node = nodes;

	mov	edx, DWORD PTR [ebx]
	mov	edi, edx
$LN176@r_dsgraph_:

; 131  : 
; 132  : 			once_more:
; 133  : 			if (k < node->key) {

	mov	DWORD PTR _Ncs$1$[esp+104], edi
$once_more$185:
	cmp	ecx, DWORD PTR [edi]
	jae	SHORT $LN94@r_dsgraph_

; 134  : 				if (node->left) {

	mov	eax, DWORD PTR [edi+20]
	test	eax, eax
	je	SHORT $LN96@r_dsgraph_

; 135  : 					node = node->left;

	mov	edi, eax

; 136  : 					goto once_more;

	jmp	SHORT $LN176@r_dsgraph_
$LN94@r_dsgraph_:

; 141  : 				}
; 142  : 			} else if (k > node->key) {

	jbe	SHORT $LN93@r_dsgraph_

; 143  : 				if (node->right) {

	mov	eax, DWORD PTR [edi+24]
	test	eax, eax
	je	SHORT $LN100@r_dsgraph_

; 144  : 					node = node->right;

	mov	edi, eax
	mov	DWORD PTR _Ncs$1$[esp+104], eax

; 145  : 					goto once_more;

	jmp	SHORT $once_more$185
$LN96@r_dsgraph_:

; 69   : 		size_t	PID	= size_t(parent-nodes);

	sub	edi, edx

; 70   : 		TNode*	N	= Alloc	(key);

	lea	eax, DWORD PTR $T2[esp+104]
	sar	edi, 2
	mov	ecx, ebx
	push	eax
	imul	esi, edi, -1227133513
	call	?Alloc@?$FixedMAP@PAVR_constant_table@@UmapMatrixStates@R_dsgraph@@Udoug_lea_allocator@@@@AAEPAUTNode@1@ABQAVR_constant_table@@@Z ; FixedMAP<R_constant_table *,R_dsgraph::mapMatrixStates,doug_lea_allocator>::Alloc

; 138  : 					TNode* N = CreateChild(node,k);

	mov	edi, eax

; 71   : 		parent		= nodes+PID;

	lea	ecx, DWORD PTR [esi*8]

; 139  : 					node->left = N;

	mov	eax, DWORD PTR [ebx]

; 71   : 		parent		= nodes+PID;

	sub	ecx, esi

; 139  : 					node->left = N;

	mov	DWORD PTR [eax+ecx*4+20], edi

; 140  : 					return N;

	jmp	SHORT $LN177@r_dsgraph_
$LN100@r_dsgraph_:

; 69   : 		size_t	PID	= size_t(parent-nodes);

	sub	edi, edx

; 70   : 		TNode*	N	= Alloc	(key);

	lea	eax, DWORD PTR $T2[esp+104]
	sar	edi, 2
	mov	ecx, ebx
	push	eax
	imul	esi, edi, -1227133513
	call	?Alloc@?$FixedMAP@PAVR_constant_table@@UmapMatrixStates@R_dsgraph@@Udoug_lea_allocator@@@@AAEPAUTNode@1@ABQAVR_constant_table@@@Z ; FixedMAP<R_constant_table *,R_dsgraph::mapMatrixStates,doug_lea_allocator>::Alloc

; 147  : 					TNode* N = CreateChild(node,k);

	mov	edi, eax

; 71   : 		parent		= nodes+PID;

	lea	ecx, DWORD PTR [esi*8]

; 148  : 					node->right = N;

	mov	eax, DWORD PTR [ebx]

; 71   : 		parent		= nodes+PID;

	sub	ecx, esi

; 148  : 					node->right = N;

	mov	DWORD PTR [eax+ecx*4+24], edi

; 149  : 					return N;

	jmp	SHORT $LN177@r_dsgraph_
$LN92@r_dsgraph_:

; 150  : 				}
; 151  : 			} else return node;
; 152  : 			
; 153  : 		} else {
; 154  : 			return Alloc(k);

	lea	eax, DWORD PTR $T2[esp+104]
	mov	ecx, ebx
	push	eax
	call	?Alloc@?$FixedMAP@PAVR_constant_table@@UmapMatrixStates@R_dsgraph@@Udoug_lea_allocator@@@@AAEPAUTNode@1@ABQAVR_constant_table@@@Z ; FixedMAP<R_constant_table *,R_dsgraph::mapMatrixStates,doug_lea_allocator>::Alloc
	mov	edi, eax
$LN177@r_dsgraph_:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp

; 148  : 	mapMatrixStates::TNode*		Nstate	= Ncs->val.insert	(pass.state->state);

	mov	DWORD PTR _Ncs$1$[esp+104], edi
$LN93@r_dsgraph_:
	mov	eax, DWORD PTR _pass$1$[esp+108]
	mov	ebx, DWORD PTR [eax+8]
	add	ebx, 8
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h

; 129  : 		if (pool) {

	cmp	DWORD PTR [edi+8], 0
	je	SHORT $LN108@r_dsgraph_

; 130  : 			TNode*	node = nodes;

	mov	esi, DWORD PTR [edi+4]
	mov	edx, esi

; 131  : 
; 132  : 			once_more:
; 133  : 			if (k < node->key) {

	mov	ecx, DWORD PTR [ebx]
$LN178@r_dsgraph_:
	mov	DWORD PTR _Nstate$1$[esp+104], edx
$once_more$186:
	cmp	ecx, DWORD PTR [edx]
	jae	SHORT $LN110@r_dsgraph_

; 134  : 				if (node->left) {

	mov	eax, DWORD PTR [edx+20]
	test	eax, eax
	je	SHORT $LN112@r_dsgraph_

; 135  : 					node = node->left;

	mov	edx, eax

; 136  : 					goto once_more;

	jmp	SHORT $LN178@r_dsgraph_
$LN110@r_dsgraph_:

; 141  : 				}
; 142  : 			} else if (k > node->key) {

	jbe	SHORT $LN109@r_dsgraph_

; 143  : 				if (node->right) {

	mov	eax, DWORD PTR [edx+24]
	test	eax, eax
	je	SHORT $LN116@r_dsgraph_

; 144  : 					node = node->right;

	mov	edx, eax

; 145  : 					goto once_more;

	jmp	SHORT $LN178@r_dsgraph_
$LN112@r_dsgraph_:

; 69   : 		size_t	PID	= size_t(parent-nodes);

	sub	edx, esi

; 70   : 		TNode*	N	= Alloc	(key);

	lea	ecx, DWORD PTR [edi+4]
	sar	edx, 2
	push	ebx
	imul	esi, edx, -1227133513
	call	?Alloc@?$FixedMAP@PAUIDirect3DStateBlock9@@UmapMatrixTextures@R_dsgraph@@Udoug_lea_allocator@@@@AAEPAUTNode@1@ABQAUIDirect3DStateBlock9@@@Z ; FixedMAP<IDirect3DStateBlock9 *,R_dsgraph::mapMatrixTextures,doug_lea_allocator>::Alloc

; 138  : 					TNode* N = CreateChild(node,k);

	mov	edx, eax

; 71   : 		parent		= nodes+PID;

	lea	ecx, DWORD PTR [esi*8]

; 139  : 					node->left = N;

	mov	eax, DWORD PTR [edi+4]

; 71   : 		parent		= nodes+PID;

	sub	ecx, esi

; 139  : 					node->left = N;

	mov	DWORD PTR [eax+ecx*4+20], edx

; 140  : 					return N;

	jmp	SHORT $LN179@r_dsgraph_
$LN116@r_dsgraph_:

; 69   : 		size_t	PID	= size_t(parent-nodes);

	sub	edx, esi

; 70   : 		TNode*	N	= Alloc	(key);

	lea	ecx, DWORD PTR [edi+4]
	sar	edx, 2
	push	ebx
	imul	esi, edx, -1227133513
	call	?Alloc@?$FixedMAP@PAUIDirect3DStateBlock9@@UmapMatrixTextures@R_dsgraph@@Udoug_lea_allocator@@@@AAEPAUTNode@1@ABQAUIDirect3DStateBlock9@@@Z ; FixedMAP<IDirect3DStateBlock9 *,R_dsgraph::mapMatrixTextures,doug_lea_allocator>::Alloc

; 147  : 					TNode* N = CreateChild(node,k);

	mov	edx, eax

; 71   : 		parent		= nodes+PID;

	lea	ecx, DWORD PTR [esi*8]

; 148  : 					node->right = N;

	mov	eax, DWORD PTR [edi+4]

; 71   : 		parent		= nodes+PID;

	sub	ecx, esi

; 148  : 					node->right = N;

	mov	DWORD PTR [eax+ecx*4+24], edx

; 149  : 					return N;

	jmp	SHORT $LN179@r_dsgraph_
$LN108@r_dsgraph_:

; 150  : 				}
; 151  : 			} else return node;
; 152  : 			
; 153  : 		} else {
; 154  : 			return Alloc(k);

	push	ebx
	lea	ecx, DWORD PTR [edi+4]
	call	?Alloc@?$FixedMAP@PAUIDirect3DStateBlock9@@UmapMatrixTextures@R_dsgraph@@Udoug_lea_allocator@@@@AAEPAUTNode@1@ABQAUIDirect3DStateBlock9@@@Z ; FixedMAP<IDirect3DStateBlock9 *,R_dsgraph::mapMatrixTextures,doug_lea_allocator>::Alloc
	mov	edx, eax
$LN179@r_dsgraph_:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp

; 149  : 	mapMatrixTextures::TNode*	Ntex	= Nstate->val.insert(pass.T._get());

	mov	DWORD PTR _Nstate$1$[esp+104], edx
$LN109@r_dsgraph_:
	mov	eax, DWORD PTR _pass$1$[esp+108]
	add	edx, 4
	mov	DWORD PTR _this$1$[esp+108], edx
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h

; 129  : 		if (pool) {

	cmp	DWORD PTR [edx+4], 0
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp

; 149  : 	mapMatrixTextures::TNode*	Ntex	= Nstate->val.insert(pass.T._get());

	mov	ecx, DWORD PTR [eax+24]
	mov	DWORD PTR $T1[esp+108], ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h

; 129  : 		if (pool) {

	je	SHORT $LN124@r_dsgraph_

; 130  : 			TNode*	node = nodes;

	mov	esi, DWORD PTR [edx]
	mov	ebx, esi
	npad	3
$once_more$187:

; 131  : 
; 132  : 			once_more:
; 133  : 			if (k < node->key) {

	cmp	ecx, DWORD PTR [ebx]
	jae	SHORT $LN126@r_dsgraph_

; 134  : 				if (node->left) {

	mov	eax, DWORD PTR [ebx+20]
	test	eax, eax
	je	SHORT $LN128@r_dsgraph_

; 135  : 					node = node->left;

	mov	ebx, eax

; 136  : 					goto once_more;

	jmp	SHORT $once_more$187
$LN126@r_dsgraph_:

; 141  : 				}
; 142  : 			} else if (k > node->key) {

	jbe	SHORT $LN125@r_dsgraph_

; 143  : 				if (node->right) {

	mov	eax, DWORD PTR [ebx+24]
	test	eax, eax
	je	SHORT $LN132@r_dsgraph_

; 144  : 					node = node->right;

	mov	ebx, eax

; 145  : 					goto once_more;

	jmp	SHORT $once_more$187
$LN128@r_dsgraph_:

; 69   : 		size_t	PID	= size_t(parent-nodes);

	sub	ebx, esi

; 70   : 		TNode*	N	= Alloc	(key);

	lea	eax, DWORD PTR $T1[esp+108]
	sar	ebx, 2
	mov	ecx, edx
	push	eax
	imul	esi, ebx, -1227133513
	call	?Alloc@?$FixedMAP@PAUSTextureList@@UmapMatrixItems@R_dsgraph@@Udoug_lea_allocator@@@@AAEPAUTNode@1@ABQAUSTextureList@@@Z ; FixedMAP<STextureList *,R_dsgraph::mapMatrixItems,doug_lea_allocator>::Alloc

; 138  : 					TNode* N = CreateChild(node,k);

	mov	ebx, eax

; 71   : 		parent		= nodes+PID;

	lea	ecx, DWORD PTR [esi*8]

; 139  : 					node->left = N;

	mov	eax, DWORD PTR _this$1$[esp+108]

; 71   : 		parent		= nodes+PID;

	sub	ecx, esi

; 139  : 					node->left = N;

	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [eax+ecx*4+20], ebx

; 140  : 					return N;

	jmp	SHORT $LN125@r_dsgraph_
$LN132@r_dsgraph_:

; 69   : 		size_t	PID	= size_t(parent-nodes);

	sub	ebx, esi

; 70   : 		TNode*	N	= Alloc	(key);

	lea	eax, DWORD PTR $T1[esp+108]
	sar	ebx, 2
	mov	ecx, edx
	push	eax
	imul	esi, ebx, -1227133513
	call	?Alloc@?$FixedMAP@PAUSTextureList@@UmapMatrixItems@R_dsgraph@@Udoug_lea_allocator@@@@AAEPAUTNode@1@ABQAUSTextureList@@@Z ; FixedMAP<STextureList *,R_dsgraph::mapMatrixItems,doug_lea_allocator>::Alloc

; 147  : 					TNode* N = CreateChild(node,k);

	mov	ebx, eax

; 71   : 		parent		= nodes+PID;

	lea	ecx, DWORD PTR [esi*8]

; 148  : 					node->right = N;

	mov	eax, DWORD PTR _this$1$[esp+108]

; 71   : 		parent		= nodes+PID;

	sub	ecx, esi

; 148  : 					node->right = N;

	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [eax+ecx*4+24], ebx

; 149  : 					return N;

	jmp	SHORT $LN125@r_dsgraph_
$LN124@r_dsgraph_:

; 150  : 				}
; 151  : 			} else return node;
; 152  : 			
; 153  : 		} else {
; 154  : 			return Alloc(k);

	lea	eax, DWORD PTR $T1[esp+108]
	mov	ecx, edx
	push	eax
	call	?Alloc@?$FixedMAP@PAUSTextureList@@UmapMatrixItems@R_dsgraph@@Udoug_lea_allocator@@@@AAEPAUTNode@1@ABQAUSTextureList@@@Z ; FixedMAP<STextureList *,R_dsgraph::mapMatrixItems,doug_lea_allocator>::Alloc
	mov	ebx, eax
$LN125@r_dsgraph_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 730  :         if (_Mylast != _My_data._Myend) {

	mov	edx, DWORD PTR [ebx+8]
	cmp	edx, DWORD PTR [ebx+12]
	je	SHORT $LN142@r_dsgraph_
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h

; 37   : 								void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	ecx, 19					; 00000013H
	lea	esi, DWORD PTR _item$[esp+108]
	mov	edi, edx
	rep movsd
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 716  :         ++_Mylast;

	add	DWORD PTR [ebx+8], 76			; 0000004cH

; 731  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

	mov	edi, DWORD PTR _Ncs$1$[esp+104]
	jmp	SHORT $LN141@r_dsgraph_
$LN142@r_dsgraph_:

; 732  :         }
; 733  : 
; 734  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	lea	ecx, DWORD PTR _item$[esp+108]
	push	ecx
	push	edx
	lea	ecx, DWORD PTR [ebx+4]
	call	??$_Emplace_reallocate@ABU_MatrixItem@R_dsgraph@@@?$vector@U_MatrixItem@R_dsgraph@@V?$doug_lea_alloc@U_MatrixItem@R_dsgraph@@@@@std@@QAEPAU_MatrixItem@R_dsgraph@@QAU23@ABU23@@Z ; std::vector<R_dsgraph::_MatrixItem,doug_lea_alloc<R_dsgraph::_MatrixItem> >::_Emplace_reallocate<R_dsgraph::_MatrixItem const &>
$LN141@r_dsgraph_:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp

; 154  : 	if (SSA>Ntex->val.ssa)		{ Ntex->val.ssa = SSA;

	movss	xmm0, DWORD PTR _SSA$1$[esp+108]
	comiss	xmm0, DWORD PTR [ebx+16]
	jbe	SHORT $LN170@r_dsgraph_

; 155  : 	if (SSA>Nstate->val.ssa)	{ Nstate->val.ssa = SSA;

	mov	eax, DWORD PTR _Nstate$1$[esp+104]
	movss	DWORD PTR [ebx+16], xmm0
	comiss	xmm0, DWORD PTR [eax+16]
	jbe	SHORT $LN170@r_dsgraph_
	movss	DWORD PTR [eax+16], xmm0

; 156  : 	if (SSA>Ncs->val.ssa)		{ Ncs->val.ssa = SSA;

	comiss	xmm0, DWORD PTR [edi+16]
	jbe	SHORT $LN170@r_dsgraph_

; 157  : 	if (SSA>Nps->val.ssa)		{ Nps->val.ssa = SSA;

	mov	eax, DWORD PTR _Nps$1$[esp+108]
	movss	DWORD PTR [edi+16], xmm0
	comiss	xmm0, DWORD PTR [eax+16]
	jbe	SHORT $LN170@r_dsgraph_
	movss	DWORD PTR [eax+16], xmm0

; 158  : 	if (SSA>Nvs->val.ssa)		{ Nvs->val.ssa = SSA;

	mov	eax, DWORD PTR _Nvs$1$[esp+108]
	comiss	xmm0, DWORD PTR [eax+16]
	jbe	SHORT $LN170@r_dsgraph_
	movss	DWORD PTR [eax+16], xmm0
$LN170@r_dsgraph_:
	pop	esi
$LN20@r_dsgraph_:
	pop	edi

; 159  : 	} } } } }
; 160  : 
; 161  : #if RENDER==R_R2
; 162  : 	if (val_recorder)			{
; 163  : 		Fbox3		temp		;
; 164  : 		Fmatrix&	xf			= *RI.val_pTransform;
; 165  : 		temp.xform	(pVisual->vis.box,xf);
; 166  : 		val_recorder->push_back	(temp);
; 167  : 	}
; 168  : #endif
; 169  : }

	pop	ebx
	add	esp, 96					; 00000060H
	ret	8
?r_dsgraph_insert_dynamic@R_dsgraph_structure@@QAEXPAVIRender_Visual@@AAU?$_vector3@M@@@Z ENDP ; R_dsgraph_structure::r_dsgraph_insert_dynamic
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp
_TEXT	SEGMENT
_Nstate$1$ = -28					; size = 4
$T1 = -28						; size = 4
_Nps$1$ = -24						; size = 4
_Nvs$1$ = -20						; size = 4
_sh$1$ = -20						; size = 4
_pass$1$ = -16						; size = 4
$T2 = -16						; size = 4
_distSQ$ = -16						; size = 4
_SSA$1$ = -12						; size = 4
_this$1$ = -8						; size = 4
_item$ = -8						; size = 8
_pVisual$ = 8						; size = 4
?r_dsgraph_insert_static@R_dsgraph_structure@@QAEXPAVIRender_Visual@@@Z PROC ; R_dsgraph_structure::r_dsgraph_insert_static
; _this$ = ecx

; 172  : {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H

; 173  : 	CRender&	RI				=	RImplementation;
; 174  : 
; 175  : 	if (pVisual->vis.marker		==	RI.marker)	return	;

	mov	eax, DWORD PTR ?RImplementation@@3VCRender@@A+296
	sub	esp, 28					; 0000001cH
	push	ebx
	push	esi
	push	edi
	mov	edi, DWORD PTR _pVisual$[ebp]
	mov	ebx, ecx
	cmp	DWORD PTR [edi+48], eax
	je	$LN17@r_dsgraph_

; 176  : 	pVisual->vis.marker			=	RI.marker			;

	mov	DWORD PTR [edi+48], eax

; 177  : 
; 178  : #if RENDER==R_R1
; 179  : 	if (RI.o.vis_intersect &&	(pVisual->vis.accept_frame!=Device.dwFrame))	return;

	test	BYTE PTR ?RImplementation@@3VCRender@@A+628, 1
	mov	ecx, DWORD PTR __imp_?Device@@3VCRenderDevice@@A
	je	SHORT $LN6@r_dsgraph_
	mov	eax, DWORD PTR [edi+52]
	cmp	eax, DWORD PTR [ecx+244]
	jne	$LN17@r_dsgraph_
$LN6@r_dsgraph_:

; 180  : 	pVisual->vis.accept_frame	=	Device.dwFrame		;

	mov	eax, DWORD PTR [ecx+244]
	mov	DWORD PTR [edi+52], eax

; 26   : 	distSQ	= Device.vCameraPosition.distance_to_sqr(C)+EPS;

	mov	eax, DWORD PTR __imp_?Device@@3VCRenderDevice@@A
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 287  : 	{	return (x-v.x)*(x-v.x) + (y-v.y)*(y-v.y) + (z-v.z)*(z-v.z);	}

	movss	xmm1, DWORD PTR [eax+492]
	movss	xmm0, DWORD PTR [eax+496]
	subss	xmm1, DWORD PTR [edi+12]
	movss	xmm2, DWORD PTR [eax+488]
	subss	xmm2, DWORD PTR [edi+8]
	subss	xmm0, DWORD PTR [edi+16]
	mulss	xmm1, xmm1
	mulss	xmm2, xmm2
	mulss	xmm0, xmm0
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp

; 26   : 	distSQ	= Device.vCameraPosition.distance_to_sqr(C)+EPS;

	addss	xmm2, xmm1

; 27   : 	return	R/distSQ;

	movss	xmm1, DWORD PTR [edi+20]
	addss	xmm0, DWORD PTR __real@3727c5ac
	addss	xmm2, xmm0

; 181  : #endif
; 182  : 
; 183  : 	float distSQ;
; 184  : 	float SSA					=	CalcSSA		(distSQ,pVisual->vis.sphere.P,pVisual);
; 185  : 	if (SSA<=r_ssaDISCARD)		return;

	movss	xmm0, DWORD PTR ?r_ssaDISCARD@@3MA

; 27   : 	return	R/distSQ;

	divss	xmm1, xmm2
	movss	DWORD PTR _distSQ$[esp+40], xmm2

; 181  : #endif
; 182  : 
; 183  : 	float distSQ;
; 184  : 	float SSA					=	CalcSSA		(distSQ,pVisual->vis.sphere.P,pVisual);
; 185  : 	if (SSA<=r_ssaDISCARD)		return;

	comiss	xmm0, xmm1

; 27   : 	return	R/distSQ;

	movss	DWORD PTR _SSA$1$[esp+40], xmm1

; 181  : #endif
; 182  : 
; 183  : 	float distSQ;
; 184  : 	float SSA					=	CalcSSA		(distSQ,pVisual->vis.sphere.P,pVisual);
; 185  : 	if (SSA<=r_ssaDISCARD)		return;

	jae	$LN17@r_dsgraph_

; 186  : 
; 187  : 	// Distortive geometry should be marked and R2 special-cases it
; 188  : 	// a) Allow to optimize RT order
; 189  : 	// b) Should be rendered to special distort buffer in another pass
; 190  : 	VERIFY						(pVisual->shader._get());
; 191  : 	ShaderElement*		sh_d	= &*pVisual->shader->E[4];
; 192  : 	if (RImplementation.o.distortion && sh_d && sh_d->flags.bDistort && pmask[sh_d->flags.iPriority/2]) {

	test	BYTE PTR ?RImplementation@@3VCRender@@A+628, 2
	mov	eax, DWORD PTR [edi+64]
	mov	eax, DWORD PTR [eax+24]
	je	SHORT $LN8@r_dsgraph_
	test	eax, eax
	je	SHORT $LN8@r_dsgraph_
	mov	eax, DWORD PTR [eax+8]
	test	al, 16					; 00000010H
	je	SHORT $LN8@r_dsgraph_
	shr	eax, 1
	and	eax, 1
	cmp	BYTE PTR [eax+ebx+300], 0
	je	SHORT $LN8@r_dsgraph_

; 193  : 		mapSorted_Node* N		= mapDistort.insertInAnyWay		(distSQ);

	lea	eax, DWORD PTR _distSQ$[esp+40]
	push	eax
	lea	ecx, DWORD PTR [ebx+388]
	call	?insertInAnyWay@?$FixedMAP@MU_MatrixItemS@R_dsgraph@@Udoug_lea_allocator@@@@QAEPAUTNode@1@ABM@Z ; FixedMAP<float,R_dsgraph::_MatrixItemS,doug_lea_allocator>::insertInAnyWay

; 194  : 		N->val.ssa				= SSA;

	movss	xmm0, DWORD PTR _SSA$1$[esp+40]
	mov	edx, eax

; 195  : 		N->val.pObject			= NULL;
; 196  : 		N->val.pVisual			= pVisual;
; 197  : 		N->val.Matrix			= Fidentity;
; 198  : 		N->val.se				= &*pVisual->shader->E[4];		// 4=L_special

	movss	xmm2, DWORD PTR _distSQ$[esp+40]
	mov	ecx, 16					; 00000010H
	mov	DWORD PTR [edx+12], edi
	lea	edi, DWORD PTR [edx+16]
	movss	DWORD PTR [edx+4], xmm0
	mov	DWORD PTR [edx+8], 0
	mov	esi, DWORD PTR __imp_?Fidentity@@3U?$_matrix@M@@A
	rep movsd
	mov	edi, DWORD PTR _pVisual$[ebp]
	mov	eax, DWORD PTR [edi+64]
	mov	eax, DWORD PTR [eax+24]
	mov	DWORD PTR [edx+80], eax
$LN8@r_dsgraph_:
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp

; 36   : 	switch (phase)		{

	mov	eax, DWORD PTR ?RImplementation@@3VCRender@@A+292
	sub	eax, 0
	je	SHORT $LN26@r_dsgraph_
	sub	eax, 1
	mov	eax, DWORD PTR [edi+64]
	je	SHORT $LN27@r_dsgraph_

; 39   : 	case PHASE_SPOT:	return pVisual->shader->E[SE_R1_LSPOT]._get();

	mov	esi, DWORD PTR [eax+20]
	jmp	SHORT $LN145@r_dsgraph_
$LN27@r_dsgraph_:

; 38   : 	case PHASE_POINT:	return pVisual->shader->E[SE_R1_LPOINT]._get();

	mov	esi, DWORD PTR [eax+16]
	jmp	SHORT $LN145@r_dsgraph_
$LN26@r_dsgraph_:
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h

; 764  :             return (float)sqrt(_X);

	sqrtss	xmm1, xmm2
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp

; 37   : 	case PHASE_NORMAL:	return (((_sqrt(cdist_sq) - pVisual->vis.sphere.R)<44)?pVisual->shader->E[SE_R1_NORMAL_HQ]:pVisual->shader->E[SE_R1_NORMAL_LQ])._get();

	mov	edx, 8
	mov	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR [edi+64]
	movss	xmm0, DWORD PTR __real@42300000
	subss	xmm1, DWORD PTR [edi+20]
	comiss	xmm0, xmm1
	cmova	eax, edx
	mov	esi, DWORD PTR [ecx+eax]
$LN145@r_dsgraph_:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp

; 203  : 	if (0==sh)								return;

	mov	DWORD PTR _sh$1$[esp+40], esi
	test	esi, esi
	je	$LN17@r_dsgraph_

; 204  : 	if (!pmask[sh->flags.iPriority/2])		return;

	mov	ecx, DWORD PTR [esi+8]
	mov	eax, ecx
	shr	eax, 1
	and	eax, 1
	cmp	BYTE PTR [eax+ebx+300], 0
	je	$LN17@r_dsgraph_

; 205  : 
; 206  : 	// strict-sorting selection
; 207  : 	if (sh->flags.bStrictB2F) {

	test	cl, 4
	je	SHORT $LN11@r_dsgraph_

; 208  : 		mapSorted_Node* N			= mapSorted.insertInAnyWay(distSQ);

	lea	eax, DWORD PTR _distSQ$[esp+40]
	push	eax
	lea	ecx, DWORD PTR [ebx+352]
	call	?insertInAnyWay@?$FixedMAP@MU_MatrixItemS@R_dsgraph@@Udoug_lea_allocator@@@@QAEPAUTNode@1@ABM@Z ; FixedMAP<float,R_dsgraph::_MatrixItemS,doug_lea_allocator>::insertInAnyWay

; 209  : 		N->val.pObject				= NULL;
; 210  : 		N->val.pVisual				= pVisual;
; 211  : 		N->val.Matrix				= Fidentity;

	mov	ecx, 16					; 00000010H
	mov	DWORD PTR [eax+12], edi
	lea	edi, DWORD PTR [eax+16]
	mov	DWORD PTR [eax+8], 0
	mov	esi, DWORD PTR __imp_?Fidentity@@3U?$_matrix@M@@A
	rep movsd

; 212  : 		N->val.se					= sh;

	mov	ecx, DWORD PTR _sh$1$[esp+40]
	mov	DWORD PTR [eax+80], ecx

; 266  : 	} } } } }
; 267  : 
; 268  : #if RENDER==R_R2
; 269  : 	if (val_recorder)			{
; 270  : 		val_recorder->push_back	(pVisual->vis.box	);
; 271  : 	}
; 272  : #endif
; 273  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
$LN11@r_dsgraph_:

; 213  : 		return;
; 214  : 	}
; 215  : 
; 216  : #if RENDER==R_R2
; 217  : 	// Emissive geometry should be marked and R2 special-cases it
; 218  : 	// a) Allow to skeep already lit pixels
; 219  : 	// b) Allow to make them 100% lit and really bright
; 220  : 	// c) Should not cast shadows
; 221  : 	// d) Should be rendered to accumulation buffer in the second pass
; 222  : 	if (sh->flags.bEmissive) {
; 223  : 		mapSorted_Node* N		= mapEmissive.insertInAnyWay	(distSQ);
; 224  : 		N->val.ssa				= SSA;
; 225  : 		N->val.pObject			= NULL;
; 226  : 		N->val.pVisual			= pVisual;
; 227  : 		N->val.Matrix			= Fidentity;
; 228  : 		N->val.se				= &*pVisual->shader->E[4];		// 4=L_special
; 229  : 	}
; 230  : 	if (sh->flags.bWmark	&& pmask_wmark)	{
; 231  : 		mapSorted_Node* N		= mapWmark.insertInAnyWay		(distSQ);
; 232  : 		N->val.ssa				= SSA;
; 233  : 		N->val.pObject			= NULL;
; 234  : 		N->val.pVisual			= pVisual;
; 235  : 		N->val.Matrix			= Fidentity;
; 236  : 		N->val.se				= sh;							
; 237  : 		return					;
; 238  : 	}
; 239  : #endif
; 240  : 
; 241  : 	if	(val_feedback && counter_S==val_feedback_breakp)	val_feedback->rfeedback_static(pVisual);

	mov	ecx, DWORD PTR [ebx+280]
	test	ecx, ecx
	je	SHORT $LN12@r_dsgraph_
	mov	eax, DWORD PTR [ebx+616]
	cmp	eax, DWORD PTR [ebx+284]
	jne	SHORT $LN12@r_dsgraph_
	mov	eax, DWORD PTR [ecx]
	push	edi
	call	DWORD PTR [eax]
$LN12@r_dsgraph_:

; 242  : 
; 243  : 	counter_S					++;

	inc	DWORD PTR [ebx+616]

; 244  : 	SPass&						pass	= *sh->passes.front	();
; 245  : 	mapNormal_T&				map		= mapNormal			[sh->flags.iPriority/2];

	mov	eax, DWORD PTR [esi+8]
	mov	ecx, DWORD PTR [esi+12]
	shr	eax, 1
	and	eax, 1
	mov	DWORD PTR _pass$1$[esp+40], ecx
	lea	edi, DWORD PTR [eax+38]
	lea	edi, DWORD PTR [eax+edi*2]
	lea	edi, DWORD PTR [ebx+edi*4]

; 246  : #ifdef USE_RESOURCE_DEBUGGER
; 247  : 	mapNormalVS::TNode*			Nvs		= map.insert		(pass.vs);
; 248  : 	mapNormalPS::TNode*			Nps		= Nvs->val.insert	(pass.ps);
; 249  : #else
; 250  : 	mapNormalVS::TNode*			Nvs		= map.insert		(pass.vs->vs);

	mov	ebx, DWORD PTR [ecx+16]
	add	ebx, 12					; 0000000cH
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h

; 129  : 		if (pool) {

	cmp	DWORD PTR [edi+4], 0
	je	SHORT $LN39@r_dsgraph_

; 130  : 			TNode*	node = nodes;

	mov	esi, DWORD PTR [edi]
	mov	edx, esi

; 131  : 
; 132  : 			once_more:
; 133  : 			if (k < node->key) {

	mov	ecx, DWORD PTR [ebx]
$LN146@r_dsgraph_:
	mov	DWORD PTR _Nvs$1$[esp+40], edx
$once_more$153:
	cmp	ecx, DWORD PTR [edx]
	jae	SHORT $LN41@r_dsgraph_

; 134  : 				if (node->left) {

	mov	eax, DWORD PTR [edx+20]
	test	eax, eax
	je	SHORT $LN43@r_dsgraph_

; 135  : 					node = node->left;

	mov	edx, eax

; 136  : 					goto once_more;

	jmp	SHORT $LN146@r_dsgraph_
$LN41@r_dsgraph_:

; 141  : 				}
; 142  : 			} else if (k > node->key) {

	jbe	SHORT $LN40@r_dsgraph_

; 143  : 				if (node->right) {

	mov	eax, DWORD PTR [edx+24]
	test	eax, eax
	je	SHORT $LN47@r_dsgraph_

; 144  : 					node = node->right;

	mov	edx, eax

; 145  : 					goto once_more;

	jmp	SHORT $LN146@r_dsgraph_
$LN43@r_dsgraph_:

; 69   : 		size_t	PID	= size_t(parent-nodes);

	sub	edx, esi

; 70   : 		TNode*	N	= Alloc	(key);

	mov	ecx, edi
	sar	edx, 2
	push	ebx
	imul	esi, edx, -1227133513
	call	?Alloc@?$FixedMAP@PAUIDirect3DVertexShader9@@UmapNormalPS@R_dsgraph@@Udoug_lea_allocator@@@@AAEPAUTNode@1@ABQAUIDirect3DVertexShader9@@@Z ; FixedMAP<IDirect3DVertexShader9 *,R_dsgraph::mapNormalPS,doug_lea_allocator>::Alloc

; 138  : 					TNode* N = CreateChild(node,k);

	mov	edx, eax

; 71   : 		parent		= nodes+PID;

	lea	ecx, DWORD PTR [esi*8]

; 139  : 					node->left = N;

	mov	eax, DWORD PTR [edi]

; 71   : 		parent		= nodes+PID;

	sub	ecx, esi

; 139  : 					node->left = N;

	mov	DWORD PTR [eax+ecx*4+20], edx

; 140  : 					return N;

	jmp	SHORT $LN147@r_dsgraph_
$LN47@r_dsgraph_:

; 69   : 		size_t	PID	= size_t(parent-nodes);

	sub	edx, esi

; 70   : 		TNode*	N	= Alloc	(key);

	mov	ecx, edi
	sar	edx, 2
	push	ebx
	imul	esi, edx, -1227133513
	call	?Alloc@?$FixedMAP@PAUIDirect3DVertexShader9@@UmapNormalPS@R_dsgraph@@Udoug_lea_allocator@@@@AAEPAUTNode@1@ABQAUIDirect3DVertexShader9@@@Z ; FixedMAP<IDirect3DVertexShader9 *,R_dsgraph::mapNormalPS,doug_lea_allocator>::Alloc

; 147  : 					TNode* N = CreateChild(node,k);

	mov	edx, eax

; 71   : 		parent		= nodes+PID;

	lea	ecx, DWORD PTR [esi*8]

; 148  : 					node->right = N;

	mov	eax, DWORD PTR [edi]

; 71   : 		parent		= nodes+PID;

	sub	ecx, esi

; 148  : 					node->right = N;

	mov	DWORD PTR [eax+ecx*4+24], edx

; 149  : 					return N;

	jmp	SHORT $LN147@r_dsgraph_
$LN39@r_dsgraph_:

; 150  : 				}
; 151  : 			} else return node;
; 152  : 			
; 153  : 		} else {
; 154  : 			return Alloc(k);

	push	ebx
	mov	ecx, edi
	call	?Alloc@?$FixedMAP@PAUIDirect3DVertexShader9@@UmapNormalPS@R_dsgraph@@Udoug_lea_allocator@@@@AAEPAUTNode@1@ABQAUIDirect3DVertexShader9@@@Z ; FixedMAP<IDirect3DVertexShader9 *,R_dsgraph::mapNormalPS,doug_lea_allocator>::Alloc
	mov	edx, eax
$LN147@r_dsgraph_:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp

; 251  : 	mapNormalPS::TNode*			Nps		= Nvs->val.insert	(pass.ps->ps);

	mov	DWORD PTR _Nvs$1$[esp+40], edx
$LN40@r_dsgraph_:
	mov	edi, DWORD PTR _pass$1$[esp+40]
	lea	ebx, DWORD PTR [edx+4]
	mov	edi, DWORD PTR [edi+12]
	add	edi, 12					; 0000000cH
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h

; 129  : 		if (pool) {

	cmp	DWORD PTR [ebx+4], 0
	je	SHORT $LN55@r_dsgraph_

; 130  : 			TNode*	node = nodes;

	mov	esi, DWORD PTR [ebx]
	mov	edx, esi

; 131  : 
; 132  : 			once_more:
; 133  : 			if (k < node->key) {

	mov	ecx, DWORD PTR [edi]
$LN148@r_dsgraph_:
	mov	DWORD PTR _Nps$1$[esp+40], edx
$once_more$154:
	cmp	ecx, DWORD PTR [edx]
	jae	SHORT $LN57@r_dsgraph_

; 134  : 				if (node->left) {

	mov	eax, DWORD PTR [edx+20]
	test	eax, eax
	je	SHORT $LN59@r_dsgraph_

; 135  : 					node = node->left;

	mov	edx, eax

; 136  : 					goto once_more;

	jmp	SHORT $LN148@r_dsgraph_
$LN57@r_dsgraph_:

; 141  : 				}
; 142  : 			} else if (k > node->key) {

	jbe	SHORT $LN56@r_dsgraph_

; 143  : 				if (node->right) {

	mov	eax, DWORD PTR [edx+24]
	test	eax, eax
	je	SHORT $LN63@r_dsgraph_

; 144  : 					node = node->right;

	mov	edx, eax

; 145  : 					goto once_more;

	jmp	SHORT $LN148@r_dsgraph_
$LN59@r_dsgraph_:

; 69   : 		size_t	PID	= size_t(parent-nodes);

	sub	edx, esi

; 70   : 		TNode*	N	= Alloc	(key);

	mov	ecx, ebx
	sar	edx, 2
	push	edi
	imul	esi, edx, -1227133513
	call	?Alloc@?$FixedMAP@PAUIDirect3DPixelShader9@@UmapNormalCS@R_dsgraph@@Udoug_lea_allocator@@@@AAEPAUTNode@1@ABQAUIDirect3DPixelShader9@@@Z ; FixedMAP<IDirect3DPixelShader9 *,R_dsgraph::mapNormalCS,doug_lea_allocator>::Alloc

; 138  : 					TNode* N = CreateChild(node,k);

	mov	edx, eax

; 71   : 		parent		= nodes+PID;

	lea	ecx, DWORD PTR [esi*8]

; 139  : 					node->left = N;

	mov	eax, DWORD PTR [ebx]

; 71   : 		parent		= nodes+PID;

	sub	ecx, esi

; 139  : 					node->left = N;

	mov	DWORD PTR [eax+ecx*4+20], edx

; 140  : 					return N;

	jmp	SHORT $LN149@r_dsgraph_
$LN63@r_dsgraph_:

; 69   : 		size_t	PID	= size_t(parent-nodes);

	sub	edx, esi

; 70   : 		TNode*	N	= Alloc	(key);

	mov	ecx, ebx
	sar	edx, 2
	push	edi
	imul	esi, edx, -1227133513
	call	?Alloc@?$FixedMAP@PAUIDirect3DPixelShader9@@UmapNormalCS@R_dsgraph@@Udoug_lea_allocator@@@@AAEPAUTNode@1@ABQAUIDirect3DPixelShader9@@@Z ; FixedMAP<IDirect3DPixelShader9 *,R_dsgraph::mapNormalCS,doug_lea_allocator>::Alloc

; 147  : 					TNode* N = CreateChild(node,k);

	mov	edx, eax

; 71   : 		parent		= nodes+PID;

	lea	ecx, DWORD PTR [esi*8]

; 148  : 					node->right = N;

	mov	eax, DWORD PTR [ebx]

; 71   : 		parent		= nodes+PID;

	sub	ecx, esi

; 148  : 					node->right = N;

	mov	DWORD PTR [eax+ecx*4+24], edx

; 149  : 					return N;

	jmp	SHORT $LN149@r_dsgraph_
$LN55@r_dsgraph_:

; 150  : 				}
; 151  : 			} else return node;
; 152  : 			
; 153  : 		} else {
; 154  : 			return Alloc(k);

	push	edi
	mov	ecx, ebx
	call	?Alloc@?$FixedMAP@PAUIDirect3DPixelShader9@@UmapNormalCS@R_dsgraph@@Udoug_lea_allocator@@@@AAEPAUTNode@1@ABQAUIDirect3DPixelShader9@@@Z ; FixedMAP<IDirect3DPixelShader9 *,R_dsgraph::mapNormalCS,doug_lea_allocator>::Alloc
	mov	edx, eax
$LN149@r_dsgraph_:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp

; 253  : 	mapNormalCS::TNode*			Ncs		= Nps->val.insert	(pass.constants._get());

	mov	DWORD PTR _Nps$1$[esp+40], edx
$LN56@r_dsgraph_:
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h

; 129  : 		if (pool) {

	cmp	DWORD PTR [edx+8], 0
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp

; 253  : 	mapNormalCS::TNode*			Ncs		= Nps->val.insert	(pass.constants._get());

	lea	edi, DWORD PTR [edx+4]
	mov	eax, DWORD PTR _pass$1$[esp+40]
	mov	ecx, DWORD PTR [eax+20]
	mov	DWORD PTR $T1[esp+40], ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h

; 129  : 		if (pool) {

	je	SHORT $LN71@r_dsgraph_

; 130  : 			TNode*	node = nodes;

	mov	edx, DWORD PTR [edi]
	mov	ebx, edx
$once_more$155:

; 131  : 
; 132  : 			once_more:
; 133  : 			if (k < node->key) {

	cmp	ecx, DWORD PTR [ebx]
	jae	SHORT $LN73@r_dsgraph_

; 134  : 				if (node->left) {

	mov	eax, DWORD PTR [ebx+20]
	test	eax, eax
	je	SHORT $LN75@r_dsgraph_

; 135  : 					node = node->left;

	mov	ebx, eax

; 136  : 					goto once_more;

	jmp	SHORT $once_more$155
$LN73@r_dsgraph_:

; 141  : 				}
; 142  : 			} else if (k > node->key) {

	jbe	SHORT $LN72@r_dsgraph_

; 143  : 				if (node->right) {

	mov	eax, DWORD PTR [ebx+24]
	test	eax, eax
	je	SHORT $LN79@r_dsgraph_

; 144  : 					node = node->right;

	mov	ebx, eax

; 145  : 					goto once_more;

	jmp	SHORT $once_more$155
$LN75@r_dsgraph_:

; 69   : 		size_t	PID	= size_t(parent-nodes);

	sub	ebx, edx

; 70   : 		TNode*	N	= Alloc	(key);

	lea	eax, DWORD PTR $T1[esp+40]
	sar	ebx, 2
	mov	ecx, edi
	push	eax
	imul	esi, ebx, -1227133513
	call	?Alloc@?$FixedMAP@PAVR_constant_table@@UmapNormalStates@R_dsgraph@@Udoug_lea_allocator@@@@AAEPAUTNode@1@ABQAVR_constant_table@@@Z ; FixedMAP<R_constant_table *,R_dsgraph::mapNormalStates,doug_lea_allocator>::Alloc

; 138  : 					TNode* N = CreateChild(node,k);

	mov	ebx, eax

; 71   : 		parent		= nodes+PID;

	lea	ecx, DWORD PTR [esi*8]

; 139  : 					node->left = N;

	mov	eax, DWORD PTR [edi]

; 71   : 		parent		= nodes+PID;

	sub	ecx, esi

; 139  : 					node->left = N;

	mov	DWORD PTR [eax+ecx*4+20], ebx

; 140  : 					return N;

	jmp	SHORT $LN72@r_dsgraph_
$LN79@r_dsgraph_:

; 69   : 		size_t	PID	= size_t(parent-nodes);

	sub	ebx, edx

; 70   : 		TNode*	N	= Alloc	(key);

	lea	eax, DWORD PTR $T1[esp+40]
	sar	ebx, 2
	mov	ecx, edi
	push	eax
	imul	esi, ebx, -1227133513
	call	?Alloc@?$FixedMAP@PAVR_constant_table@@UmapNormalStates@R_dsgraph@@Udoug_lea_allocator@@@@AAEPAUTNode@1@ABQAVR_constant_table@@@Z ; FixedMAP<R_constant_table *,R_dsgraph::mapNormalStates,doug_lea_allocator>::Alloc

; 147  : 					TNode* N = CreateChild(node,k);

	mov	ebx, eax

; 71   : 		parent		= nodes+PID;

	lea	ecx, DWORD PTR [esi*8]

; 148  : 					node->right = N;

	mov	eax, DWORD PTR [edi]

; 71   : 		parent		= nodes+PID;

	sub	ecx, esi

; 148  : 					node->right = N;

	mov	DWORD PTR [eax+ecx*4+24], ebx

; 149  : 					return N;

	jmp	SHORT $LN72@r_dsgraph_
$LN71@r_dsgraph_:

; 150  : 				}
; 151  : 			} else return node;
; 152  : 			
; 153  : 		} else {
; 154  : 			return Alloc(k);

	lea	eax, DWORD PTR $T1[esp+40]
	mov	ecx, edi
	push	eax
	call	?Alloc@?$FixedMAP@PAVR_constant_table@@UmapNormalStates@R_dsgraph@@Udoug_lea_allocator@@@@AAEPAUTNode@1@ABQAVR_constant_table@@@Z ; FixedMAP<R_constant_table *,R_dsgraph::mapNormalStates,doug_lea_allocator>::Alloc
	mov	ebx, eax
$LN72@r_dsgraph_:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp

; 254  : 	mapNormalStates::TNode*		Nstate	= Ncs->val.insert	(pass.state->state);

	mov	eax, DWORD PTR _pass$1$[esp+40]
	mov	edi, DWORD PTR [eax+8]
	add	edi, 8
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h

; 129  : 		if (pool) {

	cmp	DWORD PTR [ebx+8], 0
	je	$LN87@r_dsgraph_

; 130  : 			TNode*	node = nodes;

	mov	esi, DWORD PTR [ebx+4]
	mov	edx, esi

; 131  : 
; 132  : 			once_more:
; 133  : 			if (k < node->key) {

	mov	ecx, DWORD PTR [edi]
$LN150@r_dsgraph_:
	mov	DWORD PTR _Nstate$1$[esp+40], edx
	npad	2
$once_more$156:
	cmp	ecx, DWORD PTR [edx]
	jae	SHORT $LN89@r_dsgraph_

; 134  : 				if (node->left) {

	mov	eax, DWORD PTR [edx+20]
	test	eax, eax
	je	SHORT $LN91@r_dsgraph_

; 135  : 					node = node->left;

	mov	edx, eax

; 136  : 					goto once_more;

	jmp	SHORT $LN150@r_dsgraph_
$LN89@r_dsgraph_:

; 141  : 				}
; 142  : 			} else if (k > node->key) {

	jbe	SHORT $LN88@r_dsgraph_

; 143  : 				if (node->right) {

	mov	eax, DWORD PTR [edx+24]
	test	eax, eax
	je	SHORT $LN95@r_dsgraph_

; 144  : 					node = node->right;

	mov	edx, eax

; 145  : 					goto once_more;

	jmp	SHORT $LN150@r_dsgraph_
$LN91@r_dsgraph_:

; 69   : 		size_t	PID	= size_t(parent-nodes);

	sub	edx, esi

; 70   : 		TNode*	N	= Alloc	(key);

	lea	ecx, DWORD PTR [ebx+4]
	sar	edx, 2
	push	edi
	imul	esi, edx, -1227133513
	call	?Alloc@?$FixedMAP@PAUIDirect3DStateBlock9@@UmapNormalTextures@R_dsgraph@@Udoug_lea_allocator@@@@AAEPAUTNode@1@ABQAUIDirect3DStateBlock9@@@Z ; FixedMAP<IDirect3DStateBlock9 *,R_dsgraph::mapNormalTextures,doug_lea_allocator>::Alloc

; 138  : 					TNode* N = CreateChild(node,k);

	mov	edx, eax

; 71   : 		parent		= nodes+PID;

	lea	ecx, DWORD PTR [esi*8]

; 139  : 					node->left = N;

	mov	eax, DWORD PTR [ebx+4]

; 71   : 		parent		= nodes+PID;

	sub	ecx, esi

; 139  : 					node->left = N;

	mov	DWORD PTR [eax+ecx*4+20], edx

; 140  : 					return N;

	jmp	SHORT $LN151@r_dsgraph_
$LN95@r_dsgraph_:

; 69   : 		size_t	PID	= size_t(parent-nodes);

	sub	edx, esi

; 70   : 		TNode*	N	= Alloc	(key);

	lea	ecx, DWORD PTR [ebx+4]
	sar	edx, 2
	push	edi
	imul	esi, edx, -1227133513
	call	?Alloc@?$FixedMAP@PAUIDirect3DStateBlock9@@UmapNormalTextures@R_dsgraph@@Udoug_lea_allocator@@@@AAEPAUTNode@1@ABQAUIDirect3DStateBlock9@@@Z ; FixedMAP<IDirect3DStateBlock9 *,R_dsgraph::mapNormalTextures,doug_lea_allocator>::Alloc

; 147  : 					TNode* N = CreateChild(node,k);

	mov	edx, eax

; 71   : 		parent		= nodes+PID;

	lea	ecx, DWORD PTR [esi*8]

; 148  : 					node->right = N;

	mov	eax, DWORD PTR [ebx+4]

; 71   : 		parent		= nodes+PID;

	sub	ecx, esi

; 148  : 					node->right = N;

	mov	DWORD PTR [eax+ecx*4+24], edx

; 149  : 					return N;

	jmp	SHORT $LN151@r_dsgraph_
$LN87@r_dsgraph_:

; 150  : 				}
; 151  : 			} else return node;
; 152  : 			
; 153  : 		} else {
; 154  : 			return Alloc(k);

	push	edi
	lea	ecx, DWORD PTR [ebx+4]
	call	?Alloc@?$FixedMAP@PAUIDirect3DStateBlock9@@UmapNormalTextures@R_dsgraph@@Udoug_lea_allocator@@@@AAEPAUTNode@1@ABQAUIDirect3DStateBlock9@@@Z ; FixedMAP<IDirect3DStateBlock9 *,R_dsgraph::mapNormalTextures,doug_lea_allocator>::Alloc
	mov	edx, eax
$LN151@r_dsgraph_:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp

; 255  : 	mapNormalTextures::TNode*	Ntex	= Nstate->val.insert(pass.T._get());

	mov	DWORD PTR _Nstate$1$[esp+40], edx
$LN88@r_dsgraph_:
	mov	eax, DWORD PTR _pass$1$[esp+40]
	add	edx, 4
	mov	DWORD PTR _this$1$[esp+40], edx
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h

; 129  : 		if (pool) {

	cmp	DWORD PTR [edx+4], 0
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp

; 255  : 	mapNormalTextures::TNode*	Ntex	= Nstate->val.insert(pass.T._get());

	mov	ecx, DWORD PTR [eax+24]
	mov	DWORD PTR $T2[esp+40], ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h

; 129  : 		if (pool) {

	je	$LN103@r_dsgraph_

; 130  : 			TNode*	node = nodes;

	mov	esi, DWORD PTR [edx]
	mov	edi, esi
	npad	5
$once_more$157:

; 131  : 
; 132  : 			once_more:
; 133  : 			if (k < node->key) {

	cmp	ecx, DWORD PTR [edi]
	jae	SHORT $LN105@r_dsgraph_

; 134  : 				if (node->left) {

	mov	eax, DWORD PTR [edi+20]
	test	eax, eax
	je	SHORT $LN107@r_dsgraph_

; 135  : 					node = node->left;

	mov	edi, eax

; 136  : 					goto once_more;

	jmp	SHORT $once_more$157
$LN105@r_dsgraph_:

; 141  : 				}
; 142  : 			} else if (k > node->key) {

	jbe	SHORT $LN104@r_dsgraph_

; 143  : 				if (node->right) {

	mov	eax, DWORD PTR [edi+24]
	test	eax, eax
	je	SHORT $LN111@r_dsgraph_

; 144  : 					node = node->right;

	mov	edi, eax

; 145  : 					goto once_more;

	jmp	SHORT $once_more$157
$LN107@r_dsgraph_:

; 69   : 		size_t	PID	= size_t(parent-nodes);

	sub	edi, esi

; 70   : 		TNode*	N	= Alloc	(key);

	lea	eax, DWORD PTR $T2[esp+40]
	sar	edi, 2
	mov	ecx, edx
	push	eax
	imul	esi, edi, -1227133513
	call	?Alloc@?$FixedMAP@PAUSTextureList@@UmapNormalItems@R_dsgraph@@Udoug_lea_allocator@@@@AAEPAUTNode@1@ABQAUSTextureList@@@Z ; FixedMAP<STextureList *,R_dsgraph::mapNormalItems,doug_lea_allocator>::Alloc

; 138  : 					TNode* N = CreateChild(node,k);

	mov	edi, eax

; 71   : 		parent		= nodes+PID;

	lea	ecx, DWORD PTR [esi*8]

; 139  : 					node->left = N;

	mov	eax, DWORD PTR _this$1$[esp+40]

; 71   : 		parent		= nodes+PID;

	sub	ecx, esi

; 139  : 					node->left = N;

	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [eax+ecx*4+20], edi

; 140  : 					return N;

	jmp	SHORT $LN104@r_dsgraph_
$LN111@r_dsgraph_:

; 69   : 		size_t	PID	= size_t(parent-nodes);

	sub	edi, esi

; 70   : 		TNode*	N	= Alloc	(key);

	lea	eax, DWORD PTR $T2[esp+40]
	sar	edi, 2
	mov	ecx, edx
	push	eax
	imul	esi, edi, -1227133513
	call	?Alloc@?$FixedMAP@PAUSTextureList@@UmapNormalItems@R_dsgraph@@Udoug_lea_allocator@@@@AAEPAUTNode@1@ABQAUSTextureList@@@Z ; FixedMAP<STextureList *,R_dsgraph::mapNormalItems,doug_lea_allocator>::Alloc

; 147  : 					TNode* N = CreateChild(node,k);

	mov	edi, eax

; 71   : 		parent		= nodes+PID;

	lea	ecx, DWORD PTR [esi*8]

; 148  : 					node->right = N;

	mov	eax, DWORD PTR _this$1$[esp+40]

; 71   : 		parent		= nodes+PID;

	sub	ecx, esi

; 148  : 					node->right = N;

	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [eax+ecx*4+24], edi

; 149  : 					return N;

	jmp	SHORT $LN104@r_dsgraph_
$LN103@r_dsgraph_:

; 150  : 				}
; 151  : 			} else return node;
; 152  : 			
; 153  : 		} else {
; 154  : 			return Alloc(k);

	lea	eax, DWORD PTR $T2[esp+40]
	mov	ecx, edx
	push	eax
	call	?Alloc@?$FixedMAP@PAUSTextureList@@UmapNormalItems@R_dsgraph@@Udoug_lea_allocator@@@@AAEPAUTNode@1@ABQAUSTextureList@@@Z ; FixedMAP<STextureList *,R_dsgraph::mapNormalItems,doug_lea_allocator>::Alloc
	mov	edi, eax
$LN104@r_dsgraph_:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp

; 257  : 	_NormalItem					item	= {SSA,pVisual};

	movss	xmm0, DWORD PTR _SSA$1$[esp+40]
	lea	ecx, DWORD PTR [edi+4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 730  :         if (_Mylast != _My_data._Myend) {

	mov	edx, DWORD PTR [ecx+4]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp

; 257  : 	_NormalItem					item	= {SSA,pVisual};

	mov	esi, DWORD PTR _pVisual$[ebp]
	movss	DWORD PTR _item$[esp+40], xmm0
	mov	DWORD PTR _item$[esp+44], esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 730  :         if (_Mylast != _My_data._Myend) {

	cmp	edx, DWORD PTR [ecx+8]
	je	SHORT $LN121@r_dsgraph_

; 713  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

	mov	eax, DWORD PTR _item$[esp+40]
	mov	DWORD PTR [edx], eax
	mov	DWORD PTR [edx+4], esi

; 714  :         _Orphan_range(_Mylast, _Mylast);
; 715  :         _Ty& _Result = *_Mylast;
; 716  :         ++_Mylast;

	add	DWORD PTR [ecx+4], 8

; 731  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

	jmp	SHORT $LN120@r_dsgraph_
$LN121@r_dsgraph_:

; 732  :         }
; 733  : 
; 734  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	lea	eax, DWORD PTR _item$[esp+40]
	push	eax
	push	edx
	call	??$_Emplace_reallocate@ABU_NormalItem@R_dsgraph@@@?$vector@U_NormalItem@R_dsgraph@@V?$doug_lea_alloc@U_NormalItem@R_dsgraph@@@@@std@@QAEPAU_NormalItem@R_dsgraph@@QAU23@ABU23@@Z ; std::vector<R_dsgraph::_NormalItem,doug_lea_alloc<R_dsgraph::_NormalItem> >::_Emplace_reallocate<R_dsgraph::_NormalItem const &>
	movss	xmm0, DWORD PTR _SSA$1$[esp+40]
$LN120@r_dsgraph_:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp

; 261  : 	if (SSA>Ntex->val.ssa)		{ Ntex->val.ssa = SSA;

	comiss	xmm0, DWORD PTR [edi+16]
	jbe	SHORT $LN17@r_dsgraph_

; 262  : 	if (SSA>Nstate->val.ssa)	{ Nstate->val.ssa = SSA;

	mov	eax, DWORD PTR _Nstate$1$[esp+40]
	movss	DWORD PTR [edi+16], xmm0
	comiss	xmm0, DWORD PTR [eax+16]
	jbe	SHORT $LN17@r_dsgraph_
	movss	DWORD PTR [eax+16], xmm0

; 263  : 	if (SSA>Ncs->val.ssa)		{ Ncs->val.ssa = SSA;

	comiss	xmm0, DWORD PTR [ebx+16]
	jbe	SHORT $LN17@r_dsgraph_

; 264  : 	if (SSA>Nps->val.ssa)		{ Nps->val.ssa = SSA;

	mov	eax, DWORD PTR _Nps$1$[esp+40]
	movss	DWORD PTR [ebx+16], xmm0
	comiss	xmm0, DWORD PTR [eax+16]
	jbe	SHORT $LN17@r_dsgraph_
	movss	DWORD PTR [eax+16], xmm0

; 265  : 	if (SSA>Nvs->val.ssa)		{ Nvs->val.ssa = SSA;

	mov	eax, DWORD PTR _Nvs$1$[esp+40]
	comiss	xmm0, DWORD PTR [eax+16]
	jbe	SHORT $LN17@r_dsgraph_
	movss	DWORD PTR [eax+16], xmm0
$LN17@r_dsgraph_:

; 266  : 	} } } } }
; 267  : 
; 268  : #if RENDER==R_R2
; 269  : 	if (val_recorder)			{
; 270  : 		val_recorder->push_back	(pVisual->vis.box	);
; 271  : 	}
; 272  : #endif
; 273  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?r_dsgraph_insert_static@R_dsgraph_structure@@QAEXPAVIRender_Visual@@@Z ENDP ; R_dsgraph_structure::r_dsgraph_insert_static
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp
_TEXT	SEGMENT
_Tpos$2 = -12						; size = 12
_pVisual$ = 8						; size = 4
?add_leafs_Dynamic@CRender@@AAEXPAVIRender_Visual@@@Z PROC ; CRender::add_leafs_Dynamic
; _this$ = ecx

; 279  : {

	sub	esp, 12					; 0000000cH
	push	ebx
	push	ebp

; 280  : 	if (0==pVisual)				return;

	mov	ebp, DWORD PTR _pVisual$[esp+16]
	mov	ebx, ecx
	test	ebp, ebp
	je	$LN1@add_leafs_

; 314  : 			{
; 315  : 				Fvector							Tpos;	float		D;
; 316  : 				val_pTransform->transform_tiny	(Tpos, pV->vis.sphere.P);

	movss	xmm7, DWORD PTR ?r_ssaLOD_A@@3MA
	mov	edx, DWORD PTR __imp_?Device@@3VCRenderDevice@@A
	push	esi
	push	edi
$LL293@add_leafs_:

; 281  : 
; 282  : 	// Visual is 100% visible - simply add it
; 283  : 	xr_vector<IRender_Visual*>::iterator I,E;	// it may be useful for 'hierrarhy' visual
; 284  : 
; 285  : 	switch (pVisual->Type) {

	mov	eax, DWORD PTR [ebp+4]
	dec	eax
	cmp	eax, 9
	ja	$LN29@add_leafs_
	movzx	eax, BYTE PTR $LN324@add_leafs_[eax]
	jmp	DWORD PTR $LN325@add_leafs_[eax*4]
$LN23@add_leafs_:

; 305  : 		}
; 306  : 		return;
; 307  : 	case MT_SKELETON_ANIM:
; 308  : 	case MT_SKELETON_RIGID:
; 309  : 		{
; 310  : 			// Add all children, doesn't perform any tests
; 311  : 			CKinematics * pV			= (CKinematics*)pVisual;
; 312  : 			BOOL	_use_lod			= FALSE	;
; 313  : 			if (pV->m_lod)				

	mov	ecx, DWORD PTR [ebp+84]
	test	ecx, ecx
	je	$LN27@add_leafs_

; 314  : 			{
; 315  : 				Fvector							Tpos;	float		D;
; 316  : 				val_pTransform->transform_tiny	(Tpos, pV->vis.sphere.P);

	mov	eax, DWORD PTR [ebx+264]
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 499  : 		dest.x = v.x*_11 + v.y*_21 + v.z*_31 + _41;

	movss	xmm6, DWORD PTR [ebp+12]
	movss	xmm4, DWORD PTR [ebp+8]

; 500  : 		dest.y = v.x*_12 + v.y*_22 + v.z*_32 + _42;

	movaps	xmm1, xmm6
	movss	xmm5, DWORD PTR [ebp+16]
	movaps	xmm0, xmm4
	mulss	xmm0, DWORD PTR [eax+4]
	mulss	xmm1, DWORD PTR [eax+20]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 287  : 	{	return (x-v.x)*(x-v.x) + (y-v.y)*(y-v.y) + (z-v.z)*(z-v.z);	}

	movss	xmm3, DWORD PTR [edx+492]
	movss	xmm2, DWORD PTR [edx+488]
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 500  : 		dest.y = v.x*_12 + v.y*_22 + v.z*_32 + _42;

	addss	xmm1, xmm0
	movaps	xmm0, xmm5
	mulss	xmm0, DWORD PTR [eax+36]
	addss	xmm0, DWORD PTR [eax+52]
	addss	xmm1, xmm0
	movaps	xmm0, xmm4
	mulss	xmm0, DWORD PTR [eax]

; 501  : 		dest.z = v.x*_13 + v.y*_23 + v.z*_33 + _43;

	mulss	xmm4, DWORD PTR [eax+8]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 287  : 	{	return (x-v.x)*(x-v.x) + (y-v.y)*(y-v.y) + (z-v.z)*(z-v.z);	}

	subss	xmm3, xmm1
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 499  : 		dest.x = v.x*_11 + v.y*_21 + v.z*_31 + _41;

	movaps	xmm1, xmm6
	mulss	xmm1, DWORD PTR [eax+16]

; 501  : 		dest.z = v.x*_13 + v.y*_23 + v.z*_33 + _43;

	mulss	xmm6, DWORD PTR [eax+24]
	addss	xmm1, xmm0
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 287  : 	{	return (x-v.x)*(x-v.x) + (y-v.y)*(y-v.y) + (z-v.z)*(z-v.z);	}

	mulss	xmm3, xmm3
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 499  : 		dest.x = v.x*_11 + v.y*_21 + v.z*_31 + _41;

	movaps	xmm0, xmm5

; 501  : 		dest.z = v.x*_13 + v.y*_23 + v.z*_33 + _43;

	mulss	xmm5, DWORD PTR [eax+40]
	mulss	xmm0, DWORD PTR [eax+32]
	addss	xmm6, xmm4
	addss	xmm5, DWORD PTR [eax+56]
	addss	xmm0, DWORD PTR [eax+48]
	addss	xmm6, xmm5
	addss	xmm1, xmm0
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp

; 317  : 				float		ssa		=	CalcSSA	(D,Tpos,pV->vis.sphere.R/2.f);	// assume dynamics never consume full sphere

	movss	xmm0, DWORD PTR [ebp+20]
	mulss	xmm0, DWORD PTR __real@3f000000
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 287  : 	{	return (x-v.x)*(x-v.x) + (y-v.y)*(y-v.y) + (z-v.z)*(z-v.z);	}

	subss	xmm2, xmm1
	movss	xmm1, DWORD PTR [edx+496]
	subss	xmm1, xmm6
	mulss	xmm2, xmm2
	mulss	xmm1, xmm1
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp

; 31   : 	distSQ	= Device.vCameraPosition.distance_to_sqr(C)+EPS;

	addss	xmm2, xmm3
	addss	xmm1, DWORD PTR __real@3727c5ac
	addss	xmm2, xmm1

; 32   : 	return	R/distSQ;

	divss	xmm0, xmm2

; 318  : 				if (ssa<r_ssaLOD_A)	_use_lod	= TRUE;

	comiss	xmm7, xmm0
	jbe	SHORT $LN27@add_leafs_

; 319  : 			}
; 320  : 			if (_use_lod)				
; 321  : 			{
; 322  : 				add_leafs_Dynamic			(pV->m_lod)		;

	mov	ebp, ecx
	jmp	$LL293@add_leafs_
$LN27@add_leafs_:

; 323  : 			} else {
; 324  : 				pV->CalculateBones			(TRUE);

	mov	eax, DWORD PTR [ebp]
	mov	ecx, ebp
	push	1
	call	DWORD PTR [eax+64]

; 325  : 				pV->CalculateWallmarks		();		//. bug?

	mov	ecx, ebp
	call	DWORD PTR __imp_?CalculateWallmarks@CKinematics@@QAEXXZ

; 326  : 				I = pV->children.begin		();
; 327  : 				E = pV->children.end		();

	mov	edi, DWORD PTR [ebp+72]

; 328  : 				for (; I!=E; I++)	add_leafs_Dynamic	(*I);

	mov	esi, DWORD PTR [ebp+68]
	cmp	esi, edi
	je	$LN326@add_leafs_
$LL18@add_leafs_:
	push	DWORD PTR [esi]
	mov	ecx, ebx
	call	?add_leafs_Dynamic@CRender@@AAEXPAVIRender_Visual@@@Z ; CRender::add_leafs_Dynamic
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 74   :         ++_Ptr;

	add	esi, 4
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp

; 328  : 				for (; I!=E; I++)	add_leafs_Dynamic	(*I);

	cmp	esi, edi
	jne	SHORT $LL18@add_leafs_

; 339  : 		}
; 340  : 		return;
; 341  : 	}
; 342  : }

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 12					; 0000000cH
	ret	4
$LN20@add_leafs_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	edi, DWORD PTR [ebp+92]

; 150  :         return _Ptr == _Right._Ptr;

	cmp	edi, DWORD PTR [ebp+96]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp

; 290  : 			for (PS::CParticleGroup::SItemVecIt i_it=pG->items.begin(); i_it!=pG->items.end(); i_it++)	{

	je	$LN326@add_leafs_
$LL6@add_leafs_:

; 291  : 				PS::CParticleGroup::SItem&			I		= *i_it;
; 292  : 				if (I._effect)		add_leafs_Dynamic		(I._effect);

	mov	eax, DWORD PTR [edi]
	test	eax, eax
	je	SHORT $LN21@add_leafs_
	push	eax
	mov	ecx, ebx
	call	?add_leafs_Dynamic@CRender@@AAEXPAVIRender_Visual@@@Z ; CRender::add_leafs_Dynamic
$LN21@add_leafs_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	esi, DWORD PTR [edi+4]

; 150  :         return _Ptr == _Right._Ptr;

	cmp	esi, DWORD PTR [edi+8]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp

; 293  : 				for (xr_vector<IRender_Visual*>::iterator pit = I._children_related.begin();	pit!=I._children_related.end(); pit++)	add_leafs_Dynamic(*pit);

	je	SHORT $LN322@add_leafs_
	npad	4
$LL9@add_leafs_:
	push	DWORD PTR [esi]
	mov	ecx, ebx
	call	?add_leafs_Dynamic@CRender@@AAEXPAVIRender_Visual@@@Z ; CRender::add_leafs_Dynamic
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 74   :         ++_Ptr;

	add	esi, 4

; 150  :         return _Ptr == _Right._Ptr;

	cmp	esi, DWORD PTR [edi+8]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp

; 293  : 				for (xr_vector<IRender_Visual*>::iterator pit = I._children_related.begin();	pit!=I._children_related.end(); pit++)	add_leafs_Dynamic(*pit);

	jne	SHORT $LL9@add_leafs_
$LN322@add_leafs_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	esi, DWORD PTR [edi+16]

; 150  :         return _Ptr == _Right._Ptr;

	cmp	esi, DWORD PTR [edi+20]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp

; 294  : 				for (xr_vector<IRender_Visual*>::iterator pit = I._children_free.begin();		pit!=I._children_free.end();	pit++)	add_leafs_Dynamic(*pit);

	je	SHORT $LN4@add_leafs_
	npad	7
$LL12@add_leafs_:
	push	DWORD PTR [esi]
	mov	ecx, ebx
	call	?add_leafs_Dynamic@CRender@@AAEXPAVIRender_Visual@@@Z ; CRender::add_leafs_Dynamic
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 74   :         ++_Ptr;

	add	esi, 4

; 150  :         return _Ptr == _Right._Ptr;

	cmp	esi, DWORD PTR [edi+20]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp

; 294  : 				for (xr_vector<IRender_Visual*>::iterator pit = I._children_free.begin();		pit!=I._children_free.end();	pit++)	add_leafs_Dynamic(*pit);

	jne	SHORT $LL12@add_leafs_
$LN4@add_leafs_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 74   :         ++_Ptr;

	add	edi, 28					; 0000001cH

; 150  :         return _Ptr == _Right._Ptr;

	cmp	edi, DWORD PTR [ebp+96]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp

; 290  : 			for (PS::CParticleGroup::SItemVecIt i_it=pG->items.begin(); i_it!=pG->items.end(); i_it++)	{

	jne	SHORT $LL6@add_leafs_

; 339  : 		}
; 340  : 		return;
; 341  : 	}
; 342  : }

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 12					; 0000000cH
	ret	4
$LN22@add_leafs_:

; 295  : 			}
; 296  : 		}
; 297  : 		return;
; 298  : 	case MT_HIERRARHY:
; 299  : 		{
; 300  : 			// Add all children, doesn't perform any tests
; 301  : 			FHierrarhyVisual* pV = (FHierrarhyVisual*)pVisual;
; 302  : 			I = pV->children.begin	();
; 303  : 			E = pV->children.end	();

	mov	edi, DWORD PTR [ebp+72]

; 304  : 			for (; I!=E; I++)	add_leafs_Dynamic	(*I);

	mov	esi, DWORD PTR [ebp+68]
	cmp	esi, edi
	je	$LN326@add_leafs_
$LL15@add_leafs_:
	push	DWORD PTR [esi]
	mov	ecx, ebx
	call	?add_leafs_Dynamic@CRender@@AAEXPAVIRender_Visual@@@Z ; CRender::add_leafs_Dynamic
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 74   :         ++_Ptr;

	add	esi, 4
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp

; 304  : 			for (; I!=E; I++)	add_leafs_Dynamic	(*I);

	cmp	esi, edi
	jne	SHORT $LL15@add_leafs_

; 339  : 		}
; 340  : 		return;
; 341  : 	}
; 342  : }

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 12					; 0000000cH
	ret	4
$LN29@add_leafs_:

; 329  : 			}
; 330  : 		}
; 331  : 		return;
; 332  : 	default:
; 333  : 		{
; 334  : 			// General type of visual
; 335  : 			// Calculate distance to it's center
; 336  : 			Fvector							Tpos;
; 337  : 			val_pTransform->transform_tiny	(Tpos, pVisual->vis.sphere.P);

	mov	eax, DWORD PTR [ebx+264]

; 338  : 			r_dsgraph_insert_dynamic		(pVisual,Tpos);

	mov	ecx, ebx
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 499  : 		dest.x = v.x*_11 + v.y*_21 + v.z*_31 + _41;

	movss	xmm2, DWORD PTR [ebp+12]
	movss	xmm4, DWORD PTR [ebp+8]
	movaps	xmm1, xmm2
	movss	xmm3, DWORD PTR [ebp+16]
	movaps	xmm0, xmm4
	mulss	xmm0, DWORD PTR [eax]
	mulss	xmm1, DWORD PTR [eax+16]
	addss	xmm1, xmm0
	movaps	xmm0, xmm3
	mulss	xmm0, DWORD PTR [eax+32]
	addss	xmm0, DWORD PTR [eax+48]
	addss	xmm1, xmm0

; 500  : 		dest.y = v.x*_12 + v.y*_22 + v.z*_32 + _42;

	movaps	xmm0, xmm2
	mulss	xmm0, DWORD PTR [eax+20]

; 501  : 		dest.z = v.x*_13 + v.y*_23 + v.z*_33 + _43;

	mulss	xmm2, DWORD PTR [eax+24]
	movss	DWORD PTR _Tpos$2[esp+28], xmm1
	movaps	xmm1, xmm4
	mulss	xmm1, DWORD PTR [eax+4]
	mulss	xmm4, DWORD PTR [eax+8]
	addss	xmm1, xmm0
	movaps	xmm0, xmm3
	mulss	xmm0, DWORD PTR [eax+36]
	mulss	xmm3, DWORD PTR [eax+40]
	addss	xmm4, xmm2
	addss	xmm0, DWORD PTR [eax+52]
	addss	xmm3, DWORD PTR [eax+56]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp

; 338  : 			r_dsgraph_insert_dynamic		(pVisual,Tpos);

	lea	eax, DWORD PTR _Tpos$2[esp+28]
	push	eax
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 500  : 		dest.y = v.x*_12 + v.y*_22 + v.z*_32 + _42;

	addss	xmm1, xmm0
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp

; 338  : 			r_dsgraph_insert_dynamic		(pVisual,Tpos);

	push	ebp
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 501  : 		dest.z = v.x*_13 + v.y*_23 + v.z*_33 + _43;

	addss	xmm4, xmm3
	movss	DWORD PTR _Tpos$2[esp+40], xmm1
	movss	DWORD PTR _Tpos$2[esp+44], xmm4
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp

; 338  : 			r_dsgraph_insert_dynamic		(pVisual,Tpos);

	call	?r_dsgraph_insert_dynamic@R_dsgraph_structure@@QAEXPAVIRender_Visual@@AAU?$_vector3@M@@@Z ; R_dsgraph_structure::r_dsgraph_insert_dynamic
$LN326@add_leafs_:
	pop	edi
	pop	esi
$LN1@add_leafs_:
	pop	ebp

; 339  : 		}
; 340  : 		return;
; 341  : 	}
; 342  : }

	pop	ebx
	add	esp, 12					; 0000000cH
	ret	4
	npad	2
$LN325@add_leafs_:
	DD	$LN22@add_leafs_
	DD	$LN23@add_leafs_
	DD	$LN20@add_leafs_
	DD	$LN29@add_leafs_
$LN324@add_leafs_:
	DB	0
	DB	3
	DB	1
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	2
	DB	1
?add_leafs_Dynamic@CRender@@AAEXPAVIRender_Visual@@@Z ENDP ; CRender::add_leafs_Dynamic
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_random.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp
_TEXT	SEGMENT
_i_it$1$ = -44						; size = 4
_ssa$1$ = -40						; size = 4
_pit$1$ = -40						; size = 4
_pit$1$ = -40						; size = 4
_Tpos$4 = -36						; size = 12
_Tpos$5 = -24						; size = 12
_Tpos$6 = -12						; size = 12
_D$7 = 8						; size = 4
_pVisual$ = 8						; size = 4
?add_leafs_Static@CRender@@AAEXPAVIRender_Visual@@@Z PROC ; CRender::add_leafs_Static
; _this$ = ecx
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp

; 288  : 	if (Device.dwFrame<vis.hom_frame)	return TRUE;				// not at this time :)

	mov	eax, DWORD PTR __imp_?Device@@3VCRenderDevice@@A
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp

; 345  : {

	sub	esp, 48					; 00000030H
	push	ebx
	push	ebp
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp

; 288  : 	if (Device.dwFrame<vis.hom_frame)	return TRUE;				// not at this time :)

	mov	ebp, DWORD PTR _pVisual$[esp+52]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp

; 345  : {

	mov	ebx, ecx
	push	esi
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp

; 288  : 	if (Device.dwFrame<vis.hom_frame)	return TRUE;				// not at this time :)

	mov	esi, DWORD PTR [eax+244]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp

; 345  : {

	push	edi
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp

; 288  : 	if (Device.dwFrame<vis.hom_frame)	return TRUE;				// not at this time :)

	cmp	esi, DWORD PTR [ebp+56]
	jb	SHORT $LN710@add_leafs_

; 289  : 	if (!bEnabled)						return TRUE;				// return - everything visible

	cmp	DWORD PTR [ebx+744], 0
	je	SHORT $LN710@add_leafs_

; 290  : 	
; 291  : 	// Now, the test time comes
; 292  : 	// 0. The object was hidden, and we must prove that each frame	- test		| frame-old, tested-new, hom_res = false;
; 293  : 	// 1. The object was visible, but we must to re-check it		- test		| frame-new, tested-???, hom_res = true;
; 294  : 	// 2. New object slides into view								- delay test| frame-old, tested-old, hom_res = ???;
; 295  : 	u32 frame_current	= Device.dwFrame;
; 296  : 	// u32	frame_prev		= frame_current-1;
; 297  : 
; 298  : #ifdef DEBUG
; 299  : 	Device.Statistic->RenderCALC_HOM.Begin	();
; 300  : #endif
; 301  : 	BOOL result			= _visible			(vis.box,m_xform_01);

	lea	edx, DWORD PTR [ebx+812]
	lea	ecx, DWORD PTR [ebp+24]
	call	?_visible@@YAHAAV?$_box3@M@@AAU?$_matrix@M@@@Z ; _visible

; 302  : 	u32  delay			= 1;
; 303  : 	if (result)

	test	eax, eax
	je	SHORT $LN39@add_leafs_
; File I:\Vitalya\mine\NSProjectX\xrCore\_random.h

; 33   : 	IC 	s32		randI	(s32 max)					{ VERIFY(max);  return randI()%max; }

	mov	ecx, DWORD PTR __imp_?Random@@3VCRandom@@A
	call	?randI@CRandom@@QAEHXZ			; CRandom::randI
	cdq
	mov	ecx, 15					; 0000000fH
	idiv	ecx
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp

; 306  : 		delay			= ::Random.randI	(5*2,5*5);

	lea	eax, DWORD PTR [esi+10]
	mov	DWORD PTR [ebp+60], esi
	add	eax, edx
	mov	DWORD PTR [ebp+56], eax
$LN710@add_leafs_:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp

; 351  : 	switch (pVisual->Type) {

	mov	eax, DWORD PTR [ebp+4]
	dec	eax
	cmp	eax, 10					; 0000000aH
	ja	$LN34@add_leafs_
	movzx	eax, BYTE PTR $LN722@add_leafs_[eax]
	jmp	DWORD PTR $LN723@add_leafs_[eax*4]
$LN39@add_leafs_:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp

; 310  : 	vis.hom_frame			= frame_current + delay;

	lea	eax, DWORD PTR [esi+1]

; 311  : 	vis.hom_tested			= frame_current	;

	mov	DWORD PTR [ebp+60], esi
	mov	DWORD PTR [ebp+56], eax
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp

; 420  : }

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 48					; 00000030H
	ret	4
$LN23@add_leafs_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	esi, DWORD PTR [ebp+92]
	mov	DWORD PTR _i_it$1$[esp+64], esi

; 150  :         return _Ptr == _Right._Ptr;

	cmp	esi, DWORD PTR [ebp+96]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp

; 356  : 			for (PS::CParticleGroup::SItemVecIt i_it=pG->items.begin(); i_it!=pG->items.end(); i_it++){

	je	$LN1@add_leafs_
	movss	xmm7, DWORD PTR __real@3f000000
	mov	edi, DWORD PTR __imp_?CalculateWallmarks@CKinematics@@QAEXXZ
$LL6@add_leafs_:

; 357  : 				PS::CParticleGroup::SItem&			I		= *i_it;
; 358  : 				if (I._effect)		add_leafs_Dynamic		(I._effect);

	mov	ebp, DWORD PTR [esi]
	test	ebp, ebp
	je	$LN77@add_leafs_

; 285  : 	switch (pVisual->Type) {

	mov	eax, DWORD PTR [ebp+4]
	dec	eax
	cmp	eax, 9
	ja	$LN105@add_leafs_
	movzx	eax, BYTE PTR $LN724@add_leafs_[eax]
	jmp	DWORD PTR $LN725@add_leafs_[eax*4]
$LN96@add_leafs_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	edi, DWORD PTR [ebp+92]

; 150  :         return _Ptr == _Right._Ptr;

	cmp	edi, DWORD PTR [ebp+96]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp

; 290  : 			for (PS::CParticleGroup::SItemVecIt i_it=pG->items.begin(); i_it!=pG->items.end(); i_it++)	{

	je	SHORT $LN736@add_leafs_
	npad	1
$LL82@add_leafs_:

; 291  : 				PS::CParticleGroup::SItem&			I		= *i_it;
; 292  : 				if (I._effect)		add_leafs_Dynamic		(I._effect);

	mov	eax, DWORD PTR [edi]
	test	eax, eax
	je	SHORT $LN97@add_leafs_
	push	eax
	mov	ecx, ebx
	call	?add_leafs_Dynamic@CRender@@AAEXPAVIRender_Visual@@@Z ; CRender::add_leafs_Dynamic
$LN97@add_leafs_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	esi, DWORD PTR [edi+4]

; 150  :         return _Ptr == _Right._Ptr;

	cmp	esi, DWORD PTR [edi+8]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp

; 293  : 				for (xr_vector<IRender_Visual*>::iterator pit = I._children_related.begin();	pit!=I._children_related.end(); pit++)	add_leafs_Dynamic(*pit);

	je	SHORT $LN715@add_leafs_
$LL85@add_leafs_:
	push	DWORD PTR [esi]
	mov	ecx, ebx
	call	?add_leafs_Dynamic@CRender@@AAEXPAVIRender_Visual@@@Z ; CRender::add_leafs_Dynamic
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 74   :         ++_Ptr;

	add	esi, 4

; 150  :         return _Ptr == _Right._Ptr;

	cmp	esi, DWORD PTR [edi+8]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp

; 293  : 				for (xr_vector<IRender_Visual*>::iterator pit = I._children_related.begin();	pit!=I._children_related.end(); pit++)	add_leafs_Dynamic(*pit);

	jne	SHORT $LL85@add_leafs_
$LN715@add_leafs_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	esi, DWORD PTR [edi+16]

; 150  :         return _Ptr == _Right._Ptr;

	cmp	esi, DWORD PTR [edi+20]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp

; 294  : 				for (xr_vector<IRender_Visual*>::iterator pit = I._children_free.begin();		pit!=I._children_free.end();	pit++)	add_leafs_Dynamic(*pit);

	je	SHORT $LN80@add_leafs_
	npad	1
$LL88@add_leafs_:
	push	DWORD PTR [esi]
	mov	ecx, ebx
	call	?add_leafs_Dynamic@CRender@@AAEXPAVIRender_Visual@@@Z ; CRender::add_leafs_Dynamic
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 74   :         ++_Ptr;

	add	esi, 4

; 150  :         return _Ptr == _Right._Ptr;

	cmp	esi, DWORD PTR [edi+20]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp

; 294  : 				for (xr_vector<IRender_Visual*>::iterator pit = I._children_free.begin();		pit!=I._children_free.end();	pit++)	add_leafs_Dynamic(*pit);

	jne	SHORT $LL88@add_leafs_
$LN80@add_leafs_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 74   :         ++_Ptr;

	add	edi, 28					; 0000001cH

; 150  :         return _Ptr == _Right._Ptr;

	cmp	edi, DWORD PTR [ebp+96]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp

; 290  : 			for (PS::CParticleGroup::SItemVecIt i_it=pG->items.begin(); i_it!=pG->items.end(); i_it++)	{

	jne	SHORT $LL82@add_leafs_
$LN730@add_leafs_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	movss	xmm7, DWORD PTR __real@3f000000
$LN735@add_leafs_:
	mov	esi, DWORD PTR _i_it$1$[esp+64]
$LN736@add_leafs_:
	mov	edi, DWORD PTR __imp_?CalculateWallmarks@CKinematics@@QAEXXZ
$LN77@add_leafs_:

; 150  :         return _Ptr == _Right._Ptr;

	mov	eax, DWORD PTR _i_it$1$[esp+64]

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	esi, DWORD PTR [esi+4]
	mov	DWORD PTR _pit$1$[esp+64], esi

; 150  :         return _Ptr == _Right._Ptr;

	cmp	esi, DWORD PTR [eax+8]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp

; 359  : 				for (xr_vector<IRender_Visual*>::iterator pit = I._children_related.begin();	pit!=I._children_related.end(); pit++)	add_leafs_Dynamic(*pit);

	je	$LN717@add_leafs_
	npad	1
$LL9@add_leafs_:
	mov	ebp, DWORD PTR [esi]

; 280  : 	if (0==pVisual)				return;

	test	ebp, ebp
	je	$LN7@add_leafs_

; 281  : 
; 282  : 	// Visual is 100% visible - simply add it
; 283  : 	xr_vector<IRender_Visual*>::iterator I,E;	// it may be useful for 'hierrarhy' visual
; 284  : 
; 285  : 	switch (pVisual->Type) {

	mov	ecx, DWORD PTR [ebp+4]
	dec	ecx
	cmp	ecx, 9
	ja	$LN271@add_leafs_
	movzx	ecx, BYTE PTR $LN726@add_leafs_[ecx]
	jmp	DWORD PTR $LN727@add_leafs_[ecx*4]
$LN98@add_leafs_:

; 303  : 			E = pV->children.end	();

	mov	edi, DWORD PTR [ebp+72]

; 304  : 			for (; I!=E; I++)	add_leafs_Dynamic	(*I);

	mov	esi, DWORD PTR [ebp+68]
	cmp	esi, edi
	je	SHORT $LN735@add_leafs_
	npad	1
$LL91@add_leafs_:
	push	DWORD PTR [esi]
	mov	ecx, ebx
	call	?add_leafs_Dynamic@CRender@@AAEXPAVIRender_Visual@@@Z ; CRender::add_leafs_Dynamic
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 74   :         ++_Ptr;

	add	esi, 4
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp

; 304  : 			for (; I!=E; I++)	add_leafs_Dynamic	(*I);

	cmp	esi, edi
	jne	SHORT $LL91@add_leafs_

; 305  : 		}
; 306  : 		return;

	jmp	SHORT $LN730@add_leafs_
$LN99@add_leafs_:

; 307  : 	case MT_SKELETON_ANIM:
; 308  : 	case MT_SKELETON_RIGID:
; 309  : 		{
; 310  : 			// Add all children, doesn't perform any tests
; 311  : 			CKinematics * pV			= (CKinematics*)pVisual;
; 312  : 			BOOL	_use_lod			= FALSE	;
; 313  : 			if (pV->m_lod)				

	mov	edx, DWORD PTR [ebp+84]
	test	edx, edx
	je	$LN103@add_leafs_

; 314  : 			{
; 315  : 				Fvector							Tpos;	float		D;
; 316  : 				val_pTransform->transform_tiny	(Tpos, pV->vis.sphere.P);

	mov	ecx, DWORD PTR [ebx+264]
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 499  : 		dest.x = v.x*_11 + v.y*_21 + v.z*_31 + _41;

	movss	xmm4, DWORD PTR [ebp+12]
	movss	xmm6, DWORD PTR [ebp+8]

; 500  : 		dest.y = v.x*_12 + v.y*_22 + v.z*_32 + _42;

	movaps	xmm0, xmm4
	movss	xmm5, DWORD PTR [ebp+16]
	movaps	xmm1, xmm6
	mulss	xmm0, DWORD PTR [ecx+20]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp

; 31   : 	distSQ	= Device.vCameraPosition.distance_to_sqr(C)+EPS;

	mov	eax, DWORD PTR __imp_?Device@@3VCRenderDevice@@A
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 500  : 		dest.y = v.x*_12 + v.y*_22 + v.z*_32 + _42;

	mulss	xmm1, DWORD PTR [ecx+4]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 287  : 	{	return (x-v.x)*(x-v.x) + (y-v.y)*(y-v.y) + (z-v.z)*(z-v.z);	}

	movss	xmm3, DWORD PTR [eax+492]
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 500  : 		dest.y = v.x*_12 + v.y*_22 + v.z*_32 + _42;

	addss	xmm1, xmm0
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 287  : 	{	return (x-v.x)*(x-v.x) + (y-v.y)*(y-v.y) + (z-v.z)*(z-v.z);	}

	movss	xmm2, DWORD PTR [eax+488]
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 500  : 		dest.y = v.x*_12 + v.y*_22 + v.z*_32 + _42;

	movaps	xmm0, xmm5
	mulss	xmm0, DWORD PTR [ecx+36]
	addss	xmm0, DWORD PTR [ecx+52]
	addss	xmm1, xmm0
	movaps	xmm0, xmm6
	mulss	xmm0, DWORD PTR [ecx]

; 501  : 		dest.z = v.x*_13 + v.y*_23 + v.z*_33 + _43;

	mulss	xmm6, DWORD PTR [ecx+8]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 287  : 	{	return (x-v.x)*(x-v.x) + (y-v.y)*(y-v.y) + (z-v.z)*(z-v.z);	}

	subss	xmm3, xmm1
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 499  : 		dest.x = v.x*_11 + v.y*_21 + v.z*_31 + _41;

	movaps	xmm1, xmm4
	mulss	xmm1, DWORD PTR [ecx+16]

; 501  : 		dest.z = v.x*_13 + v.y*_23 + v.z*_33 + _43;

	mulss	xmm4, DWORD PTR [ecx+24]
	addss	xmm1, xmm0
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 287  : 	{	return (x-v.x)*(x-v.x) + (y-v.y)*(y-v.y) + (z-v.z)*(z-v.z);	}

	mulss	xmm3, xmm3
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 499  : 		dest.x = v.x*_11 + v.y*_21 + v.z*_31 + _41;

	movaps	xmm0, xmm5

; 501  : 		dest.z = v.x*_13 + v.y*_23 + v.z*_33 + _43;

	mulss	xmm5, DWORD PTR [ecx+40]
	mulss	xmm0, DWORD PTR [ecx+32]
	addss	xmm6, xmm4
	addss	xmm5, DWORD PTR [ecx+56]
	addss	xmm0, DWORD PTR [ecx+48]
	addss	xmm6, xmm5
	addss	xmm1, xmm0
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 287  : 	{	return (x-v.x)*(x-v.x) + (y-v.y)*(y-v.y) + (z-v.z)*(z-v.z);	}

	movss	xmm0, DWORD PTR [eax+496]
	subss	xmm0, xmm6
	subss	xmm2, xmm1
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp

; 317  : 				float		ssa		=	CalcSSA	(D,Tpos,pV->vis.sphere.R/2.f);	// assume dynamics never consume full sphere

	movss	xmm1, DWORD PTR [ebp+20]
	mulss	xmm1, xmm7
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 287  : 	{	return (x-v.x)*(x-v.x) + (y-v.y)*(y-v.y) + (z-v.z)*(z-v.z);	}

	mulss	xmm0, xmm0
	mulss	xmm2, xmm2
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp

; 31   : 	distSQ	= Device.vCameraPosition.distance_to_sqr(C)+EPS;

	addss	xmm0, DWORD PTR __real@3727c5ac
	addss	xmm2, xmm3
	addss	xmm2, xmm0

; 318  : 				if (ssa<r_ssaLOD_A)	_use_lod	= TRUE;

	movss	xmm0, DWORD PTR ?r_ssaLOD_A@@3MA

; 32   : 	return	R/distSQ;

	divss	xmm1, xmm2

; 318  : 				if (ssa<r_ssaLOD_A)	_use_lod	= TRUE;

	comiss	xmm0, xmm1
	jbe	SHORT $LN103@add_leafs_

; 319  : 			}
; 320  : 			if (_use_lod)				
; 321  : 			{
; 322  : 				add_leafs_Dynamic			(pV->m_lod)		;

	push	edx
	mov	ecx, ebx
	call	?add_leafs_Dynamic@CRender@@AAEXPAVIRender_Visual@@@Z ; CRender::add_leafs_Dynamic

; 323  : 			} else {

	movss	xmm7, DWORD PTR __real@3f000000
	jmp	$LN77@add_leafs_
$LN103@add_leafs_:

; 324  : 				pV->CalculateBones			(TRUE);

	mov	eax, DWORD PTR [ebp]
	mov	ecx, ebp
	push	1
	call	DWORD PTR [eax+64]

; 325  : 				pV->CalculateWallmarks		();		//. bug?

	mov	ecx, ebp
	call	edi

; 326  : 				I = pV->children.begin		();
; 327  : 				E = pV->children.end		();

	mov	edi, DWORD PTR [ebp+72]

; 328  : 				for (; I!=E; I++)	add_leafs_Dynamic	(*I);

	mov	esi, DWORD PTR [ebp+68]
	cmp	esi, edi
	je	$LN730@add_leafs_
$LL94@add_leafs_:
	push	DWORD PTR [esi]
	mov	ecx, ebx
	call	?add_leafs_Dynamic@CRender@@AAEXPAVIRender_Visual@@@Z ; CRender::add_leafs_Dynamic
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 74   :         ++_Ptr;

	add	esi, 4
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp

; 328  : 				for (; I!=E; I++)	add_leafs_Dynamic	(*I);

	cmp	esi, edi
	jne	SHORT $LL94@add_leafs_

; 329  : 			}
; 330  : 		}
; 331  : 		return;

	jmp	$LN730@add_leafs_
$LN105@add_leafs_:

; 332  : 	default:
; 333  : 		{
; 334  : 			// General type of visual
; 335  : 			// Calculate distance to it's center
; 336  : 			Fvector							Tpos;
; 337  : 			val_pTransform->transform_tiny	(Tpos, pVisual->vis.sphere.P);

	mov	eax, DWORD PTR [ebx+264]

; 338  : 			r_dsgraph_insert_dynamic		(pVisual,Tpos);

	mov	ecx, ebx
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 499  : 		dest.x = v.x*_11 + v.y*_21 + v.z*_31 + _41;

	movss	xmm2, DWORD PTR [ebp+12]
	movss	xmm4, DWORD PTR [ebp+8]
	movaps	xmm1, xmm2
	movss	xmm3, DWORD PTR [ebp+16]
	movaps	xmm0, xmm4
	mulss	xmm0, DWORD PTR [eax]
	mulss	xmm1, DWORD PTR [eax+16]
	addss	xmm1, xmm0
	movaps	xmm0, xmm3
	mulss	xmm0, DWORD PTR [eax+32]
	addss	xmm0, DWORD PTR [eax+48]
	addss	xmm1, xmm0

; 500  : 		dest.y = v.x*_12 + v.y*_22 + v.z*_32 + _42;

	movaps	xmm0, xmm2
	mulss	xmm0, DWORD PTR [eax+20]

; 501  : 		dest.z = v.x*_13 + v.y*_23 + v.z*_33 + _43;

	mulss	xmm2, DWORD PTR [eax+24]
	movss	DWORD PTR _Tpos$4[esp+64], xmm1
	movaps	xmm1, xmm4
	mulss	xmm1, DWORD PTR [eax+4]
	mulss	xmm4, DWORD PTR [eax+8]
	addss	xmm1, xmm0
	movaps	xmm0, xmm3
	mulss	xmm0, DWORD PTR [eax+36]
	mulss	xmm3, DWORD PTR [eax+40]
	addss	xmm4, xmm2
	addss	xmm0, DWORD PTR [eax+52]
	addss	xmm3, DWORD PTR [eax+56]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp

; 338  : 			r_dsgraph_insert_dynamic		(pVisual,Tpos);

	lea	eax, DWORD PTR _Tpos$4[esp+64]
	push	eax
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 500  : 		dest.y = v.x*_12 + v.y*_22 + v.z*_32 + _42;

	addss	xmm1, xmm0
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp

; 338  : 			r_dsgraph_insert_dynamic		(pVisual,Tpos);

	push	ebp
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 501  : 		dest.z = v.x*_13 + v.y*_23 + v.z*_33 + _43;

	addss	xmm4, xmm3
	movss	DWORD PTR _Tpos$4[esp+76], xmm1
	movss	DWORD PTR _Tpos$4[esp+80], xmm4
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp

; 338  : 			r_dsgraph_insert_dynamic		(pVisual,Tpos);

	call	?r_dsgraph_insert_dynamic@R_dsgraph_structure@@QAEXPAVIRender_Visual@@AAU?$_vector3@M@@@Z ; R_dsgraph_structure::r_dsgraph_insert_dynamic
	movss	xmm7, DWORD PTR __real@3f000000
	jmp	$LN77@add_leafs_
$LN262@add_leafs_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	edi, DWORD PTR [ebp+92]

; 150  :         return _Ptr == _Right._Ptr;

	cmp	edi, DWORD PTR [ebp+96]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp

; 290  : 			for (PS::CParticleGroup::SItemVecIt i_it=pG->items.begin(); i_it!=pG->items.end(); i_it++)	{

	je	SHORT $LN7@add_leafs_
	npad	6
$LL248@add_leafs_:

; 291  : 				PS::CParticleGroup::SItem&			I		= *i_it;
; 292  : 				if (I._effect)		add_leafs_Dynamic		(I._effect);

	mov	eax, DWORD PTR [edi]
	test	eax, eax
	je	SHORT $LN263@add_leafs_
	push	eax
	mov	ecx, ebx
	call	?add_leafs_Dynamic@CRender@@AAEXPAVIRender_Visual@@@Z ; CRender::add_leafs_Dynamic
$LN263@add_leafs_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	esi, DWORD PTR [edi+4]

; 150  :         return _Ptr == _Right._Ptr;

	cmp	esi, DWORD PTR [edi+8]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp

; 293  : 				for (xr_vector<IRender_Visual*>::iterator pit = I._children_related.begin();	pit!=I._children_related.end(); pit++)	add_leafs_Dynamic(*pit);

	je	SHORT $LN718@add_leafs_
$LL251@add_leafs_:
	push	DWORD PTR [esi]
	mov	ecx, ebx
	call	?add_leafs_Dynamic@CRender@@AAEXPAVIRender_Visual@@@Z ; CRender::add_leafs_Dynamic
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 74   :         ++_Ptr;

	add	esi, 4

; 150  :         return _Ptr == _Right._Ptr;

	cmp	esi, DWORD PTR [edi+8]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp

; 293  : 				for (xr_vector<IRender_Visual*>::iterator pit = I._children_related.begin();	pit!=I._children_related.end(); pit++)	add_leafs_Dynamic(*pit);

	jne	SHORT $LL251@add_leafs_
$LN718@add_leafs_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	esi, DWORD PTR [edi+16]

; 150  :         return _Ptr == _Right._Ptr;

	cmp	esi, DWORD PTR [edi+20]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp

; 294  : 				for (xr_vector<IRender_Visual*>::iterator pit = I._children_free.begin();		pit!=I._children_free.end();	pit++)	add_leafs_Dynamic(*pit);

	je	SHORT $LN246@add_leafs_
	npad	1
$LL254@add_leafs_:
	push	DWORD PTR [esi]
	mov	ecx, ebx
	call	?add_leafs_Dynamic@CRender@@AAEXPAVIRender_Visual@@@Z ; CRender::add_leafs_Dynamic
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 74   :         ++_Ptr;

	add	esi, 4

; 150  :         return _Ptr == _Right._Ptr;

	cmp	esi, DWORD PTR [edi+20]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp

; 294  : 				for (xr_vector<IRender_Visual*>::iterator pit = I._children_free.begin();		pit!=I._children_free.end();	pit++)	add_leafs_Dynamic(*pit);

	jne	SHORT $LL254@add_leafs_
$LN246@add_leafs_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 74   :         ++_Ptr;

	add	edi, 28					; 0000001cH

; 150  :         return _Ptr == _Right._Ptr;

	cmp	edi, DWORD PTR [ebp+96]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp

; 290  : 			for (PS::CParticleGroup::SItemVecIt i_it=pG->items.begin(); i_it!=pG->items.end(); i_it++)	{

	jne	SHORT $LL248@add_leafs_
$LN731@add_leafs_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 74   :         ++_Ptr;

	mov	eax, DWORD PTR _i_it$1$[esp+64]
$LN733@add_leafs_:
	mov	esi, DWORD PTR _pit$1$[esp+64]
$LN7@add_leafs_:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp

; 359  : 				for (xr_vector<IRender_Visual*>::iterator pit = I._children_related.begin();	pit!=I._children_related.end(); pit++)	add_leafs_Dynamic(*pit);

	movss	xmm7, DWORD PTR __real@3f000000
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 74   :         ++_Ptr;

	add	esi, 4
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp

; 359  : 				for (xr_vector<IRender_Visual*>::iterator pit = I._children_related.begin();	pit!=I._children_related.end(); pit++)	add_leafs_Dynamic(*pit);

	mov	edi, DWORD PTR __imp_?CalculateWallmarks@CKinematics@@QAEXXZ
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 74   :         ++_Ptr;

	mov	DWORD PTR _pit$1$[esp+64], esi

; 150  :         return _Ptr == _Right._Ptr;

	cmp	esi, DWORD PTR [eax+8]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp

; 359  : 				for (xr_vector<IRender_Visual*>::iterator pit = I._children_related.begin();	pit!=I._children_related.end(); pit++)	add_leafs_Dynamic(*pit);

	jne	$LL9@add_leafs_
$LN717@add_leafs_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	esi, DWORD PTR _i_it$1$[esp+64]

; 150  :         return _Ptr == _Right._Ptr;

	mov	eax, DWORD PTR _i_it$1$[esp+64]

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	esi, DWORD PTR [esi+16]
	mov	DWORD PTR _pit$1$[esp+64], esi

; 150  :         return _Ptr == _Right._Ptr;

	cmp	esi, DWORD PTR [eax+20]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp

; 360  : 				for (xr_vector<IRender_Visual*>::iterator pit = I._children_free.begin();		pit!=I._children_free.end();	pit++)	add_leafs_Dynamic(*pit);

	je	$LN4@add_leafs_
	npad	9
$LL12@add_leafs_:
	mov	ebp, DWORD PTR [esi]

; 280  : 	if (0==pVisual)				return;

	test	ebp, ebp
	je	$LN10@add_leafs_

; 281  : 
; 282  : 	// Visual is 100% visible - simply add it
; 283  : 	xr_vector<IRender_Visual*>::iterator I,E;	// it may be useful for 'hierrarhy' visual
; 284  : 
; 285  : 	switch (pVisual->Type) {

	mov	ecx, DWORD PTR [ebp+4]
	dec	ecx
	cmp	ecx, 9
	ja	$LN437@add_leafs_
	movzx	ecx, BYTE PTR $LN728@add_leafs_[ecx]
	jmp	DWORD PTR $LN729@add_leafs_[ecx*4]
$LN264@add_leafs_:

; 303  : 			E = pV->children.end	();

	mov	edi, DWORD PTR [ebp+72]

; 304  : 			for (; I!=E; I++)	add_leafs_Dynamic	(*I);

	mov	esi, DWORD PTR [ebp+68]
	cmp	esi, edi
	je	SHORT $LN733@add_leafs_
	npad	1
$LL257@add_leafs_:
	push	DWORD PTR [esi]
	mov	ecx, ebx
	call	?add_leafs_Dynamic@CRender@@AAEXPAVIRender_Visual@@@Z ; CRender::add_leafs_Dynamic
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 74   :         ++_Ptr;

	add	esi, 4
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp

; 304  : 			for (; I!=E; I++)	add_leafs_Dynamic	(*I);

	cmp	esi, edi
	jne	SHORT $LL257@add_leafs_

; 305  : 		}
; 306  : 		return;

	jmp	$LN731@add_leafs_
$LN265@add_leafs_:

; 307  : 	case MT_SKELETON_ANIM:
; 308  : 	case MT_SKELETON_RIGID:
; 309  : 		{
; 310  : 			// Add all children, doesn't perform any tests
; 311  : 			CKinematics * pV			= (CKinematics*)pVisual;
; 312  : 			BOOL	_use_lod			= FALSE	;
; 313  : 			if (pV->m_lod)				

	mov	edx, DWORD PTR [ebp+84]
	test	edx, edx
	je	$LN269@add_leafs_

; 314  : 			{
; 315  : 				Fvector							Tpos;	float		D;
; 316  : 				val_pTransform->transform_tiny	(Tpos, pV->vis.sphere.P);

	mov	ecx, DWORD PTR [ebx+264]
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 499  : 		dest.x = v.x*_11 + v.y*_21 + v.z*_31 + _41;

	movss	xmm4, DWORD PTR [ebp+12]
	movss	xmm6, DWORD PTR [ebp+8]

; 500  : 		dest.y = v.x*_12 + v.y*_22 + v.z*_32 + _42;

	movaps	xmm0, xmm4
	movss	xmm5, DWORD PTR [ebp+16]
	movaps	xmm1, xmm6
	mulss	xmm0, DWORD PTR [ecx+20]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp

; 31   : 	distSQ	= Device.vCameraPosition.distance_to_sqr(C)+EPS;

	mov	eax, DWORD PTR __imp_?Device@@3VCRenderDevice@@A
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 500  : 		dest.y = v.x*_12 + v.y*_22 + v.z*_32 + _42;

	mulss	xmm1, DWORD PTR [ecx+4]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 287  : 	{	return (x-v.x)*(x-v.x) + (y-v.y)*(y-v.y) + (z-v.z)*(z-v.z);	}

	movss	xmm3, DWORD PTR [eax+492]
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 500  : 		dest.y = v.x*_12 + v.y*_22 + v.z*_32 + _42;

	addss	xmm1, xmm0
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 287  : 	{	return (x-v.x)*(x-v.x) + (y-v.y)*(y-v.y) + (z-v.z)*(z-v.z);	}

	movss	xmm2, DWORD PTR [eax+488]
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 500  : 		dest.y = v.x*_12 + v.y*_22 + v.z*_32 + _42;

	movaps	xmm0, xmm5
	mulss	xmm0, DWORD PTR [ecx+36]
	addss	xmm0, DWORD PTR [ecx+52]
	addss	xmm1, xmm0
	movaps	xmm0, xmm6
	mulss	xmm0, DWORD PTR [ecx]

; 501  : 		dest.z = v.x*_13 + v.y*_23 + v.z*_33 + _43;

	mulss	xmm6, DWORD PTR [ecx+8]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 287  : 	{	return (x-v.x)*(x-v.x) + (y-v.y)*(y-v.y) + (z-v.z)*(z-v.z);	}

	subss	xmm3, xmm1
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 499  : 		dest.x = v.x*_11 + v.y*_21 + v.z*_31 + _41;

	movaps	xmm1, xmm4
	mulss	xmm1, DWORD PTR [ecx+16]

; 501  : 		dest.z = v.x*_13 + v.y*_23 + v.z*_33 + _43;

	mulss	xmm4, DWORD PTR [ecx+24]
	addss	xmm1, xmm0
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 287  : 	{	return (x-v.x)*(x-v.x) + (y-v.y)*(y-v.y) + (z-v.z)*(z-v.z);	}

	mulss	xmm3, xmm3
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 499  : 		dest.x = v.x*_11 + v.y*_21 + v.z*_31 + _41;

	movaps	xmm0, xmm5

; 501  : 		dest.z = v.x*_13 + v.y*_23 + v.z*_33 + _43;

	mulss	xmm5, DWORD PTR [ecx+40]
	mulss	xmm0, DWORD PTR [ecx+32]
	addss	xmm6, xmm4
	addss	xmm5, DWORD PTR [ecx+56]
	addss	xmm0, DWORD PTR [ecx+48]
	addss	xmm6, xmm5
	addss	xmm1, xmm0
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 287  : 	{	return (x-v.x)*(x-v.x) + (y-v.y)*(y-v.y) + (z-v.z)*(z-v.z);	}

	movss	xmm0, DWORD PTR [eax+496]
	subss	xmm0, xmm6
	subss	xmm2, xmm1
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp

; 317  : 				float		ssa		=	CalcSSA	(D,Tpos,pV->vis.sphere.R/2.f);	// assume dynamics never consume full sphere

	movss	xmm1, DWORD PTR [ebp+20]
	mulss	xmm1, xmm7
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 287  : 	{	return (x-v.x)*(x-v.x) + (y-v.y)*(y-v.y) + (z-v.z)*(z-v.z);	}

	mulss	xmm0, xmm0
	mulss	xmm2, xmm2
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp

; 31   : 	distSQ	= Device.vCameraPosition.distance_to_sqr(C)+EPS;

	addss	xmm0, DWORD PTR __real@3727c5ac
	addss	xmm2, xmm3
	addss	xmm2, xmm0

; 318  : 				if (ssa<r_ssaLOD_A)	_use_lod	= TRUE;

	movss	xmm0, DWORD PTR ?r_ssaLOD_A@@3MA

; 32   : 	return	R/distSQ;

	divss	xmm1, xmm2

; 318  : 				if (ssa<r_ssaLOD_A)	_use_lod	= TRUE;

	comiss	xmm0, xmm1
	jbe	SHORT $LN269@add_leafs_

; 319  : 			}
; 320  : 			if (_use_lod)				
; 321  : 			{
; 322  : 				add_leafs_Dynamic			(pV->m_lod)		;

	push	edx
	mov	ecx, ebx
	call	?add_leafs_Dynamic@CRender@@AAEXPAVIRender_Visual@@@Z ; CRender::add_leafs_Dynamic

; 323  : 			} else {

	mov	eax, DWORD PTR _i_it$1$[esp+64]
	jmp	$LN7@add_leafs_
$LN269@add_leafs_:

; 324  : 				pV->CalculateBones			(TRUE);

	mov	eax, DWORD PTR [ebp]
	mov	ecx, ebp
	push	1
	call	DWORD PTR [eax+64]

; 325  : 				pV->CalculateWallmarks		();		//. bug?

	mov	ecx, ebp
	call	edi

; 326  : 				I = pV->children.begin		();
; 327  : 				E = pV->children.end		();

	mov	edi, DWORD PTR [ebp+72]

; 328  : 				for (; I!=E; I++)	add_leafs_Dynamic	(*I);

	mov	esi, DWORD PTR [ebp+68]
	cmp	esi, edi
	je	$LN731@add_leafs_
$LL260@add_leafs_:
	push	DWORD PTR [esi]
	mov	ecx, ebx
	call	?add_leafs_Dynamic@CRender@@AAEXPAVIRender_Visual@@@Z ; CRender::add_leafs_Dynamic
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 74   :         ++_Ptr;

	add	esi, 4
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp

; 328  : 				for (; I!=E; I++)	add_leafs_Dynamic	(*I);

	cmp	esi, edi
	jne	SHORT $LL260@add_leafs_

; 329  : 			}
; 330  : 		}
; 331  : 		return;

	jmp	$LN731@add_leafs_
$LN271@add_leafs_:

; 332  : 	default:
; 333  : 		{
; 334  : 			// General type of visual
; 335  : 			// Calculate distance to it's center
; 336  : 			Fvector							Tpos;
; 337  : 			val_pTransform->transform_tiny	(Tpos, pVisual->vis.sphere.P);

	mov	eax, DWORD PTR [ebx+264]

; 338  : 			r_dsgraph_insert_dynamic		(pVisual,Tpos);

	mov	ecx, ebx
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 499  : 		dest.x = v.x*_11 + v.y*_21 + v.z*_31 + _41;

	movss	xmm2, DWORD PTR [ebp+12]
	movss	xmm4, DWORD PTR [ebp+8]
	movaps	xmm1, xmm2
	movss	xmm3, DWORD PTR [ebp+16]
	movaps	xmm0, xmm4
	mulss	xmm0, DWORD PTR [eax]
	mulss	xmm1, DWORD PTR [eax+16]
	addss	xmm1, xmm0
	movaps	xmm0, xmm3
	mulss	xmm0, DWORD PTR [eax+32]
	addss	xmm0, DWORD PTR [eax+48]
	addss	xmm1, xmm0

; 500  : 		dest.y = v.x*_12 + v.y*_22 + v.z*_32 + _42;

	movaps	xmm0, xmm2
	mulss	xmm0, DWORD PTR [eax+20]

; 501  : 		dest.z = v.x*_13 + v.y*_23 + v.z*_33 + _43;

	mulss	xmm2, DWORD PTR [eax+24]
	movss	DWORD PTR _Tpos$5[esp+64], xmm1
	movaps	xmm1, xmm4
	mulss	xmm1, DWORD PTR [eax+4]
	mulss	xmm4, DWORD PTR [eax+8]
	addss	xmm1, xmm0
	movaps	xmm0, xmm3
	mulss	xmm0, DWORD PTR [eax+36]
	mulss	xmm3, DWORD PTR [eax+40]
	addss	xmm4, xmm2
	addss	xmm0, DWORD PTR [eax+52]
	addss	xmm3, DWORD PTR [eax+56]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp

; 338  : 			r_dsgraph_insert_dynamic		(pVisual,Tpos);

	lea	eax, DWORD PTR _Tpos$5[esp+64]
	push	eax
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 500  : 		dest.y = v.x*_12 + v.y*_22 + v.z*_32 + _42;

	addss	xmm1, xmm0
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp

; 338  : 			r_dsgraph_insert_dynamic		(pVisual,Tpos);

	push	ebp
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 501  : 		dest.z = v.x*_13 + v.y*_23 + v.z*_33 + _43;

	addss	xmm4, xmm3
	movss	DWORD PTR _Tpos$5[esp+76], xmm1
	movss	DWORD PTR _Tpos$5[esp+80], xmm4
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp

; 338  : 			r_dsgraph_insert_dynamic		(pVisual,Tpos);

	call	?r_dsgraph_insert_dynamic@R_dsgraph_structure@@QAEXPAVIRender_Visual@@AAU?$_vector3@M@@@Z ; R_dsgraph_structure::r_dsgraph_insert_dynamic
	mov	eax, DWORD PTR _i_it$1$[esp+64]
	jmp	$LN7@add_leafs_
$LN428@add_leafs_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	edi, DWORD PTR [ebp+92]

; 150  :         return _Ptr == _Right._Ptr;

	cmp	edi, DWORD PTR [ebp+96]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp

; 290  : 			for (PS::CParticleGroup::SItemVecIt i_it=pG->items.begin(); i_it!=pG->items.end(); i_it++)	{

	je	SHORT $LN10@add_leafs_
$LL414@add_leafs_:

; 291  : 				PS::CParticleGroup::SItem&			I		= *i_it;
; 292  : 				if (I._effect)		add_leafs_Dynamic		(I._effect);

	mov	eax, DWORD PTR [edi]
	test	eax, eax
	je	SHORT $LN429@add_leafs_
	push	eax
	mov	ecx, ebx
	call	?add_leafs_Dynamic@CRender@@AAEXPAVIRender_Visual@@@Z ; CRender::add_leafs_Dynamic
$LN429@add_leafs_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	esi, DWORD PTR [edi+4]

; 150  :         return _Ptr == _Right._Ptr;

	cmp	esi, DWORD PTR [edi+8]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp

; 293  : 				for (xr_vector<IRender_Visual*>::iterator pit = I._children_related.begin();	pit!=I._children_related.end(); pit++)	add_leafs_Dynamic(*pit);

	je	SHORT $LN720@add_leafs_
	npad	5
$LL417@add_leafs_:
	push	DWORD PTR [esi]
	mov	ecx, ebx
	call	?add_leafs_Dynamic@CRender@@AAEXPAVIRender_Visual@@@Z ; CRender::add_leafs_Dynamic
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 74   :         ++_Ptr;

	add	esi, 4

; 150  :         return _Ptr == _Right._Ptr;

	cmp	esi, DWORD PTR [edi+8]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp

; 293  : 				for (xr_vector<IRender_Visual*>::iterator pit = I._children_related.begin();	pit!=I._children_related.end(); pit++)	add_leafs_Dynamic(*pit);

	jne	SHORT $LL417@add_leafs_
$LN720@add_leafs_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	esi, DWORD PTR [edi+16]

; 150  :         return _Ptr == _Right._Ptr;

	cmp	esi, DWORD PTR [edi+20]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp

; 294  : 				for (xr_vector<IRender_Visual*>::iterator pit = I._children_free.begin();		pit!=I._children_free.end();	pit++)	add_leafs_Dynamic(*pit);

	je	SHORT $LN412@add_leafs_
	npad	7
$LL420@add_leafs_:
	push	DWORD PTR [esi]
	mov	ecx, ebx
	call	?add_leafs_Dynamic@CRender@@AAEXPAVIRender_Visual@@@Z ; CRender::add_leafs_Dynamic
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 74   :         ++_Ptr;

	add	esi, 4

; 150  :         return _Ptr == _Right._Ptr;

	cmp	esi, DWORD PTR [edi+20]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp

; 294  : 				for (xr_vector<IRender_Visual*>::iterator pit = I._children_free.begin();		pit!=I._children_free.end();	pit++)	add_leafs_Dynamic(*pit);

	jne	SHORT $LL420@add_leafs_
$LN412@add_leafs_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 74   :         ++_Ptr;

	add	edi, 28					; 0000001cH

; 150  :         return _Ptr == _Right._Ptr;

	cmp	edi, DWORD PTR [ebp+96]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp

; 290  : 			for (PS::CParticleGroup::SItemVecIt i_it=pG->items.begin(); i_it!=pG->items.end(); i_it++)	{

	jne	SHORT $LL414@add_leafs_
$LN732@add_leafs_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 74   :         ++_Ptr;

	mov	eax, DWORD PTR _i_it$1$[esp+64]
$LN734@add_leafs_:
	mov	esi, DWORD PTR _pit$1$[esp+64]
$LN10@add_leafs_:
	add	esi, 4
	mov	DWORD PTR _pit$1$[esp+64], esi

; 150  :         return _Ptr == _Right._Ptr;

	cmp	esi, DWORD PTR [eax+20]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp

; 360  : 				for (xr_vector<IRender_Visual*>::iterator pit = I._children_free.begin();		pit!=I._children_free.end();	pit++)	add_leafs_Dynamic(*pit);

	jne	$LL12@add_leafs_
$LN4@add_leafs_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 74   :         ++_Ptr;

	mov	esi, DWORD PTR _i_it$1$[esp+64]

; 150  :         return _Ptr == _Right._Ptr;

	mov	eax, DWORD PTR _pVisual$[esp+60]

; 74   :         ++_Ptr;

	add	esi, 28					; 0000001cH
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp

; 356  : 			for (PS::CParticleGroup::SItemVecIt i_it=pG->items.begin(); i_it!=pG->items.end(); i_it++){

	movss	xmm7, DWORD PTR __real@3f000000
	mov	edi, DWORD PTR __imp_?CalculateWallmarks@CKinematics@@QAEXXZ
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 74   :         ++_Ptr;

	mov	DWORD PTR _i_it$1$[esp+64], esi

; 150  :         return _Ptr == _Right._Ptr;

	cmp	esi, DWORD PTR [eax+96]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp

; 356  : 			for (PS::CParticleGroup::SItemVecIt i_it=pG->items.begin(); i_it!=pG->items.end(); i_it++){

	jne	$LL6@add_leafs_

; 420  : }

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 48					; 00000030H
	ret	4
$LN430@add_leafs_:

; 303  : 			E = pV->children.end	();

	mov	edi, DWORD PTR [ebp+72]

; 304  : 			for (; I!=E; I++)	add_leafs_Dynamic	(*I);

	mov	esi, DWORD PTR [ebp+68]
	cmp	esi, edi
	je	SHORT $LN734@add_leafs_
	npad	5
$LL423@add_leafs_:
	push	DWORD PTR [esi]
	mov	ecx, ebx
	call	?add_leafs_Dynamic@CRender@@AAEXPAVIRender_Visual@@@Z ; CRender::add_leafs_Dynamic
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 74   :         ++_Ptr;

	add	esi, 4
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp

; 304  : 			for (; I!=E; I++)	add_leafs_Dynamic	(*I);

	cmp	esi, edi
	jne	SHORT $LL423@add_leafs_

; 305  : 		}
; 306  : 		return;

	jmp	SHORT $LN732@add_leafs_
$LN431@add_leafs_:

; 307  : 	case MT_SKELETON_ANIM:
; 308  : 	case MT_SKELETON_RIGID:
; 309  : 		{
; 310  : 			// Add all children, doesn't perform any tests
; 311  : 			CKinematics * pV			= (CKinematics*)pVisual;
; 312  : 			BOOL	_use_lod			= FALSE	;
; 313  : 			if (pV->m_lod)				

	mov	edx, DWORD PTR [ebp+84]
	test	edx, edx
	je	$LN435@add_leafs_

; 314  : 			{
; 315  : 				Fvector							Tpos;	float		D;
; 316  : 				val_pTransform->transform_tiny	(Tpos, pV->vis.sphere.P);

	mov	ecx, DWORD PTR [ebx+264]
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 499  : 		dest.x = v.x*_11 + v.y*_21 + v.z*_31 + _41;

	movss	xmm4, DWORD PTR [ebp+12]
	movss	xmm6, DWORD PTR [ebp+8]

; 500  : 		dest.y = v.x*_12 + v.y*_22 + v.z*_32 + _42;

	movaps	xmm0, xmm4
	movss	xmm5, DWORD PTR [ebp+16]
	movaps	xmm1, xmm6
	mulss	xmm0, DWORD PTR [ecx+20]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp

; 31   : 	distSQ	= Device.vCameraPosition.distance_to_sqr(C)+EPS;

	mov	eax, DWORD PTR __imp_?Device@@3VCRenderDevice@@A
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 500  : 		dest.y = v.x*_12 + v.y*_22 + v.z*_32 + _42;

	mulss	xmm1, DWORD PTR [ecx+4]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 287  : 	{	return (x-v.x)*(x-v.x) + (y-v.y)*(y-v.y) + (z-v.z)*(z-v.z);	}

	movss	xmm3, DWORD PTR [eax+492]
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 500  : 		dest.y = v.x*_12 + v.y*_22 + v.z*_32 + _42;

	addss	xmm1, xmm0
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 287  : 	{	return (x-v.x)*(x-v.x) + (y-v.y)*(y-v.y) + (z-v.z)*(z-v.z);	}

	movss	xmm2, DWORD PTR [eax+488]
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 500  : 		dest.y = v.x*_12 + v.y*_22 + v.z*_32 + _42;

	movaps	xmm0, xmm5
	mulss	xmm0, DWORD PTR [ecx+36]
	addss	xmm0, DWORD PTR [ecx+52]
	addss	xmm1, xmm0
	movaps	xmm0, xmm6
	mulss	xmm0, DWORD PTR [ecx]

; 501  : 		dest.z = v.x*_13 + v.y*_23 + v.z*_33 + _43;

	mulss	xmm6, DWORD PTR [ecx+8]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 287  : 	{	return (x-v.x)*(x-v.x) + (y-v.y)*(y-v.y) + (z-v.z)*(z-v.z);	}

	subss	xmm3, xmm1
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 499  : 		dest.x = v.x*_11 + v.y*_21 + v.z*_31 + _41;

	movaps	xmm1, xmm4
	mulss	xmm1, DWORD PTR [ecx+16]

; 501  : 		dest.z = v.x*_13 + v.y*_23 + v.z*_33 + _43;

	mulss	xmm4, DWORD PTR [ecx+24]
	addss	xmm1, xmm0
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 287  : 	{	return (x-v.x)*(x-v.x) + (y-v.y)*(y-v.y) + (z-v.z)*(z-v.z);	}

	mulss	xmm3, xmm3
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 499  : 		dest.x = v.x*_11 + v.y*_21 + v.z*_31 + _41;

	movaps	xmm0, xmm5

; 501  : 		dest.z = v.x*_13 + v.y*_23 + v.z*_33 + _43;

	mulss	xmm5, DWORD PTR [ecx+40]
	mulss	xmm0, DWORD PTR [ecx+32]
	addss	xmm6, xmm4
	addss	xmm5, DWORD PTR [ecx+56]
	addss	xmm0, DWORD PTR [ecx+48]
	addss	xmm6, xmm5
	addss	xmm1, xmm0
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 287  : 	{	return (x-v.x)*(x-v.x) + (y-v.y)*(y-v.y) + (z-v.z)*(z-v.z);	}

	movss	xmm0, DWORD PTR [eax+496]
	subss	xmm0, xmm6
	subss	xmm2, xmm1
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp

; 317  : 				float		ssa		=	CalcSSA	(D,Tpos,pV->vis.sphere.R/2.f);	// assume dynamics never consume full sphere

	movss	xmm1, DWORD PTR [ebp+20]
	mulss	xmm1, DWORD PTR __real@3f000000
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 287  : 	{	return (x-v.x)*(x-v.x) + (y-v.y)*(y-v.y) + (z-v.z)*(z-v.z);	}

	mulss	xmm0, xmm0
	mulss	xmm2, xmm2
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp

; 31   : 	distSQ	= Device.vCameraPosition.distance_to_sqr(C)+EPS;

	addss	xmm0, DWORD PTR __real@3727c5ac
	addss	xmm2, xmm3
	addss	xmm2, xmm0

; 318  : 				if (ssa<r_ssaLOD_A)	_use_lod	= TRUE;

	movss	xmm0, DWORD PTR ?r_ssaLOD_A@@3MA

; 32   : 	return	R/distSQ;

	divss	xmm1, xmm2

; 318  : 				if (ssa<r_ssaLOD_A)	_use_lod	= TRUE;

	comiss	xmm0, xmm1
	jbe	SHORT $LN435@add_leafs_

; 319  : 			}
; 320  : 			if (_use_lod)				
; 321  : 			{
; 322  : 				add_leafs_Dynamic			(pV->m_lod)		;

	push	edx
	mov	ecx, ebx
	call	?add_leafs_Dynamic@CRender@@AAEXPAVIRender_Visual@@@Z ; CRender::add_leafs_Dynamic

; 323  : 			} else {

	mov	eax, DWORD PTR _i_it$1$[esp+64]
	jmp	$LN10@add_leafs_
$LN435@add_leafs_:

; 324  : 				pV->CalculateBones			(TRUE);

	mov	eax, DWORD PTR [ebp]
	mov	ecx, ebp
	push	1
	call	DWORD PTR [eax+64]

; 325  : 				pV->CalculateWallmarks		();		//. bug?

	mov	ecx, ebp
	call	DWORD PTR __imp_?CalculateWallmarks@CKinematics@@QAEXXZ

; 326  : 				I = pV->children.begin		();
; 327  : 				E = pV->children.end		();

	mov	edi, DWORD PTR [ebp+72]

; 328  : 				for (; I!=E; I++)	add_leafs_Dynamic	(*I);

	mov	esi, DWORD PTR [ebp+68]
	cmp	esi, edi
	je	$LN732@add_leafs_
	npad	5
$LL426@add_leafs_:
	push	DWORD PTR [esi]
	mov	ecx, ebx
	call	?add_leafs_Dynamic@CRender@@AAEXPAVIRender_Visual@@@Z ; CRender::add_leafs_Dynamic
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 74   :         ++_Ptr;

	add	esi, 4
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp

; 328  : 				for (; I!=E; I++)	add_leafs_Dynamic	(*I);

	cmp	esi, edi
	jne	SHORT $LL426@add_leafs_

; 329  : 			}
; 330  : 		}
; 331  : 		return;

	jmp	$LN732@add_leafs_
$LN437@add_leafs_:

; 332  : 	default:
; 333  : 		{
; 334  : 			// General type of visual
; 335  : 			// Calculate distance to it's center
; 336  : 			Fvector							Tpos;
; 337  : 			val_pTransform->transform_tiny	(Tpos, pVisual->vis.sphere.P);

	mov	eax, DWORD PTR [ebx+264]

; 338  : 			r_dsgraph_insert_dynamic		(pVisual,Tpos);

	mov	ecx, ebx
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 499  : 		dest.x = v.x*_11 + v.y*_21 + v.z*_31 + _41;

	movss	xmm2, DWORD PTR [ebp+12]
	movss	xmm4, DWORD PTR [ebp+8]
	movaps	xmm1, xmm2
	movss	xmm3, DWORD PTR [ebp+16]
	movaps	xmm0, xmm4
	mulss	xmm0, DWORD PTR [eax]
	mulss	xmm1, DWORD PTR [eax+16]
	addss	xmm1, xmm0
	movaps	xmm0, xmm3
	mulss	xmm0, DWORD PTR [eax+32]
	addss	xmm0, DWORD PTR [eax+48]
	addss	xmm1, xmm0

; 500  : 		dest.y = v.x*_12 + v.y*_22 + v.z*_32 + _42;

	movaps	xmm0, xmm2
	mulss	xmm0, DWORD PTR [eax+20]

; 501  : 		dest.z = v.x*_13 + v.y*_23 + v.z*_33 + _43;

	mulss	xmm2, DWORD PTR [eax+24]
	movss	DWORD PTR _Tpos$6[esp+64], xmm1
	movaps	xmm1, xmm4
	mulss	xmm1, DWORD PTR [eax+4]
	mulss	xmm4, DWORD PTR [eax+8]
	addss	xmm1, xmm0
	movaps	xmm0, xmm3
	mulss	xmm0, DWORD PTR [eax+36]
	mulss	xmm3, DWORD PTR [eax+40]
	addss	xmm4, xmm2
	addss	xmm0, DWORD PTR [eax+52]
	addss	xmm3, DWORD PTR [eax+56]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp

; 338  : 			r_dsgraph_insert_dynamic		(pVisual,Tpos);

	lea	eax, DWORD PTR _Tpos$6[esp+64]
	push	eax
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 500  : 		dest.y = v.x*_12 + v.y*_22 + v.z*_32 + _42;

	addss	xmm1, xmm0
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp

; 338  : 			r_dsgraph_insert_dynamic		(pVisual,Tpos);

	push	ebp
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 501  : 		dest.z = v.x*_13 + v.y*_23 + v.z*_33 + _43;

	addss	xmm4, xmm3
	movss	DWORD PTR _Tpos$6[esp+76], xmm1
	movss	DWORD PTR _Tpos$6[esp+80], xmm4
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp

; 338  : 			r_dsgraph_insert_dynamic		(pVisual,Tpos);

	call	?r_dsgraph_insert_dynamic@R_dsgraph_structure@@QAEXPAVIRender_Visual@@AAU?$_vector3@M@@@Z ; R_dsgraph_structure::r_dsgraph_insert_dynamic
	mov	eax, DWORD PTR _i_it$1$[esp+64]
	jmp	$LN10@add_leafs_
$LN25@add_leafs_:

; 361  : 			}
; 362  : 		}
; 363  : 		return;
; 364  : 	case MT_HIERRARHY:
; 365  : 		{
; 366  : 			// Add all children, doesn't perform any tests
; 367  : 			FHierrarhyVisual* pV	= (FHierrarhyVisual*)pVisual;
; 368  : 			I = pV->children.begin	();
; 369  : 			E = pV->children.end	();

	mov	edi, DWORD PTR [ebp+72]

; 370  : 			for (; I!=E; I++)		add_leafs_Static (*I);

	mov	esi, DWORD PTR [ebp+68]
	cmp	esi, edi
	je	$LN1@add_leafs_
$LL15@add_leafs_:
	push	DWORD PTR [esi]
	mov	ecx, ebx
	call	?add_leafs_Static@CRender@@AAEXPAVIRender_Visual@@@Z ; CRender::add_leafs_Static
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 74   :         ++_Ptr;

	add	esi, 4
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp

; 370  : 			for (; I!=E; I++)		add_leafs_Static (*I);

	cmp	esi, edi
	jne	SHORT $LL15@add_leafs_

; 420  : }

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 48					; 00000030H
	ret	4
$LN26@add_leafs_:

; 371  : 		}
; 372  : 		return;
; 373  : 	case MT_SKELETON_ANIM:
; 374  : 	case MT_SKELETON_RIGID:
; 375  : 		{
; 376  : 			// Add all children, doesn't perform any tests
; 377  : 			CKinematics * pV		= (CKinematics*)pVisual;
; 378  : 			pV->CalculateBones		(TRUE);

	mov	eax, DWORD PTR [ebp]
	mov	ecx, ebp
	push	1
	call	DWORD PTR [eax+64]

; 379  : 			I = pV->children.begin	();
; 380  : 			E = pV->children.end	();

	mov	edi, DWORD PTR [ebp+72]

; 381  : 			for (; I!=E; I++)		add_leafs_Static	(*I);

	mov	esi, DWORD PTR [ebp+68]
	cmp	esi, edi
	je	$LN1@add_leafs_
$LL18@add_leafs_:
	push	DWORD PTR [esi]
	mov	ecx, ebx
	call	?add_leafs_Static@CRender@@AAEXPAVIRender_Visual@@@Z ; CRender::add_leafs_Static
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 74   :         ++_Ptr;

	add	esi, 4
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp

; 381  : 			for (; I!=E; I++)		add_leafs_Static	(*I);

	cmp	esi, edi
	jne	SHORT $LL18@add_leafs_

; 420  : }

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 48					; 00000030H
	ret	4
$LN28@add_leafs_:

; 26   : 	distSQ	= Device.vCameraPosition.distance_to_sqr(C)+EPS;

	mov	eax, DWORD PTR __imp_?Device@@3VCRenderDevice@@A
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 287  : 	{	return (x-v.x)*(x-v.x) + (y-v.y)*(y-v.y) + (z-v.z)*(z-v.z);	}

	movss	xmm1, DWORD PTR [eax+492]
	subss	xmm1, DWORD PTR [ebp+12]
	movss	xmm0, DWORD PTR [eax+496]
	movss	xmm2, DWORD PTR [eax+488]
	subss	xmm2, DWORD PTR [ebp+8]
	subss	xmm0, DWORD PTR [ebp+16]
	mulss	xmm1, xmm1
	mulss	xmm2, xmm2
	mulss	xmm0, xmm0
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp

; 26   : 	distSQ	= Device.vCameraPosition.distance_to_sqr(C)+EPS;

	addss	xmm2, xmm1

; 27   : 	return	R/distSQ;

	movss	xmm1, DWORD PTR [ebp+20]
	addss	xmm0, DWORD PTR __real@3727c5ac
	addss	xmm2, xmm0

; 390  : 			if (ssa<r_ssaLOD_A)

	movss	xmm0, DWORD PTR ?r_ssaLOD_A@@3MA

; 27   : 	return	R/distSQ;

	divss	xmm1, xmm2
	movss	DWORD PTR _D$7[esp+60], xmm2

; 382  : 		}
; 383  : 		return;
; 384  : 	case MT_LOD:
; 385  : 		{
; 386  : 			FLOD		* pV	=		(FLOD*) pVisual;
; 387  : 			float		D;
; 388  : 			float		ssa		=		CalcSSA(D,pV->vis.sphere.P,pV);
; 389  : 			ssa					*=		pV->lod_factor;

	mulss	xmm1, DWORD PTR [ebp+1080]

; 390  : 			if (ssa<r_ssaLOD_A)

	comiss	xmm0, xmm1
	movss	DWORD PTR _ssa$1$[esp+64], xmm1
	jbe	SHORT $LN29@add_leafs_

; 391  : 			{
; 392  : 				if (ssa<r_ssaDISCARD)	return;

	movss	xmm0, DWORD PTR ?r_ssaDISCARD@@3MA
	comiss	xmm0, xmm1
	ja	SHORT $LN1@add_leafs_

; 393  : 				mapLOD_Node*	N	=	mapLOD.insertInAnyWay(D);

	lea	eax, DWORD PTR _D$7[esp+60]
	push	eax
	lea	ecx, DWORD PTR [ebx+376]
	call	?insertInAnyWay@?$FixedMAP@MU_LodItem@R_dsgraph@@Udoug_lea_allocator@@@@QAEPAUTNode@1@ABM@Z ; FixedMAP<float,R_dsgraph::_LodItem,doug_lea_allocator>::insertInAnyWay

; 394  : 				N->val.ssa			=	ssa;

	movss	xmm1, DWORD PTR _ssa$1$[esp+64]
	movss	DWORD PTR [eax+4], xmm1

; 395  : 				N->val.pVisual		=	pVisual;

	mov	DWORD PTR [eax+8], ebp
$LN29@add_leafs_:

; 396  : 			}
; 397  : 			if (ssa>r_ssaLOD_B)

	comiss	xmm1, DWORD PTR ?r_ssaLOD_B@@3MA
	jbe	SHORT $LN1@add_leafs_

; 398  : 			{
; 399  : 				// Add all children, doesn't perform any tests
; 400  : 				I = pV->children.begin	();
; 401  : 				E = pV->children.end	();

	mov	edi, DWORD PTR [ebp+72]

; 402  : 				for (; I!=E; I++)	add_leafs_Static (*I);

	mov	esi, DWORD PTR [ebp+68]
	cmp	esi, edi
	je	SHORT $LN1@add_leafs_
$LL21@add_leafs_:
	push	DWORD PTR [esi]
	mov	ecx, ebx
	call	?add_leafs_Static@CRender@@AAEXPAVIRender_Visual@@@Z ; CRender::add_leafs_Static
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 74   :         ++_Ptr;

	add	esi, 4
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp

; 402  : 				for (; I!=E; I++)	add_leafs_Static (*I);

	cmp	esi, edi
	jne	SHORT $LL21@add_leafs_

; 420  : }

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 48					; 00000030H
	ret	4
$LN34@add_leafs_:

; 403  : 			}
; 404  : 		}
; 405  : 		return;
; 406  : 	case MT_TREE_PM:
; 407  : 	case MT_TREE_ST:
; 408  : 		{
; 409  : 			// General type of visual
; 410  : 			r_dsgraph_insert_static		(pVisual);
; 411  : 		}
; 412  : 		return;
; 413  : 	default:
; 414  : 		{
; 415  : 			// General type of visual
; 416  : 			r_dsgraph_insert_static		(pVisual);

	push	ebp
	mov	ecx, ebx
	call	?r_dsgraph_insert_static@R_dsgraph_structure@@QAEXPAVIRender_Visual@@@Z ; R_dsgraph_structure::r_dsgraph_insert_static
$LN1@add_leafs_:

; 420  : }

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 48					; 00000030H
	ret	4
	npad	3
$LN723@add_leafs_:
	DD	$LN25@add_leafs_
	DD	$LN26@add_leafs_
	DD	$LN28@add_leafs_
	DD	$LN34@add_leafs_
	DD	$LN23@add_leafs_
	DD	$LN34@add_leafs_
$LN722@add_leafs_:
	DB	0
	DB	5
	DB	1
	DB	5
	DB	5
	DB	2
	DB	3
	DB	5
	DB	4
	DB	1
	DB	3
	npad	1
$LN725@add_leafs_:
	DD	$LN98@add_leafs_
	DD	$LN99@add_leafs_
	DD	$LN96@add_leafs_
	DD	$LN105@add_leafs_
$LN724@add_leafs_:
	DB	0
	DB	3
	DB	1
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	2
	DB	1
	npad	2
$LN727@add_leafs_:
	DD	$LN264@add_leafs_
	DD	$LN265@add_leafs_
	DD	$LN262@add_leafs_
	DD	$LN271@add_leafs_
$LN726@add_leafs_:
	DB	0
	DB	3
	DB	1
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	2
	DB	1
	npad	2
$LN729@add_leafs_:
	DD	$LN430@add_leafs_
	DD	$LN431@add_leafs_
	DD	$LN428@add_leafs_
	DD	$LN437@add_leafs_
$LN728@add_leafs_:
	DB	0
	DB	3
	DB	1
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	2
	DB	1
?add_leafs_Static@CRender@@AAEXPAVIRender_Visual@@@Z ENDP ; CRender::add_leafs_Static
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp
_TEXT	SEGMENT
_i_it$1$ = -60						; size = 4
_pit$1$ = -56						; size = 4
_pit$1$ = -56						; size = 4
_VIS$1$ = -52						; size = 4
_Tpos$ = -48						; size = 12
_Tpos$5 = -36						; size = 12
_Tpos$6 = -24						; size = 12
_Tpos$7 = -12						; size = 12
_pVisual$ = 8						; size = 4
_planes$ = 12						; size = 4
?add_Dynamic@CRender@@AAEHPAVIRender_Visual@@I@Z PROC	; CRender::add_Dynamic
; _this$ = ecx

; 426  : {

	sub	esp, 60					; 0000003cH
	push	ebx
	push	ebp
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 499  : 		dest.x = v.x*_11 + v.y*_21 + v.z*_31 + _41;

	mov	ebp, DWORD PTR _pVisual$[esp+64]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp

; 426  : {

	mov	ebx, ecx

; 427  : 	// Check frustum visibility and calculate distance to visual's center
; 428  : 	Fvector		Tpos;	// transformed position
; 429  : 	EFC_Visible	VIS;
; 430  : 
; 431  : 	val_pTransform->transform_tiny	(Tpos, pVisual->vis.sphere.P);

	mov	eax, DWORD PTR [ebx+264]
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 499  : 		dest.x = v.x*_11 + v.y*_21 + v.z*_31 + _41;

	movss	xmm2, DWORD PTR [ebp+12]
	movss	xmm4, DWORD PTR [ebp+8]
	movaps	xmm1, xmm2
	movss	xmm3, DWORD PTR [ebp+16]
	movaps	xmm0, xmm4
	mulss	xmm0, DWORD PTR [eax]
	mulss	xmm1, DWORD PTR [eax+16]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp

; 432  : 	VIS = View->testSphere			(Tpos, pVisual->vis.sphere.R,planes);

	fld	DWORD PTR [ebp+20]
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 499  : 		dest.x = v.x*_11 + v.y*_21 + v.z*_31 + _41;

	addss	xmm1, xmm0
	movaps	xmm0, xmm3
	mulss	xmm0, DWORD PTR [eax+32]
	addss	xmm0, DWORD PTR [eax+48]
	addss	xmm1, xmm0

; 500  : 		dest.y = v.x*_12 + v.y*_22 + v.z*_32 + _42;

	movaps	xmm0, xmm2
	movss	DWORD PTR _Tpos$[esp+68], xmm1
	movaps	xmm1, xmm4
	mulss	xmm0, DWORD PTR [eax+20]
	mulss	xmm1, DWORD PTR [eax+4]
	addss	xmm1, xmm0
	movaps	xmm0, xmm3
	mulss	xmm0, DWORD PTR [eax+36]
	addss	xmm0, DWORD PTR [eax+52]
	addss	xmm1, xmm0
	movss	DWORD PTR _Tpos$[esp+72], xmm1

; 501  : 		dest.z = v.x*_13 + v.y*_23 + v.z*_33 + _43;

	mulss	xmm4, DWORD PTR [eax+8]
	mulss	xmm2, DWORD PTR [eax+24]
	mulss	xmm3, DWORD PTR [eax+40]
	addss	xmm4, xmm2
	addss	xmm3, DWORD PTR [eax+56]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp

; 432  : 	VIS = View->testSphere			(Tpos, pVisual->vis.sphere.R,planes);

	lea	eax, DWORD PTR _planes$[esp+64]
	push	eax
	push	ecx
	mov	ecx, DWORD PTR [ebx+252]
	lea	eax, DWORD PTR _Tpos$[esp+76]
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 501  : 		dest.z = v.x*_13 + v.y*_23 + v.z*_33 + _43;

	addss	xmm4, xmm3
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp

; 432  : 	VIS = View->testSphere			(Tpos, pVisual->vis.sphere.R,planes);

	fstp	DWORD PTR [esp]
	push	eax
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 501  : 		dest.z = v.x*_13 + v.y*_23 + v.z*_33 + _43;

	movss	DWORD PTR _Tpos$[esp+88], xmm4
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp

; 432  : 	VIS = View->testSphere			(Tpos, pVisual->vis.sphere.R,planes);

	call	DWORD PTR __imp_?testSphere@CFrustum@@QBE?AW4EFC_Visible@@AAU?$_vector3@M@@MAAI@Z
	mov	ecx, eax
	mov	DWORD PTR _VIS$1$[esp+68], ecx

; 433  : 	if (fcvNone==VIS) return FALSE	;

	test	ecx, ecx
	jne	SHORT $LN28@add_Dynami

; 517  : }

	pop	ebp
	pop	ebx
	add	esp, 60					; 0000003cH
	ret	8
$LN28@add_Dynami:

; 434  : 
; 435  : 	// If we get here visual is visible or partially visible
; 436  : 	xr_vector<IRender_Visual*>::iterator I,E;	// it may be usefull for 'hierrarhy' visuals
; 437  : 
; 438  : 	switch (pVisual->Type) {

	mov	eax, DWORD PTR [ebp+4]
	dec	eax
	push	esi
	push	edi
	cmp	eax, 9
	ja	$LN43@add_Dynami
	movzx	eax, BYTE PTR $LN1844@add_Dynami[eax]
	jmp	DWORD PTR $LN1845@add_Dynami[eax*4]
$LN29@add_Dynami:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	esi, DWORD PTR [ebp+92]
	mov	DWORD PTR _i_it$1$[esp+76], esi

; 150  :         return _Ptr == _Right._Ptr;

	cmp	esi, DWORD PTR [ebp+96]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp

; 443  : 			for (PS::CParticleGroup::SItemVecIt i_it=pG->items.begin(); i_it!=pG->items.end(); i_it++)

	je	$LN2@add_Dynami
	movss	xmm7, DWORD PTR __real@3f000000
	mov	edi, DWORD PTR __imp_?CalculateWallmarks@CKinematics@@QAEXXZ
$LL6@add_Dynami:

; 444  : 			{
; 445  : 				PS::CParticleGroup::SItem&			I		= *i_it;

	mov	ebp, DWORD PTR [esi]

; 446  : 				if (fcvPartial==VIS) 

	cmp	ecx, 1
	jne	SHORT $LN30@add_Dynami

; 447  : 				{
; 448  : 					if (I._effect)		add_Dynamic				(I._effect,planes);

	test	ebp, ebp
	je	SHORT $LN32@add_Dynami
	push	DWORD PTR _planes$[esp+72]
	mov	ecx, ebx
	push	ebp
	call	?add_Dynamic@CRender@@AAEHPAVIRender_Visual@@I@Z ; CRender::add_Dynamic
$LN32@add_Dynami:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 150  :         return _Ptr == _Right._Ptr;

	mov	edi, DWORD PTR _i_it$1$[esp+76]

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	esi, DWORD PTR [esi+4]

; 150  :         return _Ptr == _Right._Ptr;

	cmp	esi, DWORD PTR [edi+8]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp

; 449  : 					for (xr_vector<IRender_Visual*>::iterator pit = I._children_related.begin();	pit!=I._children_related.end(); pit++)	add_Dynamic(*pit,planes);

	je	SHORT $LN1835@add_Dynami
$LL9@add_Dynami:
	push	DWORD PTR _planes$[esp+72]
	mov	ecx, ebx
	push	DWORD PTR [esi]
	call	?add_Dynamic@CRender@@AAEHPAVIRender_Visual@@I@Z ; CRender::add_Dynamic
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 74   :         ++_Ptr;

	add	esi, 4

; 150  :         return _Ptr == _Right._Ptr;

	cmp	esi, DWORD PTR [edi+8]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp

; 449  : 					for (xr_vector<IRender_Visual*>::iterator pit = I._children_related.begin();	pit!=I._children_related.end(); pit++)	add_Dynamic(*pit,planes);

	jne	SHORT $LL9@add_Dynami
$LN1835@add_Dynami:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	esi, DWORD PTR [edi+16]

; 150  :         return _Ptr == _Right._Ptr;

	cmp	esi, DWORD PTR [edi+20]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp

; 450  : 					for (xr_vector<IRender_Visual*>::iterator pit = I._children_free.begin();		pit!=I._children_free.end();	pit++)	add_Dynamic(*pit,planes);

	je	$LN4@add_Dynami
$LL12@add_Dynami:
	push	DWORD PTR _planes$[esp+72]
	mov	ecx, ebx
	push	DWORD PTR [esi]
	call	?add_Dynamic@CRender@@AAEHPAVIRender_Visual@@I@Z ; CRender::add_Dynamic
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 74   :         ++_Ptr;

	add	esi, 4

; 150  :         return _Ptr == _Right._Ptr;

	cmp	esi, DWORD PTR [edi+20]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp

; 450  : 					for (xr_vector<IRender_Visual*>::iterator pit = I._children_free.begin();		pit!=I._children_free.end();	pit++)	add_Dynamic(*pit,planes);

	jne	SHORT $LL12@add_Dynami
	jmp	$LN4@add_Dynami
$LN30@add_Dynami:

; 451  : 				} else 
; 452  : 				{
; 453  : 					if (I._effect)		add_leafs_Dynamic		(I._effect);

	test	ebp, ebp
	je	$LN1199@add_Dynami

; 285  : 	switch (pVisual->Type) {

	mov	eax, DWORD PTR [ebp+4]
	dec	eax
	cmp	eax, 9
	ja	$LN1227@add_Dynami
	movzx	eax, BYTE PTR $LN1846@add_Dynami[eax]
	jmp	DWORD PTR $LN1847@add_Dynami[eax*4]
$LN1218@add_Dynami:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	edi, DWORD PTR [ebp+92]

; 150  :         return _Ptr == _Right._Ptr;

	cmp	edi, DWORD PTR [ebp+96]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp

; 290  : 			for (PS::CParticleGroup::SItemVecIt i_it=pG->items.begin(); i_it!=pG->items.end(); i_it++)	{

	je	SHORT $LN1858@add_Dynami
	npad	6
$LL1204@add_Dynami:

; 291  : 				PS::CParticleGroup::SItem&			I		= *i_it;
; 292  : 				if (I._effect)		add_leafs_Dynamic		(I._effect);

	mov	eax, DWORD PTR [edi]
	test	eax, eax
	je	SHORT $LN1219@add_Dynami
	push	eax
	mov	ecx, ebx
	call	?add_leafs_Dynamic@CRender@@AAEXPAVIRender_Visual@@@Z ; CRender::add_leafs_Dynamic
$LN1219@add_Dynami:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	esi, DWORD PTR [edi+4]

; 150  :         return _Ptr == _Right._Ptr;

	cmp	esi, DWORD PTR [edi+8]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp

; 293  : 				for (xr_vector<IRender_Visual*>::iterator pit = I._children_related.begin();	pit!=I._children_related.end(); pit++)	add_leafs_Dynamic(*pit);

	je	SHORT $LN1838@add_Dynami
$LL1207@add_Dynami:
	push	DWORD PTR [esi]
	mov	ecx, ebx
	call	?add_leafs_Dynamic@CRender@@AAEXPAVIRender_Visual@@@Z ; CRender::add_leafs_Dynamic
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 74   :         ++_Ptr;

	add	esi, 4

; 150  :         return _Ptr == _Right._Ptr;

	cmp	esi, DWORD PTR [edi+8]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp

; 293  : 				for (xr_vector<IRender_Visual*>::iterator pit = I._children_related.begin();	pit!=I._children_related.end(); pit++)	add_leafs_Dynamic(*pit);

	jne	SHORT $LL1207@add_Dynami
$LN1838@add_Dynami:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	esi, DWORD PTR [edi+16]

; 150  :         return _Ptr == _Right._Ptr;

	cmp	esi, DWORD PTR [edi+20]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp

; 294  : 				for (xr_vector<IRender_Visual*>::iterator pit = I._children_free.begin();		pit!=I._children_free.end();	pit++)	add_leafs_Dynamic(*pit);

	je	SHORT $LN1202@add_Dynami
	npad	1
$LL1210@add_Dynami:
	push	DWORD PTR [esi]
	mov	ecx, ebx
	call	?add_leafs_Dynamic@CRender@@AAEXPAVIRender_Visual@@@Z ; CRender::add_leafs_Dynamic
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 74   :         ++_Ptr;

	add	esi, 4

; 150  :         return _Ptr == _Right._Ptr;

	cmp	esi, DWORD PTR [edi+20]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp

; 294  : 				for (xr_vector<IRender_Visual*>::iterator pit = I._children_free.begin();		pit!=I._children_free.end();	pit++)	add_leafs_Dynamic(*pit);

	jne	SHORT $LL1210@add_Dynami
$LN1202@add_Dynami:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 74   :         ++_Ptr;

	add	edi, 28					; 0000001cH

; 150  :         return _Ptr == _Right._Ptr;

	cmp	edi, DWORD PTR [ebp+96]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp

; 290  : 			for (PS::CParticleGroup::SItemVecIt i_it=pG->items.begin(); i_it!=pG->items.end(); i_it++)	{

	jne	SHORT $LL1204@add_Dynami
$LN1856@add_Dynami:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	movss	xmm7, DWORD PTR __real@3f000000
$LN1857@add_Dynami:
	mov	esi, DWORD PTR _i_it$1$[esp+76]
$LN1858@add_Dynami:
	mov	edi, DWORD PTR __imp_?CalculateWallmarks@CKinematics@@QAEXXZ
$LN1199@add_Dynami:

; 150  :         return _Ptr == _Right._Ptr;

	mov	eax, DWORD PTR _i_it$1$[esp+76]

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	esi, DWORD PTR [esi+4]
	mov	DWORD PTR _pit$1$[esp+76], esi

; 150  :         return _Ptr == _Right._Ptr;

	cmp	esi, DWORD PTR [eax+8]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp

; 454  : 					for (xr_vector<IRender_Visual*>::iterator pit = I._children_related.begin();	pit!=I._children_related.end(); pit++)	add_leafs_Dynamic(*pit);

	je	$LN14@add_Dynami
	npad	1
$LL15@add_Dynami:
	mov	ebp, DWORD PTR [esi]

; 280  : 	if (0==pVisual)				return;

	test	ebp, ebp
	je	$LN13@add_Dynami

; 281  : 
; 282  : 	// Visual is 100% visible - simply add it
; 283  : 	xr_vector<IRender_Visual*>::iterator I,E;	// it may be useful for 'hierrarhy' visual
; 284  : 
; 285  : 	switch (pVisual->Type) {

	mov	ecx, DWORD PTR [ebp+4]
	dec	ecx
	cmp	ecx, 9
	ja	$LN1393@add_Dynami
	movzx	ecx, BYTE PTR $LN1848@add_Dynami[ecx]
	jmp	DWORD PTR $LN1849@add_Dynami[ecx*4]
$LN1220@add_Dynami:

; 303  : 			E = pV->children.end	();

	mov	edi, DWORD PTR [ebp+72]

; 304  : 			for (; I!=E; I++)	add_leafs_Dynamic	(*I);

	mov	esi, DWORD PTR [ebp+68]
	cmp	esi, edi
	je	SHORT $LN1857@add_Dynami
	npad	1
$LL1213@add_Dynami:
	push	DWORD PTR [esi]
	mov	ecx, ebx
	call	?add_leafs_Dynamic@CRender@@AAEXPAVIRender_Visual@@@Z ; CRender::add_leafs_Dynamic
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 74   :         ++_Ptr;

	add	esi, 4
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp

; 304  : 			for (; I!=E; I++)	add_leafs_Dynamic	(*I);

	cmp	esi, edi
	jne	SHORT $LL1213@add_Dynami

; 305  : 		}
; 306  : 		return;

	jmp	SHORT $LN1856@add_Dynami
$LN1221@add_Dynami:

; 307  : 	case MT_SKELETON_ANIM:
; 308  : 	case MT_SKELETON_RIGID:
; 309  : 		{
; 310  : 			// Add all children, doesn't perform any tests
; 311  : 			CKinematics * pV			= (CKinematics*)pVisual;
; 312  : 			BOOL	_use_lod			= FALSE	;
; 313  : 			if (pV->m_lod)				

	mov	edx, DWORD PTR [ebp+84]
	test	edx, edx
	je	$LN1225@add_Dynami

; 314  : 			{
; 315  : 				Fvector							Tpos;	float		D;
; 316  : 				val_pTransform->transform_tiny	(Tpos, pV->vis.sphere.P);

	mov	ecx, DWORD PTR [ebx+264]
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 499  : 		dest.x = v.x*_11 + v.y*_21 + v.z*_31 + _41;

	movss	xmm4, DWORD PTR [ebp+12]
	movss	xmm6, DWORD PTR [ebp+8]

; 500  : 		dest.y = v.x*_12 + v.y*_22 + v.z*_32 + _42;

	movaps	xmm0, xmm4
	movss	xmm5, DWORD PTR [ebp+16]
	movaps	xmm1, xmm6
	mulss	xmm0, DWORD PTR [ecx+20]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp

; 31   : 	distSQ	= Device.vCameraPosition.distance_to_sqr(C)+EPS;

	mov	eax, DWORD PTR __imp_?Device@@3VCRenderDevice@@A
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 500  : 		dest.y = v.x*_12 + v.y*_22 + v.z*_32 + _42;

	mulss	xmm1, DWORD PTR [ecx+4]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 287  : 	{	return (x-v.x)*(x-v.x) + (y-v.y)*(y-v.y) + (z-v.z)*(z-v.z);	}

	movss	xmm3, DWORD PTR [eax+492]
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 500  : 		dest.y = v.x*_12 + v.y*_22 + v.z*_32 + _42;

	addss	xmm1, xmm0
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 287  : 	{	return (x-v.x)*(x-v.x) + (y-v.y)*(y-v.y) + (z-v.z)*(z-v.z);	}

	movss	xmm2, DWORD PTR [eax+488]
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 500  : 		dest.y = v.x*_12 + v.y*_22 + v.z*_32 + _42;

	movaps	xmm0, xmm5
	mulss	xmm0, DWORD PTR [ecx+36]
	addss	xmm0, DWORD PTR [ecx+52]
	addss	xmm1, xmm0
	movaps	xmm0, xmm6
	mulss	xmm0, DWORD PTR [ecx]

; 501  : 		dest.z = v.x*_13 + v.y*_23 + v.z*_33 + _43;

	mulss	xmm6, DWORD PTR [ecx+8]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 287  : 	{	return (x-v.x)*(x-v.x) + (y-v.y)*(y-v.y) + (z-v.z)*(z-v.z);	}

	subss	xmm3, xmm1
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 499  : 		dest.x = v.x*_11 + v.y*_21 + v.z*_31 + _41;

	movaps	xmm1, xmm4
	mulss	xmm1, DWORD PTR [ecx+16]

; 501  : 		dest.z = v.x*_13 + v.y*_23 + v.z*_33 + _43;

	mulss	xmm4, DWORD PTR [ecx+24]
	addss	xmm1, xmm0
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 287  : 	{	return (x-v.x)*(x-v.x) + (y-v.y)*(y-v.y) + (z-v.z)*(z-v.z);	}

	mulss	xmm3, xmm3
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 499  : 		dest.x = v.x*_11 + v.y*_21 + v.z*_31 + _41;

	movaps	xmm0, xmm5

; 501  : 		dest.z = v.x*_13 + v.y*_23 + v.z*_33 + _43;

	mulss	xmm5, DWORD PTR [ecx+40]
	mulss	xmm0, DWORD PTR [ecx+32]
	addss	xmm6, xmm4
	addss	xmm5, DWORD PTR [ecx+56]
	addss	xmm0, DWORD PTR [ecx+48]
	addss	xmm6, xmm5
	addss	xmm1, xmm0
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 287  : 	{	return (x-v.x)*(x-v.x) + (y-v.y)*(y-v.y) + (z-v.z)*(z-v.z);	}

	movss	xmm0, DWORD PTR [eax+496]
	subss	xmm0, xmm6
	subss	xmm2, xmm1
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp

; 317  : 				float		ssa		=	CalcSSA	(D,Tpos,pV->vis.sphere.R/2.f);	// assume dynamics never consume full sphere

	movss	xmm1, DWORD PTR [ebp+20]
	mulss	xmm1, xmm7
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 287  : 	{	return (x-v.x)*(x-v.x) + (y-v.y)*(y-v.y) + (z-v.z)*(z-v.z);	}

	mulss	xmm0, xmm0
	mulss	xmm2, xmm2
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp

; 31   : 	distSQ	= Device.vCameraPosition.distance_to_sqr(C)+EPS;

	addss	xmm0, DWORD PTR __real@3727c5ac
	addss	xmm2, xmm3
	addss	xmm2, xmm0

; 318  : 				if (ssa<r_ssaLOD_A)	_use_lod	= TRUE;

	movss	xmm0, DWORD PTR ?r_ssaLOD_A@@3MA

; 32   : 	return	R/distSQ;

	divss	xmm1, xmm2

; 318  : 				if (ssa<r_ssaLOD_A)	_use_lod	= TRUE;

	comiss	xmm0, xmm1
	jbe	SHORT $LN1225@add_Dynami

; 319  : 			}
; 320  : 			if (_use_lod)				
; 321  : 			{
; 322  : 				add_leafs_Dynamic			(pV->m_lod)		;

	push	edx
	mov	ecx, ebx
	call	?add_leafs_Dynamic@CRender@@AAEXPAVIRender_Visual@@@Z ; CRender::add_leafs_Dynamic

; 323  : 			} else {

	movss	xmm7, DWORD PTR __real@3f000000
	jmp	$LN1199@add_Dynami
$LN1225@add_Dynami:

; 324  : 				pV->CalculateBones			(TRUE);

	mov	eax, DWORD PTR [ebp]
	mov	ecx, ebp
	push	1
	call	DWORD PTR [eax+64]

; 325  : 				pV->CalculateWallmarks		();		//. bug?

	mov	ecx, ebp
	call	edi

; 326  : 				I = pV->children.begin		();
; 327  : 				E = pV->children.end		();

	mov	edi, DWORD PTR [ebp+72]

; 328  : 				for (; I!=E; I++)	add_leafs_Dynamic	(*I);

	mov	esi, DWORD PTR [ebp+68]
	cmp	esi, edi
	je	$LN1856@add_Dynami
$LL1216@add_Dynami:
	push	DWORD PTR [esi]
	mov	ecx, ebx
	call	?add_leafs_Dynamic@CRender@@AAEXPAVIRender_Visual@@@Z ; CRender::add_leafs_Dynamic
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 74   :         ++_Ptr;

	add	esi, 4
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp

; 328  : 				for (; I!=E; I++)	add_leafs_Dynamic	(*I);

	cmp	esi, edi
	jne	SHORT $LL1216@add_Dynami

; 329  : 			}
; 330  : 		}
; 331  : 		return;

	jmp	$LN1856@add_Dynami
$LN1227@add_Dynami:

; 332  : 	default:
; 333  : 		{
; 334  : 			// General type of visual
; 335  : 			// Calculate distance to it's center
; 336  : 			Fvector							Tpos;
; 337  : 			val_pTransform->transform_tiny	(Tpos, pVisual->vis.sphere.P);

	mov	eax, DWORD PTR [ebx+264]

; 338  : 			r_dsgraph_insert_dynamic		(pVisual,Tpos);

	mov	ecx, ebx
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 499  : 		dest.x = v.x*_11 + v.y*_21 + v.z*_31 + _41;

	movss	xmm2, DWORD PTR [ebp+12]
	movss	xmm4, DWORD PTR [ebp+8]
	movaps	xmm1, xmm2
	movss	xmm3, DWORD PTR [ebp+16]
	movaps	xmm0, xmm4
	mulss	xmm0, DWORD PTR [eax]
	mulss	xmm1, DWORD PTR [eax+16]
	addss	xmm1, xmm0
	movaps	xmm0, xmm3
	mulss	xmm0, DWORD PTR [eax+32]
	addss	xmm0, DWORD PTR [eax+48]
	addss	xmm1, xmm0

; 500  : 		dest.y = v.x*_12 + v.y*_22 + v.z*_32 + _42;

	movaps	xmm0, xmm2
	mulss	xmm0, DWORD PTR [eax+20]

; 501  : 		dest.z = v.x*_13 + v.y*_23 + v.z*_33 + _43;

	mulss	xmm2, DWORD PTR [eax+24]
	movss	DWORD PTR _Tpos$5[esp+76], xmm1
	movaps	xmm1, xmm4
	mulss	xmm1, DWORD PTR [eax+4]
	mulss	xmm4, DWORD PTR [eax+8]
	addss	xmm1, xmm0
	movaps	xmm0, xmm3
	mulss	xmm0, DWORD PTR [eax+36]
	mulss	xmm3, DWORD PTR [eax+40]
	addss	xmm4, xmm2
	addss	xmm0, DWORD PTR [eax+52]
	addss	xmm3, DWORD PTR [eax+56]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp

; 338  : 			r_dsgraph_insert_dynamic		(pVisual,Tpos);

	lea	eax, DWORD PTR _Tpos$5[esp+76]
	push	eax
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 500  : 		dest.y = v.x*_12 + v.y*_22 + v.z*_32 + _42;

	addss	xmm1, xmm0
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp

; 338  : 			r_dsgraph_insert_dynamic		(pVisual,Tpos);

	push	ebp
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 501  : 		dest.z = v.x*_13 + v.y*_23 + v.z*_33 + _43;

	addss	xmm4, xmm3
	movss	DWORD PTR _Tpos$5[esp+88], xmm1
	movss	DWORD PTR _Tpos$5[esp+92], xmm4
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp

; 338  : 			r_dsgraph_insert_dynamic		(pVisual,Tpos);

	call	?r_dsgraph_insert_dynamic@R_dsgraph_structure@@QAEXPAVIRender_Visual@@AAU?$_vector3@M@@@Z ; R_dsgraph_structure::r_dsgraph_insert_dynamic
	movss	xmm7, DWORD PTR __real@3f000000
	jmp	$LN1199@add_Dynami
$LN1384@add_Dynami:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	edi, DWORD PTR [ebp+92]

; 150  :         return _Ptr == _Right._Ptr;

	cmp	edi, DWORD PTR [ebp+96]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp

; 290  : 			for (PS::CParticleGroup::SItemVecIt i_it=pG->items.begin(); i_it!=pG->items.end(); i_it++)	{

	je	SHORT $LN13@add_Dynami
	npad	6
$LL1370@add_Dynami:

; 291  : 				PS::CParticleGroup::SItem&			I		= *i_it;
; 292  : 				if (I._effect)		add_leafs_Dynamic		(I._effect);

	mov	eax, DWORD PTR [edi]
	test	eax, eax
	je	SHORT $LN1385@add_Dynami
	push	eax
	mov	ecx, ebx
	call	?add_leafs_Dynamic@CRender@@AAEXPAVIRender_Visual@@@Z ; CRender::add_leafs_Dynamic
$LN1385@add_Dynami:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	esi, DWORD PTR [edi+4]

; 150  :         return _Ptr == _Right._Ptr;

	cmp	esi, DWORD PTR [edi+8]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp

; 293  : 				for (xr_vector<IRender_Visual*>::iterator pit = I._children_related.begin();	pit!=I._children_related.end(); pit++)	add_leafs_Dynamic(*pit);

	je	SHORT $LN1840@add_Dynami
$LL1373@add_Dynami:
	push	DWORD PTR [esi]
	mov	ecx, ebx
	call	?add_leafs_Dynamic@CRender@@AAEXPAVIRender_Visual@@@Z ; CRender::add_leafs_Dynamic
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 74   :         ++_Ptr;

	add	esi, 4

; 150  :         return _Ptr == _Right._Ptr;

	cmp	esi, DWORD PTR [edi+8]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp

; 293  : 				for (xr_vector<IRender_Visual*>::iterator pit = I._children_related.begin();	pit!=I._children_related.end(); pit++)	add_leafs_Dynamic(*pit);

	jne	SHORT $LL1373@add_Dynami
$LN1840@add_Dynami:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	esi, DWORD PTR [edi+16]

; 150  :         return _Ptr == _Right._Ptr;

	cmp	esi, DWORD PTR [edi+20]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp

; 294  : 				for (xr_vector<IRender_Visual*>::iterator pit = I._children_free.begin();		pit!=I._children_free.end();	pit++)	add_leafs_Dynamic(*pit);

	je	SHORT $LN1368@add_Dynami
	npad	1
$LL1376@add_Dynami:
	push	DWORD PTR [esi]
	mov	ecx, ebx
	call	?add_leafs_Dynamic@CRender@@AAEXPAVIRender_Visual@@@Z ; CRender::add_leafs_Dynamic
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 74   :         ++_Ptr;

	add	esi, 4

; 150  :         return _Ptr == _Right._Ptr;

	cmp	esi, DWORD PTR [edi+20]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp

; 294  : 				for (xr_vector<IRender_Visual*>::iterator pit = I._children_free.begin();		pit!=I._children_free.end();	pit++)	add_leafs_Dynamic(*pit);

	jne	SHORT $LL1376@add_Dynami
$LN1368@add_Dynami:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 74   :         ++_Ptr;

	add	edi, 28					; 0000001cH

; 150  :         return _Ptr == _Right._Ptr;

	cmp	edi, DWORD PTR [ebp+96]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp

; 290  : 			for (PS::CParticleGroup::SItemVecIt i_it=pG->items.begin(); i_it!=pG->items.end(); i_it++)	{

	jne	SHORT $LL1370@add_Dynami
$LN1852@add_Dynami:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 74   :         ++_Ptr;

	mov	eax, DWORD PTR _i_it$1$[esp+76]
$LN1853@add_Dynami:
	mov	esi, DWORD PTR _pit$1$[esp+76]
$LN13@add_Dynami:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp

; 454  : 					for (xr_vector<IRender_Visual*>::iterator pit = I._children_related.begin();	pit!=I._children_related.end(); pit++)	add_leafs_Dynamic(*pit);

	movss	xmm7, DWORD PTR __real@3f000000
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 74   :         ++_Ptr;

	add	esi, 4
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp

; 454  : 					for (xr_vector<IRender_Visual*>::iterator pit = I._children_related.begin();	pit!=I._children_related.end(); pit++)	add_leafs_Dynamic(*pit);

	mov	edi, DWORD PTR __imp_?CalculateWallmarks@CKinematics@@QAEXXZ
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 74   :         ++_Ptr;

	mov	DWORD PTR _pit$1$[esp+76], esi

; 150  :         return _Ptr == _Right._Ptr;

	cmp	esi, DWORD PTR [eax+8]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp

; 454  : 					for (xr_vector<IRender_Visual*>::iterator pit = I._children_related.begin();	pit!=I._children_related.end(); pit++)	add_leafs_Dynamic(*pit);

	jne	$LL15@add_Dynami
$LN14@add_Dynami:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	esi, DWORD PTR _i_it$1$[esp+76]

; 150  :         return _Ptr == _Right._Ptr;

	mov	eax, DWORD PTR _i_it$1$[esp+76]

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	esi, DWORD PTR [esi+16]
	mov	DWORD PTR _pit$1$[esp+76], esi

; 150  :         return _Ptr == _Right._Ptr;

	cmp	esi, DWORD PTR [eax+20]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp

; 455  : 					for (xr_vector<IRender_Visual*>::iterator pit = I._children_free.begin();		pit!=I._children_free.end();	pit++)	add_leafs_Dynamic(*pit);

	je	$LN4@add_Dynami
	npad	9
$LL18@add_Dynami:
	mov	ebp, DWORD PTR [esi]

; 280  : 	if (0==pVisual)				return;

	test	ebp, ebp
	je	$LN16@add_Dynami

; 281  : 
; 282  : 	// Visual is 100% visible - simply add it
; 283  : 	xr_vector<IRender_Visual*>::iterator I,E;	// it may be useful for 'hierrarhy' visual
; 284  : 
; 285  : 	switch (pVisual->Type) {

	mov	ecx, DWORD PTR [ebp+4]
	dec	ecx
	cmp	ecx, 9
	ja	$LN1559@add_Dynami
	movzx	ecx, BYTE PTR $LN1850@add_Dynami[ecx]
	jmp	DWORD PTR $LN1851@add_Dynami[ecx*4]
$LN1386@add_Dynami:

; 303  : 			E = pV->children.end	();

	mov	edi, DWORD PTR [ebp+72]

; 304  : 			for (; I!=E; I++)	add_leafs_Dynamic	(*I);

	mov	esi, DWORD PTR [ebp+68]
	cmp	esi, edi
	je	SHORT $LN1853@add_Dynami
	npad	1
$LL1379@add_Dynami:
	push	DWORD PTR [esi]
	mov	ecx, ebx
	call	?add_leafs_Dynamic@CRender@@AAEXPAVIRender_Visual@@@Z ; CRender::add_leafs_Dynamic
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 74   :         ++_Ptr;

	add	esi, 4
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp

; 304  : 			for (; I!=E; I++)	add_leafs_Dynamic	(*I);

	cmp	esi, edi
	jne	SHORT $LL1379@add_Dynami

; 305  : 		}
; 306  : 		return;

	jmp	$LN1852@add_Dynami
$LN1387@add_Dynami:

; 307  : 	case MT_SKELETON_ANIM:
; 308  : 	case MT_SKELETON_RIGID:
; 309  : 		{
; 310  : 			// Add all children, doesn't perform any tests
; 311  : 			CKinematics * pV			= (CKinematics*)pVisual;
; 312  : 			BOOL	_use_lod			= FALSE	;
; 313  : 			if (pV->m_lod)				

	mov	edx, DWORD PTR [ebp+84]
	test	edx, edx
	je	$LN1391@add_Dynami

; 314  : 			{
; 315  : 				Fvector							Tpos;	float		D;
; 316  : 				val_pTransform->transform_tiny	(Tpos, pV->vis.sphere.P);

	mov	ecx, DWORD PTR [ebx+264]
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 499  : 		dest.x = v.x*_11 + v.y*_21 + v.z*_31 + _41;

	movss	xmm4, DWORD PTR [ebp+12]
	movss	xmm6, DWORD PTR [ebp+8]

; 500  : 		dest.y = v.x*_12 + v.y*_22 + v.z*_32 + _42;

	movaps	xmm0, xmm4
	movss	xmm5, DWORD PTR [ebp+16]
	movaps	xmm1, xmm6
	mulss	xmm0, DWORD PTR [ecx+20]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp

; 31   : 	distSQ	= Device.vCameraPosition.distance_to_sqr(C)+EPS;

	mov	eax, DWORD PTR __imp_?Device@@3VCRenderDevice@@A
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 500  : 		dest.y = v.x*_12 + v.y*_22 + v.z*_32 + _42;

	mulss	xmm1, DWORD PTR [ecx+4]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 287  : 	{	return (x-v.x)*(x-v.x) + (y-v.y)*(y-v.y) + (z-v.z)*(z-v.z);	}

	movss	xmm3, DWORD PTR [eax+492]
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 500  : 		dest.y = v.x*_12 + v.y*_22 + v.z*_32 + _42;

	addss	xmm1, xmm0
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 287  : 	{	return (x-v.x)*(x-v.x) + (y-v.y)*(y-v.y) + (z-v.z)*(z-v.z);	}

	movss	xmm2, DWORD PTR [eax+488]
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 500  : 		dest.y = v.x*_12 + v.y*_22 + v.z*_32 + _42;

	movaps	xmm0, xmm5
	mulss	xmm0, DWORD PTR [ecx+36]
	addss	xmm0, DWORD PTR [ecx+52]
	addss	xmm1, xmm0
	movaps	xmm0, xmm6
	mulss	xmm0, DWORD PTR [ecx]

; 501  : 		dest.z = v.x*_13 + v.y*_23 + v.z*_33 + _43;

	mulss	xmm6, DWORD PTR [ecx+8]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 287  : 	{	return (x-v.x)*(x-v.x) + (y-v.y)*(y-v.y) + (z-v.z)*(z-v.z);	}

	subss	xmm3, xmm1
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 499  : 		dest.x = v.x*_11 + v.y*_21 + v.z*_31 + _41;

	movaps	xmm1, xmm4
	mulss	xmm1, DWORD PTR [ecx+16]

; 501  : 		dest.z = v.x*_13 + v.y*_23 + v.z*_33 + _43;

	mulss	xmm4, DWORD PTR [ecx+24]
	addss	xmm1, xmm0
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 287  : 	{	return (x-v.x)*(x-v.x) + (y-v.y)*(y-v.y) + (z-v.z)*(z-v.z);	}

	mulss	xmm3, xmm3
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 499  : 		dest.x = v.x*_11 + v.y*_21 + v.z*_31 + _41;

	movaps	xmm0, xmm5

; 501  : 		dest.z = v.x*_13 + v.y*_23 + v.z*_33 + _43;

	mulss	xmm5, DWORD PTR [ecx+40]
	mulss	xmm0, DWORD PTR [ecx+32]
	addss	xmm6, xmm4
	addss	xmm5, DWORD PTR [ecx+56]
	addss	xmm0, DWORD PTR [ecx+48]
	addss	xmm6, xmm5
	addss	xmm1, xmm0
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 287  : 	{	return (x-v.x)*(x-v.x) + (y-v.y)*(y-v.y) + (z-v.z)*(z-v.z);	}

	movss	xmm0, DWORD PTR [eax+496]
	subss	xmm0, xmm6
	subss	xmm2, xmm1
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp

; 317  : 				float		ssa		=	CalcSSA	(D,Tpos,pV->vis.sphere.R/2.f);	// assume dynamics never consume full sphere

	movss	xmm1, DWORD PTR [ebp+20]
	mulss	xmm1, xmm7
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 287  : 	{	return (x-v.x)*(x-v.x) + (y-v.y)*(y-v.y) + (z-v.z)*(z-v.z);	}

	mulss	xmm0, xmm0
	mulss	xmm2, xmm2
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp

; 31   : 	distSQ	= Device.vCameraPosition.distance_to_sqr(C)+EPS;

	addss	xmm0, DWORD PTR __real@3727c5ac
	addss	xmm2, xmm3
	addss	xmm2, xmm0

; 318  : 				if (ssa<r_ssaLOD_A)	_use_lod	= TRUE;

	movss	xmm0, DWORD PTR ?r_ssaLOD_A@@3MA

; 32   : 	return	R/distSQ;

	divss	xmm1, xmm2

; 318  : 				if (ssa<r_ssaLOD_A)	_use_lod	= TRUE;

	comiss	xmm0, xmm1
	jbe	SHORT $LN1391@add_Dynami

; 319  : 			}
; 320  : 			if (_use_lod)				
; 321  : 			{
; 322  : 				add_leafs_Dynamic			(pV->m_lod)		;

	push	edx
	mov	ecx, ebx
	call	?add_leafs_Dynamic@CRender@@AAEXPAVIRender_Visual@@@Z ; CRender::add_leafs_Dynamic

; 323  : 			} else {

	mov	eax, DWORD PTR _i_it$1$[esp+76]
	jmp	$LN13@add_Dynami
$LN1391@add_Dynami:

; 324  : 				pV->CalculateBones			(TRUE);

	mov	eax, DWORD PTR [ebp]
	mov	ecx, ebp
	push	1
	call	DWORD PTR [eax+64]

; 325  : 				pV->CalculateWallmarks		();		//. bug?

	mov	ecx, ebp
	call	edi

; 326  : 				I = pV->children.begin		();
; 327  : 				E = pV->children.end		();

	mov	edi, DWORD PTR [ebp+72]

; 328  : 				for (; I!=E; I++)	add_leafs_Dynamic	(*I);

	mov	esi, DWORD PTR [ebp+68]
	cmp	esi, edi
	je	$LN1852@add_Dynami
$LL1382@add_Dynami:
	push	DWORD PTR [esi]
	mov	ecx, ebx
	call	?add_leafs_Dynamic@CRender@@AAEXPAVIRender_Visual@@@Z ; CRender::add_leafs_Dynamic
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 74   :         ++_Ptr;

	add	esi, 4
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp

; 328  : 				for (; I!=E; I++)	add_leafs_Dynamic	(*I);

	cmp	esi, edi
	jne	SHORT $LL1382@add_Dynami

; 329  : 			}
; 330  : 		}
; 331  : 		return;

	jmp	$LN1852@add_Dynami
$LN1393@add_Dynami:

; 332  : 	default:
; 333  : 		{
; 334  : 			// General type of visual
; 335  : 			// Calculate distance to it's center
; 336  : 			Fvector							Tpos;
; 337  : 			val_pTransform->transform_tiny	(Tpos, pVisual->vis.sphere.P);

	mov	eax, DWORD PTR [ebx+264]

; 338  : 			r_dsgraph_insert_dynamic		(pVisual,Tpos);

	mov	ecx, ebx
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 499  : 		dest.x = v.x*_11 + v.y*_21 + v.z*_31 + _41;

	movss	xmm2, DWORD PTR [ebp+12]
	movss	xmm4, DWORD PTR [ebp+8]
	movaps	xmm1, xmm2
	movss	xmm3, DWORD PTR [ebp+16]
	movaps	xmm0, xmm4
	mulss	xmm0, DWORD PTR [eax]
	mulss	xmm1, DWORD PTR [eax+16]
	addss	xmm1, xmm0
	movaps	xmm0, xmm3
	mulss	xmm0, DWORD PTR [eax+32]
	addss	xmm0, DWORD PTR [eax+48]
	addss	xmm1, xmm0

; 500  : 		dest.y = v.x*_12 + v.y*_22 + v.z*_32 + _42;

	movaps	xmm0, xmm2
	mulss	xmm0, DWORD PTR [eax+20]

; 501  : 		dest.z = v.x*_13 + v.y*_23 + v.z*_33 + _43;

	mulss	xmm2, DWORD PTR [eax+24]
	movss	DWORD PTR _Tpos$6[esp+76], xmm1
	movaps	xmm1, xmm4
	mulss	xmm1, DWORD PTR [eax+4]
	mulss	xmm4, DWORD PTR [eax+8]
	addss	xmm1, xmm0
	movaps	xmm0, xmm3
	mulss	xmm0, DWORD PTR [eax+36]
	mulss	xmm3, DWORD PTR [eax+40]
	addss	xmm4, xmm2
	addss	xmm0, DWORD PTR [eax+52]
	addss	xmm3, DWORD PTR [eax+56]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp

; 338  : 			r_dsgraph_insert_dynamic		(pVisual,Tpos);

	lea	eax, DWORD PTR _Tpos$6[esp+76]
	push	eax
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 500  : 		dest.y = v.x*_12 + v.y*_22 + v.z*_32 + _42;

	addss	xmm1, xmm0
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp

; 338  : 			r_dsgraph_insert_dynamic		(pVisual,Tpos);

	push	ebp
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 501  : 		dest.z = v.x*_13 + v.y*_23 + v.z*_33 + _43;

	addss	xmm4, xmm3
	movss	DWORD PTR _Tpos$6[esp+88], xmm1
	movss	DWORD PTR _Tpos$6[esp+92], xmm4
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp

; 338  : 			r_dsgraph_insert_dynamic		(pVisual,Tpos);

	call	?r_dsgraph_insert_dynamic@R_dsgraph_structure@@QAEXPAVIRender_Visual@@AAU?$_vector3@M@@@Z ; R_dsgraph_structure::r_dsgraph_insert_dynamic
	mov	eax, DWORD PTR _i_it$1$[esp+76]
	jmp	$LN13@add_Dynami
$LN1550@add_Dynami:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	edi, DWORD PTR [ebp+92]

; 150  :         return _Ptr == _Right._Ptr;

	cmp	edi, DWORD PTR [ebp+96]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp

; 290  : 			for (PS::CParticleGroup::SItemVecIt i_it=pG->items.begin(); i_it!=pG->items.end(); i_it++)	{

	je	SHORT $LN16@add_Dynami
$LL1536@add_Dynami:

; 291  : 				PS::CParticleGroup::SItem&			I		= *i_it;
; 292  : 				if (I._effect)		add_leafs_Dynamic		(I._effect);

	mov	eax, DWORD PTR [edi]
	test	eax, eax
	je	SHORT $LN1551@add_Dynami
	push	eax
	mov	ecx, ebx
	call	?add_leafs_Dynamic@CRender@@AAEXPAVIRender_Visual@@@Z ; CRender::add_leafs_Dynamic
$LN1551@add_Dynami:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	esi, DWORD PTR [edi+4]

; 150  :         return _Ptr == _Right._Ptr;

	cmp	esi, DWORD PTR [edi+8]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp

; 293  : 				for (xr_vector<IRender_Visual*>::iterator pit = I._children_related.begin();	pit!=I._children_related.end(); pit++)	add_leafs_Dynamic(*pit);

	je	SHORT $LN1842@add_Dynami
	npad	5
$LL1539@add_Dynami:
	push	DWORD PTR [esi]
	mov	ecx, ebx
	call	?add_leafs_Dynamic@CRender@@AAEXPAVIRender_Visual@@@Z ; CRender::add_leafs_Dynamic
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 74   :         ++_Ptr;

	add	esi, 4

; 150  :         return _Ptr == _Right._Ptr;

	cmp	esi, DWORD PTR [edi+8]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp

; 293  : 				for (xr_vector<IRender_Visual*>::iterator pit = I._children_related.begin();	pit!=I._children_related.end(); pit++)	add_leafs_Dynamic(*pit);

	jne	SHORT $LL1539@add_Dynami
$LN1842@add_Dynami:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	esi, DWORD PTR [edi+16]

; 150  :         return _Ptr == _Right._Ptr;

	cmp	esi, DWORD PTR [edi+20]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp

; 294  : 				for (xr_vector<IRender_Visual*>::iterator pit = I._children_free.begin();		pit!=I._children_free.end();	pit++)	add_leafs_Dynamic(*pit);

	je	SHORT $LN1534@add_Dynami
	npad	7
$LL1542@add_Dynami:
	push	DWORD PTR [esi]
	mov	ecx, ebx
	call	?add_leafs_Dynamic@CRender@@AAEXPAVIRender_Visual@@@Z ; CRender::add_leafs_Dynamic
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 74   :         ++_Ptr;

	add	esi, 4

; 150  :         return _Ptr == _Right._Ptr;

	cmp	esi, DWORD PTR [edi+20]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp

; 294  : 				for (xr_vector<IRender_Visual*>::iterator pit = I._children_free.begin();		pit!=I._children_free.end();	pit++)	add_leafs_Dynamic(*pit);

	jne	SHORT $LL1542@add_Dynami
$LN1534@add_Dynami:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 74   :         ++_Ptr;

	add	edi, 28					; 0000001cH

; 150  :         return _Ptr == _Right._Ptr;

	cmp	edi, DWORD PTR [ebp+96]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp

; 290  : 			for (PS::CParticleGroup::SItemVecIt i_it=pG->items.begin(); i_it!=pG->items.end(); i_it++)	{

	jne	SHORT $LL1536@add_Dynami
$LN1854@add_Dynami:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 74   :         ++_Ptr;

	mov	eax, DWORD PTR _i_it$1$[esp+76]
$LN1855@add_Dynami:
	mov	esi, DWORD PTR _pit$1$[esp+76]
$LN16@add_Dynami:
	add	esi, 4
	mov	DWORD PTR _pit$1$[esp+76], esi

; 150  :         return _Ptr == _Right._Ptr;

	cmp	esi, DWORD PTR [eax+20]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp

; 455  : 					for (xr_vector<IRender_Visual*>::iterator pit = I._children_free.begin();		pit!=I._children_free.end();	pit++)	add_leafs_Dynamic(*pit);

	jne	$LL18@add_Dynami
$LN4@add_Dynami:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 74   :         ++_Ptr;

	mov	esi, DWORD PTR _i_it$1$[esp+76]

; 150  :         return _Ptr == _Right._Ptr;

	mov	eax, DWORD PTR _pVisual$[esp+72]

; 74   :         ++_Ptr;

	add	esi, 28					; 0000001cH
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp

; 443  : 			for (PS::CParticleGroup::SItemVecIt i_it=pG->items.begin(); i_it!=pG->items.end(); i_it++)

	movss	xmm7, DWORD PTR __real@3f000000
	mov	edi, DWORD PTR __imp_?CalculateWallmarks@CKinematics@@QAEXXZ
	mov	ecx, DWORD PTR _VIS$1$[esp+76]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 74   :         ++_Ptr;

	mov	DWORD PTR _i_it$1$[esp+76], esi

; 150  :         return _Ptr == _Right._Ptr;

	cmp	esi, DWORD PTR [eax+96]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp

; 443  : 			for (PS::CParticleGroup::SItemVecIt i_it=pG->items.begin(); i_it!=pG->items.end(); i_it++)

	jne	$LL6@add_Dynami

; 513  : 		}
; 514  : 		break;
; 515  : 	}
; 516  : 	return TRUE;

	pop	edi
	pop	esi
	pop	ebp
	mov	eax, 1

; 517  : }

	pop	ebx
	add	esp, 60					; 0000003cH
	ret	8
$LN1552@add_Dynami:

; 303  : 			E = pV->children.end	();

	mov	edi, DWORD PTR [ebp+72]

; 304  : 			for (; I!=E; I++)	add_leafs_Dynamic	(*I);

	mov	esi, DWORD PTR [ebp+68]
	cmp	esi, edi
	je	SHORT $LN1855@add_Dynami
$LL1545@add_Dynami:
	push	DWORD PTR [esi]
	mov	ecx, ebx
	call	?add_leafs_Dynamic@CRender@@AAEXPAVIRender_Visual@@@Z ; CRender::add_leafs_Dynamic
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 74   :         ++_Ptr;

	add	esi, 4
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp

; 304  : 			for (; I!=E; I++)	add_leafs_Dynamic	(*I);

	cmp	esi, edi
	jne	SHORT $LL1545@add_Dynami

; 305  : 		}
; 306  : 		return;

	jmp	SHORT $LN1854@add_Dynami
$LN1553@add_Dynami:

; 307  : 	case MT_SKELETON_ANIM:
; 308  : 	case MT_SKELETON_RIGID:
; 309  : 		{
; 310  : 			// Add all children, doesn't perform any tests
; 311  : 			CKinematics * pV			= (CKinematics*)pVisual;
; 312  : 			BOOL	_use_lod			= FALSE	;
; 313  : 			if (pV->m_lod)				

	mov	edx, DWORD PTR [ebp+84]
	test	edx, edx
	je	$LN1557@add_Dynami

; 314  : 			{
; 315  : 				Fvector							Tpos;	float		D;
; 316  : 				val_pTransform->transform_tiny	(Tpos, pV->vis.sphere.P);

	mov	ecx, DWORD PTR [ebx+264]
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 499  : 		dest.x = v.x*_11 + v.y*_21 + v.z*_31 + _41;

	movss	xmm4, DWORD PTR [ebp+12]
	movss	xmm6, DWORD PTR [ebp+8]

; 500  : 		dest.y = v.x*_12 + v.y*_22 + v.z*_32 + _42;

	movaps	xmm0, xmm4
	movss	xmm5, DWORD PTR [ebp+16]
	movaps	xmm1, xmm6
	mulss	xmm0, DWORD PTR [ecx+20]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp

; 31   : 	distSQ	= Device.vCameraPosition.distance_to_sqr(C)+EPS;

	mov	eax, DWORD PTR __imp_?Device@@3VCRenderDevice@@A
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 500  : 		dest.y = v.x*_12 + v.y*_22 + v.z*_32 + _42;

	mulss	xmm1, DWORD PTR [ecx+4]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 287  : 	{	return (x-v.x)*(x-v.x) + (y-v.y)*(y-v.y) + (z-v.z)*(z-v.z);	}

	movss	xmm3, DWORD PTR [eax+492]
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 500  : 		dest.y = v.x*_12 + v.y*_22 + v.z*_32 + _42;

	addss	xmm1, xmm0
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 287  : 	{	return (x-v.x)*(x-v.x) + (y-v.y)*(y-v.y) + (z-v.z)*(z-v.z);	}

	movss	xmm2, DWORD PTR [eax+488]
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 500  : 		dest.y = v.x*_12 + v.y*_22 + v.z*_32 + _42;

	movaps	xmm0, xmm5
	mulss	xmm0, DWORD PTR [ecx+36]
	addss	xmm0, DWORD PTR [ecx+52]
	addss	xmm1, xmm0
	movaps	xmm0, xmm6
	mulss	xmm0, DWORD PTR [ecx]

; 501  : 		dest.z = v.x*_13 + v.y*_23 + v.z*_33 + _43;

	mulss	xmm6, DWORD PTR [ecx+8]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 287  : 	{	return (x-v.x)*(x-v.x) + (y-v.y)*(y-v.y) + (z-v.z)*(z-v.z);	}

	subss	xmm3, xmm1
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 499  : 		dest.x = v.x*_11 + v.y*_21 + v.z*_31 + _41;

	movaps	xmm1, xmm4
	mulss	xmm1, DWORD PTR [ecx+16]

; 501  : 		dest.z = v.x*_13 + v.y*_23 + v.z*_33 + _43;

	mulss	xmm4, DWORD PTR [ecx+24]
	addss	xmm1, xmm0
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 287  : 	{	return (x-v.x)*(x-v.x) + (y-v.y)*(y-v.y) + (z-v.z)*(z-v.z);	}

	mulss	xmm3, xmm3
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 499  : 		dest.x = v.x*_11 + v.y*_21 + v.z*_31 + _41;

	movaps	xmm0, xmm5

; 501  : 		dest.z = v.x*_13 + v.y*_23 + v.z*_33 + _43;

	mulss	xmm5, DWORD PTR [ecx+40]
	mulss	xmm0, DWORD PTR [ecx+32]
	addss	xmm6, xmm4
	addss	xmm5, DWORD PTR [ecx+56]
	addss	xmm0, DWORD PTR [ecx+48]
	addss	xmm6, xmm5
	addss	xmm1, xmm0
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 287  : 	{	return (x-v.x)*(x-v.x) + (y-v.y)*(y-v.y) + (z-v.z)*(z-v.z);	}

	movss	xmm0, DWORD PTR [eax+496]
	subss	xmm0, xmm6
	subss	xmm2, xmm1
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp

; 317  : 				float		ssa		=	CalcSSA	(D,Tpos,pV->vis.sphere.R/2.f);	// assume dynamics never consume full sphere

	movss	xmm1, DWORD PTR [ebp+20]
	mulss	xmm1, DWORD PTR __real@3f000000
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 287  : 	{	return (x-v.x)*(x-v.x) + (y-v.y)*(y-v.y) + (z-v.z)*(z-v.z);	}

	mulss	xmm0, xmm0
	mulss	xmm2, xmm2
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp

; 31   : 	distSQ	= Device.vCameraPosition.distance_to_sqr(C)+EPS;

	addss	xmm0, DWORD PTR __real@3727c5ac
	addss	xmm2, xmm3
	addss	xmm2, xmm0

; 318  : 				if (ssa<r_ssaLOD_A)	_use_lod	= TRUE;

	movss	xmm0, DWORD PTR ?r_ssaLOD_A@@3MA

; 32   : 	return	R/distSQ;

	divss	xmm1, xmm2

; 318  : 				if (ssa<r_ssaLOD_A)	_use_lod	= TRUE;

	comiss	xmm0, xmm1
	jbe	SHORT $LN1557@add_Dynami

; 319  : 			}
; 320  : 			if (_use_lod)				
; 321  : 			{
; 322  : 				add_leafs_Dynamic			(pV->m_lod)		;

	push	edx
	mov	ecx, ebx
	call	?add_leafs_Dynamic@CRender@@AAEXPAVIRender_Visual@@@Z ; CRender::add_leafs_Dynamic

; 323  : 			} else {

	mov	eax, DWORD PTR _i_it$1$[esp+76]
	jmp	$LN16@add_Dynami
$LN1557@add_Dynami:

; 324  : 				pV->CalculateBones			(TRUE);

	mov	eax, DWORD PTR [ebp]
	mov	ecx, ebp
	push	1
	call	DWORD PTR [eax+64]

; 325  : 				pV->CalculateWallmarks		();		//. bug?

	mov	ecx, ebp
	call	DWORD PTR __imp_?CalculateWallmarks@CKinematics@@QAEXXZ

; 326  : 				I = pV->children.begin		();
; 327  : 				E = pV->children.end		();

	mov	edi, DWORD PTR [ebp+72]

; 328  : 				for (; I!=E; I++)	add_leafs_Dynamic	(*I);

	mov	esi, DWORD PTR [ebp+68]
	cmp	esi, edi
	je	$LN1854@add_Dynami
	npad	1
$LL1548@add_Dynami:
	push	DWORD PTR [esi]
	mov	ecx, ebx
	call	?add_leafs_Dynamic@CRender@@AAEXPAVIRender_Visual@@@Z ; CRender::add_leafs_Dynamic
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 74   :         ++_Ptr;

	add	esi, 4
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp

; 328  : 				for (; I!=E; I++)	add_leafs_Dynamic	(*I);

	cmp	esi, edi
	jne	SHORT $LL1548@add_Dynami

; 329  : 			}
; 330  : 		}
; 331  : 		return;

	jmp	$LN1854@add_Dynami
$LN1559@add_Dynami:

; 332  : 	default:
; 333  : 		{
; 334  : 			// General type of visual
; 335  : 			// Calculate distance to it's center
; 336  : 			Fvector							Tpos;
; 337  : 			val_pTransform->transform_tiny	(Tpos, pVisual->vis.sphere.P);

	mov	eax, DWORD PTR [ebx+264]

; 338  : 			r_dsgraph_insert_dynamic		(pVisual,Tpos);

	mov	ecx, ebx
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 499  : 		dest.x = v.x*_11 + v.y*_21 + v.z*_31 + _41;

	movss	xmm2, DWORD PTR [ebp+12]
	movss	xmm4, DWORD PTR [ebp+8]
	movaps	xmm1, xmm2
	movss	xmm3, DWORD PTR [ebp+16]
	movaps	xmm0, xmm4
	mulss	xmm0, DWORD PTR [eax]
	mulss	xmm1, DWORD PTR [eax+16]
	addss	xmm1, xmm0
	movaps	xmm0, xmm3
	mulss	xmm0, DWORD PTR [eax+32]
	addss	xmm0, DWORD PTR [eax+48]
	addss	xmm1, xmm0

; 500  : 		dest.y = v.x*_12 + v.y*_22 + v.z*_32 + _42;

	movaps	xmm0, xmm2
	mulss	xmm0, DWORD PTR [eax+20]

; 501  : 		dest.z = v.x*_13 + v.y*_23 + v.z*_33 + _43;

	mulss	xmm2, DWORD PTR [eax+24]
	movss	DWORD PTR _Tpos$7[esp+76], xmm1
	movaps	xmm1, xmm4
	mulss	xmm1, DWORD PTR [eax+4]
	mulss	xmm4, DWORD PTR [eax+8]
	addss	xmm1, xmm0
	movaps	xmm0, xmm3
	mulss	xmm0, DWORD PTR [eax+36]
	mulss	xmm3, DWORD PTR [eax+40]
	addss	xmm4, xmm2
	addss	xmm0, DWORD PTR [eax+52]
	addss	xmm3, DWORD PTR [eax+56]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp

; 338  : 			r_dsgraph_insert_dynamic		(pVisual,Tpos);

	lea	eax, DWORD PTR _Tpos$7[esp+76]
	push	eax
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 500  : 		dest.y = v.x*_12 + v.y*_22 + v.z*_32 + _42;

	addss	xmm1, xmm0
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp

; 338  : 			r_dsgraph_insert_dynamic		(pVisual,Tpos);

	push	ebp
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 501  : 		dest.z = v.x*_13 + v.y*_23 + v.z*_33 + _43;

	addss	xmm4, xmm3
	movss	DWORD PTR _Tpos$7[esp+88], xmm1
	movss	DWORD PTR _Tpos$7[esp+92], xmm4
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp

; 338  : 			r_dsgraph_insert_dynamic		(pVisual,Tpos);

	call	?r_dsgraph_insert_dynamic@R_dsgraph_structure@@QAEXPAVIRender_Visual@@AAU?$_vector3@M@@@Z ; R_dsgraph_structure::r_dsgraph_insert_dynamic
	mov	eax, DWORD PTR _i_it$1$[esp+76]
	jmp	$LN16@add_Dynami
$LN34@add_Dynami:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1463 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));

	mov	esi, DWORD PTR [ebp+68]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp

; 465  : 			E = pV->children.end	();

	mov	edi, DWORD PTR [ebp+72]

; 466  : 			if (fcvPartial==VIS) 

	cmp	ecx, 1
	jne	SHORT $LN35@add_Dynami

; 468  : 				for (; I!=E; I++)	add_Dynamic			(*I,planes);

	cmp	esi, edi
	je	$LN2@add_Dynami
	npad	6
$LL21@add_Dynami:
	push	DWORD PTR _planes$[esp+72]
	mov	ecx, ebx
	push	DWORD PTR [esi]
	call	?add_Dynamic@CRender@@AAEHPAVIRender_Visual@@I@Z ; CRender::add_Dynamic
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 74   :         ++_Ptr;

	add	esi, 4
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp

; 468  : 				for (; I!=E; I++)	add_Dynamic			(*I,planes);

	cmp	esi, edi
	jne	SHORT $LL21@add_Dynami

; 513  : 		}
; 514  : 		break;
; 515  : 	}
; 516  : 	return TRUE;

	pop	edi
	pop	esi
	pop	ebp
	mov	eax, 1

; 517  : }

	pop	ebx
	add	esp, 60					; 0000003cH
	ret	8
$LN35@add_Dynami:

; 470  : 				for (; I!=E; I++)	add_leafs_Dynamic	(*I);

	cmp	esi, edi
	je	$LN2@add_Dynami
	npad	5
$LL24@add_Dynami:
	push	DWORD PTR [esi]
	mov	ecx, ebx
	call	?add_leafs_Dynamic@CRender@@AAEXPAVIRender_Visual@@@Z ; CRender::add_leafs_Dynamic
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 74   :         ++_Ptr;

	add	esi, 4
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp

; 470  : 				for (; I!=E; I++)	add_leafs_Dynamic	(*I);

	cmp	esi, edi
	jne	SHORT $LL24@add_Dynami

; 513  : 		}
; 514  : 		break;
; 515  : 	}
; 516  : 	return TRUE;

	pop	edi
	pop	esi
	pop	ebp
	mov	eax, 1

; 517  : }

	pop	ebx
	add	esp, 60					; 0000003cH
	ret	8
$LN37@add_Dynami:

; 471  : 			}
; 472  : 		}
; 473  : 		break;
; 474  : 	case MT_SKELETON_ANIM:
; 475  : 	case MT_SKELETON_RIGID:
; 476  : 		{
; 477  : 			// Add all children, doesn't perform any tests
; 478  : 			CKinematics * pV			= (CKinematics*)pVisual;
; 479  : 			BOOL	_use_lod			= FALSE	;
; 480  : 			if (pV->m_lod)				

	mov	edx, DWORD PTR [ebp+84]
	test	edx, edx
	je	$LN41@add_Dynami

; 481  : 			{
; 482  : 				Fvector							Tpos;	float		D;
; 483  : 				val_pTransform->transform_tiny	(Tpos, pV->vis.sphere.P);

	mov	ecx, DWORD PTR [ebx+264]
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 499  : 		dest.x = v.x*_11 + v.y*_21 + v.z*_31 + _41;

	movss	xmm4, DWORD PTR [ebp+12]
	movss	xmm6, DWORD PTR [ebp+8]

; 500  : 		dest.y = v.x*_12 + v.y*_22 + v.z*_32 + _42;

	movaps	xmm0, xmm4
	movss	xmm5, DWORD PTR [ebp+16]
	movaps	xmm1, xmm6
	mulss	xmm0, DWORD PTR [ecx+20]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp

; 31   : 	distSQ	= Device.vCameraPosition.distance_to_sqr(C)+EPS;

	mov	eax, DWORD PTR __imp_?Device@@3VCRenderDevice@@A
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 500  : 		dest.y = v.x*_12 + v.y*_22 + v.z*_32 + _42;

	mulss	xmm1, DWORD PTR [ecx+4]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 287  : 	{	return (x-v.x)*(x-v.x) + (y-v.y)*(y-v.y) + (z-v.z)*(z-v.z);	}

	movss	xmm3, DWORD PTR [eax+492]
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 500  : 		dest.y = v.x*_12 + v.y*_22 + v.z*_32 + _42;

	addss	xmm1, xmm0
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 287  : 	{	return (x-v.x)*(x-v.x) + (y-v.y)*(y-v.y) + (z-v.z)*(z-v.z);	}

	movss	xmm2, DWORD PTR [eax+488]
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 500  : 		dest.y = v.x*_12 + v.y*_22 + v.z*_32 + _42;

	movaps	xmm0, xmm5
	mulss	xmm0, DWORD PTR [ecx+36]
	addss	xmm0, DWORD PTR [ecx+52]
	addss	xmm1, xmm0
	movaps	xmm0, xmm6
	mulss	xmm0, DWORD PTR [ecx]

; 501  : 		dest.z = v.x*_13 + v.y*_23 + v.z*_33 + _43;

	mulss	xmm6, DWORD PTR [ecx+8]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 287  : 	{	return (x-v.x)*(x-v.x) + (y-v.y)*(y-v.y) + (z-v.z)*(z-v.z);	}

	subss	xmm3, xmm1
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 499  : 		dest.x = v.x*_11 + v.y*_21 + v.z*_31 + _41;

	movaps	xmm1, xmm4
	mulss	xmm1, DWORD PTR [ecx+16]

; 501  : 		dest.z = v.x*_13 + v.y*_23 + v.z*_33 + _43;

	mulss	xmm4, DWORD PTR [ecx+24]
	addss	xmm1, xmm0
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 287  : 	{	return (x-v.x)*(x-v.x) + (y-v.y)*(y-v.y) + (z-v.z)*(z-v.z);	}

	mulss	xmm3, xmm3
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 499  : 		dest.x = v.x*_11 + v.y*_21 + v.z*_31 + _41;

	movaps	xmm0, xmm5

; 501  : 		dest.z = v.x*_13 + v.y*_23 + v.z*_33 + _43;

	mulss	xmm5, DWORD PTR [ecx+40]
	mulss	xmm0, DWORD PTR [ecx+32]
	addss	xmm6, xmm4
	addss	xmm5, DWORD PTR [ecx+56]
	addss	xmm0, DWORD PTR [ecx+48]
	addss	xmm6, xmm5
	addss	xmm1, xmm0
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 287  : 	{	return (x-v.x)*(x-v.x) + (y-v.y)*(y-v.y) + (z-v.z)*(z-v.z);	}

	movss	xmm0, DWORD PTR [eax+496]
	subss	xmm0, xmm6
	subss	xmm2, xmm1
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp

; 484  : 				float		ssa		=	CalcSSA	(D,Tpos,pV->vis.sphere.R/2.f);	// assume dynamics never consume full sphere

	movss	xmm1, DWORD PTR [ebp+20]
	mulss	xmm1, DWORD PTR __real@3f000000
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 287  : 	{	return (x-v.x)*(x-v.x) + (y-v.y)*(y-v.y) + (z-v.z)*(z-v.z);	}

	mulss	xmm0, xmm0
	mulss	xmm2, xmm2
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp

; 31   : 	distSQ	= Device.vCameraPosition.distance_to_sqr(C)+EPS;

	addss	xmm0, DWORD PTR __real@3727c5ac
	addss	xmm2, xmm3
	addss	xmm2, xmm0

; 485  : 				if (ssa<r_ssaLOD_A)	_use_lod	= TRUE		;

	movss	xmm0, DWORD PTR ?r_ssaLOD_A@@3MA

; 32   : 	return	R/distSQ;

	divss	xmm1, xmm2

; 485  : 				if (ssa<r_ssaLOD_A)	_use_lod	= TRUE		;

	comiss	xmm0, xmm1
	jbe	SHORT $LN41@add_Dynami

; 486  : 			}
; 487  : 			if (_use_lod)
; 488  : 			{
; 489  : 				add_leafs_Dynamic			(pV->m_lod)		;

	push	edx
	mov	ecx, ebx
	call	?add_leafs_Dynamic@CRender@@AAEXPAVIRender_Visual@@@Z ; CRender::add_leafs_Dynamic

; 513  : 		}
; 514  : 		break;
; 515  : 	}
; 516  : 	return TRUE;

	pop	edi
	pop	esi
	pop	ebp
	mov	eax, 1

; 517  : }

	pop	ebx
	add	esp, 60					; 0000003cH
	ret	8
$LN41@add_Dynami:

; 490  : 			} else 
; 491  : 			{
; 492  : 				pV->CalculateBones			(TRUE);

	mov	eax, DWORD PTR [ebp]
	mov	ecx, ebp
	push	1
	call	DWORD PTR [eax+64]

; 493  : 				pV->CalculateWallmarks		();		//. bug?

	mov	ecx, ebp
	call	DWORD PTR __imp_?CalculateWallmarks@CKinematics@@QAEXXZ

; 494  : 				I = pV->children.begin		();
; 495  : 				E = pV->children.end		();

	mov	edi, DWORD PTR [ebp+72]

; 496  : 				for (; I!=E; I++)	add_leafs_Dynamic	(*I);

	mov	esi, DWORD PTR [ebp+68]
	cmp	esi, edi
	je	SHORT $LN2@add_Dynami
	npad	6
$LL27@add_Dynami:
	push	DWORD PTR [esi]
	mov	ecx, ebx
	call	?add_leafs_Dynamic@CRender@@AAEXPAVIRender_Visual@@@Z ; CRender::add_leafs_Dynamic
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 74   :         ++_Ptr;

	add	esi, 4
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp

; 496  : 				for (; I!=E; I++)	add_leafs_Dynamic	(*I);

	cmp	esi, edi
	jne	SHORT $LL27@add_Dynami

; 513  : 		}
; 514  : 		break;
; 515  : 	}
; 516  : 	return TRUE;

	pop	edi
	pop	esi
	pop	ebp
	mov	eax, 1

; 517  : }

	pop	ebx
	add	esp, 60					; 0000003cH
	ret	8
$LN43@add_Dynami:

; 497  : 			}
; 498  : 			/*
; 499  : 			I = pV->children.begin		();
; 500  : 			E = pV->children.end		();
; 501  : 			if (fcvPartial==VIS) {
; 502  : 				for (; I!=E; I++)	add_Dynamic			(*I,planes);
; 503  : 			} else {
; 504  : 				for (; I!=E; I++)	add_leafs_Dynamic	(*I);
; 505  : 			}
; 506  : 			*/
; 507  : 		}
; 508  : 		break;
; 509  : 	default:
; 510  : 		{
; 511  : 			// General type of visual
; 512  : 			r_dsgraph_insert_dynamic(pVisual,Tpos);

	lea	eax, DWORD PTR _Tpos$[esp+76]
	mov	ecx, ebx
	push	eax
	push	ebp
	call	?r_dsgraph_insert_dynamic@R_dsgraph_structure@@QAEXPAVIRender_Visual@@AAU?$_vector3@M@@@Z ; R_dsgraph_structure::r_dsgraph_insert_dynamic
$LN2@add_Dynami:

; 513  : 		}
; 514  : 		break;
; 515  : 	}
; 516  : 	return TRUE;

	pop	edi
	pop	esi
	pop	ebp
	mov	eax, 1

; 517  : }

	pop	ebx
	add	esp, 60					; 0000003cH
	ret	8
	npad	1
$LN1845@add_Dynami:
	DD	$LN34@add_Dynami
	DD	$LN37@add_Dynami
	DD	$LN29@add_Dynami
	DD	$LN43@add_Dynami
$LN1844@add_Dynami:
	DB	0
	DB	3
	DB	1
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	2
	DB	1
	npad	2
$LN1847@add_Dynami:
	DD	$LN1220@add_Dynami
	DD	$LN1221@add_Dynami
	DD	$LN1218@add_Dynami
	DD	$LN1227@add_Dynami
$LN1846@add_Dynami:
	DB	0
	DB	3
	DB	1
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	2
	DB	1
	npad	2
$LN1849@add_Dynami:
	DD	$LN1386@add_Dynami
	DD	$LN1387@add_Dynami
	DD	$LN1384@add_Dynami
	DD	$LN1393@add_Dynami
$LN1848@add_Dynami:
	DB	0
	DB	3
	DB	1
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	2
	DB	1
	npad	2
$LN1851@add_Dynami:
	DD	$LN1552@add_Dynami
	DD	$LN1553@add_Dynami
	DD	$LN1550@add_Dynami
	DD	$LN1559@add_Dynami
$LN1850@add_Dynami:
	DB	0
	DB	3
	DB	1
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	2
	DB	1
?add_Dynamic@CRender@@AAEHPAVIRender_Visual@@I@Z ENDP	; CRender::add_Dynamic
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp
_TEXT	SEGMENT
_i_it$1$ = -52						; size = 4
_pVisual$1$ = -48					; size = 4
_pit$1$ = -48						; size = 4
_pit$1$ = -48						; size = 4
_ssa$1$ = -44						; size = 4
_VIS$1$ = -44						; size = 4
_pVisual$1$ = -40					; size = 4
_pVisual$1$ = -40					; size = 4
_D$4 = -40						; size = 4
_Tpos$5 = -36						; size = 12
_Tpos$6 = -24						; size = 12
_Tpos$7 = -12						; size = 12
_pVisual$ = 8						; size = 4
_planes$ = 12						; size = 4
?add_Static@CRender@@AAEXPAVIRender_Visual@@I@Z PROC	; CRender::add_Static
; _this$ = ecx

; 520  : {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	sub	esp, 52					; 00000034H
	push	ebx
	push	esi
	push	edi

; 521  : 	// Check frustum visibility and calculate distance to visual's center
; 522  : 	EFC_Visible	VIS;
; 523  : 	vis_data&	vis			= pVisual->vis;

	mov	edi, DWORD PTR _pVisual$[ebp]

; 524  : 	VIS = View->testSAABB	(vis.sphere.P,vis.sphere.R,vis.box.data(),planes);

	lea	eax, DWORD PTR _planes$[ebp]
	fld	DWORD PTR [edi+20]
	lea	esi, DWORD PTR [edi+8]
	push	eax
	lea	eax, DWORD PTR [esi+16]
	mov	ebx, ecx
	push	eax
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR [ebx+252]
	push	esi
	call	DWORD PTR __imp_?testSAABB@CFrustum@@QBE?AW4EFC_Visible@@AAU?$_vector3@M@@MPBMAAI@Z
	mov	DWORD PTR _VIS$1$[esp+64], eax

; 525  : 	if (fcvNone==VIS)		return;

	test	eax, eax
	je	$LN2@add_Static

; 526  : 	if (!HOM.visible(vis))	return;

	push	esi
	lea	ecx, DWORD PTR [ebx+712]
	call	?visible@CHOM@@QAEHAAUvis_data@@@Z	; CHOM::visible
	test	eax, eax
	je	$LN2@add_Static

; 527  : 
; 528  : 	// If we get here visual is visible or partially visible
; 529  : 	xr_vector<IRender_Visual*>::iterator I,E;	// it may be usefull for 'hierrarhy' visuals
; 530  : 
; 531  : 	switch (pVisual->Type) {

	mov	eax, DWORD PTR [edi+4]
	dec	eax
	cmp	eax, 10					; 0000000aH
	ja	$LN54@add_Static
	movzx	eax, BYTE PTR $LN802@add_Static[eax]
	jmp	DWORD PTR $LN803@add_Static[eax*4]
$LN36@add_Static:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	esi, DWORD PTR [edi+92]
	mov	DWORD PTR _i_it$1$[esp+64], esi

; 150  :         return _Ptr == _Right._Ptr;

	cmp	esi, DWORD PTR [edi+96]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp

; 536  : 			for (PS::CParticleGroup::SItemVecIt i_it=pG->items.begin(); i_it!=pG->items.end(); i_it++){

	je	$LN2@add_Static
	movss	xmm7, DWORD PTR __real@3f000000
$LL6@add_Static:

; 537  : 				PS::CParticleGroup::SItem&			I		= *i_it;
; 538  : 				if (fcvPartial==VIS) {

	cmp	DWORD PTR _VIS$1$[esp+64], 1
	mov	edx, DWORD PTR [esi]
	mov	DWORD PTR _pVisual$1$[esp+64], edx
	jne	SHORT $LN37@add_Static

; 539  : 					if (I._effect)		add_Dynamic				(I._effect,planes);

	test	edx, edx
	je	SHORT $LN39@add_Static
	push	DWORD PTR _planes$[ebp]
	mov	ecx, ebx
	push	edx
	call	?add_Dynamic@CRender@@AAEHPAVIRender_Visual@@I@Z ; CRender::add_Dynamic
$LN39@add_Static:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 150  :         return _Ptr == _Right._Ptr;

	mov	edi, DWORD PTR _i_it$1$[esp+64]

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	esi, DWORD PTR [esi+4]

; 150  :         return _Ptr == _Right._Ptr;

	cmp	esi, DWORD PTR [edi+8]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp

; 540  : 					for (xr_vector<IRender_Visual*>::iterator pit = I._children_related.begin();	pit!=I._children_related.end(); pit++)	add_Dynamic(*pit,planes);

	je	SHORT $LN793@add_Static
	npad	5
$LL9@add_Static:
	push	DWORD PTR _planes$[ebp]
	mov	ecx, ebx
	push	DWORD PTR [esi]
	call	?add_Dynamic@CRender@@AAEHPAVIRender_Visual@@I@Z ; CRender::add_Dynamic
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 74   :         ++_Ptr;

	add	esi, 4

; 150  :         return _Ptr == _Right._Ptr;

	cmp	esi, DWORD PTR [edi+8]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp

; 540  : 					for (xr_vector<IRender_Visual*>::iterator pit = I._children_related.begin();	pit!=I._children_related.end(); pit++)	add_Dynamic(*pit,planes);

	jne	SHORT $LL9@add_Static
$LN793@add_Static:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	esi, DWORD PTR [edi+16]

; 150  :         return _Ptr == _Right._Ptr;

	cmp	esi, DWORD PTR [edi+20]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp

; 541  : 					for (xr_vector<IRender_Visual*>::iterator pit = I._children_free.begin();		pit!=I._children_free.end();	pit++)	add_Dynamic(*pit,planes);

	je	$LN4@add_Static
$LL12@add_Static:
	push	DWORD PTR _planes$[ebp]
	mov	ecx, ebx
	push	DWORD PTR [esi]
	call	?add_Dynamic@CRender@@AAEHPAVIRender_Visual@@I@Z ; CRender::add_Dynamic
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 74   :         ++_Ptr;

	add	esi, 4

; 150  :         return _Ptr == _Right._Ptr;

	cmp	esi, DWORD PTR [edi+20]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp

; 541  : 					for (xr_vector<IRender_Visual*>::iterator pit = I._children_free.begin();		pit!=I._children_free.end();	pit++)	add_Dynamic(*pit,planes);

	jne	SHORT $LL12@add_Static
	jmp	$LN4@add_Static
$LN37@add_Static:

; 542  : 				} else {
; 543  : 					if (I._effect)		add_leafs_Dynamic		(I._effect);

	test	edx, edx
	je	$LN124@add_Static

; 285  : 	switch (pVisual->Type) {

	mov	eax, DWORD PTR [edx+4]
	dec	eax
	cmp	eax, 9
	ja	$LN152@add_Static
	movzx	eax, BYTE PTR $LN804@add_Static[eax]
	jmp	DWORD PTR $LN805@add_Static[eax*4]
$LN143@add_Static:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	edi, DWORD PTR [edx+92]

; 150  :         return _Ptr == _Right._Ptr;

	cmp	edi, DWORD PTR [edx+96]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp

; 290  : 			for (PS::CParticleGroup::SItemVecIt i_it=pG->items.begin(); i_it!=pG->items.end(); i_it++)	{

	je	SHORT $LN124@add_Static
$LL129@add_Static:

; 291  : 				PS::CParticleGroup::SItem&			I		= *i_it;
; 292  : 				if (I._effect)		add_leafs_Dynamic		(I._effect);

	mov	eax, DWORD PTR [edi]
	test	eax, eax
	je	SHORT $LN144@add_Static
	push	eax
	mov	ecx, ebx
	call	?add_leafs_Dynamic@CRender@@AAEXPAVIRender_Visual@@@Z ; CRender::add_leafs_Dynamic
$LN144@add_Static:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	esi, DWORD PTR [edi+4]

; 150  :         return _Ptr == _Right._Ptr;

	cmp	esi, DWORD PTR [edi+8]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp

; 293  : 				for (xr_vector<IRender_Visual*>::iterator pit = I._children_related.begin();	pit!=I._children_related.end(); pit++)	add_leafs_Dynamic(*pit);

	je	SHORT $LN796@add_Static
	npad	6
$LL132@add_Static:
	push	DWORD PTR [esi]
	mov	ecx, ebx
	call	?add_leafs_Dynamic@CRender@@AAEXPAVIRender_Visual@@@Z ; CRender::add_leafs_Dynamic
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 74   :         ++_Ptr;

	add	esi, 4

; 150  :         return _Ptr == _Right._Ptr;

	cmp	esi, DWORD PTR [edi+8]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp

; 293  : 				for (xr_vector<IRender_Visual*>::iterator pit = I._children_related.begin();	pit!=I._children_related.end(); pit++)	add_leafs_Dynamic(*pit);

	jne	SHORT $LL132@add_Static
$LN796@add_Static:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	esi, DWORD PTR [edi+16]

; 150  :         return _Ptr == _Right._Ptr;

	cmp	esi, DWORD PTR [edi+20]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp

; 294  : 				for (xr_vector<IRender_Visual*>::iterator pit = I._children_free.begin();		pit!=I._children_free.end();	pit++)	add_leafs_Dynamic(*pit);

	je	SHORT $LN127@add_Static
	npad	7
$LL135@add_Static:
	push	DWORD PTR [esi]
	mov	ecx, ebx
	call	?add_leafs_Dynamic@CRender@@AAEXPAVIRender_Visual@@@Z ; CRender::add_leafs_Dynamic
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 74   :         ++_Ptr;

	add	esi, 4

; 150  :         return _Ptr == _Right._Ptr;

	cmp	esi, DWORD PTR [edi+20]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp

; 294  : 				for (xr_vector<IRender_Visual*>::iterator pit = I._children_free.begin();		pit!=I._children_free.end();	pit++)	add_leafs_Dynamic(*pit);

	jne	SHORT $LL135@add_Static
$LN127@add_Static:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 150  :         return _Ptr == _Right._Ptr;

	mov	eax, DWORD PTR _pVisual$1$[esp+64]

; 74   :         ++_Ptr;

	add	edi, 28					; 0000001cH

; 150  :         return _Ptr == _Right._Ptr;

	cmp	edi, DWORD PTR [eax+96]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp

; 290  : 			for (PS::CParticleGroup::SItemVecIt i_it=pG->items.begin(); i_it!=pG->items.end(); i_it++)	{

	jne	SHORT $LL129@add_Static
$LN814@add_Static:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	movss	xmm7, DWORD PTR __real@3f000000
$LN815@add_Static:
	mov	esi, DWORD PTR _i_it$1$[esp+64]
$LN124@add_Static:

; 150  :         return _Ptr == _Right._Ptr;

	mov	eax, DWORD PTR _i_it$1$[esp+64]

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	esi, DWORD PTR [esi+4]
	mov	DWORD PTR _pit$1$[esp+64], esi

; 150  :         return _Ptr == _Right._Ptr;

	cmp	esi, DWORD PTR [eax+8]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp

; 544  : 					for (xr_vector<IRender_Visual*>::iterator pit = I._children_related.begin();	pit!=I._children_related.end(); pit++)	add_leafs_Dynamic(*pit);

	je	$LN14@add_Static
	npad	3
$LL15@add_Static:
	mov	edx, DWORD PTR [esi]
	mov	DWORD PTR _pVisual$1$[esp+64], edx

; 280  : 	if (0==pVisual)				return;

	test	edx, edx
	je	$LN13@add_Static

; 281  : 
; 282  : 	// Visual is 100% visible - simply add it
; 283  : 	xr_vector<IRender_Visual*>::iterator I,E;	// it may be useful for 'hierrarhy' visual
; 284  : 
; 285  : 	switch (pVisual->Type) {

	mov	ecx, DWORD PTR [edx+4]
	dec	ecx
	cmp	ecx, 9
	ja	$LN318@add_Static
	movzx	ecx, BYTE PTR $LN806@add_Static[ecx]
	jmp	DWORD PTR $LN807@add_Static[ecx*4]
$LN145@add_Static:

; 303  : 			E = pV->children.end	();

	mov	edi, DWORD PTR [edx+72]

; 304  : 			for (; I!=E; I++)	add_leafs_Dynamic	(*I);

	mov	esi, DWORD PTR [edx+68]
	cmp	esi, edi
	je	SHORT $LN815@add_Static
$LL138@add_Static:
	push	DWORD PTR [esi]
	mov	ecx, ebx
	call	?add_leafs_Dynamic@CRender@@AAEXPAVIRender_Visual@@@Z ; CRender::add_leafs_Dynamic
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 74   :         ++_Ptr;

	add	esi, 4
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp

; 304  : 			for (; I!=E; I++)	add_leafs_Dynamic	(*I);

	cmp	esi, edi
	jne	SHORT $LL138@add_Static

; 305  : 		}
; 306  : 		return;

	jmp	SHORT $LN814@add_Static
$LN146@add_Static:

; 307  : 	case MT_SKELETON_ANIM:
; 308  : 	case MT_SKELETON_RIGID:
; 309  : 		{
; 310  : 			// Add all children, doesn't perform any tests
; 311  : 			CKinematics * pV			= (CKinematics*)pVisual;
; 312  : 			BOOL	_use_lod			= FALSE	;
; 313  : 			if (pV->m_lod)				

	mov	edi, DWORD PTR [edx+84]
	test	edi, edi
	je	$LN150@add_Static

; 314  : 			{
; 315  : 				Fvector							Tpos;	float		D;
; 316  : 				val_pTransform->transform_tiny	(Tpos, pV->vis.sphere.P);

	mov	ecx, DWORD PTR [ebx+264]
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 499  : 		dest.x = v.x*_11 + v.y*_21 + v.z*_31 + _41;

	movss	xmm4, DWORD PTR [edx+12]
	movss	xmm6, DWORD PTR [edx+8]

; 500  : 		dest.y = v.x*_12 + v.y*_22 + v.z*_32 + _42;

	movaps	xmm0, xmm4
	movss	xmm5, DWORD PTR [edx+16]
	movaps	xmm1, xmm6
	mulss	xmm0, DWORD PTR [ecx+20]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp

; 31   : 	distSQ	= Device.vCameraPosition.distance_to_sqr(C)+EPS;

	mov	eax, DWORD PTR __imp_?Device@@3VCRenderDevice@@A
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 500  : 		dest.y = v.x*_12 + v.y*_22 + v.z*_32 + _42;

	mulss	xmm1, DWORD PTR [ecx+4]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 287  : 	{	return (x-v.x)*(x-v.x) + (y-v.y)*(y-v.y) + (z-v.z)*(z-v.z);	}

	movss	xmm3, DWORD PTR [eax+492]
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 500  : 		dest.y = v.x*_12 + v.y*_22 + v.z*_32 + _42;

	addss	xmm1, xmm0
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 287  : 	{	return (x-v.x)*(x-v.x) + (y-v.y)*(y-v.y) + (z-v.z)*(z-v.z);	}

	movss	xmm2, DWORD PTR [eax+488]
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 500  : 		dest.y = v.x*_12 + v.y*_22 + v.z*_32 + _42;

	movaps	xmm0, xmm5
	mulss	xmm0, DWORD PTR [ecx+36]
	addss	xmm0, DWORD PTR [ecx+52]
	addss	xmm1, xmm0
	movaps	xmm0, xmm6
	mulss	xmm0, DWORD PTR [ecx]

; 501  : 		dest.z = v.x*_13 + v.y*_23 + v.z*_33 + _43;

	mulss	xmm6, DWORD PTR [ecx+8]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 287  : 	{	return (x-v.x)*(x-v.x) + (y-v.y)*(y-v.y) + (z-v.z)*(z-v.z);	}

	subss	xmm3, xmm1
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 499  : 		dest.x = v.x*_11 + v.y*_21 + v.z*_31 + _41;

	movaps	xmm1, xmm4
	mulss	xmm1, DWORD PTR [ecx+16]

; 501  : 		dest.z = v.x*_13 + v.y*_23 + v.z*_33 + _43;

	mulss	xmm4, DWORD PTR [ecx+24]
	addss	xmm1, xmm0
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 287  : 	{	return (x-v.x)*(x-v.x) + (y-v.y)*(y-v.y) + (z-v.z)*(z-v.z);	}

	mulss	xmm3, xmm3
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 499  : 		dest.x = v.x*_11 + v.y*_21 + v.z*_31 + _41;

	movaps	xmm0, xmm5

; 501  : 		dest.z = v.x*_13 + v.y*_23 + v.z*_33 + _43;

	mulss	xmm5, DWORD PTR [ecx+40]
	mulss	xmm0, DWORD PTR [ecx+32]
	addss	xmm6, xmm4
	addss	xmm5, DWORD PTR [ecx+56]
	addss	xmm0, DWORD PTR [ecx+48]
	addss	xmm6, xmm5
	addss	xmm1, xmm0
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 287  : 	{	return (x-v.x)*(x-v.x) + (y-v.y)*(y-v.y) + (z-v.z)*(z-v.z);	}

	movss	xmm0, DWORD PTR [eax+496]
	subss	xmm0, xmm6
	subss	xmm2, xmm1
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp

; 317  : 				float		ssa		=	CalcSSA	(D,Tpos,pV->vis.sphere.R/2.f);	// assume dynamics never consume full sphere

	movss	xmm1, DWORD PTR [edx+20]
	mulss	xmm1, xmm7
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 287  : 	{	return (x-v.x)*(x-v.x) + (y-v.y)*(y-v.y) + (z-v.z)*(z-v.z);	}

	mulss	xmm0, xmm0
	mulss	xmm2, xmm2
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp

; 31   : 	distSQ	= Device.vCameraPosition.distance_to_sqr(C)+EPS;

	addss	xmm0, DWORD PTR __real@3727c5ac
	addss	xmm2, xmm3
	addss	xmm2, xmm0

; 318  : 				if (ssa<r_ssaLOD_A)	_use_lod	= TRUE;

	movss	xmm0, DWORD PTR ?r_ssaLOD_A@@3MA

; 32   : 	return	R/distSQ;

	divss	xmm1, xmm2

; 318  : 				if (ssa<r_ssaLOD_A)	_use_lod	= TRUE;

	comiss	xmm0, xmm1
	jbe	SHORT $LN150@add_Static

; 319  : 			}
; 320  : 			if (_use_lod)				
; 321  : 			{
; 322  : 				add_leafs_Dynamic			(pV->m_lod)		;

	push	edi
	mov	ecx, ebx
	call	?add_leafs_Dynamic@CRender@@AAEXPAVIRender_Visual@@@Z ; CRender::add_leafs_Dynamic

; 323  : 			} else {

	movss	xmm7, DWORD PTR __real@3f000000
	jmp	$LN124@add_Static
$LN150@add_Static:

; 324  : 				pV->CalculateBones			(TRUE);

	mov	eax, DWORD PTR [edx]
	mov	ecx, edx
	push	1
	call	DWORD PTR [eax+64]

; 325  : 				pV->CalculateWallmarks		();		//. bug?

	mov	esi, DWORD PTR _pVisual$1$[esp+64]
	mov	ecx, esi
	call	DWORD PTR __imp_?CalculateWallmarks@CKinematics@@QAEXXZ

; 326  : 				I = pV->children.begin		();
; 327  : 				E = pV->children.end		();

	mov	edi, DWORD PTR [esi+72]

; 328  : 				for (; I!=E; I++)	add_leafs_Dynamic	(*I);

	mov	esi, DWORD PTR [esi+68]
	cmp	esi, edi
	je	$LN814@add_Static
$LL141@add_Static:
	push	DWORD PTR [esi]
	mov	ecx, ebx
	call	?add_leafs_Dynamic@CRender@@AAEXPAVIRender_Visual@@@Z ; CRender::add_leafs_Dynamic
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 74   :         ++_Ptr;

	add	esi, 4
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp

; 328  : 				for (; I!=E; I++)	add_leafs_Dynamic	(*I);

	cmp	esi, edi
	jne	SHORT $LL141@add_Static

; 329  : 			}
; 330  : 		}
; 331  : 		return;

	jmp	$LN814@add_Static
$LN152@add_Static:

; 332  : 	default:
; 333  : 		{
; 334  : 			// General type of visual
; 335  : 			// Calculate distance to it's center
; 336  : 			Fvector							Tpos;
; 337  : 			val_pTransform->transform_tiny	(Tpos, pVisual->vis.sphere.P);

	mov	eax, DWORD PTR [ebx+264]

; 338  : 			r_dsgraph_insert_dynamic		(pVisual,Tpos);

	mov	ecx, ebx
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 499  : 		dest.x = v.x*_11 + v.y*_21 + v.z*_31 + _41;

	movss	xmm2, DWORD PTR [edx+12]
	movss	xmm4, DWORD PTR [edx+8]
	movaps	xmm1, xmm2
	movss	xmm3, DWORD PTR [edx+16]
	movaps	xmm0, xmm4
	mulss	xmm0, DWORD PTR [eax]
	mulss	xmm1, DWORD PTR [eax+16]
	addss	xmm1, xmm0
	movaps	xmm0, xmm3
	mulss	xmm0, DWORD PTR [eax+32]
	addss	xmm0, DWORD PTR [eax+48]
	addss	xmm1, xmm0

; 500  : 		dest.y = v.x*_12 + v.y*_22 + v.z*_32 + _42;

	movaps	xmm0, xmm2
	mulss	xmm0, DWORD PTR [eax+20]

; 501  : 		dest.z = v.x*_13 + v.y*_23 + v.z*_33 + _43;

	mulss	xmm2, DWORD PTR [eax+24]
	movss	DWORD PTR _Tpos$5[esp+64], xmm1
	movaps	xmm1, xmm4
	mulss	xmm1, DWORD PTR [eax+4]
	mulss	xmm4, DWORD PTR [eax+8]
	addss	xmm1, xmm0
	movaps	xmm0, xmm3
	mulss	xmm0, DWORD PTR [eax+36]
	mulss	xmm3, DWORD PTR [eax+40]
	addss	xmm4, xmm2
	addss	xmm0, DWORD PTR [eax+52]
	addss	xmm3, DWORD PTR [eax+56]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp

; 338  : 			r_dsgraph_insert_dynamic		(pVisual,Tpos);

	lea	eax, DWORD PTR _Tpos$5[esp+64]
	push	eax
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 500  : 		dest.y = v.x*_12 + v.y*_22 + v.z*_32 + _42;

	addss	xmm1, xmm0
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp

; 338  : 			r_dsgraph_insert_dynamic		(pVisual,Tpos);

	push	edx
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 501  : 		dest.z = v.x*_13 + v.y*_23 + v.z*_33 + _43;

	addss	xmm4, xmm3
	movss	DWORD PTR _Tpos$5[esp+76], xmm1
	movss	DWORD PTR _Tpos$5[esp+80], xmm4
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp

; 338  : 			r_dsgraph_insert_dynamic		(pVisual,Tpos);

	call	?r_dsgraph_insert_dynamic@R_dsgraph_structure@@QAEXPAVIRender_Visual@@AAU?$_vector3@M@@@Z ; R_dsgraph_structure::r_dsgraph_insert_dynamic
	movss	xmm7, DWORD PTR __real@3f000000
	jmp	$LN124@add_Static
$LN309@add_Static:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	edi, DWORD PTR [edx+92]

; 150  :         return _Ptr == _Right._Ptr;

	cmp	edi, DWORD PTR [edx+96]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp

; 290  : 			for (PS::CParticleGroup::SItemVecIt i_it=pG->items.begin(); i_it!=pG->items.end(); i_it++)	{

	je	SHORT $LN13@add_Static
$LL295@add_Static:

; 291  : 				PS::CParticleGroup::SItem&			I		= *i_it;
; 292  : 				if (I._effect)		add_leafs_Dynamic		(I._effect);

	mov	eax, DWORD PTR [edi]
	test	eax, eax
	je	SHORT $LN310@add_Static
	push	eax
	mov	ecx, ebx
	call	?add_leafs_Dynamic@CRender@@AAEXPAVIRender_Visual@@@Z ; CRender::add_leafs_Dynamic
$LN310@add_Static:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	esi, DWORD PTR [edi+4]

; 150  :         return _Ptr == _Right._Ptr;

	cmp	esi, DWORD PTR [edi+8]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp

; 293  : 				for (xr_vector<IRender_Visual*>::iterator pit = I._children_related.begin();	pit!=I._children_related.end(); pit++)	add_leafs_Dynamic(*pit);

	je	SHORT $LN798@add_Static
	npad	6
$LL298@add_Static:
	push	DWORD PTR [esi]
	mov	ecx, ebx
	call	?add_leafs_Dynamic@CRender@@AAEXPAVIRender_Visual@@@Z ; CRender::add_leafs_Dynamic
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 74   :         ++_Ptr;

	add	esi, 4

; 150  :         return _Ptr == _Right._Ptr;

	cmp	esi, DWORD PTR [edi+8]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp

; 293  : 				for (xr_vector<IRender_Visual*>::iterator pit = I._children_related.begin();	pit!=I._children_related.end(); pit++)	add_leafs_Dynamic(*pit);

	jne	SHORT $LL298@add_Static
$LN798@add_Static:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	esi, DWORD PTR [edi+16]

; 150  :         return _Ptr == _Right._Ptr;

	cmp	esi, DWORD PTR [edi+20]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp

; 294  : 				for (xr_vector<IRender_Visual*>::iterator pit = I._children_free.begin();		pit!=I._children_free.end();	pit++)	add_leafs_Dynamic(*pit);

	je	SHORT $LN293@add_Static
	npad	7
$LL301@add_Static:
	push	DWORD PTR [esi]
	mov	ecx, ebx
	call	?add_leafs_Dynamic@CRender@@AAEXPAVIRender_Visual@@@Z ; CRender::add_leafs_Dynamic
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 74   :         ++_Ptr;

	add	esi, 4

; 150  :         return _Ptr == _Right._Ptr;

	cmp	esi, DWORD PTR [edi+20]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp

; 294  : 				for (xr_vector<IRender_Visual*>::iterator pit = I._children_free.begin();		pit!=I._children_free.end();	pit++)	add_leafs_Dynamic(*pit);

	jne	SHORT $LL301@add_Static
$LN293@add_Static:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 150  :         return _Ptr == _Right._Ptr;

	mov	eax, DWORD PTR _pVisual$1$[esp+64]

; 74   :         ++_Ptr;

	add	edi, 28					; 0000001cH

; 150  :         return _Ptr == _Right._Ptr;

	cmp	edi, DWORD PTR [eax+96]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp

; 290  : 			for (PS::CParticleGroup::SItemVecIt i_it=pG->items.begin(); i_it!=pG->items.end(); i_it++)	{

	jne	SHORT $LL295@add_Static
$LN810@add_Static:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 74   :         ++_Ptr;

	mov	eax, DWORD PTR _i_it$1$[esp+64]
$LN811@add_Static:
	mov	esi, DWORD PTR _pit$1$[esp+64]
$LN13@add_Static:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp

; 544  : 					for (xr_vector<IRender_Visual*>::iterator pit = I._children_related.begin();	pit!=I._children_related.end(); pit++)	add_leafs_Dynamic(*pit);

	movss	xmm7, DWORD PTR __real@3f000000
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 74   :         ++_Ptr;

	add	esi, 4
	mov	DWORD PTR _pit$1$[esp+64], esi

; 150  :         return _Ptr == _Right._Ptr;

	cmp	esi, DWORD PTR [eax+8]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp

; 544  : 					for (xr_vector<IRender_Visual*>::iterator pit = I._children_related.begin();	pit!=I._children_related.end(); pit++)	add_leafs_Dynamic(*pit);

	jne	$LL15@add_Static
$LN14@add_Static:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	esi, DWORD PTR _i_it$1$[esp+64]

; 150  :         return _Ptr == _Right._Ptr;

	mov	eax, DWORD PTR _i_it$1$[esp+64]

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	esi, DWORD PTR [esi+16]
	mov	DWORD PTR _pit$1$[esp+64], esi

; 150  :         return _Ptr == _Right._Ptr;

	cmp	esi, DWORD PTR [eax+20]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp

; 545  : 					for (xr_vector<IRender_Visual*>::iterator pit = I._children_free.begin();		pit!=I._children_free.end();	pit++)	add_leafs_Dynamic(*pit);

	je	$LN4@add_Static
$LL18@add_Static:
	mov	edx, DWORD PTR [esi]
	mov	DWORD PTR _pVisual$1$[esp+64], edx

; 280  : 	if (0==pVisual)				return;

	test	edx, edx
	je	$LN16@add_Static

; 281  : 
; 282  : 	// Visual is 100% visible - simply add it
; 283  : 	xr_vector<IRender_Visual*>::iterator I,E;	// it may be useful for 'hierrarhy' visual
; 284  : 
; 285  : 	switch (pVisual->Type) {

	mov	ecx, DWORD PTR [edx+4]
	dec	ecx
	cmp	ecx, 9
	ja	$LN484@add_Static
	movzx	ecx, BYTE PTR $LN808@add_Static[ecx]
	jmp	DWORD PTR $LN809@add_Static[ecx*4]
$LN311@add_Static:

; 303  : 			E = pV->children.end	();

	mov	edi, DWORD PTR [edx+72]

; 304  : 			for (; I!=E; I++)	add_leafs_Dynamic	(*I);

	mov	esi, DWORD PTR [edx+68]
	cmp	esi, edi
	je	SHORT $LN811@add_Static
	npad	8
$LL304@add_Static:
	push	DWORD PTR [esi]
	mov	ecx, ebx
	call	?add_leafs_Dynamic@CRender@@AAEXPAVIRender_Visual@@@Z ; CRender::add_leafs_Dynamic
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 74   :         ++_Ptr;

	add	esi, 4
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp

; 304  : 			for (; I!=E; I++)	add_leafs_Dynamic	(*I);

	cmp	esi, edi
	jne	SHORT $LL304@add_Static

; 305  : 		}
; 306  : 		return;

	jmp	$LN810@add_Static
$LN312@add_Static:

; 307  : 	case MT_SKELETON_ANIM:
; 308  : 	case MT_SKELETON_RIGID:
; 309  : 		{
; 310  : 			// Add all children, doesn't perform any tests
; 311  : 			CKinematics * pV			= (CKinematics*)pVisual;
; 312  : 			BOOL	_use_lod			= FALSE	;
; 313  : 			if (pV->m_lod)				

	mov	edi, DWORD PTR [edx+84]
	test	edi, edi
	je	$LN316@add_Static

; 314  : 			{
; 315  : 				Fvector							Tpos;	float		D;
; 316  : 				val_pTransform->transform_tiny	(Tpos, pV->vis.sphere.P);

	mov	ecx, DWORD PTR [ebx+264]
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 499  : 		dest.x = v.x*_11 + v.y*_21 + v.z*_31 + _41;

	movss	xmm4, DWORD PTR [edx+12]
	movss	xmm6, DWORD PTR [edx+8]

; 500  : 		dest.y = v.x*_12 + v.y*_22 + v.z*_32 + _42;

	movaps	xmm0, xmm4
	movss	xmm5, DWORD PTR [edx+16]
	movaps	xmm1, xmm6
	mulss	xmm0, DWORD PTR [ecx+20]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp

; 31   : 	distSQ	= Device.vCameraPosition.distance_to_sqr(C)+EPS;

	mov	eax, DWORD PTR __imp_?Device@@3VCRenderDevice@@A
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 500  : 		dest.y = v.x*_12 + v.y*_22 + v.z*_32 + _42;

	mulss	xmm1, DWORD PTR [ecx+4]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 287  : 	{	return (x-v.x)*(x-v.x) + (y-v.y)*(y-v.y) + (z-v.z)*(z-v.z);	}

	movss	xmm3, DWORD PTR [eax+492]
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 500  : 		dest.y = v.x*_12 + v.y*_22 + v.z*_32 + _42;

	addss	xmm1, xmm0
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 287  : 	{	return (x-v.x)*(x-v.x) + (y-v.y)*(y-v.y) + (z-v.z)*(z-v.z);	}

	movss	xmm2, DWORD PTR [eax+488]
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 500  : 		dest.y = v.x*_12 + v.y*_22 + v.z*_32 + _42;

	movaps	xmm0, xmm5
	mulss	xmm0, DWORD PTR [ecx+36]
	addss	xmm0, DWORD PTR [ecx+52]
	addss	xmm1, xmm0
	movaps	xmm0, xmm6
	mulss	xmm0, DWORD PTR [ecx]

; 501  : 		dest.z = v.x*_13 + v.y*_23 + v.z*_33 + _43;

	mulss	xmm6, DWORD PTR [ecx+8]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 287  : 	{	return (x-v.x)*(x-v.x) + (y-v.y)*(y-v.y) + (z-v.z)*(z-v.z);	}

	subss	xmm3, xmm1
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 499  : 		dest.x = v.x*_11 + v.y*_21 + v.z*_31 + _41;

	movaps	xmm1, xmm4
	mulss	xmm1, DWORD PTR [ecx+16]

; 501  : 		dest.z = v.x*_13 + v.y*_23 + v.z*_33 + _43;

	mulss	xmm4, DWORD PTR [ecx+24]
	addss	xmm1, xmm0
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 287  : 	{	return (x-v.x)*(x-v.x) + (y-v.y)*(y-v.y) + (z-v.z)*(z-v.z);	}

	mulss	xmm3, xmm3
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 499  : 		dest.x = v.x*_11 + v.y*_21 + v.z*_31 + _41;

	movaps	xmm0, xmm5

; 501  : 		dest.z = v.x*_13 + v.y*_23 + v.z*_33 + _43;

	mulss	xmm5, DWORD PTR [ecx+40]
	mulss	xmm0, DWORD PTR [ecx+32]
	addss	xmm6, xmm4
	addss	xmm5, DWORD PTR [ecx+56]
	addss	xmm0, DWORD PTR [ecx+48]
	addss	xmm6, xmm5
	addss	xmm1, xmm0
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 287  : 	{	return (x-v.x)*(x-v.x) + (y-v.y)*(y-v.y) + (z-v.z)*(z-v.z);	}

	movss	xmm0, DWORD PTR [eax+496]
	subss	xmm0, xmm6
	subss	xmm2, xmm1
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp

; 317  : 				float		ssa		=	CalcSSA	(D,Tpos,pV->vis.sphere.R/2.f);	// assume dynamics never consume full sphere

	movss	xmm1, DWORD PTR [edx+20]
	mulss	xmm1, xmm7
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 287  : 	{	return (x-v.x)*(x-v.x) + (y-v.y)*(y-v.y) + (z-v.z)*(z-v.z);	}

	mulss	xmm0, xmm0
	mulss	xmm2, xmm2
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp

; 31   : 	distSQ	= Device.vCameraPosition.distance_to_sqr(C)+EPS;

	addss	xmm0, DWORD PTR __real@3727c5ac
	addss	xmm2, xmm3
	addss	xmm2, xmm0

; 318  : 				if (ssa<r_ssaLOD_A)	_use_lod	= TRUE;

	movss	xmm0, DWORD PTR ?r_ssaLOD_A@@3MA

; 32   : 	return	R/distSQ;

	divss	xmm1, xmm2

; 318  : 				if (ssa<r_ssaLOD_A)	_use_lod	= TRUE;

	comiss	xmm0, xmm1
	jbe	SHORT $LN316@add_Static

; 319  : 			}
; 320  : 			if (_use_lod)				
; 321  : 			{
; 322  : 				add_leafs_Dynamic			(pV->m_lod)		;

	push	edi
	mov	ecx, ebx
	call	?add_leafs_Dynamic@CRender@@AAEXPAVIRender_Visual@@@Z ; CRender::add_leafs_Dynamic

; 323  : 			} else {

	mov	eax, DWORD PTR _i_it$1$[esp+64]
	jmp	$LN13@add_Static
$LN316@add_Static:

; 324  : 				pV->CalculateBones			(TRUE);

	mov	eax, DWORD PTR [edx]
	mov	ecx, edx
	push	1
	call	DWORD PTR [eax+64]

; 325  : 				pV->CalculateWallmarks		();		//. bug?

	mov	esi, DWORD PTR _pVisual$1$[esp+64]
	mov	ecx, esi
	call	DWORD PTR __imp_?CalculateWallmarks@CKinematics@@QAEXXZ

; 326  : 				I = pV->children.begin		();
; 327  : 				E = pV->children.end		();

	mov	edi, DWORD PTR [esi+72]

; 328  : 				for (; I!=E; I++)	add_leafs_Dynamic	(*I);

	mov	esi, DWORD PTR [esi+68]
	cmp	esi, edi
	je	$LN810@add_Static
	npad	3
$LL307@add_Static:
	push	DWORD PTR [esi]
	mov	ecx, ebx
	call	?add_leafs_Dynamic@CRender@@AAEXPAVIRender_Visual@@@Z ; CRender::add_leafs_Dynamic
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 74   :         ++_Ptr;

	add	esi, 4
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp

; 328  : 				for (; I!=E; I++)	add_leafs_Dynamic	(*I);

	cmp	esi, edi
	jne	SHORT $LL307@add_Static

; 329  : 			}
; 330  : 		}
; 331  : 		return;

	jmp	$LN810@add_Static
$LN318@add_Static:

; 332  : 	default:
; 333  : 		{
; 334  : 			// General type of visual
; 335  : 			// Calculate distance to it's center
; 336  : 			Fvector							Tpos;
; 337  : 			val_pTransform->transform_tiny	(Tpos, pVisual->vis.sphere.P);

	mov	eax, DWORD PTR [ebx+264]

; 338  : 			r_dsgraph_insert_dynamic		(pVisual,Tpos);

	mov	ecx, ebx
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 499  : 		dest.x = v.x*_11 + v.y*_21 + v.z*_31 + _41;

	movss	xmm2, DWORD PTR [edx+12]
	movss	xmm4, DWORD PTR [edx+8]
	movaps	xmm1, xmm2
	movss	xmm3, DWORD PTR [edx+16]
	movaps	xmm0, xmm4
	mulss	xmm0, DWORD PTR [eax]
	mulss	xmm1, DWORD PTR [eax+16]
	addss	xmm1, xmm0
	movaps	xmm0, xmm3
	mulss	xmm0, DWORD PTR [eax+32]
	addss	xmm0, DWORD PTR [eax+48]
	addss	xmm1, xmm0

; 500  : 		dest.y = v.x*_12 + v.y*_22 + v.z*_32 + _42;

	movaps	xmm0, xmm2
	mulss	xmm0, DWORD PTR [eax+20]

; 501  : 		dest.z = v.x*_13 + v.y*_23 + v.z*_33 + _43;

	mulss	xmm2, DWORD PTR [eax+24]
	movss	DWORD PTR _Tpos$6[esp+64], xmm1
	movaps	xmm1, xmm4
	mulss	xmm1, DWORD PTR [eax+4]
	mulss	xmm4, DWORD PTR [eax+8]
	addss	xmm1, xmm0
	movaps	xmm0, xmm3
	mulss	xmm0, DWORD PTR [eax+36]
	mulss	xmm3, DWORD PTR [eax+40]
	addss	xmm4, xmm2
	addss	xmm0, DWORD PTR [eax+52]
	addss	xmm3, DWORD PTR [eax+56]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp

; 338  : 			r_dsgraph_insert_dynamic		(pVisual,Tpos);

	lea	eax, DWORD PTR _Tpos$6[esp+64]
	push	eax
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 500  : 		dest.y = v.x*_12 + v.y*_22 + v.z*_32 + _42;

	addss	xmm1, xmm0
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp

; 338  : 			r_dsgraph_insert_dynamic		(pVisual,Tpos);

	push	edx
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 501  : 		dest.z = v.x*_13 + v.y*_23 + v.z*_33 + _43;

	addss	xmm4, xmm3
	movss	DWORD PTR _Tpos$6[esp+76], xmm1
	movss	DWORD PTR _Tpos$6[esp+80], xmm4
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp

; 338  : 			r_dsgraph_insert_dynamic		(pVisual,Tpos);

	call	?r_dsgraph_insert_dynamic@R_dsgraph_structure@@QAEXPAVIRender_Visual@@AAU?$_vector3@M@@@Z ; R_dsgraph_structure::r_dsgraph_insert_dynamic
	mov	eax, DWORD PTR _i_it$1$[esp+64]
	jmp	$LN13@add_Static
$LN475@add_Static:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	edi, DWORD PTR [edx+92]

; 150  :         return _Ptr == _Right._Ptr;

	cmp	edi, DWORD PTR [edx+96]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp

; 290  : 			for (PS::CParticleGroup::SItemVecIt i_it=pG->items.begin(); i_it!=pG->items.end(); i_it++)	{

	je	SHORT $LN16@add_Static
	npad	1
$LL461@add_Static:

; 291  : 				PS::CParticleGroup::SItem&			I		= *i_it;
; 292  : 				if (I._effect)		add_leafs_Dynamic		(I._effect);

	mov	eax, DWORD PTR [edi]
	test	eax, eax
	je	SHORT $LN476@add_Static
	push	eax
	mov	ecx, ebx
	call	?add_leafs_Dynamic@CRender@@AAEXPAVIRender_Visual@@@Z ; CRender::add_leafs_Dynamic
$LN476@add_Static:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	esi, DWORD PTR [edi+4]

; 150  :         return _Ptr == _Right._Ptr;

	cmp	esi, DWORD PTR [edi+8]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp

; 293  : 				for (xr_vector<IRender_Visual*>::iterator pit = I._children_related.begin();	pit!=I._children_related.end(); pit++)	add_leafs_Dynamic(*pit);

	je	SHORT $LN800@add_Static
$LL464@add_Static:
	push	DWORD PTR [esi]
	mov	ecx, ebx
	call	?add_leafs_Dynamic@CRender@@AAEXPAVIRender_Visual@@@Z ; CRender::add_leafs_Dynamic
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 74   :         ++_Ptr;

	add	esi, 4

; 150  :         return _Ptr == _Right._Ptr;

	cmp	esi, DWORD PTR [edi+8]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp

; 293  : 				for (xr_vector<IRender_Visual*>::iterator pit = I._children_related.begin();	pit!=I._children_related.end(); pit++)	add_leafs_Dynamic(*pit);

	jne	SHORT $LL464@add_Static
$LN800@add_Static:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	esi, DWORD PTR [edi+16]

; 150  :         return _Ptr == _Right._Ptr;

	cmp	esi, DWORD PTR [edi+20]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp

; 294  : 				for (xr_vector<IRender_Visual*>::iterator pit = I._children_free.begin();		pit!=I._children_free.end();	pit++)	add_leafs_Dynamic(*pit);

	je	SHORT $LN459@add_Static
	npad	1
$LL467@add_Static:
	push	DWORD PTR [esi]
	mov	ecx, ebx
	call	?add_leafs_Dynamic@CRender@@AAEXPAVIRender_Visual@@@Z ; CRender::add_leafs_Dynamic
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 74   :         ++_Ptr;

	add	esi, 4

; 150  :         return _Ptr == _Right._Ptr;

	cmp	esi, DWORD PTR [edi+20]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp

; 294  : 				for (xr_vector<IRender_Visual*>::iterator pit = I._children_free.begin();		pit!=I._children_free.end();	pit++)	add_leafs_Dynamic(*pit);

	jne	SHORT $LL467@add_Static
$LN459@add_Static:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 150  :         return _Ptr == _Right._Ptr;

	mov	eax, DWORD PTR _pVisual$1$[esp+64]

; 74   :         ++_Ptr;

	add	edi, 28					; 0000001cH

; 150  :         return _Ptr == _Right._Ptr;

	cmp	edi, DWORD PTR [eax+96]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp

; 290  : 			for (PS::CParticleGroup::SItemVecIt i_it=pG->items.begin(); i_it!=pG->items.end(); i_it++)	{

	jne	SHORT $LL461@add_Static
$LN812@add_Static:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 74   :         ++_Ptr;

	mov	eax, DWORD PTR _i_it$1$[esp+64]
$LN813@add_Static:
	mov	esi, DWORD PTR _pit$1$[esp+64]
$LN16@add_Static:
	add	esi, 4
	mov	DWORD PTR _pit$1$[esp+64], esi

; 150  :         return _Ptr == _Right._Ptr;

	cmp	esi, DWORD PTR [eax+20]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp

; 545  : 					for (xr_vector<IRender_Visual*>::iterator pit = I._children_free.begin();		pit!=I._children_free.end();	pit++)	add_leafs_Dynamic(*pit);

	jne	$LL18@add_Static
$LN4@add_Static:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 74   :         ++_Ptr;

	mov	esi, DWORD PTR _i_it$1$[esp+64]

; 150  :         return _Ptr == _Right._Ptr;

	mov	eax, DWORD PTR _pVisual$[ebp]

; 74   :         ++_Ptr;

	add	esi, 28					; 0000001cH
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp

; 536  : 			for (PS::CParticleGroup::SItemVecIt i_it=pG->items.begin(); i_it!=pG->items.end(); i_it++){

	movss	xmm7, DWORD PTR __real@3f000000
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 74   :         ++_Ptr;

	mov	DWORD PTR _i_it$1$[esp+64], esi

; 150  :         return _Ptr == _Right._Ptr;

	cmp	esi, DWORD PTR [eax+96]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp

; 536  : 			for (PS::CParticleGroup::SItemVecIt i_it=pG->items.begin(); i_it!=pG->items.end(); i_it++){

	jne	$LL6@add_Static

; 611  : 		}
; 612  : 		break;
; 613  : 	}
; 614  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
$LN477@add_Static:

; 303  : 			E = pV->children.end	();

	mov	edi, DWORD PTR [edx+72]

; 304  : 			for (; I!=E; I++)	add_leafs_Dynamic	(*I);

	mov	esi, DWORD PTR [edx+68]
	cmp	esi, edi
	je	SHORT $LN813@add_Static
$LL470@add_Static:
	push	DWORD PTR [esi]
	mov	ecx, ebx
	call	?add_leafs_Dynamic@CRender@@AAEXPAVIRender_Visual@@@Z ; CRender::add_leafs_Dynamic
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 74   :         ++_Ptr;

	add	esi, 4
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp

; 304  : 			for (; I!=E; I++)	add_leafs_Dynamic	(*I);

	cmp	esi, edi
	jne	SHORT $LL470@add_Static

; 305  : 		}
; 306  : 		return;

	jmp	SHORT $LN812@add_Static
$LN478@add_Static:

; 307  : 	case MT_SKELETON_ANIM:
; 308  : 	case MT_SKELETON_RIGID:
; 309  : 		{
; 310  : 			// Add all children, doesn't perform any tests
; 311  : 			CKinematics * pV			= (CKinematics*)pVisual;
; 312  : 			BOOL	_use_lod			= FALSE	;
; 313  : 			if (pV->m_lod)				

	mov	edi, DWORD PTR [edx+84]
	test	edi, edi
	je	$LN482@add_Static

; 314  : 			{
; 315  : 				Fvector							Tpos;	float		D;
; 316  : 				val_pTransform->transform_tiny	(Tpos, pV->vis.sphere.P);

	mov	ecx, DWORD PTR [ebx+264]
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 499  : 		dest.x = v.x*_11 + v.y*_21 + v.z*_31 + _41;

	movss	xmm4, DWORD PTR [edx+12]
	movss	xmm6, DWORD PTR [edx+8]

; 500  : 		dest.y = v.x*_12 + v.y*_22 + v.z*_32 + _42;

	movaps	xmm0, xmm4
	movss	xmm5, DWORD PTR [edx+16]
	movaps	xmm1, xmm6
	mulss	xmm0, DWORD PTR [ecx+20]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp

; 31   : 	distSQ	= Device.vCameraPosition.distance_to_sqr(C)+EPS;

	mov	eax, DWORD PTR __imp_?Device@@3VCRenderDevice@@A
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 500  : 		dest.y = v.x*_12 + v.y*_22 + v.z*_32 + _42;

	mulss	xmm1, DWORD PTR [ecx+4]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 287  : 	{	return (x-v.x)*(x-v.x) + (y-v.y)*(y-v.y) + (z-v.z)*(z-v.z);	}

	movss	xmm3, DWORD PTR [eax+492]
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 500  : 		dest.y = v.x*_12 + v.y*_22 + v.z*_32 + _42;

	addss	xmm1, xmm0
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 287  : 	{	return (x-v.x)*(x-v.x) + (y-v.y)*(y-v.y) + (z-v.z)*(z-v.z);	}

	movss	xmm2, DWORD PTR [eax+488]
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 500  : 		dest.y = v.x*_12 + v.y*_22 + v.z*_32 + _42;

	movaps	xmm0, xmm5
	mulss	xmm0, DWORD PTR [ecx+36]
	addss	xmm0, DWORD PTR [ecx+52]
	addss	xmm1, xmm0
	movaps	xmm0, xmm6
	mulss	xmm0, DWORD PTR [ecx]

; 501  : 		dest.z = v.x*_13 + v.y*_23 + v.z*_33 + _43;

	mulss	xmm6, DWORD PTR [ecx+8]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 287  : 	{	return (x-v.x)*(x-v.x) + (y-v.y)*(y-v.y) + (z-v.z)*(z-v.z);	}

	subss	xmm3, xmm1
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 499  : 		dest.x = v.x*_11 + v.y*_21 + v.z*_31 + _41;

	movaps	xmm1, xmm4
	mulss	xmm1, DWORD PTR [ecx+16]

; 501  : 		dest.z = v.x*_13 + v.y*_23 + v.z*_33 + _43;

	mulss	xmm4, DWORD PTR [ecx+24]
	addss	xmm1, xmm0
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 287  : 	{	return (x-v.x)*(x-v.x) + (y-v.y)*(y-v.y) + (z-v.z)*(z-v.z);	}

	mulss	xmm3, xmm3
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 499  : 		dest.x = v.x*_11 + v.y*_21 + v.z*_31 + _41;

	movaps	xmm0, xmm5

; 501  : 		dest.z = v.x*_13 + v.y*_23 + v.z*_33 + _43;

	mulss	xmm5, DWORD PTR [ecx+40]
	mulss	xmm0, DWORD PTR [ecx+32]
	addss	xmm6, xmm4
	addss	xmm5, DWORD PTR [ecx+56]
	addss	xmm0, DWORD PTR [ecx+48]
	addss	xmm6, xmm5
	addss	xmm1, xmm0
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 287  : 	{	return (x-v.x)*(x-v.x) + (y-v.y)*(y-v.y) + (z-v.z)*(z-v.z);	}

	movss	xmm0, DWORD PTR [eax+496]
	subss	xmm0, xmm6
	subss	xmm2, xmm1
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp

; 317  : 				float		ssa		=	CalcSSA	(D,Tpos,pV->vis.sphere.R/2.f);	// assume dynamics never consume full sphere

	movss	xmm1, DWORD PTR [edx+20]
	mulss	xmm1, DWORD PTR __real@3f000000
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 287  : 	{	return (x-v.x)*(x-v.x) + (y-v.y)*(y-v.y) + (z-v.z)*(z-v.z);	}

	mulss	xmm0, xmm0
	mulss	xmm2, xmm2
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp

; 31   : 	distSQ	= Device.vCameraPosition.distance_to_sqr(C)+EPS;

	addss	xmm0, DWORD PTR __real@3727c5ac
	addss	xmm2, xmm3
	addss	xmm2, xmm0

; 318  : 				if (ssa<r_ssaLOD_A)	_use_lod	= TRUE;

	movss	xmm0, DWORD PTR ?r_ssaLOD_A@@3MA

; 32   : 	return	R/distSQ;

	divss	xmm1, xmm2

; 318  : 				if (ssa<r_ssaLOD_A)	_use_lod	= TRUE;

	comiss	xmm0, xmm1
	jbe	SHORT $LN482@add_Static

; 319  : 			}
; 320  : 			if (_use_lod)				
; 321  : 			{
; 322  : 				add_leafs_Dynamic			(pV->m_lod)		;

	push	edi
	mov	ecx, ebx
	call	?add_leafs_Dynamic@CRender@@AAEXPAVIRender_Visual@@@Z ; CRender::add_leafs_Dynamic

; 323  : 			} else {

	mov	eax, DWORD PTR _i_it$1$[esp+64]
	jmp	$LN16@add_Static
$LN482@add_Static:

; 324  : 				pV->CalculateBones			(TRUE);

	mov	eax, DWORD PTR [edx]
	mov	ecx, edx
	push	1
	call	DWORD PTR [eax+64]

; 325  : 				pV->CalculateWallmarks		();		//. bug?

	mov	esi, DWORD PTR _pVisual$1$[esp+64]
	mov	ecx, esi
	call	DWORD PTR __imp_?CalculateWallmarks@CKinematics@@QAEXXZ

; 326  : 				I = pV->children.begin		();
; 327  : 				E = pV->children.end		();

	mov	edi, DWORD PTR [esi+72]

; 328  : 				for (; I!=E; I++)	add_leafs_Dynamic	(*I);

	mov	esi, DWORD PTR [esi+68]
	cmp	esi, edi
	je	$LN812@add_Static
$LL473@add_Static:
	push	DWORD PTR [esi]
	mov	ecx, ebx
	call	?add_leafs_Dynamic@CRender@@AAEXPAVIRender_Visual@@@Z ; CRender::add_leafs_Dynamic
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 74   :         ++_Ptr;

	add	esi, 4
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp

; 328  : 				for (; I!=E; I++)	add_leafs_Dynamic	(*I);

	cmp	esi, edi
	jne	SHORT $LL473@add_Static

; 329  : 			}
; 330  : 		}
; 331  : 		return;

	jmp	$LN812@add_Static
$LN484@add_Static:

; 332  : 	default:
; 333  : 		{
; 334  : 			// General type of visual
; 335  : 			// Calculate distance to it's center
; 336  : 			Fvector							Tpos;
; 337  : 			val_pTransform->transform_tiny	(Tpos, pVisual->vis.sphere.P);

	mov	eax, DWORD PTR [ebx+264]

; 338  : 			r_dsgraph_insert_dynamic		(pVisual,Tpos);

	mov	ecx, ebx
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 499  : 		dest.x = v.x*_11 + v.y*_21 + v.z*_31 + _41;

	movss	xmm2, DWORD PTR [edx+12]
	movss	xmm4, DWORD PTR [edx+8]
	movaps	xmm1, xmm2
	movss	xmm3, DWORD PTR [edx+16]
	movaps	xmm0, xmm4
	mulss	xmm0, DWORD PTR [eax]
	mulss	xmm1, DWORD PTR [eax+16]
	addss	xmm1, xmm0
	movaps	xmm0, xmm3
	mulss	xmm0, DWORD PTR [eax+32]
	addss	xmm0, DWORD PTR [eax+48]
	addss	xmm1, xmm0

; 500  : 		dest.y = v.x*_12 + v.y*_22 + v.z*_32 + _42;

	movaps	xmm0, xmm2
	mulss	xmm0, DWORD PTR [eax+20]

; 501  : 		dest.z = v.x*_13 + v.y*_23 + v.z*_33 + _43;

	mulss	xmm2, DWORD PTR [eax+24]
	movss	DWORD PTR _Tpos$7[esp+64], xmm1
	movaps	xmm1, xmm4
	mulss	xmm1, DWORD PTR [eax+4]
	mulss	xmm4, DWORD PTR [eax+8]
	addss	xmm1, xmm0
	movaps	xmm0, xmm3
	mulss	xmm0, DWORD PTR [eax+36]
	mulss	xmm3, DWORD PTR [eax+40]
	addss	xmm4, xmm2
	addss	xmm0, DWORD PTR [eax+52]
	addss	xmm3, DWORD PTR [eax+56]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp

; 338  : 			r_dsgraph_insert_dynamic		(pVisual,Tpos);

	lea	eax, DWORD PTR _Tpos$7[esp+64]
	push	eax
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 500  : 		dest.y = v.x*_12 + v.y*_22 + v.z*_32 + _42;

	addss	xmm1, xmm0
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp

; 338  : 			r_dsgraph_insert_dynamic		(pVisual,Tpos);

	push	edx
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 501  : 		dest.z = v.x*_13 + v.y*_23 + v.z*_33 + _43;

	addss	xmm4, xmm3
	movss	DWORD PTR _Tpos$7[esp+76], xmm1
	movss	DWORD PTR _Tpos$7[esp+80], xmm4
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp

; 338  : 			r_dsgraph_insert_dynamic		(pVisual,Tpos);

	call	?r_dsgraph_insert_dynamic@R_dsgraph_structure@@QAEXPAVIRender_Visual@@AAU?$_vector3@M@@@Z ; R_dsgraph_structure::r_dsgraph_insert_dynamic
	mov	eax, DWORD PTR _i_it$1$[esp+64]
	jmp	$LN16@add_Static
$LN41@add_Static:

; 556  : 			if (fcvPartial==VIS) {

	cmp	DWORD PTR _VIS$1$[esp+64], 1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1463 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));

	mov	esi, DWORD PTR [edi+68]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp

; 555  : 			E = pV->children.end		();

	mov	edi, DWORD PTR [edi+72]

; 556  : 			if (fcvPartial==VIS) {

	jne	SHORT $LN42@add_Static

; 557  : 				for (; I!=E; I++)	add_Static			(*I,planes);

	cmp	esi, edi
	je	$LN2@add_Static
$LL21@add_Static:
	push	DWORD PTR _planes$[ebp]
	mov	ecx, ebx
	push	DWORD PTR [esi]
	call	?add_Static@CRender@@AAEXPAVIRender_Visual@@I@Z ; CRender::add_Static
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 74   :         ++_Ptr;

	add	esi, 4
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp

; 557  : 				for (; I!=E; I++)	add_Static			(*I,planes);

	cmp	esi, edi
	jne	SHORT $LL21@add_Static

; 611  : 		}
; 612  : 		break;
; 613  : 	}
; 614  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
$LN42@add_Static:

; 559  : 				for (; I!=E; I++)	add_leafs_Static	(*I);

	cmp	esi, edi
	je	$LN2@add_Static
$LL24@add_Static:
	push	DWORD PTR [esi]
	mov	ecx, ebx
	call	?add_leafs_Static@CRender@@AAEXPAVIRender_Visual@@@Z ; CRender::add_leafs_Static
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 74   :         ++_Ptr;

	add	esi, 4
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp

; 559  : 				for (; I!=E; I++)	add_leafs_Static	(*I);

	cmp	esi, edi
	jne	SHORT $LL24@add_Static

; 611  : 		}
; 612  : 		break;
; 613  : 	}
; 614  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
$LN44@add_Static:

; 560  : 			}
; 561  : 		}
; 562  : 		break;
; 563  : 	case MT_SKELETON_ANIM:
; 564  : 	case MT_SKELETON_RIGID:
; 565  : 		{
; 566  : 			// Add all children, doesn't perform any tests
; 567  : 			CKinematics * pV		= (CKinematics*)pVisual;
; 568  : 			pV->CalculateBones		(TRUE);

	mov	eax, DWORD PTR [edi]
	mov	ecx, edi
	push	1
	call	DWORD PTR [eax+64]

; 571  : 			if (fcvPartial==VIS) {

	cmp	DWORD PTR _VIS$1$[esp+64], 1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1463 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));

	mov	esi, DWORD PTR [edi+68]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp

; 570  : 			E = pV->children.end	();

	mov	edi, DWORD PTR [edi+72]

; 571  : 			if (fcvPartial==VIS) {

	jne	SHORT $LN46@add_Static

; 572  : 				for (; I!=E; I++)	add_Static			(*I,planes);

	cmp	esi, edi
	je	$LN2@add_Static
	npad	4
$LL27@add_Static:
	push	DWORD PTR _planes$[ebp]
	mov	ecx, ebx
	push	DWORD PTR [esi]
	call	?add_Static@CRender@@AAEXPAVIRender_Visual@@I@Z ; CRender::add_Static
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 74   :         ++_Ptr;

	add	esi, 4
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp

; 572  : 				for (; I!=E; I++)	add_Static			(*I,planes);

	cmp	esi, edi
	jne	SHORT $LL27@add_Static

; 611  : 		}
; 612  : 		break;
; 613  : 	}
; 614  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
$LN46@add_Static:

; 574  : 				for (; I!=E; I++)	add_leafs_Static	(*I);

	cmp	esi, edi
	je	$LN2@add_Static
$LL30@add_Static:
	push	DWORD PTR [esi]
	mov	ecx, ebx
	call	?add_leafs_Static@CRender@@AAEXPAVIRender_Visual@@@Z ; CRender::add_leafs_Static
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 74   :         ++_Ptr;

	add	esi, 4
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp

; 574  : 				for (; I!=E; I++)	add_leafs_Static	(*I);

	cmp	esi, edi
	jne	SHORT $LL30@add_Static

; 611  : 		}
; 612  : 		break;
; 613  : 	}
; 614  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
$LN48@add_Static:

; 26   : 	distSQ	= Device.vCameraPosition.distance_to_sqr(C)+EPS;

	mov	eax, DWORD PTR __imp_?Device@@3VCRenderDevice@@A
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 287  : 	{	return (x-v.x)*(x-v.x) + (y-v.y)*(y-v.y) + (z-v.z)*(z-v.z);	}

	movss	xmm1, DWORD PTR [eax+492]
	subss	xmm1, DWORD PTR [esi+4]
	movss	xmm0, DWORD PTR [eax+496]
	movss	xmm2, DWORD PTR [eax+488]
	subss	xmm2, DWORD PTR [esi]
	subss	xmm0, DWORD PTR [esi+8]
	mulss	xmm1, xmm1
	mulss	xmm2, xmm2
	mulss	xmm0, xmm0
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp

; 26   : 	distSQ	= Device.vCameraPosition.distance_to_sqr(C)+EPS;

	addss	xmm2, xmm1

; 27   : 	return	R/distSQ;

	movss	xmm1, DWORD PTR [edi+20]
	addss	xmm0, DWORD PTR __real@3727c5ac
	addss	xmm2, xmm0

; 584  : 			if (ssa<r_ssaLOD_A)	

	movss	xmm0, DWORD PTR ?r_ssaLOD_A@@3MA

; 27   : 	return	R/distSQ;

	divss	xmm1, xmm2
	movss	DWORD PTR _D$4[esp+64], xmm2

; 575  : 			}
; 576  : 		}
; 577  : 		break;
; 578  : 	case MT_LOD:
; 579  : 		{
; 580  : 			FLOD		* pV	= (FLOD*) pVisual;
; 581  : 			float		D;
; 582  : 			float		ssa		= CalcSSA	(D,pV->vis.sphere.P,pV);
; 583  : 			ssa					*= pV->lod_factor;

	mulss	xmm1, DWORD PTR [edi+1080]

; 584  : 			if (ssa<r_ssaLOD_A)	

	comiss	xmm0, xmm1
	movss	DWORD PTR _ssa$1$[esp+64], xmm1
	jbe	SHORT $LN49@add_Static

; 585  : 			{
; 586  : 				if (ssa<r_ssaDISCARD)	return;

	movss	xmm0, DWORD PTR ?r_ssaDISCARD@@3MA
	comiss	xmm0, xmm1
	ja	SHORT $LN2@add_Static

; 587  : 				mapLOD_Node*	N		= mapLOD.insertInAnyWay(D);

	lea	eax, DWORD PTR _D$4[esp+64]
	push	eax
	lea	ecx, DWORD PTR [ebx+376]
	call	?insertInAnyWay@?$FixedMAP@MU_LodItem@R_dsgraph@@Udoug_lea_allocator@@@@QAEPAUTNode@1@ABM@Z ; FixedMAP<float,R_dsgraph::_LodItem,doug_lea_allocator>::insertInAnyWay

; 588  : 				N->val.ssa				= ssa;

	movss	xmm1, DWORD PTR _ssa$1$[esp+64]
	movss	DWORD PTR [eax+4], xmm1

; 589  : 				N->val.pVisual			= pVisual;

	mov	DWORD PTR [eax+8], edi
$LN49@add_Static:

; 590  : 			}
; 591  : 			if (ssa>r_ssaLOD_B)

	comiss	xmm1, DWORD PTR ?r_ssaLOD_B@@3MA
	jbe	SHORT $LN2@add_Static

; 596  : 				for (; I!=E; I++)	add_leafs_Static	(*I);

	mov	eax, DWORD PTR _pVisual$[ebp]
	mov	edi, DWORD PTR [edi+72]
	mov	esi, DWORD PTR [eax+68]
	cmp	esi, edi
	je	SHORT $LN2@add_Static
	npad	1
$LL33@add_Static:
	push	DWORD PTR [esi]
	mov	ecx, ebx
	call	?add_leafs_Static@CRender@@AAEXPAVIRender_Visual@@@Z ; CRender::add_leafs_Static
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 74   :         ++_Ptr;

	add	esi, 4
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp

; 596  : 				for (; I!=E; I++)	add_leafs_Static	(*I);

	cmp	esi, edi
	jne	SHORT $LL33@add_Static

; 611  : 		}
; 612  : 		break;
; 613  : 	}
; 614  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
$LN54@add_Static:

; 597  : 			}
; 598  : 		}
; 599  : 		break;
; 600  : 	case MT_TREE_ST:
; 601  : 	case MT_TREE_PM:
; 602  : 		{
; 603  : 			// General type of visual
; 604  : 			r_dsgraph_insert_static		(pVisual);
; 605  : 		}
; 606  : 		return;
; 607  : 	default:
; 608  : 		{
; 609  : 			// General type of visual
; 610  : 			r_dsgraph_insert_static		(pVisual);

	push	edi
	mov	ecx, ebx
	call	?r_dsgraph_insert_static@R_dsgraph_structure@@QAEXPAVIRender_Visual@@@Z ; R_dsgraph_structure::r_dsgraph_insert_static
$LN2@add_Static:

; 611  : 		}
; 612  : 		break;
; 613  : 	}
; 614  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
	npad	2
$LN803@add_Static:
	DD	$LN41@add_Static
	DD	$LN44@add_Static
	DD	$LN48@add_Static
	DD	$LN54@add_Static
	DD	$LN36@add_Static
	DD	$LN54@add_Static
$LN802@add_Static:
	DB	0
	DB	5
	DB	1
	DB	5
	DB	5
	DB	2
	DB	3
	DB	5
	DB	4
	DB	1
	DB	3
	npad	1
$LN805@add_Static:
	DD	$LN145@add_Static
	DD	$LN146@add_Static
	DD	$LN143@add_Static
	DD	$LN152@add_Static
$LN804@add_Static:
	DB	0
	DB	3
	DB	1
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	2
	DB	1
	npad	2
$LN807@add_Static:
	DD	$LN311@add_Static
	DD	$LN312@add_Static
	DD	$LN309@add_Static
	DD	$LN318@add_Static
$LN806@add_Static:
	DB	0
	DB	3
	DB	1
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	2
	DB	1
	npad	2
$LN809@add_Static:
	DD	$LN477@add_Static
	DD	$LN478@add_Static
	DD	$LN475@add_Static
	DD	$LN484@add_Static
$LN808@add_Static:
	DB	0
	DB	3
	DB	1
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	2
	DB	1
?add_Static@CRender@@AAEXPAVIRender_Visual@@I@Z ENDP	; CRender::add_Static
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
;	COMDAT ?insertInAnyWay@?$FixedMAP@MU_LodItem@R_dsgraph@@Udoug_lea_allocator@@@@QAEPAUTNode@1@ABM@Z
_TEXT	SEGMENT
_k$ = 8							; size = 4
?insertInAnyWay@?$FixedMAP@MU_LodItem@R_dsgraph@@Udoug_lea_allocator@@@@QAEPAUTNode@1@ABM@Z PROC ; FixedMAP<float,R_dsgraph::_LodItem,doug_lea_allocator>::insertInAnyWay, COMDAT
; _this$ = ecx

; 157  : 	IC TNode*	insertInAnyWay(const K& k) {

	push	edi
	mov	edi, ecx

; 158  : 		if (pool) {

	cmp	DWORD PTR [edi+4], 0
	je	SHORT $LN2@insertInAn

; 159  : 			TNode*	node = nodes;
; 160  : 
; 161  : 			once_more:
; 162  : 			if (k <= node->key) {

	mov	ecx, DWORD PTR _k$[esp]
	push	ebx
	mov	ebx, DWORD PTR [edi]
	push	esi
	movss	xmm1, DWORD PTR [ecx]
	mov	esi, ebx
$once_more$22:
	movss	xmm0, DWORD PTR [esi]
	comiss	xmm0, xmm1
	jb	SHORT $LN4@insertInAn

; 163  : 				if (node->left) {

	mov	eax, DWORD PTR [esi+12]
	test	eax, eax
	je	SHORT $LN6@insertInAn

; 164  : 					node = node->left;

	mov	esi, eax

; 165  : 					goto once_more;

	jmp	SHORT $once_more$22
$LN4@insertInAn:

; 169  : 					return N;
; 170  : 				}
; 171  : 			} else {
; 172  : 				if (node->right) {

	mov	eax, DWORD PTR [esi+16]
	test	eax, eax
	je	SHORT $LN8@insertInAn

; 173  : 					node = node->right;

	mov	esi, eax

; 174  : 					goto once_more;

	jmp	SHORT $once_more$22
$LN6@insertInAn:

; 70   : 		TNode*	N	= Alloc	(key);

	push	ecx
	mov	ecx, edi
	call	?Alloc@?$FixedMAP@MU_LodItem@R_dsgraph@@Udoug_lea_allocator@@@@AAEPAUTNode@1@ABM@Z ; FixedMAP<float,R_dsgraph::_LodItem,doug_lea_allocator>::Alloc
	sub	esi, ebx
	sar	esi, 2
	imul	ecx, esi, -858993459
	pop	esi
	pop	ebx

; 71   : 		parent		= nodes+PID;

	lea	edx, DWORD PTR [ecx+ecx*4]

; 166  : 				} else {
; 167  : 					TNode* N = CreateChild(node,k);
; 168  : 					node->left = N;

	mov	ecx, DWORD PTR [edi]
	pop	edi
	mov	DWORD PTR [ecx+edx*4+12], eax

; 183  : 		}
; 184  : 	}

	ret	4
$LN8@insertInAn:

; 70   : 		TNode*	N	= Alloc	(key);

	push	ecx
	mov	ecx, edi
	call	?Alloc@?$FixedMAP@MU_LodItem@R_dsgraph@@Udoug_lea_allocator@@@@AAEPAUTNode@1@ABM@Z ; FixedMAP<float,R_dsgraph::_LodItem,doug_lea_allocator>::Alloc
	sub	esi, ebx
	sar	esi, 2
	imul	ecx, esi, -858993459
	pop	esi
	pop	ebx

; 71   : 		parent		= nodes+PID;

	lea	edx, DWORD PTR [ecx+ecx*4]

; 175  : 				} else {
; 176  : 					TNode* N = CreateChild(node,k);
; 177  : 					node->right = N;

	mov	ecx, DWORD PTR [edi]
	pop	edi
	mov	DWORD PTR [ecx+edx*4+16], eax

; 183  : 		}
; 184  : 	}

	ret	4
$LN2@insertInAn:

; 178  : 					return N;
; 179  : 				}
; 180  : 			}
; 181  : 		} else {
; 182  : 			return Alloc(k);

	push	DWORD PTR _k$[esp]
	call	?Alloc@?$FixedMAP@MU_LodItem@R_dsgraph@@Udoug_lea_allocator@@@@AAEPAUTNode@1@ABM@Z ; FixedMAP<float,R_dsgraph::_LodItem,doug_lea_allocator>::Alloc
	pop	edi

; 183  : 		}
; 184  : 	}

	ret	4
?insertInAnyWay@?$FixedMAP@MU_LodItem@R_dsgraph@@Udoug_lea_allocator@@@@QAEPAUTNode@1@ABM@Z ENDP ; FixedMAP<float,R_dsgraph::_LodItem,doug_lea_allocator>::insertInAnyWay
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
;	COMDAT ?insertInAnyWay@?$FixedMAP@MU_MatrixItemS@R_dsgraph@@Udoug_lea_allocator@@@@QAEPAUTNode@1@ABM@Z
_TEXT	SEGMENT
_k$ = 8							; size = 4
?insertInAnyWay@?$FixedMAP@MU_MatrixItemS@R_dsgraph@@Udoug_lea_allocator@@@@QAEPAUTNode@1@ABM@Z PROC ; FixedMAP<float,R_dsgraph::_MatrixItemS,doug_lea_allocator>::insertInAnyWay, COMDAT
; _this$ = ecx

; 157  : 	IC TNode*	insertInAnyWay(const K& k) {

	push	edi
	mov	edi, ecx

; 158  : 		if (pool) {

	cmp	DWORD PTR [edi+4], 0
	je	SHORT $LN2@insertInAn

; 159  : 			TNode*	node = nodes;
; 160  : 
; 161  : 			once_more:
; 162  : 			if (k <= node->key) {

	mov	ecx, DWORD PTR _k$[esp]
	push	ebx
	mov	ebx, DWORD PTR [edi]
	push	esi
	movss	xmm1, DWORD PTR [ecx]
	mov	esi, ebx
$once_more$22:
	movss	xmm0, DWORD PTR [esi]
	comiss	xmm0, xmm1
	jb	SHORT $LN4@insertInAn

; 163  : 				if (node->left) {

	mov	eax, DWORD PTR [esi+84]
	test	eax, eax
	je	SHORT $LN6@insertInAn

; 164  : 					node = node->left;

	mov	esi, eax

; 165  : 					goto once_more;

	jmp	SHORT $once_more$22
$LN4@insertInAn:

; 169  : 					return N;
; 170  : 				}
; 171  : 			} else {
; 172  : 				if (node->right) {

	mov	eax, DWORD PTR [esi+88]
	test	eax, eax
	je	SHORT $LN8@insertInAn

; 173  : 					node = node->right;

	mov	esi, eax

; 174  : 					goto once_more;

	jmp	SHORT $once_more$22
$LN6@insertInAn:

; 70   : 		TNode*	N	= Alloc	(key);

	push	ecx
	mov	ecx, edi
	call	?Alloc@?$FixedMAP@MU_MatrixItemS@R_dsgraph@@Udoug_lea_allocator@@@@AAEPAUTNode@1@ABM@Z ; FixedMAP<float,R_dsgraph::_MatrixItemS,doug_lea_allocator>::Alloc
	sub	esi, ebx
	sar	esi, 2
	imul	ecx, esi, -373475417
	pop	esi
	pop	ebx

; 71   : 		parent		= nodes+PID;

	imul	edx, ecx, 92

; 166  : 				} else {
; 167  : 					TNode* N = CreateChild(node,k);
; 168  : 					node->left = N;

	mov	ecx, DWORD PTR [edi]
	pop	edi
	mov	DWORD PTR [edx+ecx+84], eax

; 183  : 		}
; 184  : 	}

	ret	4
$LN8@insertInAn:

; 70   : 		TNode*	N	= Alloc	(key);

	push	ecx
	mov	ecx, edi
	call	?Alloc@?$FixedMAP@MU_MatrixItemS@R_dsgraph@@Udoug_lea_allocator@@@@AAEPAUTNode@1@ABM@Z ; FixedMAP<float,R_dsgraph::_MatrixItemS,doug_lea_allocator>::Alloc
	sub	esi, ebx
	sar	esi, 2
	imul	ecx, esi, -373475417
	pop	esi
	pop	ebx

; 71   : 		parent		= nodes+PID;

	imul	edx, ecx, 92

; 175  : 				} else {
; 176  : 					TNode* N = CreateChild(node,k);
; 177  : 					node->right = N;

	mov	ecx, DWORD PTR [edi]
	pop	edi
	mov	DWORD PTR [edx+ecx+88], eax

; 183  : 		}
; 184  : 	}

	ret	4
$LN2@insertInAn:

; 178  : 					return N;
; 179  : 				}
; 180  : 			}
; 181  : 		} else {
; 182  : 			return Alloc(k);

	push	DWORD PTR _k$[esp]
	call	?Alloc@?$FixedMAP@MU_MatrixItemS@R_dsgraph@@Udoug_lea_allocator@@@@AAEPAUTNode@1@ABM@Z ; FixedMAP<float,R_dsgraph::_MatrixItemS,doug_lea_allocator>::Alloc
	pop	edi

; 183  : 		}
; 184  : 	}

	ret	4
?insertInAnyWay@?$FixedMAP@MU_MatrixItemS@R_dsgraph@@Udoug_lea_allocator@@@@QAEPAUTNode@1@ABM@Z ENDP ; FixedMAP<float,R_dsgraph::_MatrixItemS,doug_lea_allocator>::insertInAnyWay
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
;	COMDAT ?insert@?$FixedMAP@PAUIDirect3DVertexShader9@@UmapMatrixPS@R_dsgraph@@Udoug_lea_allocator@@@@QAEPAUTNode@1@ABQAUIDirect3DVertexShader9@@@Z
_TEXT	SEGMENT
_k$ = 8							; size = 4
?insert@?$FixedMAP@PAUIDirect3DVertexShader9@@UmapMatrixPS@R_dsgraph@@Udoug_lea_allocator@@@@QAEPAUTNode@1@ABQAUIDirect3DVertexShader9@@@Z PROC ; FixedMAP<IDirect3DVertexShader9 *,R_dsgraph::mapMatrixPS,doug_lea_allocator>::insert, COMDAT
; _this$ = ecx

; 128  : 	IC TNode*	insert(const K& k) {

	push	edi
	mov	edi, ecx

; 129  : 		if (pool) {

	cmp	DWORD PTR [edi+4], 0
	je	$LN2@insert

; 130  : 			TNode*	node = nodes;
; 131  : 
; 132  : 			once_more:
; 133  : 			if (k < node->key) {

	mov	ecx, DWORD PTR _k$[esp]
	push	ebx
	mov	ebx, DWORD PTR [edi]
	push	esi
	mov	edx, DWORD PTR [ecx]
	mov	esi, ebx
	npad	7
$once_more$25:
	cmp	edx, DWORD PTR [esi]
	jae	SHORT $LN4@insert

; 134  : 				if (node->left) {

	mov	eax, DWORD PTR [esi+20]
	test	eax, eax
	je	SHORT $LN6@insert

; 135  : 					node = node->left;

	mov	esi, eax

; 136  : 					goto once_more;

	jmp	SHORT $once_more$25
$LN4@insert:

; 141  : 				}
; 142  : 			} else if (k > node->key) {

	jbe	SHORT $LN8@insert

; 143  : 				if (node->right) {

	mov	eax, DWORD PTR [esi+24]
	test	eax, eax
	je	SHORT $LN10@insert

; 144  : 					node = node->right;

	mov	esi, eax

; 145  : 					goto once_more;

	jmp	SHORT $once_more$25
$LN6@insert:

; 70   : 		TNode*	N	= Alloc	(key);

	push	ecx
	mov	ecx, edi
	call	?Alloc@?$FixedMAP@PAUIDirect3DVertexShader9@@UmapMatrixPS@R_dsgraph@@Udoug_lea_allocator@@@@AAEPAUTNode@1@ABQAUIDirect3DVertexShader9@@@Z ; FixedMAP<IDirect3DVertexShader9 *,R_dsgraph::mapMatrixPS,doug_lea_allocator>::Alloc
	sub	esi, ebx

; 137  : 				} else {
; 138  : 					TNode* N = CreateChild(node,k);

	mov	edx, eax

; 69   : 		size_t	PID	= size_t(parent-nodes);

	sar	esi, 2
	imul	eax, esi, -1227133513
	pop	esi
	pop	ebx

; 71   : 		parent		= nodes+PID;

	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax

; 139  : 					node->left = N;

	mov	eax, DWORD PTR [edi]
	pop	edi
	mov	DWORD PTR [eax+ecx*4+20], edx

; 140  : 					return N;

	mov	eax, edx

; 155  : 		}
; 156  : 	}

	ret	4
$LN10@insert:

; 70   : 		TNode*	N	= Alloc	(key);

	push	ecx
	mov	ecx, edi
	call	?Alloc@?$FixedMAP@PAUIDirect3DVertexShader9@@UmapMatrixPS@R_dsgraph@@Udoug_lea_allocator@@@@AAEPAUTNode@1@ABQAUIDirect3DVertexShader9@@@Z ; FixedMAP<IDirect3DVertexShader9 *,R_dsgraph::mapMatrixPS,doug_lea_allocator>::Alloc
	sub	esi, ebx

; 146  : 				} else {
; 147  : 					TNode* N = CreateChild(node,k);

	mov	edx, eax

; 69   : 		size_t	PID	= size_t(parent-nodes);

	sar	esi, 2
	imul	eax, esi, -1227133513
	pop	esi
	pop	ebx

; 71   : 		parent		= nodes+PID;

	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax

; 148  : 					node->right = N;

	mov	eax, DWORD PTR [edi]
	pop	edi
	mov	DWORD PTR [eax+ecx*4+24], edx
	mov	eax, edx

; 155  : 		}
; 156  : 	}

	ret	4
$LN8@insert:

; 149  : 					return N;
; 150  : 				}
; 151  : 			} else return node;

	mov	eax, esi
	pop	esi
	pop	ebx
	pop	edi

; 155  : 		}
; 156  : 	}

	ret	4
$LN2@insert:

; 152  : 			
; 153  : 		} else {
; 154  : 			return Alloc(k);

	push	DWORD PTR _k$[esp]
	call	?Alloc@?$FixedMAP@PAUIDirect3DVertexShader9@@UmapMatrixPS@R_dsgraph@@Udoug_lea_allocator@@@@AAEPAUTNode@1@ABQAUIDirect3DVertexShader9@@@Z ; FixedMAP<IDirect3DVertexShader9 *,R_dsgraph::mapMatrixPS,doug_lea_allocator>::Alloc
	pop	edi

; 155  : 		}
; 156  : 	}

	ret	4
?insert@?$FixedMAP@PAUIDirect3DVertexShader9@@UmapMatrixPS@R_dsgraph@@Udoug_lea_allocator@@@@QAEPAUTNode@1@ABQAUIDirect3DVertexShader9@@@Z ENDP ; FixedMAP<IDirect3DVertexShader9 *,R_dsgraph::mapMatrixPS,doug_lea_allocator>::insert
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
;	COMDAT ?insert@?$FixedMAP@PAUIDirect3DPixelShader9@@UmapMatrixCS@R_dsgraph@@Udoug_lea_allocator@@@@QAEPAUTNode@1@ABQAUIDirect3DPixelShader9@@@Z
_TEXT	SEGMENT
_k$ = 8							; size = 4
?insert@?$FixedMAP@PAUIDirect3DPixelShader9@@UmapMatrixCS@R_dsgraph@@Udoug_lea_allocator@@@@QAEPAUTNode@1@ABQAUIDirect3DPixelShader9@@@Z PROC ; FixedMAP<IDirect3DPixelShader9 *,R_dsgraph::mapMatrixCS,doug_lea_allocator>::insert, COMDAT
; _this$ = ecx

; 128  : 	IC TNode*	insert(const K& k) {

	push	edi
	mov	edi, ecx

; 129  : 		if (pool) {

	cmp	DWORD PTR [edi+4], 0
	je	$LN2@insert

; 130  : 			TNode*	node = nodes;
; 131  : 
; 132  : 			once_more:
; 133  : 			if (k < node->key) {

	mov	ecx, DWORD PTR _k$[esp]
	push	ebx
	mov	ebx, DWORD PTR [edi]
	push	esi
	mov	edx, DWORD PTR [ecx]
	mov	esi, ebx
	npad	7
$once_more$25:
	cmp	edx, DWORD PTR [esi]
	jae	SHORT $LN4@insert

; 134  : 				if (node->left) {

	mov	eax, DWORD PTR [esi+20]
	test	eax, eax
	je	SHORT $LN6@insert

; 135  : 					node = node->left;

	mov	esi, eax

; 136  : 					goto once_more;

	jmp	SHORT $once_more$25
$LN4@insert:

; 141  : 				}
; 142  : 			} else if (k > node->key) {

	jbe	SHORT $LN8@insert

; 143  : 				if (node->right) {

	mov	eax, DWORD PTR [esi+24]
	test	eax, eax
	je	SHORT $LN10@insert

; 144  : 					node = node->right;

	mov	esi, eax

; 145  : 					goto once_more;

	jmp	SHORT $once_more$25
$LN6@insert:

; 70   : 		TNode*	N	= Alloc	(key);

	push	ecx
	mov	ecx, edi
	call	?Alloc@?$FixedMAP@PAUIDirect3DPixelShader9@@UmapMatrixCS@R_dsgraph@@Udoug_lea_allocator@@@@AAEPAUTNode@1@ABQAUIDirect3DPixelShader9@@@Z ; FixedMAP<IDirect3DPixelShader9 *,R_dsgraph::mapMatrixCS,doug_lea_allocator>::Alloc
	sub	esi, ebx

; 137  : 				} else {
; 138  : 					TNode* N = CreateChild(node,k);

	mov	edx, eax

; 69   : 		size_t	PID	= size_t(parent-nodes);

	sar	esi, 2
	imul	eax, esi, -1227133513
	pop	esi
	pop	ebx

; 71   : 		parent		= nodes+PID;

	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax

; 139  : 					node->left = N;

	mov	eax, DWORD PTR [edi]
	pop	edi
	mov	DWORD PTR [eax+ecx*4+20], edx

; 140  : 					return N;

	mov	eax, edx

; 155  : 		}
; 156  : 	}

	ret	4
$LN10@insert:

; 70   : 		TNode*	N	= Alloc	(key);

	push	ecx
	mov	ecx, edi
	call	?Alloc@?$FixedMAP@PAUIDirect3DPixelShader9@@UmapMatrixCS@R_dsgraph@@Udoug_lea_allocator@@@@AAEPAUTNode@1@ABQAUIDirect3DPixelShader9@@@Z ; FixedMAP<IDirect3DPixelShader9 *,R_dsgraph::mapMatrixCS,doug_lea_allocator>::Alloc
	sub	esi, ebx

; 146  : 				} else {
; 147  : 					TNode* N = CreateChild(node,k);

	mov	edx, eax

; 69   : 		size_t	PID	= size_t(parent-nodes);

	sar	esi, 2
	imul	eax, esi, -1227133513
	pop	esi
	pop	ebx

; 71   : 		parent		= nodes+PID;

	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax

; 148  : 					node->right = N;

	mov	eax, DWORD PTR [edi]
	pop	edi
	mov	DWORD PTR [eax+ecx*4+24], edx
	mov	eax, edx

; 155  : 		}
; 156  : 	}

	ret	4
$LN8@insert:

; 149  : 					return N;
; 150  : 				}
; 151  : 			} else return node;

	mov	eax, esi
	pop	esi
	pop	ebx
	pop	edi

; 155  : 		}
; 156  : 	}

	ret	4
$LN2@insert:

; 152  : 			
; 153  : 		} else {
; 154  : 			return Alloc(k);

	push	DWORD PTR _k$[esp]
	call	?Alloc@?$FixedMAP@PAUIDirect3DPixelShader9@@UmapMatrixCS@R_dsgraph@@Udoug_lea_allocator@@@@AAEPAUTNode@1@ABQAUIDirect3DPixelShader9@@@Z ; FixedMAP<IDirect3DPixelShader9 *,R_dsgraph::mapMatrixCS,doug_lea_allocator>::Alloc
	pop	edi

; 155  : 		}
; 156  : 	}

	ret	4
?insert@?$FixedMAP@PAUIDirect3DPixelShader9@@UmapMatrixCS@R_dsgraph@@Udoug_lea_allocator@@@@QAEPAUTNode@1@ABQAUIDirect3DPixelShader9@@@Z ENDP ; FixedMAP<IDirect3DPixelShader9 *,R_dsgraph::mapMatrixCS,doug_lea_allocator>::insert
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
;	COMDAT ?insert@?$FixedMAP@PAVR_constant_table@@UmapMatrixStates@R_dsgraph@@Udoug_lea_allocator@@@@QAEPAUTNode@1@ABQAVR_constant_table@@@Z
_TEXT	SEGMENT
_k$ = 8							; size = 4
?insert@?$FixedMAP@PAVR_constant_table@@UmapMatrixStates@R_dsgraph@@Udoug_lea_allocator@@@@QAEPAUTNode@1@ABQAVR_constant_table@@@Z PROC ; FixedMAP<R_constant_table *,R_dsgraph::mapMatrixStates,doug_lea_allocator>::insert, COMDAT
; _this$ = ecx

; 128  : 	IC TNode*	insert(const K& k) {

	push	edi
	mov	edi, ecx

; 129  : 		if (pool) {

	cmp	DWORD PTR [edi+4], 0
	je	$LN2@insert

; 130  : 			TNode*	node = nodes;
; 131  : 
; 132  : 			once_more:
; 133  : 			if (k < node->key) {

	mov	ecx, DWORD PTR _k$[esp]
	push	ebx
	mov	ebx, DWORD PTR [edi]
	push	esi
	mov	edx, DWORD PTR [ecx]
	mov	esi, ebx
	npad	7
$once_more$25:
	cmp	edx, DWORD PTR [esi]
	jae	SHORT $LN4@insert

; 134  : 				if (node->left) {

	mov	eax, DWORD PTR [esi+20]
	test	eax, eax
	je	SHORT $LN6@insert

; 135  : 					node = node->left;

	mov	esi, eax

; 136  : 					goto once_more;

	jmp	SHORT $once_more$25
$LN4@insert:

; 141  : 				}
; 142  : 			} else if (k > node->key) {

	jbe	SHORT $LN8@insert

; 143  : 				if (node->right) {

	mov	eax, DWORD PTR [esi+24]
	test	eax, eax
	je	SHORT $LN10@insert

; 144  : 					node = node->right;

	mov	esi, eax

; 145  : 					goto once_more;

	jmp	SHORT $once_more$25
$LN6@insert:

; 70   : 		TNode*	N	= Alloc	(key);

	push	ecx
	mov	ecx, edi
	call	?Alloc@?$FixedMAP@PAVR_constant_table@@UmapMatrixStates@R_dsgraph@@Udoug_lea_allocator@@@@AAEPAUTNode@1@ABQAVR_constant_table@@@Z ; FixedMAP<R_constant_table *,R_dsgraph::mapMatrixStates,doug_lea_allocator>::Alloc
	sub	esi, ebx

; 137  : 				} else {
; 138  : 					TNode* N = CreateChild(node,k);

	mov	edx, eax

; 69   : 		size_t	PID	= size_t(parent-nodes);

	sar	esi, 2
	imul	eax, esi, -1227133513
	pop	esi
	pop	ebx

; 71   : 		parent		= nodes+PID;

	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax

; 139  : 					node->left = N;

	mov	eax, DWORD PTR [edi]
	pop	edi
	mov	DWORD PTR [eax+ecx*4+20], edx

; 140  : 					return N;

	mov	eax, edx

; 155  : 		}
; 156  : 	}

	ret	4
$LN10@insert:

; 70   : 		TNode*	N	= Alloc	(key);

	push	ecx
	mov	ecx, edi
	call	?Alloc@?$FixedMAP@PAVR_constant_table@@UmapMatrixStates@R_dsgraph@@Udoug_lea_allocator@@@@AAEPAUTNode@1@ABQAVR_constant_table@@@Z ; FixedMAP<R_constant_table *,R_dsgraph::mapMatrixStates,doug_lea_allocator>::Alloc
	sub	esi, ebx

; 146  : 				} else {
; 147  : 					TNode* N = CreateChild(node,k);

	mov	edx, eax

; 69   : 		size_t	PID	= size_t(parent-nodes);

	sar	esi, 2
	imul	eax, esi, -1227133513
	pop	esi
	pop	ebx

; 71   : 		parent		= nodes+PID;

	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax

; 148  : 					node->right = N;

	mov	eax, DWORD PTR [edi]
	pop	edi
	mov	DWORD PTR [eax+ecx*4+24], edx
	mov	eax, edx

; 155  : 		}
; 156  : 	}

	ret	4
$LN8@insert:

; 149  : 					return N;
; 150  : 				}
; 151  : 			} else return node;

	mov	eax, esi
	pop	esi
	pop	ebx
	pop	edi

; 155  : 		}
; 156  : 	}

	ret	4
$LN2@insert:

; 152  : 			
; 153  : 		} else {
; 154  : 			return Alloc(k);

	push	DWORD PTR _k$[esp]
	call	?Alloc@?$FixedMAP@PAVR_constant_table@@UmapMatrixStates@R_dsgraph@@Udoug_lea_allocator@@@@AAEPAUTNode@1@ABQAVR_constant_table@@@Z ; FixedMAP<R_constant_table *,R_dsgraph::mapMatrixStates,doug_lea_allocator>::Alloc
	pop	edi

; 155  : 		}
; 156  : 	}

	ret	4
?insert@?$FixedMAP@PAVR_constant_table@@UmapMatrixStates@R_dsgraph@@Udoug_lea_allocator@@@@QAEPAUTNode@1@ABQAVR_constant_table@@@Z ENDP ; FixedMAP<R_constant_table *,R_dsgraph::mapMatrixStates,doug_lea_allocator>::insert
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
;	COMDAT ?insert@?$FixedMAP@PAUIDirect3DStateBlock9@@UmapMatrixTextures@R_dsgraph@@Udoug_lea_allocator@@@@QAEPAUTNode@1@ABQAUIDirect3DStateBlock9@@@Z
_TEXT	SEGMENT
_k$ = 8							; size = 4
?insert@?$FixedMAP@PAUIDirect3DStateBlock9@@UmapMatrixTextures@R_dsgraph@@Udoug_lea_allocator@@@@QAEPAUTNode@1@ABQAUIDirect3DStateBlock9@@@Z PROC ; FixedMAP<IDirect3DStateBlock9 *,R_dsgraph::mapMatrixTextures,doug_lea_allocator>::insert, COMDAT
; _this$ = ecx

; 128  : 	IC TNode*	insert(const K& k) {

	push	edi
	mov	edi, ecx

; 129  : 		if (pool) {

	cmp	DWORD PTR [edi+4], 0
	je	$LN2@insert

; 130  : 			TNode*	node = nodes;
; 131  : 
; 132  : 			once_more:
; 133  : 			if (k < node->key) {

	mov	ecx, DWORD PTR _k$[esp]
	push	ebx
	mov	ebx, DWORD PTR [edi]
	push	esi
	mov	edx, DWORD PTR [ecx]
	mov	esi, ebx
	npad	7
$once_more$25:
	cmp	edx, DWORD PTR [esi]
	jae	SHORT $LN4@insert

; 134  : 				if (node->left) {

	mov	eax, DWORD PTR [esi+20]
	test	eax, eax
	je	SHORT $LN6@insert

; 135  : 					node = node->left;

	mov	esi, eax

; 136  : 					goto once_more;

	jmp	SHORT $once_more$25
$LN4@insert:

; 141  : 				}
; 142  : 			} else if (k > node->key) {

	jbe	SHORT $LN8@insert

; 143  : 				if (node->right) {

	mov	eax, DWORD PTR [esi+24]
	test	eax, eax
	je	SHORT $LN10@insert

; 144  : 					node = node->right;

	mov	esi, eax

; 145  : 					goto once_more;

	jmp	SHORT $once_more$25
$LN6@insert:

; 70   : 		TNode*	N	= Alloc	(key);

	push	ecx
	mov	ecx, edi
	call	?Alloc@?$FixedMAP@PAUIDirect3DStateBlock9@@UmapMatrixTextures@R_dsgraph@@Udoug_lea_allocator@@@@AAEPAUTNode@1@ABQAUIDirect3DStateBlock9@@@Z ; FixedMAP<IDirect3DStateBlock9 *,R_dsgraph::mapMatrixTextures,doug_lea_allocator>::Alloc
	sub	esi, ebx

; 137  : 				} else {
; 138  : 					TNode* N = CreateChild(node,k);

	mov	edx, eax

; 69   : 		size_t	PID	= size_t(parent-nodes);

	sar	esi, 2
	imul	eax, esi, -1227133513
	pop	esi
	pop	ebx

; 71   : 		parent		= nodes+PID;

	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax

; 139  : 					node->left = N;

	mov	eax, DWORD PTR [edi]
	pop	edi
	mov	DWORD PTR [eax+ecx*4+20], edx

; 140  : 					return N;

	mov	eax, edx

; 155  : 		}
; 156  : 	}

	ret	4
$LN10@insert:

; 70   : 		TNode*	N	= Alloc	(key);

	push	ecx
	mov	ecx, edi
	call	?Alloc@?$FixedMAP@PAUIDirect3DStateBlock9@@UmapMatrixTextures@R_dsgraph@@Udoug_lea_allocator@@@@AAEPAUTNode@1@ABQAUIDirect3DStateBlock9@@@Z ; FixedMAP<IDirect3DStateBlock9 *,R_dsgraph::mapMatrixTextures,doug_lea_allocator>::Alloc
	sub	esi, ebx

; 146  : 				} else {
; 147  : 					TNode* N = CreateChild(node,k);

	mov	edx, eax

; 69   : 		size_t	PID	= size_t(parent-nodes);

	sar	esi, 2
	imul	eax, esi, -1227133513
	pop	esi
	pop	ebx

; 71   : 		parent		= nodes+PID;

	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax

; 148  : 					node->right = N;

	mov	eax, DWORD PTR [edi]
	pop	edi
	mov	DWORD PTR [eax+ecx*4+24], edx
	mov	eax, edx

; 155  : 		}
; 156  : 	}

	ret	4
$LN8@insert:

; 149  : 					return N;
; 150  : 				}
; 151  : 			} else return node;

	mov	eax, esi
	pop	esi
	pop	ebx
	pop	edi

; 155  : 		}
; 156  : 	}

	ret	4
$LN2@insert:

; 152  : 			
; 153  : 		} else {
; 154  : 			return Alloc(k);

	push	DWORD PTR _k$[esp]
	call	?Alloc@?$FixedMAP@PAUIDirect3DStateBlock9@@UmapMatrixTextures@R_dsgraph@@Udoug_lea_allocator@@@@AAEPAUTNode@1@ABQAUIDirect3DStateBlock9@@@Z ; FixedMAP<IDirect3DStateBlock9 *,R_dsgraph::mapMatrixTextures,doug_lea_allocator>::Alloc
	pop	edi

; 155  : 		}
; 156  : 	}

	ret	4
?insert@?$FixedMAP@PAUIDirect3DStateBlock9@@UmapMatrixTextures@R_dsgraph@@Udoug_lea_allocator@@@@QAEPAUTNode@1@ABQAUIDirect3DStateBlock9@@@Z ENDP ; FixedMAP<IDirect3DStateBlock9 *,R_dsgraph::mapMatrixTextures,doug_lea_allocator>::insert
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
;	COMDAT ?insert@?$FixedMAP@PAUSTextureList@@UmapMatrixItems@R_dsgraph@@Udoug_lea_allocator@@@@QAEPAUTNode@1@ABQAUSTextureList@@@Z
_TEXT	SEGMENT
_k$ = 8							; size = 4
?insert@?$FixedMAP@PAUSTextureList@@UmapMatrixItems@R_dsgraph@@Udoug_lea_allocator@@@@QAEPAUTNode@1@ABQAUSTextureList@@@Z PROC ; FixedMAP<STextureList *,R_dsgraph::mapMatrixItems,doug_lea_allocator>::insert, COMDAT
; _this$ = ecx

; 128  : 	IC TNode*	insert(const K& k) {

	push	edi
	mov	edi, ecx

; 129  : 		if (pool) {

	cmp	DWORD PTR [edi+4], 0
	je	$LN2@insert

; 130  : 			TNode*	node = nodes;
; 131  : 
; 132  : 			once_more:
; 133  : 			if (k < node->key) {

	mov	ecx, DWORD PTR _k$[esp]
	push	ebx
	mov	ebx, DWORD PTR [edi]
	push	esi
	mov	edx, DWORD PTR [ecx]
	mov	esi, ebx
	npad	7
$once_more$25:
	cmp	edx, DWORD PTR [esi]
	jae	SHORT $LN4@insert

; 134  : 				if (node->left) {

	mov	eax, DWORD PTR [esi+20]
	test	eax, eax
	je	SHORT $LN6@insert

; 135  : 					node = node->left;

	mov	esi, eax

; 136  : 					goto once_more;

	jmp	SHORT $once_more$25
$LN4@insert:

; 141  : 				}
; 142  : 			} else if (k > node->key) {

	jbe	SHORT $LN8@insert

; 143  : 				if (node->right) {

	mov	eax, DWORD PTR [esi+24]
	test	eax, eax
	je	SHORT $LN10@insert

; 144  : 					node = node->right;

	mov	esi, eax

; 145  : 					goto once_more;

	jmp	SHORT $once_more$25
$LN6@insert:

; 70   : 		TNode*	N	= Alloc	(key);

	push	ecx
	mov	ecx, edi
	call	?Alloc@?$FixedMAP@PAUSTextureList@@UmapMatrixItems@R_dsgraph@@Udoug_lea_allocator@@@@AAEPAUTNode@1@ABQAUSTextureList@@@Z ; FixedMAP<STextureList *,R_dsgraph::mapMatrixItems,doug_lea_allocator>::Alloc
	sub	esi, ebx

; 137  : 				} else {
; 138  : 					TNode* N = CreateChild(node,k);

	mov	edx, eax

; 69   : 		size_t	PID	= size_t(parent-nodes);

	sar	esi, 2
	imul	eax, esi, -1227133513
	pop	esi
	pop	ebx

; 71   : 		parent		= nodes+PID;

	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax

; 139  : 					node->left = N;

	mov	eax, DWORD PTR [edi]
	pop	edi
	mov	DWORD PTR [eax+ecx*4+20], edx

; 140  : 					return N;

	mov	eax, edx

; 155  : 		}
; 156  : 	}

	ret	4
$LN10@insert:

; 70   : 		TNode*	N	= Alloc	(key);

	push	ecx
	mov	ecx, edi
	call	?Alloc@?$FixedMAP@PAUSTextureList@@UmapMatrixItems@R_dsgraph@@Udoug_lea_allocator@@@@AAEPAUTNode@1@ABQAUSTextureList@@@Z ; FixedMAP<STextureList *,R_dsgraph::mapMatrixItems,doug_lea_allocator>::Alloc
	sub	esi, ebx

; 146  : 				} else {
; 147  : 					TNode* N = CreateChild(node,k);

	mov	edx, eax

; 69   : 		size_t	PID	= size_t(parent-nodes);

	sar	esi, 2
	imul	eax, esi, -1227133513
	pop	esi
	pop	ebx

; 71   : 		parent		= nodes+PID;

	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax

; 148  : 					node->right = N;

	mov	eax, DWORD PTR [edi]
	pop	edi
	mov	DWORD PTR [eax+ecx*4+24], edx
	mov	eax, edx

; 155  : 		}
; 156  : 	}

	ret	4
$LN8@insert:

; 149  : 					return N;
; 150  : 				}
; 151  : 			} else return node;

	mov	eax, esi
	pop	esi
	pop	ebx
	pop	edi

; 155  : 		}
; 156  : 	}

	ret	4
$LN2@insert:

; 152  : 			
; 153  : 		} else {
; 154  : 			return Alloc(k);

	push	DWORD PTR _k$[esp]
	call	?Alloc@?$FixedMAP@PAUSTextureList@@UmapMatrixItems@R_dsgraph@@Udoug_lea_allocator@@@@AAEPAUTNode@1@ABQAUSTextureList@@@Z ; FixedMAP<STextureList *,R_dsgraph::mapMatrixItems,doug_lea_allocator>::Alloc
	pop	edi

; 155  : 		}
; 156  : 	}

	ret	4
?insert@?$FixedMAP@PAUSTextureList@@UmapMatrixItems@R_dsgraph@@Udoug_lea_allocator@@@@QAEPAUTNode@1@ABQAUSTextureList@@@Z ENDP ; FixedMAP<STextureList *,R_dsgraph::mapMatrixItems,doug_lea_allocator>::insert
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?push_back@?$vector@U_MatrixItem@R_dsgraph@@V?$doug_lea_alloc@U_MatrixItem@R_dsgraph@@@@@std@@QAEXABU_MatrixItem@R_dsgraph@@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?push_back@?$vector@U_MatrixItem@R_dsgraph@@V?$doug_lea_alloc@U_MatrixItem@R_dsgraph@@@@@std@@QAEXABU_MatrixItem@R_dsgraph@@@Z PROC ; std::vector<R_dsgraph::_MatrixItem,doug_lea_alloc<R_dsgraph::_MatrixItem> >::push_back, COMDAT
; _this$ = ecx

; 742  :     _CONSTEXPR20_CONTAINER void push_back(const _Ty& _Val) { // insert element at end, provide strong guarantee

	mov	eax, ecx

; 730  :         if (_Mylast != _My_data._Myend) {

	mov	edx, DWORD PTR [eax+4]
	cmp	edx, DWORD PTR [eax+8]
	je	SHORT $LN4@push_back
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h

; 37   : 								void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	push	esi
	mov	esi, DWORD PTR __Val$[esp]
	mov	ecx, 19					; 00000013H
	push	edi
	mov	edi, edx
	rep movsd
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 716  :         ++_Mylast;

	add	DWORD PTR [eax+4], 76			; 0000004cH
	pop	edi
	pop	esi

; 743  :         emplace_back(_Val);
; 744  :     }

	ret	4
$LN4@push_back:

; 734  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	push	DWORD PTR __Val$[esp-4]
	push	edx
	call	??$_Emplace_reallocate@ABU_MatrixItem@R_dsgraph@@@?$vector@U_MatrixItem@R_dsgraph@@V?$doug_lea_alloc@U_MatrixItem@R_dsgraph@@@@@std@@QAEPAU_MatrixItem@R_dsgraph@@QAU23@ABU23@@Z ; std::vector<R_dsgraph::_MatrixItem,doug_lea_alloc<R_dsgraph::_MatrixItem> >::_Emplace_reallocate<R_dsgraph::_MatrixItem const &>

; 743  :         emplace_back(_Val);
; 744  :     }

	ret	4
?push_back@?$vector@U_MatrixItem@R_dsgraph@@V?$doug_lea_alloc@U_MatrixItem@R_dsgraph@@@@@std@@QAEXABU_MatrixItem@R_dsgraph@@@Z ENDP ; std::vector<R_dsgraph::_MatrixItem,doug_lea_alloc<R_dsgraph::_MatrixItem> >::push_back
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??$emplace_back@ABU_MatrixItem@R_dsgraph@@@?$vector@U_MatrixItem@R_dsgraph@@V?$doug_lea_alloc@U_MatrixItem@R_dsgraph@@@@@std@@QAE?A_TABU_MatrixItem@R_dsgraph@@@Z
_TEXT	SEGMENT
_<_Val_0>$ = 8						; size = 4
??$emplace_back@ABU_MatrixItem@R_dsgraph@@@?$vector@U_MatrixItem@R_dsgraph@@V?$doug_lea_alloc@U_MatrixItem@R_dsgraph@@@@@std@@QAE?A_TABU_MatrixItem@R_dsgraph@@@Z PROC ; std::vector<R_dsgraph::_MatrixItem,doug_lea_alloc<R_dsgraph::_MatrixItem> >::emplace_back<R_dsgraph::_MatrixItem const &>, COMDAT
; _this$ = ecx

; 726  :     _CONSTEXPR20_CONTAINER decltype(auto) emplace_back(_Valty&&... _Val) {

	mov	eax, ecx

; 727  :         // insert by perfectly forwarding into element at end, provide strong guarantee
; 728  :         auto& _My_data   = _Mypair._Myval2;
; 729  :         pointer& _Mylast = _My_data._Mylast;
; 730  :         if (_Mylast != _My_data._Myend) {

	mov	edx, DWORD PTR [eax+4]
	cmp	edx, DWORD PTR [eax+8]
	je	SHORT $LN2@emplace_ba
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h

; 37   : 								void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	push	esi
	mov	esi, DWORD PTR _<_Val_0>$[esp]
	mov	ecx, 19					; 00000013H
	push	edi
	mov	edi, edx
	rep movsd
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 716  :         ++_Mylast;

	add	DWORD PTR [eax+4], 76			; 0000004cH
	pop	edi
	pop	esi

; 735  : #if _HAS_CXX17
; 736  :         return _Result;
; 737  : #else // ^^^ _HAS_CXX17 ^^^ // vvv !_HAS_CXX17 vvv
; 738  :         (void) _Result;
; 739  : #endif // _HAS_CXX17
; 740  :     }

	ret	4
$LN2@emplace_ba:

; 731  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);
; 732  :         }
; 733  : 
; 734  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	push	DWORD PTR _<_Val_0>$[esp-4]
	push	edx
	call	??$_Emplace_reallocate@ABU_MatrixItem@R_dsgraph@@@?$vector@U_MatrixItem@R_dsgraph@@V?$doug_lea_alloc@U_MatrixItem@R_dsgraph@@@@@std@@QAEPAU_MatrixItem@R_dsgraph@@QAU23@ABU23@@Z ; std::vector<R_dsgraph::_MatrixItem,doug_lea_alloc<R_dsgraph::_MatrixItem> >::_Emplace_reallocate<R_dsgraph::_MatrixItem const &>

; 735  : #if _HAS_CXX17
; 736  :         return _Result;
; 737  : #else // ^^^ _HAS_CXX17 ^^^ // vvv !_HAS_CXX17 vvv
; 738  :         (void) _Result;
; 739  : #endif // _HAS_CXX17
; 740  :     }

	ret	4
??$emplace_back@ABU_MatrixItem@R_dsgraph@@@?$vector@U_MatrixItem@R_dsgraph@@V?$doug_lea_alloc@U_MatrixItem@R_dsgraph@@@@@std@@QAE?A_TABU_MatrixItem@R_dsgraph@@@Z ENDP ; std::vector<R_dsgraph::_MatrixItem,doug_lea_alloc<R_dsgraph::_MatrixItem> >::emplace_back<R_dsgraph::_MatrixItem const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??$_Emplace_back_with_unused_capacity@ABU_MatrixItem@R_dsgraph@@@?$vector@U_MatrixItem@R_dsgraph@@V?$doug_lea_alloc@U_MatrixItem@R_dsgraph@@@@@std@@AAE?A_TABU_MatrixItem@R_dsgraph@@@Z
_TEXT	SEGMENT
_<_Val_0>$ = 8						; size = 4
??$_Emplace_back_with_unused_capacity@ABU_MatrixItem@R_dsgraph@@@?$vector@U_MatrixItem@R_dsgraph@@V?$doug_lea_alloc@U_MatrixItem@R_dsgraph@@@@@std@@AAE?A_TABU_MatrixItem@R_dsgraph@@@Z PROC ; std::vector<R_dsgraph::_MatrixItem,doug_lea_alloc<R_dsgraph::_MatrixItem> >::_Emplace_back_with_unused_capacity<R_dsgraph::_MatrixItem const &>, COMDAT
; _this$ = ecx

; 708  :     _CONSTEXPR20_CONTAINER decltype(auto) _Emplace_back_with_unused_capacity(_Valty&&... _Val) {

	mov	eax, ecx
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h

; 37   : 								void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	ecx, 19					; 00000013H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 708  :     _CONSTEXPR20_CONTAINER decltype(auto) _Emplace_back_with_unused_capacity(_Valty&&... _Val) {

	push	esi
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h

; 37   : 								void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	esi, DWORD PTR _<_Val_0>$[esp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 708  :     _CONSTEXPR20_CONTAINER decltype(auto) _Emplace_back_with_unused_capacity(_Valty&&... _Val) {

	push	edi
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h

; 37   : 								void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	edi, DWORD PTR [eax+4]
	rep movsd
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 716  :         ++_Mylast;

	add	DWORD PTR [eax+4], 76			; 0000004cH
	pop	edi
	pop	esi

; 717  : #if _HAS_CXX17
; 718  :         return _Result;
; 719  : #else // ^^^ _HAS_CXX17 ^^^ // vvv !_HAS_CXX17 vvv
; 720  :         (void) _Result;
; 721  : #endif // _HAS_CXX17
; 722  :     }

	ret	4
??$_Emplace_back_with_unused_capacity@ABU_MatrixItem@R_dsgraph@@@?$vector@U_MatrixItem@R_dsgraph@@V?$doug_lea_alloc@U_MatrixItem@R_dsgraph@@@@@std@@AAE?A_TABU_MatrixItem@R_dsgraph@@@Z ENDP ; std::vector<R_dsgraph::_MatrixItem,doug_lea_alloc<R_dsgraph::_MatrixItem> >::_Emplace_back_with_unused_capacity<R_dsgraph::_MatrixItem const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
;	COMDAT ?insert@?$FixedMAP@PAUIDirect3DVertexShader9@@UmapNormalPS@R_dsgraph@@Udoug_lea_allocator@@@@QAEPAUTNode@1@ABQAUIDirect3DVertexShader9@@@Z
_TEXT	SEGMENT
_k$ = 8							; size = 4
?insert@?$FixedMAP@PAUIDirect3DVertexShader9@@UmapNormalPS@R_dsgraph@@Udoug_lea_allocator@@@@QAEPAUTNode@1@ABQAUIDirect3DVertexShader9@@@Z PROC ; FixedMAP<IDirect3DVertexShader9 *,R_dsgraph::mapNormalPS,doug_lea_allocator>::insert, COMDAT
; _this$ = ecx

; 128  : 	IC TNode*	insert(const K& k) {

	push	edi
	mov	edi, ecx

; 129  : 		if (pool) {

	cmp	DWORD PTR [edi+4], 0
	je	$LN2@insert

; 130  : 			TNode*	node = nodes;
; 131  : 
; 132  : 			once_more:
; 133  : 			if (k < node->key) {

	mov	ecx, DWORD PTR _k$[esp]
	push	ebx
	mov	ebx, DWORD PTR [edi]
	push	esi
	mov	edx, DWORD PTR [ecx]
	mov	esi, ebx
	npad	7
$once_more$25:
	cmp	edx, DWORD PTR [esi]
	jae	SHORT $LN4@insert

; 134  : 				if (node->left) {

	mov	eax, DWORD PTR [esi+20]
	test	eax, eax
	je	SHORT $LN6@insert

; 135  : 					node = node->left;

	mov	esi, eax

; 136  : 					goto once_more;

	jmp	SHORT $once_more$25
$LN4@insert:

; 141  : 				}
; 142  : 			} else if (k > node->key) {

	jbe	SHORT $LN8@insert

; 143  : 				if (node->right) {

	mov	eax, DWORD PTR [esi+24]
	test	eax, eax
	je	SHORT $LN10@insert

; 144  : 					node = node->right;

	mov	esi, eax

; 145  : 					goto once_more;

	jmp	SHORT $once_more$25
$LN6@insert:

; 70   : 		TNode*	N	= Alloc	(key);

	push	ecx
	mov	ecx, edi
	call	?Alloc@?$FixedMAP@PAUIDirect3DVertexShader9@@UmapNormalPS@R_dsgraph@@Udoug_lea_allocator@@@@AAEPAUTNode@1@ABQAUIDirect3DVertexShader9@@@Z ; FixedMAP<IDirect3DVertexShader9 *,R_dsgraph::mapNormalPS,doug_lea_allocator>::Alloc
	sub	esi, ebx

; 137  : 				} else {
; 138  : 					TNode* N = CreateChild(node,k);

	mov	edx, eax

; 69   : 		size_t	PID	= size_t(parent-nodes);

	sar	esi, 2
	imul	eax, esi, -1227133513
	pop	esi
	pop	ebx

; 71   : 		parent		= nodes+PID;

	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax

; 139  : 					node->left = N;

	mov	eax, DWORD PTR [edi]
	pop	edi
	mov	DWORD PTR [eax+ecx*4+20], edx

; 140  : 					return N;

	mov	eax, edx

; 155  : 		}
; 156  : 	}

	ret	4
$LN10@insert:

; 70   : 		TNode*	N	= Alloc	(key);

	push	ecx
	mov	ecx, edi
	call	?Alloc@?$FixedMAP@PAUIDirect3DVertexShader9@@UmapNormalPS@R_dsgraph@@Udoug_lea_allocator@@@@AAEPAUTNode@1@ABQAUIDirect3DVertexShader9@@@Z ; FixedMAP<IDirect3DVertexShader9 *,R_dsgraph::mapNormalPS,doug_lea_allocator>::Alloc
	sub	esi, ebx

; 146  : 				} else {
; 147  : 					TNode* N = CreateChild(node,k);

	mov	edx, eax

; 69   : 		size_t	PID	= size_t(parent-nodes);

	sar	esi, 2
	imul	eax, esi, -1227133513
	pop	esi
	pop	ebx

; 71   : 		parent		= nodes+PID;

	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax

; 148  : 					node->right = N;

	mov	eax, DWORD PTR [edi]
	pop	edi
	mov	DWORD PTR [eax+ecx*4+24], edx
	mov	eax, edx

; 155  : 		}
; 156  : 	}

	ret	4
$LN8@insert:

; 149  : 					return N;
; 150  : 				}
; 151  : 			} else return node;

	mov	eax, esi
	pop	esi
	pop	ebx
	pop	edi

; 155  : 		}
; 156  : 	}

	ret	4
$LN2@insert:

; 152  : 			
; 153  : 		} else {
; 154  : 			return Alloc(k);

	push	DWORD PTR _k$[esp]
	call	?Alloc@?$FixedMAP@PAUIDirect3DVertexShader9@@UmapNormalPS@R_dsgraph@@Udoug_lea_allocator@@@@AAEPAUTNode@1@ABQAUIDirect3DVertexShader9@@@Z ; FixedMAP<IDirect3DVertexShader9 *,R_dsgraph::mapNormalPS,doug_lea_allocator>::Alloc
	pop	edi

; 155  : 		}
; 156  : 	}

	ret	4
?insert@?$FixedMAP@PAUIDirect3DVertexShader9@@UmapNormalPS@R_dsgraph@@Udoug_lea_allocator@@@@QAEPAUTNode@1@ABQAUIDirect3DVertexShader9@@@Z ENDP ; FixedMAP<IDirect3DVertexShader9 *,R_dsgraph::mapNormalPS,doug_lea_allocator>::insert
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
;	COMDAT ?insert@?$FixedMAP@PAUIDirect3DPixelShader9@@UmapNormalCS@R_dsgraph@@Udoug_lea_allocator@@@@QAEPAUTNode@1@ABQAUIDirect3DPixelShader9@@@Z
_TEXT	SEGMENT
_k$ = 8							; size = 4
?insert@?$FixedMAP@PAUIDirect3DPixelShader9@@UmapNormalCS@R_dsgraph@@Udoug_lea_allocator@@@@QAEPAUTNode@1@ABQAUIDirect3DPixelShader9@@@Z PROC ; FixedMAP<IDirect3DPixelShader9 *,R_dsgraph::mapNormalCS,doug_lea_allocator>::insert, COMDAT
; _this$ = ecx

; 128  : 	IC TNode*	insert(const K& k) {

	push	edi
	mov	edi, ecx

; 129  : 		if (pool) {

	cmp	DWORD PTR [edi+4], 0
	je	$LN2@insert

; 130  : 			TNode*	node = nodes;
; 131  : 
; 132  : 			once_more:
; 133  : 			if (k < node->key) {

	mov	ecx, DWORD PTR _k$[esp]
	push	ebx
	mov	ebx, DWORD PTR [edi]
	push	esi
	mov	edx, DWORD PTR [ecx]
	mov	esi, ebx
	npad	7
$once_more$25:
	cmp	edx, DWORD PTR [esi]
	jae	SHORT $LN4@insert

; 134  : 				if (node->left) {

	mov	eax, DWORD PTR [esi+20]
	test	eax, eax
	je	SHORT $LN6@insert

; 135  : 					node = node->left;

	mov	esi, eax

; 136  : 					goto once_more;

	jmp	SHORT $once_more$25
$LN4@insert:

; 141  : 				}
; 142  : 			} else if (k > node->key) {

	jbe	SHORT $LN8@insert

; 143  : 				if (node->right) {

	mov	eax, DWORD PTR [esi+24]
	test	eax, eax
	je	SHORT $LN10@insert

; 144  : 					node = node->right;

	mov	esi, eax

; 145  : 					goto once_more;

	jmp	SHORT $once_more$25
$LN6@insert:

; 70   : 		TNode*	N	= Alloc	(key);

	push	ecx
	mov	ecx, edi
	call	?Alloc@?$FixedMAP@PAUIDirect3DPixelShader9@@UmapNormalCS@R_dsgraph@@Udoug_lea_allocator@@@@AAEPAUTNode@1@ABQAUIDirect3DPixelShader9@@@Z ; FixedMAP<IDirect3DPixelShader9 *,R_dsgraph::mapNormalCS,doug_lea_allocator>::Alloc
	sub	esi, ebx

; 137  : 				} else {
; 138  : 					TNode* N = CreateChild(node,k);

	mov	edx, eax

; 69   : 		size_t	PID	= size_t(parent-nodes);

	sar	esi, 2
	imul	eax, esi, -1227133513
	pop	esi
	pop	ebx

; 71   : 		parent		= nodes+PID;

	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax

; 139  : 					node->left = N;

	mov	eax, DWORD PTR [edi]
	pop	edi
	mov	DWORD PTR [eax+ecx*4+20], edx

; 140  : 					return N;

	mov	eax, edx

; 155  : 		}
; 156  : 	}

	ret	4
$LN10@insert:

; 70   : 		TNode*	N	= Alloc	(key);

	push	ecx
	mov	ecx, edi
	call	?Alloc@?$FixedMAP@PAUIDirect3DPixelShader9@@UmapNormalCS@R_dsgraph@@Udoug_lea_allocator@@@@AAEPAUTNode@1@ABQAUIDirect3DPixelShader9@@@Z ; FixedMAP<IDirect3DPixelShader9 *,R_dsgraph::mapNormalCS,doug_lea_allocator>::Alloc
	sub	esi, ebx

; 146  : 				} else {
; 147  : 					TNode* N = CreateChild(node,k);

	mov	edx, eax

; 69   : 		size_t	PID	= size_t(parent-nodes);

	sar	esi, 2
	imul	eax, esi, -1227133513
	pop	esi
	pop	ebx

; 71   : 		parent		= nodes+PID;

	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax

; 148  : 					node->right = N;

	mov	eax, DWORD PTR [edi]
	pop	edi
	mov	DWORD PTR [eax+ecx*4+24], edx
	mov	eax, edx

; 155  : 		}
; 156  : 	}

	ret	4
$LN8@insert:

; 149  : 					return N;
; 150  : 				}
; 151  : 			} else return node;

	mov	eax, esi
	pop	esi
	pop	ebx
	pop	edi

; 155  : 		}
; 156  : 	}

	ret	4
$LN2@insert:

; 152  : 			
; 153  : 		} else {
; 154  : 			return Alloc(k);

	push	DWORD PTR _k$[esp]
	call	?Alloc@?$FixedMAP@PAUIDirect3DPixelShader9@@UmapNormalCS@R_dsgraph@@Udoug_lea_allocator@@@@AAEPAUTNode@1@ABQAUIDirect3DPixelShader9@@@Z ; FixedMAP<IDirect3DPixelShader9 *,R_dsgraph::mapNormalCS,doug_lea_allocator>::Alloc
	pop	edi

; 155  : 		}
; 156  : 	}

	ret	4
?insert@?$FixedMAP@PAUIDirect3DPixelShader9@@UmapNormalCS@R_dsgraph@@Udoug_lea_allocator@@@@QAEPAUTNode@1@ABQAUIDirect3DPixelShader9@@@Z ENDP ; FixedMAP<IDirect3DPixelShader9 *,R_dsgraph::mapNormalCS,doug_lea_allocator>::insert
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
;	COMDAT ?insert@?$FixedMAP@PAVR_constant_table@@UmapNormalStates@R_dsgraph@@Udoug_lea_allocator@@@@QAEPAUTNode@1@ABQAVR_constant_table@@@Z
_TEXT	SEGMENT
_k$ = 8							; size = 4
?insert@?$FixedMAP@PAVR_constant_table@@UmapNormalStates@R_dsgraph@@Udoug_lea_allocator@@@@QAEPAUTNode@1@ABQAVR_constant_table@@@Z PROC ; FixedMAP<R_constant_table *,R_dsgraph::mapNormalStates,doug_lea_allocator>::insert, COMDAT
; _this$ = ecx

; 128  : 	IC TNode*	insert(const K& k) {

	push	edi
	mov	edi, ecx

; 129  : 		if (pool) {

	cmp	DWORD PTR [edi+4], 0
	je	$LN2@insert

; 130  : 			TNode*	node = nodes;
; 131  : 
; 132  : 			once_more:
; 133  : 			if (k < node->key) {

	mov	ecx, DWORD PTR _k$[esp]
	push	ebx
	mov	ebx, DWORD PTR [edi]
	push	esi
	mov	edx, DWORD PTR [ecx]
	mov	esi, ebx
	npad	7
$once_more$25:
	cmp	edx, DWORD PTR [esi]
	jae	SHORT $LN4@insert

; 134  : 				if (node->left) {

	mov	eax, DWORD PTR [esi+20]
	test	eax, eax
	je	SHORT $LN6@insert

; 135  : 					node = node->left;

	mov	esi, eax

; 136  : 					goto once_more;

	jmp	SHORT $once_more$25
$LN4@insert:

; 141  : 				}
; 142  : 			} else if (k > node->key) {

	jbe	SHORT $LN8@insert

; 143  : 				if (node->right) {

	mov	eax, DWORD PTR [esi+24]
	test	eax, eax
	je	SHORT $LN10@insert

; 144  : 					node = node->right;

	mov	esi, eax

; 145  : 					goto once_more;

	jmp	SHORT $once_more$25
$LN6@insert:

; 70   : 		TNode*	N	= Alloc	(key);

	push	ecx
	mov	ecx, edi
	call	?Alloc@?$FixedMAP@PAVR_constant_table@@UmapNormalStates@R_dsgraph@@Udoug_lea_allocator@@@@AAEPAUTNode@1@ABQAVR_constant_table@@@Z ; FixedMAP<R_constant_table *,R_dsgraph::mapNormalStates,doug_lea_allocator>::Alloc
	sub	esi, ebx

; 137  : 				} else {
; 138  : 					TNode* N = CreateChild(node,k);

	mov	edx, eax

; 69   : 		size_t	PID	= size_t(parent-nodes);

	sar	esi, 2
	imul	eax, esi, -1227133513
	pop	esi
	pop	ebx

; 71   : 		parent		= nodes+PID;

	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax

; 139  : 					node->left = N;

	mov	eax, DWORD PTR [edi]
	pop	edi
	mov	DWORD PTR [eax+ecx*4+20], edx

; 140  : 					return N;

	mov	eax, edx

; 155  : 		}
; 156  : 	}

	ret	4
$LN10@insert:

; 70   : 		TNode*	N	= Alloc	(key);

	push	ecx
	mov	ecx, edi
	call	?Alloc@?$FixedMAP@PAVR_constant_table@@UmapNormalStates@R_dsgraph@@Udoug_lea_allocator@@@@AAEPAUTNode@1@ABQAVR_constant_table@@@Z ; FixedMAP<R_constant_table *,R_dsgraph::mapNormalStates,doug_lea_allocator>::Alloc
	sub	esi, ebx

; 146  : 				} else {
; 147  : 					TNode* N = CreateChild(node,k);

	mov	edx, eax

; 69   : 		size_t	PID	= size_t(parent-nodes);

	sar	esi, 2
	imul	eax, esi, -1227133513
	pop	esi
	pop	ebx

; 71   : 		parent		= nodes+PID;

	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax

; 148  : 					node->right = N;

	mov	eax, DWORD PTR [edi]
	pop	edi
	mov	DWORD PTR [eax+ecx*4+24], edx
	mov	eax, edx

; 155  : 		}
; 156  : 	}

	ret	4
$LN8@insert:

; 149  : 					return N;
; 150  : 				}
; 151  : 			} else return node;

	mov	eax, esi
	pop	esi
	pop	ebx
	pop	edi

; 155  : 		}
; 156  : 	}

	ret	4
$LN2@insert:

; 152  : 			
; 153  : 		} else {
; 154  : 			return Alloc(k);

	push	DWORD PTR _k$[esp]
	call	?Alloc@?$FixedMAP@PAVR_constant_table@@UmapNormalStates@R_dsgraph@@Udoug_lea_allocator@@@@AAEPAUTNode@1@ABQAVR_constant_table@@@Z ; FixedMAP<R_constant_table *,R_dsgraph::mapNormalStates,doug_lea_allocator>::Alloc
	pop	edi

; 155  : 		}
; 156  : 	}

	ret	4
?insert@?$FixedMAP@PAVR_constant_table@@UmapNormalStates@R_dsgraph@@Udoug_lea_allocator@@@@QAEPAUTNode@1@ABQAVR_constant_table@@@Z ENDP ; FixedMAP<R_constant_table *,R_dsgraph::mapNormalStates,doug_lea_allocator>::insert
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
;	COMDAT ?insert@?$FixedMAP@PAUIDirect3DStateBlock9@@UmapNormalTextures@R_dsgraph@@Udoug_lea_allocator@@@@QAEPAUTNode@1@ABQAUIDirect3DStateBlock9@@@Z
_TEXT	SEGMENT
_k$ = 8							; size = 4
?insert@?$FixedMAP@PAUIDirect3DStateBlock9@@UmapNormalTextures@R_dsgraph@@Udoug_lea_allocator@@@@QAEPAUTNode@1@ABQAUIDirect3DStateBlock9@@@Z PROC ; FixedMAP<IDirect3DStateBlock9 *,R_dsgraph::mapNormalTextures,doug_lea_allocator>::insert, COMDAT
; _this$ = ecx

; 128  : 	IC TNode*	insert(const K& k) {

	push	edi
	mov	edi, ecx

; 129  : 		if (pool) {

	cmp	DWORD PTR [edi+4], 0
	je	$LN2@insert

; 130  : 			TNode*	node = nodes;
; 131  : 
; 132  : 			once_more:
; 133  : 			if (k < node->key) {

	mov	ecx, DWORD PTR _k$[esp]
	push	ebx
	mov	ebx, DWORD PTR [edi]
	push	esi
	mov	edx, DWORD PTR [ecx]
	mov	esi, ebx
	npad	7
$once_more$25:
	cmp	edx, DWORD PTR [esi]
	jae	SHORT $LN4@insert

; 134  : 				if (node->left) {

	mov	eax, DWORD PTR [esi+20]
	test	eax, eax
	je	SHORT $LN6@insert

; 135  : 					node = node->left;

	mov	esi, eax

; 136  : 					goto once_more;

	jmp	SHORT $once_more$25
$LN4@insert:

; 141  : 				}
; 142  : 			} else if (k > node->key) {

	jbe	SHORT $LN8@insert

; 143  : 				if (node->right) {

	mov	eax, DWORD PTR [esi+24]
	test	eax, eax
	je	SHORT $LN10@insert

; 144  : 					node = node->right;

	mov	esi, eax

; 145  : 					goto once_more;

	jmp	SHORT $once_more$25
$LN6@insert:

; 70   : 		TNode*	N	= Alloc	(key);

	push	ecx
	mov	ecx, edi
	call	?Alloc@?$FixedMAP@PAUIDirect3DStateBlock9@@UmapNormalTextures@R_dsgraph@@Udoug_lea_allocator@@@@AAEPAUTNode@1@ABQAUIDirect3DStateBlock9@@@Z ; FixedMAP<IDirect3DStateBlock9 *,R_dsgraph::mapNormalTextures,doug_lea_allocator>::Alloc
	sub	esi, ebx

; 137  : 				} else {
; 138  : 					TNode* N = CreateChild(node,k);

	mov	edx, eax

; 69   : 		size_t	PID	= size_t(parent-nodes);

	sar	esi, 2
	imul	eax, esi, -1227133513
	pop	esi
	pop	ebx

; 71   : 		parent		= nodes+PID;

	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax

; 139  : 					node->left = N;

	mov	eax, DWORD PTR [edi]
	pop	edi
	mov	DWORD PTR [eax+ecx*4+20], edx

; 140  : 					return N;

	mov	eax, edx

; 155  : 		}
; 156  : 	}

	ret	4
$LN10@insert:

; 70   : 		TNode*	N	= Alloc	(key);

	push	ecx
	mov	ecx, edi
	call	?Alloc@?$FixedMAP@PAUIDirect3DStateBlock9@@UmapNormalTextures@R_dsgraph@@Udoug_lea_allocator@@@@AAEPAUTNode@1@ABQAUIDirect3DStateBlock9@@@Z ; FixedMAP<IDirect3DStateBlock9 *,R_dsgraph::mapNormalTextures,doug_lea_allocator>::Alloc
	sub	esi, ebx

; 146  : 				} else {
; 147  : 					TNode* N = CreateChild(node,k);

	mov	edx, eax

; 69   : 		size_t	PID	= size_t(parent-nodes);

	sar	esi, 2
	imul	eax, esi, -1227133513
	pop	esi
	pop	ebx

; 71   : 		parent		= nodes+PID;

	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax

; 148  : 					node->right = N;

	mov	eax, DWORD PTR [edi]
	pop	edi
	mov	DWORD PTR [eax+ecx*4+24], edx
	mov	eax, edx

; 155  : 		}
; 156  : 	}

	ret	4
$LN8@insert:

; 149  : 					return N;
; 150  : 				}
; 151  : 			} else return node;

	mov	eax, esi
	pop	esi
	pop	ebx
	pop	edi

; 155  : 		}
; 156  : 	}

	ret	4
$LN2@insert:

; 152  : 			
; 153  : 		} else {
; 154  : 			return Alloc(k);

	push	DWORD PTR _k$[esp]
	call	?Alloc@?$FixedMAP@PAUIDirect3DStateBlock9@@UmapNormalTextures@R_dsgraph@@Udoug_lea_allocator@@@@AAEPAUTNode@1@ABQAUIDirect3DStateBlock9@@@Z ; FixedMAP<IDirect3DStateBlock9 *,R_dsgraph::mapNormalTextures,doug_lea_allocator>::Alloc
	pop	edi

; 155  : 		}
; 156  : 	}

	ret	4
?insert@?$FixedMAP@PAUIDirect3DStateBlock9@@UmapNormalTextures@R_dsgraph@@Udoug_lea_allocator@@@@QAEPAUTNode@1@ABQAUIDirect3DStateBlock9@@@Z ENDP ; FixedMAP<IDirect3DStateBlock9 *,R_dsgraph::mapNormalTextures,doug_lea_allocator>::insert
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
;	COMDAT ?insert@?$FixedMAP@PAUSTextureList@@UmapNormalItems@R_dsgraph@@Udoug_lea_allocator@@@@QAEPAUTNode@1@ABQAUSTextureList@@@Z
_TEXT	SEGMENT
_k$ = 8							; size = 4
?insert@?$FixedMAP@PAUSTextureList@@UmapNormalItems@R_dsgraph@@Udoug_lea_allocator@@@@QAEPAUTNode@1@ABQAUSTextureList@@@Z PROC ; FixedMAP<STextureList *,R_dsgraph::mapNormalItems,doug_lea_allocator>::insert, COMDAT
; _this$ = ecx

; 128  : 	IC TNode*	insert(const K& k) {

	push	edi
	mov	edi, ecx

; 129  : 		if (pool) {

	cmp	DWORD PTR [edi+4], 0
	je	$LN2@insert

; 130  : 			TNode*	node = nodes;
; 131  : 
; 132  : 			once_more:
; 133  : 			if (k < node->key) {

	mov	ecx, DWORD PTR _k$[esp]
	push	ebx
	mov	ebx, DWORD PTR [edi]
	push	esi
	mov	edx, DWORD PTR [ecx]
	mov	esi, ebx
	npad	7
$once_more$25:
	cmp	edx, DWORD PTR [esi]
	jae	SHORT $LN4@insert

; 134  : 				if (node->left) {

	mov	eax, DWORD PTR [esi+20]
	test	eax, eax
	je	SHORT $LN6@insert

; 135  : 					node = node->left;

	mov	esi, eax

; 136  : 					goto once_more;

	jmp	SHORT $once_more$25
$LN4@insert:

; 141  : 				}
; 142  : 			} else if (k > node->key) {

	jbe	SHORT $LN8@insert

; 143  : 				if (node->right) {

	mov	eax, DWORD PTR [esi+24]
	test	eax, eax
	je	SHORT $LN10@insert

; 144  : 					node = node->right;

	mov	esi, eax

; 145  : 					goto once_more;

	jmp	SHORT $once_more$25
$LN6@insert:

; 70   : 		TNode*	N	= Alloc	(key);

	push	ecx
	mov	ecx, edi
	call	?Alloc@?$FixedMAP@PAUSTextureList@@UmapNormalItems@R_dsgraph@@Udoug_lea_allocator@@@@AAEPAUTNode@1@ABQAUSTextureList@@@Z ; FixedMAP<STextureList *,R_dsgraph::mapNormalItems,doug_lea_allocator>::Alloc
	sub	esi, ebx

; 137  : 				} else {
; 138  : 					TNode* N = CreateChild(node,k);

	mov	edx, eax

; 69   : 		size_t	PID	= size_t(parent-nodes);

	sar	esi, 2
	imul	eax, esi, -1227133513
	pop	esi
	pop	ebx

; 71   : 		parent		= nodes+PID;

	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax

; 139  : 					node->left = N;

	mov	eax, DWORD PTR [edi]
	pop	edi
	mov	DWORD PTR [eax+ecx*4+20], edx

; 140  : 					return N;

	mov	eax, edx

; 155  : 		}
; 156  : 	}

	ret	4
$LN10@insert:

; 70   : 		TNode*	N	= Alloc	(key);

	push	ecx
	mov	ecx, edi
	call	?Alloc@?$FixedMAP@PAUSTextureList@@UmapNormalItems@R_dsgraph@@Udoug_lea_allocator@@@@AAEPAUTNode@1@ABQAUSTextureList@@@Z ; FixedMAP<STextureList *,R_dsgraph::mapNormalItems,doug_lea_allocator>::Alloc
	sub	esi, ebx

; 146  : 				} else {
; 147  : 					TNode* N = CreateChild(node,k);

	mov	edx, eax

; 69   : 		size_t	PID	= size_t(parent-nodes);

	sar	esi, 2
	imul	eax, esi, -1227133513
	pop	esi
	pop	ebx

; 71   : 		parent		= nodes+PID;

	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax

; 148  : 					node->right = N;

	mov	eax, DWORD PTR [edi]
	pop	edi
	mov	DWORD PTR [eax+ecx*4+24], edx
	mov	eax, edx

; 155  : 		}
; 156  : 	}

	ret	4
$LN8@insert:

; 149  : 					return N;
; 150  : 				}
; 151  : 			} else return node;

	mov	eax, esi
	pop	esi
	pop	ebx
	pop	edi

; 155  : 		}
; 156  : 	}

	ret	4
$LN2@insert:

; 152  : 			
; 153  : 		} else {
; 154  : 			return Alloc(k);

	push	DWORD PTR _k$[esp]
	call	?Alloc@?$FixedMAP@PAUSTextureList@@UmapNormalItems@R_dsgraph@@Udoug_lea_allocator@@@@AAEPAUTNode@1@ABQAUSTextureList@@@Z ; FixedMAP<STextureList *,R_dsgraph::mapNormalItems,doug_lea_allocator>::Alloc
	pop	edi

; 155  : 		}
; 156  : 	}

	ret	4
?insert@?$FixedMAP@PAUSTextureList@@UmapNormalItems@R_dsgraph@@Udoug_lea_allocator@@@@QAEPAUTNode@1@ABQAUSTextureList@@@Z ENDP ; FixedMAP<STextureList *,R_dsgraph::mapNormalItems,doug_lea_allocator>::insert
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?push_back@?$vector@U_NormalItem@R_dsgraph@@V?$doug_lea_alloc@U_NormalItem@R_dsgraph@@@@@std@@QAEXABU_NormalItem@R_dsgraph@@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?push_back@?$vector@U_NormalItem@R_dsgraph@@V?$doug_lea_alloc@U_NormalItem@R_dsgraph@@@@@std@@QAEXABU_NormalItem@R_dsgraph@@@Z PROC ; std::vector<R_dsgraph::_NormalItem,doug_lea_alloc<R_dsgraph::_NormalItem> >::push_back, COMDAT
; _this$ = ecx

; 742  :     _CONSTEXPR20_CONTAINER void push_back(const _Ty& _Val) { // insert element at end, provide strong guarantee

	push	esi

; 730  :         if (_Mylast != _My_data._Myend) {

	mov	esi, DWORD PTR [ecx+4]
	cmp	esi, DWORD PTR [ecx+8]
	je	SHORT $LN4@push_back

; 713  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

	mov	eax, DWORD PTR __Val$[esp]
	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR [esi], edx
	mov	DWORD PTR [esi+4], eax

; 714  :         _Orphan_range(_Mylast, _Mylast);
; 715  :         _Ty& _Result = *_Mylast;
; 716  :         ++_Mylast;

	add	DWORD PTR [ecx+4], 8
	pop	esi

; 743  :         emplace_back(_Val);
; 744  :     }

	ret	4
$LN4@push_back:

; 734  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	push	DWORD PTR __Val$[esp]
	push	esi
	call	??$_Emplace_reallocate@ABU_NormalItem@R_dsgraph@@@?$vector@U_NormalItem@R_dsgraph@@V?$doug_lea_alloc@U_NormalItem@R_dsgraph@@@@@std@@QAEPAU_NormalItem@R_dsgraph@@QAU23@ABU23@@Z ; std::vector<R_dsgraph::_NormalItem,doug_lea_alloc<R_dsgraph::_NormalItem> >::_Emplace_reallocate<R_dsgraph::_NormalItem const &>
	pop	esi

; 743  :         emplace_back(_Val);
; 744  :     }

	ret	4
?push_back@?$vector@U_NormalItem@R_dsgraph@@V?$doug_lea_alloc@U_NormalItem@R_dsgraph@@@@@std@@QAEXABU_NormalItem@R_dsgraph@@@Z ENDP ; std::vector<R_dsgraph::_NormalItem,doug_lea_alloc<R_dsgraph::_NormalItem> >::push_back
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??$emplace_back@ABU_NormalItem@R_dsgraph@@@?$vector@U_NormalItem@R_dsgraph@@V?$doug_lea_alloc@U_NormalItem@R_dsgraph@@@@@std@@QAE?A_TABU_NormalItem@R_dsgraph@@@Z
_TEXT	SEGMENT
_<_Val_0>$ = 8						; size = 4
??$emplace_back@ABU_NormalItem@R_dsgraph@@@?$vector@U_NormalItem@R_dsgraph@@V?$doug_lea_alloc@U_NormalItem@R_dsgraph@@@@@std@@QAE?A_TABU_NormalItem@R_dsgraph@@@Z PROC ; std::vector<R_dsgraph::_NormalItem,doug_lea_alloc<R_dsgraph::_NormalItem> >::emplace_back<R_dsgraph::_NormalItem const &>, COMDAT
; _this$ = ecx

; 726  :     _CONSTEXPR20_CONTAINER decltype(auto) emplace_back(_Valty&&... _Val) {

	push	esi

; 727  :         // insert by perfectly forwarding into element at end, provide strong guarantee
; 728  :         auto& _My_data   = _Mypair._Myval2;
; 729  :         pointer& _Mylast = _My_data._Mylast;
; 730  :         if (_Mylast != _My_data._Myend) {

	mov	esi, DWORD PTR [ecx+4]
	cmp	esi, DWORD PTR [ecx+8]
	je	SHORT $LN2@emplace_ba

; 713  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

	mov	eax, DWORD PTR _<_Val_0>$[esp]
	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR [esi], edx
	mov	DWORD PTR [esi+4], eax

; 714  :         _Orphan_range(_Mylast, _Mylast);
; 715  :         _Ty& _Result = *_Mylast;
; 716  :         ++_Mylast;

	add	DWORD PTR [ecx+4], 8
	pop	esi

; 735  : #if _HAS_CXX17
; 736  :         return _Result;
; 737  : #else // ^^^ _HAS_CXX17 ^^^ // vvv !_HAS_CXX17 vvv
; 738  :         (void) _Result;
; 739  : #endif // _HAS_CXX17
; 740  :     }

	ret	4
$LN2@emplace_ba:

; 731  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);
; 732  :         }
; 733  : 
; 734  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	push	DWORD PTR _<_Val_0>$[esp]
	push	esi
	call	??$_Emplace_reallocate@ABU_NormalItem@R_dsgraph@@@?$vector@U_NormalItem@R_dsgraph@@V?$doug_lea_alloc@U_NormalItem@R_dsgraph@@@@@std@@QAEPAU_NormalItem@R_dsgraph@@QAU23@ABU23@@Z ; std::vector<R_dsgraph::_NormalItem,doug_lea_alloc<R_dsgraph::_NormalItem> >::_Emplace_reallocate<R_dsgraph::_NormalItem const &>
	pop	esi

; 735  : #if _HAS_CXX17
; 736  :         return _Result;
; 737  : #else // ^^^ _HAS_CXX17 ^^^ // vvv !_HAS_CXX17 vvv
; 738  :         (void) _Result;
; 739  : #endif // _HAS_CXX17
; 740  :     }

	ret	4
??$emplace_back@ABU_NormalItem@R_dsgraph@@@?$vector@U_NormalItem@R_dsgraph@@V?$doug_lea_alloc@U_NormalItem@R_dsgraph@@@@@std@@QAE?A_TABU_NormalItem@R_dsgraph@@@Z ENDP ; std::vector<R_dsgraph::_NormalItem,doug_lea_alloc<R_dsgraph::_NormalItem> >::emplace_back<R_dsgraph::_NormalItem const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??$_Emplace_back_with_unused_capacity@ABU_NormalItem@R_dsgraph@@@?$vector@U_NormalItem@R_dsgraph@@V?$doug_lea_alloc@U_NormalItem@R_dsgraph@@@@@std@@AAE?A_TABU_NormalItem@R_dsgraph@@@Z
_TEXT	SEGMENT
_<_Val_0>$ = 8						; size = 4
??$_Emplace_back_with_unused_capacity@ABU_NormalItem@R_dsgraph@@@?$vector@U_NormalItem@R_dsgraph@@V?$doug_lea_alloc@U_NormalItem@R_dsgraph@@@@@std@@AAE?A_TABU_NormalItem@R_dsgraph@@@Z PROC ; std::vector<R_dsgraph::_NormalItem,doug_lea_alloc<R_dsgraph::_NormalItem> >::_Emplace_back_with_unused_capacity<R_dsgraph::_NormalItem const &>, COMDAT
; _this$ = ecx

; 709  :         // insert by perfectly forwarding into element at end, provide strong guarantee
; 710  :         auto& _My_data   = _Mypair._Myval2;
; 711  :         pointer& _Mylast = _My_data._Mylast;
; 712  :         _STL_INTERNAL_CHECK(_Mylast != _My_data._Myend); // check that we have unused capacity
; 713  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

	mov	eax, DWORD PTR _<_Val_0>$[esp-4]
	push	esi
	mov	esi, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax], edx
	mov	DWORD PTR [eax+4], esi

; 714  :         _Orphan_range(_Mylast, _Mylast);
; 715  :         _Ty& _Result = *_Mylast;
; 716  :         ++_Mylast;

	add	DWORD PTR [ecx+4], 8
	pop	esi

; 717  : #if _HAS_CXX17
; 718  :         return _Result;
; 719  : #else // ^^^ _HAS_CXX17 ^^^ // vvv !_HAS_CXX17 vvv
; 720  :         (void) _Result;
; 721  : #endif // _HAS_CXX17
; 722  :     }

	ret	4
??$_Emplace_back_with_unused_capacity@ABU_NormalItem@R_dsgraph@@@?$vector@U_NormalItem@R_dsgraph@@V?$doug_lea_alloc@U_NormalItem@R_dsgraph@@@@@std@@AAE?A_TABU_NormalItem@R_dsgraph@@@Z ENDP ; std::vector<R_dsgraph::_NormalItem,doug_lea_alloc<R_dsgraph::_NormalItem> >::_Emplace_back_with_unused_capacity<R_dsgraph::_NormalItem const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\FixedVector.h
;	COMDAT ?front@?$svector@V?$resptr_core@USPass@@V?$resptr_base@USPass@@@@@@$01@@QAEAAV?$resptr_core@USPass@@V?$resptr_base@USPass@@@@@@XZ
_TEXT	SEGMENT
?front@?$svector@V?$resptr_core@USPass@@V?$resptr_base@USPass@@@@@@$01@@QAEAAV?$resptr_core@USPass@@V?$resptr_base@USPass@@@@@@XZ PROC ; svector<resptr_core<SPass,resptr_base<SPass> >,2>::front, COMDAT
; _this$ = ecx

; 41   : 	IC reference		front()				{ return array[0];						}

	mov	eax, ecx
	ret	0
?front@?$svector@V?$resptr_core@USPass@@V?$resptr_base@USPass@@@@@@$01@@QAEAAV?$resptr_core@USPass@@V?$resptr_base@USPass@@@@@@XZ ENDP ; svector<resptr_core<SPass,resptr_base<SPass> >,2>::front
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
;	COMDAT ?_get@?$resptr_base@USTextureList@@@@QBEPAUSTextureList@@XZ
_TEXT	SEGMENT
?_get@?$resptr_base@USTextureList@@@@QBEPAUSTextureList@@XZ PROC ; resptr_base<STextureList>::_get, COMDAT
; _this$ = ecx

; 48   : 	ICF		T *			_get	() const							{	return p_;																					}

	mov	eax, DWORD PTR [ecx]
	ret	0
?_get@?$resptr_base@USTextureList@@@@QBEPAUSTextureList@@XZ ENDP ; resptr_base<STextureList>::_get
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
;	COMDAT ?_get@?$resptr_base@VR_constant_table@@@@QBEPAVR_constant_table@@XZ
_TEXT	SEGMENT
?_get@?$resptr_base@VR_constant_table@@@@QBEPAVR_constant_table@@XZ PROC ; resptr_base<R_constant_table>::_get, COMDAT
; _this$ = ecx

; 48   : 	ICF		T *			_get	() const							{	return p_;																					}

	mov	eax, DWORD PTR [ecx]
	ret	0
?_get@?$resptr_base@VR_constant_table@@@@QBEPAVR_constant_table@@XZ ENDP ; resptr_base<R_constant_table>::_get
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
;	COMDAT ?CreateChild@?$FixedMAP@MU_LodItem@R_dsgraph@@Udoug_lea_allocator@@@@AAEPAUTNode@1@AAPAU21@ABM@Z
_TEXT	SEGMENT
_parent$ = 8						; size = 4
_key$ = 12						; size = 4
?CreateChild@?$FixedMAP@MU_LodItem@R_dsgraph@@Udoug_lea_allocator@@@@AAEPAUTNode@1@AAPAU21@ABM@Z PROC ; FixedMAP<float,R_dsgraph::_LodItem,doug_lea_allocator>::CreateChild, COMDAT
; _this$ = ecx

; 68   : 	{

	push	ebx

; 69   : 		size_t	PID	= size_t(parent-nodes);

	mov	ebx, DWORD PTR _parent$[esp]
	push	esi
	push	edi

; 70   : 		TNode*	N	= Alloc	(key);

	push	DWORD PTR _key$[esp+8]
	mov	eax, DWORD PTR [ebx]
	mov	edi, ecx
	sub	eax, DWORD PTR [edi]
	sar	eax, 2
	imul	esi, eax, -858993459
	call	?Alloc@?$FixedMAP@MU_LodItem@R_dsgraph@@Udoug_lea_allocator@@@@AAEPAUTNode@1@ABM@Z ; FixedMAP<float,R_dsgraph::_LodItem,doug_lea_allocator>::Alloc

; 71   : 		parent		= nodes+PID;

	mov	ecx, DWORD PTR [edi]
	lea	edx, DWORD PTR [esi+esi*4]

; 72   : 		return	N;

	pop	edi
	pop	esi
	lea	ecx, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR [ebx], ecx
	pop	ebx

; 73   : 	}

	ret	8
?CreateChild@?$FixedMAP@MU_LodItem@R_dsgraph@@Udoug_lea_allocator@@@@AAEPAUTNode@1@AAPAU21@ABM@Z ENDP ; FixedMAP<float,R_dsgraph::_LodItem,doug_lea_allocator>::CreateChild
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
;	COMDAT ?Alloc@?$FixedMAP@MU_LodItem@R_dsgraph@@Udoug_lea_allocator@@@@AAEPAUTNode@1@ABM@Z
_TEXT	SEGMENT
tv392 = -8						; size = 4
_newLimit$1$ = -4					; size = 4
_key$ = 8						; size = 4
?Alloc@?$FixedMAP@MU_LodItem@R_dsgraph@@Udoug_lea_allocator@@@@AAEPAUTNode@1@ABM@Z PROC ; FixedMAP<float,R_dsgraph::_LodItem,doug_lea_allocator>::Alloc, COMDAT
; _this$ = ecx

; 59   : 	{

	sub	esp, 8
	push	ebx
	push	edi
	mov	edi, ecx

; 60   : 		if (pool==limit) Realloc();

	mov	eax, DWORD PTR [edi+4]
	mov	ecx, DWORD PTR [edi+8]
	cmp	eax, ecx
	jne	$LN33@Alloc

; 29   : 		u32	newLimit = limit + SG_REALLOC_ADVANCE;

	push	ebp
	lea	ebp, DWORD PTR [ecx+64]
	push	esi

; 30   : 		VERIFY(newLimit%SG_REALLOC_ADVANCE == 0);
; 31   : 		TNode*	newNodes = (TNode*)allocator::alloc(sizeof(TNode)*newLimit);

	lea	esi, DWORD PTR [ebp*4]
	mov	DWORD PTR _newLimit$1$[esp+24], ebp
	add	esi, ebp
	shl	esi, 2
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h

; 51   : 		static	void	*alloc		(const u32 &n)	{	return dlmalloc((u32)n);	}

	mov	ecx, esi
	call	_dlmalloc
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h

; 34   : 		ZeroMemory(newNodes, Size(newLimit));

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	mov	ebx, eax
	push	esi
	push	0
	push	ebx
	mov	ecx, DWORD PTR [ecx+12]
	call	ecx

; 35   : 		if (limit) CopyMemory	(newNodes, nodes, Size(limit));

	mov	eax, DWORD PTR [edi+8]
	test	eax, eax
	je	SHORT $LN17@Alloc

; 25   : 	{	return Count*sizeof(TNode);	}

	lea	eax, DWORD PTR [eax+eax*4]
	shl	eax, 2

; 35   : 		if (limit) CopyMemory	(newNodes, nodes, Size(limit));

	push	eax
	push	DWORD PTR [edi]
	push	ebx
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN17@Alloc:

; 36   : 
; 37   : 		for (u32 I=0; I<pool; I++)

	mov	eax, DWORD PTR [edi+4]
	xor	esi, esi
	test	eax, eax
	je	SHORT $LN12@Alloc
	mov	ecx, -16				; fffffff0H
	lea	edx, DWORD PTR [ebx+16]
	sub	ecx, ebx
	mov	DWORD PTR tv392[esp+24], ecx
$LL13@Alloc:

; 38   : 		{
; 39   : 			VERIFY	(nodes);
; 40   : 			TNode*	Nold	= nodes	+ I;

	mov	ebp, DWORD PTR [edi]
	add	ecx, edx
	add	ecx, ebp

; 41   : 			TNode*	Nnew	= newNodes + I;
; 42   : 
; 43   : 			if (Nold->left) {

	mov	eax, DWORD PTR [ecx+12]
	test	eax, eax
	je	SHORT $LN35@Alloc

; 44   : 				size_t	Lid		= Nold->left  - nodes;

	sub	eax, ebp
	sar	eax, 2
	imul	eax, eax, -858993459

; 45   : 				Nnew->left		= newNodes + Lid;

	lea	eax, DWORD PTR [eax+eax*4]
	lea	eax, DWORD PTR [ebx+eax*4]
	mov	DWORD PTR [edx-4], eax
	mov	ebp, DWORD PTR [edi]
$LN35@Alloc:

; 46   : 			}
; 47   : 			if (Nold->right) {

	mov	eax, DWORD PTR [ecx+16]
	test	eax, eax
	je	SHORT $LN11@Alloc

; 48   : 				size_t	Rid		= Nold->right - nodes;

	sub	eax, ebp
	sar	eax, 2
	imul	eax, eax, -858993459

; 49   : 				Nnew->right		= newNodes + Rid;

	lea	eax, DWORD PTR [eax+eax*4]
	lea	eax, DWORD PTR [ebx+eax*4]
	mov	DWORD PTR [edx], eax
$LN11@Alloc:

; 36   : 
; 37   : 		for (u32 I=0; I<pool; I++)

	mov	eax, DWORD PTR [edi+4]
	inc	esi
	mov	ecx, DWORD PTR tv392[esp+24]
	add	edx, 20					; 00000014H
	cmp	esi, eax
	jb	SHORT $LL13@Alloc
	mov	ebp, DWORD PTR _newLimit$1$[esp+24]
$LN12@Alloc:

; 50   : 			}
; 51   : 		}
; 52   : 		if (nodes) allocator::dealloc(nodes);

	mov	ecx, DWORD PTR [edi]
	test	ecx, ecx
	je	SHORT $LN20@Alloc
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h

; 53   : 		static	void	dealloc		(T *&p)			{	dlfree(p);	p=0;			}

	call	_dlfree
	mov	eax, DWORD PTR [edi+4]
$LN20@Alloc:
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h

; 55   : 		limit = newLimit;

	pop	esi
	mov	DWORD PTR [edi+8], ebp
	mov	DWORD PTR [edi], ebx
	pop	ebp
	jmp	SHORT $LN2@Alloc
$LN33@Alloc:
	mov	ebx, DWORD PTR [edi]
$LN2@Alloc:

; 61   : 		TNode *node = nodes + pool;
; 62   : 		node->key	= key;

	mov	ecx, DWORD PTR _key$[esp+12]
	lea	eax, DWORD PTR [eax+eax*4]
	lea	eax, DWORD PTR [ebx+eax*4]

; 63   : 		node->right = node->left = 0;

	mov	DWORD PTR [eax+12], 0
	mov	DWORD PTR [eax+16], 0
	fld	DWORD PTR [ecx]
	fstp	DWORD PTR [eax]

; 64   : 		pool++		;

	inc	DWORD PTR [edi+4]

; 65   : 		return node	;

	pop	edi
	pop	ebx

; 66   : 	}

	add	esp, 8
	ret	4
?Alloc@?$FixedMAP@MU_LodItem@R_dsgraph@@Udoug_lea_allocator@@@@AAEPAUTNode@1@ABM@Z ENDP ; FixedMAP<float,R_dsgraph::_LodItem,doug_lea_allocator>::Alloc
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
;	COMDAT ?CreateChild@?$FixedMAP@MU_MatrixItemS@R_dsgraph@@Udoug_lea_allocator@@@@AAEPAUTNode@1@AAPAU21@ABM@Z
_TEXT	SEGMENT
_parent$ = 8						; size = 4
_key$ = 12						; size = 4
?CreateChild@?$FixedMAP@MU_MatrixItemS@R_dsgraph@@Udoug_lea_allocator@@@@AAEPAUTNode@1@AAPAU21@ABM@Z PROC ; FixedMAP<float,R_dsgraph::_MatrixItemS,doug_lea_allocator>::CreateChild, COMDAT
; _this$ = ecx

; 68   : 	{

	push	ebx
	push	esi
	push	edi

; 69   : 		size_t	PID	= size_t(parent-nodes);

	mov	edi, DWORD PTR _parent$[esp+8]
	mov	ebx, ecx

; 70   : 		TNode*	N	= Alloc	(key);

	push	DWORD PTR _key$[esp+8]
	mov	eax, DWORD PTR [edi]
	sub	eax, DWORD PTR [ebx]
	sar	eax, 2
	imul	esi, eax, -373475417
	call	?Alloc@?$FixedMAP@MU_MatrixItemS@R_dsgraph@@Udoug_lea_allocator@@@@AAEPAUTNode@1@ABM@Z ; FixedMAP<float,R_dsgraph::_MatrixItemS,doug_lea_allocator>::Alloc

; 71   : 		parent		= nodes+PID;

	imul	ecx, esi, 92
	add	ecx, DWORD PTR [ebx]
	mov	DWORD PTR [edi], ecx

; 72   : 		return	N;

	pop	edi
	pop	esi
	pop	ebx

; 73   : 	}

	ret	8
?CreateChild@?$FixedMAP@MU_MatrixItemS@R_dsgraph@@Udoug_lea_allocator@@@@AAEPAUTNode@1@AAPAU21@ABM@Z ENDP ; FixedMAP<float,R_dsgraph::_MatrixItemS,doug_lea_allocator>::CreateChild
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
;	COMDAT ?Alloc@?$FixedMAP@MU_MatrixItemS@R_dsgraph@@Udoug_lea_allocator@@@@AAEPAUTNode@1@ABM@Z
_TEXT	SEGMENT
tv427 = -8						; size = 4
_newLimit$1$ = -4					; size = 4
_key$ = 8						; size = 4
?Alloc@?$FixedMAP@MU_MatrixItemS@R_dsgraph@@Udoug_lea_allocator@@@@AAEPAUTNode@1@ABM@Z PROC ; FixedMAP<float,R_dsgraph::_MatrixItemS,doug_lea_allocator>::Alloc, COMDAT
; _this$ = ecx

; 59   : 	{

	sub	esp, 8
	push	ebx
	push	edi
	mov	edi, ecx

; 60   : 		if (pool==limit) Realloc();

	mov	eax, DWORD PTR [edi+4]
	mov	ecx, DWORD PTR [edi+8]
	cmp	eax, ecx
	jne	$LN33@Alloc

; 29   : 		u32	newLimit = limit + SG_REALLOC_ADVANCE;

	push	ebp
	lea	ebp, DWORD PTR [ecx+64]
	push	esi

; 30   : 		VERIFY(newLimit%SG_REALLOC_ADVANCE == 0);
; 31   : 		TNode*	newNodes = (TNode*)allocator::alloc(sizeof(TNode)*newLimit);

	imul	esi, ebp, 92
	mov	DWORD PTR _newLimit$1$[esp+24], ebp
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h

; 51   : 		static	void	*alloc		(const u32 &n)	{	return dlmalloc((u32)n);	}

	mov	ecx, esi
	call	_dlmalloc
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h

; 34   : 		ZeroMemory(newNodes, Size(newLimit));

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	mov	ebx, eax
	push	esi
	push	0
	push	ebx
	mov	ecx, DWORD PTR [ecx+12]
	call	ecx

; 35   : 		if (limit) CopyMemory	(newNodes, nodes, Size(limit));

	mov	eax, DWORD PTR [edi+8]
	test	eax, eax
	je	SHORT $LN17@Alloc

; 25   : 	{	return Count*sizeof(TNode);	}

	imul	eax, eax, 92

; 35   : 		if (limit) CopyMemory	(newNodes, nodes, Size(limit));

	push	eax
	push	DWORD PTR [edi]
	push	ebx
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN17@Alloc:

; 36   : 
; 37   : 		for (u32 I=0; I<pool; I++)

	mov	eax, DWORD PTR [edi+4]
	xor	esi, esi
	test	eax, eax
	je	SHORT $LN12@Alloc
	mov	edx, -88				; ffffffa8H
	lea	ecx, DWORD PTR [ebx+88]
	sub	edx, ebx
	mov	DWORD PTR tv427[esp+24], edx
$LL13@Alloc:

; 38   : 		{
; 39   : 			VERIFY	(nodes);
; 40   : 			TNode*	Nold	= nodes	+ I;

	mov	ebp, DWORD PTR [edi]
	add	edx, ecx
	add	edx, ebp

; 41   : 			TNode*	Nnew	= newNodes + I;
; 42   : 
; 43   : 			if (Nold->left) {

	mov	eax, DWORD PTR [edx+84]
	test	eax, eax
	je	SHORT $LN35@Alloc

; 44   : 				size_t	Lid		= Nold->left  - nodes;

	sub	eax, ebp
	sar	eax, 2
	imul	eax, eax, -373475417

; 45   : 				Nnew->left		= newNodes + Lid;

	imul	eax, eax, 92
	add	eax, ebx
	mov	DWORD PTR [ecx-4], eax
	mov	ebp, DWORD PTR [edi]
$LN35@Alloc:

; 46   : 			}
; 47   : 			if (Nold->right) {

	mov	eax, DWORD PTR [edx+88]
	test	eax, eax
	je	SHORT $LN11@Alloc

; 48   : 				size_t	Rid		= Nold->right - nodes;

	sub	eax, ebp
	sar	eax, 2
	imul	eax, eax, -373475417

; 49   : 				Nnew->right		= newNodes + Rid;

	imul	eax, eax, 92
	add	eax, ebx
	mov	DWORD PTR [ecx], eax
$LN11@Alloc:

; 36   : 
; 37   : 		for (u32 I=0; I<pool; I++)

	mov	eax, DWORD PTR [edi+4]
	inc	esi
	mov	edx, DWORD PTR tv427[esp+24]
	add	ecx, 92					; 0000005cH
	cmp	esi, eax
	jb	SHORT $LL13@Alloc
	mov	ebp, DWORD PTR _newLimit$1$[esp+24]
$LN12@Alloc:

; 50   : 			}
; 51   : 		}
; 52   : 		if (nodes) allocator::dealloc(nodes);

	mov	ecx, DWORD PTR [edi]
	test	ecx, ecx
	je	SHORT $LN20@Alloc
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h

; 53   : 		static	void	dealloc		(T *&p)			{	dlfree(p);	p=0;			}

	call	_dlfree
	mov	eax, DWORD PTR [edi+4]
$LN20@Alloc:
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h

; 55   : 		limit = newLimit;

	pop	esi
	mov	DWORD PTR [edi+8], ebp
	mov	DWORD PTR [edi], ebx
	pop	ebp
	jmp	SHORT $LN2@Alloc
$LN33@Alloc:
	mov	ebx, DWORD PTR [edi]
$LN2@Alloc:

; 61   : 		TNode *node = nodes + pool;
; 62   : 		node->key	= key;

	mov	ecx, DWORD PTR _key$[esp+12]
	imul	eax, eax, 92
	add	eax, ebx
	fld	DWORD PTR [ecx]
	fstp	DWORD PTR [eax]

; 63   : 		node->right = node->left = 0;

	mov	DWORD PTR [eax+84], 0
	mov	DWORD PTR [eax+88], 0

; 64   : 		pool++		;

	inc	DWORD PTR [edi+4]

; 65   : 		return node	;

	pop	edi
	pop	ebx

; 66   : 	}

	add	esp, 8
	ret	4
?Alloc@?$FixedMAP@MU_MatrixItemS@R_dsgraph@@Udoug_lea_allocator@@@@AAEPAUTNode@1@ABM@Z ENDP ; FixedMAP<float,R_dsgraph::_MatrixItemS,doug_lea_allocator>::Alloc
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
;	COMDAT ?CreateChild@?$FixedMAP@PAUIDirect3DVertexShader9@@UmapMatrixPS@R_dsgraph@@Udoug_lea_allocator@@@@AAEPAUTNode@1@AAPAU21@ABQAUIDirect3DVertexShader9@@@Z
_TEXT	SEGMENT
_parent$ = 8						; size = 4
_key$ = 12						; size = 4
?CreateChild@?$FixedMAP@PAUIDirect3DVertexShader9@@UmapMatrixPS@R_dsgraph@@Udoug_lea_allocator@@@@AAEPAUTNode@1@AAPAU21@ABQAUIDirect3DVertexShader9@@@Z PROC ; FixedMAP<IDirect3DVertexShader9 *,R_dsgraph::mapMatrixPS,doug_lea_allocator>::CreateChild, COMDAT
; _this$ = ecx

; 68   : 	{

	push	ebx

; 69   : 		size_t	PID	= size_t(parent-nodes);

	mov	ebx, DWORD PTR _parent$[esp]
	push	esi
	push	edi

; 70   : 		TNode*	N	= Alloc	(key);

	push	DWORD PTR _key$[esp+8]
	mov	eax, DWORD PTR [ebx]
	mov	edi, ecx
	sub	eax, DWORD PTR [edi]
	sar	eax, 2
	imul	esi, eax, -1227133513
	call	?Alloc@?$FixedMAP@PAUIDirect3DVertexShader9@@UmapMatrixPS@R_dsgraph@@Udoug_lea_allocator@@@@AAEPAUTNode@1@ABQAUIDirect3DVertexShader9@@@Z ; FixedMAP<IDirect3DVertexShader9 *,R_dsgraph::mapMatrixPS,doug_lea_allocator>::Alloc

; 71   : 		parent		= nodes+PID;

	mov	ecx, DWORD PTR [edi]
	lea	edx, DWORD PTR [esi*8]
	sub	edx, esi

; 72   : 		return	N;

	pop	edi
	pop	esi
	lea	ecx, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR [ebx], ecx
	pop	ebx

; 73   : 	}

	ret	8
?CreateChild@?$FixedMAP@PAUIDirect3DVertexShader9@@UmapMatrixPS@R_dsgraph@@Udoug_lea_allocator@@@@AAEPAUTNode@1@AAPAU21@ABQAUIDirect3DVertexShader9@@@Z ENDP ; FixedMAP<IDirect3DVertexShader9 *,R_dsgraph::mapMatrixPS,doug_lea_allocator>::CreateChild
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
;	COMDAT ?Alloc@?$FixedMAP@PAUIDirect3DVertexShader9@@UmapMatrixPS@R_dsgraph@@Udoug_lea_allocator@@@@AAEPAUTNode@1@ABQAUIDirect3DVertexShader9@@@Z
_TEXT	SEGMENT
tv392 = -8						; size = 4
_newLimit$1$ = -4					; size = 4
_key$ = 8						; size = 4
?Alloc@?$FixedMAP@PAUIDirect3DVertexShader9@@UmapMatrixPS@R_dsgraph@@Udoug_lea_allocator@@@@AAEPAUTNode@1@ABQAUIDirect3DVertexShader9@@@Z PROC ; FixedMAP<IDirect3DVertexShader9 *,R_dsgraph::mapMatrixPS,doug_lea_allocator>::Alloc, COMDAT
; _this$ = ecx

; 59   : 	{

	sub	esp, 8
	push	ebp
	push	edi
	mov	edi, ecx

; 60   : 		if (pool==limit) Realloc();

	mov	ecx, DWORD PTR [edi+4]
	mov	eax, DWORD PTR [edi+8]
	cmp	ecx, eax
	jne	$LN33@Alloc

; 29   : 		u32	newLimit = limit + SG_REALLOC_ADVANCE;

	add	eax, 64					; 00000040H
	push	ebx
	push	esi
	mov	DWORD PTR _newLimit$1$[esp+24], eax

; 30   : 		VERIFY(newLimit%SG_REALLOC_ADVANCE == 0);
; 31   : 		TNode*	newNodes = (TNode*)allocator::alloc(sizeof(TNode)*newLimit);

	lea	esi, DWORD PTR [eax*8]
	sub	esi, eax
	shl	esi, 2
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h

; 51   : 		static	void	*alloc		(const u32 &n)	{	return dlmalloc((u32)n);	}

	mov	ecx, esi
	call	_dlmalloc
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h

; 34   : 		ZeroMemory(newNodes, Size(newLimit));

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	mov	ebp, eax
	push	esi
	push	0
	push	ebp
	mov	ecx, DWORD PTR [ecx+12]
	call	ecx

; 35   : 		if (limit) CopyMemory	(newNodes, nodes, Size(limit));

	mov	ecx, DWORD PTR [edi+8]
	test	ecx, ecx
	je	SHORT $LN17@Alloc

; 25   : 	{	return Count*sizeof(TNode);	}

	lea	eax, DWORD PTR [ecx*8]
	sub	eax, ecx
	shl	eax, 2

; 35   : 		if (limit) CopyMemory	(newNodes, nodes, Size(limit));

	push	eax
	push	DWORD PTR [edi]
	push	ebp
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN17@Alloc:

; 36   : 
; 37   : 		for (u32 I=0; I<pool; I++)

	mov	ecx, DWORD PTR [edi+4]
	xor	ebx, ebx
	test	ecx, ecx
	je	SHORT $LN12@Alloc
	mov	eax, -24				; ffffffe8H
	lea	esi, DWORD PTR [ebp+24]
	sub	eax, ebp
	mov	DWORD PTR tv392[esp+24], eax
$LL13@Alloc:

; 38   : 		{
; 39   : 			VERIFY	(nodes);
; 40   : 			TNode*	Nold	= nodes	+ I;

	mov	ecx, DWORD PTR [edi]
	lea	edx, DWORD PTR [eax+esi]
	add	edx, ecx

; 41   : 			TNode*	Nnew	= newNodes + I;
; 42   : 
; 43   : 			if (Nold->left) {

	mov	eax, DWORD PTR [edx+20]
	test	eax, eax
	je	SHORT $LN35@Alloc

; 44   : 				size_t	Lid		= Nold->left  - nodes;

	sub	eax, ecx
	sar	eax, 2
	imul	ecx, eax, -1227133513

; 45   : 				Nnew->left		= newNodes + Lid;

	lea	eax, DWORD PTR [ecx*8]
	sub	eax, ecx
	lea	eax, DWORD PTR [eax*4]
	add	eax, ebp
	mov	DWORD PTR [esi-4], eax
	mov	ecx, DWORD PTR [edi]
$LN35@Alloc:

; 46   : 			}
; 47   : 			if (Nold->right) {

	mov	eax, DWORD PTR [edx+24]
	test	eax, eax
	je	SHORT $LN11@Alloc

; 48   : 				size_t	Rid		= Nold->right - nodes;

	sub	eax, ecx
	sar	eax, 2
	imul	ecx, eax, -1227133513

; 49   : 				Nnew->right		= newNodes + Rid;

	lea	eax, DWORD PTR [ecx*8]
	sub	eax, ecx
	lea	eax, DWORD PTR [eax*4]
	add	eax, ebp
	mov	DWORD PTR [esi], eax
$LN11@Alloc:

; 36   : 
; 37   : 		for (u32 I=0; I<pool; I++)

	mov	ecx, DWORD PTR [edi+4]
	inc	ebx
	mov	eax, DWORD PTR tv392[esp+24]
	add	esi, 28					; 0000001cH
	cmp	ebx, ecx
	jb	SHORT $LL13@Alloc
$LN12@Alloc:

; 50   : 			}
; 51   : 		}
; 52   : 		if (nodes) allocator::dealloc(nodes);

	mov	eax, DWORD PTR [edi]
	pop	esi
	pop	ebx
	test	eax, eax
	je	SHORT $LN20@Alloc
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h

; 53   : 		static	void	dealloc		(T *&p)			{	dlfree(p);	p=0;			}

	mov	ecx, eax
	call	_dlfree
	mov	ecx, DWORD PTR [edi+4]
$LN20@Alloc:
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h

; 55   : 		limit = newLimit;

	mov	eax, DWORD PTR _newLimit$1$[esp+16]
	mov	DWORD PTR [edi], ebp
	mov	DWORD PTR [edi+8], eax
	jmp	SHORT $LN2@Alloc
$LN33@Alloc:
	mov	ebp, DWORD PTR [edi]
$LN2@Alloc:

; 61   : 		TNode *node = nodes + pool;

	lea	eax, DWORD PTR [ecx*8]
	sub	eax, ecx

; 62   : 		node->key	= key;

	mov	ecx, DWORD PTR _key$[esp+12]
	mov	ecx, DWORD PTR [ecx]
	lea	eax, DWORD PTR [eax*4]
	add	eax, ebp
	mov	DWORD PTR [eax], ecx

; 63   : 		node->right = node->left = 0;

	mov	DWORD PTR [eax+20], 0
	mov	DWORD PTR [eax+24], 0

; 64   : 		pool++		;

	inc	DWORD PTR [edi+4]

; 65   : 		return node	;

	pop	edi
	pop	ebp

; 66   : 	}

	add	esp, 8
	ret	4
?Alloc@?$FixedMAP@PAUIDirect3DVertexShader9@@UmapMatrixPS@R_dsgraph@@Udoug_lea_allocator@@@@AAEPAUTNode@1@ABQAUIDirect3DVertexShader9@@@Z ENDP ; FixedMAP<IDirect3DVertexShader9 *,R_dsgraph::mapMatrixPS,doug_lea_allocator>::Alloc
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
;	COMDAT ?CreateChild@?$FixedMAP@PAUIDirect3DPixelShader9@@UmapMatrixCS@R_dsgraph@@Udoug_lea_allocator@@@@AAEPAUTNode@1@AAPAU21@ABQAUIDirect3DPixelShader9@@@Z
_TEXT	SEGMENT
_parent$ = 8						; size = 4
_key$ = 12						; size = 4
?CreateChild@?$FixedMAP@PAUIDirect3DPixelShader9@@UmapMatrixCS@R_dsgraph@@Udoug_lea_allocator@@@@AAEPAUTNode@1@AAPAU21@ABQAUIDirect3DPixelShader9@@@Z PROC ; FixedMAP<IDirect3DPixelShader9 *,R_dsgraph::mapMatrixCS,doug_lea_allocator>::CreateChild, COMDAT
; _this$ = ecx

; 68   : 	{

	push	ebx

; 69   : 		size_t	PID	= size_t(parent-nodes);

	mov	ebx, DWORD PTR _parent$[esp]
	push	esi
	push	edi

; 70   : 		TNode*	N	= Alloc	(key);

	push	DWORD PTR _key$[esp+8]
	mov	eax, DWORD PTR [ebx]
	mov	edi, ecx
	sub	eax, DWORD PTR [edi]
	sar	eax, 2
	imul	esi, eax, -1227133513
	call	?Alloc@?$FixedMAP@PAUIDirect3DPixelShader9@@UmapMatrixCS@R_dsgraph@@Udoug_lea_allocator@@@@AAEPAUTNode@1@ABQAUIDirect3DPixelShader9@@@Z ; FixedMAP<IDirect3DPixelShader9 *,R_dsgraph::mapMatrixCS,doug_lea_allocator>::Alloc

; 71   : 		parent		= nodes+PID;

	mov	ecx, DWORD PTR [edi]
	lea	edx, DWORD PTR [esi*8]
	sub	edx, esi

; 72   : 		return	N;

	pop	edi
	pop	esi
	lea	ecx, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR [ebx], ecx
	pop	ebx

; 73   : 	}

	ret	8
?CreateChild@?$FixedMAP@PAUIDirect3DPixelShader9@@UmapMatrixCS@R_dsgraph@@Udoug_lea_allocator@@@@AAEPAUTNode@1@AAPAU21@ABQAUIDirect3DPixelShader9@@@Z ENDP ; FixedMAP<IDirect3DPixelShader9 *,R_dsgraph::mapMatrixCS,doug_lea_allocator>::CreateChild
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
;	COMDAT ?Alloc@?$FixedMAP@PAUIDirect3DPixelShader9@@UmapMatrixCS@R_dsgraph@@Udoug_lea_allocator@@@@AAEPAUTNode@1@ABQAUIDirect3DPixelShader9@@@Z
_TEXT	SEGMENT
tv392 = -8						; size = 4
_newLimit$1$ = -4					; size = 4
_key$ = 8						; size = 4
?Alloc@?$FixedMAP@PAUIDirect3DPixelShader9@@UmapMatrixCS@R_dsgraph@@Udoug_lea_allocator@@@@AAEPAUTNode@1@ABQAUIDirect3DPixelShader9@@@Z PROC ; FixedMAP<IDirect3DPixelShader9 *,R_dsgraph::mapMatrixCS,doug_lea_allocator>::Alloc, COMDAT
; _this$ = ecx

; 59   : 	{

	sub	esp, 8
	push	ebp
	push	edi
	mov	edi, ecx

; 60   : 		if (pool==limit) Realloc();

	mov	ecx, DWORD PTR [edi+4]
	mov	eax, DWORD PTR [edi+8]
	cmp	ecx, eax
	jne	$LN33@Alloc

; 29   : 		u32	newLimit = limit + SG_REALLOC_ADVANCE;

	add	eax, 64					; 00000040H
	push	ebx
	push	esi
	mov	DWORD PTR _newLimit$1$[esp+24], eax

; 30   : 		VERIFY(newLimit%SG_REALLOC_ADVANCE == 0);
; 31   : 		TNode*	newNodes = (TNode*)allocator::alloc(sizeof(TNode)*newLimit);

	lea	esi, DWORD PTR [eax*8]
	sub	esi, eax
	shl	esi, 2
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h

; 51   : 		static	void	*alloc		(const u32 &n)	{	return dlmalloc((u32)n);	}

	mov	ecx, esi
	call	_dlmalloc
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h

; 34   : 		ZeroMemory(newNodes, Size(newLimit));

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	mov	ebp, eax
	push	esi
	push	0
	push	ebp
	mov	ecx, DWORD PTR [ecx+12]
	call	ecx

; 35   : 		if (limit) CopyMemory	(newNodes, nodes, Size(limit));

	mov	ecx, DWORD PTR [edi+8]
	test	ecx, ecx
	je	SHORT $LN17@Alloc

; 25   : 	{	return Count*sizeof(TNode);	}

	lea	eax, DWORD PTR [ecx*8]
	sub	eax, ecx
	shl	eax, 2

; 35   : 		if (limit) CopyMemory	(newNodes, nodes, Size(limit));

	push	eax
	push	DWORD PTR [edi]
	push	ebp
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN17@Alloc:

; 36   : 
; 37   : 		for (u32 I=0; I<pool; I++)

	mov	ecx, DWORD PTR [edi+4]
	xor	ebx, ebx
	test	ecx, ecx
	je	SHORT $LN12@Alloc
	mov	eax, -24				; ffffffe8H
	lea	esi, DWORD PTR [ebp+24]
	sub	eax, ebp
	mov	DWORD PTR tv392[esp+24], eax
$LL13@Alloc:

; 38   : 		{
; 39   : 			VERIFY	(nodes);
; 40   : 			TNode*	Nold	= nodes	+ I;

	mov	ecx, DWORD PTR [edi]
	lea	edx, DWORD PTR [eax+esi]
	add	edx, ecx

; 41   : 			TNode*	Nnew	= newNodes + I;
; 42   : 
; 43   : 			if (Nold->left) {

	mov	eax, DWORD PTR [edx+20]
	test	eax, eax
	je	SHORT $LN35@Alloc

; 44   : 				size_t	Lid		= Nold->left  - nodes;

	sub	eax, ecx
	sar	eax, 2
	imul	ecx, eax, -1227133513

; 45   : 				Nnew->left		= newNodes + Lid;

	lea	eax, DWORD PTR [ecx*8]
	sub	eax, ecx
	lea	eax, DWORD PTR [eax*4]
	add	eax, ebp
	mov	DWORD PTR [esi-4], eax
	mov	ecx, DWORD PTR [edi]
$LN35@Alloc:

; 46   : 			}
; 47   : 			if (Nold->right) {

	mov	eax, DWORD PTR [edx+24]
	test	eax, eax
	je	SHORT $LN11@Alloc

; 48   : 				size_t	Rid		= Nold->right - nodes;

	sub	eax, ecx
	sar	eax, 2
	imul	ecx, eax, -1227133513

; 49   : 				Nnew->right		= newNodes + Rid;

	lea	eax, DWORD PTR [ecx*8]
	sub	eax, ecx
	lea	eax, DWORD PTR [eax*4]
	add	eax, ebp
	mov	DWORD PTR [esi], eax
$LN11@Alloc:

; 36   : 
; 37   : 		for (u32 I=0; I<pool; I++)

	mov	ecx, DWORD PTR [edi+4]
	inc	ebx
	mov	eax, DWORD PTR tv392[esp+24]
	add	esi, 28					; 0000001cH
	cmp	ebx, ecx
	jb	SHORT $LL13@Alloc
$LN12@Alloc:

; 50   : 			}
; 51   : 		}
; 52   : 		if (nodes) allocator::dealloc(nodes);

	mov	eax, DWORD PTR [edi]
	pop	esi
	pop	ebx
	test	eax, eax
	je	SHORT $LN20@Alloc
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h

; 53   : 		static	void	dealloc		(T *&p)			{	dlfree(p);	p=0;			}

	mov	ecx, eax
	call	_dlfree
	mov	ecx, DWORD PTR [edi+4]
$LN20@Alloc:
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h

; 55   : 		limit = newLimit;

	mov	eax, DWORD PTR _newLimit$1$[esp+16]
	mov	DWORD PTR [edi], ebp
	mov	DWORD PTR [edi+8], eax
	jmp	SHORT $LN2@Alloc
$LN33@Alloc:
	mov	ebp, DWORD PTR [edi]
$LN2@Alloc:

; 61   : 		TNode *node = nodes + pool;

	lea	eax, DWORD PTR [ecx*8]
	sub	eax, ecx

; 62   : 		node->key	= key;

	mov	ecx, DWORD PTR _key$[esp+12]
	mov	ecx, DWORD PTR [ecx]
	lea	eax, DWORD PTR [eax*4]
	add	eax, ebp
	mov	DWORD PTR [eax], ecx

; 63   : 		node->right = node->left = 0;

	mov	DWORD PTR [eax+20], 0
	mov	DWORD PTR [eax+24], 0

; 64   : 		pool++		;

	inc	DWORD PTR [edi+4]

; 65   : 		return node	;

	pop	edi
	pop	ebp

; 66   : 	}

	add	esp, 8
	ret	4
?Alloc@?$FixedMAP@PAUIDirect3DPixelShader9@@UmapMatrixCS@R_dsgraph@@Udoug_lea_allocator@@@@AAEPAUTNode@1@ABQAUIDirect3DPixelShader9@@@Z ENDP ; FixedMAP<IDirect3DPixelShader9 *,R_dsgraph::mapMatrixCS,doug_lea_allocator>::Alloc
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
;	COMDAT ?CreateChild@?$FixedMAP@PAVR_constant_table@@UmapMatrixStates@R_dsgraph@@Udoug_lea_allocator@@@@AAEPAUTNode@1@AAPAU21@ABQAVR_constant_table@@@Z
_TEXT	SEGMENT
_parent$ = 8						; size = 4
_key$ = 12						; size = 4
?CreateChild@?$FixedMAP@PAVR_constant_table@@UmapMatrixStates@R_dsgraph@@Udoug_lea_allocator@@@@AAEPAUTNode@1@AAPAU21@ABQAVR_constant_table@@@Z PROC ; FixedMAP<R_constant_table *,R_dsgraph::mapMatrixStates,doug_lea_allocator>::CreateChild, COMDAT
; _this$ = ecx

; 68   : 	{

	push	ebx

; 69   : 		size_t	PID	= size_t(parent-nodes);

	mov	ebx, DWORD PTR _parent$[esp]
	push	esi
	push	edi

; 70   : 		TNode*	N	= Alloc	(key);

	push	DWORD PTR _key$[esp+8]
	mov	eax, DWORD PTR [ebx]
	mov	edi, ecx
	sub	eax, DWORD PTR [edi]
	sar	eax, 2
	imul	esi, eax, -1227133513
	call	?Alloc@?$FixedMAP@PAVR_constant_table@@UmapMatrixStates@R_dsgraph@@Udoug_lea_allocator@@@@AAEPAUTNode@1@ABQAVR_constant_table@@@Z ; FixedMAP<R_constant_table *,R_dsgraph::mapMatrixStates,doug_lea_allocator>::Alloc

; 71   : 		parent		= nodes+PID;

	mov	ecx, DWORD PTR [edi]
	lea	edx, DWORD PTR [esi*8]
	sub	edx, esi

; 72   : 		return	N;

	pop	edi
	pop	esi
	lea	ecx, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR [ebx], ecx
	pop	ebx

; 73   : 	}

	ret	8
?CreateChild@?$FixedMAP@PAVR_constant_table@@UmapMatrixStates@R_dsgraph@@Udoug_lea_allocator@@@@AAEPAUTNode@1@AAPAU21@ABQAVR_constant_table@@@Z ENDP ; FixedMAP<R_constant_table *,R_dsgraph::mapMatrixStates,doug_lea_allocator>::CreateChild
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
;	COMDAT ?Alloc@?$FixedMAP@PAVR_constant_table@@UmapMatrixStates@R_dsgraph@@Udoug_lea_allocator@@@@AAEPAUTNode@1@ABQAVR_constant_table@@@Z
_TEXT	SEGMENT
tv392 = -8						; size = 4
_newLimit$1$ = -4					; size = 4
_key$ = 8						; size = 4
?Alloc@?$FixedMAP@PAVR_constant_table@@UmapMatrixStates@R_dsgraph@@Udoug_lea_allocator@@@@AAEPAUTNode@1@ABQAVR_constant_table@@@Z PROC ; FixedMAP<R_constant_table *,R_dsgraph::mapMatrixStates,doug_lea_allocator>::Alloc, COMDAT
; _this$ = ecx

; 59   : 	{

	sub	esp, 8
	push	ebp
	push	edi
	mov	edi, ecx

; 60   : 		if (pool==limit) Realloc();

	mov	ecx, DWORD PTR [edi+4]
	mov	eax, DWORD PTR [edi+8]
	cmp	ecx, eax
	jne	$LN33@Alloc

; 29   : 		u32	newLimit = limit + SG_REALLOC_ADVANCE;

	add	eax, 64					; 00000040H
	push	ebx
	push	esi
	mov	DWORD PTR _newLimit$1$[esp+24], eax

; 30   : 		VERIFY(newLimit%SG_REALLOC_ADVANCE == 0);
; 31   : 		TNode*	newNodes = (TNode*)allocator::alloc(sizeof(TNode)*newLimit);

	lea	esi, DWORD PTR [eax*8]
	sub	esi, eax
	shl	esi, 2
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h

; 51   : 		static	void	*alloc		(const u32 &n)	{	return dlmalloc((u32)n);	}

	mov	ecx, esi
	call	_dlmalloc
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h

; 34   : 		ZeroMemory(newNodes, Size(newLimit));

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	mov	ebp, eax
	push	esi
	push	0
	push	ebp
	mov	ecx, DWORD PTR [ecx+12]
	call	ecx

; 35   : 		if (limit) CopyMemory	(newNodes, nodes, Size(limit));

	mov	ecx, DWORD PTR [edi+8]
	test	ecx, ecx
	je	SHORT $LN17@Alloc

; 25   : 	{	return Count*sizeof(TNode);	}

	lea	eax, DWORD PTR [ecx*8]
	sub	eax, ecx
	shl	eax, 2

; 35   : 		if (limit) CopyMemory	(newNodes, nodes, Size(limit));

	push	eax
	push	DWORD PTR [edi]
	push	ebp
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN17@Alloc:

; 36   : 
; 37   : 		for (u32 I=0; I<pool; I++)

	mov	ecx, DWORD PTR [edi+4]
	xor	ebx, ebx
	test	ecx, ecx
	je	SHORT $LN12@Alloc
	mov	eax, -24				; ffffffe8H
	lea	esi, DWORD PTR [ebp+24]
	sub	eax, ebp
	mov	DWORD PTR tv392[esp+24], eax
$LL13@Alloc:

; 38   : 		{
; 39   : 			VERIFY	(nodes);
; 40   : 			TNode*	Nold	= nodes	+ I;

	mov	ecx, DWORD PTR [edi]
	lea	edx, DWORD PTR [eax+esi]
	add	edx, ecx

; 41   : 			TNode*	Nnew	= newNodes + I;
; 42   : 
; 43   : 			if (Nold->left) {

	mov	eax, DWORD PTR [edx+20]
	test	eax, eax
	je	SHORT $LN35@Alloc

; 44   : 				size_t	Lid		= Nold->left  - nodes;

	sub	eax, ecx
	sar	eax, 2
	imul	ecx, eax, -1227133513

; 45   : 				Nnew->left		= newNodes + Lid;

	lea	eax, DWORD PTR [ecx*8]
	sub	eax, ecx
	lea	eax, DWORD PTR [eax*4]
	add	eax, ebp
	mov	DWORD PTR [esi-4], eax
	mov	ecx, DWORD PTR [edi]
$LN35@Alloc:

; 46   : 			}
; 47   : 			if (Nold->right) {

	mov	eax, DWORD PTR [edx+24]
	test	eax, eax
	je	SHORT $LN11@Alloc

; 48   : 				size_t	Rid		= Nold->right - nodes;

	sub	eax, ecx
	sar	eax, 2
	imul	ecx, eax, -1227133513

; 49   : 				Nnew->right		= newNodes + Rid;

	lea	eax, DWORD PTR [ecx*8]
	sub	eax, ecx
	lea	eax, DWORD PTR [eax*4]
	add	eax, ebp
	mov	DWORD PTR [esi], eax
$LN11@Alloc:

; 36   : 
; 37   : 		for (u32 I=0; I<pool; I++)

	mov	ecx, DWORD PTR [edi+4]
	inc	ebx
	mov	eax, DWORD PTR tv392[esp+24]
	add	esi, 28					; 0000001cH
	cmp	ebx, ecx
	jb	SHORT $LL13@Alloc
$LN12@Alloc:

; 50   : 			}
; 51   : 		}
; 52   : 		if (nodes) allocator::dealloc(nodes);

	mov	eax, DWORD PTR [edi]
	pop	esi
	pop	ebx
	test	eax, eax
	je	SHORT $LN20@Alloc
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h

; 53   : 		static	void	dealloc		(T *&p)			{	dlfree(p);	p=0;			}

	mov	ecx, eax
	call	_dlfree
	mov	ecx, DWORD PTR [edi+4]
$LN20@Alloc:
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h

; 55   : 		limit = newLimit;

	mov	eax, DWORD PTR _newLimit$1$[esp+16]
	mov	DWORD PTR [edi], ebp
	mov	DWORD PTR [edi+8], eax
	jmp	SHORT $LN2@Alloc
$LN33@Alloc:
	mov	ebp, DWORD PTR [edi]
$LN2@Alloc:

; 61   : 		TNode *node = nodes + pool;

	lea	eax, DWORD PTR [ecx*8]
	sub	eax, ecx

; 62   : 		node->key	= key;

	mov	ecx, DWORD PTR _key$[esp+12]
	mov	ecx, DWORD PTR [ecx]
	lea	eax, DWORD PTR [eax*4]
	add	eax, ebp
	mov	DWORD PTR [eax], ecx

; 63   : 		node->right = node->left = 0;

	mov	DWORD PTR [eax+20], 0
	mov	DWORD PTR [eax+24], 0

; 64   : 		pool++		;

	inc	DWORD PTR [edi+4]

; 65   : 		return node	;

	pop	edi
	pop	ebp

; 66   : 	}

	add	esp, 8
	ret	4
?Alloc@?$FixedMAP@PAVR_constant_table@@UmapMatrixStates@R_dsgraph@@Udoug_lea_allocator@@@@AAEPAUTNode@1@ABQAVR_constant_table@@@Z ENDP ; FixedMAP<R_constant_table *,R_dsgraph::mapMatrixStates,doug_lea_allocator>::Alloc
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
;	COMDAT ?CreateChild@?$FixedMAP@PAUIDirect3DStateBlock9@@UmapMatrixTextures@R_dsgraph@@Udoug_lea_allocator@@@@AAEPAUTNode@1@AAPAU21@ABQAUIDirect3DStateBlock9@@@Z
_TEXT	SEGMENT
_parent$ = 8						; size = 4
_key$ = 12						; size = 4
?CreateChild@?$FixedMAP@PAUIDirect3DStateBlock9@@UmapMatrixTextures@R_dsgraph@@Udoug_lea_allocator@@@@AAEPAUTNode@1@AAPAU21@ABQAUIDirect3DStateBlock9@@@Z PROC ; FixedMAP<IDirect3DStateBlock9 *,R_dsgraph::mapMatrixTextures,doug_lea_allocator>::CreateChild, COMDAT
; _this$ = ecx

; 68   : 	{

	push	ebx

; 69   : 		size_t	PID	= size_t(parent-nodes);

	mov	ebx, DWORD PTR _parent$[esp]
	push	esi
	push	edi

; 70   : 		TNode*	N	= Alloc	(key);

	push	DWORD PTR _key$[esp+8]
	mov	eax, DWORD PTR [ebx]
	mov	edi, ecx
	sub	eax, DWORD PTR [edi]
	sar	eax, 2
	imul	esi, eax, -1227133513
	call	?Alloc@?$FixedMAP@PAUIDirect3DStateBlock9@@UmapMatrixTextures@R_dsgraph@@Udoug_lea_allocator@@@@AAEPAUTNode@1@ABQAUIDirect3DStateBlock9@@@Z ; FixedMAP<IDirect3DStateBlock9 *,R_dsgraph::mapMatrixTextures,doug_lea_allocator>::Alloc

; 71   : 		parent		= nodes+PID;

	mov	ecx, DWORD PTR [edi]
	lea	edx, DWORD PTR [esi*8]
	sub	edx, esi

; 72   : 		return	N;

	pop	edi
	pop	esi
	lea	ecx, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR [ebx], ecx
	pop	ebx

; 73   : 	}

	ret	8
?CreateChild@?$FixedMAP@PAUIDirect3DStateBlock9@@UmapMatrixTextures@R_dsgraph@@Udoug_lea_allocator@@@@AAEPAUTNode@1@AAPAU21@ABQAUIDirect3DStateBlock9@@@Z ENDP ; FixedMAP<IDirect3DStateBlock9 *,R_dsgraph::mapMatrixTextures,doug_lea_allocator>::CreateChild
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
;	COMDAT ?Alloc@?$FixedMAP@PAUIDirect3DStateBlock9@@UmapMatrixTextures@R_dsgraph@@Udoug_lea_allocator@@@@AAEPAUTNode@1@ABQAUIDirect3DStateBlock9@@@Z
_TEXT	SEGMENT
tv392 = -8						; size = 4
_newLimit$1$ = -4					; size = 4
_key$ = 8						; size = 4
?Alloc@?$FixedMAP@PAUIDirect3DStateBlock9@@UmapMatrixTextures@R_dsgraph@@Udoug_lea_allocator@@@@AAEPAUTNode@1@ABQAUIDirect3DStateBlock9@@@Z PROC ; FixedMAP<IDirect3DStateBlock9 *,R_dsgraph::mapMatrixTextures,doug_lea_allocator>::Alloc, COMDAT
; _this$ = ecx

; 59   : 	{

	sub	esp, 8
	push	ebp
	push	edi
	mov	edi, ecx

; 60   : 		if (pool==limit) Realloc();

	mov	ecx, DWORD PTR [edi+4]
	mov	eax, DWORD PTR [edi+8]
	cmp	ecx, eax
	jne	$LN33@Alloc

; 29   : 		u32	newLimit = limit + SG_REALLOC_ADVANCE;

	add	eax, 64					; 00000040H
	push	ebx
	push	esi
	mov	DWORD PTR _newLimit$1$[esp+24], eax

; 30   : 		VERIFY(newLimit%SG_REALLOC_ADVANCE == 0);
; 31   : 		TNode*	newNodes = (TNode*)allocator::alloc(sizeof(TNode)*newLimit);

	lea	esi, DWORD PTR [eax*8]
	sub	esi, eax
	shl	esi, 2
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h

; 51   : 		static	void	*alloc		(const u32 &n)	{	return dlmalloc((u32)n);	}

	mov	ecx, esi
	call	_dlmalloc
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h

; 34   : 		ZeroMemory(newNodes, Size(newLimit));

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	mov	ebp, eax
	push	esi
	push	0
	push	ebp
	mov	ecx, DWORD PTR [ecx+12]
	call	ecx

; 35   : 		if (limit) CopyMemory	(newNodes, nodes, Size(limit));

	mov	ecx, DWORD PTR [edi+8]
	test	ecx, ecx
	je	SHORT $LN17@Alloc

; 25   : 	{	return Count*sizeof(TNode);	}

	lea	eax, DWORD PTR [ecx*8]
	sub	eax, ecx
	shl	eax, 2

; 35   : 		if (limit) CopyMemory	(newNodes, nodes, Size(limit));

	push	eax
	push	DWORD PTR [edi]
	push	ebp
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN17@Alloc:

; 36   : 
; 37   : 		for (u32 I=0; I<pool; I++)

	mov	ecx, DWORD PTR [edi+4]
	xor	ebx, ebx
	test	ecx, ecx
	je	SHORT $LN12@Alloc
	mov	eax, -24				; ffffffe8H
	lea	esi, DWORD PTR [ebp+24]
	sub	eax, ebp
	mov	DWORD PTR tv392[esp+24], eax
$LL13@Alloc:

; 38   : 		{
; 39   : 			VERIFY	(nodes);
; 40   : 			TNode*	Nold	= nodes	+ I;

	mov	ecx, DWORD PTR [edi]
	lea	edx, DWORD PTR [eax+esi]
	add	edx, ecx

; 41   : 			TNode*	Nnew	= newNodes + I;
; 42   : 
; 43   : 			if (Nold->left) {

	mov	eax, DWORD PTR [edx+20]
	test	eax, eax
	je	SHORT $LN35@Alloc

; 44   : 				size_t	Lid		= Nold->left  - nodes;

	sub	eax, ecx
	sar	eax, 2
	imul	ecx, eax, -1227133513

; 45   : 				Nnew->left		= newNodes + Lid;

	lea	eax, DWORD PTR [ecx*8]
	sub	eax, ecx
	lea	eax, DWORD PTR [eax*4]
	add	eax, ebp
	mov	DWORD PTR [esi-4], eax
	mov	ecx, DWORD PTR [edi]
$LN35@Alloc:

; 46   : 			}
; 47   : 			if (Nold->right) {

	mov	eax, DWORD PTR [edx+24]
	test	eax, eax
	je	SHORT $LN11@Alloc

; 48   : 				size_t	Rid		= Nold->right - nodes;

	sub	eax, ecx
	sar	eax, 2
	imul	ecx, eax, -1227133513

; 49   : 				Nnew->right		= newNodes + Rid;

	lea	eax, DWORD PTR [ecx*8]
	sub	eax, ecx
	lea	eax, DWORD PTR [eax*4]
	add	eax, ebp
	mov	DWORD PTR [esi], eax
$LN11@Alloc:

; 36   : 
; 37   : 		for (u32 I=0; I<pool; I++)

	mov	ecx, DWORD PTR [edi+4]
	inc	ebx
	mov	eax, DWORD PTR tv392[esp+24]
	add	esi, 28					; 0000001cH
	cmp	ebx, ecx
	jb	SHORT $LL13@Alloc
$LN12@Alloc:

; 50   : 			}
; 51   : 		}
; 52   : 		if (nodes) allocator::dealloc(nodes);

	mov	eax, DWORD PTR [edi]
	pop	esi
	pop	ebx
	test	eax, eax
	je	SHORT $LN20@Alloc
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h

; 53   : 		static	void	dealloc		(T *&p)			{	dlfree(p);	p=0;			}

	mov	ecx, eax
	call	_dlfree
	mov	ecx, DWORD PTR [edi+4]
$LN20@Alloc:
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h

; 55   : 		limit = newLimit;

	mov	eax, DWORD PTR _newLimit$1$[esp+16]
	mov	DWORD PTR [edi], ebp
	mov	DWORD PTR [edi+8], eax
	jmp	SHORT $LN2@Alloc
$LN33@Alloc:
	mov	ebp, DWORD PTR [edi]
$LN2@Alloc:

; 61   : 		TNode *node = nodes + pool;

	lea	eax, DWORD PTR [ecx*8]
	sub	eax, ecx

; 62   : 		node->key	= key;

	mov	ecx, DWORD PTR _key$[esp+12]
	mov	ecx, DWORD PTR [ecx]
	lea	eax, DWORD PTR [eax*4]
	add	eax, ebp
	mov	DWORD PTR [eax], ecx

; 63   : 		node->right = node->left = 0;

	mov	DWORD PTR [eax+20], 0
	mov	DWORD PTR [eax+24], 0

; 64   : 		pool++		;

	inc	DWORD PTR [edi+4]

; 65   : 		return node	;

	pop	edi
	pop	ebp

; 66   : 	}

	add	esp, 8
	ret	4
?Alloc@?$FixedMAP@PAUIDirect3DStateBlock9@@UmapMatrixTextures@R_dsgraph@@Udoug_lea_allocator@@@@AAEPAUTNode@1@ABQAUIDirect3DStateBlock9@@@Z ENDP ; FixedMAP<IDirect3DStateBlock9 *,R_dsgraph::mapMatrixTextures,doug_lea_allocator>::Alloc
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
;	COMDAT ?CreateChild@?$FixedMAP@PAUSTextureList@@UmapMatrixItems@R_dsgraph@@Udoug_lea_allocator@@@@AAEPAUTNode@1@AAPAU21@ABQAUSTextureList@@@Z
_TEXT	SEGMENT
_parent$ = 8						; size = 4
_key$ = 12						; size = 4
?CreateChild@?$FixedMAP@PAUSTextureList@@UmapMatrixItems@R_dsgraph@@Udoug_lea_allocator@@@@AAEPAUTNode@1@AAPAU21@ABQAUSTextureList@@@Z PROC ; FixedMAP<STextureList *,R_dsgraph::mapMatrixItems,doug_lea_allocator>::CreateChild, COMDAT
; _this$ = ecx

; 68   : 	{

	push	ebx

; 69   : 		size_t	PID	= size_t(parent-nodes);

	mov	ebx, DWORD PTR _parent$[esp]
	push	esi
	push	edi

; 70   : 		TNode*	N	= Alloc	(key);

	push	DWORD PTR _key$[esp+8]
	mov	eax, DWORD PTR [ebx]
	mov	edi, ecx
	sub	eax, DWORD PTR [edi]
	sar	eax, 2
	imul	esi, eax, -1227133513
	call	?Alloc@?$FixedMAP@PAUSTextureList@@UmapMatrixItems@R_dsgraph@@Udoug_lea_allocator@@@@AAEPAUTNode@1@ABQAUSTextureList@@@Z ; FixedMAP<STextureList *,R_dsgraph::mapMatrixItems,doug_lea_allocator>::Alloc

; 71   : 		parent		= nodes+PID;

	mov	ecx, DWORD PTR [edi]
	lea	edx, DWORD PTR [esi*8]
	sub	edx, esi

; 72   : 		return	N;

	pop	edi
	pop	esi
	lea	ecx, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR [ebx], ecx
	pop	ebx

; 73   : 	}

	ret	8
?CreateChild@?$FixedMAP@PAUSTextureList@@UmapMatrixItems@R_dsgraph@@Udoug_lea_allocator@@@@AAEPAUTNode@1@AAPAU21@ABQAUSTextureList@@@Z ENDP ; FixedMAP<STextureList *,R_dsgraph::mapMatrixItems,doug_lea_allocator>::CreateChild
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
;	COMDAT ?Alloc@?$FixedMAP@PAUSTextureList@@UmapMatrixItems@R_dsgraph@@Udoug_lea_allocator@@@@AAEPAUTNode@1@ABQAUSTextureList@@@Z
_TEXT	SEGMENT
tv392 = -8						; size = 4
_newLimit$1$ = -4					; size = 4
_key$ = 8						; size = 4
?Alloc@?$FixedMAP@PAUSTextureList@@UmapMatrixItems@R_dsgraph@@Udoug_lea_allocator@@@@AAEPAUTNode@1@ABQAUSTextureList@@@Z PROC ; FixedMAP<STextureList *,R_dsgraph::mapMatrixItems,doug_lea_allocator>::Alloc, COMDAT
; _this$ = ecx

; 59   : 	{

	sub	esp, 8
	push	ebp
	push	edi
	mov	edi, ecx

; 60   : 		if (pool==limit) Realloc();

	mov	ecx, DWORD PTR [edi+4]
	mov	eax, DWORD PTR [edi+8]
	cmp	ecx, eax
	jne	$LN33@Alloc

; 29   : 		u32	newLimit = limit + SG_REALLOC_ADVANCE;

	add	eax, 64					; 00000040H
	push	ebx
	push	esi
	mov	DWORD PTR _newLimit$1$[esp+24], eax

; 30   : 		VERIFY(newLimit%SG_REALLOC_ADVANCE == 0);
; 31   : 		TNode*	newNodes = (TNode*)allocator::alloc(sizeof(TNode)*newLimit);

	lea	esi, DWORD PTR [eax*8]
	sub	esi, eax
	shl	esi, 2
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h

; 51   : 		static	void	*alloc		(const u32 &n)	{	return dlmalloc((u32)n);	}

	mov	ecx, esi
	call	_dlmalloc
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h

; 34   : 		ZeroMemory(newNodes, Size(newLimit));

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	mov	ebp, eax
	push	esi
	push	0
	push	ebp
	mov	ecx, DWORD PTR [ecx+12]
	call	ecx

; 35   : 		if (limit) CopyMemory	(newNodes, nodes, Size(limit));

	mov	ecx, DWORD PTR [edi+8]
	test	ecx, ecx
	je	SHORT $LN17@Alloc

; 25   : 	{	return Count*sizeof(TNode);	}

	lea	eax, DWORD PTR [ecx*8]
	sub	eax, ecx
	shl	eax, 2

; 35   : 		if (limit) CopyMemory	(newNodes, nodes, Size(limit));

	push	eax
	push	DWORD PTR [edi]
	push	ebp
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN17@Alloc:

; 36   : 
; 37   : 		for (u32 I=0; I<pool; I++)

	mov	ecx, DWORD PTR [edi+4]
	xor	ebx, ebx
	test	ecx, ecx
	je	SHORT $LN12@Alloc
	mov	eax, -24				; ffffffe8H
	lea	esi, DWORD PTR [ebp+24]
	sub	eax, ebp
	mov	DWORD PTR tv392[esp+24], eax
$LL13@Alloc:

; 38   : 		{
; 39   : 			VERIFY	(nodes);
; 40   : 			TNode*	Nold	= nodes	+ I;

	mov	ecx, DWORD PTR [edi]
	lea	edx, DWORD PTR [eax+esi]
	add	edx, ecx

; 41   : 			TNode*	Nnew	= newNodes + I;
; 42   : 
; 43   : 			if (Nold->left) {

	mov	eax, DWORD PTR [edx+20]
	test	eax, eax
	je	SHORT $LN35@Alloc

; 44   : 				size_t	Lid		= Nold->left  - nodes;

	sub	eax, ecx
	sar	eax, 2
	imul	ecx, eax, -1227133513

; 45   : 				Nnew->left		= newNodes + Lid;

	lea	eax, DWORD PTR [ecx*8]
	sub	eax, ecx
	lea	eax, DWORD PTR [eax*4]
	add	eax, ebp
	mov	DWORD PTR [esi-4], eax
	mov	ecx, DWORD PTR [edi]
$LN35@Alloc:

; 46   : 			}
; 47   : 			if (Nold->right) {

	mov	eax, DWORD PTR [edx+24]
	test	eax, eax
	je	SHORT $LN11@Alloc

; 48   : 				size_t	Rid		= Nold->right - nodes;

	sub	eax, ecx
	sar	eax, 2
	imul	ecx, eax, -1227133513

; 49   : 				Nnew->right		= newNodes + Rid;

	lea	eax, DWORD PTR [ecx*8]
	sub	eax, ecx
	lea	eax, DWORD PTR [eax*4]
	add	eax, ebp
	mov	DWORD PTR [esi], eax
$LN11@Alloc:

; 36   : 
; 37   : 		for (u32 I=0; I<pool; I++)

	mov	ecx, DWORD PTR [edi+4]
	inc	ebx
	mov	eax, DWORD PTR tv392[esp+24]
	add	esi, 28					; 0000001cH
	cmp	ebx, ecx
	jb	SHORT $LL13@Alloc
$LN12@Alloc:

; 50   : 			}
; 51   : 		}
; 52   : 		if (nodes) allocator::dealloc(nodes);

	mov	eax, DWORD PTR [edi]
	pop	esi
	pop	ebx
	test	eax, eax
	je	SHORT $LN20@Alloc
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h

; 53   : 		static	void	dealloc		(T *&p)			{	dlfree(p);	p=0;			}

	mov	ecx, eax
	call	_dlfree
	mov	ecx, DWORD PTR [edi+4]
$LN20@Alloc:
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h

; 55   : 		limit = newLimit;

	mov	eax, DWORD PTR _newLimit$1$[esp+16]
	mov	DWORD PTR [edi], ebp
	mov	DWORD PTR [edi+8], eax
	jmp	SHORT $LN2@Alloc
$LN33@Alloc:
	mov	ebp, DWORD PTR [edi]
$LN2@Alloc:

; 61   : 		TNode *node = nodes + pool;

	lea	eax, DWORD PTR [ecx*8]
	sub	eax, ecx

; 62   : 		node->key	= key;

	mov	ecx, DWORD PTR _key$[esp+12]
	mov	ecx, DWORD PTR [ecx]
	lea	eax, DWORD PTR [eax*4]
	add	eax, ebp
	mov	DWORD PTR [eax], ecx

; 63   : 		node->right = node->left = 0;

	mov	DWORD PTR [eax+20], 0
	mov	DWORD PTR [eax+24], 0

; 64   : 		pool++		;

	inc	DWORD PTR [edi+4]

; 65   : 		return node	;

	pop	edi
	pop	ebp

; 66   : 	}

	add	esp, 8
	ret	4
?Alloc@?$FixedMAP@PAUSTextureList@@UmapMatrixItems@R_dsgraph@@Udoug_lea_allocator@@@@AAEPAUTNode@1@ABQAUSTextureList@@@Z ENDP ; FixedMAP<STextureList *,R_dsgraph::mapMatrixItems,doug_lea_allocator>::Alloc
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Orphan_range@?$vector@U_MatrixItem@R_dsgraph@@V?$doug_lea_alloc@U_MatrixItem@R_dsgraph@@@@@std@@ABEXPAU_MatrixItem@R_dsgraph@@0@Z
_TEXT	SEGMENT
___formal$dead$ = 8					; size = 4
___formal$dead$ = 12					; size = 4
?_Orphan_range@?$vector@U_MatrixItem@R_dsgraph@@V?$doug_lea_alloc@U_MatrixItem@R_dsgraph@@@@@std@@ABEXPAU_MatrixItem@R_dsgraph@@0@Z PROC ; std::vector<R_dsgraph::_MatrixItem,doug_lea_alloc<R_dsgraph::_MatrixItem> >::_Orphan_range, COMDAT
; _this$dead$ = ecx

; 1801 :     _CONSTEXPR20_CONTAINER void _Orphan_range(pointer, pointer) const {}

	ret	8
?_Orphan_range@?$vector@U_MatrixItem@R_dsgraph@@V?$doug_lea_alloc@U_MatrixItem@R_dsgraph@@@@@std@@ABEXPAU_MatrixItem@R_dsgraph@@0@Z ENDP ; std::vector<R_dsgraph::_MatrixItem,doug_lea_alloc<R_dsgraph::_MatrixItem> >::_Orphan_range
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
;	COMDAT ?CreateChild@?$FixedMAP@PAUIDirect3DVertexShader9@@UmapNormalPS@R_dsgraph@@Udoug_lea_allocator@@@@AAEPAUTNode@1@AAPAU21@ABQAUIDirect3DVertexShader9@@@Z
_TEXT	SEGMENT
_parent$ = 8						; size = 4
_key$ = 12						; size = 4
?CreateChild@?$FixedMAP@PAUIDirect3DVertexShader9@@UmapNormalPS@R_dsgraph@@Udoug_lea_allocator@@@@AAEPAUTNode@1@AAPAU21@ABQAUIDirect3DVertexShader9@@@Z PROC ; FixedMAP<IDirect3DVertexShader9 *,R_dsgraph::mapNormalPS,doug_lea_allocator>::CreateChild, COMDAT
; _this$ = ecx

; 68   : 	{

	push	ebx

; 69   : 		size_t	PID	= size_t(parent-nodes);

	mov	ebx, DWORD PTR _parent$[esp]
	push	esi
	push	edi

; 70   : 		TNode*	N	= Alloc	(key);

	push	DWORD PTR _key$[esp+8]
	mov	eax, DWORD PTR [ebx]
	mov	edi, ecx
	sub	eax, DWORD PTR [edi]
	sar	eax, 2
	imul	esi, eax, -1227133513
	call	?Alloc@?$FixedMAP@PAUIDirect3DVertexShader9@@UmapNormalPS@R_dsgraph@@Udoug_lea_allocator@@@@AAEPAUTNode@1@ABQAUIDirect3DVertexShader9@@@Z ; FixedMAP<IDirect3DVertexShader9 *,R_dsgraph::mapNormalPS,doug_lea_allocator>::Alloc

; 71   : 		parent		= nodes+PID;

	mov	ecx, DWORD PTR [edi]
	lea	edx, DWORD PTR [esi*8]
	sub	edx, esi

; 72   : 		return	N;

	pop	edi
	pop	esi
	lea	ecx, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR [ebx], ecx
	pop	ebx

; 73   : 	}

	ret	8
?CreateChild@?$FixedMAP@PAUIDirect3DVertexShader9@@UmapNormalPS@R_dsgraph@@Udoug_lea_allocator@@@@AAEPAUTNode@1@AAPAU21@ABQAUIDirect3DVertexShader9@@@Z ENDP ; FixedMAP<IDirect3DVertexShader9 *,R_dsgraph::mapNormalPS,doug_lea_allocator>::CreateChild
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
;	COMDAT ?Alloc@?$FixedMAP@PAUIDirect3DVertexShader9@@UmapNormalPS@R_dsgraph@@Udoug_lea_allocator@@@@AAEPAUTNode@1@ABQAUIDirect3DVertexShader9@@@Z
_TEXT	SEGMENT
tv392 = -8						; size = 4
_newLimit$1$ = -4					; size = 4
_key$ = 8						; size = 4
?Alloc@?$FixedMAP@PAUIDirect3DVertexShader9@@UmapNormalPS@R_dsgraph@@Udoug_lea_allocator@@@@AAEPAUTNode@1@ABQAUIDirect3DVertexShader9@@@Z PROC ; FixedMAP<IDirect3DVertexShader9 *,R_dsgraph::mapNormalPS,doug_lea_allocator>::Alloc, COMDAT
; _this$ = ecx

; 59   : 	{

	sub	esp, 8
	push	ebp
	push	edi
	mov	edi, ecx

; 60   : 		if (pool==limit) Realloc();

	mov	ecx, DWORD PTR [edi+4]
	mov	eax, DWORD PTR [edi+8]
	cmp	ecx, eax
	jne	$LN33@Alloc

; 29   : 		u32	newLimit = limit + SG_REALLOC_ADVANCE;

	add	eax, 64					; 00000040H
	push	ebx
	push	esi
	mov	DWORD PTR _newLimit$1$[esp+24], eax

; 30   : 		VERIFY(newLimit%SG_REALLOC_ADVANCE == 0);
; 31   : 		TNode*	newNodes = (TNode*)allocator::alloc(sizeof(TNode)*newLimit);

	lea	esi, DWORD PTR [eax*8]
	sub	esi, eax
	shl	esi, 2
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h

; 51   : 		static	void	*alloc		(const u32 &n)	{	return dlmalloc((u32)n);	}

	mov	ecx, esi
	call	_dlmalloc
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h

; 34   : 		ZeroMemory(newNodes, Size(newLimit));

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	mov	ebp, eax
	push	esi
	push	0
	push	ebp
	mov	ecx, DWORD PTR [ecx+12]
	call	ecx

; 35   : 		if (limit) CopyMemory	(newNodes, nodes, Size(limit));

	mov	ecx, DWORD PTR [edi+8]
	test	ecx, ecx
	je	SHORT $LN17@Alloc

; 25   : 	{	return Count*sizeof(TNode);	}

	lea	eax, DWORD PTR [ecx*8]
	sub	eax, ecx
	shl	eax, 2

; 35   : 		if (limit) CopyMemory	(newNodes, nodes, Size(limit));

	push	eax
	push	DWORD PTR [edi]
	push	ebp
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN17@Alloc:

; 36   : 
; 37   : 		for (u32 I=0; I<pool; I++)

	mov	ecx, DWORD PTR [edi+4]
	xor	ebx, ebx
	test	ecx, ecx
	je	SHORT $LN12@Alloc
	mov	eax, -24				; ffffffe8H
	lea	esi, DWORD PTR [ebp+24]
	sub	eax, ebp
	mov	DWORD PTR tv392[esp+24], eax
$LL13@Alloc:

; 38   : 		{
; 39   : 			VERIFY	(nodes);
; 40   : 			TNode*	Nold	= nodes	+ I;

	mov	ecx, DWORD PTR [edi]
	lea	edx, DWORD PTR [eax+esi]
	add	edx, ecx

; 41   : 			TNode*	Nnew	= newNodes + I;
; 42   : 
; 43   : 			if (Nold->left) {

	mov	eax, DWORD PTR [edx+20]
	test	eax, eax
	je	SHORT $LN35@Alloc

; 44   : 				size_t	Lid		= Nold->left  - nodes;

	sub	eax, ecx
	sar	eax, 2
	imul	ecx, eax, -1227133513

; 45   : 				Nnew->left		= newNodes + Lid;

	lea	eax, DWORD PTR [ecx*8]
	sub	eax, ecx
	lea	eax, DWORD PTR [eax*4]
	add	eax, ebp
	mov	DWORD PTR [esi-4], eax
	mov	ecx, DWORD PTR [edi]
$LN35@Alloc:

; 46   : 			}
; 47   : 			if (Nold->right) {

	mov	eax, DWORD PTR [edx+24]
	test	eax, eax
	je	SHORT $LN11@Alloc

; 48   : 				size_t	Rid		= Nold->right - nodes;

	sub	eax, ecx
	sar	eax, 2
	imul	ecx, eax, -1227133513

; 49   : 				Nnew->right		= newNodes + Rid;

	lea	eax, DWORD PTR [ecx*8]
	sub	eax, ecx
	lea	eax, DWORD PTR [eax*4]
	add	eax, ebp
	mov	DWORD PTR [esi], eax
$LN11@Alloc:

; 36   : 
; 37   : 		for (u32 I=0; I<pool; I++)

	mov	ecx, DWORD PTR [edi+4]
	inc	ebx
	mov	eax, DWORD PTR tv392[esp+24]
	add	esi, 28					; 0000001cH
	cmp	ebx, ecx
	jb	SHORT $LL13@Alloc
$LN12@Alloc:

; 50   : 			}
; 51   : 		}
; 52   : 		if (nodes) allocator::dealloc(nodes);

	mov	eax, DWORD PTR [edi]
	pop	esi
	pop	ebx
	test	eax, eax
	je	SHORT $LN20@Alloc
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h

; 53   : 		static	void	dealloc		(T *&p)			{	dlfree(p);	p=0;			}

	mov	ecx, eax
	call	_dlfree
	mov	ecx, DWORD PTR [edi+4]
$LN20@Alloc:
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h

; 55   : 		limit = newLimit;

	mov	eax, DWORD PTR _newLimit$1$[esp+16]
	mov	DWORD PTR [edi], ebp
	mov	DWORD PTR [edi+8], eax
	jmp	SHORT $LN2@Alloc
$LN33@Alloc:
	mov	ebp, DWORD PTR [edi]
$LN2@Alloc:

; 61   : 		TNode *node = nodes + pool;

	lea	eax, DWORD PTR [ecx*8]
	sub	eax, ecx

; 62   : 		node->key	= key;

	mov	ecx, DWORD PTR _key$[esp+12]
	mov	ecx, DWORD PTR [ecx]
	lea	eax, DWORD PTR [eax*4]
	add	eax, ebp
	mov	DWORD PTR [eax], ecx

; 63   : 		node->right = node->left = 0;

	mov	DWORD PTR [eax+20], 0
	mov	DWORD PTR [eax+24], 0

; 64   : 		pool++		;

	inc	DWORD PTR [edi+4]

; 65   : 		return node	;

	pop	edi
	pop	ebp

; 66   : 	}

	add	esp, 8
	ret	4
?Alloc@?$FixedMAP@PAUIDirect3DVertexShader9@@UmapNormalPS@R_dsgraph@@Udoug_lea_allocator@@@@AAEPAUTNode@1@ABQAUIDirect3DVertexShader9@@@Z ENDP ; FixedMAP<IDirect3DVertexShader9 *,R_dsgraph::mapNormalPS,doug_lea_allocator>::Alloc
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
;	COMDAT ?CreateChild@?$FixedMAP@PAUIDirect3DPixelShader9@@UmapNormalCS@R_dsgraph@@Udoug_lea_allocator@@@@AAEPAUTNode@1@AAPAU21@ABQAUIDirect3DPixelShader9@@@Z
_TEXT	SEGMENT
_parent$ = 8						; size = 4
_key$ = 12						; size = 4
?CreateChild@?$FixedMAP@PAUIDirect3DPixelShader9@@UmapNormalCS@R_dsgraph@@Udoug_lea_allocator@@@@AAEPAUTNode@1@AAPAU21@ABQAUIDirect3DPixelShader9@@@Z PROC ; FixedMAP<IDirect3DPixelShader9 *,R_dsgraph::mapNormalCS,doug_lea_allocator>::CreateChild, COMDAT
; _this$ = ecx

; 68   : 	{

	push	ebx

; 69   : 		size_t	PID	= size_t(parent-nodes);

	mov	ebx, DWORD PTR _parent$[esp]
	push	esi
	push	edi

; 70   : 		TNode*	N	= Alloc	(key);

	push	DWORD PTR _key$[esp+8]
	mov	eax, DWORD PTR [ebx]
	mov	edi, ecx
	sub	eax, DWORD PTR [edi]
	sar	eax, 2
	imul	esi, eax, -1227133513
	call	?Alloc@?$FixedMAP@PAUIDirect3DPixelShader9@@UmapNormalCS@R_dsgraph@@Udoug_lea_allocator@@@@AAEPAUTNode@1@ABQAUIDirect3DPixelShader9@@@Z ; FixedMAP<IDirect3DPixelShader9 *,R_dsgraph::mapNormalCS,doug_lea_allocator>::Alloc

; 71   : 		parent		= nodes+PID;

	mov	ecx, DWORD PTR [edi]
	lea	edx, DWORD PTR [esi*8]
	sub	edx, esi

; 72   : 		return	N;

	pop	edi
	pop	esi
	lea	ecx, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR [ebx], ecx
	pop	ebx

; 73   : 	}

	ret	8
?CreateChild@?$FixedMAP@PAUIDirect3DPixelShader9@@UmapNormalCS@R_dsgraph@@Udoug_lea_allocator@@@@AAEPAUTNode@1@AAPAU21@ABQAUIDirect3DPixelShader9@@@Z ENDP ; FixedMAP<IDirect3DPixelShader9 *,R_dsgraph::mapNormalCS,doug_lea_allocator>::CreateChild
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
;	COMDAT ?Alloc@?$FixedMAP@PAUIDirect3DPixelShader9@@UmapNormalCS@R_dsgraph@@Udoug_lea_allocator@@@@AAEPAUTNode@1@ABQAUIDirect3DPixelShader9@@@Z
_TEXT	SEGMENT
tv392 = -8						; size = 4
_newLimit$1$ = -4					; size = 4
_key$ = 8						; size = 4
?Alloc@?$FixedMAP@PAUIDirect3DPixelShader9@@UmapNormalCS@R_dsgraph@@Udoug_lea_allocator@@@@AAEPAUTNode@1@ABQAUIDirect3DPixelShader9@@@Z PROC ; FixedMAP<IDirect3DPixelShader9 *,R_dsgraph::mapNormalCS,doug_lea_allocator>::Alloc, COMDAT
; _this$ = ecx

; 59   : 	{

	sub	esp, 8
	push	ebp
	push	edi
	mov	edi, ecx

; 60   : 		if (pool==limit) Realloc();

	mov	ecx, DWORD PTR [edi+4]
	mov	eax, DWORD PTR [edi+8]
	cmp	ecx, eax
	jne	$LN33@Alloc

; 29   : 		u32	newLimit = limit + SG_REALLOC_ADVANCE;

	add	eax, 64					; 00000040H
	push	ebx
	push	esi
	mov	DWORD PTR _newLimit$1$[esp+24], eax

; 30   : 		VERIFY(newLimit%SG_REALLOC_ADVANCE == 0);
; 31   : 		TNode*	newNodes = (TNode*)allocator::alloc(sizeof(TNode)*newLimit);

	lea	esi, DWORD PTR [eax*8]
	sub	esi, eax
	shl	esi, 2
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h

; 51   : 		static	void	*alloc		(const u32 &n)	{	return dlmalloc((u32)n);	}

	mov	ecx, esi
	call	_dlmalloc
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h

; 34   : 		ZeroMemory(newNodes, Size(newLimit));

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	mov	ebp, eax
	push	esi
	push	0
	push	ebp
	mov	ecx, DWORD PTR [ecx+12]
	call	ecx

; 35   : 		if (limit) CopyMemory	(newNodes, nodes, Size(limit));

	mov	ecx, DWORD PTR [edi+8]
	test	ecx, ecx
	je	SHORT $LN17@Alloc

; 25   : 	{	return Count*sizeof(TNode);	}

	lea	eax, DWORD PTR [ecx*8]
	sub	eax, ecx
	shl	eax, 2

; 35   : 		if (limit) CopyMemory	(newNodes, nodes, Size(limit));

	push	eax
	push	DWORD PTR [edi]
	push	ebp
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN17@Alloc:

; 36   : 
; 37   : 		for (u32 I=0; I<pool; I++)

	mov	ecx, DWORD PTR [edi+4]
	xor	ebx, ebx
	test	ecx, ecx
	je	SHORT $LN12@Alloc
	mov	eax, -24				; ffffffe8H
	lea	esi, DWORD PTR [ebp+24]
	sub	eax, ebp
	mov	DWORD PTR tv392[esp+24], eax
$LL13@Alloc:

; 38   : 		{
; 39   : 			VERIFY	(nodes);
; 40   : 			TNode*	Nold	= nodes	+ I;

	mov	ecx, DWORD PTR [edi]
	lea	edx, DWORD PTR [eax+esi]
	add	edx, ecx

; 41   : 			TNode*	Nnew	= newNodes + I;
; 42   : 
; 43   : 			if (Nold->left) {

	mov	eax, DWORD PTR [edx+20]
	test	eax, eax
	je	SHORT $LN35@Alloc

; 44   : 				size_t	Lid		= Nold->left  - nodes;

	sub	eax, ecx
	sar	eax, 2
	imul	ecx, eax, -1227133513

; 45   : 				Nnew->left		= newNodes + Lid;

	lea	eax, DWORD PTR [ecx*8]
	sub	eax, ecx
	lea	eax, DWORD PTR [eax*4]
	add	eax, ebp
	mov	DWORD PTR [esi-4], eax
	mov	ecx, DWORD PTR [edi]
$LN35@Alloc:

; 46   : 			}
; 47   : 			if (Nold->right) {

	mov	eax, DWORD PTR [edx+24]
	test	eax, eax
	je	SHORT $LN11@Alloc

; 48   : 				size_t	Rid		= Nold->right - nodes;

	sub	eax, ecx
	sar	eax, 2
	imul	ecx, eax, -1227133513

; 49   : 				Nnew->right		= newNodes + Rid;

	lea	eax, DWORD PTR [ecx*8]
	sub	eax, ecx
	lea	eax, DWORD PTR [eax*4]
	add	eax, ebp
	mov	DWORD PTR [esi], eax
$LN11@Alloc:

; 36   : 
; 37   : 		for (u32 I=0; I<pool; I++)

	mov	ecx, DWORD PTR [edi+4]
	inc	ebx
	mov	eax, DWORD PTR tv392[esp+24]
	add	esi, 28					; 0000001cH
	cmp	ebx, ecx
	jb	SHORT $LL13@Alloc
$LN12@Alloc:

; 50   : 			}
; 51   : 		}
; 52   : 		if (nodes) allocator::dealloc(nodes);

	mov	eax, DWORD PTR [edi]
	pop	esi
	pop	ebx
	test	eax, eax
	je	SHORT $LN20@Alloc
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h

; 53   : 		static	void	dealloc		(T *&p)			{	dlfree(p);	p=0;			}

	mov	ecx, eax
	call	_dlfree
	mov	ecx, DWORD PTR [edi+4]
$LN20@Alloc:
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h

; 55   : 		limit = newLimit;

	mov	eax, DWORD PTR _newLimit$1$[esp+16]
	mov	DWORD PTR [edi], ebp
	mov	DWORD PTR [edi+8], eax
	jmp	SHORT $LN2@Alloc
$LN33@Alloc:
	mov	ebp, DWORD PTR [edi]
$LN2@Alloc:

; 61   : 		TNode *node = nodes + pool;

	lea	eax, DWORD PTR [ecx*8]
	sub	eax, ecx

; 62   : 		node->key	= key;

	mov	ecx, DWORD PTR _key$[esp+12]
	mov	ecx, DWORD PTR [ecx]
	lea	eax, DWORD PTR [eax*4]
	add	eax, ebp
	mov	DWORD PTR [eax], ecx

; 63   : 		node->right = node->left = 0;

	mov	DWORD PTR [eax+20], 0
	mov	DWORD PTR [eax+24], 0

; 64   : 		pool++		;

	inc	DWORD PTR [edi+4]

; 65   : 		return node	;

	pop	edi
	pop	ebp

; 66   : 	}

	add	esp, 8
	ret	4
?Alloc@?$FixedMAP@PAUIDirect3DPixelShader9@@UmapNormalCS@R_dsgraph@@Udoug_lea_allocator@@@@AAEPAUTNode@1@ABQAUIDirect3DPixelShader9@@@Z ENDP ; FixedMAP<IDirect3DPixelShader9 *,R_dsgraph::mapNormalCS,doug_lea_allocator>::Alloc
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
;	COMDAT ?CreateChild@?$FixedMAP@PAVR_constant_table@@UmapNormalStates@R_dsgraph@@Udoug_lea_allocator@@@@AAEPAUTNode@1@AAPAU21@ABQAVR_constant_table@@@Z
_TEXT	SEGMENT
_parent$ = 8						; size = 4
_key$ = 12						; size = 4
?CreateChild@?$FixedMAP@PAVR_constant_table@@UmapNormalStates@R_dsgraph@@Udoug_lea_allocator@@@@AAEPAUTNode@1@AAPAU21@ABQAVR_constant_table@@@Z PROC ; FixedMAP<R_constant_table *,R_dsgraph::mapNormalStates,doug_lea_allocator>::CreateChild, COMDAT
; _this$ = ecx

; 68   : 	{

	push	ebx

; 69   : 		size_t	PID	= size_t(parent-nodes);

	mov	ebx, DWORD PTR _parent$[esp]
	push	esi
	push	edi

; 70   : 		TNode*	N	= Alloc	(key);

	push	DWORD PTR _key$[esp+8]
	mov	eax, DWORD PTR [ebx]
	mov	edi, ecx
	sub	eax, DWORD PTR [edi]
	sar	eax, 2
	imul	esi, eax, -1227133513
	call	?Alloc@?$FixedMAP@PAVR_constant_table@@UmapNormalStates@R_dsgraph@@Udoug_lea_allocator@@@@AAEPAUTNode@1@ABQAVR_constant_table@@@Z ; FixedMAP<R_constant_table *,R_dsgraph::mapNormalStates,doug_lea_allocator>::Alloc

; 71   : 		parent		= nodes+PID;

	mov	ecx, DWORD PTR [edi]
	lea	edx, DWORD PTR [esi*8]
	sub	edx, esi

; 72   : 		return	N;

	pop	edi
	pop	esi
	lea	ecx, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR [ebx], ecx
	pop	ebx

; 73   : 	}

	ret	8
?CreateChild@?$FixedMAP@PAVR_constant_table@@UmapNormalStates@R_dsgraph@@Udoug_lea_allocator@@@@AAEPAUTNode@1@AAPAU21@ABQAVR_constant_table@@@Z ENDP ; FixedMAP<R_constant_table *,R_dsgraph::mapNormalStates,doug_lea_allocator>::CreateChild
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
;	COMDAT ?Alloc@?$FixedMAP@PAVR_constant_table@@UmapNormalStates@R_dsgraph@@Udoug_lea_allocator@@@@AAEPAUTNode@1@ABQAVR_constant_table@@@Z
_TEXT	SEGMENT
tv392 = -8						; size = 4
_newLimit$1$ = -4					; size = 4
_key$ = 8						; size = 4
?Alloc@?$FixedMAP@PAVR_constant_table@@UmapNormalStates@R_dsgraph@@Udoug_lea_allocator@@@@AAEPAUTNode@1@ABQAVR_constant_table@@@Z PROC ; FixedMAP<R_constant_table *,R_dsgraph::mapNormalStates,doug_lea_allocator>::Alloc, COMDAT
; _this$ = ecx

; 59   : 	{

	sub	esp, 8
	push	ebp
	push	edi
	mov	edi, ecx

; 60   : 		if (pool==limit) Realloc();

	mov	ecx, DWORD PTR [edi+4]
	mov	eax, DWORD PTR [edi+8]
	cmp	ecx, eax
	jne	$LN33@Alloc

; 29   : 		u32	newLimit = limit + SG_REALLOC_ADVANCE;

	add	eax, 64					; 00000040H
	push	ebx
	push	esi
	mov	DWORD PTR _newLimit$1$[esp+24], eax

; 30   : 		VERIFY(newLimit%SG_REALLOC_ADVANCE == 0);
; 31   : 		TNode*	newNodes = (TNode*)allocator::alloc(sizeof(TNode)*newLimit);

	lea	esi, DWORD PTR [eax*8]
	sub	esi, eax
	shl	esi, 2
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h

; 51   : 		static	void	*alloc		(const u32 &n)	{	return dlmalloc((u32)n);	}

	mov	ecx, esi
	call	_dlmalloc
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h

; 34   : 		ZeroMemory(newNodes, Size(newLimit));

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	mov	ebp, eax
	push	esi
	push	0
	push	ebp
	mov	ecx, DWORD PTR [ecx+12]
	call	ecx

; 35   : 		if (limit) CopyMemory	(newNodes, nodes, Size(limit));

	mov	ecx, DWORD PTR [edi+8]
	test	ecx, ecx
	je	SHORT $LN17@Alloc

; 25   : 	{	return Count*sizeof(TNode);	}

	lea	eax, DWORD PTR [ecx*8]
	sub	eax, ecx
	shl	eax, 2

; 35   : 		if (limit) CopyMemory	(newNodes, nodes, Size(limit));

	push	eax
	push	DWORD PTR [edi]
	push	ebp
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN17@Alloc:

; 36   : 
; 37   : 		for (u32 I=0; I<pool; I++)

	mov	ecx, DWORD PTR [edi+4]
	xor	ebx, ebx
	test	ecx, ecx
	je	SHORT $LN12@Alloc
	mov	eax, -24				; ffffffe8H
	lea	esi, DWORD PTR [ebp+24]
	sub	eax, ebp
	mov	DWORD PTR tv392[esp+24], eax
$LL13@Alloc:

; 38   : 		{
; 39   : 			VERIFY	(nodes);
; 40   : 			TNode*	Nold	= nodes	+ I;

	mov	ecx, DWORD PTR [edi]
	lea	edx, DWORD PTR [eax+esi]
	add	edx, ecx

; 41   : 			TNode*	Nnew	= newNodes + I;
; 42   : 
; 43   : 			if (Nold->left) {

	mov	eax, DWORD PTR [edx+20]
	test	eax, eax
	je	SHORT $LN35@Alloc

; 44   : 				size_t	Lid		= Nold->left  - nodes;

	sub	eax, ecx
	sar	eax, 2
	imul	ecx, eax, -1227133513

; 45   : 				Nnew->left		= newNodes + Lid;

	lea	eax, DWORD PTR [ecx*8]
	sub	eax, ecx
	lea	eax, DWORD PTR [eax*4]
	add	eax, ebp
	mov	DWORD PTR [esi-4], eax
	mov	ecx, DWORD PTR [edi]
$LN35@Alloc:

; 46   : 			}
; 47   : 			if (Nold->right) {

	mov	eax, DWORD PTR [edx+24]
	test	eax, eax
	je	SHORT $LN11@Alloc

; 48   : 				size_t	Rid		= Nold->right - nodes;

	sub	eax, ecx
	sar	eax, 2
	imul	ecx, eax, -1227133513

; 49   : 				Nnew->right		= newNodes + Rid;

	lea	eax, DWORD PTR [ecx*8]
	sub	eax, ecx
	lea	eax, DWORD PTR [eax*4]
	add	eax, ebp
	mov	DWORD PTR [esi], eax
$LN11@Alloc:

; 36   : 
; 37   : 		for (u32 I=0; I<pool; I++)

	mov	ecx, DWORD PTR [edi+4]
	inc	ebx
	mov	eax, DWORD PTR tv392[esp+24]
	add	esi, 28					; 0000001cH
	cmp	ebx, ecx
	jb	SHORT $LL13@Alloc
$LN12@Alloc:

; 50   : 			}
; 51   : 		}
; 52   : 		if (nodes) allocator::dealloc(nodes);

	mov	eax, DWORD PTR [edi]
	pop	esi
	pop	ebx
	test	eax, eax
	je	SHORT $LN20@Alloc
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h

; 53   : 		static	void	dealloc		(T *&p)			{	dlfree(p);	p=0;			}

	mov	ecx, eax
	call	_dlfree
	mov	ecx, DWORD PTR [edi+4]
$LN20@Alloc:
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h

; 55   : 		limit = newLimit;

	mov	eax, DWORD PTR _newLimit$1$[esp+16]
	mov	DWORD PTR [edi], ebp
	mov	DWORD PTR [edi+8], eax
	jmp	SHORT $LN2@Alloc
$LN33@Alloc:
	mov	ebp, DWORD PTR [edi]
$LN2@Alloc:

; 61   : 		TNode *node = nodes + pool;

	lea	eax, DWORD PTR [ecx*8]
	sub	eax, ecx

; 62   : 		node->key	= key;

	mov	ecx, DWORD PTR _key$[esp+12]
	mov	ecx, DWORD PTR [ecx]
	lea	eax, DWORD PTR [eax*4]
	add	eax, ebp
	mov	DWORD PTR [eax], ecx

; 63   : 		node->right = node->left = 0;

	mov	DWORD PTR [eax+20], 0
	mov	DWORD PTR [eax+24], 0

; 64   : 		pool++		;

	inc	DWORD PTR [edi+4]

; 65   : 		return node	;

	pop	edi
	pop	ebp

; 66   : 	}

	add	esp, 8
	ret	4
?Alloc@?$FixedMAP@PAVR_constant_table@@UmapNormalStates@R_dsgraph@@Udoug_lea_allocator@@@@AAEPAUTNode@1@ABQAVR_constant_table@@@Z ENDP ; FixedMAP<R_constant_table *,R_dsgraph::mapNormalStates,doug_lea_allocator>::Alloc
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
;	COMDAT ?CreateChild@?$FixedMAP@PAUIDirect3DStateBlock9@@UmapNormalTextures@R_dsgraph@@Udoug_lea_allocator@@@@AAEPAUTNode@1@AAPAU21@ABQAUIDirect3DStateBlock9@@@Z
_TEXT	SEGMENT
_parent$ = 8						; size = 4
_key$ = 12						; size = 4
?CreateChild@?$FixedMAP@PAUIDirect3DStateBlock9@@UmapNormalTextures@R_dsgraph@@Udoug_lea_allocator@@@@AAEPAUTNode@1@AAPAU21@ABQAUIDirect3DStateBlock9@@@Z PROC ; FixedMAP<IDirect3DStateBlock9 *,R_dsgraph::mapNormalTextures,doug_lea_allocator>::CreateChild, COMDAT
; _this$ = ecx

; 68   : 	{

	push	ebx

; 69   : 		size_t	PID	= size_t(parent-nodes);

	mov	ebx, DWORD PTR _parent$[esp]
	push	esi
	push	edi

; 70   : 		TNode*	N	= Alloc	(key);

	push	DWORD PTR _key$[esp+8]
	mov	eax, DWORD PTR [ebx]
	mov	edi, ecx
	sub	eax, DWORD PTR [edi]
	sar	eax, 2
	imul	esi, eax, -1227133513
	call	?Alloc@?$FixedMAP@PAUIDirect3DStateBlock9@@UmapNormalTextures@R_dsgraph@@Udoug_lea_allocator@@@@AAEPAUTNode@1@ABQAUIDirect3DStateBlock9@@@Z ; FixedMAP<IDirect3DStateBlock9 *,R_dsgraph::mapNormalTextures,doug_lea_allocator>::Alloc

; 71   : 		parent		= nodes+PID;

	mov	ecx, DWORD PTR [edi]
	lea	edx, DWORD PTR [esi*8]
	sub	edx, esi

; 72   : 		return	N;

	pop	edi
	pop	esi
	lea	ecx, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR [ebx], ecx
	pop	ebx

; 73   : 	}

	ret	8
?CreateChild@?$FixedMAP@PAUIDirect3DStateBlock9@@UmapNormalTextures@R_dsgraph@@Udoug_lea_allocator@@@@AAEPAUTNode@1@AAPAU21@ABQAUIDirect3DStateBlock9@@@Z ENDP ; FixedMAP<IDirect3DStateBlock9 *,R_dsgraph::mapNormalTextures,doug_lea_allocator>::CreateChild
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
;	COMDAT ?Alloc@?$FixedMAP@PAUIDirect3DStateBlock9@@UmapNormalTextures@R_dsgraph@@Udoug_lea_allocator@@@@AAEPAUTNode@1@ABQAUIDirect3DStateBlock9@@@Z
_TEXT	SEGMENT
tv392 = -8						; size = 4
_newLimit$1$ = -4					; size = 4
_key$ = 8						; size = 4
?Alloc@?$FixedMAP@PAUIDirect3DStateBlock9@@UmapNormalTextures@R_dsgraph@@Udoug_lea_allocator@@@@AAEPAUTNode@1@ABQAUIDirect3DStateBlock9@@@Z PROC ; FixedMAP<IDirect3DStateBlock9 *,R_dsgraph::mapNormalTextures,doug_lea_allocator>::Alloc, COMDAT
; _this$ = ecx

; 59   : 	{

	sub	esp, 8
	push	ebp
	push	edi
	mov	edi, ecx

; 60   : 		if (pool==limit) Realloc();

	mov	ecx, DWORD PTR [edi+4]
	mov	eax, DWORD PTR [edi+8]
	cmp	ecx, eax
	jne	$LN33@Alloc

; 29   : 		u32	newLimit = limit + SG_REALLOC_ADVANCE;

	add	eax, 64					; 00000040H
	push	ebx
	push	esi
	mov	DWORD PTR _newLimit$1$[esp+24], eax

; 30   : 		VERIFY(newLimit%SG_REALLOC_ADVANCE == 0);
; 31   : 		TNode*	newNodes = (TNode*)allocator::alloc(sizeof(TNode)*newLimit);

	lea	esi, DWORD PTR [eax*8]
	sub	esi, eax
	shl	esi, 2
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h

; 51   : 		static	void	*alloc		(const u32 &n)	{	return dlmalloc((u32)n);	}

	mov	ecx, esi
	call	_dlmalloc
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h

; 34   : 		ZeroMemory(newNodes, Size(newLimit));

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	mov	ebp, eax
	push	esi
	push	0
	push	ebp
	mov	ecx, DWORD PTR [ecx+12]
	call	ecx

; 35   : 		if (limit) CopyMemory	(newNodes, nodes, Size(limit));

	mov	ecx, DWORD PTR [edi+8]
	test	ecx, ecx
	je	SHORT $LN17@Alloc

; 25   : 	{	return Count*sizeof(TNode);	}

	lea	eax, DWORD PTR [ecx*8]
	sub	eax, ecx
	shl	eax, 2

; 35   : 		if (limit) CopyMemory	(newNodes, nodes, Size(limit));

	push	eax
	push	DWORD PTR [edi]
	push	ebp
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN17@Alloc:

; 36   : 
; 37   : 		for (u32 I=0; I<pool; I++)

	mov	ecx, DWORD PTR [edi+4]
	xor	ebx, ebx
	test	ecx, ecx
	je	SHORT $LN12@Alloc
	mov	eax, -24				; ffffffe8H
	lea	esi, DWORD PTR [ebp+24]
	sub	eax, ebp
	mov	DWORD PTR tv392[esp+24], eax
$LL13@Alloc:

; 38   : 		{
; 39   : 			VERIFY	(nodes);
; 40   : 			TNode*	Nold	= nodes	+ I;

	mov	ecx, DWORD PTR [edi]
	lea	edx, DWORD PTR [eax+esi]
	add	edx, ecx

; 41   : 			TNode*	Nnew	= newNodes + I;
; 42   : 
; 43   : 			if (Nold->left) {

	mov	eax, DWORD PTR [edx+20]
	test	eax, eax
	je	SHORT $LN35@Alloc

; 44   : 				size_t	Lid		= Nold->left  - nodes;

	sub	eax, ecx
	sar	eax, 2
	imul	ecx, eax, -1227133513

; 45   : 				Nnew->left		= newNodes + Lid;

	lea	eax, DWORD PTR [ecx*8]
	sub	eax, ecx
	lea	eax, DWORD PTR [eax*4]
	add	eax, ebp
	mov	DWORD PTR [esi-4], eax
	mov	ecx, DWORD PTR [edi]
$LN35@Alloc:

; 46   : 			}
; 47   : 			if (Nold->right) {

	mov	eax, DWORD PTR [edx+24]
	test	eax, eax
	je	SHORT $LN11@Alloc

; 48   : 				size_t	Rid		= Nold->right - nodes;

	sub	eax, ecx
	sar	eax, 2
	imul	ecx, eax, -1227133513

; 49   : 				Nnew->right		= newNodes + Rid;

	lea	eax, DWORD PTR [ecx*8]
	sub	eax, ecx
	lea	eax, DWORD PTR [eax*4]
	add	eax, ebp
	mov	DWORD PTR [esi], eax
$LN11@Alloc:

; 36   : 
; 37   : 		for (u32 I=0; I<pool; I++)

	mov	ecx, DWORD PTR [edi+4]
	inc	ebx
	mov	eax, DWORD PTR tv392[esp+24]
	add	esi, 28					; 0000001cH
	cmp	ebx, ecx
	jb	SHORT $LL13@Alloc
$LN12@Alloc:

; 50   : 			}
; 51   : 		}
; 52   : 		if (nodes) allocator::dealloc(nodes);

	mov	eax, DWORD PTR [edi]
	pop	esi
	pop	ebx
	test	eax, eax
	je	SHORT $LN20@Alloc
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h

; 53   : 		static	void	dealloc		(T *&p)			{	dlfree(p);	p=0;			}

	mov	ecx, eax
	call	_dlfree
	mov	ecx, DWORD PTR [edi+4]
$LN20@Alloc:
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h

; 55   : 		limit = newLimit;

	mov	eax, DWORD PTR _newLimit$1$[esp+16]
	mov	DWORD PTR [edi], ebp
	mov	DWORD PTR [edi+8], eax
	jmp	SHORT $LN2@Alloc
$LN33@Alloc:
	mov	ebp, DWORD PTR [edi]
$LN2@Alloc:

; 61   : 		TNode *node = nodes + pool;

	lea	eax, DWORD PTR [ecx*8]
	sub	eax, ecx

; 62   : 		node->key	= key;

	mov	ecx, DWORD PTR _key$[esp+12]
	mov	ecx, DWORD PTR [ecx]
	lea	eax, DWORD PTR [eax*4]
	add	eax, ebp
	mov	DWORD PTR [eax], ecx

; 63   : 		node->right = node->left = 0;

	mov	DWORD PTR [eax+20], 0
	mov	DWORD PTR [eax+24], 0

; 64   : 		pool++		;

	inc	DWORD PTR [edi+4]

; 65   : 		return node	;

	pop	edi
	pop	ebp

; 66   : 	}

	add	esp, 8
	ret	4
?Alloc@?$FixedMAP@PAUIDirect3DStateBlock9@@UmapNormalTextures@R_dsgraph@@Udoug_lea_allocator@@@@AAEPAUTNode@1@ABQAUIDirect3DStateBlock9@@@Z ENDP ; FixedMAP<IDirect3DStateBlock9 *,R_dsgraph::mapNormalTextures,doug_lea_allocator>::Alloc
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
;	COMDAT ?CreateChild@?$FixedMAP@PAUSTextureList@@UmapNormalItems@R_dsgraph@@Udoug_lea_allocator@@@@AAEPAUTNode@1@AAPAU21@ABQAUSTextureList@@@Z
_TEXT	SEGMENT
_parent$ = 8						; size = 4
_key$ = 12						; size = 4
?CreateChild@?$FixedMAP@PAUSTextureList@@UmapNormalItems@R_dsgraph@@Udoug_lea_allocator@@@@AAEPAUTNode@1@AAPAU21@ABQAUSTextureList@@@Z PROC ; FixedMAP<STextureList *,R_dsgraph::mapNormalItems,doug_lea_allocator>::CreateChild, COMDAT
; _this$ = ecx

; 68   : 	{

	push	ebx

; 69   : 		size_t	PID	= size_t(parent-nodes);

	mov	ebx, DWORD PTR _parent$[esp]
	push	esi
	push	edi

; 70   : 		TNode*	N	= Alloc	(key);

	push	DWORD PTR _key$[esp+8]
	mov	eax, DWORD PTR [ebx]
	mov	edi, ecx
	sub	eax, DWORD PTR [edi]
	sar	eax, 2
	imul	esi, eax, -1227133513
	call	?Alloc@?$FixedMAP@PAUSTextureList@@UmapNormalItems@R_dsgraph@@Udoug_lea_allocator@@@@AAEPAUTNode@1@ABQAUSTextureList@@@Z ; FixedMAP<STextureList *,R_dsgraph::mapNormalItems,doug_lea_allocator>::Alloc

; 71   : 		parent		= nodes+PID;

	mov	ecx, DWORD PTR [edi]
	lea	edx, DWORD PTR [esi*8]
	sub	edx, esi

; 72   : 		return	N;

	pop	edi
	pop	esi
	lea	ecx, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR [ebx], ecx
	pop	ebx

; 73   : 	}

	ret	8
?CreateChild@?$FixedMAP@PAUSTextureList@@UmapNormalItems@R_dsgraph@@Udoug_lea_allocator@@@@AAEPAUTNode@1@AAPAU21@ABQAUSTextureList@@@Z ENDP ; FixedMAP<STextureList *,R_dsgraph::mapNormalItems,doug_lea_allocator>::CreateChild
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
;	COMDAT ?Alloc@?$FixedMAP@PAUSTextureList@@UmapNormalItems@R_dsgraph@@Udoug_lea_allocator@@@@AAEPAUTNode@1@ABQAUSTextureList@@@Z
_TEXT	SEGMENT
tv392 = -8						; size = 4
_newLimit$1$ = -4					; size = 4
_key$ = 8						; size = 4
?Alloc@?$FixedMAP@PAUSTextureList@@UmapNormalItems@R_dsgraph@@Udoug_lea_allocator@@@@AAEPAUTNode@1@ABQAUSTextureList@@@Z PROC ; FixedMAP<STextureList *,R_dsgraph::mapNormalItems,doug_lea_allocator>::Alloc, COMDAT
; _this$ = ecx

; 59   : 	{

	sub	esp, 8
	push	ebp
	push	edi
	mov	edi, ecx

; 60   : 		if (pool==limit) Realloc();

	mov	ecx, DWORD PTR [edi+4]
	mov	eax, DWORD PTR [edi+8]
	cmp	ecx, eax
	jne	$LN33@Alloc

; 29   : 		u32	newLimit = limit + SG_REALLOC_ADVANCE;

	add	eax, 64					; 00000040H
	push	ebx
	push	esi
	mov	DWORD PTR _newLimit$1$[esp+24], eax

; 30   : 		VERIFY(newLimit%SG_REALLOC_ADVANCE == 0);
; 31   : 		TNode*	newNodes = (TNode*)allocator::alloc(sizeof(TNode)*newLimit);

	lea	esi, DWORD PTR [eax*8]
	sub	esi, eax
	shl	esi, 2
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h

; 51   : 		static	void	*alloc		(const u32 &n)	{	return dlmalloc((u32)n);	}

	mov	ecx, esi
	call	_dlmalloc
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h

; 34   : 		ZeroMemory(newNodes, Size(newLimit));

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	mov	ebp, eax
	push	esi
	push	0
	push	ebp
	mov	ecx, DWORD PTR [ecx+12]
	call	ecx

; 35   : 		if (limit) CopyMemory	(newNodes, nodes, Size(limit));

	mov	ecx, DWORD PTR [edi+8]
	test	ecx, ecx
	je	SHORT $LN17@Alloc

; 25   : 	{	return Count*sizeof(TNode);	}

	lea	eax, DWORD PTR [ecx*8]
	sub	eax, ecx
	shl	eax, 2

; 35   : 		if (limit) CopyMemory	(newNodes, nodes, Size(limit));

	push	eax
	push	DWORD PTR [edi]
	push	ebp
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN17@Alloc:

; 36   : 
; 37   : 		for (u32 I=0; I<pool; I++)

	mov	ecx, DWORD PTR [edi+4]
	xor	ebx, ebx
	test	ecx, ecx
	je	SHORT $LN12@Alloc
	mov	eax, -24				; ffffffe8H
	lea	esi, DWORD PTR [ebp+24]
	sub	eax, ebp
	mov	DWORD PTR tv392[esp+24], eax
$LL13@Alloc:

; 38   : 		{
; 39   : 			VERIFY	(nodes);
; 40   : 			TNode*	Nold	= nodes	+ I;

	mov	ecx, DWORD PTR [edi]
	lea	edx, DWORD PTR [eax+esi]
	add	edx, ecx

; 41   : 			TNode*	Nnew	= newNodes + I;
; 42   : 
; 43   : 			if (Nold->left) {

	mov	eax, DWORD PTR [edx+20]
	test	eax, eax
	je	SHORT $LN35@Alloc

; 44   : 				size_t	Lid		= Nold->left  - nodes;

	sub	eax, ecx
	sar	eax, 2
	imul	ecx, eax, -1227133513

; 45   : 				Nnew->left		= newNodes + Lid;

	lea	eax, DWORD PTR [ecx*8]
	sub	eax, ecx
	lea	eax, DWORD PTR [eax*4]
	add	eax, ebp
	mov	DWORD PTR [esi-4], eax
	mov	ecx, DWORD PTR [edi]
$LN35@Alloc:

; 46   : 			}
; 47   : 			if (Nold->right) {

	mov	eax, DWORD PTR [edx+24]
	test	eax, eax
	je	SHORT $LN11@Alloc

; 48   : 				size_t	Rid		= Nold->right - nodes;

	sub	eax, ecx
	sar	eax, 2
	imul	ecx, eax, -1227133513

; 49   : 				Nnew->right		= newNodes + Rid;

	lea	eax, DWORD PTR [ecx*8]
	sub	eax, ecx
	lea	eax, DWORD PTR [eax*4]
	add	eax, ebp
	mov	DWORD PTR [esi], eax
$LN11@Alloc:

; 36   : 
; 37   : 		for (u32 I=0; I<pool; I++)

	mov	ecx, DWORD PTR [edi+4]
	inc	ebx
	mov	eax, DWORD PTR tv392[esp+24]
	add	esi, 28					; 0000001cH
	cmp	ebx, ecx
	jb	SHORT $LL13@Alloc
$LN12@Alloc:

; 50   : 			}
; 51   : 		}
; 52   : 		if (nodes) allocator::dealloc(nodes);

	mov	eax, DWORD PTR [edi]
	pop	esi
	pop	ebx
	test	eax, eax
	je	SHORT $LN20@Alloc
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h

; 53   : 		static	void	dealloc		(T *&p)			{	dlfree(p);	p=0;			}

	mov	ecx, eax
	call	_dlfree
	mov	ecx, DWORD PTR [edi+4]
$LN20@Alloc:
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h

; 55   : 		limit = newLimit;

	mov	eax, DWORD PTR _newLimit$1$[esp+16]
	mov	DWORD PTR [edi], ebp
	mov	DWORD PTR [edi+8], eax
	jmp	SHORT $LN2@Alloc
$LN33@Alloc:
	mov	ebp, DWORD PTR [edi]
$LN2@Alloc:

; 61   : 		TNode *node = nodes + pool;

	lea	eax, DWORD PTR [ecx*8]
	sub	eax, ecx

; 62   : 		node->key	= key;

	mov	ecx, DWORD PTR _key$[esp+12]
	mov	ecx, DWORD PTR [ecx]
	lea	eax, DWORD PTR [eax*4]
	add	eax, ebp
	mov	DWORD PTR [eax], ecx

; 63   : 		node->right = node->left = 0;

	mov	DWORD PTR [eax+20], 0
	mov	DWORD PTR [eax+24], 0

; 64   : 		pool++		;

	inc	DWORD PTR [edi+4]

; 65   : 		return node	;

	pop	edi
	pop	ebp

; 66   : 	}

	add	esp, 8
	ret	4
?Alloc@?$FixedMAP@PAUSTextureList@@UmapNormalItems@R_dsgraph@@Udoug_lea_allocator@@@@AAEPAUTNode@1@ABQAUSTextureList@@@Z ENDP ; FixedMAP<STextureList *,R_dsgraph::mapNormalItems,doug_lea_allocator>::Alloc
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Orphan_range@?$vector@U_NormalItem@R_dsgraph@@V?$doug_lea_alloc@U_NormalItem@R_dsgraph@@@@@std@@ABEXPAU_NormalItem@R_dsgraph@@0@Z
_TEXT	SEGMENT
___formal$dead$ = 8					; size = 4
___formal$dead$ = 12					; size = 4
?_Orphan_range@?$vector@U_NormalItem@R_dsgraph@@V?$doug_lea_alloc@U_NormalItem@R_dsgraph@@@@@std@@ABEXPAU_NormalItem@R_dsgraph@@0@Z PROC ; std::vector<R_dsgraph::_NormalItem,doug_lea_alloc<R_dsgraph::_NormalItem> >::_Orphan_range, COMDAT
; _this$dead$ = ecx

; 1801 :     _CONSTEXPR20_CONTAINER void _Orphan_range(pointer, pointer) const {}

	ret	8
?_Orphan_range@?$vector@U_NormalItem@R_dsgraph@@V?$doug_lea_alloc@U_NormalItem@R_dsgraph@@@@@std@@ABEXPAU_NormalItem@R_dsgraph@@0@Z ENDP ; std::vector<R_dsgraph::_NormalItem,doug_lea_alloc<R_dsgraph::_NormalItem> >::_Orphan_range
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
;	COMDAT ?Realloc@?$FixedMAP@MU_LodItem@R_dsgraph@@Udoug_lea_allocator@@@@AAEXXZ
_TEXT	SEGMENT
tv318 = -8						; size = 4
_newLimit$1$ = -4					; size = 4
?Realloc@?$FixedMAP@MU_LodItem@R_dsgraph@@Udoug_lea_allocator@@@@AAEXXZ PROC ; FixedMAP<float,R_dsgraph::_LodItem,doug_lea_allocator>::Realloc, COMDAT
; _this$ = ecx

; 28   : 	{

	sub	esp, 8
	push	ebx
	push	ebp
	push	esi
	mov	esi, ecx
	push	edi

; 29   : 		u32	newLimit = limit + SG_REALLOC_ADVANCE;

	mov	ebx, DWORD PTR [esi+8]
	add	ebx, 64					; 00000040H
	mov	DWORD PTR _newLimit$1$[esp+24], ebx

; 30   : 		VERIFY(newLimit%SG_REALLOC_ADVANCE == 0);
; 31   : 		TNode*	newNodes = (TNode*)allocator::alloc(sizeof(TNode)*newLimit);

	lea	edi, DWORD PTR [ebx+ebx*4]
	shl	edi, 2
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h

; 51   : 		static	void	*alloc		(const u32 &n)	{	return dlmalloc((u32)n);	}

	mov	ecx, edi
	call	_dlmalloc
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h

; 34   : 		ZeroMemory(newNodes, Size(newLimit));

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	mov	ebp, eax
	push	edi
	push	0
	push	ebp
	mov	ecx, DWORD PTR [ecx+12]
	call	ecx

; 35   : 		if (limit) CopyMemory	(newNodes, nodes, Size(limit));

	mov	eax, DWORD PTR [esi+8]
	test	eax, eax
	je	SHORT $LN14@Realloc

; 25   : 	{	return Count*sizeof(TNode);	}

	lea	eax, DWORD PTR [eax+eax*4]
	shl	eax, 2

; 35   : 		if (limit) CopyMemory	(newNodes, nodes, Size(limit));

	push	eax
	push	DWORD PTR [esi]
	push	ebp
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN14@Realloc:

; 36   : 
; 37   : 		for (u32 I=0; I<pool; I++)

	xor	edi, edi
	cmp	DWORD PTR [esi+4], edi
	jbe	SHORT $LN9@Realloc
	mov	eax, -16				; fffffff0H
	lea	ecx, DWORD PTR [ebp+16]
	sub	eax, ebp
	mov	DWORD PTR tv318[esp+24], eax
	npad	1
$LL10@Realloc:

; 38   : 		{
; 39   : 			VERIFY	(nodes);
; 40   : 			TNode*	Nold	= nodes	+ I;

	mov	ebx, DWORD PTR [esi]
	lea	edx, DWORD PTR [eax+ecx]
	add	edx, ebx

; 41   : 			TNode*	Nnew	= newNodes + I;
; 42   : 
; 43   : 			if (Nold->left) {

	mov	eax, DWORD PTR [edx+12]
	test	eax, eax
	je	SHORT $LN31@Realloc

; 44   : 				size_t	Lid		= Nold->left  - nodes;

	sub	eax, ebx
	sar	eax, 2
	imul	eax, eax, -858993459

; 45   : 				Nnew->left		= newNodes + Lid;

	lea	eax, DWORD PTR [eax+eax*4]
	lea	eax, DWORD PTR [eax*4]
	add	eax, ebp
	mov	DWORD PTR [ecx-4], eax
	mov	ebx, DWORD PTR [esi]
$LN31@Realloc:

; 46   : 			}
; 47   : 			if (Nold->right) {

	mov	eax, DWORD PTR [edx+16]
	test	eax, eax
	je	SHORT $LN8@Realloc

; 48   : 				size_t	Rid		= Nold->right - nodes;

	sub	eax, ebx
	sar	eax, 2
	imul	eax, eax, -858993459

; 49   : 				Nnew->right		= newNodes + Rid;

	lea	eax, DWORD PTR [eax+eax*4]
	lea	eax, DWORD PTR [eax*4]
	add	eax, ebp
	mov	DWORD PTR [ecx], eax
$LN8@Realloc:

; 36   : 
; 37   : 		for (u32 I=0; I<pool; I++)

	mov	eax, DWORD PTR tv318[esp+24]
	inc	edi
	add	ecx, 20					; 00000014H
	cmp	edi, DWORD PTR [esi+4]
	jb	SHORT $LL10@Realloc
	mov	ebx, DWORD PTR _newLimit$1$[esp+24]
$LN9@Realloc:

; 50   : 			}
; 51   : 		}
; 52   : 		if (nodes) allocator::dealloc(nodes);

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN32@Realloc
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h

; 53   : 		static	void	dealloc		(T *&p)			{	dlfree(p);	p=0;			}

	call	_dlfree
$LN32@Realloc:
	pop	edi
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h

; 56   : 	}

	mov	DWORD PTR [esi+8], ebx
	mov	DWORD PTR [esi], ebp
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 8
	ret	0
?Realloc@?$FixedMAP@MU_LodItem@R_dsgraph@@Udoug_lea_allocator@@@@AAEXXZ ENDP ; FixedMAP<float,R_dsgraph::_LodItem,doug_lea_allocator>::Realloc
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
;	COMDAT ?Realloc@?$FixedMAP@MU_MatrixItemS@R_dsgraph@@Udoug_lea_allocator@@@@AAEXXZ
_TEXT	SEGMENT
tv344 = -8						; size = 4
_newLimit$1$ = -4					; size = 4
?Realloc@?$FixedMAP@MU_MatrixItemS@R_dsgraph@@Udoug_lea_allocator@@@@AAEXXZ PROC ; FixedMAP<float,R_dsgraph::_MatrixItemS,doug_lea_allocator>::Realloc, COMDAT
; _this$ = ecx

; 28   : 	{

	sub	esp, 8
	push	ebx
	push	ebp
	push	esi
	mov	esi, ecx
	push	edi

; 29   : 		u32	newLimit = limit + SG_REALLOC_ADVANCE;

	mov	ebp, DWORD PTR [esi+8]
	add	ebp, 64					; 00000040H

; 30   : 		VERIFY(newLimit%SG_REALLOC_ADVANCE == 0);
; 31   : 		TNode*	newNodes = (TNode*)allocator::alloc(sizeof(TNode)*newLimit);

	imul	edi, ebp, 92
	mov	DWORD PTR _newLimit$1$[esp+24], ebp
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h

; 51   : 		static	void	*alloc		(const u32 &n)	{	return dlmalloc((u32)n);	}

	mov	ecx, edi
	call	_dlmalloc
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h

; 34   : 		ZeroMemory(newNodes, Size(newLimit));

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	mov	ebx, eax
	push	edi
	push	0
	push	ebx
	mov	ecx, DWORD PTR [ecx+12]
	call	ecx

; 35   : 		if (limit) CopyMemory	(newNodes, nodes, Size(limit));

	mov	eax, DWORD PTR [esi+8]
	test	eax, eax
	je	SHORT $LN14@Realloc

; 25   : 	{	return Count*sizeof(TNode);	}

	imul	eax, eax, 92

; 35   : 		if (limit) CopyMemory	(newNodes, nodes, Size(limit));

	push	eax
	push	DWORD PTR [esi]
	push	ebx
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN14@Realloc:

; 36   : 
; 37   : 		for (u32 I=0; I<pool; I++)

	xor	edi, edi
	cmp	DWORD PTR [esi+4], edi
	jbe	SHORT $LN9@Realloc
	mov	eax, -88				; ffffffa8H
	lea	ecx, DWORD PTR [ebx+88]
	sub	eax, ebx
	mov	DWORD PTR tv344[esp+24], eax
	npad	7
$LL10@Realloc:

; 38   : 		{
; 39   : 			VERIFY	(nodes);
; 40   : 			TNode*	Nold	= nodes	+ I;

	mov	ebp, DWORD PTR [esi]
	lea	edx, DWORD PTR [eax+ecx]
	add	edx, ebp

; 41   : 			TNode*	Nnew	= newNodes + I;
; 42   : 
; 43   : 			if (Nold->left) {

	mov	eax, DWORD PTR [edx+84]
	test	eax, eax
	je	SHORT $LN31@Realloc

; 44   : 				size_t	Lid		= Nold->left  - nodes;

	sub	eax, ebp
	sar	eax, 2
	imul	eax, eax, -373475417

; 45   : 				Nnew->left		= newNodes + Lid;

	imul	eax, eax, 92
	add	eax, ebx
	mov	DWORD PTR [ecx-4], eax
	mov	ebp, DWORD PTR [esi]
$LN31@Realloc:

; 46   : 			}
; 47   : 			if (Nold->right) {

	mov	eax, DWORD PTR [edx+88]
	test	eax, eax
	je	SHORT $LN8@Realloc

; 48   : 				size_t	Rid		= Nold->right - nodes;

	sub	eax, ebp
	sar	eax, 2
	imul	eax, eax, -373475417

; 49   : 				Nnew->right		= newNodes + Rid;

	imul	eax, eax, 92
	add	eax, ebx
	mov	DWORD PTR [ecx], eax
$LN8@Realloc:

; 36   : 
; 37   : 		for (u32 I=0; I<pool; I++)

	mov	eax, DWORD PTR tv344[esp+24]
	inc	edi
	add	ecx, 92					; 0000005cH
	cmp	edi, DWORD PTR [esi+4]
	jb	SHORT $LL10@Realloc
	mov	ebp, DWORD PTR _newLimit$1$[esp+24]
$LN9@Realloc:

; 50   : 			}
; 51   : 		}
; 52   : 		if (nodes) allocator::dealloc(nodes);

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN32@Realloc
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h

; 53   : 		static	void	dealloc		(T *&p)			{	dlfree(p);	p=0;			}

	call	_dlfree
$LN32@Realloc:
	pop	edi
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h

; 56   : 	}

	mov	DWORD PTR [esi+8], ebp
	mov	DWORD PTR [esi], ebx
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 8
	ret	0
?Realloc@?$FixedMAP@MU_MatrixItemS@R_dsgraph@@Udoug_lea_allocator@@@@AAEXXZ ENDP ; FixedMAP<float,R_dsgraph::_MatrixItemS,doug_lea_allocator>::Realloc
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
;	COMDAT ?Realloc@?$FixedMAP@PAUIDirect3DVertexShader9@@UmapMatrixPS@R_dsgraph@@Udoug_lea_allocator@@@@AAEXXZ
_TEXT	SEGMENT
_newLimit$1$ = -8					; size = 4
tv318 = -4						; size = 4
?Realloc@?$FixedMAP@PAUIDirect3DVertexShader9@@UmapMatrixPS@R_dsgraph@@Udoug_lea_allocator@@@@AAEXXZ PROC ; FixedMAP<IDirect3DVertexShader9 *,R_dsgraph::mapMatrixPS,doug_lea_allocator>::Realloc, COMDAT
; _this$ = ecx

; 28   : 	{

	sub	esp, 8
	push	ebp
	push	esi
	mov	esi, ecx
	push	edi

; 29   : 		u32	newLimit = limit + SG_REALLOC_ADVANCE;

	mov	eax, DWORD PTR [esi+8]
	add	eax, 64					; 00000040H
	mov	DWORD PTR _newLimit$1$[esp+20], eax

; 30   : 		VERIFY(newLimit%SG_REALLOC_ADVANCE == 0);
; 31   : 		TNode*	newNodes = (TNode*)allocator::alloc(sizeof(TNode)*newLimit);

	lea	edi, DWORD PTR [eax*8]
	sub	edi, eax
	shl	edi, 2
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h

; 51   : 		static	void	*alloc		(const u32 &n)	{	return dlmalloc((u32)n);	}

	mov	ecx, edi
	call	_dlmalloc
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h

; 34   : 		ZeroMemory(newNodes, Size(newLimit));

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	mov	ebp, eax
	push	edi
	push	0
	push	ebp
	mov	ecx, DWORD PTR [ecx+12]
	call	ecx

; 35   : 		if (limit) CopyMemory	(newNodes, nodes, Size(limit));

	mov	ecx, DWORD PTR [esi+8]
	test	ecx, ecx
	je	SHORT $LN14@Realloc

; 25   : 	{	return Count*sizeof(TNode);	}

	lea	eax, DWORD PTR [ecx*8]
	sub	eax, ecx
	shl	eax, 2

; 35   : 		if (limit) CopyMemory	(newNodes, nodes, Size(limit));

	push	eax
	push	DWORD PTR [esi]
	push	ebp
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN14@Realloc:

; 36   : 
; 37   : 		for (u32 I=0; I<pool; I++)

	push	ebx
	xor	ebx, ebx
	cmp	DWORD PTR [esi+4], ebx
	jbe	SHORT $LN9@Realloc
	mov	eax, -24				; ffffffe8H
	lea	edx, DWORD PTR [ebp+24]
	sub	eax, ebp
	mov	DWORD PTR tv318[esp+24], eax
	npad	5
$LL10@Realloc:

; 38   : 		{
; 39   : 			VERIFY	(nodes);
; 40   : 			TNode*	Nold	= nodes	+ I;

	mov	ecx, DWORD PTR [esi]
	lea	edi, DWORD PTR [eax+edx]
	add	edi, ecx

; 41   : 			TNode*	Nnew	= newNodes + I;
; 42   : 
; 43   : 			if (Nold->left) {

	mov	eax, DWORD PTR [edi+20]
	test	eax, eax
	je	SHORT $LN31@Realloc

; 44   : 				size_t	Lid		= Nold->left  - nodes;

	sub	eax, ecx
	sar	eax, 2
	imul	ecx, eax, -1227133513

; 45   : 				Nnew->left		= newNodes + Lid;

	lea	eax, DWORD PTR [ecx*8]
	sub	eax, ecx
	lea	eax, DWORD PTR [eax*4]
	add	eax, ebp
	mov	DWORD PTR [edx-4], eax
	mov	ecx, DWORD PTR [esi]
$LN31@Realloc:

; 46   : 			}
; 47   : 			if (Nold->right) {

	mov	eax, DWORD PTR [edi+24]
	test	eax, eax
	je	SHORT $LN8@Realloc

; 48   : 				size_t	Rid		= Nold->right - nodes;

	sub	eax, ecx
	sar	eax, 2
	imul	ecx, eax, -1227133513

; 49   : 				Nnew->right		= newNodes + Rid;

	lea	eax, DWORD PTR [ecx*8]
	sub	eax, ecx
	lea	eax, DWORD PTR [eax*4]
	add	eax, ebp
	mov	DWORD PTR [edx], eax
$LN8@Realloc:

; 36   : 
; 37   : 		for (u32 I=0; I<pool; I++)

	mov	eax, DWORD PTR tv318[esp+24]
	inc	ebx
	add	edx, 28					; 0000001cH
	cmp	ebx, DWORD PTR [esi+4]
	jb	SHORT $LL10@Realloc
$LN9@Realloc:

; 50   : 			}
; 51   : 		}
; 52   : 		if (nodes) allocator::dealloc(nodes);

	mov	ecx, DWORD PTR [esi]
	pop	ebx
	test	ecx, ecx
	je	SHORT $LN32@Realloc
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h

; 53   : 		static	void	dealloc		(T *&p)			{	dlfree(p);	p=0;			}

	call	_dlfree
$LN32@Realloc:
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h

; 56   : 	}

	mov	eax, DWORD PTR _newLimit$1$[esp+20]
	pop	edi
	mov	DWORD PTR [esi], ebp
	mov	DWORD PTR [esi+8], eax
	pop	esi
	pop	ebp
	add	esp, 8
	ret	0
?Realloc@?$FixedMAP@PAUIDirect3DVertexShader9@@UmapMatrixPS@R_dsgraph@@Udoug_lea_allocator@@@@AAEXXZ ENDP ; FixedMAP<IDirect3DVertexShader9 *,R_dsgraph::mapMatrixPS,doug_lea_allocator>::Realloc
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
;	COMDAT ?Realloc@?$FixedMAP@PAUIDirect3DPixelShader9@@UmapMatrixCS@R_dsgraph@@Udoug_lea_allocator@@@@AAEXXZ
_TEXT	SEGMENT
_newLimit$1$ = -8					; size = 4
tv318 = -4						; size = 4
?Realloc@?$FixedMAP@PAUIDirect3DPixelShader9@@UmapMatrixCS@R_dsgraph@@Udoug_lea_allocator@@@@AAEXXZ PROC ; FixedMAP<IDirect3DPixelShader9 *,R_dsgraph::mapMatrixCS,doug_lea_allocator>::Realloc, COMDAT
; _this$ = ecx

; 28   : 	{

	sub	esp, 8
	push	ebp
	push	esi
	mov	esi, ecx
	push	edi

; 29   : 		u32	newLimit = limit + SG_REALLOC_ADVANCE;

	mov	eax, DWORD PTR [esi+8]
	add	eax, 64					; 00000040H
	mov	DWORD PTR _newLimit$1$[esp+20], eax

; 30   : 		VERIFY(newLimit%SG_REALLOC_ADVANCE == 0);
; 31   : 		TNode*	newNodes = (TNode*)allocator::alloc(sizeof(TNode)*newLimit);

	lea	edi, DWORD PTR [eax*8]
	sub	edi, eax
	shl	edi, 2
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h

; 51   : 		static	void	*alloc		(const u32 &n)	{	return dlmalloc((u32)n);	}

	mov	ecx, edi
	call	_dlmalloc
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h

; 34   : 		ZeroMemory(newNodes, Size(newLimit));

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	mov	ebp, eax
	push	edi
	push	0
	push	ebp
	mov	ecx, DWORD PTR [ecx+12]
	call	ecx

; 35   : 		if (limit) CopyMemory	(newNodes, nodes, Size(limit));

	mov	ecx, DWORD PTR [esi+8]
	test	ecx, ecx
	je	SHORT $LN14@Realloc

; 25   : 	{	return Count*sizeof(TNode);	}

	lea	eax, DWORD PTR [ecx*8]
	sub	eax, ecx
	shl	eax, 2

; 35   : 		if (limit) CopyMemory	(newNodes, nodes, Size(limit));

	push	eax
	push	DWORD PTR [esi]
	push	ebp
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN14@Realloc:

; 36   : 
; 37   : 		for (u32 I=0; I<pool; I++)

	push	ebx
	xor	ebx, ebx
	cmp	DWORD PTR [esi+4], ebx
	jbe	SHORT $LN9@Realloc
	mov	eax, -24				; ffffffe8H
	lea	edx, DWORD PTR [ebp+24]
	sub	eax, ebp
	mov	DWORD PTR tv318[esp+24], eax
	npad	5
$LL10@Realloc:

; 38   : 		{
; 39   : 			VERIFY	(nodes);
; 40   : 			TNode*	Nold	= nodes	+ I;

	mov	ecx, DWORD PTR [esi]
	lea	edi, DWORD PTR [eax+edx]
	add	edi, ecx

; 41   : 			TNode*	Nnew	= newNodes + I;
; 42   : 
; 43   : 			if (Nold->left) {

	mov	eax, DWORD PTR [edi+20]
	test	eax, eax
	je	SHORT $LN31@Realloc

; 44   : 				size_t	Lid		= Nold->left  - nodes;

	sub	eax, ecx
	sar	eax, 2
	imul	ecx, eax, -1227133513

; 45   : 				Nnew->left		= newNodes + Lid;

	lea	eax, DWORD PTR [ecx*8]
	sub	eax, ecx
	lea	eax, DWORD PTR [eax*4]
	add	eax, ebp
	mov	DWORD PTR [edx-4], eax
	mov	ecx, DWORD PTR [esi]
$LN31@Realloc:

; 46   : 			}
; 47   : 			if (Nold->right) {

	mov	eax, DWORD PTR [edi+24]
	test	eax, eax
	je	SHORT $LN8@Realloc

; 48   : 				size_t	Rid		= Nold->right - nodes;

	sub	eax, ecx
	sar	eax, 2
	imul	ecx, eax, -1227133513

; 49   : 				Nnew->right		= newNodes + Rid;

	lea	eax, DWORD PTR [ecx*8]
	sub	eax, ecx
	lea	eax, DWORD PTR [eax*4]
	add	eax, ebp
	mov	DWORD PTR [edx], eax
$LN8@Realloc:

; 36   : 
; 37   : 		for (u32 I=0; I<pool; I++)

	mov	eax, DWORD PTR tv318[esp+24]
	inc	ebx
	add	edx, 28					; 0000001cH
	cmp	ebx, DWORD PTR [esi+4]
	jb	SHORT $LL10@Realloc
$LN9@Realloc:

; 50   : 			}
; 51   : 		}
; 52   : 		if (nodes) allocator::dealloc(nodes);

	mov	ecx, DWORD PTR [esi]
	pop	ebx
	test	ecx, ecx
	je	SHORT $LN32@Realloc
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h

; 53   : 		static	void	dealloc		(T *&p)			{	dlfree(p);	p=0;			}

	call	_dlfree
$LN32@Realloc:
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h

; 56   : 	}

	mov	eax, DWORD PTR _newLimit$1$[esp+20]
	pop	edi
	mov	DWORD PTR [esi], ebp
	mov	DWORD PTR [esi+8], eax
	pop	esi
	pop	ebp
	add	esp, 8
	ret	0
?Realloc@?$FixedMAP@PAUIDirect3DPixelShader9@@UmapMatrixCS@R_dsgraph@@Udoug_lea_allocator@@@@AAEXXZ ENDP ; FixedMAP<IDirect3DPixelShader9 *,R_dsgraph::mapMatrixCS,doug_lea_allocator>::Realloc
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
;	COMDAT ?Realloc@?$FixedMAP@PAVR_constant_table@@UmapMatrixStates@R_dsgraph@@Udoug_lea_allocator@@@@AAEXXZ
_TEXT	SEGMENT
_newLimit$1$ = -8					; size = 4
tv318 = -4						; size = 4
?Realloc@?$FixedMAP@PAVR_constant_table@@UmapMatrixStates@R_dsgraph@@Udoug_lea_allocator@@@@AAEXXZ PROC ; FixedMAP<R_constant_table *,R_dsgraph::mapMatrixStates,doug_lea_allocator>::Realloc, COMDAT
; _this$ = ecx

; 28   : 	{

	sub	esp, 8
	push	ebp
	push	esi
	mov	esi, ecx
	push	edi

; 29   : 		u32	newLimit = limit + SG_REALLOC_ADVANCE;

	mov	eax, DWORD PTR [esi+8]
	add	eax, 64					; 00000040H
	mov	DWORD PTR _newLimit$1$[esp+20], eax

; 30   : 		VERIFY(newLimit%SG_REALLOC_ADVANCE == 0);
; 31   : 		TNode*	newNodes = (TNode*)allocator::alloc(sizeof(TNode)*newLimit);

	lea	edi, DWORD PTR [eax*8]
	sub	edi, eax
	shl	edi, 2
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h

; 51   : 		static	void	*alloc		(const u32 &n)	{	return dlmalloc((u32)n);	}

	mov	ecx, edi
	call	_dlmalloc
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h

; 34   : 		ZeroMemory(newNodes, Size(newLimit));

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	mov	ebp, eax
	push	edi
	push	0
	push	ebp
	mov	ecx, DWORD PTR [ecx+12]
	call	ecx

; 35   : 		if (limit) CopyMemory	(newNodes, nodes, Size(limit));

	mov	ecx, DWORD PTR [esi+8]
	test	ecx, ecx
	je	SHORT $LN14@Realloc

; 25   : 	{	return Count*sizeof(TNode);	}

	lea	eax, DWORD PTR [ecx*8]
	sub	eax, ecx
	shl	eax, 2

; 35   : 		if (limit) CopyMemory	(newNodes, nodes, Size(limit));

	push	eax
	push	DWORD PTR [esi]
	push	ebp
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN14@Realloc:

; 36   : 
; 37   : 		for (u32 I=0; I<pool; I++)

	push	ebx
	xor	ebx, ebx
	cmp	DWORD PTR [esi+4], ebx
	jbe	SHORT $LN9@Realloc
	mov	eax, -24				; ffffffe8H
	lea	edx, DWORD PTR [ebp+24]
	sub	eax, ebp
	mov	DWORD PTR tv318[esp+24], eax
	npad	5
$LL10@Realloc:

; 38   : 		{
; 39   : 			VERIFY	(nodes);
; 40   : 			TNode*	Nold	= nodes	+ I;

	mov	ecx, DWORD PTR [esi]
	lea	edi, DWORD PTR [eax+edx]
	add	edi, ecx

; 41   : 			TNode*	Nnew	= newNodes + I;
; 42   : 
; 43   : 			if (Nold->left) {

	mov	eax, DWORD PTR [edi+20]
	test	eax, eax
	je	SHORT $LN31@Realloc

; 44   : 				size_t	Lid		= Nold->left  - nodes;

	sub	eax, ecx
	sar	eax, 2
	imul	ecx, eax, -1227133513

; 45   : 				Nnew->left		= newNodes + Lid;

	lea	eax, DWORD PTR [ecx*8]
	sub	eax, ecx
	lea	eax, DWORD PTR [eax*4]
	add	eax, ebp
	mov	DWORD PTR [edx-4], eax
	mov	ecx, DWORD PTR [esi]
$LN31@Realloc:

; 46   : 			}
; 47   : 			if (Nold->right) {

	mov	eax, DWORD PTR [edi+24]
	test	eax, eax
	je	SHORT $LN8@Realloc

; 48   : 				size_t	Rid		= Nold->right - nodes;

	sub	eax, ecx
	sar	eax, 2
	imul	ecx, eax, -1227133513

; 49   : 				Nnew->right		= newNodes + Rid;

	lea	eax, DWORD PTR [ecx*8]
	sub	eax, ecx
	lea	eax, DWORD PTR [eax*4]
	add	eax, ebp
	mov	DWORD PTR [edx], eax
$LN8@Realloc:

; 36   : 
; 37   : 		for (u32 I=0; I<pool; I++)

	mov	eax, DWORD PTR tv318[esp+24]
	inc	ebx
	add	edx, 28					; 0000001cH
	cmp	ebx, DWORD PTR [esi+4]
	jb	SHORT $LL10@Realloc
$LN9@Realloc:

; 50   : 			}
; 51   : 		}
; 52   : 		if (nodes) allocator::dealloc(nodes);

	mov	ecx, DWORD PTR [esi]
	pop	ebx
	test	ecx, ecx
	je	SHORT $LN32@Realloc
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h

; 53   : 		static	void	dealloc		(T *&p)			{	dlfree(p);	p=0;			}

	call	_dlfree
$LN32@Realloc:
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h

; 56   : 	}

	mov	eax, DWORD PTR _newLimit$1$[esp+20]
	pop	edi
	mov	DWORD PTR [esi], ebp
	mov	DWORD PTR [esi+8], eax
	pop	esi
	pop	ebp
	add	esp, 8
	ret	0
?Realloc@?$FixedMAP@PAVR_constant_table@@UmapMatrixStates@R_dsgraph@@Udoug_lea_allocator@@@@AAEXXZ ENDP ; FixedMAP<R_constant_table *,R_dsgraph::mapMatrixStates,doug_lea_allocator>::Realloc
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
;	COMDAT ?Realloc@?$FixedMAP@PAUIDirect3DStateBlock9@@UmapMatrixTextures@R_dsgraph@@Udoug_lea_allocator@@@@AAEXXZ
_TEXT	SEGMENT
_newLimit$1$ = -8					; size = 4
tv318 = -4						; size = 4
?Realloc@?$FixedMAP@PAUIDirect3DStateBlock9@@UmapMatrixTextures@R_dsgraph@@Udoug_lea_allocator@@@@AAEXXZ PROC ; FixedMAP<IDirect3DStateBlock9 *,R_dsgraph::mapMatrixTextures,doug_lea_allocator>::Realloc, COMDAT
; _this$ = ecx

; 28   : 	{

	sub	esp, 8
	push	ebp
	push	esi
	mov	esi, ecx
	push	edi

; 29   : 		u32	newLimit = limit + SG_REALLOC_ADVANCE;

	mov	eax, DWORD PTR [esi+8]
	add	eax, 64					; 00000040H
	mov	DWORD PTR _newLimit$1$[esp+20], eax

; 30   : 		VERIFY(newLimit%SG_REALLOC_ADVANCE == 0);
; 31   : 		TNode*	newNodes = (TNode*)allocator::alloc(sizeof(TNode)*newLimit);

	lea	edi, DWORD PTR [eax*8]
	sub	edi, eax
	shl	edi, 2
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h

; 51   : 		static	void	*alloc		(const u32 &n)	{	return dlmalloc((u32)n);	}

	mov	ecx, edi
	call	_dlmalloc
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h

; 34   : 		ZeroMemory(newNodes, Size(newLimit));

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	mov	ebp, eax
	push	edi
	push	0
	push	ebp
	mov	ecx, DWORD PTR [ecx+12]
	call	ecx

; 35   : 		if (limit) CopyMemory	(newNodes, nodes, Size(limit));

	mov	ecx, DWORD PTR [esi+8]
	test	ecx, ecx
	je	SHORT $LN14@Realloc

; 25   : 	{	return Count*sizeof(TNode);	}

	lea	eax, DWORD PTR [ecx*8]
	sub	eax, ecx
	shl	eax, 2

; 35   : 		if (limit) CopyMemory	(newNodes, nodes, Size(limit));

	push	eax
	push	DWORD PTR [esi]
	push	ebp
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN14@Realloc:

; 36   : 
; 37   : 		for (u32 I=0; I<pool; I++)

	push	ebx
	xor	ebx, ebx
	cmp	DWORD PTR [esi+4], ebx
	jbe	SHORT $LN9@Realloc
	mov	eax, -24				; ffffffe8H
	lea	edx, DWORD PTR [ebp+24]
	sub	eax, ebp
	mov	DWORD PTR tv318[esp+24], eax
	npad	5
$LL10@Realloc:

; 38   : 		{
; 39   : 			VERIFY	(nodes);
; 40   : 			TNode*	Nold	= nodes	+ I;

	mov	ecx, DWORD PTR [esi]
	lea	edi, DWORD PTR [eax+edx]
	add	edi, ecx

; 41   : 			TNode*	Nnew	= newNodes + I;
; 42   : 
; 43   : 			if (Nold->left) {

	mov	eax, DWORD PTR [edi+20]
	test	eax, eax
	je	SHORT $LN31@Realloc

; 44   : 				size_t	Lid		= Nold->left  - nodes;

	sub	eax, ecx
	sar	eax, 2
	imul	ecx, eax, -1227133513

; 45   : 				Nnew->left		= newNodes + Lid;

	lea	eax, DWORD PTR [ecx*8]
	sub	eax, ecx
	lea	eax, DWORD PTR [eax*4]
	add	eax, ebp
	mov	DWORD PTR [edx-4], eax
	mov	ecx, DWORD PTR [esi]
$LN31@Realloc:

; 46   : 			}
; 47   : 			if (Nold->right) {

	mov	eax, DWORD PTR [edi+24]
	test	eax, eax
	je	SHORT $LN8@Realloc

; 48   : 				size_t	Rid		= Nold->right - nodes;

	sub	eax, ecx
	sar	eax, 2
	imul	ecx, eax, -1227133513

; 49   : 				Nnew->right		= newNodes + Rid;

	lea	eax, DWORD PTR [ecx*8]
	sub	eax, ecx
	lea	eax, DWORD PTR [eax*4]
	add	eax, ebp
	mov	DWORD PTR [edx], eax
$LN8@Realloc:

; 36   : 
; 37   : 		for (u32 I=0; I<pool; I++)

	mov	eax, DWORD PTR tv318[esp+24]
	inc	ebx
	add	edx, 28					; 0000001cH
	cmp	ebx, DWORD PTR [esi+4]
	jb	SHORT $LL10@Realloc
$LN9@Realloc:

; 50   : 			}
; 51   : 		}
; 52   : 		if (nodes) allocator::dealloc(nodes);

	mov	ecx, DWORD PTR [esi]
	pop	ebx
	test	ecx, ecx
	je	SHORT $LN32@Realloc
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h

; 53   : 		static	void	dealloc		(T *&p)			{	dlfree(p);	p=0;			}

	call	_dlfree
$LN32@Realloc:
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h

; 56   : 	}

	mov	eax, DWORD PTR _newLimit$1$[esp+20]
	pop	edi
	mov	DWORD PTR [esi], ebp
	mov	DWORD PTR [esi+8], eax
	pop	esi
	pop	ebp
	add	esp, 8
	ret	0
?Realloc@?$FixedMAP@PAUIDirect3DStateBlock9@@UmapMatrixTextures@R_dsgraph@@Udoug_lea_allocator@@@@AAEXXZ ENDP ; FixedMAP<IDirect3DStateBlock9 *,R_dsgraph::mapMatrixTextures,doug_lea_allocator>::Realloc
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
;	COMDAT ?Realloc@?$FixedMAP@PAUSTextureList@@UmapMatrixItems@R_dsgraph@@Udoug_lea_allocator@@@@AAEXXZ
_TEXT	SEGMENT
_newLimit$1$ = -8					; size = 4
tv318 = -4						; size = 4
?Realloc@?$FixedMAP@PAUSTextureList@@UmapMatrixItems@R_dsgraph@@Udoug_lea_allocator@@@@AAEXXZ PROC ; FixedMAP<STextureList *,R_dsgraph::mapMatrixItems,doug_lea_allocator>::Realloc, COMDAT
; _this$ = ecx

; 28   : 	{

	sub	esp, 8
	push	ebp
	push	esi
	mov	esi, ecx
	push	edi

; 29   : 		u32	newLimit = limit + SG_REALLOC_ADVANCE;

	mov	eax, DWORD PTR [esi+8]
	add	eax, 64					; 00000040H
	mov	DWORD PTR _newLimit$1$[esp+20], eax

; 30   : 		VERIFY(newLimit%SG_REALLOC_ADVANCE == 0);
; 31   : 		TNode*	newNodes = (TNode*)allocator::alloc(sizeof(TNode)*newLimit);

	lea	edi, DWORD PTR [eax*8]
	sub	edi, eax
	shl	edi, 2
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h

; 51   : 		static	void	*alloc		(const u32 &n)	{	return dlmalloc((u32)n);	}

	mov	ecx, edi
	call	_dlmalloc
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h

; 34   : 		ZeroMemory(newNodes, Size(newLimit));

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	mov	ebp, eax
	push	edi
	push	0
	push	ebp
	mov	ecx, DWORD PTR [ecx+12]
	call	ecx

; 35   : 		if (limit) CopyMemory	(newNodes, nodes, Size(limit));

	mov	ecx, DWORD PTR [esi+8]
	test	ecx, ecx
	je	SHORT $LN14@Realloc

; 25   : 	{	return Count*sizeof(TNode);	}

	lea	eax, DWORD PTR [ecx*8]
	sub	eax, ecx
	shl	eax, 2

; 35   : 		if (limit) CopyMemory	(newNodes, nodes, Size(limit));

	push	eax
	push	DWORD PTR [esi]
	push	ebp
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN14@Realloc:

; 36   : 
; 37   : 		for (u32 I=0; I<pool; I++)

	push	ebx
	xor	ebx, ebx
	cmp	DWORD PTR [esi+4], ebx
	jbe	SHORT $LN9@Realloc
	mov	eax, -24				; ffffffe8H
	lea	edx, DWORD PTR [ebp+24]
	sub	eax, ebp
	mov	DWORD PTR tv318[esp+24], eax
	npad	5
$LL10@Realloc:

; 38   : 		{
; 39   : 			VERIFY	(nodes);
; 40   : 			TNode*	Nold	= nodes	+ I;

	mov	ecx, DWORD PTR [esi]
	lea	edi, DWORD PTR [eax+edx]
	add	edi, ecx

; 41   : 			TNode*	Nnew	= newNodes + I;
; 42   : 
; 43   : 			if (Nold->left) {

	mov	eax, DWORD PTR [edi+20]
	test	eax, eax
	je	SHORT $LN31@Realloc

; 44   : 				size_t	Lid		= Nold->left  - nodes;

	sub	eax, ecx
	sar	eax, 2
	imul	ecx, eax, -1227133513

; 45   : 				Nnew->left		= newNodes + Lid;

	lea	eax, DWORD PTR [ecx*8]
	sub	eax, ecx
	lea	eax, DWORD PTR [eax*4]
	add	eax, ebp
	mov	DWORD PTR [edx-4], eax
	mov	ecx, DWORD PTR [esi]
$LN31@Realloc:

; 46   : 			}
; 47   : 			if (Nold->right) {

	mov	eax, DWORD PTR [edi+24]
	test	eax, eax
	je	SHORT $LN8@Realloc

; 48   : 				size_t	Rid		= Nold->right - nodes;

	sub	eax, ecx
	sar	eax, 2
	imul	ecx, eax, -1227133513

; 49   : 				Nnew->right		= newNodes + Rid;

	lea	eax, DWORD PTR [ecx*8]
	sub	eax, ecx
	lea	eax, DWORD PTR [eax*4]
	add	eax, ebp
	mov	DWORD PTR [edx], eax
$LN8@Realloc:

; 36   : 
; 37   : 		for (u32 I=0; I<pool; I++)

	mov	eax, DWORD PTR tv318[esp+24]
	inc	ebx
	add	edx, 28					; 0000001cH
	cmp	ebx, DWORD PTR [esi+4]
	jb	SHORT $LL10@Realloc
$LN9@Realloc:

; 50   : 			}
; 51   : 		}
; 52   : 		if (nodes) allocator::dealloc(nodes);

	mov	ecx, DWORD PTR [esi]
	pop	ebx
	test	ecx, ecx
	je	SHORT $LN32@Realloc
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h

; 53   : 		static	void	dealloc		(T *&p)			{	dlfree(p);	p=0;			}

	call	_dlfree
$LN32@Realloc:
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h

; 56   : 	}

	mov	eax, DWORD PTR _newLimit$1$[esp+20]
	pop	edi
	mov	DWORD PTR [esi], ebp
	mov	DWORD PTR [esi+8], eax
	pop	esi
	pop	ebp
	add	esp, 8
	ret	0
?Realloc@?$FixedMAP@PAUSTextureList@@UmapMatrixItems@R_dsgraph@@Udoug_lea_allocator@@@@AAEXXZ ENDP ; FixedMAP<STextureList *,R_dsgraph::mapMatrixItems,doug_lea_allocator>::Realloc
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
;	COMDAT ?Realloc@?$FixedMAP@PAUIDirect3DVertexShader9@@UmapNormalPS@R_dsgraph@@Udoug_lea_allocator@@@@AAEXXZ
_TEXT	SEGMENT
_newLimit$1$ = -8					; size = 4
tv318 = -4						; size = 4
?Realloc@?$FixedMAP@PAUIDirect3DVertexShader9@@UmapNormalPS@R_dsgraph@@Udoug_lea_allocator@@@@AAEXXZ PROC ; FixedMAP<IDirect3DVertexShader9 *,R_dsgraph::mapNormalPS,doug_lea_allocator>::Realloc, COMDAT
; _this$ = ecx

; 28   : 	{

	sub	esp, 8
	push	ebp
	push	esi
	mov	esi, ecx
	push	edi

; 29   : 		u32	newLimit = limit + SG_REALLOC_ADVANCE;

	mov	eax, DWORD PTR [esi+8]
	add	eax, 64					; 00000040H
	mov	DWORD PTR _newLimit$1$[esp+20], eax

; 30   : 		VERIFY(newLimit%SG_REALLOC_ADVANCE == 0);
; 31   : 		TNode*	newNodes = (TNode*)allocator::alloc(sizeof(TNode)*newLimit);

	lea	edi, DWORD PTR [eax*8]
	sub	edi, eax
	shl	edi, 2
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h

; 51   : 		static	void	*alloc		(const u32 &n)	{	return dlmalloc((u32)n);	}

	mov	ecx, edi
	call	_dlmalloc
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h

; 34   : 		ZeroMemory(newNodes, Size(newLimit));

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	mov	ebp, eax
	push	edi
	push	0
	push	ebp
	mov	ecx, DWORD PTR [ecx+12]
	call	ecx

; 35   : 		if (limit) CopyMemory	(newNodes, nodes, Size(limit));

	mov	ecx, DWORD PTR [esi+8]
	test	ecx, ecx
	je	SHORT $LN14@Realloc

; 25   : 	{	return Count*sizeof(TNode);	}

	lea	eax, DWORD PTR [ecx*8]
	sub	eax, ecx
	shl	eax, 2

; 35   : 		if (limit) CopyMemory	(newNodes, nodes, Size(limit));

	push	eax
	push	DWORD PTR [esi]
	push	ebp
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN14@Realloc:

; 36   : 
; 37   : 		for (u32 I=0; I<pool; I++)

	push	ebx
	xor	ebx, ebx
	cmp	DWORD PTR [esi+4], ebx
	jbe	SHORT $LN9@Realloc
	mov	eax, -24				; ffffffe8H
	lea	edx, DWORD PTR [ebp+24]
	sub	eax, ebp
	mov	DWORD PTR tv318[esp+24], eax
	npad	5
$LL10@Realloc:

; 38   : 		{
; 39   : 			VERIFY	(nodes);
; 40   : 			TNode*	Nold	= nodes	+ I;

	mov	ecx, DWORD PTR [esi]
	lea	edi, DWORD PTR [eax+edx]
	add	edi, ecx

; 41   : 			TNode*	Nnew	= newNodes + I;
; 42   : 
; 43   : 			if (Nold->left) {

	mov	eax, DWORD PTR [edi+20]
	test	eax, eax
	je	SHORT $LN31@Realloc

; 44   : 				size_t	Lid		= Nold->left  - nodes;

	sub	eax, ecx
	sar	eax, 2
	imul	ecx, eax, -1227133513

; 45   : 				Nnew->left		= newNodes + Lid;

	lea	eax, DWORD PTR [ecx*8]
	sub	eax, ecx
	lea	eax, DWORD PTR [eax*4]
	add	eax, ebp
	mov	DWORD PTR [edx-4], eax
	mov	ecx, DWORD PTR [esi]
$LN31@Realloc:

; 46   : 			}
; 47   : 			if (Nold->right) {

	mov	eax, DWORD PTR [edi+24]
	test	eax, eax
	je	SHORT $LN8@Realloc

; 48   : 				size_t	Rid		= Nold->right - nodes;

	sub	eax, ecx
	sar	eax, 2
	imul	ecx, eax, -1227133513

; 49   : 				Nnew->right		= newNodes + Rid;

	lea	eax, DWORD PTR [ecx*8]
	sub	eax, ecx
	lea	eax, DWORD PTR [eax*4]
	add	eax, ebp
	mov	DWORD PTR [edx], eax
$LN8@Realloc:

; 36   : 
; 37   : 		for (u32 I=0; I<pool; I++)

	mov	eax, DWORD PTR tv318[esp+24]
	inc	ebx
	add	edx, 28					; 0000001cH
	cmp	ebx, DWORD PTR [esi+4]
	jb	SHORT $LL10@Realloc
$LN9@Realloc:

; 50   : 			}
; 51   : 		}
; 52   : 		if (nodes) allocator::dealloc(nodes);

	mov	ecx, DWORD PTR [esi]
	pop	ebx
	test	ecx, ecx
	je	SHORT $LN32@Realloc
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h

; 53   : 		static	void	dealloc		(T *&p)			{	dlfree(p);	p=0;			}

	call	_dlfree
$LN32@Realloc:
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h

; 56   : 	}

	mov	eax, DWORD PTR _newLimit$1$[esp+20]
	pop	edi
	mov	DWORD PTR [esi], ebp
	mov	DWORD PTR [esi+8], eax
	pop	esi
	pop	ebp
	add	esp, 8
	ret	0
?Realloc@?$FixedMAP@PAUIDirect3DVertexShader9@@UmapNormalPS@R_dsgraph@@Udoug_lea_allocator@@@@AAEXXZ ENDP ; FixedMAP<IDirect3DVertexShader9 *,R_dsgraph::mapNormalPS,doug_lea_allocator>::Realloc
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
;	COMDAT ?Realloc@?$FixedMAP@PAUIDirect3DPixelShader9@@UmapNormalCS@R_dsgraph@@Udoug_lea_allocator@@@@AAEXXZ
_TEXT	SEGMENT
_newLimit$1$ = -8					; size = 4
tv318 = -4						; size = 4
?Realloc@?$FixedMAP@PAUIDirect3DPixelShader9@@UmapNormalCS@R_dsgraph@@Udoug_lea_allocator@@@@AAEXXZ PROC ; FixedMAP<IDirect3DPixelShader9 *,R_dsgraph::mapNormalCS,doug_lea_allocator>::Realloc, COMDAT
; _this$ = ecx

; 28   : 	{

	sub	esp, 8
	push	ebp
	push	esi
	mov	esi, ecx
	push	edi

; 29   : 		u32	newLimit = limit + SG_REALLOC_ADVANCE;

	mov	eax, DWORD PTR [esi+8]
	add	eax, 64					; 00000040H
	mov	DWORD PTR _newLimit$1$[esp+20], eax

; 30   : 		VERIFY(newLimit%SG_REALLOC_ADVANCE == 0);
; 31   : 		TNode*	newNodes = (TNode*)allocator::alloc(sizeof(TNode)*newLimit);

	lea	edi, DWORD PTR [eax*8]
	sub	edi, eax
	shl	edi, 2
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h

; 51   : 		static	void	*alloc		(const u32 &n)	{	return dlmalloc((u32)n);	}

	mov	ecx, edi
	call	_dlmalloc
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h

; 34   : 		ZeroMemory(newNodes, Size(newLimit));

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	mov	ebp, eax
	push	edi
	push	0
	push	ebp
	mov	ecx, DWORD PTR [ecx+12]
	call	ecx

; 35   : 		if (limit) CopyMemory	(newNodes, nodes, Size(limit));

	mov	ecx, DWORD PTR [esi+8]
	test	ecx, ecx
	je	SHORT $LN14@Realloc

; 25   : 	{	return Count*sizeof(TNode);	}

	lea	eax, DWORD PTR [ecx*8]
	sub	eax, ecx
	shl	eax, 2

; 35   : 		if (limit) CopyMemory	(newNodes, nodes, Size(limit));

	push	eax
	push	DWORD PTR [esi]
	push	ebp
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN14@Realloc:

; 36   : 
; 37   : 		for (u32 I=0; I<pool; I++)

	push	ebx
	xor	ebx, ebx
	cmp	DWORD PTR [esi+4], ebx
	jbe	SHORT $LN9@Realloc
	mov	eax, -24				; ffffffe8H
	lea	edx, DWORD PTR [ebp+24]
	sub	eax, ebp
	mov	DWORD PTR tv318[esp+24], eax
	npad	5
$LL10@Realloc:

; 38   : 		{
; 39   : 			VERIFY	(nodes);
; 40   : 			TNode*	Nold	= nodes	+ I;

	mov	ecx, DWORD PTR [esi]
	lea	edi, DWORD PTR [eax+edx]
	add	edi, ecx

; 41   : 			TNode*	Nnew	= newNodes + I;
; 42   : 
; 43   : 			if (Nold->left) {

	mov	eax, DWORD PTR [edi+20]
	test	eax, eax
	je	SHORT $LN31@Realloc

; 44   : 				size_t	Lid		= Nold->left  - nodes;

	sub	eax, ecx
	sar	eax, 2
	imul	ecx, eax, -1227133513

; 45   : 				Nnew->left		= newNodes + Lid;

	lea	eax, DWORD PTR [ecx*8]
	sub	eax, ecx
	lea	eax, DWORD PTR [eax*4]
	add	eax, ebp
	mov	DWORD PTR [edx-4], eax
	mov	ecx, DWORD PTR [esi]
$LN31@Realloc:

; 46   : 			}
; 47   : 			if (Nold->right) {

	mov	eax, DWORD PTR [edi+24]
	test	eax, eax
	je	SHORT $LN8@Realloc

; 48   : 				size_t	Rid		= Nold->right - nodes;

	sub	eax, ecx
	sar	eax, 2
	imul	ecx, eax, -1227133513

; 49   : 				Nnew->right		= newNodes + Rid;

	lea	eax, DWORD PTR [ecx*8]
	sub	eax, ecx
	lea	eax, DWORD PTR [eax*4]
	add	eax, ebp
	mov	DWORD PTR [edx], eax
$LN8@Realloc:

; 36   : 
; 37   : 		for (u32 I=0; I<pool; I++)

	mov	eax, DWORD PTR tv318[esp+24]
	inc	ebx
	add	edx, 28					; 0000001cH
	cmp	ebx, DWORD PTR [esi+4]
	jb	SHORT $LL10@Realloc
$LN9@Realloc:

; 50   : 			}
; 51   : 		}
; 52   : 		if (nodes) allocator::dealloc(nodes);

	mov	ecx, DWORD PTR [esi]
	pop	ebx
	test	ecx, ecx
	je	SHORT $LN32@Realloc
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h

; 53   : 		static	void	dealloc		(T *&p)			{	dlfree(p);	p=0;			}

	call	_dlfree
$LN32@Realloc:
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h

; 56   : 	}

	mov	eax, DWORD PTR _newLimit$1$[esp+20]
	pop	edi
	mov	DWORD PTR [esi], ebp
	mov	DWORD PTR [esi+8], eax
	pop	esi
	pop	ebp
	add	esp, 8
	ret	0
?Realloc@?$FixedMAP@PAUIDirect3DPixelShader9@@UmapNormalCS@R_dsgraph@@Udoug_lea_allocator@@@@AAEXXZ ENDP ; FixedMAP<IDirect3DPixelShader9 *,R_dsgraph::mapNormalCS,doug_lea_allocator>::Realloc
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
;	COMDAT ?Realloc@?$FixedMAP@PAVR_constant_table@@UmapNormalStates@R_dsgraph@@Udoug_lea_allocator@@@@AAEXXZ
_TEXT	SEGMENT
_newLimit$1$ = -8					; size = 4
tv318 = -4						; size = 4
?Realloc@?$FixedMAP@PAVR_constant_table@@UmapNormalStates@R_dsgraph@@Udoug_lea_allocator@@@@AAEXXZ PROC ; FixedMAP<R_constant_table *,R_dsgraph::mapNormalStates,doug_lea_allocator>::Realloc, COMDAT
; _this$ = ecx

; 28   : 	{

	sub	esp, 8
	push	ebp
	push	esi
	mov	esi, ecx
	push	edi

; 29   : 		u32	newLimit = limit + SG_REALLOC_ADVANCE;

	mov	eax, DWORD PTR [esi+8]
	add	eax, 64					; 00000040H
	mov	DWORD PTR _newLimit$1$[esp+20], eax

; 30   : 		VERIFY(newLimit%SG_REALLOC_ADVANCE == 0);
; 31   : 		TNode*	newNodes = (TNode*)allocator::alloc(sizeof(TNode)*newLimit);

	lea	edi, DWORD PTR [eax*8]
	sub	edi, eax
	shl	edi, 2
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h

; 51   : 		static	void	*alloc		(const u32 &n)	{	return dlmalloc((u32)n);	}

	mov	ecx, edi
	call	_dlmalloc
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h

; 34   : 		ZeroMemory(newNodes, Size(newLimit));

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	mov	ebp, eax
	push	edi
	push	0
	push	ebp
	mov	ecx, DWORD PTR [ecx+12]
	call	ecx

; 35   : 		if (limit) CopyMemory	(newNodes, nodes, Size(limit));

	mov	ecx, DWORD PTR [esi+8]
	test	ecx, ecx
	je	SHORT $LN14@Realloc

; 25   : 	{	return Count*sizeof(TNode);	}

	lea	eax, DWORD PTR [ecx*8]
	sub	eax, ecx
	shl	eax, 2

; 35   : 		if (limit) CopyMemory	(newNodes, nodes, Size(limit));

	push	eax
	push	DWORD PTR [esi]
	push	ebp
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN14@Realloc:

; 36   : 
; 37   : 		for (u32 I=0; I<pool; I++)

	push	ebx
	xor	ebx, ebx
	cmp	DWORD PTR [esi+4], ebx
	jbe	SHORT $LN9@Realloc
	mov	eax, -24				; ffffffe8H
	lea	edx, DWORD PTR [ebp+24]
	sub	eax, ebp
	mov	DWORD PTR tv318[esp+24], eax
	npad	5
$LL10@Realloc:

; 38   : 		{
; 39   : 			VERIFY	(nodes);
; 40   : 			TNode*	Nold	= nodes	+ I;

	mov	ecx, DWORD PTR [esi]
	lea	edi, DWORD PTR [eax+edx]
	add	edi, ecx

; 41   : 			TNode*	Nnew	= newNodes + I;
; 42   : 
; 43   : 			if (Nold->left) {

	mov	eax, DWORD PTR [edi+20]
	test	eax, eax
	je	SHORT $LN31@Realloc

; 44   : 				size_t	Lid		= Nold->left  - nodes;

	sub	eax, ecx
	sar	eax, 2
	imul	ecx, eax, -1227133513

; 45   : 				Nnew->left		= newNodes + Lid;

	lea	eax, DWORD PTR [ecx*8]
	sub	eax, ecx
	lea	eax, DWORD PTR [eax*4]
	add	eax, ebp
	mov	DWORD PTR [edx-4], eax
	mov	ecx, DWORD PTR [esi]
$LN31@Realloc:

; 46   : 			}
; 47   : 			if (Nold->right) {

	mov	eax, DWORD PTR [edi+24]
	test	eax, eax
	je	SHORT $LN8@Realloc

; 48   : 				size_t	Rid		= Nold->right - nodes;

	sub	eax, ecx
	sar	eax, 2
	imul	ecx, eax, -1227133513

; 49   : 				Nnew->right		= newNodes + Rid;

	lea	eax, DWORD PTR [ecx*8]
	sub	eax, ecx
	lea	eax, DWORD PTR [eax*4]
	add	eax, ebp
	mov	DWORD PTR [edx], eax
$LN8@Realloc:

; 36   : 
; 37   : 		for (u32 I=0; I<pool; I++)

	mov	eax, DWORD PTR tv318[esp+24]
	inc	ebx
	add	edx, 28					; 0000001cH
	cmp	ebx, DWORD PTR [esi+4]
	jb	SHORT $LL10@Realloc
$LN9@Realloc:

; 50   : 			}
; 51   : 		}
; 52   : 		if (nodes) allocator::dealloc(nodes);

	mov	ecx, DWORD PTR [esi]
	pop	ebx
	test	ecx, ecx
	je	SHORT $LN32@Realloc
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h

; 53   : 		static	void	dealloc		(T *&p)			{	dlfree(p);	p=0;			}

	call	_dlfree
$LN32@Realloc:
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h

; 56   : 	}

	mov	eax, DWORD PTR _newLimit$1$[esp+20]
	pop	edi
	mov	DWORD PTR [esi], ebp
	mov	DWORD PTR [esi+8], eax
	pop	esi
	pop	ebp
	add	esp, 8
	ret	0
?Realloc@?$FixedMAP@PAVR_constant_table@@UmapNormalStates@R_dsgraph@@Udoug_lea_allocator@@@@AAEXXZ ENDP ; FixedMAP<R_constant_table *,R_dsgraph::mapNormalStates,doug_lea_allocator>::Realloc
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
;	COMDAT ?Realloc@?$FixedMAP@PAUIDirect3DStateBlock9@@UmapNormalTextures@R_dsgraph@@Udoug_lea_allocator@@@@AAEXXZ
_TEXT	SEGMENT
_newLimit$1$ = -8					; size = 4
tv318 = -4						; size = 4
?Realloc@?$FixedMAP@PAUIDirect3DStateBlock9@@UmapNormalTextures@R_dsgraph@@Udoug_lea_allocator@@@@AAEXXZ PROC ; FixedMAP<IDirect3DStateBlock9 *,R_dsgraph::mapNormalTextures,doug_lea_allocator>::Realloc, COMDAT
; _this$ = ecx

; 28   : 	{

	sub	esp, 8
	push	ebp
	push	esi
	mov	esi, ecx
	push	edi

; 29   : 		u32	newLimit = limit + SG_REALLOC_ADVANCE;

	mov	eax, DWORD PTR [esi+8]
	add	eax, 64					; 00000040H
	mov	DWORD PTR _newLimit$1$[esp+20], eax

; 30   : 		VERIFY(newLimit%SG_REALLOC_ADVANCE == 0);
; 31   : 		TNode*	newNodes = (TNode*)allocator::alloc(sizeof(TNode)*newLimit);

	lea	edi, DWORD PTR [eax*8]
	sub	edi, eax
	shl	edi, 2
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h

; 51   : 		static	void	*alloc		(const u32 &n)	{	return dlmalloc((u32)n);	}

	mov	ecx, edi
	call	_dlmalloc
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h

; 34   : 		ZeroMemory(newNodes, Size(newLimit));

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	mov	ebp, eax
	push	edi
	push	0
	push	ebp
	mov	ecx, DWORD PTR [ecx+12]
	call	ecx

; 35   : 		if (limit) CopyMemory	(newNodes, nodes, Size(limit));

	mov	ecx, DWORD PTR [esi+8]
	test	ecx, ecx
	je	SHORT $LN14@Realloc

; 25   : 	{	return Count*sizeof(TNode);	}

	lea	eax, DWORD PTR [ecx*8]
	sub	eax, ecx
	shl	eax, 2

; 35   : 		if (limit) CopyMemory	(newNodes, nodes, Size(limit));

	push	eax
	push	DWORD PTR [esi]
	push	ebp
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN14@Realloc:

; 36   : 
; 37   : 		for (u32 I=0; I<pool; I++)

	push	ebx
	xor	ebx, ebx
	cmp	DWORD PTR [esi+4], ebx
	jbe	SHORT $LN9@Realloc
	mov	eax, -24				; ffffffe8H
	lea	edx, DWORD PTR [ebp+24]
	sub	eax, ebp
	mov	DWORD PTR tv318[esp+24], eax
	npad	5
$LL10@Realloc:

; 38   : 		{
; 39   : 			VERIFY	(nodes);
; 40   : 			TNode*	Nold	= nodes	+ I;

	mov	ecx, DWORD PTR [esi]
	lea	edi, DWORD PTR [eax+edx]
	add	edi, ecx

; 41   : 			TNode*	Nnew	= newNodes + I;
; 42   : 
; 43   : 			if (Nold->left) {

	mov	eax, DWORD PTR [edi+20]
	test	eax, eax
	je	SHORT $LN31@Realloc

; 44   : 				size_t	Lid		= Nold->left  - nodes;

	sub	eax, ecx
	sar	eax, 2
	imul	ecx, eax, -1227133513

; 45   : 				Nnew->left		= newNodes + Lid;

	lea	eax, DWORD PTR [ecx*8]
	sub	eax, ecx
	lea	eax, DWORD PTR [eax*4]
	add	eax, ebp
	mov	DWORD PTR [edx-4], eax
	mov	ecx, DWORD PTR [esi]
$LN31@Realloc:

; 46   : 			}
; 47   : 			if (Nold->right) {

	mov	eax, DWORD PTR [edi+24]
	test	eax, eax
	je	SHORT $LN8@Realloc

; 48   : 				size_t	Rid		= Nold->right - nodes;

	sub	eax, ecx
	sar	eax, 2
	imul	ecx, eax, -1227133513

; 49   : 				Nnew->right		= newNodes + Rid;

	lea	eax, DWORD PTR [ecx*8]
	sub	eax, ecx
	lea	eax, DWORD PTR [eax*4]
	add	eax, ebp
	mov	DWORD PTR [edx], eax
$LN8@Realloc:

; 36   : 
; 37   : 		for (u32 I=0; I<pool; I++)

	mov	eax, DWORD PTR tv318[esp+24]
	inc	ebx
	add	edx, 28					; 0000001cH
	cmp	ebx, DWORD PTR [esi+4]
	jb	SHORT $LL10@Realloc
$LN9@Realloc:

; 50   : 			}
; 51   : 		}
; 52   : 		if (nodes) allocator::dealloc(nodes);

	mov	ecx, DWORD PTR [esi]
	pop	ebx
	test	ecx, ecx
	je	SHORT $LN32@Realloc
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h

; 53   : 		static	void	dealloc		(T *&p)			{	dlfree(p);	p=0;			}

	call	_dlfree
$LN32@Realloc:
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h

; 56   : 	}

	mov	eax, DWORD PTR _newLimit$1$[esp+20]
	pop	edi
	mov	DWORD PTR [esi], ebp
	mov	DWORD PTR [esi+8], eax
	pop	esi
	pop	ebp
	add	esp, 8
	ret	0
?Realloc@?$FixedMAP@PAUIDirect3DStateBlock9@@UmapNormalTextures@R_dsgraph@@Udoug_lea_allocator@@@@AAEXXZ ENDP ; FixedMAP<IDirect3DStateBlock9 *,R_dsgraph::mapNormalTextures,doug_lea_allocator>::Realloc
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
;	COMDAT ?Realloc@?$FixedMAP@PAUSTextureList@@UmapNormalItems@R_dsgraph@@Udoug_lea_allocator@@@@AAEXXZ
_TEXT	SEGMENT
_newLimit$1$ = -8					; size = 4
tv318 = -4						; size = 4
?Realloc@?$FixedMAP@PAUSTextureList@@UmapNormalItems@R_dsgraph@@Udoug_lea_allocator@@@@AAEXXZ PROC ; FixedMAP<STextureList *,R_dsgraph::mapNormalItems,doug_lea_allocator>::Realloc, COMDAT
; _this$ = ecx

; 28   : 	{

	sub	esp, 8
	push	ebp
	push	esi
	mov	esi, ecx
	push	edi

; 29   : 		u32	newLimit = limit + SG_REALLOC_ADVANCE;

	mov	eax, DWORD PTR [esi+8]
	add	eax, 64					; 00000040H
	mov	DWORD PTR _newLimit$1$[esp+20], eax

; 30   : 		VERIFY(newLimit%SG_REALLOC_ADVANCE == 0);
; 31   : 		TNode*	newNodes = (TNode*)allocator::alloc(sizeof(TNode)*newLimit);

	lea	edi, DWORD PTR [eax*8]
	sub	edi, eax
	shl	edi, 2
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h

; 51   : 		static	void	*alloc		(const u32 &n)	{	return dlmalloc((u32)n);	}

	mov	ecx, edi
	call	_dlmalloc
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h

; 34   : 		ZeroMemory(newNodes, Size(newLimit));

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	mov	ebp, eax
	push	edi
	push	0
	push	ebp
	mov	ecx, DWORD PTR [ecx+12]
	call	ecx

; 35   : 		if (limit) CopyMemory	(newNodes, nodes, Size(limit));

	mov	ecx, DWORD PTR [esi+8]
	test	ecx, ecx
	je	SHORT $LN14@Realloc

; 25   : 	{	return Count*sizeof(TNode);	}

	lea	eax, DWORD PTR [ecx*8]
	sub	eax, ecx
	shl	eax, 2

; 35   : 		if (limit) CopyMemory	(newNodes, nodes, Size(limit));

	push	eax
	push	DWORD PTR [esi]
	push	ebp
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN14@Realloc:

; 36   : 
; 37   : 		for (u32 I=0; I<pool; I++)

	push	ebx
	xor	ebx, ebx
	cmp	DWORD PTR [esi+4], ebx
	jbe	SHORT $LN9@Realloc
	mov	eax, -24				; ffffffe8H
	lea	edx, DWORD PTR [ebp+24]
	sub	eax, ebp
	mov	DWORD PTR tv318[esp+24], eax
	npad	5
$LL10@Realloc:

; 38   : 		{
; 39   : 			VERIFY	(nodes);
; 40   : 			TNode*	Nold	= nodes	+ I;

	mov	ecx, DWORD PTR [esi]
	lea	edi, DWORD PTR [eax+edx]
	add	edi, ecx

; 41   : 			TNode*	Nnew	= newNodes + I;
; 42   : 
; 43   : 			if (Nold->left) {

	mov	eax, DWORD PTR [edi+20]
	test	eax, eax
	je	SHORT $LN31@Realloc

; 44   : 				size_t	Lid		= Nold->left  - nodes;

	sub	eax, ecx
	sar	eax, 2
	imul	ecx, eax, -1227133513

; 45   : 				Nnew->left		= newNodes + Lid;

	lea	eax, DWORD PTR [ecx*8]
	sub	eax, ecx
	lea	eax, DWORD PTR [eax*4]
	add	eax, ebp
	mov	DWORD PTR [edx-4], eax
	mov	ecx, DWORD PTR [esi]
$LN31@Realloc:

; 46   : 			}
; 47   : 			if (Nold->right) {

	mov	eax, DWORD PTR [edi+24]
	test	eax, eax
	je	SHORT $LN8@Realloc

; 48   : 				size_t	Rid		= Nold->right - nodes;

	sub	eax, ecx
	sar	eax, 2
	imul	ecx, eax, -1227133513

; 49   : 				Nnew->right		= newNodes + Rid;

	lea	eax, DWORD PTR [ecx*8]
	sub	eax, ecx
	lea	eax, DWORD PTR [eax*4]
	add	eax, ebp
	mov	DWORD PTR [edx], eax
$LN8@Realloc:

; 36   : 
; 37   : 		for (u32 I=0; I<pool; I++)

	mov	eax, DWORD PTR tv318[esp+24]
	inc	ebx
	add	edx, 28					; 0000001cH
	cmp	ebx, DWORD PTR [esi+4]
	jb	SHORT $LL10@Realloc
$LN9@Realloc:

; 50   : 			}
; 51   : 		}
; 52   : 		if (nodes) allocator::dealloc(nodes);

	mov	ecx, DWORD PTR [esi]
	pop	ebx
	test	ecx, ecx
	je	SHORT $LN32@Realloc
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h

; 53   : 		static	void	dealloc		(T *&p)			{	dlfree(p);	p=0;			}

	call	_dlfree
$LN32@Realloc:
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h

; 56   : 	}

	mov	eax, DWORD PTR _newLimit$1$[esp+20]
	pop	edi
	mov	DWORD PTR [esi], ebp
	mov	DWORD PTR [esi+8], eax
	pop	esi
	pop	ebp
	add	esp, 8
	ret	0
?Realloc@?$FixedMAP@PAUSTextureList@@UmapNormalItems@R_dsgraph@@Udoug_lea_allocator@@@@AAEXXZ ENDP ; FixedMAP<STextureList *,R_dsgraph::mapNormalItems,doug_lea_allocator>::Realloc
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
;	COMDAT ?Size@?$FixedMAP@MU_LodItem@R_dsgraph@@Udoug_lea_allocator@@@@AAEII@Z
_TEXT	SEGMENT
_Count$ = 8						; size = 4
?Size@?$FixedMAP@MU_LodItem@R_dsgraph@@Udoug_lea_allocator@@@@AAEII@Z PROC ; FixedMAP<float,R_dsgraph::_LodItem,doug_lea_allocator>::Size, COMDAT
; _this$dead$ = ecx

; 25   : 	{	return Count*sizeof(TNode);	}

	mov	eax, DWORD PTR _Count$[esp-4]
	lea	eax, DWORD PTR [eax+eax*4]
	shl	eax, 2
	ret	4
?Size@?$FixedMAP@MU_LodItem@R_dsgraph@@Udoug_lea_allocator@@@@AAEII@Z ENDP ; FixedMAP<float,R_dsgraph::_LodItem,doug_lea_allocator>::Size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
;	COMDAT ?Size@?$FixedMAP@MU_MatrixItemS@R_dsgraph@@Udoug_lea_allocator@@@@AAEII@Z
_TEXT	SEGMENT
_Count$ = 8						; size = 4
?Size@?$FixedMAP@MU_MatrixItemS@R_dsgraph@@Udoug_lea_allocator@@@@AAEII@Z PROC ; FixedMAP<float,R_dsgraph::_MatrixItemS,doug_lea_allocator>::Size, COMDAT
; _this$dead$ = ecx

; 25   : 	{	return Count*sizeof(TNode);	}

	imul	eax, DWORD PTR _Count$[esp-4], 92
	ret	4
?Size@?$FixedMAP@MU_MatrixItemS@R_dsgraph@@Udoug_lea_allocator@@@@AAEII@Z ENDP ; FixedMAP<float,R_dsgraph::_MatrixItemS,doug_lea_allocator>::Size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
;	COMDAT ?Size@?$FixedMAP@PAUIDirect3DVertexShader9@@UmapMatrixPS@R_dsgraph@@Udoug_lea_allocator@@@@AAEII@Z
_TEXT	SEGMENT
_Count$ = 8						; size = 4
?Size@?$FixedMAP@PAUIDirect3DVertexShader9@@UmapMatrixPS@R_dsgraph@@Udoug_lea_allocator@@@@AAEII@Z PROC ; FixedMAP<IDirect3DVertexShader9 *,R_dsgraph::mapMatrixPS,doug_lea_allocator>::Size, COMDAT
; _this$dead$ = ecx

; 25   : 	{	return Count*sizeof(TNode);	}

	mov	ecx, DWORD PTR _Count$[esp-4]
	lea	eax, DWORD PTR [ecx*8]
	sub	eax, ecx
	shl	eax, 2
	ret	4
?Size@?$FixedMAP@PAUIDirect3DVertexShader9@@UmapMatrixPS@R_dsgraph@@Udoug_lea_allocator@@@@AAEII@Z ENDP ; FixedMAP<IDirect3DVertexShader9 *,R_dsgraph::mapMatrixPS,doug_lea_allocator>::Size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
;	COMDAT ?Size@?$FixedMAP@PAUIDirect3DPixelShader9@@UmapMatrixCS@R_dsgraph@@Udoug_lea_allocator@@@@AAEII@Z
_TEXT	SEGMENT
_Count$ = 8						; size = 4
?Size@?$FixedMAP@PAUIDirect3DPixelShader9@@UmapMatrixCS@R_dsgraph@@Udoug_lea_allocator@@@@AAEII@Z PROC ; FixedMAP<IDirect3DPixelShader9 *,R_dsgraph::mapMatrixCS,doug_lea_allocator>::Size, COMDAT
; _this$dead$ = ecx

; 25   : 	{	return Count*sizeof(TNode);	}

	mov	ecx, DWORD PTR _Count$[esp-4]
	lea	eax, DWORD PTR [ecx*8]
	sub	eax, ecx
	shl	eax, 2
	ret	4
?Size@?$FixedMAP@PAUIDirect3DPixelShader9@@UmapMatrixCS@R_dsgraph@@Udoug_lea_allocator@@@@AAEII@Z ENDP ; FixedMAP<IDirect3DPixelShader9 *,R_dsgraph::mapMatrixCS,doug_lea_allocator>::Size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
;	COMDAT ?Size@?$FixedMAP@PAVR_constant_table@@UmapMatrixStates@R_dsgraph@@Udoug_lea_allocator@@@@AAEII@Z
_TEXT	SEGMENT
_Count$ = 8						; size = 4
?Size@?$FixedMAP@PAVR_constant_table@@UmapMatrixStates@R_dsgraph@@Udoug_lea_allocator@@@@AAEII@Z PROC ; FixedMAP<R_constant_table *,R_dsgraph::mapMatrixStates,doug_lea_allocator>::Size, COMDAT
; _this$dead$ = ecx

; 25   : 	{	return Count*sizeof(TNode);	}

	mov	ecx, DWORD PTR _Count$[esp-4]
	lea	eax, DWORD PTR [ecx*8]
	sub	eax, ecx
	shl	eax, 2
	ret	4
?Size@?$FixedMAP@PAVR_constant_table@@UmapMatrixStates@R_dsgraph@@Udoug_lea_allocator@@@@AAEII@Z ENDP ; FixedMAP<R_constant_table *,R_dsgraph::mapMatrixStates,doug_lea_allocator>::Size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
;	COMDAT ?Size@?$FixedMAP@PAUIDirect3DStateBlock9@@UmapMatrixTextures@R_dsgraph@@Udoug_lea_allocator@@@@AAEII@Z
_TEXT	SEGMENT
_Count$ = 8						; size = 4
?Size@?$FixedMAP@PAUIDirect3DStateBlock9@@UmapMatrixTextures@R_dsgraph@@Udoug_lea_allocator@@@@AAEII@Z PROC ; FixedMAP<IDirect3DStateBlock9 *,R_dsgraph::mapMatrixTextures,doug_lea_allocator>::Size, COMDAT
; _this$dead$ = ecx

; 25   : 	{	return Count*sizeof(TNode);	}

	mov	ecx, DWORD PTR _Count$[esp-4]
	lea	eax, DWORD PTR [ecx*8]
	sub	eax, ecx
	shl	eax, 2
	ret	4
?Size@?$FixedMAP@PAUIDirect3DStateBlock9@@UmapMatrixTextures@R_dsgraph@@Udoug_lea_allocator@@@@AAEII@Z ENDP ; FixedMAP<IDirect3DStateBlock9 *,R_dsgraph::mapMatrixTextures,doug_lea_allocator>::Size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
;	COMDAT ?Size@?$FixedMAP@PAUSTextureList@@UmapMatrixItems@R_dsgraph@@Udoug_lea_allocator@@@@AAEII@Z
_TEXT	SEGMENT
_Count$ = 8						; size = 4
?Size@?$FixedMAP@PAUSTextureList@@UmapMatrixItems@R_dsgraph@@Udoug_lea_allocator@@@@AAEII@Z PROC ; FixedMAP<STextureList *,R_dsgraph::mapMatrixItems,doug_lea_allocator>::Size, COMDAT
; _this$dead$ = ecx

; 25   : 	{	return Count*sizeof(TNode);	}

	mov	ecx, DWORD PTR _Count$[esp-4]
	lea	eax, DWORD PTR [ecx*8]
	sub	eax, ecx
	shl	eax, 2
	ret	4
?Size@?$FixedMAP@PAUSTextureList@@UmapMatrixItems@R_dsgraph@@Udoug_lea_allocator@@@@AAEII@Z ENDP ; FixedMAP<STextureList *,R_dsgraph::mapMatrixItems,doug_lea_allocator>::Size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
;	COMDAT ?Size@?$FixedMAP@PAUIDirect3DVertexShader9@@UmapNormalPS@R_dsgraph@@Udoug_lea_allocator@@@@AAEII@Z
_TEXT	SEGMENT
_Count$ = 8						; size = 4
?Size@?$FixedMAP@PAUIDirect3DVertexShader9@@UmapNormalPS@R_dsgraph@@Udoug_lea_allocator@@@@AAEII@Z PROC ; FixedMAP<IDirect3DVertexShader9 *,R_dsgraph::mapNormalPS,doug_lea_allocator>::Size, COMDAT
; _this$dead$ = ecx

; 25   : 	{	return Count*sizeof(TNode);	}

	mov	ecx, DWORD PTR _Count$[esp-4]
	lea	eax, DWORD PTR [ecx*8]
	sub	eax, ecx
	shl	eax, 2
	ret	4
?Size@?$FixedMAP@PAUIDirect3DVertexShader9@@UmapNormalPS@R_dsgraph@@Udoug_lea_allocator@@@@AAEII@Z ENDP ; FixedMAP<IDirect3DVertexShader9 *,R_dsgraph::mapNormalPS,doug_lea_allocator>::Size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
;	COMDAT ?Size@?$FixedMAP@PAUIDirect3DPixelShader9@@UmapNormalCS@R_dsgraph@@Udoug_lea_allocator@@@@AAEII@Z
_TEXT	SEGMENT
_Count$ = 8						; size = 4
?Size@?$FixedMAP@PAUIDirect3DPixelShader9@@UmapNormalCS@R_dsgraph@@Udoug_lea_allocator@@@@AAEII@Z PROC ; FixedMAP<IDirect3DPixelShader9 *,R_dsgraph::mapNormalCS,doug_lea_allocator>::Size, COMDAT
; _this$dead$ = ecx

; 25   : 	{	return Count*sizeof(TNode);	}

	mov	ecx, DWORD PTR _Count$[esp-4]
	lea	eax, DWORD PTR [ecx*8]
	sub	eax, ecx
	shl	eax, 2
	ret	4
?Size@?$FixedMAP@PAUIDirect3DPixelShader9@@UmapNormalCS@R_dsgraph@@Udoug_lea_allocator@@@@AAEII@Z ENDP ; FixedMAP<IDirect3DPixelShader9 *,R_dsgraph::mapNormalCS,doug_lea_allocator>::Size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
;	COMDAT ?Size@?$FixedMAP@PAVR_constant_table@@UmapNormalStates@R_dsgraph@@Udoug_lea_allocator@@@@AAEII@Z
_TEXT	SEGMENT
_Count$ = 8						; size = 4
?Size@?$FixedMAP@PAVR_constant_table@@UmapNormalStates@R_dsgraph@@Udoug_lea_allocator@@@@AAEII@Z PROC ; FixedMAP<R_constant_table *,R_dsgraph::mapNormalStates,doug_lea_allocator>::Size, COMDAT
; _this$dead$ = ecx

; 25   : 	{	return Count*sizeof(TNode);	}

	mov	ecx, DWORD PTR _Count$[esp-4]
	lea	eax, DWORD PTR [ecx*8]
	sub	eax, ecx
	shl	eax, 2
	ret	4
?Size@?$FixedMAP@PAVR_constant_table@@UmapNormalStates@R_dsgraph@@Udoug_lea_allocator@@@@AAEII@Z ENDP ; FixedMAP<R_constant_table *,R_dsgraph::mapNormalStates,doug_lea_allocator>::Size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
;	COMDAT ?Size@?$FixedMAP@PAUIDirect3DStateBlock9@@UmapNormalTextures@R_dsgraph@@Udoug_lea_allocator@@@@AAEII@Z
_TEXT	SEGMENT
_Count$ = 8						; size = 4
?Size@?$FixedMAP@PAUIDirect3DStateBlock9@@UmapNormalTextures@R_dsgraph@@Udoug_lea_allocator@@@@AAEII@Z PROC ; FixedMAP<IDirect3DStateBlock9 *,R_dsgraph::mapNormalTextures,doug_lea_allocator>::Size, COMDAT
; _this$dead$ = ecx

; 25   : 	{	return Count*sizeof(TNode);	}

	mov	ecx, DWORD PTR _Count$[esp-4]
	lea	eax, DWORD PTR [ecx*8]
	sub	eax, ecx
	shl	eax, 2
	ret	4
?Size@?$FixedMAP@PAUIDirect3DStateBlock9@@UmapNormalTextures@R_dsgraph@@Udoug_lea_allocator@@@@AAEII@Z ENDP ; FixedMAP<IDirect3DStateBlock9 *,R_dsgraph::mapNormalTextures,doug_lea_allocator>::Size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
;	COMDAT ?Size@?$FixedMAP@PAUSTextureList@@UmapNormalItems@R_dsgraph@@Udoug_lea_allocator@@@@AAEII@Z
_TEXT	SEGMENT
_Count$ = 8						; size = 4
?Size@?$FixedMAP@PAUSTextureList@@UmapNormalItems@R_dsgraph@@Udoug_lea_allocator@@@@AAEII@Z PROC ; FixedMAP<STextureList *,R_dsgraph::mapNormalItems,doug_lea_allocator>::Size, COMDAT
; _this$dead$ = ecx

; 25   : 	{	return Count*sizeof(TNode);	}

	mov	ecx, DWORD PTR _Count$[esp-4]
	lea	eax, DWORD PTR [ecx*8]
	sub	eax, ecx
	shl	eax, 2
	ret	4
?Size@?$FixedMAP@PAUSTextureList@@UmapNormalItems@R_dsgraph@@Udoug_lea_allocator@@@@AAEII@Z ENDP ; FixedMAP<STextureList *,R_dsgraph::mapNormalItems,doug_lea_allocator>::Size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\type_traits
;	COMDAT ??$forward@ABU_MatrixItem@R_dsgraph@@@std@@YAABU_MatrixItem@R_dsgraph@@ABU12@@Z
_TEXT	SEGMENT
??$forward@ABU_MatrixItem@R_dsgraph@@@std@@YAABU_MatrixItem@R_dsgraph@@ABU12@@Z PROC ; std::forward<R_dsgraph::_MatrixItem const &>, COMDAT
; __Arg$ = ecx

; 1386 :     return static_cast<_Ty&&>(_Arg);

	mov	eax, ecx

; 1387 : }

	ret	0
??$forward@ABU_MatrixItem@R_dsgraph@@@std@@YAABU_MatrixItem@R_dsgraph@@ABU12@@Z ENDP ; std::forward<R_dsgraph::_MatrixItem const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$construct@U_MatrixItem@R_dsgraph@@ABU12@@?$_Normal_allocator_traits@V?$doug_lea_alloc@U_MatrixItem@R_dsgraph@@@@@std@@SAXAAV?$doug_lea_alloc@U_MatrixItem@R_dsgraph@@@@PAU_MatrixItem@R_dsgraph@@ABU34@@Z
_TEXT	SEGMENT
_<_Args_0>$ = 8						; size = 4
??$construct@U_MatrixItem@R_dsgraph@@ABU12@@?$_Normal_allocator_traits@V?$doug_lea_alloc@U_MatrixItem@R_dsgraph@@@@@std@@SAXAAV?$doug_lea_alloc@U_MatrixItem@R_dsgraph@@@@PAU_MatrixItem@R_dsgraph@@ABU34@@Z PROC ; std::_Normal_allocator_traits<doug_lea_alloc<R_dsgraph::_MatrixItem> >::construct<R_dsgraph::_MatrixItem,R_dsgraph::_MatrixItem const &>, COMDAT
; __Al$dead$ = ecx
; __Ptr$ = edx

; 564  :     static _CONSTEXPR20_DYNALLOC void construct(_Alloc& _Al, _Ty* _Ptr, _Types&&... _Args) {

	push	esi
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h

; 37   : 								void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	esi, DWORD PTR _<_Args_0>$[esp]
	mov	ecx, 19					; 00000013H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 564  :     static _CONSTEXPR20_DYNALLOC void construct(_Alloc& _Al, _Ty* _Ptr, _Types&&... _Args) {

	push	edi
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h

; 37   : 								void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	edi, edx
	rep movsd
	pop	edi
	pop	esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 575  :     }

	ret	0
??$construct@U_MatrixItem@R_dsgraph@@ABU12@@?$_Normal_allocator_traits@V?$doug_lea_alloc@U_MatrixItem@R_dsgraph@@@@@std@@SAXAAV?$doug_lea_alloc@U_MatrixItem@R_dsgraph@@@@PAU_MatrixItem@R_dsgraph@@ABU34@@Z ENDP ; std::_Normal_allocator_traits<doug_lea_alloc<R_dsgraph::_MatrixItem> >::construct<R_dsgraph::_MatrixItem,R_dsgraph::_MatrixItem const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??$_Emplace_reallocate@ABU_MatrixItem@R_dsgraph@@@?$vector@U_MatrixItem@R_dsgraph@@V?$doug_lea_alloc@U_MatrixItem@R_dsgraph@@@@@std@@QAEPAU_MatrixItem@R_dsgraph@@QAU23@ABU23@@Z
_TEXT	SEGMENT
__Backout$2 = -48					; size = 12
__Oldsize$1$ = -36					; size = 4
__UFirst$3 = -32					; size = 4
__Newvec$ = -28						; size = 4
__Newcapacity$1$ = -24					; size = 4
tv469 = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Whereptr$ = 8						; size = 4
__ULast$1$ = 12						; size = 4
_<_Val_0>$ = 12						; size = 4
??$_Emplace_reallocate@ABU_MatrixItem@R_dsgraph@@@?$vector@U_MatrixItem@R_dsgraph@@V?$doug_lea_alloc@U_MatrixItem@R_dsgraph@@@@@std@@QAEPAU_MatrixItem@R_dsgraph@@QAU23@ABU23@@Z PROC ; std::vector<R_dsgraph::_MatrixItem,doug_lea_alloc<R_dsgraph::_MatrixItem> >::_Emplace_reallocate<R_dsgraph::_MatrixItem const &>, COMDAT
; _this$ = ecx

; 752  :     _CONSTEXPR20_CONTAINER pointer _Emplace_reallocate(const pointer _Whereptr, _Valty&&... _Val) {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Emplace_reallocate@ABU_MatrixItem@R_dsgraph@@@?$vector@U_MatrixItem@R_dsgraph@@V?$doug_lea_alloc@U_MatrixItem@R_dsgraph@@@@@std@@QAEPAU_MatrixItem@R_dsgraph@@QAU23@ABU23@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 36					; 00000024H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	ebx, ecx

; 753  :         // reallocate and insert by perfectly forwarding _Val at _Whereptr
; 754  :         _Alty& _Al        = _Getal();
; 755  :         auto& _My_data    = _Mypair._Myval2;
; 756  :         pointer& _Myfirst = _My_data._Myfirst;
; 757  :         pointer& _Mylast  = _My_data._Mylast;
; 758  : 
; 759  :         _STL_INTERNAL_CHECK(_Mylast == _My_data._Myend); // check that we have no unused capacity
; 760  : 
; 761  :         const auto _Whereoff = static_cast<size_type>(_Whereptr - _Myfirst);

	mov	ecx, DWORD PTR [ebx]
	mov	edx, DWORD PTR __Whereptr$[ebp]
	sub	edx, ecx
	mov	eax, 1808407283				; 6bca1af3H
	imul	edx
	sar	edx, 5
	mov	esi, edx
	shr	esi, 31					; 0000001fH
	add	esi, edx

; 762  :         const auto _Oldsize  = static_cast<size_type>(_Mylast - _Myfirst);

	mov	eax, DWORD PTR [ebx+4]
	sub	eax, ecx
	sar	eax, 2
	imul	eax, eax, 678152731
	mov	DWORD PTR __Oldsize$1$[ebp], eax

; 763  : 
; 764  :         if (_Oldsize == max_size()) {

	cmp	eax, 56512727				; 035e50d7H
	je	$LN54@Emplace_re

; 766  :         }
; 767  : 
; 768  :         const size_type _Newsize     = _Oldsize + 1;

	lea	edi, DWORD PTR [eax+1]

; 1546 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	eax, DWORD PTR [ebx+8]
	sub	eax, ecx
	sar	eax, 2
	imul	edx, eax, 678152731

; 1675 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	ecx, edx
	shr	ecx, 1
	mov	eax, 56512727				; 035e50d7H
	sub	eax, ecx
	cmp	edx, eax
	jbe	SHORT $LN12@Emplace_re

; 1676 :             return _Max; // geometric growth would overflow

	mov	eax, 56512727				; 035e50d7H
	jmp	SHORT $LN52@Emplace_re
$LN12@Emplace_re:

; 1677 :         }
; 1678 : 
; 1679 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	lea	eax, DWORD PTR [ecx+edx]

; 1680 : 
; 1681 :         if (_Geometric < _Newsize) {

	cmp	eax, edi
	cmovb	eax, edi
$LN52@Emplace_re:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h

; 33   : 								pointer					allocate		(size_type n, const void* p=0) const	{	return (T*)dlmalloc(sizeof(T)*(u32)n);	}

	mov	DWORD PTR __Newcapacity$1$[ebp], eax
	imul	ecx, eax, 76
	call	_dlmalloc
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 771  :         const pointer _Newvec           = _Al.allocate(_Newcapacity);

	mov	edx, eax
	mov	DWORD PTR __Newvec$[ebp], edx

; 772  :         const pointer _Constructed_last = _Newvec + _Whereoff + 1;
; 773  :         pointer _Constructed_first      = _Constructed_last;
; 774  : 
; 775  :         _TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 776  :         _Alty_traits::construct(_Al, _Unfancy(_Newvec + _Whereoff), _STD forward<_Valty>(_Val)...);

	imul	eax, esi, 76
	add	eax, edx
	mov	DWORD PTR tv469[ebp], eax
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h

; 37   : 								void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	ecx, 19					; 00000013H
	mov	esi, DWORD PTR _<_Val_0>$[ebp]
	mov	edi, eax
	rep movsd
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 779  :         if (_Whereptr == _Mylast) { // at back, provide strong guarantee

	mov	ecx, DWORD PTR [ebx+4]
	mov	DWORD PTR __ULast$1$[ebp], ecx
	mov	eax, DWORD PTR [ebx]
	mov	esi, DWORD PTR __Whereptr$[ebp]
	cmp	esi, ecx
	jne	SHORT $LN4@Emplace_re
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1703 :     auto _UFirst      = _Get_unwrapped(_First);

	mov	DWORD PTR __UFirst$3[ebp], eax

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	DWORD PTR __Backout$2[ebp], edx
	mov	DWORD PTR __Backout$2[ebp+4], edx
	mov	DWORD PTR __Backout$2[ebp+8], ebx
	npad	4
$LL30@Emplace_re:

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	eax, ecx
	je	SHORT $LN29@Emplace_re
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h

; 37   : 								void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	ecx, 19					; 00000013H
	mov	esi, eax
	mov	edi, edx
	rep movsd
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1621 :         ++_Last;

	add	edx, 76					; 0000004cH
	mov	DWORD PTR __Backout$2[ebp+4], edx

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	add	eax, 76					; 0000004cH
	mov	DWORD PTR __UFirst$3[ebp], eax
	mov	ecx, DWORD PTR __ULast$1$[ebp]
	jmp	SHORT $LL30@Emplace_re
$LN29@Emplace_re:

; 1625 :         _First = _Last;

	mov	DWORD PTR __Backout$2[ebp], edx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 781  :         } else { // provide basic guarantee

	mov	edi, DWORD PTR tv469[ebp]
	jmp	SHORT $LN5@Emplace_re
$LN4@Emplace_re:

; 782  :             _Umove(_Myfirst, _Whereptr, _Newvec);

	push	edx
	push	esi
	push	eax
	call	?_Umove@?$vector@U_MatrixItem@R_dsgraph@@V?$doug_lea_alloc@U_MatrixItem@R_dsgraph@@@@@std@@AAEPAU_MatrixItem@R_dsgraph@@PAU34@00@Z ; std::vector<R_dsgraph::_MatrixItem,doug_lea_alloc<R_dsgraph::_MatrixItem> >::_Umove

; 783  :             _Constructed_first = _Newvec;
; 784  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

	mov	edi, DWORD PTR tv469[ebp]
	lea	eax, DWORD PTR [edi+76]
	push	eax
	push	DWORD PTR [ebx+4]
	push	esi
	call	?_Umove@?$vector@U_MatrixItem@R_dsgraph@@V?$doug_lea_alloc@U_MatrixItem@R_dsgraph@@@@@std@@AAEPAU_MatrixItem@R_dsgraph@@PAU34@00@Z ; std::vector<R_dsgraph::_MatrixItem,doug_lea_alloc<R_dsgraph::_MatrixItem> >::_Umove
$LN5@Emplace_re:
	mov	DWORD PTR __$EHRec$[ebp+12], -1

; 1732 :         if (_Myfirst) { // destroy and deallocate old array

	mov	ecx, DWORD PTR [ebx]
	test	ecx, ecx
	je	SHORT $LN43@Emplace_re
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h

; 35   : 								void					deallocate		(pointer p, size_type n) const			{	dlfree	(p);				}

	call	_dlfree
$LN43@Emplace_re:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1737 :         _Myfirst = _Newvec;

	mov	eax, DWORD PTR __Newvec$[ebp]
	mov	DWORD PTR [ebx], eax

; 1738 :         _Mylast  = _Newvec + _Newsize;

	mov	ecx, DWORD PTR __Oldsize$1$[ebp]
	inc	ecx
	imul	ecx, ecx, 76
	add	ecx, eax
	mov	DWORD PTR [ebx+4], ecx

; 1739 :         _Myend   = _Newvec + _Newcapacity;

	imul	ecx, DWORD PTR __Newcapacity$1$[ebp], 76
	add	ecx, eax
	mov	DWORD PTR [ebx+8], ecx

; 790  :         _CATCH_END
; 791  : 
; 792  :         _Change_array(_Newvec, _Newsize, _Newcapacity);
; 793  :         return _Newvec + _Whereoff;

	mov	eax, edi

; 794  :     }

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
__catch$??$_Emplace_reallocate@ABU_MatrixItem@R_dsgraph@@@?$vector@U_MatrixItem@R_dsgraph@@V?$doug_lea_alloc@U_MatrixItem@R_dsgraph@@@@@std@@QAEPAU_MatrixItem@R_dsgraph@@QAU23@ABU23@@Z$0:

; 785  :         }
; 786  :         _CATCH_ALL
; 787  :         _Destroy(_Constructed_first, _Constructed_last);
; 788  :         _Al.deallocate(_Newvec, _Newcapacity);

	push	ecx
	push	DWORD PTR __Newvec$[ebp]
	call	?deallocate@?$doug_lea_alloc@U_MatrixItem@R_dsgraph@@@@QBEXPAU_MatrixItem@R_dsgraph@@I@Z ; doug_lea_alloc<R_dsgraph::_MatrixItem>::deallocate

; 789  :         _RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$LN54@Emplace_re:

; 765  :             _Xlength();

	call	?_Xlength@?$vector@U_MatrixItem@R_dsgraph@@V?$doug_lea_alloc@U_MatrixItem@R_dsgraph@@@@@std@@CAXXZ ; std::vector<R_dsgraph::_MatrixItem,doug_lea_alloc<R_dsgraph::_MatrixItem> >::_Xlength
$LN51@Emplace_re:
	int	3
	int	3
	int	3
	int	3
	int	3
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Emplace_reallocate@ABU_MatrixItem@R_dsgraph@@@?$vector@U_MatrixItem@R_dsgraph@@V?$doug_lea_alloc@U_MatrixItem@R_dsgraph@@@@@std@@QAEPAU_MatrixItem@R_dsgraph@@QAU23@ABU23@@Z:
	npad	1
	npad	1
	mov	eax, OFFSET __ehfuncinfo$??$_Emplace_reallocate@ABU_MatrixItem@R_dsgraph@@@?$vector@U_MatrixItem@R_dsgraph@@V?$doug_lea_alloc@U_MatrixItem@R_dsgraph@@@@@std@@QAEPAU_MatrixItem@R_dsgraph@@QAU23@ABU23@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Emplace_reallocate@ABU_MatrixItem@R_dsgraph@@@?$vector@U_MatrixItem@R_dsgraph@@V?$doug_lea_alloc@U_MatrixItem@R_dsgraph@@@@@std@@QAEPAU_MatrixItem@R_dsgraph@@QAU23@ABU23@@Z ENDP ; std::vector<R_dsgraph::_MatrixItem,doug_lea_alloc<R_dsgraph::_MatrixItem> >::_Emplace_reallocate<R_dsgraph::_MatrixItem const &>
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\type_traits
;	COMDAT ??$forward@ABU_NormalItem@R_dsgraph@@@std@@YAABU_NormalItem@R_dsgraph@@ABU12@@Z
_TEXT	SEGMENT
??$forward@ABU_NormalItem@R_dsgraph@@@std@@YAABU_NormalItem@R_dsgraph@@ABU12@@Z PROC ; std::forward<R_dsgraph::_NormalItem const &>, COMDAT
; __Arg$ = ecx

; 1386 :     return static_cast<_Ty&&>(_Arg);

	mov	eax, ecx

; 1387 : }

	ret	0
??$forward@ABU_NormalItem@R_dsgraph@@@std@@YAABU_NormalItem@R_dsgraph@@ABU12@@Z ENDP ; std::forward<R_dsgraph::_NormalItem const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$construct@U_NormalItem@R_dsgraph@@ABU12@@?$_Normal_allocator_traits@V?$doug_lea_alloc@U_NormalItem@R_dsgraph@@@@@std@@SAXAAV?$doug_lea_alloc@U_NormalItem@R_dsgraph@@@@PAU_NormalItem@R_dsgraph@@ABU34@@Z
_TEXT	SEGMENT
_<_Args_0>$ = 8						; size = 4
??$construct@U_NormalItem@R_dsgraph@@ABU12@@?$_Normal_allocator_traits@V?$doug_lea_alloc@U_NormalItem@R_dsgraph@@@@@std@@SAXAAV?$doug_lea_alloc@U_NormalItem@R_dsgraph@@@@PAU_NormalItem@R_dsgraph@@ABU34@@Z PROC ; std::_Normal_allocator_traits<doug_lea_alloc<R_dsgraph::_NormalItem> >::construct<R_dsgraph::_NormalItem,R_dsgraph::_NormalItem const &>, COMDAT
; __Al$dead$ = ecx
; __Ptr$ = edx

; 565  :         if constexpr (_Uses_default_construct<_Alloc, _Ty*, _Types...>::value) {
; 566  :             (void) _Al; // TRANSITION, DevCom-1004719
; 567  : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 568  :             _STD construct_at(_Ptr, _STD forward<_Types>(_Args)...);
; 569  : #else // __cpp_lib_constexpr_dynamic_alloc
; 570  :             ::new (static_cast<void*>(_Ptr)) _Ty(_STD forward<_Types>(_Args)...);
; 571  : #endif // __cpp_lib_constexpr_dynamic_alloc
; 572  :         } else {
; 573  :             _Al.construct(_Ptr, _STD forward<_Types>(_Args)...);

	mov	eax, DWORD PTR _<_Args_0>$[esp-4]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR [edx], ecx
	mov	DWORD PTR [edx+4], eax

; 574  :         }
; 575  :     }

	ret	0
??$construct@U_NormalItem@R_dsgraph@@ABU12@@?$_Normal_allocator_traits@V?$doug_lea_alloc@U_NormalItem@R_dsgraph@@@@@std@@SAXAAV?$doug_lea_alloc@U_NormalItem@R_dsgraph@@@@PAU_NormalItem@R_dsgraph@@ABU34@@Z ENDP ; std::_Normal_allocator_traits<doug_lea_alloc<R_dsgraph::_NormalItem> >::construct<R_dsgraph::_NormalItem,R_dsgraph::_NormalItem const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??$_Emplace_reallocate@ABU_NormalItem@R_dsgraph@@@?$vector@U_NormalItem@R_dsgraph@@V?$doug_lea_alloc@U_NormalItem@R_dsgraph@@@@@std@@QAEPAU_NormalItem@R_dsgraph@@QAU23@ABU23@@Z
_TEXT	SEGMENT
__Backout$2 = -76					; size = 12
__Backout$3 = -64					; size = 12
__Backout$4 = -52					; size = 12
__UFirst$5 = -40					; size = 4
__UFirst$6 = -36					; size = 4
__UFirst$7 = -32					; size = 4
tv542 = -28						; size = 4
__Newcapacity$1$ = -24					; size = 4
__Newsize$1$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Newvec$ = 8						; size = 4
__Whereptr$ = 8						; size = 4
_<_Val_0>$ = 12						; size = 4
??$_Emplace_reallocate@ABU_NormalItem@R_dsgraph@@@?$vector@U_NormalItem@R_dsgraph@@V?$doug_lea_alloc@U_NormalItem@R_dsgraph@@@@@std@@QAEPAU_NormalItem@R_dsgraph@@QAU23@ABU23@@Z PROC ; std::vector<R_dsgraph::_NormalItem,doug_lea_alloc<R_dsgraph::_NormalItem> >::_Emplace_reallocate<R_dsgraph::_NormalItem const &>, COMDAT
; _this$ = ecx

; 752  :     _CONSTEXPR20_CONTAINER pointer _Emplace_reallocate(const pointer _Whereptr, _Valty&&... _Val) {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Emplace_reallocate@ABU_NormalItem@R_dsgraph@@@?$vector@U_NormalItem@R_dsgraph@@V?$doug_lea_alloc@U_NormalItem@R_dsgraph@@@@@std@@QAEPAU_NormalItem@R_dsgraph@@QAU23@ABU23@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	ebx, ecx

; 753  :         // reallocate and insert by perfectly forwarding _Val at _Whereptr
; 754  :         _Alty& _Al        = _Getal();
; 755  :         auto& _My_data    = _Mypair._Myval2;
; 756  :         pointer& _Myfirst = _My_data._Myfirst;
; 757  :         pointer& _Mylast  = _My_data._Mylast;
; 758  : 
; 759  :         _STL_INTERNAL_CHECK(_Mylast == _My_data._Myend); // check that we have no unused capacity
; 760  : 
; 761  :         const auto _Whereoff = static_cast<size_type>(_Whereptr - _Myfirst);

	mov	edx, DWORD PTR [ebx]
	mov	esi, DWORD PTR __Whereptr$[ebp]
	mov	edi, esi
	sub	edi, edx
	sar	edi, 3

; 762  :         const auto _Oldsize  = static_cast<size_type>(_Mylast - _Myfirst);

	mov	eax, DWORD PTR [ebx+4]
	sub	eax, edx
	sar	eax, 3

; 763  : 
; 764  :         if (_Oldsize == max_size()) {

	cmp	eax, 536870911				; 1fffffffH
	je	$LN78@Emplace_re

; 766  :         }
; 767  : 
; 768  :         const size_type _Newsize     = _Oldsize + 1;

	inc	eax
	mov	DWORD PTR __Newsize$1$[ebp], eax

; 1546 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	ecx, DWORD PTR [ebx+8]
	sub	ecx, edx
	sar	ecx, 3

; 1675 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	edx, ecx
	shr	edx, 1
	mov	eax, 536870911				; 1fffffffH
	sub	eax, edx
	cmp	ecx, eax
	jbe	SHORT $LN12@Emplace_re

; 1676 :             return _Max; // geometric growth would overflow

	mov	eax, 536870911				; 1fffffffH
	jmp	SHORT $LN76@Emplace_re
$LN12@Emplace_re:

; 1677 :         }
; 1678 : 
; 1679 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	lea	eax, DWORD PTR [edx+ecx]

; 1680 : 
; 1681 :         if (_Geometric < _Newsize) {

	cmp	eax, DWORD PTR __Newsize$1$[ebp]
	cmovb	eax, DWORD PTR __Newsize$1$[ebp]
$LN76@Emplace_re:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h

; 33   : 								pointer					allocate		(size_type n, const void* p=0) const	{	return (T*)dlmalloc(sizeof(T)*(u32)n);	}

	mov	DWORD PTR __Newcapacity$1$[ebp], eax
	lea	ecx, DWORD PTR [eax*8]
	call	_dlmalloc
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 771  :         const pointer _Newvec           = _Al.allocate(_Newcapacity);

	mov	DWORD PTR __Newvec$[ebp], eax

; 772  :         const pointer _Constructed_last = _Newvec + _Whereoff + 1;
; 773  :         pointer _Constructed_first      = _Constructed_last;
; 774  : 
; 775  :         _TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 776  :         _Alty_traits::construct(_Al, _Unfancy(_Newvec + _Whereoff), _STD forward<_Valty>(_Val)...);

	lea	edx, DWORD PTR [eax+edi*8]
	mov	DWORD PTR tv542[ebp], edx
	mov	eax, DWORD PTR _<_Val_0>$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR [edx], ecx
	mov	DWORD PTR [edx+4], eax

; 777  :         _Constructed_first = _Newvec + _Whereoff;
; 778  : 
; 779  :         if (_Whereptr == _Mylast) { // at back, provide strong guarantee

	mov	edi, DWORD PTR [ebx+4]
	mov	edx, DWORD PTR [ebx]
	mov	eax, DWORD PTR __Newvec$[ebp]
	cmp	esi, edi
	jne	SHORT $LN4@Emplace_re
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1703 :     auto _UFirst      = _Get_unwrapped(_First);

	mov	DWORD PTR __UFirst$7[ebp], edx

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	DWORD PTR __Backout$4[ebp], eax
	mov	esi, eax
	mov	DWORD PTR __Backout$4[ebp+4], esi
	mov	DWORD PTR __Backout$4[ebp+8], ebx
$LL26@Emplace_re:

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	edx, edi
	je	SHORT $LN25@Emplace_re

; 1620 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR [esi+4], ecx

; 1621 :         ++_Last;

	add	esi, 8
	mov	DWORD PTR __Backout$4[ebp+4], esi

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	add	edx, 8
	mov	DWORD PTR __UFirst$7[ebp], edx
	jmp	SHORT $LL26@Emplace_re
$LN25@Emplace_re:

; 1625 :         _First = _Last;

	mov	DWORD PTR __Backout$4[ebp], esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 781  :         } else { // provide basic guarantee

	jmp	SHORT $LN5@Emplace_re
$LN4@Emplace_re:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1703 :     auto _UFirst      = _Get_unwrapped(_First);

	mov	DWORD PTR __UFirst$6[ebp], edx

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	DWORD PTR __Backout$3[ebp], eax
	mov	edi, eax
	mov	DWORD PTR __Backout$3[ebp+4], edi
	mov	DWORD PTR __Backout$3[ebp+8], ebx
$LL39@Emplace_re:

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	edx, esi
	je	SHORT $LN38@Emplace_re

; 1620 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [edi], eax
	mov	DWORD PTR [edi+4], ecx

; 1621 :         ++_Last;

	add	edi, 8
	mov	DWORD PTR __Backout$3[ebp+4], edi

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	add	edx, 8
	mov	DWORD PTR __UFirst$6[ebp], edx
	jmp	SHORT $LL39@Emplace_re
$LN38@Emplace_re:

; 1625 :         _First = _Last;

	mov	DWORD PTR __Backout$3[ebp], edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 784  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

	mov	edx, DWORD PTR tv542[ebp]
	add	edx, 8

; 1646 :         return _Uninitialized_move(_First, _Last, _Dest, _Getal());

	mov	edi, DWORD PTR [ebx+4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1703 :     auto _UFirst      = _Get_unwrapped(_First);

	mov	DWORD PTR __UFirst$5[ebp], esi

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	DWORD PTR __Backout$2[ebp], edx
	mov	DWORD PTR __Backout$2[ebp+4], edx
	mov	DWORD PTR __Backout$2[ebp+8], ebx
$LL52@Emplace_re:

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	esi, edi
	je	SHORT $LN51@Emplace_re

; 1620 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR [esi+4]
	mov	DWORD PTR [edx], eax
	mov	DWORD PTR [edx+4], ecx

; 1621 :         ++_Last;

	add	edx, 8
	mov	DWORD PTR __Backout$2[ebp+4], edx

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	add	esi, 8
	mov	DWORD PTR __UFirst$5[ebp], esi
	jmp	SHORT $LL52@Emplace_re
$LN51@Emplace_re:

; 1625 :         _First = _Last;

	mov	DWORD PTR __Backout$2[ebp], edx
$LN5@Emplace_re:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
	mov	DWORD PTR __$EHRec$[ebp+12], -1

; 1732 :         if (_Myfirst) { // destroy and deallocate old array

	mov	ecx, DWORD PTR [ebx]
	test	ecx, ecx
	je	SHORT $LN61@Emplace_re
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h

; 35   : 								void					deallocate		(pointer p, size_type n) const			{	dlfree	(p);				}

	call	_dlfree
$LN61@Emplace_re:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1737 :         _Myfirst = _Newvec;

	mov	eax, DWORD PTR __Newvec$[ebp]
	mov	DWORD PTR [ebx], eax

; 1738 :         _Mylast  = _Newvec + _Newsize;

	mov	ecx, DWORD PTR __Newsize$1$[ebp]
	lea	ecx, DWORD PTR [eax+ecx*8]
	mov	DWORD PTR [ebx+4], ecx

; 1739 :         _Myend   = _Newvec + _Newcapacity;

	mov	ecx, DWORD PTR __Newcapacity$1$[ebp]
	lea	ecx, DWORD PTR [eax+ecx*8]
	mov	DWORD PTR [ebx+8], ecx

; 790  :         _CATCH_END
; 791  : 
; 792  :         _Change_array(_Newvec, _Newsize, _Newcapacity);
; 793  :         return _Newvec + _Whereoff;

	mov	eax, DWORD PTR tv542[ebp]

; 794  :     }

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
__catch$??$_Emplace_reallocate@ABU_NormalItem@R_dsgraph@@@?$vector@U_NormalItem@R_dsgraph@@V?$doug_lea_alloc@U_NormalItem@R_dsgraph@@@@@std@@QAEPAU_NormalItem@R_dsgraph@@QAU23@ABU23@@Z$0:

; 785  :         }
; 786  :         _CATCH_ALL
; 787  :         _Destroy(_Constructed_first, _Constructed_last);
; 788  :         _Al.deallocate(_Newvec, _Newcapacity);

	push	ecx
	push	DWORD PTR __Newvec$[ebp]
	call	?deallocate@?$doug_lea_alloc@U_NormalItem@R_dsgraph@@@@QBEXPAU_NormalItem@R_dsgraph@@I@Z ; doug_lea_alloc<R_dsgraph::_NormalItem>::deallocate

; 789  :         _RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$LN78@Emplace_re:

; 765  :             _Xlength();

	call	?_Xlength@?$vector@U_NormalItem@R_dsgraph@@V?$doug_lea_alloc@U_NormalItem@R_dsgraph@@@@@std@@CAXXZ ; std::vector<R_dsgraph::_NormalItem,doug_lea_alloc<R_dsgraph::_NormalItem> >::_Xlength
$LN75@Emplace_re:
	int	3
	int	3
	int	3
	int	3
	int	3
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Emplace_reallocate@ABU_NormalItem@R_dsgraph@@@?$vector@U_NormalItem@R_dsgraph@@V?$doug_lea_alloc@U_NormalItem@R_dsgraph@@@@@std@@QAEPAU_NormalItem@R_dsgraph@@QAU23@ABU23@@Z:
	npad	1
	npad	1
	mov	eax, OFFSET __ehfuncinfo$??$_Emplace_reallocate@ABU_NormalItem@R_dsgraph@@@?$vector@U_NormalItem@R_dsgraph@@V?$doug_lea_alloc@U_NormalItem@R_dsgraph@@@@@std@@QAEPAU_NormalItem@R_dsgraph@@QAU23@ABU23@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Emplace_reallocate@ABU_NormalItem@R_dsgraph@@@?$vector@U_NormalItem@R_dsgraph@@V?$doug_lea_alloc@U_NormalItem@R_dsgraph@@@@@std@@QAEPAU_NormalItem@R_dsgraph@@QAU23@ABU23@@Z ENDP ; std::vector<R_dsgraph::_NormalItem,doug_lea_alloc<R_dsgraph::_NormalItem> >::_Emplace_reallocate<R_dsgraph::_NormalItem const &>
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Xlength@?$vector@U_MatrixItem@R_dsgraph@@V?$doug_lea_alloc@U_MatrixItem@R_dsgraph@@@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@U_MatrixItem@R_dsgraph@@V?$doug_lea_alloc@U_MatrixItem@R_dsgraph@@@@@std@@CAXXZ PROC ; std::vector<R_dsgraph::_MatrixItem,doug_lea_alloc<R_dsgraph::_MatrixItem> >::_Xlength, COMDAT

; 1761 :         _Xlength_error("vector too long");

	push	OFFSET ??_C@_0BA@FOIKENOD@vector?5too?5long@
	call	DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN3@Xlength:
	int	3
?_Xlength@?$vector@U_MatrixItem@R_dsgraph@@V?$doug_lea_alloc@U_MatrixItem@R_dsgraph@@@@@std@@CAXXZ ENDP ; std::vector<R_dsgraph::_MatrixItem,doug_lea_alloc<R_dsgraph::_MatrixItem> >::_Xlength
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Change_array@?$vector@U_MatrixItem@R_dsgraph@@V?$doug_lea_alloc@U_MatrixItem@R_dsgraph@@@@@std@@AAEXQAU_MatrixItem@R_dsgraph@@II@Z
_TEXT	SEGMENT
__Newvec$ = 8						; size = 4
__Newsize$ = 12						; size = 4
__Newcapacity$ = 16					; size = 4
?_Change_array@?$vector@U_MatrixItem@R_dsgraph@@V?$doug_lea_alloc@U_MatrixItem@R_dsgraph@@@@@std@@AAEXQAU_MatrixItem@R_dsgraph@@II@Z PROC ; std::vector<R_dsgraph::_MatrixItem,doug_lea_alloc<R_dsgraph::_MatrixItem> >::_Change_array, COMDAT
; _this$ = ecx

; 1723 :         const pointer _Newvec, const size_type _Newsize, const size_type _Newcapacity) {

	push	esi
	mov	esi, ecx

; 1724 :         // orphan all iterators, discard old array, acquire new array
; 1725 :         auto& _My_data    = _Mypair._Myval2;
; 1726 :         pointer& _Myfirst = _My_data._Myfirst;
; 1727 :         pointer& _Mylast  = _My_data._Mylast;
; 1728 :         pointer& _Myend   = _My_data._Myend;
; 1729 : 
; 1730 :         _My_data._Orphan_all();
; 1731 : 
; 1732 :         if (_Myfirst) { // destroy and deallocate old array

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN2@Change_arr
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h

; 35   : 								void					deallocate		(pointer p, size_type n) const			{	dlfree	(p);				}

	call	_dlfree
$LN2@Change_arr:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1738 :         _Mylast  = _Newvec + _Newsize;

	imul	eax, DWORD PTR __Newsize$[esp], 76
	mov	ecx, DWORD PTR __Newvec$[esp]
	mov	DWORD PTR [esi], ecx
	add	eax, ecx
	mov	DWORD PTR [esi+4], eax

; 1739 :         _Myend   = _Newvec + _Newcapacity;

	imul	eax, DWORD PTR __Newcapacity$[esp], 76
	add	eax, ecx
	mov	DWORD PTR [esi+8], eax
	pop	esi

; 1740 :     }

	ret	12					; 0000000cH
?_Change_array@?$vector@U_MatrixItem@R_dsgraph@@V?$doug_lea_alloc@U_MatrixItem@R_dsgraph@@@@@std@@AAEXQAU_MatrixItem@R_dsgraph@@II@Z ENDP ; std::vector<R_dsgraph::_MatrixItem,doug_lea_alloc<R_dsgraph::_MatrixItem> >::_Change_array
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Calculate_growth@?$vector@U_MatrixItem@R_dsgraph@@V?$doug_lea_alloc@U_MatrixItem@R_dsgraph@@@@@std@@ABEII@Z
_TEXT	SEGMENT
__Newsize$ = 8						; size = 4
?_Calculate_growth@?$vector@U_MatrixItem@R_dsgraph@@V?$doug_lea_alloc@U_MatrixItem@R_dsgraph@@@@@std@@ABEII@Z PROC ; std::vector<R_dsgraph::_MatrixItem,doug_lea_alloc<R_dsgraph::_MatrixItem> >::_Calculate_growth, COMDAT
; _this$ = ecx

; 1546 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx]

; 1671 :         // given _Oldcapacity and _Newsize, calculate geometric growth
; 1672 :         const size_type _Oldcapacity = capacity();
; 1673 :         const auto _Max              = max_size();
; 1674 : 
; 1675 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	ecx, 56512727				; 035e50d7H

; 1546 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	sar	eax, 2

; 1670 :     _CONSTEXPR20_CONTAINER size_type _Calculate_growth(const size_type _Newsize) const {

	push	esi

; 1546 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	imul	esi, eax, 678152731

; 1671 :         // given _Oldcapacity and _Newsize, calculate geometric growth
; 1672 :         const size_type _Oldcapacity = capacity();
; 1673 :         const auto _Max              = max_size();
; 1674 : 
; 1675 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	edx, esi
	shr	edx, 1
	sub	ecx, edx
	cmp	esi, ecx
	jbe	SHORT $LN2@Calculate_

; 1676 :             return _Max; // geometric growth would overflow

	mov	eax, 56512727				; 035e50d7H
	pop	esi

; 1682 :             return _Newsize; // geometric growth would be insufficient
; 1683 :         }
; 1684 : 
; 1685 :         return _Geometric; // geometric growth is sufficient
; 1686 :     }

	ret	4
$LN2@Calculate_:

; 1677 :         }
; 1678 : 
; 1679 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	lea	eax, DWORD PTR [edx+esi]

; 1680 : 
; 1681 :         if (_Geometric < _Newsize) {

	cmp	eax, DWORD PTR __Newsize$[esp]
	pop	esi
	cmovb	eax, DWORD PTR __Newsize$[esp-4]

; 1682 :             return _Newsize; // geometric growth would be insufficient
; 1683 :         }
; 1684 : 
; 1685 :         return _Geometric; // geometric growth is sufficient
; 1686 :     }

	ret	4
?_Calculate_growth@?$vector@U_MatrixItem@R_dsgraph@@V?$doug_lea_alloc@U_MatrixItem@R_dsgraph@@@@@std@@ABEII@Z ENDP ; std::vector<R_dsgraph::_MatrixItem,doug_lea_alloc<R_dsgraph::_MatrixItem> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Umove_if_noexcept@?$vector@U_MatrixItem@R_dsgraph@@V?$doug_lea_alloc@U_MatrixItem@R_dsgraph@@@@@std@@AAEXPAU_MatrixItem@R_dsgraph@@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
?_Umove_if_noexcept@?$vector@U_MatrixItem@R_dsgraph@@V?$doug_lea_alloc@U_MatrixItem@R_dsgraph@@@@@std@@AAEXPAU_MatrixItem@R_dsgraph@@00@Z PROC ; std::vector<R_dsgraph::_MatrixItem,doug_lea_alloc<R_dsgraph::_MatrixItem> >::_Umove_if_noexcept, COMDAT
; _this$dead$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1703 :     auto _UFirst      = _Get_unwrapped(_First);

	mov	eax, DWORD PTR __First$[esp-4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1659 :     _CONSTEXPR20_CONTAINER void _Umove_if_noexcept(pointer _First, pointer _Last, pointer _Dest) {

	push	ebx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	mov	ebx, DWORD PTR __Last$[esp]
	cmp	eax, ebx
	je	SHORT $LN7@Umove_if_n

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	edx, DWORD PTR __Dest$[esp]
	push	esi
	sub	edx, eax
	push	edi
$LL8@Umove_if_n:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h

; 37   : 								void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	lea	edi, DWORD PTR [edx+eax]
	mov	esi, eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	add	eax, 76					; 0000004cH
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h

; 37   : 								void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	ecx, 19					; 00000013H
	rep movsd
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	eax, ebx
	jne	SHORT $LL8@Umove_if_n
	pop	edi
	pop	esi
$LN7@Umove_if_n:
	pop	ebx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1663 :     }

	ret	12					; 0000000cH
?_Umove_if_noexcept@?$vector@U_MatrixItem@R_dsgraph@@V?$doug_lea_alloc@U_MatrixItem@R_dsgraph@@@@@std@@AAEXPAU_MatrixItem@R_dsgraph@@00@Z ENDP ; std::vector<R_dsgraph::_MatrixItem,doug_lea_alloc<R_dsgraph::_MatrixItem> >::_Umove_if_noexcept
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Umove@?$vector@U_MatrixItem@R_dsgraph@@V?$doug_lea_alloc@U_MatrixItem@R_dsgraph@@@@@std@@AAEPAU_MatrixItem@R_dsgraph@@PAU34@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
?_Umove@?$vector@U_MatrixItem@R_dsgraph@@V?$doug_lea_alloc@U_MatrixItem@R_dsgraph@@@@@std@@AAEPAU_MatrixItem@R_dsgraph@@PAU34@00@Z PROC ; std::vector<R_dsgraph::_MatrixItem,doug_lea_alloc<R_dsgraph::_MatrixItem> >::_Umove, COMDAT
; _this$dead$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	mov	edx, DWORD PTR __First$[esp-4]

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	eax, DWORD PTR __Dest$[esp-4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1644 :     _CONSTEXPR20_CONTAINER pointer _Umove(pointer _First, pointer _Last, pointer _Dest) {

	push	ebx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	mov	ebx, DWORD PTR __Last$[esp]
	cmp	edx, ebx
	je	SHORT $LN5@Umove
	push	esi
	push	edi
$LL6@Umove:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h

; 37   : 								void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	esi, edx
	mov	edi, eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1621 :         ++_Last;

	add	edx, 76					; 0000004cH
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h

; 37   : 								void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	ecx, 19					; 00000013H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1621 :         ++_Last;

	add	eax, 76					; 0000004cH
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h

; 37   : 								void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	rep movsd
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	edx, ebx
	jne	SHORT $LL6@Umove
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1646 :         return _Uninitialized_move(_First, _Last, _Dest, _Getal());

	pop	edi
	pop	esi
$LN5@Umove:

; 1647 :     }

	pop	ebx
	ret	12					; 0000000cH
?_Umove@?$vector@U_MatrixItem@R_dsgraph@@V?$doug_lea_alloc@U_MatrixItem@R_dsgraph@@@@@std@@AAEPAU_MatrixItem@R_dsgraph@@PAU34@00@Z ENDP ; std::vector<R_dsgraph::_MatrixItem,doug_lea_alloc<R_dsgraph::_MatrixItem> >::_Umove
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?max_size@?$vector@U_MatrixItem@R_dsgraph@@V?$doug_lea_alloc@U_MatrixItem@R_dsgraph@@@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@U_MatrixItem@R_dsgraph@@V?$doug_lea_alloc@U_MatrixItem@R_dsgraph@@@@@std@@QBEIXZ PROC ; std::vector<R_dsgraph::_MatrixItem,doug_lea_alloc<R_dsgraph::_MatrixItem> >::max_size, COMDAT
; _this$dead$ = ecx

; 1540 :         return (_STD min)(

	mov	eax, 56512727				; 035e50d7H

; 1541 :             static_cast<size_type>((numeric_limits<difference_type>::max)()), _Alty_traits::max_size(_Getal()));
; 1542 :     }

	ret	0
?max_size@?$vector@U_MatrixItem@R_dsgraph@@V?$doug_lea_alloc@U_MatrixItem@R_dsgraph@@@@@std@@QBEIXZ ENDP ; std::vector<R_dsgraph::_MatrixItem,doug_lea_alloc<R_dsgraph::_MatrixItem> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
;	COMDAT ?construct@?$doug_lea_alloc@U_MatrixItem@R_dsgraph@@@@QAEXPAU_MatrixItem@R_dsgraph@@ABU23@@Z
_TEXT	SEGMENT
_p$ = 8							; size = 4
__Val$ = 12						; size = 4
?construct@?$doug_lea_alloc@U_MatrixItem@R_dsgraph@@@@QAEXPAU_MatrixItem@R_dsgraph@@ABU23@@Z PROC ; doug_lea_alloc<R_dsgraph::_MatrixItem>::construct, COMDAT
; _this$dead$ = ecx

; 37   : 								void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	push	esi
	mov	esi, DWORD PTR __Val$[esp]
	mov	ecx, 19					; 00000013H
	push	edi
	mov	edi, DWORD PTR _p$[esp+4]
	rep movsd
	pop	edi
	pop	esi
	ret	8
?construct@?$doug_lea_alloc@U_MatrixItem@R_dsgraph@@@@QAEXPAU_MatrixItem@R_dsgraph@@ABU23@@Z ENDP ; doug_lea_alloc<R_dsgraph::_MatrixItem>::construct
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
;	COMDAT ?allocate@?$doug_lea_alloc@U_MatrixItem@R_dsgraph@@@@QBEPAU_MatrixItem@R_dsgraph@@IPBX@Z
_TEXT	SEGMENT
_n$ = 8							; size = 4
_p$dead$ = 12						; size = 4
?allocate@?$doug_lea_alloc@U_MatrixItem@R_dsgraph@@@@QBEPAU_MatrixItem@R_dsgraph@@IPBX@Z PROC ; doug_lea_alloc<R_dsgraph::_MatrixItem>::allocate, COMDAT
; _this$dead$ = ecx

; 33   : 								pointer					allocate		(size_type n, const void* p=0) const	{	return (T*)dlmalloc(sizeof(T)*(u32)n);	}

	imul	ecx, DWORD PTR _n$[esp-4], 76
	call	_dlmalloc
	ret	8
?allocate@?$doug_lea_alloc@U_MatrixItem@R_dsgraph@@@@QBEPAU_MatrixItem@R_dsgraph@@IPBX@Z ENDP ; doug_lea_alloc<R_dsgraph::_MatrixItem>::allocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Xlength@?$vector@U_NormalItem@R_dsgraph@@V?$doug_lea_alloc@U_NormalItem@R_dsgraph@@@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@U_NormalItem@R_dsgraph@@V?$doug_lea_alloc@U_NormalItem@R_dsgraph@@@@@std@@CAXXZ PROC ; std::vector<R_dsgraph::_NormalItem,doug_lea_alloc<R_dsgraph::_NormalItem> >::_Xlength, COMDAT

; 1761 :         _Xlength_error("vector too long");

	push	OFFSET ??_C@_0BA@FOIKENOD@vector?5too?5long@
	call	DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN3@Xlength:
	int	3
?_Xlength@?$vector@U_NormalItem@R_dsgraph@@V?$doug_lea_alloc@U_NormalItem@R_dsgraph@@@@@std@@CAXXZ ENDP ; std::vector<R_dsgraph::_NormalItem,doug_lea_alloc<R_dsgraph::_NormalItem> >::_Xlength
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Change_array@?$vector@U_NormalItem@R_dsgraph@@V?$doug_lea_alloc@U_NormalItem@R_dsgraph@@@@@std@@AAEXQAU_NormalItem@R_dsgraph@@II@Z
_TEXT	SEGMENT
__Newvec$ = 8						; size = 4
__Newsize$ = 12						; size = 4
__Newcapacity$ = 16					; size = 4
?_Change_array@?$vector@U_NormalItem@R_dsgraph@@V?$doug_lea_alloc@U_NormalItem@R_dsgraph@@@@@std@@AAEXQAU_NormalItem@R_dsgraph@@II@Z PROC ; std::vector<R_dsgraph::_NormalItem,doug_lea_alloc<R_dsgraph::_NormalItem> >::_Change_array, COMDAT
; _this$ = ecx

; 1723 :         const pointer _Newvec, const size_type _Newsize, const size_type _Newcapacity) {

	push	esi
	mov	esi, ecx

; 1724 :         // orphan all iterators, discard old array, acquire new array
; 1725 :         auto& _My_data    = _Mypair._Myval2;
; 1726 :         pointer& _Myfirst = _My_data._Myfirst;
; 1727 :         pointer& _Mylast  = _My_data._Mylast;
; 1728 :         pointer& _Myend   = _My_data._Myend;
; 1729 : 
; 1730 :         _My_data._Orphan_all();
; 1731 : 
; 1732 :         if (_Myfirst) { // destroy and deallocate old array

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN2@Change_arr
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h

; 35   : 								void					deallocate		(pointer p, size_type n) const			{	dlfree	(p);				}

	call	_dlfree
$LN2@Change_arr:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1737 :         _Myfirst = _Newvec;

	mov	ecx, DWORD PTR __Newvec$[esp]

; 1738 :         _Mylast  = _Newvec + _Newsize;

	mov	eax, DWORD PTR __Newsize$[esp]
	mov	DWORD PTR [esi], ecx
	lea	eax, DWORD PTR [ecx+eax*8]
	mov	DWORD PTR [esi+4], eax

; 1739 :         _Myend   = _Newvec + _Newcapacity;

	mov	eax, DWORD PTR __Newcapacity$[esp]
	lea	eax, DWORD PTR [ecx+eax*8]
	mov	DWORD PTR [esi+8], eax
	pop	esi

; 1740 :     }

	ret	12					; 0000000cH
?_Change_array@?$vector@U_NormalItem@R_dsgraph@@V?$doug_lea_alloc@U_NormalItem@R_dsgraph@@@@@std@@AAEXQAU_NormalItem@R_dsgraph@@II@Z ENDP ; std::vector<R_dsgraph::_NormalItem,doug_lea_alloc<R_dsgraph::_NormalItem> >::_Change_array
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Calculate_growth@?$vector@U_NormalItem@R_dsgraph@@V?$doug_lea_alloc@U_NormalItem@R_dsgraph@@@@@std@@ABEII@Z
_TEXT	SEGMENT
__Newsize$ = 8						; size = 4
?_Calculate_growth@?$vector@U_NormalItem@R_dsgraph@@V?$doug_lea_alloc@U_NormalItem@R_dsgraph@@@@@std@@ABEII@Z PROC ; std::vector<R_dsgraph::_NormalItem,doug_lea_alloc<R_dsgraph::_NormalItem> >::_Calculate_growth, COMDAT
; _this$ = ecx

; 1546 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	edx, DWORD PTR [ecx+8]
	sub	edx, DWORD PTR [ecx]

; 1671 :         // given _Oldcapacity and _Newsize, calculate geometric growth
; 1672 :         const size_type _Oldcapacity = capacity();
; 1673 :         const auto _Max              = max_size();
; 1674 : 
; 1675 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	ecx, 536870911				; 1fffffffH

; 1546 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	sar	edx, 3

; 1670 :     _CONSTEXPR20_CONTAINER size_type _Calculate_growth(const size_type _Newsize) const {

	push	esi

; 1671 :         // given _Oldcapacity and _Newsize, calculate geometric growth
; 1672 :         const size_type _Oldcapacity = capacity();
; 1673 :         const auto _Max              = max_size();
; 1674 : 
; 1675 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	esi, edx
	shr	esi, 1
	sub	ecx, esi
	cmp	edx, ecx
	jbe	SHORT $LN2@Calculate_

; 1676 :             return _Max; // geometric growth would overflow

	mov	eax, 536870911				; 1fffffffH
	pop	esi

; 1682 :             return _Newsize; // geometric growth would be insufficient
; 1683 :         }
; 1684 : 
; 1685 :         return _Geometric; // geometric growth is sufficient
; 1686 :     }

	ret	4
$LN2@Calculate_:

; 1677 :         }
; 1678 : 
; 1679 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	lea	eax, DWORD PTR [esi+edx]

; 1680 : 
; 1681 :         if (_Geometric < _Newsize) {

	cmp	eax, DWORD PTR __Newsize$[esp]
	pop	esi
	cmovb	eax, DWORD PTR __Newsize$[esp-4]

; 1682 :             return _Newsize; // geometric growth would be insufficient
; 1683 :         }
; 1684 : 
; 1685 :         return _Geometric; // geometric growth is sufficient
; 1686 :     }

	ret	4
?_Calculate_growth@?$vector@U_NormalItem@R_dsgraph@@V?$doug_lea_alloc@U_NormalItem@R_dsgraph@@@@@std@@ABEII@Z ENDP ; std::vector<R_dsgraph::_NormalItem,doug_lea_alloc<R_dsgraph::_NormalItem> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Umove_if_noexcept@?$vector@U_NormalItem@R_dsgraph@@V?$doug_lea_alloc@U_NormalItem@R_dsgraph@@@@@std@@AAEXPAU_NormalItem@R_dsgraph@@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
?_Umove_if_noexcept@?$vector@U_NormalItem@R_dsgraph@@V?$doug_lea_alloc@U_NormalItem@R_dsgraph@@@@@std@@AAEXPAU_NormalItem@R_dsgraph@@00@Z PROC ; std::vector<R_dsgraph::_NormalItem,doug_lea_alloc<R_dsgraph::_NormalItem> >::_Umove_if_noexcept, COMDAT
; _this$dead$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1703 :     auto _UFirst      = _Get_unwrapped(_First);

	mov	eax, DWORD PTR __First$[esp-4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1659 :     _CONSTEXPR20_CONTAINER void _Umove_if_noexcept(pointer _First, pointer _Last, pointer _Dest) {

	push	edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	mov	edi, DWORD PTR __Last$[esp]
	cmp	eax, edi
	je	SHORT $LN7@Umove_if_n

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	push	esi
	mov	esi, DWORD PTR __Dest$[esp+4]
	sub	esi, eax
$LL8@Umove_if_n:

; 1620 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [esi+eax], ecx
	mov	DWORD PTR [esi+eax+4], edx

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	add	eax, 8
	cmp	eax, edi
	jne	SHORT $LL8@Umove_if_n
	pop	esi
$LN7@Umove_if_n:
	pop	edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1663 :     }

	ret	12					; 0000000cH
?_Umove_if_noexcept@?$vector@U_NormalItem@R_dsgraph@@V?$doug_lea_alloc@U_NormalItem@R_dsgraph@@@@@std@@AAEXPAU_NormalItem@R_dsgraph@@00@Z ENDP ; std::vector<R_dsgraph::_NormalItem,doug_lea_alloc<R_dsgraph::_NormalItem> >::_Umove_if_noexcept
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Umove@?$vector@U_NormalItem@R_dsgraph@@V?$doug_lea_alloc@U_NormalItem@R_dsgraph@@@@@std@@AAEPAU_NormalItem@R_dsgraph@@PAU34@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
?_Umove@?$vector@U_NormalItem@R_dsgraph@@V?$doug_lea_alloc@U_NormalItem@R_dsgraph@@@@@std@@AAEPAU_NormalItem@R_dsgraph@@PAU34@00@Z PROC ; std::vector<R_dsgraph::_NormalItem,doug_lea_alloc<R_dsgraph::_NormalItem> >::_Umove, COMDAT
; _this$dead$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	mov	ecx, DWORD PTR __First$[esp-4]

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	eax, DWORD PTR __Dest$[esp-4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1644 :     _CONSTEXPR20_CONTAINER pointer _Umove(pointer _First, pointer _Last, pointer _Dest) {

	push	edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	mov	edi, DWORD PTR __Last$[esp]
	cmp	ecx, edi
	je	SHORT $LN5@Umove
	push	esi
$LL6@Umove:

; 1620 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

	mov	edx, DWORD PTR [ecx]
	mov	esi, DWORD PTR [ecx+4]

; 1621 :         ++_Last;

	add	ecx, 8
	mov	DWORD PTR [eax], edx
	mov	DWORD PTR [eax+4], esi
	add	eax, 8

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	ecx, edi
	jne	SHORT $LL6@Umove
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1646 :         return _Uninitialized_move(_First, _Last, _Dest, _Getal());

	pop	esi
$LN5@Umove:
	pop	edi

; 1647 :     }

	ret	12					; 0000000cH
?_Umove@?$vector@U_NormalItem@R_dsgraph@@V?$doug_lea_alloc@U_NormalItem@R_dsgraph@@@@@std@@AAEPAU_NormalItem@R_dsgraph@@PAU34@00@Z ENDP ; std::vector<R_dsgraph::_NormalItem,doug_lea_alloc<R_dsgraph::_NormalItem> >::_Umove
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?max_size@?$vector@U_NormalItem@R_dsgraph@@V?$doug_lea_alloc@U_NormalItem@R_dsgraph@@@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@U_NormalItem@R_dsgraph@@V?$doug_lea_alloc@U_NormalItem@R_dsgraph@@@@@std@@QBEIXZ PROC ; std::vector<R_dsgraph::_NormalItem,doug_lea_alloc<R_dsgraph::_NormalItem> >::max_size, COMDAT
; _this$dead$ = ecx

; 1540 :         return (_STD min)(

	mov	eax, 536870911				; 1fffffffH

; 1541 :             static_cast<size_type>((numeric_limits<difference_type>::max)()), _Alty_traits::max_size(_Getal()));
; 1542 :     }

	ret	0
?max_size@?$vector@U_NormalItem@R_dsgraph@@V?$doug_lea_alloc@U_NormalItem@R_dsgraph@@@@@std@@QBEIXZ ENDP ; std::vector<R_dsgraph::_NormalItem,doug_lea_alloc<R_dsgraph::_NormalItem> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
;	COMDAT ?construct@?$doug_lea_alloc@U_NormalItem@R_dsgraph@@@@QAEXPAU_NormalItem@R_dsgraph@@ABU23@@Z
_TEXT	SEGMENT
_p$ = 8							; size = 4
__Val$ = 12						; size = 4
?construct@?$doug_lea_alloc@U_NormalItem@R_dsgraph@@@@QAEXPAU_NormalItem@R_dsgraph@@ABU23@@Z PROC ; doug_lea_alloc<R_dsgraph::_NormalItem>::construct, COMDAT
; _this$dead$ = ecx

; 37   : 								void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	eax, DWORD PTR __Val$[esp-4]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR _p$[esp-4]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	ret	8
?construct@?$doug_lea_alloc@U_NormalItem@R_dsgraph@@@@QAEXPAU_NormalItem@R_dsgraph@@ABU23@@Z ENDP ; doug_lea_alloc<R_dsgraph::_NormalItem>::construct
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
;	COMDAT ?allocate@?$doug_lea_alloc@U_NormalItem@R_dsgraph@@@@QBEPAU_NormalItem@R_dsgraph@@IPBX@Z
_TEXT	SEGMENT
_n$ = 8							; size = 4
_p$dead$ = 12						; size = 4
?allocate@?$doug_lea_alloc@U_NormalItem@R_dsgraph@@@@QBEPAU_NormalItem@R_dsgraph@@IPBX@Z PROC ; doug_lea_alloc<R_dsgraph::_NormalItem>::allocate, COMDAT
; _this$dead$ = ecx

; 33   : 								pointer					allocate		(size_type n, const void* p=0) const	{	return (T*)dlmalloc(sizeof(T)*(u32)n);	}

	mov	eax, DWORD PTR _n$[esp-4]
	lea	ecx, DWORD PTR [eax*8]
	call	_dlmalloc
	ret	8
?allocate@?$doug_lea_alloc@U_NormalItem@R_dsgraph@@@@QBEPAU_NormalItem@R_dsgraph@@IPBX@Z ENDP ; doug_lea_alloc<R_dsgraph::_NormalItem>::allocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Getal@?$vector@U_MatrixItem@R_dsgraph@@V?$doug_lea_alloc@U_MatrixItem@R_dsgraph@@@@@std@@ABEABV?$doug_lea_alloc@U_MatrixItem@R_dsgraph@@@@XZ
_TEXT	SEGMENT
?_Getal@?$vector@U_MatrixItem@R_dsgraph@@V?$doug_lea_alloc@U_MatrixItem@R_dsgraph@@@@@std@@ABEABV?$doug_lea_alloc@U_MatrixItem@R_dsgraph@@@@XZ PROC ; std::vector<R_dsgraph::_MatrixItem,doug_lea_alloc<R_dsgraph::_MatrixItem> >::_Getal, COMDAT
; _this$ = ecx

; 1809 :         return _Mypair._Get_first();

	mov	eax, ecx

; 1810 :     }

	ret	0
?_Getal@?$vector@U_MatrixItem@R_dsgraph@@V?$doug_lea_alloc@U_MatrixItem@R_dsgraph@@@@@std@@ABEABV?$doug_lea_alloc@U_MatrixItem@R_dsgraph@@@@XZ ENDP ; std::vector<R_dsgraph::_MatrixItem,doug_lea_alloc<R_dsgraph::_MatrixItem> >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Umove_if_noexcept1@?$vector@U_MatrixItem@R_dsgraph@@V?$doug_lea_alloc@U_MatrixItem@R_dsgraph@@@@@std@@AAEXPAU_MatrixItem@R_dsgraph@@00U?$integral_constant@_N$00@2@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
?_Umove_if_noexcept1@?$vector@U_MatrixItem@R_dsgraph@@V?$doug_lea_alloc@U_MatrixItem@R_dsgraph@@@@@std@@AAEXPAU_MatrixItem@R_dsgraph@@00U?$integral_constant@_N$00@2@@Z PROC ; std::vector<R_dsgraph::_MatrixItem,doug_lea_alloc<R_dsgraph::_MatrixItem> >::_Umove_if_noexcept1, COMDAT
; _this$dead$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1703 :     auto _UFirst      = _Get_unwrapped(_First);

	mov	eax, DWORD PTR __First$[esp-4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1649 :     _CONSTEXPR20_CONTAINER void _Umove_if_noexcept1(pointer _First, pointer _Last, pointer _Dest, true_type) {

	push	ebx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	mov	ebx, DWORD PTR __Last$[esp]
	cmp	eax, ebx
	je	SHORT $LN5@Umove_if_n

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	edx, DWORD PTR __Dest$[esp]
	push	esi
	sub	edx, eax
	push	edi
$LL6@Umove_if_n:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h

; 37   : 								void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	lea	edi, DWORD PTR [edx+eax]
	mov	esi, eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	add	eax, 76					; 0000004cH
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h

; 37   : 								void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	ecx, 19					; 00000013H
	rep movsd
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	eax, ebx
	jne	SHORT $LL6@Umove_if_n
	pop	edi
	pop	esi
$LN5@Umove_if_n:
	pop	ebx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1652 :     }

	ret	16					; 00000010H
?_Umove_if_noexcept1@?$vector@U_MatrixItem@R_dsgraph@@V?$doug_lea_alloc@U_MatrixItem@R_dsgraph@@@@@std@@AAEXPAU_MatrixItem@R_dsgraph@@00U?$integral_constant@_N$00@2@@Z ENDP ; std::vector<R_dsgraph::_MatrixItem,doug_lea_alloc<R_dsgraph::_MatrixItem> >::_Umove_if_noexcept1
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?capacity@?$vector@U_MatrixItem@R_dsgraph@@V?$doug_lea_alloc@U_MatrixItem@R_dsgraph@@@@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@U_MatrixItem@R_dsgraph@@V?$doug_lea_alloc@U_MatrixItem@R_dsgraph@@@@@std@@QBEIXZ PROC ; std::vector<R_dsgraph::_MatrixItem,doug_lea_alloc<R_dsgraph::_MatrixItem> >::capacity, COMDAT
; _this$ = ecx

; 1545 :         auto& _My_data = _Mypair._Myval2;
; 1546 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx]
	sar	eax, 2
	imul	eax, eax, 678152731

; 1547 :     }

	ret	0
?capacity@?$vector@U_MatrixItem@R_dsgraph@@V?$doug_lea_alloc@U_MatrixItem@R_dsgraph@@@@@std@@QBEIXZ ENDP ; std::vector<R_dsgraph::_MatrixItem,doug_lea_alloc<R_dsgraph::_MatrixItem> >::capacity
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?max_size@?$_Normal_allocator_traits@V?$doug_lea_alloc@U_MatrixItem@R_dsgraph@@@@@std@@SAIABV?$doug_lea_alloc@U_MatrixItem@R_dsgraph@@@@@Z
_TEXT	SEGMENT
?max_size@?$_Normal_allocator_traits@V?$doug_lea_alloc@U_MatrixItem@R_dsgraph@@@@@std@@SAIABV?$doug_lea_alloc@U_MatrixItem@R_dsgraph@@@@@Z PROC ; std::_Normal_allocator_traits<doug_lea_alloc<R_dsgraph::_MatrixItem> >::max_size, COMDAT
; __Al$dead$ = ecx

; 591  :         if constexpr (_Has_max_size<_Alloc>::value) {
; 592  :             return _Al.max_size();

	mov	eax, 56512727				; 035e50d7H

; 593  :         } else {
; 594  :             return (numeric_limits<size_type>::max)() / sizeof(value_type);
; 595  :         }
; 596  :     }

	ret	0
?max_size@?$_Normal_allocator_traits@V?$doug_lea_alloc@U_MatrixItem@R_dsgraph@@@@@std@@SAIABV?$doug_lea_alloc@U_MatrixItem@R_dsgraph@@@@@Z ENDP ; std::_Normal_allocator_traits<doug_lea_alloc<R_dsgraph::_MatrixItem> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Getal@?$vector@U_NormalItem@R_dsgraph@@V?$doug_lea_alloc@U_NormalItem@R_dsgraph@@@@@std@@ABEABV?$doug_lea_alloc@U_NormalItem@R_dsgraph@@@@XZ
_TEXT	SEGMENT
?_Getal@?$vector@U_NormalItem@R_dsgraph@@V?$doug_lea_alloc@U_NormalItem@R_dsgraph@@@@@std@@ABEABV?$doug_lea_alloc@U_NormalItem@R_dsgraph@@@@XZ PROC ; std::vector<R_dsgraph::_NormalItem,doug_lea_alloc<R_dsgraph::_NormalItem> >::_Getal, COMDAT
; _this$ = ecx

; 1809 :         return _Mypair._Get_first();

	mov	eax, ecx

; 1810 :     }

	ret	0
?_Getal@?$vector@U_NormalItem@R_dsgraph@@V?$doug_lea_alloc@U_NormalItem@R_dsgraph@@@@@std@@ABEABV?$doug_lea_alloc@U_NormalItem@R_dsgraph@@@@XZ ENDP ; std::vector<R_dsgraph::_NormalItem,doug_lea_alloc<R_dsgraph::_NormalItem> >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Umove_if_noexcept1@?$vector@U_NormalItem@R_dsgraph@@V?$doug_lea_alloc@U_NormalItem@R_dsgraph@@@@@std@@AAEXPAU_NormalItem@R_dsgraph@@00U?$integral_constant@_N$00@2@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
?_Umove_if_noexcept1@?$vector@U_NormalItem@R_dsgraph@@V?$doug_lea_alloc@U_NormalItem@R_dsgraph@@@@@std@@AAEXPAU_NormalItem@R_dsgraph@@00U?$integral_constant@_N$00@2@@Z PROC ; std::vector<R_dsgraph::_NormalItem,doug_lea_alloc<R_dsgraph::_NormalItem> >::_Umove_if_noexcept1, COMDAT
; _this$dead$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1703 :     auto _UFirst      = _Get_unwrapped(_First);

	mov	eax, DWORD PTR __First$[esp-4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1649 :     _CONSTEXPR20_CONTAINER void _Umove_if_noexcept1(pointer _First, pointer _Last, pointer _Dest, true_type) {

	push	edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	mov	edi, DWORD PTR __Last$[esp]
	cmp	eax, edi
	je	SHORT $LN5@Umove_if_n

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	push	esi
	mov	esi, DWORD PTR __Dest$[esp+4]
	sub	esi, eax
$LL6@Umove_if_n:

; 1620 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [esi+eax], ecx
	mov	DWORD PTR [esi+eax+4], edx

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	add	eax, 8
	cmp	eax, edi
	jne	SHORT $LL6@Umove_if_n
	pop	esi
$LN5@Umove_if_n:
	pop	edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1652 :     }

	ret	16					; 00000010H
?_Umove_if_noexcept1@?$vector@U_NormalItem@R_dsgraph@@V?$doug_lea_alloc@U_NormalItem@R_dsgraph@@@@@std@@AAEXPAU_NormalItem@R_dsgraph@@00U?$integral_constant@_N$00@2@@Z ENDP ; std::vector<R_dsgraph::_NormalItem,doug_lea_alloc<R_dsgraph::_NormalItem> >::_Umove_if_noexcept1
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?capacity@?$vector@U_NormalItem@R_dsgraph@@V?$doug_lea_alloc@U_NormalItem@R_dsgraph@@@@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@U_NormalItem@R_dsgraph@@V?$doug_lea_alloc@U_NormalItem@R_dsgraph@@@@@std@@QBEIXZ PROC ; std::vector<R_dsgraph::_NormalItem,doug_lea_alloc<R_dsgraph::_NormalItem> >::capacity, COMDAT
; _this$ = ecx

; 1545 :         auto& _My_data = _Mypair._Myval2;
; 1546 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx]
	sar	eax, 3

; 1547 :     }

	ret	0
?capacity@?$vector@U_NormalItem@R_dsgraph@@V?$doug_lea_alloc@U_NormalItem@R_dsgraph@@@@@std@@QBEIXZ ENDP ; std::vector<R_dsgraph::_NormalItem,doug_lea_alloc<R_dsgraph::_NormalItem> >::capacity
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?max_size@?$_Normal_allocator_traits@V?$doug_lea_alloc@U_NormalItem@R_dsgraph@@@@@std@@SAIABV?$doug_lea_alloc@U_NormalItem@R_dsgraph@@@@@Z
_TEXT	SEGMENT
?max_size@?$_Normal_allocator_traits@V?$doug_lea_alloc@U_NormalItem@R_dsgraph@@@@@std@@SAIABV?$doug_lea_alloc@U_NormalItem@R_dsgraph@@@@@Z PROC ; std::_Normal_allocator_traits<doug_lea_alloc<R_dsgraph::_NormalItem> >::max_size, COMDAT
; __Al$dead$ = ecx

; 591  :         if constexpr (_Has_max_size<_Alloc>::value) {
; 592  :             return _Al.max_size();

	mov	eax, 536870911				; 1fffffffH

; 593  :         } else {
; 594  :             return (numeric_limits<size_type>::max)() / sizeof(value_type);
; 595  :         }
; 596  :     }

	ret	0
?max_size@?$_Normal_allocator_traits@V?$doug_lea_alloc@U_NormalItem@R_dsgraph@@@@@std@@SAIABV?$doug_lea_alloc@U_NormalItem@R_dsgraph@@@@@Z ENDP ; std::_Normal_allocator_traits<doug_lea_alloc<R_dsgraph::_NormalItem> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$doug_lea_alloc@U_MatrixItem@R_dsgraph@@@@V?$_Vector_val@U?$_Simple_types@U_MatrixItem@R_dsgraph@@@std@@@std@@$00@std@@QBEABV?$doug_lea_alloc@U_MatrixItem@R_dsgraph@@@@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@V?$doug_lea_alloc@U_MatrixItem@R_dsgraph@@@@V?$_Vector_val@U?$_Simple_types@U_MatrixItem@R_dsgraph@@@std@@@std@@$00@std@@QBEABV?$doug_lea_alloc@U_MatrixItem@R_dsgraph@@@@XZ PROC ; std::_Compressed_pair<doug_lea_alloc<R_dsgraph::_MatrixItem>,std::_Vector_val<std::_Simple_types<R_dsgraph::_MatrixItem> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 1343 :         return *this;

	mov	eax, ecx

; 1344 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$doug_lea_alloc@U_MatrixItem@R_dsgraph@@@@V?$_Vector_val@U?$_Simple_types@U_MatrixItem@R_dsgraph@@@std@@@std@@$00@std@@QBEABV?$doug_lea_alloc@U_MatrixItem@R_dsgraph@@@@XZ ENDP ; std::_Compressed_pair<doug_lea_alloc<R_dsgraph::_MatrixItem>,std::_Vector_val<std::_Simple_types<R_dsgraph::_MatrixItem> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
;	COMDAT ?max_size@?$doug_lea_alloc@U_MatrixItem@R_dsgraph@@@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$doug_lea_alloc@U_MatrixItem@R_dsgraph@@@@QBEIXZ PROC ; doug_lea_alloc<R_dsgraph::_MatrixItem>::max_size, COMDAT
; _this$dead$ = ecx

; 39   : 								size_type				max_size		() const								{	size_type _Count = (size_type)(-1) / sizeof (T);	return (0 < _Count ? _Count : 1);	}

	mov	eax, 56512727				; 035e50d7H
	ret	0
?max_size@?$doug_lea_alloc@U_MatrixItem@R_dsgraph@@@@QBEIXZ ENDP ; doug_lea_alloc<R_dsgraph::_MatrixItem>::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$doug_lea_alloc@U_NormalItem@R_dsgraph@@@@V?$_Vector_val@U?$_Simple_types@U_NormalItem@R_dsgraph@@@std@@@std@@$00@std@@QBEABV?$doug_lea_alloc@U_NormalItem@R_dsgraph@@@@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@V?$doug_lea_alloc@U_NormalItem@R_dsgraph@@@@V?$_Vector_val@U?$_Simple_types@U_NormalItem@R_dsgraph@@@std@@@std@@$00@std@@QBEABV?$doug_lea_alloc@U_NormalItem@R_dsgraph@@@@XZ PROC ; std::_Compressed_pair<doug_lea_alloc<R_dsgraph::_NormalItem>,std::_Vector_val<std::_Simple_types<R_dsgraph::_NormalItem> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 1343 :         return *this;

	mov	eax, ecx

; 1344 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$doug_lea_alloc@U_NormalItem@R_dsgraph@@@@V?$_Vector_val@U?$_Simple_types@U_NormalItem@R_dsgraph@@@std@@@std@@$00@std@@QBEABV?$doug_lea_alloc@U_NormalItem@R_dsgraph@@@@XZ ENDP ; std::_Compressed_pair<doug_lea_alloc<R_dsgraph::_NormalItem>,std::_Vector_val<std::_Simple_types<R_dsgraph::_NormalItem> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
;	COMDAT ?max_size@?$doug_lea_alloc@U_NormalItem@R_dsgraph@@@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$doug_lea_alloc@U_NormalItem@R_dsgraph@@@@QBEIXZ PROC ; doug_lea_alloc<R_dsgraph::_NormalItem>::max_size, COMDAT
; _this$dead$ = ecx

; 39   : 								size_type				max_size		() const								{	size_type _Count = (size_type)(-1) / sizeof (T);	return (0 < _Count ? _Count : 1);	}

	mov	eax, 536870911				; 1fffffffH
	ret	0
?max_size@?$doug_lea_alloc@U_NormalItem@R_dsgraph@@@@QBEIXZ ENDP ; doug_lea_alloc<R_dsgraph::_NormalItem>::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Uninitialized_move@PAU_MatrixItem@R_dsgraph@@V?$doug_lea_alloc@U_MatrixItem@R_dsgraph@@@@@std@@YAPAU_MatrixItem@R_dsgraph@@QAU12@0PAU12@AAV?$doug_lea_alloc@U_MatrixItem@R_dsgraph@@@@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Al$dead$ = 12						; size = 4
??$_Uninitialized_move@PAU_MatrixItem@R_dsgraph@@V?$doug_lea_alloc@U_MatrixItem@R_dsgraph@@@@@std@@YAPAU_MatrixItem@R_dsgraph@@QAU12@0PAU12@AAV?$doug_lea_alloc@U_MatrixItem@R_dsgraph@@@@@Z PROC ; std::_Uninitialized_move<R_dsgraph::_MatrixItem *,doug_lea_alloc<R_dsgraph::_MatrixItem> >, COMDAT
; __First$ = ecx
; __Last$ = edx

; 1699 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

	push	ebx
	mov	ebx, edx
	mov	eax, ecx

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	edx, DWORD PTR __Dest$[esp]

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	eax, ebx
	je	SHORT $LN20@Uninitiali
	push	esi
	push	edi
	npad	1
$LL4@Uninitiali:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h

; 37   : 								void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	esi, eax
	mov	edi, edx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1621 :         ++_Last;

	add	eax, 76					; 0000004cH
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h

; 37   : 								void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	ecx, 19					; 00000013H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1621 :         ++_Last;

	add	edx, 76					; 0000004cH
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h

; 37   : 								void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	rep movsd
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	eax, ebx
	jne	SHORT $LL4@Uninitiali

; 1718 :         _Backout._Emplace_back(_STD move(*_UFirst));
; 1719 :     }
; 1720 : 
; 1721 :     return _Backout._Release();

	pop	edi
	pop	esi
$LN20@Uninitiali:

; 1722 : }

	mov	eax, edx
	pop	ebx
	ret	0
??$_Uninitialized_move@PAU_MatrixItem@R_dsgraph@@V?$doug_lea_alloc@U_MatrixItem@R_dsgraph@@@@@std@@YAPAU_MatrixItem@R_dsgraph@@QAU12@0PAU12@AAV?$doug_lea_alloc@U_MatrixItem@R_dsgraph@@@@@Z ENDP ; std::_Uninitialized_move<R_dsgraph::_MatrixItem *,doug_lea_alloc<R_dsgraph::_MatrixItem> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_Get_unwrapped@ABQAU_MatrixItem@R_dsgraph@@@std@@YA?A_TABQAU_MatrixItem@R_dsgraph@@@Z
_TEXT	SEGMENT
??$_Get_unwrapped@ABQAU_MatrixItem@R_dsgraph@@@std@@YA?A_TABQAU_MatrixItem@R_dsgraph@@@Z PROC ; std::_Get_unwrapped<R_dsgraph::_MatrixItem * const &>, COMDAT
; __It$ = ecx

; 1275 :     // unwrap an iterator previously subjected to _Adl_verify_range or otherwise validated
; 1276 :     if constexpr (is_pointer_v<decay_t<_Iter>>) { // special-case pointers and arrays
; 1277 :         return _It + 0;

	mov	eax, DWORD PTR [ecx]

; 1278 :     } else if constexpr (_Unwrappable_v<_Iter>) {
; 1279 :         return static_cast<_Iter&&>(_It)._Unwrapped();
; 1280 :     } else {
; 1281 :         return static_cast<_Iter&&>(_It);
; 1282 :     }
; 1283 : }

	ret	0
??$_Get_unwrapped@ABQAU_MatrixItem@R_dsgraph@@@std@@YA?A_TABQAU_MatrixItem@R_dsgraph@@@Z ENDP ; std::_Get_unwrapped<R_dsgraph::_MatrixItem * const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Uninitialized_move@PAU_NormalItem@R_dsgraph@@V?$doug_lea_alloc@U_NormalItem@R_dsgraph@@@@@std@@YAPAU_NormalItem@R_dsgraph@@QAU12@0PAU12@AAV?$doug_lea_alloc@U_NormalItem@R_dsgraph@@@@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Al$dead$ = 12						; size = 4
??$_Uninitialized_move@PAU_NormalItem@R_dsgraph@@V?$doug_lea_alloc@U_NormalItem@R_dsgraph@@@@@std@@YAPAU_NormalItem@R_dsgraph@@QAU12@0PAU12@AAV?$doug_lea_alloc@U_NormalItem@R_dsgraph@@@@@Z PROC ; std::_Uninitialized_move<R_dsgraph::_NormalItem *,doug_lea_alloc<R_dsgraph::_NormalItem> >, COMDAT
; __First$ = ecx
; __Last$ = edx

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	eax, DWORD PTR __Dest$[esp-4]

; 1699 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

	push	edi
	mov	edi, edx

; 1700 :     // move [_First, _Last) to raw _Dest, using _Al
; 1701 :     // note: only called internally from elsewhere in the STL
; 1702 :     using _Ptrval     = typename _Alloc::value_type*;
; 1703 :     auto _UFirst      = _Get_unwrapped(_First);
; 1704 :     const auto _ULast = _Get_unwrapped(_Last);
; 1705 :     if constexpr (conjunction_v<bool_constant<_Ptr_move_cat<decltype(_UFirst), _Ptrval>::_Really_trivial>,
; 1706 :                       _Uses_default_construct<_Alloc, _Ptrval, decltype(_STD move(*_UFirst))>>) {
; 1707 : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 1708 :         if (!_STD is_constant_evaluated())
; 1709 : #endif // __cpp_lib_constexpr_dynamic_alloc
; 1710 :         {
; 1711 :             _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));
; 1712 :             return _Dest + (_ULast - _UFirst);
; 1713 :         }
; 1714 :     }
; 1715 : 
; 1716 :     _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	ecx, edi
	je	SHORT $LN3@Uninitiali
	push	esi
	npad	4
$LL4@Uninitiali:

; 1620 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

	mov	edx, DWORD PTR [ecx]
	mov	esi, DWORD PTR [ecx+4]

; 1621 :         ++_Last;

	add	ecx, 8
	mov	DWORD PTR [eax], edx
	mov	DWORD PTR [eax+4], esi
	add	eax, 8

; 1700 :     // move [_First, _Last) to raw _Dest, using _Al
; 1701 :     // note: only called internally from elsewhere in the STL
; 1702 :     using _Ptrval     = typename _Alloc::value_type*;
; 1703 :     auto _UFirst      = _Get_unwrapped(_First);
; 1704 :     const auto _ULast = _Get_unwrapped(_Last);
; 1705 :     if constexpr (conjunction_v<bool_constant<_Ptr_move_cat<decltype(_UFirst), _Ptrval>::_Really_trivial>,
; 1706 :                       _Uses_default_construct<_Alloc, _Ptrval, decltype(_STD move(*_UFirst))>>) {
; 1707 : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 1708 :         if (!_STD is_constant_evaluated())
; 1709 : #endif // __cpp_lib_constexpr_dynamic_alloc
; 1710 :         {
; 1711 :             _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));
; 1712 :             return _Dest + (_ULast - _UFirst);
; 1713 :         }
; 1714 :     }
; 1715 : 
; 1716 :     _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	ecx, edi
	jne	SHORT $LL4@Uninitiali

; 1718 :         _Backout._Emplace_back(_STD move(*_UFirst));
; 1719 :     }
; 1720 : 
; 1721 :     return _Backout._Release();

	pop	esi
$LN3@Uninitiali:
	pop	edi

; 1722 : }

	ret	0
??$_Uninitialized_move@PAU_NormalItem@R_dsgraph@@V?$doug_lea_alloc@U_NormalItem@R_dsgraph@@@@@std@@YAPAU_NormalItem@R_dsgraph@@QAU12@0PAU12@AAV?$doug_lea_alloc@U_NormalItem@R_dsgraph@@@@@Z ENDP ; std::_Uninitialized_move<R_dsgraph::_NormalItem *,doug_lea_alloc<R_dsgraph::_NormalItem> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_Get_unwrapped@ABQAU_NormalItem@R_dsgraph@@@std@@YA?A_TABQAU_NormalItem@R_dsgraph@@@Z
_TEXT	SEGMENT
??$_Get_unwrapped@ABQAU_NormalItem@R_dsgraph@@@std@@YA?A_TABQAU_NormalItem@R_dsgraph@@@Z PROC ; std::_Get_unwrapped<R_dsgraph::_NormalItem * const &>, COMDAT
; __It$ = ecx

; 1275 :     // unwrap an iterator previously subjected to _Adl_verify_range or otherwise validated
; 1276 :     if constexpr (is_pointer_v<decay_t<_Iter>>) { // special-case pointers and arrays
; 1277 :         return _It + 0;

	mov	eax, DWORD PTR [ecx]

; 1278 :     } else if constexpr (_Unwrappable_v<_Iter>) {
; 1279 :         return static_cast<_Iter&&>(_It)._Unwrapped();
; 1280 :     } else {
; 1281 :         return static_cast<_Iter&&>(_It);
; 1282 :     }
; 1283 : }

	ret	0
??$_Get_unwrapped@ABQAU_NormalItem@R_dsgraph@@@std@@YA?A_TABQAU_NormalItem@R_dsgraph@@@Z ENDP ; std::_Get_unwrapped<R_dsgraph::_NormalItem * const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Release@?$_Uninitialized_backout_al@V?$doug_lea_alloc@U_NormalItem@R_dsgraph@@@@@std@@QAEPAU_NormalItem@R_dsgraph@@XZ
_TEXT	SEGMENT
?_Release@?$_Uninitialized_backout_al@V?$doug_lea_alloc@U_NormalItem@R_dsgraph@@@@@std@@QAEPAU_NormalItem@R_dsgraph@@XZ PROC ; std::_Uninitialized_backout_al<doug_lea_alloc<R_dsgraph::_NormalItem> >::_Release, COMDAT
; _this$ = ecx

; 1625 :         _First = _Last;

	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [ecx], eax

; 1626 :         return _Last;
; 1627 :     }

	ret	0
?_Release@?$_Uninitialized_backout_al@V?$doug_lea_alloc@U_NormalItem@R_dsgraph@@@@@std@@QAEPAU_NormalItem@R_dsgraph@@XZ ENDP ; std::_Uninitialized_backout_al<doug_lea_alloc<R_dsgraph::_NormalItem> >::_Release
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??1?$_Uninitialized_backout_al@V?$doug_lea_alloc@U_NormalItem@R_dsgraph@@@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Uninitialized_backout_al@V?$doug_lea_alloc@U_NormalItem@R_dsgraph@@@@@std@@QAE@XZ PROC ; std::_Uninitialized_backout_al<doug_lea_alloc<R_dsgraph::_NormalItem> >::~_Uninitialized_backout_al<doug_lea_alloc<R_dsgraph::_NormalItem> >, COMDAT
; _this$ = ecx

; 1615 :         _Destroy_range(_First, _Last, _Al);
; 1616 :     }

	ret	0
??1?$_Uninitialized_backout_al@V?$doug_lea_alloc@U_NormalItem@R_dsgraph@@@@@std@@QAE@XZ ENDP ; std::_Uninitialized_backout_al<doug_lea_alloc<R_dsgraph::_NormalItem> >::~_Uninitialized_backout_al<doug_lea_alloc<R_dsgraph::_NormalItem> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??0?$_Uninitialized_backout_al@V?$doug_lea_alloc@U_NormalItem@R_dsgraph@@@@@std@@QAE@PAU_NormalItem@R_dsgraph@@AAV?$doug_lea_alloc@U_NormalItem@R_dsgraph@@@@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Al_$ = 12						; size = 4
??0?$_Uninitialized_backout_al@V?$doug_lea_alloc@U_NormalItem@R_dsgraph@@@@@std@@QAE@PAU_NormalItem@R_dsgraph@@AAV?$doug_lea_alloc@U_NormalItem@R_dsgraph@@@@@Z PROC ; std::_Uninitialized_backout_al<doug_lea_alloc<R_dsgraph::_NormalItem> >::_Uninitialized_backout_al<doug_lea_alloc<R_dsgraph::_NormalItem> >, COMDAT
; _this$ = ecx

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	eax, DWORD PTR __Dest$[esp-4]
	mov	DWORD PTR [ecx], eax
	mov	DWORD PTR [ecx+4], eax
	mov	eax, DWORD PTR __Al_$[esp-4]
	mov	DWORD PTR [ecx+8], eax
	mov	eax, ecx
	ret	8
??0?$_Uninitialized_backout_al@V?$doug_lea_alloc@U_NormalItem@R_dsgraph@@@@@std@@QAE@PAU_NormalItem@R_dsgraph@@AAV?$doug_lea_alloc@U_NormalItem@R_dsgraph@@@@@Z ENDP ; std::_Uninitialized_backout_al<doug_lea_alloc<R_dsgraph::_NormalItem> >::_Uninitialized_backout_al<doug_lea_alloc<R_dsgraph::_NormalItem> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Release@?$_Uninitialized_backout_al@V?$doug_lea_alloc@U_MatrixItem@R_dsgraph@@@@@std@@QAEPAU_MatrixItem@R_dsgraph@@XZ
_TEXT	SEGMENT
?_Release@?$_Uninitialized_backout_al@V?$doug_lea_alloc@U_MatrixItem@R_dsgraph@@@@@std@@QAEPAU_MatrixItem@R_dsgraph@@XZ PROC ; std::_Uninitialized_backout_al<doug_lea_alloc<R_dsgraph::_MatrixItem> >::_Release, COMDAT
; _this$ = ecx

; 1625 :         _First = _Last;

	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [ecx], eax

; 1626 :         return _Last;
; 1627 :     }

	ret	0
?_Release@?$_Uninitialized_backout_al@V?$doug_lea_alloc@U_MatrixItem@R_dsgraph@@@@@std@@QAEPAU_MatrixItem@R_dsgraph@@XZ ENDP ; std::_Uninitialized_backout_al<doug_lea_alloc<R_dsgraph::_MatrixItem> >::_Release
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??1?$_Uninitialized_backout_al@V?$doug_lea_alloc@U_MatrixItem@R_dsgraph@@@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Uninitialized_backout_al@V?$doug_lea_alloc@U_MatrixItem@R_dsgraph@@@@@std@@QAE@XZ PROC ; std::_Uninitialized_backout_al<doug_lea_alloc<R_dsgraph::_MatrixItem> >::~_Uninitialized_backout_al<doug_lea_alloc<R_dsgraph::_MatrixItem> >, COMDAT
; _this$ = ecx

; 1615 :         _Destroy_range(_First, _Last, _Al);
; 1616 :     }

	ret	0
??1?$_Uninitialized_backout_al@V?$doug_lea_alloc@U_MatrixItem@R_dsgraph@@@@@std@@QAE@XZ ENDP ; std::_Uninitialized_backout_al<doug_lea_alloc<R_dsgraph::_MatrixItem> >::~_Uninitialized_backout_al<doug_lea_alloc<R_dsgraph::_MatrixItem> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??0?$_Uninitialized_backout_al@V?$doug_lea_alloc@U_MatrixItem@R_dsgraph@@@@@std@@QAE@PAU_MatrixItem@R_dsgraph@@AAV?$doug_lea_alloc@U_MatrixItem@R_dsgraph@@@@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Al_$ = 12						; size = 4
??0?$_Uninitialized_backout_al@V?$doug_lea_alloc@U_MatrixItem@R_dsgraph@@@@@std@@QAE@PAU_MatrixItem@R_dsgraph@@AAV?$doug_lea_alloc@U_MatrixItem@R_dsgraph@@@@@Z PROC ; std::_Uninitialized_backout_al<doug_lea_alloc<R_dsgraph::_MatrixItem> >::_Uninitialized_backout_al<doug_lea_alloc<R_dsgraph::_MatrixItem> >, COMDAT
; _this$ = ecx

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	eax, DWORD PTR __Dest$[esp-4]
	mov	DWORD PTR [ecx], eax
	mov	DWORD PTR [ecx+4], eax
	mov	eax, DWORD PTR __Al_$[esp-4]
	mov	DWORD PTR [ecx+8], eax
	mov	eax, ecx
	ret	8
??0?$_Uninitialized_backout_al@V?$doug_lea_alloc@U_MatrixItem@R_dsgraph@@@@@std@@QAE@PAU_MatrixItem@R_dsgraph@@AAV?$doug_lea_alloc@U_MatrixItem@R_dsgraph@@@@@Z ENDP ; std::_Uninitialized_backout_al<doug_lea_alloc<R_dsgraph::_MatrixItem> >::_Uninitialized_backout_al<doug_lea_alloc<R_dsgraph::_MatrixItem> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\type_traits
;	COMDAT ??$move@AAU_MatrixItem@R_dsgraph@@@std@@YA$$QAU_MatrixItem@R_dsgraph@@AAU12@@Z
_TEXT	SEGMENT
??$move@AAU_MatrixItem@R_dsgraph@@@std@@YA$$QAU_MatrixItem@R_dsgraph@@AAU12@@Z PROC ; std::move<R_dsgraph::_MatrixItem &>, COMDAT
; __Arg$ = ecx

; 1397 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

	mov	eax, ecx

; 1398 : }

	ret	0
??$move@AAU_MatrixItem@R_dsgraph@@@std@@YA$$QAU_MatrixItem@R_dsgraph@@AAU12@@Z ENDP ; std::move<R_dsgraph::_MatrixItem &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Emplace_back@U_MatrixItem@R_dsgraph@@@?$_Uninitialized_backout_al@V?$doug_lea_alloc@U_MatrixItem@R_dsgraph@@@@@std@@QAEX$$QAU_MatrixItem@R_dsgraph@@@Z
_TEXT	SEGMENT
_<_Vals_0>$ = 8						; size = 4
??$_Emplace_back@U_MatrixItem@R_dsgraph@@@?$_Uninitialized_backout_al@V?$doug_lea_alloc@U_MatrixItem@R_dsgraph@@@@@std@@QAEX$$QAU_MatrixItem@R_dsgraph@@@Z PROC ; std::_Uninitialized_backout_al<doug_lea_alloc<R_dsgraph::_MatrixItem> >::_Emplace_back<R_dsgraph::_MatrixItem>, COMDAT
; _this$ = ecx

; 1619 :     _CONSTEXPR20_DYNALLOC void _Emplace_back(_Types&&... _Vals) { // construct a new element at *_Last and increment

	mov	eax, ecx
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h

; 37   : 								void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	ecx, 19					; 00000013H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1619 :     _CONSTEXPR20_DYNALLOC void _Emplace_back(_Types&&... _Vals) { // construct a new element at *_Last and increment

	push	esi
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h

; 37   : 								void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	esi, DWORD PTR _<_Vals_0>$[esp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1619 :     _CONSTEXPR20_DYNALLOC void _Emplace_back(_Types&&... _Vals) { // construct a new element at *_Last and increment

	push	edi
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h

; 37   : 								void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	edi, DWORD PTR [eax+4]
	rep movsd
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1621 :         ++_Last;

	add	DWORD PTR [eax+4], 76			; 0000004cH
	pop	edi
	pop	esi

; 1622 :     }

	ret	4
??$_Emplace_back@U_MatrixItem@R_dsgraph@@@?$_Uninitialized_backout_al@V?$doug_lea_alloc@U_MatrixItem@R_dsgraph@@@@@std@@QAEX$$QAU_MatrixItem@R_dsgraph@@@Z ENDP ; std::_Uninitialized_backout_al<doug_lea_alloc<R_dsgraph::_MatrixItem> >::_Emplace_back<R_dsgraph::_MatrixItem>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\type_traits
;	COMDAT ??$move@AAU_NormalItem@R_dsgraph@@@std@@YA$$QAU_NormalItem@R_dsgraph@@AAU12@@Z
_TEXT	SEGMENT
??$move@AAU_NormalItem@R_dsgraph@@@std@@YA$$QAU_NormalItem@R_dsgraph@@AAU12@@Z PROC ; std::move<R_dsgraph::_NormalItem &>, COMDAT
; __Arg$ = ecx

; 1397 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

	mov	eax, ecx

; 1398 : }

	ret	0
??$move@AAU_NormalItem@R_dsgraph@@@std@@YA$$QAU_NormalItem@R_dsgraph@@AAU12@@Z ENDP ; std::move<R_dsgraph::_NormalItem &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Emplace_back@U_NormalItem@R_dsgraph@@@?$_Uninitialized_backout_al@V?$doug_lea_alloc@U_NormalItem@R_dsgraph@@@@@std@@QAEX$$QAU_NormalItem@R_dsgraph@@@Z
_TEXT	SEGMENT
_<_Vals_0>$ = 8						; size = 4
??$_Emplace_back@U_NormalItem@R_dsgraph@@@?$_Uninitialized_backout_al@V?$doug_lea_alloc@U_NormalItem@R_dsgraph@@@@@std@@QAEX$$QAU_NormalItem@R_dsgraph@@@Z PROC ; std::_Uninitialized_backout_al<doug_lea_alloc<R_dsgraph::_NormalItem> >::_Emplace_back<R_dsgraph::_NormalItem>, COMDAT
; _this$ = ecx

; 1620 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

	mov	eax, DWORD PTR _<_Vals_0>$[esp-4]
	push	esi
	mov	esi, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax], edx
	mov	DWORD PTR [eax+4], esi

; 1621 :         ++_Last;

	add	DWORD PTR [ecx+4], 8
	pop	esi

; 1622 :     }

	ret	4
??$_Emplace_back@U_NormalItem@R_dsgraph@@@?$_Uninitialized_backout_al@V?$doug_lea_alloc@U_NormalItem@R_dsgraph@@@@@std@@QAEX$$QAU_NormalItem@R_dsgraph@@@Z ENDP ; std::_Uninitialized_backout_al<doug_lea_alloc<R_dsgraph::_NormalItem> >::_Emplace_back<R_dsgraph::_NormalItem>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\type_traits
;	COMDAT ??$forward@U_MatrixItem@R_dsgraph@@@std@@YA$$QAU_MatrixItem@R_dsgraph@@AAU12@@Z
_TEXT	SEGMENT
??$forward@U_MatrixItem@R_dsgraph@@@std@@YA$$QAU_MatrixItem@R_dsgraph@@AAU12@@Z PROC ; std::forward<R_dsgraph::_MatrixItem>, COMDAT
; __Arg$ = ecx

; 1386 :     return static_cast<_Ty&&>(_Arg);

	mov	eax, ecx

; 1387 : }

	ret	0
??$forward@U_MatrixItem@R_dsgraph@@@std@@YA$$QAU_MatrixItem@R_dsgraph@@AAU12@@Z ENDP ; std::forward<R_dsgraph::_MatrixItem>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$construct@U_MatrixItem@R_dsgraph@@U12@@?$_Normal_allocator_traits@V?$doug_lea_alloc@U_MatrixItem@R_dsgraph@@@@@std@@SAXAAV?$doug_lea_alloc@U_MatrixItem@R_dsgraph@@@@PAU_MatrixItem@R_dsgraph@@$$QAU34@@Z
_TEXT	SEGMENT
_<_Args_0>$ = 8						; size = 4
??$construct@U_MatrixItem@R_dsgraph@@U12@@?$_Normal_allocator_traits@V?$doug_lea_alloc@U_MatrixItem@R_dsgraph@@@@@std@@SAXAAV?$doug_lea_alloc@U_MatrixItem@R_dsgraph@@@@PAU_MatrixItem@R_dsgraph@@$$QAU34@@Z PROC ; std::_Normal_allocator_traits<doug_lea_alloc<R_dsgraph::_MatrixItem> >::construct<R_dsgraph::_MatrixItem,R_dsgraph::_MatrixItem>, COMDAT
; __Al$dead$ = ecx
; __Ptr$ = edx

; 564  :     static _CONSTEXPR20_DYNALLOC void construct(_Alloc& _Al, _Ty* _Ptr, _Types&&... _Args) {

	push	esi
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h

; 37   : 								void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	esi, DWORD PTR _<_Args_0>$[esp]
	mov	ecx, 19					; 00000013H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 564  :     static _CONSTEXPR20_DYNALLOC void construct(_Alloc& _Al, _Ty* _Ptr, _Types&&... _Args) {

	push	edi
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h

; 37   : 								void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	edi, edx
	rep movsd
	pop	edi
	pop	esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 575  :     }

	ret	0
??$construct@U_MatrixItem@R_dsgraph@@U12@@?$_Normal_allocator_traits@V?$doug_lea_alloc@U_MatrixItem@R_dsgraph@@@@@std@@SAXAAV?$doug_lea_alloc@U_MatrixItem@R_dsgraph@@@@PAU_MatrixItem@R_dsgraph@@$$QAU34@@Z ENDP ; std::_Normal_allocator_traits<doug_lea_alloc<R_dsgraph::_MatrixItem> >::construct<R_dsgraph::_MatrixItem,R_dsgraph::_MatrixItem>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\type_traits
;	COMDAT ??$forward@U_NormalItem@R_dsgraph@@@std@@YA$$QAU_NormalItem@R_dsgraph@@AAU12@@Z
_TEXT	SEGMENT
??$forward@U_NormalItem@R_dsgraph@@@std@@YA$$QAU_NormalItem@R_dsgraph@@AAU12@@Z PROC ; std::forward<R_dsgraph::_NormalItem>, COMDAT
; __Arg$ = ecx

; 1386 :     return static_cast<_Ty&&>(_Arg);

	mov	eax, ecx

; 1387 : }

	ret	0
??$forward@U_NormalItem@R_dsgraph@@@std@@YA$$QAU_NormalItem@R_dsgraph@@AAU12@@Z ENDP ; std::forward<R_dsgraph::_NormalItem>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$construct@U_NormalItem@R_dsgraph@@U12@@?$_Normal_allocator_traits@V?$doug_lea_alloc@U_NormalItem@R_dsgraph@@@@@std@@SAXAAV?$doug_lea_alloc@U_NormalItem@R_dsgraph@@@@PAU_NormalItem@R_dsgraph@@$$QAU34@@Z
_TEXT	SEGMENT
_<_Args_0>$ = 8						; size = 4
??$construct@U_NormalItem@R_dsgraph@@U12@@?$_Normal_allocator_traits@V?$doug_lea_alloc@U_NormalItem@R_dsgraph@@@@@std@@SAXAAV?$doug_lea_alloc@U_NormalItem@R_dsgraph@@@@PAU_NormalItem@R_dsgraph@@$$QAU34@@Z PROC ; std::_Normal_allocator_traits<doug_lea_alloc<R_dsgraph::_NormalItem> >::construct<R_dsgraph::_NormalItem,R_dsgraph::_NormalItem>, COMDAT
; __Al$dead$ = ecx
; __Ptr$ = edx

; 565  :         if constexpr (_Uses_default_construct<_Alloc, _Ty*, _Types...>::value) {
; 566  :             (void) _Al; // TRANSITION, DevCom-1004719
; 567  : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 568  :             _STD construct_at(_Ptr, _STD forward<_Types>(_Args)...);
; 569  : #else // __cpp_lib_constexpr_dynamic_alloc
; 570  :             ::new (static_cast<void*>(_Ptr)) _Ty(_STD forward<_Types>(_Args)...);
; 571  : #endif // __cpp_lib_constexpr_dynamic_alloc
; 572  :         } else {
; 573  :             _Al.construct(_Ptr, _STD forward<_Types>(_Args)...);

	mov	eax, DWORD PTR _<_Args_0>$[esp-4]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR [edx], ecx
	mov	DWORD PTR [edx+4], eax

; 574  :         }
; 575  :     }

	ret	0
??$construct@U_NormalItem@R_dsgraph@@U12@@?$_Normal_allocator_traits@V?$doug_lea_alloc@U_NormalItem@R_dsgraph@@@@@std@@SAXAAV?$doug_lea_alloc@U_NormalItem@R_dsgraph@@@@PAU_NormalItem@R_dsgraph@@$$QAU34@@Z ENDP ; std::_Normal_allocator_traits<doug_lea_alloc<R_dsgraph::_NormalItem> >::construct<R_dsgraph::_NormalItem,R_dsgraph::_NormalItem>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
;	COMDAT ?deallocate@?$doug_lea_alloc@U_NormalItem@R_dsgraph@@@@QBEXPAU_NormalItem@R_dsgraph@@I@Z
_TEXT	SEGMENT
_p$ = 8							; size = 4
_n$dead$ = 12						; size = 4
?deallocate@?$doug_lea_alloc@U_NormalItem@R_dsgraph@@@@QBEXPAU_NormalItem@R_dsgraph@@I@Z PROC ; doug_lea_alloc<R_dsgraph::_NormalItem>::deallocate, COMDAT
; _this$dead$ = ecx

; 35   : 								void					deallocate		(pointer p, size_type n) const			{	dlfree	(p);				}

	mov	ecx, DWORD PTR _p$[esp-4]
	call	_dlfree
	ret	8
?deallocate@?$doug_lea_alloc@U_NormalItem@R_dsgraph@@@@QBEXPAU_NormalItem@R_dsgraph@@I@Z ENDP ; doug_lea_alloc<R_dsgraph::_NormalItem>::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Destroy_in_place@PAU_NormalItem@R_dsgraph@@@std@@YAXAAPAU_NormalItem@R_dsgraph@@@Z
_TEXT	SEGMENT
??$_Destroy_in_place@PAU_NormalItem@R_dsgraph@@@std@@YAXAAPAU_NormalItem@R_dsgraph@@@Z PROC ; std::_Destroy_in_place<R_dsgraph::_NormalItem *>, COMDAT
; __Obj$dead$ = ecx

; 295  :     if constexpr (is_array_v<_Ty>) {
; 296  :         _Destroy_range(_Obj, _Obj + extent_v<_Ty>);
; 297  :     } else {
; 298  :         _Obj.~_Ty();
; 299  :     }
; 300  : }

	ret	0
??$_Destroy_in_place@PAU_NormalItem@R_dsgraph@@@std@@YAXAAPAU_NormalItem@R_dsgraph@@@Z ENDP ; std::_Destroy_in_place<R_dsgraph::_NormalItem *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
;	COMDAT ?destroy@?$doug_lea_alloc@U_NormalItem@R_dsgraph@@@@QAEXPAU_NormalItem@R_dsgraph@@@Z
_TEXT	SEGMENT
_p$dead$ = 8						; size = 4
?destroy@?$doug_lea_alloc@U_NormalItem@R_dsgraph@@@@QAEXPAU_NormalItem@R_dsgraph@@@Z PROC ; doug_lea_alloc<R_dsgraph::_NormalItem>::destroy, COMDAT
; _this$dead$ = ecx

; 38   : 								void					destroy			(pointer p)								{	std::_Destroy_in_place(p);			}

	ret	4
?destroy@?$doug_lea_alloc@U_NormalItem@R_dsgraph@@@@QAEXPAU_NormalItem@R_dsgraph@@@Z ENDP ; doug_lea_alloc<R_dsgraph::_NormalItem>::destroy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$destroy@U_NormalItem@R_dsgraph@@@?$_Normal_allocator_traits@V?$doug_lea_alloc@U_NormalItem@R_dsgraph@@@@@std@@SAXAAV?$doug_lea_alloc@U_NormalItem@R_dsgraph@@@@PAU_NormalItem@R_dsgraph@@@Z
_TEXT	SEGMENT
??$destroy@U_NormalItem@R_dsgraph@@@?$_Normal_allocator_traits@V?$doug_lea_alloc@U_NormalItem@R_dsgraph@@@@@std@@SAXAAV?$doug_lea_alloc@U_NormalItem@R_dsgraph@@@@PAU_NormalItem@R_dsgraph@@@Z PROC ; std::_Normal_allocator_traits<doug_lea_alloc<R_dsgraph::_NormalItem> >::destroy<R_dsgraph::_NormalItem>, COMDAT
; __Al$dead$ = ecx
; __Ptr$dead$ = edx

; 579  :         if constexpr (_Uses_default_destroy<_Alloc, _Ty*>::value) {
; 580  : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 581  :             _STD destroy_at(_Ptr);
; 582  : #else // __cpp_lib_constexpr_dynamic_alloc
; 583  :             _Ptr->~_Ty();
; 584  : #endif // __cpp_lib_constexpr_dynamic_alloc
; 585  :         } else {
; 586  :             _Al.destroy(_Ptr);
; 587  :         }
; 588  :     }

	ret	0
??$destroy@U_NormalItem@R_dsgraph@@@?$_Normal_allocator_traits@V?$doug_lea_alloc@U_NormalItem@R_dsgraph@@@@@std@@SAXAAV?$doug_lea_alloc@U_NormalItem@R_dsgraph@@@@PAU_NormalItem@R_dsgraph@@@Z ENDP ; std::_Normal_allocator_traits<doug_lea_alloc<R_dsgraph::_NormalItem> >::destroy<R_dsgraph::_NormalItem>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Destroy_range@V?$doug_lea_alloc@U_NormalItem@R_dsgraph@@@@@std@@YAXPAU_NormalItem@R_dsgraph@@QAU12@AAV?$doug_lea_alloc@U_NormalItem@R_dsgraph@@@@@Z
_TEXT	SEGMENT
__Al$dead$ = 8						; size = 4
??$_Destroy_range@V?$doug_lea_alloc@U_NormalItem@R_dsgraph@@@@@std@@YAXPAU_NormalItem@R_dsgraph@@QAU12@AAV?$doug_lea_alloc@U_NormalItem@R_dsgraph@@@@@Z PROC ; std::_Destroy_range<doug_lea_alloc<R_dsgraph::_NormalItem> >, COMDAT
; __First$dead$ = ecx
; __Last$dead$ = edx

; 901  :     // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
; 902  :     using _Ty = typename _Alloc::value_type;
; 903  :     if constexpr (!conjunction_v<is_trivially_destructible<_Ty>, _Uses_default_destroy<_Alloc, _Ty*>>) {
; 904  :         for (; _First != _Last; ++_First) {
; 905  :             allocator_traits<_Alloc>::destroy(_Al, _Unfancy(_First));
; 906  :         }
; 907  :     }
; 908  : }

	ret	0
??$_Destroy_range@V?$doug_lea_alloc@U_NormalItem@R_dsgraph@@@@@std@@YAXPAU_NormalItem@R_dsgraph@@QAU12@AAV?$doug_lea_alloc@U_NormalItem@R_dsgraph@@@@@Z ENDP ; std::_Destroy_range<doug_lea_alloc<R_dsgraph::_NormalItem> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Destroy@?$vector@U_NormalItem@R_dsgraph@@V?$doug_lea_alloc@U_NormalItem@R_dsgraph@@@@@std@@AAEXPAU_NormalItem@R_dsgraph@@0@Z
_TEXT	SEGMENT
__First$dead$ = 8					; size = 4
__Last$dead$ = 12					; size = 4
?_Destroy@?$vector@U_NormalItem@R_dsgraph@@V?$doug_lea_alloc@U_NormalItem@R_dsgraph@@@@@std@@AAEXPAU_NormalItem@R_dsgraph@@0@Z PROC ; std::vector<R_dsgraph::_NormalItem,doug_lea_alloc<R_dsgraph::_NormalItem> >::_Destroy, COMDAT
; _this$dead$ = ecx

; 1666 :         // destroy [_First, _Last) using allocator
; 1667 :         _Destroy_range(_First, _Last, _Getal());
; 1668 :     }

	ret	8
?_Destroy@?$vector@U_NormalItem@R_dsgraph@@V?$doug_lea_alloc@U_NormalItem@R_dsgraph@@@@@std@@AAEXPAU_NormalItem@R_dsgraph@@0@Z ENDP ; std::vector<R_dsgraph::_NormalItem,doug_lea_alloc<R_dsgraph::_NormalItem> >::_Destroy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
;	COMDAT ?deallocate@?$doug_lea_alloc@U_MatrixItem@R_dsgraph@@@@QBEXPAU_MatrixItem@R_dsgraph@@I@Z
_TEXT	SEGMENT
_p$ = 8							; size = 4
_n$dead$ = 12						; size = 4
?deallocate@?$doug_lea_alloc@U_MatrixItem@R_dsgraph@@@@QBEXPAU_MatrixItem@R_dsgraph@@I@Z PROC ; doug_lea_alloc<R_dsgraph::_MatrixItem>::deallocate, COMDAT
; _this$dead$ = ecx

; 35   : 								void					deallocate		(pointer p, size_type n) const			{	dlfree	(p);				}

	mov	ecx, DWORD PTR _p$[esp-4]
	call	_dlfree
	ret	8
?deallocate@?$doug_lea_alloc@U_MatrixItem@R_dsgraph@@@@QBEXPAU_MatrixItem@R_dsgraph@@I@Z ENDP ; doug_lea_alloc<R_dsgraph::_MatrixItem>::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Destroy_in_place@PAU_MatrixItem@R_dsgraph@@@std@@YAXAAPAU_MatrixItem@R_dsgraph@@@Z
_TEXT	SEGMENT
??$_Destroy_in_place@PAU_MatrixItem@R_dsgraph@@@std@@YAXAAPAU_MatrixItem@R_dsgraph@@@Z PROC ; std::_Destroy_in_place<R_dsgraph::_MatrixItem *>, COMDAT
; __Obj$dead$ = ecx

; 295  :     if constexpr (is_array_v<_Ty>) {
; 296  :         _Destroy_range(_Obj, _Obj + extent_v<_Ty>);
; 297  :     } else {
; 298  :         _Obj.~_Ty();
; 299  :     }
; 300  : }

	ret	0
??$_Destroy_in_place@PAU_MatrixItem@R_dsgraph@@@std@@YAXAAPAU_MatrixItem@R_dsgraph@@@Z ENDP ; std::_Destroy_in_place<R_dsgraph::_MatrixItem *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
;	COMDAT ?destroy@?$doug_lea_alloc@U_MatrixItem@R_dsgraph@@@@QAEXPAU_MatrixItem@R_dsgraph@@@Z
_TEXT	SEGMENT
_p$dead$ = 8						; size = 4
?destroy@?$doug_lea_alloc@U_MatrixItem@R_dsgraph@@@@QAEXPAU_MatrixItem@R_dsgraph@@@Z PROC ; doug_lea_alloc<R_dsgraph::_MatrixItem>::destroy, COMDAT
; _this$dead$ = ecx

; 38   : 								void					destroy			(pointer p)								{	std::_Destroy_in_place(p);			}

	ret	4
?destroy@?$doug_lea_alloc@U_MatrixItem@R_dsgraph@@@@QAEXPAU_MatrixItem@R_dsgraph@@@Z ENDP ; doug_lea_alloc<R_dsgraph::_MatrixItem>::destroy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$destroy@U_MatrixItem@R_dsgraph@@@?$_Normal_allocator_traits@V?$doug_lea_alloc@U_MatrixItem@R_dsgraph@@@@@std@@SAXAAV?$doug_lea_alloc@U_MatrixItem@R_dsgraph@@@@PAU_MatrixItem@R_dsgraph@@@Z
_TEXT	SEGMENT
??$destroy@U_MatrixItem@R_dsgraph@@@?$_Normal_allocator_traits@V?$doug_lea_alloc@U_MatrixItem@R_dsgraph@@@@@std@@SAXAAV?$doug_lea_alloc@U_MatrixItem@R_dsgraph@@@@PAU_MatrixItem@R_dsgraph@@@Z PROC ; std::_Normal_allocator_traits<doug_lea_alloc<R_dsgraph::_MatrixItem> >::destroy<R_dsgraph::_MatrixItem>, COMDAT
; __Al$dead$ = ecx
; __Ptr$dead$ = edx

; 579  :         if constexpr (_Uses_default_destroy<_Alloc, _Ty*>::value) {
; 580  : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 581  :             _STD destroy_at(_Ptr);
; 582  : #else // __cpp_lib_constexpr_dynamic_alloc
; 583  :             _Ptr->~_Ty();
; 584  : #endif // __cpp_lib_constexpr_dynamic_alloc
; 585  :         } else {
; 586  :             _Al.destroy(_Ptr);
; 587  :         }
; 588  :     }

	ret	0
??$destroy@U_MatrixItem@R_dsgraph@@@?$_Normal_allocator_traits@V?$doug_lea_alloc@U_MatrixItem@R_dsgraph@@@@@std@@SAXAAV?$doug_lea_alloc@U_MatrixItem@R_dsgraph@@@@PAU_MatrixItem@R_dsgraph@@@Z ENDP ; std::_Normal_allocator_traits<doug_lea_alloc<R_dsgraph::_MatrixItem> >::destroy<R_dsgraph::_MatrixItem>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Destroy_range@V?$doug_lea_alloc@U_MatrixItem@R_dsgraph@@@@@std@@YAXPAU_MatrixItem@R_dsgraph@@QAU12@AAV?$doug_lea_alloc@U_MatrixItem@R_dsgraph@@@@@Z
_TEXT	SEGMENT
__Al$dead$ = 8						; size = 4
??$_Destroy_range@V?$doug_lea_alloc@U_MatrixItem@R_dsgraph@@@@@std@@YAXPAU_MatrixItem@R_dsgraph@@QAU12@AAV?$doug_lea_alloc@U_MatrixItem@R_dsgraph@@@@@Z PROC ; std::_Destroy_range<doug_lea_alloc<R_dsgraph::_MatrixItem> >, COMDAT
; __First$dead$ = ecx
; __Last$dead$ = edx

; 901  :     // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
; 902  :     using _Ty = typename _Alloc::value_type;
; 903  :     if constexpr (!conjunction_v<is_trivially_destructible<_Ty>, _Uses_default_destroy<_Alloc, _Ty*>>) {
; 904  :         for (; _First != _Last; ++_First) {
; 905  :             allocator_traits<_Alloc>::destroy(_Al, _Unfancy(_First));
; 906  :         }
; 907  :     }
; 908  : }

	ret	0
??$_Destroy_range@V?$doug_lea_alloc@U_MatrixItem@R_dsgraph@@@@@std@@YAXPAU_MatrixItem@R_dsgraph@@QAU12@AAV?$doug_lea_alloc@U_MatrixItem@R_dsgraph@@@@@Z ENDP ; std::_Destroy_range<doug_lea_alloc<R_dsgraph::_MatrixItem> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Destroy@?$vector@U_MatrixItem@R_dsgraph@@V?$doug_lea_alloc@U_MatrixItem@R_dsgraph@@@@@std@@AAEXPAU_MatrixItem@R_dsgraph@@0@Z
_TEXT	SEGMENT
__First$dead$ = 8					; size = 4
__Last$dead$ = 12					; size = 4
?_Destroy@?$vector@U_MatrixItem@R_dsgraph@@V?$doug_lea_alloc@U_MatrixItem@R_dsgraph@@@@@std@@AAEXPAU_MatrixItem@R_dsgraph@@0@Z PROC ; std::vector<R_dsgraph::_MatrixItem,doug_lea_alloc<R_dsgraph::_MatrixItem> >::_Destroy, COMDAT
; _this$dead$ = ecx

; 1666 :         // destroy [_First, _Last) using allocator
; 1667 :         _Destroy_range(_First, _Last, _Getal());
; 1668 :     }

	ret	8
?_Destroy@?$vector@U_MatrixItem@R_dsgraph@@V?$doug_lea_alloc@U_MatrixItem@R_dsgraph@@@@@std@@AAEXPAU_MatrixItem@R_dsgraph@@0@Z ENDP ; std::vector<R_dsgraph::_MatrixItem,doug_lea_alloc<R_dsgraph::_MatrixItem> >::_Destroy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
;	COMDAT ??$dealloc@UTNode@?$FixedMAP@PAUSTextureList@@UmapNormalItems@R_dsgraph@@Udoug_lea_allocator@@@@@doug_lea_allocator@@SAXAAPAUTNode@?$FixedMAP@PAUSTextureList@@UmapNormalItems@R_dsgraph@@Udoug_lea_allocator@@@@@Z
_TEXT	SEGMENT
??$dealloc@UTNode@?$FixedMAP@PAUSTextureList@@UmapNormalItems@R_dsgraph@@Udoug_lea_allocator@@@@@doug_lea_allocator@@SAXAAPAUTNode@?$FixedMAP@PAUSTextureList@@UmapNormalItems@R_dsgraph@@Udoug_lea_allocator@@@@@Z PROC ; doug_lea_allocator::dealloc<FixedMAP<STextureList *,R_dsgraph::mapNormalItems,doug_lea_allocator>::TNode>, COMDAT
; _p$ = ecx

; 53   : 		static	void	dealloc		(T *&p)			{	dlfree(p);	p=0;			}

	push	esi
	mov	esi, ecx
	mov	ecx, DWORD PTR [esi]
	call	_dlfree
	mov	DWORD PTR [esi], 0
	pop	esi
	ret	0
??$dealloc@UTNode@?$FixedMAP@PAUSTextureList@@UmapNormalItems@R_dsgraph@@Udoug_lea_allocator@@@@@doug_lea_allocator@@SAXAAPAUTNode@?$FixedMAP@PAUSTextureList@@UmapNormalItems@R_dsgraph@@Udoug_lea_allocator@@@@@Z ENDP ; doug_lea_allocator::dealloc<FixedMAP<STextureList *,R_dsgraph::mapNormalItems,doug_lea_allocator>::TNode>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
;	COMDAT ??$dealloc@UTNode@?$FixedMAP@PAUIDirect3DStateBlock9@@UmapNormalTextures@R_dsgraph@@Udoug_lea_allocator@@@@@doug_lea_allocator@@SAXAAPAUTNode@?$FixedMAP@PAUIDirect3DStateBlock9@@UmapNormalTextures@R_dsgraph@@Udoug_lea_allocator@@@@@Z
_TEXT	SEGMENT
??$dealloc@UTNode@?$FixedMAP@PAUIDirect3DStateBlock9@@UmapNormalTextures@R_dsgraph@@Udoug_lea_allocator@@@@@doug_lea_allocator@@SAXAAPAUTNode@?$FixedMAP@PAUIDirect3DStateBlock9@@UmapNormalTextures@R_dsgraph@@Udoug_lea_allocator@@@@@Z PROC ; doug_lea_allocator::dealloc<FixedMAP<IDirect3DStateBlock9 *,R_dsgraph::mapNormalTextures,doug_lea_allocator>::TNode>, COMDAT
; _p$ = ecx

; 53   : 		static	void	dealloc		(T *&p)			{	dlfree(p);	p=0;			}

	push	esi
	mov	esi, ecx
	mov	ecx, DWORD PTR [esi]
	call	_dlfree
	mov	DWORD PTR [esi], 0
	pop	esi
	ret	0
??$dealloc@UTNode@?$FixedMAP@PAUIDirect3DStateBlock9@@UmapNormalTextures@R_dsgraph@@Udoug_lea_allocator@@@@@doug_lea_allocator@@SAXAAPAUTNode@?$FixedMAP@PAUIDirect3DStateBlock9@@UmapNormalTextures@R_dsgraph@@Udoug_lea_allocator@@@@@Z ENDP ; doug_lea_allocator::dealloc<FixedMAP<IDirect3DStateBlock9 *,R_dsgraph::mapNormalTextures,doug_lea_allocator>::TNode>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
;	COMDAT ??$dealloc@UTNode@?$FixedMAP@PAVR_constant_table@@UmapNormalStates@R_dsgraph@@Udoug_lea_allocator@@@@@doug_lea_allocator@@SAXAAPAUTNode@?$FixedMAP@PAVR_constant_table@@UmapNormalStates@R_dsgraph@@Udoug_lea_allocator@@@@@Z
_TEXT	SEGMENT
??$dealloc@UTNode@?$FixedMAP@PAVR_constant_table@@UmapNormalStates@R_dsgraph@@Udoug_lea_allocator@@@@@doug_lea_allocator@@SAXAAPAUTNode@?$FixedMAP@PAVR_constant_table@@UmapNormalStates@R_dsgraph@@Udoug_lea_allocator@@@@@Z PROC ; doug_lea_allocator::dealloc<FixedMAP<R_constant_table *,R_dsgraph::mapNormalStates,doug_lea_allocator>::TNode>, COMDAT
; _p$ = ecx

; 53   : 		static	void	dealloc		(T *&p)			{	dlfree(p);	p=0;			}

	push	esi
	mov	esi, ecx
	mov	ecx, DWORD PTR [esi]
	call	_dlfree
	mov	DWORD PTR [esi], 0
	pop	esi
	ret	0
??$dealloc@UTNode@?$FixedMAP@PAVR_constant_table@@UmapNormalStates@R_dsgraph@@Udoug_lea_allocator@@@@@doug_lea_allocator@@SAXAAPAUTNode@?$FixedMAP@PAVR_constant_table@@UmapNormalStates@R_dsgraph@@Udoug_lea_allocator@@@@@Z ENDP ; doug_lea_allocator::dealloc<FixedMAP<R_constant_table *,R_dsgraph::mapNormalStates,doug_lea_allocator>::TNode>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
;	COMDAT ??$dealloc@UTNode@?$FixedMAP@PAUIDirect3DPixelShader9@@UmapNormalCS@R_dsgraph@@Udoug_lea_allocator@@@@@doug_lea_allocator@@SAXAAPAUTNode@?$FixedMAP@PAUIDirect3DPixelShader9@@UmapNormalCS@R_dsgraph@@Udoug_lea_allocator@@@@@Z
_TEXT	SEGMENT
??$dealloc@UTNode@?$FixedMAP@PAUIDirect3DPixelShader9@@UmapNormalCS@R_dsgraph@@Udoug_lea_allocator@@@@@doug_lea_allocator@@SAXAAPAUTNode@?$FixedMAP@PAUIDirect3DPixelShader9@@UmapNormalCS@R_dsgraph@@Udoug_lea_allocator@@@@@Z PROC ; doug_lea_allocator::dealloc<FixedMAP<IDirect3DPixelShader9 *,R_dsgraph::mapNormalCS,doug_lea_allocator>::TNode>, COMDAT
; _p$ = ecx

; 53   : 		static	void	dealloc		(T *&p)			{	dlfree(p);	p=0;			}

	push	esi
	mov	esi, ecx
	mov	ecx, DWORD PTR [esi]
	call	_dlfree
	mov	DWORD PTR [esi], 0
	pop	esi
	ret	0
??$dealloc@UTNode@?$FixedMAP@PAUIDirect3DPixelShader9@@UmapNormalCS@R_dsgraph@@Udoug_lea_allocator@@@@@doug_lea_allocator@@SAXAAPAUTNode@?$FixedMAP@PAUIDirect3DPixelShader9@@UmapNormalCS@R_dsgraph@@Udoug_lea_allocator@@@@@Z ENDP ; doug_lea_allocator::dealloc<FixedMAP<IDirect3DPixelShader9 *,R_dsgraph::mapNormalCS,doug_lea_allocator>::TNode>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
;	COMDAT ??$dealloc@UTNode@?$FixedMAP@PAUIDirect3DVertexShader9@@UmapNormalPS@R_dsgraph@@Udoug_lea_allocator@@@@@doug_lea_allocator@@SAXAAPAUTNode@?$FixedMAP@PAUIDirect3DVertexShader9@@UmapNormalPS@R_dsgraph@@Udoug_lea_allocator@@@@@Z
_TEXT	SEGMENT
??$dealloc@UTNode@?$FixedMAP@PAUIDirect3DVertexShader9@@UmapNormalPS@R_dsgraph@@Udoug_lea_allocator@@@@@doug_lea_allocator@@SAXAAPAUTNode@?$FixedMAP@PAUIDirect3DVertexShader9@@UmapNormalPS@R_dsgraph@@Udoug_lea_allocator@@@@@Z PROC ; doug_lea_allocator::dealloc<FixedMAP<IDirect3DVertexShader9 *,R_dsgraph::mapNormalPS,doug_lea_allocator>::TNode>, COMDAT
; _p$ = ecx

; 53   : 		static	void	dealloc		(T *&p)			{	dlfree(p);	p=0;			}

	push	esi
	mov	esi, ecx
	mov	ecx, DWORD PTR [esi]
	call	_dlfree
	mov	DWORD PTR [esi], 0
	pop	esi
	ret	0
??$dealloc@UTNode@?$FixedMAP@PAUIDirect3DVertexShader9@@UmapNormalPS@R_dsgraph@@Udoug_lea_allocator@@@@@doug_lea_allocator@@SAXAAPAUTNode@?$FixedMAP@PAUIDirect3DVertexShader9@@UmapNormalPS@R_dsgraph@@Udoug_lea_allocator@@@@@Z ENDP ; doug_lea_allocator::dealloc<FixedMAP<IDirect3DVertexShader9 *,R_dsgraph::mapNormalPS,doug_lea_allocator>::TNode>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
;	COMDAT ??$dealloc@UTNode@?$FixedMAP@PAUSTextureList@@UmapMatrixItems@R_dsgraph@@Udoug_lea_allocator@@@@@doug_lea_allocator@@SAXAAPAUTNode@?$FixedMAP@PAUSTextureList@@UmapMatrixItems@R_dsgraph@@Udoug_lea_allocator@@@@@Z
_TEXT	SEGMENT
??$dealloc@UTNode@?$FixedMAP@PAUSTextureList@@UmapMatrixItems@R_dsgraph@@Udoug_lea_allocator@@@@@doug_lea_allocator@@SAXAAPAUTNode@?$FixedMAP@PAUSTextureList@@UmapMatrixItems@R_dsgraph@@Udoug_lea_allocator@@@@@Z PROC ; doug_lea_allocator::dealloc<FixedMAP<STextureList *,R_dsgraph::mapMatrixItems,doug_lea_allocator>::TNode>, COMDAT
; _p$ = ecx

; 53   : 		static	void	dealloc		(T *&p)			{	dlfree(p);	p=0;			}

	push	esi
	mov	esi, ecx
	mov	ecx, DWORD PTR [esi]
	call	_dlfree
	mov	DWORD PTR [esi], 0
	pop	esi
	ret	0
??$dealloc@UTNode@?$FixedMAP@PAUSTextureList@@UmapMatrixItems@R_dsgraph@@Udoug_lea_allocator@@@@@doug_lea_allocator@@SAXAAPAUTNode@?$FixedMAP@PAUSTextureList@@UmapMatrixItems@R_dsgraph@@Udoug_lea_allocator@@@@@Z ENDP ; doug_lea_allocator::dealloc<FixedMAP<STextureList *,R_dsgraph::mapMatrixItems,doug_lea_allocator>::TNode>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
;	COMDAT ??$dealloc@UTNode@?$FixedMAP@PAUIDirect3DStateBlock9@@UmapMatrixTextures@R_dsgraph@@Udoug_lea_allocator@@@@@doug_lea_allocator@@SAXAAPAUTNode@?$FixedMAP@PAUIDirect3DStateBlock9@@UmapMatrixTextures@R_dsgraph@@Udoug_lea_allocator@@@@@Z
_TEXT	SEGMENT
??$dealloc@UTNode@?$FixedMAP@PAUIDirect3DStateBlock9@@UmapMatrixTextures@R_dsgraph@@Udoug_lea_allocator@@@@@doug_lea_allocator@@SAXAAPAUTNode@?$FixedMAP@PAUIDirect3DStateBlock9@@UmapMatrixTextures@R_dsgraph@@Udoug_lea_allocator@@@@@Z PROC ; doug_lea_allocator::dealloc<FixedMAP<IDirect3DStateBlock9 *,R_dsgraph::mapMatrixTextures,doug_lea_allocator>::TNode>, COMDAT
; _p$ = ecx

; 53   : 		static	void	dealloc		(T *&p)			{	dlfree(p);	p=0;			}

	push	esi
	mov	esi, ecx
	mov	ecx, DWORD PTR [esi]
	call	_dlfree
	mov	DWORD PTR [esi], 0
	pop	esi
	ret	0
??$dealloc@UTNode@?$FixedMAP@PAUIDirect3DStateBlock9@@UmapMatrixTextures@R_dsgraph@@Udoug_lea_allocator@@@@@doug_lea_allocator@@SAXAAPAUTNode@?$FixedMAP@PAUIDirect3DStateBlock9@@UmapMatrixTextures@R_dsgraph@@Udoug_lea_allocator@@@@@Z ENDP ; doug_lea_allocator::dealloc<FixedMAP<IDirect3DStateBlock9 *,R_dsgraph::mapMatrixTextures,doug_lea_allocator>::TNode>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
;	COMDAT ??$dealloc@UTNode@?$FixedMAP@PAVR_constant_table@@UmapMatrixStates@R_dsgraph@@Udoug_lea_allocator@@@@@doug_lea_allocator@@SAXAAPAUTNode@?$FixedMAP@PAVR_constant_table@@UmapMatrixStates@R_dsgraph@@Udoug_lea_allocator@@@@@Z
_TEXT	SEGMENT
??$dealloc@UTNode@?$FixedMAP@PAVR_constant_table@@UmapMatrixStates@R_dsgraph@@Udoug_lea_allocator@@@@@doug_lea_allocator@@SAXAAPAUTNode@?$FixedMAP@PAVR_constant_table@@UmapMatrixStates@R_dsgraph@@Udoug_lea_allocator@@@@@Z PROC ; doug_lea_allocator::dealloc<FixedMAP<R_constant_table *,R_dsgraph::mapMatrixStates,doug_lea_allocator>::TNode>, COMDAT
; _p$ = ecx

; 53   : 		static	void	dealloc		(T *&p)			{	dlfree(p);	p=0;			}

	push	esi
	mov	esi, ecx
	mov	ecx, DWORD PTR [esi]
	call	_dlfree
	mov	DWORD PTR [esi], 0
	pop	esi
	ret	0
??$dealloc@UTNode@?$FixedMAP@PAVR_constant_table@@UmapMatrixStates@R_dsgraph@@Udoug_lea_allocator@@@@@doug_lea_allocator@@SAXAAPAUTNode@?$FixedMAP@PAVR_constant_table@@UmapMatrixStates@R_dsgraph@@Udoug_lea_allocator@@@@@Z ENDP ; doug_lea_allocator::dealloc<FixedMAP<R_constant_table *,R_dsgraph::mapMatrixStates,doug_lea_allocator>::TNode>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
;	COMDAT ??$dealloc@UTNode@?$FixedMAP@PAUIDirect3DPixelShader9@@UmapMatrixCS@R_dsgraph@@Udoug_lea_allocator@@@@@doug_lea_allocator@@SAXAAPAUTNode@?$FixedMAP@PAUIDirect3DPixelShader9@@UmapMatrixCS@R_dsgraph@@Udoug_lea_allocator@@@@@Z
_TEXT	SEGMENT
??$dealloc@UTNode@?$FixedMAP@PAUIDirect3DPixelShader9@@UmapMatrixCS@R_dsgraph@@Udoug_lea_allocator@@@@@doug_lea_allocator@@SAXAAPAUTNode@?$FixedMAP@PAUIDirect3DPixelShader9@@UmapMatrixCS@R_dsgraph@@Udoug_lea_allocator@@@@@Z PROC ; doug_lea_allocator::dealloc<FixedMAP<IDirect3DPixelShader9 *,R_dsgraph::mapMatrixCS,doug_lea_allocator>::TNode>, COMDAT
; _p$ = ecx

; 53   : 		static	void	dealloc		(T *&p)			{	dlfree(p);	p=0;			}

	push	esi
	mov	esi, ecx
	mov	ecx, DWORD PTR [esi]
	call	_dlfree
	mov	DWORD PTR [esi], 0
	pop	esi
	ret	0
??$dealloc@UTNode@?$FixedMAP@PAUIDirect3DPixelShader9@@UmapMatrixCS@R_dsgraph@@Udoug_lea_allocator@@@@@doug_lea_allocator@@SAXAAPAUTNode@?$FixedMAP@PAUIDirect3DPixelShader9@@UmapMatrixCS@R_dsgraph@@Udoug_lea_allocator@@@@@Z ENDP ; doug_lea_allocator::dealloc<FixedMAP<IDirect3DPixelShader9 *,R_dsgraph::mapMatrixCS,doug_lea_allocator>::TNode>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
;	COMDAT ??$dealloc@UTNode@?$FixedMAP@PAUIDirect3DVertexShader9@@UmapMatrixPS@R_dsgraph@@Udoug_lea_allocator@@@@@doug_lea_allocator@@SAXAAPAUTNode@?$FixedMAP@PAUIDirect3DVertexShader9@@UmapMatrixPS@R_dsgraph@@Udoug_lea_allocator@@@@@Z
_TEXT	SEGMENT
??$dealloc@UTNode@?$FixedMAP@PAUIDirect3DVertexShader9@@UmapMatrixPS@R_dsgraph@@Udoug_lea_allocator@@@@@doug_lea_allocator@@SAXAAPAUTNode@?$FixedMAP@PAUIDirect3DVertexShader9@@UmapMatrixPS@R_dsgraph@@Udoug_lea_allocator@@@@@Z PROC ; doug_lea_allocator::dealloc<FixedMAP<IDirect3DVertexShader9 *,R_dsgraph::mapMatrixPS,doug_lea_allocator>::TNode>, COMDAT
; _p$ = ecx

; 53   : 		static	void	dealloc		(T *&p)			{	dlfree(p);	p=0;			}

	push	esi
	mov	esi, ecx
	mov	ecx, DWORD PTR [esi]
	call	_dlfree
	mov	DWORD PTR [esi], 0
	pop	esi
	ret	0
??$dealloc@UTNode@?$FixedMAP@PAUIDirect3DVertexShader9@@UmapMatrixPS@R_dsgraph@@Udoug_lea_allocator@@@@@doug_lea_allocator@@SAXAAPAUTNode@?$FixedMAP@PAUIDirect3DVertexShader9@@UmapMatrixPS@R_dsgraph@@Udoug_lea_allocator@@@@@Z ENDP ; doug_lea_allocator::dealloc<FixedMAP<IDirect3DVertexShader9 *,R_dsgraph::mapMatrixPS,doug_lea_allocator>::TNode>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
;	COMDAT ??$dealloc@UTNode@?$FixedMAP@MU_MatrixItemS@R_dsgraph@@Udoug_lea_allocator@@@@@doug_lea_allocator@@SAXAAPAUTNode@?$FixedMAP@MU_MatrixItemS@R_dsgraph@@Udoug_lea_allocator@@@@@Z
_TEXT	SEGMENT
??$dealloc@UTNode@?$FixedMAP@MU_MatrixItemS@R_dsgraph@@Udoug_lea_allocator@@@@@doug_lea_allocator@@SAXAAPAUTNode@?$FixedMAP@MU_MatrixItemS@R_dsgraph@@Udoug_lea_allocator@@@@@Z PROC ; doug_lea_allocator::dealloc<FixedMAP<float,R_dsgraph::_MatrixItemS,doug_lea_allocator>::TNode>, COMDAT
; _p$ = ecx

; 53   : 		static	void	dealloc		(T *&p)			{	dlfree(p);	p=0;			}

	push	esi
	mov	esi, ecx
	mov	ecx, DWORD PTR [esi]
	call	_dlfree
	mov	DWORD PTR [esi], 0
	pop	esi
	ret	0
??$dealloc@UTNode@?$FixedMAP@MU_MatrixItemS@R_dsgraph@@Udoug_lea_allocator@@@@@doug_lea_allocator@@SAXAAPAUTNode@?$FixedMAP@MU_MatrixItemS@R_dsgraph@@Udoug_lea_allocator@@@@@Z ENDP ; doug_lea_allocator::dealloc<FixedMAP<float,R_dsgraph::_MatrixItemS,doug_lea_allocator>::TNode>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
;	COMDAT ??$dealloc@UTNode@?$FixedMAP@MU_LodItem@R_dsgraph@@Udoug_lea_allocator@@@@@doug_lea_allocator@@SAXAAPAUTNode@?$FixedMAP@MU_LodItem@R_dsgraph@@Udoug_lea_allocator@@@@@Z
_TEXT	SEGMENT
??$dealloc@UTNode@?$FixedMAP@MU_LodItem@R_dsgraph@@Udoug_lea_allocator@@@@@doug_lea_allocator@@SAXAAPAUTNode@?$FixedMAP@MU_LodItem@R_dsgraph@@Udoug_lea_allocator@@@@@Z PROC ; doug_lea_allocator::dealloc<FixedMAP<float,R_dsgraph::_LodItem,doug_lea_allocator>::TNode>, COMDAT
; _p$ = ecx

; 53   : 		static	void	dealloc		(T *&p)			{	dlfree(p);	p=0;			}

	push	esi
	mov	esi, ecx
	mov	ecx, DWORD PTR [esi]
	call	_dlfree
	mov	DWORD PTR [esi], 0
	pop	esi
	ret	0
??$dealloc@UTNode@?$FixedMAP@MU_LodItem@R_dsgraph@@Udoug_lea_allocator@@@@@doug_lea_allocator@@SAXAAPAUTNode@?$FixedMAP@MU_LodItem@R_dsgraph@@Udoug_lea_allocator@@@@@Z ENDP ; doug_lea_allocator::dealloc<FixedMAP<float,R_dsgraph::_LodItem,doug_lea_allocator>::TNode>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
;	COMDAT ?alloc@doug_lea_allocator@@SAPAXABI@Z
_TEXT	SEGMENT
?alloc@doug_lea_allocator@@SAPAXABI@Z PROC		; doug_lea_allocator::alloc, COMDAT
; _n$ = ecx

; 51   : 		static	void	*alloc		(const u32 &n)	{	return dlmalloc((u32)n);	}

	mov	ecx, DWORD PTR [ecx]
	jmp	_dlmalloc
?alloc@doug_lea_allocator@@SAPAXABI@Z ENDP		; doug_lea_allocator::alloc
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$doug_lea_alloc@U_NormalItem@R_dsgraph@@@@V?$_Vector_val@U?$_Simple_types@U_NormalItem@R_dsgraph@@@std@@@std@@$00@std@@QAEAAV?$doug_lea_alloc@U_NormalItem@R_dsgraph@@@@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@V?$doug_lea_alloc@U_NormalItem@R_dsgraph@@@@V?$_Vector_val@U?$_Simple_types@U_NormalItem@R_dsgraph@@@std@@@std@@$00@std@@QAEAAV?$doug_lea_alloc@U_NormalItem@R_dsgraph@@@@XZ PROC ; std::_Compressed_pair<doug_lea_alloc<R_dsgraph::_NormalItem>,std::_Vector_val<std::_Simple_types<R_dsgraph::_NormalItem> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 1339 :         return *this;

	mov	eax, ecx

; 1340 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$doug_lea_alloc@U_NormalItem@R_dsgraph@@@@V?$_Vector_val@U?$_Simple_types@U_NormalItem@R_dsgraph@@@std@@@std@@$00@std@@QAEAAV?$doug_lea_alloc@U_NormalItem@R_dsgraph@@@@XZ ENDP ; std::_Compressed_pair<doug_lea_alloc<R_dsgraph::_NormalItem>,std::_Vector_val<std::_Simple_types<R_dsgraph::_NormalItem> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Getal@?$vector@U_NormalItem@R_dsgraph@@V?$doug_lea_alloc@U_NormalItem@R_dsgraph@@@@@std@@AAEAAV?$doug_lea_alloc@U_NormalItem@R_dsgraph@@@@XZ
_TEXT	SEGMENT
?_Getal@?$vector@U_NormalItem@R_dsgraph@@V?$doug_lea_alloc@U_NormalItem@R_dsgraph@@@@@std@@AAEAAV?$doug_lea_alloc@U_NormalItem@R_dsgraph@@@@XZ PROC ; std::vector<R_dsgraph::_NormalItem,doug_lea_alloc<R_dsgraph::_NormalItem> >::_Getal, COMDAT
; _this$ = ecx

; 1805 :         return _Mypair._Get_first();

	mov	eax, ecx

; 1806 :     }

	ret	0
?_Getal@?$vector@U_NormalItem@R_dsgraph@@V?$doug_lea_alloc@U_NormalItem@R_dsgraph@@@@@std@@AAEAAV?$doug_lea_alloc@U_NormalItem@R_dsgraph@@@@XZ ENDP ; std::vector<R_dsgraph::_NormalItem,doug_lea_alloc<R_dsgraph::_NormalItem> >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef
;	COMDAT ??$_Unfancy@U_NormalItem@R_dsgraph@@@std@@YAPAU_NormalItem@R_dsgraph@@PAU12@@Z
_TEXT	SEGMENT
??$_Unfancy@U_NormalItem@R_dsgraph@@@std@@YAPAU_NormalItem@R_dsgraph@@PAU12@@Z PROC ; std::_Unfancy<R_dsgraph::_NormalItem>, COMDAT
; __Ptr$ = ecx

; 266  :     return _Ptr;

	mov	eax, ecx

; 267  : }

	ret	0
??$_Unfancy@U_NormalItem@R_dsgraph@@@std@@YAPAU_NormalItem@R_dsgraph@@PAU12@@Z ENDP ; std::_Unfancy<R_dsgraph::_NormalItem>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$doug_lea_alloc@U_MatrixItem@R_dsgraph@@@@V?$_Vector_val@U?$_Simple_types@U_MatrixItem@R_dsgraph@@@std@@@std@@$00@std@@QAEAAV?$doug_lea_alloc@U_MatrixItem@R_dsgraph@@@@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@V?$doug_lea_alloc@U_MatrixItem@R_dsgraph@@@@V?$_Vector_val@U?$_Simple_types@U_MatrixItem@R_dsgraph@@@std@@@std@@$00@std@@QAEAAV?$doug_lea_alloc@U_MatrixItem@R_dsgraph@@@@XZ PROC ; std::_Compressed_pair<doug_lea_alloc<R_dsgraph::_MatrixItem>,std::_Vector_val<std::_Simple_types<R_dsgraph::_MatrixItem> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 1339 :         return *this;

	mov	eax, ecx

; 1340 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$doug_lea_alloc@U_MatrixItem@R_dsgraph@@@@V?$_Vector_val@U?$_Simple_types@U_MatrixItem@R_dsgraph@@@std@@@std@@$00@std@@QAEAAV?$doug_lea_alloc@U_MatrixItem@R_dsgraph@@@@XZ ENDP ; std::_Compressed_pair<doug_lea_alloc<R_dsgraph::_MatrixItem>,std::_Vector_val<std::_Simple_types<R_dsgraph::_MatrixItem> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Getal@?$vector@U_MatrixItem@R_dsgraph@@V?$doug_lea_alloc@U_MatrixItem@R_dsgraph@@@@@std@@AAEAAV?$doug_lea_alloc@U_MatrixItem@R_dsgraph@@@@XZ
_TEXT	SEGMENT
?_Getal@?$vector@U_MatrixItem@R_dsgraph@@V?$doug_lea_alloc@U_MatrixItem@R_dsgraph@@@@@std@@AAEAAV?$doug_lea_alloc@U_MatrixItem@R_dsgraph@@@@XZ PROC ; std::vector<R_dsgraph::_MatrixItem,doug_lea_alloc<R_dsgraph::_MatrixItem> >::_Getal, COMDAT
; _this$ = ecx

; 1805 :         return _Mypair._Get_first();

	mov	eax, ecx

; 1806 :     }

	ret	0
?_Getal@?$vector@U_MatrixItem@R_dsgraph@@V?$doug_lea_alloc@U_MatrixItem@R_dsgraph@@@@@std@@AAEAAV?$doug_lea_alloc@U_MatrixItem@R_dsgraph@@@@XZ ENDP ; std::vector<R_dsgraph::_MatrixItem,doug_lea_alloc<R_dsgraph::_MatrixItem> >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef
;	COMDAT ??$_Unfancy@U_MatrixItem@R_dsgraph@@@std@@YAPAU_MatrixItem@R_dsgraph@@PAU12@@Z
_TEXT	SEGMENT
??$_Unfancy@U_MatrixItem@R_dsgraph@@@std@@YAPAU_MatrixItem@R_dsgraph@@PAU12@@Z PROC ; std::_Unfancy<R_dsgraph::_MatrixItem>, COMDAT
; __Ptr$ = ecx

; 266  :     return _Ptr;

	mov	eax, ecx

; 267  : }

	ret	0
??$_Unfancy@U_MatrixItem@R_dsgraph@@@std@@YAPAU_MatrixItem@R_dsgraph@@PAU12@@Z ENDP ; std::_Unfancy<R_dsgraph::_MatrixItem>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
;	COMDAT ??C?$resptr_core@USState@@V?$resptr_base@USState@@@@@@QBEPAUSState@@XZ
_TEXT	SEGMENT
??C?$resptr_core@USState@@V?$resptr_base@USState@@@@@@QBEPAUSState@@XZ PROC ; resptr_core<SState,resptr_base<SState> >::operator->, COMDAT
; _this$ = ecx

; 71   : 	T *					operator->() const												{	return p_;	}

	mov	eax, DWORD PTR [ecx]
	ret	0
??C?$resptr_core@USState@@V?$resptr_base@USState@@@@@@QBEPAUSState@@XZ ENDP ; resptr_core<SState,resptr_base<SState> >::operator->
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
;	COMDAT ??C?$resptr_core@USPS@@V?$resptr_base@USPS@@@@@@QBEPAUSPS@@XZ
_TEXT	SEGMENT
??C?$resptr_core@USPS@@V?$resptr_base@USPS@@@@@@QBEPAUSPS@@XZ PROC ; resptr_core<SPS,resptr_base<SPS> >::operator->, COMDAT
; _this$ = ecx

; 71   : 	T *					operator->() const												{	return p_;	}

	mov	eax, DWORD PTR [ecx]
	ret	0
??C?$resptr_core@USPS@@V?$resptr_base@USPS@@@@@@QBEPAUSPS@@XZ ENDP ; resptr_core<SPS,resptr_base<SPS> >::operator->
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
;	COMDAT ??C?$resptr_core@USVS@@V?$resptr_base@USVS@@@@@@QBEPAUSVS@@XZ
_TEXT	SEGMENT
??C?$resptr_core@USVS@@V?$resptr_base@USVS@@@@@@QBEPAUSVS@@XZ PROC ; resptr_core<SVS,resptr_base<SVS> >::operator->, COMDAT
; _this$ = ecx

; 71   : 	T *					operator->() const												{	return p_;	}

	mov	eax, DWORD PTR [ecx]
	ret	0
??C?$resptr_core@USVS@@V?$resptr_base@USVS@@@@@@QBEPAUSVS@@XZ ENDP ; resptr_core<SVS,resptr_base<SVS> >::operator->
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
;	COMDAT ??D?$resptr_core@USPass@@V?$resptr_base@USPass@@@@@@QBEAAUSPass@@XZ
_TEXT	SEGMENT
??D?$resptr_core@USPass@@V?$resptr_base@USPass@@@@@@QBEAAUSPass@@XZ PROC ; resptr_core<SPass,resptr_base<SPass> >::operator*, COMDAT
; _this$ = ecx

; 70   : 	T &					operator*() const												{	return *p_;	}

	mov	eax, DWORD PTR [ecx]
	ret	0
??D?$resptr_core@USPass@@V?$resptr_base@USPass@@@@@@QBEAAUSPass@@XZ ENDP ; resptr_core<SPass,resptr_base<SPass> >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
;	COMDAT ??D?$resptr_core@UShaderElement@@V?$resptr_base@UShaderElement@@@@@@QBEAAUShaderElement@@XZ
_TEXT	SEGMENT
??D?$resptr_core@UShaderElement@@V?$resptr_base@UShaderElement@@@@@@QBEAAUShaderElement@@XZ PROC ; resptr_core<ShaderElement,resptr_base<ShaderElement> >::operator*, COMDAT
; _this$ = ecx

; 70   : 	T &					operator*() const												{	return *p_;	}

	mov	eax, DWORD PTR [ecx]
	ret	0
??D?$resptr_core@UShaderElement@@V?$resptr_base@UShaderElement@@@@@@QBEAAUShaderElement@@XZ ENDP ; resptr_core<ShaderElement,resptr_base<ShaderElement> >::operator*
_TEXT	ENDS
END
