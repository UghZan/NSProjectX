; Listing generated by Microsoft (R) Optimizing Compiler Version 19.29.30146.0 

	TITLE	i:\vitalya\mine\nsprojectx\nspx_build\intermediate\release-win32\xrrender_r1\lighttrack.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	??_R2CROS_impl@@8				; CROS_impl::`RTTI Base Class Array'
PUBLIC	??_R2IRender_ObjectSpecific@@8			; IRender_ObjectSpecific::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CROS_impl@@8			; CROS_impl::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@IRender_ObjectSpecific@@8		; IRender_ObjectSpecific::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R3IRender_ObjectSpecific@@8			; IRender_ObjectSpecific::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R0?AVIRender_ObjectSpecific@@@8		; IRender_ObjectSpecific `RTTI Type Descriptor'
PUBLIC	??_R3CROS_impl@@8				; CROS_impl::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R0?AVCROS_impl@@@8				; CROS_impl `RTTI Type Descriptor'
PUBLIC	??_R4CROS_impl@@6B@				; CROS_impl::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVIRenderable@@@8				; IRenderable `RTTI Type Descriptor'
PUBLIC	??_R0?AVCObject@@@8				; CObject `RTTI Type Descriptor'
PUBLIC	??_7CROS_impl@@6B@				; CROS_impl::`vftable'
EXTRN	__imp_??0IRender_ObjectSpecific@@QAE@XZ:PROC
EXTRN	__imp_?_get@?$resptr_base@VIRender_Light@@@@QBEPAVIRender_Light@@XZ:PROC
EXTRN	__imp_?q_box@ISpatial_DB@@QAEXAAV?$xr_vector@PAVISpatial@@V?$xalloc@PAVISpatial@@@@@@IIABU?$_vector3@M@@1@Z:PROC
EXTRN	__imp_?RayTest@CObjectSpace@@QAEHABU?$_vector3@M@@0MW4rq_target@collide@@PAUray_cache@4@PAVCObject@@@Z:PROC
EXTRN	__imp_??_7IRender_ObjectSpecific@@6B@:BYTE
EXTRN	__imp_??1IRender_ObjectSpecific@@UAE@XZ:PROC
;	COMDAT ??_7CROS_impl@@6B@
CONST	SEGMENT
??_7CROS_impl@@6B@ DD FLAT:??_R4CROS_impl@@6B@		; CROS_impl::`vftable'
	DD	FLAT:?force_mode@CROS_impl@@UAEXI@Z
	DD	FLAT:?get_luminocity@CROS_impl@@UAEMXZ
	DD	FLAT:?get_luminocity_hemi@CROS_impl@@UAEMXZ
	DD	FLAT:??_ECROS_impl@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_R0?AVCObject@@@8
data$r	SEGMENT
??_R0?AVCObject@@@8 DD FLAT:??_7type_info@@6B@		; CObject `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCObject@@', 00H
data$r	ENDS
;	COMDAT ??_R0?AVIRenderable@@@8
data$r	SEGMENT
??_R0?AVIRenderable@@@8 DD FLAT:??_7type_info@@6B@	; IRenderable `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVIRenderable@@', 00H
data$r	ENDS
;	COMDAT ??_R4CROS_impl@@6B@
rdata$r	SEGMENT
??_R4CROS_impl@@6B@ DD 00H				; CROS_impl::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCROS_impl@@@8
	DD	FLAT:??_R3CROS_impl@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCROS_impl@@@8
data$rs	SEGMENT
??_R0?AVCROS_impl@@@8 DD FLAT:??_7type_info@@6B@	; CROS_impl `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCROS_impl@@', 00H
data$rs	ENDS
;	COMDAT ??_R3CROS_impl@@8
rdata$r	SEGMENT
??_R3CROS_impl@@8 DD 00H				; CROS_impl::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2CROS_impl@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVIRender_ObjectSpecific@@@8
data$rs	SEGMENT
??_R0?AVIRender_ObjectSpecific@@@8 DD FLAT:??_7type_info@@6B@ ; IRender_ObjectSpecific `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVIRender_ObjectSpecific@@', 00H
data$rs	ENDS
;	COMDAT ??_R3IRender_ObjectSpecific@@8
rdata$r	SEGMENT
??_R3IRender_ObjectSpecific@@8 DD 00H			; IRender_ObjectSpecific::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2IRender_ObjectSpecific@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@IRender_ObjectSpecific@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@IRender_ObjectSpecific@@8 DD FLAT:??_R0?AVIRender_ObjectSpecific@@@8 ; IRender_ObjectSpecific::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3IRender_ObjectSpecific@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@CROS_impl@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CROS_impl@@8 DD FLAT:??_R0?AVCROS_impl@@@8 ; CROS_impl::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CROS_impl@@8
rdata$r	ENDS
;	COMDAT ??_R2IRender_ObjectSpecific@@8
rdata$r	SEGMENT
??_R2IRender_ObjectSpecific@@8 DD FLAT:??_R1A@?0A@EA@IRender_ObjectSpecific@@8 ; IRender_ObjectSpecific::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R2CROS_impl@@8
rdata$r	SEGMENT
??_R2CROS_impl@@8 DD FLAT:??_R1A@?0A@EA@CROS_impl@@8	; CROS_impl::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@IRender_ObjectSpecific@@8
?_Fake_alloc@std@@3U_Fake_allocator@1@B	ORG $+1		; std::_Fake_alloc
?hdir@@3QAY02$$CBMA DD 000000000r		; 0	; hdir
	DD	03f800000r			; 1
	DD	000000000r			; 0
	DD	03f06963er			; 0.52573
	DD	03f59c433r			; 0.85065
	DD	000000000r			; 0
	DD	03e265bear			; 0.16246
	DD	03f59c433r			; 0.85065
	DD	03f000000r			; 0.5
	DD	0bed9c4dbr			; -0.42533
	DD	03f59c433r			; 0.85065
	DD	03e9e37dfr			; 0.30902
	DD	0bed9c4dbr			; -0.42533
	DD	03f59c433r			; 0.85065
	DD	0be9e37dfr			; -0.30902
	DD	03e265bear			; 0.16246
	DD	03f59c433r			; 0.85065
	DD	0bf000000r			; -0.5
	DD	03f64f95dr			; 0.89443
	DD	03ee4f8b6r			; 0.44721
	DD	000000000r			; 0
	DD	03e8d82fdr			; 0.27639
	DD	03ee4f8b6r			; 0.44721
	DD	03f59c433r			; 0.85065
	DD	0bf393e81r			; -0.72361
	DD	03ee4f8b6r			; 0.44721
	DD	03f06963er			; 0.52573
	DD	0bf393e81r			; -0.72361
	DD	03ee4f8b6r			; 0.44721
	DD	0bf06963er			; -0.52573
	DD	03e8d82fdr			; 0.27639
	DD	03ee4f8b6r			; 0.44721
	DD	0bf59c433r			; -0.85065
	DD	03f302d38r			; 0.68819
	DD	03f06963er			; 0.52573
	DD	03f000000r			; 0.5
	DD	0be8696e6r			; -0.26287
	DD	03f06963er			; 0.52573
	DD	03f4f1befr			; 0.80902
	DD	0bf59c433r			; -0.85065
	DD	03f06963er			; 0.52573
	DD	080000000r			; -0
	DD	0be8696e6r			; -0.26287
	DD	03f06963er			; 0.52573
	DD	0bf4f1befr			; -0.80902
	DD	03f302d38r			; 0.68819
	DD	03f06963er			; 0.52573
	DD	0bf000000r			; -0.5
	DD	03f7378abr			; 0.95106
	DD	000000000r			; 0
	DD	03e9e37dfr			; 0.30902
	DD	03f167968r			; 0.58779
	DD	000000000r			; 0
	DD	03f4f1befr			; 0.80902
	DD	080000000r			; -0
	DD	000000000r			; 0
	DD	03f800000r			; 1
	DD	0bf167968r			; -0.58779
	DD	000000000r			; 0
	DD	03f4f1befr			; 0.80902
	DD	0bf7378abr			; -0.95106
	DD	000000000r			; 0
	DD	03e9e37dfr			; 0.30902
	DD	0bf7378abr			; -0.95106
	DD	000000000r			; 0
	DD	0be9e37dfr			; -0.30902
	DD	0bf167968r			; -0.58779
	DD	000000000r			; 0
	DD	0bf4f1befr			; -0.80902
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	0bf800000r			; -1
	DD	03f167968r			; 0.58779
	DD	000000000r			; 0
	DD	0bf4f1befr			; -0.80902
	DD	03f7378abr			; 0.95106
	DD	000000000r			; 0
	DD	0be9e37dfr			; -0.30902
PUBLIC	??0ray_cache@collide@@QAE@XZ			; collide::ray_cache::ray_cache
PUBLIC	??$forward@AAPAULight@CROS_impl@@@std@@YAAAPAULight@CROS_impl@@AAPAU12@@Z ; std::forward<CROS_impl::Light * &>
PUBLIC	??$swap@ULight@CROS_impl@@$0A@@std@@YAXAAULight@CROS_impl@@0@Z ; std::swap<CROS_impl::Light,0>
PUBLIC	??$_Med3_unchecked@PAULight@CROS_impl@@P6A_NABU12@0@Z@std@@YAXPAULight@CROS_impl@@00P6A_NABU12@1@Z@Z ; std::_Med3_unchecked<CROS_impl::Light *,bool (__cdecl*)(CROS_impl::Light const &,CROS_impl::Light const &)>
PUBLIC	??$_Pop_heap_hole_unchecked@PAULight@CROS_impl@@U12@P6A_NABU12@0@Z@std@@YAXPAULight@CROS_impl@@00$$QAU12@P6A_NABU12@2@Z@Z ; std::_Pop_heap_hole_unchecked<CROS_impl::Light *,CROS_impl::Light,bool (__cdecl*)(CROS_impl::Light const &,CROS_impl::Light const &)>
PUBLIC	??$_Push_heap_by_index@PAULight@CROS_impl@@U12@P6A_NABU12@0@Z@std@@YAXPAULight@CROS_impl@@HH$$QAU12@P6A_NABU12@2@Z@Z ; std::_Push_heap_by_index<CROS_impl::Light *,CROS_impl::Light,bool (__cdecl*)(CROS_impl::Light const &,CROS_impl::Light const &)>
PUBLIC	??$_To_address@PAULight@CROS_impl@@@std@@YA?A_PABQAULight@CROS_impl@@@Z ; std::_To_address<CROS_impl::Light *>
PUBLIC	??$_Copy_backward_memmove@PAULight@CROS_impl@@PAU12@@std@@YAPAULight@CROS_impl@@PAU12@00@Z ; std::_Copy_backward_memmove<CROS_impl::Light *,CROS_impl::Light *>
PUBLIC	??$?0AAPAULight@CROS_impl@@AAPAU01@$0A@@?$pair@PAULight@CROS_impl@@PAU12@@std@@QAE@AAPAULight@CROS_impl@@0@Z ; std::pair<CROS_impl::Light *,CROS_impl::Light *>::pair<CROS_impl::Light *,CROS_impl::Light *><CROS_impl::Light * &,CROS_impl::Light * &,0>
PUBLIC	??$iter_swap@PAULight@CROS_impl@@PAU12@@std@@YAXPAULight@CROS_impl@@0@Z ; std::iter_swap<CROS_impl::Light *,CROS_impl::Light *>
PUBLIC	??$_Next_iter@PAULight@CROS_impl@@@std@@YAPAULight@CROS_impl@@PAU12@@Z ; std::_Next_iter<CROS_impl::Light *>
PUBLIC	??$_Guess_median_unchecked@PAULight@CROS_impl@@P6A_NABU12@0@Z@std@@YAXPAULight@CROS_impl@@00P6A_NABU12@1@Z@Z ; std::_Guess_median_unchecked<CROS_impl::Light *,bool (__cdecl*)(CROS_impl::Light const &,CROS_impl::Light const &)>
PUBLIC	??$_Prev_iter@PAULight@CROS_impl@@@std@@YAPAULight@CROS_impl@@PAU12@@Z ; std::_Prev_iter<CROS_impl::Light *>
PUBLIC	??$_Pop_heap_unchecked@PAULight@CROS_impl@@P6A_NABU12@0@Z@std@@YAXPAULight@CROS_impl@@0P6A_NABU12@1@Z@Z ; std::_Pop_heap_unchecked<CROS_impl::Light *,bool (__cdecl*)(CROS_impl::Light const &,CROS_impl::Light const &)>
PUBLIC	??$_Pop_heap_hole_by_index@PAULight@CROS_impl@@U12@P6A_NABU12@0@Z@std@@YAXPAULight@CROS_impl@@HH$$QAU12@P6A_NABU12@2@Z@Z ; std::_Pop_heap_hole_by_index<CROS_impl::Light *,CROS_impl::Light,bool (__cdecl*)(CROS_impl::Light const &,CROS_impl::Light const &)>
PUBLIC	??$_Move_backward_unchecked@PAULight@CROS_impl@@PAU12@@std@@YAPAULight@CROS_impl@@PAU12@00@Z ; std::_Move_backward_unchecked<CROS_impl::Light *,CROS_impl::Light *>
PUBLIC	??$_Destroy_in_place@PAULight@CROS_impl@@@std@@YAXAAPAULight@CROS_impl@@@Z ; std::_Destroy_in_place<CROS_impl::Light *>
PUBLIC	??$_Emplace_back@UItem@CROS_impl@@@?$_Uninitialized_backout_al@V?$xalloc@UItem@CROS_impl@@@@@std@@QAEX$$QAUItem@CROS_impl@@@Z ; std::_Uninitialized_backout_al<xalloc<CROS_impl::Item> >::_Emplace_back<CROS_impl::Item>
PUBLIC	??$_Emplace_back@ULight@CROS_impl@@@?$_Uninitialized_backout_al@V?$xalloc@ULight@CROS_impl@@@@@std@@QAEX$$QAULight@CROS_impl@@@Z ; std::_Uninitialized_backout_al<xalloc<CROS_impl::Light> >::_Emplace_back<CROS_impl::Light>
PUBLIC	??$_Partition_by_median_guess_unchecked@PAULight@CROS_impl@@P6A_NABU12@0@Z@std@@YA?AU?$pair@PAULight@CROS_impl@@PAU12@@0@PAULight@CROS_impl@@0P6A_NABU23@1@Z@Z ; std::_Partition_by_median_guess_unchecked<CROS_impl::Light *,bool (__cdecl*)(CROS_impl::Light const &,CROS_impl::Light const &)>
PUBLIC	??$_Sort_heap_unchecked@PAULight@CROS_impl@@P6A_NABU12@0@Z@std@@YAXPAULight@CROS_impl@@0P6A_NABU12@1@Z@Z ; std::_Sort_heap_unchecked<CROS_impl::Light *,bool (__cdecl*)(CROS_impl::Light const &,CROS_impl::Light const &)>
PUBLIC	??$_Make_heap_unchecked@PAULight@CROS_impl@@P6A_NABU12@0@Z@std@@YAXPAULight@CROS_impl@@0P6A_NABU12@1@Z@Z ; std::_Make_heap_unchecked<CROS_impl::Light *,bool (__cdecl*)(CROS_impl::Light const &,CROS_impl::Light const &)>
PUBLIC	??$_Insertion_sort_unchecked@PAULight@CROS_impl@@P6A_NABU12@0@Z@std@@YAPAULight@CROS_impl@@QAU12@0P6A_NABU12@1@Z@Z ; std::_Insertion_sort_unchecked<CROS_impl::Light *,bool (__cdecl*)(CROS_impl::Light const &,CROS_impl::Light const &)>
PUBLIC	?destroy@?$xalloc@ULight@CROS_impl@@@@QAEXPAULight@CROS_impl@@@Z ; xalloc<CROS_impl::Light>::destroy
PUBLIC	??0?$_Uninitialized_backout_al@V?$xalloc@ULight@CROS_impl@@@@@std@@QAE@PAULight@CROS_impl@@AAV?$xalloc@ULight@CROS_impl@@@@@Z ; std::_Uninitialized_backout_al<xalloc<CROS_impl::Light> >::_Uninitialized_backout_al<xalloc<CROS_impl::Light> >
PUBLIC	??1?$_Uninitialized_backout_al@V?$xalloc@ULight@CROS_impl@@@@@std@@QAE@XZ ; std::_Uninitialized_backout_al<xalloc<CROS_impl::Light> >::~_Uninitialized_backout_al<xalloc<CROS_impl::Light> >
PUBLIC	?_Release@?$_Uninitialized_backout_al@V?$xalloc@ULight@CROS_impl@@@@@std@@QAEPAULight@CROS_impl@@XZ ; std::_Uninitialized_backout_al<xalloc<CROS_impl::Light> >::_Release
PUBLIC	??0?$_Uninitialized_backout_al@V?$xalloc@UItem@CROS_impl@@@@@std@@QAE@PAUItem@CROS_impl@@AAV?$xalloc@UItem@CROS_impl@@@@@Z ; std::_Uninitialized_backout_al<xalloc<CROS_impl::Item> >::_Uninitialized_backout_al<xalloc<CROS_impl::Item> >
PUBLIC	??1?$_Uninitialized_backout_al@V?$xalloc@UItem@CROS_impl@@@@@std@@QAE@XZ ; std::_Uninitialized_backout_al<xalloc<CROS_impl::Item> >::~_Uninitialized_backout_al<xalloc<CROS_impl::Item> >
PUBLIC	?_Release@?$_Uninitialized_backout_al@V?$xalloc@UItem@CROS_impl@@@@@std@@QAEPAUItem@CROS_impl@@XZ ; std::_Uninitialized_backout_al<xalloc<CROS_impl::Item> >::_Release
PUBLIC	??$xr_alloc@UItem@CROS_impl@@@@YAPAUItem@CROS_impl@@I@Z ; xr_alloc<CROS_impl::Item>
PUBLIC	??$_Destroy_in_place@PAUItem@CROS_impl@@@std@@YAXAAPAUItem@CROS_impl@@@Z ; std::_Destroy_in_place<CROS_impl::Item *>
PUBLIC	??$_Get_unwrapped@ABQAUItem@CROS_impl@@@std@@YA?A_TABQAUItem@CROS_impl@@@Z ; std::_Get_unwrapped<CROS_impl::Item * const &>
PUBLIC	??$_Uninitialized_move@PAUItem@CROS_impl@@V?$xalloc@UItem@CROS_impl@@@@@std@@YAPAUItem@CROS_impl@@QAU12@0PAU12@AAV?$xalloc@UItem@CROS_impl@@@@@Z ; std::_Uninitialized_move<CROS_impl::Item *,xalloc<CROS_impl::Item> >
PUBLIC	??$xr_alloc@ULight@CROS_impl@@@@YAPAULight@CROS_impl@@I@Z ; xr_alloc<CROS_impl::Light>
PUBLIC	??$_Get_unwrapped@ABQAULight@CROS_impl@@@std@@YA?A_TABQAULight@CROS_impl@@@Z ; std::_Get_unwrapped<CROS_impl::Light * const &>
PUBLIC	??$_Uninitialized_move@PAULight@CROS_impl@@V?$xalloc@ULight@CROS_impl@@@@@std@@YAPAULight@CROS_impl@@QAU12@0PAU12@AAV?$xalloc@ULight@CROS_impl@@@@@Z ; std::_Uninitialized_move<CROS_impl::Light *,xalloc<CROS_impl::Light> >
PUBLIC	??$destroy@ULight@CROS_impl@@@?$_Normal_allocator_traits@V?$xalloc@ULight@CROS_impl@@@@@std@@SAXAAV?$xalloc@ULight@CROS_impl@@@@PAULight@CROS_impl@@@Z ; std::_Normal_allocator_traits<xalloc<CROS_impl::Light> >::destroy<CROS_impl::Light>
PUBLIC	??$_To_address@PAUItem@CROS_impl@@@std@@YA?A_PABQAUItem@CROS_impl@@@Z ; std::_To_address<CROS_impl::Item *>
PUBLIC	??$_Copy_memmove@PAUItem@CROS_impl@@PAU12@@std@@YAPAUItem@CROS_impl@@PAU12@00@Z ; std::_Copy_memmove<CROS_impl::Item *,CROS_impl::Item *>
PUBLIC	??$_Sort_unchecked@PAULight@CROS_impl@@P6A_NABU12@0@Z@std@@YAXPAULight@CROS_impl@@0HP6A_NABU12@1@Z@Z ; std::_Sort_unchecked<CROS_impl::Light *,bool (__cdecl*)(CROS_impl::Light const &,CROS_impl::Light const &)>
PUBLIC	??$_Pass_fn@P6A_NABULight@CROS_impl@@0@Z$0A@@std@@YAP6A_NABULight@CROS_impl@@0@ZP6A_N00@Z@Z ; std::_Pass_fn<bool (__cdecl*)(CROS_impl::Light const &,CROS_impl::Light const &),0>
PUBLIC	??$_Adl_verify_range@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@ULight@CROS_impl@@@std@@@std@@@std@@V12@@std@@YAXABV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@ULight@CROS_impl@@@std@@@std@@@0@0@Z ; std::_Adl_verify_range<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CROS_impl::Light> > >,std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CROS_impl::Light> > > >
PUBLIC	?max_size@?$xalloc@UItem@CROS_impl@@@@QBEIXZ	; xalloc<CROS_impl::Item>::max_size
PUBLIC	?_Get_first@?$_Compressed_pair@V?$xalloc@UItem@CROS_impl@@@@V?$_Vector_val@U?$_Simple_types@UItem@CROS_impl@@@std@@@std@@$00@std@@QBEABV?$xalloc@UItem@CROS_impl@@@@XZ ; std::_Compressed_pair<xalloc<CROS_impl::Item>,std::_Vector_val<std::_Simple_types<CROS_impl::Item> >,1>::_Get_first
PUBLIC	?max_size@?$xalloc@ULight@CROS_impl@@@@QBEIXZ	; xalloc<CROS_impl::Light>::max_size
PUBLIC	?_Get_first@?$_Compressed_pair@V?$xalloc@ULight@CROS_impl@@@@V?$_Vector_val@U?$_Simple_types@ULight@CROS_impl@@@std@@@std@@$00@std@@QBEABV?$xalloc@ULight@CROS_impl@@@@XZ ; std::_Compressed_pair<xalloc<CROS_impl::Light>,std::_Vector_val<std::_Simple_types<CROS_impl::Light> >,1>::_Get_first
PUBLIC	?max_size@?$_Normal_allocator_traits@V?$xalloc@UItem@CROS_impl@@@@@std@@SAIABV?$xalloc@UItem@CROS_impl@@@@@Z ; std::_Normal_allocator_traits<xalloc<CROS_impl::Item> >::max_size
PUBLIC	?capacity@?$vector@UItem@CROS_impl@@V?$xalloc@UItem@CROS_impl@@@@@std@@QBEIXZ ; std::vector<CROS_impl::Item,xalloc<CROS_impl::Item> >::capacity
PUBLIC	?_Umove_if_noexcept1@?$vector@UItem@CROS_impl@@V?$xalloc@UItem@CROS_impl@@@@@std@@AAEXPAUItem@CROS_impl@@00U?$integral_constant@_N$00@2@@Z ; std::vector<CROS_impl::Item,xalloc<CROS_impl::Item> >::_Umove_if_noexcept1
PUBLIC	?_Getal@?$vector@UItem@CROS_impl@@V?$xalloc@UItem@CROS_impl@@@@@std@@ABEABV?$xalloc@UItem@CROS_impl@@@@XZ ; std::vector<CROS_impl::Item,xalloc<CROS_impl::Item> >::_Getal
PUBLIC	?max_size@?$_Normal_allocator_traits@V?$xalloc@ULight@CROS_impl@@@@@std@@SAIABV?$xalloc@ULight@CROS_impl@@@@@Z ; std::_Normal_allocator_traits<xalloc<CROS_impl::Light> >::max_size
PUBLIC	?capacity@?$vector@ULight@CROS_impl@@V?$xalloc@ULight@CROS_impl@@@@@std@@QBEIXZ ; std::vector<CROS_impl::Light,xalloc<CROS_impl::Light> >::capacity
PUBLIC	?_Umove_if_noexcept1@?$vector@ULight@CROS_impl@@V?$xalloc@ULight@CROS_impl@@@@@std@@AAEXPAULight@CROS_impl@@00U?$integral_constant@_N$00@2@@Z ; std::vector<CROS_impl::Light,xalloc<CROS_impl::Light> >::_Umove_if_noexcept1
PUBLIC	?_Getal@?$vector@ULight@CROS_impl@@V?$xalloc@ULight@CROS_impl@@@@@std@@ABEABV?$xalloc@ULight@CROS_impl@@@@XZ ; std::vector<CROS_impl::Light,xalloc<CROS_impl::Light> >::_Getal
PUBLIC	??0?$xalloc@UItem@CROS_impl@@@@QAE@XZ		; xalloc<CROS_impl::Item>::xalloc<CROS_impl::Item>
PUBLIC	?allocate@?$xalloc@UItem@CROS_impl@@@@QBEPAUItem@CROS_impl@@IPBX@Z ; xalloc<CROS_impl::Item>::allocate
PUBLIC	?construct@?$xalloc@UItem@CROS_impl@@@@QAEXPAUItem@CROS_impl@@ABU23@@Z ; xalloc<CROS_impl::Item>::construct
PUBLIC	?destroy@?$xalloc@UItem@CROS_impl@@@@QAEXPAUItem@CROS_impl@@@Z ; xalloc<CROS_impl::Item>::destroy
PUBLIC	?max_size@?$vector@UItem@CROS_impl@@V?$xalloc@UItem@CROS_impl@@@@@std@@QBEIXZ ; std::vector<CROS_impl::Item,xalloc<CROS_impl::Item> >::max_size
PUBLIC	?_Umove@?$vector@UItem@CROS_impl@@V?$xalloc@UItem@CROS_impl@@@@@std@@AAEPAUItem@CROS_impl@@PAU34@00@Z ; std::vector<CROS_impl::Item,xalloc<CROS_impl::Item> >::_Umove
PUBLIC	?_Umove_if_noexcept@?$vector@UItem@CROS_impl@@V?$xalloc@UItem@CROS_impl@@@@@std@@AAEXPAUItem@CROS_impl@@00@Z ; std::vector<CROS_impl::Item,xalloc<CROS_impl::Item> >::_Umove_if_noexcept
PUBLIC	?_Calculate_growth@?$vector@UItem@CROS_impl@@V?$xalloc@UItem@CROS_impl@@@@@std@@ABEII@Z ; std::vector<CROS_impl::Item,xalloc<CROS_impl::Item> >::_Calculate_growth
PUBLIC	?_Change_array@?$vector@UItem@CROS_impl@@V?$xalloc@UItem@CROS_impl@@@@@std@@AAEXQAUItem@CROS_impl@@II@Z ; std::vector<CROS_impl::Item,xalloc<CROS_impl::Item> >::_Change_array
PUBLIC	?_Xlength@?$vector@UItem@CROS_impl@@V?$xalloc@UItem@CROS_impl@@@@@std@@CAXXZ ; std::vector<CROS_impl::Item,xalloc<CROS_impl::Item> >::_Xlength
PUBLIC	??0?$_Vector_val@U?$_Simple_types@UItem@CROS_impl@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<CROS_impl::Item> >::_Vector_val<std::_Simple_types<CROS_impl::Item> >
PUBLIC	??0?$xalloc@ULight@CROS_impl@@@@QAE@XZ		; xalloc<CROS_impl::Light>::xalloc<CROS_impl::Light>
PUBLIC	?allocate@?$xalloc@ULight@CROS_impl@@@@QBEPAULight@CROS_impl@@IPBX@Z ; xalloc<CROS_impl::Light>::allocate
PUBLIC	?construct@?$xalloc@ULight@CROS_impl@@@@QAEXPAULight@CROS_impl@@ABU23@@Z ; xalloc<CROS_impl::Light>::construct
PUBLIC	?max_size@?$vector@ULight@CROS_impl@@V?$xalloc@ULight@CROS_impl@@@@@std@@QBEIXZ ; std::vector<CROS_impl::Light,xalloc<CROS_impl::Light> >::max_size
PUBLIC	?_Umove@?$vector@ULight@CROS_impl@@V?$xalloc@ULight@CROS_impl@@@@@std@@AAEPAULight@CROS_impl@@PAU34@00@Z ; std::vector<CROS_impl::Light,xalloc<CROS_impl::Light> >::_Umove
PUBLIC	?_Umove_if_noexcept@?$vector@ULight@CROS_impl@@V?$xalloc@ULight@CROS_impl@@@@@std@@AAEXPAULight@CROS_impl@@00@Z ; std::vector<CROS_impl::Light,xalloc<CROS_impl::Light> >::_Umove_if_noexcept
PUBLIC	?_Calculate_growth@?$vector@ULight@CROS_impl@@V?$xalloc@ULight@CROS_impl@@@@@std@@ABEII@Z ; std::vector<CROS_impl::Light,xalloc<CROS_impl::Light> >::_Calculate_growth
PUBLIC	?_Change_array@?$vector@ULight@CROS_impl@@V?$xalloc@ULight@CROS_impl@@@@@std@@AAEXQAULight@CROS_impl@@II@Z ; std::vector<CROS_impl::Light,xalloc<CROS_impl::Light> >::_Change_array
PUBLIC	?_Xlength@?$vector@ULight@CROS_impl@@V?$xalloc@ULight@CROS_impl@@@@@std@@CAXXZ ; std::vector<CROS_impl::Light,xalloc<CROS_impl::Light> >::_Xlength
PUBLIC	??0?$_Vector_val@U?$_Simple_types@ULight@CROS_impl@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<CROS_impl::Light> >::_Vector_val<std::_Simple_types<CROS_impl::Light> >
PUBLIC	?_Unwrapped@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@ULight@CROS_impl@@@std@@@std@@@std@@QBEPAULight@CROS_impl@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CROS_impl::Light> > >::_Unwrapped
PUBLIC	??$xr_free@UItem@CROS_impl@@@@YAXAAPAUItem@CROS_impl@@@Z ; xr_free<CROS_impl::Item>
PUBLIC	??$_Destroy_range@V?$xalloc@UItem@CROS_impl@@@@@std@@YAXPAUItem@CROS_impl@@QAU12@AAV?$xalloc@UItem@CROS_impl@@@@@Z ; std::_Destroy_range<xalloc<CROS_impl::Item> >
PUBLIC	??$xr_free@ULight@CROS_impl@@@@YAXAAPAULight@CROS_impl@@@Z ; xr_free<CROS_impl::Light>
PUBLIC	??$_Destroy_range@V?$xalloc@ULight@CROS_impl@@@@@std@@YAXPAULight@CROS_impl@@QAU12@AAV?$xalloc@ULight@CROS_impl@@@@@Z ; std::_Destroy_range<xalloc<CROS_impl::Light> >
PUBLIC	??$addressof@V?$_Vector_val@U?$_Simple_types@PAVISpatial@@@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@PAVISpatial@@@std@@@0@AAV10@@Z ; std::addressof<std::_Vector_val<std::_Simple_types<ISpatial *> > >
PUBLIC	??$?0$$V@?$_Compressed_pair@V?$xalloc@UItem@CROS_impl@@@@V?$_Vector_val@U?$_Simple_types@UItem@CROS_impl@@@std@@@std@@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<xalloc<CROS_impl::Item>,std::_Vector_val<std::_Simple_types<CROS_impl::Item> >,1>::_Compressed_pair<xalloc<CROS_impl::Item>,std::_Vector_val<std::_Simple_types<CROS_impl::Item> >,1><>
PUBLIC	??$?0$$V@?$_Compressed_pair@V?$xalloc@ULight@CROS_impl@@@@V?$_Vector_val@U?$_Simple_types@ULight@CROS_impl@@@std@@@std@@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<xalloc<CROS_impl::Light>,std::_Vector_val<std::_Simple_types<CROS_impl::Light> >,1>::_Compressed_pair<xalloc<CROS_impl::Light>,std::_Vector_val<std::_Simple_types<CROS_impl::Light> >,1><>
PUBLIC	??$_Emplace_reallocate@UItem@CROS_impl@@@?$vector@UItem@CROS_impl@@V?$xalloc@UItem@CROS_impl@@@@@std@@QAEPAUItem@CROS_impl@@QAU23@$$QAU23@@Z ; std::vector<CROS_impl::Item,xalloc<CROS_impl::Item> >::_Emplace_reallocate<CROS_impl::Item>
PUBLIC	??$construct@UItem@CROS_impl@@U12@@?$_Normal_allocator_traits@V?$xalloc@UItem@CROS_impl@@@@@std@@SAXAAV?$xalloc@UItem@CROS_impl@@@@PAUItem@CROS_impl@@$$QAU34@@Z ; std::_Normal_allocator_traits<xalloc<CROS_impl::Item> >::construct<CROS_impl::Item,CROS_impl::Item>
PUBLIC	??$forward@UItem@CROS_impl@@@std@@YA$$QAUItem@CROS_impl@@AAU12@@Z ; std::forward<CROS_impl::Item>
PUBLIC	??$move@AAUItem@CROS_impl@@@std@@YA$$QAUItem@CROS_impl@@AAU12@@Z ; std::move<CROS_impl::Item &>
PUBLIC	??$destroy@UItem@CROS_impl@@@?$_Normal_allocator_traits@V?$xalloc@UItem@CROS_impl@@@@@std@@SAXAAV?$xalloc@UItem@CROS_impl@@@@PAUItem@CROS_impl@@@Z ; std::_Normal_allocator_traits<xalloc<CROS_impl::Item> >::destroy<CROS_impl::Item>
PUBLIC	??$_Unfancy@UItem@CROS_impl@@@std@@YAPAUItem@CROS_impl@@PAU12@@Z ; std::_Unfancy<CROS_impl::Item>
PUBLIC	??$_Move_unchecked@PAUItem@CROS_impl@@PAU12@@std@@YAPAUItem@CROS_impl@@PAU12@00@Z ; std::_Move_unchecked<CROS_impl::Item *,CROS_impl::Item *>
PUBLIC	??$addressof@V?$_Vector_val@U?$_Simple_types@UItem@CROS_impl@@@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@UItem@CROS_impl@@@std@@@0@AAV10@@Z ; std::addressof<std::_Vector_val<std::_Simple_types<CROS_impl::Item> > >
PUBLIC	??$_Emplace_reallocate@ULight@CROS_impl@@@?$vector@ULight@CROS_impl@@V?$xalloc@ULight@CROS_impl@@@@@std@@QAEPAULight@CROS_impl@@QAU23@$$QAU23@@Z ; std::vector<CROS_impl::Light,xalloc<CROS_impl::Light> >::_Emplace_reallocate<CROS_impl::Light>
PUBLIC	??$construct@ULight@CROS_impl@@U12@@?$_Normal_allocator_traits@V?$xalloc@ULight@CROS_impl@@@@@std@@SAXAAV?$xalloc@ULight@CROS_impl@@@@PAULight@CROS_impl@@$$QAU34@@Z ; std::_Normal_allocator_traits<xalloc<CROS_impl::Light> >::construct<CROS_impl::Light,CROS_impl::Light>
PUBLIC	??$_Unfancy@ULight@CROS_impl@@@std@@YAPAULight@CROS_impl@@PAU12@@Z ; std::_Unfancy<CROS_impl::Light>
PUBLIC	??$forward@ULight@CROS_impl@@@std@@YA$$QAULight@CROS_impl@@AAU12@@Z ; std::forward<CROS_impl::Light>
PUBLIC	??$move@AAULight@CROS_impl@@@std@@YA$$QAULight@CROS_impl@@AAU12@@Z ; std::move<CROS_impl::Light &>
PUBLIC	??$addressof@V?$_Vector_val@U?$_Simple_types@ULight@CROS_impl@@@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@ULight@CROS_impl@@@std@@@0@AAV10@@Z ; std::addressof<std::_Vector_val<std::_Simple_types<CROS_impl::Light> > >
PUBLIC	??$_Get_unwrapped@ABV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@ULight@CROS_impl@@@std@@@std@@@std@@@std@@YA?A_TABV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@ULight@CROS_impl@@@std@@@std@@@0@@Z ; std::_Get_unwrapped<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CROS_impl::Light> > > const &>
PUBLIC	??$sort@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@ULight@CROS_impl@@@std@@@std@@@std@@P6A_NABULight@CROS_impl@@0@Z@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@ULight@CROS_impl@@@std@@@std@@@0@0P6A_NABULight@CROS_impl@@1@Z@Z ; std::sort<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CROS_impl::Light> > >,bool (__cdecl*)(CROS_impl::Light const &,CROS_impl::Light const &)>
PUBLIC	?_Verify_offset@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@ULight@CROS_impl@@@std@@@std@@@std@@QBEXH@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CROS_impl::Light> > >::_Verify_offset
PUBLIC	?_Verify_offset@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVISpatial@@@std@@@std@@@std@@QBEXH@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<ISpatial *> > >::_Verify_offset
PUBLIC	?_Verify_offset@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CROS_impl@@@std@@@std@@@std@@QBEXH@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CROS_impl::Item> > >::_Verify_offset
PUBLIC	??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@ULight@CROS_impl@@@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CROS_impl::Light> > >::operator+=
PUBLIC	??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVISpatial@@@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<ISpatial *> > >::operator+=
PUBLIC	?deallocate@?$xalloc@UItem@CROS_impl@@@@QBEXPAUItem@CROS_impl@@I@Z ; xalloc<CROS_impl::Item>::deallocate
PUBLIC	?_Destroy@?$vector@UItem@CROS_impl@@V?$xalloc@UItem@CROS_impl@@@@@std@@AAEXPAUItem@CROS_impl@@0@Z ; std::vector<CROS_impl::Item,xalloc<CROS_impl::Item> >::_Destroy
PUBLIC	?_Get_first@?$_Compressed_pair@V?$xalloc@UItem@CROS_impl@@@@V?$_Vector_val@U?$_Simple_types@UItem@CROS_impl@@@std@@@std@@$00@std@@QAEAAV?$xalloc@UItem@CROS_impl@@@@XZ ; std::_Compressed_pair<xalloc<CROS_impl::Item>,std::_Vector_val<std::_Simple_types<CROS_impl::Item> >,1>::_Get_first
PUBLIC	?deallocate@?$xalloc@ULight@CROS_impl@@@@QBEXPAULight@CROS_impl@@I@Z ; xalloc<CROS_impl::Light>::deallocate
PUBLIC	?clear@?$vector@ULight@CROS_impl@@V?$xalloc@ULight@CROS_impl@@@@@std@@QAEXXZ ; std::vector<CROS_impl::Light,xalloc<CROS_impl::Light> >::clear
PUBLIC	?_Destroy@?$vector@ULight@CROS_impl@@V?$xalloc@ULight@CROS_impl@@@@@std@@AAEXPAULight@CROS_impl@@0@Z ; std::vector<CROS_impl::Light,xalloc<CROS_impl::Light> >::_Destroy
PUBLIC	?_Get_first@?$_Compressed_pair@V?$xalloc@ULight@CROS_impl@@@@V?$_Vector_val@U?$_Simple_types@ULight@CROS_impl@@@std@@@std@@$00@std@@QAEAAV?$xalloc@ULight@CROS_impl@@@@XZ ; std::_Compressed_pair<xalloc<CROS_impl::Light>,std::_Vector_val<std::_Simple_types<CROS_impl::Light> >,1>::_Get_first
PUBLIC	??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CROS_impl@@@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CROS_impl::Item> > >::operator+=
PUBLIC	?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CROS_impl@@@std@@@std@@@std@@QBEXABV12@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CROS_impl::Item> > >::_Compat
PUBLIC	??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@ULight@CROS_impl@@@std@@@std@@@std@@QBEABULight@CROS_impl@@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CROS_impl::Light> > >::operator*
PUBLIC	??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@ULight@CROS_impl@@@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CROS_impl::Light> > >::operator+=
PUBLIC	??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVISpatial@@@std@@@std@@@std@@QAE@PAPAVISpatial@@PBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<ISpatial *> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<ISpatial *> > >
PUBLIC	??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVISpatial@@@std@@@std@@@std@@QBEABQAVISpatial@@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<ISpatial *> > >::operator*
PUBLIC	??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVISpatial@@@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<ISpatial *> > >::operator+=
PUBLIC	??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVISpatial@@@std@@@std@@@std@@QAE@PAPAVISpatial@@PBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<ISpatial *> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<ISpatial *> > >
PUBLIC	?begin@?$vector@PAVISpatial@@V?$xalloc@PAVISpatial@@@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVISpatial@@@std@@@std@@@2@XZ ; std::vector<ISpatial *,xalloc<ISpatial *> >::begin
PUBLIC	?size@?$vector@PAVISpatial@@V?$xalloc@PAVISpatial@@@@@std@@QBEIXZ ; std::vector<ISpatial *,xalloc<ISpatial *> >::size
PUBLIC	??0?$vector@UItem@CROS_impl@@V?$xalloc@UItem@CROS_impl@@@@@std@@QAE@XZ ; std::vector<CROS_impl::Item,xalloc<CROS_impl::Item> >::vector<CROS_impl::Item,xalloc<CROS_impl::Item> >
PUBLIC	?size@?$vector@UItem@CROS_impl@@V?$xalloc@UItem@CROS_impl@@@@@std@@QBEIXZ ; std::vector<CROS_impl::Item,xalloc<CROS_impl::Item> >::size
PUBLIC	?_Tidy@?$vector@UItem@CROS_impl@@V?$xalloc@UItem@CROS_impl@@@@@std@@AAEXXZ ; std::vector<CROS_impl::Item,xalloc<CROS_impl::Item> >::_Tidy
PUBLIC	?_Orphan_range@?$vector@UItem@CROS_impl@@V?$xalloc@UItem@CROS_impl@@@@@std@@ABEXPAUItem@CROS_impl@@0@Z ; std::vector<CROS_impl::Item,xalloc<CROS_impl::Item> >::_Orphan_range
PUBLIC	?_Getal@?$vector@UItem@CROS_impl@@V?$xalloc@UItem@CROS_impl@@@@@std@@AAEAAV?$xalloc@UItem@CROS_impl@@@@XZ ; std::vector<CROS_impl::Item,xalloc<CROS_impl::Item> >::_Getal
PUBLIC	??0?$vector@ULight@CROS_impl@@V?$xalloc@ULight@CROS_impl@@@@@std@@QAE@XZ ; std::vector<CROS_impl::Light,xalloc<CROS_impl::Light> >::vector<CROS_impl::Light,xalloc<CROS_impl::Light> >
PUBLIC	?size@?$vector@ULight@CROS_impl@@V?$xalloc@ULight@CROS_impl@@@@@std@@QBEIXZ ; std::vector<CROS_impl::Light,xalloc<CROS_impl::Light> >::size
PUBLIC	?_Tidy@?$vector@ULight@CROS_impl@@V?$xalloc@ULight@CROS_impl@@@@@std@@AAEXXZ ; std::vector<CROS_impl::Light,xalloc<CROS_impl::Light> >::_Tidy
PUBLIC	?_Orphan_range@?$vector@ULight@CROS_impl@@V?$xalloc@ULight@CROS_impl@@@@@std@@ABEXPAULight@CROS_impl@@0@Z ; std::vector<CROS_impl::Light,xalloc<CROS_impl::Light> >::_Orphan_range
PUBLIC	?_Getal@?$vector@ULight@CROS_impl@@V?$xalloc@ULight@CROS_impl@@@@@std@@AAEAAV?$xalloc@ULight@CROS_impl@@@@XZ ; std::vector<CROS_impl::Light,xalloc<CROS_impl::Light> >::_Getal
PUBLIC	?clear_and_free@?$xr_vector@ULight@CROS_impl@@V?$xalloc@ULight@CROS_impl@@@@@@QAEXXZ ; xr_vector<CROS_impl::Light,xalloc<CROS_impl::Light> >::clear_and_free
PUBLIC	??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CROS_impl@@@std@@@std@@@std@@QAE@PAUItem@CROS_impl@@PBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CROS_impl::Item> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CROS_impl::Item> > >
PUBLIC	??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CROS_impl@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CROS_impl::Item> > >::operator++
PUBLIC	??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CROS_impl@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CROS_impl::Item> > >::operator==
PUBLIC	??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CROS_impl@@@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CROS_impl::Item> > >::operator+=
PUBLIC	??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@ULight@CROS_impl@@@std@@@std@@@std@@QAE@PAULight@CROS_impl@@PBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CROS_impl::Light> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CROS_impl::Light> > >
PUBLIC	??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@ULight@CROS_impl@@@std@@@std@@@std@@QBEAAULight@CROS_impl@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CROS_impl::Light> > >::operator*
PUBLIC	??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@ULight@CROS_impl@@@std@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CROS_impl::Light> > >::operator+
PUBLIC	??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVISpatial@@@std@@@std@@@std@@QBEAAPAVISpatial@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<ISpatial *> > >::operator*
PUBLIC	??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVISpatial@@@std@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<ISpatial *> > >::operator+
PUBLIC	??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CROS_impl@@@std@@@std@@@std@@QAE@PAUItem@CROS_impl@@PBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CROS_impl::Item> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<CROS_impl::Item> > >
PUBLIC	??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@ULight@CROS_impl@@@std@@@std@@@std@@QAE@PAULight@CROS_impl@@PBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CROS_impl::Light> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<CROS_impl::Light> > >
PUBLIC	?magnitude@?$_vector3@M@@QBEMXZ			; _vector3<float>::magnitude
PUBLIC	?random_dir@?$_vector3@M@@QAEAAU1@AAVCRandom@@@Z ; _vector3<float>::random_dir
PUBLIC	?mul_rgb@?$_color@M@@QAEAAU1@M@Z		; _color<float>::mul_rgb
PUBLIC	?mul_rgb@?$_color@M@@QAEAAU1@ABU1@M@Z		; _color<float>::mul_rgb
PUBLIC	?intensity@?$_color@M@@QBEMXZ			; _color<float>::intensity
PUBLIC	?size@?$xr_vector@PAVISpatial@@V?$xalloc@PAVISpatial@@@@@@QBEIXZ ; xr_vector<ISpatial *,xalloc<ISpatial *> >::size
PUBLIC	??A?$xr_vector@PAVISpatial@@V?$xalloc@PAVISpatial@@@@@@QAEAAPAVISpatial@@I@Z ; xr_vector<ISpatial *,xalloc<ISpatial *> >::operator[]
PUBLIC	??1?$vector@UItem@CROS_impl@@V?$xalloc@UItem@CROS_impl@@@@@std@@QAE@XZ ; std::vector<CROS_impl::Item,xalloc<CROS_impl::Item> >::~vector<CROS_impl::Item,xalloc<CROS_impl::Item> >
PUBLIC	??$_Emplace_back_with_unused_capacity@UItem@CROS_impl@@@?$vector@UItem@CROS_impl@@V?$xalloc@UItem@CROS_impl@@@@@std@@AAE?A_T$$QAUItem@CROS_impl@@@Z ; std::vector<CROS_impl::Item,xalloc<CROS_impl::Item> >::_Emplace_back_with_unused_capacity<CROS_impl::Item>
PUBLIC	??$emplace_back@UItem@CROS_impl@@@?$vector@UItem@CROS_impl@@V?$xalloc@UItem@CROS_impl@@@@@std@@QAE?A_T$$QAUItem@CROS_impl@@@Z ; std::vector<CROS_impl::Item,xalloc<CROS_impl::Item> >::emplace_back<CROS_impl::Item>
PUBLIC	?push_back@?$vector@UItem@CROS_impl@@V?$xalloc@UItem@CROS_impl@@@@@std@@QAEX$$QAUItem@CROS_impl@@@Z ; std::vector<CROS_impl::Item,xalloc<CROS_impl::Item> >::push_back
PUBLIC	?erase@?$vector@UItem@CROS_impl@@V?$xalloc@UItem@CROS_impl@@@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CROS_impl@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CROS_impl@@@std@@@std@@@2@@Z ; std::vector<CROS_impl::Item,xalloc<CROS_impl::Item> >::erase
PUBLIC	?begin@?$vector@UItem@CROS_impl@@V?$xalloc@UItem@CROS_impl@@@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CROS_impl@@@std@@@std@@@2@XZ ; std::vector<CROS_impl::Item,xalloc<CROS_impl::Item> >::begin
PUBLIC	?end@?$vector@UItem@CROS_impl@@V?$xalloc@UItem@CROS_impl@@@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CROS_impl@@@std@@@std@@@2@XZ ; std::vector<CROS_impl::Item,xalloc<CROS_impl::Item> >::end
PUBLIC	?back@?$vector@UItem@CROS_impl@@V?$xalloc@UItem@CROS_impl@@@@@std@@QAEAAUItem@CROS_impl@@XZ ; std::vector<CROS_impl::Item,xalloc<CROS_impl::Item> >::back
PUBLIC	??0?$xr_vector@UItem@CROS_impl@@V?$xalloc@UItem@CROS_impl@@@@@@QAE@XZ ; xr_vector<CROS_impl::Item,xalloc<CROS_impl::Item> >::xr_vector<CROS_impl::Item,xalloc<CROS_impl::Item> >
PUBLIC	?size@?$xr_vector@UItem@CROS_impl@@V?$xalloc@UItem@CROS_impl@@@@@@QBEIXZ ; xr_vector<CROS_impl::Item,xalloc<CROS_impl::Item> >::size
PUBLIC	??1?$vector@ULight@CROS_impl@@V?$xalloc@ULight@CROS_impl@@@@@std@@QAE@XZ ; std::vector<CROS_impl::Light,xalloc<CROS_impl::Light> >::~vector<CROS_impl::Light,xalloc<CROS_impl::Light> >
PUBLIC	??$_Emplace_back_with_unused_capacity@ULight@CROS_impl@@@?$vector@ULight@CROS_impl@@V?$xalloc@ULight@CROS_impl@@@@@std@@AAE?A_T$$QAULight@CROS_impl@@@Z ; std::vector<CROS_impl::Light,xalloc<CROS_impl::Light> >::_Emplace_back_with_unused_capacity<CROS_impl::Light>
PUBLIC	??$emplace_back@ULight@CROS_impl@@@?$vector@ULight@CROS_impl@@V?$xalloc@ULight@CROS_impl@@@@@std@@QAE?A_T$$QAULight@CROS_impl@@@Z ; std::vector<CROS_impl::Light,xalloc<CROS_impl::Light> >::emplace_back<CROS_impl::Light>
PUBLIC	?push_back@?$vector@ULight@CROS_impl@@V?$xalloc@ULight@CROS_impl@@@@@std@@QAEX$$QAULight@CROS_impl@@@Z ; std::vector<CROS_impl::Light,xalloc<CROS_impl::Light> >::push_back
PUBLIC	?begin@?$vector@ULight@CROS_impl@@V?$xalloc@ULight@CROS_impl@@@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@ULight@CROS_impl@@@std@@@std@@@2@XZ ; std::vector<CROS_impl::Light,xalloc<CROS_impl::Light> >::begin
PUBLIC	?end@?$vector@ULight@CROS_impl@@V?$xalloc@ULight@CROS_impl@@@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@ULight@CROS_impl@@@std@@@std@@@2@XZ ; std::vector<CROS_impl::Light,xalloc<CROS_impl::Light> >::end
PUBLIC	?back@?$vector@ULight@CROS_impl@@V?$xalloc@ULight@CROS_impl@@@@@std@@QAEAAULight@CROS_impl@@XZ ; std::vector<CROS_impl::Light,xalloc<CROS_impl::Light> >::back
PUBLIC	??0?$xr_vector@ULight@CROS_impl@@V?$xalloc@ULight@CROS_impl@@@@@@QAE@XZ ; xr_vector<CROS_impl::Light,xalloc<CROS_impl::Light> >::xr_vector<CROS_impl::Light,xalloc<CROS_impl::Light> >
PUBLIC	?size@?$xr_vector@ULight@CROS_impl@@V?$xalloc@ULight@CROS_impl@@@@@@QBEIXZ ; xr_vector<CROS_impl::Light,xalloc<CROS_impl::Light> >::size
PUBLIC	?clear@?$xr_vector@ULight@CROS_impl@@V?$xalloc@ULight@CROS_impl@@@@@@QAEXXZ ; xr_vector<CROS_impl::Light,xalloc<CROS_impl::Light> >::clear
PUBLIC	??A?$xr_vector@ULight@CROS_impl@@V?$xalloc@ULight@CROS_impl@@@@@@QAEAAULight@CROS_impl@@I@Z ; xr_vector<CROS_impl::Light,xalloc<CROS_impl::Light> >::operator[]
PUBLIC	??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CROS_impl@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CROS_impl::Item> > >::operator!=
PUBLIC	??C?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CROS_impl@@@std@@@std@@@std@@QBEPAUItem@CROS_impl@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CROS_impl::Item> > >::operator->
PUBLIC	??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CROS_impl@@@std@@@std@@@std@@QAE?AV01@H@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CROS_impl::Item> > >::operator++
PUBLIC	??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CROS_impl@@@std@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CROS_impl::Item> > >::operator+
PUBLIC	?update_smooth@CROS_impl@@QAEXPAVIRenderable@@@Z ; CROS_impl::update_smooth
PUBLIC	?update@CROS_impl@@QAEXPAVIRenderable@@@Z	; CROS_impl::update
PUBLIC	?pred_energy@@YA_NABULight@CROS_impl@@0@Z	; pred_energy
PUBLIC	??0Item@CROS_impl@@QAE@XZ			; CROS_impl::Item::Item
PUBLIC	?add@CROS_impl@@QAEXPAVlight@@@Z		; CROS_impl::add
PUBLIC	??0CROS_impl@@QAE@XZ				; CROS_impl::CROS_impl
PUBLIC	??1?$xr_vector@ULight@CROS_impl@@V?$xalloc@ULight@CROS_impl@@@@@@QAE@XZ ; xr_vector<CROS_impl::Light,xalloc<CROS_impl::Light> >::~xr_vector<CROS_impl::Light,xalloc<CROS_impl::Light> >
PUBLIC	??1?$xr_vector@UItem@CROS_impl@@V?$xalloc@UItem@CROS_impl@@@@@@QAE@XZ ; xr_vector<CROS_impl::Item,xalloc<CROS_impl::Item> >::~xr_vector<CROS_impl::Item,xalloc<CROS_impl::Item> >
PUBLIC	??_GCROS_impl@@UAEPAXI@Z			; CROS_impl::`scalar deleting destructor'
PUBLIC	??1CROS_impl@@UAE@XZ				; CROS_impl::~CROS_impl
PUBLIC	?get_hemi@CROS_impl@@QAEMXZ			; CROS_impl::get_hemi
PUBLIC	?get_luminocity_hemi@CROS_impl@@UAEMXZ		; CROS_impl::get_luminocity_hemi
PUBLIC	?get_luminocity@CROS_impl@@UAEMXZ		; CROS_impl::get_luminocity
PUBLIC	?force_mode@CROS_impl@@UAEXI@Z			; CROS_impl::force_mode
EXTRN	??_ECROS_impl@@UAEPAXI@Z:PROC			; CROS_impl::`vector deleting destructor'
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$_Emplace_reallocate@ULight@CROS_impl@@@?$vector@ULight@CROS_impl@@V?$xalloc@ULight@CROS_impl@@@@@std@@QAEPAULight@CROS_impl@@QAU23@$$QAU23@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Emplace_reallocate@ULight@CROS_impl@@@?$vector@ULight@CROS_impl@@V?$xalloc@ULight@CROS_impl@@@@@std@@QAEPAULight@CROS_impl@@QAU23@$$QAU23@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Emplace_reallocate@ULight@CROS_impl@@@?$vector@ULight@CROS_impl@@V?$xalloc@ULight@CROS_impl@@@@@std@@QAEPAULight@CROS_impl@@QAU23@$$QAU23@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
__unwindtable$??$_Emplace_reallocate@ULight@CROS_impl@@@?$vector@ULight@CROS_impl@@V?$xalloc@ULight@CROS_impl@@@@@std@@QAEPAULight@CROS_impl@@QAU23@$$QAU23@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Emplace_reallocate@ULight@CROS_impl@@@?$vector@ULight@CROS_impl@@V?$xalloc@ULight@CROS_impl@@@@@std@@QAEPAULight@CROS_impl@@QAU23@$$QAU23@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Emplace_reallocate@ULight@CROS_impl@@@?$vector@ULight@CROS_impl@@V?$xalloc@ULight@CROS_impl@@@@@std@@QAEPAULight@CROS_impl@@QAU23@$$QAU23@@Z$2
__catchsym$??$_Emplace_reallocate@ULight@CROS_impl@@@?$vector@ULight@CROS_impl@@V?$xalloc@ULight@CROS_impl@@@@@std@@QAEPAULight@CROS_impl@@QAU23@$$QAU23@@Z$2 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Emplace_reallocate@ULight@CROS_impl@@@?$vector@ULight@CROS_impl@@V?$xalloc@ULight@CROS_impl@@@@@std@@QAEPAULight@CROS_impl@@QAU23@$$QAU23@@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$_Emplace_reallocate@UItem@CROS_impl@@@?$vector@UItem@CROS_impl@@V?$xalloc@UItem@CROS_impl@@@@@std@@QAEPAUItem@CROS_impl@@QAU23@$$QAU23@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Emplace_reallocate@UItem@CROS_impl@@@?$vector@UItem@CROS_impl@@V?$xalloc@UItem@CROS_impl@@@@@std@@QAEPAUItem@CROS_impl@@QAU23@$$QAU23@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Emplace_reallocate@UItem@CROS_impl@@@?$vector@UItem@CROS_impl@@V?$xalloc@UItem@CROS_impl@@@@@std@@QAEPAUItem@CROS_impl@@QAU23@$$QAU23@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
__unwindtable$??$_Emplace_reallocate@UItem@CROS_impl@@@?$vector@UItem@CROS_impl@@V?$xalloc@UItem@CROS_impl@@@@@std@@QAEPAUItem@CROS_impl@@QAU23@$$QAU23@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Emplace_reallocate@UItem@CROS_impl@@@?$vector@UItem@CROS_impl@@V?$xalloc@UItem@CROS_impl@@@@@std@@QAEPAUItem@CROS_impl@@QAU23@$$QAU23@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Emplace_reallocate@UItem@CROS_impl@@@?$vector@UItem@CROS_impl@@V?$xalloc@UItem@CROS_impl@@@@@std@@QAEPAUItem@CROS_impl@@QAU23@$$QAU23@@Z$2
__catchsym$??$_Emplace_reallocate@UItem@CROS_impl@@@?$vector@UItem@CROS_impl@@V?$xalloc@UItem@CROS_impl@@@@@std@@QAEPAUItem@CROS_impl@@QAU23@$$QAU23@@Z$2 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Emplace_reallocate@UItem@CROS_impl@@@?$vector@UItem@CROS_impl@@V?$xalloc@UItem@CROS_impl@@@@@std@@QAEPAUItem@CROS_impl@@QAU23@$$QAU23@@Z$0
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\LightTrack.h
;	COMDAT ?force_mode@CROS_impl@@UAEXI@Z
_TEXT	SEGMENT
_mode$ = 8						; size = 4
?force_mode@CROS_impl@@UAEXI@Z PROC			; CROS_impl::force_mode, COMDAT
; _this$ = ecx

; 57   : 	virtual	void			force_mode			(u32 mode)		{ MODE = mode;															};

	mov	eax, DWORD PTR _mode$[esp-4]
	mov	DWORD PTR [ecx+4], eax
	ret	4
?force_mode@CROS_impl@@UAEXI@Z ENDP			; CROS_impl::force_mode
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\LightTrack.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\LightTrack.h
;	COMDAT ?get_luminocity@CROS_impl@@UAEMXZ
_TEXT	SEGMENT
?get_luminocity@CROS_impl@@UAEMXZ PROC			; CROS_impl::get_luminocity, COMDAT
; _this$ = ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	fld	DWORD PTR [ecx+1952]
	fadd	DWORD PTR [ecx+1948]
	fadd	DWORD PTR [ecx+1956]
	fmul	DWORD PTR __real@3eaaaaab
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\LightTrack.h

; 58   : 	virtual float			get_luminocity		()				{ Fvector one; return one.set(1,1,1).div(3.f).dotproduct(approximate);	};

	ret	0
?get_luminocity@CROS_impl@@UAEMXZ ENDP			; CROS_impl::get_luminocity
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\LightTrack.h
; File I:\Vitalya\mine\NSProjectX\xrCore\vector.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\LightTrack.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\vector.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\LightTrack.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\LightTrack.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\LightTrack.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\LightTrack.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\LightTrack.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\LightTrack.h
;	COMDAT ?get_luminocity_hemi@CROS_impl@@UAEMXZ
_TEXT	SEGMENT
$T1 = -4						; size = 4
?get_luminocity_hemi@CROS_impl@@UAEMXZ PROC		; CROS_impl::get_luminocity_hemi, COMDAT
; _this$ = ecx

; 59   : 	virtual float			get_luminocity_hemi	()				{ return get_hemi();}

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H

; 66   : 		if (dwFrameSmooth!=Device.dwFrame)		update_smooth();

	mov	eax, DWORD PTR __imp_?Device@@3VCRenderDevice@@A

; 59   : 	virtual float			get_luminocity_hemi	()				{ return get_hemi();}

	sub	esp, 8

; 66   : 		if (dwFrameSmooth!=Device.dwFrame)		update_smooth();

	mov	eax, DWORD PTR [eax+244]
	cmp	DWORD PTR [ecx+12], eax
	je	SHORT $LN16@get_lumino
; File I:\Vitalya\mine\NSProjectX\xrCore\vector.h

; 92   : 	if( val<_low ) val = _low; else if( val>_high ) val = _high;

	movss	xmm3, DWORD PTR __real@3f800000
	xorps	xmm0, xmm0
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\LightTrack.cpp

; 260  : 	dwFrameSmooth			=	Device.dwFrame					;

	mov	DWORD PTR [ecx+12], eax

; 261  : 	if (O && (0==result_count))	update(O)						;	// First time only
; 262  : 	float	l_f				=	Device.fTimeDelta*ps_r2_lt_smooth;

	mov	eax, DWORD PTR __imp_?Device@@3VCRenderDevice@@A
	movss	xmm2, DWORD PTR [eax+468]
; File I:\Vitalya\mine\NSProjectX\xrCore\vector.h

; 92   : 	if( val<_low ) val = _low; else if( val>_high ) val = _high;

	comiss	xmm0, xmm2
	jbe	SHORT $LN11@get_lumino
	movaps	xmm2, xmm0
	jmp	SHORT $LN13@get_lumino
$LN11@get_lumino:
	comiss	xmm2, xmm3
	jbe	SHORT $LN13@get_lumino
	movaps	xmm2, xmm3
$LN13@get_lumino:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\LightTrack.cpp

; 264  : 	float	l_i				=	1.f-l_f							;

	subss	xmm3, xmm2

; 265  : 	hemi_smooth				=	hemi_value*l_f + hemi_smooth*l_i;

	movaps	xmm1, xmm2
	mulss	xmm1, DWORD PTR [ecx+1932]

; 266  : 	sun_smooth				=	sun_value *l_f + sun_smooth *l_i;

	mulss	xmm2, DWORD PTR [ecx+1940]
	movaps	xmm0, xmm3
	mulss	xmm3, DWORD PTR [ecx+1944]
	mulss	xmm0, DWORD PTR [ecx+1936]
	addss	xmm2, xmm3
	addss	xmm1, xmm0
	movss	DWORD PTR [ecx+1944], xmm2
	movss	DWORD PTR $T1[esp+8], xmm1
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\LightTrack.h

; 59   : 	virtual float			get_luminocity_hemi	()				{ return get_hemi();}

	fld	DWORD PTR $T1[esp+8]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\LightTrack.cpp

; 265  : 	hemi_smooth				=	hemi_value*l_f + hemi_smooth*l_i;

	movss	DWORD PTR [ecx+1936], xmm1
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\LightTrack.h

; 59   : 	virtual float			get_luminocity_hemi	()				{ return get_hemi();}

	mov	esp, ebp
	pop	ebp
	ret	0
$LN16@get_lumino:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\LightTrack.cpp

; 266  : 	sun_smooth				=	sun_value *l_f + sun_smooth *l_i;

	movss	xmm0, DWORD PTR [ecx+1936]
	movss	DWORD PTR $T1[esp+8], xmm0
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\LightTrack.h

; 59   : 	virtual float			get_luminocity_hemi	()				{ return get_hemi();}

	fld	DWORD PTR $T1[esp+8]
	mov	esp, ebp
	pop	ebp
	ret	0
?get_luminocity_hemi@CROS_impl@@UAEMXZ ENDP		; CROS_impl::get_luminocity_hemi
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\LightTrack.h
; File I:\Vitalya\mine\NSProjectX\xrCore\vector.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\LightTrack.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\vector.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\LightTrack.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\LightTrack.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\LightTrack.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\LightTrack.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\LightTrack.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\LightTrack.h
;	COMDAT ?get_hemi@CROS_impl@@QAEMXZ
_TEXT	SEGMENT
$T1 = -4						; size = 4
?get_hemi@CROS_impl@@QAEMXZ PROC			; CROS_impl::get_hemi, COMDAT
; _this$ = ecx

; 65   : 	ICF	float				get_hemi			()	{

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H

; 66   : 		if (dwFrameSmooth!=Device.dwFrame)		update_smooth();

	mov	eax, DWORD PTR __imp_?Device@@3VCRenderDevice@@A
	sub	esp, 8
	mov	eax, DWORD PTR [eax+244]
	cmp	DWORD PTR [ecx+12], eax
	je	SHORT $LN14@get_hemi
; File I:\Vitalya\mine\NSProjectX\xrCore\vector.h

; 92   : 	if( val<_low ) val = _low; else if( val>_high ) val = _high;

	movss	xmm3, DWORD PTR __real@3f800000
	xorps	xmm0, xmm0
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\LightTrack.cpp

; 260  : 	dwFrameSmooth			=	Device.dwFrame					;

	mov	DWORD PTR [ecx+12], eax

; 261  : 	if (O && (0==result_count))	update(O)						;	// First time only
; 262  : 	float	l_f				=	Device.fTimeDelta*ps_r2_lt_smooth;

	mov	eax, DWORD PTR __imp_?Device@@3VCRenderDevice@@A
	movss	xmm2, DWORD PTR [eax+468]
; File I:\Vitalya\mine\NSProjectX\xrCore\vector.h

; 92   : 	if( val<_low ) val = _low; else if( val>_high ) val = _high;

	comiss	xmm0, xmm2
	jbe	SHORT $LN9@get_hemi
	movaps	xmm2, xmm0
	jmp	SHORT $LN11@get_hemi
$LN9@get_hemi:
	comiss	xmm2, xmm3
	jbe	SHORT $LN11@get_hemi
	movaps	xmm2, xmm3
$LN11@get_hemi:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\LightTrack.cpp

; 264  : 	float	l_i				=	1.f-l_f							;

	subss	xmm3, xmm2

; 265  : 	hemi_smooth				=	hemi_value*l_f + hemi_smooth*l_i;

	movaps	xmm1, xmm2
	mulss	xmm1, DWORD PTR [ecx+1932]

; 266  : 	sun_smooth				=	sun_value *l_f + sun_smooth *l_i;

	mulss	xmm2, DWORD PTR [ecx+1940]
	movaps	xmm0, xmm3
	mulss	xmm3, DWORD PTR [ecx+1944]
	mulss	xmm0, DWORD PTR [ecx+1936]
	addss	xmm2, xmm3
	addss	xmm1, xmm0
	movss	DWORD PTR [ecx+1944], xmm2
	movss	DWORD PTR $T1[esp+8], xmm1
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\LightTrack.h

; 68   : 	}

	fld	DWORD PTR $T1[esp+8]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\LightTrack.cpp

; 265  : 	hemi_smooth				=	hemi_value*l_f + hemi_smooth*l_i;

	movss	DWORD PTR [ecx+1936], xmm1
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\LightTrack.h

; 68   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
$LN14@get_hemi:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\LightTrack.cpp

; 266  : 	sun_smooth				=	sun_value *l_f + sun_smooth *l_i;

	movss	xmm0, DWORD PTR [ecx+1936]
	movss	DWORD PTR $T1[esp+8], xmm0
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\LightTrack.h

; 68   : 	}

	fld	DWORD PTR $T1[esp+8]
	mov	esp, ebp
	pop	ebp
	ret	0
?get_hemi@CROS_impl@@QAEMXZ ENDP			; CROS_impl::get_hemi
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\LightTrack.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\LightTrack.h
;	COMDAT ??1CROS_impl@@UAE@XZ
_TEXT	SEGMENT
??1CROS_impl@@UAE@XZ PROC				; CROS_impl::~CROS_impl, COMDAT
; _this$ = ecx

; 79   : 	virtual ~CROS_impl	()	{};

	push	esi
	mov	esi, ecx
	mov	DWORD PTR [esi], OFFSET ??_7CROS_impl@@6B@
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [esi+28]
	test	eax, eax
	je	SHORT $LN8@CROS_impl
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi+28], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+32], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+36], 0
$LN8@CROS_impl:

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [esi+16]
	test	eax, eax
	je	SHORT $LN29@CROS_impl
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi+16], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+20], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+24], 0
$LN29@CROS_impl:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\LightTrack.h

; 79   : 	virtual ~CROS_impl	()	{};

	mov	eax, DWORD PTR __imp_??_7IRender_ObjectSpecific@@6B@
	mov	DWORD PTR [esi], eax
	pop	esi
	ret	0
??1CROS_impl@@UAE@XZ ENDP				; CROS_impl::~CROS_impl
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\LightTrack.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrEngine\render.h
;	COMDAT ??_GCROS_impl@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCROS_impl@@UAEPAXI@Z PROC				; CROS_impl::`scalar deleting destructor', COMDAT
; _this$ = ecx
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\LightTrack.h

; 79   : 	virtual ~CROS_impl	()	{};

	push	esi
	mov	esi, ecx
	mov	DWORD PTR [esi], OFFSET ??_7CROS_impl@@6B@
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [esi+28]
	test	eax, eax
	je	SHORT $LN11@scalar
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi+28], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+32], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+36], 0
$LN11@scalar:

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [esi+16]
	test	eax, eax
	je	SHORT $LN23@scalar
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi+16], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+20], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+24], 0
$LN23@scalar:
	test	BYTE PTR ___flags$[esp], 1
; File I:\Vitalya\mine\NSProjectX\xrEngine\render.h

; 92   : 	virtual ~IRender_ObjectSpecific() {};

	mov	eax, DWORD PTR __imp_??_7IRender_ObjectSpecific@@6B@
	mov	DWORD PTR [esi], eax
	je	SHORT $LN32@scalar
	push	1960					; 000007a8H
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN32@scalar:
	mov	eax, esi
	pop	esi
	ret	4
??_GCROS_impl@@UAEPAXI@Z ENDP				; CROS_impl::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??1?$xr_vector@UItem@CROS_impl@@V?$xalloc@UItem@CROS_impl@@@@@@QAE@XZ
_TEXT	SEGMENT
??1?$xr_vector@UItem@CROS_impl@@V?$xalloc@UItem@CROS_impl@@@@@@QAE@XZ PROC ; xr_vector<CROS_impl::Item,xalloc<CROS_impl::Item> >::~xr_vector<CROS_impl::Item,xalloc<CROS_impl::Item> >, COMDAT
; _this$ = ecx

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	push	esi
	mov	esi, ecx
	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN6@xr_vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+4], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+8], 0
$LN6@xr_vector:
	pop	esi
	ret	0
??1?$xr_vector@UItem@CROS_impl@@V?$xalloc@UItem@CROS_impl@@@@@@QAE@XZ ENDP ; xr_vector<CROS_impl::Item,xalloc<CROS_impl::Item> >::~xr_vector<CROS_impl::Item,xalloc<CROS_impl::Item> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??1?$xr_vector@ULight@CROS_impl@@V?$xalloc@ULight@CROS_impl@@@@@@QAE@XZ
_TEXT	SEGMENT
??1?$xr_vector@ULight@CROS_impl@@V?$xalloc@ULight@CROS_impl@@@@@@QAE@XZ PROC ; xr_vector<CROS_impl::Light,xalloc<CROS_impl::Light> >::~xr_vector<CROS_impl::Light,xalloc<CROS_impl::Light> >, COMDAT
; _this$ = ecx

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	push	esi
	mov	esi, ecx
	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN6@xr_vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+4], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+8], 0
$LN6@xr_vector:
	pop	esi
	ret	0
??1?$xr_vector@ULight@CROS_impl@@V?$xalloc@ULight@CROS_impl@@@@@@QAE@XZ ENDP ; xr_vector<CROS_impl::Light,xalloc<CROS_impl::Light> >::~xr_vector<CROS_impl::Light,xalloc<CROS_impl::Light> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\LightTrack.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\LightTrack.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrEngine\xr_collide_defs.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\LightTrack.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\LightTrack.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\LightTrack.cpp
_TEXT	SEGMENT
??0CROS_impl@@QAE@XZ PROC				; CROS_impl::CROS_impl
; _this$ = ecx

; 21   : {

	push	esi
	mov	esi, ecx
	mov	edx, 26					; 0000001aH
	lea	ecx, DWORD PTR [esi+68]
	mov	DWORD PTR [esi], OFFSET ??_7CROS_impl@@6B@
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [esi+16], 0
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\LightTrack.cpp

; 21   : {

	lea	eax, DWORD PTR [ecx+20]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [esi+20], 0
	mov	DWORD PTR [esi+24], 0
	mov	DWORD PTR [esi+28], 0
	mov	DWORD PTR [esi+32], 0
	mov	DWORD PTR [esi+36], 0
	npad	2
$LL22@CROS_impl:
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 23   : 	ICF	SelfRef	set(T _x, T _y, T _z)					{ x = _x;		y = _y;		z = _z;		return *this;	};

	mov	DWORD PTR [ecx], 0
	lea	ecx, DWORD PTR [ecx+68]
	mov	DWORD PTR [eax-16], 0
	lea	eax, DWORD PTR [eax+68]
	mov	DWORD PTR [eax-80], 0
	mov	DWORD PTR [eax-76], 0
	mov	DWORD PTR [eax-72], 0
	mov	DWORD PTR [eax-68], 0
; File I:\Vitalya\mine\NSProjectX\xrEngine\xr_collide_defs.h

; 34   : 			range = 0;

	mov	DWORD PTR [eax-64], 0

; 35   : 			result = FALSE;

	mov	DWORD PTR [eax-60], 0
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 23   : 	ICF	SelfRef	set(T _x, T _y, T _z)					{ x = _x;		y = _y;		z = _z;		return *this;	};

	mov	DWORD PTR [eax-56], 0
	mov	DWORD PTR [eax-52], 0
	mov	DWORD PTR [eax-48], 0
	mov	DWORD PTR [eax-44], 0
	mov	DWORD PTR [eax-40], 0
	mov	DWORD PTR [eax-36], 0
	mov	DWORD PTR [eax-32], 0
	mov	DWORD PTR [eax-28], 0
	mov	DWORD PTR [eax-24], 0
	sub	edx, 1
	jne	$LL22@CROS_impl
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\LightTrack.cpp

; 21   : {

	lea	ecx, DWORD PTR [esi+1836]
	call	??0ray_cache@collide@@QAE@XZ		; collide::ray_cache::ray_cache
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 23   : 	ICF	SelfRef	set(T _x, T _y, T _z)					{ x = _x;		y = _y;		z = _z;		return *this;	};

	mov	DWORD PTR [esi+1948], 0
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\LightTrack.cpp

; 41   : }

	mov	eax, esi
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 23   : 	ICF	SelfRef	set(T _x, T _y, T _z)					{ x = _x;		y = _y;		z = _z;		return *this;	};

	mov	DWORD PTR [esi+1952], 0
	mov	DWORD PTR [esi+1956], 0
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\LightTrack.cpp

; 23   : 	dwFrame				= u32(-1);

	mov	DWORD PTR [esi+8], -1

; 24   : 	shadow_recv_frame	= u32(-1);

	mov	DWORD PTR [esi+1924], -1

; 25   : 	shadow_recv_slot	= -1;

	mov	DWORD PTR [esi+1928], -1

; 26   : 
; 27   : 	result_count		= 0;

	mov	DWORD PTR [esi+1904], 0

; 28   : 	result_iterator		= 0;

	mov	DWORD PTR [esi+1908], 0

; 29   : 	result_frame		= u32(-1);

	mov	DWORD PTR [esi+1912], -1

; 30   : 	result_sun			= 0;

	mov	DWORD PTR [esi+1916], 0

; 31   : 	hemi_value			= 0.5f;

	mov	DWORD PTR [esi+1932], 1056964608	; 3f000000H

; 32   : 	hemi_smooth			= 0.5f;

	mov	DWORD PTR [esi+1936], 1056964608	; 3f000000H

; 33   : 	sun_value			= 0.2f;

	mov	DWORD PTR [esi+1940], 1045220557	; 3e4ccccdH

; 34   : 	sun_smooth			= 0.2f;

	mov	DWORD PTR [esi+1944], 1045220557	; 3e4ccccdH

; 35   : 
; 36   : #if RENDER==R_R1
; 37   : 	MODE				= IRender_ObjectSpecific::TRACE_ALL											;

	mov	DWORD PTR [esi+4], 7

; 41   : }

	pop	esi
	ret	0
??0CROS_impl@@QAE@XZ ENDP				; CROS_impl::CROS_impl
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\LightTrack.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\LightTrack.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\LightTrack.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\LightTrack.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\LightTrack.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\LightTrack.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\LightTrack.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\LightTrack.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\LightTrack.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\LightTrack.cpp
_TEXT	SEGMENT
_this$1$ = -88						; size = 4
$T1 = -84						; size = 84
_source$ = 8						; size = 4
?add@CROS_impl@@QAEXPAVlight@@@Z PROC			; CROS_impl::add
; _this$ = ecx

; 44   : {

	sub	esp, 88					; 00000058H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	eax, DWORD PTR [ecx+16]

; 150  :         return _Ptr == _Right._Ptr;

	mov	edx, DWORD PTR [ecx+20]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\LightTrack.cpp

; 44   : {

	mov	DWORD PTR _this$1$[esp+88], ecx
	push	ebx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1463 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));

	lea	ebx, DWORD PTR [ecx+16]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\LightTrack.cpp

; 44   : {

	push	ebp

; 46   : 	for (xr_vector<Item>::iterator I=track.begin(); I!=track.end(); I++)	

	mov	ebp, DWORD PTR _source$[esp+92]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 150  :         return _Ptr == _Right._Ptr;

	cmp	eax, edx
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\LightTrack.cpp

; 46   : 	for (xr_vector<Item>::iterator I=track.begin(); I!=track.end(); I++)	

	je	SHORT $LN3@add
	npad	7
$LL4@add:

; 47   : 		if (source == I->source)	{ I->frame_touched = Device.dwFrame; return; }

	cmp	ebp, DWORD PTR [eax+4]
	je	SHORT $LN49@add
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 74   :         ++_Ptr;

	add	eax, 84					; 00000054H

; 150  :         return _Ptr == _Right._Ptr;

	cmp	eax, edx
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\LightTrack.cpp

; 46   : 	for (xr_vector<Item>::iterator I=track.begin(); I!=track.end(); I++)	

	jne	SHORT $LL4@add
$LN3@add:

; 48   : 
; 49   : 	// Register _new_
; 50   : 	track.push_back		(Item());

	push	84					; 00000054H
	lea	eax, DWORD PTR $T1[esp+100]
	push	0
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH
	lea	ecx, DWORD PTR $T1[esp+104]
	call	??0ray_cache@collide@@QAE@XZ		; collide::ray_cache::ray_cache
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 730  :         if (_Mylast != _My_data._Myend) {

	mov	eax, DWORD PTR [ebx+4]
	cmp	eax, DWORD PTR [ebx+8]
	je	SHORT $LN32@add
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	push	esi
	push	edi
	mov	ecx, 21					; 00000015H
	lea	esi, DWORD PTR $T1[esp+104]
	mov	edi, eax
	rep movsd
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 716  :         ++_Mylast;

	add	DWORD PTR [ebx+4], 84			; 00000054H
	pop	edi
	pop	esi

; 731  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

	jmp	SHORT $LN31@add
$LN49@add:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\LightTrack.cpp

; 47   : 		if (source == I->source)	{ I->frame_touched = Device.dwFrame; return; }

	mov	ecx, DWORD PTR __imp_?Device@@3VCRenderDevice@@A
	pop	ebp

; 59   : }

	pop	ebx
	mov	ecx, DWORD PTR [ecx+244]
	mov	DWORD PTR [eax], ecx
	add	esp, 88					; 00000058H
	ret	4
$LN32@add:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 734  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	lea	ecx, DWORD PTR $T1[esp+96]
	push	ecx
	push	eax
	mov	ecx, ebx
	call	??$_Emplace_reallocate@UItem@CROS_impl@@@?$vector@UItem@CROS_impl@@V?$xalloc@UItem@CROS_impl@@@@@std@@QAEPAUItem@CROS_impl@@QAU23@$$QAU23@@Z ; std::vector<CROS_impl::Item,xalloc<CROS_impl::Item> >::_Emplace_reallocate<CROS_impl::Item>
$LN31@add:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\LightTrack.cpp

; 52   : 	L.frame_touched		= Device.dwFrame;

	mov	eax, DWORD PTR __imp_?Device@@3VCRenderDevice@@A
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1611 :         return _My_data._Mylast[-1];

	mov	ecx, DWORD PTR _this$1$[esp+96]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\LightTrack.cpp

; 52   : 	L.frame_touched		= Device.dwFrame;

	mov	eax, DWORD PTR [eax+244]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1611 :         return _My_data._Mylast[-1];

	mov	ecx, DWORD PTR [ecx+20]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\LightTrack.cpp

; 53   : 	L.source			= source;

	mov	DWORD PTR [ecx-80], ebp
	pop	ebp
	mov	DWORD PTR [ecx-84], eax
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 23   : 	ICF	SelfRef	set(T _x, T _y, T _z)					{ x = _x;		y = _y;		z = _z;		return *this;	};

	mov	DWORD PTR [ecx-44], 0
	mov	DWORD PTR [ecx-40], 0
	mov	DWORD PTR [ecx-36], 0
	mov	DWORD PTR [ecx-32], 0
	mov	DWORD PTR [ecx-28], 0
	mov	DWORD PTR [ecx-24], 0
	mov	DWORD PTR [ecx-20], 0
	mov	DWORD PTR [ecx-16], 0
	mov	DWORD PTR [ecx-12], 0
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\LightTrack.cpp

; 57   : 	L.test				= 0.f;

	mov	DWORD PTR [ecx-8], 0

; 58   : 	L.energy			= 0.f;

	mov	DWORD PTR [ecx-4], 0

; 59   : }

	pop	ebx
	add	esp, 88					; 00000058H
	ret	4
?add@CROS_impl@@QAEXPAVlight@@@Z ENDP			; CROS_impl::add
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ??0Item@CROS_impl@@QAE@XZ
_TEXT	SEGMENT
??0Item@CROS_impl@@QAE@XZ PROC				; CROS_impl::Item::Item, COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	lea	ecx, DWORD PTR [esi+8]
	call	??0ray_cache@collide@@QAE@XZ		; collide::ray_cache::ray_cache
	mov	eax, esi
	pop	esi
	ret	0
??0Item@CROS_impl@@QAE@XZ ENDP				; CROS_impl::Item::Item
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\LightTrack.cpp
;	COMDAT ?pred_energy@@YA_NABULight@CROS_impl@@0@Z
_TEXT	SEGMENT
_L1$ = 8						; size = 4
_L2$ = 12						; size = 4
?pred_energy@@YA_NABULight@CROS_impl@@0@Z PROC		; pred_energy, COMDAT

; 61   : IC bool	pred_energy			(const CROS_impl::Light& L1, const CROS_impl::Light& L2)	{ return L1.energy>L2.energy; }

	mov	eax, DWORD PTR _L1$[esp-4]
	movss	xmm0, DWORD PTR [eax+4]
	mov	eax, DWORD PTR _L2$[esp-4]
	comiss	xmm0, DWORD PTR [eax+4]
	jbe	SHORT $LN3@pred_energ
	mov	al, 1
	ret	0
$LN3@pred_energ:
	xor	al, al
	ret	0
?pred_energy@@YA_NABULight@CROS_impl@@0@Z ENDP		; pred_energy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\LightTrack.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\LightTrack.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\LightTrack.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\LightTrack.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\LightTrack.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\LightTrack.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_random.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\LightTrack.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\LightTrack.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\LightTrack.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\LightTrack.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\LightTrack.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\LightTrack.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\LightTrack.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\LightTrack.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\LightTrack.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\LightTrack.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\LightTrack.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\LightTrack.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\LightTrack.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\LightTrack.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\LightTrack.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\LightTrack.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\LightTrack.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\LightTrack.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\LightTrack.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\LightTrack.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\LightTrack.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\LightTrack.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\LightTrack.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\LightTrack.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\LightTrack.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\LightTrack.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\LightTrack.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\LightTrack.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\LightTrack.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\LightTrack.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\LightTrack.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\LightTrack.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\LightTrack.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\LightTrack.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\LightTrack.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\LightTrack.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\LightTrack.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\LightTrack.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\LightTrack.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_random.h
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_random.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\LightTrack.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_random.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_random.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\LightTrack.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\LightTrack.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\LightTrack.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\LightTrack.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\LightTrack.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\LightTrack.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\LightTrack.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\vector.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\LightTrack.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\vector.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\LightTrack.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\vector.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\LightTrack.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_color.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\LightTrack.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\LightTrack.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\LightTrack.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_color.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\LightTrack.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_color.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\LightTrack.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_color.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\LightTrack.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\LightTrack.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\LightTrack.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\LightTrack.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_color.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\LightTrack.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\LightTrack.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\LightTrack.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_color.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\LightTrack.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\LightTrack.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\LightTrack.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\LightTrack.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\LightTrack.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\LightTrack.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\LightTrack.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\LightTrack.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\LightTrack.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\LightTrack.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\LightTrack.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\LightTrack.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\LightTrack.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\vector.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\LightTrack.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\LightTrack.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\LightTrack.cpp
_TEXT	SEGMENT
$T2 = -188						; size = 4
_id$1$ = -188						; size = 4
_o_it$1$ = -188						; size = 4
tv3739 = -188						; size = 4
_source$1$ = -184					; size = 4
tv3688 = -184						; size = 4
_this$1$ = -180						; size = 4
_bTraceLights$1$ = -180					; size = 4
tv3740 = -180						; size = 4
tv2354 = -180						; size = 4
_lacc$1$sroa$784$1$ = -176				; size = 4
__object$1$ = -176					; size = 4
_lacc$1$sroa$786$1$ = -172				; size = 4
_sun$1$ = -172						; size = 4
_radius$1$ = -168					; size = 4
tv3939 = -164						; size = 4
tv3935 = -164						; size = 4
tv1502 = -164						; size = 4
$T3 = -160						; size = 4
tv1500 = -160						; size = 4
_f$4 = -160						; size = 4
_xrL$1$ = -156						; size = 4
_this$1$ = -156						; size = 4
_position$ = -152					; size = 12
$T5 = -140						; size = 4
tv3447 = -140						; size = 4
$T6 = -136						; size = 4
_dt$1$ = -136						; size = 4
_bb_size$7 = -132					; size = 12
_direction$8 = -132					; size = 12
_direction$ = -132					; size = 12
_D$9 = -120						; size = 12
_direction$10 = -120					; size = 12
$T11 = -108						; size = 24
$T12 = -108						; size = 24
$T13 = -84						; size = 84
_O$ = 8							; size = 4
?update@CROS_impl@@QAEXPAVIRenderable@@@Z PROC		; CROS_impl::update
; _this$ = ecx

; 98   : {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	sub	esp, 192				; 000000c0H

; 99   : 	// clip & verify
; 100  : 	if					(dwFrame==Device.dwFrame)			return;

	mov	eax, DWORD PTR __imp_?Device@@3VCRenderDevice@@A
	push	esi
	push	edi
	mov	edi, ecx
	mov	eax, DWORD PTR [eax+244]
	mov	DWORD PTR _this$1$[esp+200], edi
	cmp	DWORD PTR [edi+8], eax
	je	$LN1@update

; 101  : 	dwFrame				= Device.dwFrame;
; 102  : 	if					(0==O)								return;

	mov	esi, DWORD PTR _O$[ebp]
	mov	DWORD PTR [edi+8], eax
	test	esi, esi
	je	$LN1@update

; 103  : 	if					(0==O->renderable.visual)			return;

	cmp	DWORD PTR [esi+68], 0
	je	$LN1@update

; 104  : 	VERIFY				(dynamic_cast<CROS_impl*>			(O->renderable_ROS()));
; 105  : 	float	dt			=	Device.fTimeDelta;

	mov	eax, DWORD PTR __imp_?Device@@3VCRenderDevice@@A

; 107  : 	CObject*	_object	= dynamic_cast<CObject*>	(O);

	push	0
	push	OFFSET ??_R0?AVCObject@@@8
	push	OFFSET ??_R0?AVIRenderable@@@8
	movss	xmm0, DWORD PTR [eax+468]
	push	0
	push	esi
	movss	DWORD PTR _dt$1$[esp+220], xmm0
	call	___RTDynamicCast

; 108  : 
; 109  : 	// select sample, randomize position inside object
; 110  : 	Fvector	position;	O->renderable.xform.transform_tiny	(position,O->renderable.visual->vis.sphere.P);

	mov	ecx, DWORD PTR [esi+68]
	add	esp, 20					; 00000014H
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 499  : 		dest.x = v.x*_11 + v.y*_21 + v.z*_31 + _41;

	movss	xmm1, DWORD PTR [esi+20]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\LightTrack.cpp

; 107  : 	CObject*	_object	= dynamic_cast<CObject*>	(O);

	mov	DWORD PTR __object$1$[esp+200], eax
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 499  : 		dest.x = v.x*_11 + v.y*_21 + v.z*_31 + _41;

	mulss	xmm1, DWORD PTR [ecx+12]
	movss	xmm0, DWORD PTR [ecx+8]
	mulss	xmm0, DWORD PTR [esi+4]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\LightTrack.cpp

; 113  : 	Fvector	direction;	direction.random_dir();

	push	DWORD PTR __imp_?Random@@3VCRandom@@A
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 499  : 		dest.x = v.x*_11 + v.y*_21 + v.z*_31 + _41;

	addss	xmm1, xmm0
	movss	xmm0, DWORD PTR [esi+36]
	mulss	xmm0, DWORD PTR [ecx+16]
	addss	xmm0, DWORD PTR [esi+52]
	addss	xmm1, xmm0

; 500  : 		dest.y = v.x*_12 + v.y*_22 + v.z*_32 + _42;
; 501  : 		dest.z = v.x*_13 + v.y*_23 + v.z*_33 + _43;

	movss	xmm0, DWORD PTR [esi+12]
	movss	DWORD PTR _position$[esp+204], xmm1
	movss	xmm2, DWORD PTR [ecx+12]
	movss	xmm4, DWORD PTR [ecx+8]
	movss	xmm1, DWORD PTR [esi+28]
	movss	xmm3, DWORD PTR [ecx+16]
	mulss	xmm0, xmm4
	mulss	xmm4, DWORD PTR [esi+8]
	mulss	xmm1, xmm2
	mulss	xmm2, DWORD PTR [esi+24]
	addss	xmm1, xmm0
	movss	xmm0, DWORD PTR [esi+44]
	mulss	xmm0, xmm3
	mulss	xmm3, DWORD PTR [esi+40]
	addss	xmm4, xmm2
	addss	xmm0, DWORD PTR [esi+60]
	addss	xmm3, DWORD PTR [esi+56]
	addss	xmm1, xmm0
	addss	xmm4, xmm3
	movss	DWORD PTR _position$[esp+212], xmm1
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\LightTrack.cpp

; 111  : 	float	radius;		radius	= O->renderable.visual->vis.sphere.R;

	movss	xmm0, DWORD PTR [ecx+20]

; 113  : 	Fvector	direction;	direction.random_dir();

	lea	ecx, DWORD PTR _direction$[esp+204]
	movss	DWORD PTR _radius$1$[esp+204], xmm0
	mulss	xmm0, DWORD PTR __real@3e99999a
	addss	xmm4, xmm0
	movss	DWORD PTR _position$[esp+208], xmm4
	call	?random_dir@?$_vector3@M@@QAEAAU1@AAVCRandom@@@Z ; _vector3<float>::random_dir
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 48   : 	ICF		T *			_get	() const							{	return p_;																					}

	mov	eax, DWORD PTR ?RImplementation@@3VCRender@@A+980
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\LightTrack.cpp

; 123  : 	if	(MODE & IRender_ObjectSpecific::TRACE_SUN)	{

	mov	ecx, DWORD PTR [edi+4]
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 48   : 	ICF		T *			_get	() const							{	return p_;																					}

	mov	eax, DWORD PTR [eax+16]
	mov	DWORD PTR _sun$1$[esp+200], eax
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\LightTrack.cpp

; 123  : 	if	(MODE & IRender_ObjectSpecific::TRACE_SUN)	{

	test	cl, 2
	je	$LN470@update

; 124  : 		if  (--result_sun	< 0)	{

	add	DWORD PTR [edi+1916], -1
	jns	$LN470@update
; File I:\Vitalya\mine\NSProjectX\xrCore\_random.h

; 33   : 	IC 	s32		randI	(s32 max)					{ VERIFY(max);  return randI()%max; }

	mov	ecx, DWORD PTR __imp_?Random@@3VCRandom@@A
	call	?randI@CRandom@@QAEHXZ			; CRandom::randI
	cdq
	mov	ecx, 7
	idiv	ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 24   : 	ICF SelfRef	set(const _vector3<float> &v)			{ x = T(v.x);	y = T(v.y);	z = T(v.z);	return *this;	};

	mov	eax, DWORD PTR _sun$1$[esp+200]
	movss	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\LightTrack.cpp

; 125  : 			result_sun		+=		::Random.randI(lt_hemisamples/4,lt_hemisamples/2)	;

	add	edx, 6
	add	DWORD PTR [edi+1916], edx

; 127  : 			sun_value		=	!(g_pGameLevel->ObjectSpace.RayTest(position,direction,500.f,collide::rqtBoth,&cache_sun,_object))?1.f:0.f;

	push	DWORD PTR __object$1$[esp+200]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 24   : 	ICF SelfRef	set(const _vector3<float> &v)			{ x = T(v.x);	y = T(v.y);	z = T(v.z);	return *this;	};

	movss	xmm4, DWORD PTR [eax+76]

; 49   : 	IC	SelfRef	invert()								{ x=-x; y=-y; z=-z;						return *this;	}

	movss	xmm2, DWORD PTR [eax+80]

; 24   : 	ICF SelfRef	set(const _vector3<float> &v)			{ x = T(v.x);	y = T(v.y);	z = T(v.z);	return *this;	};

	xorps	xmm4, xmm0

; 49   : 	IC	SelfRef	invert()								{ x=-x; y=-y; z=-z;						return *this;	}

	movss	xmm3, DWORD PTR [eax+84]
	xorps	xmm2, xmm0
	xorps	xmm3, xmm0
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\LightTrack.cpp

; 127  : 			sun_value		=	!(g_pGameLevel->ObjectSpace.RayTest(position,direction,500.f,collide::rqtBoth,&cache_sun,_object))?1.f:0.f;

	fld	DWORD PTR __real@43fa0000
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 190  : 		T mag=_sqrt(T(1)/(x*x + y*y + z*z));

	movaps	xmm1, xmm2
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\LightTrack.cpp

; 127  : 			sun_value		=	!(g_pGameLevel->ObjectSpace.RayTest(position,direction,500.f,collide::rqtBoth,&cache_sun,_object))?1.f:0.f;

	lea	eax, DWORD PTR [edi+1836]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 190  : 		T mag=_sqrt(T(1)/(x*x + y*y + z*z));

	mulss	xmm1, xmm2

; 49   : 	IC	SelfRef	invert()								{ x=-x; y=-y; z=-z;						return *this;	}

	movaps	xmm0, xmm4
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\LightTrack.cpp

; 127  : 			sun_value		=	!(g_pGameLevel->ObjectSpace.RayTest(position,direction,500.f,collide::rqtBoth,&cache_sun,_object))?1.f:0.f;

	push	eax
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 49   : 	IC	SelfRef	invert()								{ x=-x; y=-y; z=-z;						return *this;	}

	mulss	xmm0, xmm4
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\LightTrack.cpp

; 127  : 			sun_value		=	!(g_pGameLevel->ObjectSpace.RayTest(position,direction,500.f,collide::rqtBoth,&cache_sun,_object))?1.f:0.f;

	lea	eax, DWORD PTR _direction$10[esp+208]
	push	3
	push	ecx
	fstp	DWORD PTR [esp]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 190  : 		T mag=_sqrt(T(1)/(x*x + y*y + z*z));

	addss	xmm1, xmm0
	movaps	xmm0, xmm3
	mulss	xmm0, xmm3
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\LightTrack.cpp

; 127  : 			sun_value		=	!(g_pGameLevel->ObjectSpace.RayTest(position,direction,500.f,collide::rqtBoth,&cache_sun,_object))?1.f:0.f;

	push	eax
	lea	eax, DWORD PTR _position$[esp+220]
	push	eax
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 190  : 		T mag=_sqrt(T(1)/(x*x + y*y + z*z));

	addss	xmm1, xmm0
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\LightTrack.cpp

; 127  : 			sun_value		=	!(g_pGameLevel->ObjectSpace.RayTest(position,direction,500.f,collide::rqtBoth,&cache_sun,_object))?1.f:0.f;

	mov	eax, DWORD PTR __imp_?g_pGameLevel@@3PAVIGame_Level@@A
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 190  : 		T mag=_sqrt(T(1)/(x*x + y*y + z*z));

	movss	xmm0, DWORD PTR __real@3f800000
	divss	xmm0, xmm1
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h

; 764  :             return (float)sqrt(_X);

	sqrtss	xmm1, xmm0
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 190  : 		T mag=_sqrt(T(1)/(x*x + y*y + z*z));

	movaps	xmm0, xmm1
	mulss	xmm0, xmm4

; 191  : 		x *= mag;

	movss	DWORD PTR _direction$10[esp+224], xmm0
	movaps	xmm0, xmm1
	mulss	xmm0, xmm2

; 192  : 		y *= mag;

	mulss	xmm1, xmm3
	movss	DWORD PTR _direction$10[esp+228], xmm0

; 193  : 		z *= mag;

	movss	DWORD PTR _direction$10[esp+232], xmm1
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\LightTrack.cpp

; 127  : 			sun_value		=	!(g_pGameLevel->ObjectSpace.RayTest(position,direction,500.f,collide::rqtBoth,&cache_sun,_object))?1.f:0.f;

	mov	ecx, DWORD PTR [eax]
	add	ecx, 168				; 000000a8H
	call	DWORD PTR __imp_?RayTest@CObjectSpace@@QAEHABU?$_vector3@M@@0MW4rq_target@collide@@PAUray_cache@4@PAVCObject@@@Z
	test	eax, eax
	jne	SHORT $LN49@update
	movss	xmm0, DWORD PTR __real@3f800000
	jmp	SHORT $LN50@update
$LN49@update:
	xorps	xmm0, xmm0
$LN50@update:
	mov	ecx, DWORD PTR [edi+4]
	movss	DWORD PTR [edi+1940], xmm0
$LN470@update:

; 128  : 		}
; 129  : 	}
; 130  : 	
; 131  : 	// hemi-tracing
; 132  : 	bool	bFirstTime	=	(0==result_count);

	mov	eax, DWORD PTR [edi+1904]
	mov	DWORD PTR tv3740[esp+200], eax

; 133  : 	if	(MODE & IRender_ObjectSpecific::TRACE_HEMI)	{

	mov	DWORD PTR $T2[esp+200], eax
	test	cl, 4
	je	$LN6@update

; 134  : 		for (u32 it=0; it<(u32)ps_r2_dhemi_count;	it++)		{	// five samples per one frame

	fld	DWORD PTR __real@42480000
	mov	DWORD PTR tv3739[esp+200], 5
$LN7@update:

; 135  : 			u32	sample		=	0				;
; 136  : 			if	(result_count<lt_hemisamples)	{ sample=result_count; result_count++;							}

	mov	esi, DWORD PTR [edi+1904]
	cmp	esi, 26					; 0000001aH
	jge	SHORT $LN29@update
	lea	eax, DWORD PTR [esi+1]
	mov	DWORD PTR [edi+1904], eax
	jmp	SHORT $LN30@update
$LN29@update:

; 137  : 			else								{ sample=(result_iterator%lt_hemisamples); result_iterator++;	}

	mov	ecx, DWORD PTR [edi+1908]
	mov	esi, 26					; 0000001aH
	mov	eax, ecx
	xor	edx, edx
	div	esi
	lea	eax, DWORD PTR [ecx+1]
	mov	esi, edx
	mov	DWORD PTR [edi+1908], eax
$LN30@update:

; 138  : 
; 139  : 			// take sample
; 140  : 			Fvector	direction;	direction.set	(hdir[sample][0],hdir[sample][1],hdir[sample][2]).normalize	();

	lea	eax, DWORD PTR [esi+esi*2]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 23   : 	ICF	SelfRef	set(T _x, T _y, T _z)					{ x = _x;		y = _y;		z = _z;		return *this;	};

	movss	xmm2, DWORD PTR ?hdir@@3QAY02$$CBMA[eax*4]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\LightTrack.cpp

; 142  : 			result[sample]	=	!g_pGameLevel->ObjectSpace.RayTest(position,direction,50.f,collide::rqtStatic,&cache[sample],_object);

	lea	ecx, DWORD PTR [esi+1]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 23   : 	ICF	SelfRef	set(T _x, T _y, T _z)					{ x = _x;		y = _y;		z = _z;		return *this;	};

	movss	xmm3, DWORD PTR ?hdir@@3QAY02$$CBMA[eax*4+4]
	movaps	xmm0, xmm2
	movss	xmm4, DWORD PTR ?hdir@@3QAY02$$CBMA[eax*4+8]

; 190  : 		T mag=_sqrt(T(1)/(x*x + y*y + z*z));

	movaps	xmm1, xmm3

; 23   : 	ICF	SelfRef	set(T _x, T _y, T _z)					{ x = _x;		y = _y;		z = _z;		return *this;	};

	mulss	xmm0, xmm2
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\LightTrack.cpp

; 142  : 			result[sample]	=	!g_pGameLevel->ObjectSpace.RayTest(position,direction,50.f,collide::rqtStatic,&cache[sample],_object);

	mov	eax, ecx
	shl	eax, 4
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 190  : 		T mag=_sqrt(T(1)/(x*x + y*y + z*z));

	mulss	xmm1, xmm3
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\LightTrack.cpp

; 142  : 			result[sample]	=	!g_pGameLevel->ObjectSpace.RayTest(position,direction,50.f,collide::rqtStatic,&cache[sample],_object);

	add	eax, ecx
	push	DWORD PTR __object$1$[esp+200]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 190  : 		T mag=_sqrt(T(1)/(x*x + y*y + z*z));

	addss	xmm1, xmm0
	movaps	xmm0, xmm4
	mulss	xmm0, xmm4
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\LightTrack.cpp

; 142  : 			result[sample]	=	!g_pGameLevel->ObjectSpace.RayTest(position,direction,50.f,collide::rqtStatic,&cache[sample],_object);

	lea	eax, DWORD PTR [edi+eax*4]
	push	eax
	push	2
	push	ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 190  : 		T mag=_sqrt(T(1)/(x*x + y*y + z*z));

	addss	xmm1, xmm0
	movss	xmm0, DWORD PTR __real@3f800000
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\LightTrack.cpp

; 142  : 			result[sample]	=	!g_pGameLevel->ObjectSpace.RayTest(position,direction,50.f,collide::rqtStatic,&cache[sample],_object);

	fstp	DWORD PTR [esp]
	lea	eax, DWORD PTR _direction$8[esp+216]
	push	eax
	lea	eax, DWORD PTR _position$[esp+220]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 190  : 		T mag=_sqrt(T(1)/(x*x + y*y + z*z));

	divss	xmm0, xmm1
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\LightTrack.cpp

; 142  : 			result[sample]	=	!g_pGameLevel->ObjectSpace.RayTest(position,direction,50.f,collide::rqtStatic,&cache[sample],_object);

	push	eax
	mov	eax, DWORD PTR __imp_?g_pGameLevel@@3PAVIGame_Level@@A
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h

; 764  :             return (float)sqrt(_X);

	sqrtss	xmm1, xmm0
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 190  : 		T mag=_sqrt(T(1)/(x*x + y*y + z*z));

	movaps	xmm0, xmm1
	mulss	xmm0, xmm2

; 191  : 		x *= mag;

	movss	DWORD PTR _direction$8[esp+224], xmm0
	movaps	xmm0, xmm1
	mulss	xmm0, xmm3

; 192  : 		y *= mag;

	mulss	xmm1, xmm4
	movss	DWORD PTR _direction$8[esp+228], xmm0

; 193  : 		z *= mag;

	movss	DWORD PTR _direction$8[esp+232], xmm1
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\LightTrack.cpp

; 142  : 			result[sample]	=	!g_pGameLevel->ObjectSpace.RayTest(position,direction,50.f,collide::rqtStatic,&cache[sample],_object);

	mov	ecx, DWORD PTR [eax]
	add	ecx, 168				; 000000a8H
	call	DWORD PTR __imp_?RayTest@CObjectSpace@@QAEHABU?$_vector3@M@@0MW4rq_target@collide@@PAUray_cache@4@PAVCObject@@@Z
	fld	DWORD PTR __real@42480000
	test	eax, eax
	sete	al
	sub	DWORD PTR tv3739[esp+200], 1
	mov	BYTE PTR [esi+edi+40], al
	jne	$LN7@update

; 134  : 		for (u32 it=0; it<(u32)ps_r2_dhemi_count;	it++)		{	// five samples per one frame

	mov	eax, DWORD PTR [edi+1904]
	fstp	ST(0)
	mov	esi, DWORD PTR _O$[ebp]
	mov	DWORD PTR $T2[esp+200], eax
$LN6@update:

; 143  : 			//	Msg				("%d:-- %s",sample,result[sample]?"true":"false");
; 144  : 		}
; 145  : 	}
; 146  : 
; 147  : 	// hemi & sun: update and smooth
; 148  : //	float	l_f				=	dt*lt_smooth;
; 149  : //	float	l_i				=	1.f-l_f;
; 150  : 	int		_pass			=	0;

	xor	edx, edx

; 151  : 	for (int it=0; it<result_count; it++)	if (result[it])	_pass	++;

	xor	ecx, ecx
	test	eax, eax
	jle	SHORT $LN482@update

; 143  : 			//	Msg				("%d:-- %s",sample,result[sample]?"true":"false");
; 144  : 		}
; 145  : 	}
; 146  : 
; 147  : 	// hemi & sun: update and smooth
; 148  : //	float	l_f				=	dt*lt_smooth;
; 149  : //	float	l_i				=	1.f-l_f;
; 150  : 	int		_pass			=	0;

	mov	esi, DWORD PTR [edi+1904]
	npad	1
$LL10@update:

; 151  : 	for (int it=0; it<result_count; it++)	if (result[it])	_pass	++;

	cmp	BYTE PTR [edi+ecx+40], 0
	lea	eax, DWORD PTR [edx+1]
	cmove	eax, edx
	inc	ecx
	mov	edx, eax
	cmp	ecx, esi
	jl	SHORT $LL10@update
	mov	ecx, esi
	mov	esi, DWORD PTR _O$[ebp]
	jmp	SHORT $LN9@update
$LN482@update:
	mov	ecx, DWORD PTR $T2[esp+200]
$LN9@update:

; 152  : 	hemi_value				=	float	(_pass)/float(result_count?result_count:1);

	test	ecx, ecx
	mov	eax, 1
	cvtsi2ss xmm1, edx
	cmovne	eax, ecx

; 153  : 	hemi_value				*=	ps_r2_dhemi_scale;
; 154  : 	if (bFirstTime)			hemi_smooth		= hemi_value;

	cmp	DWORD PTR tv3740[esp+200], 0
	cvtsi2ss xmm0, eax
	divss	xmm1, xmm0
	movss	DWORD PTR [edi+1932], xmm1
	jne	SHORT $LN469@update
	movss	DWORD PTR [edi+1936], xmm1
$LN469@update:

; 155  : 	update_smooth			()	;

	push	0
	mov	ecx, edi
	call	?update_smooth@CROS_impl@@QAEXPAVIRenderable@@@Z ; CROS_impl::update_smooth

; 156  : 
; 157  : 	// light-tracing
; 158  : 	BOOL	bTraceLights	= MODE & IRender_ObjectSpecific::TRACE_LIGHTS;

	mov	eax, DWORD PTR [edi+4]

; 159  : 	if		((!O->renderable_ShadowGenerate()) && (!O->renderable_ShadowReceive()))	bTraceLights = FALSE;

	mov	ecx, esi
	and	eax, 1
	mov	DWORD PTR _bTraceLights$1$[esp+200], eax
	mov	eax, DWORD PTR [esi]
	mov	eax, DWORD PTR [eax+8]
	call	eax
	test	eax, eax
	jne	SHORT $LN33@update
	mov	eax, DWORD PTR [esi]
	mov	ecx, esi
	mov	eax, DWORD PTR [eax+12]
	call	eax
	test	eax, eax
	je	$LN34@update
$LN33@update:

; 160  : 	if		(bTraceLights)	{

	cmp	DWORD PTR _bTraceLights$1$[esp+200], 0
	je	$LN34@update

; 161  : 		// Select nearest lights
; 162  : 		Fvector					bb_size	=	{radius,radius,radius};
; 163  : 		g_SpatialSpace->q_box				(RImplementation.lstSpatial,0,STYPE_LIGHTSOURCE,position,bb_size);

	mov	ecx, DWORD PTR __imp_?g_SpatialSpace@@3PAVISpatial_DB@@A
	lea	eax, DWORD PTR _bb_size$7[esp+200]
	movss	xmm0, DWORD PTR _radius$1$[esp+200]
	push	eax
	lea	eax, DWORD PTR _position$[esp+204]
	movss	DWORD PTR _bb_size$7[esp+204], xmm0
	mov	ecx, DWORD PTR [ecx]
	push	eax
	push	2
	push	0
	push	OFFSET ?RImplementation@@3VCRender@@A+580
	movss	DWORD PTR _bb_size$7[esp+224], xmm0
	movss	DWORD PTR _bb_size$7[esp+228], xmm0
	call	DWORD PTR __imp_?q_box@ISpatial_DB@@QAEXAAV?$xr_vector@PAVISpatial@@V?$xalloc@PAVISpatial@@@@@@IIABU?$_vector3@M@@1@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	eax, DWORD PTR ?RImplementation@@3VCRender@@A+584
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\LightTrack.cpp

; 164  : 		for (u32 o_it=0; o_it<RImplementation.lstSpatial.size(); o_it++)	{

	xor	ecx, ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	edx, DWORD PTR ?RImplementation@@3VCRender@@A+580
	sub	eax, edx
	sar	eax, 2
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\LightTrack.cpp

; 164  : 		for (u32 o_it=0; o_it<RImplementation.lstSpatial.size(); o_it++)	{

	mov	DWORD PTR _o_it$1$[esp+200], ecx
	test	eax, eax
	je	$LN12@update
	npad	3
$LL13@update:

; 165  : 			ISpatial*	spatial		= RImplementation.lstSpatial[o_it];

	mov	ecx, DWORD PTR [edx+ecx*4]

; 166  : 			light*		source		= (light*)	(spatial->dcast_Light());

	mov	eax, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax+28]
	call	eax
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 287  : 	{	return (x-v.x)*(x-v.x) + (y-v.y)*(y-v.y) + (z-v.z)*(z-v.z);	}

	movss	xmm1, DWORD PTR _position$[esp+204]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\LightTrack.cpp

; 166  : 			light*		source		= (light*)	(spatial->dcast_Light());

	mov	ecx, eax
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 287  : 	{	return (x-v.x)*(x-v.x) + (y-v.y)*(y-v.y) + (z-v.z)*(z-v.z);	}

	movss	xmm2, DWORD PTR _position$[esp+200]
	movss	xmm0, DWORD PTR _position$[esp+208]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\LightTrack.cpp

; 166  : 			light*		source		= (light*)	(spatial->dcast_Light());

	mov	DWORD PTR _source$1$[esp+200], ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 287  : 	{	return (x-v.x)*(x-v.x) + (y-v.y)*(y-v.y) + (z-v.z)*(z-v.z);	}

	subss	xmm2, DWORD PTR [ecx+64]
	subss	xmm1, DWORD PTR [ecx+68]
	subss	xmm0, DWORD PTR [ecx+72]
	mulss	xmm2, xmm2
	mulss	xmm1, xmm1
	mulss	xmm0, xmm0
	addss	xmm2, xmm1
	addss	xmm2, xmm0
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\LightTrack.cpp

; 168  : 			float	R				= radius+source->range;

	movss	xmm0, DWORD PTR _radius$1$[esp+200]
	addss	xmm0, DWORD PTR [ecx+100]
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h

; 764  :             return (float)sqrt(_X);

	sqrtss	xmm1, xmm2
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\LightTrack.cpp

; 169  : 			if (position.distance_to(source->position) < R)		add	(source);

	comiss	xmm0, xmm1
	jbe	$LN11@update
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	eax, DWORD PTR [edi+16]

; 1463 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));

	lea	esi, DWORD PTR [edi+16]

; 150  :         return _Ptr == _Right._Ptr;

	mov	edx, DWORD PTR [edi+20]

; 1463 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));

	mov	DWORD PTR _this$1$[esp+200], esi

; 150  :         return _Ptr == _Right._Ptr;

	cmp	eax, edx
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\LightTrack.cpp

; 46   : 	for (xr_vector<Item>::iterator I=track.begin(); I!=track.end(); I++)	

	je	SHORT $LN130@update
	npad	2
$LL131@update:

; 47   : 		if (source == I->source)	{ I->frame_touched = Device.dwFrame; return; }

	cmp	ecx, DWORD PTR [eax+4]
	je	SHORT $LN449@update
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 74   :         ++_Ptr;

	add	eax, 84					; 00000054H

; 150  :         return _Ptr == _Right._Ptr;

	cmp	eax, edx
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\LightTrack.cpp

; 46   : 	for (xr_vector<Item>::iterator I=track.begin(); I!=track.end(); I++)	

	jne	SHORT $LL131@update
$LN130@update:

; 48   : 
; 49   : 	// Register _new_
; 50   : 	track.push_back		(Item());

	push	84					; 00000054H
	lea	eax, DWORD PTR $T13[esp+204]
	push	0
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH
	lea	ecx, DWORD PTR $T13[esp+208]
	call	??0ray_cache@collide@@QAE@XZ		; collide::ray_cache::ray_cache
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 730  :         if (_Mylast != _My_data._Myend) {

	mov	eax, DWORD PTR [esi+4]
	cmp	eax, DWORD PTR [esi+8]
	je	SHORT $LN159@update
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	edi, eax
	lea	esi, DWORD PTR $T13[esp+200]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 716  :         ++_Mylast;

	mov	eax, DWORD PTR _this$1$[esp+200]
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	ecx, 21					; 00000015H
	rep movsd
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 716  :         ++_Mylast;

	add	DWORD PTR [eax+4], 84			; 00000054H

; 731  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

	mov	edi, DWORD PTR _this$1$[esp+200]
	jmp	SHORT $LN158@update
$LN449@update:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\LightTrack.cpp

; 47   : 		if (source == I->source)	{ I->frame_touched = Device.dwFrame; return; }

	mov	ecx, DWORD PTR __imp_?Device@@3VCRenderDevice@@A
	mov	ecx, DWORD PTR [ecx+244]
	mov	DWORD PTR [eax], ecx
	jmp	SHORT $LN11@update
$LN159@update:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 734  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	lea	ecx, DWORD PTR $T13[esp+200]
	push	ecx
	push	eax
	mov	ecx, esi
	call	??$_Emplace_reallocate@UItem@CROS_impl@@@?$vector@UItem@CROS_impl@@V?$xalloc@UItem@CROS_impl@@@@@std@@QAEPAUItem@CROS_impl@@QAU23@$$QAU23@@Z ; std::vector<CROS_impl::Item,xalloc<CROS_impl::Item> >::_Emplace_reallocate<CROS_impl::Item>
$LN158@update:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\LightTrack.cpp

; 52   : 	L.frame_touched		= Device.dwFrame;

	mov	eax, DWORD PTR __imp_?Device@@3VCRenderDevice@@A
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1611 :         return _My_data._Mylast[-1];

	mov	ecx, DWORD PTR [edi+20]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\LightTrack.cpp

; 52   : 	L.frame_touched		= Device.dwFrame;

	mov	eax, DWORD PTR [eax+244]
	mov	DWORD PTR [ecx-84], eax

; 53   : 	L.source			= source;

	mov	eax, DWORD PTR _source$1$[esp+200]
	mov	DWORD PTR [ecx-80], eax
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 23   : 	ICF	SelfRef	set(T _x, T _y, T _z)					{ x = _x;		y = _y;		z = _z;		return *this;	};

	mov	DWORD PTR [ecx-44], 0
	mov	DWORD PTR [ecx-40], 0
	mov	DWORD PTR [ecx-36], 0
	mov	DWORD PTR [ecx-32], 0
	mov	DWORD PTR [ecx-28], 0
	mov	DWORD PTR [ecx-24], 0
	mov	DWORD PTR [ecx-20], 0
	mov	DWORD PTR [ecx-16], 0
	mov	DWORD PTR [ecx-12], 0
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\LightTrack.cpp

; 57   : 	L.test				= 0.f;

	mov	DWORD PTR [ecx-8], 0

; 58   : 	L.energy			= 0.f;

	mov	DWORD PTR [ecx-4], 0
$LN11@update:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	eax, DWORD PTR ?RImplementation@@3VCRender@@A+584
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\LightTrack.cpp

; 164  : 		for (u32 o_it=0; o_it<RImplementation.lstSpatial.size(); o_it++)	{

	mov	ecx, DWORD PTR _o_it$1$[esp+200]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	edx, DWORD PTR ?RImplementation@@3VCRender@@A+580
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\LightTrack.cpp

; 164  : 		for (u32 o_it=0; o_it<RImplementation.lstSpatial.size(); o_it++)	{

	inc	ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	sub	eax, edx
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\LightTrack.cpp

; 164  : 		for (u32 o_it=0; o_it<RImplementation.lstSpatial.size(); o_it++)	{

	mov	DWORD PTR _o_it$1$[esp+200], ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	sar	eax, 2
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\LightTrack.cpp

; 164  : 		for (u32 o_it=0; o_it<RImplementation.lstSpatial.size(); o_it++)	{

	cmp	ecx, eax
	jb	$LL13@update
$LN12@update:

; 170  : 		}
; 171  : 
; 172  : 		// Trace visibility
; 173  : 		lights.clear	();

	mov	eax, DWORD PTR [edi+28]
	lea	esi, DWORD PTR [edi+28]

; 174  : 		float traceR	= radius*.5f;

	movss	xmm0, DWORD PTR _radius$1$[esp+200]
	mulss	xmm0, DWORD PTR __real@3f000000
	mov	DWORD PTR [esi+4], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	eax, DWORD PTR [edi+20]
	mov	ecx, DWORD PTR [edi+16]
	sub	eax, ecx
	sar	eax, 2
	imul	eax, eax, 1022611261
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\LightTrack.cpp

; 174  : 		float traceR	= radius*.5f;

	movss	DWORD PTR _radius$1$[esp+200], xmm0
	movss	DWORD PTR tv2354[esp+200], xmm0

; 175  : 		for (s32 id=0; id<s32(track.size()); id++)

	mov	DWORD PTR _id$1$[esp+200], 0
	test	eax, eax
	jle	$LN18@update
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1535 :         auto& _My_data = _Mypair._Myval2;

	fld	DWORD PTR tv2354[esp+200]
	xor	eax, eax
	fld	DWORD PTR __real@38c9116d
	fld	DWORD PTR __real@3949116d
	mov	DWORD PTR tv3688[esp+200], eax
$LN19@update:

; 119  :         _Ptr += _Off;

	lea	esi, DWORD PTR [eax+ecx]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\LightTrack.cpp

; 179  : 			if (I->frame_touched!=Device.dwFrame)	{ track.erase(I) ; id--	; continue ; }

	mov	eax, DWORD PTR __imp_?Device@@3VCRenderDevice@@A
	mov	ecx, DWORD PTR [esi]
	cmp	ecx, DWORD PTR [eax+244]
	je	SHORT $LN36@update
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility

; 4065 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	mov	eax, DWORD PTR [edi+20]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1406 :         _Move_unchecked(_Whereptr + 1, _Mylast, _Whereptr);

	lea	ecx, DWORD PTR [esi+84]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility

; 4065 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	sub	eax, ecx
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\LightTrack.cpp

; 179  : 			if (I->frame_touched!=Device.dwFrame)	{ track.erase(I) ; id--	; continue ; }

	fstp	ST(1)
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility

; 4066 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	push	eax
	push	ecx
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\LightTrack.cpp

; 179  : 			if (I->frame_touched!=Device.dwFrame)	{ track.erase(I) ; id--	; continue ; }

	fstp	ST(0)
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility

; 4066 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	push	esi
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\LightTrack.cpp

; 179  : 			if (I->frame_touched!=Device.dwFrame)	{ track.erase(I) ; id--	; continue ; }

	fstp	ST(0)
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility

; 4066 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	call	_memmove
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\LightTrack.cpp

; 179  : 			if (I->frame_touched!=Device.dwFrame)	{ track.erase(I) ; id--	; continue ; }

	mov	edx, DWORD PTR _id$1$[esp+212]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility

; 4066 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	add	esp, 12					; 0000000cH
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\LightTrack.cpp

; 179  : 			if (I->frame_touched!=Device.dwFrame)	{ track.erase(I) ; id--	; continue ; }

	mov	eax, DWORD PTR tv3688[esp+200]
	dec	edx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1408 :         --_Mylast;

	add	DWORD PTR [edi+20], -84			; ffffffacH
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\LightTrack.cpp

; 179  : 			if (I->frame_touched!=Device.dwFrame)	{ track.erase(I) ; id--	; continue ; }

	sub	eax, 84					; 00000054H
	jmp	$LN17@update
$LN36@update:

; 180  : 
; 181  : 			// Trace visibility
; 182  : 			Fvector				P,D;
; 183  : 			float		amount	= 0;
; 184  : 			light*		xrL		= I->source;

	mov	edx, DWORD PTR [esi+4]

; 185  : 			Fvector&	LP		= xrL->position;
; 186  : 			P.mad				(position,P.random_dir(),traceR);		// Random point inside range

	mov	ecx, DWORD PTR __imp_?Random@@3VCRandom@@A
	mov	DWORD PTR _xrL$1$[esp+200], edx
	add	edx, 64					; 00000040H
; File I:\Vitalya\mine\NSProjectX\xrCore\_random.h

; 39   : 	IC 	float	randF	()							{ return float(randI())/maxF();	}

	call	?randI@CRandom@@QAEHXZ			; CRandom::randI
	mov	DWORD PTR tv3939[esp+200], eax
	fild	DWORD PTR tv3939[esp+200]

; 40   : 	IC 	float	randF	(float max)					{ return randF()*max; }

	fmulp	ST(2), ST(0)
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h

; 653  :             return (float)cos(_X);

	fxch	ST(1)
	fcos
	fst	DWORD PTR tv3447[esp+200]
; File I:\Vitalya\mine\NSProjectX\xrCore\_random.h

; 39   : 	IC 	float	randF	()							{ return float(randI())/maxF();	}

	call	?randI@CRandom@@QAEHXZ			; CRandom::randI
	mov	DWORD PTR tv3935[esp+200], eax
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\LightTrack.cpp

; 190  : 			if (g_pGameLevel->ObjectSpace.RayTest(LP,D.div(f),f,collide::rqtStatic,&I->cache,_object))	amount -=	lt_dec;

	lea	eax, DWORD PTR [esi+8]
; File I:\Vitalya\mine\NSProjectX\xrCore\_random.h

; 39   : 	IC 	float	randF	()							{ return float(randI())/maxF();	}

	fild	DWORD PTR tv3935[esp+200]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 145  : 		y = p.y + d.y*m;

	movss	xmm4, DWORD PTR tv3447[esp+200]
; File I:\Vitalya\mine\NSProjectX\xrCore\_random.h

; 40   : 	IC 	float	randF	(float max)					{ return randF()*max; }

	fmulp	ST(2), ST(0)
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 145  : 		y = p.y + d.y*m;

	mulss	xmm4, xmm0
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\LightTrack.cpp

; 190  : 			if (g_pGameLevel->ObjectSpace.RayTest(LP,D.div(f),f,collide::rqtStatic,&I->cache,_object))	amount -=	lt_dec;

	push	DWORD PTR __object$1$[esp+200]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 236  : 		T a = R.randF(PI_MUL_2);

	fmul	ST(0), ST(0)

; 237  : 		T r = _sqrt(1-z*z);

	fld1

; 146  : 		z = p.z + d.z*m;

	addss	xmm4, DWORD PTR _position$[esp+212]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\LightTrack.cpp

; 190  : 			if (g_pGameLevel->ObjectSpace.RayTest(LP,D.div(f),f,collide::rqtStatic,&I->cache,_object))	amount -=	lt_dec;

	push	eax
	push	2
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 237  : 		T r = _sqrt(1-z*z);

	fsubrp	ST(1), ST(0)
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\LightTrack.cpp

; 190  : 			if (g_pGameLevel->ObjectSpace.RayTest(LP,D.div(f),f,collide::rqtStatic,&I->cache,_object))	amount -=	lt_dec;

	push	ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	subss	xmm4, DWORD PTR [edx+8]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\LightTrack.cpp

; 190  : 			if (g_pGameLevel->ObjectSpace.RayTest(LP,D.div(f),f,collide::rqtStatic,&I->cache,_object))	amount -=	lt_dec;

	lea	eax, DWORD PTR _D$9[esp+216]
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h

; 764  :             return (float)sqrt(_X);

	fsqrt

; 653  :             return (float)cos(_X);

	fld	ST(1)
	fcos
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 240  : 		x	= r * ca;

	fmul	ST(0), ST(1)

; 241  : 		y	= r * sa;

	fmul	ST(0), ST(3)

; 144  : 		x = p.x + d.x*m;

	fadd	DWORD PTR _position$[esp+216]

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	fsub	DWORD PTR [edx]
	fstp	DWORD PTR tv1502[esp+216]
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h

; 754  :             return (float)sin(_X);

	fxch	ST(1)
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 167  : 		return x*x + y*y + z*z;

	movss	xmm2, DWORD PTR tv1502[esp+216]
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h

; 754  :             return (float)sin(_X);

	fsin
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 167  : 		return x*x + y*y + z*z;

	movaps	xmm1, xmm2

; 241  : 		y	= r * sa;

	fmulp	ST(1), ST(0)

; 167  : 		return x*x + y*y + z*z;

	mulss	xmm1, xmm2

; 144  : 		x = p.x + d.x*m;

	fmulp	ST(1), ST(0)

; 145  : 		y = p.y + d.y*m;

	fadd	DWORD PTR _position$[esp+220]

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	fsub	DWORD PTR [edx+4]
	fstp	DWORD PTR tv1500[esp+216]
	movss	xmm3, DWORD PTR tv1500[esp+216]
	movaps	xmm0, xmm3
	mulss	xmm0, xmm3

; 167  : 		return x*x + y*y + z*z;

	addss	xmm1, xmm0
	movaps	xmm0, xmm4
	mulss	xmm0, xmm4
	addss	xmm1, xmm0
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h

; 764  :             return (float)sqrt(_X);

	sqrtss	xmm0, xmm1
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 45   : 	ICF SelfRef	div(T s)								{ x/=s;		y/=s;    z/=s;				return *this;	};

	movss	xmm1, DWORD PTR __real@3f800000
	divss	xmm1, xmm0
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\LightTrack.cpp

; 189  : 			float	f			=	D.sub(P,LP).magnitude();

	movss	DWORD PTR _f$4[esp+216], xmm0

; 190  : 			if (g_pGameLevel->ObjectSpace.RayTest(LP,D.div(f),f,collide::rqtStatic,&I->cache,_object))	amount -=	lt_dec;

	fld	DWORD PTR _f$4[esp+216]
	fstp	DWORD PTR [esp]
	push	eax
	mov	eax, DWORD PTR __imp_?g_pGameLevel@@3PAVIGame_Level@@A
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 45   : 	ICF SelfRef	div(T s)								{ x/=s;		y/=s;    z/=s;				return *this;	};

	mulss	xmm2, xmm1
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\LightTrack.cpp

; 190  : 			if (g_pGameLevel->ObjectSpace.RayTest(LP,D.div(f),f,collide::rqtStatic,&I->cache,_object))	amount -=	lt_dec;

	push	edx
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 45   : 	ICF SelfRef	div(T s)								{ x/=s;		y/=s;    z/=s;				return *this;	};

	mulss	xmm3, xmm1
	mulss	xmm4, xmm1
	movss	DWORD PTR _D$9[esp+224], xmm2
	movss	DWORD PTR _D$9[esp+228], xmm3
	movss	DWORD PTR _D$9[esp+232], xmm4
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\LightTrack.cpp

; 190  : 			if (g_pGameLevel->ObjectSpace.RayTest(LP,D.div(f),f,collide::rqtStatic,&I->cache,_object))	amount -=	lt_dec;

	mov	ecx, DWORD PTR [eax]
	add	ecx, 168				; 000000a8H
	call	DWORD PTR __imp_?RayTest@CObjectSpace@@QAEHABU?$_vector3@M@@0MW4rq_target@collide@@PAUray_cache@4@PAVCObject@@@Z
	test	eax, eax
	je	SHORT $LN37@update
	movss	xmm1, DWORD PTR __real@c0000000
	jmp	SHORT $LN38@update
$LN37@update:

; 191  : 			else																						amount +=	lt_inc;

	movss	xmm1, DWORD PTR __real@40800000
$LN38@update:

; 192  : 			I->test				+=	amount * dt;	clamp	(I->test,-.5f,1.f);

	mulss	xmm1, DWORD PTR _dt$1$[esp+200]
; File I:\Vitalya\mine\NSProjectX\xrCore\vector.h

; 92   : 	if( val<_low ) val = _low; else if( val>_high ) val = _high;

	movss	xmm0, DWORD PTR __real@bf000000
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\LightTrack.cpp

; 192  : 			I->test				+=	amount * dt;	clamp	(I->test,-.5f,1.f);

	addss	xmm1, DWORD PTR [esi+76]
; File I:\Vitalya\mine\NSProjectX\xrCore\vector.h

; 92   : 	if( val<_low ) val = _low; else if( val>_high ) val = _high;

	comiss	xmm0, xmm1
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\LightTrack.cpp

; 192  : 			I->test				+=	amount * dt;	clamp	(I->test,-.5f,1.f);

	movss	DWORD PTR [esi+76], xmm1
; File I:\Vitalya\mine\NSProjectX\xrCore\vector.h

; 92   : 	if( val<_low ) val = _low; else if( val>_high ) val = _high;

	jbe	SHORT $LN249@update
	mov	DWORD PTR [esi+76], -1090519040		; bf000000H
	jmp	SHORT $LN496@update
$LN249@update:
	movss	xmm0, DWORD PTR __real@3f800000
	comiss	xmm1, xmm0
	jbe	SHORT $LN251@update
	mov	DWORD PTR [esi+76], 1065353216		; 3f800000H
$LN496@update:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\LightTrack.cpp

; 193  : 			I->energy			=	.9f*I->energy + .1f*I->test;

	movaps	xmm1, xmm0
$LN251@update:
	movss	xmm0, DWORD PTR [esi+80]
	mulss	xmm0, DWORD PTR __real@3f666666
	mov	edx, DWORD PTR _xrL$1$[esp+200]
	mulss	xmm1, DWORD PTR __real@3dcccccd
	addss	xmm1, xmm0
	movss	DWORD PTR [esi+80], xmm1
	movss	xmm0, DWORD PTR [edx+112]
	addss	xmm0, DWORD PTR [edx+108]
; File I:\Vitalya\mine\NSProjectX\xrCore\_color.h

; 203  : 		return (r + g + b)/3.f;

	addss	xmm0, DWORD PTR [edx+116]
	mulss	xmm0, DWORD PTR __real@3eaaaaab
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\LightTrack.cpp

; 196  : 			float	E			=	I->energy * xrL->color.intensity	();

	mulss	xmm0, xmm1

; 197  : 			if (E > EPS)		{

	comiss	xmm0, DWORD PTR __real@3727c5ac
	jbe	$LN480@update

; 199  : 				lights.push_back			(CROS_impl::Light())		;

	xor	eax, eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 730  :         if (_Mylast != _My_data._Myend) {

	lea	ecx, DWORD PTR [edi+28]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\LightTrack.cpp

; 199  : 				lights.push_back			(CROS_impl::Light())		;

	mov	DWORD PTR $T12[esp+200], eax
	mov	DWORD PTR $T12[esp+204], eax
	mov	DWORD PTR $T12[esp+208], eax
	mov	DWORD PTR $T12[esp+212], eax
	mov	DWORD PTR $T12[esp+216], eax
	mov	DWORD PTR $T12[esp+220], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 730  :         if (_Mylast != _My_data._Myend) {

	mov	eax, DWORD PTR [ecx+4]
	cmp	eax, DWORD PTR [ecx+8]
	je	SHORT $LN258@update
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	DWORD PTR [eax], 0
	mov	DWORD PTR [eax+4], 0
	mov	DWORD PTR [eax+8], 0
	mov	DWORD PTR [eax+12], 0
	mov	DWORD PTR [eax+16], 0
	mov	DWORD PTR [eax+20], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 716  :         ++_Mylast;

	add	DWORD PTR [ecx+4], 24			; 00000018H

; 731  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

	jmp	SHORT $LN257@update
$LN258@update:

; 734  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	lea	edx, DWORD PTR $T12[esp+200]
	push	edx
	push	eax
	call	??$_Emplace_reallocate@ULight@CROS_impl@@@?$vector@ULight@CROS_impl@@V?$xalloc@ULight@CROS_impl@@@@@std@@QAEPAULight@CROS_impl@@QAU23@$$QAU23@@Z ; std::vector<CROS_impl::Light,xalloc<CROS_impl::Light> >::_Emplace_reallocate<CROS_impl::Light>
	mov	edx, DWORD PTR _xrL$1$[esp+200]
$LN257@update:

; 1611 :         return _My_data._Mylast[-1];

	mov	eax, DWORD PTR [edi+32]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\LightTrack.cpp

; 202  : 				L.color.mul_rgb				(xrL->color,I->energy/2)	;

	movss	xmm3, DWORD PTR __real@3f000000
	mov	DWORD PTR [eax-24], edx
	movss	xmm1, DWORD PTR [esi+80]
	mulss	xmm1, xmm3
; File I:\Vitalya\mine\NSProjectX\xrCore\_color.h

; 188  : 		r=c.r*s;

	movaps	xmm2, xmm1

; 189  : 		g=c.g*s;

	movaps	xmm0, xmm1
	mulss	xmm2, DWORD PTR [edx+108]
	movss	DWORD PTR [eax-16], xmm2
	mulss	xmm0, DWORD PTR [edx+112]
	movss	DWORD PTR [eax-12], xmm0

; 190  : 		b=c.b*s;

	mulss	xmm1, DWORD PTR [edx+116]
	movss	DWORD PTR [eax-8], xmm1
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\LightTrack.cpp

; 203  : 				L.energy					= I->energy/2				;

	movss	xmm1, DWORD PTR [esi+80]
	mulss	xmm1, xmm3
	movss	DWORD PTR [eax-20], xmm1

; 204  : 				if (!xrL->flags.bStatic)	{ L.color.mul_rgb(.5f); L.energy *= .5f; }

	test	BYTE PTR [edx+60], 16			; 00000010H
	mov	edx, DWORD PTR _id$1$[esp+200]
	jne	SHORT $LN481@update
; File I:\Vitalya\mine\NSProjectX\xrCore\_color.h

; 174  : 		g*=s;

	mulss	xmm0, xmm3
	mulss	xmm2, xmm3
	movss	DWORD PTR [eax-12], xmm0

; 175  : 		b*=s;

	movss	xmm0, DWORD PTR [eax-8]
	mulss	xmm0, xmm3
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\LightTrack.cpp

; 204  : 				if (!xrL->flags.bStatic)	{ L.color.mul_rgb(.5f); L.energy *= .5f; }

	mulss	xmm1, xmm3
; File I:\Vitalya\mine\NSProjectX\xrCore\_color.h

; 173  : 		r*=s;

	movss	DWORD PTR [eax-16], xmm2

; 175  : 		b*=s;

	movss	DWORD PTR [eax-8], xmm0
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\LightTrack.cpp

; 204  : 				if (!xrL->flags.bStatic)	{ L.color.mul_rgb(.5f); L.energy *= .5f; }

	movss	DWORD PTR [eax-20], xmm1
	jmp	SHORT $LN481@update
$LN480@update:

; 197  : 			if (E > EPS)		{

	mov	edx, DWORD PTR _id$1$[esp+200]
$LN481@update:

; 175  : 		for (s32 id=0; id<s32(track.size()); id++)

	mov	eax, DWORD PTR tv3688[esp+200]
$LN17@update:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	ecx, DWORD PTR [edi+16]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\LightTrack.cpp

; 175  : 		for (s32 id=0; id<s32(track.size()); id++)

	add	eax, 84					; 00000054H
	fld	DWORD PTR tv2354[esp+200]
	inc	edx
	fld	DWORD PTR __real@38c9116d
	movss	xmm0, DWORD PTR _radius$1$[esp+200]
	fld	DWORD PTR __real@3949116d
	mov	DWORD PTR tv3688[esp+200], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	eax, DWORD PTR [edi+20]
	sub	eax, ecx
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\LightTrack.cpp

; 175  : 		for (s32 id=0; id<s32(track.size()); id++)

	mov	DWORD PTR _id$1$[esp+200], edx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	sar	eax, 2
	imul	eax, eax, 1022611261
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\LightTrack.cpp

; 175  : 		for (s32 id=0; id<s32(track.size()); id++)

	cmp	edx, eax
	mov	eax, DWORD PTR tv3688[esp+200]
	jl	$LN19@update
	fstp	ST(1)
	lea	esi, DWORD PTR [edi+28]
	fstp	ST(0)
	fstp	ST(0)
$LN18@update:
; File I:\Vitalya\mine\NSProjectX\xrCore\_color.h

; 203  : 		return (r + g + b)/3.f;

	mov	ecx, DWORD PTR _sun$1$[esp+200]
	movss	xmm0, DWORD PTR [ecx+112]
	addss	xmm0, DWORD PTR [ecx+108]
	addss	xmm0, DWORD PTR [ecx+116]
	mulss	xmm0, DWORD PTR __real@3eaaaaab
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\LightTrack.cpp

; 209  : 		float	E			=	sun_smooth * sun->color.intensity	();

	mulss	xmm0, DWORD PTR [edi+1944]

; 210  : 		if (E > EPS)		{

	comiss	xmm0, DWORD PTR __real@3727c5ac
	jbe	$LN41@update
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 730  :         if (_Mylast != _My_data._Myend) {

	mov	eax, DWORD PTR [esi+4]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\LightTrack.cpp

; 212  : 			lights.push_back			(CROS_impl::Light())		;

	xor	edx, edx
	mov	DWORD PTR $T11[esp+200], edx
	mov	DWORD PTR $T11[esp+204], edx
	mov	DWORD PTR $T11[esp+208], edx
	mov	DWORD PTR $T11[esp+212], edx
	mov	DWORD PTR $T11[esp+216], edx
	mov	DWORD PTR $T11[esp+220], edx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 730  :         if (_Mylast != _My_data._Myend) {

	cmp	eax, DWORD PTR [esi+8]
	je	SHORT $LN277@update
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	DWORD PTR [eax], edx
	mov	DWORD PTR [eax+4], edx
	mov	DWORD PTR [eax+8], edx
	mov	DWORD PTR [eax+12], edx
	mov	DWORD PTR [eax+16], edx
	mov	DWORD PTR [eax+20], edx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 716  :         ++_Mylast;

	add	DWORD PTR [esi+4], 24			; 00000018H

; 731  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

	jmp	SHORT $LN276@update
$LN277@update:

; 734  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	lea	ecx, DWORD PTR $T11[esp+200]
	push	ecx
	push	eax
	mov	ecx, esi
	call	??$_Emplace_reallocate@ULight@CROS_impl@@@?$vector@ULight@CROS_impl@@V?$xalloc@ULight@CROS_impl@@@@@std@@QAEPAULight@CROS_impl@@QAU23@$$QAU23@@Z ; std::vector<CROS_impl::Light,xalloc<CROS_impl::Light> >::_Emplace_reallocate<CROS_impl::Light>
	mov	ecx, DWORD PTR _sun$1$[esp+200]
$LN276@update:

; 1611 :         return _My_data._Mylast[-1];

	mov	eax, DWORD PTR [edi+32]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\LightTrack.cpp

; 214  : 			L.source					= sun						;

	mov	DWORD PTR [eax-24], ecx

; 215  : 			L.color.mul_rgb				(sun->color,sun_smooth/2)	;

	movss	xmm1, DWORD PTR [edi+1944]
	mulss	xmm1, DWORD PTR __real@3f000000
; File I:\Vitalya\mine\NSProjectX\xrCore\_color.h

; 188  : 		r=c.r*s;

	movaps	xmm0, xmm1
	mulss	xmm0, DWORD PTR [ecx+108]
	movss	DWORD PTR [eax-16], xmm0

; 189  : 		g=c.g*s;

	movaps	xmm0, xmm1
	mulss	xmm0, DWORD PTR [ecx+112]
	movss	DWORD PTR [eax-12], xmm0

; 190  : 		b=c.b*s;

	mulss	xmm1, DWORD PTR [ecx+116]
	movss	DWORD PTR [eax-8], xmm1
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\LightTrack.cpp

; 216  : 			L.energy					= sun_smooth				;

	fld	DWORD PTR [edi+1944]
	fstp	DWORD PTR [eax-20]
$LN41@update:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 7079 :     const auto _ULast  = _Get_unwrapped(_Last);

	mov	edx, DWORD PTR [edi+32]

; 7080 :     _Sort_unchecked(_UFirst, _ULast, _ULast - _UFirst, _Pass_fn(_Pred));

	mov	eax, edx
	mov	ecx, DWORD PTR [esi]
	sub	eax, ecx
	sar	eax, 3
	imul	eax, eax, -1431655765
	push	OFFSET ?pred_energy@@YA_NABULight@CROS_impl@@0@Z ; pred_energy
	push	eax
	call	??$_Sort_unchecked@PAULight@CROS_impl@@P6A_NABU12@0@Z@std@@YAXPAULight@CROS_impl@@0HP6A_NABU12@1@Z@Z ; std::_Sort_unchecked<CROS_impl::Light *,bool (__cdecl*)(CROS_impl::Light const &,CROS_impl::Light const &)>
	add	esp, 8
$LN34@update:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\LightTrack.cpp

; 225  : 	CEnvDescriptor*	desc	=	g_pGamePersistent->Environment().CurrentEnv;

	mov	eax, DWORD PTR __imp_?g_pGamePersistent@@3PAVIGame_Persistent@@A

; 229  : 	if (MODE & IRender_ObjectSpecific::TRACE_HEMI	)	hemi.mul(hemi_smooth); else hemi.mul(.2f);

	mov	ecx, DWORD PTR [edi+4]
	movss	xmm4, DWORD PTR __real@3e4ccccd
	mov	eax, DWORD PTR [eax]
	mov	eax, DWORD PTR [eax+1116]
	mov	eax, DWORD PTR [eax+440]
	test	cl, 4
	je	SHORT $LN42@update
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 40   : 	ICF SelfRef	mul(T s)								{ x*=s;		y*=s;		z*=s;			return *this;	};

	movss	xmm0, DWORD PTR [edi+1936]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\LightTrack.cpp

; 229  : 	if (MODE & IRender_ObjectSpecific::TRACE_HEMI	)	hemi.mul(hemi_smooth); else hemi.mul(.2f);

	jmp	SHORT $LN43@update
$LN42@update:
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 40   : 	ICF SelfRef	mul(T s)								{ x*=s;		y*=s;		z*=s;			return *this;	};

	movaps	xmm0, xmm4
$LN43@update:

; 29   : 	ICF	SelfRef	add(const Self &v)						{ x+=v.x;	y+=v.y;		z+=v.z;			return *this;	};

	movaps	xmm1, xmm0
	movaps	xmm2, xmm0
	mulss	xmm1, DWORD PTR [eax+132]
	mulss	xmm2, DWORD PTR [eax+136]
	mulss	xmm0, DWORD PTR [eax+140]
	addss	xmm1, DWORD PTR [eax+120]
	addss	xmm2, DWORD PTR [eax+124]
	addss	xmm0, DWORD PTR [eax+128]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\LightTrack.cpp

; 231  : 	if (MODE & IRender_ObjectSpecific::TRACE_SUN	)	sun_.mul(sun_smooth); else sun_.mul(.2f);

	test	cl, 2
	je	SHORT $LN44@update
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 40   : 	ICF SelfRef	mul(T s)								{ x*=s;		y*=s;		z*=s;			return *this;	};

	movss	xmm4, DWORD PTR [edi+1944]
$LN44@update:

; 29   : 	ICF	SelfRef	add(const Self &v)						{ x+=v.x;	y+=v.y;		z+=v.z;			return *this;	};

	movaps	xmm6, xmm4
	movaps	xmm5, xmm4
	mulss	xmm6, DWORD PTR [eax+148]
	mulss	xmm5, DWORD PTR [eax+152]
	mulss	xmm4, DWORD PTR [eax+156]
	addss	xmm6, xmm1
	addss	xmm5, xmm2
	addss	xmm4, xmm0
	movss	DWORD PTR $T5[esp+200], xmm6
	movss	DWORD PTR $T3[esp+200], xmm5
	movss	DWORD PTR $T6[esp+200], xmm4
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\LightTrack.cpp

; 233  : 	if (MODE & IRender_ObjectSpecific::TRACE_LIGHTS )	{

	test	cl, 1
	je	$LN46@update
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	eax, DWORD PTR [edi+32]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\LightTrack.cpp

; 234  : 		Fvector		lacc	=	{ 0,0,0 };

	xorps	xmm1, xmm1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	ecx, DWORD PTR [edi+28]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\LightTrack.cpp

; 234  : 		Fvector		lacc	=	{ 0,0,0 };

	movaps	xmm7, xmm1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	sub	eax, ecx
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\LightTrack.cpp

; 234  : 		Fvector		lacc	=	{ 0,0,0 };

	movaps	xmm0, xmm1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	sar	eax, 3
	imul	edx, eax, -1431655765
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\LightTrack.cpp

; 235  : 		for (u32 lit=0; lit<lights.size(); lit++)	{

	test	edx, edx
	je	$LN21@update
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1463 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));

	movss	xmm3, DWORD PTR __real@3f800000
	add	ecx, 12					; 0000000cH
	movaps	xmm6, xmm0
	movaps	xmm5, xmm0
	movaps	xmm4, xmm1
	npad	7
$LL22@update:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\LightTrack.cpp

; 236  : 			float	d	=	lights[lit].source->position.distance_to(position);

	mov	eax, DWORD PTR [ecx-12]

; 238  : 			float	a	=	clampr(1.f - d/(r+EPS),0.f,1.f)*(lights[lit].source->flags.bStatic?1.f:2.f);

	test	BYTE PTR [eax+60], 16			; 00000010H
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 287  : 	{	return (x-v.x)*(x-v.x) + (y-v.y)*(y-v.y) + (z-v.z)*(z-v.z);	}

	movss	xmm1, DWORD PTR [eax+68]
	subss	xmm1, DWORD PTR _position$[esp+204]
	movss	xmm2, DWORD PTR [eax+64]
	subss	xmm2, DWORD PTR _position$[esp+200]
	movss	xmm0, DWORD PTR [eax+72]
	subss	xmm0, DWORD PTR _position$[esp+208]
	mulss	xmm1, xmm1
	mulss	xmm2, xmm2
	mulss	xmm0, xmm0
	addss	xmm2, xmm1
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\LightTrack.cpp

; 238  : 			float	a	=	clampr(1.f - d/(r+EPS),0.f,1.f)*(lights[lit].source->flags.bStatic?1.f:2.f);

	movss	xmm1, DWORD PTR [eax+100]
	addss	xmm1, DWORD PTR __real@3727c5ac
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 287  : 	{	return (x-v.x)*(x-v.x) + (y-v.y)*(y-v.y) + (z-v.z)*(z-v.z);	}

	addss	xmm2, xmm0
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\LightTrack.cpp

; 238  : 			float	a	=	clampr(1.f - d/(r+EPS),0.f,1.f)*(lights[lit].source->flags.bStatic?1.f:2.f);

	movaps	xmm0, xmm3
	divss	xmm0, xmm1
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h

; 764  :             return (float)sqrt(_X);

	sqrtss	xmm2, xmm2
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\LightTrack.cpp

; 238  : 			float	a	=	clampr(1.f - d/(r+EPS),0.f,1.f)*(lights[lit].source->flags.bStatic?1.f:2.f);

	movaps	xmm1, xmm3
	mulss	xmm2, xmm0
	subss	xmm1, xmm2
	je	SHORT $LN53@update
	movaps	xmm0, xmm3
	jmp	SHORT $LN54@update
$LN53@update:
	movss	xmm0, DWORD PTR __real@40000000
$LN54@update:
; File I:\Vitalya\mine\NSProjectX\xrCore\vector.h

; 96   : 	if		( val<_low	)	return _low; 

	comiss	xmm4, xmm1
	jbe	SHORT $LN383@update
	movaps	xmm1, xmm4
	jmp	SHORT $LN385@update
$LN383@update:

; 97   : 	else if	( val>_high )	return _high;

	comiss	xmm1, xmm3
	jbe	SHORT $LN385@update
	movaps	xmm1, xmm3
$LN385@update:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\LightTrack.cpp

; 238  : 			float	a	=	clampr(1.f - d/(r+EPS),0.f,1.f)*(lights[lit].source->flags.bStatic?1.f:2.f);

	mulss	xmm1, xmm0

; 239  : 			lacc.x		+=	lights[lit].color.r*a;

	movaps	xmm0, xmm1
	mulss	xmm0, DWORD PTR [ecx-4]
	addss	xmm7, xmm0

; 240  : 			lacc.y		+=	lights[lit].color.g*a;

	movaps	xmm0, xmm1
	mulss	xmm0, DWORD PTR [ecx]

; 241  : 			lacc.z		+=	lights[lit].color.b*a;

	mulss	xmm1, DWORD PTR [ecx+4]
	add	ecx, 24					; 00000018H
	addss	xmm6, xmm0
	addss	xmm5, xmm1
	sub	edx, 1
	jne	$LL22@update
	movss	xmm4, DWORD PTR $T6[esp+200]
	movss	DWORD PTR _lacc$1$sroa$784$1$[esp+200], xmm5
	movss	xmm5, DWORD PTR $T3[esp+200]
	movss	xmm1, DWORD PTR _lacc$1$sroa$784$1$[esp+200]
	movss	DWORD PTR _lacc$1$sroa$786$1$[esp+200], xmm6
	movss	xmm6, DWORD PTR $T5[esp+200]
	movss	xmm0, DWORD PTR _lacc$1$sroa$786$1$[esp+200]
$LN21@update:
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 29   : 	ICF	SelfRef	add(const Self &v)						{ x+=v.x;	y+=v.y;		z+=v.z;			return *this;	};

	addss	xmm4, xmm1
	addss	xmm5, xmm0
	addss	xmm6, xmm7
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\LightTrack.cpp

; 248  : 	} else 			accum.set	( .1f, .1f, .1f );

	jmp	SHORT $LN47@update
$LN46@update:
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 23   : 	ICF	SelfRef	set(T _x, T _y, T _z)					{ x = _x;		y = _y;		z = _z;		return *this;	};

	movss	xmm0, DWORD PTR __real@3dcccccd
	movaps	xmm4, xmm0
	movaps	xmm5, xmm0
	movaps	xmm6, xmm0
$LN47@update:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\LightTrack.cpp

; 249  : 	approximate				=	accum;

	movss	DWORD PTR [edi+1948], xmm6
	movss	DWORD PTR [edi+1952], xmm5
	movss	DWORD PTR [edi+1956], xmm4
$LN1@update:

; 250  : }

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
?update@CROS_impl@@QAEXPAVIRenderable@@@Z ENDP		; CROS_impl::update
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\LightTrack.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\vector.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\LightTrack.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\vector.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\LightTrack.cpp
_TEXT	SEGMENT
_O$dead$ = 8						; size = 4
?update_smooth@CROS_impl@@QAEXPAVIRenderable@@@Z PROC	; CROS_impl::update_smooth
; _this$ = ecx

; 256  : {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H

; 257  : 	if (dwFrameSmooth == Device.dwFrame)

	mov	eax, DWORD PTR __imp_?Device@@3VCRenderDevice@@A
	mov	eax, DWORD PTR [eax+244]
	cmp	DWORD PTR [ecx+12], eax
	je	SHORT $LN1@update_smo
; File I:\Vitalya\mine\NSProjectX\xrCore\vector.h

; 92   : 	if( val<_low ) val = _low; else if( val>_high ) val = _high;

	movss	xmm3, DWORD PTR __real@3f800000
	xorps	xmm0, xmm0
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\LightTrack.cpp

; 260  : 	dwFrameSmooth			=	Device.dwFrame					;

	mov	DWORD PTR [ecx+12], eax

; 261  : 	if (O && (0==result_count))	update(O)						;	// First time only
; 262  : 	float	l_f				=	Device.fTimeDelta*ps_r2_lt_smooth;

	mov	eax, DWORD PTR __imp_?Device@@3VCRenderDevice@@A
	movss	xmm2, DWORD PTR [eax+468]
; File I:\Vitalya\mine\NSProjectX\xrCore\vector.h

; 92   : 	if( val<_low ) val = _low; else if( val>_high ) val = _high;

	comiss	xmm0, xmm2
	jbe	SHORT $LN6@update_smo
	movaps	xmm2, xmm0
	jmp	SHORT $LN8@update_smo
$LN6@update_smo:
	comiss	xmm2, xmm3
	jbe	SHORT $LN8@update_smo
	movaps	xmm2, xmm3
$LN8@update_smo:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\LightTrack.cpp

; 264  : 	float	l_i				=	1.f-l_f							;

	subss	xmm3, xmm2

; 265  : 	hemi_smooth				=	hemi_value*l_f + hemi_smooth*l_i;

	movaps	xmm1, xmm2
	mulss	xmm1, DWORD PTR [ecx+1932]

; 266  : 	sun_smooth				=	sun_value *l_f + sun_smooth *l_i;

	mulss	xmm2, DWORD PTR [ecx+1940]
	movaps	xmm0, xmm3
	mulss	xmm3, DWORD PTR [ecx+1944]
	mulss	xmm0, DWORD PTR [ecx+1936]
	addss	xmm2, xmm3
	addss	xmm1, xmm0
	movss	DWORD PTR [ecx+1944], xmm2
	movss	DWORD PTR [ecx+1936], xmm1
$LN1@update_smo:

; 267  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?update_smooth@CROS_impl@@QAEXPAVIRenderable@@@Z ENDP	; CROS_impl::update_smooth
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CROS_impl@@@std@@@std@@@std@@QBE?AV01@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CROS_impl@@@std@@@std@@@std@@QBE?AV01@H@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CROS_impl::Item> > >::operator+, COMDAT
; _this$ = ecx

; 119  :         _Ptr += _Off;

	imul	edx, DWORD PTR __Off$[esp-4], 84
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	add	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx

; 303  :         _Vector_iterator _Tmp = *this;
; 304  :         _Tmp += _Off; // TRANSITION, LLVM-49342
; 305  :         return _Tmp;
; 306  :     }

	ret	8
??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CROS_impl@@@std@@@std@@@std@@QBE?AV01@H@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CROS_impl::Item> > >::operator+
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CROS_impl@@@std@@@std@@@std@@QAE?AV01@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$dead$ = 12					; size = 4
??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CROS_impl@@@std@@@std@@@std@@QAE?AV01@H@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CROS_impl::Item> > >::operator++, COMDAT
; _this$ = ecx

; 281  :         _Vector_iterator _Tmp = *this;

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx

; 74   :         ++_Ptr;

	add	edx, 84					; 00000054H
	mov	DWORD PTR [ecx], edx

; 282  :         _Mybase::operator++();
; 283  :         return _Tmp;
; 284  :     }

	ret	8
??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CROS_impl@@@std@@@std@@@std@@QAE?AV01@H@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CROS_impl::Item> > >::operator++
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??C?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CROS_impl@@@std@@@std@@@std@@QBEPAUItem@CROS_impl@@XZ
_TEXT	SEGMENT
??C?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CROS_impl@@@std@@@std@@@std@@QBEPAUItem@CROS_impl@@XZ PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CROS_impl::Item> > >::operator->, COMDAT
; _this$ = ecx

; 265  : #if _ITERATOR_DEBUG_LEVEL != 0
; 266  :         const auto _Mycont = static_cast<const _Myvec*>(this->_Getcont());
; 267  :         _STL_VERIFY(this->_Ptr, "can't dereference value-initialized vector iterator");
; 268  :         _STL_VERIFY(_Mycont->_Myfirst <= this->_Ptr && this->_Ptr < _Mycont->_Mylast,
; 269  :             "can't dereference out of range vector iterator");
; 270  : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 271  : 
; 272  :         return this->_Ptr;

	mov	eax, DWORD PTR [ecx]

; 273  :     }

	ret	0
??C?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CROS_impl@@@std@@@std@@@std@@QBEPAUItem@CROS_impl@@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CROS_impl::Item> > >::operator->
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CROS_impl@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CROS_impl@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CROS_impl::Item> > >::operator!=, COMDAT
; _this$ = ecx

; 160  :         return !(*this == _Right);

	mov	eax, DWORD PTR __Right$[esp-4]
	mov	ecx, DWORD PTR [ecx]
	cmp	ecx, DWORD PTR [eax]
	setne	al

; 161  :     }

	ret	4
??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CROS_impl@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CROS_impl::Item> > >::operator!=
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ??A?$xr_vector@ULight@CROS_impl@@V?$xalloc@ULight@CROS_impl@@@@@@QAEAAULight@CROS_impl@@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$xr_vector@ULight@CROS_impl@@V?$xalloc@ULight@CROS_impl@@@@@@QAEAAULight@CROS_impl@@I@Z PROC ; xr_vector<CROS_impl::Light,xalloc<CROS_impl::Light> >::operator[], COMDAT
; _this$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 119  :         _Ptr += _Off;

	mov	eax, DWORD PTR __Pos$[esp-4]
	lea	edx, DWORD PTR [eax+eax*2]
	mov	eax, DWORD PTR [ecx]
	lea	eax, DWORD PTR [eax+edx*8]
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 138  : 	reference operator[]		(size_type _Pos)					{ {VERIFY(_Pos<size());} return (*(begin() + _Pos)); }

	ret	4
??A?$xr_vector@ULight@CROS_impl@@V?$xalloc@ULight@CROS_impl@@@@@@QAEAAULight@CROS_impl@@I@Z ENDP ; xr_vector<CROS_impl::Light,xalloc<CROS_impl::Light> >::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?clear@?$xr_vector@ULight@CROS_impl@@V?$xalloc@ULight@CROS_impl@@@@@@QAEXXZ
_TEXT	SEGMENT
?clear@?$xr_vector@ULight@CROS_impl@@V?$xalloc@ULight@CROS_impl@@@@@@QAEXXZ PROC ; xr_vector<CROS_impl::Light,xalloc<CROS_impl::Light> >::clear, COMDAT
; _this$ = ecx

; 132  : 	void	clear				()									{ clear_and_free	();			}

	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [ecx+4], eax
	ret	0
?clear@?$xr_vector@ULight@CROS_impl@@V?$xalloc@ULight@CROS_impl@@@@@@QAEXXZ ENDP ; xr_vector<CROS_impl::Light,xalloc<CROS_impl::Light> >::clear
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?size@?$xr_vector@ULight@CROS_impl@@V?$xalloc@ULight@CROS_impl@@@@@@QBEIXZ
_TEXT	SEGMENT
?size@?$xr_vector@ULight@CROS_impl@@V?$xalloc@ULight@CROS_impl@@@@@@QBEIXZ PROC ; xr_vector<CROS_impl::Light,xalloc<CROS_impl::Light> >::size, COMDAT
; _this$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	eax, DWORD PTR [ecx+4]
	sub	eax, DWORD PTR [ecx]
	sar	eax, 3
	imul	eax, eax, -1431655765
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 125  : 	u32		size				() const							{ return (u32)inherited::size();} 

	ret	0
?size@?$xr_vector@ULight@CROS_impl@@V?$xalloc@ULight@CROS_impl@@@@@@QBEIXZ ENDP ; xr_vector<CROS_impl::Light,xalloc<CROS_impl::Light> >::size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ??0?$xr_vector@ULight@CROS_impl@@V?$xalloc@ULight@CROS_impl@@@@@@QAE@XZ
_TEXT	SEGMENT
??0?$xr_vector@ULight@CROS_impl@@V?$xalloc@ULight@CROS_impl@@@@@@QAE@XZ PROC ; xr_vector<CROS_impl::Light,xalloc<CROS_impl::Light> >::xr_vector<CROS_impl::Light,xalloc<CROS_impl::Light> >, COMDAT
; _this$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx], 0
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 122  : 			xr_vector			()									: inherited	()					{}

	mov	eax, ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 122  : 			xr_vector			()									: inherited	()					{}

	ret	0
??0?$xr_vector@ULight@CROS_impl@@V?$xalloc@ULight@CROS_impl@@@@@@QAE@XZ ENDP ; xr_vector<CROS_impl::Light,xalloc<CROS_impl::Light> >::xr_vector<CROS_impl::Light,xalloc<CROS_impl::Light> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?back@?$vector@ULight@CROS_impl@@V?$xalloc@ULight@CROS_impl@@@@@std@@QAEAAULight@CROS_impl@@XZ
_TEXT	SEGMENT
?back@?$vector@ULight@CROS_impl@@V?$xalloc@ULight@CROS_impl@@@@@std@@QAEAAULight@CROS_impl@@XZ PROC ; std::vector<CROS_impl::Light,xalloc<CROS_impl::Light> >::back, COMDAT
; _this$ = ecx

; 1606 :         auto& _My_data = _Mypair._Myval2;
; 1607 : #if _CONTAINER_DEBUG_LEVEL > 0
; 1608 :         _STL_VERIFY(_My_data._Myfirst != _My_data._Mylast, "back() called on empty vector");
; 1609 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 1610 : 
; 1611 :         return _My_data._Mylast[-1];

	mov	eax, DWORD PTR [ecx+4]
	sub	eax, 24					; 00000018H

; 1612 :     }

	ret	0
?back@?$vector@ULight@CROS_impl@@V?$xalloc@ULight@CROS_impl@@@@@std@@QAEAAULight@CROS_impl@@XZ ENDP ; std::vector<CROS_impl::Light,xalloc<CROS_impl::Light> >::back
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?end@?$vector@ULight@CROS_impl@@V?$xalloc@ULight@CROS_impl@@@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@ULight@CROS_impl@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@ULight@CROS_impl@@V?$xalloc@ULight@CROS_impl@@@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@ULight@CROS_impl@@@std@@@std@@@2@XZ PROC ; std::vector<CROS_impl::Light,xalloc<CROS_impl::Light> >::end, COMDAT
; _this$ = ecx

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	ecx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax], ecx

; 1472 :         auto& _My_data = _Mypair._Myval2;
; 1473 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));
; 1474 :     }

	ret	4
?end@?$vector@ULight@CROS_impl@@V?$xalloc@ULight@CROS_impl@@@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@ULight@CROS_impl@@@std@@@std@@@2@XZ ENDP ; std::vector<CROS_impl::Light,xalloc<CROS_impl::Light> >::end
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?begin@?$vector@ULight@CROS_impl@@V?$xalloc@ULight@CROS_impl@@@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@ULight@CROS_impl@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@ULight@CROS_impl@@V?$xalloc@ULight@CROS_impl@@@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@ULight@CROS_impl@@@std@@@std@@@2@XZ PROC ; std::vector<CROS_impl::Light,xalloc<CROS_impl::Light> >::begin, COMDAT
; _this$ = ecx

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	ecx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], ecx

; 1462 :         auto& _My_data = _Mypair._Myval2;
; 1463 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));
; 1464 :     }

	ret	4
?begin@?$vector@ULight@CROS_impl@@V?$xalloc@ULight@CROS_impl@@@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@ULight@CROS_impl@@@std@@@std@@@2@XZ ENDP ; std::vector<CROS_impl::Light,xalloc<CROS_impl::Light> >::begin
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?push_back@?$vector@ULight@CROS_impl@@V?$xalloc@ULight@CROS_impl@@@@@std@@QAEX$$QAULight@CROS_impl@@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?push_back@?$vector@ULight@CROS_impl@@V?$xalloc@ULight@CROS_impl@@@@@std@@QAEX$$QAULight@CROS_impl@@@Z PROC ; std::vector<CROS_impl::Light,xalloc<CROS_impl::Light> >::push_back, COMDAT
; _this$ = ecx

; 746  :     _CONSTEXPR20_CONTAINER void push_back(_Ty&& _Val) {

	push	esi

; 730  :         if (_Mylast != _My_data._Myend) {

	mov	esi, DWORD PTR [ecx+4]
	cmp	esi, DWORD PTR [ecx+8]
	je	SHORT $LN4@push_back
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	edx, DWORD PTR __Val$[esp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [esi], eax
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [esi+4], eax
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR [esi+8], eax
	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR [esi+12], eax
	mov	eax, DWORD PTR [edx+16]
	mov	DWORD PTR [esi+16], eax
	mov	eax, DWORD PTR [edx+20]
	mov	DWORD PTR [esi+20], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 716  :         ++_Mylast;

	add	DWORD PTR [ecx+4], 24			; 00000018H
	pop	esi

; 747  :         // insert by moving into element at end, provide strong guarantee
; 748  :         emplace_back(_STD move(_Val));
; 749  :     }

	ret	4
$LN4@push_back:

; 734  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	push	DWORD PTR __Val$[esp]
	push	esi
	call	??$_Emplace_reallocate@ULight@CROS_impl@@@?$vector@ULight@CROS_impl@@V?$xalloc@ULight@CROS_impl@@@@@std@@QAEPAULight@CROS_impl@@QAU23@$$QAU23@@Z ; std::vector<CROS_impl::Light,xalloc<CROS_impl::Light> >::_Emplace_reallocate<CROS_impl::Light>
	pop	esi

; 747  :         // insert by moving into element at end, provide strong guarantee
; 748  :         emplace_back(_STD move(_Val));
; 749  :     }

	ret	4
?push_back@?$vector@ULight@CROS_impl@@V?$xalloc@ULight@CROS_impl@@@@@std@@QAEX$$QAULight@CROS_impl@@@Z ENDP ; std::vector<CROS_impl::Light,xalloc<CROS_impl::Light> >::push_back
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??$emplace_back@ULight@CROS_impl@@@?$vector@ULight@CROS_impl@@V?$xalloc@ULight@CROS_impl@@@@@std@@QAE?A_T$$QAULight@CROS_impl@@@Z
_TEXT	SEGMENT
_<_Val_0>$ = 8						; size = 4
??$emplace_back@ULight@CROS_impl@@@?$vector@ULight@CROS_impl@@V?$xalloc@ULight@CROS_impl@@@@@std@@QAE?A_T$$QAULight@CROS_impl@@@Z PROC ; std::vector<CROS_impl::Light,xalloc<CROS_impl::Light> >::emplace_back<CROS_impl::Light>, COMDAT
; _this$ = ecx

; 726  :     _CONSTEXPR20_CONTAINER decltype(auto) emplace_back(_Valty&&... _Val) {

	push	esi

; 727  :         // insert by perfectly forwarding into element at end, provide strong guarantee
; 728  :         auto& _My_data   = _Mypair._Myval2;
; 729  :         pointer& _Mylast = _My_data._Mylast;
; 730  :         if (_Mylast != _My_data._Myend) {

	mov	esi, DWORD PTR [ecx+4]
	cmp	esi, DWORD PTR [ecx+8]
	je	SHORT $LN2@emplace_ba
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	edx, DWORD PTR _<_Val_0>$[esp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [esi], eax
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [esi+4], eax
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR [esi+8], eax
	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR [esi+12], eax
	mov	eax, DWORD PTR [edx+16]
	mov	DWORD PTR [esi+16], eax
	mov	eax, DWORD PTR [edx+20]
	mov	DWORD PTR [esi+20], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 716  :         ++_Mylast;

	add	DWORD PTR [ecx+4], 24			; 00000018H
	pop	esi

; 735  : #if _HAS_CXX17
; 736  :         return _Result;
; 737  : #else // ^^^ _HAS_CXX17 ^^^ // vvv !_HAS_CXX17 vvv
; 738  :         (void) _Result;
; 739  : #endif // _HAS_CXX17
; 740  :     }

	ret	4
$LN2@emplace_ba:

; 731  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);
; 732  :         }
; 733  : 
; 734  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	push	DWORD PTR _<_Val_0>$[esp]
	push	esi
	call	??$_Emplace_reallocate@ULight@CROS_impl@@@?$vector@ULight@CROS_impl@@V?$xalloc@ULight@CROS_impl@@@@@std@@QAEPAULight@CROS_impl@@QAU23@$$QAU23@@Z ; std::vector<CROS_impl::Light,xalloc<CROS_impl::Light> >::_Emplace_reallocate<CROS_impl::Light>
	pop	esi

; 735  : #if _HAS_CXX17
; 736  :         return _Result;
; 737  : #else // ^^^ _HAS_CXX17 ^^^ // vvv !_HAS_CXX17 vvv
; 738  :         (void) _Result;
; 739  : #endif // _HAS_CXX17
; 740  :     }

	ret	4
??$emplace_back@ULight@CROS_impl@@@?$vector@ULight@CROS_impl@@V?$xalloc@ULight@CROS_impl@@@@@std@@QAE?A_T$$QAULight@CROS_impl@@@Z ENDP ; std::vector<CROS_impl::Light,xalloc<CROS_impl::Light> >::emplace_back<CROS_impl::Light>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??$_Emplace_back_with_unused_capacity@ULight@CROS_impl@@@?$vector@ULight@CROS_impl@@V?$xalloc@ULight@CROS_impl@@@@@std@@AAE?A_T$$QAULight@CROS_impl@@@Z
_TEXT	SEGMENT
_<_Val_0>$ = 8						; size = 4
??$_Emplace_back_with_unused_capacity@ULight@CROS_impl@@@?$vector@ULight@CROS_impl@@V?$xalloc@ULight@CROS_impl@@@@@std@@AAE?A_T$$QAULight@CROS_impl@@@Z PROC ; std::vector<CROS_impl::Light,xalloc<CROS_impl::Light> >::_Emplace_back_with_unused_capacity<CROS_impl::Light>, COMDAT
; _this$ = ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	edx, DWORD PTR _<_Val_0>$[esp-4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 708  :     _CONSTEXPR20_CONTAINER decltype(auto) _Emplace_back_with_unused_capacity(_Valty&&... _Val) {

	push	esi
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	esi, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [esi], eax
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [esi+4], eax
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR [esi+8], eax
	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR [esi+12], eax
	mov	eax, DWORD PTR [edx+16]
	mov	DWORD PTR [esi+16], eax
	mov	eax, DWORD PTR [edx+20]
	mov	DWORD PTR [esi+20], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 716  :         ++_Mylast;

	add	DWORD PTR [ecx+4], 24			; 00000018H
	pop	esi

; 717  : #if _HAS_CXX17
; 718  :         return _Result;
; 719  : #else // ^^^ _HAS_CXX17 ^^^ // vvv !_HAS_CXX17 vvv
; 720  :         (void) _Result;
; 721  : #endif // _HAS_CXX17
; 722  :     }

	ret	4
??$_Emplace_back_with_unused_capacity@ULight@CROS_impl@@@?$vector@ULight@CROS_impl@@V?$xalloc@ULight@CROS_impl@@@@@std@@AAE?A_T$$QAULight@CROS_impl@@@Z ENDP ; std::vector<CROS_impl::Light,xalloc<CROS_impl::Light> >::_Emplace_back_with_unused_capacity<CROS_impl::Light>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??1?$vector@ULight@CROS_impl@@V?$xalloc@ULight@CROS_impl@@@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@ULight@CROS_impl@@V?$xalloc@ULight@CROS_impl@@@@@std@@QAE@XZ PROC ; std::vector<CROS_impl::Light,xalloc<CROS_impl::Light> >::~vector<CROS_impl::Light,xalloc<CROS_impl::Light> >, COMDAT
; _this$ = ecx

; 698  :     _CONSTEXPR20_CONTAINER ~vector() noexcept {

	push	esi
	mov	esi, ecx

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN4@vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+4], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+8], 0
$LN4@vector:
	pop	esi

; 699  :         _Tidy();
; 700  : #if _ITERATOR_DEBUG_LEVEL != 0
; 701  :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 702  :         _Delete_plain_internal(_Alproxy, _STD exchange(_Mypair._Myval2._Myproxy, nullptr));
; 703  : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 704  :     }

	ret	0
??1?$vector@ULight@CROS_impl@@V?$xalloc@ULight@CROS_impl@@@@@std@@QAE@XZ ENDP ; std::vector<CROS_impl::Light,xalloc<CROS_impl::Light> >::~vector<CROS_impl::Light,xalloc<CROS_impl::Light> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?size@?$xr_vector@UItem@CROS_impl@@V?$xalloc@UItem@CROS_impl@@@@@@QBEIXZ
_TEXT	SEGMENT
?size@?$xr_vector@UItem@CROS_impl@@V?$xalloc@UItem@CROS_impl@@@@@@QBEIXZ PROC ; xr_vector<CROS_impl::Item,xalloc<CROS_impl::Item> >::size, COMDAT
; _this$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	eax, DWORD PTR [ecx+4]
	sub	eax, DWORD PTR [ecx]
	sar	eax, 2
	imul	eax, eax, 1022611261
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 125  : 	u32		size				() const							{ return (u32)inherited::size();} 

	ret	0
?size@?$xr_vector@UItem@CROS_impl@@V?$xalloc@UItem@CROS_impl@@@@@@QBEIXZ ENDP ; xr_vector<CROS_impl::Item,xalloc<CROS_impl::Item> >::size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ??0?$xr_vector@UItem@CROS_impl@@V?$xalloc@UItem@CROS_impl@@@@@@QAE@XZ
_TEXT	SEGMENT
??0?$xr_vector@UItem@CROS_impl@@V?$xalloc@UItem@CROS_impl@@@@@@QAE@XZ PROC ; xr_vector<CROS_impl::Item,xalloc<CROS_impl::Item> >::xr_vector<CROS_impl::Item,xalloc<CROS_impl::Item> >, COMDAT
; _this$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx], 0
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 122  : 			xr_vector			()									: inherited	()					{}

	mov	eax, ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 122  : 			xr_vector			()									: inherited	()					{}

	ret	0
??0?$xr_vector@UItem@CROS_impl@@V?$xalloc@UItem@CROS_impl@@@@@@QAE@XZ ENDP ; xr_vector<CROS_impl::Item,xalloc<CROS_impl::Item> >::xr_vector<CROS_impl::Item,xalloc<CROS_impl::Item> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?back@?$vector@UItem@CROS_impl@@V?$xalloc@UItem@CROS_impl@@@@@std@@QAEAAUItem@CROS_impl@@XZ
_TEXT	SEGMENT
?back@?$vector@UItem@CROS_impl@@V?$xalloc@UItem@CROS_impl@@@@@std@@QAEAAUItem@CROS_impl@@XZ PROC ; std::vector<CROS_impl::Item,xalloc<CROS_impl::Item> >::back, COMDAT
; _this$ = ecx

; 1606 :         auto& _My_data = _Mypair._Myval2;
; 1607 : #if _CONTAINER_DEBUG_LEVEL > 0
; 1608 :         _STL_VERIFY(_My_data._Myfirst != _My_data._Mylast, "back() called on empty vector");
; 1609 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 1610 : 
; 1611 :         return _My_data._Mylast[-1];

	mov	eax, DWORD PTR [ecx+4]
	sub	eax, 84					; 00000054H

; 1612 :     }

	ret	0
?back@?$vector@UItem@CROS_impl@@V?$xalloc@UItem@CROS_impl@@@@@std@@QAEAAUItem@CROS_impl@@XZ ENDP ; std::vector<CROS_impl::Item,xalloc<CROS_impl::Item> >::back
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?end@?$vector@UItem@CROS_impl@@V?$xalloc@UItem@CROS_impl@@@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CROS_impl@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@UItem@CROS_impl@@V?$xalloc@UItem@CROS_impl@@@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CROS_impl@@@std@@@std@@@2@XZ PROC ; std::vector<CROS_impl::Item,xalloc<CROS_impl::Item> >::end, COMDAT
; _this$ = ecx

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	ecx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax], ecx

; 1472 :         auto& _My_data = _Mypair._Myval2;
; 1473 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));
; 1474 :     }

	ret	4
?end@?$vector@UItem@CROS_impl@@V?$xalloc@UItem@CROS_impl@@@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CROS_impl@@@std@@@std@@@2@XZ ENDP ; std::vector<CROS_impl::Item,xalloc<CROS_impl::Item> >::end
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?begin@?$vector@UItem@CROS_impl@@V?$xalloc@UItem@CROS_impl@@@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CROS_impl@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@UItem@CROS_impl@@V?$xalloc@UItem@CROS_impl@@@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CROS_impl@@@std@@@std@@@2@XZ PROC ; std::vector<CROS_impl::Item,xalloc<CROS_impl::Item> >::begin, COMDAT
; _this$ = ecx

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	ecx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], ecx

; 1462 :         auto& _My_data = _Mypair._Myval2;
; 1463 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));
; 1464 :     }

	ret	4
?begin@?$vector@UItem@CROS_impl@@V?$xalloc@UItem@CROS_impl@@@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CROS_impl@@@std@@@std@@@2@XZ ENDP ; std::vector<CROS_impl::Item,xalloc<CROS_impl::Item> >::begin
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?erase@?$vector@UItem@CROS_impl@@V?$xalloc@UItem@CROS_impl@@@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CROS_impl@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CROS_impl@@@std@@@std@@@2@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?erase@?$vector@UItem@CROS_impl@@V?$xalloc@UItem@CROS_impl@@@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CROS_impl@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CROS_impl@@@std@@@std@@@2@@Z PROC ; std::vector<CROS_impl::Item,xalloc<CROS_impl::Item> >::erase, COMDAT
; _this$ = ecx

; 1394 :         is_nothrow_move_assignable_v<value_type>) /* strengthened */ {

	push	esi
	push	edi

; 1395 :         const pointer _Whereptr = _Where._Ptr;

	mov	edi, DWORD PTR __Where$[esp+4]
	mov	esi, ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility

; 4065 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	mov	eax, DWORD PTR [esi+4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1397 :         pointer& _Mylast        = _My_data._Mylast;

	lea	edx, DWORD PTR [edi+84]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility

; 4065 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	sub	eax, edx

; 4066 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	push	eax
	push	edx
	push	edi
	call	_memmove
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	eax, DWORD PTR ___$ReturnUdt$[esp+16]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility

; 4066 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	add	esp, 12					; 0000000cH
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1408 :         --_Mylast;

	add	DWORD PTR [esi+4], -84			; ffffffacH

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	DWORD PTR [eax], edi

; 1409 :         return iterator(_Whereptr, _STD addressof(_My_data));

	pop	edi
	pop	esi

; 1410 :     }

	ret	8
?erase@?$vector@UItem@CROS_impl@@V?$xalloc@UItem@CROS_impl@@@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CROS_impl@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CROS_impl@@@std@@@std@@@2@@Z ENDP ; std::vector<CROS_impl::Item,xalloc<CROS_impl::Item> >::erase
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?push_back@?$vector@UItem@CROS_impl@@V?$xalloc@UItem@CROS_impl@@@@@std@@QAEX$$QAUItem@CROS_impl@@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?push_back@?$vector@UItem@CROS_impl@@V?$xalloc@UItem@CROS_impl@@@@@std@@QAEX$$QAUItem@CROS_impl@@@Z PROC ; std::vector<CROS_impl::Item,xalloc<CROS_impl::Item> >::push_back, COMDAT
; _this$ = ecx

; 746  :     _CONSTEXPR20_CONTAINER void push_back(_Ty&& _Val) {

	mov	eax, ecx

; 730  :         if (_Mylast != _My_data._Myend) {

	mov	edx, DWORD PTR [eax+4]
	cmp	edx, DWORD PTR [eax+8]
	je	SHORT $LN4@push_back
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	push	esi
	mov	esi, DWORD PTR __Val$[esp]
	mov	ecx, 21					; 00000015H
	push	edi
	mov	edi, edx
	rep movsd
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 716  :         ++_Mylast;

	add	DWORD PTR [eax+4], 84			; 00000054H
	pop	edi
	pop	esi

; 747  :         // insert by moving into element at end, provide strong guarantee
; 748  :         emplace_back(_STD move(_Val));
; 749  :     }

	ret	4
$LN4@push_back:

; 734  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	push	DWORD PTR __Val$[esp-4]
	push	edx
	call	??$_Emplace_reallocate@UItem@CROS_impl@@@?$vector@UItem@CROS_impl@@V?$xalloc@UItem@CROS_impl@@@@@std@@QAEPAUItem@CROS_impl@@QAU23@$$QAU23@@Z ; std::vector<CROS_impl::Item,xalloc<CROS_impl::Item> >::_Emplace_reallocate<CROS_impl::Item>

; 747  :         // insert by moving into element at end, provide strong guarantee
; 748  :         emplace_back(_STD move(_Val));
; 749  :     }

	ret	4
?push_back@?$vector@UItem@CROS_impl@@V?$xalloc@UItem@CROS_impl@@@@@std@@QAEX$$QAUItem@CROS_impl@@@Z ENDP ; std::vector<CROS_impl::Item,xalloc<CROS_impl::Item> >::push_back
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??$emplace_back@UItem@CROS_impl@@@?$vector@UItem@CROS_impl@@V?$xalloc@UItem@CROS_impl@@@@@std@@QAE?A_T$$QAUItem@CROS_impl@@@Z
_TEXT	SEGMENT
_<_Val_0>$ = 8						; size = 4
??$emplace_back@UItem@CROS_impl@@@?$vector@UItem@CROS_impl@@V?$xalloc@UItem@CROS_impl@@@@@std@@QAE?A_T$$QAUItem@CROS_impl@@@Z PROC ; std::vector<CROS_impl::Item,xalloc<CROS_impl::Item> >::emplace_back<CROS_impl::Item>, COMDAT
; _this$ = ecx

; 726  :     _CONSTEXPR20_CONTAINER decltype(auto) emplace_back(_Valty&&... _Val) {

	mov	eax, ecx

; 727  :         // insert by perfectly forwarding into element at end, provide strong guarantee
; 728  :         auto& _My_data   = _Mypair._Myval2;
; 729  :         pointer& _Mylast = _My_data._Mylast;
; 730  :         if (_Mylast != _My_data._Myend) {

	mov	edx, DWORD PTR [eax+4]
	cmp	edx, DWORD PTR [eax+8]
	je	SHORT $LN2@emplace_ba
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	push	esi
	mov	esi, DWORD PTR _<_Val_0>$[esp]
	mov	ecx, 21					; 00000015H
	push	edi
	mov	edi, edx
	rep movsd
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 716  :         ++_Mylast;

	add	DWORD PTR [eax+4], 84			; 00000054H
	pop	edi
	pop	esi

; 735  : #if _HAS_CXX17
; 736  :         return _Result;
; 737  : #else // ^^^ _HAS_CXX17 ^^^ // vvv !_HAS_CXX17 vvv
; 738  :         (void) _Result;
; 739  : #endif // _HAS_CXX17
; 740  :     }

	ret	4
$LN2@emplace_ba:

; 731  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);
; 732  :         }
; 733  : 
; 734  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	push	DWORD PTR _<_Val_0>$[esp-4]
	push	edx
	call	??$_Emplace_reallocate@UItem@CROS_impl@@@?$vector@UItem@CROS_impl@@V?$xalloc@UItem@CROS_impl@@@@@std@@QAEPAUItem@CROS_impl@@QAU23@$$QAU23@@Z ; std::vector<CROS_impl::Item,xalloc<CROS_impl::Item> >::_Emplace_reallocate<CROS_impl::Item>

; 735  : #if _HAS_CXX17
; 736  :         return _Result;
; 737  : #else // ^^^ _HAS_CXX17 ^^^ // vvv !_HAS_CXX17 vvv
; 738  :         (void) _Result;
; 739  : #endif // _HAS_CXX17
; 740  :     }

	ret	4
??$emplace_back@UItem@CROS_impl@@@?$vector@UItem@CROS_impl@@V?$xalloc@UItem@CROS_impl@@@@@std@@QAE?A_T$$QAUItem@CROS_impl@@@Z ENDP ; std::vector<CROS_impl::Item,xalloc<CROS_impl::Item> >::emplace_back<CROS_impl::Item>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??$_Emplace_back_with_unused_capacity@UItem@CROS_impl@@@?$vector@UItem@CROS_impl@@V?$xalloc@UItem@CROS_impl@@@@@std@@AAE?A_T$$QAUItem@CROS_impl@@@Z
_TEXT	SEGMENT
_<_Val_0>$ = 8						; size = 4
??$_Emplace_back_with_unused_capacity@UItem@CROS_impl@@@?$vector@UItem@CROS_impl@@V?$xalloc@UItem@CROS_impl@@@@@std@@AAE?A_T$$QAUItem@CROS_impl@@@Z PROC ; std::vector<CROS_impl::Item,xalloc<CROS_impl::Item> >::_Emplace_back_with_unused_capacity<CROS_impl::Item>, COMDAT
; _this$ = ecx

; 708  :     _CONSTEXPR20_CONTAINER decltype(auto) _Emplace_back_with_unused_capacity(_Valty&&... _Val) {

	mov	eax, ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	ecx, 21					; 00000015H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 708  :     _CONSTEXPR20_CONTAINER decltype(auto) _Emplace_back_with_unused_capacity(_Valty&&... _Val) {

	push	esi
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	esi, DWORD PTR _<_Val_0>$[esp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 708  :     _CONSTEXPR20_CONTAINER decltype(auto) _Emplace_back_with_unused_capacity(_Valty&&... _Val) {

	push	edi
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	edi, DWORD PTR [eax+4]
	rep movsd
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 716  :         ++_Mylast;

	add	DWORD PTR [eax+4], 84			; 00000054H
	pop	edi
	pop	esi

; 717  : #if _HAS_CXX17
; 718  :         return _Result;
; 719  : #else // ^^^ _HAS_CXX17 ^^^ // vvv !_HAS_CXX17 vvv
; 720  :         (void) _Result;
; 721  : #endif // _HAS_CXX17
; 722  :     }

	ret	4
??$_Emplace_back_with_unused_capacity@UItem@CROS_impl@@@?$vector@UItem@CROS_impl@@V?$xalloc@UItem@CROS_impl@@@@@std@@AAE?A_T$$QAUItem@CROS_impl@@@Z ENDP ; std::vector<CROS_impl::Item,xalloc<CROS_impl::Item> >::_Emplace_back_with_unused_capacity<CROS_impl::Item>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??1?$vector@UItem@CROS_impl@@V?$xalloc@UItem@CROS_impl@@@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@UItem@CROS_impl@@V?$xalloc@UItem@CROS_impl@@@@@std@@QAE@XZ PROC ; std::vector<CROS_impl::Item,xalloc<CROS_impl::Item> >::~vector<CROS_impl::Item,xalloc<CROS_impl::Item> >, COMDAT
; _this$ = ecx

; 698  :     _CONSTEXPR20_CONTAINER ~vector() noexcept {

	push	esi
	mov	esi, ecx

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN4@vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+4], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+8], 0
$LN4@vector:
	pop	esi

; 699  :         _Tidy();
; 700  : #if _ITERATOR_DEBUG_LEVEL != 0
; 701  :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 702  :         _Delete_plain_internal(_Alproxy, _STD exchange(_Mypair._Myval2._Myproxy, nullptr));
; 703  : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 704  :     }

	ret	0
??1?$vector@UItem@CROS_impl@@V?$xalloc@UItem@CROS_impl@@@@@std@@QAE@XZ ENDP ; std::vector<CROS_impl::Item,xalloc<CROS_impl::Item> >::~vector<CROS_impl::Item,xalloc<CROS_impl::Item> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ??A?$xr_vector@PAVISpatial@@V?$xalloc@PAVISpatial@@@@@@QAEAAPAVISpatial@@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$xr_vector@PAVISpatial@@V?$xalloc@PAVISpatial@@@@@@QAEAAPAVISpatial@@I@Z PROC ; xr_vector<ISpatial *,xalloc<ISpatial *> >::operator[], COMDAT
; _this$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 119  :         _Ptr += _Off;

	mov	ecx, DWORD PTR [ecx]
	mov	eax, DWORD PTR __Pos$[esp-4]
	lea	eax, DWORD PTR [ecx+eax*4]
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 138  : 	reference operator[]		(size_type _Pos)					{ {VERIFY(_Pos<size());} return (*(begin() + _Pos)); }

	ret	4
??A?$xr_vector@PAVISpatial@@V?$xalloc@PAVISpatial@@@@@@QAEAAPAVISpatial@@I@Z ENDP ; xr_vector<ISpatial *,xalloc<ISpatial *> >::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?size@?$xr_vector@PAVISpatial@@V?$xalloc@PAVISpatial@@@@@@QBEIXZ
_TEXT	SEGMENT
?size@?$xr_vector@PAVISpatial@@V?$xalloc@PAVISpatial@@@@@@QBEIXZ PROC ; xr_vector<ISpatial *,xalloc<ISpatial *> >::size, COMDAT
; _this$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	eax, DWORD PTR [ecx+4]
	sub	eax, DWORD PTR [ecx]
	sar	eax, 2
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 125  : 	u32		size				() const							{ return (u32)inherited::size();} 

	ret	0
?size@?$xr_vector@PAVISpatial@@V?$xalloc@PAVISpatial@@@@@@QBEIXZ ENDP ; xr_vector<ISpatial *,xalloc<ISpatial *> >::size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_color.h
;	COMDAT ?intensity@?$_color@M@@QBEMXZ
_TEXT	SEGMENT
?intensity@?$_color@M@@QBEMXZ PROC			; _color<float>::intensity, COMDAT
; _this$ = ecx

; 203  : 		return (r + g + b)/3.f;

	fld	DWORD PTR [ecx+4]
	fadd	DWORD PTR [ecx]
	fadd	DWORD PTR [ecx+8]
	fmul	DWORD PTR __real@3eaaaaab

; 204  : 	}

	ret	0
?intensity@?$_color@M@@QBEMXZ ENDP			; _color<float>::intensity
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_color.h
;	COMDAT ?mul_rgb@?$_color@M@@QAEAAU1@ABU1@M@Z
_TEXT	SEGMENT
_c$ = 8							; size = 4
_s$ = 12						; size = 4
?mul_rgb@?$_color@M@@QAEAAU1@ABU1@M@Z PROC		; _color<float>::mul_rgb, COMDAT
; _this$ = ecx

; 188  : 		r=c.r*s;

	mov	eax, DWORD PTR _c$[esp-4]
	movss	xmm1, DWORD PTR _s$[esp-4]
	movaps	xmm0, xmm1
	mulss	xmm0, DWORD PTR [eax]
	movss	DWORD PTR [ecx], xmm0

; 189  : 		g=c.g*s;

	movaps	xmm0, xmm1
	mulss	xmm0, DWORD PTR [eax+4]
	movss	DWORD PTR [ecx+4], xmm0

; 190  : 		b=c.b*s;

	mulss	xmm1, DWORD PTR [eax+8]

; 191  : 		return *this;

	mov	eax, ecx
	movss	DWORD PTR [ecx+8], xmm1

; 192  : 	};

	ret	8
?mul_rgb@?$_color@M@@QAEAAU1@ABU1@M@Z ENDP		; _color<float>::mul_rgb
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_color.h
;	COMDAT ?mul_rgb@?$_color@M@@QAEAAU1@M@Z
_TEXT	SEGMENT
_s$ = 8							; size = 4
?mul_rgb@?$_color@M@@QAEAAU1@M@Z PROC			; _color<float>::mul_rgb, COMDAT
; _this$ = ecx

; 173  : 		r*=s;

	movss	xmm1, DWORD PTR _s$[esp-4]

; 174  : 		g*=s;
; 175  : 		b*=s;
; 176  : 		return *this;

	mov	eax, ecx
	movaps	xmm0, xmm1
	mulss	xmm0, DWORD PTR [ecx]
	movss	DWORD PTR [ecx], xmm0
	movaps	xmm0, xmm1
	mulss	xmm0, DWORD PTR [ecx+4]
	mulss	xmm1, DWORD PTR [ecx+8]
	movss	DWORD PTR [ecx+4], xmm0
	movss	DWORD PTR [ecx+8], xmm1

; 177  : 	};

	ret	4
?mul_rgb@?$_color@M@@QAEAAU1@M@Z ENDP			; _color<float>::mul_rgb
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_random.h
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_random.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_random.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_random.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
;	COMDAT ?random_dir@?$_vector3@M@@QAEAAU1@AAVCRandom@@@Z
_TEXT	SEGMENT
tv197 = 8						; size = 4
tv194 = 8						; size = 4
_r$ = 8							; size = 4
_R$ = 8							; size = 4
?random_dir@?$_vector3@M@@QAEAAU1@AAVCRandom@@@Z PROC	; _vector3<float>::random_dir, COMDAT
; _this$ = ecx

; 233  : 	{

	mov	edx, ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\_random.h

; 39   : 	IC 	float	randF	()							{ return float(randI())/maxF();	}

	mov	ecx, DWORD PTR _R$[esp-4]
	call	?randI@CRandom@@QAEHXZ			; CRandom::randI
	mov	DWORD PTR tv197[esp-4], eax
	fild	DWORD PTR tv197[esp-4]

; 40   : 	IC 	float	randF	(float max)					{ return randF()*max; }

	fmul	DWORD PTR __real@38c9116d
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h

; 653  :             return (float)cos(_X);

	fcos
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 235  : 		z	= _cos(R.randF(PI));

	fstp	DWORD PTR [edx+8]
; File I:\Vitalya\mine\NSProjectX\xrCore\_random.h

; 39   : 	IC 	float	randF	()							{ return float(randI())/maxF();	}

	call	?randI@CRandom@@QAEHXZ			; CRandom::randI
	mov	DWORD PTR tv194[esp-4], eax
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 242  : 		return *this;	

	mov	eax, edx
; File I:\Vitalya\mine\NSProjectX\xrCore\_random.h

; 39   : 	IC 	float	randF	()							{ return float(randI())/maxF();	}

	fild	DWORD PTR tv194[esp-4]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 237  : 		T r = _sqrt(1-z*z);

	movss	xmm1, DWORD PTR [edx+8]
; File I:\Vitalya\mine\NSProjectX\xrCore\_random.h

; 40   : 	IC 	float	randF	(float max)					{ return randF()*max; }

	fmul	DWORD PTR __real@3949116d
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 237  : 		T r = _sqrt(1-z*z);

	movss	xmm0, DWORD PTR __real@3f800000
	mulss	xmm1, xmm1
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h

; 653  :             return (float)cos(_X);

	fld	ST(0)
	fcos
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 237  : 		T r = _sqrt(1-z*z);

	subss	xmm0, xmm1
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h

; 764  :             return (float)sqrt(_X);

	sqrtss	xmm0, xmm0
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 237  : 		T r = _sqrt(1-z*z);

	movss	DWORD PTR _r$[esp-4], xmm0

; 238  : 		T sa= _sin (a);
; 239  : 		T ca= _cos (a);
; 240  : 		x	= r * ca;

	fld	DWORD PTR _r$[esp-4]
	fmul	ST(1), ST(0)
	fxch	ST(1)
	fstp	DWORD PTR [edx]
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h

; 754  :             return (float)sin(_X);

	fxch	ST(1)
	fsin
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 241  : 		y	= r * sa;

	fmulp	ST(1), ST(0)
	fstp	DWORD PTR [edx+4]

; 243  : 	};

	ret	4
?random_dir@?$_vector3@M@@QAEAAU1@AAVCRandom@@@Z ENDP	; _vector3<float>::random_dir
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
;	COMDAT ?magnitude@?$_vector3@M@@QBEMXZ
_TEXT	SEGMENT
?magnitude@?$_vector3@M@@QBEMXZ PROC			; _vector3<float>::magnitude, COMDAT
; _this$ = ecx

; 167  : 		return x*x + y*y + z*z;

	fld	DWORD PTR [ecx+4]
	fld	DWORD PTR [ecx+8]
	fld	DWORD PTR [ecx]
	fmul	ST(0), ST(0)
	fxch	ST(2)
	fmul	ST(0), ST(0)
	faddp	ST(2), ST(0)
	fmul	ST(0), ST(0)
	faddp	ST(1), ST(0)
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h

; 764  :             return (float)sqrt(_X);

	fsqrt
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 173  : 	}

	ret	0
?magnitude@?$_vector3@M@@QBEMXZ ENDP			; _vector3<float>::magnitude
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@ULight@CROS_impl@@@std@@@std@@@std@@QAE@PAULight@CROS_impl@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
___param0$ = 8						; size = 4
___param1$dead$ = 12					; size = 4
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@ULight@CROS_impl@@@std@@@std@@@std@@QAE@PAULight@CROS_impl@@PBU_Container_base0@1@@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CROS_impl::Light> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<CROS_impl::Light> > >, COMDAT
; _this$ = ecx

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	eax, DWORD PTR ___param0$[esp-4]
	mov	DWORD PTR [ecx], eax
	mov	eax, ecx
	ret	8
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@ULight@CROS_impl@@@std@@@std@@@std@@QAE@PAULight@CROS_impl@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CROS_impl::Light> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<CROS_impl::Light> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CROS_impl@@@std@@@std@@@std@@QAE@PAUItem@CROS_impl@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
___param0$ = 8						; size = 4
___param1$dead$ = 12					; size = 4
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CROS_impl@@@std@@@std@@@std@@QAE@PAUItem@CROS_impl@@PBU_Container_base0@1@@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CROS_impl::Item> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<CROS_impl::Item> > >, COMDAT
; _this$ = ecx

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	eax, DWORD PTR ___param0$[esp-4]
	mov	DWORD PTR [ecx], eax
	mov	eax, ecx
	ret	8
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CROS_impl@@@std@@@std@@@std@@QAE@PAUItem@CROS_impl@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CROS_impl::Item> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<CROS_impl::Item> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVISpatial@@@std@@@std@@@std@@QBE?AV01@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVISpatial@@@std@@@std@@@std@@QBE?AV01@H@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<ISpatial *> > >::operator+, COMDAT
; _this$ = ecx

; 119  :         _Ptr += _Off;

	mov	eax, DWORD PTR __Off$[esp-4]
	mov	ecx, DWORD PTR [ecx]
	lea	ecx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 303  :         _Vector_iterator _Tmp = *this;
; 304  :         _Tmp += _Off; // TRANSITION, LLVM-49342
; 305  :         return _Tmp;
; 306  :     }

	ret	8
??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVISpatial@@@std@@@std@@@std@@QBE?AV01@H@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<ISpatial *> > >::operator+
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVISpatial@@@std@@@std@@@std@@QBEAAPAVISpatial@@XZ
_TEXT	SEGMENT
??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVISpatial@@@std@@@std@@@std@@QBEAAPAVISpatial@@XZ PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<ISpatial *> > >::operator*, COMDAT
; _this$ = ecx

; 261  :         return const_cast<reference>(_Mybase::operator*());

	mov	eax, DWORD PTR [ecx]

; 262  :     }

	ret	0
??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVISpatial@@@std@@@std@@@std@@QBEAAPAVISpatial@@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<ISpatial *> > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@ULight@CROS_impl@@@std@@@std@@@std@@QBE?AV01@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@ULight@CROS_impl@@@std@@@std@@@std@@QBE?AV01@H@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CROS_impl::Light> > >::operator+, COMDAT
; _this$ = ecx

; 119  :         _Ptr += _Off;

	mov	eax, DWORD PTR __Off$[esp-4]
	lea	edx, DWORD PTR [eax+eax*2]
	mov	eax, DWORD PTR [ecx]
	lea	ecx, DWORD PTR [eax+edx*8]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 303  :         _Vector_iterator _Tmp = *this;
; 304  :         _Tmp += _Off; // TRANSITION, LLVM-49342
; 305  :         return _Tmp;
; 306  :     }

	ret	8
??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@ULight@CROS_impl@@@std@@@std@@@std@@QBE?AV01@H@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CROS_impl::Light> > >::operator+
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@ULight@CROS_impl@@@std@@@std@@@std@@QBEAAULight@CROS_impl@@XZ
_TEXT	SEGMENT
??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@ULight@CROS_impl@@@std@@@std@@@std@@QBEAAULight@CROS_impl@@XZ PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CROS_impl::Light> > >::operator*, COMDAT
; _this$ = ecx

; 261  :         return const_cast<reference>(_Mybase::operator*());

	mov	eax, DWORD PTR [ecx]

; 262  :     }

	ret	0
??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@ULight@CROS_impl@@@std@@@std@@@std@@QBEAAULight@CROS_impl@@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CROS_impl::Light> > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@ULight@CROS_impl@@@std@@@std@@@std@@QAE@PAULight@CROS_impl@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Pvector$dead$ = 12					; size = 4
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@ULight@CROS_impl@@@std@@@std@@@std@@QAE@PAULight@CROS_impl@@PBU_Container_base0@1@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CROS_impl::Light> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CROS_impl::Light> > >, COMDAT
; _this$ = ecx

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	eax, DWORD PTR __Parg$[esp-4]
	mov	DWORD PTR [ecx], eax

; 42   :         this->_Adopt(_Pvector);
; 43   :     }

	mov	eax, ecx
	ret	8
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@ULight@CROS_impl@@@std@@@std@@@std@@QAE@PAULight@CROS_impl@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CROS_impl::Light> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CROS_impl::Light> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CROS_impl@@@std@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CROS_impl@@@std@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CROS_impl::Item> > >::operator+=, COMDAT
; _this$ = ecx

; 119  :         _Ptr += _Off;

	imul	eax, DWORD PTR __Off$[esp-4], 84
	add	DWORD PTR [ecx], eax

; 298  :         _Mybase::operator+=(_Off);
; 299  :         return *this;

	mov	eax, ecx

; 300  :     }

	ret	4
??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CROS_impl@@@std@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CROS_impl::Item> > >::operator+=
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CROS_impl@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CROS_impl@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CROS_impl::Item> > >::operator==, COMDAT
; _this$ = ecx

; 149  :         _Compat(_Right);
; 150  :         return _Ptr == _Right._Ptr;

	mov	eax, DWORD PTR __Right$[esp-4]
	mov	ecx, DWORD PTR [ecx]
	cmp	ecx, DWORD PTR [eax]
	sete	al

; 151  :     }

	ret	4
??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CROS_impl@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CROS_impl::Item> > >::operator==
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CROS_impl@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CROS_impl@@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CROS_impl::Item> > >::operator++, COMDAT
; _this$ = ecx

; 68   : #if _ITERATOR_DEBUG_LEVEL != 0
; 69   :         const auto _Mycont = static_cast<const _Myvec*>(this->_Getcont());
; 70   :         _STL_VERIFY(_Ptr, "can't increment value-initialized vector iterator");
; 71   :         _STL_VERIFY(_Ptr < _Mycont->_Mylast, "can't increment vector iterator past end");
; 72   : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 73   : 
; 74   :         ++_Ptr;

	add	DWORD PTR [ecx], 84			; 00000054H

; 75   :         return *this;

	mov	eax, ecx

; 76   :     }

	ret	0
??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CROS_impl@@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CROS_impl::Item> > >::operator++
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CROS_impl@@@std@@@std@@@std@@QAE@PAUItem@CROS_impl@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Pvector$dead$ = 12					; size = 4
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CROS_impl@@@std@@@std@@@std@@QAE@PAUItem@CROS_impl@@PBU_Container_base0@1@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CROS_impl::Item> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CROS_impl::Item> > >, COMDAT
; _this$ = ecx

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	eax, DWORD PTR __Parg$[esp-4]
	mov	DWORD PTR [ecx], eax

; 42   :         this->_Adopt(_Pvector);
; 43   :     }

	mov	eax, ecx
	ret	8
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CROS_impl@@@std@@@std@@@std@@QAE@PAUItem@CROS_impl@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CROS_impl::Item> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CROS_impl::Item> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?clear_and_free@?$xr_vector@ULight@CROS_impl@@V?$xalloc@ULight@CROS_impl@@@@@@QAEXXZ
_TEXT	SEGMENT
?clear_and_free@?$xr_vector@ULight@CROS_impl@@V?$xalloc@ULight@CROS_impl@@@@@@QAEXXZ PROC ; xr_vector<CROS_impl::Light,xalloc<CROS_impl::Light> >::clear_and_free, COMDAT
; _this$ = ecx

; 127  : 	void	clear_and_free		()									{ inherited::clear();			}

	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [ecx+4], eax
	ret	0
?clear_and_free@?$xr_vector@ULight@CROS_impl@@V?$xalloc@ULight@CROS_impl@@@@@@QAEXXZ ENDP ; xr_vector<CROS_impl::Light,xalloc<CROS_impl::Light> >::clear_and_free
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Getal@?$vector@ULight@CROS_impl@@V?$xalloc@ULight@CROS_impl@@@@@std@@AAEAAV?$xalloc@ULight@CROS_impl@@@@XZ
_TEXT	SEGMENT
?_Getal@?$vector@ULight@CROS_impl@@V?$xalloc@ULight@CROS_impl@@@@@std@@AAEAAV?$xalloc@ULight@CROS_impl@@@@XZ PROC ; std::vector<CROS_impl::Light,xalloc<CROS_impl::Light> >::_Getal, COMDAT
; _this$ = ecx

; 1805 :         return _Mypair._Get_first();

	mov	eax, ecx

; 1806 :     }

	ret	0
?_Getal@?$vector@ULight@CROS_impl@@V?$xalloc@ULight@CROS_impl@@@@@std@@AAEAAV?$xalloc@ULight@CROS_impl@@@@XZ ENDP ; std::vector<CROS_impl::Light,xalloc<CROS_impl::Light> >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Orphan_range@?$vector@ULight@CROS_impl@@V?$xalloc@ULight@CROS_impl@@@@@std@@ABEXPAULight@CROS_impl@@0@Z
_TEXT	SEGMENT
___formal$dead$ = 8					; size = 4
___formal$dead$ = 12					; size = 4
?_Orphan_range@?$vector@ULight@CROS_impl@@V?$xalloc@ULight@CROS_impl@@@@@std@@ABEXPAULight@CROS_impl@@0@Z PROC ; std::vector<CROS_impl::Light,xalloc<CROS_impl::Light> >::_Orphan_range, COMDAT
; _this$dead$ = ecx

; 1801 :     _CONSTEXPR20_CONTAINER void _Orphan_range(pointer, pointer) const {}

	ret	8
?_Orphan_range@?$vector@ULight@CROS_impl@@V?$xalloc@ULight@CROS_impl@@@@@std@@ABEXPAULight@CROS_impl@@0@Z ENDP ; std::vector<CROS_impl::Light,xalloc<CROS_impl::Light> >::_Orphan_range
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Tidy@?$vector@ULight@CROS_impl@@V?$xalloc@ULight@CROS_impl@@@@@std@@AAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@ULight@CROS_impl@@V?$xalloc@ULight@CROS_impl@@@@@std@@AAEXXZ PROC ; std::vector<CROS_impl::Light,xalloc<CROS_impl::Light> >::_Tidy, COMDAT
; _this$ = ecx

; 1742 :     _CONSTEXPR20_CONTAINER void _Tidy() noexcept { // free all storage

	push	esi
	mov	esi, ecx

; 1743 :         auto& _My_data    = _Mypair._Myval2;
; 1744 :         pointer& _Myfirst = _My_data._Myfirst;
; 1745 :         pointer& _Mylast  = _My_data._Mylast;
; 1746 :         pointer& _Myend   = _My_data._Myend;
; 1747 : 
; 1748 :         _My_data._Orphan_all();
; 1749 : 
; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN2@Tidy
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+4], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+8], 0
$LN2@Tidy:

; 1757 :         }
; 1758 :     }

	pop	esi
	ret	0
?_Tidy@?$vector@ULight@CROS_impl@@V?$xalloc@ULight@CROS_impl@@@@@std@@AAEXXZ ENDP ; std::vector<CROS_impl::Light,xalloc<CROS_impl::Light> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?size@?$vector@ULight@CROS_impl@@V?$xalloc@ULight@CROS_impl@@@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@ULight@CROS_impl@@V?$xalloc@ULight@CROS_impl@@@@@std@@QBEIXZ PROC ; std::vector<CROS_impl::Light,xalloc<CROS_impl::Light> >::size, COMDAT
; _this$ = ecx

; 1535 :         auto& _My_data = _Mypair._Myval2;
; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	eax, DWORD PTR [ecx+4]
	sub	eax, DWORD PTR [ecx]
	sar	eax, 3
	imul	eax, eax, -1431655765

; 1537 :     }

	ret	0
?size@?$vector@ULight@CROS_impl@@V?$xalloc@ULight@CROS_impl@@@@@std@@QBEIXZ ENDP ; std::vector<CROS_impl::Light,xalloc<CROS_impl::Light> >::size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0?$vector@ULight@CROS_impl@@V?$xalloc@ULight@CROS_impl@@@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@ULight@CROS_impl@@V?$xalloc@ULight@CROS_impl@@@@@std@@QAE@XZ PROC ; std::vector<CROS_impl::Light,xalloc<CROS_impl::Light> >::vector<CROS_impl::Light,xalloc<CROS_impl::Light> >, COMDAT
; _this$ = ecx

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx], 0

; 464  :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 465  :     }

	mov	eax, ecx

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0

; 464  :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 465  :     }

	ret	0
??0?$vector@ULight@CROS_impl@@V?$xalloc@ULight@CROS_impl@@@@@std@@QAE@XZ ENDP ; std::vector<CROS_impl::Light,xalloc<CROS_impl::Light> >::vector<CROS_impl::Light,xalloc<CROS_impl::Light> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Getal@?$vector@UItem@CROS_impl@@V?$xalloc@UItem@CROS_impl@@@@@std@@AAEAAV?$xalloc@UItem@CROS_impl@@@@XZ
_TEXT	SEGMENT
?_Getal@?$vector@UItem@CROS_impl@@V?$xalloc@UItem@CROS_impl@@@@@std@@AAEAAV?$xalloc@UItem@CROS_impl@@@@XZ PROC ; std::vector<CROS_impl::Item,xalloc<CROS_impl::Item> >::_Getal, COMDAT
; _this$ = ecx

; 1805 :         return _Mypair._Get_first();

	mov	eax, ecx

; 1806 :     }

	ret	0
?_Getal@?$vector@UItem@CROS_impl@@V?$xalloc@UItem@CROS_impl@@@@@std@@AAEAAV?$xalloc@UItem@CROS_impl@@@@XZ ENDP ; std::vector<CROS_impl::Item,xalloc<CROS_impl::Item> >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Orphan_range@?$vector@UItem@CROS_impl@@V?$xalloc@UItem@CROS_impl@@@@@std@@ABEXPAUItem@CROS_impl@@0@Z
_TEXT	SEGMENT
___formal$dead$ = 8					; size = 4
___formal$dead$ = 12					; size = 4
?_Orphan_range@?$vector@UItem@CROS_impl@@V?$xalloc@UItem@CROS_impl@@@@@std@@ABEXPAUItem@CROS_impl@@0@Z PROC ; std::vector<CROS_impl::Item,xalloc<CROS_impl::Item> >::_Orphan_range, COMDAT
; _this$dead$ = ecx

; 1801 :     _CONSTEXPR20_CONTAINER void _Orphan_range(pointer, pointer) const {}

	ret	8
?_Orphan_range@?$vector@UItem@CROS_impl@@V?$xalloc@UItem@CROS_impl@@@@@std@@ABEXPAUItem@CROS_impl@@0@Z ENDP ; std::vector<CROS_impl::Item,xalloc<CROS_impl::Item> >::_Orphan_range
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Tidy@?$vector@UItem@CROS_impl@@V?$xalloc@UItem@CROS_impl@@@@@std@@AAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@UItem@CROS_impl@@V?$xalloc@UItem@CROS_impl@@@@@std@@AAEXXZ PROC ; std::vector<CROS_impl::Item,xalloc<CROS_impl::Item> >::_Tidy, COMDAT
; _this$ = ecx

; 1742 :     _CONSTEXPR20_CONTAINER void _Tidy() noexcept { // free all storage

	push	esi
	mov	esi, ecx

; 1743 :         auto& _My_data    = _Mypair._Myval2;
; 1744 :         pointer& _Myfirst = _My_data._Myfirst;
; 1745 :         pointer& _Mylast  = _My_data._Mylast;
; 1746 :         pointer& _Myend   = _My_data._Myend;
; 1747 : 
; 1748 :         _My_data._Orphan_all();
; 1749 : 
; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN2@Tidy
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+4], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+8], 0
$LN2@Tidy:

; 1757 :         }
; 1758 :     }

	pop	esi
	ret	0
?_Tidy@?$vector@UItem@CROS_impl@@V?$xalloc@UItem@CROS_impl@@@@@std@@AAEXXZ ENDP ; std::vector<CROS_impl::Item,xalloc<CROS_impl::Item> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?size@?$vector@UItem@CROS_impl@@V?$xalloc@UItem@CROS_impl@@@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@UItem@CROS_impl@@V?$xalloc@UItem@CROS_impl@@@@@std@@QBEIXZ PROC ; std::vector<CROS_impl::Item,xalloc<CROS_impl::Item> >::size, COMDAT
; _this$ = ecx

; 1535 :         auto& _My_data = _Mypair._Myval2;
; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	eax, DWORD PTR [ecx+4]
	sub	eax, DWORD PTR [ecx]
	sar	eax, 2
	imul	eax, eax, 1022611261

; 1537 :     }

	ret	0
?size@?$vector@UItem@CROS_impl@@V?$xalloc@UItem@CROS_impl@@@@@std@@QBEIXZ ENDP ; std::vector<CROS_impl::Item,xalloc<CROS_impl::Item> >::size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0?$vector@UItem@CROS_impl@@V?$xalloc@UItem@CROS_impl@@@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@UItem@CROS_impl@@V?$xalloc@UItem@CROS_impl@@@@@std@@QAE@XZ PROC ; std::vector<CROS_impl::Item,xalloc<CROS_impl::Item> >::vector<CROS_impl::Item,xalloc<CROS_impl::Item> >, COMDAT
; _this$ = ecx

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx], 0

; 464  :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 465  :     }

	mov	eax, ecx

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0

; 464  :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 465  :     }

	ret	0
??0?$vector@UItem@CROS_impl@@V?$xalloc@UItem@CROS_impl@@@@@std@@QAE@XZ ENDP ; std::vector<CROS_impl::Item,xalloc<CROS_impl::Item> >::vector<CROS_impl::Item,xalloc<CROS_impl::Item> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?size@?$vector@PAVISpatial@@V?$xalloc@PAVISpatial@@@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@PAVISpatial@@V?$xalloc@PAVISpatial@@@@@std@@QBEIXZ PROC ; std::vector<ISpatial *,xalloc<ISpatial *> >::size, COMDAT
; _this$ = ecx

; 1535 :         auto& _My_data = _Mypair._Myval2;
; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	eax, DWORD PTR [ecx+4]
	sub	eax, DWORD PTR [ecx]
	sar	eax, 2

; 1537 :     }

	ret	0
?size@?$vector@PAVISpatial@@V?$xalloc@PAVISpatial@@@@@std@@QBEIXZ ENDP ; std::vector<ISpatial *,xalloc<ISpatial *> >::size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?begin@?$vector@PAVISpatial@@V?$xalloc@PAVISpatial@@@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVISpatial@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@PAVISpatial@@V?$xalloc@PAVISpatial@@@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVISpatial@@@std@@@std@@@2@XZ PROC ; std::vector<ISpatial *,xalloc<ISpatial *> >::begin, COMDAT
; _this$ = ecx

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	ecx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], ecx

; 1462 :         auto& _My_data = _Mypair._Myval2;
; 1463 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));
; 1464 :     }

	ret	4
?begin@?$vector@PAVISpatial@@V?$xalloc@PAVISpatial@@@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVISpatial@@@std@@@std@@@2@XZ ENDP ; std::vector<ISpatial *,xalloc<ISpatial *> >::begin
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVISpatial@@@std@@@std@@@std@@QAE@PAPAVISpatial@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
___param0$ = 8						; size = 4
___param1$dead$ = 12					; size = 4
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVISpatial@@@std@@@std@@@std@@QAE@PAPAVISpatial@@PBU_Container_base0@1@@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<ISpatial *> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<ISpatial *> > >, COMDAT
; _this$ = ecx

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	eax, DWORD PTR ___param0$[esp-4]
	mov	DWORD PTR [ecx], eax
	mov	eax, ecx
	ret	8
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVISpatial@@@std@@@std@@@std@@QAE@PAPAVISpatial@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<ISpatial *> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<ISpatial *> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVISpatial@@@std@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVISpatial@@@std@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<ISpatial *> > >::operator+=, COMDAT
; _this$ = ecx

; 119  :         _Ptr += _Off;

	mov	eax, DWORD PTR __Off$[esp-4]
	shl	eax, 2
	add	DWORD PTR [ecx], eax

; 298  :         _Mybase::operator+=(_Off);
; 299  :         return *this;

	mov	eax, ecx

; 300  :     }

	ret	4
??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVISpatial@@@std@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<ISpatial *> > >::operator+=
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVISpatial@@@std@@@std@@@std@@QBEABQAVISpatial@@XZ
_TEXT	SEGMENT
??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVISpatial@@@std@@@std@@@std@@QBEABQAVISpatial@@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<ISpatial *> > >::operator*, COMDAT
; _this$ = ecx

; 46   : #if _ITERATOR_DEBUG_LEVEL != 0
; 47   :         const auto _Mycont = static_cast<const _Myvec*>(this->_Getcont());
; 48   :         _STL_VERIFY(_Ptr, "can't dereference value-initialized vector iterator");
; 49   :         _STL_VERIFY(
; 50   :             _Mycont->_Myfirst <= _Ptr && _Ptr < _Mycont->_Mylast, "can't dereference out of range vector iterator");
; 51   : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 52   : 
; 53   :         return *_Ptr;

	mov	eax, DWORD PTR [ecx]

; 54   :     }

	ret	0
??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVISpatial@@@std@@@std@@@std@@QBEABQAVISpatial@@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<ISpatial *> > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVISpatial@@@std@@@std@@@std@@QAE@PAPAVISpatial@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Pvector$dead$ = 12					; size = 4
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVISpatial@@@std@@@std@@@std@@QAE@PAPAVISpatial@@PBU_Container_base0@1@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<ISpatial *> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<ISpatial *> > >, COMDAT
; _this$ = ecx

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	eax, DWORD PTR __Parg$[esp-4]
	mov	DWORD PTR [ecx], eax

; 42   :         this->_Adopt(_Pvector);
; 43   :     }

	mov	eax, ecx
	ret	8
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVISpatial@@@std@@@std@@@std@@QAE@PAPAVISpatial@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<ISpatial *> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<ISpatial *> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@ULight@CROS_impl@@@std@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@ULight@CROS_impl@@@std@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CROS_impl::Light> > >::operator+=, COMDAT
; _this$ = ecx

; 119  :         _Ptr += _Off;

	mov	eax, DWORD PTR __Off$[esp-4]
	lea	eax, DWORD PTR [eax+eax*2]
	shl	eax, 3
	add	DWORD PTR [ecx], eax

; 298  :         _Mybase::operator+=(_Off);
; 299  :         return *this;

	mov	eax, ecx

; 300  :     }

	ret	4
??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@ULight@CROS_impl@@@std@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CROS_impl::Light> > >::operator+=
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@ULight@CROS_impl@@@std@@@std@@@std@@QBEABULight@CROS_impl@@XZ
_TEXT	SEGMENT
??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@ULight@CROS_impl@@@std@@@std@@@std@@QBEABULight@CROS_impl@@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CROS_impl::Light> > >::operator*, COMDAT
; _this$ = ecx

; 46   : #if _ITERATOR_DEBUG_LEVEL != 0
; 47   :         const auto _Mycont = static_cast<const _Myvec*>(this->_Getcont());
; 48   :         _STL_VERIFY(_Ptr, "can't dereference value-initialized vector iterator");
; 49   :         _STL_VERIFY(
; 50   :             _Mycont->_Myfirst <= _Ptr && _Ptr < _Mycont->_Mylast, "can't dereference out of range vector iterator");
; 51   : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 52   : 
; 53   :         return *_Ptr;

	mov	eax, DWORD PTR [ecx]

; 54   :     }

	ret	0
??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@ULight@CROS_impl@@@std@@@std@@@std@@QBEABULight@CROS_impl@@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CROS_impl::Light> > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CROS_impl@@@std@@@std@@@std@@QBEXABV12@@Z
_TEXT	SEGMENT
__Right$dead$ = 8					; size = 4
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CROS_impl@@@std@@@std@@@std@@QBEXABV12@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CROS_impl::Item> > >::_Compat, COMDAT
; _this$dead$ = ecx

; 182  :         // test for compatible iterator pair
; 183  : #if _ITERATOR_DEBUG_LEVEL == 0
; 184  :         (void) _Right;
; 185  : #else // ^^^ _ITERATOR_DEBUG_LEVEL == 0 ^^^ // vvv _ITERATOR_DEBUG_LEVEL != 0 vvv
; 186  :         _STL_VERIFY(this->_Getcont() == _Right._Getcont(), "vector iterators incompatible");
; 187  : #endif // _ITERATOR_DEBUG_LEVEL == 0
; 188  :     }

	ret	4
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CROS_impl@@@std@@@std@@@std@@QBEXABV12@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CROS_impl::Item> > >::_Compat
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CROS_impl@@@std@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CROS_impl@@@std@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CROS_impl::Item> > >::operator+=, COMDAT
; _this$ = ecx

; 118  :         _Verify_offset(_Off);
; 119  :         _Ptr += _Off;

	imul	eax, DWORD PTR __Off$[esp-4], 84
	add	DWORD PTR [ecx], eax

; 120  :         return *this;

	mov	eax, ecx

; 121  :     }

	ret	4
??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CROS_impl@@@std@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CROS_impl::Item> > >::operator+=
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$xalloc@ULight@CROS_impl@@@@V?$_Vector_val@U?$_Simple_types@ULight@CROS_impl@@@std@@@std@@$00@std@@QAEAAV?$xalloc@ULight@CROS_impl@@@@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@V?$xalloc@ULight@CROS_impl@@@@V?$_Vector_val@U?$_Simple_types@ULight@CROS_impl@@@std@@@std@@$00@std@@QAEAAV?$xalloc@ULight@CROS_impl@@@@XZ PROC ; std::_Compressed_pair<xalloc<CROS_impl::Light>,std::_Vector_val<std::_Simple_types<CROS_impl::Light> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 1339 :         return *this;

	mov	eax, ecx

; 1340 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$xalloc@ULight@CROS_impl@@@@V?$_Vector_val@U?$_Simple_types@ULight@CROS_impl@@@std@@@std@@$00@std@@QAEAAV?$xalloc@ULight@CROS_impl@@@@XZ ENDP ; std::_Compressed_pair<xalloc<CROS_impl::Light>,std::_Vector_val<std::_Simple_types<CROS_impl::Light> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Destroy@?$vector@ULight@CROS_impl@@V?$xalloc@ULight@CROS_impl@@@@@std@@AAEXPAULight@CROS_impl@@0@Z
_TEXT	SEGMENT
__First$dead$ = 8					; size = 4
__Last$dead$ = 12					; size = 4
?_Destroy@?$vector@ULight@CROS_impl@@V?$xalloc@ULight@CROS_impl@@@@@std@@AAEXPAULight@CROS_impl@@0@Z PROC ; std::vector<CROS_impl::Light,xalloc<CROS_impl::Light> >::_Destroy, COMDAT
; _this$dead$ = ecx

; 1666 :         // destroy [_First, _Last) using allocator
; 1667 :         _Destroy_range(_First, _Last, _Getal());
; 1668 :     }

	ret	8
?_Destroy@?$vector@ULight@CROS_impl@@V?$xalloc@ULight@CROS_impl@@@@@std@@AAEXPAULight@CROS_impl@@0@Z ENDP ; std::vector<CROS_impl::Light,xalloc<CROS_impl::Light> >::_Destroy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?clear@?$vector@ULight@CROS_impl@@V?$xalloc@ULight@CROS_impl@@@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$vector@ULight@CROS_impl@@V?$xalloc@ULight@CROS_impl@@@@@std@@QAEXXZ PROC ; std::vector<CROS_impl::Light,xalloc<CROS_impl::Light> >::clear, COMDAT
; _this$ = ecx

; 1437 :         auto& _My_data    = _Mypair._Myval2;
; 1438 :         pointer& _Myfirst = _My_data._Myfirst;
; 1439 :         pointer& _Mylast  = _My_data._Mylast;
; 1440 : 
; 1441 :         _My_data._Orphan_all();
; 1442 :         _Destroy(_Myfirst, _Mylast);
; 1443 :         _Mylast = _Myfirst;

	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [ecx+4], eax

; 1444 :     }

	ret	0
?clear@?$vector@ULight@CROS_impl@@V?$xalloc@ULight@CROS_impl@@@@@std@@QAEXXZ ENDP ; std::vector<CROS_impl::Light,xalloc<CROS_impl::Light> >::clear
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?deallocate@?$xalloc@ULight@CROS_impl@@@@QBEXPAULight@CROS_impl@@I@Z
_TEXT	SEGMENT
_p$ = 8							; size = 4
_n$dead$ = 12						; size = 4
?deallocate@?$xalloc@ULight@CROS_impl@@@@QBEXPAULight@CROS_impl@@I@Z PROC ; xalloc<CROS_impl::Light>::deallocate, COMDAT
; _this$dead$ = ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	eax, DWORD PTR _p$[esp-4]
	test	eax, eax
	je	SHORT $LN4@deallocate
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN4@deallocate:
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 82   : 							void					deallocate		(pointer p, size_type n) const			{	xr_free	(p);				}

	ret	8
?deallocate@?$xalloc@ULight@CROS_impl@@@@QBEXPAULight@CROS_impl@@I@Z ENDP ; xalloc<CROS_impl::Light>::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$xalloc@UItem@CROS_impl@@@@V?$_Vector_val@U?$_Simple_types@UItem@CROS_impl@@@std@@@std@@$00@std@@QAEAAV?$xalloc@UItem@CROS_impl@@@@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@V?$xalloc@UItem@CROS_impl@@@@V?$_Vector_val@U?$_Simple_types@UItem@CROS_impl@@@std@@@std@@$00@std@@QAEAAV?$xalloc@UItem@CROS_impl@@@@XZ PROC ; std::_Compressed_pair<xalloc<CROS_impl::Item>,std::_Vector_val<std::_Simple_types<CROS_impl::Item> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 1339 :         return *this;

	mov	eax, ecx

; 1340 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$xalloc@UItem@CROS_impl@@@@V?$_Vector_val@U?$_Simple_types@UItem@CROS_impl@@@std@@@std@@$00@std@@QAEAAV?$xalloc@UItem@CROS_impl@@@@XZ ENDP ; std::_Compressed_pair<xalloc<CROS_impl::Item>,std::_Vector_val<std::_Simple_types<CROS_impl::Item> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Destroy@?$vector@UItem@CROS_impl@@V?$xalloc@UItem@CROS_impl@@@@@std@@AAEXPAUItem@CROS_impl@@0@Z
_TEXT	SEGMENT
__First$dead$ = 8					; size = 4
__Last$dead$ = 12					; size = 4
?_Destroy@?$vector@UItem@CROS_impl@@V?$xalloc@UItem@CROS_impl@@@@@std@@AAEXPAUItem@CROS_impl@@0@Z PROC ; std::vector<CROS_impl::Item,xalloc<CROS_impl::Item> >::_Destroy, COMDAT
; _this$dead$ = ecx

; 1666 :         // destroy [_First, _Last) using allocator
; 1667 :         _Destroy_range(_First, _Last, _Getal());
; 1668 :     }

	ret	8
?_Destroy@?$vector@UItem@CROS_impl@@V?$xalloc@UItem@CROS_impl@@@@@std@@AAEXPAUItem@CROS_impl@@0@Z ENDP ; std::vector<CROS_impl::Item,xalloc<CROS_impl::Item> >::_Destroy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?deallocate@?$xalloc@UItem@CROS_impl@@@@QBEXPAUItem@CROS_impl@@I@Z
_TEXT	SEGMENT
_p$ = 8							; size = 4
_n$dead$ = 12						; size = 4
?deallocate@?$xalloc@UItem@CROS_impl@@@@QBEXPAUItem@CROS_impl@@I@Z PROC ; xalloc<CROS_impl::Item>::deallocate, COMDAT
; _this$dead$ = ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	eax, DWORD PTR _p$[esp-4]
	test	eax, eax
	je	SHORT $LN4@deallocate
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN4@deallocate:
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 82   : 							void					deallocate		(pointer p, size_type n) const			{	xr_free	(p);				}

	ret	8
?deallocate@?$xalloc@UItem@CROS_impl@@@@QBEXPAUItem@CROS_impl@@I@Z ENDP ; xalloc<CROS_impl::Item>::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVISpatial@@@std@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVISpatial@@@std@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<ISpatial *> > >::operator+=, COMDAT
; _this$ = ecx

; 118  :         _Verify_offset(_Off);
; 119  :         _Ptr += _Off;

	mov	eax, DWORD PTR __Off$[esp-4]
	shl	eax, 2
	add	DWORD PTR [ecx], eax

; 120  :         return *this;

	mov	eax, ecx

; 121  :     }

	ret	4
??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVISpatial@@@std@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<ISpatial *> > >::operator+=
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@ULight@CROS_impl@@@std@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@ULight@CROS_impl@@@std@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CROS_impl::Light> > >::operator+=, COMDAT
; _this$ = ecx

; 118  :         _Verify_offset(_Off);
; 119  :         _Ptr += _Off;

	mov	eax, DWORD PTR __Off$[esp-4]
	lea	eax, DWORD PTR [eax+eax*2]
	shl	eax, 3
	add	DWORD PTR [ecx], eax

; 120  :         return *this;

	mov	eax, ecx

; 121  :     }

	ret	4
??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@ULight@CROS_impl@@@std@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CROS_impl::Light> > >::operator+=
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Verify_offset@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CROS_impl@@@std@@@std@@@std@@QBEXH@Z
_TEXT	SEGMENT
__Off$dead$ = 8						; size = 4
?_Verify_offset@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CROS_impl@@@std@@@std@@@std@@QBEXH@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CROS_impl::Item> > >::_Verify_offset, COMDAT
; _this$dead$ = ecx

; 102  : #if _ITERATOR_DEBUG_LEVEL == 0
; 103  :         (void) _Off;
; 104  : #else // ^^^ _ITERATOR_DEBUG_LEVEL == 0 ^^^ // vvv _ITERATOR_DEBUG_LEVEL != 0 vvv
; 105  :         const auto _Mycont = static_cast<const _Myvec*>(this->_Getcont());
; 106  :         _STL_VERIFY(_Off == 0 || _Ptr, "cannot seek value-initialized vector iterator");
; 107  :         if (_Off < 0) {
; 108  :             _STL_VERIFY(_Off >= _Mycont->_Myfirst - _Ptr, "cannot seek vector iterator before begin");
; 109  :         }
; 110  : 
; 111  :         if (_Off > 0) {
; 112  :             _STL_VERIFY(_Off <= _Mycont->_Mylast - _Ptr, "cannot seek vector iterator after end");
; 113  :         }
; 114  : #endif // _ITERATOR_DEBUG_LEVEL == 0
; 115  :     }

	ret	4
?_Verify_offset@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CROS_impl@@@std@@@std@@@std@@QBEXH@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CROS_impl::Item> > >::_Verify_offset
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Verify_offset@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVISpatial@@@std@@@std@@@std@@QBEXH@Z
_TEXT	SEGMENT
__Off$dead$ = 8						; size = 4
?_Verify_offset@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVISpatial@@@std@@@std@@@std@@QBEXH@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<ISpatial *> > >::_Verify_offset, COMDAT
; _this$dead$ = ecx

; 102  : #if _ITERATOR_DEBUG_LEVEL == 0
; 103  :         (void) _Off;
; 104  : #else // ^^^ _ITERATOR_DEBUG_LEVEL == 0 ^^^ // vvv _ITERATOR_DEBUG_LEVEL != 0 vvv
; 105  :         const auto _Mycont = static_cast<const _Myvec*>(this->_Getcont());
; 106  :         _STL_VERIFY(_Off == 0 || _Ptr, "cannot seek value-initialized vector iterator");
; 107  :         if (_Off < 0) {
; 108  :             _STL_VERIFY(_Off >= _Mycont->_Myfirst - _Ptr, "cannot seek vector iterator before begin");
; 109  :         }
; 110  : 
; 111  :         if (_Off > 0) {
; 112  :             _STL_VERIFY(_Off <= _Mycont->_Mylast - _Ptr, "cannot seek vector iterator after end");
; 113  :         }
; 114  : #endif // _ITERATOR_DEBUG_LEVEL == 0
; 115  :     }

	ret	4
?_Verify_offset@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVISpatial@@@std@@@std@@@std@@QBEXH@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<ISpatial *> > >::_Verify_offset
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Verify_offset@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@ULight@CROS_impl@@@std@@@std@@@std@@QBEXH@Z
_TEXT	SEGMENT
__Off$dead$ = 8						; size = 4
?_Verify_offset@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@ULight@CROS_impl@@@std@@@std@@@std@@QBEXH@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CROS_impl::Light> > >::_Verify_offset, COMDAT
; _this$dead$ = ecx

; 102  : #if _ITERATOR_DEBUG_LEVEL == 0
; 103  :         (void) _Off;
; 104  : #else // ^^^ _ITERATOR_DEBUG_LEVEL == 0 ^^^ // vvv _ITERATOR_DEBUG_LEVEL != 0 vvv
; 105  :         const auto _Mycont = static_cast<const _Myvec*>(this->_Getcont());
; 106  :         _STL_VERIFY(_Off == 0 || _Ptr, "cannot seek value-initialized vector iterator");
; 107  :         if (_Off < 0) {
; 108  :             _STL_VERIFY(_Off >= _Mycont->_Myfirst - _Ptr, "cannot seek vector iterator before begin");
; 109  :         }
; 110  : 
; 111  :         if (_Off > 0) {
; 112  :             _STL_VERIFY(_Off <= _Mycont->_Mylast - _Ptr, "cannot seek vector iterator after end");
; 113  :         }
; 114  : #endif // _ITERATOR_DEBUG_LEVEL == 0
; 115  :     }

	ret	4
?_Verify_offset@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@ULight@CROS_impl@@@std@@@std@@@std@@QBEXH@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CROS_impl::Light> > >::_Verify_offset
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
;	COMDAT ??$sort@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@ULight@CROS_impl@@@std@@@std@@@std@@P6A_NABULight@CROS_impl@@0@Z@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@ULight@CROS_impl@@@std@@@std@@@0@0P6A_NABULight@CROS_impl@@1@Z@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$sort@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@ULight@CROS_impl@@@std@@@std@@@std@@P6A_NABULight@CROS_impl@@0@Z@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@ULight@CROS_impl@@@std@@@std@@@0@0P6A_NABULight@CROS_impl@@1@Z@Z PROC ; std::sort<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CROS_impl::Light> > >,bool (__cdecl*)(CROS_impl::Light const &,CROS_impl::Light const &)>, COMDAT
; __Pred$dead$ = ecx

; 7076 : _CONSTEXPR20 void sort(const _RanIt _First, const _RanIt _Last, _Pr _Pred) { // order [_First, _Last)

	push	ecx

; 7077 :     _Adl_verify_range(_First, _Last);
; 7078 :     const auto _UFirst = _Get_unwrapped(_First);
; 7079 :     const auto _ULast  = _Get_unwrapped(_Last);
; 7080 :     _Sort_unchecked(_UFirst, _ULast, _ULast - _UFirst, _Pass_fn(_Pred));

	mov	edx, DWORD PTR __Last$[esp]
	mov	eax, edx
	mov	ecx, DWORD PTR __First$[esp]
	sub	eax, ecx
	sar	eax, 3
	imul	eax, eax, -1431655765
	push	OFFSET ?pred_energy@@YA_NABULight@CROS_impl@@0@Z ; pred_energy
	push	eax
	call	??$_Sort_unchecked@PAULight@CROS_impl@@P6A_NABU12@0@Z@std@@YAXPAULight@CROS_impl@@0HP6A_NABU12@1@Z@Z ; std::_Sort_unchecked<CROS_impl::Light *,bool (__cdecl*)(CROS_impl::Light const &,CROS_impl::Light const &)>
	add	esp, 8

; 7081 : }

	pop	ecx
	ret	0
??$sort@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@ULight@CROS_impl@@@std@@@std@@@std@@P6A_NABULight@CROS_impl@@0@Z@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@ULight@CROS_impl@@@std@@@std@@@0@0P6A_NABULight@CROS_impl@@1@Z@Z ENDP ; std::sort<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CROS_impl::Light> > >,bool (__cdecl*)(CROS_impl::Light const &,CROS_impl::Light const &)>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_Get_unwrapped@ABV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@ULight@CROS_impl@@@std@@@std@@@std@@@std@@YA?A_TABV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@ULight@CROS_impl@@@std@@@std@@@0@@Z
_TEXT	SEGMENT
??$_Get_unwrapped@ABV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@ULight@CROS_impl@@@std@@@std@@@std@@@std@@YA?A_TABV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@ULight@CROS_impl@@@std@@@std@@@0@@Z PROC ; std::_Get_unwrapped<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CROS_impl::Light> > > const &>, COMDAT
; __It$ = ecx

; 1275 :     // unwrap an iterator previously subjected to _Adl_verify_range or otherwise validated
; 1276 :     if constexpr (is_pointer_v<decay_t<_Iter>>) { // special-case pointers and arrays
; 1277 :         return _It + 0;
; 1278 :     } else if constexpr (_Unwrappable_v<_Iter>) {
; 1279 :         return static_cast<_Iter&&>(_It)._Unwrapped();

	mov	eax, DWORD PTR [ecx]

; 1280 :     } else {
; 1281 :         return static_cast<_Iter&&>(_It);
; 1282 :     }
; 1283 : }

	ret	0
??$_Get_unwrapped@ABV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@ULight@CROS_impl@@@std@@@std@@@std@@@std@@YA?A_TABV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@ULight@CROS_impl@@@std@@@std@@@0@@Z ENDP ; std::_Get_unwrapped<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CROS_impl::Light> > > const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef
;	COMDAT ??$addressof@V?$_Vector_val@U?$_Simple_types@ULight@CROS_impl@@@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@ULight@CROS_impl@@@std@@@0@AAV10@@Z
_TEXT	SEGMENT
??$addressof@V?$_Vector_val@U?$_Simple_types@ULight@CROS_impl@@@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@ULight@CROS_impl@@@std@@@0@AAV10@@Z PROC ; std::addressof<std::_Vector_val<std::_Simple_types<CROS_impl::Light> > >, COMDAT
; __Val$ = ecx

; 253  :     return __builtin_addressof(_Val);

	mov	eax, ecx

; 254  : }

	ret	0
??$addressof@V?$_Vector_val@U?$_Simple_types@ULight@CROS_impl@@@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@ULight@CROS_impl@@@std@@@0@AAV10@@Z ENDP ; std::addressof<std::_Vector_val<std::_Simple_types<CROS_impl::Light> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\type_traits
;	COMDAT ??$move@AAULight@CROS_impl@@@std@@YA$$QAULight@CROS_impl@@AAU12@@Z
_TEXT	SEGMENT
??$move@AAULight@CROS_impl@@@std@@YA$$QAULight@CROS_impl@@AAU12@@Z PROC ; std::move<CROS_impl::Light &>, COMDAT
; __Arg$ = ecx

; 1397 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

	mov	eax, ecx

; 1398 : }

	ret	0
??$move@AAULight@CROS_impl@@@std@@YA$$QAULight@CROS_impl@@AAU12@@Z ENDP ; std::move<CROS_impl::Light &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\type_traits
;	COMDAT ??$forward@ULight@CROS_impl@@@std@@YA$$QAULight@CROS_impl@@AAU12@@Z
_TEXT	SEGMENT
??$forward@ULight@CROS_impl@@@std@@YA$$QAULight@CROS_impl@@AAU12@@Z PROC ; std::forward<CROS_impl::Light>, COMDAT
; __Arg$ = ecx

; 1386 :     return static_cast<_Ty&&>(_Arg);

	mov	eax, ecx

; 1387 : }

	ret	0
??$forward@ULight@CROS_impl@@@std@@YA$$QAULight@CROS_impl@@AAU12@@Z ENDP ; std::forward<CROS_impl::Light>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef
;	COMDAT ??$_Unfancy@ULight@CROS_impl@@@std@@YAPAULight@CROS_impl@@PAU12@@Z
_TEXT	SEGMENT
??$_Unfancy@ULight@CROS_impl@@@std@@YAPAULight@CROS_impl@@PAU12@@Z PROC ; std::_Unfancy<CROS_impl::Light>, COMDAT
; __Ptr$ = ecx

; 266  :     return _Ptr;

	mov	eax, ecx

; 267  : }

	ret	0
??$_Unfancy@ULight@CROS_impl@@@std@@YAPAULight@CROS_impl@@PAU12@@Z ENDP ; std::_Unfancy<CROS_impl::Light>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$construct@ULight@CROS_impl@@U12@@?$_Normal_allocator_traits@V?$xalloc@ULight@CROS_impl@@@@@std@@SAXAAV?$xalloc@ULight@CROS_impl@@@@PAULight@CROS_impl@@$$QAU34@@Z
_TEXT	SEGMENT
_<_Args_0>$ = 8						; size = 4
??$construct@ULight@CROS_impl@@U12@@?$_Normal_allocator_traits@V?$xalloc@ULight@CROS_impl@@@@@std@@SAXAAV?$xalloc@ULight@CROS_impl@@@@PAULight@CROS_impl@@$$QAU34@@Z PROC ; std::_Normal_allocator_traits<xalloc<CROS_impl::Light> >::construct<CROS_impl::Light,CROS_impl::Light>, COMDAT
; __Al$dead$ = ecx
; __Ptr$ = edx
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	ecx, DWORD PTR _<_Args_0>$[esp-4]
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], eax
	mov	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+8], eax
	mov	eax, DWORD PTR [ecx+12]
	mov	DWORD PTR [edx+12], eax
	mov	eax, DWORD PTR [ecx+16]
	mov	DWORD PTR [edx+16], eax
	mov	eax, DWORD PTR [ecx+20]
	mov	DWORD PTR [edx+20], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 575  :     }

	ret	0
??$construct@ULight@CROS_impl@@U12@@?$_Normal_allocator_traits@V?$xalloc@ULight@CROS_impl@@@@@std@@SAXAAV?$xalloc@ULight@CROS_impl@@@@PAULight@CROS_impl@@$$QAU34@@Z ENDP ; std::_Normal_allocator_traits<xalloc<CROS_impl::Light> >::construct<CROS_impl::Light,CROS_impl::Light>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??$_Emplace_reallocate@ULight@CROS_impl@@@?$vector@ULight@CROS_impl@@V?$xalloc@ULight@CROS_impl@@@@@std@@QAEPAULight@CROS_impl@@QAU23@$$QAU23@@Z
_TEXT	SEGMENT
__Backout$2 = -44					; size = 12
__Newvec$ = -32						; size = 4
__Oldsize$1$ = -28					; size = 4
__UFirst$3 = -24					; size = 4
tv435 = -20						; size = 4
__Whereoff$1$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Whereptr$ = 8						; size = 4
__ULast$1$ = 12						; size = 4
_<_Val_0>$ = 12						; size = 4
??$_Emplace_reallocate@ULight@CROS_impl@@@?$vector@ULight@CROS_impl@@V?$xalloc@ULight@CROS_impl@@@@@std@@QAEPAULight@CROS_impl@@QAU23@$$QAU23@@Z PROC ; std::vector<CROS_impl::Light,xalloc<CROS_impl::Light> >::_Emplace_reallocate<CROS_impl::Light>, COMDAT
; _this$ = ecx

; 752  :     _CONSTEXPR20_CONTAINER pointer _Emplace_reallocate(const pointer _Whereptr, _Valty&&... _Val) {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Emplace_reallocate@ULight@CROS_impl@@@?$vector@ULight@CROS_impl@@V?$xalloc@ULight@CROS_impl@@@@@std@@QAEPAULight@CROS_impl@@QAU23@$$QAU23@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 32					; 00000020H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	edi, ecx

; 753  :         // reallocate and insert by perfectly forwarding _Val at _Whereptr
; 754  :         _Alty& _Al        = _Getal();
; 755  :         auto& _My_data    = _Mypair._Myval2;
; 756  :         pointer& _Myfirst = _My_data._Myfirst;
; 757  :         pointer& _Mylast  = _My_data._Mylast;
; 758  : 
; 759  :         _STL_INTERNAL_CHECK(_Mylast == _My_data._Myend); // check that we have no unused capacity
; 760  : 
; 761  :         const auto _Whereoff = static_cast<size_type>(_Whereptr - _Myfirst);

	mov	ecx, DWORD PTR [edi]
	mov	edx, DWORD PTR __Whereptr$[ebp]
	sub	edx, ecx
	mov	eax, 715827883				; 2aaaaaabH
	imul	edx
	sar	edx, 2
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	mov	DWORD PTR __Whereoff$1$[ebp], eax

; 762  :         const auto _Oldsize  = static_cast<size_type>(_Mylast - _Myfirst);

	mov	eax, DWORD PTR [edi+4]
	sub	eax, ecx
	sar	eax, 3
	imul	eax, eax, -1431655765
	mov	DWORD PTR __Oldsize$1$[ebp], eax

; 763  : 
; 764  :         if (_Oldsize == max_size()) {

	cmp	eax, 178956970				; 0aaaaaaaH
	je	$LN58@Emplace_re

; 766  :         }
; 767  : 
; 768  :         const size_type _Newsize     = _Oldsize + 1;

	lea	ebx, DWORD PTR [eax+1]

; 1546 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	eax, DWORD PTR [edi+8]
	sub	eax, ecx
	sar	eax, 3
	imul	edx, eax, -1431655765

; 1675 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	ecx, edx
	shr	ecx, 1
	mov	eax, 178956970				; 0aaaaaaaH
	sub	eax, ecx
	cmp	edx, eax
	jbe	SHORT $LN12@Emplace_re

; 1676 :             return _Max; // geometric growth would overflow

	mov	esi, 178956970				; 0aaaaaaaH
	jmp	SHORT $LN13@Emplace_re
$LN12@Emplace_re:

; 1677 :         }
; 1678 : 
; 1679 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	lea	esi, DWORD PTR [ecx+edx]

; 1680 : 
; 1681 :         if (_Geometric < _Newsize) {

	cmp	esi, ebx
	cmovb	esi, ebx
$LN13@Emplace_re:
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	lea	eax, DWORD PTR [esi+esi*2]
	shl	eax, 3
	push	eax
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 771  :         const pointer _Newvec           = _Al.allocate(_Newcapacity);

	mov	ebx, eax
	mov	DWORD PTR __Newvec$[ebp], ebx

; 772  :         const pointer _Constructed_last = _Newvec + _Whereoff + 1;
; 773  :         pointer _Constructed_first      = _Constructed_last;
; 774  : 
; 775  :         _TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 776  :         _Alty_traits::construct(_Al, _Unfancy(_Newvec + _Whereoff), _STD forward<_Valty>(_Val)...);

	mov	eax, DWORD PTR __Whereoff$1$[ebp]
	lea	ecx, DWORD PTR [eax+eax*2]
	lea	edx, DWORD PTR [ebx+ecx*8]
	mov	DWORD PTR tv435[ebp], edx
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	ecx, DWORD PTR _<_Val_0>$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], eax
	mov	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+8], eax
	mov	eax, DWORD PTR [ecx+12]
	mov	DWORD PTR [edx+12], eax
	mov	eax, DWORD PTR [ecx+16]
	mov	DWORD PTR [edx+16], eax
	mov	eax, DWORD PTR [ecx+20]
	mov	DWORD PTR [edx+20], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 779  :         if (_Whereptr == _Mylast) { // at back, provide strong guarantee

	mov	eax, DWORD PTR [edi+4]
	mov	DWORD PTR __ULast$1$[ebp], eax
	mov	ecx, DWORD PTR [edi]
	mov	edx, DWORD PTR __Whereptr$[ebp]
	cmp	edx, eax
	jne	SHORT $LN4@Emplace_re
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1703 :     auto _UFirst      = _Get_unwrapped(_First);

	mov	DWORD PTR __UFirst$3[ebp], ecx

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	DWORD PTR __Backout$2[ebp], ebx
	mov	edx, ebx
	mov	DWORD PTR __Backout$2[ebp+4], edx
	mov	DWORD PTR __Backout$2[ebp+8], edi
$LL32@Emplace_re:

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	ecx, eax
	je	SHORT $LN31@Emplace_re
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], eax
	mov	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+8], eax
	mov	eax, DWORD PTR [ecx+12]
	mov	DWORD PTR [edx+12], eax
	mov	eax, DWORD PTR [ecx+16]
	mov	DWORD PTR [edx+16], eax
	mov	eax, DWORD PTR [ecx+20]
	mov	DWORD PTR [edx+20], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1621 :         ++_Last;

	add	edx, 24					; 00000018H
	mov	DWORD PTR __Backout$2[ebp+4], edx

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	add	ecx, 24					; 00000018H
	mov	DWORD PTR __UFirst$3[ebp], ecx
	mov	eax, DWORD PTR __ULast$1$[ebp]
	jmp	SHORT $LL32@Emplace_re
$LN31@Emplace_re:

; 1625 :         _First = _Last;

	mov	DWORD PTR __Backout$2[ebp], edx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 781  :         } else { // provide basic guarantee

	jmp	SHORT $LN5@Emplace_re
$LN4@Emplace_re:

; 782  :             _Umove(_Myfirst, _Whereptr, _Newvec);

	push	ebx
	push	edx
	push	ecx
	call	?_Umove@?$vector@ULight@CROS_impl@@V?$xalloc@ULight@CROS_impl@@@@@std@@AAEPAULight@CROS_impl@@PAU34@00@Z ; std::vector<CROS_impl::Light,xalloc<CROS_impl::Light> >::_Umove

; 783  :             _Constructed_first = _Newvec;
; 784  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

	mov	ecx, DWORD PTR tv435[ebp]
	lea	eax, DWORD PTR [ecx+24]
	push	eax
	push	DWORD PTR [edi+4]
	push	DWORD PTR __Whereptr$[ebp]
	call	?_Umove@?$vector@ULight@CROS_impl@@V?$xalloc@ULight@CROS_impl@@@@@std@@AAEPAULight@CROS_impl@@PAU34@00@Z ; std::vector<CROS_impl::Light,xalloc<CROS_impl::Light> >::_Umove
$LN5@Emplace_re:
	mov	DWORD PTR __$EHRec$[ebp+12], -1

; 1732 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [edi]
	test	eax, eax
	je	SHORT $LN50@Emplace_re
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	push	eax
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN50@Emplace_re:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1737 :         _Myfirst = _Newvec;

	mov	DWORD PTR [edi], ebx

; 1738 :         _Mylast  = _Newvec + _Newsize;

	mov	eax, DWORD PTR __Oldsize$1$[ebp]
	inc	eax
	lea	ecx, DWORD PTR [eax+eax*2]
	lea	ecx, DWORD PTR [ebx+ecx*8]
	mov	DWORD PTR [edi+4], ecx

; 1739 :         _Myend   = _Newvec + _Newcapacity;

	lea	ecx, DWORD PTR [esi+esi*2]
	lea	ecx, DWORD PTR [ebx+ecx*8]
	mov	DWORD PTR [edi+8], ecx

; 790  :         _CATCH_END
; 791  : 
; 792  :         _Change_array(_Newvec, _Newsize, _Newcapacity);
; 793  :         return _Newvec + _Whereoff;

	mov	eax, DWORD PTR tv435[ebp]

; 794  :     }

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
__catch$??$_Emplace_reallocate@ULight@CROS_impl@@@?$vector@ULight@CROS_impl@@V?$xalloc@ULight@CROS_impl@@@@@std@@QAEPAULight@CROS_impl@@QAU23@$$QAU23@@Z$0:

; 785  :         }
; 786  :         _CATCH_ALL
; 787  :         _Destroy(_Constructed_first, _Constructed_last);
; 788  :         _Al.deallocate(_Newvec, _Newcapacity);

	push	ecx
	push	DWORD PTR __Newvec$[ebp]
	call	?deallocate@?$xalloc@ULight@CROS_impl@@@@QBEXPAULight@CROS_impl@@I@Z ; xalloc<CROS_impl::Light>::deallocate

; 789  :         _RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$LN58@Emplace_re:

; 765  :             _Xlength();

	call	?_Xlength@?$vector@ULight@CROS_impl@@V?$xalloc@ULight@CROS_impl@@@@@std@@CAXXZ ; std::vector<CROS_impl::Light,xalloc<CROS_impl::Light> >::_Xlength
$LN56@Emplace_re:
	int	3
	int	3
	int	3
	int	3
	int	3
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Emplace_reallocate@ULight@CROS_impl@@@?$vector@ULight@CROS_impl@@V?$xalloc@ULight@CROS_impl@@@@@std@@QAEPAULight@CROS_impl@@QAU23@$$QAU23@@Z:
	npad	1
	npad	1
	mov	eax, OFFSET __ehfuncinfo$??$_Emplace_reallocate@ULight@CROS_impl@@@?$vector@ULight@CROS_impl@@V?$xalloc@ULight@CROS_impl@@@@@std@@QAEPAULight@CROS_impl@@QAU23@$$QAU23@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Emplace_reallocate@ULight@CROS_impl@@@?$vector@ULight@CROS_impl@@V?$xalloc@ULight@CROS_impl@@@@@std@@QAEPAULight@CROS_impl@@QAU23@$$QAU23@@Z ENDP ; std::vector<CROS_impl::Light,xalloc<CROS_impl::Light> >::_Emplace_reallocate<CROS_impl::Light>
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef
;	COMDAT ??$addressof@V?$_Vector_val@U?$_Simple_types@UItem@CROS_impl@@@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@UItem@CROS_impl@@@std@@@0@AAV10@@Z
_TEXT	SEGMENT
??$addressof@V?$_Vector_val@U?$_Simple_types@UItem@CROS_impl@@@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@UItem@CROS_impl@@@std@@@0@AAV10@@Z PROC ; std::addressof<std::_Vector_val<std::_Simple_types<CROS_impl::Item> > >, COMDAT
; __Val$ = ecx

; 253  :     return __builtin_addressof(_Val);

	mov	eax, ecx

; 254  : }

	ret	0
??$addressof@V?$_Vector_val@U?$_Simple_types@UItem@CROS_impl@@@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@UItem@CROS_impl@@@std@@@0@AAV10@@Z ENDP ; std::addressof<std::_Vector_val<std::_Simple_types<CROS_impl::Item> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_Move_unchecked@PAUItem@CROS_impl@@PAU12@@std@@YAPAUItem@CROS_impl@@PAU12@00@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
??$_Move_unchecked@PAUItem@CROS_impl@@PAU12@@std@@YAPAUItem@CROS_impl@@PAU12@00@Z PROC ; std::_Move_unchecked<CROS_impl::Item *,CROS_impl::Item *>, COMDAT
; __First$ = ecx
; __Last$ = edx

; 4308 : _CONSTEXPR20 _OutIt _Move_unchecked(_InIt _First, _InIt _Last, _OutIt _Dest) {

	push	esi

; 4066 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	esi, DWORD PTR __Dest$[esp]

; 4308 : _CONSTEXPR20 _OutIt _Move_unchecked(_InIt _First, _InIt _Last, _OutIt _Dest) {

	push	edi
	mov	edi, edx

; 4065 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	sub	edi, ecx

; 4066 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	push	edi
	push	ecx
	push	esi
	call	_memmove
	add	esp, 12					; 0000000cH

; 4067 :     if constexpr (is_pointer_v<_OutCtgIt>) {
; 4068 :         return reinterpret_cast<_OutCtgIt>(_Dest_ch + _Count);

	lea	eax, DWORD PTR [edi+esi]

; 4309 :     // move [_First, _Last) to [_Dest, ...)
; 4310 :     // note: _Move_unchecked has callers other than the move family
; 4311 :     if constexpr (_Ptr_move_cat<_InIt, _OutIt>::_Trivially_copyable) {
; 4312 : #ifdef __cpp_lib_is_constant_evaluated
; 4313 :         if (!_STD is_constant_evaluated())
; 4314 : #endif // __cpp_lib_is_constant_evaluated
; 4315 :         {
; 4316 :             return _Copy_memmove(_First, _Last, _Dest);

	pop	edi
	pop	esi

; 4317 :         }
; 4318 :     }
; 4319 : 
; 4320 :     for (; _First != _Last; ++_Dest, (void) ++_First) {
; 4321 :         *_Dest = _STD move(*_First);
; 4322 :     }
; 4323 : 
; 4324 :     return _Dest;
; 4325 : }

	ret	0
??$_Move_unchecked@PAUItem@CROS_impl@@PAU12@@std@@YAPAUItem@CROS_impl@@PAU12@00@Z ENDP ; std::_Move_unchecked<CROS_impl::Item *,CROS_impl::Item *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef
;	COMDAT ??$_Unfancy@UItem@CROS_impl@@@std@@YAPAUItem@CROS_impl@@PAU12@@Z
_TEXT	SEGMENT
??$_Unfancy@UItem@CROS_impl@@@std@@YAPAUItem@CROS_impl@@PAU12@@Z PROC ; std::_Unfancy<CROS_impl::Item>, COMDAT
; __Ptr$ = ecx

; 266  :     return _Ptr;

	mov	eax, ecx

; 267  : }

	ret	0
??$_Unfancy@UItem@CROS_impl@@@std@@YAPAUItem@CROS_impl@@PAU12@@Z ENDP ; std::_Unfancy<CROS_impl::Item>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$destroy@UItem@CROS_impl@@@?$_Normal_allocator_traits@V?$xalloc@UItem@CROS_impl@@@@@std@@SAXAAV?$xalloc@UItem@CROS_impl@@@@PAUItem@CROS_impl@@@Z
_TEXT	SEGMENT
??$destroy@UItem@CROS_impl@@@?$_Normal_allocator_traits@V?$xalloc@UItem@CROS_impl@@@@@std@@SAXAAV?$xalloc@UItem@CROS_impl@@@@PAUItem@CROS_impl@@@Z PROC ; std::_Normal_allocator_traits<xalloc<CROS_impl::Item> >::destroy<CROS_impl::Item>, COMDAT
; __Al$dead$ = ecx
; __Ptr$dead$ = edx

; 579  :         if constexpr (_Uses_default_destroy<_Alloc, _Ty*>::value) {
; 580  : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 581  :             _STD destroy_at(_Ptr);
; 582  : #else // __cpp_lib_constexpr_dynamic_alloc
; 583  :             _Ptr->~_Ty();
; 584  : #endif // __cpp_lib_constexpr_dynamic_alloc
; 585  :         } else {
; 586  :             _Al.destroy(_Ptr);
; 587  :         }
; 588  :     }

	ret	0
??$destroy@UItem@CROS_impl@@@?$_Normal_allocator_traits@V?$xalloc@UItem@CROS_impl@@@@@std@@SAXAAV?$xalloc@UItem@CROS_impl@@@@PAUItem@CROS_impl@@@Z ENDP ; std::_Normal_allocator_traits<xalloc<CROS_impl::Item> >::destroy<CROS_impl::Item>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\type_traits
;	COMDAT ??$move@AAUItem@CROS_impl@@@std@@YA$$QAUItem@CROS_impl@@AAU12@@Z
_TEXT	SEGMENT
??$move@AAUItem@CROS_impl@@@std@@YA$$QAUItem@CROS_impl@@AAU12@@Z PROC ; std::move<CROS_impl::Item &>, COMDAT
; __Arg$ = ecx

; 1397 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

	mov	eax, ecx

; 1398 : }

	ret	0
??$move@AAUItem@CROS_impl@@@std@@YA$$QAUItem@CROS_impl@@AAU12@@Z ENDP ; std::move<CROS_impl::Item &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\type_traits
;	COMDAT ??$forward@UItem@CROS_impl@@@std@@YA$$QAUItem@CROS_impl@@AAU12@@Z
_TEXT	SEGMENT
??$forward@UItem@CROS_impl@@@std@@YA$$QAUItem@CROS_impl@@AAU12@@Z PROC ; std::forward<CROS_impl::Item>, COMDAT
; __Arg$ = ecx

; 1386 :     return static_cast<_Ty&&>(_Arg);

	mov	eax, ecx

; 1387 : }

	ret	0
??$forward@UItem@CROS_impl@@@std@@YA$$QAUItem@CROS_impl@@AAU12@@Z ENDP ; std::forward<CROS_impl::Item>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$construct@UItem@CROS_impl@@U12@@?$_Normal_allocator_traits@V?$xalloc@UItem@CROS_impl@@@@@std@@SAXAAV?$xalloc@UItem@CROS_impl@@@@PAUItem@CROS_impl@@$$QAU34@@Z
_TEXT	SEGMENT
_<_Args_0>$ = 8						; size = 4
??$construct@UItem@CROS_impl@@U12@@?$_Normal_allocator_traits@V?$xalloc@UItem@CROS_impl@@@@@std@@SAXAAV?$xalloc@UItem@CROS_impl@@@@PAUItem@CROS_impl@@$$QAU34@@Z PROC ; std::_Normal_allocator_traits<xalloc<CROS_impl::Item> >::construct<CROS_impl::Item,CROS_impl::Item>, COMDAT
; __Al$dead$ = ecx
; __Ptr$ = edx

; 564  :     static _CONSTEXPR20_DYNALLOC void construct(_Alloc& _Al, _Ty* _Ptr, _Types&&... _Args) {

	push	esi
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	esi, DWORD PTR _<_Args_0>$[esp]
	mov	ecx, 21					; 00000015H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 564  :     static _CONSTEXPR20_DYNALLOC void construct(_Alloc& _Al, _Ty* _Ptr, _Types&&... _Args) {

	push	edi
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	edi, edx
	rep movsd
	pop	edi
	pop	esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 575  :     }

	ret	0
??$construct@UItem@CROS_impl@@U12@@?$_Normal_allocator_traits@V?$xalloc@UItem@CROS_impl@@@@@std@@SAXAAV?$xalloc@UItem@CROS_impl@@@@PAUItem@CROS_impl@@$$QAU34@@Z ENDP ; std::_Normal_allocator_traits<xalloc<CROS_impl::Item> >::construct<CROS_impl::Item,CROS_impl::Item>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??$_Emplace_reallocate@UItem@CROS_impl@@@?$vector@UItem@CROS_impl@@V?$xalloc@UItem@CROS_impl@@@@@std@@QAEPAUItem@CROS_impl@@QAU23@$$QAU23@@Z
_TEXT	SEGMENT
__Backout$2 = -48					; size = 12
__Oldsize$1$ = -36					; size = 4
__UFirst$3 = -32					; size = 4
__Newvec$ = -28						; size = 4
__Newcapacity$1$ = -24					; size = 4
tv474 = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Whereptr$ = 8						; size = 4
__ULast$1$ = 12						; size = 4
_<_Val_0>$ = 12						; size = 4
??$_Emplace_reallocate@UItem@CROS_impl@@@?$vector@UItem@CROS_impl@@V?$xalloc@UItem@CROS_impl@@@@@std@@QAEPAUItem@CROS_impl@@QAU23@$$QAU23@@Z PROC ; std::vector<CROS_impl::Item,xalloc<CROS_impl::Item> >::_Emplace_reallocate<CROS_impl::Item>, COMDAT
; _this$ = ecx

; 752  :     _CONSTEXPR20_CONTAINER pointer _Emplace_reallocate(const pointer _Whereptr, _Valty&&... _Val) {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Emplace_reallocate@UItem@CROS_impl@@@?$vector@UItem@CROS_impl@@V?$xalloc@UItem@CROS_impl@@@@@std@@QAEPAUItem@CROS_impl@@QAU23@$$QAU23@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 36					; 00000024H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	ebx, ecx

; 753  :         // reallocate and insert by perfectly forwarding _Val at _Whereptr
; 754  :         _Alty& _Al        = _Getal();
; 755  :         auto& _My_data    = _Mypair._Myval2;
; 756  :         pointer& _Myfirst = _My_data._Myfirst;
; 757  :         pointer& _Mylast  = _My_data._Mylast;
; 758  : 
; 759  :         _STL_INTERNAL_CHECK(_Mylast == _My_data._Myend); // check that we have no unused capacity
; 760  : 
; 761  :         const auto _Whereoff = static_cast<size_type>(_Whereptr - _Myfirst);

	mov	ecx, DWORD PTR [ebx]
	mov	edx, DWORD PTR __Whereptr$[ebp]
	sub	edx, ecx
	mov	eax, 818089009				; 30c30c31H
	imul	edx
	sar	edx, 4
	mov	esi, edx
	shr	esi, 31					; 0000001fH
	add	esi, edx

; 762  :         const auto _Oldsize  = static_cast<size_type>(_Mylast - _Myfirst);

	mov	eax, DWORD PTR [ebx+4]
	sub	eax, ecx
	sar	eax, 2
	imul	eax, eax, 1022611261
	mov	DWORD PTR __Oldsize$1$[ebp], eax

; 763  : 
; 764  :         if (_Oldsize == max_size()) {

	cmp	eax, 51130563				; 030c30c3H
	je	$LN59@Emplace_re

; 766  :         }
; 767  : 
; 768  :         const size_type _Newsize     = _Oldsize + 1;

	lea	edi, DWORD PTR [eax+1]

; 1546 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	eax, DWORD PTR [ebx+8]
	sub	eax, ecx
	sar	eax, 2
	imul	edx, eax, 1022611261

; 1675 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	ecx, edx
	shr	ecx, 1
	mov	eax, 51130563				; 030c30c3H
	sub	eax, ecx
	cmp	edx, eax
	jbe	SHORT $LN12@Emplace_re

; 1676 :             return _Max; // geometric growth would overflow

	mov	eax, 51130563				; 030c30c3H
	jmp	SHORT $LN57@Emplace_re
$LN12@Emplace_re:

; 1677 :         }
; 1678 : 
; 1679 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	lea	eax, DWORD PTR [ecx+edx]

; 1680 : 
; 1681 :         if (_Geometric < _Newsize) {

	cmp	eax, edi
	cmovb	eax, edi
$LN57@Emplace_re:
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	mov	DWORD PTR __Newcapacity$1$[ebp], eax
	imul	eax, eax, 84
	push	eax
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 771  :         const pointer _Newvec           = _Al.allocate(_Newcapacity);

	mov	edx, eax
	mov	DWORD PTR __Newvec$[ebp], edx

; 772  :         const pointer _Constructed_last = _Newvec + _Whereoff + 1;
; 773  :         pointer _Constructed_first      = _Constructed_last;
; 774  : 
; 775  :         _TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 776  :         _Alty_traits::construct(_Al, _Unfancy(_Newvec + _Whereoff), _STD forward<_Valty>(_Val)...);

	imul	eax, esi, 84
	add	eax, edx
	mov	DWORD PTR tv474[ebp], eax
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	ecx, 21					; 00000015H
	mov	esi, DWORD PTR _<_Val_0>$[ebp]
	mov	edi, eax
	rep movsd
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 779  :         if (_Whereptr == _Mylast) { // at back, provide strong guarantee

	mov	ecx, DWORD PTR [ebx+4]
	mov	DWORD PTR __ULast$1$[ebp], ecx
	mov	eax, DWORD PTR [ebx]
	mov	esi, DWORD PTR __Whereptr$[ebp]
	cmp	esi, ecx
	jne	SHORT $LN4@Emplace_re
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1703 :     auto _UFirst      = _Get_unwrapped(_First);

	mov	DWORD PTR __UFirst$3[ebp], eax

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	DWORD PTR __Backout$2[ebp], edx
	mov	DWORD PTR __Backout$2[ebp+4], edx
	mov	DWORD PTR __Backout$2[ebp+8], ebx
$LL32@Emplace_re:

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	eax, ecx
	je	SHORT $LN31@Emplace_re
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	ecx, 21					; 00000015H
	mov	esi, eax
	mov	edi, edx
	rep movsd
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1621 :         ++_Last;

	add	edx, 84					; 00000054H
	mov	DWORD PTR __Backout$2[ebp+4], edx

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	add	eax, 84					; 00000054H
	mov	DWORD PTR __UFirst$3[ebp], eax
	mov	ecx, DWORD PTR __ULast$1$[ebp]
	jmp	SHORT $LL32@Emplace_re
$LN31@Emplace_re:

; 1625 :         _First = _Last;

	mov	DWORD PTR __Backout$2[ebp], edx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 781  :         } else { // provide basic guarantee

	mov	edi, DWORD PTR tv474[ebp]
	jmp	SHORT $LN5@Emplace_re
$LN4@Emplace_re:

; 782  :             _Umove(_Myfirst, _Whereptr, _Newvec);

	push	edx
	push	esi
	push	eax
	call	?_Umove@?$vector@UItem@CROS_impl@@V?$xalloc@UItem@CROS_impl@@@@@std@@AAEPAUItem@CROS_impl@@PAU34@00@Z ; std::vector<CROS_impl::Item,xalloc<CROS_impl::Item> >::_Umove

; 783  :             _Constructed_first = _Newvec;
; 784  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

	mov	edi, DWORD PTR tv474[ebp]
	lea	eax, DWORD PTR [edi+84]
	push	eax
	push	DWORD PTR [ebx+4]
	push	esi
	call	?_Umove@?$vector@UItem@CROS_impl@@V?$xalloc@UItem@CROS_impl@@@@@std@@AAEPAUItem@CROS_impl@@PAU34@00@Z ; std::vector<CROS_impl::Item,xalloc<CROS_impl::Item> >::_Umove
$LN5@Emplace_re:
	mov	DWORD PTR __$EHRec$[ebp+12], -1

; 1732 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [ebx]
	test	eax, eax
	je	SHORT $LN50@Emplace_re
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	push	eax
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN50@Emplace_re:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1737 :         _Myfirst = _Newvec;

	mov	eax, DWORD PTR __Newvec$[ebp]
	mov	DWORD PTR [ebx], eax

; 1738 :         _Mylast  = _Newvec + _Newsize;

	mov	ecx, DWORD PTR __Oldsize$1$[ebp]
	inc	ecx
	imul	ecx, ecx, 84
	add	ecx, eax
	mov	DWORD PTR [ebx+4], ecx

; 1739 :         _Myend   = _Newvec + _Newcapacity;

	imul	ecx, DWORD PTR __Newcapacity$1$[ebp], 84
	add	ecx, eax
	mov	DWORD PTR [ebx+8], ecx

; 790  :         _CATCH_END
; 791  : 
; 792  :         _Change_array(_Newvec, _Newsize, _Newcapacity);
; 793  :         return _Newvec + _Whereoff;

	mov	eax, edi

; 794  :     }

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
__catch$??$_Emplace_reallocate@UItem@CROS_impl@@@?$vector@UItem@CROS_impl@@V?$xalloc@UItem@CROS_impl@@@@@std@@QAEPAUItem@CROS_impl@@QAU23@$$QAU23@@Z$0:

; 785  :         }
; 786  :         _CATCH_ALL
; 787  :         _Destroy(_Constructed_first, _Constructed_last);
; 788  :         _Al.deallocate(_Newvec, _Newcapacity);

	push	ecx
	push	DWORD PTR __Newvec$[ebp]
	call	?deallocate@?$xalloc@UItem@CROS_impl@@@@QBEXPAUItem@CROS_impl@@I@Z ; xalloc<CROS_impl::Item>::deallocate

; 789  :         _RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$LN59@Emplace_re:

; 765  :             _Xlength();

	call	?_Xlength@?$vector@UItem@CROS_impl@@V?$xalloc@UItem@CROS_impl@@@@@std@@CAXXZ ; std::vector<CROS_impl::Item,xalloc<CROS_impl::Item> >::_Xlength
$LN56@Emplace_re:
	int	3
	int	3
	int	3
	int	3
	int	3
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Emplace_reallocate@UItem@CROS_impl@@@?$vector@UItem@CROS_impl@@V?$xalloc@UItem@CROS_impl@@@@@std@@QAEPAUItem@CROS_impl@@QAU23@$$QAU23@@Z:
	npad	1
	npad	1
	mov	eax, OFFSET __ehfuncinfo$??$_Emplace_reallocate@UItem@CROS_impl@@@?$vector@UItem@CROS_impl@@V?$xalloc@UItem@CROS_impl@@@@@std@@QAEPAUItem@CROS_impl@@QAU23@$$QAU23@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Emplace_reallocate@UItem@CROS_impl@@@?$vector@UItem@CROS_impl@@V?$xalloc@UItem@CROS_impl@@@@@std@@QAEPAUItem@CROS_impl@@QAU23@$$QAU23@@Z ENDP ; std::vector<CROS_impl::Item,xalloc<CROS_impl::Item> >::_Emplace_reallocate<CROS_impl::Item>
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$?0$$V@?$_Compressed_pair@V?$xalloc@ULight@CROS_impl@@@@V?$_Vector_val@U?$_Simple_types@ULight@CROS_impl@@@std@@@std@@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$?0$$V@?$_Compressed_pair@V?$xalloc@ULight@CROS_impl@@@@V?$_Vector_val@U?$_Simple_types@ULight@CROS_impl@@@std@@@std@@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<xalloc<CROS_impl::Light>,std::_Vector_val<std::_Simple_types<CROS_impl::Light> >,1>::_Compressed_pair<xalloc<CROS_impl::Light>,std::_Vector_val<std::_Simple_types<CROS_impl::Light> >,1><>, COMDAT
; _this$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1331 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	eax, ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1331 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	ret	4
??$?0$$V@?$_Compressed_pair@V?$xalloc@ULight@CROS_impl@@@@V?$_Vector_val@U?$_Simple_types@ULight@CROS_impl@@@std@@@std@@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<xalloc<CROS_impl::Light>,std::_Vector_val<std::_Simple_types<CROS_impl::Light> >,1>::_Compressed_pair<xalloc<CROS_impl::Light>,std::_Vector_val<std::_Simple_types<CROS_impl::Light> >,1><>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$?0$$V@?$_Compressed_pair@V?$xalloc@UItem@CROS_impl@@@@V?$_Vector_val@U?$_Simple_types@UItem@CROS_impl@@@std@@@std@@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$?0$$V@?$_Compressed_pair@V?$xalloc@UItem@CROS_impl@@@@V?$_Vector_val@U?$_Simple_types@UItem@CROS_impl@@@std@@@std@@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<xalloc<CROS_impl::Item>,std::_Vector_val<std::_Simple_types<CROS_impl::Item> >,1>::_Compressed_pair<xalloc<CROS_impl::Item>,std::_Vector_val<std::_Simple_types<CROS_impl::Item> >,1><>, COMDAT
; _this$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1331 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	eax, ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1331 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	ret	4
??$?0$$V@?$_Compressed_pair@V?$xalloc@UItem@CROS_impl@@@@V?$_Vector_val@U?$_Simple_types@UItem@CROS_impl@@@std@@@std@@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<xalloc<CROS_impl::Item>,std::_Vector_val<std::_Simple_types<CROS_impl::Item> >,1>::_Compressed_pair<xalloc<CROS_impl::Item>,std::_Vector_val<std::_Simple_types<CROS_impl::Item> >,1><>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef
;	COMDAT ??$addressof@V?$_Vector_val@U?$_Simple_types@PAVISpatial@@@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@PAVISpatial@@@std@@@0@AAV10@@Z
_TEXT	SEGMENT
??$addressof@V?$_Vector_val@U?$_Simple_types@PAVISpatial@@@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@PAVISpatial@@@std@@@0@AAV10@@Z PROC ; std::addressof<std::_Vector_val<std::_Simple_types<ISpatial *> > >, COMDAT
; __Val$ = ecx

; 253  :     return __builtin_addressof(_Val);

	mov	eax, ecx

; 254  : }

	ret	0
??$addressof@V?$_Vector_val@U?$_Simple_types@PAVISpatial@@@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@PAVISpatial@@@std@@@0@AAV10@@Z ENDP ; std::addressof<std::_Vector_val<std::_Simple_types<ISpatial *> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Destroy_range@V?$xalloc@ULight@CROS_impl@@@@@std@@YAXPAULight@CROS_impl@@QAU12@AAV?$xalloc@ULight@CROS_impl@@@@@Z
_TEXT	SEGMENT
__Al$dead$ = 8						; size = 4
??$_Destroy_range@V?$xalloc@ULight@CROS_impl@@@@@std@@YAXPAULight@CROS_impl@@QAU12@AAV?$xalloc@ULight@CROS_impl@@@@@Z PROC ; std::_Destroy_range<xalloc<CROS_impl::Light> >, COMDAT
; __First$dead$ = ecx
; __Last$dead$ = edx

; 901  :     // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
; 902  :     using _Ty = typename _Alloc::value_type;
; 903  :     if constexpr (!conjunction_v<is_trivially_destructible<_Ty>, _Uses_default_destroy<_Alloc, _Ty*>>) {
; 904  :         for (; _First != _Last; ++_First) {
; 905  :             allocator_traits<_Alloc>::destroy(_Al, _Unfancy(_First));
; 906  :         }
; 907  :     }
; 908  : }

	ret	0
??$_Destroy_range@V?$xalloc@ULight@CROS_impl@@@@@std@@YAXPAULight@CROS_impl@@QAU12@AAV?$xalloc@ULight@CROS_impl@@@@@Z ENDP ; std::_Destroy_range<xalloc<CROS_impl::Light> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
;	COMDAT ??$xr_free@ULight@CROS_impl@@@@YAXAAPAULight@CROS_impl@@@Z
_TEXT	SEGMENT
??$xr_free@ULight@CROS_impl@@@@YAXAAPAULight@CROS_impl@@@Z PROC ; xr_free<CROS_impl::Light>, COMDAT
; _P$ = ecx

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	push	esi
	mov	esi, ecx
	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN2@xr_free
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
	mov	DWORD PTR [esi], 0
$LN2@xr_free:
	pop	esi
	ret	0
??$xr_free@ULight@CROS_impl@@@@YAXAAPAULight@CROS_impl@@@Z ENDP ; xr_free<CROS_impl::Light>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Destroy_range@V?$xalloc@UItem@CROS_impl@@@@@std@@YAXPAUItem@CROS_impl@@QAU12@AAV?$xalloc@UItem@CROS_impl@@@@@Z
_TEXT	SEGMENT
__Al$dead$ = 8						; size = 4
??$_Destroy_range@V?$xalloc@UItem@CROS_impl@@@@@std@@YAXPAUItem@CROS_impl@@QAU12@AAV?$xalloc@UItem@CROS_impl@@@@@Z PROC ; std::_Destroy_range<xalloc<CROS_impl::Item> >, COMDAT
; __First$dead$ = ecx
; __Last$dead$ = edx

; 901  :     // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
; 902  :     using _Ty = typename _Alloc::value_type;
; 903  :     if constexpr (!conjunction_v<is_trivially_destructible<_Ty>, _Uses_default_destroy<_Alloc, _Ty*>>) {
; 904  :         for (; _First != _Last; ++_First) {
; 905  :             allocator_traits<_Alloc>::destroy(_Al, _Unfancy(_First));
; 906  :         }
; 907  :     }
; 908  : }

	ret	0
??$_Destroy_range@V?$xalloc@UItem@CROS_impl@@@@@std@@YAXPAUItem@CROS_impl@@QAU12@AAV?$xalloc@UItem@CROS_impl@@@@@Z ENDP ; std::_Destroy_range<xalloc<CROS_impl::Item> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
;	COMDAT ??$xr_free@UItem@CROS_impl@@@@YAXAAPAUItem@CROS_impl@@@Z
_TEXT	SEGMENT
??$xr_free@UItem@CROS_impl@@@@YAXAAPAUItem@CROS_impl@@@Z PROC ; xr_free<CROS_impl::Item>, COMDAT
; _P$ = ecx

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	push	esi
	mov	esi, ecx
	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN2@xr_free
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
	mov	DWORD PTR [esi], 0
$LN2@xr_free:
	pop	esi
	ret	0
??$xr_free@UItem@CROS_impl@@@@YAXAAPAUItem@CROS_impl@@@Z ENDP ; xr_free<CROS_impl::Item>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Unwrapped@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@ULight@CROS_impl@@@std@@@std@@@std@@QBEPAULight@CROS_impl@@XZ
_TEXT	SEGMENT
?_Unwrapped@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@ULight@CROS_impl@@@std@@@std@@@std@@QBEPAULight@CROS_impl@@XZ PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CROS_impl::Light> > >::_Unwrapped, COMDAT
; _this$ = ecx

; 328  :         return _Unfancy(this->_Ptr);

	mov	eax, DWORD PTR [ecx]

; 329  :     }

	ret	0
?_Unwrapped@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@ULight@CROS_impl@@@std@@@std@@@std@@QBEPAULight@CROS_impl@@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CROS_impl::Light> > >::_Unwrapped
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@ULight@CROS_impl@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Vector_val@U?$_Simple_types@ULight@CROS_impl@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<std::_Simple_types<CROS_impl::Light> >::_Vector_val<std::_Simple_types<CROS_impl::Light> >, COMDAT
; _this$ = ecx

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx], 0
	mov	eax, ecx
	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0
	ret	0
??0?$_Vector_val@U?$_Simple_types@ULight@CROS_impl@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<std::_Simple_types<CROS_impl::Light> >::_Vector_val<std::_Simple_types<CROS_impl::Light> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Xlength@?$vector@ULight@CROS_impl@@V?$xalloc@ULight@CROS_impl@@@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@ULight@CROS_impl@@V?$xalloc@ULight@CROS_impl@@@@@std@@CAXXZ PROC ; std::vector<CROS_impl::Light,xalloc<CROS_impl::Light> >::_Xlength, COMDAT

; 1761 :         _Xlength_error("vector too long");

	push	OFFSET ??_C@_0BA@FOIKENOD@vector?5too?5long@
	call	DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN3@Xlength:
	int	3
?_Xlength@?$vector@ULight@CROS_impl@@V?$xalloc@ULight@CROS_impl@@@@@std@@CAXXZ ENDP ; std::vector<CROS_impl::Light,xalloc<CROS_impl::Light> >::_Xlength
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Change_array@?$vector@ULight@CROS_impl@@V?$xalloc@ULight@CROS_impl@@@@@std@@AAEXQAULight@CROS_impl@@II@Z
_TEXT	SEGMENT
__Newvec$ = 8						; size = 4
__Newsize$ = 12						; size = 4
__Newcapacity$ = 16					; size = 4
?_Change_array@?$vector@ULight@CROS_impl@@V?$xalloc@ULight@CROS_impl@@@@@std@@AAEXQAULight@CROS_impl@@II@Z PROC ; std::vector<CROS_impl::Light,xalloc<CROS_impl::Light> >::_Change_array, COMDAT
; _this$ = ecx

; 1723 :         const pointer _Newvec, const size_type _Newsize, const size_type _Newcapacity) {

	push	esi
	mov	esi, ecx

; 1724 :         // orphan all iterators, discard old array, acquire new array
; 1725 :         auto& _My_data    = _Mypair._Myval2;
; 1726 :         pointer& _Myfirst = _My_data._Myfirst;
; 1727 :         pointer& _Mylast  = _My_data._Mylast;
; 1728 :         pointer& _Myend   = _My_data._Myend;
; 1729 : 
; 1730 :         _My_data._Orphan_all();
; 1731 : 
; 1732 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN7@Change_arr
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN7@Change_arr:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1737 :         _Myfirst = _Newvec;

	mov	ecx, DWORD PTR __Newvec$[esp]

; 1738 :         _Mylast  = _Newvec + _Newsize;

	mov	eax, DWORD PTR __Newsize$[esp]
	mov	DWORD PTR [esi], ecx
	lea	eax, DWORD PTR [eax+eax*2]
	lea	eax, DWORD PTR [ecx+eax*8]
	mov	DWORD PTR [esi+4], eax

; 1739 :         _Myend   = _Newvec + _Newcapacity;

	mov	eax, DWORD PTR __Newcapacity$[esp]
	lea	eax, DWORD PTR [eax+eax*2]
	lea	eax, DWORD PTR [ecx+eax*8]
	mov	DWORD PTR [esi+8], eax
	pop	esi

; 1740 :     }

	ret	12					; 0000000cH
?_Change_array@?$vector@ULight@CROS_impl@@V?$xalloc@ULight@CROS_impl@@@@@std@@AAEXQAULight@CROS_impl@@II@Z ENDP ; std::vector<CROS_impl::Light,xalloc<CROS_impl::Light> >::_Change_array
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Calculate_growth@?$vector@ULight@CROS_impl@@V?$xalloc@ULight@CROS_impl@@@@@std@@ABEII@Z
_TEXT	SEGMENT
__Newsize$ = 8						; size = 4
?_Calculate_growth@?$vector@ULight@CROS_impl@@V?$xalloc@ULight@CROS_impl@@@@@std@@ABEII@Z PROC ; std::vector<CROS_impl::Light,xalloc<CROS_impl::Light> >::_Calculate_growth, COMDAT
; _this$ = ecx

; 1546 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx]

; 1671 :         // given _Oldcapacity and _Newsize, calculate geometric growth
; 1672 :         const size_type _Oldcapacity = capacity();
; 1673 :         const auto _Max              = max_size();
; 1674 : 
; 1675 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	ecx, 178956970				; 0aaaaaaaH

; 1546 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	sar	eax, 3

; 1670 :     _CONSTEXPR20_CONTAINER size_type _Calculate_growth(const size_type _Newsize) const {

	push	esi

; 1546 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	imul	esi, eax, -1431655765

; 1671 :         // given _Oldcapacity and _Newsize, calculate geometric growth
; 1672 :         const size_type _Oldcapacity = capacity();
; 1673 :         const auto _Max              = max_size();
; 1674 : 
; 1675 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	edx, esi
	shr	edx, 1
	sub	ecx, edx
	cmp	esi, ecx
	jbe	SHORT $LN2@Calculate_

; 1676 :             return _Max; // geometric growth would overflow

	mov	eax, 178956970				; 0aaaaaaaH
	pop	esi

; 1682 :             return _Newsize; // geometric growth would be insufficient
; 1683 :         }
; 1684 : 
; 1685 :         return _Geometric; // geometric growth is sufficient
; 1686 :     }

	ret	4
$LN2@Calculate_:

; 1677 :         }
; 1678 : 
; 1679 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	lea	eax, DWORD PTR [edx+esi]

; 1680 : 
; 1681 :         if (_Geometric < _Newsize) {

	cmp	eax, DWORD PTR __Newsize$[esp]
	pop	esi
	cmovb	eax, DWORD PTR __Newsize$[esp-4]

; 1682 :             return _Newsize; // geometric growth would be insufficient
; 1683 :         }
; 1684 : 
; 1685 :         return _Geometric; // geometric growth is sufficient
; 1686 :     }

	ret	4
?_Calculate_growth@?$vector@ULight@CROS_impl@@V?$xalloc@ULight@CROS_impl@@@@@std@@ABEII@Z ENDP ; std::vector<CROS_impl::Light,xalloc<CROS_impl::Light> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Umove_if_noexcept@?$vector@ULight@CROS_impl@@V?$xalloc@ULight@CROS_impl@@@@@std@@AAEXPAULight@CROS_impl@@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
?_Umove_if_noexcept@?$vector@ULight@CROS_impl@@V?$xalloc@ULight@CROS_impl@@@@@std@@AAEXPAULight@CROS_impl@@00@Z PROC ; std::vector<CROS_impl::Light,xalloc<CROS_impl::Light> >::_Umove_if_noexcept, COMDAT
; _this$dead$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1703 :     auto _UFirst      = _Get_unwrapped(_First);

	mov	eax, DWORD PTR __First$[esp-4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1659 :     _CONSTEXPR20_CONTAINER void _Umove_if_noexcept(pointer _First, pointer _Last, pointer _Dest) {

	push	esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	mov	esi, DWORD PTR __Last$[esp]
	cmp	eax, esi
	je	SHORT $LN7@Umove_if_n

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	edx, DWORD PTR __Dest$[esp]
	sub	edx, eax
$LL8@Umove_if_n:
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx+eax], ecx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+eax+4], ecx
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR [edx+eax+8], ecx
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR [edx+eax+12], ecx
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR [edx+eax+16], ecx
	mov	ecx, DWORD PTR [eax+20]
	mov	DWORD PTR [edx+eax+20], ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	add	eax, 24					; 00000018H
	cmp	eax, esi
	jne	SHORT $LL8@Umove_if_n
$LN7@Umove_if_n:
	pop	esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1663 :     }

	ret	12					; 0000000cH
?_Umove_if_noexcept@?$vector@ULight@CROS_impl@@V?$xalloc@ULight@CROS_impl@@@@@std@@AAEXPAULight@CROS_impl@@00@Z ENDP ; std::vector<CROS_impl::Light,xalloc<CROS_impl::Light> >::_Umove_if_noexcept
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Umove@?$vector@ULight@CROS_impl@@V?$xalloc@ULight@CROS_impl@@@@@std@@AAEPAULight@CROS_impl@@PAU34@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
?_Umove@?$vector@ULight@CROS_impl@@V?$xalloc@ULight@CROS_impl@@@@@std@@AAEPAULight@CROS_impl@@PAU34@00@Z PROC ; std::vector<CROS_impl::Light,xalloc<CROS_impl::Light> >::_Umove, COMDAT
; _this$dead$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	mov	ecx, DWORD PTR __First$[esp-4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1644 :     _CONSTEXPR20_CONTAINER pointer _Umove(pointer _First, pointer _Last, pointer _Dest) {

	push	esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	esi, DWORD PTR __Dest$[esp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1644 :     _CONSTEXPR20_CONTAINER pointer _Umove(pointer _First, pointer _Last, pointer _Dest) {

	push	edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	mov	edi, DWORD PTR __Last$[esp+4]
	cmp	ecx, edi
	je	SHORT $LN22@Umove
$LL6@Umove:
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [esi], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [esi+4], eax
	mov	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR [esi+8], eax
	mov	eax, DWORD PTR [ecx+12]
	mov	DWORD PTR [esi+12], eax
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR [esi+16], edx
	mov	edx, DWORD PTR [ecx+20]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1621 :         ++_Last;

	add	ecx, 24					; 00000018H
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	DWORD PTR [esi+20], edx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1621 :         ++_Last;

	add	esi, 24					; 00000018H

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	ecx, edi
	jne	SHORT $LL6@Umove
$LN22@Umove:
	pop	edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1647 :     }

	mov	eax, esi
	pop	esi
	ret	12					; 0000000cH
?_Umove@?$vector@ULight@CROS_impl@@V?$xalloc@ULight@CROS_impl@@@@@std@@AAEPAULight@CROS_impl@@PAU34@00@Z ENDP ; std::vector<CROS_impl::Light,xalloc<CROS_impl::Light> >::_Umove
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?max_size@?$vector@ULight@CROS_impl@@V?$xalloc@ULight@CROS_impl@@@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@ULight@CROS_impl@@V?$xalloc@ULight@CROS_impl@@@@@std@@QBEIXZ PROC ; std::vector<CROS_impl::Light,xalloc<CROS_impl::Light> >::max_size, COMDAT
; _this$dead$ = ecx

; 1540 :         return (_STD min)(

	mov	eax, 178956970				; 0aaaaaaaH

; 1541 :             static_cast<size_type>((numeric_limits<difference_type>::max)()), _Alty_traits::max_size(_Getal()));
; 1542 :     }

	ret	0
?max_size@?$vector@ULight@CROS_impl@@V?$xalloc@ULight@CROS_impl@@@@@std@@QBEIXZ ENDP ; std::vector<CROS_impl::Light,xalloc<CROS_impl::Light> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?construct@?$xalloc@ULight@CROS_impl@@@@QAEXPAULight@CROS_impl@@ABU23@@Z
_TEXT	SEGMENT
_p$ = 8							; size = 4
__Val$ = 12						; size = 4
?construct@?$xalloc@ULight@CROS_impl@@@@QAEXPAULight@CROS_impl@@ABU23@@Z PROC ; xalloc<CROS_impl::Light>::construct, COMDAT
; _this$dead$ = ecx

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	edx, DWORD PTR __Val$[esp-4]
	mov	ecx, DWORD PTR _p$[esp-4]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+4], eax
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR [ecx+8], eax
	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR [ecx+12], eax
	mov	eax, DWORD PTR [edx+16]
	mov	DWORD PTR [ecx+16], eax
	mov	eax, DWORD PTR [edx+20]
	mov	DWORD PTR [ecx+20], eax
	ret	8
?construct@?$xalloc@ULight@CROS_impl@@@@QAEXPAULight@CROS_impl@@ABU23@@Z ENDP ; xalloc<CROS_impl::Light>::construct
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?allocate@?$xalloc@ULight@CROS_impl@@@@QBEPAULight@CROS_impl@@IPBX@Z
_TEXT	SEGMENT
_n$ = 8							; size = 4
_p$dead$ = 12						; size = 4
?allocate@?$xalloc@ULight@CROS_impl@@@@QBEPAULight@CROS_impl@@IPBX@Z PROC ; xalloc<CROS_impl::Light>::allocate, COMDAT
; _this$dead$ = ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	mov	eax, DWORD PTR _n$[esp-4]
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	lea	eax, DWORD PTR [eax+eax*2]
	shl	eax, 3
	push	eax
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 80   : 							pointer					allocate		(size_type n, const void* p=0) const	{	return xr_alloc<T>((u32)n);	}

	ret	8
?allocate@?$xalloc@ULight@CROS_impl@@@@QBEPAULight@CROS_impl@@IPBX@Z ENDP ; xalloc<CROS_impl::Light>::allocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ??0?$xalloc@ULight@CROS_impl@@@@QAE@XZ
_TEXT	SEGMENT
??0?$xalloc@ULight@CROS_impl@@@@QAE@XZ PROC		; xalloc<CROS_impl::Light>::xalloc<CROS_impl::Light>, COMDAT
; _this$ = ecx

; 76   : 													xalloc			()										{	}

	mov	eax, ecx
	ret	0
??0?$xalloc@ULight@CROS_impl@@@@QAE@XZ ENDP		; xalloc<CROS_impl::Light>::xalloc<CROS_impl::Light>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@UItem@CROS_impl@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Vector_val@U?$_Simple_types@UItem@CROS_impl@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<std::_Simple_types<CROS_impl::Item> >::_Vector_val<std::_Simple_types<CROS_impl::Item> >, COMDAT
; _this$ = ecx

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx], 0
	mov	eax, ecx
	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0
	ret	0
??0?$_Vector_val@U?$_Simple_types@UItem@CROS_impl@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<std::_Simple_types<CROS_impl::Item> >::_Vector_val<std::_Simple_types<CROS_impl::Item> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Xlength@?$vector@UItem@CROS_impl@@V?$xalloc@UItem@CROS_impl@@@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@UItem@CROS_impl@@V?$xalloc@UItem@CROS_impl@@@@@std@@CAXXZ PROC ; std::vector<CROS_impl::Item,xalloc<CROS_impl::Item> >::_Xlength, COMDAT

; 1761 :         _Xlength_error("vector too long");

	push	OFFSET ??_C@_0BA@FOIKENOD@vector?5too?5long@
	call	DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN3@Xlength:
	int	3
?_Xlength@?$vector@UItem@CROS_impl@@V?$xalloc@UItem@CROS_impl@@@@@std@@CAXXZ ENDP ; std::vector<CROS_impl::Item,xalloc<CROS_impl::Item> >::_Xlength
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Change_array@?$vector@UItem@CROS_impl@@V?$xalloc@UItem@CROS_impl@@@@@std@@AAEXQAUItem@CROS_impl@@II@Z
_TEXT	SEGMENT
__Newvec$ = 8						; size = 4
__Newsize$ = 12						; size = 4
__Newcapacity$ = 16					; size = 4
?_Change_array@?$vector@UItem@CROS_impl@@V?$xalloc@UItem@CROS_impl@@@@@std@@AAEXQAUItem@CROS_impl@@II@Z PROC ; std::vector<CROS_impl::Item,xalloc<CROS_impl::Item> >::_Change_array, COMDAT
; _this$ = ecx

; 1723 :         const pointer _Newvec, const size_type _Newsize, const size_type _Newcapacity) {

	push	esi
	mov	esi, ecx

; 1724 :         // orphan all iterators, discard old array, acquire new array
; 1725 :         auto& _My_data    = _Mypair._Myval2;
; 1726 :         pointer& _Myfirst = _My_data._Myfirst;
; 1727 :         pointer& _Mylast  = _My_data._Mylast;
; 1728 :         pointer& _Myend   = _My_data._Myend;
; 1729 : 
; 1730 :         _My_data._Orphan_all();
; 1731 : 
; 1732 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN7@Change_arr
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN7@Change_arr:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1738 :         _Mylast  = _Newvec + _Newsize;

	imul	eax, DWORD PTR __Newsize$[esp], 84
	mov	ecx, DWORD PTR __Newvec$[esp]
	mov	DWORD PTR [esi], ecx
	add	eax, ecx
	mov	DWORD PTR [esi+4], eax

; 1739 :         _Myend   = _Newvec + _Newcapacity;

	imul	eax, DWORD PTR __Newcapacity$[esp], 84
	add	eax, ecx
	mov	DWORD PTR [esi+8], eax
	pop	esi

; 1740 :     }

	ret	12					; 0000000cH
?_Change_array@?$vector@UItem@CROS_impl@@V?$xalloc@UItem@CROS_impl@@@@@std@@AAEXQAUItem@CROS_impl@@II@Z ENDP ; std::vector<CROS_impl::Item,xalloc<CROS_impl::Item> >::_Change_array
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Calculate_growth@?$vector@UItem@CROS_impl@@V?$xalloc@UItem@CROS_impl@@@@@std@@ABEII@Z
_TEXT	SEGMENT
__Newsize$ = 8						; size = 4
?_Calculate_growth@?$vector@UItem@CROS_impl@@V?$xalloc@UItem@CROS_impl@@@@@std@@ABEII@Z PROC ; std::vector<CROS_impl::Item,xalloc<CROS_impl::Item> >::_Calculate_growth, COMDAT
; _this$ = ecx

; 1546 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx]

; 1671 :         // given _Oldcapacity and _Newsize, calculate geometric growth
; 1672 :         const size_type _Oldcapacity = capacity();
; 1673 :         const auto _Max              = max_size();
; 1674 : 
; 1675 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	ecx, 51130563				; 030c30c3H

; 1546 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	sar	eax, 2

; 1670 :     _CONSTEXPR20_CONTAINER size_type _Calculate_growth(const size_type _Newsize) const {

	push	esi

; 1546 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	imul	esi, eax, 1022611261

; 1671 :         // given _Oldcapacity and _Newsize, calculate geometric growth
; 1672 :         const size_type _Oldcapacity = capacity();
; 1673 :         const auto _Max              = max_size();
; 1674 : 
; 1675 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	edx, esi
	shr	edx, 1
	sub	ecx, edx
	cmp	esi, ecx
	jbe	SHORT $LN2@Calculate_

; 1676 :             return _Max; // geometric growth would overflow

	mov	eax, 51130563				; 030c30c3H
	pop	esi

; 1682 :             return _Newsize; // geometric growth would be insufficient
; 1683 :         }
; 1684 : 
; 1685 :         return _Geometric; // geometric growth is sufficient
; 1686 :     }

	ret	4
$LN2@Calculate_:

; 1677 :         }
; 1678 : 
; 1679 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	lea	eax, DWORD PTR [edx+esi]

; 1680 : 
; 1681 :         if (_Geometric < _Newsize) {

	cmp	eax, DWORD PTR __Newsize$[esp]
	pop	esi
	cmovb	eax, DWORD PTR __Newsize$[esp-4]

; 1682 :             return _Newsize; // geometric growth would be insufficient
; 1683 :         }
; 1684 : 
; 1685 :         return _Geometric; // geometric growth is sufficient
; 1686 :     }

	ret	4
?_Calculate_growth@?$vector@UItem@CROS_impl@@V?$xalloc@UItem@CROS_impl@@@@@std@@ABEII@Z ENDP ; std::vector<CROS_impl::Item,xalloc<CROS_impl::Item> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Umove_if_noexcept@?$vector@UItem@CROS_impl@@V?$xalloc@UItem@CROS_impl@@@@@std@@AAEXPAUItem@CROS_impl@@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
?_Umove_if_noexcept@?$vector@UItem@CROS_impl@@V?$xalloc@UItem@CROS_impl@@@@@std@@AAEXPAUItem@CROS_impl@@00@Z PROC ; std::vector<CROS_impl::Item,xalloc<CROS_impl::Item> >::_Umove_if_noexcept, COMDAT
; _this$dead$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1703 :     auto _UFirst      = _Get_unwrapped(_First);

	mov	eax, DWORD PTR __First$[esp-4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1659 :     _CONSTEXPR20_CONTAINER void _Umove_if_noexcept(pointer _First, pointer _Last, pointer _Dest) {

	push	ebx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	mov	ebx, DWORD PTR __Last$[esp]
	cmp	eax, ebx
	je	SHORT $LN7@Umove_if_n

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	edx, DWORD PTR __Dest$[esp]
	push	esi
	sub	edx, eax
	push	edi
$LL8@Umove_if_n:
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	lea	edi, DWORD PTR [edx+eax]
	mov	esi, eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	add	eax, 84					; 00000054H
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	ecx, 21					; 00000015H
	rep movsd
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	eax, ebx
	jne	SHORT $LL8@Umove_if_n
	pop	edi
	pop	esi
$LN7@Umove_if_n:
	pop	ebx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1663 :     }

	ret	12					; 0000000cH
?_Umove_if_noexcept@?$vector@UItem@CROS_impl@@V?$xalloc@UItem@CROS_impl@@@@@std@@AAEXPAUItem@CROS_impl@@00@Z ENDP ; std::vector<CROS_impl::Item,xalloc<CROS_impl::Item> >::_Umove_if_noexcept
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Umove@?$vector@UItem@CROS_impl@@V?$xalloc@UItem@CROS_impl@@@@@std@@AAEPAUItem@CROS_impl@@PAU34@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
?_Umove@?$vector@UItem@CROS_impl@@V?$xalloc@UItem@CROS_impl@@@@@std@@AAEPAUItem@CROS_impl@@PAU34@00@Z PROC ; std::vector<CROS_impl::Item,xalloc<CROS_impl::Item> >::_Umove, COMDAT
; _this$dead$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	mov	edx, DWORD PTR __First$[esp-4]

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	eax, DWORD PTR __Dest$[esp-4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1644 :     _CONSTEXPR20_CONTAINER pointer _Umove(pointer _First, pointer _Last, pointer _Dest) {

	push	ebx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	mov	ebx, DWORD PTR __Last$[esp]
	cmp	edx, ebx
	je	SHORT $LN5@Umove
	push	esi
	push	edi
$LL6@Umove:
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	esi, edx
	mov	edi, eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1621 :         ++_Last;

	add	edx, 84					; 00000054H
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	ecx, 21					; 00000015H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1621 :         ++_Last;

	add	eax, 84					; 00000054H
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	rep movsd
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	edx, ebx
	jne	SHORT $LL6@Umove
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1646 :         return _Uninitialized_move(_First, _Last, _Dest, _Getal());

	pop	edi
	pop	esi
$LN5@Umove:

; 1647 :     }

	pop	ebx
	ret	12					; 0000000cH
?_Umove@?$vector@UItem@CROS_impl@@V?$xalloc@UItem@CROS_impl@@@@@std@@AAEPAUItem@CROS_impl@@PAU34@00@Z ENDP ; std::vector<CROS_impl::Item,xalloc<CROS_impl::Item> >::_Umove
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?max_size@?$vector@UItem@CROS_impl@@V?$xalloc@UItem@CROS_impl@@@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@UItem@CROS_impl@@V?$xalloc@UItem@CROS_impl@@@@@std@@QBEIXZ PROC ; std::vector<CROS_impl::Item,xalloc<CROS_impl::Item> >::max_size, COMDAT
; _this$dead$ = ecx

; 1540 :         return (_STD min)(

	mov	eax, 51130563				; 030c30c3H

; 1541 :             static_cast<size_type>((numeric_limits<difference_type>::max)()), _Alty_traits::max_size(_Getal()));
; 1542 :     }

	ret	0
?max_size@?$vector@UItem@CROS_impl@@V?$xalloc@UItem@CROS_impl@@@@@std@@QBEIXZ ENDP ; std::vector<CROS_impl::Item,xalloc<CROS_impl::Item> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?destroy@?$xalloc@UItem@CROS_impl@@@@QAEXPAUItem@CROS_impl@@@Z
_TEXT	SEGMENT
_p$dead$ = 8						; size = 4
?destroy@?$xalloc@UItem@CROS_impl@@@@QAEXPAUItem@CROS_impl@@@Z PROC ; xalloc<CROS_impl::Item>::destroy, COMDAT
; _this$dead$ = ecx

; 85   : 							void					destroy			(pointer p)								{	std::_Destroy_in_place(p);			}

	ret	4
?destroy@?$xalloc@UItem@CROS_impl@@@@QAEXPAUItem@CROS_impl@@@Z ENDP ; xalloc<CROS_impl::Item>::destroy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?construct@?$xalloc@UItem@CROS_impl@@@@QAEXPAUItem@CROS_impl@@ABU23@@Z
_TEXT	SEGMENT
_p$ = 8							; size = 4
__Val$ = 12						; size = 4
?construct@?$xalloc@UItem@CROS_impl@@@@QAEXPAUItem@CROS_impl@@ABU23@@Z PROC ; xalloc<CROS_impl::Item>::construct, COMDAT
; _this$dead$ = ecx

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	push	esi
	mov	esi, DWORD PTR __Val$[esp]
	mov	ecx, 21					; 00000015H
	push	edi
	mov	edi, DWORD PTR _p$[esp+4]
	rep movsd
	pop	edi
	pop	esi
	ret	8
?construct@?$xalloc@UItem@CROS_impl@@@@QAEXPAUItem@CROS_impl@@ABU23@@Z ENDP ; xalloc<CROS_impl::Item>::construct
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?allocate@?$xalloc@UItem@CROS_impl@@@@QBEPAUItem@CROS_impl@@IPBX@Z
_TEXT	SEGMENT
_n$ = 8							; size = 4
_p$dead$ = 12						; size = 4
?allocate@?$xalloc@UItem@CROS_impl@@@@QBEPAUItem@CROS_impl@@IPBX@Z PROC ; xalloc<CROS_impl::Item>::allocate, COMDAT
; _this$dead$ = ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	imul	eax, DWORD PTR _n$[esp-4], 84
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 80   : 							pointer					allocate		(size_type n, const void* p=0) const	{	return xr_alloc<T>((u32)n);	}

	ret	8
?allocate@?$xalloc@UItem@CROS_impl@@@@QBEPAUItem@CROS_impl@@IPBX@Z ENDP ; xalloc<CROS_impl::Item>::allocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ??0?$xalloc@UItem@CROS_impl@@@@QAE@XZ
_TEXT	SEGMENT
??0?$xalloc@UItem@CROS_impl@@@@QAE@XZ PROC		; xalloc<CROS_impl::Item>::xalloc<CROS_impl::Item>, COMDAT
; _this$ = ecx

; 76   : 													xalloc			()										{	}

	mov	eax, ecx
	ret	0
??0?$xalloc@UItem@CROS_impl@@@@QAE@XZ ENDP		; xalloc<CROS_impl::Item>::xalloc<CROS_impl::Item>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Getal@?$vector@ULight@CROS_impl@@V?$xalloc@ULight@CROS_impl@@@@@std@@ABEABV?$xalloc@ULight@CROS_impl@@@@XZ
_TEXT	SEGMENT
?_Getal@?$vector@ULight@CROS_impl@@V?$xalloc@ULight@CROS_impl@@@@@std@@ABEABV?$xalloc@ULight@CROS_impl@@@@XZ PROC ; std::vector<CROS_impl::Light,xalloc<CROS_impl::Light> >::_Getal, COMDAT
; _this$ = ecx

; 1809 :         return _Mypair._Get_first();

	mov	eax, ecx

; 1810 :     }

	ret	0
?_Getal@?$vector@ULight@CROS_impl@@V?$xalloc@ULight@CROS_impl@@@@@std@@ABEABV?$xalloc@ULight@CROS_impl@@@@XZ ENDP ; std::vector<CROS_impl::Light,xalloc<CROS_impl::Light> >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Umove_if_noexcept1@?$vector@ULight@CROS_impl@@V?$xalloc@ULight@CROS_impl@@@@@std@@AAEXPAULight@CROS_impl@@00U?$integral_constant@_N$00@2@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
?_Umove_if_noexcept1@?$vector@ULight@CROS_impl@@V?$xalloc@ULight@CROS_impl@@@@@std@@AAEXPAULight@CROS_impl@@00U?$integral_constant@_N$00@2@@Z PROC ; std::vector<CROS_impl::Light,xalloc<CROS_impl::Light> >::_Umove_if_noexcept1, COMDAT
; _this$dead$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1703 :     auto _UFirst      = _Get_unwrapped(_First);

	mov	eax, DWORD PTR __First$[esp-4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1649 :     _CONSTEXPR20_CONTAINER void _Umove_if_noexcept1(pointer _First, pointer _Last, pointer _Dest, true_type) {

	push	esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	mov	esi, DWORD PTR __Last$[esp]
	cmp	eax, esi
	je	SHORT $LN5@Umove_if_n

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	edx, DWORD PTR __Dest$[esp]
	sub	edx, eax
$LL6@Umove_if_n:
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx+eax], ecx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+eax+4], ecx
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR [edx+eax+8], ecx
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR [edx+eax+12], ecx
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR [edx+eax+16], ecx
	mov	ecx, DWORD PTR [eax+20]
	mov	DWORD PTR [edx+eax+20], ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	add	eax, 24					; 00000018H
	cmp	eax, esi
	jne	SHORT $LL6@Umove_if_n
$LN5@Umove_if_n:
	pop	esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1652 :     }

	ret	16					; 00000010H
?_Umove_if_noexcept1@?$vector@ULight@CROS_impl@@V?$xalloc@ULight@CROS_impl@@@@@std@@AAEXPAULight@CROS_impl@@00U?$integral_constant@_N$00@2@@Z ENDP ; std::vector<CROS_impl::Light,xalloc<CROS_impl::Light> >::_Umove_if_noexcept1
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?capacity@?$vector@ULight@CROS_impl@@V?$xalloc@ULight@CROS_impl@@@@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@ULight@CROS_impl@@V?$xalloc@ULight@CROS_impl@@@@@std@@QBEIXZ PROC ; std::vector<CROS_impl::Light,xalloc<CROS_impl::Light> >::capacity, COMDAT
; _this$ = ecx

; 1545 :         auto& _My_data = _Mypair._Myval2;
; 1546 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx]
	sar	eax, 3
	imul	eax, eax, -1431655765

; 1547 :     }

	ret	0
?capacity@?$vector@ULight@CROS_impl@@V?$xalloc@ULight@CROS_impl@@@@@std@@QBEIXZ ENDP ; std::vector<CROS_impl::Light,xalloc<CROS_impl::Light> >::capacity
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?max_size@?$_Normal_allocator_traits@V?$xalloc@ULight@CROS_impl@@@@@std@@SAIABV?$xalloc@ULight@CROS_impl@@@@@Z
_TEXT	SEGMENT
?max_size@?$_Normal_allocator_traits@V?$xalloc@ULight@CROS_impl@@@@@std@@SAIABV?$xalloc@ULight@CROS_impl@@@@@Z PROC ; std::_Normal_allocator_traits<xalloc<CROS_impl::Light> >::max_size, COMDAT
; __Al$dead$ = ecx

; 591  :         if constexpr (_Has_max_size<_Alloc>::value) {
; 592  :             return _Al.max_size();

	mov	eax, 178956970				; 0aaaaaaaH

; 593  :         } else {
; 594  :             return (numeric_limits<size_type>::max)() / sizeof(value_type);
; 595  :         }
; 596  :     }

	ret	0
?max_size@?$_Normal_allocator_traits@V?$xalloc@ULight@CROS_impl@@@@@std@@SAIABV?$xalloc@ULight@CROS_impl@@@@@Z ENDP ; std::_Normal_allocator_traits<xalloc<CROS_impl::Light> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Getal@?$vector@UItem@CROS_impl@@V?$xalloc@UItem@CROS_impl@@@@@std@@ABEABV?$xalloc@UItem@CROS_impl@@@@XZ
_TEXT	SEGMENT
?_Getal@?$vector@UItem@CROS_impl@@V?$xalloc@UItem@CROS_impl@@@@@std@@ABEABV?$xalloc@UItem@CROS_impl@@@@XZ PROC ; std::vector<CROS_impl::Item,xalloc<CROS_impl::Item> >::_Getal, COMDAT
; _this$ = ecx

; 1809 :         return _Mypair._Get_first();

	mov	eax, ecx

; 1810 :     }

	ret	0
?_Getal@?$vector@UItem@CROS_impl@@V?$xalloc@UItem@CROS_impl@@@@@std@@ABEABV?$xalloc@UItem@CROS_impl@@@@XZ ENDP ; std::vector<CROS_impl::Item,xalloc<CROS_impl::Item> >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Umove_if_noexcept1@?$vector@UItem@CROS_impl@@V?$xalloc@UItem@CROS_impl@@@@@std@@AAEXPAUItem@CROS_impl@@00U?$integral_constant@_N$00@2@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
?_Umove_if_noexcept1@?$vector@UItem@CROS_impl@@V?$xalloc@UItem@CROS_impl@@@@@std@@AAEXPAUItem@CROS_impl@@00U?$integral_constant@_N$00@2@@Z PROC ; std::vector<CROS_impl::Item,xalloc<CROS_impl::Item> >::_Umove_if_noexcept1, COMDAT
; _this$dead$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1703 :     auto _UFirst      = _Get_unwrapped(_First);

	mov	eax, DWORD PTR __First$[esp-4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1649 :     _CONSTEXPR20_CONTAINER void _Umove_if_noexcept1(pointer _First, pointer _Last, pointer _Dest, true_type) {

	push	ebx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	mov	ebx, DWORD PTR __Last$[esp]
	cmp	eax, ebx
	je	SHORT $LN5@Umove_if_n

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	edx, DWORD PTR __Dest$[esp]
	push	esi
	sub	edx, eax
	push	edi
$LL6@Umove_if_n:
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	lea	edi, DWORD PTR [edx+eax]
	mov	esi, eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	add	eax, 84					; 00000054H
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	ecx, 21					; 00000015H
	rep movsd
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	eax, ebx
	jne	SHORT $LL6@Umove_if_n
	pop	edi
	pop	esi
$LN5@Umove_if_n:
	pop	ebx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1652 :     }

	ret	16					; 00000010H
?_Umove_if_noexcept1@?$vector@UItem@CROS_impl@@V?$xalloc@UItem@CROS_impl@@@@@std@@AAEXPAUItem@CROS_impl@@00U?$integral_constant@_N$00@2@@Z ENDP ; std::vector<CROS_impl::Item,xalloc<CROS_impl::Item> >::_Umove_if_noexcept1
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?capacity@?$vector@UItem@CROS_impl@@V?$xalloc@UItem@CROS_impl@@@@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@UItem@CROS_impl@@V?$xalloc@UItem@CROS_impl@@@@@std@@QBEIXZ PROC ; std::vector<CROS_impl::Item,xalloc<CROS_impl::Item> >::capacity, COMDAT
; _this$ = ecx

; 1545 :         auto& _My_data = _Mypair._Myval2;
; 1546 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx]
	sar	eax, 2
	imul	eax, eax, 1022611261

; 1547 :     }

	ret	0
?capacity@?$vector@UItem@CROS_impl@@V?$xalloc@UItem@CROS_impl@@@@@std@@QBEIXZ ENDP ; std::vector<CROS_impl::Item,xalloc<CROS_impl::Item> >::capacity
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?max_size@?$_Normal_allocator_traits@V?$xalloc@UItem@CROS_impl@@@@@std@@SAIABV?$xalloc@UItem@CROS_impl@@@@@Z
_TEXT	SEGMENT
?max_size@?$_Normal_allocator_traits@V?$xalloc@UItem@CROS_impl@@@@@std@@SAIABV?$xalloc@UItem@CROS_impl@@@@@Z PROC ; std::_Normal_allocator_traits<xalloc<CROS_impl::Item> >::max_size, COMDAT
; __Al$dead$ = ecx

; 591  :         if constexpr (_Has_max_size<_Alloc>::value) {
; 592  :             return _Al.max_size();

	mov	eax, 51130563				; 030c30c3H

; 593  :         } else {
; 594  :             return (numeric_limits<size_type>::max)() / sizeof(value_type);
; 595  :         }
; 596  :     }

	ret	0
?max_size@?$_Normal_allocator_traits@V?$xalloc@UItem@CROS_impl@@@@@std@@SAIABV?$xalloc@UItem@CROS_impl@@@@@Z ENDP ; std::_Normal_allocator_traits<xalloc<CROS_impl::Item> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$xalloc@ULight@CROS_impl@@@@V?$_Vector_val@U?$_Simple_types@ULight@CROS_impl@@@std@@@std@@$00@std@@QBEABV?$xalloc@ULight@CROS_impl@@@@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@V?$xalloc@ULight@CROS_impl@@@@V?$_Vector_val@U?$_Simple_types@ULight@CROS_impl@@@std@@@std@@$00@std@@QBEABV?$xalloc@ULight@CROS_impl@@@@XZ PROC ; std::_Compressed_pair<xalloc<CROS_impl::Light>,std::_Vector_val<std::_Simple_types<CROS_impl::Light> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 1343 :         return *this;

	mov	eax, ecx

; 1344 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$xalloc@ULight@CROS_impl@@@@V?$_Vector_val@U?$_Simple_types@ULight@CROS_impl@@@std@@@std@@$00@std@@QBEABV?$xalloc@ULight@CROS_impl@@@@XZ ENDP ; std::_Compressed_pair<xalloc<CROS_impl::Light>,std::_Vector_val<std::_Simple_types<CROS_impl::Light> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?max_size@?$xalloc@ULight@CROS_impl@@@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$xalloc@ULight@CROS_impl@@@@QBEIXZ PROC	; xalloc<CROS_impl::Light>::max_size, COMDAT
; _this$dead$ = ecx

; 86   : 							size_type				max_size		() const								{	size_type _Count = (size_type)(-1) / sizeof (T);	return (0 < _Count ? _Count : 1);	}

	mov	eax, 178956970				; 0aaaaaaaH
	ret	0
?max_size@?$xalloc@ULight@CROS_impl@@@@QBEIXZ ENDP	; xalloc<CROS_impl::Light>::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$xalloc@UItem@CROS_impl@@@@V?$_Vector_val@U?$_Simple_types@UItem@CROS_impl@@@std@@@std@@$00@std@@QBEABV?$xalloc@UItem@CROS_impl@@@@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@V?$xalloc@UItem@CROS_impl@@@@V?$_Vector_val@U?$_Simple_types@UItem@CROS_impl@@@std@@@std@@$00@std@@QBEABV?$xalloc@UItem@CROS_impl@@@@XZ PROC ; std::_Compressed_pair<xalloc<CROS_impl::Item>,std::_Vector_val<std::_Simple_types<CROS_impl::Item> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 1343 :         return *this;

	mov	eax, ecx

; 1344 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$xalloc@UItem@CROS_impl@@@@V?$_Vector_val@U?$_Simple_types@UItem@CROS_impl@@@std@@@std@@$00@std@@QBEABV?$xalloc@UItem@CROS_impl@@@@XZ ENDP ; std::_Compressed_pair<xalloc<CROS_impl::Item>,std::_Vector_val<std::_Simple_types<CROS_impl::Item> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?max_size@?$xalloc@UItem@CROS_impl@@@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$xalloc@UItem@CROS_impl@@@@QBEIXZ PROC	; xalloc<CROS_impl::Item>::max_size, COMDAT
; _this$dead$ = ecx

; 86   : 							size_type				max_size		() const								{	size_type _Count = (size_type)(-1) / sizeof (T);	return (0 < _Count ? _Count : 1);	}

	mov	eax, 51130563				; 030c30c3H
	ret	0
?max_size@?$xalloc@UItem@CROS_impl@@@@QBEIXZ ENDP	; xalloc<CROS_impl::Item>::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_Adl_verify_range@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@ULight@CROS_impl@@@std@@@std@@@std@@V12@@std@@YAXABV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@ULight@CROS_impl@@@std@@@std@@@0@0@Z
_TEXT	SEGMENT
??$_Adl_verify_range@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@ULight@CROS_impl@@@std@@@std@@@std@@V12@@std@@YAXABV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@ULight@CROS_impl@@@std@@@std@@@0@0@Z PROC ; std::_Adl_verify_range<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CROS_impl::Light> > >,std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CROS_impl::Light> > > >, COMDAT
; __First$dead$ = ecx
; __Last$dead$ = edx

; 1259 :     // check that [_First, _Last) forms an iterator range
; 1260 :     if constexpr (_Range_verifiable_v<_Iter, _Sentinel>) {
; 1261 :         _Verify_range(_First, _Last);
; 1262 :     }
; 1263 : }

	ret	0
??$_Adl_verify_range@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@ULight@CROS_impl@@@std@@@std@@@std@@V12@@std@@YAXABV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@ULight@CROS_impl@@@std@@@std@@@0@0@Z ENDP ; std::_Adl_verify_range<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CROS_impl::Light> > >,std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CROS_impl::Light> > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_Pass_fn@P6A_NABULight@CROS_impl@@0@Z$0A@@std@@YAP6A_NABULight@CROS_impl@@0@ZP6A_N00@Z@Z
_TEXT	SEGMENT
??$_Pass_fn@P6A_NABULight@CROS_impl@@0@Z$0A@@std@@YAP6A_NABULight@CROS_impl@@0@ZP6A_N00@Z@Z PROC ; std::_Pass_fn<bool (__cdecl*)(CROS_impl::Light const &,CROS_impl::Light const &),0>, COMDAT
; __Val$dead$ = ecx

; 253  :     return _Val;

	mov	eax, OFFSET ?pred_energy@@YA_NABULight@CROS_impl@@0@Z ; pred_energy

; 254  : }

	ret	0
??$_Pass_fn@P6A_NABULight@CROS_impl@@0@Z$0A@@std@@YAP6A_NABULight@CROS_impl@@0@ZP6A_N00@Z@Z ENDP ; std::_Pass_fn<bool (__cdecl*)(CROS_impl::Light const &,CROS_impl::Light const &),0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
;	COMDAT ??$_Sort_unchecked@PAULight@CROS_impl@@P6A_NABU12@0@Z@std@@YAXPAULight@CROS_impl@@0HP6A_NABU12@1@Z@Z
_TEXT	SEGMENT
tv602 = -48						; size = 4
__Bottom$1$ = -48					; size = 4
__Last$1$ = -44						; size = 4
__Hole$1$ = -40						; size = 4
$T1 = -36						; size = 4
__Mid$2 = -36						; size = 8
__Val$3 = -28						; size = 24
__Val$4 = -28						; size = 24
__Val$5 = -28						; size = 24
__Ideal$ = 8						; size = 4
__Pred$ = 12						; size = 4
??$_Sort_unchecked@PAULight@CROS_impl@@P6A_NABU12@0@Z@std@@YAXPAULight@CROS_impl@@0HP6A_NABU12@1@Z@Z PROC ; std::_Sort_unchecked<CROS_impl::Light *,bool (__cdecl*)(CROS_impl::Light const &,CROS_impl::Light const &)>, COMDAT
; __First$ = ecx
; __Last$ = edx

; 7046 : _CONSTEXPR20 void _Sort_unchecked(_RanIt _First, _RanIt _Last, _Iter_diff_t<_RanIt> _Ideal, _Pr _Pred) {

	sub	esp, 52					; 00000034H
	push	ebx
	push	ebp

; 7047 :     // order [_First, _Last)
; 7048 :     for (;;) {
; 7049 :         if (_Last - _First <= _ISORT_MAX) { // small

	mov	ebp, DWORD PTR __Pred$[esp+56]
	mov	ebx, ecx
	push	esi
	push	edi
	mov	edi, edx
	mov	eax, edi
	mov	DWORD PTR __Last$1$[esp+68], edi
	sub	eax, ebx
	cmp	eax, 792				; 00000318H
	jl	SHORT $LN171@Sort_unche
	mov	esi, DWORD PTR __Ideal$[esp+64]
$LL2@Sort_unche:

; 7050 :             _Insertion_sort_unchecked(_First, _Last, _Pred);
; 7051 :             return;
; 7052 :         }
; 7053 : 
; 7054 :         if (_Ideal <= 0) { // heap sort if too many divisions

	test	esi, esi
	jle	$LN172@Sort_unche

; 7057 :             return;
; 7058 :         }
; 7059 : 
; 7060 :         // divide and conquer by quicksort
; 7061 :         auto _Mid = _Partition_by_median_guess_unchecked(_First, _Last, _Pred);

	push	ebp
	push	edi
	mov	edx, ebx
	lea	ecx, DWORD PTR __Mid$2[esp+76]
	call	??$_Partition_by_median_guess_unchecked@PAULight@CROS_impl@@P6A_NABU12@0@Z@std@@YA?AU?$pair@PAULight@CROS_impl@@PAU12@@0@PAULight@CROS_impl@@0P6A_NABU23@1@Z@Z ; std::_Partition_by_median_guess_unchecked<CROS_impl::Light *,bool (__cdecl*)(CROS_impl::Light const &,CROS_impl::Light const &)>

; 7062 : 
; 7063 :         _Ideal = (_Ideal >> 1) + (_Ideal >> 2); // allow 1.5 log2(N) divisions
; 7064 : 
; 7065 :         if (_Mid.first - _First < _Last - _Mid.second) { // loop on second half

	mov	edx, DWORD PTR __Mid$2[esp+76]
	mov	eax, esi
	sar	eax, 2
	add	esp, 8
	sar	esi, 1
	add	esi, eax
	mov	eax, edi
	sub	eax, DWORD PTR __Mid$2[esp+72]
	sar	eax, 3
	imul	ecx, eax, -1431655765
	mov	eax, edx
	sub	eax, ebx
	sar	eax, 3
	imul	eax, eax, -1431655765
	push	ebp
	push	esi
	cmp	eax, ecx
	jge	SHORT $LN7@Sort_unche

; 7066 :             _Sort_unchecked(_First, _Mid.first, _Ideal, _Pred);

	mov	ecx, ebx
	call	??$_Sort_unchecked@PAULight@CROS_impl@@P6A_NABU12@0@Z@std@@YAXPAULight@CROS_impl@@0HP6A_NABU12@1@Z@Z ; std::_Sort_unchecked<CROS_impl::Light *,bool (__cdecl*)(CROS_impl::Light const &,CROS_impl::Light const &)>

; 7067 :             _First = _Mid.second;

	mov	ebx, DWORD PTR __Mid$2[esp+80]

; 7068 :         } else { // loop on first half

	jmp	SHORT $LN189@Sort_unche
$LN7@Sort_unche:

; 7069 :             _Sort_unchecked(_Mid.second, _Last, _Ideal, _Pred);

	mov	ecx, DWORD PTR __Mid$2[esp+80]
	mov	edx, edi
	call	??$_Sort_unchecked@PAULight@CROS_impl@@P6A_NABU12@0@Z@std@@YAXPAULight@CROS_impl@@0HP6A_NABU12@1@Z@Z ; std::_Sort_unchecked<CROS_impl::Light *,bool (__cdecl*)(CROS_impl::Light const &,CROS_impl::Light const &)>

; 7070 :             _Last = _Mid.first;

	mov	edi, DWORD PTR __Mid$2[esp+76]
	mov	DWORD PTR __Last$1$[esp+76], edi
$LN189@Sort_unche:

; 7047 :     // order [_First, _Last)
; 7048 :     for (;;) {
; 7049 :         if (_Last - _First <= _ISORT_MAX) { // small

	mov	eax, edi
	add	esp, 8
	sub	eax, ebx
	cmp	eax, 792				; 00000318H
	jge	SHORT $LL2@Sort_unche
$LN171@Sort_unche:

; 6921 :     if (_First != _Last) {

	cmp	ebx, edi
	je	$LN34@Sort_unche

; 6922 :         for (_BidIt _Mid = _First; ++_Mid != _Last;) { // order next element

	lea	ebp, DWORD PTR [ebx+24]
	cmp	ebp, edi
	je	$LN34@Sort_unche
	mov	esi, ebx
	mov	DWORD PTR tv602[esp+68], ebx
$LL11@Sort_unche:

; 6923 :             _BidIt _Hole               = _Mid;
; 6924 :             _Iter_value_t<_BidIt> _Val = _STD move(*_Mid);

	mov	eax, DWORD PTR [ebp]
	mov	edi, ebp
	mov	DWORD PTR __Val$5[esp+68], eax
	mov	eax, DWORD PTR [ebp+4]
	mov	DWORD PTR __Val$5[esp+72], eax
	mov	eax, DWORD PTR [ebp+8]
	mov	DWORD PTR __Val$5[esp+76], eax
	mov	eax, DWORD PTR [ebp+12]
	mov	DWORD PTR __Val$5[esp+80], eax
	mov	eax, DWORD PTR [ebp+16]
	mov	DWORD PTR __Val$5[esp+84], eax
	mov	eax, DWORD PTR [ebp+20]
	mov	DWORD PTR __Val$5[esp+88], eax

; 6925 : 
; 6926 :             if (_DEBUG_LT_PRED(_Pred, _Val, *_First)) { // found new earliest element, move to front

	lea	eax, DWORD PTR __Val$5[esp+68]
	push	ebx
	push	eax
	call	DWORD PTR __Pred$[esp+72]
	add	esp, 8
	test	al, al
	je	$LN18@Sort_unche
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility

; 4254 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	mov	ecx, ebp

; 4255 :     auto _Result                = _CSTD memmove(_Dest_ch - _Count, _First_ch, _Count);

	mov	eax, ebp
	sub	ecx, ebx
	push	ecx
	sub	eax, ecx
	add	eax, 24					; 00000018H
	push	ebx
	push	eax
	call	_memmove
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 6928 :                 *_First = _STD move(_Val);

	mov	eax, DWORD PTR __Val$5[esp+80]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility

; 4255 :     auto _Result                = _CSTD memmove(_Dest_ch - _Count, _First_ch, _Count);

	add	esp, 12					; 0000000cH
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 6928 :                 *_First = _STD move(_Val);

	mov	DWORD PTR [ebx], eax
	mov	eax, DWORD PTR __Val$5[esp+72]
	mov	DWORD PTR [ebx+4], eax
	mov	eax, DWORD PTR __Val$5[esp+76]
	mov	DWORD PTR [ebx+8], eax
	mov	eax, DWORD PTR __Val$5[esp+80]
	mov	DWORD PTR [ebx+12], eax
	mov	eax, DWORD PTR __Val$5[esp+84]
	mov	DWORD PTR [ebx+16], eax
	mov	eax, DWORD PTR __Val$5[esp+88]
	mov	DWORD PTR [ebx+20], eax

; 6929 :             } else { // look for insertion point after first

	jmp	$LN19@Sort_unche
$LN172@Sort_unche:

; 5547 :     _Diff _Bottom = _Last - _First;

	mov	esi, edi
	sub	esi, ebx
	mov	eax, esi
	mov	DWORD PTR $T1[esp+68], esi
	sar	eax, 3
	imul	ecx, eax, -1431655765

; 5548 :     for (_Diff _Hole = _Bottom >> 1; _Hole > 0;) { // shift for codegen

	mov	eax, ecx
	mov	DWORD PTR __Bottom$1$[esp+68], ecx
	sar	eax, 1
	mov	DWORD PTR __Hole$1$[esp+68], eax
	test	eax, eax
	jle	SHORT $LN29@Sort_unche

; 5420 :         _Pop_heap_hole_unchecked(_First, _Last, _Last, _STD move(_Val), _Pred);
; 5421 :     }
; 5422 : }
; 5423 : 
; 5424 : template <class _RanIt, class _Pr>
; 5425 : _CONSTEXPR20 void pop_heap(_RanIt _First, _RanIt _Last, _Pr _Pred) {
; 5426 :     // pop *_First to *(_Last - 1) and reheap
; 5427 :     _Adl_verify_range(_First, _Last);
; 5428 :     _Pop_heap_unchecked(_Get_unwrapped(_First), _Get_unwrapped(_Last), _Pass_fn(_Pred));
; 5429 : }
; 5430 : 
; 5431 : template <class _RanIt>
; 5432 : _CONSTEXPR20 void pop_heap(_RanIt _First, _RanIt _Last) {
; 5433 :     // pop *_First to *(_Last - 1) and reheap
; 5434 :     _STD pop_heap(_First, _Last, less<>{});
; 5435 : }
; 5436 : 
; 5437 : #ifdef __cpp_lib_concepts
; 5438 : namespace ranges {
; 5439 :     // clang-format off
; 5440 :     template <random_access_iterator _It, class _Ty, class _Pr, class _Pj1, class _Pj2>
; 5441 :         requires sortable<_It, _Pr, _Pj1> && indirectly_writable<_It, _Ty>
; 5442 :             && indirect_strict_weak_order<_Pr, projected<_It, _Pj1>, projected<remove_reference_t<_Ty>*, _Pj2>>
; 5443 :     constexpr void _Pop_heap_hole_by_index(_It _First, iter_difference_t<_It> _Hole,
; 5444 :         const iter_difference_t<_It> _Bottom, _Ty&& _Val, _Pr _Pred, _Pj1 _Proj1, _Pj2 _Proj2) {
; 5445 :         // clang-format on
; 5446 :         // percolate _Hole to _Bottom, then push _Val
; 5447 :         _STL_INTERNAL_CHECK(_Hole >= 0);
; 5448 :         _STL_INTERNAL_CHECK(_Bottom > 0);
; 5449 : 
; 5450 :         using _Diff      = iter_difference_t<_It>;
; 5451 :         const _Diff _Top = _Hole;
; 5452 :         _Diff _Idx       = _Hole;
; 5453 : 
; 5454 :         // Check whether _Idx can have a child before calculating that child's index, since
; 5455 :         // calculating the child's index can trigger integer overflows
; 5456 :         const _Diff _Max_sequence_non_leaf = (_Bottom - 1) >> 1; // shift for codegen
; 5457 :         while (_Idx < _Max_sequence_non_leaf) { // move _Hole down to larger child
; 5458 :             _Idx      = 2 * _Idx + 2;
; 5459 :             auto _Mid = _First + _Idx;
; 5460 :             if (_STD invoke(_Pred, _STD invoke(_Proj1, *_Mid), _STD invoke(_Proj1, *_RANGES prev(_Mid)))) {
; 5461 :                 --_Idx;
; 5462 :                 --_Mid;
; 5463 :             }
; 5464 :             *(_First + _Hole) = _RANGES iter_move(_Mid);
; 5465 :             _Hole             = _Idx;
; 5466 :         }
; 5467 : 
; 5468 :         if (_Idx == _Max_sequence_non_leaf && _Bottom % 2 == 0) { // only child at bottom, move _Hole down to it
; 5469 :             *(_First + _Hole) = _RANGES iter_move(_First + (_Bottom - 1));
; 5470 :             _Hole             = _Bottom - 1;
; 5471 :         }
; 5472 : 
; 5473 :         _RANGES _Push_heap_by_index(_STD move(_First), _Hole, _Top, _STD forward<_Ty>(_Val), _Pred, _Proj1, _Proj2);
; 5474 :     }
; 5475 : 
; 5476 :     // clang-format off
; 5477 :     template <random_access_iterator _It, class _Ty, class _Pr, class _Pj1, class _Pj2>
; 5478 :         requires sortable<_It, _Pr, _Pj1> && indirectly_writable<_It, _Ty>
; 5479 :             && indirect_strict_weak_order<_Pr, projected<_It, _Pj1>, projected<remove_reference_t<_Ty>*, _Pj2>>
; 5480 :     constexpr void _Pop_heap_hole_unchecked(
; 5481 :         _It _First, const _It _Last, const _It _Dest, _Ty&& _Val, _Pr _Pred, _Pj1 _Proj1, _Pj2 _Proj2) {
; 5482 :         // clang-format on
; 5483 :         // pop *_First to *_Dest and reheap
; 5484 :         _STL_INTERNAL_CHECK(_First != _Last);
; 5485 :         _STL_INTERNAL_CHECK(_First != _Dest);
; 5486 : 
; 5487 :         *_Dest            = _RANGES iter_move(_First);
; 5488 :         const auto _Count = _Last - _First;
; 5489 :         _RANGES _Pop_heap_hole_by_index(_STD move(_First), 0, _Count, _STD forward<_Ty>(_Val), _Pred, _Proj1, _Proj2);
; 5490 :     }
; 5491 : 
; 5492 :     // clang-format off
; 5493 :     template <random_access_iterator _It, class _Pr, class _Pj>
; 5494 :         requires sortable<_It, _Pr, _Pj>
; 5495 :     constexpr void _Pop_heap_unchecked(_It _First, _It _Last, _Pr _Pred, _Pj _Proj) {
; 5496 :         // clang-format on
; 5497 :         // pop *_First to *(_Last - 1) and reheap
; 5498 :         if (_Last - _First < 2) {
; 5499 :             return;
; 5500 :         }
; 5501 : 
; 5502 :         --_Last;
; 5503 :         iter_value_t<_It> _Val = _RANGES iter_move(_Last);
; 5504 :         // NB: if _Proj is a _Ref_fn, this aliases the _Proj1 and _Proj2 parameters of _Pop_heap_hole_unchecked
; 5505 :         _RANGES _Pop_heap_hole_unchecked(_STD move(_First), _Last, _Last, _STD move(_Val), _Pred, _Proj, _Proj);
; 5506 :     }
; 5507 : 
; 5508 :     class _Pop_heap_fn : private _Not_quite_object {
; 5509 :     public:
; 5510 :         using _Not_quite_object::_Not_quite_object;
; 5511 : 
; 5512 :         // clang-format off
; 5513 :         template <random_access_iterator _It, sentinel_for<_It> _Se, class _Pr = ranges::less, class _Pj = identity>
; 5514 :             requires sortable<_It, _Pr, _Pj>
; 5515 :         constexpr _It operator()(_It _First, _Se _Last, _Pr _Pred = {}, _Pj _Proj = {}) const {
; 5516 :             _Adl_verify_range(_First, _Last);
; 5517 :             auto _UFirst = _Get_unwrapped(_STD move(_First));
; 5518 :             auto _ULast  = _Get_final_iterator_unwrapped<_It>(_UFirst, _STD move(_Last));
; 5519 :             _Seek_wrapped(_First, _ULast);
; 5520 :             _RANGES _Pop_heap_unchecked(_STD move(_UFirst), _STD move(_ULast), _Pass_fn(_Pred), _Pass_fn(_Proj));
; 5521 :             return _First;
; 5522 :         }
; 5523 : 
; 5524 :         template <random_access_range _Rng, class _Pr = ranges::less, class _Pj = identity>
; 5525 :             requires sortable<iterator_t<_Rng>, _Pr, _Pj>
; 5526 :         constexpr borrowed_iterator_t<_Rng> operator()(_Rng&& _Range, _Pr _Pred = {}, _Pj _Proj = {}) const {
; 5527 :             if constexpr (common_range<_Rng>) {
; 5528 :                 _RANGES _Pop_heap_unchecked(_Ubegin(_Range), _Uend(_Range), _Pass_fn(_Pred), _Pass_fn(_Proj));
; 5529 :                 return _RANGES end(_Range);
; 5530 :             } else {
; 5531 :                 auto _ULast = _Get_final_iterator_unwrapped(_Range);
; 5532 :                 _RANGES _Pop_heap_unchecked(_Ubegin(_Range), _ULast, _Pass_fn(_Pred), _Pass_fn(_Proj));
; 5533 :                 return _Rewrap_iterator(_Range, _STD move(_ULast));
; 5534 :             }
; 5535 :         }
; 5536 :         // clang-format on
; 5537 :     };
; 5538 : 
; 5539 :     inline constexpr _Pop_heap_fn pop_heap{_Not_quite_object::_Construct_tag{}};
; 5540 : } // namespace ranges
; 5541 : #endif // __cpp_lib_concepts
; 5542 : 
; 5543 : template <class _RanIt, class _Pr>
; 5544 : _CONSTEXPR20 void _Make_heap_unchecked(_RanIt _First, _RanIt _Last, _Pr _Pred) {
; 5545 :     // make [_First, _Last) into a heap
; 5546 :     using _Diff   = _Iter_diff_t<_RanIt>;
; 5547 :     _Diff _Bottom = _Last - _First;

	mov	esi, eax
	lea	eax, DWORD PTR [esi+esi*2]
	lea	edi, DWORD PTR [ebx+eax*8]
$LL176@Sort_unche:

; 5549 :         // reheap top half, bottom to top
; 5550 :         --_Hole;
; 5551 :         _Iter_value_t<_RanIt> _Val = _STD move(*(_First + _Hole));

	mov	eax, DWORD PTR [edi-24]
	lea	edi, DWORD PTR [edi-24]
	mov	DWORD PTR __Val$4[esp+68], eax
	dec	esi
	mov	eax, DWORD PTR [edi+4]

; 5552 :         _Pop_heap_hole_by_index(_First, _Hole, _Bottom, _STD move(_Val), _Pred);

	mov	edx, esi
	mov	DWORD PTR __Val$4[esp+72], eax
	mov	eax, DWORD PTR [edi+8]
	mov	DWORD PTR __Val$4[esp+76], eax
	mov	eax, DWORD PTR [edi+12]
	mov	DWORD PTR __Val$4[esp+80], eax
	mov	eax, DWORD PTR [edi+16]
	mov	DWORD PTR __Val$4[esp+84], eax
	mov	eax, DWORD PTR [edi+20]
	mov	DWORD PTR __Val$4[esp+88], eax
	lea	eax, DWORD PTR __Val$4[esp+68]
	push	ebp
	push	eax
	push	ecx
	mov	ecx, ebx
	call	??$_Pop_heap_hole_by_index@PAULight@CROS_impl@@U12@P6A_NABU12@0@Z@std@@YAXPAULight@CROS_impl@@HH$$QAU12@P6A_NABU12@2@Z@Z ; std::_Pop_heap_hole_by_index<CROS_impl::Light *,CROS_impl::Light,bool (__cdecl*)(CROS_impl::Light const &,CROS_impl::Light const &)>
	mov	ecx, DWORD PTR __Bottom$1$[esp+80]
	add	esp, 12					; 0000000cH
	test	esi, esi
	jg	SHORT $LL176@Sort_unche
	mov	esi, DWORD PTR $T1[esp+68]
	mov	edi, DWORD PTR __Last$1$[esp+68]
$LN29@Sort_unche:

; 5774 :     for (; _Last - _First >= 2; --_Last) {

	cmp	ecx, 2
	jl	$LN34@Sort_unche

; 7055 :             _Make_heap_unchecked(_First, _Last, _Pred);
; 7056 :             _Sort_heap_unchecked(_First, _Last, _Pred);

	add	edi, -24				; ffffffe8H
	npad	3
$LL35@Sort_unche:

; 5417 :     if (2 <= _Last - _First) {

	sar	esi, 3
	imul	eax, esi, -1431655765
	mov	esi, edi
	sub	esi, ebx
	cmp	eax, 2
	jl	SHORT $LN33@Sort_unche

; 5418 :         --_Last;
; 5419 :         _Iter_value_t<_RanIt> _Val = _STD move(*_Last);

	mov	eax, DWORD PTR [edi]

; 5410 :     _Pop_heap_hole_by_index(

	xor	edx, edx

; 5419 :         _Iter_value_t<_RanIt> _Val = _STD move(*_Last);

	mov	DWORD PTR __Val$3[esp+68], eax

; 5410 :     _Pop_heap_hole_by_index(

	mov	ecx, ebx

; 5419 :         _Iter_value_t<_RanIt> _Val = _STD move(*_Last);

	mov	eax, DWORD PTR [edi+4]
	mov	DWORD PTR __Val$3[esp+72], eax
	mov	eax, DWORD PTR [edi+8]
	mov	DWORD PTR __Val$3[esp+76], eax
	mov	eax, DWORD PTR [edi+12]
	mov	DWORD PTR __Val$3[esp+80], eax
	mov	eax, DWORD PTR [edi+16]
	mov	DWORD PTR __Val$3[esp+84], eax
	mov	eax, DWORD PTR [edi+20]
	mov	DWORD PTR __Val$3[esp+88], eax

; 5408 :     *_Dest      = _STD move(*_First);

	mov	eax, DWORD PTR [ebx]
	mov	DWORD PTR [edi], eax
	mov	eax, DWORD PTR [ebx+4]
	mov	DWORD PTR [edi+4], eax
	mov	eax, DWORD PTR [ebx+8]
	mov	DWORD PTR [edi+8], eax
	mov	eax, DWORD PTR [ebx+12]
	mov	DWORD PTR [edi+12], eax
	mov	eax, DWORD PTR [ebx+16]
	mov	DWORD PTR [edi+16], eax
	mov	eax, DWORD PTR [ebx+20]
	mov	DWORD PTR [edi+20], eax

; 5409 :     using _Diff = _Iter_diff_t<_RanIt>;
; 5410 :     _Pop_heap_hole_by_index(

	lea	eax, DWORD PTR __Val$3[esp+68]
	push	ebp
	push	eax
	mov	eax, esi
	sar	eax, 3
	imul	eax, eax, -1431655765
	push	eax
	call	??$_Pop_heap_hole_by_index@PAULight@CROS_impl@@U12@P6A_NABU12@0@Z@std@@YAXPAULight@CROS_impl@@HH$$QAU12@P6A_NABU12@2@Z@Z ; std::_Pop_heap_hole_by_index<CROS_impl::Light *,CROS_impl::Light,bool (__cdecl*)(CROS_impl::Light const &,CROS_impl::Light const &)>
	add	esp, 12					; 0000000cH
$LN33@Sort_unche:

; 5774 :     for (; _Last - _First >= 2; --_Last) {

	sub	edi, 24					; 00000018H
	cmp	esi, 48					; 00000030H
	jge	$LL35@Sort_unche

; 7071 :         }
; 7072 :     }
; 7073 : }

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 52					; 00000034H
	ret	0
$LN18@Sort_unche:

; 6930 :                 for (_BidIt _Prev = _Hole; _DEBUG_LT_PRED(_Pred, _Val, *--_Prev); _Hole = _Prev) {

	push	DWORD PTR tv602[esp+68]
	lea	eax, DWORD PTR __Val$5[esp+72]
	push	eax
	call	DWORD PTR __Pred$[esp+72]
	add	esp, 8
	test	al, al
	je	SHORT $LN15@Sort_unche
$LL16@Sort_unche:

; 6931 :                     *_Hole = _STD move(*_Prev); // move hole down

	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [edi], eax
	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [edi+4], eax
	mov	eax, DWORD PTR [esi+8]
	mov	DWORD PTR [edi+8], eax
	mov	eax, DWORD PTR [esi+12]
	mov	DWORD PTR [edi+12], eax
	mov	eax, DWORD PTR [esi+16]
	mov	DWORD PTR [edi+16], eax
	mov	eax, DWORD PTR [esi+20]
	mov	DWORD PTR [edi+20], eax
	mov	edi, esi
	sub	esi, 24					; 00000018H
	lea	eax, DWORD PTR __Val$5[esp+68]
	push	esi
	push	eax
	call	DWORD PTR __Pred$[esp+72]
	add	esp, 8
	test	al, al
	jne	SHORT $LL16@Sort_unche
$LN15@Sort_unche:

; 6932 :                 }
; 6933 : 
; 6934 :                 *_Hole = _STD move(_Val); // insert element in hole

	mov	eax, DWORD PTR __Val$5[esp+68]
	mov	esi, DWORD PTR tv602[esp+68]
	mov	DWORD PTR [edi], eax
	mov	eax, DWORD PTR __Val$5[esp+72]
	mov	DWORD PTR [edi+4], eax
	mov	eax, DWORD PTR __Val$5[esp+76]
	mov	DWORD PTR [edi+8], eax
	mov	eax, DWORD PTR __Val$5[esp+80]
	mov	DWORD PTR [edi+12], eax
	mov	eax, DWORD PTR __Val$5[esp+84]
	mov	DWORD PTR [edi+16], eax
	mov	eax, DWORD PTR __Val$5[esp+88]
	mov	DWORD PTR [edi+20], eax
$LN19@Sort_unche:

; 6922 :         for (_BidIt _Mid = _First; ++_Mid != _Last;) { // order next element

	add	ebp, 24					; 00000018H
	add	esi, 24					; 00000018H
	mov	DWORD PTR tv602[esp+68], esi
	cmp	ebp, DWORD PTR __Last$1$[esp+68]
	jne	$LL11@Sort_unche
$LN34@Sort_unche:

; 7071 :         }
; 7072 :     }
; 7073 : }

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 52					; 00000034H
	ret	0
??$_Sort_unchecked@PAULight@CROS_impl@@P6A_NABU12@0@Z@std@@YAXPAULight@CROS_impl@@0HP6A_NABU12@1@Z@Z ENDP ; std::_Sort_unchecked<CROS_impl::Light *,bool (__cdecl*)(CROS_impl::Light const &,CROS_impl::Light const &)>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_Copy_memmove@PAUItem@CROS_impl@@PAU12@@std@@YAPAUItem@CROS_impl@@PAU12@00@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
??$_Copy_memmove@PAUItem@CROS_impl@@PAU12@@std@@YAPAUItem@CROS_impl@@PAU12@00@Z PROC ; std::_Copy_memmove<CROS_impl::Item *,CROS_impl::Item *>, COMDAT
; __First$ = ecx
; __Last$ = edx

; 4058 : _OutCtgIt _Copy_memmove(_CtgIt _First, _CtgIt _Last, _OutCtgIt _Dest) {

	push	esi

; 4059 :     auto _FirstPtr              = _To_address(_First);
; 4060 :     auto _LastPtr               = _To_address(_Last);
; 4061 :     auto _DestPtr               = _To_address(_Dest);
; 4062 :     const char* const _First_ch = const_cast<const char*>(reinterpret_cast<const volatile char*>(_FirstPtr));
; 4063 :     const char* const _Last_ch  = const_cast<const char*>(reinterpret_cast<const volatile char*>(_LastPtr));
; 4064 :     char* const _Dest_ch        = const_cast<char*>(reinterpret_cast<const volatile char*>(_DestPtr));
; 4065 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);
; 4066 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	esi, DWORD PTR __Dest$[esp]
	push	edi
	mov	edi, edx
	sub	edi, ecx
	push	edi
	push	ecx
	push	esi
	call	_memmove
	add	esp, 12					; 0000000cH

; 4067 :     if constexpr (is_pointer_v<_OutCtgIt>) {
; 4068 :         return reinterpret_cast<_OutCtgIt>(_Dest_ch + _Count);

	lea	eax, DWORD PTR [edi+esi]
	pop	edi
	pop	esi

; 4069 :     } else {
; 4070 :         return _Dest + (_LastPtr - _FirstPtr);
; 4071 :     }
; 4072 : }

	ret	0
??$_Copy_memmove@PAUItem@CROS_impl@@PAU12@@std@@YAPAUItem@CROS_impl@@PAU12@00@Z ENDP ; std::_Copy_memmove<CROS_impl::Item *,CROS_impl::Item *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_To_address@PAUItem@CROS_impl@@@std@@YA?A_PABQAUItem@CROS_impl@@@Z
_TEXT	SEGMENT
??$_To_address@PAUItem@CROS_impl@@@std@@YA?A_PABQAUItem@CROS_impl@@@Z PROC ; std::_To_address<CROS_impl::Item *>, COMDAT
; __Val$ = ecx

; 3981 :     _STL_INTERNAL_STATIC_ASSERT(is_pointer_v<_Iter>);
; 3982 :     return _Val;

	mov	eax, DWORD PTR [ecx]

; 3983 : }

	ret	0
??$_To_address@PAUItem@CROS_impl@@@std@@YA?A_PABQAUItem@CROS_impl@@@Z ENDP ; std::_To_address<CROS_impl::Item *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$destroy@ULight@CROS_impl@@@?$_Normal_allocator_traits@V?$xalloc@ULight@CROS_impl@@@@@std@@SAXAAV?$xalloc@ULight@CROS_impl@@@@PAULight@CROS_impl@@@Z
_TEXT	SEGMENT
??$destroy@ULight@CROS_impl@@@?$_Normal_allocator_traits@V?$xalloc@ULight@CROS_impl@@@@@std@@SAXAAV?$xalloc@ULight@CROS_impl@@@@PAULight@CROS_impl@@@Z PROC ; std::_Normal_allocator_traits<xalloc<CROS_impl::Light> >::destroy<CROS_impl::Light>, COMDAT
; __Al$dead$ = ecx
; __Ptr$dead$ = edx

; 579  :         if constexpr (_Uses_default_destroy<_Alloc, _Ty*>::value) {
; 580  : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 581  :             _STD destroy_at(_Ptr);
; 582  : #else // __cpp_lib_constexpr_dynamic_alloc
; 583  :             _Ptr->~_Ty();
; 584  : #endif // __cpp_lib_constexpr_dynamic_alloc
; 585  :         } else {
; 586  :             _Al.destroy(_Ptr);
; 587  :         }
; 588  :     }

	ret	0
??$destroy@ULight@CROS_impl@@@?$_Normal_allocator_traits@V?$xalloc@ULight@CROS_impl@@@@@std@@SAXAAV?$xalloc@ULight@CROS_impl@@@@PAULight@CROS_impl@@@Z ENDP ; std::_Normal_allocator_traits<xalloc<CROS_impl::Light> >::destroy<CROS_impl::Light>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Uninitialized_move@PAULight@CROS_impl@@V?$xalloc@ULight@CROS_impl@@@@@std@@YAPAULight@CROS_impl@@QAU12@0PAU12@AAV?$xalloc@ULight@CROS_impl@@@@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Al$dead$ = 12						; size = 4
??$_Uninitialized_move@PAULight@CROS_impl@@V?$xalloc@ULight@CROS_impl@@@@@std@@YAPAULight@CROS_impl@@QAU12@0PAU12@AAV?$xalloc@ULight@CROS_impl@@@@@Z PROC ; std::_Uninitialized_move<CROS_impl::Light *,xalloc<CROS_impl::Light> >, COMDAT
; __First$ = ecx
; __Last$ = edx

; 1699 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

	push	esi

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	esi, DWORD PTR __Dest$[esp]

; 1699 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

	push	edi
	mov	edi, edx

; 1700 :     // move [_First, _Last) to raw _Dest, using _Al
; 1701 :     // note: only called internally from elsewhere in the STL
; 1702 :     using _Ptrval     = typename _Alloc::value_type*;
; 1703 :     auto _UFirst      = _Get_unwrapped(_First);
; 1704 :     const auto _ULast = _Get_unwrapped(_Last);
; 1705 :     if constexpr (conjunction_v<bool_constant<_Ptr_move_cat<decltype(_UFirst), _Ptrval>::_Really_trivial>,
; 1706 :                       _Uses_default_construct<_Alloc, _Ptrval, decltype(_STD move(*_UFirst))>>) {
; 1707 : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 1708 :         if (!_STD is_constant_evaluated())
; 1709 : #endif // __cpp_lib_constexpr_dynamic_alloc
; 1710 :         {
; 1711 :             _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));
; 1712 :             return _Dest + (_ULast - _UFirst);
; 1713 :         }
; 1714 :     }
; 1715 : 
; 1716 :     _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	ecx, edi
	je	SHORT $LN20@Uninitiali
	npad	4
$LL4@Uninitiali:
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [esi], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [esi+4], eax
	mov	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR [esi+8], eax
	mov	eax, DWORD PTR [ecx+12]
	mov	DWORD PTR [esi+12], eax
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR [esi+16], edx
	mov	edx, DWORD PTR [ecx+20]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1621 :         ++_Last;

	add	ecx, 24					; 00000018H
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	DWORD PTR [esi+20], edx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1621 :         ++_Last;

	add	esi, 24					; 00000018H

; 1700 :     // move [_First, _Last) to raw _Dest, using _Al
; 1701 :     // note: only called internally from elsewhere in the STL
; 1702 :     using _Ptrval     = typename _Alloc::value_type*;
; 1703 :     auto _UFirst      = _Get_unwrapped(_First);
; 1704 :     const auto _ULast = _Get_unwrapped(_Last);
; 1705 :     if constexpr (conjunction_v<bool_constant<_Ptr_move_cat<decltype(_UFirst), _Ptrval>::_Really_trivial>,
; 1706 :                       _Uses_default_construct<_Alloc, _Ptrval, decltype(_STD move(*_UFirst))>>) {
; 1707 : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 1708 :         if (!_STD is_constant_evaluated())
; 1709 : #endif // __cpp_lib_constexpr_dynamic_alloc
; 1710 :         {
; 1711 :             _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));
; 1712 :             return _Dest + (_ULast - _UFirst);
; 1713 :         }
; 1714 :     }
; 1715 : 
; 1716 :     _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	ecx, edi
	jne	SHORT $LL4@Uninitiali
$LN20@Uninitiali:
	pop	edi

; 1718 :         _Backout._Emplace_back(_STD move(*_UFirst));
; 1719 :     }
; 1720 : 
; 1721 :     return _Backout._Release();
; 1722 : }

	mov	eax, esi
	pop	esi
	ret	0
??$_Uninitialized_move@PAULight@CROS_impl@@V?$xalloc@ULight@CROS_impl@@@@@std@@YAPAULight@CROS_impl@@QAU12@0PAU12@AAV?$xalloc@ULight@CROS_impl@@@@@Z ENDP ; std::_Uninitialized_move<CROS_impl::Light *,xalloc<CROS_impl::Light> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_Get_unwrapped@ABQAULight@CROS_impl@@@std@@YA?A_TABQAULight@CROS_impl@@@Z
_TEXT	SEGMENT
??$_Get_unwrapped@ABQAULight@CROS_impl@@@std@@YA?A_TABQAULight@CROS_impl@@@Z PROC ; std::_Get_unwrapped<CROS_impl::Light * const &>, COMDAT
; __It$ = ecx

; 1275 :     // unwrap an iterator previously subjected to _Adl_verify_range or otherwise validated
; 1276 :     if constexpr (is_pointer_v<decay_t<_Iter>>) { // special-case pointers and arrays
; 1277 :         return _It + 0;

	mov	eax, DWORD PTR [ecx]

; 1278 :     } else if constexpr (_Unwrappable_v<_Iter>) {
; 1279 :         return static_cast<_Iter&&>(_It)._Unwrapped();
; 1280 :     } else {
; 1281 :         return static_cast<_Iter&&>(_It);
; 1282 :     }
; 1283 : }

	ret	0
??$_Get_unwrapped@ABQAULight@CROS_impl@@@std@@YA?A_TABQAULight@CROS_impl@@@Z ENDP ; std::_Get_unwrapped<CROS_impl::Light * const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
;	COMDAT ??$xr_alloc@ULight@CROS_impl@@@@YAPAULight@CROS_impl@@I@Z
_TEXT	SEGMENT
??$xr_alloc@ULight@CROS_impl@@@@YAPAULight@CROS_impl@@I@Z PROC ; xr_alloc<CROS_impl::Light>, COMDAT
; _count$ = ecx

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	lea	eax, DWORD PTR [ecx+ecx*2]
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	shl	eax, 3
	push	eax
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
	ret	0
??$xr_alloc@ULight@CROS_impl@@@@YAPAULight@CROS_impl@@I@Z ENDP ; xr_alloc<CROS_impl::Light>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Uninitialized_move@PAUItem@CROS_impl@@V?$xalloc@UItem@CROS_impl@@@@@std@@YAPAUItem@CROS_impl@@QAU12@0PAU12@AAV?$xalloc@UItem@CROS_impl@@@@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Al$dead$ = 12						; size = 4
??$_Uninitialized_move@PAUItem@CROS_impl@@V?$xalloc@UItem@CROS_impl@@@@@std@@YAPAUItem@CROS_impl@@QAU12@0PAU12@AAV?$xalloc@UItem@CROS_impl@@@@@Z PROC ; std::_Uninitialized_move<CROS_impl::Item *,xalloc<CROS_impl::Item> >, COMDAT
; __First$ = ecx
; __Last$ = edx

; 1699 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

	push	ebx
	mov	ebx, edx
	mov	eax, ecx

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	edx, DWORD PTR __Dest$[esp]

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	eax, ebx
	je	SHORT $LN20@Uninitiali
	push	esi
	push	edi
	npad	1
$LL4@Uninitiali:
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	esi, eax
	mov	edi, edx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1621 :         ++_Last;

	add	eax, 84					; 00000054H
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	ecx, 21					; 00000015H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1621 :         ++_Last;

	add	edx, 84					; 00000054H
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	rep movsd
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	eax, ebx
	jne	SHORT $LL4@Uninitiali

; 1718 :         _Backout._Emplace_back(_STD move(*_UFirst));
; 1719 :     }
; 1720 : 
; 1721 :     return _Backout._Release();

	pop	edi
	pop	esi
$LN20@Uninitiali:

; 1722 : }

	mov	eax, edx
	pop	ebx
	ret	0
??$_Uninitialized_move@PAUItem@CROS_impl@@V?$xalloc@UItem@CROS_impl@@@@@std@@YAPAUItem@CROS_impl@@QAU12@0PAU12@AAV?$xalloc@UItem@CROS_impl@@@@@Z ENDP ; std::_Uninitialized_move<CROS_impl::Item *,xalloc<CROS_impl::Item> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_Get_unwrapped@ABQAUItem@CROS_impl@@@std@@YA?A_TABQAUItem@CROS_impl@@@Z
_TEXT	SEGMENT
??$_Get_unwrapped@ABQAUItem@CROS_impl@@@std@@YA?A_TABQAUItem@CROS_impl@@@Z PROC ; std::_Get_unwrapped<CROS_impl::Item * const &>, COMDAT
; __It$ = ecx

; 1275 :     // unwrap an iterator previously subjected to _Adl_verify_range or otherwise validated
; 1276 :     if constexpr (is_pointer_v<decay_t<_Iter>>) { // special-case pointers and arrays
; 1277 :         return _It + 0;

	mov	eax, DWORD PTR [ecx]

; 1278 :     } else if constexpr (_Unwrappable_v<_Iter>) {
; 1279 :         return static_cast<_Iter&&>(_It)._Unwrapped();
; 1280 :     } else {
; 1281 :         return static_cast<_Iter&&>(_It);
; 1282 :     }
; 1283 : }

	ret	0
??$_Get_unwrapped@ABQAUItem@CROS_impl@@@std@@YA?A_TABQAUItem@CROS_impl@@@Z ENDP ; std::_Get_unwrapped<CROS_impl::Item * const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Destroy_in_place@PAUItem@CROS_impl@@@std@@YAXAAPAUItem@CROS_impl@@@Z
_TEXT	SEGMENT
??$_Destroy_in_place@PAUItem@CROS_impl@@@std@@YAXAAPAUItem@CROS_impl@@@Z PROC ; std::_Destroy_in_place<CROS_impl::Item *>, COMDAT
; __Obj$dead$ = ecx

; 295  :     if constexpr (is_array_v<_Ty>) {
; 296  :         _Destroy_range(_Obj, _Obj + extent_v<_Ty>);
; 297  :     } else {
; 298  :         _Obj.~_Ty();
; 299  :     }
; 300  : }

	ret	0
??$_Destroy_in_place@PAUItem@CROS_impl@@@std@@YAXAAPAUItem@CROS_impl@@@Z ENDP ; std::_Destroy_in_place<CROS_impl::Item *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
;	COMDAT ??$xr_alloc@UItem@CROS_impl@@@@YAPAUItem@CROS_impl@@I@Z
_TEXT	SEGMENT
??$xr_alloc@UItem@CROS_impl@@@@YAPAUItem@CROS_impl@@I@Z PROC ; xr_alloc<CROS_impl::Item>, COMDAT
; _count$ = ecx

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	imul	eax, ecx, 84
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
	ret	0
??$xr_alloc@UItem@CROS_impl@@@@YAPAUItem@CROS_impl@@I@Z ENDP ; xr_alloc<CROS_impl::Item>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Release@?$_Uninitialized_backout_al@V?$xalloc@UItem@CROS_impl@@@@@std@@QAEPAUItem@CROS_impl@@XZ
_TEXT	SEGMENT
?_Release@?$_Uninitialized_backout_al@V?$xalloc@UItem@CROS_impl@@@@@std@@QAEPAUItem@CROS_impl@@XZ PROC ; std::_Uninitialized_backout_al<xalloc<CROS_impl::Item> >::_Release, COMDAT
; _this$ = ecx

; 1625 :         _First = _Last;

	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [ecx], eax

; 1626 :         return _Last;
; 1627 :     }

	ret	0
?_Release@?$_Uninitialized_backout_al@V?$xalloc@UItem@CROS_impl@@@@@std@@QAEPAUItem@CROS_impl@@XZ ENDP ; std::_Uninitialized_backout_al<xalloc<CROS_impl::Item> >::_Release
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??1?$_Uninitialized_backout_al@V?$xalloc@UItem@CROS_impl@@@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Uninitialized_backout_al@V?$xalloc@UItem@CROS_impl@@@@@std@@QAE@XZ PROC ; std::_Uninitialized_backout_al<xalloc<CROS_impl::Item> >::~_Uninitialized_backout_al<xalloc<CROS_impl::Item> >, COMDAT
; _this$ = ecx

; 1615 :         _Destroy_range(_First, _Last, _Al);
; 1616 :     }

	ret	0
??1?$_Uninitialized_backout_al@V?$xalloc@UItem@CROS_impl@@@@@std@@QAE@XZ ENDP ; std::_Uninitialized_backout_al<xalloc<CROS_impl::Item> >::~_Uninitialized_backout_al<xalloc<CROS_impl::Item> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??0?$_Uninitialized_backout_al@V?$xalloc@UItem@CROS_impl@@@@@std@@QAE@PAUItem@CROS_impl@@AAV?$xalloc@UItem@CROS_impl@@@@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Al_$ = 12						; size = 4
??0?$_Uninitialized_backout_al@V?$xalloc@UItem@CROS_impl@@@@@std@@QAE@PAUItem@CROS_impl@@AAV?$xalloc@UItem@CROS_impl@@@@@Z PROC ; std::_Uninitialized_backout_al<xalloc<CROS_impl::Item> >::_Uninitialized_backout_al<xalloc<CROS_impl::Item> >, COMDAT
; _this$ = ecx

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	eax, DWORD PTR __Dest$[esp-4]
	mov	DWORD PTR [ecx], eax
	mov	DWORD PTR [ecx+4], eax
	mov	eax, DWORD PTR __Al_$[esp-4]
	mov	DWORD PTR [ecx+8], eax
	mov	eax, ecx
	ret	8
??0?$_Uninitialized_backout_al@V?$xalloc@UItem@CROS_impl@@@@@std@@QAE@PAUItem@CROS_impl@@AAV?$xalloc@UItem@CROS_impl@@@@@Z ENDP ; std::_Uninitialized_backout_al<xalloc<CROS_impl::Item> >::_Uninitialized_backout_al<xalloc<CROS_impl::Item> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Release@?$_Uninitialized_backout_al@V?$xalloc@ULight@CROS_impl@@@@@std@@QAEPAULight@CROS_impl@@XZ
_TEXT	SEGMENT
?_Release@?$_Uninitialized_backout_al@V?$xalloc@ULight@CROS_impl@@@@@std@@QAEPAULight@CROS_impl@@XZ PROC ; std::_Uninitialized_backout_al<xalloc<CROS_impl::Light> >::_Release, COMDAT
; _this$ = ecx

; 1625 :         _First = _Last;

	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [ecx], eax

; 1626 :         return _Last;
; 1627 :     }

	ret	0
?_Release@?$_Uninitialized_backout_al@V?$xalloc@ULight@CROS_impl@@@@@std@@QAEPAULight@CROS_impl@@XZ ENDP ; std::_Uninitialized_backout_al<xalloc<CROS_impl::Light> >::_Release
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??1?$_Uninitialized_backout_al@V?$xalloc@ULight@CROS_impl@@@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Uninitialized_backout_al@V?$xalloc@ULight@CROS_impl@@@@@std@@QAE@XZ PROC ; std::_Uninitialized_backout_al<xalloc<CROS_impl::Light> >::~_Uninitialized_backout_al<xalloc<CROS_impl::Light> >, COMDAT
; _this$ = ecx

; 1615 :         _Destroy_range(_First, _Last, _Al);
; 1616 :     }

	ret	0
??1?$_Uninitialized_backout_al@V?$xalloc@ULight@CROS_impl@@@@@std@@QAE@XZ ENDP ; std::_Uninitialized_backout_al<xalloc<CROS_impl::Light> >::~_Uninitialized_backout_al<xalloc<CROS_impl::Light> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??0?$_Uninitialized_backout_al@V?$xalloc@ULight@CROS_impl@@@@@std@@QAE@PAULight@CROS_impl@@AAV?$xalloc@ULight@CROS_impl@@@@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Al_$ = 12						; size = 4
??0?$_Uninitialized_backout_al@V?$xalloc@ULight@CROS_impl@@@@@std@@QAE@PAULight@CROS_impl@@AAV?$xalloc@ULight@CROS_impl@@@@@Z PROC ; std::_Uninitialized_backout_al<xalloc<CROS_impl::Light> >::_Uninitialized_backout_al<xalloc<CROS_impl::Light> >, COMDAT
; _this$ = ecx

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	eax, DWORD PTR __Dest$[esp-4]
	mov	DWORD PTR [ecx], eax
	mov	DWORD PTR [ecx+4], eax
	mov	eax, DWORD PTR __Al_$[esp-4]
	mov	DWORD PTR [ecx+8], eax
	mov	eax, ecx
	ret	8
??0?$_Uninitialized_backout_al@V?$xalloc@ULight@CROS_impl@@@@@std@@QAE@PAULight@CROS_impl@@AAV?$xalloc@ULight@CROS_impl@@@@@Z ENDP ; std::_Uninitialized_backout_al<xalloc<CROS_impl::Light> >::_Uninitialized_backout_al<xalloc<CROS_impl::Light> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?destroy@?$xalloc@ULight@CROS_impl@@@@QAEXPAULight@CROS_impl@@@Z
_TEXT	SEGMENT
_p$dead$ = 8						; size = 4
?destroy@?$xalloc@ULight@CROS_impl@@@@QAEXPAULight@CROS_impl@@@Z PROC ; xalloc<CROS_impl::Light>::destroy, COMDAT
; _this$dead$ = ecx

; 85   : 							void					destroy			(pointer p)								{	std::_Destroy_in_place(p);			}

	ret	4
?destroy@?$xalloc@ULight@CROS_impl@@@@QAEXPAULight@CROS_impl@@@Z ENDP ; xalloc<CROS_impl::Light>::destroy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
;	COMDAT ??$_Insertion_sort_unchecked@PAULight@CROS_impl@@P6A_NABU12@0@Z@std@@YAPAULight@CROS_impl@@QAU12@0P6A_NABU12@1@Z@Z
_TEXT	SEGMENT
tv163 = -32						; size = 4
__Last$1$ = -28						; size = 4
__Val$1 = -24						; size = 24
__Pred$ = 8						; size = 4
??$_Insertion_sort_unchecked@PAULight@CROS_impl@@P6A_NABU12@0@Z@std@@YAPAULight@CROS_impl@@QAU12@0P6A_NABU12@1@Z@Z PROC ; std::_Insertion_sort_unchecked<CROS_impl::Light *,bool (__cdecl*)(CROS_impl::Light const &,CROS_impl::Light const &)>, COMDAT
; __First$ = ecx
; __Last$ = edx

; 6919 : _CONSTEXPR20 _BidIt _Insertion_sort_unchecked(const _BidIt _First, const _BidIt _Last, _Pr _Pred) {

	sub	esp, 32					; 00000020H
	push	ebx
	push	ebp
	mov	eax, edx
	mov	ebp, ecx
	mov	DWORD PTR __Last$1$[esp+40], eax
	push	esi
	push	edi

; 6920 :     // insertion sort [_First, _Last)
; 6921 :     if (_First != _Last) {

	cmp	ebp, eax
	je	$LN3@Insertion_

; 6922 :         for (_BidIt _Mid = _First; ++_Mid != _Last;) { // order next element

	lea	ebx, DWORD PTR [ebp+24]
	cmp	ebx, eax
	je	$LN3@Insertion_
	mov	esi, ebp
	mov	DWORD PTR tv163[esp+48], ebp
$LL2@Insertion_:

; 6923 :             _BidIt _Hole               = _Mid;
; 6924 :             _Iter_value_t<_BidIt> _Val = _STD move(*_Mid);

	mov	eax, DWORD PTR [ebx]
	mov	edi, ebx
	mov	DWORD PTR __Val$1[esp+48], eax
	mov	eax, DWORD PTR [ebx+4]
	mov	DWORD PTR __Val$1[esp+52], eax
	mov	eax, DWORD PTR [ebx+8]
	mov	DWORD PTR __Val$1[esp+56], eax
	mov	eax, DWORD PTR [ebx+12]
	mov	DWORD PTR __Val$1[esp+60], eax
	mov	eax, DWORD PTR [ebx+16]
	mov	DWORD PTR __Val$1[esp+64], eax
	mov	eax, DWORD PTR [ebx+20]
	mov	DWORD PTR __Val$1[esp+68], eax

; 6925 : 
; 6926 :             if (_DEBUG_LT_PRED(_Pred, _Val, *_First)) { // found new earliest element, move to front

	lea	eax, DWORD PTR __Val$1[esp+48]
	push	ebp
	push	eax
	call	DWORD PTR __Pred$[esp+52]
	add	esp, 8
	test	al, al
	je	SHORT $LN9@Insertion_
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility

; 4254 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	mov	ecx, ebx

; 4255 :     auto _Result                = _CSTD memmove(_Dest_ch - _Count, _First_ch, _Count);

	mov	eax, ebx
	sub	ecx, ebp
	push	ecx
	sub	eax, ecx
	add	eax, 24					; 00000018H
	push	ebp
	push	eax
	call	_memmove
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 6928 :                 *_First = _STD move(_Val);

	mov	eax, DWORD PTR __Val$1[esp+60]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility

; 4255 :     auto _Result                = _CSTD memmove(_Dest_ch - _Count, _First_ch, _Count);

	add	esp, 12					; 0000000cH
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 6928 :                 *_First = _STD move(_Val);

	mov	DWORD PTR [ebp], eax
	mov	eax, DWORD PTR __Val$1[esp+52]
	mov	DWORD PTR [ebp+4], eax
	mov	eax, DWORD PTR __Val$1[esp+56]
	mov	DWORD PTR [ebp+8], eax
	mov	eax, DWORD PTR __Val$1[esp+60]
	mov	DWORD PTR [ebp+12], eax
	mov	eax, DWORD PTR __Val$1[esp+64]
	mov	DWORD PTR [ebp+16], eax
	mov	eax, DWORD PTR __Val$1[esp+68]
	mov	DWORD PTR [ebp+20], eax

; 6929 :             } else { // look for insertion point after first

	jmp	SHORT $LN10@Insertion_
$LN9@Insertion_:

; 6930 :                 for (_BidIt _Prev = _Hole; _DEBUG_LT_PRED(_Pred, _Val, *--_Prev); _Hole = _Prev) {

	push	DWORD PTR tv163[esp+48]
	lea	eax, DWORD PTR __Val$1[esp+52]
	push	eax
	call	DWORD PTR __Pred$[esp+52]
	add	esp, 8
	test	al, al
	je	SHORT $LN6@Insertion_
	npad	6
$LL7@Insertion_:

; 6931 :                     *_Hole = _STD move(*_Prev); // move hole down

	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [edi], eax
	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [edi+4], eax
	mov	eax, DWORD PTR [esi+8]
	mov	DWORD PTR [edi+8], eax
	mov	eax, DWORD PTR [esi+12]
	mov	DWORD PTR [edi+12], eax
	mov	eax, DWORD PTR [esi+16]
	mov	DWORD PTR [edi+16], eax
	mov	eax, DWORD PTR [esi+20]
	mov	DWORD PTR [edi+20], eax
	mov	edi, esi
	sub	esi, 24					; 00000018H
	lea	eax, DWORD PTR __Val$1[esp+48]
	push	esi
	push	eax
	call	DWORD PTR __Pred$[esp+52]
	add	esp, 8
	test	al, al
	jne	SHORT $LL7@Insertion_
$LN6@Insertion_:

; 6932 :                 }
; 6933 : 
; 6934 :                 *_Hole = _STD move(_Val); // insert element in hole

	mov	eax, DWORD PTR __Val$1[esp+48]
	mov	esi, DWORD PTR tv163[esp+48]
	mov	DWORD PTR [edi], eax
	mov	eax, DWORD PTR __Val$1[esp+52]
	mov	DWORD PTR [edi+4], eax
	mov	eax, DWORD PTR __Val$1[esp+56]
	mov	DWORD PTR [edi+8], eax
	mov	eax, DWORD PTR __Val$1[esp+60]
	mov	DWORD PTR [edi+12], eax
	mov	eax, DWORD PTR __Val$1[esp+64]
	mov	DWORD PTR [edi+16], eax
	mov	eax, DWORD PTR __Val$1[esp+68]
	mov	DWORD PTR [edi+20], eax
$LN10@Insertion_:

; 6922 :         for (_BidIt _Mid = _First; ++_Mid != _Last;) { // order next element

	mov	eax, DWORD PTR __Last$1$[esp+48]
	add	ebx, 24					; 00000018H
	add	esi, 24					; 00000018H
	mov	DWORD PTR tv163[esp+48], esi
	cmp	ebx, eax
	jne	$LL2@Insertion_
$LN3@Insertion_:

; 6935 :             }
; 6936 :         }
; 6937 :     }
; 6938 : 
; 6939 :     return _Last;
; 6940 : }

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 32					; 00000020H
	ret	0
??$_Insertion_sort_unchecked@PAULight@CROS_impl@@P6A_NABU12@0@Z@std@@YAPAULight@CROS_impl@@QAU12@0P6A_NABU12@1@Z@Z ENDP ; std::_Insertion_sort_unchecked<CROS_impl::Light *,bool (__cdecl*)(CROS_impl::Light const &,CROS_impl::Light const &)>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
;	COMDAT ??$_Make_heap_unchecked@PAULight@CROS_impl@@P6A_NABU12@0@Z@std@@YAXPAULight@CROS_impl@@0P6A_NABU12@1@Z@Z
_TEXT	SEGMENT
__Hole$1$ = -44						; size = 4
__Max_sequence_non_leaf$1$ = -40			; size = 4
__Bottom$1$ = -36					; size = 4
tv167 = -32						; size = 4
tv144 = -28						; size = 4
__Val$1 = -24						; size = 24
__Pred$ = 8						; size = 4
??$_Make_heap_unchecked@PAULight@CROS_impl@@P6A_NABU12@0@Z@std@@YAXPAULight@CROS_impl@@0P6A_NABU12@1@Z@Z PROC ; std::_Make_heap_unchecked<CROS_impl::Light *,bool (__cdecl*)(CROS_impl::Light const &,CROS_impl::Light const &)>, COMDAT
; __First$ = ecx
; __Last$ = edx

; 5544 : _CONSTEXPR20 void _Make_heap_unchecked(_RanIt _First, _RanIt _Last, _Pr _Pred) {

	sub	esp, 48					; 00000030H
	push	ebx
	push	ebp
	mov	ebp, ecx

; 5545 :     // make [_First, _Last) into a heap
; 5546 :     using _Diff   = _Iter_diff_t<_RanIt>;
; 5547 :     _Diff _Bottom = _Last - _First;

	sub	edx, ebp
	sar	edx, 3
	imul	eax, edx, -1431655765
	push	esi
	push	edi

; 5548 :     for (_Diff _Hole = _Bottom >> 1; _Hole > 0;) { // shift for codegen

	mov	edi, eax
	mov	DWORD PTR __Bottom$1$[esp+64], eax
	sar	edi, 1
	test	edi, edi
	jle	$LN3@Make_heap_

; 5545 :     // make [_First, _Last) into a heap
; 5546 :     using _Diff   = _Iter_diff_t<_RanIt>;
; 5547 :     _Diff _Bottom = _Last - _First;

	dec	eax
	mov	edx, eax
	mov	DWORD PTR tv167[esp+64], eax
	lea	eax, DWORD PTR [edi+edi*2]
	sar	edx, 1
	lea	ecx, DWORD PTR [eax*8]
	mov	DWORD PTR __Max_sequence_non_leaf$1$[esp+64], edx
	add	ecx, ebp
	npad	3
$LL2@Make_heap_:

; 5549 :         // reheap top half, bottom to top
; 5550 :         --_Hole;
; 5551 :         _Iter_value_t<_RanIt> _Val = _STD move(*(_First + _Hole));

	mov	eax, DWORD PTR [ecx-24]
	sub	ecx, 24					; 00000018H
	mov	DWORD PTR __Val$1[esp+64], eax
	dec	edi
	mov	DWORD PTR __Hole$1$[esp+64], edi

; 5552 :         _Pop_heap_hole_by_index(_First, _Hole, _Bottom, _STD move(_Val), _Pred);

	mov	ebx, edi
	mov	DWORD PTR tv144[esp+64], ecx

; 5381 :     _Diff _Idx       = _Hole;

	mov	esi, edi

; 5549 :         // reheap top half, bottom to top
; 5550 :         --_Hole;
; 5551 :         _Iter_value_t<_RanIt> _Val = _STD move(*(_First + _Hole));

	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR __Val$1[esp+68], eax
	mov	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR __Val$1[esp+72], eax
	mov	eax, DWORD PTR [ecx+12]
	mov	DWORD PTR __Val$1[esp+76], eax
	mov	eax, DWORD PTR [ecx+16]
	mov	DWORD PTR __Val$1[esp+80], eax
	mov	eax, DWORD PTR [ecx+20]
	mov	DWORD PTR __Val$1[esp+84], eax

; 5386 :     while (_Idx < _Max_sequence_non_leaf) { // move _Hole down to larger child

	cmp	edi, edx
	jge	SHORT $LN8@Make_heap_
	mov	edi, DWORD PTR __Max_sequence_non_leaf$1$[esp+64]
$LL7@Make_heap_:

; 5387 :         _Idx = 2 * _Idx + 2;

	lea	esi, DWORD PTR [esi*2+2]

; 5388 :         if (_DEBUG_LT_PRED(_Pred, *(_First + _Idx), *(_First + (_Idx - 1)))) {

	lea	eax, DWORD PTR [esi+esi*2]
	lea	ecx, DWORD PTR [eax*8]
	add	ecx, ebp
	lea	eax, DWORD PTR [ecx-24]
	push	eax
	push	ecx
	call	DWORD PTR __Pred$[esp+68]
	add	esp, 8
	test	al, al
	je	SHORT $LN9@Make_heap_

; 5389 :             --_Idx;

	dec	esi
$LN9@Make_heap_:

; 5390 :         }
; 5391 :         *(_First + _Hole) = _STD move(*(_First + _Idx));

	lea	eax, DWORD PTR [esi+esi*2]
	lea	edx, DWORD PTR [eax*8]
	add	edx, ebp
	lea	eax, DWORD PTR [ebx+ebx*2]
	lea	ecx, DWORD PTR [eax*8]

; 5392 :         _Hole             = _Idx;

	mov	ebx, esi
	add	ecx, ebp
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+4], eax
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR [ecx+8], eax
	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR [ecx+12], eax
	mov	eax, DWORD PTR [edx+16]
	mov	DWORD PTR [ecx+16], eax
	mov	eax, DWORD PTR [edx+20]
	mov	DWORD PTR [ecx+20], eax
	cmp	esi, edi
	jl	SHORT $LL7@Make_heap_
	mov	edi, DWORD PTR __Hole$1$[esp+64]
	mov	edx, DWORD PTR __Max_sequence_non_leaf$1$[esp+64]
$LN8@Make_heap_:

; 5393 :     }
; 5394 : 
; 5395 :     if (_Idx == _Max_sequence_non_leaf && _Bottom % 2 == 0) { // only child at bottom, move _Hole down to it

	cmp	esi, edx
	jne	SHORT $LN10@Make_heap_
	mov	eax, DWORD PTR __Bottom$1$[esp+64]
	test	al, 1
	jne	SHORT $LN10@Make_heap_

; 5396 :         *(_First + _Hole) = _STD move(*(_First + (_Bottom - 1)));

	lea	eax, DWORD PTR [eax+eax*2]
	lea	edx, DWORD PTR [eax*8]
	add	edx, ebp
	lea	eax, DWORD PTR [ebx+ebx*2]

; 5397 :         _Hole             = _Bottom - 1;

	mov	ebx, DWORD PTR tv167[esp+64]
	lea	ecx, DWORD PTR [eax*8]
	add	ecx, ebp
	mov	eax, DWORD PTR [edx-24]
	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR [edx-20]
	mov	DWORD PTR [ecx+4], eax
	mov	eax, DWORD PTR [edx-16]
	mov	DWORD PTR [ecx+8], eax
	mov	eax, DWORD PTR [edx-12]
	mov	DWORD PTR [ecx+12], eax
	mov	eax, DWORD PTR [edx-8]
	mov	DWORD PTR [ecx+16], eax
	mov	eax, DWORD PTR [edx-4]
	mov	DWORD PTR [ecx+20], eax
$LN10@Make_heap_:

; 5268 :          _Top < _Hole && _DEBUG_LT_PRED(_Pred, *(_First + _Idx), _Val); //

	cmp	edi, ebx
	jge	SHORT $LN29@Make_heap_
	npad	3
$LL15@Make_heap_:

; 5267 :     for (_Diff _Idx = (_Hole - 1) >> 1; // shift for codegen

	lea	esi, DWORD PTR [ebx-1]
	sar	esi, 1

; 5268 :          _Top < _Hole && _DEBUG_LT_PRED(_Pred, *(_First + _Idx), _Val); //

	lea	eax, DWORD PTR [esi+esi*2]
	lea	edi, DWORD PTR [eax*8]
	lea	eax, DWORD PTR __Val$1[esp+64]
	add	edi, ebp
	push	eax
	push	edi
	call	DWORD PTR __Pred$[esp+68]
	add	esp, 8
	test	al, al
	je	SHORT $LN31@Make_heap_

; 5269 :          _Idx = (_Hole - 1) >> 1) { // shift for codegen
; 5270 :         // move _Hole up to parent
; 5271 :         *(_First + _Hole) = _STD move(*(_First + _Idx));

	lea	eax, DWORD PTR [ebx+ebx*2]

; 5272 :         _Hole             = _Idx;

	mov	ebx, esi
	lea	ecx, DWORD PTR [eax*8]
	mov	eax, DWORD PTR [edi]
	add	ecx, ebp
	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR [edi+4]
	mov	DWORD PTR [ecx+4], eax
	mov	eax, DWORD PTR [edi+8]
	mov	DWORD PTR [ecx+8], eax
	mov	eax, DWORD PTR [edi+12]
	mov	DWORD PTR [ecx+12], eax
	mov	eax, DWORD PTR [edi+16]
	mov	DWORD PTR [ecx+16], eax
	mov	eax, DWORD PTR [edi+20]
	mov	edi, DWORD PTR __Hole$1$[esp+64]
	mov	DWORD PTR [ecx+20], eax
	cmp	edi, esi
	jl	SHORT $LL15@Make_heap_

; 5268 :          _Top < _Hole && _DEBUG_LT_PRED(_Pred, *(_First + _Idx), _Val); //

	jmp	SHORT $LN29@Make_heap_
$LN31@Make_heap_:
	mov	edi, DWORD PTR __Hole$1$[esp+64]
$LN29@Make_heap_:

; 5548 :     for (_Diff _Hole = _Bottom >> 1; _Hole > 0;) { // shift for codegen

	mov	edx, DWORD PTR __Max_sequence_non_leaf$1$[esp+64]

; 5275 :     *(_First + _Hole) = _STD forward<_Ty>(_Val); // drop _Val into final hole

	lea	eax, DWORD PTR [ebx+ebx*2]
	lea	ecx, DWORD PTR [eax*8]
	mov	eax, DWORD PTR __Val$1[esp+64]
	add	ecx, ebp
	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR __Val$1[esp+68]
	mov	DWORD PTR [ecx+4], eax
	mov	eax, DWORD PTR __Val$1[esp+72]
	mov	DWORD PTR [ecx+8], eax
	mov	eax, DWORD PTR __Val$1[esp+76]
	mov	DWORD PTR [ecx+12], eax
	mov	eax, DWORD PTR __Val$1[esp+80]
	mov	DWORD PTR [ecx+16], eax
	mov	eax, DWORD PTR __Val$1[esp+84]
	mov	DWORD PTR [ecx+20], eax

; 5548 :     for (_Diff _Hole = _Bottom >> 1; _Hole > 0;) { // shift for codegen

	mov	ecx, DWORD PTR tv144[esp+64]
	test	edi, edi
	jg	$LL2@Make_heap_
$LN3@Make_heap_:

; 5553 :     }
; 5554 : }

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 48					; 00000030H
	ret	0
??$_Make_heap_unchecked@PAULight@CROS_impl@@P6A_NABU12@0@Z@std@@YAXPAULight@CROS_impl@@0P6A_NABU12@1@Z@Z ENDP ; std::_Make_heap_unchecked<CROS_impl::Light *,bool (__cdecl*)(CROS_impl::Light const &,CROS_impl::Light const &)>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
;	COMDAT ??$_Sort_heap_unchecked@PAULight@CROS_impl@@P6A_NABU12@0@Z@std@@YAXPAULight@CROS_impl@@0P6A_NABU12@1@Z@Z
_TEXT	SEGMENT
__Val$1 = -24						; size = 24
__Pred$ = 8						; size = 4
??$_Sort_heap_unchecked@PAULight@CROS_impl@@P6A_NABU12@0@Z@std@@YAXPAULight@CROS_impl@@0P6A_NABU12@1@Z@Z PROC ; std::_Sort_heap_unchecked<CROS_impl::Light *,bool (__cdecl*)(CROS_impl::Light const &,CROS_impl::Light const &)>, COMDAT
; __First$ = ecx
; __Last$ = edx

; 5772 : _CONSTEXPR20 void _Sort_heap_unchecked(_RanIt _First, _RanIt _Last, _Pr _Pred) {

	sub	esp, 24					; 00000018H
	push	ebx
	push	ebp
	push	esi
	mov	ebx, ecx

; 5773 :     // order heap by repeatedly popping
; 5774 :     for (; _Last - _First >= 2; --_Last) {

	mov	esi, edx
	sub	esi, ebx
	push	edi
	cmp	esi, 48					; 00000030H
	jl	$LN3@Sort_heap_
	mov	ebp, DWORD PTR __Pred$[esp+36]
	lea	edi, DWORD PTR [edx-24]
	npad	3
$LL4@Sort_heap_:

; 5417 :     if (2 <= _Last - _First) {

	mov	eax, -1431655765			; aaaaaaabH
	mul	esi
	mov	esi, edi
	shr	edx, 4
	sub	esi, ebx
	cmp	edx, 2
	jl	SHORT $LN2@Sort_heap_

; 5418 :         --_Last;
; 5419 :         _Iter_value_t<_RanIt> _Val = _STD move(*_Last);

	mov	eax, DWORD PTR [edi]

; 5410 :     _Pop_heap_hole_by_index(

	xor	edx, edx

; 5419 :         _Iter_value_t<_RanIt> _Val = _STD move(*_Last);

	mov	DWORD PTR __Val$1[esp+40], eax

; 5410 :     _Pop_heap_hole_by_index(

	mov	ecx, ebx

; 5419 :         _Iter_value_t<_RanIt> _Val = _STD move(*_Last);

	mov	eax, DWORD PTR [edi+4]
	mov	DWORD PTR __Val$1[esp+44], eax
	mov	eax, DWORD PTR [edi+8]
	mov	DWORD PTR __Val$1[esp+48], eax
	mov	eax, DWORD PTR [edi+12]
	mov	DWORD PTR __Val$1[esp+52], eax
	mov	eax, DWORD PTR [edi+16]
	mov	DWORD PTR __Val$1[esp+56], eax
	mov	eax, DWORD PTR [edi+20]
	mov	DWORD PTR __Val$1[esp+60], eax

; 5408 :     *_Dest      = _STD move(*_First);

	mov	eax, DWORD PTR [ebx]
	mov	DWORD PTR [edi], eax
	mov	eax, DWORD PTR [ebx+4]
	mov	DWORD PTR [edi+4], eax
	mov	eax, DWORD PTR [ebx+8]
	mov	DWORD PTR [edi+8], eax
	mov	eax, DWORD PTR [ebx+12]
	mov	DWORD PTR [edi+12], eax
	mov	eax, DWORD PTR [ebx+16]
	mov	DWORD PTR [edi+16], eax
	mov	eax, DWORD PTR [ebx+20]
	mov	DWORD PTR [edi+20], eax

; 5409 :     using _Diff = _Iter_diff_t<_RanIt>;
; 5410 :     _Pop_heap_hole_by_index(

	lea	eax, DWORD PTR __Val$1[esp+40]
	push	ebp
	push	eax
	mov	eax, esi
	sar	eax, 3
	imul	eax, eax, -1431655765
	push	eax
	call	??$_Pop_heap_hole_by_index@PAULight@CROS_impl@@U12@P6A_NABU12@0@Z@std@@YAXPAULight@CROS_impl@@HH$$QAU12@P6A_NABU12@2@Z@Z ; std::_Pop_heap_hole_by_index<CROS_impl::Light *,CROS_impl::Light,bool (__cdecl*)(CROS_impl::Light const &,CROS_impl::Light const &)>
	add	esp, 12					; 0000000cH
$LN2@Sort_heap_:

; 5773 :     // order heap by repeatedly popping
; 5774 :     for (; _Last - _First >= 2; --_Last) {

	sub	edi, 24					; 00000018H
	cmp	esi, 48					; 00000030H
	jge	$LL4@Sort_heap_
$LN3@Sort_heap_:

; 5775 :         _Pop_heap_unchecked(_First, _Last, _Pred);
; 5776 :     }
; 5777 : }

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 24					; 00000018H
	ret	0
??$_Sort_heap_unchecked@PAULight@CROS_impl@@P6A_NABU12@0@Z@std@@YAXPAULight@CROS_impl@@0P6A_NABU12@1@Z@Z ENDP ; std::_Sort_heap_unchecked<CROS_impl::Light *,bool (__cdecl*)(CROS_impl::Light const &,CROS_impl::Light const &)>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
;	COMDAT ??$_Partition_by_median_guess_unchecked@PAULight@CROS_impl@@P6A_NABU12@0@Z@std@@YA?AU?$pair@PAULight@CROS_impl@@PAU12@@0@PAULight@CROS_impl@@0P6A_NABU23@1@Z@Z
_TEXT	SEGMENT
__Plast$1$ = -32					; size = 4
__Gfirst$1$ = -28					; size = 4
$T1 = -24						; size = 4
__Glast$1$ = -24					; size = 4
$T2 = -20						; size = 4
__Tmp$1$ = -20						; size = 4
__Last$1$ = -20						; size = 4
tv365 = -20						; size = 4
tv358 = -20						; size = 4
__First$1$ = -16					; size = 4
__Tmp$6$ = -12						; size = 4
__Tmp$6$ = -12						; size = 4
__Tmp$6$ = -12						; size = 4
__Tmp$1$ = -8						; size = 4
__Tmp$6$ = -8						; size = 4
__Tmp$1$ = -8						; size = 4
__Tmp$6$ = -8						; size = 4
__Tmp$6$ = -8						; size = 4
__Tmp$6$ = -8						; size = 4
tv364 = -8						; size = 4
___$ReturnUdt$1$ = -4					; size = 4
__Last$ = 8						; size = 4
__Pred$ = 12						; size = 4
??$_Partition_by_median_guess_unchecked@PAULight@CROS_impl@@P6A_NABU12@0@Z@std@@YA?AU?$pair@PAULight@CROS_impl@@PAU12@@0@PAULight@CROS_impl@@0P6A_NABU23@1@Z@Z PROC ; std::_Partition_by_median_guess_unchecked<CROS_impl::Light *,bool (__cdecl*)(CROS_impl::Light const &,CROS_impl::Light const &)>, COMDAT
; ___$ReturnUdt$ = ecx
; __First$ = edx

; 6976 : _CONSTEXPR20 pair<_RanIt, _RanIt> _Partition_by_median_guess_unchecked(_RanIt _First, _RanIt _Last, _Pr _Pred) {

	sub	esp, 36					; 00000024H
	push	ebx
	push	ebp
	push	esi
	push	edi

; 6977 :     // partition [_First, _Last)
; 6978 :     _RanIt _Mid = _First + ((_Last - _First) >> 1); // shift for codegen

	mov	edi, DWORD PTR __Last$[esp+48]
	mov	eax, edi
	sub	eax, edx

; 6963 :     if (40 < _Count) { // Tukey's ninther

	mov	ebx, DWORD PTR __Pred$[esp+48]

; 6977 :     // partition [_First, _Last)
; 6978 :     _RanIt _Mid = _First + ((_Last - _First) >> 1); // shift for codegen

	sar	eax, 3
	imul	eax, eax, -1431655765
	mov	DWORD PTR ___$ReturnUdt$1$[esp+52], ecx

; 6979 :     _Guess_median_unchecked(_First, _Mid, _Prev_iter(_Last), _Pred);

	lea	ecx, DWORD PTR [edi-24]
	mov	DWORD PTR __First$1$[esp+52], edx
	mov	DWORD PTR __Last$1$[esp+52], ecx
	sar	eax, 1
	lea	eax, DWORD PTR [eax+eax*2]
	lea	esi, DWORD PTR [edx+eax*8]

; 6962 :     const _Diff _Count = _Last - _First;

	mov	eax, ecx
	sub	eax, edx
	sar	eax, 3
	imul	eax, eax, -1431655765

; 6963 :     if (40 < _Count) { // Tukey's ninther

	cmp	eax, 40					; 00000028H
	jle	SHORT $LN35@Partition_

; 6964 :         const _Diff _Step     = (_Count + 1) >> 3; // +1 can't overflow because range was made inclusive in caller
; 6965 :         const _Diff _Two_step = _Step << 1; // note: intentionally discards low-order bit
; 6966 :         _Med3_unchecked(_First, _First + _Step, _First + _Two_step, _Pred);

	mov	ebp, DWORD PTR __Pred$[esp+48]
	inc	eax
	sar	eax, 3
	push	ebp
	lea	edi, DWORD PTR [eax+eax*2]
	lea	ebx, DWORD PTR [eax+eax*2]
	shl	edi, 3
	shl	ebx, 4
	lea	ecx, DWORD PTR [edi+edx]
	lea	eax, DWORD PTR [ebx+edx]
	mov	DWORD PTR $T1[esp+56], ecx
	mov	edx, ecx
	mov	ecx, DWORD PTR __First$1$[esp+56]
	push	eax
	call	??$_Med3_unchecked@PAULight@CROS_impl@@P6A_NABU12@0@Z@std@@YAXPAULight@CROS_impl@@00P6A_NABU12@1@Z@Z ; std::_Med3_unchecked<CROS_impl::Light *,bool (__cdecl*)(CROS_impl::Light const &,CROS_impl::Light const &)>

; 6967 :         _Med3_unchecked(_Mid - _Step, _Mid, _Mid + _Step, _Pred);

	lea	eax, DWORD PTR [edi+esi]
	mov	ecx, esi
	push	ebp
	push	eax
	sub	ecx, edi
	mov	edx, esi
	call	??$_Med3_unchecked@PAULight@CROS_impl@@P6A_NABU12@0@Z@std@@YAXPAULight@CROS_impl@@00P6A_NABU12@1@Z@Z ; std::_Med3_unchecked<CROS_impl::Light *,bool (__cdecl*)(CROS_impl::Light const &,CROS_impl::Light const &)>

; 6968 :         _Med3_unchecked(_Last - _Two_step, _Last - _Step, _Last, _Pred);

	mov	eax, DWORD PTR __Last$1$[esp+68]
	mov	ecx, eax
	sub	ecx, edi
	push	ebp
	push	eax
	sub	eax, ebx
	mov	DWORD PTR $T2[esp+76], ecx
	mov	edx, ecx
	mov	ecx, eax
	call	??$_Med3_unchecked@PAULight@CROS_impl@@P6A_NABU12@0@Z@std@@YAXPAULight@CROS_impl@@00P6A_NABU12@1@Z@Z ; std::_Med3_unchecked<CROS_impl::Light *,bool (__cdecl*)(CROS_impl::Light const &,CROS_impl::Light const &)>

; 6969 :         _Med3_unchecked(_First + _Step, _Mid, _Last - _Step, _Pred);
; 6970 :     } else {

	mov	edi, DWORD PTR __Last$[esp+72]
	add	esp, 24					; 00000018H
	mov	ecx, DWORD PTR $T2[esp+52]
	mov	ebx, ebp
	mov	eax, DWORD PTR $T1[esp+52]
	jmp	SHORT $LN36@Partition_
$LN35@Partition_:

; 6971 :         _Med3_unchecked(_First, _Mid, _Last, _Pred);

	mov	eax, edx
$LN36@Partition_:

; 6980 :     _RanIt _Pfirst = _Mid;

	push	ebx
	push	ecx
	mov	edx, esi
	mov	ecx, eax
	call	??$_Med3_unchecked@PAULight@CROS_impl@@P6A_NABU12@0@Z@std@@YAXPAULight@CROS_impl@@00P6A_NABU12@1@Z@Z ; std::_Med3_unchecked<CROS_impl::Light *,bool (__cdecl*)(CROS_impl::Light const &,CROS_impl::Light const &)>
	add	esp, 8

; 6981 :     _RanIt _Plast  = _Next_iter(_Pfirst);

	lea	ebp, DWORD PTR [esi+24]
	mov	DWORD PTR __Plast$1$[esp+52], ebp

; 6982 : 
; 6983 :     while (_First < _Pfirst && !_DEBUG_LT_PRED(_Pred, *_Prev_iter(_Pfirst), *_Pfirst)
; 6984 :            && !_Pred(*_Pfirst, *_Prev_iter(_Pfirst))) {

	cmp	DWORD PTR __First$1$[esp+52], esi
	jae	SHORT $LN70@Partition_
	mov	edi, DWORD PTR __First$1$[esp+52]
	npad	3
$LL2@Partition_:
	lea	eax, DWORD PTR [esi-24]
	push	esi
	push	eax
	mov	DWORD PTR tv365[esp+60], eax
	call	ebx
	add	esp, 8
	test	al, al
	jne	SHORT $LN94@Partition_
	push	DWORD PTR tv365[esp+52]
	push	esi
	call	ebx
	add	esp, 8
	test	al, al
	jne	SHORT $LN94@Partition_

; 6985 :         --_Pfirst;

	mov	esi, DWORD PTR tv365[esp+52]
	cmp	edi, esi
	jb	SHORT $LL2@Partition_
$LN94@Partition_:
	mov	edi, DWORD PTR __Last$[esp+48]
$LN70@Partition_:

; 6986 :     }
; 6987 : 
; 6988 :     while (_Plast < _Last && !_DEBUG_LT_PRED(_Pred, *_Plast, *_Pfirst) && !_Pred(*_Pfirst, *_Plast)) {

	cmp	ebp, edi
	jae	SHORT $LN5@Partition_
$LL4@Partition_:
	push	esi
	push	ebp
	call	ebx
	add	esp, 8
	test	al, al
	jne	SHORT $LN95@Partition_
	push	ebp
	push	esi
	call	ebx
	add	esp, 8
	test	al, al
	jne	SHORT $LN95@Partition_

; 6989 :         ++_Plast;

	add	ebp, 24					; 00000018H
	cmp	ebp, edi
	jb	SHORT $LL4@Partition_
$LN95@Partition_:
	mov	DWORD PTR __Plast$1$[esp+52], ebp
$LN5@Partition_:

; 6990 :     }
; 6991 : 
; 6992 :     _RanIt _Gfirst = _Plast;
; 6993 :     _RanIt _Glast  = _Pfirst;

	mov	ebx, esi
	mov	edi, ebp
	mov	DWORD PTR __Glast$1$[esp+52], ebx
$LN101@Partition_:

; 6994 : 
; 6995 :     for (;;) { // partition
; 6996 :         for (; _Gfirst < _Last; ++_Gfirst) {

	mov	DWORD PTR __Gfirst$1$[esp+52], edi
	npad	3
$LL6@Partition_:
	cmp	edi, DWORD PTR __Last$[esp+48]
	jae	$LN74@Partition_
	mov	ebx, DWORD PTR __Pred$[esp+48]
	npad	2
$LL11@Partition_:

; 6997 :             if (_DEBUG_LT_PRED(_Pred, *_Pfirst, *_Gfirst)) {

	push	edi
	push	esi
	call	ebx
	add	esp, 8
	test	al, al
	jne	$LN9@Partition_

; 6998 :                 continue;
; 6999 :             } else if (_Pred(*_Gfirst, *_Pfirst)) {

	push	esi
	push	edi
	call	ebx
	add	esp, 8
	test	al, al
	jne	$LN96@Partition_

; 7000 :                 break;
; 7001 :             } else if (_Plast != _Gfirst) {

	lea	eax, DWORD PTR [ebp+24]
	mov	DWORD PTR tv364[esp+52], eax
	cmp	ebp, edi
	je	$LN19@Partition_
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 100  :     _Ty _Tmp = _STD move(_Left);

	mov	ecx, DWORD PTR [ebp]
	mov	edi, DWORD PTR [ebp+8]
	mov	ebx, DWORD PTR [ebp+12]
	mov	edx, DWORD PTR [ebp+4]
	mov	ebp, DWORD PTR [ebp+16]
	mov	eax, DWORD PTR __Plast$1$[esp+52]
	mov	DWORD PTR __Tmp$1$[esp+52], ecx

; 101  :     _Left    = _STD move(_Right);

	mov	ecx, DWORD PTR __Plast$1$[esp+52]
	mov	eax, DWORD PTR [eax+20]
	mov	DWORD PTR __Tmp$6$[esp+52], eax
	mov	eax, DWORD PTR __Gfirst$1$[esp+52]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR __Gfirst$1$[esp+52]
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], eax
	mov	eax, DWORD PTR __Gfirst$1$[esp+52]
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax
	mov	eax, DWORD PTR __Gfirst$1$[esp+52]
	mov	eax, DWORD PTR [eax+12]
	mov	DWORD PTR [ecx+12], eax
	mov	eax, DWORD PTR __Gfirst$1$[esp+52]
	mov	eax, DWORD PTR [eax+16]
	mov	DWORD PTR [ecx+16], eax
	mov	eax, DWORD PTR __Gfirst$1$[esp+52]
	mov	eax, DWORD PTR [eax+20]
	mov	DWORD PTR [ecx+20], eax

; 102  :     _Right   = _STD move(_Tmp);

	mov	eax, DWORD PTR __Gfirst$1$[esp+52]
	mov	ecx, DWORD PTR __Tmp$1$[esp+52]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	mov	DWORD PTR [eax+8], edi
	mov	edi, eax
	mov	eax, DWORD PTR __Tmp$6$[esp+52]
	mov	DWORD PTR [edi+12], ebx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 7004 :             } else {

	mov	ebx, DWORD PTR __Pred$[esp+48]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 102  :     _Right   = _STD move(_Tmp);

	mov	DWORD PTR [edi+16], ebp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 7003 :                 ++_Plast;

	mov	ebp, DWORD PTR tv364[esp+52]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 102  :     _Right   = _STD move(_Tmp);

	mov	DWORD PTR [edi+20], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 7004 :             } else {

	jmp	SHORT $LN99@Partition_
$LN19@Partition_:

; 7005 :                 ++_Plast;

	mov	ebp, eax
$LN99@Partition_:

; 6994 : 
; 6995 :     for (;;) { // partition
; 6996 :         for (; _Gfirst < _Last; ++_Gfirst) {

	mov	DWORD PTR __Plast$1$[esp+52], ebp
$LN9@Partition_:
	add	edi, 24					; 00000018H
	mov	DWORD PTR __Gfirst$1$[esp+52], edi
	cmp	edi, DWORD PTR __Last$[esp+48]
	jb	$LL11@Partition_
$LN96@Partition_:
	mov	ebx, DWORD PTR __Glast$1$[esp+52]
$LN74@Partition_:

; 7009 :         for (; _First < _Glast; --_Glast) {

	mov	eax, DWORD PTR __First$1$[esp+52]
	cmp	ebx, eax
	jbe	$LN100@Partition_
	mov	ebp, DWORD PTR __Pred$[esp+48]
	lea	edi, DWORD PTR [ebx-24]
	mov	DWORD PTR tv358[esp+52], edi
$LL14@Partition_:

; 7010 :             if (_DEBUG_LT_PRED(_Pred, *_Prev_iter(_Glast), *_Pfirst)) {

	push	esi
	push	edi
	call	ebp
	add	esp, 8
	test	al, al
	jne	$LN12@Partition_

; 7011 :                 continue;
; 7012 :             } else if (_Pred(*_Pfirst, *_Prev_iter(_Glast))) {

	push	edi
	push	esi
	call	ebp
	add	esp, 8
	test	al, al
	jne	$LN98@Partition_

; 7013 :                 break;
; 7014 :             } else if (--_Pfirst != _Prev_iter(_Glast)) {

	sub	esi, 24					; 00000018H
	cmp	esi, edi
	je	SHORT $LN12@Partition_
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 100  :     _Ty _Tmp = _STD move(_Left);

	mov	eax, DWORD PTR [esi+20]
	mov	edi, DWORD PTR [esi+8]
	mov	ebx, DWORD PTR [esi+12]
	mov	ebp, DWORD PTR [esi+16]
	mov	ecx, DWORD PTR [esi]
	mov	edx, DWORD PTR [esi+4]
	mov	DWORD PTR __Tmp$6$[esp+52], eax

; 101  :     _Left    = _STD move(_Right);

	mov	eax, DWORD PTR tv358[esp+52]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [esi], eax
	mov	eax, DWORD PTR tv358[esp+52]
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR [esi+4], eax
	mov	eax, DWORD PTR tv358[esp+52]
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [esi+8], eax
	mov	eax, DWORD PTR tv358[esp+52]
	mov	eax, DWORD PTR [eax+12]
	mov	DWORD PTR [esi+12], eax
	mov	eax, DWORD PTR tv358[esp+52]
	mov	eax, DWORD PTR [eax+16]
	mov	DWORD PTR [esi+16], eax
	mov	eax, DWORD PTR tv358[esp+52]
	mov	eax, DWORD PTR [eax+20]
	mov	DWORD PTR [esi+20], eax

; 102  :     _Right   = _STD move(_Tmp);

	mov	eax, DWORD PTR tv358[esp+52]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	mov	DWORD PTR [eax+8], edi
	mov	edi, eax
	mov	eax, DWORD PTR __Tmp$6$[esp+52]
	mov	DWORD PTR [edi+12], ebx
	mov	ebx, DWORD PTR __Glast$1$[esp+52]
	mov	DWORD PTR [edi+16], ebp
	mov	ebp, DWORD PTR __Pred$[esp+48]
	mov	DWORD PTR [edi+20], eax
$LN12@Partition_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 7009 :         for (; _First < _Glast; --_Glast) {

	mov	eax, DWORD PTR __First$1$[esp+52]
	sub	ebx, 24					; 00000018H
	sub	edi, 24					; 00000018H
	mov	DWORD PTR __Glast$1$[esp+52], ebx
	mov	DWORD PTR tv358[esp+52], edi
	cmp	eax, ebx
	jb	$LL14@Partition_

; 7011 :                 continue;
; 7012 :             } else if (_Pred(*_Pfirst, *_Prev_iter(_Glast))) {

	jmp	SHORT $LN97@Partition_
$LN98@Partition_:
	mov	eax, DWORD PTR __First$1$[esp+52]
$LN97@Partition_:
	mov	edi, DWORD PTR __Gfirst$1$[esp+52]

; 7015 :                 _STD iter_swap(_Pfirst, _Prev_iter(_Glast));
; 7016 :             }
; 7017 :         }
; 7018 : 
; 7019 :         if (_Glast == _First && _Gfirst == _Last) {

	cmp	ebx, eax
$LN100@Partition_:
	jne	$LN27@Partition_
	cmp	edi, DWORD PTR __Last$[esp+48]
	je	$LN76@Partition_

; 7021 :         }
; 7022 : 
; 7023 :         if (_Glast == _First) { // no room at bottom, rotate pivot upward
; 7024 :             if (_Plast != _Gfirst) {

	mov	ecx, DWORD PTR __Plast$1$[esp+52]
	cmp	ecx, edi
	je	SHORT $LN29@Partition_
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 100  :     _Ty _Tmp = _STD move(_Left);

	mov	eax, DWORD PTR [esi+20]
	mov	ecx, DWORD PTR [esi]
	mov	edx, DWORD PTR [esi+4]
	mov	edi, DWORD PTR [esi+8]
	mov	ebx, DWORD PTR [esi+12]
	mov	ebp, DWORD PTR [esi+16]
	mov	DWORD PTR __Tmp$6$[esp+52], eax

; 101  :     _Left    = _STD move(_Right);

	mov	eax, DWORD PTR __Plast$1$[esp+52]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [esi], eax
	mov	eax, DWORD PTR __Plast$1$[esp+52]
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR [esi+4], eax
	mov	eax, DWORD PTR __Plast$1$[esp+52]
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [esi+8], eax
	mov	eax, DWORD PTR __Plast$1$[esp+52]
	mov	eax, DWORD PTR [eax+12]
	mov	DWORD PTR [esi+12], eax
	mov	eax, DWORD PTR __Plast$1$[esp+52]
	mov	eax, DWORD PTR [eax+16]
	mov	DWORD PTR [esi+16], eax
	mov	eax, DWORD PTR __Plast$1$[esp+52]
	mov	eax, DWORD PTR [eax+20]
	mov	DWORD PTR [esi+20], eax

; 102  :     _Right   = _STD move(_Tmp);

	mov	eax, DWORD PTR __Plast$1$[esp+52]
	mov	DWORD PTR [eax], ecx
	mov	ecx, eax
	mov	eax, DWORD PTR __Tmp$6$[esp+52]
	mov	DWORD PTR [ecx+4], edx
	mov	DWORD PTR [ecx+8], edi
	mov	DWORD PTR [ecx+12], ebx
	mov	DWORD PTR [ecx+16], ebp
	mov	DWORD PTR [ecx+20], eax
$LN29@Partition_:

; 100  :     _Ty _Tmp = _STD move(_Left);

	mov	eax, DWORD PTR [esi+20]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 7028 :             ++_Plast;

	add	ecx, 24					; 00000018H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 100  :     _Ty _Tmp = _STD move(_Left);

	mov	edi, DWORD PTR [esi+8]
	mov	ebx, DWORD PTR [esi+12]
	mov	ebp, DWORD PTR [esi+16]
	mov	edx, DWORD PTR [esi+4]
	mov	DWORD PTR __Tmp$6$[esp+52], eax

; 101  :     _Left    = _STD move(_Right);

	mov	eax, DWORD PTR __Gfirst$1$[esp+52]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 7028 :             ++_Plast;

	mov	DWORD PTR __Plast$1$[esp+52], ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 100  :     _Ty _Tmp = _STD move(_Left);

	mov	ecx, DWORD PTR [esi]

; 101  :     _Left    = _STD move(_Right);

	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [esi], eax
	mov	eax, DWORD PTR __Gfirst$1$[esp+52]
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR [esi+4], eax
	mov	eax, DWORD PTR __Gfirst$1$[esp+52]
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [esi+8], eax
	mov	eax, DWORD PTR __Gfirst$1$[esp+52]
	mov	eax, DWORD PTR [eax+12]
	mov	DWORD PTR [esi+12], eax
	mov	eax, DWORD PTR __Gfirst$1$[esp+52]
	mov	eax, DWORD PTR [eax+16]
	mov	DWORD PTR [esi+16], eax
	mov	eax, DWORD PTR __Gfirst$1$[esp+52]
	mov	eax, DWORD PTR [eax+20]
	mov	DWORD PTR [esi+20], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 7030 :             ++_Pfirst;

	add	esi, 24					; 00000018H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 102  :     _Right   = _STD move(_Tmp);

	mov	eax, DWORD PTR __Gfirst$1$[esp+52]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	mov	DWORD PTR [eax+8], edi
	mov	edi, eax
	mov	eax, DWORD PTR __Tmp$6$[esp+52]
	mov	DWORD PTR [edi+12], ebx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 7031 :             ++_Gfirst;

	mov	ebx, DWORD PTR __Glast$1$[esp+52]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 102  :     _Right   = _STD move(_Tmp);

	mov	DWORD PTR [edi+16], ebp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 7031 :             ++_Gfirst;

	mov	ebp, DWORD PTR __Plast$1$[esp+52]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 102  :     _Right   = _STD move(_Tmp);

	mov	DWORD PTR [edi+20], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 7031 :             ++_Gfirst;

	add	edi, 24					; 00000018H
	jmp	$LN101@Partition_
$LN27@Partition_:

; 7032 :         } else if (_Gfirst == _Last) { // no room at top, rotate pivot downward

	add	ebx, -24				; ffffffe8H
	mov	DWORD PTR __Glast$1$[esp+52], ebx
	cmp	edi, DWORD PTR __Last$[esp+48]
	jne	$LN30@Partition_

; 7033 :             if (--_Glast != --_Pfirst) {

	sub	esi, 24					; 00000018H
	cmp	ebx, esi
	je	SHORT $LN32@Partition_
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 100  :     _Ty _Tmp = _STD move(_Left);

	mov	ecx, DWORD PTR [ebx]
	mov	edx, DWORD PTR [ebx+4]
	mov	edi, DWORD PTR [ebx+8]
	mov	ebx, DWORD PTR [ebx+12]
	mov	eax, DWORD PTR __Glast$1$[esp+52]
	mov	DWORD PTR __Tmp$1$[esp+52], ecx

; 101  :     _Left    = _STD move(_Right);

	mov	ecx, DWORD PTR __Glast$1$[esp+52]
	mov	ebp, DWORD PTR [eax+16]
	mov	eax, DWORD PTR [eax+20]
	mov	DWORD PTR __Tmp$6$[esp+52], eax
	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [ecx+4], eax
	mov	eax, DWORD PTR [esi+8]
	mov	DWORD PTR [ecx+8], eax
	mov	eax, DWORD PTR [esi+12]
	mov	DWORD PTR [ecx+12], eax
	mov	eax, DWORD PTR [esi+16]
	mov	DWORD PTR [ecx+16], eax
	mov	eax, DWORD PTR [esi+20]
	mov	DWORD PTR [ecx+20], eax

; 102  :     _Right   = _STD move(_Tmp);

	mov	ecx, DWORD PTR __Tmp$1$[esp+52]
	mov	eax, DWORD PTR __Tmp$6$[esp+52]
	mov	DWORD PTR [esi], ecx
	mov	DWORD PTR [esi+4], edx
	mov	DWORD PTR [esi+8], edi
	mov	DWORD PTR [esi+12], ebx
	mov	DWORD PTR [esi+16], ebp
	mov	DWORD PTR [esi+20], eax
$LN32@Partition_:

; 100  :     _Ty _Tmp = _STD move(_Left);

	mov	eax, DWORD PTR [esi+20]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 7037 :             _STD iter_swap(_Pfirst, --_Plast);

	sub	DWORD PTR __Plast$1$[esp+52], 24	; 00000018H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 100  :     _Ty _Tmp = _STD move(_Left);

	mov	edi, DWORD PTR [esi+8]
	mov	ebx, DWORD PTR [esi+12]
	mov	ebp, DWORD PTR [esi+16]
	mov	ecx, DWORD PTR [esi]
	mov	edx, DWORD PTR [esi+4]
	mov	DWORD PTR __Tmp$6$[esp+52], eax

; 101  :     _Left    = _STD move(_Right);

	mov	eax, DWORD PTR __Plast$1$[esp+52]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [esi], eax
	mov	eax, DWORD PTR __Plast$1$[esp+52]
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR [esi+4], eax
	mov	eax, DWORD PTR __Plast$1$[esp+52]
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [esi+8], eax
	mov	eax, DWORD PTR __Plast$1$[esp+52]
	mov	eax, DWORD PTR [eax+12]
	mov	DWORD PTR [esi+12], eax
	mov	eax, DWORD PTR __Plast$1$[esp+52]
	mov	eax, DWORD PTR [eax+16]
	mov	DWORD PTR [esi+16], eax
	mov	eax, DWORD PTR __Plast$1$[esp+52]
	mov	eax, DWORD PTR [eax+20]
	mov	DWORD PTR [esi+20], eax

; 102  :     _Right   = _STD move(_Tmp);

	mov	eax, DWORD PTR __Plast$1$[esp+52]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	mov	DWORD PTR [eax+8], edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 7038 :         } else {

	mov	edi, DWORD PTR __Gfirst$1$[esp+52]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 102  :     _Right   = _STD move(_Tmp);

	mov	DWORD PTR [eax+12], ebx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 7038 :         } else {

	mov	ebx, DWORD PTR __Glast$1$[esp+52]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 102  :     _Right   = _STD move(_Tmp);

	mov	DWORD PTR [eax+16], ebp
	mov	ebp, DWORD PTR __Plast$1$[esp+52]
	mov	eax, DWORD PTR __Tmp$6$[esp+52]
	mov	DWORD PTR [ebp+20], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 7038 :         } else {

	jmp	$LL6@Partition_
$LN30@Partition_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 100  :     _Ty _Tmp = _STD move(_Left);

	mov	ecx, DWORD PTR [edi]
	mov	edx, DWORD PTR [edi+4]
	mov	eax, DWORD PTR __Gfirst$1$[esp+52]
	mov	edi, DWORD PTR [edi+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 7039 :             _STD iter_swap(_Gfirst, --_Glast);

	mov	DWORD PTR __Glast$1$[esp+52], ebx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 100  :     _Ty _Tmp = _STD move(_Left);

	mov	DWORD PTR __Tmp$1$[esp+52], ecx
	mov	ebx, DWORD PTR [eax+12]
	mov	ebp, DWORD PTR [eax+16]
	mov	eax, DWORD PTR [eax+20]

; 101  :     _Left    = _STD move(_Right);

	mov	ecx, DWORD PTR __Gfirst$1$[esp+52]
	mov	DWORD PTR __Tmp$6$[esp+52], eax
	mov	eax, DWORD PTR __Glast$1$[esp+52]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR __Glast$1$[esp+52]
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], eax
	mov	eax, DWORD PTR __Glast$1$[esp+52]
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax
	mov	eax, DWORD PTR __Glast$1$[esp+52]
	mov	eax, DWORD PTR [eax+12]
	mov	DWORD PTR [ecx+12], eax
	mov	eax, DWORD PTR __Glast$1$[esp+52]
	mov	eax, DWORD PTR [eax+16]
	mov	DWORD PTR [ecx+16], eax
	mov	eax, DWORD PTR __Glast$1$[esp+52]
	mov	eax, DWORD PTR [eax+20]
	mov	DWORD PTR [ecx+20], eax

; 102  :     _Right   = _STD move(_Tmp);

	mov	eax, DWORD PTR __Glast$1$[esp+52]
	mov	ecx, DWORD PTR __Tmp$1$[esp+52]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	mov	DWORD PTR [eax+8], edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 7040 :             ++_Gfirst;

	mov	edi, DWORD PTR __Gfirst$1$[esp+52]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 102  :     _Right   = _STD move(_Tmp);

	mov	DWORD PTR [eax+12], ebx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 7040 :             ++_Gfirst;

	add	edi, 24					; 00000018H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 102  :     _Right   = _STD move(_Tmp);

	mov	ebx, eax
	mov	eax, DWORD PTR __Tmp$6$[esp+52]
	mov	DWORD PTR [ebx+16], ebp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 7042 :     }

	mov	ebp, DWORD PTR __Plast$1$[esp+52]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 102  :     _Right   = _STD move(_Tmp);

	mov	DWORD PTR [ebx+20], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 7042 :     }

	jmp	$LN101@Partition_
$LN76@Partition_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 186  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

	mov	ecx, DWORD PTR ___$ReturnUdt$1$[esp+52]
	mov	eax, DWORD PTR __Plast$1$[esp+52]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 7043 : }

	pop	edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 186  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

	mov	DWORD PTR [ecx], esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 7043 : }

	pop	esi
	pop	ebp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 186  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

	mov	DWORD PTR [ecx+4], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 7020 :             return pair<_RanIt, _RanIt>(_Pfirst, _Plast);

	mov	eax, ecx

; 7043 : }

	pop	ebx
	add	esp, 36					; 00000024H
	ret	0
??$_Partition_by_median_guess_unchecked@PAULight@CROS_impl@@P6A_NABU12@0@Z@std@@YA?AU?$pair@PAULight@CROS_impl@@PAU12@@0@PAULight@CROS_impl@@0P6A_NABU23@1@Z@Z ENDP ; std::_Partition_by_median_guess_unchecked<CROS_impl::Light *,bool (__cdecl*)(CROS_impl::Light const &,CROS_impl::Light const &)>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Emplace_back@ULight@CROS_impl@@@?$_Uninitialized_backout_al@V?$xalloc@ULight@CROS_impl@@@@@std@@QAEX$$QAULight@CROS_impl@@@Z
_TEXT	SEGMENT
_<_Vals_0>$ = 8						; size = 4
??$_Emplace_back@ULight@CROS_impl@@@?$_Uninitialized_backout_al@V?$xalloc@ULight@CROS_impl@@@@@std@@QAEX$$QAULight@CROS_impl@@@Z PROC ; std::_Uninitialized_backout_al<xalloc<CROS_impl::Light> >::_Emplace_back<CROS_impl::Light>, COMDAT
; _this$ = ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	edx, DWORD PTR _<_Vals_0>$[esp-4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1619 :     _CONSTEXPR20_DYNALLOC void _Emplace_back(_Types&&... _Vals) { // construct a new element at *_Last and increment

	push	esi
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	esi, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [esi], eax
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [esi+4], eax
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR [esi+8], eax
	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR [esi+12], eax
	mov	eax, DWORD PTR [edx+16]
	mov	DWORD PTR [esi+16], eax
	mov	eax, DWORD PTR [edx+20]
	mov	DWORD PTR [esi+20], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1621 :         ++_Last;

	add	DWORD PTR [ecx+4], 24			; 00000018H
	pop	esi

; 1622 :     }

	ret	4
??$_Emplace_back@ULight@CROS_impl@@@?$_Uninitialized_backout_al@V?$xalloc@ULight@CROS_impl@@@@@std@@QAEX$$QAULight@CROS_impl@@@Z ENDP ; std::_Uninitialized_backout_al<xalloc<CROS_impl::Light> >::_Emplace_back<CROS_impl::Light>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Emplace_back@UItem@CROS_impl@@@?$_Uninitialized_backout_al@V?$xalloc@UItem@CROS_impl@@@@@std@@QAEX$$QAUItem@CROS_impl@@@Z
_TEXT	SEGMENT
_<_Vals_0>$ = 8						; size = 4
??$_Emplace_back@UItem@CROS_impl@@@?$_Uninitialized_backout_al@V?$xalloc@UItem@CROS_impl@@@@@std@@QAEX$$QAUItem@CROS_impl@@@Z PROC ; std::_Uninitialized_backout_al<xalloc<CROS_impl::Item> >::_Emplace_back<CROS_impl::Item>, COMDAT
; _this$ = ecx

; 1619 :     _CONSTEXPR20_DYNALLOC void _Emplace_back(_Types&&... _Vals) { // construct a new element at *_Last and increment

	mov	eax, ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	ecx, 21					; 00000015H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1619 :     _CONSTEXPR20_DYNALLOC void _Emplace_back(_Types&&... _Vals) { // construct a new element at *_Last and increment

	push	esi
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	esi, DWORD PTR _<_Vals_0>$[esp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1619 :     _CONSTEXPR20_DYNALLOC void _Emplace_back(_Types&&... _Vals) { // construct a new element at *_Last and increment

	push	edi
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	edi, DWORD PTR [eax+4]
	rep movsd
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1621 :         ++_Last;

	add	DWORD PTR [eax+4], 84			; 00000054H
	pop	edi
	pop	esi

; 1622 :     }

	ret	4
??$_Emplace_back@UItem@CROS_impl@@@?$_Uninitialized_backout_al@V?$xalloc@UItem@CROS_impl@@@@@std@@QAEX$$QAUItem@CROS_impl@@@Z ENDP ; std::_Uninitialized_backout_al<xalloc<CROS_impl::Item> >::_Emplace_back<CROS_impl::Item>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Destroy_in_place@PAULight@CROS_impl@@@std@@YAXAAPAULight@CROS_impl@@@Z
_TEXT	SEGMENT
??$_Destroy_in_place@PAULight@CROS_impl@@@std@@YAXAAPAULight@CROS_impl@@@Z PROC ; std::_Destroy_in_place<CROS_impl::Light *>, COMDAT
; __Obj$dead$ = ecx

; 295  :     if constexpr (is_array_v<_Ty>) {
; 296  :         _Destroy_range(_Obj, _Obj + extent_v<_Ty>);
; 297  :     } else {
; 298  :         _Obj.~_Ty();
; 299  :     }
; 300  : }

	ret	0
??$_Destroy_in_place@PAULight@CROS_impl@@@std@@YAXAAPAULight@CROS_impl@@@Z ENDP ; std::_Destroy_in_place<CROS_impl::Light *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_Move_backward_unchecked@PAULight@CROS_impl@@PAU12@@std@@YAPAULight@CROS_impl@@PAU12@00@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
??$_Move_backward_unchecked@PAULight@CROS_impl@@PAU12@@std@@YAPAULight@CROS_impl@@PAU12@00@Z PROC ; std::_Move_backward_unchecked<CROS_impl::Light *,CROS_impl::Light *>, COMDAT
; __First$ = ecx
; __Last$ = edx

; 4255 :     auto _Result                = _CSTD memmove(_Dest_ch - _Count, _First_ch, _Count);

	mov	eax, DWORD PTR __Dest$[esp-4]
	sub	edx, ecx
	push	edx
	push	ecx
	sub	eax, edx
	push	eax
	call	_memmove
	add	esp, 12					; 0000000cH

; 4351 :     // move [_First, _Last) backwards to [..., _Dest)
; 4352 :     // note: _Move_backward_unchecked has callers other than the move_backward family
; 4353 :     if constexpr (_Ptr_move_cat<_BidIt1, _BidIt2>::_Trivially_copyable) {
; 4354 : #ifdef __cpp_lib_is_constant_evaluated
; 4355 :         if (!_STD is_constant_evaluated())
; 4356 : #endif // __cpp_lib_is_constant_evaluated
; 4357 :         {
; 4358 :             return _Copy_backward_memmove(_First, _Last, _Dest);
; 4359 :         }
; 4360 :     }
; 4361 : 
; 4362 :     while (_First != _Last) {
; 4363 :         *--_Dest = _STD move(*--_Last);
; 4364 :     }
; 4365 : 
; 4366 :     return _Dest;
; 4367 : }

	ret	0
??$_Move_backward_unchecked@PAULight@CROS_impl@@PAU12@@std@@YAPAULight@CROS_impl@@PAU12@00@Z ENDP ; std::_Move_backward_unchecked<CROS_impl::Light *,CROS_impl::Light *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
;	COMDAT ??$_Pop_heap_hole_by_index@PAULight@CROS_impl@@U12@P6A_NABU12@0@Z@std@@YAXPAULight@CROS_impl@@HH$$QAU12@P6A_NABU12@2@Z@Z
_TEXT	SEGMENT
__Top$1$ = -8						; size = 4
tv94 = -4						; size = 4
__Bottom$ = 8						; size = 4
__Val$ = 12						; size = 4
__Pred$ = 16						; size = 4
??$_Pop_heap_hole_by_index@PAULight@CROS_impl@@U12@P6A_NABU12@0@Z@std@@YAXPAULight@CROS_impl@@HH$$QAU12@P6A_NABU12@2@Z@Z PROC ; std::_Pop_heap_hole_by_index<CROS_impl::Light *,CROS_impl::Light,bool (__cdecl*)(CROS_impl::Light const &,CROS_impl::Light const &)>, COMDAT
; __First$ = ecx
; __Hole$ = edx

; 5375 :     _RanIt _First, _Iter_diff_t<_RanIt> _Hole, _Iter_diff_t<_RanIt> _Bottom, _Ty&& _Val, _Pr _Pred) {

	sub	esp, 8

; 5376 :     // percolate _Hole to _Bottom, then push _Val
; 5377 :     _STL_INTERNAL_CHECK(_Bottom > 0);
; 5378 : 
; 5379 :     using _Diff      = _Iter_diff_t<_RanIt>;
; 5380 :     const _Diff _Top = _Hole;
; 5381 :     _Diff _Idx       = _Hole;
; 5382 : 
; 5383 :     // Check whether _Idx can have a child before calculating that child's index, since
; 5384 :     // calculating the child's index can trigger integer overflows
; 5385 :     const _Diff _Max_sequence_non_leaf = (_Bottom - 1) >> 1; // shift for codegen

	mov	eax, DWORD PTR __Bottom$[esp+4]
	push	ebx
	push	ebp
	push	esi
	mov	ebp, ecx
	mov	ebx, edx
	lea	ecx, DWORD PTR [eax-1]
	mov	DWORD PTR __Top$1$[esp+20], ebx
	push	edi
	mov	edi, ecx
	mov	DWORD PTR tv94[esp+24], ecx
	sar	edi, 1
	mov	esi, ebx

; 5386 :     while (_Idx < _Max_sequence_non_leaf) { // move _Hole down to larger child

	cmp	ebx, edi
	jge	SHORT $LN3@Pop_heap_h
$LL2@Pop_heap_h:

; 5387 :         _Idx = 2 * _Idx + 2;

	lea	esi, DWORD PTR [esi*2+2]

; 5388 :         if (_DEBUG_LT_PRED(_Pred, *(_First + _Idx), *(_First + (_Idx - 1)))) {

	lea	eax, DWORD PTR [esi+esi*2]
	lea	ecx, DWORD PTR [eax*8]
	add	ecx, ebp
	lea	eax, DWORD PTR [ecx-24]
	push	eax
	push	ecx
	call	DWORD PTR __Pred$[esp+28]
	add	esp, 8
	test	al, al
	je	SHORT $LN4@Pop_heap_h

; 5389 :             --_Idx;

	dec	esi
$LN4@Pop_heap_h:

; 5390 :         }
; 5391 :         *(_First + _Hole) = _STD move(*(_First + _Idx));

	lea	eax, DWORD PTR [esi+esi*2]
	lea	edx, DWORD PTR [eax*8]
	add	edx, ebp
	lea	eax, DWORD PTR [ebx+ebx*2]
	lea	ecx, DWORD PTR [eax*8]

; 5392 :         _Hole             = _Idx;

	mov	ebx, esi
	add	ecx, ebp
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+4], eax
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR [ecx+8], eax
	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR [ecx+12], eax
	mov	eax, DWORD PTR [edx+16]
	mov	DWORD PTR [ecx+16], eax
	mov	eax, DWORD PTR [edx+20]
	mov	DWORD PTR [ecx+20], eax
	cmp	esi, edi
	jl	SHORT $LL2@Pop_heap_h
	mov	eax, DWORD PTR __Bottom$[esp+20]
$LN3@Pop_heap_h:

; 5393 :     }
; 5394 : 
; 5395 :     if (_Idx == _Max_sequence_non_leaf && _Bottom % 2 == 0) { // only child at bottom, move _Hole down to it

	cmp	esi, edi
	jne	SHORT $LN5@Pop_heap_h
	test	al, 1
	jne	SHORT $LN5@Pop_heap_h

; 5396 :         *(_First + _Hole) = _STD move(*(_First + (_Bottom - 1)));

	lea	eax, DWORD PTR [eax+eax*2]
	lea	edx, DWORD PTR [eax*8]
	add	edx, ebp
	lea	eax, DWORD PTR [ebx+ebx*2]

; 5397 :         _Hole             = _Bottom - 1;

	mov	ebx, DWORD PTR tv94[esp+24]
	lea	ecx, DWORD PTR [eax*8]
	add	ecx, ebp
	mov	eax, DWORD PTR [edx-24]
	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR [edx-20]
	mov	DWORD PTR [ecx+4], eax
	mov	eax, DWORD PTR [edx-16]
	mov	DWORD PTR [ecx+8], eax
	mov	eax, DWORD PTR [edx-12]
	mov	DWORD PTR [ecx+12], eax
	mov	eax, DWORD PTR [edx-8]
	mov	DWORD PTR [ecx+16], eax
	mov	eax, DWORD PTR [edx-4]
	mov	DWORD PTR [ecx+20], eax
$LN5@Pop_heap_h:

; 5268 :          _Top < _Hole && _DEBUG_LT_PRED(_Pred, *(_First + _Idx), _Val); //

	cmp	DWORD PTR __Top$1$[esp+24], ebx
	jge	SHORT $LN20@Pop_heap_h
	npad	7
$LL10@Pop_heap_h:
	push	DWORD PTR __Val$[esp+20]
	lea	esi, DWORD PTR [ebx-1]
	sar	esi, 1
	lea	eax, DWORD PTR [esi+esi*2]
	lea	edi, DWORD PTR [eax*8]
	add	edi, ebp
	push	edi
	call	DWORD PTR __Pred$[esp+28]
	add	esp, 8
	test	al, al
	je	SHORT $LN20@Pop_heap_h

; 5269 :          _Idx = (_Hole - 1) >> 1) { // shift for codegen
; 5270 :         // move _Hole up to parent
; 5271 :         *(_First + _Hole) = _STD move(*(_First + _Idx));

	lea	eax, DWORD PTR [ebx+ebx*2]

; 5272 :         _Hole             = _Idx;

	mov	ebx, esi
	lea	ecx, DWORD PTR [eax*8]
	mov	eax, DWORD PTR [edi]
	add	ecx, ebp
	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR [edi+4]
	mov	DWORD PTR [ecx+4], eax
	mov	eax, DWORD PTR [edi+8]
	mov	DWORD PTR [ecx+8], eax
	mov	eax, DWORD PTR [edi+12]
	mov	DWORD PTR [ecx+12], eax
	mov	eax, DWORD PTR [edi+16]
	mov	DWORD PTR [ecx+16], eax
	mov	eax, DWORD PTR [edi+20]
	mov	DWORD PTR [ecx+20], eax
	cmp	DWORD PTR __Top$1$[esp+24], esi
	jl	SHORT $LL10@Pop_heap_h
$LN20@Pop_heap_h:

; 5273 :     }
; 5274 : 
; 5275 :     *(_First + _Hole) = _STD forward<_Ty>(_Val); // drop _Val into final hole

	mov	edx, DWORD PTR __Val$[esp+20]
	lea	eax, DWORD PTR [ebx+ebx*2]
	lea	ecx, DWORD PTR [eax*8]
	add	ecx, ebp
	pop	edi
	mov	eax, DWORD PTR [edx]
	pop	esi
	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+4], eax
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR [ecx+8], eax
	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR [ecx+12], eax
	mov	eax, DWORD PTR [edx+16]
	mov	DWORD PTR [ecx+16], eax
	mov	eax, DWORD PTR [edx+20]
	pop	ebp
	mov	DWORD PTR [ecx+20], eax
	pop	ebx

; 5398 :     }
; 5399 : 
; 5400 :     _Push_heap_by_index(_First, _Hole, _Top, _STD forward<_Ty>(_Val), _Pred);
; 5401 : }

	add	esp, 8
	ret	0
??$_Pop_heap_hole_by_index@PAULight@CROS_impl@@U12@P6A_NABU12@0@Z@std@@YAXPAULight@CROS_impl@@HH$$QAU12@P6A_NABU12@2@Z@Z ENDP ; std::_Pop_heap_hole_by_index<CROS_impl::Light *,CROS_impl::Light,bool (__cdecl*)(CROS_impl::Light const &,CROS_impl::Light const &)>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
;	COMDAT ??$_Pop_heap_unchecked@PAULight@CROS_impl@@P6A_NABU12@0@Z@std@@YAXPAULight@CROS_impl@@0P6A_NABU12@1@Z@Z
_TEXT	SEGMENT
__Val$1 = -24						; size = 24
__Pred$ = 8						; size = 4
??$_Pop_heap_unchecked@PAULight@CROS_impl@@P6A_NABU12@0@Z@std@@YAXPAULight@CROS_impl@@0P6A_NABU12@1@Z@Z PROC ; std::_Pop_heap_unchecked<CROS_impl::Light *,bool (__cdecl*)(CROS_impl::Light const &,CROS_impl::Light const &)>, COMDAT
; __First$ = ecx
; __Last$ = edx

; 5416 :     // pop *_First to *(_Last - 1) and reheap
; 5417 :     if (2 <= _Last - _First) {

	mov	eax, edx
	sub	esp, 24					; 00000018H
	sub	eax, ecx
	sar	eax, 3
	imul	eax, eax, -1431655765
	cmp	eax, 2
	jl	SHORT $LN2@Pop_heap_u

; 5418 :         --_Last;
; 5419 :         _Iter_value_t<_RanIt> _Val = _STD move(*_Last);

	mov	eax, DWORD PTR [edx-24]
	sub	edx, 24					; 00000018H
	mov	DWORD PTR __Val$1[esp+24], eax

; 5410 :     _Pop_heap_hole_by_index(

	push	DWORD PTR __Pred$[esp+20]

; 5418 :         --_Last;
; 5419 :         _Iter_value_t<_RanIt> _Val = _STD move(*_Last);

	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR __Val$1[esp+32], eax
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR __Val$1[esp+36], eax
	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR __Val$1[esp+40], eax
	mov	eax, DWORD PTR [edx+16]
	mov	DWORD PTR __Val$1[esp+44], eax
	mov	eax, DWORD PTR [edx+20]
	mov	DWORD PTR __Val$1[esp+48], eax

; 5408 :     *_Dest      = _STD move(*_First);

	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], eax
	mov	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+8], eax
	mov	eax, DWORD PTR [ecx+12]
	mov	DWORD PTR [edx+12], eax
	mov	eax, DWORD PTR [ecx+16]
	mov	DWORD PTR [edx+16], eax
	mov	eax, DWORD PTR [ecx+20]
	mov	DWORD PTR [edx+20], eax

; 5409 :     using _Diff = _Iter_diff_t<_RanIt>;
; 5410 :     _Pop_heap_hole_by_index(

	sub	edx, ecx
	lea	eax, DWORD PTR __Val$1[esp+28]
	sar	edx, 3
	push	eax
	imul	eax, edx, -1431655765
	xor	edx, edx
	push	eax
	call	??$_Pop_heap_hole_by_index@PAULight@CROS_impl@@U12@P6A_NABU12@0@Z@std@@YAXPAULight@CROS_impl@@HH$$QAU12@P6A_NABU12@2@Z@Z ; std::_Pop_heap_hole_by_index<CROS_impl::Light *,CROS_impl::Light,bool (__cdecl*)(CROS_impl::Light const &,CROS_impl::Light const &)>
	add	esp, 12					; 0000000cH
$LN2@Pop_heap_u:

; 5420 :         _Pop_heap_hole_unchecked(_First, _Last, _Last, _STD move(_Val), _Pred);
; 5421 :     }
; 5422 : }

	add	esp, 24					; 00000018H
	ret	0
??$_Pop_heap_unchecked@PAULight@CROS_impl@@P6A_NABU12@0@Z@std@@YAXPAULight@CROS_impl@@0P6A_NABU12@1@Z@Z ENDP ; std::_Pop_heap_unchecked<CROS_impl::Light *,bool (__cdecl*)(CROS_impl::Light const &,CROS_impl::Light const &)>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_Prev_iter@PAULight@CROS_impl@@@std@@YAPAULight@CROS_impl@@PAU12@@Z
_TEXT	SEGMENT
??$_Prev_iter@PAULight@CROS_impl@@@std@@YAPAULight@CROS_impl@@PAU12@@Z PROC ; std::_Prev_iter<CROS_impl::Light *>, COMDAT
; __First$ = ecx

; 1554 :     return --_First;

	lea	eax, DWORD PTR [ecx-24]

; 1555 : }

	ret	0
??$_Prev_iter@PAULight@CROS_impl@@@std@@YAPAULight@CROS_impl@@PAU12@@Z ENDP ; std::_Prev_iter<CROS_impl::Light *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
;	COMDAT ??$_Guess_median_unchecked@PAULight@CROS_impl@@P6A_NABU12@0@Z@std@@YAXPAULight@CROS_impl@@00P6A_NABU12@1@Z@Z
_TEXT	SEGMENT
__Mid$1$ = -4						; size = 4
$T1 = 8							; size = 4
__Last$ = 8						; size = 4
__Pred$ = 12						; size = 4
??$_Guess_median_unchecked@PAULight@CROS_impl@@P6A_NABU12@0@Z@std@@YAXPAULight@CROS_impl@@00P6A_NABU12@1@Z@Z PROC ; std::_Guess_median_unchecked<CROS_impl::Light *,bool (__cdecl*)(CROS_impl::Light const &,CROS_impl::Light const &)>, COMDAT
; __First$ = ecx
; __Mid$ = edx

; 6959 : _CONSTEXPR20 void _Guess_median_unchecked(_RanIt _First, _RanIt _Mid, _RanIt _Last, _Pr _Pred) {

	push	ecx
	push	ebx

; 6960 :     // sort median element to middle
; 6961 :     using _Diff        = _Iter_diff_t<_RanIt>;
; 6962 :     const _Diff _Count = _Last - _First;

	mov	ebx, DWORD PTR __Last$[esp+4]
	mov	eax, ebx
	sub	eax, ecx
	sar	eax, 3
	imul	eax, eax, -1431655765
	push	ebp
	push	esi
	mov	ebp, edx
	push	edi
	mov	DWORD PTR __Mid$1$[esp+20], ebp

; 6963 :     if (40 < _Count) { // Tukey's ninther

	cmp	eax, 40					; 00000028H
	jle	SHORT $LN2@Guess_medi

; 6964 :         const _Diff _Step     = (_Count + 1) >> 3; // +1 can't overflow because range was made inclusive in caller
; 6965 :         const _Diff _Two_step = _Step << 1; // note: intentionally discards low-order bit
; 6966 :         _Med3_unchecked(_First, _First + _Step, _First + _Two_step, _Pred);

	push	DWORD PTR __Pred$[esp+16]
	inc	eax
	sar	eax, 3
	lea	edi, DWORD PTR [eax+eax*2]
	lea	esi, DWORD PTR [eax+eax*2]
	shl	edi, 4
	shl	esi, 3
	lea	eax, DWORD PTR [edi+ecx]
	lea	edx, DWORD PTR [esi+ecx]
	push	eax
	mov	DWORD PTR $T1[esp+24], edx
	call	??$_Med3_unchecked@PAULight@CROS_impl@@P6A_NABU12@0@Z@std@@YAXPAULight@CROS_impl@@00P6A_NABU12@1@Z@Z ; std::_Med3_unchecked<CROS_impl::Light *,bool (__cdecl*)(CROS_impl::Light const &,CROS_impl::Light const &)>

; 6967 :         _Med3_unchecked(_Mid - _Step, _Mid, _Mid + _Step, _Pred);

	push	DWORD PTR __Pred$[esp+24]
	lea	eax, DWORD PTR [esi+ebp]
	mov	ecx, ebp
	push	eax
	sub	ecx, esi
	mov	edx, ebp
	call	??$_Med3_unchecked@PAULight@CROS_impl@@P6A_NABU12@0@Z@std@@YAXPAULight@CROS_impl@@00P6A_NABU12@1@Z@Z ; std::_Med3_unchecked<CROS_impl::Light *,bool (__cdecl*)(CROS_impl::Light const &,CROS_impl::Light const &)>

; 6968 :         _Med3_unchecked(_Last - _Two_step, _Last - _Step, _Last, _Pred);

	push	DWORD PTR __Pred$[esp+32]
	mov	ebp, ebx
	push	ebx
	sub	ebp, esi
	sub	ebx, edi
	mov	edx, ebp
	mov	ecx, ebx
	call	??$_Med3_unchecked@PAULight@CROS_impl@@P6A_NABU12@0@Z@std@@YAXPAULight@CROS_impl@@00P6A_NABU12@1@Z@Z ; std::_Med3_unchecked<CROS_impl::Light *,bool (__cdecl*)(CROS_impl::Light const &,CROS_impl::Light const &)>

; 6969 :         _Med3_unchecked(_First + _Step, _Mid, _Last - _Step, _Pred);
; 6970 :     } else {

	mov	ecx, DWORD PTR $T1[esp+40]
	add	esp, 24					; 00000018H
	jmp	SHORT $LN3@Guess_medi
$LN2@Guess_medi:

; 6971 :         _Med3_unchecked(_First, _Mid, _Last, _Pred);

	mov	ebp, ebx
$LN3@Guess_medi:

; 6972 :     }
; 6973 : }

	push	DWORD PTR __Pred$[esp+16]
	mov	edx, DWORD PTR __Mid$1$[esp+24]
	push	ebp
	call	??$_Med3_unchecked@PAULight@CROS_impl@@P6A_NABU12@0@Z@std@@YAXPAULight@CROS_impl@@00P6A_NABU12@1@Z@Z ; std::_Med3_unchecked<CROS_impl::Light *,bool (__cdecl*)(CROS_impl::Light const &,CROS_impl::Light const &)>
	add	esp, 8
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	pop	ecx
	ret	0
??$_Guess_median_unchecked@PAULight@CROS_impl@@P6A_NABU12@0@Z@std@@YAXPAULight@CROS_impl@@00P6A_NABU12@1@Z@Z ENDP ; std::_Guess_median_unchecked<CROS_impl::Light *,bool (__cdecl*)(CROS_impl::Light const &,CROS_impl::Light const &)>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_Next_iter@PAULight@CROS_impl@@@std@@YAPAULight@CROS_impl@@PAU12@@Z
_TEXT	SEGMENT
??$_Next_iter@PAULight@CROS_impl@@@std@@YAPAULight@CROS_impl@@PAU12@@Z PROC ; std::_Next_iter<CROS_impl::Light *>, COMDAT
; __First$ = ecx

; 1541 :     return ++_First;

	lea	eax, DWORD PTR [ecx+24]

; 1542 : }

	ret	0
??$_Next_iter@PAULight@CROS_impl@@@std@@YAPAULight@CROS_impl@@PAU12@@Z ENDP ; std::_Next_iter<CROS_impl::Light *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
;	COMDAT ??$iter_swap@PAULight@CROS_impl@@PAU12@@std@@YAXPAULight@CROS_impl@@0@Z
_TEXT	SEGMENT
__Right$1$ = -8						; size = 4
__Tmp$6$ = -4						; size = 4
??$iter_swap@PAULight@CROS_impl@@PAU12@@std@@YAXPAULight@CROS_impl@@0@Z PROC ; std::iter_swap<CROS_impl::Light *,CROS_impl::Light *>, COMDAT
; __Left$ = ecx
; __Right$ = edx

; 77   : _CONSTEXPR20 void iter_swap(_FwdIt1 _Left, _FwdIt2 _Right) { // swap *_Left and *_Right

	sub	esp, 8

; 100  :     _Ty _Tmp = _STD move(_Left);

	mov	eax, DWORD PTR [ecx+20]
	mov	DWORD PTR __Tmp$6$[esp+8], eax

; 77   : _CONSTEXPR20 void iter_swap(_FwdIt1 _Left, _FwdIt2 _Right) { // swap *_Left and *_Right

	push	ebx

; 100  :     _Ty _Tmp = _STD move(_Left);

	mov	ebx, DWORD PTR [ecx+12]

; 77   : _CONSTEXPR20 void iter_swap(_FwdIt1 _Left, _FwdIt2 _Right) { // swap *_Left and *_Right

	mov	DWORD PTR __Right$1$[esp+12], edx

; 100  :     _Ty _Tmp = _STD move(_Left);

	mov	edx, DWORD PTR [ecx+8]

; 101  :     _Left    = _STD move(_Right);

	mov	eax, DWORD PTR __Right$1$[esp+12]

; 77   : _CONSTEXPR20 void iter_swap(_FwdIt1 _Left, _FwdIt2 _Right) { // swap *_Left and *_Right

	push	ebp

; 100  :     _Ty _Tmp = _STD move(_Left);

	mov	ebp, DWORD PTR [ecx+16]

; 77   : _CONSTEXPR20 void iter_swap(_FwdIt1 _Left, _FwdIt2 _Right) { // swap *_Left and *_Right

	push	esi

; 101  :     _Left    = _STD move(_Right);

	mov	eax, DWORD PTR [eax]
	mov	esi, DWORD PTR [ecx]

; 77   : _CONSTEXPR20 void iter_swap(_FwdIt1 _Left, _FwdIt2 _Right) { // swap *_Left and *_Right

	push	edi

; 100  :     _Ty _Tmp = _STD move(_Left);

	mov	edi, DWORD PTR [ecx+4]

; 101  :     _Left    = _STD move(_Right);

	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR __Right$1$[esp+24]
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], eax
	mov	eax, DWORD PTR __Right$1$[esp+24]
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax
	mov	eax, DWORD PTR __Right$1$[esp+24]
	mov	eax, DWORD PTR [eax+12]
	mov	DWORD PTR [ecx+12], eax
	mov	eax, DWORD PTR __Right$1$[esp+24]
	mov	eax, DWORD PTR [eax+16]
	mov	DWORD PTR [ecx+16], eax
	mov	eax, DWORD PTR __Right$1$[esp+24]
	mov	eax, DWORD PTR [eax+20]
	mov	DWORD PTR [ecx+20], eax

; 102  :     _Right   = _STD move(_Tmp);

	mov	ecx, DWORD PTR __Right$1$[esp+24]
	mov	eax, DWORD PTR __Tmp$6$[esp+24]
	mov	DWORD PTR [ecx], esi
	mov	DWORD PTR [ecx+4], edi

; 78   :     swap(*_Left, *_Right);
; 79   : }

	pop	edi

; 102  :     _Right   = _STD move(_Tmp);

	mov	DWORD PTR [ecx+8], edx
	mov	DWORD PTR [ecx+12], ebx

; 78   :     swap(*_Left, *_Right);
; 79   : }

	pop	esi

; 102  :     _Right   = _STD move(_Tmp);

	mov	DWORD PTR [ecx+16], ebp

; 78   :     swap(*_Left, *_Right);
; 79   : }

	pop	ebp

; 102  :     _Right   = _STD move(_Tmp);

	mov	DWORD PTR [ecx+20], eax

; 78   :     swap(*_Left, *_Right);
; 79   : }

	pop	ebx
	add	esp, 8
	ret	0
??$iter_swap@PAULight@CROS_impl@@PAU12@@std@@YAXPAULight@CROS_impl@@0@Z ENDP ; std::iter_swap<CROS_impl::Light *,CROS_impl::Light *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
;	COMDAT ??$?0AAPAULight@CROS_impl@@AAPAU01@$0A@@?$pair@PAULight@CROS_impl@@PAU12@@std@@QAE@AAPAULight@CROS_impl@@0@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??$?0AAPAULight@CROS_impl@@AAPAU01@$0A@@?$pair@PAULight@CROS_impl@@PAU12@@std@@QAE@AAPAULight@CROS_impl@@0@Z PROC ; std::pair<CROS_impl::Light *,CROS_impl::Light *>::pair<CROS_impl::Light *,CROS_impl::Light *><CROS_impl::Light * &,CROS_impl::Light * &,0>, COMDAT
; _this$ = ecx

; 186  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

	mov	eax, DWORD PTR __Val1$[esp-4]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR __Val2$[esp-4]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx+4], eax
	mov	eax, ecx
	ret	8
??$?0AAPAULight@CROS_impl@@AAPAU01@$0A@@?$pair@PAULight@CROS_impl@@PAU12@@std@@QAE@AAPAULight@CROS_impl@@0@Z ENDP ; std::pair<CROS_impl::Light *,CROS_impl::Light *>::pair<CROS_impl::Light *,CROS_impl::Light *><CROS_impl::Light * &,CROS_impl::Light * &,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_Copy_backward_memmove@PAULight@CROS_impl@@PAU12@@std@@YAPAULight@CROS_impl@@PAU12@00@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
??$_Copy_backward_memmove@PAULight@CROS_impl@@PAU12@@std@@YAPAULight@CROS_impl@@PAU12@00@Z PROC ; std::_Copy_backward_memmove<CROS_impl::Light *,CROS_impl::Light *>, COMDAT
; __First$ = ecx
; __Last$ = edx

; 4247 :     // implement copy_backward-like function as memmove
; 4248 :     auto _FirstPtr              = _To_address(_First);
; 4249 :     auto _LastPtr               = _To_address(_Last);
; 4250 :     auto _DestPtr               = _To_address(_Dest);
; 4251 :     const char* const _First_ch = const_cast<const char*>(reinterpret_cast<const volatile char*>(_FirstPtr));
; 4252 :     const char* const _Last_ch  = const_cast<const char*>(reinterpret_cast<const volatile char*>(_LastPtr));
; 4253 :     char* const _Dest_ch        = const_cast<char*>(reinterpret_cast<const volatile char*>(_DestPtr));
; 4254 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);
; 4255 :     auto _Result                = _CSTD memmove(_Dest_ch - _Count, _First_ch, _Count);

	mov	eax, DWORD PTR __Dest$[esp-4]
	sub	edx, ecx
	push	edx
	push	ecx
	sub	eax, edx
	push	eax
	call	_memmove
	add	esp, 12					; 0000000cH

; 4256 :     if constexpr (is_pointer_v<_CtgIt2>) {
; 4257 :         return static_cast<_CtgIt2>(_Result);
; 4258 :     } else {
; 4259 :         return _Dest - (_LastPtr - _FirstPtr);
; 4260 :     }
; 4261 : }

	ret	0
??$_Copy_backward_memmove@PAULight@CROS_impl@@PAU12@@std@@YAPAULight@CROS_impl@@PAU12@00@Z ENDP ; std::_Copy_backward_memmove<CROS_impl::Light *,CROS_impl::Light *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_To_address@PAULight@CROS_impl@@@std@@YA?A_PABQAULight@CROS_impl@@@Z
_TEXT	SEGMENT
??$_To_address@PAULight@CROS_impl@@@std@@YA?A_PABQAULight@CROS_impl@@@Z PROC ; std::_To_address<CROS_impl::Light *>, COMDAT
; __Val$ = ecx

; 3981 :     _STL_INTERNAL_STATIC_ASSERT(is_pointer_v<_Iter>);
; 3982 :     return _Val;

	mov	eax, DWORD PTR [ecx]

; 3983 : }

	ret	0
??$_To_address@PAULight@CROS_impl@@@std@@YA?A_PABQAULight@CROS_impl@@@Z ENDP ; std::_To_address<CROS_impl::Light *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
;	COMDAT ??$_Push_heap_by_index@PAULight@CROS_impl@@U12@P6A_NABU12@0@Z@std@@YAXPAULight@CROS_impl@@HH$$QAU12@P6A_NABU12@2@Z@Z
_TEXT	SEGMENT
__First$1$ = -4						; size = 4
__Top$ = 8						; size = 4
__Val$ = 12						; size = 4
__Pred$ = 16						; size = 4
??$_Push_heap_by_index@PAULight@CROS_impl@@U12@P6A_NABU12@0@Z@std@@YAXPAULight@CROS_impl@@HH$$QAU12@P6A_NABU12@2@Z@Z PROC ; std::_Push_heap_by_index<CROS_impl::Light *,CROS_impl::Light,bool (__cdecl*)(CROS_impl::Light const &,CROS_impl::Light const &)>, COMDAT
; __First$ = ecx
; __Hole$ = edx

; 5264 :     _RanIt _First, _Iter_diff_t<_RanIt> _Hole, _Iter_diff_t<_RanIt> _Top, _Ty&& _Val, _Pr _Pred) {

	push	ecx
	push	ebx
	mov	ebx, edx
	mov	DWORD PTR __First$1$[esp+8], ecx
	push	ebp

; 5268 :          _Top < _Hole && _DEBUG_LT_PRED(_Pred, *(_First + _Idx), _Val); //

	mov	ebp, DWORD PTR __Val$[esp+8]
	cmp	DWORD PTR __Top$[esp+8], ebx
	jge	SHORT $LN3@Push_heap_
	push	esi
	push	edi
$LL4@Push_heap_:

; 5265 :     // percolate _Hole to _Top or where _Val belongs
; 5266 :     using _Diff = _Iter_diff_t<_RanIt>;
; 5267 :     for (_Diff _Idx = (_Hole - 1) >> 1; // shift for codegen

	lea	esi, DWORD PTR [ebx-1]
	sar	esi, 1

; 5268 :          _Top < _Hole && _DEBUG_LT_PRED(_Pred, *(_First + _Idx), _Val); //

	push	ebp
	lea	eax, DWORD PTR [esi+esi*2]
	lea	edi, DWORD PTR [ecx+eax*8]
	push	edi
	call	DWORD PTR __Pred$[esp+24]
	add	esp, 8
	test	al, al
	je	SHORT $LN10@Push_heap_

; 5269 :          _Idx = (_Hole - 1) >> 1) { // shift for codegen
; 5270 :         // move _Hole up to parent
; 5271 :         *(_First + _Hole) = _STD move(*(_First + _Idx));

	lea	eax, DWORD PTR [ebx+ebx*2]
	mov	ecx, DWORD PTR __First$1$[esp+20]
	lea	ecx, DWORD PTR [ecx+eax*8]
	mov	eax, DWORD PTR [edi]

; 5272 :         _Hole             = _Idx;

	mov	ebx, esi
	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR [edi+4]
	mov	DWORD PTR [ecx+4], eax
	mov	eax, DWORD PTR [edi+8]
	mov	DWORD PTR [ecx+8], eax
	mov	eax, DWORD PTR [edi+12]
	mov	DWORD PTR [ecx+12], eax
	mov	eax, DWORD PTR [edi+16]
	mov	DWORD PTR [ecx+16], eax
	mov	eax, DWORD PTR [edi+20]
	mov	DWORD PTR [ecx+20], eax
	mov	ecx, DWORD PTR __First$1$[esp+20]
	cmp	DWORD PTR __Top$[esp+16], esi
	jl	SHORT $LL4@Push_heap_
$LN10@Push_heap_:
	mov	ecx, DWORD PTR __First$1$[esp+20]
	pop	edi
	pop	esi
$LN3@Push_heap_:

; 5273 :     }
; 5274 : 
; 5275 :     *(_First + _Hole) = _STD forward<_Ty>(_Val); // drop _Val into final hole

	lea	eax, DWORD PTR [ebx+ebx*2]
	lea	ecx, DWORD PTR [ecx+eax*8]
	mov	eax, DWORD PTR [ebp]
	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR [ebp+4]
	mov	DWORD PTR [ecx+4], eax
	mov	eax, DWORD PTR [ebp+8]
	mov	DWORD PTR [ecx+8], eax
	mov	eax, DWORD PTR [ebp+12]
	mov	DWORD PTR [ecx+12], eax
	mov	eax, DWORD PTR [ebp+16]
	mov	DWORD PTR [ecx+16], eax
	mov	eax, DWORD PTR [ebp+20]
	pop	ebp
	mov	DWORD PTR [ecx+20], eax
	pop	ebx

; 5276 : }

	pop	ecx
	ret	0
??$_Push_heap_by_index@PAULight@CROS_impl@@U12@P6A_NABU12@0@Z@std@@YAXPAULight@CROS_impl@@HH$$QAU12@P6A_NABU12@2@Z@Z ENDP ; std::_Push_heap_by_index<CROS_impl::Light *,CROS_impl::Light,bool (__cdecl*)(CROS_impl::Light const &,CROS_impl::Light const &)>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
;	COMDAT ??$_Pop_heap_hole_unchecked@PAULight@CROS_impl@@U12@P6A_NABU12@0@Z@std@@YAXPAULight@CROS_impl@@00$$QAU12@P6A_NABU12@2@Z@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Val$ = 12						; size = 4
__Pred$ = 16						; size = 4
??$_Pop_heap_hole_unchecked@PAULight@CROS_impl@@U12@P6A_NABU12@0@Z@std@@YAXPAULight@CROS_impl@@00$$QAU12@P6A_NABU12@2@Z@Z PROC ; std::_Pop_heap_hole_unchecked<CROS_impl::Light *,CROS_impl::Light,bool (__cdecl*)(CROS_impl::Light const &,CROS_impl::Light const &)>, COMDAT
; __First$ = ecx
; __Last$ = edx

; 5405 :     // pop *_First to *_Dest and reheap
; 5406 :     // precondition: _First != _Last
; 5407 :     // precondition: _First != _Dest
; 5408 :     *_Dest      = _STD move(*_First);

	mov	eax, DWORD PTR [ecx]
	push	esi
	mov	esi, DWORD PTR __Dest$[esp]
	mov	DWORD PTR [esi], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [esi+4], eax
	mov	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR [esi+8], eax
	mov	eax, DWORD PTR [ecx+12]
	mov	DWORD PTR [esi+12], eax
	mov	eax, DWORD PTR [ecx+16]
	mov	DWORD PTR [esi+16], eax
	mov	eax, DWORD PTR [ecx+20]
	mov	DWORD PTR [esi+20], eax

; 5409 :     using _Diff = _Iter_diff_t<_RanIt>;
; 5410 :     _Pop_heap_hole_by_index(

	pop	esi
	sub	edx, ecx
	sar	edx, 3
	imul	eax, edx, -1431655765
	mov	DWORD PTR __Dest$[esp-4], eax
	xor	edx, edx
	jmp	??$_Pop_heap_hole_by_index@PAULight@CROS_impl@@U12@P6A_NABU12@0@Z@std@@YAXPAULight@CROS_impl@@HH$$QAU12@P6A_NABU12@2@Z@Z ; std::_Pop_heap_hole_by_index<CROS_impl::Light *,CROS_impl::Light,bool (__cdecl*)(CROS_impl::Light const &,CROS_impl::Light const &)>
??$_Pop_heap_hole_unchecked@PAULight@CROS_impl@@U12@P6A_NABU12@0@Z@std@@YAXPAULight@CROS_impl@@00$$QAU12@P6A_NABU12@2@Z@Z ENDP ; std::_Pop_heap_hole_unchecked<CROS_impl::Light *,CROS_impl::Light,bool (__cdecl*)(CROS_impl::Light const &,CROS_impl::Light const &)>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
;	COMDAT ??$_Med3_unchecked@PAULight@CROS_impl@@P6A_NABU12@0@Z@std@@YAXPAULight@CROS_impl@@00P6A_NABU12@1@Z@Z
_TEXT	SEGMENT
__First$1$ = -12					; size = 4
__Mid$1$ = -8						; size = 4
__Tmp$1$ = -4						; size = 4
__Tmp$1$ = -4						; size = 4
__Last$ = 8						; size = 4
__Tmp$1$ = 12						; size = 4
__Pred$ = 12						; size = 4
??$_Med3_unchecked@PAULight@CROS_impl@@P6A_NABU12@0@Z@std@@YAXPAULight@CROS_impl@@00P6A_NABU12@1@Z@Z PROC ; std::_Med3_unchecked<CROS_impl::Light *,bool (__cdecl*)(CROS_impl::Light const &,CROS_impl::Light const &)>, COMDAT
; __First$ = ecx
; __Mid$ = edx

; 6943 : _CONSTEXPR20 void _Med3_unchecked(_RanIt _First, _RanIt _Mid, _RanIt _Last, _Pr _Pred) {

	sub	esp, 12					; 0000000cH
	push	ebx
	push	ebp
	push	esi
	mov	eax, ecx
	mov	ebp, edx
	push	edi

; 6944 :     // sort median of three elements to middle
; 6945 :     if (_DEBUG_LT_PRED(_Pred, *_Mid, *_First)) {

	push	eax
	push	ebp
	mov	DWORD PTR __Mid$1$[esp+36], ebp
	mov	DWORD PTR __First$1$[esp+36], eax
	call	DWORD PTR __Pred$[esp+32]
	add	esp, 8
	test	al, al
	je	SHORT $LN2@Med3_unche
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 100  :     _Ty _Tmp = _STD move(_Left);

	mov	ecx, DWORD PTR [ebp]
	mov	edx, DWORD PTR [ebp+4]
	mov	esi, DWORD PTR [ebp+8]
	mov	edi, DWORD PTR [ebp+12]
	mov	ebx, DWORD PTR [ebp+16]
	mov	ebp, DWORD PTR [ebp+20]
	mov	DWORD PTR __Tmp$1$[esp+28], ecx

; 101  :     _Left    = _STD move(_Right);

	mov	ecx, DWORD PTR __First$1$[esp+28]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR __Mid$1$[esp+28]
	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR __First$1$[esp+28]
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], eax
	mov	eax, DWORD PTR __First$1$[esp+28]
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax
	mov	eax, DWORD PTR __First$1$[esp+28]
	mov	eax, DWORD PTR [eax+12]
	mov	DWORD PTR [ecx+12], eax
	mov	eax, DWORD PTR __First$1$[esp+28]
	mov	eax, DWORD PTR [eax+16]
	mov	DWORD PTR [ecx+16], eax
	mov	eax, DWORD PTR __First$1$[esp+28]
	mov	eax, DWORD PTR [eax+20]
	mov	DWORD PTR [ecx+20], eax

; 102  :     _Right   = _STD move(_Tmp);

	mov	eax, DWORD PTR __First$1$[esp+28]
	mov	ecx, DWORD PTR __Tmp$1$[esp+28]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	mov	DWORD PTR [eax+8], esi
	mov	DWORD PTR [eax+12], edi
	mov	DWORD PTR [eax+16], ebx
	mov	DWORD PTR [eax+20], ebp
	mov	ebp, DWORD PTR __Mid$1$[esp+28]
$LN2@Med3_unche:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 6949 :     if (_DEBUG_LT_PRED(_Pred, *_Last, *_Mid)) { // swap middle and last, then test first again

	push	ebp
	mov	ebp, DWORD PTR __Last$[esp+28]
	push	ebp
	call	DWORD PTR __Pred$[esp+32]
	add	esp, 8
	test	al, al
	je	$LN4@Med3_unche
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 100  :     _Ty _Tmp = _STD move(_Left);

	mov	ecx, DWORD PTR [ebp]
	mov	edx, DWORD PTR [ebp+4]
	mov	esi, DWORD PTR [ebp+8]
	mov	edi, DWORD PTR [ebp+12]
	mov	ebx, DWORD PTR [ebp+16]
	mov	ebp, DWORD PTR [ebp+20]

; 101  :     _Left    = _STD move(_Right);

	mov	eax, DWORD PTR __Mid$1$[esp+28]
	mov	DWORD PTR __Tmp$1$[esp+28], ecx
	mov	ecx, DWORD PTR __Last$[esp+24]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR __Mid$1$[esp+28]
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], eax
	mov	eax, DWORD PTR __Mid$1$[esp+28]
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax
	mov	eax, DWORD PTR __Mid$1$[esp+28]
	mov	eax, DWORD PTR [eax+12]
	mov	DWORD PTR [ecx+12], eax
	mov	eax, DWORD PTR __Mid$1$[esp+28]
	mov	eax, DWORD PTR [eax+16]
	mov	DWORD PTR [ecx+16], eax
	mov	eax, DWORD PTR __Mid$1$[esp+28]
	mov	eax, DWORD PTR [eax+20]
	mov	DWORD PTR [ecx+20], eax

; 102  :     _Right   = _STD move(_Tmp);

	mov	eax, DWORD PTR __Mid$1$[esp+28]
	mov	ecx, DWORD PTR __Tmp$1$[esp+28]
	mov	DWORD PTR [eax], ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 6952 :         if (_DEBUG_LT_PRED(_Pred, *_Mid, *_First)) {

	mov	ecx, DWORD PTR __First$1$[esp+28]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 102  :     _Right   = _STD move(_Tmp);

	mov	DWORD PTR [eax+4], edx
	mov	DWORD PTR [eax+8], esi
	mov	DWORD PTR [eax+12], edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 6952 :         if (_DEBUG_LT_PRED(_Pred, *_Mid, *_First)) {

	push	ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 102  :     _Right   = _STD move(_Tmp);

	mov	DWORD PTR [eax+16], ebx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 6952 :         if (_DEBUG_LT_PRED(_Pred, *_Mid, *_First)) {

	push	eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 102  :     _Right   = _STD move(_Tmp);

	mov	DWORD PTR [eax+20], ebp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 6952 :         if (_DEBUG_LT_PRED(_Pred, *_Mid, *_First)) {

	call	DWORD PTR __Pred$[esp+32]
	add	esp, 8
	test	al, al
	je	SHORT $LN4@Med3_unche
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 100  :     _Ty _Tmp = _STD move(_Left);

	mov	eax, DWORD PTR __Mid$1$[esp+28]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	esi, DWORD PTR [eax+8]
	mov	edi, DWORD PTR [eax+12]
	mov	ebx, DWORD PTR [eax+16]
	mov	ebp, DWORD PTR [eax+20]

; 101  :     _Left    = _STD move(_Right);

	mov	eax, DWORD PTR __First$1$[esp+28]
	mov	DWORD PTR __Tmp$1$[esp+24], ecx
	mov	ecx, DWORD PTR __Mid$1$[esp+28]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR __First$1$[esp+28]
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], eax
	mov	eax, DWORD PTR __First$1$[esp+28]
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax
	mov	eax, DWORD PTR __First$1$[esp+28]
	mov	eax, DWORD PTR [eax+12]
	mov	DWORD PTR [ecx+12], eax
	mov	eax, DWORD PTR __First$1$[esp+28]
	mov	eax, DWORD PTR [eax+16]
	mov	DWORD PTR [ecx+16], eax
	mov	eax, DWORD PTR __First$1$[esp+28]
	mov	eax, DWORD PTR [eax+20]
	mov	DWORD PTR [ecx+20], eax

; 102  :     _Right   = _STD move(_Tmp);

	mov	eax, DWORD PTR __First$1$[esp+28]
	mov	ecx, DWORD PTR __Tmp$1$[esp+24]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	mov	DWORD PTR [eax+8], esi
	mov	DWORD PTR [eax+12], edi
	mov	DWORD PTR [eax+16], ebx
	mov	DWORD PTR [eax+20], ebp
$LN4@Med3_unche:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 6956 : }

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 12					; 0000000cH
	ret	0
??$_Med3_unchecked@PAULight@CROS_impl@@P6A_NABU12@0@Z@std@@YAXPAULight@CROS_impl@@00P6A_NABU12@1@Z@Z ENDP ; std::_Med3_unchecked<CROS_impl::Light *,bool (__cdecl*)(CROS_impl::Light const &,CROS_impl::Light const &)>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
;	COMDAT ??$swap@ULight@CROS_impl@@$0A@@std@@YAXAAULight@CROS_impl@@0@Z
_TEXT	SEGMENT
__Right$1$ = -8						; size = 4
__Tmp$6$ = -4						; size = 4
??$swap@ULight@CROS_impl@@$0A@@std@@YAXAAULight@CROS_impl@@0@Z PROC ; std::swap<CROS_impl::Light,0>, COMDAT
; __Left$ = ecx
; __Right$ = edx

; 99   :     is_nothrow_move_constructible_v<_Ty>&& is_nothrow_move_assignable_v<_Ty>) {

	sub	esp, 8

; 100  :     _Ty _Tmp = _STD move(_Left);

	mov	eax, DWORD PTR [ecx+20]
	mov	DWORD PTR __Tmp$6$[esp+8], eax
	push	ebx
	mov	ebx, DWORD PTR [ecx+12]
	mov	DWORD PTR __Right$1$[esp+12], edx
	mov	edx, DWORD PTR [ecx+8]

; 101  :     _Left    = _STD move(_Right);

	mov	eax, DWORD PTR __Right$1$[esp+12]
	push	ebp
	mov	ebp, DWORD PTR [ecx+16]
	push	esi
	mov	eax, DWORD PTR [eax]
	mov	esi, DWORD PTR [ecx]
	push	edi
	mov	edi, DWORD PTR [ecx+4]
	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR __Right$1$[esp+24]
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], eax
	mov	eax, DWORD PTR __Right$1$[esp+24]
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax
	mov	eax, DWORD PTR __Right$1$[esp+24]
	mov	eax, DWORD PTR [eax+12]
	mov	DWORD PTR [ecx+12], eax
	mov	eax, DWORD PTR __Right$1$[esp+24]
	mov	eax, DWORD PTR [eax+16]
	mov	DWORD PTR [ecx+16], eax
	mov	eax, DWORD PTR __Right$1$[esp+24]
	mov	eax, DWORD PTR [eax+20]
	mov	DWORD PTR [ecx+20], eax

; 102  :     _Right   = _STD move(_Tmp);

	mov	ecx, DWORD PTR __Right$1$[esp+24]
	mov	eax, DWORD PTR __Tmp$6$[esp+24]
	mov	DWORD PTR [ecx], esi
	mov	DWORD PTR [ecx+4], edi

; 103  : }

	pop	edi
	mov	DWORD PTR [ecx+8], edx
	mov	DWORD PTR [ecx+12], ebx
	pop	esi
	mov	DWORD PTR [ecx+16], ebp
	pop	ebp
	mov	DWORD PTR [ecx+20], eax
	pop	ebx
	add	esp, 8
	ret	0
??$swap@ULight@CROS_impl@@$0A@@std@@YAXAAULight@CROS_impl@@0@Z ENDP ; std::swap<CROS_impl::Light,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\type_traits
;	COMDAT ??$forward@AAPAULight@CROS_impl@@@std@@YAAAPAULight@CROS_impl@@AAPAU12@@Z
_TEXT	SEGMENT
??$forward@AAPAULight@CROS_impl@@@std@@YAAAPAULight@CROS_impl@@AAPAU12@@Z PROC ; std::forward<CROS_impl::Light * &>, COMDAT
; __Arg$ = ecx

; 1386 :     return static_cast<_Ty&&>(_Arg);

	mov	eax, ecx

; 1387 : }

	ret	0
??$forward@AAPAULight@CROS_impl@@@std@@YAAAPAULight@CROS_impl@@AAPAU12@@Z ENDP ; std::forward<CROS_impl::Light * &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrEngine\xr_collide_defs.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrEngine\xr_collide_defs.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrEngine\xr_collide_defs.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrEngine\xr_collide_defs.h
;	COMDAT ??0ray_cache@collide@@QAE@XZ
_TEXT	SEGMENT
??0ray_cache@collide@@QAE@XZ PROC			; collide::ray_cache::ray_cache, COMDAT
; _this$ = ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 23   : 	ICF	SelfRef	set(T _x, T _y, T _z)					{ x = _x;		y = _y;		z = _z;		return *this;	};

	mov	DWORD PTR [ecx], 0
; File I:\Vitalya\mine\NSProjectX\xrEngine\xr_collide_defs.h

; 39   : 		}

	mov	eax, ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 23   : 	ICF	SelfRef	set(T _x, T _y, T _z)					{ x = _x;		y = _y;		z = _z;		return *this;	};

	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0
	mov	DWORD PTR [ecx+12], 0
	mov	DWORD PTR [ecx+16], 0
	mov	DWORD PTR [ecx+20], 0
; File I:\Vitalya\mine\NSProjectX\xrEngine\xr_collide_defs.h

; 34   : 			range = 0;

	mov	DWORD PTR [ecx+24], 0

; 35   : 			result = FALSE;

	mov	DWORD PTR [ecx+28], 0
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 23   : 	ICF	SelfRef	set(T _x, T _y, T _z)					{ x = _x;		y = _y;		z = _z;		return *this;	};

	mov	DWORD PTR [ecx+32], 0
	mov	DWORD PTR [ecx+36], 0
	mov	DWORD PTR [ecx+40], 0
	mov	DWORD PTR [ecx+44], 0
	mov	DWORD PTR [ecx+48], 0
	mov	DWORD PTR [ecx+52], 0
	mov	DWORD PTR [ecx+56], 0
	mov	DWORD PTR [ecx+60], 0
	mov	DWORD PTR [ecx+64], 0
; File I:\Vitalya\mine\NSProjectX\xrEngine\xr_collide_defs.h

; 39   : 		}

	ret	0
??0ray_cache@collide@@QAE@XZ ENDP			; collide::ray_cache::ray_cache
_TEXT	ENDS
END
